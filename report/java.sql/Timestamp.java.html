<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Timestamp.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.sql</a> &gt; <span class="el_source">Timestamp.java</span></div><h1>Timestamp.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.sql;

import java.time.Instant;
import java.time.LocalDateTime;
import java.util.StringTokenizer;

/**
 * &lt;P&gt;A thin wrapper around &lt;code&gt;java.util.Date&lt;/code&gt; that allows
 * the JDBC API to identify this as an SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; value.
 * It adds the ability
 * to hold the SQL &lt;code&gt;TIMESTAMP&lt;/code&gt; fractional seconds value, by allowing
 * the specification of fractional seconds to a precision of nanoseconds.
 * A Timestamp also provides formatting and
 * parsing operations to support the JDBC escape syntax for timestamp values.
 *
 * &lt;p&gt;The precision of a Timestamp object is calculated to be either:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;code&gt;19 &lt;/code&gt;, which is the number of characters in yyyy-mm-dd hh:mm:ss
 * &lt;li&gt; &lt;code&gt; 20 + s &lt;/code&gt;, which is the number
 * of characters in the yyyy-mm-dd hh:mm:ss.[fff...] and &lt;code&gt;s&lt;/code&gt; represents  the scale of the given Timestamp,
 * its fractional seconds precision.
 *&lt;/ul&gt;
 *
 * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This type is a composite of a &lt;code&gt;java.util.Date&lt;/code&gt; and a
 * separate nanoseconds value. Only integral seconds are stored in the
 * &lt;code&gt;java.util.Date&lt;/code&gt; component. The fractional seconds - the nanos - are
 * separate.  The &lt;code&gt;Timestamp.equals(Object)&lt;/code&gt; method never returns
 * &lt;code&gt;true&lt;/code&gt; when passed an object
 * that isn't an instance of &lt;code&gt;java.sql.Timestamp&lt;/code&gt;,
 * because the nanos component of a date is unknown.
 * As a result, the &lt;code&gt;Timestamp.equals(Object)&lt;/code&gt;
 * method is not symmetric with respect to the
 * &lt;code&gt;java.util.Date.equals(Object)&lt;/code&gt;
 * method.  Also, the &lt;code&gt;hashCode&lt;/code&gt; method uses the underlying
 * &lt;code&gt;java.util.Date&lt;/code&gt;
 * implementation and therefore does not include nanos in its computation.
 * &lt;P&gt;
 * Due to the differences between the &lt;code&gt;Timestamp&lt;/code&gt; class
 * and the &lt;code&gt;java.util.Date&lt;/code&gt;
 * class mentioned above, it is recommended that code not view
 * &lt;code&gt;Timestamp&lt;/code&gt; values generically as an instance of
 * &lt;code&gt;java.util.Date&lt;/code&gt;.  The
 * inheritance relationship between &lt;code&gt;Timestamp&lt;/code&gt;
 * and &lt;code&gt;java.util.Date&lt;/code&gt; really
 * denotes implementation inheritance, and not type inheritance.
 */
public class Timestamp extends java.util.Date {

    /**
     * Constructs a &lt;code&gt;Timestamp&lt;/code&gt; object initialized
     * with the given values.
     *
     * @param year the year minus 1900
     * @param month 0 to 11
     * @param date 1 to 31
     * @param hour 0 to 23
     * @param minute 0 to 59
     * @param second 0 to 59
     * @param nano 0 to 999,999,999
     * @deprecated instead use the constructor &lt;code&gt;Timestamp(long millis)&lt;/code&gt;
     * @exception IllegalArgumentException if the nano argument is out of bounds
     */
    @Deprecated
    public Timestamp(int year, int month, int date,
                     int hour, int minute, int second, int nano) {
<span class="nc" id="L91">        super(year, month, date, hour, minute, second);</span>
<span class="nc bnc" id="L92" title="All 4 branches missed.">        if (nano &gt; 999999999 || nano &lt; 0) {</span>
<span class="nc" id="L93">            throw new IllegalArgumentException(&quot;nanos &gt; 999999999 or &lt; 0&quot;);</span>
        }
<span class="nc" id="L95">        nanos = nano;</span>
<span class="nc" id="L96">    }</span>

    /**
     * Constructs a &lt;code&gt;Timestamp&lt;/code&gt; object
     * using a milliseconds time value. The
     * integral seconds are stored in the underlying date value; the
     * fractional seconds are stored in the &lt;code&gt;nanos&lt;/code&gt; field of
     * the &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * @param time milliseconds since January 1, 1970, 00:00:00 GMT.
     *        A negative number is the number of milliseconds before
     *         January 1, 1970, 00:00:00 GMT.
     * @see java.util.Calendar
     */
    public Timestamp(long time) {
<span class="nc" id="L111">        super((time/1000)*1000);</span>
<span class="nc" id="L112">        nanos = (int)((time%1000) * 1000000);</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (nanos &lt; 0) {</span>
<span class="nc" id="L114">            nanos = 1000000000 + nanos;</span>
<span class="nc" id="L115">            super.setTime(((time/1000)-1)*1000);</span>
        }
<span class="nc" id="L117">    }</span>

    /**
     * Sets this &lt;code&gt;Timestamp&lt;/code&gt; object to represent a point in time that is
     * &lt;tt&gt;time&lt;/tt&gt; milliseconds after January 1, 1970 00:00:00 GMT.
     *
     * @param time   the number of milliseconds.
     * @see #getTime
     * @see #Timestamp(long time)
     * @see java.util.Calendar
     */
    public void setTime(long time) {
<span class="nc" id="L129">        super.setTime((time/1000)*1000);</span>
<span class="nc" id="L130">        nanos = (int)((time%1000) * 1000000);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (nanos &lt; 0) {</span>
<span class="nc" id="L132">            nanos = 1000000000 + nanos;</span>
<span class="nc" id="L133">            super.setTime(((time/1000)-1)*1000);</span>
        }
<span class="nc" id="L135">    }</span>

    /**
     * Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT
     * represented by this &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * @return  the number of milliseconds since January 1, 1970, 00:00:00 GMT
     *          represented by this date.
     * @see #setTime
     */
    public long getTime() {
<span class="nc" id="L146">        long time = super.getTime();</span>
<span class="nc" id="L147">        return (time + (nanos / 1000000));</span>
    }


    /**
     * @serial
     */
    private int nanos;

    /**
     * Converts a &lt;code&gt;String&lt;/code&gt; object in JDBC timestamp escape format to a
     * &lt;code&gt;Timestamp&lt;/code&gt; value.
     *
     * @param s timestamp in format &lt;code&gt;yyyy-[m]m-[d]d hh:mm:ss[.f...]&lt;/code&gt;.  The
     * fractional seconds may be omitted. The leading zero for &lt;code&gt;mm&lt;/code&gt;
     * and &lt;code&gt;dd&lt;/code&gt; may also be omitted.
     *
     * @return corresponding &lt;code&gt;Timestamp&lt;/code&gt; value
     * @exception java.lang.IllegalArgumentException if the given argument
     * does not have the format &lt;code&gt;yyyy-[m]m-[d]d hh:mm:ss[.f...]&lt;/code&gt;
     */
    public static Timestamp valueOf(String s) {
        final int YEAR_LENGTH = 4;
        final int MONTH_LENGTH = 2;
        final int DAY_LENGTH = 2;
        final int MAX_MONTH = 12;
        final int MAX_DAY = 31;
        String date_s;
        String time_s;
        String nanos_s;
<span class="nc" id="L177">        int year = 0;</span>
<span class="nc" id="L178">        int month = 0;</span>
<span class="nc" id="L179">        int day = 0;</span>
        int hour;
        int minute;
        int second;
<span class="nc" id="L183">        int a_nanos = 0;</span>
        int firstDash;
        int secondDash;
        int dividingSpace;
<span class="nc" id="L187">        int firstColon = 0;</span>
<span class="nc" id="L188">        int secondColon = 0;</span>
<span class="nc" id="L189">        int period = 0;</span>
<span class="nc" id="L190">        String formatError = &quot;Timestamp format must be yyyy-mm-dd hh:mm:ss[.fffffffff]&quot;;</span>
<span class="nc" id="L191">        String zeros = &quot;000000000&quot;;</span>
<span class="nc" id="L192">        String delimiterDate = &quot;-&quot;;</span>
<span class="nc" id="L193">        String delimiterTime = &quot;:&quot;;</span>

<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (s == null) throw new java.lang.IllegalArgumentException(&quot;null string&quot;);</span>

        // Split the string into date and time components
<span class="nc" id="L198">        s = s.trim();</span>
<span class="nc" id="L199">        dividingSpace = s.indexOf(' ');</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (dividingSpace &gt; 0) {</span>
<span class="nc" id="L201">            date_s = s.substring(0,dividingSpace);</span>
<span class="nc" id="L202">            time_s = s.substring(dividingSpace+1);</span>
        } else {
<span class="nc" id="L204">            throw new java.lang.IllegalArgumentException(formatError);</span>
        }

        // Parse the date
<span class="nc" id="L208">        firstDash = date_s.indexOf('-');</span>
<span class="nc" id="L209">        secondDash = date_s.indexOf('-', firstDash+1);</span>

        // Parse the time
<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (time_s == null)</span>
<span class="nc" id="L213">            throw new java.lang.IllegalArgumentException(formatError);</span>
<span class="nc" id="L214">        firstColon = time_s.indexOf(':');</span>
<span class="nc" id="L215">        secondColon = time_s.indexOf(':', firstColon+1);</span>
<span class="nc" id="L216">        period = time_s.indexOf('.', secondColon+1);</span>

        // Convert the date
<span class="nc" id="L219">        boolean parsedDate = false;</span>
<span class="nc bnc" id="L220" title="All 6 branches missed.">        if ((firstDash &gt; 0) &amp;&amp; (secondDash &gt; 0) &amp;&amp; (secondDash &lt; date_s.length() - 1)) {</span>
<span class="nc" id="L221">            String yyyy = date_s.substring(0, firstDash);</span>
<span class="nc" id="L222">            String mm = date_s.substring(firstDash + 1, secondDash);</span>
<span class="nc" id="L223">            String dd = date_s.substring(secondDash + 1);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">            if (yyyy.length() == YEAR_LENGTH &amp;&amp;</span>
<span class="nc bnc" id="L225" title="All 4 branches missed.">                    (mm.length() &gt;= 1 &amp;&amp; mm.length() &lt;= MONTH_LENGTH) &amp;&amp;</span>
<span class="nc bnc" id="L226" title="All 4 branches missed.">                    (dd.length() &gt;= 1 &amp;&amp; dd.length() &lt;= DAY_LENGTH)) {</span>
<span class="nc" id="L227">                 year = Integer.parseInt(yyyy);</span>
<span class="nc" id="L228">                 month = Integer.parseInt(mm);</span>
<span class="nc" id="L229">                 day = Integer.parseInt(dd);</span>

<span class="nc bnc" id="L231" title="All 8 branches missed.">                if ((month &gt;= 1 &amp;&amp; month &lt;= MAX_MONTH) &amp;&amp; (day &gt;= 1 &amp;&amp; day &lt;= MAX_DAY)) {</span>
<span class="nc" id="L232">                    parsedDate = true;</span>
                }
            }
        }
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (! parsedDate) {</span>
<span class="nc" id="L237">            throw new java.lang.IllegalArgumentException(formatError);</span>
        }

        // Convert the time; default missing nanos
<span class="nc bnc" id="L241" title="All 4 branches missed.">        if ((firstColon &gt; 0) &amp; (secondColon &gt; 0) &amp;</span>
<span class="nc bnc" id="L242" title="All 4 branches missed.">            (secondColon &lt; time_s.length()-1)) {</span>
<span class="nc" id="L243">            hour = Integer.parseInt(time_s.substring(0, firstColon));</span>
<span class="nc" id="L244">            minute =</span>
<span class="nc" id="L245">                Integer.parseInt(time_s.substring(firstColon+1, secondColon));</span>
<span class="nc bnc" id="L246" title="All 6 branches missed.">            if ((period &gt; 0) &amp; (period &lt; time_s.length()-1)) {</span>
<span class="nc" id="L247">                second =</span>
<span class="nc" id="L248">                    Integer.parseInt(time_s.substring(secondColon+1, period));</span>
<span class="nc" id="L249">                nanos_s = time_s.substring(period+1);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">                if (nanos_s.length() &gt; 9)</span>
<span class="nc" id="L251">                    throw new java.lang.IllegalArgumentException(formatError);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                if (!Character.isDigit(nanos_s.charAt(0)))</span>
<span class="nc" id="L253">                    throw new java.lang.IllegalArgumentException(formatError);</span>
<span class="nc" id="L254">                nanos_s = nanos_s + zeros.substring(0,9-nanos_s.length());</span>
<span class="nc" id="L255">                a_nanos = Integer.parseInt(nanos_s);</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            } else if (period &gt; 0) {</span>
<span class="nc" id="L257">                throw new java.lang.IllegalArgumentException(formatError);</span>
            } else {
<span class="nc" id="L259">                second = Integer.parseInt(time_s.substring(secondColon+1));</span>
            }
        } else {
<span class="nc" id="L262">            throw new java.lang.IllegalArgumentException(formatError);</span>
        }

<span class="nc" id="L265">        return new Timestamp(year - 1900, month - 1, day, hour, minute, second, a_nanos);</span>
    }

    /**
     * Formats a timestamp in JDBC timestamp escape format.
     *         &lt;code&gt;yyyy-mm-dd hh:mm:ss.fffffffff&lt;/code&gt;,
     * where &lt;code&gt;ffffffffff&lt;/code&gt; indicates nanoseconds.
     * &lt;P&gt;
     * @return a &lt;code&gt;String&lt;/code&gt; object in
     *           &lt;code&gt;yyyy-mm-dd hh:mm:ss.fffffffff&lt;/code&gt; format
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public String toString () {

<span class="nc" id="L279">        int year = super.getYear() + 1900;</span>
<span class="nc" id="L280">        int month = super.getMonth() + 1;</span>
<span class="nc" id="L281">        int day = super.getDate();</span>
<span class="nc" id="L282">        int hour = super.getHours();</span>
<span class="nc" id="L283">        int minute = super.getMinutes();</span>
<span class="nc" id="L284">        int second = super.getSeconds();</span>
        String yearString;
        String monthString;
        String dayString;
        String hourString;
        String minuteString;
        String secondString;
        String nanosString;
<span class="nc" id="L292">        String zeros = &quot;000000000&quot;;</span>
<span class="nc" id="L293">        String yearZeros = &quot;0000&quot;;</span>
        StringBuffer timestampBuf;

<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (year &lt; 1000) {</span>
            // Add leading zeros
<span class="nc" id="L298">            yearString = &quot;&quot; + year;</span>
<span class="nc" id="L299">            yearString = yearZeros.substring(0, (4-yearString.length())) +</span>
                yearString;
        } else {
<span class="nc" id="L302">            yearString = &quot;&quot; + year;</span>
        }
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (month &lt; 10) {</span>
<span class="nc" id="L305">            monthString = &quot;0&quot; + month;</span>
        } else {
<span class="nc" id="L307">            monthString = Integer.toString(month);</span>
        }
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (day &lt; 10) {</span>
<span class="nc" id="L310">            dayString = &quot;0&quot; + day;</span>
        } else {
<span class="nc" id="L312">            dayString = Integer.toString(day);</span>
        }
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (hour &lt; 10) {</span>
<span class="nc" id="L315">            hourString = &quot;0&quot; + hour;</span>
        } else {
<span class="nc" id="L317">            hourString = Integer.toString(hour);</span>
        }
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (minute &lt; 10) {</span>
<span class="nc" id="L320">            minuteString = &quot;0&quot; + minute;</span>
        } else {
<span class="nc" id="L322">            minuteString = Integer.toString(minute);</span>
        }
<span class="nc bnc" id="L324" title="All 2 branches missed.">        if (second &lt; 10) {</span>
<span class="nc" id="L325">            secondString = &quot;0&quot; + second;</span>
        } else {
<span class="nc" id="L327">            secondString = Integer.toString(second);</span>
        }
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (nanos == 0) {</span>
<span class="nc" id="L330">            nanosString = &quot;0&quot;;</span>
        } else {
<span class="nc" id="L332">            nanosString = Integer.toString(nanos);</span>

            // Add leading zeros
<span class="nc" id="L335">            nanosString = zeros.substring(0, (9-nanosString.length())) +</span>
                nanosString;

            // Truncate trailing zeros
<span class="nc" id="L339">            char[] nanosChar = new char[nanosString.length()];</span>
<span class="nc" id="L340">            nanosString.getChars(0, nanosString.length(), nanosChar, 0);</span>
<span class="nc" id="L341">            int truncIndex = 8;</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">            while (nanosChar[truncIndex] == '0') {</span>
<span class="nc" id="L343">                truncIndex--;</span>
            }

<span class="nc" id="L346">            nanosString = new String(nanosChar, 0, truncIndex + 1);</span>
        }

        // do a string buffer here instead.
<span class="nc" id="L350">        timestampBuf = new StringBuffer(20+nanosString.length());</span>
<span class="nc" id="L351">        timestampBuf.append(yearString);</span>
<span class="nc" id="L352">        timestampBuf.append(&quot;-&quot;);</span>
<span class="nc" id="L353">        timestampBuf.append(monthString);</span>
<span class="nc" id="L354">        timestampBuf.append(&quot;-&quot;);</span>
<span class="nc" id="L355">        timestampBuf.append(dayString);</span>
<span class="nc" id="L356">        timestampBuf.append(&quot; &quot;);</span>
<span class="nc" id="L357">        timestampBuf.append(hourString);</span>
<span class="nc" id="L358">        timestampBuf.append(&quot;:&quot;);</span>
<span class="nc" id="L359">        timestampBuf.append(minuteString);</span>
<span class="nc" id="L360">        timestampBuf.append(&quot;:&quot;);</span>
<span class="nc" id="L361">        timestampBuf.append(secondString);</span>
<span class="nc" id="L362">        timestampBuf.append(&quot;.&quot;);</span>
<span class="nc" id="L363">        timestampBuf.append(nanosString);</span>

<span class="nc" id="L365">        return (timestampBuf.toString());</span>
    }

    /**
     * Gets this &lt;code&gt;Timestamp&lt;/code&gt; object's &lt;code&gt;nanos&lt;/code&gt; value.
     *
     * @return this &lt;code&gt;Timestamp&lt;/code&gt; object's fractional seconds component
     * @see #setNanos
     */
    public int getNanos() {
<span class="nc" id="L375">        return nanos;</span>
    }

    /**
     * Sets this &lt;code&gt;Timestamp&lt;/code&gt; object's &lt;code&gt;nanos&lt;/code&gt; field
     * to the given value.
     *
     * @param n the new fractional seconds component
     * @exception java.lang.IllegalArgumentException if the given argument
     *            is greater than 999999999 or less than 0
     * @see #getNanos
     */
    public void setNanos(int n) {
<span class="nc bnc" id="L388" title="All 4 branches missed.">        if (n &gt; 999999999 || n &lt; 0) {</span>
<span class="nc" id="L389">            throw new IllegalArgumentException(&quot;nanos &gt; 999999999 or &lt; 0&quot;);</span>
        }
<span class="nc" id="L391">        nanos = n;</span>
<span class="nc" id="L392">    }</span>

    /**
     * Tests to see if this &lt;code&gt;Timestamp&lt;/code&gt; object is
     * equal to the given &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * @param ts the &lt;code&gt;Timestamp&lt;/code&gt; value to compare with
     * @return &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;Timestamp&lt;/code&gt;
     *         object is equal to this &lt;code&gt;Timestamp&lt;/code&gt; object;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public boolean equals(Timestamp ts) {
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (super.equals(ts)) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if  (nanos == ts.nanos) {</span>
<span class="nc" id="L406">                return true;</span>
            } else {
<span class="nc" id="L408">                return false;</span>
            }
        } else {
<span class="nc" id="L411">            return false;</span>
        }
    }

    /**
     * Tests to see if this &lt;code&gt;Timestamp&lt;/code&gt; object is
     * equal to the given object.
     *
     * This version of the method &lt;code&gt;equals&lt;/code&gt; has been added
     * to fix the incorrect
     * signature of &lt;code&gt;Timestamp.equals(Timestamp)&lt;/code&gt; and to preserve backward
     * compatibility with existing class files.
     *
     * Note: This method is not symmetric with respect to the
     * &lt;code&gt;equals(Object)&lt;/code&gt; method in the base class.
     *
     * @param ts the &lt;code&gt;Object&lt;/code&gt; value to compare with
     * @return &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;Object&lt;/code&gt; is an instance
     *         of a &lt;code&gt;Timestamp&lt;/code&gt; that
     *         is equal to this &lt;code&gt;Timestamp&lt;/code&gt; object;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public boolean equals(java.lang.Object ts) {
<span class="nc bnc" id="L434" title="All 2 branches missed.">      if (ts instanceof Timestamp) {</span>
<span class="nc" id="L435">        return this.equals((Timestamp)ts);</span>
      } else {
<span class="nc" id="L437">        return false;</span>
      }
    }

    /**
     * Indicates whether this &lt;code&gt;Timestamp&lt;/code&gt; object is
     * earlier than the given &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * @param ts the &lt;code&gt;Timestamp&lt;/code&gt; value to compare with
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Timestamp&lt;/code&gt; object is earlier;
     *        &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public boolean before(Timestamp ts) {
<span class="nc bnc" id="L450" title="All 2 branches missed.">        return compareTo(ts) &lt; 0;</span>
    }

    /**
     * Indicates whether this &lt;code&gt;Timestamp&lt;/code&gt; object is
     * later than the given &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * @param ts the &lt;code&gt;Timestamp&lt;/code&gt; value to compare with
     * @return &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;Timestamp&lt;/code&gt; object is later;
     *        &lt;code&gt;false&lt;/code&gt; otherwise
     */
    public boolean after(Timestamp ts) {
<span class="nc bnc" id="L462" title="All 2 branches missed.">        return compareTo(ts) &gt; 0;</span>
    }

    /**
     * Compares this &lt;code&gt;Timestamp&lt;/code&gt; object to the given
     * &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * @param   ts   the &lt;code&gt;Timestamp&lt;/code&gt; object to be compared to
     *                this &lt;code&gt;Timestamp&lt;/code&gt; object
     * @return  the value &lt;code&gt;0&lt;/code&gt; if the two &lt;code&gt;Timestamp&lt;/code&gt;
     *          objects are equal; a value less than &lt;code&gt;0&lt;/code&gt; if this
     *          &lt;code&gt;Timestamp&lt;/code&gt; object is before the given argument;
     *          and a value greater than &lt;code&gt;0&lt;/code&gt; if this
     *          &lt;code&gt;Timestamp&lt;/code&gt; object is after the given argument.
     * @since   1.4
     */
    public int compareTo(Timestamp ts) {
<span class="nc" id="L479">        long thisTime = this.getTime();</span>
<span class="nc" id="L480">        long anotherTime = ts.getTime();</span>
<span class="nc bnc" id="L481" title="All 4 branches missed.">        int i = (thisTime&lt;anotherTime ? -1 :(thisTime==anotherTime?0 :1));</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (i == 0) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">            if (nanos &gt; ts.nanos) {</span>
<span class="nc" id="L484">                    return 1;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            } else if (nanos &lt; ts.nanos) {</span>
<span class="nc" id="L486">                return -1;</span>
            }
        }
<span class="nc" id="L489">        return i;</span>
    }

    /**
     * Compares this &lt;code&gt;Timestamp&lt;/code&gt; object to the given
     * &lt;code&gt;Date&lt;/code&gt; object.
     *
     * @param o the &lt;code&gt;Date&lt;/code&gt; to be compared to
     *          this &lt;code&gt;Timestamp&lt;/code&gt; object
     * @return  the value &lt;code&gt;0&lt;/code&gt; if this &lt;code&gt;Timestamp&lt;/code&gt; object
     *          and the given object are equal; a value less than &lt;code&gt;0&lt;/code&gt;
     *          if this  &lt;code&gt;Timestamp&lt;/code&gt; object is before the given argument;
     *          and a value greater than &lt;code&gt;0&lt;/code&gt; if this
     *          &lt;code&gt;Timestamp&lt;/code&gt; object is after the given argument.
     *
     * @since   1.5
     */
    public int compareTo(java.util.Date o) {
<span class="nc bnc" id="L507" title="All 2 branches missed.">       if(o instanceof Timestamp) {</span>
            // When Timestamp instance compare it with a Timestamp
            // Hence it is basically calling this.compareTo((Timestamp))o);
            // Note typecasting is safe because o is instance of Timestamp
<span class="nc" id="L511">           return compareTo((Timestamp)o);</span>
      } else {
            // When Date doing a o.compareTo(this)
            // will give wrong results.
<span class="nc" id="L515">          Timestamp ts = new Timestamp(o.getTime());</span>
<span class="nc" id="L516">          return this.compareTo(ts);</span>
      }
    }

    /**
     * {@inheritDoc}
     *
     * The {@code hashCode} method uses the underlying {@code java.util.Date}
     * implementation and therefore does not include nanos in its computation.
     *
     */
    @Override
    public int hashCode() {
<span class="nc" id="L529">        return super.hashCode();</span>
    }

    static final long serialVersionUID = 2745179027874758501L;

    private static final int MILLIS_PER_SECOND = 1000;

    /**
     * Obtains an instance of {@code Timestamp} from a {@code LocalDateTime}
     * object, with the same year, month, day of month, hours, minutes,
     * seconds and nanos date-time value as the provided {@code LocalDateTime}.
     * &lt;p&gt;
     * The provided {@code LocalDateTime} is interpreted as the local
     * date-time in the local time zone.
     *
     * @param dateTime a {@code LocalDateTime} to convert
     * @return a {@code Timestamp} object
     * @exception NullPointerException if {@code dateTime} is null.
     * @since 1.8
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public static Timestamp valueOf(LocalDateTime dateTime) {
<span class="nc" id="L551">        return new Timestamp(dateTime.getYear() - 1900,</span>
<span class="nc" id="L552">                             dateTime.getMonthValue() - 1,</span>
<span class="nc" id="L553">                             dateTime.getDayOfMonth(),</span>
<span class="nc" id="L554">                             dateTime.getHour(),</span>
<span class="nc" id="L555">                             dateTime.getMinute(),</span>
<span class="nc" id="L556">                             dateTime.getSecond(),</span>
<span class="nc" id="L557">                             dateTime.getNano());</span>
    }

    /**
     * Converts this {@code Timestamp} object to a {@code LocalDateTime}.
     * &lt;p&gt;
     * The conversion creates a {@code LocalDateTime} that represents the
     * same year, month, day of month, hours, minutes, seconds and nanos
     * date-time value as this {@code Timestamp} in the local time zone.
     *
     * @return a {@code LocalDateTime} object representing the same date-time value
     * @since 1.8
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public LocalDateTime toLocalDateTime() {
<span class="nc" id="L572">        return LocalDateTime.of(getYear() + 1900,</span>
<span class="nc" id="L573">                                getMonth() + 1,</span>
<span class="nc" id="L574">                                getDate(),</span>
<span class="nc" id="L575">                                getHours(),</span>
<span class="nc" id="L576">                                getMinutes(),</span>
<span class="nc" id="L577">                                getSeconds(),</span>
<span class="nc" id="L578">                                getNanos());</span>
    }

    /**
     * Obtains an instance of {@code Timestamp} from an {@link Instant} object.
     * &lt;p&gt;
     * {@code Instant} can store points on the time-line further in the future
     * and further in the past than {@code Date}. In this scenario, this method
     * will throw an exception.
     *
     * @param instant  the instant to convert
     * @return an {@code Timestamp} representing the same point on the time-line as
     *  the provided instant
     * @exception NullPointerException if {@code instant} is null.
     * @exception IllegalArgumentException if the instant is too large to
     *  represent as a {@code Timesamp}
     * @since 1.8
     */
    public static Timestamp from(Instant instant) {
        try {
<span class="nc" id="L598">            Timestamp stamp = new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);</span>
<span class="nc" id="L599">            stamp.nanos = instant.getNano();</span>
<span class="nc" id="L600">            return stamp;</span>
<span class="nc" id="L601">        } catch (ArithmeticException ex) {</span>
<span class="nc" id="L602">            throw new IllegalArgumentException(ex);</span>
        }
    }

    /**
     * Converts this {@code Timestamp} object to an {@code Instant}.
     * &lt;p&gt;
     * The conversion creates an {@code Instant} that represents the same
     * point on the time-line as this {@code Timestamp}.
     *
     * @return an instant representing the same point on the time-line
     * @since 1.8
     */
    @Override
    public Instant toInstant() {
<span class="nc" id="L617">        return Instant.ofEpochSecond(super.getTime() / MILLIS_PER_SECOND, nanos);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>