<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DriverManager.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.sql</a> &gt; <span class="el_source">DriverManager.java</span></div><h1>DriverManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.sql;

import java.util.Iterator;
import java.util.ServiceLoader;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.concurrent.CopyOnWriteArrayList;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;


/**
 * &lt;P&gt;The basic service for managing a set of JDBC drivers.&lt;br&gt;
 * &lt;B&gt;NOTE:&lt;/B&gt; The {@link javax.sql.DataSource} interface, new in the
 * JDBC 2.0 API, provides another way to connect to a data source.
 * The use of a &lt;code&gt;DataSource&lt;/code&gt; object is the preferred means of
 * connecting to a data source.
 *
 * &lt;P&gt;As part of its initialization, the &lt;code&gt;DriverManager&lt;/code&gt; class will
 * attempt to load the driver classes referenced in the &quot;jdbc.drivers&quot;
 * system property. This allows a user to customize the JDBC Drivers
 * used by their applications. For example in your
 * ~/.hotjava/properties file you might specify:
 * &lt;pre&gt;
 * &lt;CODE&gt;jdbc.drivers=foo.bah.Driver:wombat.sql.Driver:bad.taste.ourDriver&lt;/CODE&gt;
 * &lt;/pre&gt;
 *&lt;P&gt; The &lt;code&gt;DriverManager&lt;/code&gt; methods &lt;code&gt;getConnection&lt;/code&gt; and
 * &lt;code&gt;getDrivers&lt;/code&gt; have been enhanced to support the Java Standard Edition
 * &lt;a href=&quot;../../../technotes/guides/jar/jar.html#Service%20Provider&quot;&gt;Service Provider&lt;/a&gt; mechanism. JDBC 4.0 Drivers must
 * include the file &lt;code&gt;META-INF/services/java.sql.Driver&lt;/code&gt;. This file contains the name of the JDBC drivers
 * implementation of &lt;code&gt;java.sql.Driver&lt;/code&gt;.  For example, to load the &lt;code&gt;my.sql.Driver&lt;/code&gt; class,
 * the &lt;code&gt;META-INF/services/java.sql.Driver&lt;/code&gt; file would contain the entry:
 * &lt;pre&gt;
 * &lt;code&gt;my.sql.Driver&lt;/code&gt;
 * &lt;/pre&gt;
 *
 * &lt;P&gt;Applications no longer need to explicitly load JDBC drivers using &lt;code&gt;Class.forName()&lt;/code&gt;. Existing programs
 * which currently load JDBC drivers using &lt;code&gt;Class.forName()&lt;/code&gt; will continue to work without
 * modification.
 *
 * &lt;P&gt;When the method &lt;code&gt;getConnection&lt;/code&gt; is called,
 * the &lt;code&gt;DriverManager&lt;/code&gt; will attempt to
 * locate a suitable driver from amongst those loaded at
 * initialization and those loaded explicitly using the same classloader
 * as the current applet or application.
 *
 * &lt;P&gt;
 * Starting with the Java 2 SDK, Standard Edition, version 1.3, a
 * logging stream can be set only if the proper
 * permission has been granted.  Normally this will be done with
 * the tool PolicyTool, which can be used to grant &lt;code&gt;permission
 * java.sql.SQLPermission &quot;setLog&quot;&lt;/code&gt;.
 * @see Driver
 * @see Connection
 */
public class DriverManager {


    // List of registered JDBC drivers
<span class="nc" id="L85">    private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="nc" id="L86">    private static volatile int loginTimeout = 0;</span>
<span class="nc" id="L87">    private static volatile java.io.PrintWriter logWriter = null;</span>
<span class="nc" id="L88">    private static volatile java.io.PrintStream logStream = null;</span>
    // Used in println() to synchronize logWriter
<span class="nc" id="L90">    private final static  Object logSync = new Object();</span>

    /* Prevent the DriverManager class from being instantiated. */
<span class="nc" id="L93">    private DriverManager(){}</span>


    /**
     * Load the initial JDBC drivers by checking the System property
     * jdbc.properties and then use the {@code ServiceLoader} mechanism
     */
    static {
<span class="nc" id="L101">        loadInitialDrivers();</span>
<span class="nc" id="L102">        println(&quot;JDBC DriverManager initialized&quot;);</span>
    }

    /**
     * The &lt;code&gt;SQLPermission&lt;/code&gt; constant that allows the
     * setting of the logging stream.
     * @since 1.3
     */
<span class="nc" id="L110">    final static SQLPermission SET_LOG_PERMISSION =</span>
        new SQLPermission(&quot;setLog&quot;);

    /**
     * The {@code SQLPermission} constant that allows the
     * un-register a registered JDBC driver.
     * @since 1.8
     */
<span class="nc" id="L118">    final static SQLPermission DEREGISTER_DRIVER_PERMISSION =</span>
        new SQLPermission(&quot;deregisterDriver&quot;);

    //--------------------------JDBC 2.0-----------------------------

    /**
     * Retrieves the log writer.
     *
     * The &lt;code&gt;getLogWriter&lt;/code&gt; and &lt;code&gt;setLogWriter&lt;/code&gt;
     * methods should be used instead
     * of the &lt;code&gt;get/setlogStream&lt;/code&gt; methods, which are deprecated.
     * @return a &lt;code&gt;java.io.PrintWriter&lt;/code&gt; object
     * @see #setLogWriter
     * @since 1.2
     */
    public static java.io.PrintWriter getLogWriter() {
<span class="nc" id="L134">            return logWriter;</span>
    }

    /**
     * Sets the logging/tracing &lt;code&gt;PrintWriter&lt;/code&gt; object
     * that is used by the &lt;code&gt;DriverManager&lt;/code&gt; and all drivers.
     * &lt;P&gt;
     * There is a minor versioning problem created by the introduction
     * of the method &lt;code&gt;setLogWriter&lt;/code&gt;.  The
     * method &lt;code&gt;setLogWriter&lt;/code&gt; cannot create a &lt;code&gt;PrintStream&lt;/code&gt; object
     * that will be returned by &lt;code&gt;getLogStream&lt;/code&gt;---the Java platform does
     * not provide a backward conversion.  As a result, a new application
     * that uses &lt;code&gt;setLogWriter&lt;/code&gt; and also uses a JDBC 1.0 driver that uses
     * &lt;code&gt;getLogStream&lt;/code&gt; will likely not see debugging information written
     * by that driver.
     *&lt;P&gt;
     * Starting with the Java 2 SDK, Standard Edition, version 1.3 release, this method checks
     * to see that there is an &lt;code&gt;SQLPermission&lt;/code&gt; object before setting
     * the logging stream.  If a &lt;code&gt;SecurityManager&lt;/code&gt; exists and its
     * &lt;code&gt;checkPermission&lt;/code&gt; method denies setting the log writer, this
     * method throws a &lt;code&gt;java.lang.SecurityException&lt;/code&gt;.
     *
     * @param out the new logging/tracing &lt;code&gt;PrintStream&lt;/code&gt; object;
     *      &lt;code&gt;null&lt;/code&gt; to disable logging and tracing
     * @throws SecurityException
     *    if a security manager exists and its
     *    &lt;code&gt;checkPermission&lt;/code&gt; method denies
     *    setting the log writer
     *
     * @see SecurityManager#checkPermission
     * @see #getLogWriter
     * @since 1.2
     */
    public static void setLogWriter(java.io.PrintWriter out) {

<span class="nc" id="L169">        SecurityManager sec = System.getSecurityManager();</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (sec != null) {</span>
<span class="nc" id="L171">            sec.checkPermission(SET_LOG_PERMISSION);</span>
        }
<span class="nc" id="L173">            logStream = null;</span>
<span class="nc" id="L174">            logWriter = out;</span>
<span class="nc" id="L175">    }</span>


    //---------------------------------------------------------------

    /**
     * Attempts to establish a connection to the given database URL.
     * The &lt;code&gt;DriverManager&lt;/code&gt; attempts to select an appropriate driver from
     * the set of registered JDBC drivers.
     *&lt;p&gt;
     * &lt;B&gt;Note:&lt;/B&gt; If a property is specified as part of the {@code url} and
     * is also specified in the {@code Properties} object, it is
     * implementation-defined as to which value will take precedence.
     * For maximum portability, an application should only specify a
     * property once.
     *
     * @param url a database url of the form
     * &lt;code&gt; jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
     * @param info a list of arbitrary string tag/value pairs as
     * connection arguments; normally at least a &quot;user&quot; and
     * &quot;password&quot; property should be included
     * @return a Connection to the URL
     * @exception SQLException if a database access error occurs or the url is
     * {@code null}
     * @throws SQLTimeoutException  when the driver has determined that the
     * timeout value specified by the {@code setLoginTimeout} method
     * has been exceeded and has at least tried to cancel the
     * current database connection attempt
     */
    @CallerSensitive
    public static Connection getConnection(String url,
        java.util.Properties info) throws SQLException {

<span class="nc" id="L208">        return (getConnection(url, info, Reflection.getCallerClass()));</span>
    }

    /**
     * Attempts to establish a connection to the given database URL.
     * The &lt;code&gt;DriverManager&lt;/code&gt; attempts to select an appropriate driver from
     * the set of registered JDBC drivers.
     *&lt;p&gt;
     * &lt;B&gt;Note:&lt;/B&gt; If a property is specified as part of the {@code url} and
     * is also specified in the {@code Properties} object, it is
     * implementation-defined as to which value will take precedence.
     * For maximum portability, an application should only specify a
     * property once.
     *
     * @param url a database url of the form
     * &lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
     * @param user the database user on whose behalf the connection is being
     *   made
     * @param password the user's password
     * @return a connection to the URL
     * @exception SQLException if a database access error occurs or the url is
     * {@code null}
     * @throws SQLTimeoutException  when the driver has determined that the
     * timeout value specified by the {@code setLoginTimeout} method
     * has been exceeded and has at least tried to cancel the
     * current database connection attempt
     */
    @CallerSensitive
    public static Connection getConnection(String url,
        String user, String password) throws SQLException {
<span class="nc" id="L238">        java.util.Properties info = new java.util.Properties();</span>

<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (user != null) {</span>
<span class="nc" id="L241">            info.put(&quot;user&quot;, user);</span>
        }
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (password != null) {</span>
<span class="nc" id="L244">            info.put(&quot;password&quot;, password);</span>
        }

<span class="nc" id="L247">        return (getConnection(url, info, Reflection.getCallerClass()));</span>
    }

    /**
     * Attempts to establish a connection to the given database URL.
     * The &lt;code&gt;DriverManager&lt;/code&gt; attempts to select an appropriate driver from
     * the set of registered JDBC drivers.
     *
     * @param url a database url of the form
     *  &lt;code&gt; jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
     * @return a connection to the URL
     * @exception SQLException if a database access error occurs or the url is
     * {@code null}
     * @throws SQLTimeoutException  when the driver has determined that the
     * timeout value specified by the {@code setLoginTimeout} method
     * has been exceeded and has at least tried to cancel the
     * current database connection attempt
     */
    @CallerSensitive
    public static Connection getConnection(String url)
        throws SQLException {

<span class="nc" id="L269">        java.util.Properties info = new java.util.Properties();</span>
<span class="nc" id="L270">        return (getConnection(url, info, Reflection.getCallerClass()));</span>
    }

    /**
     * Attempts to locate a driver that understands the given URL.
     * The &lt;code&gt;DriverManager&lt;/code&gt; attempts to select an appropriate driver from
     * the set of registered JDBC drivers.
     *
     * @param url a database URL of the form
     *     &lt;code&gt;jdbc:&lt;em&gt;subprotocol&lt;/em&gt;:&lt;em&gt;subname&lt;/em&gt;&lt;/code&gt;
     * @return a &lt;code&gt;Driver&lt;/code&gt; object representing a driver
     * that can connect to the given URL
     * @exception SQLException if a database access error occurs
     */
    @CallerSensitive
    public static Driver getDriver(String url)
        throws SQLException {

<span class="nc" id="L288">        println(&quot;DriverManager.getDriver(\&quot;&quot; + url + &quot;\&quot;)&quot;);</span>

<span class="nc" id="L290">        Class&lt;?&gt; callerClass = Reflection.getCallerClass();</span>

        // Walk through the loaded registeredDrivers attempting to locate someone
        // who understands the given URL.
<span class="nc bnc" id="L294" title="All 2 branches missed.">        for (DriverInfo aDriver : registeredDrivers) {</span>
            // If the caller does not have permission to load the driver then
            // skip it.
<span class="nc bnc" id="L297" title="All 2 branches missed.">            if(isDriverAllowed(aDriver.driver, callerClass)) {</span>
                try {
<span class="nc bnc" id="L299" title="All 2 branches missed.">                    if(aDriver.driver.acceptsURL(url)) {</span>
                        // Success!
<span class="nc" id="L301">                        println(&quot;getDriver returning &quot; + aDriver.driver.getClass().getName());</span>
<span class="nc" id="L302">                    return (aDriver.driver);</span>
                    }

<span class="nc" id="L305">                } catch(SQLException sqe) {</span>
                    // Drop through and try the next driver.
<span class="nc" id="L307">                }</span>
            } else {
<span class="nc" id="L309">                println(&quot;    skipping: &quot; + aDriver.driver.getClass().getName());</span>
            }

<span class="nc" id="L312">        }</span>

<span class="nc" id="L314">        println(&quot;getDriver: no suitable driver&quot;);</span>
<span class="nc" id="L315">        throw new SQLException(&quot;No suitable driver&quot;, &quot;08001&quot;);</span>
    }


    /**
     * Registers the given driver with the {@code DriverManager}.
     * A newly-loaded driver class should call
     * the method {@code registerDriver} to make itself
     * known to the {@code DriverManager}. If the driver had previously been
     * registered, no action is taken.
     *
     * @param driver the new JDBC Driver that is to be registered with the
     *               {@code DriverManager}
     * @exception SQLException if a database access error occurs
     * @exception NullPointerException if {@code driver} is null
     */
    public static synchronized void registerDriver(java.sql.Driver driver)
        throws SQLException {

<span class="nc" id="L334">        registerDriver(driver, null);</span>
<span class="nc" id="L335">    }</span>

    /**
     * Registers the given driver with the {@code DriverManager}.
     * A newly-loaded driver class should call
     * the method {@code registerDriver} to make itself
     * known to the {@code DriverManager}. If the driver had previously been
     * registered, no action is taken.
     *
     * @param driver the new JDBC Driver that is to be registered with the
     *               {@code DriverManager}
     * @param da     the {@code DriverAction} implementation to be used when
     *               {@code DriverManager#deregisterDriver} is called
     * @exception SQLException if a database access error occurs
     * @exception NullPointerException if {@code driver} is null
     */
    public static synchronized void registerDriver(java.sql.Driver driver,
            DriverAction da)
        throws SQLException {

        /* Register the driver if it has not already been added to our list */
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if(driver != null) {</span>
<span class="nc" id="L357">            registeredDrivers.addIfAbsent(new DriverInfo(driver, da));</span>
        } else {
            // This is for compatibility with the original DriverManager
<span class="nc" id="L360">            throw new NullPointerException();</span>
        }

<span class="nc" id="L363">        println(&quot;registerDriver: &quot; + driver);</span>

<span class="nc" id="L365">    }</span>

    /**
     * Removes the specified driver from the {@code DriverManager}'s list of
     * registered drivers.
     * &lt;p&gt;
     * If a {@code null} value is specified for the driver to be removed, then no
     * action is taken.
     * &lt;p&gt;
     * If a security manager exists and its {@code checkPermission} denies
     * permission, then a {@code SecurityException} will be thrown.
     * &lt;p&gt;
     * If the specified driver is not found in the list of registered drivers,
     * then no action is taken.  If the driver was found, it will be removed
     * from the list of registered drivers.
     * &lt;p&gt;
     * If a {@code DriverAction} instance was specified when the JDBC driver was
     * registered, its deregister method will be called
     * prior to the driver being removed from the list of registered drivers.
     *
     * @param driver the JDBC Driver to remove
     * @exception SQLException if a database access error occurs
     * @throws SecurityException if a security manager exists and its
     * {@code checkPermission} method denies permission to deregister a driver.
     *
     * @see SecurityManager#checkPermission
     */
    @CallerSensitive
    public static synchronized void deregisterDriver(Driver driver)
        throws SQLException {
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (driver == null) {</span>
<span class="nc" id="L396">            return;</span>
        }

<span class="nc" id="L399">        SecurityManager sec = System.getSecurityManager();</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (sec != null) {</span>
<span class="nc" id="L401">            sec.checkPermission(DEREGISTER_DRIVER_PERMISSION);</span>
        }

<span class="nc" id="L404">        println(&quot;DriverManager.deregisterDriver: &quot; + driver);</span>

<span class="nc" id="L406">        DriverInfo aDriver = new DriverInfo(driver, null);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if(registeredDrivers.contains(aDriver)) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if (isDriverAllowed(driver, Reflection.getCallerClass())) {</span>
<span class="nc" id="L409">                DriverInfo di = registeredDrivers.get(registeredDrivers.indexOf(aDriver));</span>
                 // If a DriverAction was specified, Call it to notify the
                 // driver that it has been deregistered
<span class="nc bnc" id="L412" title="All 2 branches missed.">                 if(di.action() != null) {</span>
<span class="nc" id="L413">                     di.action().deregister();</span>
                 }
<span class="nc" id="L415">                 registeredDrivers.remove(aDriver);</span>
<span class="nc" id="L416">            } else {</span>
                // If the caller does not have permission to load the driver then
                // throw a SecurityException.
<span class="nc" id="L419">                throw new SecurityException();</span>
            }
        } else {
<span class="nc" id="L422">            println(&quot;    couldn't find driver to unload&quot;);</span>
        }
<span class="nc" id="L424">    }</span>

    /**
     * Retrieves an Enumeration with all of the currently loaded JDBC drivers
     * to which the current caller has access.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; The classname of a driver can be found using
     * &lt;CODE&gt;d.getClass().getName()&lt;/CODE&gt;
     *
     * @return the list of JDBC Drivers loaded by the caller's class loader
     */
    @CallerSensitive
    public static java.util.Enumeration&lt;Driver&gt; getDrivers() {
<span class="nc" id="L437">        java.util.Vector&lt;Driver&gt; result = new java.util.Vector&lt;&gt;();</span>

<span class="nc" id="L439">        Class&lt;?&gt; callerClass = Reflection.getCallerClass();</span>

        // Walk through the loaded registeredDrivers.
<span class="nc bnc" id="L442" title="All 2 branches missed.">        for(DriverInfo aDriver : registeredDrivers) {</span>
            // If the caller does not have permission to load the driver then
            // skip it.
<span class="nc bnc" id="L445" title="All 2 branches missed.">            if(isDriverAllowed(aDriver.driver, callerClass)) {</span>
<span class="nc" id="L446">                result.addElement(aDriver.driver);</span>
            } else {
<span class="nc" id="L448">                println(&quot;    skipping: &quot; + aDriver.getClass().getName());</span>
            }
<span class="nc" id="L450">        }</span>
<span class="nc" id="L451">        return (result.elements());</span>
    }


    /**
     * Sets the maximum time in seconds that a driver will wait
     * while attempting to connect to a database once the driver has
     * been identified.
     *
     * @param seconds the login time limit in seconds; zero means there is no limit
     * @see #getLoginTimeout
     */
    public static void setLoginTimeout(int seconds) {
<span class="nc" id="L464">        loginTimeout = seconds;</span>
<span class="nc" id="L465">    }</span>

    /**
     * Gets the maximum time in seconds that a driver can wait
     * when attempting to log in to a database.
     *
     * @return the driver login time limit in seconds
     * @see #setLoginTimeout
     */
    public static int getLoginTimeout() {
<span class="nc" id="L475">        return (loginTimeout);</span>
    }

    /**
     * Sets the logging/tracing PrintStream that is used
     * by the &lt;code&gt;DriverManager&lt;/code&gt;
     * and all drivers.
     *&lt;P&gt;
     * In the Java 2 SDK, Standard Edition, version 1.3 release, this method checks
     * to see that there is an &lt;code&gt;SQLPermission&lt;/code&gt; object before setting
     * the logging stream.  If a &lt;code&gt;SecurityManager&lt;/code&gt; exists and its
     * &lt;code&gt;checkPermission&lt;/code&gt; method denies setting the log writer, this
     * method throws a &lt;code&gt;java.lang.SecurityException&lt;/code&gt;.
     *
     * @param out the new logging/tracing PrintStream; to disable, set to &lt;code&gt;null&lt;/code&gt;
     * @deprecated Use {@code setLogWriter}
     * @throws SecurityException if a security manager exists and its
     *    &lt;code&gt;checkPermission&lt;/code&gt; method denies setting the log stream
     *
     * @see SecurityManager#checkPermission
     * @see #getLogStream
     */
    @Deprecated
    public static void setLogStream(java.io.PrintStream out) {

<span class="nc" id="L500">        SecurityManager sec = System.getSecurityManager();</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (sec != null) {</span>
<span class="nc" id="L502">            sec.checkPermission(SET_LOG_PERMISSION);</span>
        }

<span class="nc" id="L505">        logStream = out;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if ( out != null )</span>
<span class="nc" id="L507">            logWriter = new java.io.PrintWriter(out);</span>
        else
<span class="nc" id="L509">            logWriter = null;</span>
<span class="nc" id="L510">    }</span>

    /**
     * Retrieves the logging/tracing PrintStream that is used by the &lt;code&gt;DriverManager&lt;/code&gt;
     * and all drivers.
     *
     * @return the logging/tracing PrintStream; if disabled, is &lt;code&gt;null&lt;/code&gt;
     * @deprecated  Use {@code getLogWriter}
     * @see #setLogStream
     */
    @Deprecated
    public static java.io.PrintStream getLogStream() {
<span class="nc" id="L522">        return logStream;</span>
    }

    /**
     * Prints a message to the current JDBC log stream.
     *
     * @param message a log or tracing message
     */
    public static void println(String message) {
<span class="nc" id="L531">        synchronized (logSync) {</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">            if (logWriter != null) {</span>
<span class="nc" id="L533">                logWriter.println(message);</span>

                // automatic flushing is never enabled, so we must do it ourselves
<span class="nc" id="L536">                logWriter.flush();</span>
            }
<span class="nc" id="L538">        }</span>
<span class="nc" id="L539">    }</span>

    //------------------------------------------------------------------------

    // Indicates whether the class object that would be created if the code calling
    // DriverManager is accessible.
    private static boolean isDriverAllowed(Driver driver, Class&lt;?&gt; caller) {
<span class="nc bnc" id="L546" title="All 2 branches missed.">        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;</span>
<span class="nc" id="L547">        return isDriverAllowed(driver, callerCL);</span>
    }

    private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) {
<span class="nc" id="L551">        boolean result = false;</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if(driver != null) {</span>
<span class="nc" id="L553">            Class&lt;?&gt; aClass = null;</span>
            try {
<span class="nc" id="L555">                aClass =  Class.forName(driver.getClass().getName(), true, classLoader);</span>
<span class="nc" id="L556">            } catch (Exception ex) {</span>
<span class="nc" id="L557">                result = false;</span>
<span class="nc" id="L558">            }</span>

<span class="nc bnc" id="L560" title="All 2 branches missed.">             result = ( aClass == driver.getClass() ) ? true : false;</span>
        }

<span class="nc" id="L563">        return result;</span>
    }

    private static void loadInitialDrivers() {
        String drivers;
        try {
<span class="nc" id="L569">            drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {</span>
                public String run() {
<span class="nc" id="L571">                    return System.getProperty(&quot;jdbc.drivers&quot;);</span>
                }
            });
<span class="nc" id="L574">        } catch (Exception ex) {</span>
<span class="nc" id="L575">            drivers = null;</span>
<span class="nc" id="L576">        }</span>
        // If the driver is packaged as a Service Provider, load it.
        // Get all the drivers through the classloader
        // exposed as a java.sql.Driver.class service.
        // ServiceLoader.load() replaces the sun.misc.Providers()

<span class="nc" id="L582">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
            public Void run() {

<span class="nc" id="L585">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span>
<span class="nc" id="L586">                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span>

                /* Load these drivers, so that they can be instantiated.
                 * It may be the case that the driver class may not be there
                 * i.e. there may be a packaged driver with the service class
                 * as implementation of java.sql.Driver but the actual class
                 * may be missing. In that case a java.util.ServiceConfigurationError
                 * will be thrown at runtime by the VM trying to locate
                 * and load the service.
                 *
                 * Adding a try catch block to catch those runtime errors
                 * if driver not available in classpath but it's
                 * packaged as service and that service is there in classpath.
                 */
                try{
<span class="nc bnc" id="L601" title="All 2 branches missed.">                    while(driversIterator.hasNext()) {</span>
<span class="nc" id="L602">                        driversIterator.next();</span>
                    }
<span class="nc" id="L604">                } catch(Throwable t) {</span>
                // Do nothing
<span class="nc" id="L606">                }</span>
<span class="nc" id="L607">                return null;</span>
            }
        });

<span class="nc" id="L611">        println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers);</span>

<span class="nc bnc" id="L613" title="All 4 branches missed.">        if (drivers == null || drivers.equals(&quot;&quot;)) {</span>
<span class="nc" id="L614">            return;</span>
        }
<span class="nc" id="L616">        String[] driversList = drivers.split(&quot;:&quot;);</span>
<span class="nc" id="L617">        println(&quot;number of Drivers:&quot; + driversList.length);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">        for (String aDriver : driversList) {</span>
            try {
<span class="nc" id="L620">                println(&quot;DriverManager.Initialize: loading &quot; + aDriver);</span>
<span class="nc" id="L621">                Class.forName(aDriver, true,</span>
<span class="nc" id="L622">                        ClassLoader.getSystemClassLoader());</span>
<span class="nc" id="L623">            } catch (Exception ex) {</span>
<span class="nc" id="L624">                println(&quot;DriverManager.Initialize: load failed: &quot; + ex);</span>
<span class="nc" id="L625">            }</span>
        }
<span class="nc" id="L627">    }</span>


    //  Worker method called by the public getConnection() methods.
    private static Connection getConnection(
        String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException {
        /*
         * When callerCl is null, we should check the application's
         * (which is invoking this class indirectly)
         * classloader, so that the JDBC driver class outside rt.jar
         * can be loaded from here.
         */
<span class="nc bnc" id="L639" title="All 2 branches missed.">        ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;</span>
<span class="nc" id="L640">        synchronized(DriverManager.class) {</span>
            // synchronize loading of the correct classloader.
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (callerCL == null) {</span>
<span class="nc" id="L643">                callerCL = Thread.currentThread().getContextClassLoader();</span>
            }
<span class="nc" id="L645">        }</span>

<span class="nc bnc" id="L647" title="All 2 branches missed.">        if(url == null) {</span>
<span class="nc" id="L648">            throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;);</span>
        }

<span class="nc" id="L651">        println(&quot;DriverManager.getConnection(\&quot;&quot; + url + &quot;\&quot;)&quot;);</span>

        // Walk through the loaded registeredDrivers attempting to make a connection.
        // Remember the first exception that gets raised so we can reraise it.
<span class="nc" id="L655">        SQLException reason = null;</span>

<span class="nc bnc" id="L657" title="All 2 branches missed.">        for(DriverInfo aDriver : registeredDrivers) {</span>
            // If the caller does not have permission to load the driver then
            // skip it.
<span class="nc bnc" id="L660" title="All 2 branches missed.">            if(isDriverAllowed(aDriver.driver, callerCL)) {</span>
                try {
<span class="nc" id="L662">                    println(&quot;    trying &quot; + aDriver.driver.getClass().getName());</span>
<span class="nc" id="L663">                    Connection con = aDriver.driver.connect(url, info);</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">                    if (con != null) {</span>
                        // Success!
<span class="nc" id="L666">                        println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName());</span>
<span class="nc" id="L667">                        return (con);</span>
                    }
<span class="nc" id="L669">                } catch (SQLException ex) {</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">                    if (reason == null) {</span>
<span class="nc" id="L671">                        reason = ex;</span>
                    }
<span class="nc" id="L673">                }</span>

            } else {
<span class="nc" id="L676">                println(&quot;    skipping: &quot; + aDriver.getClass().getName());</span>
            }

<span class="nc" id="L679">        }</span>

        // if we got here nobody could connect.
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (reason != null)    {</span>
<span class="nc" id="L683">            println(&quot;getConnection failed: &quot; + reason);</span>
<span class="nc" id="L684">            throw reason;</span>
        }

<span class="nc" id="L687">        println(&quot;getConnection: no suitable driver found for &quot;+ url);</span>
<span class="nc" id="L688">        throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;);</span>
    }


}

/*
 * Wrapper class for registered Drivers in order to not expose Driver.equals()
 * to avoid the capture of the Driver it being compared to as it might not
 * normally have access.
 */
class DriverInfo {

    final Driver driver;
    DriverAction da;
<span class="nc" id="L703">    DriverInfo(Driver driver, DriverAction action) {</span>
<span class="nc" id="L704">        this.driver = driver;</span>
<span class="nc" id="L705">        da = action;</span>
<span class="nc" id="L706">    }</span>

    @Override
    public boolean equals(Object other) {
<span class="nc bnc" id="L710" title="All 4 branches missed.">        return (other instanceof DriverInfo)</span>
                &amp;&amp; this.driver == ((DriverInfo) other).driver;
    }

    @Override
    public int hashCode() {
<span class="nc" id="L716">        return driver.hashCode();</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L721">        return (&quot;driver[className=&quot;  + driver + &quot;]&quot;);</span>
    }

    DriverAction action() {
<span class="nc" id="L725">        return da;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>