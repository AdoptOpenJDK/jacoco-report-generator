<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Reference.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang.ref</a> &gt; <span class="el_source">Reference.java</span></div><h1>Reference.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.ref;

import sun.misc.Cleaner;

/**
 * Abstract base class for reference objects.  This class defines the
 * operations common to all reference objects.  Because reference objects are
 * implemented in close cooperation with the garbage collector, this class may
 * not be subclassed directly.
 *
 * @author   Mark Reinhold
 * @since    1.2
 */

public abstract class Reference&lt;T&gt; {

    /* A Reference instance is in one of four possible internal states:
     *
     *     Active: Subject to special treatment by the garbage collector.  Some
     *     time after the collector detects that the reachability of the
     *     referent has changed to the appropriate state, it changes the
     *     instance's state to either Pending or Inactive, depending upon
     *     whether or not the instance was registered with a queue when it was
     *     created.  In the former case it also adds the instance to the
     *     pending-Reference list.  Newly-created instances are Active.
     *
     *     Pending: An element of the pending-Reference list, waiting to be
     *     enqueued by the Reference-handler thread.  Unregistered instances
     *     are never in this state.
     *
     *     Enqueued: An element of the queue with which the instance was
     *     registered when it was created.  When an instance is removed from
     *     its ReferenceQueue, it is made Inactive.  Unregistered instances are
     *     never in this state.
     *
     *     Inactive: Nothing more to do.  Once an instance becomes Inactive its
     *     state will never change again.
     *
     * The state is encoded in the queue and next fields as follows:
     *
     *     Active: queue = ReferenceQueue with which instance is registered, or
     *     ReferenceQueue.NULL if it was not registered with a queue; next =
     *     null.
     *
     *     Pending: queue = ReferenceQueue with which instance is registered;
     *     next = this
     *
     *     Enqueued: queue = ReferenceQueue.ENQUEUED; next = Following instance
     *     in queue, or this if at end of list.
     *
     *     Inactive: queue = ReferenceQueue.NULL; next = this.
     *
     * With this scheme the collector need only examine the next field in order
     * to determine whether a Reference instance requires special treatment: If
     * the next field is null then the instance is active; if it is non-null,
     * then the collector should treat the instance normally.
     *
     * To ensure that a concurrent collector can discover active Reference
     * objects without interfering with application threads that may apply
     * the enqueue() method to those objects, collectors should link
     * discovered objects through the discovered field. The discovered
     * field is also used for linking Reference objects in the pending list.
     */

    private T referent;         /* Treated specially by GC */

    volatile ReferenceQueue&lt;? super T&gt; queue;

    /* When active:   NULL
     *     pending:   this
     *    Enqueued:   next reference in queue (or this if last)
     *    Inactive:   this
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    Reference next;

    /* When active:   next element in a discovered reference list maintained by GC (or this if last)
     *     pending:   next element in the pending list (or null if last)
     *   otherwise:   NULL
     */
    transient private Reference&lt;T&gt; discovered;  /* used by VM */


    /* Object used to synchronize with the garbage collector.  The collector
     * must acquire this lock at the beginning of each collection cycle.  It is
     * therefore critical that any code holding this lock complete as quickly
     * as possible, allocate no new objects, and avoid calling user code.
     */
<span class="fc" id="L114">    static private class Lock { };</span>
<span class="fc" id="L115">    private static Lock lock = new Lock();</span>


    /* List of References waiting to be enqueued.  The collector adds
     * References to this list, while the Reference-handler thread removes
     * them.  This list is protected by the above lock object. The
     * list uses the discovered field to link its elements.
     */
<span class="fc" id="L123">    private static Reference&lt;Object&gt; pending = null;</span>

    /* High-priority thread to enqueue pending References
     */
    private static class ReferenceHandler extends Thread {

        ReferenceHandler(ThreadGroup g, String name) {
<span class="fc" id="L130">            super(g, name);</span>
<span class="fc" id="L131">        }</span>

        public void run() {
            for (;;) {
                Reference&lt;Object&gt; r;
<span class="fc" id="L136">                synchronized (lock) {</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">                    if (pending != null) {</span>
<span class="fc" id="L138">                        r = pending;</span>
<span class="fc" id="L139">                        pending = r.discovered;</span>
<span class="fc" id="L140">                        r.discovered = null;</span>
                    } else {
                        // The waiting on the lock may cause an OOME because it may try to allocate
                        // exception objects, so also catch OOME here to avoid silent exit of the
                        // reference handler thread.
                        //
                        // Explicitly define the order of the two exceptions we catch here
                        // when waiting for the lock.
                        //
                        // We do not want to try to potentially load the InterruptedException class
                        // (which would be done if this was its first use, and InterruptedException
                        // were checked first) in this situation.
                        //
                        // This may lead to the VM not ever trying to load the InterruptedException
                        // class again.
                        try {
                            try {
<span class="fc" id="L157">                                lock.wait();</span>
<span class="fc" id="L158">                            } catch (OutOfMemoryError x) { }</span>
<span class="pc" id="L159">                        } catch (InterruptedException x) { }</span>
<span class="fc" id="L160">                        continue;</span>
                    }
<span class="pc" id="L162">                }</span>

                // Fast path for cleaners
<span class="fc bfc" id="L165" title="All 2 branches covered.">                if (r instanceof Cleaner) {</span>
<span class="fc" id="L166">                    ((Cleaner)r).clean();</span>
<span class="fc" id="L167">                    continue;</span>
                }

<span class="fc" id="L170">                ReferenceQueue&lt;Object&gt; q = r.queue;</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">                if (q != ReferenceQueue.NULL) q.enqueue(r);</span>
<span class="fc" id="L172">            }</span>
        }
    }

    static {
<span class="fc" id="L177">        ThreadGroup tg = Thread.currentThread().getThreadGroup();</span>
<span class="fc" id="L178">        for (ThreadGroup tgn = tg;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">             tgn != null;</span>
<span class="fc" id="L180">             tg = tgn, tgn = tg.getParent());</span>
<span class="fc" id="L181">        Thread handler = new ReferenceHandler(tg, &quot;Reference Handler&quot;);</span>
        /* If there were a special system-only priority greater than
         * MAX_PRIORITY, it would be used here
         */
<span class="fc" id="L185">        handler.setPriority(Thread.MAX_PRIORITY);</span>
<span class="fc" id="L186">        handler.setDaemon(true);</span>
<span class="fc" id="L187">        handler.start();</span>
<span class="fc" id="L188">    }</span>


    /* -- Referent accessor and setters -- */

    /**
     * Returns this reference object's referent.  If this reference object has
     * been cleared, either by the program or by the garbage collector, then
     * this method returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return   The object to which this reference refers, or
     *           &lt;code&gt;null&lt;/code&gt; if this reference object has been cleared
     */
    public T get() {
<span class="fc" id="L202">        return this.referent;</span>
    }

    /**
     * Clears this reference object.  Invoking this method will not cause this
     * object to be enqueued.
     *
     * &lt;p&gt; This method is invoked only by Java code; when the garbage collector
     * clears references it does so directly, without invoking this method.
     */
    public void clear() {
<span class="fc" id="L213">        this.referent = null;</span>
<span class="fc" id="L214">    }</span>


    /* -- Queue operations -- */

    /**
     * Tells whether or not this reference object has been enqueued, either by
     * the program or by the garbage collector.  If this reference object was
     * not registered with a queue when it was created, then this method will
     * always return &lt;code&gt;false&lt;/code&gt;.
     *
     * @return   &lt;code&gt;true&lt;/code&gt; if and only if this reference object has
     *           been enqueued
     */
    public boolean isEnqueued() {
<span class="fc bfc" id="L229" title="All 2 branches covered.">        return (this.queue == ReferenceQueue.ENQUEUED);</span>
    }

    /**
     * Adds this reference object to the queue with which it is registered,
     * if any.
     *
     * &lt;p&gt; This method is invoked only by Java code; when the garbage collector
     * enqueues references it does so directly, without invoking this method.
     *
     * @return   &lt;code&gt;true&lt;/code&gt; if this reference object was successfully
     *           enqueued; &lt;code&gt;false&lt;/code&gt; if it was already enqueued or if
     *           it was not registered with a queue when it was created
     */
    public boolean enqueue() {
<span class="fc" id="L244">        return this.queue.enqueue(this);</span>
    }


    /* -- Constructors -- */

    Reference(T referent) {
<span class="fc" id="L251">        this(referent, null);</span>
<span class="fc" id="L252">    }</span>

<span class="fc" id="L254">    Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) {</span>
<span class="fc" id="L255">        this.referent = referent;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        this.queue = (queue == null) ? ReferenceQueue.NULL : queue;</span>
<span class="fc" id="L257">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>