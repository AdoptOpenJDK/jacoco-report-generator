<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LValue.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.tools.example.debug.expr</a> &gt; <span class="el_source">LValue.java</span></div><h1>LValue.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This source code is provided to illustrate the usage of a given feature
 * or technique and has been deliberately simplified. Additional steps
 * required for a production-quality application, such as security checks,
 * input validation and proper error handling, might not be present in
 * this sample code.
 */


package com.sun.tools.example.debug.expr;

import com.sun.jdi.*;
import java.util.*;

<span class="nc" id="L40">abstract class LValue {</span>

    // The JDI Value object for this LValue.  Once we have this Value,
    // we have to remember it since after we return the LValue object
    // to the ExpressionParser, it might decide that it needs
    // the 'toString' value for the LValue in which case it will
    // call getMassagedValue to get this toString value.  At that
    // point, we don't want to call JDI a 2nd time to get the Value
    // for the LValue.  This is especially wrong when the LValue
    // represents a member function.  We would end up calling it
    // a 2nd time.
    //
    // Unfortunately, there are several levels of calls to
    // get/set values in this file.  To minimize confusion,
    // jdiValue is set/tested at the lowest level - right
    // next to the actual calls to JDI methods to get/set the
    // value in the debuggee.
    protected Value jdiValue;

    abstract Value getValue() throws InvocationException,
                                     IncompatibleThreadStateException,
                                     InvalidTypeException,
                                     ClassNotLoadedException,
                                     ParseException;

    abstract void setValue0(Value value)
                   throws ParseException, InvalidTypeException,
                          ClassNotLoadedException;

    abstract void invokeWith(List&lt;Value&gt; arguments) throws ParseException;

    void setValue(Value value) throws ParseException {
        try {
<span class="nc" id="L73">            setValue0(value);</span>
<span class="nc" id="L74">        } catch (InvalidTypeException exc) {</span>
<span class="nc" id="L75">            throw new ParseException(</span>
                &quot;Attempt to set value of incorrect type&quot; +
                exc);
<span class="nc" id="L78">        } catch (ClassNotLoadedException exc) {</span>
<span class="nc" id="L79">            throw new ParseException(</span>
<span class="nc" id="L80">                &quot;Attempt to set value before &quot; + exc.className() + &quot; was loaded&quot; +</span>
                exc);
<span class="nc" id="L82">        }</span>
<span class="nc" id="L83">    }</span>

    void setValue(LValue lval) throws ParseException {
<span class="nc" id="L86">        setValue(lval.interiorGetValue());</span>
<span class="nc" id="L87">    }</span>

    LValue memberLValue(ExpressionParser.GetFrame frameGetter,
                        String fieldName) throws ParseException {
        try {
<span class="nc" id="L92">            return memberLValue(fieldName, frameGetter.get().thread());</span>
<span class="nc" id="L93">        } catch (IncompatibleThreadStateException exc) {</span>
<span class="nc" id="L94">            throw new ParseException(&quot;Thread not suspended&quot;);</span>
        }
    }

    LValue memberLValue(String fieldName, ThreadReference thread) throws ParseException {

<span class="nc" id="L100">        Value val = interiorGetValue();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">        if ((val instanceof ArrayReference) &amp;&amp;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            &quot;length&quot;.equals(fieldName)){</span>
<span class="nc" id="L103">            return new LValueArrayLength((ArrayReference)val);</span>
        }
<span class="nc" id="L105">        return new LValueInstanceMember(val, fieldName, thread);</span>
    }

    // Return the Value for this LValue that would be used to concatenate
    // to a String.  IE, if it is an Object, call toString in the debuggee.
    Value getMassagedValue(ExpressionParser.GetFrame frameGetter) throws ParseException {
<span class="nc" id="L111">        Value vv = interiorGetValue();</span>

        // If vv is an ObjectReference, then we have to
        // do the implicit call to toString().
<span class="nc bnc" id="L115" title="All 6 branches missed.">        if (vv instanceof ObjectReference &amp;&amp;</span>
            !(vv instanceof StringReference) &amp;&amp;
            !(vv instanceof ArrayReference)) {
            StackFrame frame;
            try {
<span class="nc" id="L120">                frame = frameGetter.get();</span>
<span class="nc" id="L121">            } catch (IncompatibleThreadStateException exc) {</span>
<span class="nc" id="L122">                throw new ParseException(&quot;Thread not suspended&quot;);</span>
<span class="nc" id="L123">            }</span>

<span class="nc" id="L125">            ThreadReference thread = frame.thread();</span>
<span class="nc" id="L126">            LValue toStringMember = memberLValue(&quot;toString&quot;, thread);</span>
<span class="nc" id="L127">            toStringMember.invokeWith(new ArrayList&lt;Value&gt;());</span>
<span class="nc" id="L128">            return toStringMember.interiorGetValue();</span>
        }
<span class="nc" id="L130">        return vv;</span>
    }

    Value interiorGetValue() throws ParseException {
        Value value;
        try {
<span class="nc" id="L136">            value = getValue();</span>
<span class="nc" id="L137">        } catch (InvocationException e) {</span>
<span class="nc" id="L138">            throw new ParseException(&quot;Unable to complete expression. Exception &quot; +</span>
<span class="nc" id="L139">                                     e.exception() + &quot; thrown&quot;);</span>
<span class="nc" id="L140">        } catch (IncompatibleThreadStateException itse) {</span>
<span class="nc" id="L141">            throw new ParseException(&quot;Unable to complete expression. Thread &quot; +</span>
                                     &quot;not suspended for method invoke&quot;);
<span class="nc" id="L143">        } catch (InvalidTypeException ite) {</span>
<span class="nc" id="L144">            throw new ParseException(&quot;Unable to complete expression. Method &quot; +</span>
                                     &quot;argument type mismatch&quot;);
<span class="nc" id="L146">        } catch (ClassNotLoadedException tnle) {</span>
<span class="nc" id="L147">            throw new ParseException(&quot;Unable to complete expression. Method &quot; +</span>
<span class="nc" id="L148">                                     &quot;argument type &quot; + tnle.className() +</span>
                                     &quot; not yet loaded&quot;);
<span class="nc" id="L150">        }</span>
<span class="nc" id="L151">        return value;</span>
    }

    LValue arrayElementLValue(LValue lval) throws ParseException {
<span class="nc" id="L155">        Value indexValue = lval.interiorGetValue();</span>
        int index;
<span class="nc bnc" id="L157" title="All 8 branches missed.">        if ( (indexValue instanceof IntegerValue) ||</span>
             (indexValue instanceof ShortValue) ||
             (indexValue instanceof ByteValue) ||
             (indexValue instanceof CharValue) ) {
<span class="nc" id="L161">            index = ((PrimitiveValue)indexValue).intValue();</span>
        } else {
<span class="nc" id="L163">            throw new ParseException(&quot;Array index must be a integer type&quot;);</span>
        }
<span class="nc" id="L165">        return new LValueArrayElement(interiorGetValue(), index);</span>
    }

   @Override
    public String toString() {
        try {
<span class="nc" id="L171">            return interiorGetValue().toString();</span>
<span class="nc" id="L172">        } catch (ParseException e) {</span>
<span class="nc" id="L173">            return &quot;&lt;Parse Exception&gt;&quot;;</span>
        }
    }

    static final int STATIC = 0;
    static final int INSTANCE = 1;

    static Field fieldByName(ReferenceType refType, String name, int kind) {
        /*
         * TO DO: Note that this currently fails to find superclass
         * or implemented interface fields. This is due to a temporary
         * limititation of RefType.fieldByName. Once that method is
         * fixed, superclass fields will be found.
         */
<span class="nc" id="L187">        Field field = refType.fieldByName(name);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (field != null) {</span>
<span class="nc" id="L189">            boolean isStatic = field.isStatic();</span>
<span class="nc bnc" id="L190" title="All 8 branches missed.">            if (((kind == STATIC) &amp;&amp; !isStatic) ||</span>
                ((kind == INSTANCE) &amp;&amp; isStatic)) {
<span class="nc" id="L192">                field = null;</span>
            }
        }
/***
        System.err.println(&quot;fieldByName: &quot; + refType.name() + &quot; &quot; +
                                             name + &quot; &quot; +
                                             kind + &quot; &quot; +
                                             (field != null));
***/
<span class="nc" id="L201">        return field;</span>
    }

    static List&lt;Method&gt; methodsByName(ReferenceType refType,
                                      String name, int kind) {
<span class="nc" id="L206">        List&lt;Method&gt; list = refType.methodsByName(name);</span>
<span class="nc" id="L207">        Iterator&lt;Method&gt; iter = list.iterator();</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L209">            Method method = iter.next();</span>
<span class="nc" id="L210">            boolean isStatic = method.isStatic();</span>
<span class="nc bnc" id="L211" title="All 8 branches missed.">            if (((kind == STATIC) &amp;&amp; !isStatic) ||</span>
                ((kind == INSTANCE) &amp;&amp; isStatic)) {
<span class="nc" id="L213">                iter.remove();</span>
            }
<span class="nc" id="L215">        }</span>
<span class="nc" id="L216">        return list;</span>
    }

<span class="nc" id="L219">    static List&lt;String&gt; primitiveTypeNames = new ArrayList&lt;String&gt;();</span>
    static {
<span class="nc" id="L221">        primitiveTypeNames.add(&quot;boolean&quot;);</span>
<span class="nc" id="L222">        primitiveTypeNames.add(&quot;byte&quot;);</span>
<span class="nc" id="L223">        primitiveTypeNames.add(&quot;char&quot;);</span>
<span class="nc" id="L224">        primitiveTypeNames.add(&quot;short&quot;);</span>
<span class="nc" id="L225">        primitiveTypeNames.add(&quot;int&quot;);</span>
<span class="nc" id="L226">        primitiveTypeNames.add(&quot;long&quot;);</span>
<span class="nc" id="L227">        primitiveTypeNames.add(&quot;float&quot;);</span>
<span class="nc" id="L228">        primitiveTypeNames.add(&quot;double&quot;);</span>
<span class="nc" id="L229">    }</span>


    static final int SAME = 0;
    static final int ASSIGNABLE = 1;
    static final int DIFFERENT = 2;
    /*
     * Return SAME, DIFFERENT or ASSIGNABLE.
     * SAME means each arg type is the same as type of the corr. arg.
     * ASSIGNABLE means that not all the pairs are the same, but
     * for those that aren't, at least the argType is assignable
     * from the type of the argument value.
     * DIFFERENT means that in at least one pair, the
     * argType is not assignable from the type of the argument value.
     * IE, one is an Apple and the other is an Orange.
     */
    static int argumentsMatch(List&lt;Type&gt; argTypes, List&lt;Value&gt; arguments) {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (argTypes.size() != arguments.size()) {</span>
<span class="nc" id="L247">            return DIFFERENT;</span>
        }

<span class="nc" id="L250">        Iterator&lt;Type&gt; typeIter = argTypes.iterator();</span>
<span class="nc" id="L251">        Iterator&lt;Value&gt; valIter = arguments.iterator();</span>
<span class="nc" id="L252">        int result = SAME;</span>

        // If any pair aren't the same, change the
        // result to ASSIGNABLE.  If any pair aren't
        // assignable, return DIFFERENT
<span class="nc bnc" id="L257" title="All 2 branches missed.">        while (typeIter.hasNext()) {</span>
<span class="nc" id="L258">            Type argType = typeIter.next();</span>
<span class="nc" id="L259">            Value value = valIter.next();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            if (value == null) {</span>
                // Null values can be passed to any non-primitive argument
<span class="nc bnc" id="L262" title="All 2 branches missed.">                if (primitiveTypeNames.contains(argType.name())) {</span>
<span class="nc" id="L263">                    return DIFFERENT;</span>
                }
                // Else, we will assume that a null value
                // exactly matches an object type.
            }
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (!value.type().equals(argType)) {</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">                if (isAssignableTo(value.type(), argType)) {</span>
<span class="nc" id="L270">                    result = ASSIGNABLE;</span>
                } else {
<span class="nc" id="L272">                    return DIFFERENT;</span>
                }
            }
<span class="nc" id="L275">        }</span>
<span class="nc" id="L276">        return result;</span>
    }


    // These is...AssignableTo methods are based on similar code in the JDI
    // implementations of ClassType, ArrayType, and InterfaceType

    static boolean isComponentAssignable(Type fromType, Type toType) {
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (fromType instanceof PrimitiveType) {</span>
            // Assignment of primitive arrays requires identical
            // component types.
<span class="nc" id="L287">            return fromType.equals(toType);</span>
        }
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (toType instanceof PrimitiveType) {</span>
<span class="nc" id="L290">            return false;</span>
        }
        // Assignment of object arrays requires availability
        // of widening conversion of component types
<span class="nc" id="L294">        return isAssignableTo(fromType, toType);</span>
    }

    static boolean isArrayAssignableTo(ArrayType fromType, Type toType) {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (toType instanceof ArrayType) {</span>
            try {
<span class="nc" id="L300">                Type toComponentType = ((ArrayType)toType).componentType();</span>
<span class="nc" id="L301">                return isComponentAssignable(fromType.componentType(), toComponentType);</span>
<span class="nc" id="L302">            } catch (ClassNotLoadedException e) {</span>
                // One or both component types has not yet been
                // loaded =&gt; can't assign
<span class="nc" id="L305">                return false;</span>
            }
        }
<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (toType instanceof InterfaceType) {</span>
            // Only valid InterfaceType assignee is Cloneable
<span class="nc" id="L310">            return toType.name().equals(&quot;java.lang.Cloneable&quot;);</span>
        }
        // Only valid ClassType assignee is Object
<span class="nc" id="L313">        return toType.name().equals(&quot;java.lang.Object&quot;);</span>
    }

    static boolean isAssignableTo(Type fromType, Type toType) {
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (fromType.equals(toType)) {</span>
<span class="nc" id="L318">            return true;</span>
        }

        // If one is boolean, so must be the other.
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (fromType instanceof BooleanType) {</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (toType instanceof BooleanType) {</span>
<span class="nc" id="L324">                return true;</span>
            }
<span class="nc" id="L326">            return false;</span>
        }
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (toType instanceof BooleanType) {</span>
<span class="nc" id="L329">            return false;</span>
        }

        // Other primitive types are intermixable only with each other.
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (fromType instanceof PrimitiveType) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (toType instanceof PrimitiveType) {</span>
<span class="nc" id="L335">                return true;</span>
            }
<span class="nc" id="L337">            return false;</span>
        }
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (toType instanceof PrimitiveType) {</span>
<span class="nc" id="L340">            return false;</span>
        }

        // neither one is primitive.
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (fromType instanceof ArrayType) {</span>
<span class="nc" id="L345">            return isArrayAssignableTo((ArrayType)fromType, toType);</span>
        }
        List&lt;InterfaceType&gt; interfaces;
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (fromType instanceof ClassType) {</span>
<span class="nc" id="L349">            ClassType superclazz = ((ClassType)fromType).superclass();</span>
<span class="nc bnc" id="L350" title="All 4 branches missed.">            if ((superclazz != null) &amp;&amp; isAssignableTo(superclazz, toType)) {</span>
<span class="nc" id="L351">                return true;</span>
            }
<span class="nc" id="L353">            interfaces = ((ClassType)fromType).interfaces();</span>
<span class="nc" id="L354">        } else {</span>
            // fromType must be an InterfaceType
<span class="nc" id="L356">            interfaces = ((InterfaceType)fromType).superinterfaces();</span>
        }
<span class="nc bnc" id="L358" title="All 2 branches missed.">        for (InterfaceType interfaze : interfaces) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (isAssignableTo(interfaze, toType)) {</span>
<span class="nc" id="L360">                return true;</span>
            }
<span class="nc" id="L362">        }</span>
<span class="nc" id="L363">        return false;</span>
    }

    static Method resolveOverload(List&lt;Method&gt; overloads,
                                  List&lt;Value&gt; arguments)
                                       throws ParseException {

        // If there is only one method to call, we'll just choose
        // that without looking at the args.  If they aren't right
        // the invoke will return a better error message than we
        // could generate here.
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (overloads.size() == 1) {</span>
<span class="nc" id="L375">            return overloads.get(0);</span>
        }

        // Resolving overloads is beyond the scope of this exercise.
        // So, we will look for a method that matches exactly the
        // types of the arguments.  If we can't find one, then
        // if there is exactly one method whose param types are assignable
        // from the arg types, we will use that.  Otherwise,
        // it is an error.  We won't guess which of multiple possible
        // methods to call. And, since casts aren't implemented,
        // the user can't use them to pick a particular overload to call.
        // IE, the user is out of luck in this case.
<span class="nc" id="L387">        Method retVal = null;</span>
<span class="nc" id="L388">        int assignableCount = 0;</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">        for (Method mm : overloads) {</span>
            List&lt;Type&gt; argTypes;
            try {
<span class="nc" id="L392">                argTypes = mm.argumentTypes();</span>
<span class="nc" id="L393">            } catch (ClassNotLoadedException ee) {</span>
                // This probably won't happen for the
                // method that we are really supposed to
                // call.
<span class="nc" id="L397">                continue;</span>
<span class="nc" id="L398">            }</span>
<span class="nc" id="L399">            int compare = argumentsMatch(argTypes, arguments);</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">            if (compare == SAME) {</span>
<span class="nc" id="L401">                return mm;</span>
            }
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (compare == DIFFERENT) {</span>
<span class="nc" id="L404">                continue;</span>
            }
            // Else, it is assignable.  Remember it.
<span class="nc" id="L407">            retVal = mm;</span>
<span class="nc" id="L408">            assignableCount++;</span>
<span class="nc" id="L409">        }</span>

        // At this point, we didn't find an exact match,
        // but we found one for which the args are assignable.
        //
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (retVal != null) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (assignableCount == 1) {</span>
<span class="nc" id="L416">                return retVal;</span>
            }
<span class="nc" id="L418">            throw new ParseException(&quot;Arguments match multiple methods&quot;);</span>
        }
<span class="nc" id="L420">        throw new ParseException(&quot;Arguments match no method&quot;);</span>
    }

    private static class LValueLocal extends LValue {
        final StackFrame frame;
        final LocalVariable var;

<span class="nc" id="L427">        LValueLocal(StackFrame frame, LocalVariable var) {</span>
<span class="nc" id="L428">            this.frame = frame;</span>
<span class="nc" id="L429">            this.var = var;</span>
<span class="nc" id="L430">        }</span>

      @Override
        Value getValue() {
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (jdiValue == null) {</span>
<span class="nc" id="L435">                jdiValue = frame.getValue(var);</span>
            }
<span class="nc" id="L437">            return jdiValue;</span>
        }

      @Override
        void setValue0(Value val) throws InvalidTypeException,
                                         ClassNotLoadedException {
<span class="nc" id="L443">            frame.setValue(var, val);</span>
<span class="nc" id="L444">            jdiValue = val;</span>
<span class="nc" id="L445">        }</span>

      @Override
        void invokeWith(List&lt;Value&gt; arguments) throws ParseException {
<span class="nc" id="L449">            throw new ParseException(var.name() + &quot; is not a method&quot;);</span>
        }
    }

    private static class LValueInstanceMember extends LValue {
        final ObjectReference obj;
        final ThreadReference thread;
        final Field matchingField;
        final List&lt;Method&gt; overloads;
<span class="nc" id="L458">        Method matchingMethod = null;</span>
<span class="nc" id="L459">        List&lt;Value&gt; methodArguments = null;</span>

        LValueInstanceMember(Value value,
                            String memberName,
<span class="nc" id="L463">                            ThreadReference thread) throws ParseException {</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if (!(value instanceof ObjectReference)) {</span>
<span class="nc" id="L465">                throw new ParseException(</span>
                       &quot;Cannot access field of primitive type: &quot; + value);
            }
<span class="nc" id="L468">            this.obj = (ObjectReference)value;</span>
<span class="nc" id="L469">            this.thread = thread;</span>
<span class="nc" id="L470">            ReferenceType refType = obj.referenceType();</span>
            /*
             * Can't tell yet whether this LValue will be accessed as a
             * field or method, so we keep track of all the possibilities
             */
<span class="nc" id="L475">            matchingField = LValue.fieldByName(refType, memberName,</span>
                                               LValue.INSTANCE);
<span class="nc" id="L477">            overloads = LValue.methodsByName(refType, memberName,</span>
                                              LValue.INSTANCE);
<span class="nc bnc" id="L479" title="All 4 branches missed.">            if ((matchingField == null) &amp;&amp; overloads.size() == 0) {</span>
<span class="nc" id="L480">                throw new ParseException(&quot;No instance field or method with the name &quot;</span>
<span class="nc" id="L481">                               + memberName + &quot; in &quot; + refType.name());</span>
            }
<span class="nc" id="L483">        }</span>

      @Override
        Value getValue() throws InvocationException, InvalidTypeException,
                                ClassNotLoadedException, IncompatibleThreadStateException,
                                ParseException {
<span class="nc bnc" id="L489" title="All 2 branches missed.">            if (jdiValue != null) {</span>
<span class="nc" id="L490">                return jdiValue;</span>
            }
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if (matchingMethod == null) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                if (matchingField == null) {</span>
<span class="nc" id="L494">                    throw new ParseException(&quot;No such field in &quot; + obj.referenceType().name());</span>
                }
<span class="nc" id="L496">                return jdiValue = obj.getValue(matchingField);</span>
            } else {
<span class="nc" id="L498">                return jdiValue = obj.invokeMethod(thread, matchingMethod, methodArguments, 0);</span>
            }
        }

        @Override
        void setValue0(Value val) throws ParseException,
                                         InvalidTypeException,
                                        ClassNotLoadedException {
<span class="nc bnc" id="L506" title="All 2 branches missed.">            if (matchingMethod != null) {</span>
<span class="nc" id="L507">                throw new ParseException(&quot;Cannot assign to a method invocation&quot;);</span>
            }
<span class="nc" id="L509">            obj.setValue(matchingField, val);</span>
<span class="nc" id="L510">            jdiValue = val;</span>
<span class="nc" id="L511">        }</span>

        @Override
        void invokeWith(List&lt;Value&gt; arguments) throws ParseException {
<span class="nc bnc" id="L515" title="All 2 branches missed.">            if (matchingMethod != null) {</span>
<span class="nc" id="L516">                throw new ParseException(&quot;Invalid consecutive invocations&quot;);</span>
            }
<span class="nc" id="L518">            methodArguments = arguments;</span>
<span class="nc" id="L519">            matchingMethod = LValue.resolveOverload(overloads, arguments);</span>
<span class="nc" id="L520">        }</span>
    }

    private static class LValueStaticMember extends LValue {
        final ReferenceType refType;
        final ThreadReference thread;
        final Field matchingField;
        final List&lt;Method&gt; overloads;
<span class="nc" id="L528">        Method matchingMethod = null;</span>
<span class="nc" id="L529">        List&lt;Value&gt; methodArguments = null;</span>

        LValueStaticMember(ReferenceType refType,
                          String memberName,
<span class="nc" id="L533">                          ThreadReference thread) throws ParseException {</span>
<span class="nc" id="L534">            this.refType = refType;</span>
<span class="nc" id="L535">            this.thread = thread;</span>
            /*
             * Can't tell yet whether this LValue will be accessed as a
             * field or method, so we keep track of all the possibilities
             */
<span class="nc" id="L540">            matchingField = LValue.fieldByName(refType, memberName,</span>
                                               LValue.STATIC);
<span class="nc" id="L542">            overloads = LValue.methodsByName(refType, memberName,</span>
                                              LValue.STATIC);
<span class="nc bnc" id="L544" title="All 4 branches missed.">            if ((matchingField == null) &amp;&amp; overloads.size() == 0) {</span>
<span class="nc" id="L545">                throw new ParseException(&quot;No static field or method with the name &quot;</span>
<span class="nc" id="L546">                               + memberName + &quot; in &quot; + refType.name());</span>
            }
<span class="nc" id="L548">        }</span>

        @Override
        Value getValue() throws InvocationException, InvalidTypeException,
                                ClassNotLoadedException, IncompatibleThreadStateException,
                                ParseException {
<span class="nc bnc" id="L554" title="All 2 branches missed.">            if (jdiValue != null) {</span>
<span class="nc" id="L555">                return jdiValue;</span>
            }
<span class="nc bnc" id="L557" title="All 2 branches missed.">            if (matchingMethod == null) {</span>
<span class="nc" id="L558">                return jdiValue = refType.getValue(matchingField);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">            } else if (refType instanceof ClassType) {</span>
<span class="nc" id="L560">                ClassType clazz = (ClassType)refType;</span>
<span class="nc" id="L561">                return jdiValue = clazz.invokeMethod(thread, matchingMethod, methodArguments, 0);</span>
            } else {
<span class="nc" id="L563">                throw new InvalidTypeException(&quot;Cannot invoke static method on &quot; +</span>
<span class="nc" id="L564">                                         refType.name());</span>
            }
        }

        @Override
        void setValue0(Value val)
                           throws ParseException, InvalidTypeException,
                                  ClassNotLoadedException {
<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (matchingMethod != null) {</span>
<span class="nc" id="L573">                throw new ParseException(&quot;Cannot assign to a method invocation&quot;);</span>
            }
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (!(refType instanceof ClassType)) {</span>
<span class="nc" id="L576">                throw new ParseException(</span>
                       &quot;Cannot set interface field: &quot; + refType);
            }
<span class="nc" id="L579">            ((ClassType)refType).setValue(matchingField, val);</span>
<span class="nc" id="L580">            jdiValue = val;</span>
<span class="nc" id="L581">        }</span>

        @Override
        void invokeWith(List&lt;Value&gt; arguments) throws ParseException {
<span class="nc bnc" id="L585" title="All 2 branches missed.">            if (matchingMethod != null) {</span>
<span class="nc" id="L586">                throw new ParseException(&quot;Invalid consecutive invocations&quot;);</span>
            }
<span class="nc" id="L588">            methodArguments = arguments;</span>
<span class="nc" id="L589">            matchingMethod = LValue.resolveOverload(overloads, arguments);</span>
<span class="nc" id="L590">        }</span>
    }

    private static class LValueArrayLength extends LValue {
        /*
         * Since one can code &quot;int myLen = myArray.length;&quot;,
         * one might expect that these JDI calls would get a Value
         * object for the length of an array in the debugee:
         *    Field xxx = ArrayType.fieldByName(&quot;length&quot;)
         *    Value lenVal= ArrayReference.getValue(xxx)
         *
         * However, this doesn't work because the array length isn't
         * really stored as a field, and can't be accessed as such
         * via JDI.  Instead, the arrayRef.length() method has to be
         * used.
         */
        final ArrayReference arrayRef;
<span class="nc" id="L607">        LValueArrayLength (ArrayReference value) {</span>
<span class="nc" id="L608">            this.arrayRef = value;</span>
<span class="nc" id="L609">        }</span>

        @Override
        Value getValue() {
<span class="nc bnc" id="L613" title="All 2 branches missed.">            if (jdiValue == null) {</span>
<span class="nc" id="L614">                jdiValue = arrayRef.virtualMachine().mirrorOf(arrayRef.length());</span>
            }
<span class="nc" id="L616">            return jdiValue;</span>
        }

        @Override
        void setValue0(Value value) throws ParseException  {
<span class="nc" id="L621">            throw new ParseException(&quot;Cannot set constant: &quot; + value);</span>
        }

        @Override
        void invokeWith(List&lt;Value&gt; arguments) throws ParseException {
<span class="nc" id="L626">            throw new ParseException(&quot;Array element is not a method&quot;);</span>
        }
    }

    private static class LValueArrayElement extends LValue {
        final ArrayReference array;
        final int index;

<span class="nc" id="L634">        LValueArrayElement(Value value, int index) throws ParseException {</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">            if (!(value instanceof ArrayReference)) {</span>
<span class="nc" id="L636">                throw new ParseException(</span>
                       &quot;Must be array type: &quot; + value);
            }
<span class="nc" id="L639">            this.array = (ArrayReference)value;</span>
<span class="nc" id="L640">            this.index = index;</span>
<span class="nc" id="L641">        }</span>

        @Override
        Value getValue() {
<span class="nc bnc" id="L645" title="All 2 branches missed.">            if (jdiValue == null) {</span>
<span class="nc" id="L646">                jdiValue = array.getValue(index);</span>
            }
<span class="nc" id="L648">            return jdiValue;</span>
        }

        @Override
        void setValue0(Value val) throws InvalidTypeException,
                                         ClassNotLoadedException  {
<span class="nc" id="L654">            array.setValue(index, val);</span>
<span class="nc" id="L655">            jdiValue = val;</span>
<span class="nc" id="L656">        }</span>

        @Override
        void invokeWith(List&lt;Value&gt; arguments) throws ParseException {
<span class="nc" id="L660">            throw new ParseException(&quot;Array element is not a method&quot;);</span>
        }
    }

<span class="nc" id="L664">    private static class LValueConstant extends LValue {</span>
        final Value value;

<span class="nc" id="L667">        LValueConstant(Value value) {</span>
<span class="nc" id="L668">            this.value = value;</span>
<span class="nc" id="L669">        }</span>

        @Override
        Value getValue() {
<span class="nc bnc" id="L673" title="All 2 branches missed.">            if (jdiValue == null) {</span>
<span class="nc" id="L674">                jdiValue = value;</span>
            }
<span class="nc" id="L676">            return jdiValue;</span>
        }

        @Override
        void setValue0(Value val) throws ParseException {
<span class="nc" id="L681">            throw new ParseException(&quot;Cannot set constant: &quot; + value);</span>
        }

        @Override
        void invokeWith(List&lt;Value&gt; arguments) throws ParseException {
<span class="nc" id="L686">            throw new ParseException(&quot;Constant is not a method&quot;);</span>
        }
    }

    static LValue make(VirtualMachine vm, boolean val) {
<span class="nc" id="L691">        return new LValueConstant(vm.mirrorOf(val));</span>
    }

    static LValue make(VirtualMachine vm, byte val) {
<span class="nc" id="L695">        return new LValueConstant(vm.mirrorOf(val));</span>
    }

    static LValue make(VirtualMachine vm, char val) {
<span class="nc" id="L699">        return new LValueConstant(vm.mirrorOf(val));</span>
    }

    static LValue make(VirtualMachine vm, short val) {
<span class="nc" id="L703">        return new LValueConstant(vm.mirrorOf(val));</span>
    }

    static LValue make(VirtualMachine vm, int val) {
<span class="nc" id="L707">        return new LValueConstant(vm.mirrorOf(val));</span>
    }

    static LValue make(VirtualMachine vm, long val) {
<span class="nc" id="L711">        return new LValueConstant(vm.mirrorOf(val));</span>
    }

    static LValue make(VirtualMachine vm, float val) {
<span class="nc" id="L715">        return new LValueConstant(vm.mirrorOf(val));</span>
    }

    static LValue make(VirtualMachine vm, double val) {
<span class="nc" id="L719">        return new LValueConstant(vm.mirrorOf(val));</span>
    }

    static LValue make(VirtualMachine vm, String val) throws ParseException {
<span class="nc" id="L723">        return new LValueConstant(vm.mirrorOf(val));</span>
    }

    static LValue makeBoolean(VirtualMachine vm, Token token) {
<span class="nc bnc" id="L727" title="All 2 branches missed.">        return make(vm, token.image.charAt(0) == 't');</span>
    }

    static LValue makeCharacter(VirtualMachine vm, Token token) {
<span class="nc" id="L731">        return make(vm, token.image.charAt(1));</span>
    }

    static LValue makeFloat(VirtualMachine vm, Token token) {
<span class="nc" id="L735">        return make(vm, Float.valueOf(token.image).floatValue());</span>
    }

    static LValue makeDouble(VirtualMachine vm, Token token) {
<span class="nc" id="L739">        return make(vm, Double.valueOf(token.image).doubleValue());</span>
    }

    static LValue makeInteger(VirtualMachine vm, Token token) {
<span class="nc" id="L743">        return make(vm, Integer.parseInt(token.image));</span>
    }

    static LValue makeShort(VirtualMachine vm, Token token) {
<span class="nc" id="L747">        return make(vm, Short.parseShort(token.image));</span>
    }

    static LValue makeLong(VirtualMachine vm, Token token) {
<span class="nc" id="L751">        return make(vm, Long.parseLong(token.image));</span>
    }

    static LValue makeByte(VirtualMachine vm, Token token) {
<span class="nc" id="L755">        return make(vm, Byte.parseByte(token.image));</span>
    }

    static LValue makeString(VirtualMachine vm,
                             Token token) throws ParseException {
<span class="nc" id="L760">        int len = token.image.length();</span>
<span class="nc" id="L761">        return make(vm, token.image.substring(1,len-1));</span>
    }

    static LValue makeNull(VirtualMachine vm,
                           Token token) throws ParseException {
<span class="nc" id="L766">        return new LValueConstant(null);</span>
    }

    static LValue makeThisObject(VirtualMachine vm,
                                 ExpressionParser.GetFrame frameGetter,
                                 Token token) throws ParseException {
<span class="nc bnc" id="L772" title="All 2 branches missed.">        if (frameGetter == null) {</span>
<span class="nc" id="L773">            throw new ParseException(&quot;No current thread&quot;);</span>
        } else {
            try {
<span class="nc" id="L776">                StackFrame frame = frameGetter.get();</span>
<span class="nc" id="L777">                ObjectReference thisObject = frame.thisObject();</span>

<span class="nc bnc" id="L779" title="All 2 branches missed.">                if (thisObject==null) {</span>
<span class="nc" id="L780">                        throw new ParseException(</span>
                            &quot;No 'this'.  In native or static method&quot;);
                } else {
<span class="nc" id="L783">                        return new LValueConstant(thisObject);</span>
                }
<span class="nc" id="L785">            } catch (IncompatibleThreadStateException exc) {</span>
<span class="nc" id="L786">                throw new ParseException(&quot;Thread not suspended&quot;);</span>
            }
        }
    }

    static LValue makeNewObject(VirtualMachine vm,
                                 ExpressionParser.GetFrame frameGetter,
                                String className, List&lt;Value&gt; arguments) throws ParseException {
<span class="nc" id="L794">        List&lt;ReferenceType&gt; classes = vm.classesByName(className);</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (classes.size() == 0) {</span>
<span class="nc" id="L796">            throw new ParseException(&quot;No class named: &quot; + className);</span>
        }

<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (classes.size() &gt; 1) {</span>
<span class="nc" id="L800">            throw new ParseException(&quot;More than one class named: &quot; +</span>
                                     className);
        }
<span class="nc" id="L803">        ReferenceType refType = classes.get(0);</span>


<span class="nc bnc" id="L806" title="All 2 branches missed.">        if (!(refType instanceof ClassType)) {</span>
<span class="nc" id="L807">            throw new ParseException(&quot;Cannot create instance of interface &quot; +</span>
                                     className);
        }

<span class="nc" id="L811">        ClassType classType = (ClassType)refType;</span>
<span class="nc" id="L812">        List&lt;Method&gt; methods = new ArrayList&lt;Method&gt;(classType.methods()); // writable</span>
<span class="nc" id="L813">        Iterator&lt;Method&gt; iter = methods.iterator();</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L815">            Method method = iter.next();</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">            if (!method.isConstructor()) {</span>
<span class="nc" id="L817">                iter.remove();</span>
            }
<span class="nc" id="L819">        }</span>
<span class="nc" id="L820">        Method constructor = LValue.resolveOverload(methods, arguments);</span>

        ObjectReference newObject;
        try {
<span class="nc" id="L824">            ThreadReference thread = frameGetter.get().thread();</span>
<span class="nc" id="L825">            newObject = classType.newInstance(thread, constructor, arguments, 0);</span>
<span class="nc" id="L826">        } catch (InvocationException ie) {</span>
<span class="nc" id="L827">            throw new ParseException(&quot;Exception in &quot; + className + &quot; constructor: &quot; +</span>
<span class="nc" id="L828">                                     ie.exception().referenceType().name());</span>
<span class="nc" id="L829">        } catch (IncompatibleThreadStateException exc) {</span>
<span class="nc" id="L830">            throw new ParseException(&quot;Thread not suspended&quot;);</span>
<span class="nc" id="L831">        } catch (Exception e) {</span>
            /*
             * TO DO: Better error handling
             */
<span class="nc" id="L835">            throw new ParseException(&quot;Unable to create &quot; + className + &quot; instance&quot;);</span>
<span class="nc" id="L836">        }</span>
<span class="nc" id="L837">        return new LValueConstant(newObject);</span>
    }

    private static LValue nFields(LValue lval,
                                  StringTokenizer izer,
                                  ThreadReference thread)
                                          throws ParseException {
<span class="nc bnc" id="L844" title="All 2 branches missed.">        if (!izer.hasMoreTokens()) {</span>
<span class="nc" id="L845">            return lval;</span>
        } else {
<span class="nc" id="L847">            return nFields(lval.memberLValue(izer.nextToken(), thread), izer, thread);</span>
        }
    }

    static LValue makeName(VirtualMachine vm,
                           ExpressionParser.GetFrame frameGetter,
                           String name) throws ParseException {
<span class="nc" id="L854">        StringTokenizer izer = new StringTokenizer(name, &quot;.&quot;);</span>
<span class="nc" id="L855">        String first = izer.nextToken();</span>
        // check local variables
<span class="nc bnc" id="L857" title="All 2 branches missed.">        if (frameGetter != null) {</span>
            try {
<span class="nc" id="L859">                StackFrame frame = frameGetter.get();</span>
<span class="nc" id="L860">                ThreadReference thread = frame.thread();</span>
                LocalVariable var;
                try {
<span class="nc" id="L863">                    var = frame.visibleVariableByName(first);</span>
<span class="nc" id="L864">                } catch (AbsentInformationException e) {</span>
<span class="nc" id="L865">                    var = null;</span>
<span class="nc" id="L866">                }</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">                if (var != null) {</span>
<span class="nc" id="L868">                    return nFields(new LValueLocal(frame, var), izer, thread);</span>
                } else {
<span class="nc" id="L870">                    ObjectReference thisObject = frame.thisObject();</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                    if (thisObject != null) {</span>
                        // check if it is a field of 'this'
<span class="nc" id="L873">                        LValue thisLValue = new LValueConstant(thisObject);</span>
                        LValue fv;
                        try {
<span class="nc" id="L876">                            fv = thisLValue.memberLValue(first, thread);</span>
<span class="nc" id="L877">                        } catch (ParseException exc) {</span>
<span class="nc" id="L878">                            fv = null;</span>
<span class="nc" id="L879">                        }</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">                        if (fv != null) {</span>
<span class="nc" id="L881">                            return nFields(fv, izer, thread);</span>
                        }
                    }
                }
                // check for class name
<span class="nc bnc" id="L886" title="All 2 branches missed.">                while (izer.hasMoreTokens()) {</span>
<span class="nc" id="L887">                    List&lt;ReferenceType&gt; classes = vm.classesByName(first);</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">                    if (classes.size() &gt; 0) {</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">                        if (classes.size() &gt; 1) {</span>
<span class="nc" id="L890">                            throw new ParseException(&quot;More than one class named: &quot; +</span>
                                                     first);
                        } else {
<span class="nc" id="L893">                            ReferenceType refType = classes.get(0);</span>
<span class="nc" id="L894">                            LValue lval = new LValueStaticMember(refType,</span>
<span class="nc" id="L895">                                                            izer.nextToken(), thread);</span>
<span class="nc" id="L896">                            return nFields(lval, izer, thread);</span>
                        }
                    }
<span class="nc" id="L899">                    first = first + '.' + izer.nextToken();</span>
<span class="nc" id="L900">                }</span>
<span class="nc" id="L901">            } catch (IncompatibleThreadStateException exc) {</span>
<span class="nc" id="L902">                throw new ParseException(&quot;Thread not suspended&quot;);</span>
<span class="nc" id="L903">            }</span>
        }
<span class="nc" id="L905">        throw new ParseException(&quot;Name unknown: &quot; + name);</span>
    }

    static String stringValue(LValue lval, ExpressionParser.GetFrame frameGetter
                              ) throws ParseException {
<span class="nc" id="L910">        Value val = lval.getMassagedValue(frameGetter);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">        if (val == null) {</span>
<span class="nc" id="L912">            return &quot;null&quot;;</span>
        }
<span class="nc bnc" id="L914" title="All 2 branches missed.">        if (val instanceof StringReference) {</span>
<span class="nc" id="L915">            return ((StringReference)val).value();</span>
        }
<span class="nc" id="L917">        return val.toString();  // is this correct in all cases?</span>
    }

    static LValue booleanOperation(VirtualMachine vm, Token token,
                            LValue rightL,
                            LValue leftL) throws ParseException {
<span class="nc" id="L923">        String op = token.image;</span>
<span class="nc" id="L924">        Value right = rightL.interiorGetValue();</span>
<span class="nc" id="L925">        Value left = leftL.interiorGetValue();</span>
<span class="nc bnc" id="L926" title="All 4 branches missed.">        if ( !(right instanceof PrimitiveValue) ||</span>
             !(left instanceof PrimitiveValue) ) {
<span class="nc bnc" id="L928" title="All 2 branches missed.">            if (op.equals(&quot;==&quot;)) {</span>
<span class="nc" id="L929">                return make(vm, right.equals(left));</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">            } else if (op.equals(&quot;!=&quot;)) {</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">                return make(vm, !right.equals(left));</span>
            } else {
<span class="nc" id="L933">                throw new ParseException(&quot;Operands or '&quot; + op +</span>
                                     &quot;' must be primitive&quot;);
            }
        }
        // can compare any numeric doubles
<span class="nc" id="L938">        double rr = ((PrimitiveValue)right).doubleValue();</span>
<span class="nc" id="L939">        double ll = ((PrimitiveValue)left).doubleValue();</span>
        boolean res;
<span class="nc bnc" id="L941" title="All 2 branches missed.">        if (op.equals(&quot;&lt;&quot;)) {</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">            res = rr &lt; ll;</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">        } else if (op.equals(&quot;&gt;&quot;)) {</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">            res = rr &gt; ll;</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">        } else if (op.equals(&quot;&lt;=&quot;)) {</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">            res = rr &lt;= ll;</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">        } else if (op.equals(&quot;&gt;=&quot;)) {</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">            res = rr &gt;= ll;</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">        } else if (op.equals(&quot;==&quot;)) {</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">            res = rr == ll;</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">        } else if (op.equals(&quot;!=&quot;)) {</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">            res = rr != ll;</span>
        } else {
<span class="nc" id="L954">            throw new ParseException(&quot;Unknown operation: &quot; + op);</span>
        }
<span class="nc" id="L956">        return make(vm, res);</span>
    }

    static LValue operation(VirtualMachine vm, Token token,
                            LValue rightL, LValue leftL,
                            ExpressionParser.GetFrame frameGetter
                            ) throws ParseException {
<span class="nc" id="L963">        String op = token.image;</span>
<span class="nc" id="L964">        Value right = rightL.interiorGetValue();</span>
<span class="nc" id="L965">        Value left = leftL.interiorGetValue();</span>
<span class="nc bnc" id="L966" title="All 4 branches missed.">        if ((right instanceof StringReference) ||</span>
                              (left instanceof StringReference)) {
<span class="nc bnc" id="L968" title="All 2 branches missed.">            if (op.equals(&quot;+&quot;)) {</span>
                // If one is an ObjectRef, we will need to invoke
                // toString on it, so we need the thread.
<span class="nc" id="L971">                return make(vm, stringValue(rightL, frameGetter) +</span>
<span class="nc" id="L972">                            stringValue(leftL, frameGetter));</span>
            }
        }
<span class="nc bnc" id="L975" title="All 4 branches missed.">        if ((right instanceof ObjectReference) ||</span>
                              (left instanceof ObjectReference)) {
<span class="nc bnc" id="L977" title="All 2 branches missed.">            if (op.equals(&quot;==&quot;)) {</span>
<span class="nc" id="L978">                return make(vm, right.equals(left));</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">            } else if (op.equals(&quot;!=&quot;)) {</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">                return make(vm, !right.equals(left));</span>
            } else {
<span class="nc" id="L982">                throw new ParseException(&quot;Invalid operation '&quot; +</span>
                                         op + &quot;' on an Object&quot;);
            }
        }
<span class="nc bnc" id="L986" title="All 4 branches missed.">        if ((right instanceof BooleanValue) ||</span>
                              (left instanceof BooleanValue)) {
<span class="nc" id="L988">            throw new ParseException(&quot;Invalid operation '&quot; +</span>
                                     op + &quot;' on a Boolean&quot;);
        }
        // from here on, we know it is a integer kind of type
<span class="nc" id="L992">        PrimitiveValue primRight = (PrimitiveValue)right;</span>
<span class="nc" id="L993">        PrimitiveValue primLeft = (PrimitiveValue)left;</span>
<span class="nc bnc" id="L994" title="All 4 branches missed.">        if ((primRight instanceof DoubleValue) ||</span>
                              (primLeft instanceof DoubleValue)) {
<span class="nc" id="L996">            double rr = primRight.doubleValue();</span>
<span class="nc" id="L997">            double ll = primLeft.doubleValue();</span>
            double res;
<span class="nc bnc" id="L999" title="All 2 branches missed.">            if (op.equals(&quot;+&quot;)) {</span>
<span class="nc" id="L1000">                res = rr + ll;</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            } else if (op.equals(&quot;-&quot;)) {</span>
<span class="nc" id="L1002">                res = rr - ll;</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">            } else if (op.equals(&quot;*&quot;)) {</span>
<span class="nc" id="L1004">                res = rr * ll;</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            } else if (op.equals(&quot;/&quot;)) {</span>
<span class="nc" id="L1006">                res = rr / ll;</span>
            } else {
<span class="nc" id="L1008">                throw new ParseException(&quot;Unknown operation: &quot; + op);</span>
            }
<span class="nc" id="L1010">            return make(vm, res);</span>
        }
<span class="nc bnc" id="L1012" title="All 4 branches missed.">        if ((primRight instanceof FloatValue) ||</span>
                              (primLeft instanceof FloatValue)) {
<span class="nc" id="L1014">            float rr = primRight.floatValue();</span>
<span class="nc" id="L1015">            float ll = primLeft.floatValue();</span>
            float res;
<span class="nc bnc" id="L1017" title="All 2 branches missed.">            if (op.equals(&quot;+&quot;)) {</span>
<span class="nc" id="L1018">                res = rr + ll;</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">            } else if (op.equals(&quot;-&quot;)) {</span>
<span class="nc" id="L1020">                res = rr - ll;</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">            } else if (op.equals(&quot;*&quot;)) {</span>
<span class="nc" id="L1022">                res = rr * ll;</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">            } else if (op.equals(&quot;/&quot;)) {</span>
<span class="nc" id="L1024">                res = rr / ll;</span>
            } else {
<span class="nc" id="L1026">                throw new ParseException(&quot;Unknown operation: &quot; + op);</span>
            }
<span class="nc" id="L1028">            return make(vm, res);</span>
        }
<span class="nc bnc" id="L1030" title="All 4 branches missed.">        if ((primRight instanceof LongValue) ||</span>
                              (primLeft instanceof LongValue)) {
<span class="nc" id="L1032">            long rr = primRight.longValue();</span>
<span class="nc" id="L1033">            long ll = primLeft.longValue();</span>
            long res;
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            if (op.equals(&quot;+&quot;)) {</span>
<span class="nc" id="L1036">                res = rr + ll;</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            } else if (op.equals(&quot;-&quot;)) {</span>
<span class="nc" id="L1038">                res = rr - ll;</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            } else if (op.equals(&quot;*&quot;)) {</span>
<span class="nc" id="L1040">                res = rr * ll;</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">            } else if (op.equals(&quot;/&quot;)) {</span>
<span class="nc" id="L1042">                res = rr / ll;</span>
            } else {
<span class="nc" id="L1044">                throw new ParseException(&quot;Unknown operation: &quot; + op);</span>
            }
<span class="nc" id="L1046">            return make(vm, res);</span>
        } else {
<span class="nc" id="L1048">            int rr = primRight.intValue();</span>
<span class="nc" id="L1049">            int ll = primLeft.intValue();</span>
            int res;
<span class="nc bnc" id="L1051" title="All 2 branches missed.">            if (op.equals(&quot;+&quot;)) {</span>
<span class="nc" id="L1052">                res = rr + ll;</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">            } else if (op.equals(&quot;-&quot;)) {</span>
<span class="nc" id="L1054">                res = rr - ll;</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">            } else if (op.equals(&quot;*&quot;)) {</span>
<span class="nc" id="L1056">                res = rr * ll;</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">            } else if (op.equals(&quot;/&quot;)) {</span>
<span class="nc" id="L1058">                res = rr / ll;</span>
            } else {
<span class="nc" id="L1060">                throw new ParseException(&quot;Unknown operation: &quot; + op);</span>
            }
<span class="nc" id="L1062">            return make(vm, res);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>