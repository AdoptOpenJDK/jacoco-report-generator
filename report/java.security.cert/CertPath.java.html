<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CertPath.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security.cert</a> &gt; <span class="el_source">CertPath.java</span></div><h1>CertPath.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security.cert;

import java.io.ByteArrayInputStream;
import java.io.NotSerializableException;
import java.io.ObjectStreamException;
import java.io.Serializable;
import java.util.Iterator;
import java.util.List;

/**
 * An immutable sequence of certificates (a certification path).
 * &lt;p&gt;
 * This is an abstract class that defines the methods common to all
 * {@code CertPath}s. Subclasses can handle different kinds of
 * certificates (X.509, PGP, etc.).
 * &lt;p&gt;
 * All {@code CertPath} objects have a type, a list of
 * {@code Certificate}s, and one or more supported encodings. Because the
 * {@code CertPath} class is immutable, a {@code CertPath} cannot
 * change in any externally visible way after being constructed. This
 * stipulation applies to all public fields and methods of this class and any
 * added or overridden by subclasses.
 * &lt;p&gt;
 * The type is a {@code String} that identifies the type of
 * {@code Certificate}s in the certification path. For each
 * certificate {@code cert} in a certification path {@code certPath},
 * {@code cert.getType().equals(certPath.getType())} must be
 * {@code true}.
 * &lt;p&gt;
 * The list of {@code Certificate}s is an ordered {@code List} of
 * zero or more {@code Certificate}s. This {@code List} and all
 * of the {@code Certificate}s contained in it must be immutable.
 * &lt;p&gt;
 * Each {@code CertPath} object must support one or more encodings
 * so that the object can be translated into a byte array for storage or
 * transmission to other parties. Preferably, these encodings should be
 * well-documented standards (such as PKCS#7). One of the encodings supported
 * by a {@code CertPath} is considered the default encoding. This
 * encoding is used if no encoding is explicitly requested (for the
 * {@link #getEncoded() getEncoded()} method, for instance).
 * &lt;p&gt;
 * All {@code CertPath} objects are also {@code Serializable}.
 * {@code CertPath} objects are resolved into an alternate
 * {@link CertPathRep CertPathRep} object during serialization. This allows
 * a {@code CertPath} object to be serialized into an equivalent
 * representation regardless of its underlying implementation.
 * &lt;p&gt;
 * {@code CertPath} objects can be created with a
 * {@code CertificateFactory} or they can be returned by other classes,
 * such as a {@code CertPathBuilder}.
 * &lt;p&gt;
 * By convention, X.509 {@code CertPath}s (consisting of
 * {@code X509Certificate}s), are ordered starting with the target
 * certificate and ending with a certificate issued by the trust anchor. That
 * is, the issuer of one certificate is the subject of the following one. The
 * certificate representing the {@link TrustAnchor TrustAnchor} should not be
 * included in the certification path. Unvalidated X.509 {@code CertPath}s
 * may not follow these conventions. PKIX {@code CertPathValidator}s will
 * detect any departure from these conventions that cause the certification
 * path to be invalid and throw a {@code CertPathValidatorException}.
 *
 * &lt;p&gt; Every implementation of the Java platform is required to support the
 * following standard {@code CertPath} encodings:
 * &lt;ul&gt;
 * &lt;li&gt;{@code PKCS7}&lt;/li&gt;
 * &lt;li&gt;{@code PkiPath}&lt;/li&gt;
 * &lt;/ul&gt;
 * These encodings are described in the &lt;a href=
 * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#CertPathEncodings&quot;&gt;
 * CertPath Encodings section&lt;/a&gt; of the
 * Java Cryptography Architecture Standard Algorithm Name Documentation.
 * Consult the release documentation for your implementation to see if any
 * other encodings are supported.
 * &lt;p&gt;
 * &lt;b&gt;Concurrent Access&lt;/b&gt;
 * &lt;p&gt;
 * All {@code CertPath} objects must be thread-safe. That is, multiple
 * threads may concurrently invoke the methods defined in this class on a
 * single {@code CertPath} object (or more than one) with no
 * ill effects. This is also true for the {@code List} returned by
 * {@code CertPath.getCertificates}.
 * &lt;p&gt;
 * Requiring {@code CertPath} objects to be immutable and thread-safe
 * allows them to be passed around to various pieces of code without worrying
 * about coordinating access.  Providing this thread-safety is
 * generally not difficult, since the {@code CertPath} and
 * {@code List} objects in question are immutable.
 *
 * @see CertificateFactory
 * @see CertPathBuilder
 *
 * @author      Yassir Elley
 * @since       1.4
 */
public abstract class CertPath implements Serializable {

    private static final long serialVersionUID = 6068470306649138683L;

    private String type;        // the type of certificates in this chain

    /**
     * Creates a {@code CertPath} of the specified type.
     * &lt;p&gt;
     * This constructor is protected because most users should use a
     * {@code CertificateFactory} to create {@code CertPath}s.
     *
     * @param type the standard name of the type of
     * {@code Certificate}s in this path
     */
<span class="fc" id="L135">    protected CertPath(String type) {</span>
<span class="fc" id="L136">        this.type = type;</span>
<span class="fc" id="L137">    }</span>

    /**
     * Returns the type of {@code Certificate}s in this certification
     * path. This is the same string that would be returned by
     * {@link java.security.cert.Certificate#getType() cert.getType()}
     * for all {@code Certificate}s in the certification path.
     *
     * @return the type of {@code Certificate}s in this certification
     * path (never null)
     */
    public String getType() {
<span class="fc" id="L149">        return type;</span>
    }

    /**
     * Returns an iteration of the encodings supported by this certification
     * path, with the default encoding first. Attempts to modify the returned
     * {@code Iterator} via its {@code remove} method result in an
     * {@code UnsupportedOperationException}.
     *
     * @return an {@code Iterator} over the names of the supported
     *         encodings (as Strings)
     */
    public abstract Iterator&lt;String&gt; getEncodings();

    /**
     * Compares this certification path for equality with the specified
     * object. Two {@code CertPath}s are equal if and only if their
     * types are equal and their certificate {@code List}s (and by
     * implication the {@code Certificate}s in those {@code List}s)
     * are equal. A {@code CertPath} is never equal to an object that is
     * not a {@code CertPath}.
     * &lt;p&gt;
     * This algorithm is implemented by this method. If it is overridden,
     * the behavior specified here must be maintained.
     *
     * @param other the object to test for equality with this certification path
     * @return true if the specified object is equal to this certification path,
     * false otherwise
     */
    public boolean equals(Object other) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (this == other)</span>
<span class="nc" id="L180">            return true;</span>

<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (! (other instanceof CertPath))</span>
<span class="nc" id="L183">            return false;</span>

<span class="nc" id="L185">        CertPath otherCP = (CertPath) other;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (! otherCP.getType().equals(type))</span>
<span class="nc" id="L187">            return false;</span>

<span class="nc" id="L189">        List&lt;? extends Certificate&gt; thisCertList = this.getCertificates();</span>
<span class="nc" id="L190">        List&lt;? extends Certificate&gt; otherCertList = otherCP.getCertificates();</span>
<span class="nc" id="L191">        return(thisCertList.equals(otherCertList));</span>
    }

    /**
     * Returns the hashcode for this certification path. The hash code of
     * a certification path is defined to be the result of the following
     * calculation:
     * &lt;pre&gt;{@code
     *  hashCode = path.getType().hashCode();
     *  hashCode = 31*hashCode + path.getCertificates().hashCode();
     * }&lt;/pre&gt;
     * This ensures that {@code path1.equals(path2)} implies that
     * {@code path1.hashCode()==path2.hashCode()} for any two certification
     * paths, {@code path1} and {@code path2}, as required by the
     * general contract of {@code Object.hashCode}.
     *
     * @return the hashcode value for this certification path
     */
    public int hashCode() {
<span class="nc" id="L210">        int hashCode = type.hashCode();</span>
<span class="nc" id="L211">        hashCode = 31*hashCode + getCertificates().hashCode();</span>
<span class="nc" id="L212">        return hashCode;</span>
    }

    /**
     * Returns a string representation of this certification path.
     * This calls the {@code toString} method on each of the
     * {@code Certificate}s in the path.
     *
     * @return a string representation of this certification path
     */
    public String toString() {
<span class="nc" id="L223">        StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L224">        Iterator&lt;? extends Certificate&gt; stringIterator =</span>
<span class="nc" id="L225">                                        getCertificates().iterator();</span>

<span class="nc" id="L227">        sb.append(&quot;\n&quot; + type + &quot; Cert Path: length = &quot;</span>
<span class="nc" id="L228">            + getCertificates().size() + &quot;.\n&quot;);</span>
<span class="nc" id="L229">        sb.append(&quot;[\n&quot;);</span>
<span class="nc" id="L230">        int i = 1;</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">        while (stringIterator.hasNext()) {</span>
<span class="nc" id="L232">            sb.append(&quot;==========================================&quot;</span>
                + &quot;===============Certificate &quot; + i + &quot; start.\n&quot;);
<span class="nc" id="L234">            Certificate stringCert = stringIterator.next();</span>
<span class="nc" id="L235">            sb.append(stringCert.toString());</span>
<span class="nc" id="L236">            sb.append(&quot;\n========================================&quot;</span>
                + &quot;=================Certificate &quot; + i + &quot; end.\n\n\n&quot;);
<span class="nc" id="L238">            i++;</span>
<span class="nc" id="L239">        }</span>

<span class="nc" id="L241">        sb.append(&quot;\n]&quot;);</span>
<span class="nc" id="L242">        return sb.toString();</span>
    }

    /**
     * Returns the encoded form of this certification path, using the default
     * encoding.
     *
     * @return the encoded bytes
     * @exception CertificateEncodingException if an encoding error occurs
     */
    public abstract byte[] getEncoded()
        throws CertificateEncodingException;

    /**
     * Returns the encoded form of this certification path, using the
     * specified encoding.
     *
     * @param encoding the name of the encoding to use
     * @return the encoded bytes
     * @exception CertificateEncodingException if an encoding error occurs or
     *   the encoding requested is not supported
     */
    public abstract byte[] getEncoded(String encoding)
        throws CertificateEncodingException;

    /**
     * Returns the list of certificates in this certification path.
     * The {@code List} returned must be immutable and thread-safe.
     *
     * @return an immutable {@code List} of {@code Certificate}s
     *         (may be empty, but not null)
     */
    public abstract List&lt;? extends Certificate&gt; getCertificates();

    /**
     * Replaces the {@code CertPath} to be serialized with a
     * {@code CertPathRep} object.
     *
     * @return the {@code CertPathRep} to be serialized
     *
     * @throws ObjectStreamException if a {@code CertPathRep} object
     * representing this certification path could not be created
     */
    protected Object writeReplace() throws ObjectStreamException {
        try {
<span class="nc" id="L287">            return new CertPathRep(type, getEncoded());</span>
<span class="nc" id="L288">        } catch (CertificateException ce) {</span>
<span class="nc" id="L289">            NotSerializableException nse =</span>
                new NotSerializableException
                    (&quot;java.security.cert.CertPath: &quot; + type);
<span class="nc" id="L292">            nse.initCause(ce);</span>
<span class="nc" id="L293">            throw nse;</span>
        }
    }

    /**
     * Alternate {@code CertPath} class for serialization.
     * @since 1.4
     */
    protected static class CertPathRep implements Serializable {

        private static final long serialVersionUID = 3015633072427920915L;

        /** The Certificate type */
        private String type;
        /** The encoded form of the cert path */
        private byte[] data;

        /**
         * Creates a {@code CertPathRep} with the specified
         * type and encoded form of a certification path.
         *
         * @param type the standard name of a {@code CertPath} type
         * @param data the encoded form of the certification path
         */
<span class="nc" id="L317">        protected CertPathRep(String type, byte[] data) {</span>
<span class="nc" id="L318">            this.type = type;</span>
<span class="nc" id="L319">            this.data = data;</span>
<span class="nc" id="L320">        }</span>

        /**
         * Returns a {@code CertPath} constructed from the type and data.
         *
         * @return the resolved {@code CertPath} object
         *
         * @throws ObjectStreamException if a {@code CertPath} could not
         * be constructed
         */
        protected Object readResolve() throws ObjectStreamException {
            try {
<span class="nc" id="L332">                CertificateFactory cf = CertificateFactory.getInstance(type);</span>
<span class="nc" id="L333">                return cf.generateCertPath(new ByteArrayInputStream(data));</span>
<span class="nc" id="L334">            } catch (CertificateException ce) {</span>
<span class="nc" id="L335">                NotSerializableException nse =</span>
                    new NotSerializableException
                        (&quot;java.security.cert.CertPath: &quot; + type);
<span class="nc" id="L338">                nse.initCause(ce);</span>
<span class="nc" id="L339">                throw nse;</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>