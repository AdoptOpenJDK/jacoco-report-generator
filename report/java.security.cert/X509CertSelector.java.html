<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>X509CertSelector.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security.cert</a> &gt; <span class="el_source">X509CertSelector.java</span></div><h1>X509CertSelector.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security.cert;

import java.io.IOException;
import java.math.BigInteger;
import java.security.PublicKey;
import java.util.*;
import javax.security.auth.x500.X500Principal;

import sun.misc.HexDumpEncoder;
import sun.security.util.Debug;
import sun.security.util.DerInputStream;
import sun.security.util.DerValue;
import sun.security.util.ObjectIdentifier;
import sun.security.x509.*;

/**
 * A {@code CertSelector} that selects {@code X509Certificates} that
 * match all specified criteria. This class is particularly useful when
 * selecting certificates from a {@code CertStore} to build a
 * PKIX-compliant certification path.
 * &lt;p&gt;
 * When first constructed, an {@code X509CertSelector} has no criteria
 * enabled and each of the {@code get} methods return a default value
 * ({@code null}, or {@code -1} for the {@link #getBasicConstraints
 * getBasicConstraints} method). Therefore, the {@link #match match}
 * method would return {@code true} for any {@code X509Certificate}.
 * Typically, several criteria are enabled (by calling
 * {@link #setIssuer setIssuer} or
 * {@link #setKeyUsage setKeyUsage}, for instance) and then the
 * {@code X509CertSelector} is passed to
 * {@link CertStore#getCertificates CertStore.getCertificates} or some similar
 * method.
 * &lt;p&gt;
 * Several criteria can be enabled (by calling {@link #setIssuer setIssuer}
 * and {@link #setSerialNumber setSerialNumber},
 * for example) such that the {@code match} method
 * usually uniquely matches a single {@code X509Certificate}. We say
 * usually, since it is possible for two issuing CAs to have the same
 * distinguished name and each issue a certificate with the same serial
 * number. Other unique combinations include the issuer, subject,
 * subjectKeyIdentifier and/or the subjectPublicKey criteria.
 * &lt;p&gt;
 * Please refer to &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280.txt&quot;&gt;RFC 3280:
 * Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt; for
 * definitions of the X.509 certificate extensions mentioned below.
 * &lt;p&gt;
 * &lt;b&gt;Concurrent Access&lt;/b&gt;
 * &lt;p&gt;
 * Unless otherwise specified, the methods defined in this class are not
 * thread-safe. Multiple threads that need to access a single
 * object concurrently should synchronize amongst themselves and
 * provide the necessary locking. Multiple threads each manipulating
 * separate objects need not synchronize.
 *
 * @see CertSelector
 * @see X509Certificate
 *
 * @since       1.4
 * @author      Steve Hanna
 */
public class X509CertSelector implements CertSelector {

<span class="fc" id="L88">    private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);</span>

<span class="fc" id="L90">    private final static ObjectIdentifier ANY_EXTENDED_KEY_USAGE =</span>
<span class="fc" id="L91">        ObjectIdentifier.newInternal(new int[] {2, 5, 29, 37, 0});</span>

    static {
<span class="fc" id="L94">        CertPathHelperImpl.initialize();</span>
    }

    private BigInteger serialNumber;
    private X500Principal issuer;
    private X500Principal subject;
    private byte[] subjectKeyID;
    private byte[] authorityKeyID;
    private Date certificateValid;
    private Date privateKeyValid;
    private ObjectIdentifier subjectPublicKeyAlgID;
    private PublicKey subjectPublicKey;
    private byte[] subjectPublicKeyBytes;
    private boolean[] keyUsage;
    private Set&lt;String&gt; keyPurposeSet;
    private Set&lt;ObjectIdentifier&gt; keyPurposeOIDSet;
    private Set&lt;List&lt;?&gt;&gt; subjectAlternativeNames;
    private Set&lt;GeneralNameInterface&gt; subjectAlternativeGeneralNames;
    private CertificatePolicySet policy;
    private Set&lt;String&gt; policySet;
    private Set&lt;List&lt;?&gt;&gt; pathToNames;
    private Set&lt;GeneralNameInterface&gt; pathToGeneralNames;
    private NameConstraintsExtension nc;
    private byte[] ncBytes;
<span class="fc" id="L118">    private int basicConstraints = -1;</span>
    private X509Certificate x509Cert;
<span class="fc" id="L120">    private boolean matchAllSubjectAltNames = true;</span>

<span class="fc" id="L122">    private static final Boolean FALSE = Boolean.FALSE;</span>

    private static final int PRIVATE_KEY_USAGE_ID = 0;
    private static final int SUBJECT_ALT_NAME_ID = 1;
    private static final int NAME_CONSTRAINTS_ID = 2;
    private static final int CERT_POLICIES_ID = 3;
    private static final int EXTENDED_KEY_USAGE_ID = 4;
    private static final int NUM_OF_EXTENSIONS = 5;
<span class="fc" id="L130">    private static final String[] EXTENSION_OIDS = new String[NUM_OF_EXTENSIONS];</span>

    static {
<span class="fc" id="L133">        EXTENSION_OIDS[PRIVATE_KEY_USAGE_ID]  = &quot;2.5.29.16&quot;;</span>
<span class="fc" id="L134">        EXTENSION_OIDS[SUBJECT_ALT_NAME_ID]   = &quot;2.5.29.17&quot;;</span>
<span class="fc" id="L135">        EXTENSION_OIDS[NAME_CONSTRAINTS_ID]   = &quot;2.5.29.30&quot;;</span>
<span class="fc" id="L136">        EXTENSION_OIDS[CERT_POLICIES_ID]      = &quot;2.5.29.32&quot;;</span>
<span class="fc" id="L137">        EXTENSION_OIDS[EXTENDED_KEY_USAGE_ID] = &quot;2.5.29.37&quot;;</span>
<span class="fc" id="L138">    };</span>

    /* Constants representing the GeneralName types */
    static final int NAME_ANY = 0;
    static final int NAME_RFC822 = 1;
    static final int NAME_DNS = 2;
    static final int NAME_X400 = 3;
    static final int NAME_DIRECTORY = 4;
    static final int NAME_EDI = 5;
    static final int NAME_URI = 6;
    static final int NAME_IP = 7;
    static final int NAME_OID = 8;

    /**
     * Creates an {@code X509CertSelector}. Initially, no criteria are set
     * so any {@code X509Certificate} will match.
     */
<span class="fc" id="L155">    public X509CertSelector() {</span>
        // empty
<span class="fc" id="L157">    }</span>

    /**
     * Sets the certificateEquals criterion. The specified
     * {@code X509Certificate} must be equal to the
     * {@code X509Certificate} passed to the {@code match} method.
     * If {@code null}, then this check is not applied.
     *
     * &lt;p&gt;This method is particularly useful when it is necessary to
     * match a single certificate. Although other criteria can be specified
     * in conjunction with the certificateEquals criterion, it is usually not
     * practical or necessary.
     *
     * @param cert the {@code X509Certificate} to match (or
     * {@code null})
     * @see #getCertificate
     */
    public void setCertificate(X509Certificate cert) {
<span class="fc" id="L175">        x509Cert = cert;</span>
<span class="fc" id="L176">    }</span>

    /**
     * Sets the serialNumber criterion. The specified serial number
     * must match the certificate serial number in the
     * {@code X509Certificate}. If {@code null}, any certificate
     * serial number will do.
     *
     * @param serial the certificate serial number to match
     *        (or {@code null})
     * @see #getSerialNumber
     */
    public void setSerialNumber(BigInteger serial) {
<span class="fc" id="L189">        serialNumber = serial;</span>
<span class="fc" id="L190">    }</span>

    /**
     * Sets the issuer criterion. The specified distinguished name
     * must match the issuer distinguished name in the
     * {@code X509Certificate}. If {@code null}, any issuer
     * distinguished name will do.
     *
     * @param issuer a distinguished name as X500Principal
     *                 (or {@code null})
     * @since 1.5
     */
    public void setIssuer(X500Principal issuer) {
<span class="nc" id="L203">        this.issuer = issuer;</span>
<span class="nc" id="L204">    }</span>

    /**
     * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #setIssuer(X500Principal)}
     * or {@linkplain #setIssuer(byte[])} instead. This method should not be
     * relied on as it can fail to match some certificates because of a loss of
     * encoding information in the
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; String form
     * of some distinguished names.
     * &lt;p&gt;
     * Sets the issuer criterion. The specified distinguished name
     * must match the issuer distinguished name in the
     * {@code X509Certificate}. If {@code null}, any issuer
     * distinguished name will do.
     * &lt;p&gt;
     * If {@code issuerDN} is not {@code null}, it should contain a
     * distinguished name, in RFC 2253 format.
     *
     * @param issuerDN a distinguished name in RFC 2253 format
     *                 (or {@code null})
     * @throws IOException if a parsing error occurs (incorrect form for DN)
     */
    public void setIssuer(String issuerDN) throws IOException {
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (issuerDN == null) {</span>
<span class="nc" id="L228">            issuer = null;</span>
        } else {
<span class="nc" id="L230">            issuer = new X500Name(issuerDN).asX500Principal();</span>
        }
<span class="nc" id="L232">    }</span>

    /**
     * Sets the issuer criterion. The specified distinguished name
     * must match the issuer distinguished name in the
     * {@code X509Certificate}. If {@code null} is specified,
     * the issuer criterion is disabled and any issuer distinguished name will
     * do.
     * &lt;p&gt;
     * If {@code issuerDN} is not {@code null}, it should contain a
     * single DER encoded distinguished name, as defined in X.501. The ASN.1
     * notation for this structure is as follows.
     * &lt;pre&gt;{@code
     * Name ::= CHOICE {
     *   RDNSequence }
     *
     * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
     *
     * RelativeDistinguishedName ::=
     *   SET SIZE (1 .. MAX) OF AttributeTypeAndValue
     *
     * AttributeTypeAndValue ::= SEQUENCE {
     *   type     AttributeType,
     *   value    AttributeValue }
     *
     * AttributeType ::= OBJECT IDENTIFIER
     *
     * AttributeValue ::= ANY DEFINED BY AttributeType
     * ....
     * DirectoryString ::= CHOICE {
     *       teletexString           TeletexString (SIZE (1..MAX)),
     *       printableString         PrintableString (SIZE (1..MAX)),
     *       universalString         UniversalString (SIZE (1..MAX)),
     *       utf8String              UTF8String (SIZE (1.. MAX)),
     *       bmpString               BMPString (SIZE (1..MAX)) }
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Note that the byte array specified here is cloned to protect against
     * subsequent modifications.
     *
     * @param issuerDN a byte array containing the distinguished name
     *                 in ASN.1 DER encoded form (or {@code null})
     * @throws IOException if an encoding error occurs (incorrect form for DN)
     */
    public void setIssuer(byte[] issuerDN) throws IOException {
        try {
<span class="nc bnc" id="L278" title="All 2 branches missed.">            issuer = (issuerDN == null ? null : new X500Principal(issuerDN));</span>
<span class="nc" id="L279">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L280">            throw new IOException(&quot;Invalid name&quot;, e);</span>
<span class="nc" id="L281">        }</span>
<span class="nc" id="L282">    }</span>

    /**
     * Sets the subject criterion. The specified distinguished name
     * must match the subject distinguished name in the
     * {@code X509Certificate}. If {@code null}, any subject
     * distinguished name will do.
     *
     * @param subject a distinguished name as X500Principal
     *                  (or {@code null})
     * @since 1.5
     */
    public void setSubject(X500Principal subject) {
<span class="fc" id="L295">        this.subject = subject;</span>
<span class="fc" id="L296">    }</span>

    /**
     * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #setSubject(X500Principal)}
     * or {@linkplain #setSubject(byte[])} instead. This method should not be
     * relied on as it can fail to match some certificates because of a loss of
     * encoding information in the RFC 2253 String form of some distinguished
     * names.
     * &lt;p&gt;
     * Sets the subject criterion. The specified distinguished name
     * must match the subject distinguished name in the
     * {@code X509Certificate}. If {@code null}, any subject
     * distinguished name will do.
     * &lt;p&gt;
     * If {@code subjectDN} is not {@code null}, it should contain a
     * distinguished name, in RFC 2253 format.
     *
     * @param subjectDN a distinguished name in RFC 2253 format
     *                  (or {@code null})
     * @throws IOException if a parsing error occurs (incorrect form for DN)
     */
    public void setSubject(String subjectDN) throws IOException {
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (subjectDN == null) {</span>
<span class="nc" id="L319">            subject = null;</span>
        } else {
<span class="nc" id="L321">            subject = new X500Name(subjectDN).asX500Principal();</span>
        }
<span class="nc" id="L323">    }</span>

    /**
     * Sets the subject criterion. The specified distinguished name
     * must match the subject distinguished name in the
     * {@code X509Certificate}. If {@code null}, any subject
     * distinguished name will do.
     * &lt;p&gt;
     * If {@code subjectDN} is not {@code null}, it should contain a
     * single DER encoded distinguished name, as defined in X.501. For the ASN.1
     * notation for this structure, see
     * {@link #setIssuer(byte [] issuerDN) setIssuer(byte [] issuerDN)}.
     *
     * @param subjectDN a byte array containing the distinguished name in
     *                  ASN.1 DER format (or {@code null})
     * @throws IOException if an encoding error occurs (incorrect form for DN)
     */
    public void setSubject(byte[] subjectDN) throws IOException {
        try {
<span class="nc bnc" id="L342" title="All 2 branches missed.">            subject = (subjectDN == null ? null : new X500Principal(subjectDN));</span>
<span class="nc" id="L343">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L344">            throw new IOException(&quot;Invalid name&quot;, e);</span>
<span class="nc" id="L345">        }</span>
<span class="nc" id="L346">    }</span>

    /**
     * Sets the subjectKeyIdentifier criterion. The
     * {@code X509Certificate} must contain a SubjectKeyIdentifier
     * extension for which the contents of the extension
     * matches the specified criterion value.
     * If the criterion value is {@code null}, no
     * subjectKeyIdentifier check will be done.
     * &lt;p&gt;
     * If {@code subjectKeyID} is not {@code null}, it
     * should contain a single DER encoded value corresponding to the contents
     * of the extension value (not including the object identifier,
     * criticality setting, and encapsulating OCTET STRING)
     * for a SubjectKeyIdentifier extension.
     * The ASN.1 notation for this structure follows.
     *
     * &lt;pre&gt;{@code
     * SubjectKeyIdentifier ::= KeyIdentifier
     *
     * KeyIdentifier ::= OCTET STRING
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Since the format of subject key identifiers is not mandated by
     * any standard, subject key identifiers are not parsed by the
     * {@code X509CertSelector}. Instead, the values are compared using
     * a byte-by-byte comparison.
     * &lt;p&gt;
     * Note that the byte array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param subjectKeyID the subject key identifier (or {@code null})
     * @see #getSubjectKeyIdentifier
     */
    public void setSubjectKeyIdentifier(byte[] subjectKeyID) {
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (subjectKeyID == null) {</span>
<span class="nc" id="L382">            this.subjectKeyID = null;</span>
        } else {
<span class="fc" id="L384">            this.subjectKeyID = subjectKeyID.clone();</span>
        }
<span class="fc" id="L386">    }</span>

    /**
     * Sets the authorityKeyIdentifier criterion. The
     * {@code X509Certificate} must contain an
     * AuthorityKeyIdentifier extension for which the contents of the
     * extension value matches the specified criterion value.
     * If the criterion value is {@code null}, no
     * authorityKeyIdentifier check will be done.
     * &lt;p&gt;
     * If {@code authorityKeyID} is not {@code null}, it
     * should contain a single DER encoded value corresponding to the contents
     * of the extension value (not including the object identifier,
     * criticality setting, and encapsulating OCTET STRING)
     * for an AuthorityKeyIdentifier extension.
     * The ASN.1 notation for this structure follows.
     *
     * &lt;pre&gt;{@code
     * AuthorityKeyIdentifier ::= SEQUENCE {
     *    keyIdentifier             [0] KeyIdentifier           OPTIONAL,
     *    authorityCertIssuer       [1] GeneralNames            OPTIONAL,
     *    authorityCertSerialNumber [2] CertificateSerialNumber OPTIONAL  }
     *
     * KeyIdentifier ::= OCTET STRING
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Authority key identifiers are not parsed by the
     * {@code X509CertSelector}.  Instead, the values are
     * compared using a byte-by-byte comparison.
     * &lt;p&gt;
     * When the {@code keyIdentifier} field of
     * {@code AuthorityKeyIdentifier} is populated, the value is
     * usually taken from the {@code SubjectKeyIdentifier} extension
     * in the issuer's certificate.  Note, however, that the result of
     * {@code X509Certificate.getExtensionValue(&lt;SubjectKeyIdentifier Object
     * Identifier&gt;)} on the issuer's certificate may NOT be used
     * directly as the input to {@code setAuthorityKeyIdentifier}.
     * This is because the SubjectKeyIdentifier contains
     * only a KeyIdentifier OCTET STRING, and not a SEQUENCE of
     * KeyIdentifier, GeneralNames, and CertificateSerialNumber.
     * In order to use the extension value of the issuer certificate's
     * {@code SubjectKeyIdentifier}
     * extension, it will be necessary to extract the value of the embedded
     * {@code KeyIdentifier} OCTET STRING, then DER encode this OCTET
     * STRING inside a SEQUENCE.
     * For more details on SubjectKeyIdentifier, see
     * {@link #setSubjectKeyIdentifier(byte[] subjectKeyID)}.
     * &lt;p&gt;
     * Note also that the byte array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param authorityKeyID the authority key identifier
     *        (or {@code null})
     * @see #getAuthorityKeyIdentifier
     */
    public void setAuthorityKeyIdentifier(byte[] authorityKeyID) {
<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (authorityKeyID == null) {</span>
<span class="nc" id="L443">            this.authorityKeyID = null;</span>
        } else {
<span class="nc" id="L445">            this.authorityKeyID = authorityKeyID.clone();</span>
        }
<span class="nc" id="L447">    }</span>

    /**
     * Sets the certificateValid criterion. The specified date must fall
     * within the certificate validity period for the
     * {@code X509Certificate}. If {@code null}, no certificateValid
     * check will be done.
     * &lt;p&gt;
     * Note that the {@code Date} supplied here is cloned to protect
     * against subsequent modifications.
     *
     * @param certValid the {@code Date} to check (or {@code null})
     * @see #getCertificateValid
     */
    public void setCertificateValid(Date certValid) {
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">        if (certValid == null) {</span>
<span class="nc" id="L463">            certificateValid = null;</span>
        } else {
<span class="fc" id="L465">            certificateValid = (Date)certValid.clone();</span>
        }
<span class="fc" id="L467">    }</span>

    /**
     * Sets the privateKeyValid criterion. The specified date must fall
     * within the private key validity period for the
     * {@code X509Certificate}. If {@code null}, no privateKeyValid
     * check will be done.
     * &lt;p&gt;
     * Note that the {@code Date} supplied here is cloned to protect
     * against subsequent modifications.
     *
     * @param privateKeyValid the {@code Date} to check (or
     *                        {@code null})
     * @see #getPrivateKeyValid
     */
    public void setPrivateKeyValid(Date privateKeyValid) {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (privateKeyValid == null) {</span>
<span class="nc" id="L484">            this.privateKeyValid = null;</span>
        } else {
<span class="nc" id="L486">            this.privateKeyValid = (Date)privateKeyValid.clone();</span>
        }
<span class="nc" id="L488">    }</span>

    /**
     * Sets the subjectPublicKeyAlgID criterion. The
     * {@code X509Certificate} must contain a subject public key
     * with the specified algorithm. If {@code null}, no
     * subjectPublicKeyAlgID check will be done.
     *
     * @param oid The object identifier (OID) of the algorithm to check
     *            for (or {@code null}). An OID is represented by a
     *            set of nonnegative integers separated by periods.
     * @throws IOException if the OID is invalid, such as
     * the first component being not 0, 1 or 2 or the second component
     * being greater than 39.
     *
     * @see #getSubjectPublicKeyAlgID
     */
    public void setSubjectPublicKeyAlgID(String oid) throws IOException {
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (oid == null) {</span>
<span class="nc" id="L507">            subjectPublicKeyAlgID = null;</span>
        } else {
<span class="nc" id="L509">            subjectPublicKeyAlgID = new ObjectIdentifier(oid);</span>
        }
<span class="nc" id="L511">    }</span>

    /**
     * Sets the subjectPublicKey criterion. The
     * {@code X509Certificate} must contain the specified subject public
     * key. If {@code null}, no subjectPublicKey check will be done.
     *
     * @param key the subject public key to check for (or {@code null})
     * @see #getSubjectPublicKey
     */
    public void setSubjectPublicKey(PublicKey key) {
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L523">            subjectPublicKey = null;</span>
<span class="nc" id="L524">            subjectPublicKeyBytes = null;</span>
        } else {
<span class="nc" id="L526">            subjectPublicKey = key;</span>
<span class="nc" id="L527">            subjectPublicKeyBytes = key.getEncoded();</span>
        }
<span class="nc" id="L529">    }</span>

    /**
     * Sets the subjectPublicKey criterion. The {@code X509Certificate}
     * must contain the specified subject public key. If {@code null},
     * no subjectPublicKey check will be done.
     * &lt;p&gt;
     * Because this method allows the public key to be specified as a byte
     * array, it may be used for unknown key types.
     * &lt;p&gt;
     * If {@code key} is not {@code null}, it should contain a
     * single DER encoded SubjectPublicKeyInfo structure, as defined in X.509.
     * The ASN.1 notation for this structure is as follows.
     * &lt;pre&gt;{@code
     * SubjectPublicKeyInfo  ::=  SEQUENCE  {
     *   algorithm            AlgorithmIdentifier,
     *   subjectPublicKey     BIT STRING  }
     *
     * AlgorithmIdentifier  ::=  SEQUENCE  {
     *   algorithm               OBJECT IDENTIFIER,
     *   parameters              ANY DEFINED BY algorithm OPTIONAL  }
     *                              -- contains a value of the type
     *                              -- registered for use with the
     *                              -- algorithm object identifier value
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Note that the byte array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param key a byte array containing the subject public key in ASN.1 DER
     *            form (or {@code null})
     * @throws IOException if an encoding error occurs (incorrect form for
     * subject public key)
     * @see #getSubjectPublicKey
     */
    public void setSubjectPublicKey(byte[] key) throws IOException {
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L566">            subjectPublicKey = null;</span>
<span class="nc" id="L567">            subjectPublicKeyBytes = null;</span>
        } else {
<span class="nc" id="L569">            subjectPublicKeyBytes = key.clone();</span>
<span class="nc" id="L570">            subjectPublicKey = X509Key.parse(new DerValue(subjectPublicKeyBytes));</span>
        }
<span class="nc" id="L572">    }</span>

    /**
     * Sets the keyUsage criterion. The {@code X509Certificate}
     * must allow the specified keyUsage values. If {@code null}, no
     * keyUsage check will be done. Note that an {@code X509Certificate}
     * that has no keyUsage extension implicitly allows all keyUsage values.
     * &lt;p&gt;
     * Note that the boolean array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param keyUsage a boolean array in the same format as the boolean
     *                 array returned by
     * {@link X509Certificate#getKeyUsage() X509Certificate.getKeyUsage()}.
     *                 Or {@code null}.
     * @see #getKeyUsage
     */
    public void setKeyUsage(boolean[] keyUsage) {
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">        if (keyUsage == null) {</span>
<span class="nc" id="L591">            this.keyUsage = null;</span>
        } else {
<span class="fc" id="L593">            this.keyUsage = keyUsage.clone();</span>
        }
<span class="fc" id="L595">    }</span>

    /**
     * Sets the extendedKeyUsage criterion. The {@code X509Certificate}
     * must allow the specified key purposes in its extended key usage
     * extension. If {@code keyPurposeSet} is empty or {@code null},
     * no extendedKeyUsage check will be done. Note that an
     * {@code X509Certificate} that has no extendedKeyUsage extension
     * implicitly allows all key purposes.
     * &lt;p&gt;
     * Note that the {@code Set} is cloned to protect against
     * subsequent modifications.
     *
     * @param keyPurposeSet a {@code Set} of key purpose OIDs in string
     * format (or {@code null}). Each OID is represented by a set of
     * nonnegative integers separated by periods.
     * @throws IOException if the OID is invalid, such as
     * the first component being not 0, 1 or 2 or the second component
     * being greater than 39.
     * @see #getExtendedKeyUsage
     */
    public void setExtendedKeyUsage(Set&lt;String&gt; keyPurposeSet) throws IOException {
<span class="nc bnc" id="L617" title="All 4 branches missed.">        if ((keyPurposeSet == null) || keyPurposeSet.isEmpty()) {</span>
<span class="nc" id="L618">            this.keyPurposeSet = null;</span>
<span class="nc" id="L619">            keyPurposeOIDSet = null;</span>
        } else {
<span class="nc" id="L621">            this.keyPurposeSet =</span>
<span class="nc" id="L622">                Collections.unmodifiableSet(new HashSet&lt;String&gt;(keyPurposeSet));</span>
<span class="nc" id="L623">            keyPurposeOIDSet = new HashSet&lt;ObjectIdentifier&gt;();</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">            for (String s : this.keyPurposeSet) {</span>
<span class="nc" id="L625">                keyPurposeOIDSet.add(new ObjectIdentifier(s));</span>
<span class="nc" id="L626">            }</span>
        }
<span class="nc" id="L628">    }</span>

    /**
     * Enables/disables matching all of the subjectAlternativeNames
     * specified in the {@link #setSubjectAlternativeNames
     * setSubjectAlternativeNames} or {@link #addSubjectAlternativeName
     * addSubjectAlternativeName} methods. If enabled,
     * the {@code X509Certificate} must contain all of the
     * specified subject alternative names. If disabled, the
     * {@code X509Certificate} must contain at least one of the
     * specified subject alternative names.
     *
     * &lt;p&gt;The matchAllNames flag is {@code true} by default.
     *
     * @param matchAllNames if {@code true}, the flag is enabled;
     * if {@code false}, the flag is disabled.
     * @see #getMatchAllSubjectAltNames
     */
    public void setMatchAllSubjectAltNames(boolean matchAllNames) {
<span class="nc" id="L647">        this.matchAllSubjectAltNames = matchAllNames;</span>
<span class="nc" id="L648">    }</span>

    /**
     * Sets the subjectAlternativeNames criterion. The
     * {@code X509Certificate} must contain all or at least one of the
     * specified subjectAlternativeNames, depending on the value of
     * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
     * setMatchAllSubjectAltNames}).
     * &lt;p&gt;
     * This method allows the caller to specify, with a single method call,
     * the complete set of subject alternative names for the
     * subjectAlternativeNames criterion. The specified value replaces
     * the previous value for the subjectAlternativeNames criterion.
     * &lt;p&gt;
     * The {@code names} parameter (if not {@code null}) is a
     * {@code Collection} with one
     * entry for each name to be included in the subject alternative name
     * criterion. Each entry is a {@code List} whose first entry is an
     * {@code Integer} (the name type, 0-8) and whose second
     * entry is a {@code String} or a byte array (the name, in
     * string or ASN.1 DER encoded form, respectively).
     * There can be multiple names of the same type. If {@code null}
     * is supplied as the value for this argument, no
     * subjectAlternativeNames check will be performed.
     * &lt;p&gt;
     * Each subject alternative name in the {@code Collection}
     * may be specified either as a {@code String} or as an ASN.1 encoded
     * byte array. For more details about the formats used, see
     * {@link #addSubjectAlternativeName(int type, String name)
     * addSubjectAlternativeName(int type, String name)} and
     * {@link #addSubjectAlternativeName(int type, byte [] name)
     * addSubjectAlternativeName(int type, byte [] name)}.
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, specify the byte
     * array form instead of the String form. See the note in
     * {@link #addSubjectAlternativeName(int, String)} for more information.
     * &lt;p&gt;
     * Note that the {@code names} parameter can contain duplicate
     * names (same name and name type), but they may be removed from the
     * {@code Collection} of names returned by the
     * {@link #getSubjectAlternativeNames getSubjectAlternativeNames} method.
     * &lt;p&gt;
     * Note that a deep copy is performed on the {@code Collection} to
     * protect against subsequent modifications.
     *
     * @param names a {@code Collection} of names (or {@code null})
     * @throws IOException if a parsing error occurs
     * @see #getSubjectAlternativeNames
     */
    public void setSubjectAlternativeNames(Collection&lt;List&lt;?&gt;&gt; names)
            throws IOException {
<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (names == null) {</span>
<span class="nc" id="L700">            subjectAlternativeNames = null;</span>
<span class="nc" id="L701">            subjectAlternativeGeneralNames = null;</span>
        } else {
<span class="nc bnc" id="L703" title="All 2 branches missed.">            if (names.isEmpty()) {</span>
<span class="nc" id="L704">                subjectAlternativeNames = null;</span>
<span class="nc" id="L705">                subjectAlternativeGeneralNames = null;</span>
<span class="nc" id="L706">                return;</span>
            }
<span class="nc" id="L708">            Set&lt;List&lt;?&gt;&gt; tempNames = cloneAndCheckNames(names);</span>
            // Ensure that we either set both of these or neither
<span class="nc" id="L710">            subjectAlternativeGeneralNames = parseNames(tempNames);</span>
<span class="nc" id="L711">            subjectAlternativeNames = tempNames;</span>
        }
<span class="nc" id="L713">    }</span>

    /**
     * Adds a name to the subjectAlternativeNames criterion. The
     * {@code X509Certificate} must contain all or at least one
     * of the specified subjectAlternativeNames, depending on the value of
     * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
     * setMatchAllSubjectAltNames}).
     * &lt;p&gt;
     * This method allows the caller to add a name to the set of subject
     * alternative names.
     * The specified name is added to any previous value for the
     * subjectAlternativeNames criterion. If the specified name is a
     * duplicate, it may be ignored.
     * &lt;p&gt;
     * The name is provided in string format.
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc822.txt&quot;&gt;RFC 822&lt;/a&gt;, DNS, and URI
     * names use the well-established string formats for those types (subject to
     * the restrictions included in RFC 3280). IPv4 address names are
     * supplied using dotted quad notation. OID address names are represented
     * as a series of nonnegative integers separated by periods. And
     * directory names (distinguished names) are supplied in RFC 2253 format.
     * No standard string format is defined for otherNames, X.400 names,
     * EDI party names, IPv6 address names, or any other type of names. They
     * should be specified using the
     * {@link #addSubjectAlternativeName(int type, byte [] name)
     * addSubjectAlternativeName(int type, byte [] name)}
     * method.
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, use
     * {@linkplain #addSubjectAlternativeName(int, byte[])} instead.
     * This method should not be relied on as it can fail to match some
     * certificates because of a loss of encoding information in the RFC 2253
     * String form of some distinguished names.
     *
     * @param type the name type (0-8, as specified in
     *             RFC 3280, section 4.2.1.7)
     * @param name the name in string form (not {@code null})
     * @throws IOException if a parsing error occurs
     */
    public void addSubjectAlternativeName(int type, String name)
            throws IOException {
<span class="nc" id="L755">        addSubjectAlternativeNameInternal(type, name);</span>
<span class="nc" id="L756">    }</span>

    /**
     * Adds a name to the subjectAlternativeNames criterion. The
     * {@code X509Certificate} must contain all or at least one
     * of the specified subjectAlternativeNames, depending on the value of
     * the matchAllNames flag (see {@link #setMatchAllSubjectAltNames
     * setMatchAllSubjectAltNames}).
     * &lt;p&gt;
     * This method allows the caller to add a name to the set of subject
     * alternative names.
     * The specified name is added to any previous value for the
     * subjectAlternativeNames criterion. If the specified name is a
     * duplicate, it may be ignored.
     * &lt;p&gt;
     * The name is provided as a byte array. This byte array should contain
     * the DER encoded name, as it would appear in the GeneralName structure
     * defined in RFC 3280 and X.509. The encoded byte array should only contain
     * the encoded value of the name, and should not include the tag associated
     * with the name in the GeneralName structure. The ASN.1 definition of this
     * structure appears below.
     * &lt;pre&gt;{@code
     *  GeneralName ::= CHOICE {
     *       otherName                       [0]     OtherName,
     *       rfc822Name                      [1]     IA5String,
     *       dNSName                         [2]     IA5String,
     *       x400Address                     [3]     ORAddress,
     *       directoryName                   [4]     Name,
     *       ediPartyName                    [5]     EDIPartyName,
     *       uniformResourceIdentifier       [6]     IA5String,
     *       iPAddress                       [7]     OCTET STRING,
     *       registeredID                    [8]     OBJECT IDENTIFIER}
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Note that the byte array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param type the name type (0-8, as listed above)
     * @param name a byte array containing the name in ASN.1 DER encoded form
     * @throws IOException if a parsing error occurs
     */
    public void addSubjectAlternativeName(int type, byte[] name)
            throws IOException {
        // clone because byte arrays are modifiable
<span class="nc" id="L800">        addSubjectAlternativeNameInternal(type, name.clone());</span>
<span class="nc" id="L801">    }</span>

    /**
     * A private method that adds a name (String or byte array) to the
     * subjectAlternativeNames criterion. The {@code X509Certificate}
     * must contain the specified subjectAlternativeName.
     *
     * @param type the name type (0-8, as specified in
     *             RFC 3280, section 4.2.1.7)
     * @param name the name in string or byte array form
     * @throws IOException if a parsing error occurs
     */
    private void addSubjectAlternativeNameInternal(int type, Object name)
            throws IOException {
        // First, ensure that the name parses
<span class="nc" id="L816">        GeneralNameInterface tempName = makeGeneralNameInterface(type, name);</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">        if (subjectAlternativeNames == null) {</span>
<span class="nc" id="L818">            subjectAlternativeNames = new HashSet&lt;List&lt;?&gt;&gt;();</span>
        }
<span class="nc bnc" id="L820" title="All 2 branches missed.">        if (subjectAlternativeGeneralNames == null) {</span>
<span class="nc" id="L821">            subjectAlternativeGeneralNames = new HashSet&lt;GeneralNameInterface&gt;();</span>
        }
<span class="nc" id="L823">        List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(2);</span>
<span class="nc" id="L824">        list.add(Integer.valueOf(type));</span>
<span class="nc" id="L825">        list.add(name);</span>
<span class="nc" id="L826">        subjectAlternativeNames.add(list);</span>
<span class="nc" id="L827">        subjectAlternativeGeneralNames.add(tempName);</span>
<span class="nc" id="L828">    }</span>

    /**
     * Parse an argument of the form passed to setSubjectAlternativeNames,
     * returning a {@code Collection} of
     * {@code GeneralNameInterface}s.
     * Throw an IllegalArgumentException or a ClassCastException
     * if the argument is malformed.
     *
     * @param names a Collection with one entry per name.
     *              Each entry is a {@code List} whose first entry
     *              is an Integer (the name type, 0-8) and whose second
     *              entry is a String or a byte array (the name, in
     *              string or ASN.1 DER encoded form, respectively).
     *              There can be multiple names of the same type. Null is
     *              not an acceptable value.
     * @return a Set of {@code GeneralNameInterface}s
     * @throws IOException if a parsing error occurs
     */
    private static Set&lt;GeneralNameInterface&gt; parseNames(Collection&lt;List&lt;?&gt;&gt; names) throws IOException {
<span class="nc" id="L848">        Set&lt;GeneralNameInterface&gt; genNames = new HashSet&lt;GeneralNameInterface&gt;();</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">        for (List&lt;?&gt; nameList : names) {</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">            if (nameList.size() != 2) {</span>
<span class="nc" id="L851">                throw new IOException(&quot;name list size not 2&quot;);</span>
            }
<span class="nc" id="L853">            Object o =  nameList.get(0);</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">            if (!(o instanceof Integer)) {</span>
<span class="nc" id="L855">                throw new IOException(&quot;expected an Integer&quot;);</span>
            }
<span class="nc" id="L857">            int nameType = ((Integer)o).intValue();</span>
<span class="nc" id="L858">            o = nameList.get(1);</span>
<span class="nc" id="L859">            genNames.add(makeGeneralNameInterface(nameType, o));</span>
<span class="nc" id="L860">        }</span>

<span class="nc" id="L862">        return genNames;</span>
    }

    /**
     * Compare for equality two objects of the form passed to
     * setSubjectAlternativeNames (or X509CRLSelector.setIssuerNames).
     * Throw an {@code IllegalArgumentException} or a
     * {@code ClassCastException} if one of the objects is malformed.
     *
     * @param object1 a Collection containing the first object to compare
     * @param object2 a Collection containing the second object to compare
     * @return true if the objects are equal, false otherwise
     */
    static boolean equalNames(Collection&lt;?&gt; object1, Collection&lt;?&gt; object2) {
<span class="nc bnc" id="L876" title="All 4 branches missed.">        if ((object1 == null) || (object2 == null)) {</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">            return object1 == object2;</span>
        }
<span class="nc" id="L879">        return object1.equals(object2);</span>
    }

    /**
     * Make a {@code GeneralNameInterface} out of a name type (0-8) and an
     * Object that may be a byte array holding the ASN.1 DER encoded
     * name or a String form of the name.  Except for X.509
     * Distinguished Names, the String form of the name must not be the
     * result from calling toString on an existing GeneralNameInterface
     * implementing class.  The output of toString is not compatible
     * with the String constructors for names other than Distinguished
     * Names.
     *
     * @param type name type (0-8)
     * @param name name as ASN.1 Der-encoded byte array or String
     * @return a GeneralNameInterface name
     * @throws IOException if a parsing error occurs
     */
    static GeneralNameInterface makeGeneralNameInterface(int type, Object name)
            throws IOException {
        GeneralNameInterface result;
<span class="nc bnc" id="L900" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L901">            debug.println(&quot;X509CertSelector.makeGeneralNameInterface(&quot;</span>
                + type + &quot;)...&quot;);
        }

<span class="nc bnc" id="L905" title="All 2 branches missed.">        if (name instanceof String) {</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L907">                debug.println(&quot;X509CertSelector.makeGeneralNameInterface() &quot;</span>
                    + &quot;name is String: &quot; + name);
            }
<span class="nc bnc" id="L910" title="All 7 branches missed.">            switch (type) {</span>
            case NAME_RFC822:
<span class="nc" id="L912">                result = new RFC822Name((String)name);</span>
<span class="nc" id="L913">                break;</span>
            case NAME_DNS:
<span class="nc" id="L915">                result = new DNSName((String)name);</span>
<span class="nc" id="L916">                break;</span>
            case NAME_DIRECTORY:
<span class="nc" id="L918">                result = new X500Name((String)name);</span>
<span class="nc" id="L919">                break;</span>
            case NAME_URI:
<span class="nc" id="L921">                result = new URIName((String)name);</span>
<span class="nc" id="L922">                break;</span>
            case NAME_IP:
<span class="nc" id="L924">                result = new IPAddressName((String)name);</span>
<span class="nc" id="L925">                break;</span>
            case NAME_OID:
<span class="nc" id="L927">                result = new OIDName((String)name);</span>
<span class="nc" id="L928">                break;</span>
            default:
<span class="nc" id="L930">                throw new IOException(&quot;unable to parse String names of type &quot;</span>
                                      + type);
            }
<span class="nc bnc" id="L933" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L934">                debug.println(&quot;X509CertSelector.makeGeneralNameInterface() &quot;</span>
<span class="nc" id="L935">                    + &quot;result: &quot; + result.toString());</span>
            }
<span class="nc bnc" id="L937" title="All 2 branches missed.">        } else if (name instanceof byte[]) {</span>
<span class="nc" id="L938">            DerValue val = new DerValue((byte[]) name);</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L940">                debug.println</span>
<span class="nc" id="L941">                    (&quot;X509CertSelector.makeGeneralNameInterface() is byte[]&quot;);</span>
            }

<span class="nc bnc" id="L944" title="All 10 branches missed.">            switch (type) {</span>
            case NAME_ANY:
<span class="nc" id="L946">                result = new OtherName(val);</span>
<span class="nc" id="L947">                break;</span>
            case NAME_RFC822:
<span class="nc" id="L949">                result = new RFC822Name(val);</span>
<span class="nc" id="L950">                break;</span>
            case NAME_DNS:
<span class="nc" id="L952">                result = new DNSName(val);</span>
<span class="nc" id="L953">                break;</span>
            case NAME_X400:
<span class="nc" id="L955">                result = new X400Address(val);</span>
<span class="nc" id="L956">                break;</span>
            case NAME_DIRECTORY:
<span class="nc" id="L958">                result = new X500Name(val);</span>
<span class="nc" id="L959">                break;</span>
            case NAME_EDI:
<span class="nc" id="L961">                result = new EDIPartyName(val);</span>
<span class="nc" id="L962">                break;</span>
            case NAME_URI:
<span class="nc" id="L964">                result = new URIName(val);</span>
<span class="nc" id="L965">                break;</span>
            case NAME_IP:
<span class="nc" id="L967">                result = new IPAddressName(val);</span>
<span class="nc" id="L968">                break;</span>
            case NAME_OID:
<span class="nc" id="L970">                result = new OIDName(val);</span>
<span class="nc" id="L971">                break;</span>
            default:
<span class="nc" id="L973">                throw new IOException(&quot;unable to parse byte array names of &quot;</span>
                    + &quot;type &quot; + type);
            }
<span class="nc bnc" id="L976" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L977">                debug.println(&quot;X509CertSelector.makeGeneralNameInterface() result: &quot;</span>
<span class="nc" id="L978">                    + result.toString());</span>
            }
<span class="nc" id="L980">        } else {</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L982">                debug.println(&quot;X509CertSelector.makeGeneralName() input name &quot;</span>
                    + &quot;not String or byte array&quot;);
            }
<span class="nc" id="L985">            throw new IOException(&quot;name not String or byte array&quot;);</span>
        }
<span class="nc" id="L987">        return result;</span>
    }


    /**
     * Sets the name constraints criterion. The {@code X509Certificate}
     * must have subject and subject alternative names that
     * meet the specified name constraints.
     * &lt;p&gt;
     * The name constraints are specified as a byte array. This byte array
     * should contain the DER encoded form of the name constraints, as they
     * would appear in the NameConstraints structure defined in RFC 3280
     * and X.509. The ASN.1 definition of this structure appears below.
     *
     * &lt;pre&gt;{@code
     *  NameConstraints ::= SEQUENCE {
     *       permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
     *       excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
     *
     *  GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
     *
     *  GeneralSubtree ::= SEQUENCE {
     *       base                    GeneralName,
     *       minimum         [0]     BaseDistance DEFAULT 0,
     *       maximum         [1]     BaseDistance OPTIONAL }
     *
     *  BaseDistance ::= INTEGER (0..MAX)
     *
     *  GeneralName ::= CHOICE {
     *       otherName                       [0]     OtherName,
     *       rfc822Name                      [1]     IA5String,
     *       dNSName                         [2]     IA5String,
     *       x400Address                     [3]     ORAddress,
     *       directoryName                   [4]     Name,
     *       ediPartyName                    [5]     EDIPartyName,
     *       uniformResourceIdentifier       [6]     IA5String,
     *       iPAddress                       [7]     OCTET STRING,
     *       registeredID                    [8]     OBJECT IDENTIFIER}
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Note that the byte array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param bytes a byte array containing the ASN.1 DER encoding of
     *              a NameConstraints extension to be used for checking
     *              name constraints. Only the value of the extension is
     *              included, not the OID or criticality flag. Can be
     *              {@code null},
     *              in which case no name constraints check will be performed.
     * @throws IOException if a parsing error occurs
     * @see #getNameConstraints
     */
    public void setNameConstraints(byte[] bytes) throws IOException {
<span class="nc bnc" id="L1040" title="All 2 branches missed.">        if (bytes == null) {</span>
<span class="nc" id="L1041">            ncBytes = null;</span>
<span class="nc" id="L1042">            nc = null;</span>
        } else {
<span class="nc" id="L1044">            ncBytes = bytes.clone();</span>
<span class="nc" id="L1045">            nc = new NameConstraintsExtension(FALSE, bytes);</span>
        }
<span class="nc" id="L1047">    }</span>

    /**
     * Sets the basic constraints constraint. If the value is greater than or
     * equal to zero, {@code X509Certificates} must include a
     * basicConstraints extension with
     * a pathLen of at least this value. If the value is -2, only end-entity
     * certificates are accepted. If the value is -1, no check is done.
     * &lt;p&gt;
     * This constraint is useful when building a certification path forward
     * (from the target toward the trust anchor. If a partial path has been
     * built, any candidate certificate must have a maxPathLen value greater
     * than or equal to the number of certificates in the partial path.
     *
     * @param minMaxPathLen the value for the basic constraints constraint
     * @throws IllegalArgumentException if the value is less than -2
     * @see #getBasicConstraints
     */
    public void setBasicConstraints(int minMaxPathLen) {
<span class="pc bpc" id="L1066" title="1 of 2 branches missed.">        if (minMaxPathLen &lt; -2) {</span>
<span class="nc" id="L1067">            throw new IllegalArgumentException(&quot;basic constraints less than -2&quot;);</span>
        }
<span class="fc" id="L1069">        basicConstraints = minMaxPathLen;</span>
<span class="fc" id="L1070">    }</span>

    /**
     * Sets the policy constraint. The {@code X509Certificate} must
     * include at least one of the specified policies in its certificate
     * policies extension. If {@code certPolicySet} is empty, then the
     * {@code X509Certificate} must include at least some specified policy
     * in its certificate policies extension. If {@code certPolicySet} is
     * {@code null}, no policy check will be performed.
     * &lt;p&gt;
     * Note that the {@code Set} is cloned to protect against
     * subsequent modifications.
     *
     * @param certPolicySet a {@code Set} of certificate policy OIDs in
     *                      string format (or {@code null}). Each OID is
     *                      represented by a set of nonnegative integers
     *                    separated by periods.
     * @throws IOException if a parsing error occurs on the OID such as
     * the first component is not 0, 1 or 2 or the second component is
     * greater than 39.
     * @see #getPolicy
     */
    public void setPolicy(Set&lt;String&gt; certPolicySet) throws IOException {
<span class="nc bnc" id="L1093" title="All 2 branches missed.">        if (certPolicySet == null) {</span>
<span class="nc" id="L1094">            policySet = null;</span>
<span class="nc" id="L1095">            policy = null;</span>
        } else {
            // Snapshot set and parse it
<span class="nc" id="L1098">            Set&lt;String&gt; tempSet = Collections.unmodifiableSet</span>
<span class="nc" id="L1099">                                        (new HashSet&lt;String&gt;(certPolicySet));</span>
            /* Convert to Vector of ObjectIdentifiers */
<span class="nc" id="L1101">            Iterator&lt;String&gt; i = tempSet.iterator();</span>
<span class="nc" id="L1102">            Vector&lt;CertificatePolicyId&gt; polIdVector = new Vector&lt;CertificatePolicyId&gt;();</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">            while (i.hasNext()) {</span>
<span class="nc" id="L1104">                Object o = i.next();</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                if (!(o instanceof String)) {</span>
<span class="nc" id="L1106">                    throw new IOException(&quot;non String in certPolicySet&quot;);</span>
                }
<span class="nc" id="L1108">                polIdVector.add(new CertificatePolicyId(new ObjectIdentifier(</span>
                  (String)o)));
<span class="nc" id="L1110">            }</span>
            // If everything went OK, make the changes
<span class="nc" id="L1112">            policySet = tempSet;</span>
<span class="nc" id="L1113">            policy = new CertificatePolicySet(polIdVector);</span>
        }
<span class="nc" id="L1115">    }</span>

    /**
     * Sets the pathToNames criterion. The {@code X509Certificate} must
     * not include name constraints that would prohibit building a
     * path to the specified names.
     * &lt;p&gt;
     * This method allows the caller to specify, with a single method call,
     * the complete set of names which the {@code X509Certificates}'s
     * name constraints must permit. The specified value replaces
     * the previous value for the pathToNames criterion.
     * &lt;p&gt;
     * This constraint is useful when building a certification path forward
     * (from the target toward the trust anchor. If a partial path has been
     * built, any candidate certificate must not include name constraints that
     * would prohibit building a path to any of the names in the partial path.
     * &lt;p&gt;
     * The {@code names} parameter (if not {@code null}) is a
     * {@code Collection} with one
     * entry for each name to be included in the pathToNames
     * criterion. Each entry is a {@code List} whose first entry is an
     * {@code Integer} (the name type, 0-8) and whose second
     * entry is a {@code String} or a byte array (the name, in
     * string or ASN.1 DER encoded form, respectively).
     * There can be multiple names of the same type. If {@code null}
     * is supplied as the value for this argument, no
     * pathToNames check will be performed.
     * &lt;p&gt;
     * Each name in the {@code Collection}
     * may be specified either as a {@code String} or as an ASN.1 encoded
     * byte array. For more details about the formats used, see
     * {@link #addPathToName(int type, String name)
     * addPathToName(int type, String name)} and
     * {@link #addPathToName(int type, byte [] name)
     * addPathToName(int type, byte [] name)}.
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, specify the byte
     * array form instead of the String form. See the note in
     * {@link #addPathToName(int, String)} for more information.
     * &lt;p&gt;
     * Note that the {@code names} parameter can contain duplicate
     * names (same name and name type), but they may be removed from the
     * {@code Collection} of names returned by the
     * {@link #getPathToNames getPathToNames} method.
     * &lt;p&gt;
     * Note that a deep copy is performed on the {@code Collection} to
     * protect against subsequent modifications.
     *
     * @param names a {@code Collection} with one entry per name
     *              (or {@code null})
     * @throws IOException if a parsing error occurs
     * @see #getPathToNames
     */
    public void setPathToNames(Collection&lt;List&lt;?&gt;&gt; names) throws IOException {
<span class="nc bnc" id="L1169" title="All 4 branches missed.">        if ((names == null) || names.isEmpty()) {</span>
<span class="nc" id="L1170">            pathToNames = null;</span>
<span class="nc" id="L1171">            pathToGeneralNames = null;</span>
        } else {
<span class="nc" id="L1173">            Set&lt;List&lt;?&gt;&gt; tempNames = cloneAndCheckNames(names);</span>
<span class="nc" id="L1174">            pathToGeneralNames = parseNames(tempNames);</span>
            // Ensure that we either set both of these or neither
<span class="nc" id="L1176">            pathToNames = tempNames;</span>
        }
<span class="nc" id="L1178">    }</span>

    // called from CertPathHelper
    void setPathToNamesInternal(Set&lt;GeneralNameInterface&gt; names) {
        // set names to non-null dummy value
        // this breaks getPathToNames()
<span class="fc" id="L1184">        pathToNames = Collections.&lt;List&lt;?&gt;&gt;emptySet();</span>
<span class="fc" id="L1185">        pathToGeneralNames = names;</span>
<span class="fc" id="L1186">    }</span>

    /**
     * Adds a name to the pathToNames criterion. The {@code X509Certificate}
     * must not include name constraints that would prohibit building a
     * path to the specified name.
     * &lt;p&gt;
     * This method allows the caller to add a name to the set of names which
     * the {@code X509Certificates}'s name constraints must permit.
     * The specified name is added to any previous value for the
     * pathToNames criterion.  If the name is a duplicate, it may be ignored.
     * &lt;p&gt;
     * The name is provided in string format. RFC 822, DNS, and URI names
     * use the well-established string formats for those types (subject to
     * the restrictions included in RFC 3280). IPv4 address names are
     * supplied using dotted quad notation. OID address names are represented
     * as a series of nonnegative integers separated by periods. And
     * directory names (distinguished names) are supplied in RFC 2253 format.
     * No standard string format is defined for otherNames, X.400 names,
     * EDI party names, IPv6 address names, or any other type of names. They
     * should be specified using the
     * {@link #addPathToName(int type, byte [] name)
     * addPathToName(int type, byte [] name)} method.
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; for distinguished names, use
     * {@linkplain #addPathToName(int, byte[])} instead.
     * This method should not be relied on as it can fail to match some
     * certificates because of a loss of encoding information in the RFC 2253
     * String form of some distinguished names.
     *
     * @param type the name type (0-8, as specified in
     *             RFC 3280, section 4.2.1.7)
     * @param name the name in string form
     * @throws IOException if a parsing error occurs
     */
    public void addPathToName(int type, String name) throws IOException {
<span class="nc" id="L1222">        addPathToNameInternal(type, name);</span>
<span class="nc" id="L1223">    }</span>

    /**
     * Adds a name to the pathToNames criterion. The {@code X509Certificate}
     * must not include name constraints that would prohibit building a
     * path to the specified name.
     * &lt;p&gt;
     * This method allows the caller to add a name to the set of names which
     * the {@code X509Certificates}'s name constraints must permit.
     * The specified name is added to any previous value for the
     * pathToNames criterion. If the name is a duplicate, it may be ignored.
     * &lt;p&gt;
     * The name is provided as a byte array. This byte array should contain
     * the DER encoded name, as it would appear in the GeneralName structure
     * defined in RFC 3280 and X.509. The ASN.1 definition of this structure
     * appears in the documentation for
     * {@link #addSubjectAlternativeName(int type, byte [] name)
     * addSubjectAlternativeName(int type, byte [] name)}.
     * &lt;p&gt;
     * Note that the byte array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param type the name type (0-8, as specified in
     *             RFC 3280, section 4.2.1.7)
     * @param name a byte array containing the name in ASN.1 DER encoded form
     * @throws IOException if a parsing error occurs
     */
    public void addPathToName(int type, byte [] name) throws IOException {
        // clone because byte arrays are modifiable
<span class="nc" id="L1252">        addPathToNameInternal(type, name.clone());</span>
<span class="nc" id="L1253">    }</span>

    /**
     * A private method that adds a name (String or byte array) to the
     * pathToNames criterion. The {@code X509Certificate} must contain
     * the specified pathToName.
     *
     * @param type the name type (0-8, as specified in
     *             RFC 3280, section 4.2.1.7)
     * @param name the name in string or byte array form
     * @throws IOException if an encoding error occurs (incorrect form for DN)
     */
    private void addPathToNameInternal(int type, Object name)
            throws IOException {
        // First, ensure that the name parses
<span class="nc" id="L1268">        GeneralNameInterface tempName = makeGeneralNameInterface(type, name);</span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">        if (pathToGeneralNames == null) {</span>
<span class="nc" id="L1270">            pathToNames = new HashSet&lt;List&lt;?&gt;&gt;();</span>
<span class="nc" id="L1271">            pathToGeneralNames = new HashSet&lt;GeneralNameInterface&gt;();</span>
        }
<span class="nc" id="L1273">        List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(2);</span>
<span class="nc" id="L1274">        list.add(Integer.valueOf(type));</span>
<span class="nc" id="L1275">        list.add(name);</span>
<span class="nc" id="L1276">        pathToNames.add(list);</span>
<span class="nc" id="L1277">        pathToGeneralNames.add(tempName);</span>
<span class="nc" id="L1278">    }</span>

    /**
     * Returns the certificateEquals criterion. The specified
     * {@code X509Certificate} must be equal to the
     * {@code X509Certificate} passed to the {@code match} method.
     * If {@code null}, this check is not applied.
     *
     * @return the {@code X509Certificate} to match (or {@code null})
     * @see #setCertificate
     */
    public X509Certificate getCertificate() {
<span class="fc" id="L1290">        return x509Cert;</span>
    }

    /**
     * Returns the serialNumber criterion. The specified serial number
     * must match the certificate serial number in the
     * {@code X509Certificate}. If {@code null}, any certificate
     * serial number will do.
     *
     * @return the certificate serial number to match
     *                (or {@code null})
     * @see #setSerialNumber
     */
    public BigInteger getSerialNumber() {
<span class="fc" id="L1304">        return serialNumber;</span>
    }

    /**
     * Returns the issuer criterion as an {@code X500Principal}. This
     * distinguished name must match the issuer distinguished name in the
     * {@code X509Certificate}. If {@code null}, the issuer criterion
     * is disabled and any issuer distinguished name will do.
     *
     * @return the required issuer distinguished name as X500Principal
     *         (or {@code null})
     * @since 1.5
     */
    public X500Principal getIssuer() {
<span class="nc" id="L1318">        return issuer;</span>
    }

    /**
     * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #getIssuer()} or
     * {@linkplain #getIssuerAsBytes()} instead. This method should not be
     * relied on as it can fail to match some certificates because of a loss of
     * encoding information in the RFC 2253 String form of some distinguished
     * names.
     * &lt;p&gt;
     * Returns the issuer criterion as a {@code String}. This
     * distinguished name must match the issuer distinguished name in the
     * {@code X509Certificate}. If {@code null}, the issuer criterion
     * is disabled and any issuer distinguished name will do.
     * &lt;p&gt;
     * If the value returned is not {@code null}, it is a
     * distinguished name, in RFC 2253 format.
     *
     * @return the required issuer distinguished name in RFC 2253 format
     *         (or {@code null})
     */
    public String getIssuerAsString() {
<span class="nc bnc" id="L1340" title="All 2 branches missed.">        return (issuer == null ? null : issuer.getName());</span>
    }

    /**
     * Returns the issuer criterion as a byte array. This distinguished name
     * must match the issuer distinguished name in the
     * {@code X509Certificate}. If {@code null}, the issuer criterion
     * is disabled and any issuer distinguished name will do.
     * &lt;p&gt;
     * If the value returned is not {@code null}, it is a byte
     * array containing a single DER encoded distinguished name, as defined in
     * X.501. The ASN.1 notation for this structure is supplied in the
     * documentation for
     * {@link #setIssuer(byte [] issuerDN) setIssuer(byte [] issuerDN)}.
     * &lt;p&gt;
     * Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return a byte array containing the required issuer distinguished name
     *         in ASN.1 DER format (or {@code null})
     * @throws IOException if an encoding error occurs
     */
    public byte[] getIssuerAsBytes() throws IOException {
<span class="nc bnc" id="L1363" title="All 2 branches missed.">        return (issuer == null ? null: issuer.getEncoded());</span>
    }

    /**
     * Returns the subject criterion as an {@code X500Principal}. This
     * distinguished name must match the subject distinguished name in the
     * {@code X509Certificate}. If {@code null}, the subject criterion
     * is disabled and any subject distinguished name will do.
     *
     * @return the required subject distinguished name as X500Principal
     *         (or {@code null})
     * @since 1.5
     */
    public X500Principal getSubject() {
<span class="fc" id="L1377">        return subject;</span>
    }

    /**
     * &lt;strong&gt;Denigrated&lt;/strong&gt;, use {@linkplain #getSubject()} or
     * {@linkplain #getSubjectAsBytes()} instead. This method should not be
     * relied on as it can fail to match some certificates because of a loss of
     * encoding information in the RFC 2253 String form of some distinguished
     * names.
     * &lt;p&gt;
     * Returns the subject criterion as a {@code String}. This
     * distinguished name must match the subject distinguished name in the
     * {@code X509Certificate}. If {@code null}, the subject criterion
     * is disabled and any subject distinguished name will do.
     * &lt;p&gt;
     * If the value returned is not {@code null}, it is a
     * distinguished name, in RFC 2253 format.
     *
     * @return the required subject distinguished name in RFC 2253 format
     *         (or {@code null})
     */
    public String getSubjectAsString() {
<span class="nc bnc" id="L1399" title="All 2 branches missed.">        return (subject == null ? null : subject.getName());</span>
    }

    /**
     * Returns the subject criterion as a byte array. This distinguished name
     * must match the subject distinguished name in the
     * {@code X509Certificate}. If {@code null}, the subject criterion
     * is disabled and any subject distinguished name will do.
     * &lt;p&gt;
     * If the value returned is not {@code null}, it is a byte
     * array containing a single DER encoded distinguished name, as defined in
     * X.501. The ASN.1 notation for this structure is supplied in the
     * documentation for
     * {@link #setSubject(byte [] subjectDN) setSubject(byte [] subjectDN)}.
     * &lt;p&gt;
     * Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return a byte array containing the required subject distinguished name
     *         in ASN.1 DER format (or {@code null})
     * @throws IOException if an encoding error occurs
     */
    public byte[] getSubjectAsBytes() throws IOException {
<span class="nc bnc" id="L1422" title="All 2 branches missed.">        return (subject == null ? null : subject.getEncoded());</span>
    }

    /**
     * Returns the subjectKeyIdentifier criterion. The
     * {@code X509Certificate} must contain a SubjectKeyIdentifier
     * extension with the specified value. If {@code null}, no
     * subjectKeyIdentifier check will be done.
     * &lt;p&gt;
     * Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return the key identifier (or {@code null})
     * @see #setSubjectKeyIdentifier
     */
    public byte[] getSubjectKeyIdentifier() {
<span class="pc bpc" id="L1438" title="1 of 2 branches missed.">        if (subjectKeyID == null) {</span>
<span class="fc" id="L1439">            return null;</span>
        }
<span class="nc" id="L1441">        return subjectKeyID.clone();</span>
    }

    /**
     * Returns the authorityKeyIdentifier criterion. The
     * {@code X509Certificate} must contain a AuthorityKeyIdentifier
     * extension with the specified value. If {@code null}, no
     * authorityKeyIdentifier check will be done.
     * &lt;p&gt;
     * Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return the key identifier (or {@code null})
     * @see #setAuthorityKeyIdentifier
     */
    public byte[] getAuthorityKeyIdentifier() {
<span class="nc bnc" id="L1457" title="All 2 branches missed.">        if (authorityKeyID == null) {</span>
<span class="nc" id="L1458">          return null;</span>
        }
<span class="nc" id="L1460">        return authorityKeyID.clone();</span>
    }

    /**
     * Returns the certificateValid criterion. The specified date must fall
     * within the certificate validity period for the
     * {@code X509Certificate}. If {@code null}, no certificateValid
     * check will be done.
     * &lt;p&gt;
     * Note that the {@code Date} returned is cloned to protect against
     * subsequent modifications.
     *
     * @return the {@code Date} to check (or {@code null})
     * @see #setCertificateValid
     */
    public Date getCertificateValid() {
<span class="nc bnc" id="L1476" title="All 2 branches missed.">        if (certificateValid == null) {</span>
<span class="nc" id="L1477">            return null;</span>
        }
<span class="nc" id="L1479">        return (Date)certificateValid.clone();</span>
    }

    /**
     * Returns the privateKeyValid criterion. The specified date must fall
     * within the private key validity period for the
     * {@code X509Certificate}. If {@code null}, no privateKeyValid
     * check will be done.
     * &lt;p&gt;
     * Note that the {@code Date} returned is cloned to protect against
     * subsequent modifications.
     *
     * @return the {@code Date} to check (or {@code null})
     * @see #setPrivateKeyValid
     */
    public Date getPrivateKeyValid() {
<span class="nc bnc" id="L1495" title="All 2 branches missed.">        if (privateKeyValid == null) {</span>
<span class="nc" id="L1496">            return null;</span>
        }
<span class="nc" id="L1498">        return (Date)privateKeyValid.clone();</span>
    }

    /**
     * Returns the subjectPublicKeyAlgID criterion. The
     * {@code X509Certificate} must contain a subject public key
     * with the specified algorithm. If {@code null}, no
     * subjectPublicKeyAlgID check will be done.
     *
     * @return the object identifier (OID) of the signature algorithm to check
     *         for (or {@code null}). An OID is represented by a set of
     *         nonnegative integers separated by periods.
     * @see #setSubjectPublicKeyAlgID
     */
    public String getSubjectPublicKeyAlgID() {
<span class="nc bnc" id="L1513" title="All 2 branches missed.">        if (subjectPublicKeyAlgID == null) {</span>
<span class="nc" id="L1514">            return null;</span>
        }
<span class="nc" id="L1516">        return subjectPublicKeyAlgID.toString();</span>
    }

    /**
     * Returns the subjectPublicKey criterion. The
     * {@code X509Certificate} must contain the specified subject
     * public key. If {@code null}, no subjectPublicKey check will be done.
     *
     * @return the subject public key to check for (or {@code null})
     * @see #setSubjectPublicKey
     */
    public PublicKey getSubjectPublicKey() {
<span class="nc" id="L1528">        return subjectPublicKey;</span>
    }

    /**
     * Returns the keyUsage criterion. The {@code X509Certificate}
     * must allow the specified keyUsage values. If null, no keyUsage
     * check will be done.
     * &lt;p&gt;
     * Note that the boolean array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return a boolean array in the same format as the boolean
     *                 array returned by
     * {@link X509Certificate#getKeyUsage() X509Certificate.getKeyUsage()}.
     *                 Or {@code null}.
     * @see #setKeyUsage
     */
    public boolean[] getKeyUsage() {
<span class="nc bnc" id="L1546" title="All 2 branches missed.">        if (keyUsage == null) {</span>
<span class="nc" id="L1547">            return null;</span>
        }
<span class="nc" id="L1549">        return keyUsage.clone();</span>
    }

    /**
     * Returns the extendedKeyUsage criterion. The {@code X509Certificate}
     * must allow the specified key purposes in its extended key usage
     * extension. If the {@code keyPurposeSet} returned is empty or
     * {@code null}, no extendedKeyUsage check will be done. Note that an
     * {@code X509Certificate} that has no extendedKeyUsage extension
     * implicitly allows all key purposes.
     *
     * @return an immutable {@code Set} of key purpose OIDs in string
     * format (or {@code null})
     * @see #setExtendedKeyUsage
     */
    public Set&lt;String&gt; getExtendedKeyUsage() {
<span class="nc" id="L1565">        return keyPurposeSet;</span>
    }

    /**
     * Indicates if the {@code X509Certificate} must contain all
     * or at least one of the subjectAlternativeNames
     * specified in the {@link #setSubjectAlternativeNames
     * setSubjectAlternativeNames} or {@link #addSubjectAlternativeName
     * addSubjectAlternativeName} methods. If {@code true},
     * the {@code X509Certificate} must contain all of the
     * specified subject alternative names. If {@code false}, the
     * {@code X509Certificate} must contain at least one of the
     * specified subject alternative names.
     *
     * @return {@code true} if the flag is enabled;
     * {@code false} if the flag is disabled. The flag is
     * {@code true} by default.
     * @see #setMatchAllSubjectAltNames
     */
    public boolean getMatchAllSubjectAltNames() {
<span class="nc" id="L1585">        return matchAllSubjectAltNames;</span>
    }

    /**
     * Returns a copy of the subjectAlternativeNames criterion.
     * The {@code X509Certificate} must contain all or at least one
     * of the specified subjectAlternativeNames, depending on the value
     * of the matchAllNames flag (see {@link #getMatchAllSubjectAltNames
     * getMatchAllSubjectAltNames}). If the value returned is
     * {@code null}, no subjectAlternativeNames check will be performed.
     * &lt;p&gt;
     * If the value returned is not {@code null}, it is a
     * {@code Collection} with
     * one entry for each name to be included in the subject alternative name
     * criterion. Each entry is a {@code List} whose first entry is an
     * {@code Integer} (the name type, 0-8) and whose second
     * entry is a {@code String} or a byte array (the name, in
     * string or ASN.1 DER encoded form, respectively).
     * There can be multiple names of the same type.  Note that the
     * {@code Collection} returned may contain duplicate names (same name
     * and name type).
     * &lt;p&gt;
     * Each subject alternative name in the {@code Collection}
     * may be specified either as a {@code String} or as an ASN.1 encoded
     * byte array. For more details about the formats used, see
     * {@link #addSubjectAlternativeName(int type, String name)
     * addSubjectAlternativeName(int type, String name)} and
     * {@link #addSubjectAlternativeName(int type, byte [] name)
     * addSubjectAlternativeName(int type, byte [] name)}.
     * &lt;p&gt;
     * Note that a deep copy is performed on the {@code Collection} to
     * protect against subsequent modifications.
     *
     * @return a {@code Collection} of names (or {@code null})
     * @see #setSubjectAlternativeNames
     */
    public Collection&lt;List&lt;?&gt;&gt; getSubjectAlternativeNames() {
<span class="nc bnc" id="L1622" title="All 2 branches missed.">        if (subjectAlternativeNames == null) {</span>
<span class="nc" id="L1623">            return null;</span>
        }
<span class="nc" id="L1625">        return cloneNames(subjectAlternativeNames);</span>
    }

    /**
     * Clone an object of the form passed to
     * setSubjectAlternativeNames and setPathToNames.
     * Throw a {@code RuntimeException} if the argument is malformed.
     * &lt;p&gt;
     * This method wraps cloneAndCheckNames, changing any
     * {@code IOException} into a {@code RuntimeException}. This
     * method should be used when the object being
     * cloned has already been checked, so there should never be any exceptions.
     *
     * @param names a {@code Collection} with one entry per name.
     *              Each entry is a {@code List} whose first entry
     *              is an Integer (the name type, 0-8) and whose second
     *              entry is a String or a byte array (the name, in
     *              string or ASN.1 DER encoded form, respectively).
     *              There can be multiple names of the same type. Null
     *              is not an acceptable value.
     * @return a deep copy of the specified {@code Collection}
     * @throws RuntimeException if a parsing error occurs
     */
    private static Set&lt;List&lt;?&gt;&gt; cloneNames(Collection&lt;List&lt;?&gt;&gt; names) {
        try {
<span class="nc" id="L1650">            return cloneAndCheckNames(names);</span>
<span class="nc" id="L1651">        } catch (IOException e) {</span>
<span class="nc" id="L1652">            throw new RuntimeException(&quot;cloneNames encountered IOException: &quot; +</span>
<span class="nc" id="L1653">                                       e.getMessage());</span>
        }
    }

    /**
     * Clone and check an argument of the form passed to
     * setSubjectAlternativeNames and setPathToNames.
     * Throw an {@code IOException} if the argument is malformed.
     *
     * @param names a {@code Collection} with one entry per name.
     *              Each entry is a {@code List} whose first entry
     *              is an Integer (the name type, 0-8) and whose second
     *              entry is a String or a byte array (the name, in
     *              string or ASN.1 DER encoded form, respectively).
     *              There can be multiple names of the same type.
     *              {@code null} is not an acceptable value.
     * @return a deep copy of the specified {@code Collection}
     * @throws IOException if a parsing error occurs
     */
    private static Set&lt;List&lt;?&gt;&gt; cloneAndCheckNames(Collection&lt;List&lt;?&gt;&gt; names) throws IOException {
        // Copy the Lists and Collection
<span class="nc" id="L1674">        Set&lt;List&lt;?&gt;&gt; namesCopy = new HashSet&lt;List&lt;?&gt;&gt;();</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">        for (List&lt;?&gt; o : names)</span>
        {
<span class="nc" id="L1677">            namesCopy.add(new ArrayList&lt;Object&gt;(o));</span>
<span class="nc" id="L1678">        }</span>

        // Check the contents of the Lists and clone any byte arrays
<span class="nc bnc" id="L1681" title="All 2 branches missed.">        for (List&lt;?&gt; list : namesCopy) {</span>
            @SuppressWarnings(&quot;unchecked&quot;) // See javadoc for parameter &quot;names&quot;.
<span class="nc" id="L1683">            List&lt;Object&gt; nameList = (List&lt;Object&gt;)list;</span>
<span class="nc bnc" id="L1684" title="All 2 branches missed.">            if (nameList.size() != 2) {</span>
<span class="nc" id="L1685">                throw new IOException(&quot;name list size not 2&quot;);</span>
            }
<span class="nc" id="L1687">            Object o = nameList.get(0);</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">            if (!(o instanceof Integer)) {</span>
<span class="nc" id="L1689">                throw new IOException(&quot;expected an Integer&quot;);</span>
            }
<span class="nc" id="L1691">            int nameType = ((Integer)o).intValue();</span>
<span class="nc bnc" id="L1692" title="All 4 branches missed.">            if ((nameType &lt; 0) || (nameType &gt; 8)) {</span>
<span class="nc" id="L1693">                throw new IOException(&quot;name type not 0-8&quot;);</span>
            }
<span class="nc" id="L1695">            Object nameObject = nameList.get(1);</span>
<span class="nc bnc" id="L1696" title="All 4 branches missed.">            if (!(nameObject instanceof byte[]) &amp;&amp;</span>
                !(nameObject instanceof String)) {
<span class="nc bnc" id="L1698" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L1699">                    debug.println(&quot;X509CertSelector.cloneAndCheckNames() &quot;</span>
                        + &quot;name not byte array&quot;);
                }
<span class="nc" id="L1702">                throw new IOException(&quot;name not byte array or String&quot;);</span>
            }
<span class="nc bnc" id="L1704" title="All 2 branches missed.">            if (nameObject instanceof byte[]) {</span>
<span class="nc" id="L1705">                nameList.set(1, ((byte[]) nameObject).clone());</span>
            }
<span class="nc" id="L1707">        }</span>
<span class="nc" id="L1708">        return namesCopy;</span>
    }

    /**
     * Returns the name constraints criterion. The {@code X509Certificate}
     * must have subject and subject alternative names that
     * meet the specified name constraints.
     * &lt;p&gt;
     * The name constraints are returned as a byte array. This byte array
     * contains the DER encoded form of the name constraints, as they
     * would appear in the NameConstraints structure defined in RFC 3280
     * and X.509. The ASN.1 notation for this structure is supplied in the
     * documentation for
     * {@link #setNameConstraints(byte [] bytes) setNameConstraints(byte [] bytes)}.
     * &lt;p&gt;
     * Note that the byte array returned is cloned to protect against
     * subsequent modifications.
     *
     * @return a byte array containing the ASN.1 DER encoding of
     *         a NameConstraints extension used for checking name constraints.
     *         {@code null} if no name constraints check will be performed.
     * @see #setNameConstraints
     */
    public byte[] getNameConstraints() {
<span class="nc bnc" id="L1732" title="All 2 branches missed.">        if (ncBytes == null) {</span>
<span class="nc" id="L1733">            return null;</span>
        } else {
<span class="nc" id="L1735">            return ncBytes.clone();</span>
        }
    }

    /**
     * Returns the basic constraints constraint. If the value is greater than
     * or equal to zero, the {@code X509Certificates} must include a
     * basicConstraints extension with a pathLen of at least this value.
     * If the value is -2, only end-entity certificates are accepted. If
     * the value is -1, no basicConstraints check is done.
     *
     * @return the value for the basic constraints constraint
     * @see #setBasicConstraints
     */
    public int getBasicConstraints() {
<span class="fc" id="L1750">        return basicConstraints;</span>
    }

    /**
     * Returns the policy criterion. The {@code X509Certificate} must
     * include at least one of the specified policies in its certificate policies
     * extension. If the {@code Set} returned is empty, then the
     * {@code X509Certificate} must include at least some specified policy
     * in its certificate policies extension. If the {@code Set} returned is
     * {@code null}, no policy check will be performed.
     *
     * @return an immutable {@code Set} of certificate policy OIDs in
     *         string format (or {@code null})
     * @see #setPolicy
     */
    public Set&lt;String&gt; getPolicy() {
<span class="nc" id="L1766">        return policySet;</span>
    }

    /**
     * Returns a copy of the pathToNames criterion. The
     * {@code X509Certificate} must not include name constraints that would
     * prohibit building a path to the specified names. If the value
     * returned is {@code null}, no pathToNames check will be performed.
     * &lt;p&gt;
     * If the value returned is not {@code null}, it is a
     * {@code Collection} with one
     * entry for each name to be included in the pathToNames
     * criterion. Each entry is a {@code List} whose first entry is an
     * {@code Integer} (the name type, 0-8) and whose second
     * entry is a {@code String} or a byte array (the name, in
     * string or ASN.1 DER encoded form, respectively).
     * There can be multiple names of the same type. Note that the
     * {@code Collection} returned may contain duplicate names (same
     * name and name type).
     * &lt;p&gt;
     * Each name in the {@code Collection}
     * may be specified either as a {@code String} or as an ASN.1 encoded
     * byte array. For more details about the formats used, see
     * {@link #addPathToName(int type, String name)
     * addPathToName(int type, String name)} and
     * {@link #addPathToName(int type, byte [] name)
     * addPathToName(int type, byte [] name)}.
     * &lt;p&gt;
     * Note that a deep copy is performed on the {@code Collection} to
     * protect against subsequent modifications.
     *
     * @return a {@code Collection} of names (or {@code null})
     * @see #setPathToNames
     */
    public Collection&lt;List&lt;?&gt;&gt; getPathToNames() {
<span class="nc bnc" id="L1801" title="All 2 branches missed.">        if (pathToNames == null) {</span>
<span class="nc" id="L1802">            return null;</span>
        }
<span class="nc" id="L1804">        return cloneNames(pathToNames);</span>
    }

    /**
     * Return a printable representation of the {@code CertSelector}.
     *
     * @return a {@code String} describing the contents of the
     *         {@code CertSelector}
     */
    public String toString() {
<span class="nc" id="L1814">        StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L1815">        sb.append(&quot;X509CertSelector: [\n&quot;);</span>
<span class="nc bnc" id="L1816" title="All 2 branches missed.">        if (x509Cert != null) {</span>
<span class="nc" id="L1817">            sb.append(&quot;  Certificate: &quot; + x509Cert.toString() + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1819" title="All 2 branches missed.">        if (serialNumber != null) {</span>
<span class="nc" id="L1820">            sb.append(&quot;  Serial Number: &quot; + serialNumber.toString() + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1822" title="All 2 branches missed.">        if (issuer != null) {</span>
<span class="nc" id="L1823">            sb.append(&quot;  Issuer: &quot; + getIssuerAsString() + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1825" title="All 2 branches missed.">        if (subject != null) {</span>
<span class="nc" id="L1826">            sb.append(&quot;  Subject: &quot; + getSubjectAsString() + &quot;\n&quot;);</span>
        }
<span class="nc" id="L1828">        sb.append(&quot;  matchAllSubjectAltNames flag: &quot;</span>
<span class="nc" id="L1829">                  + String.valueOf(matchAllSubjectAltNames) + &quot;\n&quot;);</span>
<span class="nc bnc" id="L1830" title="All 2 branches missed.">        if (subjectAlternativeNames != null) {</span>
<span class="nc" id="L1831">            sb.append(&quot;  SubjectAlternativeNames:\n&quot;);</span>
<span class="nc" id="L1832">            Iterator&lt;List&lt;?&gt;&gt; i = subjectAlternativeNames.iterator();</span>
<span class="nc bnc" id="L1833" title="All 2 branches missed.">            while (i.hasNext()) {</span>
<span class="nc" id="L1834">                List&lt;?&gt; list = i.next();</span>
<span class="nc" id="L1835">                sb.append(&quot;    type &quot; + list.get(0) +</span>
<span class="nc" id="L1836">                          &quot;, name &quot; + list.get(1) + &quot;\n&quot;);</span>
<span class="nc" id="L1837">            }</span>
        }
<span class="nc bnc" id="L1839" title="All 2 branches missed.">        if (subjectKeyID != null) {</span>
<span class="nc" id="L1840">            HexDumpEncoder enc = new HexDumpEncoder();</span>
<span class="nc" id="L1841">            sb.append(&quot;  Subject Key Identifier: &quot; +</span>
<span class="nc" id="L1842">                      enc.encodeBuffer(subjectKeyID) + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1844" title="All 2 branches missed.">        if (authorityKeyID != null) {</span>
<span class="nc" id="L1845">            HexDumpEncoder enc = new HexDumpEncoder();</span>
<span class="nc" id="L1846">            sb.append(&quot;  Authority Key Identifier: &quot; +</span>
<span class="nc" id="L1847">                      enc.encodeBuffer(authorityKeyID) + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1849" title="All 2 branches missed.">        if (certificateValid != null) {</span>
<span class="nc" id="L1850">            sb.append(&quot;  Certificate Valid: &quot; +</span>
<span class="nc" id="L1851">                      certificateValid.toString() + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1853" title="All 2 branches missed.">        if (privateKeyValid != null) {</span>
<span class="nc" id="L1854">            sb.append(&quot;  Private Key Valid: &quot; +</span>
<span class="nc" id="L1855">                      privateKeyValid.toString() + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1857" title="All 2 branches missed.">        if (subjectPublicKeyAlgID != null) {</span>
<span class="nc" id="L1858">            sb.append(&quot;  Subject Public Key AlgID: &quot; +</span>
<span class="nc" id="L1859">                      subjectPublicKeyAlgID.toString() + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1861" title="All 2 branches missed.">        if (subjectPublicKey != null) {</span>
<span class="nc" id="L1862">            sb.append(&quot;  Subject Public Key: &quot; +</span>
<span class="nc" id="L1863">                      subjectPublicKey.toString() + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1865" title="All 2 branches missed.">        if (keyUsage != null) {</span>
<span class="nc" id="L1866">            sb.append(&quot;  Key Usage: &quot; + keyUsageToString(keyUsage) + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1868" title="All 2 branches missed.">        if (keyPurposeSet != null) {</span>
<span class="nc" id="L1869">            sb.append(&quot;  Extended Key Usage: &quot; +</span>
<span class="nc" id="L1870">                      keyPurposeSet.toString() + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1872" title="All 2 branches missed.">        if (policy != null) {</span>
<span class="nc" id="L1873">            sb.append(&quot;  Policy: &quot; + policy.toString() + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L1875" title="All 2 branches missed.">        if (pathToGeneralNames != null) {</span>
<span class="nc" id="L1876">            sb.append(&quot;  Path to names:\n&quot;);</span>
<span class="nc" id="L1877">            Iterator&lt;GeneralNameInterface&gt; i = pathToGeneralNames.iterator();</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">            while (i.hasNext()) {</span>
<span class="nc" id="L1879">                sb.append(&quot;    &quot; + i.next() + &quot;\n&quot;);</span>
            }
        }
<span class="nc" id="L1882">        sb.append(&quot;]&quot;);</span>
<span class="nc" id="L1883">        return sb.toString();</span>
    }

    // Copied from sun.security.x509.KeyUsageExtension
    // (without calling the superclass)
    /**
     * Returns a printable representation of the KeyUsage.
     */
    private static String keyUsageToString(boolean[] k) {
<span class="nc" id="L1892">        String s = &quot;KeyUsage [\n&quot;;</span>
        try {
<span class="nc bnc" id="L1894" title="All 2 branches missed.">            if (k[0]) {</span>
<span class="nc" id="L1895">                s += &quot;  DigitalSignature\n&quot;;</span>
            }
<span class="nc bnc" id="L1897" title="All 2 branches missed.">            if (k[1]) {</span>
<span class="nc" id="L1898">                s += &quot;  Non_repudiation\n&quot;;</span>
            }
<span class="nc bnc" id="L1900" title="All 2 branches missed.">            if (k[2]) {</span>
<span class="nc" id="L1901">                s += &quot;  Key_Encipherment\n&quot;;</span>
            }
<span class="nc bnc" id="L1903" title="All 2 branches missed.">            if (k[3]) {</span>
<span class="nc" id="L1904">                s += &quot;  Data_Encipherment\n&quot;;</span>
            }
<span class="nc bnc" id="L1906" title="All 2 branches missed.">            if (k[4]) {</span>
<span class="nc" id="L1907">                s += &quot;  Key_Agreement\n&quot;;</span>
            }
<span class="nc bnc" id="L1909" title="All 2 branches missed.">            if (k[5]) {</span>
<span class="nc" id="L1910">                s += &quot;  Key_CertSign\n&quot;;</span>
            }
<span class="nc bnc" id="L1912" title="All 2 branches missed.">            if (k[6]) {</span>
<span class="nc" id="L1913">                s += &quot;  Crl_Sign\n&quot;;</span>
            }
<span class="nc bnc" id="L1915" title="All 2 branches missed.">            if (k[7]) {</span>
<span class="nc" id="L1916">                s += &quot;  Encipher_Only\n&quot;;</span>
            }
<span class="nc bnc" id="L1918" title="All 2 branches missed.">            if (k[8]) {</span>
<span class="nc" id="L1919">                s += &quot;  Decipher_Only\n&quot;;</span>
            }
<span class="nc" id="L1921">        } catch (ArrayIndexOutOfBoundsException ex) {}</span>

<span class="nc" id="L1923">        s += &quot;]\n&quot;;</span>

<span class="nc" id="L1925">        return (s);</span>
    }

    /**
     * Returns an Extension object given any X509Certificate and extension oid.
     * Throw an {@code IOException} if the extension byte value is
     * malformed.
     *
     * @param cert a {@code X509Certificate}
     * @param extId an {@code integer} which specifies the extension index.
     * Currently, the supported extensions are as follows:
     * index 0 - PrivateKeyUsageExtension
     * index 1 - SubjectAlternativeNameExtension
     * index 2 - NameConstraintsExtension
     * index 3 - CertificatePoliciesExtension
     * index 4 - ExtendedKeyUsageExtension
     * @return an {@code Extension} object whose real type is as specified
     * by the extension oid.
     * @throws IOException if cannot construct the {@code Extension}
     * object with the extension encoding retrieved from the passed in
     * {@code X509Certificate}.
     */
    private static Extension getExtensionObject(X509Certificate cert, int extId)
            throws IOException {
<span class="pc bpc" id="L1949" title="1 of 2 branches missed.">        if (cert instanceof X509CertImpl) {</span>
<span class="fc" id="L1950">            X509CertImpl impl = (X509CertImpl)cert;</span>
<span class="pc bpc" id="L1951" title="5 of 6 branches missed.">            switch (extId) {</span>
            case PRIVATE_KEY_USAGE_ID:
<span class="nc" id="L1953">                return impl.getPrivateKeyUsageExtension();</span>
            case SUBJECT_ALT_NAME_ID:
<span class="nc" id="L1955">                return impl.getSubjectAlternativeNameExtension();</span>
            case NAME_CONSTRAINTS_ID:
<span class="fc" id="L1957">                return impl.getNameConstraintsExtension();</span>
            case CERT_POLICIES_ID:
<span class="nc" id="L1959">                return impl.getCertificatePoliciesExtension();</span>
            case EXTENDED_KEY_USAGE_ID:
<span class="nc" id="L1961">                return impl.getExtendedKeyUsageExtension();</span>
            default:
<span class="nc" id="L1963">                return null;</span>
            }
        }
<span class="nc" id="L1966">        byte[] rawExtVal = cert.getExtensionValue(EXTENSION_OIDS[extId]);</span>
<span class="nc bnc" id="L1967" title="All 2 branches missed.">        if (rawExtVal == null) {</span>
<span class="nc" id="L1968">            return null;</span>
        }
<span class="nc" id="L1970">        DerInputStream in = new DerInputStream(rawExtVal);</span>
<span class="nc" id="L1971">        byte[] encoded = in.getOctetString();</span>
<span class="nc bnc" id="L1972" title="All 6 branches missed.">        switch (extId) {</span>
        case PRIVATE_KEY_USAGE_ID:
            try {
<span class="nc" id="L1975">                return new PrivateKeyUsageExtension(FALSE, encoded);</span>
<span class="nc" id="L1976">            } catch (CertificateException ex) {</span>
<span class="nc" id="L1977">                throw new IOException(ex.getMessage());</span>
            }
        case SUBJECT_ALT_NAME_ID:
<span class="nc" id="L1980">            return new SubjectAlternativeNameExtension(FALSE, encoded);</span>
        case NAME_CONSTRAINTS_ID:
<span class="nc" id="L1982">            return new NameConstraintsExtension(FALSE, encoded);</span>
        case CERT_POLICIES_ID:
<span class="nc" id="L1984">            return new CertificatePoliciesExtension(FALSE, encoded);</span>
        case EXTENDED_KEY_USAGE_ID:
<span class="nc" id="L1986">            return new ExtendedKeyUsageExtension(FALSE, encoded);</span>
        default:
<span class="nc" id="L1988">            return null;</span>
        }
    }

    /**
     * Decides whether a {@code Certificate} should be selected.
     *
     * @param cert the {@code Certificate} to be checked
     * @return {@code true} if the {@code Certificate} should be
     *         selected, {@code false} otherwise
     */
    public boolean match(Certificate cert) {
<span class="pc bpc" id="L2000" title="1 of 2 branches missed.">        if (!(cert instanceof X509Certificate)) {</span>
<span class="nc" id="L2001">            return false;</span>
        }
<span class="fc" id="L2003">        X509Certificate xcert = (X509Certificate)cert;</span>

<span class="pc bpc" id="L2005" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L2006">            debug.println(&quot;X509CertSelector.match(SN: &quot;</span>
<span class="nc" id="L2007">                + (xcert.getSerialNumber()).toString(16) + &quot;\n  Issuer: &quot;</span>
<span class="nc" id="L2008">                + xcert.getIssuerDN() + &quot;\n  Subject: &quot; + xcert.getSubjectDN()</span>
                + &quot;)&quot;);
        }

        /* match on X509Certificate */
<span class="fc bfc" id="L2013" title="All 2 branches covered.">        if (x509Cert != null) {</span>
<span class="fc bfc" id="L2014" title="All 2 branches covered.">            if (!x509Cert.equals(xcert)) {</span>
<span class="pc bpc" id="L2015" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2016">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;certs don't match&quot;);
                }
<span class="fc" id="L2019">                return false;</span>
            }
        }

        /* match on serial number */
<span class="fc bfc" id="L2024" title="All 2 branches covered.">        if (serialNumber != null) {</span>
<span class="fc bfc" id="L2025" title="All 2 branches covered.">            if (!serialNumber.equals(xcert.getSerialNumber())) {</span>
<span class="pc bpc" id="L2026" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2027">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;serial numbers don't match&quot;);
                }
<span class="fc" id="L2030">                return false;</span>
            }
        }

        /* match on issuer name */
<span class="pc bpc" id="L2035" title="1 of 2 branches missed.">        if (issuer != null) {</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">            if (!issuer.equals(xcert.getIssuerX500Principal())) {</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2038">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;issuer DNs don't match&quot;);
                }
<span class="nc" id="L2041">                return false;</span>
            }
        }

        /* match on subject name */
<span class="fc bfc" id="L2046" title="All 2 branches covered.">        if (subject != null) {</span>
<span class="fc bfc" id="L2047" title="All 2 branches covered.">            if (!subject.equals(xcert.getSubjectX500Principal())) {</span>
<span class="pc bpc" id="L2048" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2049">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;subject DNs don't match&quot;);
                }
<span class="fc" id="L2052">                return false;</span>
            }
        }

        /* match on certificate validity range */
<span class="fc bfc" id="L2057" title="All 2 branches covered.">        if (certificateValid != null) {</span>
            try {
<span class="fc" id="L2059">                xcert.checkValidity(certificateValid);</span>
<span class="nc" id="L2060">            } catch (CertificateException e) {</span>
<span class="nc bnc" id="L2061" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2062">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;certificate not within validity period&quot;);
                }
<span class="nc" id="L2065">                return false;</span>
<span class="fc" id="L2066">            }</span>
        }

        /* match on subject public key */
<span class="pc bpc" id="L2070" title="1 of 2 branches missed.">        if (subjectPublicKeyBytes != null) {</span>
<span class="nc" id="L2071">            byte[] certKey = xcert.getPublicKey().getEncoded();</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">            if (!Arrays.equals(subjectPublicKeyBytes, certKey)) {</span>
<span class="nc bnc" id="L2073" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2074">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;subject public keys don't match&quot;);
                }
<span class="nc" id="L2077">                return false;</span>
            }
        }

<span class="fc bfc" id="L2081" title="All 2 branches covered.">        boolean result = matchBasicConstraints(xcert)</span>
<span class="fc bfc" id="L2082" title="All 2 branches covered.">                      &amp;&amp; matchKeyUsage(xcert)</span>
<span class="pc bpc" id="L2083" title="1 of 2 branches missed.">                      &amp;&amp; matchExtendedKeyUsage(xcert)</span>
<span class="fc bfc" id="L2084" title="All 2 branches covered.">                      &amp;&amp; matchSubjectKeyID(xcert)</span>
<span class="pc bpc" id="L2085" title="1 of 2 branches missed.">                      &amp;&amp; matchAuthorityKeyID(xcert)</span>
<span class="pc bpc" id="L2086" title="1 of 2 branches missed.">                      &amp;&amp; matchPrivateKeyValid(xcert)</span>
<span class="pc bpc" id="L2087" title="1 of 2 branches missed.">                      &amp;&amp; matchSubjectPublicKeyAlgID(xcert)</span>
<span class="pc bpc" id="L2088" title="1 of 2 branches missed.">                      &amp;&amp; matchPolicy(xcert)</span>
<span class="pc bpc" id="L2089" title="1 of 2 branches missed.">                      &amp;&amp; matchSubjectAlternativeNames(xcert)</span>
<span class="pc bpc" id="L2090" title="1 of 2 branches missed.">                      &amp;&amp; matchPathToNames(xcert)</span>
<span class="pc bpc" id="L2091" title="1 of 2 branches missed.">                      &amp;&amp; matchNameConstraints(xcert);</span>

<span class="pc bpc" id="L2093" title="1 of 4 branches missed.">        if (result &amp;&amp; (debug != null)) {</span>
<span class="nc" id="L2094">            debug.println(&quot;X509CertSelector.match returning: true&quot;);</span>
        }
<span class="fc" id="L2096">        return result;</span>
    }

    /* match on subject key identifier extension value */
    private boolean matchSubjectKeyID(X509Certificate xcert) {
<span class="fc bfc" id="L2101" title="All 2 branches covered.">        if (subjectKeyID == null) {</span>
<span class="fc" id="L2102">            return true;</span>
        }
        try {
<span class="fc" id="L2105">            byte[] extVal = xcert.getExtensionValue(&quot;2.5.29.14&quot;);</span>
<span class="pc bpc" id="L2106" title="1 of 2 branches missed.">            if (extVal == null) {</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2108">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;no subject key ID extension&quot;);
                }
<span class="nc" id="L2111">                return false;</span>
            }
<span class="fc" id="L2113">            DerInputStream in = new DerInputStream(extVal);</span>
<span class="fc" id="L2114">            byte[] certSubjectKeyID = in.getOctetString();</span>
<span class="pc bpc" id="L2115" title="1 of 2 branches missed.">            if (certSubjectKeyID == null ||</span>
<span class="fc bfc" id="L2116" title="All 2 branches covered.">                    !Arrays.equals(subjectKeyID, certSubjectKeyID)) {</span>
<span class="pc bpc" id="L2117" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2118">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;subject key IDs don't match&quot;);
                }
<span class="fc" id="L2121">                return false;</span>
            }
<span class="nc" id="L2123">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2125">                debug.println(&quot;X509CertSelector.match: &quot;</span>
                    + &quot;exception in subject key ID check&quot;);
            }
<span class="nc" id="L2128">            return false;</span>
<span class="fc" id="L2129">        }</span>
<span class="fc" id="L2130">        return true;</span>
    }

    /* match on authority key identifier extension value */
    private boolean matchAuthorityKeyID(X509Certificate xcert) {
<span class="pc bpc" id="L2135" title="1 of 2 branches missed.">        if (authorityKeyID == null) {</span>
<span class="fc" id="L2136">            return true;</span>
        }
        try {
<span class="nc" id="L2139">            byte[] extVal = xcert.getExtensionValue(&quot;2.5.29.35&quot;);</span>
<span class="nc bnc" id="L2140" title="All 2 branches missed.">            if (extVal == null) {</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2142">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;no authority key ID extension&quot;);
                }
<span class="nc" id="L2145">                return false;</span>
            }
<span class="nc" id="L2147">            DerInputStream in = new DerInputStream(extVal);</span>
<span class="nc" id="L2148">            byte[] certAuthKeyID = in.getOctetString();</span>
<span class="nc bnc" id="L2149" title="All 2 branches missed.">            if (certAuthKeyID == null ||</span>
<span class="nc bnc" id="L2150" title="All 2 branches missed.">                    !Arrays.equals(authorityKeyID, certAuthKeyID)) {</span>
<span class="nc bnc" id="L2151" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2152">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;authority key IDs don't match&quot;);
                }
<span class="nc" id="L2155">                return false;</span>
            }
<span class="nc" id="L2157">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2159">                debug.println(&quot;X509CertSelector.match: &quot;</span>
                    + &quot;exception in authority key ID check&quot;);
            }
<span class="nc" id="L2162">            return false;</span>
<span class="nc" id="L2163">        }</span>
<span class="nc" id="L2164">        return true;</span>
    }

    /* match on private key usage range */
    private boolean matchPrivateKeyValid(X509Certificate xcert) {
<span class="pc bpc" id="L2169" title="1 of 2 branches missed.">        if (privateKeyValid == null) {</span>
<span class="fc" id="L2170">            return true;</span>
        }
<span class="nc" id="L2172">        PrivateKeyUsageExtension ext = null;</span>
        try {
<span class="nc" id="L2174">            ext = (PrivateKeyUsageExtension)</span>
<span class="nc" id="L2175">                getExtensionObject(xcert, PRIVATE_KEY_USAGE_ID);</span>
<span class="nc bnc" id="L2176" title="All 2 branches missed.">            if (ext != null) {</span>
<span class="nc" id="L2177">                ext.valid(privateKeyValid);</span>
            }
<span class="nc" id="L2179">        } catch (CertificateExpiredException e1) {</span>
<span class="nc bnc" id="L2180" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2181">                String time = &quot;n/a&quot;;</span>
                try {
<span class="nc" id="L2183">                    Date notAfter = ext.get(PrivateKeyUsageExtension.NOT_AFTER);</span>
<span class="nc" id="L2184">                    time = notAfter.toString();</span>
<span class="nc" id="L2185">                } catch (CertificateException ex) {</span>
                    // not able to retrieve notAfter value
<span class="nc" id="L2187">                }</span>
<span class="nc" id="L2188">                debug.println(&quot;X509CertSelector.match: private key usage not &quot;</span>
                    + &quot;within validity date; ext.NOT_After: &quot;
                    + time + &quot;; X509CertSelector: &quot;
<span class="nc" id="L2191">                    + this.toString());</span>
<span class="nc" id="L2192">                e1.printStackTrace();</span>
            }
<span class="nc" id="L2194">            return false;</span>
<span class="nc" id="L2195">        } catch (CertificateNotYetValidException e2) {</span>
<span class="nc bnc" id="L2196" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2197">                String time = &quot;n/a&quot;;</span>
                try {
<span class="nc" id="L2199">                    Date notBefore = ext.get(PrivateKeyUsageExtension.NOT_BEFORE);</span>
<span class="nc" id="L2200">                    time = notBefore.toString();</span>
<span class="nc" id="L2201">                } catch (CertificateException ex) {</span>
                    // not able to retrieve notBefore value
<span class="nc" id="L2203">                }</span>
<span class="nc" id="L2204">                debug.println(&quot;X509CertSelector.match: private key usage not &quot;</span>
                    + &quot;within validity date; ext.NOT_BEFORE: &quot;
                    + time + &quot;; X509CertSelector: &quot;
<span class="nc" id="L2207">                    + this.toString());</span>
<span class="nc" id="L2208">                e2.printStackTrace();</span>
            }
<span class="nc" id="L2210">            return false;</span>
<span class="nc" id="L2211">        } catch (IOException e4) {</span>
<span class="nc bnc" id="L2212" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2213">                debug.println(&quot;X509CertSelector.match: IOException in &quot;</span>
                    + &quot;private key usage check; X509CertSelector: &quot;
<span class="nc" id="L2215">                    + this.toString());</span>
<span class="nc" id="L2216">                e4.printStackTrace();</span>
            }
<span class="nc" id="L2218">            return false;</span>
<span class="nc" id="L2219">        }</span>
<span class="nc" id="L2220">        return true;</span>
    }

    /* match on subject public key algorithm OID */
    private boolean matchSubjectPublicKeyAlgID(X509Certificate xcert) {
<span class="pc bpc" id="L2225" title="1 of 2 branches missed.">        if (subjectPublicKeyAlgID == null) {</span>
<span class="fc" id="L2226">            return true;</span>
        }
        try {
<span class="nc" id="L2229">            byte[] encodedKey = xcert.getPublicKey().getEncoded();</span>
<span class="nc" id="L2230">            DerValue val = new DerValue(encodedKey);</span>
<span class="nc bnc" id="L2231" title="All 2 branches missed.">            if (val.tag != DerValue.tag_Sequence) {</span>
<span class="nc" id="L2232">                throw new IOException(&quot;invalid key format&quot;);</span>
            }

<span class="nc" id="L2235">            AlgorithmId algID = AlgorithmId.parse(val.data.getDerValue());</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2237">                debug.println(&quot;X509CertSelector.match: subjectPublicKeyAlgID = &quot;</span>
                    + subjectPublicKeyAlgID + &quot;, xcert subjectPublicKeyAlgID = &quot;
<span class="nc" id="L2239">                    + algID.getOID());</span>
            }
<span class="nc bnc" id="L2241" title="All 2 branches missed.">            if (!subjectPublicKeyAlgID.equals((Object)algID.getOID())) {</span>
<span class="nc bnc" id="L2242" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2243">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;subject public key alg IDs don't match&quot;);
                }
<span class="nc" id="L2246">                return false;</span>
            }
<span class="nc" id="L2248">        } catch (IOException e5) {</span>
<span class="nc bnc" id="L2249" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2250">                debug.println(&quot;X509CertSelector.match: IOException in subject &quot;</span>
                    + &quot;public key algorithm OID check&quot;);
            }
<span class="nc" id="L2253">            return false;</span>
<span class="nc" id="L2254">        }</span>
<span class="nc" id="L2255">        return true;</span>
    }

    /* match on key usage extension value */
    private boolean matchKeyUsage(X509Certificate xcert) {
<span class="fc bfc" id="L2260" title="All 2 branches covered.">        if (keyUsage == null) {</span>
<span class="fc" id="L2261">            return true;</span>
        }
<span class="fc" id="L2263">        boolean[] certKeyUsage = xcert.getKeyUsage();</span>
<span class="pc bpc" id="L2264" title="1 of 2 branches missed.">        if (certKeyUsage != null) {</span>
<span class="fc bfc" id="L2265" title="All 2 branches covered.">            for (int keyBit = 0; keyBit &lt; keyUsage.length; keyBit++) {</span>
<span class="pc bpc" id="L2266" title="1 of 6 branches missed.">                if (keyUsage[keyBit] &amp;&amp;</span>
                    ((keyBit &gt;= certKeyUsage.length) || !certKeyUsage[keyBit])) {
<span class="pc bpc" id="L2268" title="1 of 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L2269">                        debug.println(&quot;X509CertSelector.match: &quot;</span>
                            + &quot;key usage bits don't match&quot;);
                    }
<span class="fc" id="L2272">                    return false;</span>
                }
            }
        }
<span class="fc" id="L2276">        return true;</span>
    }

    /* match on extended key usage purpose OIDs */
    private boolean matchExtendedKeyUsage(X509Certificate xcert) {
<span class="pc bpc" id="L2281" title="3 of 4 branches missed.">        if ((keyPurposeSet == null) || keyPurposeSet.isEmpty()) {</span>
<span class="fc" id="L2282">            return true;</span>
        }
        try {
<span class="nc" id="L2285">            ExtendedKeyUsageExtension ext =</span>
<span class="nc" id="L2286">                (ExtendedKeyUsageExtension)getExtensionObject(xcert,</span>
                                                EXTENDED_KEY_USAGE_ID);
<span class="nc bnc" id="L2288" title="All 2 branches missed.">            if (ext != null) {</span>
<span class="nc" id="L2289">                Vector&lt;ObjectIdentifier&gt; certKeyPurposeVector =</span>
<span class="nc" id="L2290">                    ext.get(ExtendedKeyUsageExtension.USAGES);</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">                if (!certKeyPurposeVector.contains(ANY_EXTENDED_KEY_USAGE)</span>
<span class="nc bnc" id="L2292" title="All 2 branches missed.">                        &amp;&amp; !certKeyPurposeVector.containsAll(keyPurposeOIDSet)) {</span>
<span class="nc bnc" id="L2293" title="All 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L2294">                        debug.println(&quot;X509CertSelector.match: cert failed &quot;</span>
                            + &quot;extendedKeyUsage criterion&quot;);
                    }
<span class="nc" id="L2297">                    return false;</span>
                }
            }
<span class="nc" id="L2300">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L2301" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2302">                debug.println(&quot;X509CertSelector.match: &quot;</span>
                    + &quot;IOException in extended key usage check&quot;);
            }
<span class="nc" id="L2305">            return false;</span>
<span class="nc" id="L2306">        }</span>
<span class="nc" id="L2307">        return true;</span>
    }

    /* match on subject alternative name extension names */
    private boolean matchSubjectAlternativeNames(X509Certificate xcert) {
<span class="pc bpc" id="L2312" title="3 of 4 branches missed.">        if ((subjectAlternativeNames == null) || subjectAlternativeNames.isEmpty()) {</span>
<span class="fc" id="L2313">            return true;</span>
        }
        try {
<span class="nc" id="L2316">            SubjectAlternativeNameExtension sanExt =</span>
<span class="nc" id="L2317">                (SubjectAlternativeNameExtension) getExtensionObject(xcert,</span>
                                                      SUBJECT_ALT_NAME_ID);
<span class="nc bnc" id="L2319" title="All 2 branches missed.">            if (sanExt == null) {</span>
<span class="nc bnc" id="L2320" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2321">                  debug.println(&quot;X509CertSelector.match: &quot;</span>
                      + &quot;no subject alternative name extension&quot;);
                }
<span class="nc" id="L2324">                return false;</span>
            }
<span class="nc" id="L2326">            GeneralNames certNames =</span>
<span class="nc" id="L2327">                    sanExt.get(SubjectAlternativeNameExtension.SUBJECT_NAME);</span>
<span class="nc" id="L2328">            Iterator&lt;GeneralNameInterface&gt; i =</span>
<span class="nc" id="L2329">                                subjectAlternativeGeneralNames.iterator();</span>
<span class="nc bnc" id="L2330" title="All 2 branches missed.">            while (i.hasNext()) {</span>
<span class="nc" id="L2331">                GeneralNameInterface matchName = i.next();</span>
<span class="nc" id="L2332">                boolean found = false;</span>
<span class="nc" id="L2333">                for (Iterator&lt;GeneralName&gt; t = certNames.iterator();</span>
<span class="nc bnc" id="L2334" title="All 4 branches missed.">                                                t.hasNext() &amp;&amp; !found; ) {</span>
<span class="nc" id="L2335">                    GeneralNameInterface certName = (t.next()).getName();</span>
<span class="nc" id="L2336">                    found = certName.equals(matchName);</span>
<span class="nc" id="L2337">                }</span>
<span class="nc bnc" id="L2338" title="All 6 branches missed.">                if (!found &amp;&amp; (matchAllSubjectAltNames || !i.hasNext())) {</span>
<span class="nc bnc" id="L2339" title="All 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L2340">                      debug.println(&quot;X509CertSelector.match: subject alternative &quot;</span>
                          + &quot;name &quot; + matchName + &quot; not found&quot;);
                    }
<span class="nc" id="L2343">                    return false;</span>
<span class="nc bnc" id="L2344" title="All 4 branches missed.">                } else if (found &amp;&amp; !matchAllSubjectAltNames) {</span>
<span class="nc" id="L2345">                    break;</span>
                }
<span class="nc" id="L2347">            }</span>
<span class="nc" id="L2348">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L2349" title="All 2 branches missed.">            if (debug != null)</span>
<span class="nc" id="L2350">                debug.println(&quot;X509CertSelector.match: IOException in subject &quot;</span>
                    + &quot;alternative name check&quot;);
<span class="nc" id="L2352">            return false;</span>
<span class="nc" id="L2353">        }</span>
<span class="nc" id="L2354">        return true;</span>
    }

    /* match on name constraints */
    private boolean matchNameConstraints(X509Certificate xcert) {
<span class="pc bpc" id="L2359" title="1 of 2 branches missed.">        if (nc == null) {</span>
<span class="fc" id="L2360">            return true;</span>
        }
        try {
<span class="nc bnc" id="L2363" title="All 2 branches missed.">            if (!nc.verify(xcert)) {</span>
<span class="nc bnc" id="L2364" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2365">                    debug.println(&quot;X509CertSelector.match: &quot;</span>
                        + &quot;name constraints not satisfied&quot;);
                }
<span class="nc" id="L2368">                return false;</span>
            }
<span class="nc" id="L2370">        } catch (IOException e) {</span>
<span class="nc bnc" id="L2371" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2372">                debug.println(&quot;X509CertSelector.match: &quot;</span>
                    + &quot;IOException in name constraints check&quot;);
            }
<span class="nc" id="L2375">            return false;</span>
<span class="nc" id="L2376">        }</span>
<span class="nc" id="L2377">        return true;</span>
    }

    /* match on policy OIDs */
    private boolean matchPolicy(X509Certificate xcert) {
<span class="pc bpc" id="L2382" title="1 of 2 branches missed.">        if (policy == null) {</span>
<span class="fc" id="L2383">            return true;</span>
        }
        try {
<span class="nc" id="L2386">            CertificatePoliciesExtension ext = (CertificatePoliciesExtension)</span>
<span class="nc" id="L2387">                getExtensionObject(xcert, CERT_POLICIES_ID);</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">            if (ext == null) {</span>
<span class="nc bnc" id="L2389" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2390">                  debug.println(&quot;X509CertSelector.match: &quot;</span>
                      + &quot;no certificate policy extension&quot;);
                }
<span class="nc" id="L2393">                return false;</span>
            }
<span class="nc" id="L2395">            List&lt;PolicyInformation&gt; policies = ext.get(CertificatePoliciesExtension.POLICIES);</span>
            /*
             * Convert the Vector of PolicyInformation to a Vector
             * of CertificatePolicyIds for easier comparison.
             */
<span class="nc" id="L2400">            List&lt;CertificatePolicyId&gt; policyIDs = new ArrayList&lt;CertificatePolicyId&gt;(policies.size());</span>
<span class="nc bnc" id="L2401" title="All 2 branches missed.">            for (PolicyInformation info : policies) {</span>
<span class="nc" id="L2402">                policyIDs.add(info.getPolicyIdentifier());</span>
<span class="nc" id="L2403">            }</span>
<span class="nc bnc" id="L2404" title="All 2 branches missed.">            if (policy != null) {</span>
<span class="nc" id="L2405">                boolean foundOne = false;</span>
                /*
                 * if the user passes in an empty policy Set, then
                 * we just want to make sure that the candidate certificate
                 * has some policy OID in its CertPoliciesExtension
                 */
<span class="nc bnc" id="L2411" title="All 2 branches missed.">                if (policy.getCertPolicyIds().isEmpty()) {</span>
<span class="nc bnc" id="L2412" title="All 2 branches missed.">                    if (policyIDs.isEmpty()) {</span>
<span class="nc bnc" id="L2413" title="All 2 branches missed.">                        if (debug != null) {</span>
<span class="nc" id="L2414">                            debug.println(&quot;X509CertSelector.match: &quot;</span>
                                + &quot;cert failed policyAny criterion&quot;);
                        }
<span class="nc" id="L2417">                        return false;</span>
                    }
                } else {
<span class="nc bnc" id="L2420" title="All 2 branches missed.">                    for (CertificatePolicyId id : policy.getCertPolicyIds()) {</span>
<span class="nc bnc" id="L2421" title="All 2 branches missed.">                        if (policyIDs.contains(id)) {</span>
<span class="nc" id="L2422">                            foundOne = true;</span>
<span class="nc" id="L2423">                            break;</span>
                        }
<span class="nc" id="L2425">                    }</span>
<span class="nc bnc" id="L2426" title="All 2 branches missed.">                    if (!foundOne) {</span>
<span class="nc bnc" id="L2427" title="All 2 branches missed.">                        if (debug != null) {</span>
<span class="nc" id="L2428">                            debug.println(&quot;X509CertSelector.match: &quot;</span>
                                + &quot;cert failed policyAny criterion&quot;);
                        }
<span class="nc" id="L2431">                        return false;</span>
                    }
                }
            }
<span class="nc" id="L2435">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L2436" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2437">                debug.println(&quot;X509CertSelector.match: &quot;</span>
                    + &quot;IOException in certificate policy ID check&quot;);
            }
<span class="nc" id="L2440">            return false;</span>
<span class="nc" id="L2441">        }</span>
<span class="nc" id="L2442">        return true;</span>
    }

    /* match on pathToNames */
    private boolean matchPathToNames(X509Certificate xcert) {
<span class="fc bfc" id="L2447" title="All 2 branches covered.">        if (pathToGeneralNames == null) {</span>
<span class="fc" id="L2448">            return true;</span>
        }
        try {
<span class="fc" id="L2451">            NameConstraintsExtension ext = (NameConstraintsExtension)</span>
<span class="fc" id="L2452">                getExtensionObject(xcert, NAME_CONSTRAINTS_ID);</span>
<span class="pc bpc" id="L2453" title="1 of 2 branches missed.">            if (ext == null) {</span>
<span class="fc" id="L2454">                return true;</span>
            }
<span class="nc bnc" id="L2456" title="All 4 branches missed.">            if ((debug != null) &amp;&amp; Debug.isOn(&quot;certpath&quot;)) {</span>
<span class="nc" id="L2457">                debug.println(&quot;X509CertSelector.match pathToNames:\n&quot;);</span>
<span class="nc" id="L2458">                Iterator&lt;GeneralNameInterface&gt; i =</span>
<span class="nc" id="L2459">                                        pathToGeneralNames.iterator();</span>
<span class="nc bnc" id="L2460" title="All 2 branches missed.">                while (i.hasNext()) {</span>
<span class="nc" id="L2461">                    debug.println(&quot;    &quot; + i.next() + &quot;\n&quot;);</span>
                }
            }

<span class="nc" id="L2465">            GeneralSubtrees permitted =</span>
<span class="nc" id="L2466">                    ext.get(NameConstraintsExtension.PERMITTED_SUBTREES);</span>
<span class="nc" id="L2467">            GeneralSubtrees excluded =</span>
<span class="nc" id="L2468">                    ext.get(NameConstraintsExtension.EXCLUDED_SUBTREES);</span>
<span class="nc bnc" id="L2469" title="All 2 branches missed.">            if (excluded != null) {</span>
<span class="nc bnc" id="L2470" title="All 2 branches missed.">                if (matchExcluded(excluded) == false) {</span>
<span class="nc" id="L2471">                    return false;</span>
                }
            }
<span class="nc bnc" id="L2474" title="All 2 branches missed.">            if (permitted != null) {</span>
<span class="nc bnc" id="L2475" title="All 2 branches missed.">                if (matchPermitted(permitted) == false) {</span>
<span class="nc" id="L2476">                    return false;</span>
                }
            }
<span class="nc" id="L2479">        } catch (IOException ex) {</span>
<span class="nc bnc" id="L2480" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L2481">                debug.println(&quot;X509CertSelector.match: &quot;</span>
                    + &quot;IOException in name constraints check&quot;);
            }
<span class="nc" id="L2484">            return false;</span>
<span class="nc" id="L2485">        }</span>
<span class="nc" id="L2486">        return true;</span>
    }

    private boolean matchExcluded(GeneralSubtrees excluded) {
        /*
         * Enumerate through excluded and compare each entry
         * to all pathToNames. If any pathToName is within any of the
         * subtrees listed in excluded, return false.
         */
<span class="nc bnc" id="L2495" title="All 2 branches missed.">        for (Iterator&lt;GeneralSubtree&gt; t = excluded.iterator(); t.hasNext(); ) {</span>
<span class="nc" id="L2496">            GeneralSubtree tree = t.next();</span>
<span class="nc" id="L2497">            GeneralNameInterface excludedName = tree.getName().getName();</span>
<span class="nc" id="L2498">            Iterator&lt;GeneralNameInterface&gt; i = pathToGeneralNames.iterator();</span>
<span class="nc bnc" id="L2499" title="All 2 branches missed.">            while (i.hasNext()) {</span>
<span class="nc" id="L2500">                GeneralNameInterface pathToName = i.next();</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">                if (excludedName.getType() == pathToName.getType()) {</span>
<span class="nc bnc" id="L2502" title="All 2 branches missed.">                    switch (pathToName.constrains(excludedName)) {</span>
                    case GeneralNameInterface.NAME_WIDENS:
                    case GeneralNameInterface.NAME_MATCH:
<span class="nc bnc" id="L2505" title="All 2 branches missed.">                        if (debug != null) {</span>
<span class="nc" id="L2506">                            debug.println(&quot;X509CertSelector.match: name constraints &quot;</span>
                                + &quot;inhibit path to specified name&quot;);
<span class="nc" id="L2508">                            debug.println(&quot;X509CertSelector.match: excluded name: &quot; +</span>
                                pathToName);
                        }
<span class="nc" id="L2511">                        return false;</span>
                    default:
                    }
                }
<span class="nc" id="L2515">            }</span>
<span class="nc" id="L2516">        }</span>
<span class="nc" id="L2517">        return true;</span>
    }

    private boolean matchPermitted(GeneralSubtrees permitted) {
        /*
         * Enumerate through pathToNames, checking that each pathToName
         * is in at least one of the subtrees listed in permitted.
         * If not, return false. However, if no subtrees of a given type
         * are listed, all names of that type are permitted.
         */
<span class="nc" id="L2527">        Iterator&lt;GeneralNameInterface&gt; i = pathToGeneralNames.iterator();</span>
<span class="nc bnc" id="L2528" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L2529">            GeneralNameInterface pathToName = i.next();</span>
<span class="nc" id="L2530">            Iterator&lt;GeneralSubtree&gt; t = permitted.iterator();</span>
<span class="nc" id="L2531">            boolean permittedNameFound = false;</span>
<span class="nc" id="L2532">            boolean nameTypeFound = false;</span>
<span class="nc" id="L2533">            String names = &quot;&quot;;</span>
<span class="nc bnc" id="L2534" title="All 4 branches missed.">            while (t.hasNext() &amp;&amp; !permittedNameFound) {</span>
<span class="nc" id="L2535">                GeneralSubtree tree = t.next();</span>
<span class="nc" id="L2536">                GeneralNameInterface permittedName = tree.getName().getName();</span>
<span class="nc bnc" id="L2537" title="All 2 branches missed.">                if (permittedName.getType() == pathToName.getType()) {</span>
<span class="nc" id="L2538">                    nameTypeFound = true;</span>
<span class="nc" id="L2539">                    names = names + &quot;  &quot; + permittedName;</span>
<span class="nc bnc" id="L2540" title="All 2 branches missed.">                    switch (pathToName.constrains(permittedName)) {</span>
                    case GeneralNameInterface.NAME_WIDENS:
                    case GeneralNameInterface.NAME_MATCH:
<span class="nc" id="L2543">                        permittedNameFound = true;</span>
<span class="nc" id="L2544">                        break;</span>
                    default:
                    }
                }
<span class="nc" id="L2548">            }</span>
<span class="nc bnc" id="L2549" title="All 4 branches missed.">            if (!permittedNameFound &amp;&amp; nameTypeFound) {</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">                if (debug != null)</span>
<span class="nc" id="L2551">                  debug.println(&quot;X509CertSelector.match: &quot; +</span>
                            &quot;name constraints inhibit path to specified name; &quot; +
<span class="nc" id="L2553">                            &quot;permitted names of type &quot; + pathToName.getType() +</span>
                            &quot;: &quot; + names);
<span class="nc" id="L2555">                return false;</span>
            }
<span class="nc" id="L2557">        }</span>
<span class="nc" id="L2558">        return true;</span>
    }

    /* match on basic constraints */
    private boolean matchBasicConstraints(X509Certificate xcert) {
<span class="fc bfc" id="L2563" title="All 2 branches covered.">        if (basicConstraints == -1) {</span>
<span class="fc" id="L2564">            return true;</span>
        }
<span class="fc" id="L2566">        int maxPathLen = xcert.getBasicConstraints();</span>
<span class="fc bfc" id="L2567" title="All 2 branches covered.">        if (basicConstraints == -2) {</span>
<span class="fc bfc" id="L2568" title="All 2 branches covered.">            if (maxPathLen != -1) {</span>
<span class="pc bpc" id="L2569" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2570">                    debug.println(&quot;X509CertSelector.match: not an EE cert&quot;);</span>
                }
<span class="fc" id="L2572">                return false;</span>
            }
        } else {
<span class="fc bfc" id="L2575" title="All 2 branches covered.">            if (maxPathLen &lt; basicConstraints) {</span>
<span class="pc bpc" id="L2576" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L2577">                    debug.println(&quot;X509CertSelector.match: maxPathLen too small (&quot;</span>
                        + maxPathLen + &quot; &lt; &quot; + basicConstraints + &quot;)&quot;);
                }
<span class="fc" id="L2580">                return false;</span>
            }
        }
<span class="fc" id="L2583">        return true;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;) // Safe casts assuming clone() works correctly
    private static &lt;T&gt; Set&lt;T&gt; cloneSet(Set&lt;T&gt; set) {
<span class="nc bnc" id="L2588" title="All 2 branches missed.">        if (set instanceof HashSet) {</span>
<span class="nc" id="L2589">            Object clone = ((HashSet&lt;T&gt;)set).clone();</span>
<span class="nc" id="L2590">            return (Set&lt;T&gt;)clone;</span>
        } else {
<span class="nc" id="L2592">            return new HashSet&lt;T&gt;(set);</span>
        }
    }

    /**
     * Returns a copy of this object.
     *
     * @return the copy
     */
    public Object clone() {
        try {
<span class="fc" id="L2603">            X509CertSelector copy = (X509CertSelector)super.clone();</span>
            // Must clone these because addPathToName et al. modify them
<span class="pc bpc" id="L2605" title="1 of 2 branches missed.">            if (subjectAlternativeNames != null) {</span>
<span class="nc" id="L2606">                copy.subjectAlternativeNames =</span>
<span class="nc" id="L2607">                        cloneSet(subjectAlternativeNames);</span>
<span class="nc" id="L2608">                copy.subjectAlternativeGeneralNames =</span>
<span class="nc" id="L2609">                        cloneSet(subjectAlternativeGeneralNames);</span>
            }
<span class="pc bpc" id="L2611" title="1 of 2 branches missed.">            if (pathToGeneralNames != null) {</span>
<span class="nc" id="L2612">                copy.pathToNames = cloneSet(pathToNames);</span>
<span class="nc" id="L2613">                copy.pathToGeneralNames = cloneSet(pathToGeneralNames);</span>
            }
<span class="fc" id="L2615">            return copy;</span>
<span class="nc" id="L2616">        } catch (CloneNotSupportedException e) {</span>
            /* Cannot happen */
<span class="nc" id="L2618">            throw new InternalError(e.toString(), e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>