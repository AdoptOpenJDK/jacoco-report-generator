<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>X509CRLSelector.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security.cert</a> &gt; <span class="el_source">X509CRLSelector.java</span></div><h1>X509CRLSelector.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security.cert;

import java.io.IOException;
import java.math.BigInteger;
import java.util.*;

import javax.security.auth.x500.X500Principal;

import sun.security.util.Debug;
import sun.security.util.DerInputStream;
import sun.security.x509.CRLNumberExtension;
import sun.security.x509.X500Name;

/**
 * A {@code CRLSelector} that selects {@code X509CRLs} that
 * match all specified criteria. This class is particularly useful when
 * selecting CRLs from a {@code CertStore} to check revocation status
 * of a particular certificate.
 * &lt;p&gt;
 * When first constructed, an {@code X509CRLSelector} has no criteria
 * enabled and each of the {@code get} methods return a default
 * value ({@code null}). Therefore, the {@link #match match} method
 * would return {@code true} for any {@code X509CRL}. Typically,
 * several criteria are enabled (by calling {@link #setIssuers setIssuers}
 * or {@link #setDateAndTime setDateAndTime}, for instance) and then the
 * {@code X509CRLSelector} is passed to
 * {@link CertStore#getCRLs CertStore.getCRLs} or some similar
 * method.
 * &lt;p&gt;
 * Please refer to &lt;a href=&quot;http://www.ietf.org/rfc/rfc3280.txt&quot;&gt;RFC 3280:
 * Internet X.509 Public Key Infrastructure Certificate and CRL Profile&lt;/a&gt;
 * for definitions of the X.509 CRL fields and extensions mentioned below.
 * &lt;p&gt;
 * &lt;b&gt;Concurrent Access&lt;/b&gt;
 * &lt;p&gt;
 * Unless otherwise specified, the methods defined in this class are not
 * thread-safe. Multiple threads that need to access a single
 * object concurrently should synchronize amongst themselves and
 * provide the necessary locking. Multiple threads each manipulating
 * separate objects need not synchronize.
 *
 * @see CRLSelector
 * @see X509CRL
 *
 * @since       1.4
 * @author      Steve Hanna
 */
public class X509CRLSelector implements CRLSelector {

    static {
<span class="fc" id="L76">        CertPathHelperImpl.initialize();</span>
    }

<span class="fc" id="L79">    private static final Debug debug = Debug.getInstance(&quot;certpath&quot;);</span>
    private HashSet&lt;Object&gt; issuerNames;
    private HashSet&lt;X500Principal&gt; issuerX500Principals;
    private BigInteger minCRL;
    private BigInteger maxCRL;
    private Date dateAndTime;
    private X509Certificate certChecking;
<span class="fc" id="L86">    private long skew = 0;</span>

    /**
     * Creates an {@code X509CRLSelector}. Initially, no criteria are set
     * so any {@code X509CRL} will match.
     */
<span class="fc" id="L92">    public X509CRLSelector() {}</span>

    /**
     * Sets the issuerNames criterion. The issuer distinguished name in the
     * {@code X509CRL} must match at least one of the specified
     * distinguished names. If {@code null}, any issuer distinguished name
     * will do.
     * &lt;p&gt;
     * This method allows the caller to specify, with a single method call,
     * the complete set of issuer names which {@code X509CRLs} may contain.
     * The specified value replaces the previous value for the issuerNames
     * criterion.
     * &lt;p&gt;
     * The {@code names} parameter (if not {@code null}) is a
     * {@code Collection} of {@code X500Principal}s.
     * &lt;p&gt;
     * Note that the {@code names} parameter can contain duplicate
     * distinguished names, but they may be removed from the
     * {@code Collection} of names returned by the
     * {@link #getIssuers getIssuers} method.
     * &lt;p&gt;
     * Note that a copy is performed on the {@code Collection} to
     * protect against subsequent modifications.
     *
     * @param issuers a {@code Collection} of X500Principals
     *   (or {@code null})
     * @see #getIssuers
     * @since 1.5
     */
    public void setIssuers(Collection&lt;X500Principal&gt; issuers) {
<span class="nc bnc" id="L122" title="All 4 branches missed.">        if ((issuers == null) || issuers.isEmpty()) {</span>
<span class="nc" id="L123">            issuerNames = null;</span>
<span class="nc" id="L124">            issuerX500Principals = null;</span>
        } else {
            // clone
<span class="nc" id="L127">            issuerX500Principals = new HashSet&lt;X500Principal&gt;(issuers);</span>
<span class="nc" id="L128">            issuerNames = new HashSet&lt;Object&gt;();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">            for (X500Principal p : issuerX500Principals) {</span>
<span class="nc" id="L130">                issuerNames.add(p.getEncoded());</span>
<span class="nc" id="L131">            }</span>
        }
<span class="nc" id="L133">    }</span>

    /**
     * &lt;strong&gt;Note:&lt;/strong&gt; use {@linkplain #setIssuers(Collection)} instead
     * or only specify the byte array form of distinguished names when using
     * this method. See {@link #addIssuerName(String)} for more information.
     * &lt;p&gt;
     * Sets the issuerNames criterion. The issuer distinguished name in the
     * {@code X509CRL} must match at least one of the specified
     * distinguished names. If {@code null}, any issuer distinguished name
     * will do.
     * &lt;p&gt;
     * This method allows the caller to specify, with a single method call,
     * the complete set of issuer names which {@code X509CRLs} may contain.
     * The specified value replaces the previous value for the issuerNames
     * criterion.
     * &lt;p&gt;
     * The {@code names} parameter (if not {@code null}) is a
     * {@code Collection} of names. Each name is a {@code String}
     * or a byte array representing a distinguished name (in
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; or
     * ASN.1 DER encoded form, respectively). If {@code null} is supplied
     * as the value for this argument, no issuerNames check will be performed.
     * &lt;p&gt;
     * Note that the {@code names} parameter can contain duplicate
     * distinguished names, but they may be removed from the
     * {@code Collection} of names returned by the
     * {@link #getIssuerNames getIssuerNames} method.
     * &lt;p&gt;
     * If a name is specified as a byte array, it should contain a single DER
     * encoded distinguished name, as defined in X.501. The ASN.1 notation for
     * this structure is as follows.
     * &lt;pre&gt;{@code
     * Name ::= CHOICE {
     *   RDNSequence }
     *
     * RDNSequence ::= SEQUENCE OF RelativeDistinguishedName
     *
     * RelativeDistinguishedName ::=
     *   SET SIZE (1 .. MAX) OF AttributeTypeAndValue
     *
     * AttributeTypeAndValue ::= SEQUENCE {
     *   type     AttributeType,
     *   value    AttributeValue }
     *
     * AttributeType ::= OBJECT IDENTIFIER
     *
     * AttributeValue ::= ANY DEFINED BY AttributeType
     * ....
     * DirectoryString ::= CHOICE {
     *       teletexString           TeletexString (SIZE (1..MAX)),
     *       printableString         PrintableString (SIZE (1..MAX)),
     *       universalString         UniversalString (SIZE (1..MAX)),
     *       utf8String              UTF8String (SIZE (1.. MAX)),
     *       bmpString               BMPString (SIZE (1..MAX)) }
     * }&lt;/pre&gt;
     * &lt;p&gt;
     * Note that a deep copy is performed on the {@code Collection} to
     * protect against subsequent modifications.
     *
     * @param names a {@code Collection} of names (or {@code null})
     * @throws IOException if a parsing error occurs
     * @see #getIssuerNames
     */
    public void setIssuerNames(Collection&lt;?&gt; names) throws IOException {
<span class="nc bnc" id="L198" title="All 4 branches missed.">        if (names == null || names.size() == 0) {</span>
<span class="nc" id="L199">            issuerNames = null;</span>
<span class="nc" id="L200">            issuerX500Principals = null;</span>
        } else {
<span class="nc" id="L202">            HashSet&lt;Object&gt; tempNames = cloneAndCheckIssuerNames(names);</span>
            // Ensure that we either set both of these or neither
<span class="nc" id="L204">            issuerX500Principals = parseIssuerNames(tempNames);</span>
<span class="nc" id="L205">            issuerNames = tempNames;</span>
        }
<span class="nc" id="L207">    }</span>

    /**
     * Adds a name to the issuerNames criterion. The issuer distinguished
     * name in the {@code X509CRL} must match at least one of the specified
     * distinguished names.
     * &lt;p&gt;
     * This method allows the caller to add a name to the set of issuer names
     * which {@code X509CRLs} may contain. The specified name is added to
     * any previous value for the issuerNames criterion.
     * If the specified name is a duplicate, it may be ignored.
     *
     * @param issuer the issuer as X500Principal
     * @since 1.5
     */
    public void addIssuer(X500Principal issuer) {
<span class="nc" id="L223">        addIssuerNameInternal(issuer.getEncoded(), issuer);</span>
<span class="nc" id="L224">    }</span>

    /**
     * &lt;strong&gt;Denigrated&lt;/strong&gt;, use
     * {@linkplain #addIssuer(X500Principal)} or
     * {@linkplain #addIssuerName(byte[])} instead. This method should not be
     * relied on as it can fail to match some CRLs because of a loss of
     * encoding information in the RFC 2253 String form of some distinguished
     * names.
     * &lt;p&gt;
     * Adds a name to the issuerNames criterion. The issuer distinguished
     * name in the {@code X509CRL} must match at least one of the specified
     * distinguished names.
     * &lt;p&gt;
     * This method allows the caller to add a name to the set of issuer names
     * which {@code X509CRLs} may contain. The specified name is added to
     * any previous value for the issuerNames criterion.
     * If the specified name is a duplicate, it may be ignored.
     *
     * @param name the name in RFC 2253 form
     * @throws IOException if a parsing error occurs
     */
    public void addIssuerName(String name) throws IOException {
<span class="nc" id="L247">        addIssuerNameInternal(name, new X500Name(name).asX500Principal());</span>
<span class="nc" id="L248">    }</span>

    /**
     * Adds a name to the issuerNames criterion. The issuer distinguished
     * name in the {@code X509CRL} must match at least one of the specified
     * distinguished names.
     * &lt;p&gt;
     * This method allows the caller to add a name to the set of issuer names
     * which {@code X509CRLs} may contain. The specified name is added to
     * any previous value for the issuerNames criterion. If the specified name
     * is a duplicate, it may be ignored.
     * If a name is specified as a byte array, it should contain a single DER
     * encoded distinguished name, as defined in X.501. The ASN.1 notation for
     * this structure is as follows.
     * &lt;p&gt;
     * The name is provided as a byte array. This byte array should contain
     * a single DER encoded distinguished name, as defined in X.501. The ASN.1
     * notation for this structure appears in the documentation for
     * {@link #setIssuerNames setIssuerNames(Collection names)}.
     * &lt;p&gt;
     * Note that the byte array supplied here is cloned to protect against
     * subsequent modifications.
     *
     * @param name a byte array containing the name in ASN.1 DER encoded form
     * @throws IOException if a parsing error occurs
     */
    public void addIssuerName(byte[] name) throws IOException {
        // clone because byte arrays are modifiable
<span class="nc" id="L276">        addIssuerNameInternal(name.clone(), new X500Name(name).asX500Principal());</span>
<span class="nc" id="L277">    }</span>

    /**
     * A private method that adds a name (String or byte array) to the
     * issuerNames criterion. The issuer distinguished
     * name in the {@code X509CRL} must match at least one of the specified
     * distinguished names.
     *
     * @param name the name in string or byte array form
     * @param principal the name in X500Principal form
     * @throws IOException if a parsing error occurs
     */
    private void addIssuerNameInternal(Object name, X500Principal principal) {
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (issuerNames == null) {</span>
<span class="nc" id="L291">            issuerNames = new HashSet&lt;Object&gt;();</span>
        }
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (issuerX500Principals == null) {</span>
<span class="nc" id="L294">            issuerX500Principals = new HashSet&lt;X500Principal&gt;();</span>
        }
<span class="nc" id="L296">        issuerNames.add(name);</span>
<span class="nc" id="L297">        issuerX500Principals.add(principal);</span>
<span class="nc" id="L298">    }</span>

    /**
     * Clone and check an argument of the form passed to
     * setIssuerNames. Throw an IOException if the argument is malformed.
     *
     * @param names a {@code Collection} of names. Each entry is a
     *              String or a byte array (the name, in string or ASN.1
     *              DER encoded form, respectively). {@code null} is
     *              not an acceptable value.
     * @return a deep copy of the specified {@code Collection}
     * @throws IOException if a parsing error occurs
     */
    private static HashSet&lt;Object&gt; cloneAndCheckIssuerNames(Collection&lt;?&gt; names)
        throws IOException
    {
<span class="nc" id="L314">        HashSet&lt;Object&gt; namesCopy = new HashSet&lt;Object&gt;();</span>
<span class="nc" id="L315">        Iterator&lt;?&gt; i = names.iterator();</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L317">            Object nameObject = i.next();</span>
<span class="nc bnc" id="L318" title="All 4 branches missed.">            if (!(nameObject instanceof byte []) &amp;&amp;</span>
                !(nameObject instanceof String))
<span class="nc" id="L320">                throw new IOException(&quot;name not byte array or String&quot;);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">            if (nameObject instanceof byte [])</span>
<span class="nc" id="L322">                namesCopy.add(((byte []) nameObject).clone());</span>
            else
<span class="nc" id="L324">                namesCopy.add(nameObject);</span>
<span class="nc" id="L325">        }</span>
<span class="nc" id="L326">        return(namesCopy);</span>
    }

    /**
     * Clone an argument of the form passed to setIssuerNames.
     * Throw a RuntimeException if the argument is malformed.
     * &lt;p&gt;
     * This method wraps cloneAndCheckIssuerNames, changing any IOException
     * into a RuntimeException. This method should be used when the object being
     * cloned has already been checked, so there should never be any exceptions.
     *
     * @param names a {@code Collection} of names. Each entry is a
     *              String or a byte array (the name, in string or ASN.1
     *              DER encoded form, respectively). {@code null} is
     *              not an acceptable value.
     * @return a deep copy of the specified {@code Collection}
     * @throws RuntimeException if a parsing error occurs
     */
    private static HashSet&lt;Object&gt; cloneIssuerNames(Collection&lt;Object&gt; names) {
        try {
<span class="nc" id="L346">            return cloneAndCheckIssuerNames(names);</span>
<span class="nc" id="L347">        } catch (IOException ioe) {</span>
<span class="nc" id="L348">            throw new RuntimeException(ioe);</span>
        }
    }

    /**
     * Parse an argument of the form passed to setIssuerNames,
     * returning a Collection of issuerX500Principals.
     * Throw an IOException if the argument is malformed.
     *
     * @param names a {@code Collection} of names. Each entry is a
     *              String or a byte array (the name, in string or ASN.1
     *              DER encoded form, respectively). &lt;Code&gt;Null&lt;/Code&gt; is
     *              not an acceptable value.
     * @return a HashSet of issuerX500Principals
     * @throws IOException if a parsing error occurs
     */
    private static HashSet&lt;X500Principal&gt; parseIssuerNames(Collection&lt;Object&gt; names)
    throws IOException {
<span class="nc" id="L366">        HashSet&lt;X500Principal&gt; x500Principals = new HashSet&lt;X500Principal&gt;();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        for (Iterator&lt;Object&gt; t = names.iterator(); t.hasNext(); ) {</span>
<span class="nc" id="L368">            Object nameObject = t.next();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (nameObject instanceof String) {</span>
<span class="nc" id="L370">                x500Principals.add(new X500Name((String)nameObject).asX500Principal());</span>
            } else {
                try {
<span class="nc" id="L373">                    x500Principals.add(new X500Principal((byte[])nameObject));</span>
<span class="nc" id="L374">                } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L375">                    throw (IOException)new IOException(&quot;Invalid name&quot;).initCause(e);</span>
<span class="nc" id="L376">                }</span>
            }
<span class="nc" id="L378">        }</span>
<span class="nc" id="L379">        return x500Principals;</span>
    }

    /**
     * Sets the minCRLNumber criterion. The {@code X509CRL} must have a
     * CRL number extension whose value is greater than or equal to the
     * specified value. If {@code null}, no minCRLNumber check will be
     * done.
     *
     * @param minCRL the minimum CRL number accepted (or {@code null})
     */
    public void setMinCRLNumber(BigInteger minCRL) {
<span class="nc" id="L391">        this.minCRL = minCRL;</span>
<span class="nc" id="L392">    }</span>

    /**
     * Sets the maxCRLNumber criterion. The {@code X509CRL} must have a
     * CRL number extension whose value is less than or equal to the
     * specified value. If {@code null}, no maxCRLNumber check will be
     * done.
     *
     * @param maxCRL the maximum CRL number accepted (or {@code null})
     */
    public void setMaxCRLNumber(BigInteger maxCRL) {
<span class="nc" id="L403">        this.maxCRL = maxCRL;</span>
<span class="nc" id="L404">    }</span>

    /**
     * Sets the dateAndTime criterion. The specified date must be
     * equal to or later than the value of the thisUpdate component
     * of the {@code X509CRL} and earlier than the value of the
     * nextUpdate component. There is no match if the {@code X509CRL}
     * does not contain a nextUpdate component.
     * If {@code null}, no dateAndTime check will be done.
     * &lt;p&gt;
     * Note that the {@code Date} supplied here is cloned to protect
     * against subsequent modifications.
     *
     * @param dateAndTime the {@code Date} to match against
     *                    (or {@code null})
     * @see #getDateAndTime
     */
    public void setDateAndTime(Date dateAndTime) {
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (dateAndTime == null)</span>
<span class="nc" id="L423">            this.dateAndTime = null;</span>
        else
<span class="nc" id="L425">            this.dateAndTime = new Date(dateAndTime.getTime());</span>
<span class="nc" id="L426">        this.skew = 0;</span>
<span class="nc" id="L427">    }</span>

    /**
     * Sets the dateAndTime criterion and allows for the specified clock skew
     * (in milliseconds) when checking against the validity period of the CRL.
     */
    void setDateAndTime(Date dateAndTime, long skew) {
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        this.dateAndTime =</span>
<span class="fc" id="L435">            (dateAndTime == null ? null : new Date(dateAndTime.getTime()));</span>
<span class="fc" id="L436">        this.skew = skew;</span>
<span class="fc" id="L437">    }</span>

    /**
     * Sets the certificate being checked. This is not a criterion. Rather,
     * it is optional information that may help a {@code CertStore}
     * find CRLs that would be relevant when checking revocation for the
     * specified certificate. If {@code null} is specified, then no
     * such optional information is provided.
     *
     * @param cert the {@code X509Certificate} being checked
     *             (or {@code null})
     * @see #getCertificateChecking
     */
    public void setCertificateChecking(X509Certificate cert) {
<span class="fc" id="L451">        certChecking = cert;</span>
<span class="fc" id="L452">    }</span>

    /**
     * Returns the issuerNames criterion. The issuer distinguished
     * name in the {@code X509CRL} must match at least one of the specified
     * distinguished names. If the value returned is {@code null}, any
     * issuer distinguished name will do.
     * &lt;p&gt;
     * If the value returned is not {@code null}, it is a
     * unmodifiable {@code Collection} of {@code X500Principal}s.
     *
     * @return an unmodifiable {@code Collection} of names
     *   (or {@code null})
     * @see #setIssuers
     * @since 1.5
     */
    public Collection&lt;X500Principal&gt; getIssuers() {
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (issuerX500Principals == null) {</span>
<span class="nc" id="L470">            return null;</span>
        }
<span class="nc" id="L472">        return Collections.unmodifiableCollection(issuerX500Principals);</span>
    }

    /**
     * Returns a copy of the issuerNames criterion. The issuer distinguished
     * name in the {@code X509CRL} must match at least one of the specified
     * distinguished names. If the value returned is {@code null}, any
     * issuer distinguished name will do.
     * &lt;p&gt;
     * If the value returned is not {@code null}, it is a
     * {@code Collection} of names. Each name is a {@code String}
     * or a byte array representing a distinguished name (in RFC 2253 or
     * ASN.1 DER encoded form, respectively).  Note that the
     * {@code Collection} returned may contain duplicate names.
     * &lt;p&gt;
     * If a name is specified as a byte array, it should contain a single DER
     * encoded distinguished name, as defined in X.501. The ASN.1 notation for
     * this structure is given in the documentation for
     * {@link #setIssuerNames setIssuerNames(Collection names)}.
     * &lt;p&gt;
     * Note that a deep copy is performed on the {@code Collection} to
     * protect against subsequent modifications.
     *
     * @return a {@code Collection} of names (or {@code null})
     * @see #setIssuerNames
     */
    public Collection&lt;Object&gt; getIssuerNames() {
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (issuerNames == null) {</span>
<span class="nc" id="L500">            return null;</span>
        }
<span class="nc" id="L502">        return cloneIssuerNames(issuerNames);</span>
    }

    /**
     * Returns the minCRLNumber criterion. The {@code X509CRL} must have a
     * CRL number extension whose value is greater than or equal to the
     * specified value. If {@code null}, no minCRLNumber check will be done.
     *
     * @return the minimum CRL number accepted (or {@code null})
     */
    public BigInteger getMinCRL() {
<span class="nc" id="L513">        return minCRL;</span>
    }

    /**
     * Returns the maxCRLNumber criterion. The {@code X509CRL} must have a
     * CRL number extension whose value is less than or equal to the
     * specified value. If {@code null}, no maxCRLNumber check will be
     * done.
     *
     * @return the maximum CRL number accepted (or {@code null})
     */
    public BigInteger getMaxCRL() {
<span class="nc" id="L525">        return maxCRL;</span>
    }

    /**
     * Returns the dateAndTime criterion. The specified date must be
     * equal to or later than the value of the thisUpdate component
     * of the {@code X509CRL} and earlier than the value of the
     * nextUpdate component. There is no match if the
     * {@code X509CRL} does not contain a nextUpdate component.
     * If {@code null}, no dateAndTime check will be done.
     * &lt;p&gt;
     * Note that the {@code Date} returned is cloned to protect against
     * subsequent modifications.
     *
     * @return the {@code Date} to match against (or {@code null})
     * @see #setDateAndTime
     */
    public Date getDateAndTime() {
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (dateAndTime == null)</span>
<span class="nc" id="L544">            return null;</span>
<span class="nc" id="L545">        return (Date) dateAndTime.clone();</span>
    }

    /**
     * Returns the certificate being checked. This is not a criterion. Rather,
     * it is optional information that may help a {@code CertStore}
     * find CRLs that would be relevant when checking revocation for the
     * specified certificate. If the value returned is {@code null}, then
     * no such optional information is provided.
     *
     * @return the certificate being checked (or {@code null})
     * @see #setCertificateChecking
     */
    public X509Certificate getCertificateChecking() {
<span class="fc" id="L559">        return certChecking;</span>
    }

    /**
     * Returns a printable representation of the {@code X509CRLSelector}.
     *
     * @return a {@code String} describing the contents of the
     *         {@code X509CRLSelector}.
     */
    public String toString() {
<span class="nc" id="L569">        StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L570">        sb.append(&quot;X509CRLSelector: [\n&quot;);</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (issuerNames != null) {</span>
<span class="nc" id="L572">            sb.append(&quot;  IssuerNames:\n&quot;);</span>
<span class="nc" id="L573">            Iterator&lt;Object&gt; i = issuerNames.iterator();</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            while (i.hasNext())</span>
<span class="nc" id="L575">                sb.append(&quot;    &quot; + i.next() + &quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (minCRL != null)</span>
<span class="nc" id="L578">            sb.append(&quot;  minCRLNumber: &quot; + minCRL + &quot;\n&quot;);</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">        if (maxCRL != null)</span>
<span class="nc" id="L580">            sb.append(&quot;  maxCRLNumber: &quot; + maxCRL + &quot;\n&quot;);</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">        if (dateAndTime != null)</span>
<span class="nc" id="L582">            sb.append(&quot;  dateAndTime: &quot; + dateAndTime + &quot;\n&quot;);</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (certChecking != null)</span>
<span class="nc" id="L584">            sb.append(&quot;  Certificate being checked: &quot; + certChecking + &quot;\n&quot;);</span>
<span class="nc" id="L585">        sb.append(&quot;]&quot;);</span>
<span class="nc" id="L586">        return sb.toString();</span>
    }

    /**
     * Decides whether a {@code CRL} should be selected.
     *
     * @param crl the {@code CRL} to be checked
     * @return {@code true} if the {@code CRL} should be selected,
     *         {@code false} otherwise
     */
    public boolean match(CRL crl) {
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">        if (!(crl instanceof X509CRL)) {</span>
<span class="nc" id="L598">            return false;</span>
        }
<span class="fc" id="L600">        X509CRL xcrl = (X509CRL)crl;</span>

        /* match on issuer name */
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">        if (issuerNames != null) {</span>
<span class="nc" id="L604">            X500Principal issuer = xcrl.getIssuerX500Principal();</span>
<span class="nc" id="L605">            Iterator&lt;X500Principal&gt; i = issuerX500Principals.iterator();</span>
<span class="nc" id="L606">            boolean found = false;</span>
<span class="nc bnc" id="L607" title="All 4 branches missed.">            while (!found &amp;&amp; i.hasNext()) {</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">                if (i.next().equals(issuer)) {</span>
<span class="nc" id="L609">                    found = true;</span>
                }
            }
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (!found) {</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L614">                    debug.println(&quot;X509CRLSelector.match: issuer DNs &quot;</span>
                        + &quot;don't match&quot;);
                }
<span class="nc" id="L617">                return false;</span>
            }
        }

<span class="pc bpc" id="L621" title="2 of 4 branches missed.">        if ((minCRL != null) || (maxCRL != null)) {</span>
            /* Get CRL number extension from CRL */
<span class="nc" id="L623">            byte[] crlNumExtVal = xcrl.getExtensionValue(&quot;2.5.29.20&quot;);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">            if (crlNumExtVal == null) {</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L626">                    debug.println(&quot;X509CRLSelector.match: no CRLNumber&quot;);</span>
                }
            }
            BigInteger crlNum;
            try {
<span class="nc" id="L631">                DerInputStream in = new DerInputStream(crlNumExtVal);</span>
<span class="nc" id="L632">                byte[] encoded = in.getOctetString();</span>
<span class="nc" id="L633">                CRLNumberExtension crlNumExt =</span>
                    new CRLNumberExtension(Boolean.FALSE, encoded);
<span class="nc" id="L635">                crlNum = crlNumExt.get(CRLNumberExtension.NUMBER);</span>
<span class="nc" id="L636">            } catch (IOException ex) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L638">                    debug.println(&quot;X509CRLSelector.match: exception in &quot;</span>
                        + &quot;decoding CRL number&quot;);
                }
<span class="nc" id="L641">                return false;</span>
<span class="nc" id="L642">            }</span>

            /* match on minCRLNumber */
<span class="nc bnc" id="L645" title="All 2 branches missed.">            if (minCRL != null) {</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">                if (crlNum.compareTo(minCRL) &lt; 0) {</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L648">                        debug.println(&quot;X509CRLSelector.match: CRLNumber too small&quot;);</span>
                    }
<span class="nc" id="L650">                    return false;</span>
                }
            }

            /* match on maxCRLNumber */
<span class="nc bnc" id="L655" title="All 2 branches missed.">            if (maxCRL != null) {</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if (crlNum.compareTo(maxCRL) &gt; 0) {</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L658">                        debug.println(&quot;X509CRLSelector.match: CRLNumber too large&quot;);</span>
                    }
<span class="nc" id="L660">                    return false;</span>
                }
            }
        }


        /* match on dateAndTime */
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (dateAndTime != null) {</span>
<span class="fc" id="L668">            Date crlThisUpdate = xcrl.getThisUpdate();</span>
<span class="fc" id="L669">            Date nextUpdate = xcrl.getNextUpdate();</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">            if (nextUpdate == null) {</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L672">                    debug.println(&quot;X509CRLSelector.match: nextUpdate null&quot;);</span>
                }
<span class="nc" id="L674">                return false;</span>
            }
<span class="fc" id="L676">            Date nowPlusSkew = dateAndTime;</span>
<span class="fc" id="L677">            Date nowMinusSkew = dateAndTime;</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">            if (skew &gt; 0) {</span>
<span class="fc" id="L679">                nowPlusSkew = new Date(dateAndTime.getTime() + skew);</span>
<span class="fc" id="L680">                nowMinusSkew = new Date(dateAndTime.getTime() - skew);</span>
            }
<span class="pc bpc" id="L682" title="1 of 2 branches missed.">            if (nowMinusSkew.after(nextUpdate)</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">                || nowPlusSkew.before(crlThisUpdate)) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L685">                    debug.println(&quot;X509CRLSelector.match: update out of range&quot;);</span>
                }
<span class="nc" id="L687">                return false;</span>
            }
        }

<span class="fc" id="L691">        return true;</span>
    }

    /**
     * Returns a copy of this object.
     *
     * @return the copy
     */
    public Object clone() {
        try {
<span class="nc" id="L701">            X509CRLSelector copy = (X509CRLSelector)super.clone();</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">            if (issuerNames != null) {</span>
<span class="nc" id="L703">                copy.issuerNames =</span>
                        new HashSet&lt;Object&gt;(issuerNames);
<span class="nc" id="L705">                copy.issuerX500Principals =</span>
                        new HashSet&lt;X500Principal&gt;(issuerX500Principals);
            }
<span class="nc" id="L708">            return copy;</span>
<span class="nc" id="L709">        } catch (CloneNotSupportedException e) {</span>
            /* Cannot happen */
<span class="nc" id="L711">            throw new InternalError(e.toString(), e);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>