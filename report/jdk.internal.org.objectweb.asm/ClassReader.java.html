<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClassReader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm</a> &gt; <span class="el_source">ClassReader.java</span></div><h1>ClassReader.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm;

import java.io.IOException;
import java.io.InputStream;

/**
 * A Java class parser to make a {@link ClassVisitor} visit an existing class.
 * This class parses a byte array conforming to the Java class file format and
 * calls the appropriate visit methods of a given class visitor for each field,
 * method and bytecode instruction encountered.
 *
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
public class ClassReader {

    /**
     * True to enable signatures support.
     */
    static final boolean SIGNATURES = true;

    /**
     * True to enable annotations support.
     */
    static final boolean ANNOTATIONS = true;

    /**
     * True to enable stack map frames support.
     */
    static final boolean FRAMES = true;

    /**
     * True to enable bytecode writing support.
     */
    static final boolean WRITER = true;

    /**
     * True to enable JSR_W and GOTO_W support.
     */
    static final boolean RESIZE = true;

    /**
     * Flag to skip method code. If this class is set &lt;code&gt;CODE&lt;/code&gt;
     * attribute won't be visited. This can be used, for example, to retrieve
     * annotations for methods and method parameters.
     */
    public static final int SKIP_CODE = 1;

    /**
     * Flag to skip the debug information in the class. If this flag is set the
     * debug information of the class is not visited, i.e. the
     * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and
     * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be
     * called.
     */
    public static final int SKIP_DEBUG = 2;

    /**
     * Flag to skip the stack map frames in the class. If this flag is set the
     * stack map frames of the class is not visited, i.e. the
     * {@link MethodVisitor#visitFrame visitFrame} method will not be called.
     * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is
     * used: it avoids visiting frames that will be ignored and recomputed from
     * scratch in the class writer.
     */
    public static final int SKIP_FRAMES = 4;

    /**
     * Flag to expand the stack map frames. By default stack map frames are
     * visited in their original format (i.e. &quot;expanded&quot; for classes whose
     * version is less than V1_6, and &quot;compressed&quot; for the other classes). If
     * this flag is set, stack map frames are always visited in expanded format
     * (this option adds a decompression/recompression step in ClassReader and
     * ClassWriter which degrades performances quite a lot).
     */
    public static final int EXPAND_FRAMES = 8;

    /**
     * The class to be parsed. &lt;i&gt;The content of this array must not be
     * modified. This field is intended for {@link Attribute} sub classes, and
     * is normally not needed by class generators or adapters.&lt;/i&gt;
     */
    public final byte[] b;

    /**
     * The start index of each constant pool item in {@link #b b}, plus one. The
     * one byte offset skips the constant pool item tag that indicates its type.
     */
    private final int[] items;

    /**
     * The String objects corresponding to the CONSTANT_Utf8 items. This cache
     * avoids multiple parsing of a given CONSTANT_Utf8 constant pool item,
     * which GREATLY improves performances (by a factor 2 to 3). This caching
     * strategy could be extended to all constant pool items, but its benefit
     * would not be so great for these items (because they are much less
     * expensive to parse than CONSTANT_Utf8 items).
     */
    private final String[] strings;

    /**
     * Maximum length of the strings contained in the constant pool of the
     * class.
     */
    private final int maxStringLength;

    /**
     * Start index of the class header information (access, name...) in
     * {@link #b b}.
     */
    public final int header;

    // ------------------------------------------------------------------------
    // Constructors
    // ------------------------------------------------------------------------

    /**
     * Constructs a new {@link ClassReader} object.
     *
     * @param b
     *            the bytecode of the class to be read.
     */
    public ClassReader(final byte[] b) {
<span class="fc" id="L182">        this(b, 0, b.length);</span>
<span class="fc" id="L183">    }</span>

    /**
     * Constructs a new {@link ClassReader} object.
     *
     * @param b
     *            the bytecode of the class to be read.
     * @param off
     *            the start offset of the class data.
     * @param len
     *            the length of the class data.
     */
<span class="fc" id="L195">    public ClassReader(final byte[] b, final int off, final int len) {</span>
<span class="fc" id="L196">        this.b = b;</span>
        // checks the class version
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (readShort(off + 6) &gt; Opcodes.V1_8) {</span>
<span class="nc" id="L199">            throw new IllegalArgumentException();</span>
        }
        // parses the constant pool
<span class="fc" id="L202">        items = new int[readUnsignedShort(off + 8)];</span>
<span class="fc" id="L203">        int n = items.length;</span>
<span class="fc" id="L204">        strings = new String[n];</span>
<span class="fc" id="L205">        int max = 0;</span>
<span class="fc" id="L206">        int index = off + 10;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        for (int i = 1; i &lt; n; ++i) {</span>
<span class="fc" id="L208">            items[i] = index + 1;</span>
            int size;
<span class="pc bpc" id="L210" title="2 of 5 branches missed.">            switch (b[index]) {</span>
            case ClassWriter.FIELD:
            case ClassWriter.METH:
            case ClassWriter.IMETH:
            case ClassWriter.INT:
            case ClassWriter.FLOAT:
            case ClassWriter.NAME_TYPE:
            case ClassWriter.INDY:
<span class="fc" id="L218">                size = 5;</span>
<span class="fc" id="L219">                break;</span>
            case ClassWriter.LONG:
            case ClassWriter.DOUBLE:
<span class="nc" id="L222">                size = 9;</span>
<span class="nc" id="L223">                ++i;</span>
<span class="nc" id="L224">                break;</span>
            case ClassWriter.UTF8:
<span class="fc" id="L226">                size = 3 + readUnsignedShort(index + 1);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">                if (size &gt; max) {</span>
<span class="fc" id="L228">                    max = size;</span>
                }
                break;
            case ClassWriter.HANDLE:
<span class="nc" id="L232">                size = 4;</span>
<span class="nc" id="L233">                break;</span>
            // case ClassWriter.CLASS:
            // case ClassWriter.STR:
            // case ClassWriter.MTYPE
            default:
<span class="fc" id="L238">                size = 3;</span>
                break;
            }
<span class="fc" id="L241">            index += size;</span>
        }
<span class="fc" id="L243">        maxStringLength = max;</span>
        // the class header information starts just after the constant pool
<span class="fc" id="L245">        header = index;</span>
<span class="fc" id="L246">    }</span>

    /**
     * Returns the class's access flags (see {@link Opcodes}). This value may
     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5
     * and those flags are represented by attributes.
     *
     * @return the class access flags
     *
     * @see ClassVisitor#visit(int, int, String, String, String, String[])
     */
    public int getAccess() {
<span class="nc" id="L258">        return readUnsignedShort(header);</span>
    }

    /**
     * Returns the internal name of the class (see
     * {@link Type#getInternalName() getInternalName}).
     *
     * @return the internal class name
     *
     * @see ClassVisitor#visit(int, int, String, String, String, String[])
     */
    public String getClassName() {
<span class="nc" id="L270">        return readClass(header + 2, new char[maxStringLength]);</span>
    }

    /**
     * Returns the internal of name of the super class (see
     * {@link Type#getInternalName() getInternalName}). For interfaces, the
     * super class is {@link Object}.
     *
     * @return the internal name of super class, or &lt;tt&gt;null&lt;/tt&gt; for
     *         {@link Object} class.
     *
     * @see ClassVisitor#visit(int, int, String, String, String, String[])
     */
    public String getSuperName() {
<span class="nc" id="L284">        return readClass(header + 4, new char[maxStringLength]);</span>
    }

    /**
     * Returns the internal names of the class's interfaces (see
     * {@link Type#getInternalName() getInternalName}).
     *
     * @return the array of internal names for all implemented interfaces or
     *         &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @see ClassVisitor#visit(int, int, String, String, String, String[])
     */
    public String[] getInterfaces() {
<span class="nc" id="L297">        int index = header + 6;</span>
<span class="nc" id="L298">        int n = readUnsignedShort(index);</span>
<span class="nc" id="L299">        String[] interfaces = new String[n];</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (n &gt; 0) {</span>
<span class="nc" id="L301">            char[] buf = new char[maxStringLength];</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L303">                index += 2;</span>
<span class="nc" id="L304">                interfaces[i] = readClass(index, buf);</span>
            }
        }
<span class="nc" id="L307">        return interfaces;</span>
    }

    /**
     * Copies the constant pool data into the given {@link ClassWriter}. Should
     * be called before the {@link #accept(ClassVisitor,int)} method.
     *
     * @param classWriter
     *            the {@link ClassWriter} to copy constant pool into.
     */
    void copyPool(final ClassWriter classWriter) {
<span class="nc" id="L318">        char[] buf = new char[maxStringLength];</span>
<span class="nc" id="L319">        int ll = items.length;</span>
<span class="nc" id="L320">        Item[] items2 = new Item[ll];</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">        for (int i = 1; i &lt; ll; i++) {</span>
<span class="nc" id="L322">            int index = items[i];</span>
<span class="nc" id="L323">            int tag = b[index - 1];</span>
<span class="nc" id="L324">            Item item = new Item(i);</span>
            int nameType;
<span class="nc bnc" id="L326" title="All 10 branches missed.">            switch (tag) {</span>
            case ClassWriter.FIELD:
            case ClassWriter.METH:
            case ClassWriter.IMETH:
<span class="nc" id="L330">                nameType = items[readUnsignedShort(index + 2)];</span>
<span class="nc" id="L331">                item.set(tag, readClass(index, buf), readUTF8(nameType, buf),</span>
<span class="nc" id="L332">                        readUTF8(nameType + 2, buf));</span>
<span class="nc" id="L333">                break;</span>
            case ClassWriter.INT:
<span class="nc" id="L335">                item.set(readInt(index));</span>
<span class="nc" id="L336">                break;</span>
            case ClassWriter.FLOAT:
<span class="nc" id="L338">                item.set(Float.intBitsToFloat(readInt(index)));</span>
<span class="nc" id="L339">                break;</span>
            case ClassWriter.NAME_TYPE:
<span class="nc" id="L341">                item.set(tag, readUTF8(index, buf), readUTF8(index + 2, buf),</span>
                        null);
<span class="nc" id="L343">                break;</span>
            case ClassWriter.LONG:
<span class="nc" id="L345">                item.set(readLong(index));</span>
<span class="nc" id="L346">                ++i;</span>
<span class="nc" id="L347">                break;</span>
            case ClassWriter.DOUBLE:
<span class="nc" id="L349">                item.set(Double.longBitsToDouble(readLong(index)));</span>
<span class="nc" id="L350">                ++i;</span>
<span class="nc" id="L351">                break;</span>
            case ClassWriter.UTF8: {
<span class="nc" id="L353">                String s = strings[i];</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">                if (s == null) {</span>
<span class="nc" id="L355">                    index = items[i];</span>
<span class="nc" id="L356">                    s = strings[i] = readUTF(index + 2,</span>
<span class="nc" id="L357">                            readUnsignedShort(index), buf);</span>
                }
<span class="nc" id="L359">                item.set(tag, s, null, null);</span>
<span class="nc" id="L360">                break;</span>
            }
            case ClassWriter.HANDLE: {
<span class="nc" id="L363">                int fieldOrMethodRef = items[readUnsignedShort(index + 1)];</span>
<span class="nc" id="L364">                nameType = items[readUnsignedShort(fieldOrMethodRef + 2)];</span>
<span class="nc" id="L365">                item.set(ClassWriter.HANDLE_BASE + readByte(index),</span>
<span class="nc" id="L366">                        readClass(fieldOrMethodRef, buf),</span>
<span class="nc" id="L367">                        readUTF8(nameType, buf), readUTF8(nameType + 2, buf));</span>
<span class="nc" id="L368">                break;</span>
            }
            case ClassWriter.INDY:
<span class="nc bnc" id="L371" title="All 2 branches missed.">                if (classWriter.bootstrapMethods == null) {</span>
<span class="nc" id="L372">                    copyBootstrapMethods(classWriter, items2, buf);</span>
                }
<span class="nc" id="L374">                nameType = items[readUnsignedShort(index + 2)];</span>
<span class="nc" id="L375">                item.set(readUTF8(nameType, buf), readUTF8(nameType + 2, buf),</span>
<span class="nc" id="L376">                        readUnsignedShort(index));</span>
<span class="nc" id="L377">                break;</span>
            // case ClassWriter.STR:
            // case ClassWriter.CLASS:
            // case ClassWriter.MTYPE
            default:
<span class="nc" id="L382">                item.set(tag, readUTF8(index, buf), null, null);</span>
                break;
            }

<span class="nc" id="L386">            int index2 = item.hashCode % items2.length;</span>
<span class="nc" id="L387">            item.next = items2[index2];</span>
<span class="nc" id="L388">            items2[index2] = item;</span>
        }

<span class="nc" id="L391">        int off = items[1] - 1;</span>
<span class="nc" id="L392">        classWriter.pool.putByteArray(b, off, header - off);</span>
<span class="nc" id="L393">        classWriter.items = items2;</span>
<span class="nc" id="L394">        classWriter.threshold = (int) (0.75d * ll);</span>
<span class="nc" id="L395">        classWriter.index = ll;</span>
<span class="nc" id="L396">    }</span>

    /**
     * Copies the bootstrap method data into the given {@link ClassWriter}.
     * Should be called before the {@link #accept(ClassVisitor,int)} method.
     *
     * @param classWriter
     *            the {@link ClassWriter} to copy bootstrap methods into.
     */
    private void copyBootstrapMethods(final ClassWriter classWriter,
            final Item[] items, final char[] c) {
        // finds the &quot;BootstrapMethods&quot; attribute
<span class="nc" id="L408">        int u = getAttributes();</span>
<span class="nc" id="L409">        boolean found = false;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for (int i = readUnsignedShort(u); i &gt; 0; --i) {</span>
<span class="nc" id="L411">            String attrName = readUTF8(u + 2, c);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            if (&quot;BootstrapMethods&quot;.equals(attrName)) {</span>
<span class="nc" id="L413">                found = true;</span>
<span class="nc" id="L414">                break;</span>
            }
<span class="nc" id="L416">            u += 6 + readInt(u + 4);</span>
        }
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (!found) {</span>
<span class="nc" id="L419">            return;</span>
        }
        // copies the bootstrap methods in the class writer
<span class="nc" id="L422">        int boostrapMethodCount = readUnsignedShort(u + 8);</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        for (int j = 0, v = u + 10; j &lt; boostrapMethodCount; j++) {</span>
<span class="nc" id="L424">            int position = v - u - 10;</span>
<span class="nc" id="L425">            int hashCode = readConst(readUnsignedShort(v), c).hashCode();</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            for (int k = readUnsignedShort(v + 2); k &gt; 0; --k) {</span>
<span class="nc" id="L427">                hashCode ^= readConst(readUnsignedShort(v + 4), c).hashCode();</span>
<span class="nc" id="L428">                v += 2;</span>
            }
<span class="nc" id="L430">            v += 4;</span>
<span class="nc" id="L431">            Item item = new Item(j);</span>
<span class="nc" id="L432">            item.set(position, hashCode &amp; 0x7FFFFFFF);</span>
<span class="nc" id="L433">            int index = item.hashCode % items.length;</span>
<span class="nc" id="L434">            item.next = items[index];</span>
<span class="nc" id="L435">            items[index] = item;</span>
        }
<span class="nc" id="L437">        int attrSize = readInt(u + 4);</span>
<span class="nc" id="L438">        ByteVector bootstrapMethods = new ByteVector(attrSize + 62);</span>
<span class="nc" id="L439">        bootstrapMethods.putByteArray(b, u + 10, attrSize - 2);</span>
<span class="nc" id="L440">        classWriter.bootstrapMethodsCount = boostrapMethodCount;</span>
<span class="nc" id="L441">        classWriter.bootstrapMethods = bootstrapMethods;</span>
<span class="nc" id="L442">    }</span>

    /**
     * Constructs a new {@link ClassReader} object.
     *
     * @param is
     *            an input stream from which to read the class.
     * @throws IOException
     *             if a problem occurs during reading.
     */
    public ClassReader(final InputStream is) throws IOException {
<span class="nc" id="L453">        this(readClass(is, false));</span>
<span class="nc" id="L454">    }</span>

    /**
     * Constructs a new {@link ClassReader} object.
     *
     * @param name
     *            the binary qualified name of the class to be read.
     * @throws IOException
     *             if an exception occurs during reading.
     */
    public ClassReader(final String name) throws IOException {
<span class="nc" id="L465">        this(readClass(</span>
<span class="nc" id="L466">                ClassLoader.getSystemResourceAsStream(name.replace('.', '/')</span>
                        + &quot;.class&quot;), true));
<span class="nc" id="L468">    }</span>

    /**
     * Reads the bytecode of a class.
     *
     * @param is
     *            an input stream from which to read the class.
     * @param close
     *            true to close the input stream after reading.
     * @return the bytecode read from the given input stream.
     * @throws IOException
     *             if a problem occurs during reading.
     */
    private static byte[] readClass(final InputStream is, boolean close)
            throws IOException {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (is == null) {</span>
<span class="nc" id="L484">            throw new IOException(&quot;Class not found&quot;);</span>
        }
        try {
<span class="nc" id="L487">            byte[] b = new byte[is.available()];</span>
<span class="nc" id="L488">            int len = 0;</span>
            while (true) {
<span class="nc" id="L490">                int n = is.read(b, len, b.length - len);</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                if (n == -1) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                    if (len &lt; b.length) {</span>
<span class="nc" id="L493">                        byte[] c = new byte[len];</span>
<span class="nc" id="L494">                        System.arraycopy(b, 0, c, 0, len);</span>
<span class="nc" id="L495">                        b = c;</span>
                    }
<span class="nc" id="L497">                    return b;</span>
                }
<span class="nc" id="L499">                len += n;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                if (len == b.length) {</span>
<span class="nc" id="L501">                    int last = is.read();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">                    if (last &lt; 0) {</span>
<span class="nc" id="L503">                        return b;</span>
                    }
<span class="nc" id="L505">                    byte[] c = new byte[b.length + 1000];</span>
<span class="nc" id="L506">                    System.arraycopy(b, 0, c, 0, len);</span>
<span class="nc" id="L507">                    c[len++] = (byte) last;</span>
<span class="nc" id="L508">                    b = c;</span>
                }
<span class="nc" id="L510">            }</span>
        } finally {
<span class="nc bnc" id="L512" title="All 6 branches missed.">            if (close) {</span>
<span class="nc" id="L513">                is.close();</span>
            }
        }
    }

    // ------------------------------------------------------------------------
    // Public methods
    // ------------------------------------------------------------------------

    /**
     * Makes the given visitor visit the Java class of this {@link ClassReader}
     * . This class is the one specified in the constructor (see
     * {@link #ClassReader(byte[]) ClassReader}).
     *
     * @param classVisitor
     *            the visitor that must visit this class.
     * @param flags
     *            option flags that can be used to modify the default behavior
     *            of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES}
     *            , {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.
     */
    public void accept(final ClassVisitor classVisitor, final int flags) {
<span class="fc" id="L535">        accept(classVisitor, new Attribute[0], flags);</span>
<span class="fc" id="L536">    }</span>

    /**
     * Makes the given visitor visit the Java class of this {@link ClassReader}.
     * This class is the one specified in the constructor (see
     * {@link #ClassReader(byte[]) ClassReader}).
     *
     * @param classVisitor
     *            the visitor that must visit this class.
     * @param attrs
     *            prototypes of the attributes that must be parsed during the
     *            visit of the class. Any attribute whose type is not equal to
     *            the type of one the prototypes will not be parsed: its byte
     *            array value will be passed unchanged to the ClassWriter.
     *            &lt;i&gt;This may corrupt it if this value contains references to
     *            the constant pool, or has syntactic or semantic links with a
     *            class element that has been transformed by a class adapter
     *            between the reader and the writer&lt;/i&gt;.
     * @param flags
     *            option flags that can be used to modify the default behavior
     *            of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES}
     *            , {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.
     */
    public void accept(final ClassVisitor classVisitor,
            final Attribute[] attrs, final int flags) {
<span class="fc" id="L561">        int u = header; // current offset in the class file</span>
<span class="fc" id="L562">        char[] c = new char[maxStringLength]; // buffer used to read strings</span>

<span class="fc" id="L564">        Context context = new Context();</span>
<span class="fc" id="L565">        context.attrs = attrs;</span>
<span class="fc" id="L566">        context.flags = flags;</span>
<span class="fc" id="L567">        context.buffer = c;</span>

        // reads the class declaration
<span class="fc" id="L570">        int access = readUnsignedShort(u);</span>
<span class="fc" id="L571">        String name = readClass(u + 2, c);</span>
<span class="fc" id="L572">        String superClass = readClass(u + 4, c);</span>
<span class="fc" id="L573">        String[] interfaces = new String[readUnsignedShort(u + 6)];</span>
<span class="fc" id="L574">        u += 8;</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">        for (int i = 0; i &lt; interfaces.length; ++i) {</span>
<span class="nc" id="L576">            interfaces[i] = readClass(u, c);</span>
<span class="nc" id="L577">            u += 2;</span>
        }

        // reads the class attributes
<span class="fc" id="L581">        String signature = null;</span>
<span class="fc" id="L582">        String sourceFile = null;</span>
<span class="fc" id="L583">        String sourceDebug = null;</span>
<span class="fc" id="L584">        String enclosingOwner = null;</span>
<span class="fc" id="L585">        String enclosingName = null;</span>
<span class="fc" id="L586">        String enclosingDesc = null;</span>
<span class="fc" id="L587">        int anns = 0;</span>
<span class="fc" id="L588">        int ianns = 0;</span>
<span class="fc" id="L589">        int tanns = 0;</span>
<span class="fc" id="L590">        int itanns = 0;</span>
<span class="fc" id="L591">        int innerClasses = 0;</span>
<span class="fc" id="L592">        Attribute attributes = null;</span>

<span class="fc" id="L594">        u = getAttributes();</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">        for (int i = readUnsignedShort(u); i &gt; 0; --i) {</span>
<span class="fc" id="L596">            String attrName = readUTF8(u + 2, c);</span>
            // tests are sorted in decreasing frequency order
            // (based on frequencies observed on typical classes)
<span class="fc bfc" id="L599" title="All 2 branches covered.">            if (&quot;SourceFile&quot;.equals(attrName)) {</span>
<span class="fc" id="L600">                sourceFile = readUTF8(u + 8, c);</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">            } else if (&quot;InnerClasses&quot;.equals(attrName)) {</span>
<span class="fc" id="L602">                innerClasses = u + 8;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">            } else if (&quot;EnclosingMethod&quot;.equals(attrName)) {</span>
<span class="nc" id="L604">                enclosingOwner = readClass(u + 8, c);</span>
<span class="nc" id="L605">                int item = readUnsignedShort(u + 10);</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">                if (item != 0) {</span>
<span class="nc" id="L607">                    enclosingName = readUTF8(items[item], c);</span>
<span class="nc" id="L608">                    enclosingDesc = readUTF8(items[item] + 2, c);</span>
                }
<span class="nc bnc" id="L610" title="All 2 branches missed.">            } else if (SIGNATURES &amp;&amp; &quot;Signature&quot;.equals(attrName)) {</span>
<span class="nc" id="L611">                signature = readUTF8(u + 8, c);</span>
<span class="nc" id="L612">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeVisibleAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L614">                anns = u + 8;</span>
<span class="nc" id="L615">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeVisibleTypeAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L617">                tanns = u + 8;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">            } else if (&quot;Deprecated&quot;.equals(attrName)) {</span>
<span class="nc" id="L619">                access |= Opcodes.ACC_DEPRECATED;</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            } else if (&quot;Synthetic&quot;.equals(attrName)) {</span>
<span class="nc" id="L621">                access |= Opcodes.ACC_SYNTHETIC</span>
                        | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
<span class="nc bnc" id="L623" title="All 2 branches missed.">            } else if (&quot;SourceDebugExtension&quot;.equals(attrName)) {</span>
<span class="nc" id="L624">                int len = readInt(u + 4);</span>
<span class="nc" id="L625">                sourceDebug = readUTF(u + 8, len, new char[len]);</span>
<span class="nc" id="L626">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeInvisibleAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L628">                ianns = u + 8;</span>
<span class="nc" id="L629">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeInvisibleTypeAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L631">                itanns = u + 8;</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">            } else if (&quot;BootstrapMethods&quot;.equals(attrName)) {</span>
<span class="nc" id="L633">                int[] bootstrapMethods = new int[readUnsignedShort(u + 8)];</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                for (int j = 0, v = u + 10; j &lt; bootstrapMethods.length; j++) {</span>
<span class="nc" id="L635">                    bootstrapMethods[j] = v;</span>
<span class="nc" id="L636">                    v += 2 + readUnsignedShort(v + 2) &lt;&lt; 1;</span>
                }
<span class="nc" id="L638">                context.bootstrapMethods = bootstrapMethods;</span>
<span class="nc" id="L639">            } else {</span>
<span class="nc" id="L640">                Attribute attr = readAttribute(attrs, attrName, u + 8,</span>
<span class="nc" id="L641">                        readInt(u + 4), c, -1, null);</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">                if (attr != null) {</span>
<span class="nc" id="L643">                    attr.next = attributes;</span>
<span class="nc" id="L644">                    attributes = attr;</span>
                }
            }
<span class="fc" id="L647">            u += 6 + readInt(u + 4);</span>
        }

        // visits the class declaration
<span class="fc" id="L651">        classVisitor.visit(readInt(items[1] - 7), access, name, signature,</span>
                superClass, interfaces);

        // visits the source and debug info
<span class="pc bpc" id="L655" title="4 of 6 branches missed.">        if ((flags &amp; SKIP_DEBUG) == 0</span>
                &amp;&amp; (sourceFile != null || sourceDebug != null)) {
<span class="fc" id="L657">            classVisitor.visitSource(sourceFile, sourceDebug);</span>
        }

        // visits the outer class
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">        if (enclosingOwner != null) {</span>
<span class="nc" id="L662">            classVisitor.visitOuterClass(enclosingOwner, enclosingName,</span>
                    enclosingDesc);
        }

        // visits the class annotations and type annotations
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; anns != 0) {</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">            for (int i = readUnsignedShort(anns), v = anns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L669">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L670">                        classVisitor.visitAnnotation(readUTF8(v, c), true));</span>
            }
        }
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; ianns != 0) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">            for (int i = readUnsignedShort(ianns), v = ianns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L675">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L676">                        classVisitor.visitAnnotation(readUTF8(v, c), false));</span>
            }
        }
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; tanns != 0) {</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">            for (int i = readUnsignedShort(tanns), v = tanns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L681">                v = readAnnotationTarget(context, v);</span>
<span class="nc" id="L682">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L683">                        classVisitor.visitTypeAnnotation(context.typeRef,</span>
<span class="nc" id="L684">                                context.typePath, readUTF8(v, c), true));</span>
            }
        }
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; itanns != 0) {</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">            for (int i = readUnsignedShort(itanns), v = itanns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L689">                v = readAnnotationTarget(context, v);</span>
<span class="nc" id="L690">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L691">                        classVisitor.visitTypeAnnotation(context.typeRef,</span>
<span class="nc" id="L692">                                context.typePath, readUTF8(v, c), false));</span>
            }
        }

        // visits the attributes
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">        while (attributes != null) {</span>
<span class="nc" id="L698">            Attribute attr = attributes.next;</span>
<span class="nc" id="L699">            attributes.next = null;</span>
<span class="nc" id="L700">            classVisitor.visitAttribute(attributes);</span>
<span class="nc" id="L701">            attributes = attr;</span>
<span class="nc" id="L702">        }</span>

        // visits the inner classes
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (innerClasses != 0) {</span>
<span class="fc" id="L706">            int v = innerClasses + 2;</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">            for (int i = readUnsignedShort(innerClasses); i &gt; 0; --i) {</span>
<span class="fc" id="L708">                classVisitor.visitInnerClass(readClass(v, c),</span>
<span class="fc" id="L709">                        readClass(v + 2, c), readUTF8(v + 4, c),</span>
<span class="fc" id="L710">                        readUnsignedShort(v + 6));</span>
<span class="fc" id="L711">                v += 8;</span>
            }
        }

        // visits the fields and methods
<span class="fc" id="L716">        u = header + 10 + 2 * interfaces.length;</span>
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">        for (int i = readUnsignedShort(u - 2); i &gt; 0; --i) {</span>
<span class="nc" id="L718">            u = readField(classVisitor, context, u);</span>
        }
<span class="fc" id="L720">        u += 2;</span>
<span class="fc bfc" id="L721" title="All 2 branches covered.">        for (int i = readUnsignedShort(u - 2); i &gt; 0; --i) {</span>
<span class="fc" id="L722">            u = readMethod(classVisitor, context, u);</span>
        }

        // visits the end of the class
<span class="fc" id="L726">        classVisitor.visitEnd();</span>
<span class="fc" id="L727">    }</span>

    /**
     * Reads a field and makes the given visitor visit it.
     *
     * @param classVisitor
     *            the visitor that must visit the field.
     * @param context
     *            information about the class being parsed.
     * @param u
     *            the start offset of the field in the class file.
     * @return the offset of the first byte following the field in the class.
     */
    private int readField(final ClassVisitor classVisitor,
            final Context context, int u) {
        // reads the field declaration
<span class="nc" id="L743">        char[] c = context.buffer;</span>
<span class="nc" id="L744">        int access = readUnsignedShort(u);</span>
<span class="nc" id="L745">        String name = readUTF8(u + 2, c);</span>
<span class="nc" id="L746">        String desc = readUTF8(u + 4, c);</span>
<span class="nc" id="L747">        u += 6;</span>

        // reads the field attributes
<span class="nc" id="L750">        String signature = null;</span>
<span class="nc" id="L751">        int anns = 0;</span>
<span class="nc" id="L752">        int ianns = 0;</span>
<span class="nc" id="L753">        int tanns = 0;</span>
<span class="nc" id="L754">        int itanns = 0;</span>
<span class="nc" id="L755">        Object value = null;</span>
<span class="nc" id="L756">        Attribute attributes = null;</span>

<span class="nc bnc" id="L758" title="All 2 branches missed.">        for (int i = readUnsignedShort(u); i &gt; 0; --i) {</span>
<span class="nc" id="L759">            String attrName = readUTF8(u + 2, c);</span>
            // tests are sorted in decreasing frequency order
            // (based on frequencies observed on typical classes)
<span class="nc bnc" id="L762" title="All 2 branches missed.">            if (&quot;ConstantValue&quot;.equals(attrName)) {</span>
<span class="nc" id="L763">                int item = readUnsignedShort(u + 8);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">                value = item == 0 ? null : readConst(item, c);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">            } else if (SIGNATURES &amp;&amp; &quot;Signature&quot;.equals(attrName)) {</span>
<span class="nc" id="L766">                signature = readUTF8(u + 8, c);</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">            } else if (&quot;Deprecated&quot;.equals(attrName)) {</span>
<span class="nc" id="L768">                access |= Opcodes.ACC_DEPRECATED;</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">            } else if (&quot;Synthetic&quot;.equals(attrName)) {</span>
<span class="nc" id="L770">                access |= Opcodes.ACC_SYNTHETIC</span>
                        | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
<span class="nc" id="L772">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeVisibleAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L774">                anns = u + 8;</span>
<span class="nc" id="L775">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeVisibleTypeAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L777">                tanns = u + 8;</span>
<span class="nc" id="L778">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeInvisibleAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L780">                ianns = u + 8;</span>
<span class="nc" id="L781">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeInvisibleTypeAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L783">                itanns = u + 8;</span>
            } else {
<span class="nc" id="L785">                Attribute attr = readAttribute(context.attrs, attrName, u + 8,</span>
<span class="nc" id="L786">                        readInt(u + 4), c, -1, null);</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">                if (attr != null) {</span>
<span class="nc" id="L788">                    attr.next = attributes;</span>
<span class="nc" id="L789">                    attributes = attr;</span>
                }
            }
<span class="nc" id="L792">            u += 6 + readInt(u + 4);</span>
        }
<span class="nc" id="L794">        u += 2;</span>

        // visits the field declaration
<span class="nc" id="L797">        FieldVisitor fv = classVisitor.visitField(access, name, desc,</span>
                signature, value);
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (fv == null) {</span>
<span class="nc" id="L800">            return u;</span>
        }

        // visits the field annotations and type annotations
<span class="nc bnc" id="L804" title="All 2 branches missed.">        if (ANNOTATIONS &amp;&amp; anns != 0) {</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">            for (int i = readUnsignedShort(anns), v = anns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L806">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L807">                        fv.visitAnnotation(readUTF8(v, c), true));</span>
            }
        }
<span class="nc bnc" id="L810" title="All 2 branches missed.">        if (ANNOTATIONS &amp;&amp; ianns != 0) {</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">            for (int i = readUnsignedShort(ianns), v = ianns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L812">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L813">                        fv.visitAnnotation(readUTF8(v, c), false));</span>
            }
        }
<span class="nc bnc" id="L816" title="All 2 branches missed.">        if (ANNOTATIONS &amp;&amp; tanns != 0) {</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">            for (int i = readUnsignedShort(tanns), v = tanns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L818">                v = readAnnotationTarget(context, v);</span>
<span class="nc" id="L819">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L820">                        fv.visitTypeAnnotation(context.typeRef,</span>
<span class="nc" id="L821">                                context.typePath, readUTF8(v, c), true));</span>
            }
        }
<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (ANNOTATIONS &amp;&amp; itanns != 0) {</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">            for (int i = readUnsignedShort(itanns), v = itanns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L826">                v = readAnnotationTarget(context, v);</span>
<span class="nc" id="L827">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L828">                        fv.visitTypeAnnotation(context.typeRef,</span>
<span class="nc" id="L829">                                context.typePath, readUTF8(v, c), false));</span>
            }
        }

        // visits the field attributes
<span class="nc bnc" id="L834" title="All 2 branches missed.">        while (attributes != null) {</span>
<span class="nc" id="L835">            Attribute attr = attributes.next;</span>
<span class="nc" id="L836">            attributes.next = null;</span>
<span class="nc" id="L837">            fv.visitAttribute(attributes);</span>
<span class="nc" id="L838">            attributes = attr;</span>
<span class="nc" id="L839">        }</span>

        // visits the end of the field
<span class="nc" id="L842">        fv.visitEnd();</span>

<span class="nc" id="L844">        return u;</span>
    }

    /**
     * Reads a method and makes the given visitor visit it.
     *
     * @param classVisitor
     *            the visitor that must visit the method.
     * @param context
     *            information about the class being parsed.
     * @param u
     *            the start offset of the method in the class file.
     * @return the offset of the first byte following the method in the class.
     */
    private int readMethod(final ClassVisitor classVisitor,
            final Context context, int u) {
        // reads the method declaration
<span class="fc" id="L861">        char[] c = context.buffer;</span>
<span class="fc" id="L862">        context.access = readUnsignedShort(u);</span>
<span class="fc" id="L863">        context.name = readUTF8(u + 2, c);</span>
<span class="fc" id="L864">        context.desc = readUTF8(u + 4, c);</span>
<span class="fc" id="L865">        u += 6;</span>

        // reads the method attributes
<span class="fc" id="L868">        int code = 0;</span>
<span class="fc" id="L869">        int exception = 0;</span>
<span class="fc" id="L870">        String[] exceptions = null;</span>
<span class="fc" id="L871">        String signature = null;</span>
<span class="fc" id="L872">        int methodParameters = 0;</span>
<span class="fc" id="L873">        int anns = 0;</span>
<span class="fc" id="L874">        int ianns = 0;</span>
<span class="fc" id="L875">        int tanns = 0;</span>
<span class="fc" id="L876">        int itanns = 0;</span>
<span class="fc" id="L877">        int dann = 0;</span>
<span class="fc" id="L878">        int mpanns = 0;</span>
<span class="fc" id="L879">        int impanns = 0;</span>
<span class="fc" id="L880">        int firstAttribute = u;</span>
<span class="fc" id="L881">        Attribute attributes = null;</span>

<span class="fc bfc" id="L883" title="All 2 branches covered.">        for (int i = readUnsignedShort(u); i &gt; 0; --i) {</span>
<span class="fc" id="L884">            String attrName = readUTF8(u + 2, c);</span>
            // tests are sorted in decreasing frequency order
            // (based on frequencies observed on typical classes)
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">            if (&quot;Code&quot;.equals(attrName)) {</span>
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">                if ((context.flags &amp; SKIP_CODE) == 0) {</span>
<span class="fc" id="L889">                    code = u + 8;</span>
                }
<span class="nc bnc" id="L891" title="All 2 branches missed.">            } else if (&quot;Exceptions&quot;.equals(attrName)) {</span>
<span class="nc" id="L892">                exceptions = new String[readUnsignedShort(u + 8)];</span>
<span class="nc" id="L893">                exception = u + 10;</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">                for (int j = 0; j &lt; exceptions.length; ++j) {</span>
<span class="nc" id="L895">                    exceptions[j] = readClass(exception, c);</span>
<span class="nc" id="L896">                    exception += 2;</span>
                }
<span class="nc bnc" id="L898" title="All 2 branches missed.">            } else if (SIGNATURES &amp;&amp; &quot;Signature&quot;.equals(attrName)) {</span>
<span class="nc" id="L899">                signature = readUTF8(u + 8, c);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">            } else if (&quot;Deprecated&quot;.equals(attrName)) {</span>
<span class="nc" id="L901">                context.access |= Opcodes.ACC_DEPRECATED;</span>
<span class="nc" id="L902">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeVisibleAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L904">                anns = u + 8;</span>
<span class="nc" id="L905">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeVisibleTypeAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L907">                tanns = u + 8;</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">            } else if (ANNOTATIONS &amp;&amp; &quot;AnnotationDefault&quot;.equals(attrName)) {</span>
<span class="nc" id="L909">                dann = u + 8;</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">            } else if (&quot;Synthetic&quot;.equals(attrName)) {</span>
<span class="nc" id="L911">                context.access |= Opcodes.ACC_SYNTHETIC</span>
                        | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
<span class="nc" id="L913">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeInvisibleAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L915">                ianns = u + 8;</span>
<span class="nc" id="L916">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeInvisibleTypeAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L918">                itanns = u + 8;</span>
<span class="nc" id="L919">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeVisibleParameterAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L921">                mpanns = u + 8;</span>
<span class="nc" id="L922">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeInvisibleParameterAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L924">                impanns = u + 8;</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">            } else if (&quot;MethodParameters&quot;.equals(attrName)) {</span>
<span class="nc" id="L926">                methodParameters = u + 8;</span>
            } else {
<span class="nc" id="L928">                Attribute attr = readAttribute(context.attrs, attrName, u + 8,</span>
<span class="nc" id="L929">                        readInt(u + 4), c, -1, null);</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">                if (attr != null) {</span>
<span class="nc" id="L931">                    attr.next = attributes;</span>
<span class="nc" id="L932">                    attributes = attr;</span>
                }
            }
<span class="fc" id="L935">            u += 6 + readInt(u + 4);</span>
        }
<span class="fc" id="L937">        u += 2;</span>

        // visits the method declaration
<span class="fc" id="L940">        MethodVisitor mv = classVisitor.visitMethod(context.access,</span>
                context.name, context.desc, signature, exceptions);
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">        if (mv == null) {</span>
<span class="nc" id="L943">            return u;</span>
        }

        /*
         * if the returned MethodVisitor is in fact a MethodWriter, it means
         * there is no method adapter between the reader and the writer. If, in
         * addition, the writer's constant pool was copied from this reader
         * (mw.cw.cr == this), and the signature and exceptions of the method
         * have not been changed, then it is possible to skip all visit events
         * and just copy the original code of the method to the writer (the
         * access, name and descriptor can have been changed, this is not
         * important since they are not copied as is from the reader).
         */
<span class="pc bpc" id="L956" title="1 of 2 branches missed.">        if (WRITER &amp;&amp; mv instanceof MethodWriter) {</span>
<span class="fc" id="L957">            MethodWriter mw = (MethodWriter) mv;</span>
<span class="pc bpc" id="L958" title="3 of 4 branches missed.">            if (mw.cw.cr == this &amp;&amp; signature == mw.signature) {</span>
<span class="nc" id="L959">                boolean sameExceptions = false;</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">                if (exceptions == null) {</span>
<span class="nc bnc" id="L961" title="All 2 branches missed.">                    sameExceptions = mw.exceptionCount == 0;</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                } else if (exceptions.length == mw.exceptionCount) {</span>
<span class="nc" id="L963">                    sameExceptions = true;</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">                    for (int j = exceptions.length - 1; j &gt;= 0; --j) {</span>
<span class="nc" id="L965">                        exception -= 2;</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">                        if (mw.exceptions[j] != readUnsignedShort(exception)) {</span>
<span class="nc" id="L967">                            sameExceptions = false;</span>
<span class="nc" id="L968">                            break;</span>
                        }
                    }
                }
<span class="nc bnc" id="L972" title="All 2 branches missed.">                if (sameExceptions) {</span>
                    /*
                     * we do not copy directly the code into MethodWriter to
                     * save a byte array copy operation. The real copy will be
                     * done in ClassWriter.toByteArray().
                     */
<span class="nc" id="L978">                    mw.classReaderOffset = firstAttribute;</span>
<span class="nc" id="L979">                    mw.classReaderLength = u - firstAttribute;</span>
<span class="nc" id="L980">                    return u;</span>
                }
            }
        }

        // visit the method parameters
<span class="pc bpc" id="L986" title="1 of 2 branches missed.">        if (methodParameters != 0) {</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">            for (int i = b[methodParameters] &amp; 0xFF, v = methodParameters + 1; i &gt; 0; --i, v = v + 4) {</span>
<span class="nc" id="L988">                mv.visitParameter(readUTF8(v, c), readUnsignedShort(v + 2));</span>
            }
        }

        // visits the method annotations
<span class="pc bpc" id="L993" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; dann != 0) {</span>
<span class="nc" id="L994">            AnnotationVisitor dv = mv.visitAnnotationDefault();</span>
<span class="nc" id="L995">            readAnnotationValue(dann, c, null, dv);</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">            if (dv != null) {</span>
<span class="nc" id="L997">                dv.visitEnd();</span>
            }
        }
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; anns != 0) {</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            for (int i = readUnsignedShort(anns), v = anns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L1002">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L1003">                        mv.visitAnnotation(readUTF8(v, c), true));</span>
            }
        }
<span class="pc bpc" id="L1006" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; ianns != 0) {</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            for (int i = readUnsignedShort(ianns), v = ianns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L1008">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L1009">                        mv.visitAnnotation(readUTF8(v, c), false));</span>
            }
        }
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; tanns != 0) {</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">            for (int i = readUnsignedShort(tanns), v = tanns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L1014">                v = readAnnotationTarget(context, v);</span>
<span class="nc" id="L1015">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L1016">                        mv.visitTypeAnnotation(context.typeRef,</span>
<span class="nc" id="L1017">                                context.typePath, readUTF8(v, c), true));</span>
            }
        }
<span class="pc bpc" id="L1020" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; itanns != 0) {</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">            for (int i = readUnsignedShort(itanns), v = itanns + 2; i &gt; 0; --i) {</span>
<span class="nc" id="L1022">                v = readAnnotationTarget(context, v);</span>
<span class="nc" id="L1023">                v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L1024">                        mv.visitTypeAnnotation(context.typeRef,</span>
<span class="nc" id="L1025">                                context.typePath, readUTF8(v, c), false));</span>
            }
        }
<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; mpanns != 0) {</span>
<span class="nc" id="L1029">            readParameterAnnotations(mv, context, mpanns, true);</span>
        }
<span class="pc bpc" id="L1031" title="1 of 2 branches missed.">        if (ANNOTATIONS &amp;&amp; impanns != 0) {</span>
<span class="nc" id="L1032">            readParameterAnnotations(mv, context, impanns, false);</span>
        }

        // visits the method attributes
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">        while (attributes != null) {</span>
<span class="nc" id="L1037">            Attribute attr = attributes.next;</span>
<span class="nc" id="L1038">            attributes.next = null;</span>
<span class="nc" id="L1039">            mv.visitAttribute(attributes);</span>
<span class="nc" id="L1040">            attributes = attr;</span>
<span class="nc" id="L1041">        }</span>

        // visits the method code
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">        if (code != 0) {</span>
<span class="fc" id="L1045">            mv.visitCode();</span>
<span class="fc" id="L1046">            readCode(mv, context, code);</span>
        }

        // visits the end of the method
<span class="fc" id="L1050">        mv.visitEnd();</span>

<span class="fc" id="L1052">        return u;</span>
    }

    /**
     * Reads the bytecode of a method and makes the given visitor visit it.
     *
     * @param mv
     *            the visitor that must visit the method's code.
     * @param context
     *            information about the class being parsed.
     * @param u
     *            the start offset of the code attribute in the class file.
     */
    private void readCode(final MethodVisitor mv, final Context context, int u) {
        // reads the header
<span class="fc" id="L1067">        byte[] b = this.b;</span>
<span class="fc" id="L1068">        char[] c = context.buffer;</span>
<span class="fc" id="L1069">        int maxStack = readUnsignedShort(u);</span>
<span class="fc" id="L1070">        int maxLocals = readUnsignedShort(u + 2);</span>
<span class="fc" id="L1071">        int codeLength = readInt(u + 4);</span>
<span class="fc" id="L1072">        u += 8;</span>

        // reads the bytecode to find the labels
<span class="fc" id="L1075">        int codeStart = u;</span>
<span class="fc" id="L1076">        int codeEnd = u + codeLength;</span>
<span class="fc" id="L1077">        Label[] labels = context.labels = new Label[codeLength + 2];</span>
<span class="fc" id="L1078">        readLabel(codeLength + 1, labels);</span>
<span class="fc bfc" id="L1079" title="All 2 branches covered.">        while (u &lt; codeEnd) {</span>
<span class="fc" id="L1080">            int offset = u - codeStart;</span>
<span class="fc" id="L1081">            int opcode = b[u] &amp; 0xFF;</span>
<span class="pc bpc" id="L1082" title="7 of 10 branches missed.">            switch (ClassWriter.TYPE[opcode]) {</span>
            case ClassWriter.NOARG_INSN:
            case ClassWriter.IMPLVAR_INSN:
<span class="fc" id="L1085">                u += 1;</span>
<span class="fc" id="L1086">                break;</span>
            case ClassWriter.LABEL_INSN:
<span class="nc" id="L1088">                readLabel(offset + readShort(u + 1), labels);</span>
<span class="nc" id="L1089">                u += 3;</span>
<span class="nc" id="L1090">                break;</span>
            case ClassWriter.LABELW_INSN:
<span class="nc" id="L1092">                readLabel(offset + readInt(u + 1), labels);</span>
<span class="nc" id="L1093">                u += 5;</span>
<span class="nc" id="L1094">                break;</span>
            case ClassWriter.WIDE_INSN:
<span class="nc" id="L1096">                opcode = b[u + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L1098">                    u += 6;</span>
                } else {
<span class="nc" id="L1100">                    u += 4;</span>
                }
<span class="nc" id="L1102">                break;</span>
            case ClassWriter.TABL_INSN:
                // skips 0 to 3 padding bytes
<span class="nc" id="L1105">                u = u + 4 - (offset &amp; 3);</span>
                // reads instruction
<span class="nc" id="L1107">                readLabel(offset + readInt(u), labels);</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">                for (int i = readInt(u + 8) - readInt(u + 4) + 1; i &gt; 0; --i) {</span>
<span class="nc" id="L1109">                    readLabel(offset + readInt(u + 12), labels);</span>
<span class="nc" id="L1110">                    u += 4;</span>
                }
<span class="nc" id="L1112">                u += 12;</span>
<span class="nc" id="L1113">                break;</span>
            case ClassWriter.LOOK_INSN:
                // skips 0 to 3 padding bytes
<span class="nc" id="L1116">                u = u + 4 - (offset &amp; 3);</span>
                // reads instruction
<span class="nc" id="L1118">                readLabel(offset + readInt(u), labels);</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">                for (int i = readInt(u + 4); i &gt; 0; --i) {</span>
<span class="nc" id="L1120">                    readLabel(offset + readInt(u + 12), labels);</span>
<span class="nc" id="L1121">                    u += 8;</span>
                }
<span class="nc" id="L1123">                u += 8;</span>
<span class="nc" id="L1124">                break;</span>
            case ClassWriter.VAR_INSN:
            case ClassWriter.SBYTE_INSN:
            case ClassWriter.LDC_INSN:
<span class="fc" id="L1128">                u += 2;</span>
<span class="fc" id="L1129">                break;</span>
            case ClassWriter.SHORT_INSN:
            case ClassWriter.LDCW_INSN:
            case ClassWriter.FIELDORMETH_INSN:
            case ClassWriter.TYPE_INSN:
            case ClassWriter.IINC_INSN:
<span class="fc" id="L1135">                u += 3;</span>
<span class="fc" id="L1136">                break;</span>
            case ClassWriter.ITFMETH_INSN:
            case ClassWriter.INDYMETH_INSN:
<span class="nc" id="L1139">                u += 5;</span>
<span class="nc" id="L1140">                break;</span>
            // case MANA_INSN:
            default:
<span class="nc" id="L1143">                u += 4;</span>
                break;
            }
<span class="fc" id="L1146">        }</span>

        // reads the try catch entries to find the labels, and also visits them
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">        for (int i = readUnsignedShort(u); i &gt; 0; --i) {</span>
<span class="nc" id="L1150">            Label start = readLabel(readUnsignedShort(u + 2), labels);</span>
<span class="nc" id="L1151">            Label end = readLabel(readUnsignedShort(u + 4), labels);</span>
<span class="nc" id="L1152">            Label handler = readLabel(readUnsignedShort(u + 6), labels);</span>
<span class="nc" id="L1153">            String type = readUTF8(items[readUnsignedShort(u + 8)], c);</span>
<span class="nc" id="L1154">            mv.visitTryCatchBlock(start, end, handler, type);</span>
<span class="nc" id="L1155">            u += 8;</span>
        }
<span class="fc" id="L1157">        u += 2;</span>

        // reads the code attributes
<span class="fc" id="L1160">        int[] tanns = null; // start index of each visible type annotation</span>
<span class="fc" id="L1161">        int[] itanns = null; // start index of each invisible type annotation</span>
<span class="fc" id="L1162">        int tann = 0; // current index in tanns array</span>
<span class="fc" id="L1163">        int itann = 0; // current index in itanns array</span>
<span class="fc" id="L1164">        int ntoff = -1; // next visible type annotation code offset</span>
<span class="fc" id="L1165">        int nitoff = -1; // next invisible type annotation code offset</span>
<span class="fc" id="L1166">        int varTable = 0;</span>
<span class="fc" id="L1167">        int varTypeTable = 0;</span>
<span class="fc" id="L1168">        boolean zip = true;</span>
<span class="pc bpc" id="L1169" title="1 of 2 branches missed.">        boolean unzip = (context.flags &amp; EXPAND_FRAMES) != 0;</span>
<span class="fc" id="L1170">        int stackMap = 0;</span>
<span class="fc" id="L1171">        int stackMapSize = 0;</span>
<span class="fc" id="L1172">        int frameCount = 0;</span>
<span class="fc" id="L1173">        Context frame = null;</span>
<span class="fc" id="L1174">        Attribute attributes = null;</span>

<span class="fc bfc" id="L1176" title="All 2 branches covered.">        for (int i = readUnsignedShort(u); i &gt; 0; --i) {</span>
<span class="fc" id="L1177">            String attrName = readUTF8(u + 2, c);</span>
<span class="pc bpc" id="L1178" title="1 of 2 branches missed.">            if (&quot;LocalVariableTable&quot;.equals(attrName)) {</span>
<span class="nc bnc" id="L1179" title="All 2 branches missed.">                if ((context.flags &amp; SKIP_DEBUG) == 0) {</span>
<span class="nc" id="L1180">                    varTable = u + 8;</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">                    for (int j = readUnsignedShort(u + 8), v = u; j &gt; 0; --j) {</span>
<span class="nc" id="L1182">                        int label = readUnsignedShort(v + 10);</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">                        if (labels[label] == null) {</span>
<span class="nc" id="L1184">                            readLabel(label, labels).status |= Label.DEBUG;</span>
                        }
<span class="nc" id="L1186">                        label += readUnsignedShort(v + 12);</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">                        if (labels[label] == null) {</span>
<span class="nc" id="L1188">                            readLabel(label, labels).status |= Label.DEBUG;</span>
                        }
<span class="nc" id="L1190">                        v += 10;</span>
                    }
                }
<span class="pc bpc" id="L1193" title="1 of 2 branches missed.">            } else if (&quot;LocalVariableTypeTable&quot;.equals(attrName)) {</span>
<span class="nc" id="L1194">                varTypeTable = u + 8;</span>
<span class="pc bpc" id="L1195" title="1 of 2 branches missed.">            } else if (&quot;LineNumberTable&quot;.equals(attrName)) {</span>
<span class="pc bpc" id="L1196" title="1 of 2 branches missed.">                if ((context.flags &amp; SKIP_DEBUG) == 0) {</span>
<span class="fc bfc" id="L1197" title="All 2 branches covered.">                    for (int j = readUnsignedShort(u + 8), v = u; j &gt; 0; --j) {</span>
<span class="fc" id="L1198">                        int label = readUnsignedShort(v + 10);</span>
<span class="pc bpc" id="L1199" title="1 of 2 branches missed.">                        if (labels[label] == null) {</span>
<span class="fc" id="L1200">                            readLabel(label, labels).status |= Label.DEBUG;</span>
                        }
<span class="fc" id="L1202">                        labels[label].line = readUnsignedShort(v + 12);</span>
<span class="fc" id="L1203">                        v += 4;</span>
                    }
                }
<span class="nc" id="L1206">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeVisibleTypeAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L1208">                tanns = readTypeAnnotations(mv, context, u + 8, true);</span>
<span class="nc bnc" id="L1209" title="All 4 branches missed.">                ntoff = tanns.length == 0 || readByte(tanns[0]) &lt; 0x43 ? -1</span>
<span class="nc" id="L1210">                        : readUnsignedShort(tanns[0] + 1);</span>
<span class="nc" id="L1211">            } else if (ANNOTATIONS</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">                    &amp;&amp; &quot;RuntimeInvisibleTypeAnnotations&quot;.equals(attrName)) {</span>
<span class="nc" id="L1213">                itanns = readTypeAnnotations(mv, context, u + 8, false);</span>
<span class="nc bnc" id="L1214" title="All 4 branches missed.">                nitoff = itanns.length == 0 || readByte(itanns[0]) &lt; 0x43 ? -1</span>
<span class="nc" id="L1215">                        : readUnsignedShort(itanns[0] + 1);</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">            } else if (FRAMES &amp;&amp; &quot;StackMapTable&quot;.equals(attrName)) {</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">                if ((context.flags &amp; SKIP_FRAMES) == 0) {</span>
<span class="nc" id="L1218">                    stackMap = u + 10;</span>
<span class="nc" id="L1219">                    stackMapSize = readInt(u + 4);</span>
<span class="nc" id="L1220">                    frameCount = readUnsignedShort(u + 8);</span>
                }
                /*
                 * here we do not extract the labels corresponding to the
                 * attribute content. This would require a full parsing of the
                 * attribute, which would need to be repeated in the second
                 * phase (see below). Instead the content of the attribute is
                 * read one frame at a time (i.e. after a frame has been
                 * visited, the next frame is read), and the labels it contains
                 * are also extracted one frame at a time. Thanks to the
                 * ordering of frames, having only a &quot;one frame lookahead&quot; is
                 * not a problem, i.e. it is not possible to see an offset
                 * smaller than the offset of the current insn and for which no
                 * Label exist.
                 */
                /*
                 * This is not true for UNINITIALIZED type offsets. We solve
                 * this by parsing the stack map table without a full decoding
                 * (see below).
                 */
<span class="nc bnc" id="L1240" title="All 2 branches missed.">            } else if (FRAMES &amp;&amp; &quot;StackMap&quot;.equals(attrName)) {</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">                if ((context.flags &amp; SKIP_FRAMES) == 0) {</span>
<span class="nc" id="L1242">                    zip = false;</span>
<span class="nc" id="L1243">                    stackMap = u + 10;</span>
<span class="nc" id="L1244">                    stackMapSize = readInt(u + 4);</span>
<span class="nc" id="L1245">                    frameCount = readUnsignedShort(u + 8);</span>
                }
                /*
                 * IMPORTANT! here we assume that the frames are ordered, as in
                 * the StackMapTable attribute, although this is not guaranteed
                 * by the attribute format.
                 */
            } else {
<span class="nc bnc" id="L1253" title="All 2 branches missed.">                for (int j = 0; j &lt; context.attrs.length; ++j) {</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">                    if (context.attrs[j].type.equals(attrName)) {</span>
<span class="nc" id="L1255">                        Attribute attr = context.attrs[j].read(this, u + 8,</span>
<span class="nc" id="L1256">                                readInt(u + 4), c, codeStart - 8, labels);</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">                        if (attr != null) {</span>
<span class="nc" id="L1258">                            attr.next = attributes;</span>
<span class="nc" id="L1259">                            attributes = attr;</span>
                        }
                    }
                }
            }
<span class="fc" id="L1264">            u += 6 + readInt(u + 4);</span>
        }
<span class="fc" id="L1266">        u += 2;</span>

        // generates the first (implicit) stack map frame
<span class="pc bpc" id="L1269" title="1 of 2 branches missed.">        if (FRAMES &amp;&amp; stackMap != 0) {</span>
            /*
             * for the first explicit frame the offset is not offset_delta + 1
             * but only offset_delta; setting the implicit frame offset to -1
             * allow the use of the &quot;offset_delta + 1&quot; rule in all cases
             */
<span class="nc" id="L1275">            frame = context;</span>
<span class="nc" id="L1276">            frame.offset = -1;</span>
<span class="nc" id="L1277">            frame.mode = 0;</span>
<span class="nc" id="L1278">            frame.localCount = 0;</span>
<span class="nc" id="L1279">            frame.localDiff = 0;</span>
<span class="nc" id="L1280">            frame.stackCount = 0;</span>
<span class="nc" id="L1281">            frame.local = new Object[maxLocals];</span>
<span class="nc" id="L1282">            frame.stack = new Object[maxStack];</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">            if (unzip) {</span>
<span class="nc" id="L1284">                getImplicitFrame(context);</span>
            }
            /*
             * Finds labels for UNINITIALIZED frame types. Instead of decoding
             * each element of the stack map table, we look for 3 consecutive
             * bytes that &quot;look like&quot; an UNINITIALIZED type (tag 8, offset
             * within code bounds, NEW instruction at this offset). We may find
             * false positives (i.e. not real UNINITIALIZED types), but this
             * should be rare, and the only consequence will be the creation of
             * an unneeded label. This is better than creating a label for each
             * NEW instruction, and faster than fully decoding the whole stack
             * map table.
             */
<span class="nc bnc" id="L1297" title="All 2 branches missed.">            for (int i = stackMap; i &lt; stackMap + stackMapSize - 2; ++i) {</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">                if (b[i] == 8) { // UNINITIALIZED FRAME TYPE</span>
<span class="nc" id="L1299">                    int v = readUnsignedShort(i + 1);</span>
<span class="nc bnc" id="L1300" title="All 4 branches missed.">                    if (v &gt;= 0 &amp;&amp; v &lt; codeLength) {</span>
<span class="nc bnc" id="L1301" title="All 2 branches missed.">                        if ((b[codeStart + v] &amp; 0xFF) == Opcodes.NEW) {</span>
<span class="nc" id="L1302">                            readLabel(v, labels);</span>
                        }
                    }
                }
            }
        }

        // visits the instructions
<span class="fc" id="L1310">        u = codeStart;</span>
<span class="fc bfc" id="L1311" title="All 2 branches covered.">        while (u &lt; codeEnd) {</span>
<span class="fc" id="L1312">            int offset = u - codeStart;</span>

            // visits the label and line number for this offset, if any
<span class="fc" id="L1315">            Label l = labels[offset];</span>
<span class="fc bfc" id="L1316" title="All 2 branches covered.">            if (l != null) {</span>
<span class="fc" id="L1317">                mv.visitLabel(l);</span>
<span class="pc bpc" id="L1318" title="2 of 4 branches missed.">                if ((context.flags &amp; SKIP_DEBUG) == 0 &amp;&amp; l.line &gt; 0) {</span>
<span class="fc" id="L1319">                    mv.visitLineNumber(l.line, l);</span>
                }
            }

            // visits the frame for this offset, if any
<span class="pc bpc" id="L1324" title="5 of 6 branches missed.">            while (FRAMES &amp;&amp; frame != null</span>
                    &amp;&amp; (frame.offset == offset || frame.offset == -1)) {
                // if there is a frame for this offset, makes the visitor visit
                // it, and reads the next frame if there is one.
<span class="nc bnc" id="L1328" title="All 2 branches missed.">                if (frame.offset != -1) {</span>
<span class="nc bnc" id="L1329" title="All 4 branches missed.">                    if (!zip || unzip) {</span>
<span class="nc" id="L1330">                        mv.visitFrame(Opcodes.F_NEW, frame.localCount,</span>
                                frame.local, frame.stackCount, frame.stack);
                    } else {
<span class="nc" id="L1333">                        mv.visitFrame(frame.mode, frame.localDiff, frame.local,</span>
                                frame.stackCount, frame.stack);
                    }
                }
<span class="nc bnc" id="L1337" title="All 2 branches missed.">                if (frameCount &gt; 0) {</span>
<span class="nc" id="L1338">                    stackMap = readFrame(stackMap, zip, unzip, frame);</span>
<span class="nc" id="L1339">                    --frameCount;</span>
                } else {
<span class="nc" id="L1341">                    frame = null;</span>
                }
            }

            // visits the instruction at this offset
<span class="fc" id="L1346">            int opcode = b[u] &amp; 0xFF;</span>
<span class="pc bpc" id="L1347" title="13 of 17 branches missed.">            switch (ClassWriter.TYPE[opcode]) {</span>
            case ClassWriter.NOARG_INSN:
<span class="fc" id="L1349">                mv.visitInsn(opcode);</span>
<span class="fc" id="L1350">                u += 1;</span>
<span class="fc" id="L1351">                break;</span>
            case ClassWriter.IMPLVAR_INSN:
<span class="pc bpc" id="L1353" title="1 of 2 branches missed.">                if (opcode &gt; Opcodes.ISTORE) {</span>
<span class="nc" id="L1354">                    opcode -= 59; // ISTORE_0</span>
<span class="nc" id="L1355">                    mv.visitVarInsn(Opcodes.ISTORE + (opcode &gt;&gt; 2),</span>
                            opcode &amp; 0x3);
                } else {
<span class="fc" id="L1358">                    opcode -= 26; // ILOAD_0</span>
<span class="fc" id="L1359">                    mv.visitVarInsn(Opcodes.ILOAD + (opcode &gt;&gt; 2), opcode &amp; 0x3);</span>
                }
<span class="fc" id="L1361">                u += 1;</span>
<span class="fc" id="L1362">                break;</span>
            case ClassWriter.LABEL_INSN:
<span class="nc" id="L1364">                mv.visitJumpInsn(opcode, labels[offset + readShort(u + 1)]);</span>
<span class="nc" id="L1365">                u += 3;</span>
<span class="nc" id="L1366">                break;</span>
            case ClassWriter.LABELW_INSN:
<span class="nc" id="L1368">                mv.visitJumpInsn(opcode - 33, labels[offset + readInt(u + 1)]);</span>
<span class="nc" id="L1369">                u += 5;</span>
<span class="nc" id="L1370">                break;</span>
            case ClassWriter.WIDE_INSN:
<span class="nc" id="L1372">                opcode = b[u + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">                if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L1374">                    mv.visitIincInsn(readUnsignedShort(u + 2), readShort(u + 4));</span>
<span class="nc" id="L1375">                    u += 6;</span>
                } else {
<span class="nc" id="L1377">                    mv.visitVarInsn(opcode, readUnsignedShort(u + 2));</span>
<span class="nc" id="L1378">                    u += 4;</span>
                }
<span class="nc" id="L1380">                break;</span>
            case ClassWriter.TABL_INSN: {
                // skips 0 to 3 padding bytes
<span class="nc" id="L1383">                u = u + 4 - (offset &amp; 3);</span>
                // reads instruction
<span class="nc" id="L1385">                int label = offset + readInt(u);</span>
<span class="nc" id="L1386">                int min = readInt(u + 4);</span>
<span class="nc" id="L1387">                int max = readInt(u + 8);</span>
<span class="nc" id="L1388">                Label[] table = new Label[max - min + 1];</span>
<span class="nc" id="L1389">                u += 12;</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">                for (int i = 0; i &lt; table.length; ++i) {</span>
<span class="nc" id="L1391">                    table[i] = labels[offset + readInt(u)];</span>
<span class="nc" id="L1392">                    u += 4;</span>
                }
<span class="nc" id="L1394">                mv.visitTableSwitchInsn(min, max, labels[label], table);</span>
<span class="nc" id="L1395">                break;</span>
            }
            case ClassWriter.LOOK_INSN: {
                // skips 0 to 3 padding bytes
<span class="nc" id="L1399">                u = u + 4 - (offset &amp; 3);</span>
                // reads instruction
<span class="nc" id="L1401">                int label = offset + readInt(u);</span>
<span class="nc" id="L1402">                int len = readInt(u + 4);</span>
<span class="nc" id="L1403">                int[] keys = new int[len];</span>
<span class="nc" id="L1404">                Label[] values = new Label[len];</span>
<span class="nc" id="L1405">                u += 8;</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">                for (int i = 0; i &lt; len; ++i) {</span>
<span class="nc" id="L1407">                    keys[i] = readInt(u);</span>
<span class="nc" id="L1408">                    values[i] = labels[offset + readInt(u + 4)];</span>
<span class="nc" id="L1409">                    u += 8;</span>
                }
<span class="nc" id="L1411">                mv.visitLookupSwitchInsn(labels[label], keys, values);</span>
<span class="nc" id="L1412">                break;</span>
            }
            case ClassWriter.VAR_INSN:
<span class="nc" id="L1415">                mv.visitVarInsn(opcode, b[u + 1] &amp; 0xFF);</span>
<span class="nc" id="L1416">                u += 2;</span>
<span class="nc" id="L1417">                break;</span>
            case ClassWriter.SBYTE_INSN:
<span class="nc" id="L1419">                mv.visitIntInsn(opcode, b[u + 1]);</span>
<span class="nc" id="L1420">                u += 2;</span>
<span class="nc" id="L1421">                break;</span>
            case ClassWriter.SHORT_INSN:
<span class="nc" id="L1423">                mv.visitIntInsn(opcode, readShort(u + 1));</span>
<span class="nc" id="L1424">                u += 3;</span>
<span class="nc" id="L1425">                break;</span>
            case ClassWriter.LDC_INSN:
<span class="fc" id="L1427">                mv.visitLdcInsn(readConst(b[u + 1] &amp; 0xFF, c));</span>
<span class="fc" id="L1428">                u += 2;</span>
<span class="fc" id="L1429">                break;</span>
            case ClassWriter.LDCW_INSN:
<span class="nc" id="L1431">                mv.visitLdcInsn(readConst(readUnsignedShort(u + 1), c));</span>
<span class="nc" id="L1432">                u += 3;</span>
<span class="nc" id="L1433">                break;</span>
            case ClassWriter.FIELDORMETH_INSN:
            case ClassWriter.ITFMETH_INSN: {
<span class="fc" id="L1436">                int cpIndex = items[readUnsignedShort(u + 1)];</span>
<span class="pc bpc" id="L1437" title="1 of 2 branches missed.">                boolean itf = b[cpIndex - 1] == ClassWriter.IMETH;</span>
<span class="fc" id="L1438">                String iowner = readClass(cpIndex, c);</span>
<span class="fc" id="L1439">                cpIndex = items[readUnsignedShort(cpIndex + 2)];</span>
<span class="fc" id="L1440">                String iname = readUTF8(cpIndex, c);</span>
<span class="fc" id="L1441">                String idesc = readUTF8(cpIndex + 2, c);</span>
<span class="fc bfc" id="L1442" title="All 2 branches covered.">                if (opcode &lt; Opcodes.INVOKEVIRTUAL) {</span>
<span class="fc" id="L1443">                    mv.visitFieldInsn(opcode, iowner, iname, idesc);</span>
                } else {
<span class="fc" id="L1445">                    mv.visitMethodInsn(opcode, iowner, iname, idesc, itf);</span>
                }
<span class="pc bpc" id="L1447" title="1 of 2 branches missed.">                if (opcode == Opcodes.INVOKEINTERFACE) {</span>
<span class="nc" id="L1448">                    u += 5;</span>
                } else {
<span class="fc" id="L1450">                    u += 3;</span>
                }
<span class="fc" id="L1452">                break;</span>
            }
            case ClassWriter.INDYMETH_INSN: {
<span class="nc" id="L1455">                int cpIndex = items[readUnsignedShort(u + 1)];</span>
<span class="nc" id="L1456">                int bsmIndex = context.bootstrapMethods[readUnsignedShort(cpIndex)];</span>
<span class="nc" id="L1457">                Handle bsm = (Handle) readConst(readUnsignedShort(bsmIndex), c);</span>
<span class="nc" id="L1458">                int bsmArgCount = readUnsignedShort(bsmIndex + 2);</span>
<span class="nc" id="L1459">                Object[] bsmArgs = new Object[bsmArgCount];</span>
<span class="nc" id="L1460">                bsmIndex += 4;</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">                for (int i = 0; i &lt; bsmArgCount; i++) {</span>
<span class="nc" id="L1462">                    bsmArgs[i] = readConst(readUnsignedShort(bsmIndex), c);</span>
<span class="nc" id="L1463">                    bsmIndex += 2;</span>
                }
<span class="nc" id="L1465">                cpIndex = items[readUnsignedShort(cpIndex + 2)];</span>
<span class="nc" id="L1466">                String iname = readUTF8(cpIndex, c);</span>
<span class="nc" id="L1467">                String idesc = readUTF8(cpIndex + 2, c);</span>
<span class="nc" id="L1468">                mv.visitInvokeDynamicInsn(iname, idesc, bsm, bsmArgs);</span>
<span class="nc" id="L1469">                u += 5;</span>
<span class="nc" id="L1470">                break;</span>
            }
            case ClassWriter.TYPE_INSN:
<span class="nc" id="L1473">                mv.visitTypeInsn(opcode, readClass(u + 1, c));</span>
<span class="nc" id="L1474">                u += 3;</span>
<span class="nc" id="L1475">                break;</span>
            case ClassWriter.IINC_INSN:
<span class="nc" id="L1477">                mv.visitIincInsn(b[u + 1] &amp; 0xFF, b[u + 2]);</span>
<span class="nc" id="L1478">                u += 3;</span>
<span class="nc" id="L1479">                break;</span>
            // case MANA_INSN:
            default:
<span class="nc" id="L1482">                mv.visitMultiANewArrayInsn(readClass(u + 1, c), b[u + 3] &amp; 0xFF);</span>
<span class="nc" id="L1483">                u += 4;</span>
                break;
            }

            // visit the instruction annotations, if any
<span class="pc bpc" id="L1488" title="5 of 6 branches missed.">            while (tanns != null &amp;&amp; tann &lt; tanns.length &amp;&amp; ntoff &lt;= offset) {</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">                if (ntoff == offset) {</span>
<span class="nc" id="L1490">                    int v = readAnnotationTarget(context, tanns[tann]);</span>
<span class="nc" id="L1491">                    readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L1492">                            mv.visitInsnAnnotation(context.typeRef,</span>
<span class="nc" id="L1493">                                    context.typePath, readUTF8(v, c), true));</span>
                }
<span class="nc bnc" id="L1495" title="All 4 branches missed.">                ntoff = ++tann &gt;= tanns.length || readByte(tanns[tann]) &lt; 0x43 ? -1</span>
<span class="nc" id="L1496">                        : readUnsignedShort(tanns[tann] + 1);</span>
            }
<span class="pc bpc" id="L1498" title="5 of 6 branches missed.">            while (itanns != null &amp;&amp; itann &lt; itanns.length &amp;&amp; nitoff &lt;= offset) {</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">                if (nitoff == offset) {</span>
<span class="nc" id="L1500">                    int v = readAnnotationTarget(context, itanns[itann]);</span>
<span class="nc" id="L1501">                    readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L1502">                            mv.visitInsnAnnotation(context.typeRef,</span>
<span class="nc" id="L1503">                                    context.typePath, readUTF8(v, c), false));</span>
                }
<span class="nc bnc" id="L1505" title="All 2 branches missed.">                nitoff = ++itann &gt;= itanns.length</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">                        || readByte(itanns[itann]) &lt; 0x43 ? -1</span>
<span class="nc" id="L1507">                        : readUnsignedShort(itanns[itann] + 1);</span>
            }
<span class="fc" id="L1509">        }</span>
<span class="pc bpc" id="L1510" title="1 of 2 branches missed.">        if (labels[codeLength] != null) {</span>
<span class="nc" id="L1511">            mv.visitLabel(labels[codeLength]);</span>
        }

        // visits the local variable tables
<span class="pc bpc" id="L1515" title="2 of 4 branches missed.">        if ((context.flags &amp; SKIP_DEBUG) == 0 &amp;&amp; varTable != 0) {</span>
<span class="nc" id="L1516">            int[] typeTable = null;</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">            if (varTypeTable != 0) {</span>
<span class="nc" id="L1518">                u = varTypeTable + 2;</span>
<span class="nc" id="L1519">                typeTable = new int[readUnsignedShort(varTypeTable) * 3];</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">                for (int i = typeTable.length; i &gt; 0;) {</span>
<span class="nc" id="L1521">                    typeTable[--i] = u + 6; // signature</span>
<span class="nc" id="L1522">                    typeTable[--i] = readUnsignedShort(u + 8); // index</span>
<span class="nc" id="L1523">                    typeTable[--i] = readUnsignedShort(u); // start</span>
<span class="nc" id="L1524">                    u += 10;</span>
                }
            }
<span class="nc" id="L1527">            u = varTable + 2;</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">            for (int i = readUnsignedShort(varTable); i &gt; 0; --i) {</span>
<span class="nc" id="L1529">                int start = readUnsignedShort(u);</span>
<span class="nc" id="L1530">                int length = readUnsignedShort(u + 2);</span>
<span class="nc" id="L1531">                int index = readUnsignedShort(u + 8);</span>
<span class="nc" id="L1532">                String vsignature = null;</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">                if (typeTable != null) {</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">                    for (int j = 0; j &lt; typeTable.length; j += 3) {</span>
<span class="nc bnc" id="L1535" title="All 4 branches missed.">                        if (typeTable[j] == start &amp;&amp; typeTable[j + 1] == index) {</span>
<span class="nc" id="L1536">                            vsignature = readUTF8(typeTable[j + 2], c);</span>
<span class="nc" id="L1537">                            break;</span>
                        }
                    }
                }
<span class="nc" id="L1541">                mv.visitLocalVariable(readUTF8(u + 4, c), readUTF8(u + 6, c),</span>
                        vsignature, labels[start], labels[start + length],
                        index);
<span class="nc" id="L1544">                u += 10;</span>
            }
        }

        // visits the local variables type annotations
<span class="pc bpc" id="L1549" title="1 of 2 branches missed.">        if (tanns != null) {</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">            for (int i = 0; i &lt; tanns.length; ++i) {</span>
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                if ((readByte(tanns[i]) &gt;&gt; 1) == (0x40 &gt;&gt; 1)) {</span>
<span class="nc" id="L1552">                    int v = readAnnotationTarget(context, tanns[i]);</span>
<span class="nc" id="L1553">                    v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L1554">                            mv.visitLocalVariableAnnotation(context.typeRef,</span>
                                    context.typePath, context.start,
<span class="nc" id="L1556">                                    context.end, context.index, readUTF8(v, c),</span>
                                    true));
                }
            }
        }
<span class="pc bpc" id="L1561" title="1 of 2 branches missed.">        if (itanns != null) {</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">            for (int i = 0; i &lt; itanns.length; ++i) {</span>
<span class="nc bnc" id="L1563" title="All 2 branches missed.">                if ((readByte(itanns[i]) &gt;&gt; 1) == (0x40 &gt;&gt; 1)) {</span>
<span class="nc" id="L1564">                    int v = readAnnotationTarget(context, itanns[i]);</span>
<span class="nc" id="L1565">                    v = readAnnotationValues(v + 2, c, true,</span>
<span class="nc" id="L1566">                            mv.visitLocalVariableAnnotation(context.typeRef,</span>
                                    context.typePath, context.start,
<span class="nc" id="L1568">                                    context.end, context.index, readUTF8(v, c),</span>
                                    false));
                }
            }
        }

        // visits the code attributes
<span class="pc bpc" id="L1575" title="1 of 2 branches missed.">        while (attributes != null) {</span>
<span class="nc" id="L1576">            Attribute attr = attributes.next;</span>
<span class="nc" id="L1577">            attributes.next = null;</span>
<span class="nc" id="L1578">            mv.visitAttribute(attributes);</span>
<span class="nc" id="L1579">            attributes = attr;</span>
<span class="nc" id="L1580">        }</span>

        // visits the max stack and max locals values
<span class="fc" id="L1583">        mv.visitMaxs(maxStack, maxLocals);</span>
<span class="fc" id="L1584">    }</span>

    /**
     * Parses a type annotation table to find the labels, and to visit the try
     * catch block annotations.
     *
     * @param u
     *            the start offset of a type annotation table.
     * @param mv
     *            the method visitor to be used to visit the try catch block
     *            annotations.
     * @param context
     *            information about the class being parsed.
     * @param visible
     *            if the type annotation table to parse contains runtime visible
     *            annotations.
     * @return the start offset of each type annotation in the parsed table.
     */
    private int[] readTypeAnnotations(final MethodVisitor mv,
            final Context context, int u, boolean visible) {
<span class="nc" id="L1604">        char[] c = context.buffer;</span>
<span class="nc" id="L1605">        int[] offsets = new int[readUnsignedShort(u)];</span>
<span class="nc" id="L1606">        u += 2;</span>
<span class="nc bnc" id="L1607" title="All 2 branches missed.">        for (int i = 0; i &lt; offsets.length; ++i) {</span>
<span class="nc" id="L1608">            offsets[i] = u;</span>
<span class="nc" id="L1609">            int target = readInt(u);</span>
<span class="nc bnc" id="L1610" title="All 5 branches missed.">            switch (target &gt;&gt;&gt; 24) {</span>
            case 0x00: // CLASS_TYPE_PARAMETER
            case 0x01: // METHOD_TYPE_PARAMETER
            case 0x16: // METHOD_FORMAL_PARAMETER
<span class="nc" id="L1614">                u += 2;</span>
<span class="nc" id="L1615">                break;</span>
            case 0x13: // FIELD
            case 0x14: // METHOD_RETURN
            case 0x15: // METHOD_RECEIVER
<span class="nc" id="L1619">                u += 1;</span>
<span class="nc" id="L1620">                break;</span>
            case 0x40: // LOCAL_VARIABLE
            case 0x41: // RESOURCE_VARIABLE
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                for (int j = readUnsignedShort(u + 1); j &gt; 0; --j) {</span>
<span class="nc" id="L1624">                    int start = readUnsignedShort(u + 3);</span>
<span class="nc" id="L1625">                    int length = readUnsignedShort(u + 5);</span>
<span class="nc" id="L1626">                    readLabel(start, context.labels);</span>
<span class="nc" id="L1627">                    readLabel(start + length, context.labels);</span>
<span class="nc" id="L1628">                    u += 6;</span>
                }
<span class="nc" id="L1630">                u += 3;</span>
<span class="nc" id="L1631">                break;</span>
            case 0x47: // CAST
            case 0x48: // CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
            case 0x49: // METHOD_INVOCATION_TYPE_ARGUMENT
            case 0x4A: // CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
            case 0x4B: // METHOD_REFERENCE_TYPE_ARGUMENT
<span class="nc" id="L1637">                u += 4;</span>
<span class="nc" id="L1638">                break;</span>
            // case 0x10: // CLASS_EXTENDS
            // case 0x11: // CLASS_TYPE_PARAMETER_BOUND
            // case 0x12: // METHOD_TYPE_PARAMETER_BOUND
            // case 0x17: // THROWS
            // case 0x42: // EXCEPTION_PARAMETER
            // case 0x43: // INSTANCEOF
            // case 0x44: // NEW
            // case 0x45: // CONSTRUCTOR_REFERENCE
            // case 0x46: // METHOD_REFERENCE
            default:
<span class="nc" id="L1649">                u += 3;</span>
                break;
            }
<span class="nc" id="L1652">            int pathLength = readByte(u);</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">            if ((target &gt;&gt;&gt; 24) == 0x42) {</span>
<span class="nc bnc" id="L1654" title="All 2 branches missed.">                TypePath path = pathLength == 0 ? null : new TypePath(b, u);</span>
<span class="nc" id="L1655">                u += 1 + 2 * pathLength;</span>
<span class="nc" id="L1656">                u = readAnnotationValues(u + 2, c, true,</span>
<span class="nc" id="L1657">                        mv.visitTryCatchAnnotation(target, path,</span>
<span class="nc" id="L1658">                                readUTF8(u, c), visible));</span>
<span class="nc" id="L1659">            } else {</span>
<span class="nc" id="L1660">                u = readAnnotationValues(u + 3 + 2 * pathLength, c, true, null);</span>
            }
        }
<span class="nc" id="L1663">        return offsets;</span>
    }

    /**
     * Parses the header of a type annotation to extract its target_type and
     * target_path (the result is stored in the given context), and returns the
     * start offset of the rest of the type_annotation structure (i.e. the
     * offset to the type_index field, which is followed by
     * num_element_value_pairs and then the name,value pairs).
     *
     * @param context
     *            information about the class being parsed. This is where the
     *            extracted target_type and target_path must be stored.
     * @param u
     *            the start offset of a type_annotation structure.
     * @return the start offset of the rest of the type_annotation structure.
     */
    private int readAnnotationTarget(final Context context, int u) {
<span class="nc" id="L1681">        int target = readInt(u);</span>
<span class="nc bnc" id="L1682" title="All 5 branches missed.">        switch (target &gt;&gt;&gt; 24) {</span>
        case 0x00: // CLASS_TYPE_PARAMETER
        case 0x01: // METHOD_TYPE_PARAMETER
        case 0x16: // METHOD_FORMAL_PARAMETER
<span class="nc" id="L1686">            target &amp;= 0xFFFF0000;</span>
<span class="nc" id="L1687">            u += 2;</span>
<span class="nc" id="L1688">            break;</span>
        case 0x13: // FIELD
        case 0x14: // METHOD_RETURN
        case 0x15: // METHOD_RECEIVER
<span class="nc" id="L1692">            target &amp;= 0xFF000000;</span>
<span class="nc" id="L1693">            u += 1;</span>
<span class="nc" id="L1694">            break;</span>
        case 0x40: // LOCAL_VARIABLE
        case 0x41: { // RESOURCE_VARIABLE
<span class="nc" id="L1697">            target &amp;= 0xFF000000;</span>
<span class="nc" id="L1698">            int n = readUnsignedShort(u + 1);</span>
<span class="nc" id="L1699">            context.start = new Label[n];</span>
<span class="nc" id="L1700">            context.end = new Label[n];</span>
<span class="nc" id="L1701">            context.index = new int[n];</span>
<span class="nc" id="L1702">            u += 3;</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">            for (int i = 0; i &lt; n; ++i) {</span>
<span class="nc" id="L1704">                int start = readUnsignedShort(u);</span>
<span class="nc" id="L1705">                int length = readUnsignedShort(u + 2);</span>
<span class="nc" id="L1706">                context.start[i] = readLabel(start, context.labels);</span>
<span class="nc" id="L1707">                context.end[i] = readLabel(start + length, context.labels);</span>
<span class="nc" id="L1708">                context.index[i] = readUnsignedShort(u + 4);</span>
<span class="nc" id="L1709">                u += 6;</span>
            }
<span class="nc" id="L1711">            break;</span>
        }
        case 0x47: // CAST
        case 0x48: // CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
        case 0x49: // METHOD_INVOCATION_TYPE_ARGUMENT
        case 0x4A: // CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
        case 0x4B: // METHOD_REFERENCE_TYPE_ARGUMENT
<span class="nc" id="L1718">            target &amp;= 0xFF0000FF;</span>
<span class="nc" id="L1719">            u += 4;</span>
<span class="nc" id="L1720">            break;</span>
        // case 0x10: // CLASS_EXTENDS
        // case 0x11: // CLASS_TYPE_PARAMETER_BOUND
        // case 0x12: // METHOD_TYPE_PARAMETER_BOUND
        // case 0x17: // THROWS
        // case 0x42: // EXCEPTION_PARAMETER
        // case 0x43: // INSTANCEOF
        // case 0x44: // NEW
        // case 0x45: // CONSTRUCTOR_REFERENCE
        // case 0x46: // METHOD_REFERENCE
        default:
<span class="nc bnc" id="L1731" title="All 2 branches missed.">            target &amp;= (target &gt;&gt;&gt; 24) &lt; 0x43 ? 0xFFFFFF00 : 0xFF000000;</span>
<span class="nc" id="L1732">            u += 3;</span>
            break;
        }
<span class="nc" id="L1735">        int pathLength = readByte(u);</span>
<span class="nc" id="L1736">        context.typeRef = target;</span>
<span class="nc bnc" id="L1737" title="All 2 branches missed.">        context.typePath = pathLength == 0 ? null : new TypePath(b, u);</span>
<span class="nc" id="L1738">        return u + 1 + 2 * pathLength;</span>
    }

    /**
     * Reads parameter annotations and makes the given visitor visit them.
     *
     * @param mv
     *            the visitor that must visit the annotations.
     * @param context
     *            information about the class being parsed.
     * @param v
     *            start offset in {@link #b b} of the annotations to be read.
     * @param visible
     *            &lt;tt&gt;true&lt;/tt&gt; if the annotations to be read are visible at
     *            runtime.
     */
    private void readParameterAnnotations(final MethodVisitor mv,
            final Context context, int v, final boolean visible) {
        int i;
<span class="nc" id="L1757">        int n = b[v++] &amp; 0xFF;</span>
        // workaround for a bug in javac (javac compiler generates a parameter
        // annotation array whose size is equal to the number of parameters in
        // the Java source file, while it should generate an array whose size is
        // equal to the number of parameters in the method descriptor - which
        // includes the synthetic parameters added by the compiler). This work-
        // around supposes that the synthetic parameters are the first ones.
<span class="nc" id="L1764">        int synthetics = Type.getArgumentTypes(context.desc).length - n;</span>
        AnnotationVisitor av;
<span class="nc bnc" id="L1766" title="All 2 branches missed.">        for (i = 0; i &lt; synthetics; ++i) {</span>
            // virtual annotation to detect synthetic parameters in MethodWriter
<span class="nc" id="L1768">            av = mv.visitParameterAnnotation(i, &quot;Ljava/lang/Synthetic;&quot;, false);</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">            if (av != null) {</span>
<span class="nc" id="L1770">                av.visitEnd();</span>
            }
        }
<span class="nc" id="L1773">        char[] c = context.buffer;</span>
<span class="nc bnc" id="L1774" title="All 2 branches missed.">        for (; i &lt; n + synthetics; ++i) {</span>
<span class="nc" id="L1775">            int j = readUnsignedShort(v);</span>
<span class="nc" id="L1776">            v += 2;</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">            for (; j &gt; 0; --j) {</span>
<span class="nc" id="L1778">                av = mv.visitParameterAnnotation(i, readUTF8(v, c), visible);</span>
<span class="nc" id="L1779">                v = readAnnotationValues(v + 2, c, true, av);</span>
            }
        }
<span class="nc" id="L1782">    }</span>

    /**
     * Reads the values of an annotation and makes the given visitor visit them.
     *
     * @param v
     *            the start offset in {@link #b b} of the values to be read
     *            (including the unsigned short that gives the number of
     *            values).
     * @param buf
     *            buffer to be used to call {@link #readUTF8 readUTF8},
     *            {@link #readClass(int,char[]) readClass} or {@link #readConst
     *            readConst}.
     * @param named
     *            if the annotation values are named or not.
     * @param av
     *            the visitor that must visit the values.
     * @return the end offset of the annotation values.
     */
    private int readAnnotationValues(int v, final char[] buf,
            final boolean named, final AnnotationVisitor av) {
<span class="nc" id="L1803">        int i = readUnsignedShort(v);</span>
<span class="nc" id="L1804">        v += 2;</span>
<span class="nc bnc" id="L1805" title="All 2 branches missed.">        if (named) {</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">            for (; i &gt; 0; --i) {</span>
<span class="nc" id="L1807">                v = readAnnotationValue(v + 2, buf, readUTF8(v, buf), av);</span>
            }
        } else {
<span class="nc bnc" id="L1810" title="All 2 branches missed.">            for (; i &gt; 0; --i) {</span>
<span class="nc" id="L1811">                v = readAnnotationValue(v, buf, null, av);</span>
            }
        }
<span class="nc bnc" id="L1814" title="All 2 branches missed.">        if (av != null) {</span>
<span class="nc" id="L1815">            av.visitEnd();</span>
        }
<span class="nc" id="L1817">        return v;</span>
    }

    /**
     * Reads a value of an annotation and makes the given visitor visit it.
     *
     * @param v
     *            the start offset in {@link #b b} of the value to be read
     *            (&lt;i&gt;not including the value name constant pool index&lt;/i&gt;).
     * @param buf
     *            buffer to be used to call {@link #readUTF8 readUTF8},
     *            {@link #readClass(int,char[]) readClass} or {@link #readConst
     *            readConst}.
     * @param name
     *            the name of the value to be read.
     * @param av
     *            the visitor that must visit the value.
     * @return the end offset of the annotation value.
     */
    private int readAnnotationValue(int v, final char[] buf, final String name,
            final AnnotationVisitor av) {
        int i;
<span class="nc bnc" id="L1839" title="All 2 branches missed.">        if (av == null) {</span>
<span class="nc bnc" id="L1840" title="All 4 branches missed.">            switch (b[v] &amp; 0xFF) {</span>
            case 'e': // enum_const_value
<span class="nc" id="L1842">                return v + 5;</span>
            case '@': // annotation_value
<span class="nc" id="L1844">                return readAnnotationValues(v + 3, buf, true, null);</span>
            case '[': // array_value
<span class="nc" id="L1846">                return readAnnotationValues(v + 1, buf, false, null);</span>
            default:
<span class="nc" id="L1848">                return v + 3;</span>
            }
        }
<span class="nc bnc" id="L1851" title="All 11 branches missed.">        switch (b[v++] &amp; 0xFF) {</span>
        case 'I': // pointer to CONSTANT_Integer
        case 'J': // pointer to CONSTANT_Long
        case 'F': // pointer to CONSTANT_Float
        case 'D': // pointer to CONSTANT_Double
<span class="nc" id="L1856">            av.visit(name, readConst(readUnsignedShort(v), buf));</span>
<span class="nc" id="L1857">            v += 2;</span>
<span class="nc" id="L1858">            break;</span>
        case 'B': // pointer to CONSTANT_Byte
<span class="nc" id="L1860">            av.visit(name,</span>
<span class="nc" id="L1861">                    new Byte((byte) readInt(items[readUnsignedShort(v)])));</span>
<span class="nc" id="L1862">            v += 2;</span>
<span class="nc" id="L1863">            break;</span>
        case 'Z': // pointer to CONSTANT_Boolean
<span class="nc" id="L1865">            av.visit(name,</span>
<span class="nc bnc" id="L1866" title="All 2 branches missed.">                    readInt(items[readUnsignedShort(v)]) == 0 ? Boolean.FALSE</span>
                            : Boolean.TRUE);
<span class="nc" id="L1868">            v += 2;</span>
<span class="nc" id="L1869">            break;</span>
        case 'S': // pointer to CONSTANT_Short
<span class="nc" id="L1871">            av.visit(name, new Short(</span>
<span class="nc" id="L1872">                    (short) readInt(items[readUnsignedShort(v)])));</span>
<span class="nc" id="L1873">            v += 2;</span>
<span class="nc" id="L1874">            break;</span>
        case 'C': // pointer to CONSTANT_Char
<span class="nc" id="L1876">            av.visit(name, new Character(</span>
<span class="nc" id="L1877">                    (char) readInt(items[readUnsignedShort(v)])));</span>
<span class="nc" id="L1878">            v += 2;</span>
<span class="nc" id="L1879">            break;</span>
        case 's': // pointer to CONSTANT_Utf8
<span class="nc" id="L1881">            av.visit(name, readUTF8(v, buf));</span>
<span class="nc" id="L1882">            v += 2;</span>
<span class="nc" id="L1883">            break;</span>
        case 'e': // enum_const_value
<span class="nc" id="L1885">            av.visitEnum(name, readUTF8(v, buf), readUTF8(v + 2, buf));</span>
<span class="nc" id="L1886">            v += 4;</span>
<span class="nc" id="L1887">            break;</span>
        case 'c': // class_info
<span class="nc" id="L1889">            av.visit(name, Type.getType(readUTF8(v, buf)));</span>
<span class="nc" id="L1890">            v += 2;</span>
<span class="nc" id="L1891">            break;</span>
        case '@': // annotation_value
<span class="nc" id="L1893">            v = readAnnotationValues(v + 2, buf, true,</span>
<span class="nc" id="L1894">                    av.visitAnnotation(name, readUTF8(v, buf)));</span>
<span class="nc" id="L1895">            break;</span>
        case '[': // array_value
<span class="nc" id="L1897">            int size = readUnsignedShort(v);</span>
<span class="nc" id="L1898">            v += 2;</span>
<span class="nc bnc" id="L1899" title="All 2 branches missed.">            if (size == 0) {</span>
<span class="nc" id="L1900">                return readAnnotationValues(v - 2, buf, false,</span>
<span class="nc" id="L1901">                        av.visitArray(name));</span>
            }
<span class="nc bnc" id="L1903" title="All 9 branches missed.">            switch (this.b[v++] &amp; 0xFF) {</span>
            case 'B':
<span class="nc" id="L1905">                byte[] bv = new byte[size];</span>
<span class="nc bnc" id="L1906" title="All 2 branches missed.">                for (i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1907">                    bv[i] = (byte) readInt(items[readUnsignedShort(v)]);</span>
<span class="nc" id="L1908">                    v += 3;</span>
                }
<span class="nc" id="L1910">                av.visit(name, bv);</span>
<span class="nc" id="L1911">                --v;</span>
<span class="nc" id="L1912">                break;</span>
            case 'Z':
<span class="nc" id="L1914">                boolean[] zv = new boolean[size];</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">                for (i = 0; i &lt; size; i++) {</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">                    zv[i] = readInt(items[readUnsignedShort(v)]) != 0;</span>
<span class="nc" id="L1917">                    v += 3;</span>
                }
<span class="nc" id="L1919">                av.visit(name, zv);</span>
<span class="nc" id="L1920">                --v;</span>
<span class="nc" id="L1921">                break;</span>
            case 'S':
<span class="nc" id="L1923">                short[] sv = new short[size];</span>
<span class="nc bnc" id="L1924" title="All 2 branches missed.">                for (i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1925">                    sv[i] = (short) readInt(items[readUnsignedShort(v)]);</span>
<span class="nc" id="L1926">                    v += 3;</span>
                }
<span class="nc" id="L1928">                av.visit(name, sv);</span>
<span class="nc" id="L1929">                --v;</span>
<span class="nc" id="L1930">                break;</span>
            case 'C':
<span class="nc" id="L1932">                char[] cv = new char[size];</span>
<span class="nc bnc" id="L1933" title="All 2 branches missed.">                for (i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1934">                    cv[i] = (char) readInt(items[readUnsignedShort(v)]);</span>
<span class="nc" id="L1935">                    v += 3;</span>
                }
<span class="nc" id="L1937">                av.visit(name, cv);</span>
<span class="nc" id="L1938">                --v;</span>
<span class="nc" id="L1939">                break;</span>
            case 'I':
<span class="nc" id="L1941">                int[] iv = new int[size];</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">                for (i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1943">                    iv[i] = readInt(items[readUnsignedShort(v)]);</span>
<span class="nc" id="L1944">                    v += 3;</span>
                }
<span class="nc" id="L1946">                av.visit(name, iv);</span>
<span class="nc" id="L1947">                --v;</span>
<span class="nc" id="L1948">                break;</span>
            case 'J':
<span class="nc" id="L1950">                long[] lv = new long[size];</span>
<span class="nc bnc" id="L1951" title="All 2 branches missed.">                for (i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1952">                    lv[i] = readLong(items[readUnsignedShort(v)]);</span>
<span class="nc" id="L1953">                    v += 3;</span>
                }
<span class="nc" id="L1955">                av.visit(name, lv);</span>
<span class="nc" id="L1956">                --v;</span>
<span class="nc" id="L1957">                break;</span>
            case 'F':
<span class="nc" id="L1959">                float[] fv = new float[size];</span>
<span class="nc bnc" id="L1960" title="All 2 branches missed.">                for (i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1961">                    fv[i] = Float</span>
<span class="nc" id="L1962">                            .intBitsToFloat(readInt(items[readUnsignedShort(v)]));</span>
<span class="nc" id="L1963">                    v += 3;</span>
                }
<span class="nc" id="L1965">                av.visit(name, fv);</span>
<span class="nc" id="L1966">                --v;</span>
<span class="nc" id="L1967">                break;</span>
            case 'D':
<span class="nc" id="L1969">                double[] dv = new double[size];</span>
<span class="nc bnc" id="L1970" title="All 2 branches missed.">                for (i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1971">                    dv[i] = Double</span>
<span class="nc" id="L1972">                            .longBitsToDouble(readLong(items[readUnsignedShort(v)]));</span>
<span class="nc" id="L1973">                    v += 3;</span>
                }
<span class="nc" id="L1975">                av.visit(name, dv);</span>
<span class="nc" id="L1976">                --v;</span>
<span class="nc" id="L1977">                break;</span>
            default:
<span class="nc" id="L1979">                v = readAnnotationValues(v - 3, buf, false, av.visitArray(name));</span>
            }
        }
<span class="nc" id="L1982">        return v;</span>
    }

    /**
     * Computes the implicit frame of the method currently being parsed (as
     * defined in the given {@link Context}) and stores it in the given context.
     *
     * @param frame
     *            information about the class being parsed.
     */
    private void getImplicitFrame(final Context frame) {
<span class="nc" id="L1993">        String desc = frame.desc;</span>
<span class="nc" id="L1994">        Object[] locals = frame.local;</span>
<span class="nc" id="L1995">        int local = 0;</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">        if ((frame.access &amp; Opcodes.ACC_STATIC) == 0) {</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">            if (&quot;&lt;init&gt;&quot;.equals(frame.name)) {</span>
<span class="nc" id="L1998">                locals[local++] = Opcodes.UNINITIALIZED_THIS;</span>
            } else {
<span class="nc" id="L2000">                locals[local++] = readClass(header + 2, frame.buffer);</span>
            }
        }
<span class="nc" id="L2003">        int i = 1;</span>
        loop: while (true) {
<span class="nc" id="L2005">            int j = i;</span>
<span class="nc bnc" id="L2006" title="All 7 branches missed.">            switch (desc.charAt(i++)) {</span>
            case 'Z':
            case 'C':
            case 'B':
            case 'S':
            case 'I':
<span class="nc" id="L2012">                locals[local++] = Opcodes.INTEGER;</span>
<span class="nc" id="L2013">                break;</span>
            case 'F':
<span class="nc" id="L2015">                locals[local++] = Opcodes.FLOAT;</span>
<span class="nc" id="L2016">                break;</span>
            case 'J':
<span class="nc" id="L2018">                locals[local++] = Opcodes.LONG;</span>
<span class="nc" id="L2019">                break;</span>
            case 'D':
<span class="nc" id="L2021">                locals[local++] = Opcodes.DOUBLE;</span>
<span class="nc" id="L2022">                break;</span>
            case '[':
<span class="nc bnc" id="L2024" title="All 2 branches missed.">                while (desc.charAt(i) == '[') {</span>
<span class="nc" id="L2025">                    ++i;</span>
                }
<span class="nc bnc" id="L2027" title="All 2 branches missed.">                if (desc.charAt(i) == 'L') {</span>
<span class="nc" id="L2028">                    ++i;</span>
<span class="nc bnc" id="L2029" title="All 2 branches missed.">                    while (desc.charAt(i) != ';') {</span>
<span class="nc" id="L2030">                        ++i;</span>
                    }
                }
<span class="nc" id="L2033">                locals[local++] = desc.substring(j, ++i);</span>
<span class="nc" id="L2034">                break;</span>
            case 'L':
<span class="nc bnc" id="L2036" title="All 2 branches missed.">                while (desc.charAt(i) != ';') {</span>
<span class="nc" id="L2037">                    ++i;</span>
                }
<span class="nc" id="L2039">                locals[local++] = desc.substring(j + 1, i++);</span>
<span class="nc" id="L2040">                break;</span>
            default:
<span class="nc" id="L2042">                break loop;</span>
            }
<span class="nc" id="L2044">        }</span>
<span class="nc" id="L2045">        frame.localCount = local;</span>
<span class="nc" id="L2046">    }</span>

    /**
     * Reads a stack map frame and stores the result in the given
     * {@link Context} object.
     *
     * @param stackMap
     *            the start offset of a stack map frame in the class file.
     * @param zip
     *            if the stack map frame at stackMap is compressed or not.
     * @param unzip
     *            if the stack map frame must be uncompressed.
     * @param frame
     *            where the parsed stack map frame must be stored.
     * @return the offset of the first byte following the parsed frame.
     */
    private int readFrame(int stackMap, boolean zip, boolean unzip,
            Context frame) {
<span class="nc" id="L2064">        char[] c = frame.buffer;</span>
<span class="nc" id="L2065">        Label[] labels = frame.labels;</span>
        int tag;
        int delta;
<span class="nc bnc" id="L2068" title="All 2 branches missed.">        if (zip) {</span>
<span class="nc" id="L2069">            tag = b[stackMap++] &amp; 0xFF;</span>
        } else {
<span class="nc" id="L2071">            tag = MethodWriter.FULL_FRAME;</span>
<span class="nc" id="L2072">            frame.offset = -1;</span>
        }
<span class="nc" id="L2074">        frame.localDiff = 0;</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">        if (tag &lt; MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME) {</span>
<span class="nc" id="L2076">            delta = tag;</span>
<span class="nc" id="L2077">            frame.mode = Opcodes.F_SAME;</span>
<span class="nc" id="L2078">            frame.stackCount = 0;</span>
<span class="nc bnc" id="L2079" title="All 2 branches missed.">        } else if (tag &lt; MethodWriter.RESERVED) {</span>
<span class="nc" id="L2080">            delta = tag - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;</span>
<span class="nc" id="L2081">            stackMap = readFrameType(frame.stack, 0, stackMap, c, labels);</span>
<span class="nc" id="L2082">            frame.mode = Opcodes.F_SAME1;</span>
<span class="nc" id="L2083">            frame.stackCount = 1;</span>
        } else {
<span class="nc" id="L2085">            delta = readUnsignedShort(stackMap);</span>
<span class="nc" id="L2086">            stackMap += 2;</span>
<span class="nc bnc" id="L2087" title="All 2 branches missed.">            if (tag == MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {</span>
<span class="nc" id="L2088">                stackMap = readFrameType(frame.stack, 0, stackMap, c, labels);</span>
<span class="nc" id="L2089">                frame.mode = Opcodes.F_SAME1;</span>
<span class="nc" id="L2090">                frame.stackCount = 1;</span>
<span class="nc bnc" id="L2091" title="All 4 branches missed.">            } else if (tag &gt;= MethodWriter.CHOP_FRAME</span>
                    &amp;&amp; tag &lt; MethodWriter.SAME_FRAME_EXTENDED) {
<span class="nc" id="L2093">                frame.mode = Opcodes.F_CHOP;</span>
<span class="nc" id="L2094">                frame.localDiff = MethodWriter.SAME_FRAME_EXTENDED - tag;</span>
<span class="nc" id="L2095">                frame.localCount -= frame.localDiff;</span>
<span class="nc" id="L2096">                frame.stackCount = 0;</span>
<span class="nc bnc" id="L2097" title="All 2 branches missed.">            } else if (tag == MethodWriter.SAME_FRAME_EXTENDED) {</span>
<span class="nc" id="L2098">                frame.mode = Opcodes.F_SAME;</span>
<span class="nc" id="L2099">                frame.stackCount = 0;</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">            } else if (tag &lt; MethodWriter.FULL_FRAME) {</span>
<span class="nc bnc" id="L2101" title="All 2 branches missed.">                int local = unzip ? frame.localCount : 0;</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">                for (int i = tag - MethodWriter.SAME_FRAME_EXTENDED; i &gt; 0; i--) {</span>
<span class="nc" id="L2103">                    stackMap = readFrameType(frame.local, local++, stackMap, c,</span>
                            labels);
                }
<span class="nc" id="L2106">                frame.mode = Opcodes.F_APPEND;</span>
<span class="nc" id="L2107">                frame.localDiff = tag - MethodWriter.SAME_FRAME_EXTENDED;</span>
<span class="nc" id="L2108">                frame.localCount += frame.localDiff;</span>
<span class="nc" id="L2109">                frame.stackCount = 0;</span>
<span class="nc" id="L2110">            } else { // if (tag == FULL_FRAME) {</span>
<span class="nc" id="L2111">                frame.mode = Opcodes.F_FULL;</span>
<span class="nc" id="L2112">                int n = readUnsignedShort(stackMap);</span>
<span class="nc" id="L2113">                stackMap += 2;</span>
<span class="nc" id="L2114">                frame.localDiff = n;</span>
<span class="nc" id="L2115">                frame.localCount = n;</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">                for (int local = 0; n &gt; 0; n--) {</span>
<span class="nc" id="L2117">                    stackMap = readFrameType(frame.local, local++, stackMap, c,</span>
                            labels);
                }
<span class="nc" id="L2120">                n = readUnsignedShort(stackMap);</span>
<span class="nc" id="L2121">                stackMap += 2;</span>
<span class="nc" id="L2122">                frame.stackCount = n;</span>
<span class="nc bnc" id="L2123" title="All 2 branches missed.">                for (int stack = 0; n &gt; 0; n--) {</span>
<span class="nc" id="L2124">                    stackMap = readFrameType(frame.stack, stack++, stackMap, c,</span>
                            labels);
                }
            }
        }
<span class="nc" id="L2129">        frame.offset += delta + 1;</span>
<span class="nc" id="L2130">        readLabel(frame.offset, labels);</span>
<span class="nc" id="L2131">        return stackMap;</span>
    }

    /**
     * Reads a stack map frame type and stores it at the given index in the
     * given array.
     *
     * @param frame
     *            the array where the parsed type must be stored.
     * @param index
     *            the index in 'frame' where the parsed type must be stored.
     * @param v
     *            the start offset of the stack map frame type to read.
     * @param buf
     *            a buffer to read strings.
     * @param labels
     *            the labels of the method currently being parsed, indexed by
     *            their offset. If the parsed type is an Uninitialized type, a
     *            new label for the corresponding NEW instruction is stored in
     *            this array if it does not already exist.
     * @return the offset of the first byte after the parsed type.
     */
    private int readFrameType(final Object[] frame, final int index, int v,
            final char[] buf, final Label[] labels) {
<span class="nc" id="L2155">        int type = b[v++] &amp; 0xFF;</span>
<span class="nc bnc" id="L2156" title="All 9 branches missed.">        switch (type) {</span>
        case 0:
<span class="nc" id="L2158">            frame[index] = Opcodes.TOP;</span>
<span class="nc" id="L2159">            break;</span>
        case 1:
<span class="nc" id="L2161">            frame[index] = Opcodes.INTEGER;</span>
<span class="nc" id="L2162">            break;</span>
        case 2:
<span class="nc" id="L2164">            frame[index] = Opcodes.FLOAT;</span>
<span class="nc" id="L2165">            break;</span>
        case 3:
<span class="nc" id="L2167">            frame[index] = Opcodes.DOUBLE;</span>
<span class="nc" id="L2168">            break;</span>
        case 4:
<span class="nc" id="L2170">            frame[index] = Opcodes.LONG;</span>
<span class="nc" id="L2171">            break;</span>
        case 5:
<span class="nc" id="L2173">            frame[index] = Opcodes.NULL;</span>
<span class="nc" id="L2174">            break;</span>
        case 6:
<span class="nc" id="L2176">            frame[index] = Opcodes.UNINITIALIZED_THIS;</span>
<span class="nc" id="L2177">            break;</span>
        case 7: // Object
<span class="nc" id="L2179">            frame[index] = readClass(v, buf);</span>
<span class="nc" id="L2180">            v += 2;</span>
<span class="nc" id="L2181">            break;</span>
        default: // Uninitialized
<span class="nc" id="L2183">            frame[index] = readLabel(readUnsignedShort(v), labels);</span>
<span class="nc" id="L2184">            v += 2;</span>
        }
<span class="nc" id="L2186">        return v;</span>
    }

    /**
     * Returns the label corresponding to the given offset. The default
     * implementation of this method creates a label for the given offset if it
     * has not been already created.
     *
     * @param offset
     *            a bytecode offset in a method.
     * @param labels
     *            the already created labels, indexed by their offset. If a
     *            label already exists for offset this method must not create a
     *            new one. Otherwise it must store the new label in this array.
     * @return a non null Label, which must be equal to labels[offset].
     */
    protected Label readLabel(int offset, Label[] labels) {
<span class="pc bpc" id="L2203" title="1 of 2 branches missed.">        if (labels[offset] == null) {</span>
<span class="fc" id="L2204">            labels[offset] = new Label();</span>
        }
<span class="fc" id="L2206">        return labels[offset];</span>
    }

    /**
     * Returns the start index of the attribute_info structure of this class.
     *
     * @return the start index of the attribute_info structure of this class.
     */
    private int getAttributes() {
        // skips the header
<span class="fc" id="L2216">        int u = header + 8 + readUnsignedShort(header + 6) * 2;</span>
        // skips fields and methods
<span class="pc bpc" id="L2218" title="1 of 2 branches missed.">        for (int i = readUnsignedShort(u); i &gt; 0; --i) {</span>
<span class="nc bnc" id="L2219" title="All 2 branches missed.">            for (int j = readUnsignedShort(u + 8); j &gt; 0; --j) {</span>
<span class="nc" id="L2220">                u += 6 + readInt(u + 12);</span>
            }
<span class="nc" id="L2222">            u += 8;</span>
        }
<span class="fc" id="L2224">        u += 2;</span>
<span class="fc bfc" id="L2225" title="All 2 branches covered.">        for (int i = readUnsignedShort(u); i &gt; 0; --i) {</span>
<span class="fc bfc" id="L2226" title="All 2 branches covered.">            for (int j = readUnsignedShort(u + 8); j &gt; 0; --j) {</span>
<span class="fc" id="L2227">                u += 6 + readInt(u + 12);</span>
            }
<span class="fc" id="L2229">            u += 8;</span>
        }
        // the attribute_info structure starts just after the methods
<span class="fc" id="L2232">        return u + 2;</span>
    }

    /**
     * Reads an attribute in {@link #b b}.
     *
     * @param attrs
     *            prototypes of the attributes that must be parsed during the
     *            visit of the class. Any attribute whose type is not equal to
     *            the type of one the prototypes is ignored (i.e. an empty
     *            {@link Attribute} instance is returned).
     * @param type
     *            the type of the attribute.
     * @param off
     *            index of the first byte of the attribute's content in
     *            {@link #b b}. The 6 attribute header bytes, containing the
     *            type and the length of the attribute, are not taken into
     *            account here (they have already been read).
     * @param len
     *            the length of the attribute's content.
     * @param buf
     *            buffer to be used to call {@link #readUTF8 readUTF8},
     *            {@link #readClass(int,char[]) readClass} or {@link #readConst
     *            readConst}.
     * @param codeOff
     *            index of the first byte of code's attribute content in
     *            {@link #b b}, or -1 if the attribute to be read is not a code
     *            attribute. The 6 attribute header bytes, containing the type
     *            and the length of the attribute, are not taken into account
     *            here.
     * @param labels
     *            the labels of the method's code, or &lt;tt&gt;null&lt;/tt&gt; if the
     *            attribute to be read is not a code attribute.
     * @return the attribute that has been read, or &lt;tt&gt;null&lt;/tt&gt; to skip this
     *         attribute.
     */
    private Attribute readAttribute(final Attribute[] attrs, final String type,
            final int off, final int len, final char[] buf, final int codeOff,
            final Label[] labels) {
<span class="nc bnc" id="L2271" title="All 2 branches missed.">        for (int i = 0; i &lt; attrs.length; ++i) {</span>
<span class="nc bnc" id="L2272" title="All 2 branches missed.">            if (attrs[i].type.equals(type)) {</span>
<span class="nc" id="L2273">                return attrs[i].read(this, off, len, buf, codeOff, labels);</span>
            }
        }
<span class="nc" id="L2276">        return new Attribute(type).read(this, off, len, null, -1, null);</span>
    }

    // ------------------------------------------------------------------------
    // Utility methods: low level parsing
    // ------------------------------------------------------------------------

    /**
     * Returns the number of constant pool items in {@link #b b}.
     *
     * @return the number of constant pool items in {@link #b b}.
     */
    public int getItemCount() {
<span class="nc" id="L2289">        return items.length;</span>
    }

    /**
     * Returns the start index of the constant pool item in {@link #b b}, plus
     * one. &lt;i&gt;This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.&lt;/i&gt;
     *
     * @param item
     *            the index a constant pool item.
     * @return the start index of the constant pool item in {@link #b b}, plus
     *         one.
     */
    public int getItem(final int item) {
<span class="nc" id="L2303">        return items[item];</span>
    }

    /**
     * Returns the maximum length of the strings contained in the constant pool
     * of the class.
     *
     * @return the maximum length of the strings contained in the constant pool
     *         of the class.
     */
    public int getMaxStringLength() {
<span class="nc" id="L2314">        return maxStringLength;</span>
    }

    /**
     * Reads a byte value in {@link #b b}. &lt;i&gt;This method is intended for
     * {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.&lt;/i&gt;
     *
     * @param index
     *            the start index of the value to be read in {@link #b b}.
     * @return the read value.
     */
    public int readByte(final int index) {
<span class="nc" id="L2327">        return b[index] &amp; 0xFF;</span>
    }

    /**
     * Reads an unsigned short value in {@link #b b}. &lt;i&gt;This method is intended
     * for {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.&lt;/i&gt;
     *
     * @param index
     *            the start index of the value to be read in {@link #b b}.
     * @return the read value.
     */
    public int readUnsignedShort(final int index) {
<span class="fc" id="L2340">        byte[] b = this.b;</span>
<span class="fc" id="L2341">        return ((b[index] &amp; 0xFF) &lt;&lt; 8) | (b[index + 1] &amp; 0xFF);</span>
    }

    /**
     * Reads a signed short value in {@link #b b}. &lt;i&gt;This method is intended
     * for {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.&lt;/i&gt;
     *
     * @param index
     *            the start index of the value to be read in {@link #b b}.
     * @return the read value.
     */
    public short readShort(final int index) {
<span class="fc" id="L2354">        byte[] b = this.b;</span>
<span class="fc" id="L2355">        return (short) (((b[index] &amp; 0xFF) &lt;&lt; 8) | (b[index + 1] &amp; 0xFF));</span>
    }

    /**
     * Reads a signed int value in {@link #b b}. &lt;i&gt;This method is intended for
     * {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.&lt;/i&gt;
     *
     * @param index
     *            the start index of the value to be read in {@link #b b}.
     * @return the read value.
     */
    public int readInt(final int index) {
<span class="fc" id="L2368">        byte[] b = this.b;</span>
<span class="fc" id="L2369">        return ((b[index] &amp; 0xFF) &lt;&lt; 24) | ((b[index + 1] &amp; 0xFF) &lt;&lt; 16)</span>
                | ((b[index + 2] &amp; 0xFF) &lt;&lt; 8) | (b[index + 3] &amp; 0xFF);
    }

    /**
     * Reads a signed long value in {@link #b b}. &lt;i&gt;This method is intended for
     * {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.&lt;/i&gt;
     *
     * @param index
     *            the start index of the value to be read in {@link #b b}.
     * @return the read value.
     */
    public long readLong(final int index) {
<span class="nc" id="L2383">        long l1 = readInt(index);</span>
<span class="nc" id="L2384">        long l0 = readInt(index + 4) &amp; 0xFFFFFFFFL;</span>
<span class="nc" id="L2385">        return (l1 &lt;&lt; 32) | l0;</span>
    }

    /**
     * Reads an UTF8 string constant pool item in {@link #b b}. &lt;i&gt;This method
     * is intended for {@link Attribute} sub classes, and is normally not needed
     * by class generators or adapters.&lt;/i&gt;
     *
     * @param index
     *            the start index of an unsigned short value in {@link #b b},
     *            whose value is the index of an UTF8 constant pool item.
     * @param buf
     *            buffer to be used to read the item. This buffer must be
     *            sufficiently large. It is not automatically resized.
     * @return the String corresponding to the specified UTF8 item.
     */
    public String readUTF8(int index, final char[] buf) {
<span class="fc" id="L2402">        int item = readUnsignedShort(index);</span>
<span class="pc bpc" id="L2403" title="2 of 4 branches missed.">        if (index == 0 || item == 0) {</span>
<span class="nc" id="L2404">            return null;</span>
        }
<span class="fc" id="L2406">        String s = strings[item];</span>
<span class="fc bfc" id="L2407" title="All 2 branches covered.">        if (s != null) {</span>
<span class="fc" id="L2408">            return s;</span>
        }
<span class="fc" id="L2410">        index = items[item];</span>
<span class="fc" id="L2411">        return strings[item] = readUTF(index + 2, readUnsignedShort(index), buf);</span>
    }

    /**
     * Reads UTF8 string in {@link #b b}.
     *
     * @param index
     *            start offset of the UTF8 string to be read.
     * @param utfLen
     *            length of the UTF8 string to be read.
     * @param buf
     *            buffer to be used to read the string. This buffer must be
     *            sufficiently large. It is not automatically resized.
     * @return the String corresponding to the specified UTF8 string.
     */
    private String readUTF(int index, final int utfLen, final char[] buf) {
<span class="fc" id="L2427">        int endIndex = index + utfLen;</span>
<span class="fc" id="L2428">        byte[] b = this.b;</span>
<span class="fc" id="L2429">        int strLen = 0;</span>
        int c;
<span class="fc" id="L2431">        int st = 0;</span>
<span class="fc" id="L2432">        char cc = 0;</span>
<span class="fc bfc" id="L2433" title="All 2 branches covered.">        while (index &lt; endIndex) {</span>
<span class="fc" id="L2434">            c = b[index++];</span>
<span class="pc bpc" id="L2435" title="3 of 4 branches missed.">            switch (st) {</span>
            case 0:
<span class="fc" id="L2437">                c = c &amp; 0xFF;</span>
<span class="pc bpc" id="L2438" title="1 of 2 branches missed.">                if (c &lt; 0x80) { // 0xxxxxxx</span>
<span class="fc" id="L2439">                    buf[strLen++] = (char) c;</span>
<span class="nc bnc" id="L2440" title="All 4 branches missed.">                } else if (c &lt; 0xE0 &amp;&amp; c &gt; 0xBF) { // 110x xxxx 10xx xxxx</span>
<span class="nc" id="L2441">                    cc = (char) (c &amp; 0x1F);</span>
<span class="nc" id="L2442">                    st = 1;</span>
                } else { // 1110 xxxx 10xx xxxx 10xx xxxx
<span class="nc" id="L2444">                    cc = (char) (c &amp; 0x0F);</span>
<span class="nc" id="L2445">                    st = 2;</span>
                }
<span class="nc" id="L2447">                break;</span>

            case 1: // byte 2 of 2-byte char or byte 3 of 3-byte char
<span class="nc" id="L2450">                buf[strLen++] = (char) ((cc &lt;&lt; 6) | (c &amp; 0x3F));</span>
<span class="nc" id="L2451">                st = 0;</span>
<span class="nc" id="L2452">                break;</span>

            case 2: // byte 2 of 3-byte char
<span class="nc" id="L2455">                cc = (char) ((cc &lt;&lt; 6) | (c &amp; 0x3F));</span>
<span class="nc" id="L2456">                st = 1;</span>
<span class="fc" id="L2457">                break;</span>
            }
        }
<span class="fc" id="L2460">        return new String(buf, 0, strLen);</span>
    }

    /**
     * Reads a class constant pool item in {@link #b b}. &lt;i&gt;This method is
     * intended for {@link Attribute} sub classes, and is normally not needed by
     * class generators or adapters.&lt;/i&gt;
     *
     * @param index
     *            the start index of an unsigned short value in {@link #b b},
     *            whose value is the index of a class constant pool item.
     * @param buf
     *            buffer to be used to read the item. This buffer must be
     *            sufficiently large. It is not automatically resized.
     * @return the String corresponding to the specified class item.
     */
    public String readClass(final int index, final char[] buf) {
        // computes the start index of the CONSTANT_Class item in b
        // and reads the CONSTANT_Utf8 item designated by
        // the first two bytes of this CONSTANT_Class item
<span class="fc" id="L2480">        return readUTF8(items[readUnsignedShort(index)], buf);</span>
    }

    /**
     * Reads a numeric or string constant pool item in {@link #b b}. &lt;i&gt;This
     * method is intended for {@link Attribute} sub classes, and is normally not
     * needed by class generators or adapters.&lt;/i&gt;
     *
     * @param item
     *            the index of a constant pool item.
     * @param buf
     *            buffer to be used to read the item. This buffer must be
     *            sufficiently large. It is not automatically resized.
     * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double},
     *         {@link String}, {@link Type} or {@link Handle} corresponding to
     *         the given constant pool item.
     */
    public Object readConst(final int item, final char[] buf) {
<span class="fc" id="L2498">        int index = items[item];</span>
<span class="pc bpc" id="L2499" title="7 of 8 branches missed.">        switch (b[index - 1]) {</span>
        case ClassWriter.INT:
<span class="nc" id="L2501">            return new Integer(readInt(index));</span>
        case ClassWriter.FLOAT:
<span class="nc" id="L2503">            return new Float(Float.intBitsToFloat(readInt(index)));</span>
        case ClassWriter.LONG:
<span class="nc" id="L2505">            return new Long(readLong(index));</span>
        case ClassWriter.DOUBLE:
<span class="nc" id="L2507">            return new Double(Double.longBitsToDouble(readLong(index)));</span>
        case ClassWriter.CLASS:
<span class="nc" id="L2509">            return Type.getObjectType(readUTF8(index, buf));</span>
        case ClassWriter.STR:
<span class="fc" id="L2511">            return readUTF8(index, buf);</span>
        case ClassWriter.MTYPE:
<span class="nc" id="L2513">            return Type.getMethodType(readUTF8(index, buf));</span>
        default: // case ClassWriter.HANDLE_BASE + [1..9]:
<span class="nc" id="L2515">            int tag = readByte(index);</span>
<span class="nc" id="L2516">            int[] items = this.items;</span>
<span class="nc" id="L2517">            int cpIndex = items[readUnsignedShort(index + 1)];</span>
<span class="nc" id="L2518">            String owner = readClass(cpIndex, buf);</span>
<span class="nc" id="L2519">            cpIndex = items[readUnsignedShort(cpIndex + 2)];</span>
<span class="nc" id="L2520">            String name = readUTF8(cpIndex, buf);</span>
<span class="nc" id="L2521">            String desc = readUTF8(cpIndex + 2, buf);</span>
<span class="nc" id="L2522">            return new Handle(tag, owner, name, desc);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>