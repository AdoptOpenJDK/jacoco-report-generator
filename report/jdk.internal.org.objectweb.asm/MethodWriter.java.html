<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MethodWriter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">jdk.internal.org.objectweb.asm</a> &gt; <span class="el_source">MethodWriter.java</span></div><h1>MethodWriter.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package jdk.internal.org.objectweb.asm;

/**
 * A {@link MethodVisitor} that generates methods in bytecode form. Each visit
 * method of this class appends the bytecode corresponding to the visited
 * instruction to a byte vector, in the order these methods are called.
 *
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
class MethodWriter extends MethodVisitor {

    /**
     * Pseudo access flag used to denote constructors.
     */
    static final int ACC_CONSTRUCTOR = 0x80000;

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is zero.
     */
    static final int SAME_FRAME = 0; // to 63 (0-3f)

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is 1
     */
    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64; // to 127 (40-7f)

    /**
     * Reserved for future use
     */
    static final int RESERVED = 128;

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is 1. Offset is bigger then 63;
     */
    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247; // f7

    /**
     * Frame where current locals are the same as the locals in the previous
     * frame, except that the k last locals are absent. The value of k is given
     * by the formula 251-frame_type.
     */
    static final int CHOP_FRAME = 248; // to 250 (f8-fA)

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is zero. Offset is bigger then 63;
     */
    static final int SAME_FRAME_EXTENDED = 251; // fb

    /**
     * Frame where current locals are the same as the locals in the previous
     * frame, except that k additional locals are defined. The value of k is
     * given by the formula frame_type-251.
     */
    static final int APPEND_FRAME = 252; // to 254 // fc-fe

    /**
     * Full frame
     */
    static final int FULL_FRAME = 255; // ff

    /**
     * Indicates that the stack map frames must be recomputed from scratch. In
     * this case the maximum stack size and number of local variables is also
     * recomputed from scratch.
     *
     * @see #compute
     */
    private static final int FRAMES = 0;

    /**
     * Indicates that the maximum stack size and number of local variables must
     * be automatically computed.
     *
     * @see #compute
     */
    private static final int MAXS = 1;

    /**
     * Indicates that nothing must be automatically computed.
     *
     * @see #compute
     */
    private static final int NOTHING = 2;

    /**
     * The class writer to which this method must be added.
     */
    final ClassWriter cw;

    /**
     * Access flags of this method.
     */
    private int access;

    /**
     * The index of the constant pool item that contains the name of this
     * method.
     */
    private final int name;

    /**
     * The index of the constant pool item that contains the descriptor of this
     * method.
     */
    private final int desc;

    /**
     * The descriptor of this method.
     */
    private final String descriptor;

    /**
     * The signature of this method.
     */
    String signature;

    /**
     * If not zero, indicates that the code of this method must be copied from
     * the ClassReader associated to this writer in &lt;code&gt;cw.cr&lt;/code&gt;. More
     * precisely, this field gives the index of the first byte to copied from
     * &lt;code&gt;cw.cr.b&lt;/code&gt;.
     */
    int classReaderOffset;

    /**
     * If not zero, indicates that the code of this method must be copied from
     * the ClassReader associated to this writer in &lt;code&gt;cw.cr&lt;/code&gt;. More
     * precisely, this field gives the number of bytes to copied from
     * &lt;code&gt;cw.cr.b&lt;/code&gt;.
     */
    int classReaderLength;

    /**
     * Number of exceptions that can be thrown by this method.
     */
    int exceptionCount;

    /**
     * The exceptions that can be thrown by this method. More precisely, this
     * array contains the indexes of the constant pool items that contain the
     * internal names of these exception classes.
     */
    int[] exceptions;

    /**
     * The annotation default attribute of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private ByteVector annd;

    /**
     * The runtime visible annotations of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter anns;

    /**
     * The runtime invisible annotations of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter ianns;

    /**
     * The runtime visible type annotations of this method. May be &lt;tt&gt;null&lt;/tt&gt;
     * .
     */
    private AnnotationWriter tanns;

    /**
     * The runtime invisible type annotations of this method. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter itanns;

    /**
     * The runtime visible parameter annotations of this method. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter[] panns;

    /**
     * The runtime invisible parameter annotations of this method. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter[] ipanns;

    /**
     * The number of synthetic parameters of this method.
     */
    private int synthetics;

    /**
     * The non standard attributes of the method.
     */
    private Attribute attrs;

    /**
     * The bytecode of this method.
     */
<span class="fc" id="L260">    private ByteVector code = new ByteVector();</span>

    /**
     * Maximum stack size of this method.
     */
    private int maxStack;

    /**
     * Maximum number of local variables for this method.
     */
    private int maxLocals;

    /**
     * Number of local variables in the current stack map frame.
     */
    private int currentLocals;

    /**
     * Number of stack map frames in the StackMapTable attribute.
     */
    private int frameCount;

    /**
     * The StackMapTable attribute.
     */
    private ByteVector stackMap;

    /**
     * The offset of the last frame that was written in the StackMapTable
     * attribute.
     */
    private int previousFrameOffset;

    /**
     * The last frame that was written in the StackMapTable attribute.
     *
     * @see #frame
     */
    private int[] previousFrame;

    /**
     * The current stack map frame. The first element contains the offset of the
     * instruction to which the frame corresponds, the second element is the
     * number of locals and the third one is the number of stack elements. The
     * local variables start at index 3 and are followed by the operand stack
     * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =
     * nStack, frame[3] = nLocal. All types are encoded as integers, with the
     * same format as the one used in {@link Label}, but limited to BASE types.
     */
    private int[] frame;

    /**
     * Number of elements in the exception handler list.
     */
    private int handlerCount;

    /**
     * The first element in the exception handler list.
     */
    private Handler firstHandler;

    /**
     * The last element in the exception handler list.
     */
    private Handler lastHandler;

    /**
     * Number of entries in the MethodParameters attribute.
     */
    private int methodParametersCount;

    /**
     * The MethodParameters attribute.
     */
    private ByteVector methodParameters;

    /**
     * Number of entries in the LocalVariableTable attribute.
     */
    private int localVarCount;

    /**
     * The LocalVariableTable attribute.
     */
    private ByteVector localVar;

    /**
     * Number of entries in the LocalVariableTypeTable attribute.
     */
    private int localVarTypeCount;

    /**
     * The LocalVariableTypeTable attribute.
     */
    private ByteVector localVarType;

    /**
     * Number of entries in the LineNumberTable attribute.
     */
    private int lineNumberCount;

    /**
     * The LineNumberTable attribute.
     */
    private ByteVector lineNumber;

    /**
     * The start offset of the last visited instruction.
     */
    private int lastCodeOffset;

    /**
     * The runtime visible type annotations of the code. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter ctanns;

    /**
     * The runtime invisible type annotations of the code. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter ictanns;

    /**
     * The non standard attributes of the method's code.
     */
    private Attribute cattrs;

    /**
     * Indicates if some jump instructions are too small and need to be resized.
     */
    private boolean resize;

    /**
     * The number of subroutines in this method.
     */
    private int subroutines;

    // ------------------------------------------------------------------------

    /*
     * Fields for the control flow graph analysis algorithm (used to compute the
     * maximum stack size). A control flow graph contains one node per &quot;basic
     * block&quot;, and one edge per &quot;jump&quot; from one basic block to another. Each
     * node (i.e., each basic block) is represented by the Label object that
     * corresponds to the first instruction of this basic block. Each node also
     * stores the list of its successors in the graph, as a linked list of Edge
     * objects.
     */

    /**
     * Indicates what must be automatically computed.
     *
     * @see #FRAMES
     * @see #MAXS
     * @see #NOTHING
     */
    private final int compute;

    /**
     * A list of labels. This list is the list of basic blocks in the method,
     * i.e. a list of Label objects linked to each other by their
     * {@link Label#successor} field, in the order they are visited by
     * {@link MethodVisitor#visitLabel}, and starting with the first basic
     * block.
     */
    private Label labels;

    /**
     * The previous basic block.
     */
    private Label previousBlock;

    /**
     * The current basic block.
     */
    private Label currentBlock;

    /**
     * The (relative) stack size after the last visited instruction. This size
     * is relative to the beginning of the current basic block, i.e., the true
     * stack size after the last visited instruction is equal to the
     * {@link Label#inputStackTop beginStackSize} of the current basic block
     * plus &lt;tt&gt;stackSize&lt;/tt&gt;.
     */
    private int stackSize;

    /**
     * The (relative) maximum stack size after the last visited instruction.
     * This size is relative to the beginning of the current basic block, i.e.,
     * the true maximum stack size after the last visited instruction is equal
     * to the {@link Label#inputStackTop beginStackSize} of the current basic
     * block plus &lt;tt&gt;stackSize&lt;/tt&gt;.
     */
    private int maxStackSize;

    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------

    /**
     * Constructs a new {@link MethodWriter}.
     *
     * @param cw
     *            the class writer in which the method must be added.
     * @param access
     *            the method's access flags (see {@link Opcodes}).
     * @param name
     *            the method's name.
     * @param desc
     *            the method's descriptor (see {@link Type}).
     * @param signature
     *            the method's signature. May be &lt;tt&gt;null&lt;/tt&gt;.
     * @param exceptions
     *            the internal names of the method's exceptions. May be
     *            &lt;tt&gt;null&lt;/tt&gt;.
     * @param computeMaxs
     *            &lt;tt&gt;true&lt;/tt&gt; if the maximum stack size and number of local
     *            variables must be automatically computed.
     * @param computeFrames
     *            &lt;tt&gt;true&lt;/tt&gt; if the stack map tables must be recomputed from
     *            scratch.
     */
    MethodWriter(final ClassWriter cw, final int access, final String name,
            final String desc, final String signature,
            final String[] exceptions, final boolean computeMaxs,
            final boolean computeFrames) {
<span class="fc" id="L485">        super(Opcodes.ASM5);</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (cw.firstMethod == null) {</span>
<span class="fc" id="L487">            cw.firstMethod = this;</span>
        } else {
<span class="fc" id="L489">            cw.lastMethod.mv = this;</span>
        }
<span class="fc" id="L491">        cw.lastMethod = this;</span>
<span class="fc" id="L492">        this.cw = cw;</span>
<span class="fc" id="L493">        this.access = access;</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">        if (&quot;&lt;init&gt;&quot;.equals(name)) {</span>
<span class="fc" id="L495">            this.access |= ACC_CONSTRUCTOR;</span>
        }
<span class="fc" id="L497">        this.name = cw.newUTF8(name);</span>
<span class="fc" id="L498">        this.desc = cw.newUTF8(desc);</span>
<span class="fc" id="L499">        this.descriptor = desc;</span>
        if (ClassReader.SIGNATURES) {
<span class="fc" id="L501">            this.signature = signature;</span>
        }
<span class="fc bfc" id="L503" title="All 4 branches covered.">        if (exceptions != null &amp;&amp; exceptions.length &gt; 0) {</span>
<span class="fc" id="L504">            exceptionCount = exceptions.length;</span>
<span class="fc" id="L505">            this.exceptions = new int[exceptionCount];</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">            for (int i = 0; i &lt; exceptionCount; ++i) {</span>
<span class="fc" id="L507">                this.exceptions[i] = cw.newClass(exceptions[i]);</span>
            }
        }
<span class="fc bfc" id="L510" title="All 4 branches covered.">        this.compute = computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);</span>
<span class="pc bpc" id="L511" title="1 of 4 branches missed.">        if (computeMaxs || computeFrames) {</span>
            // updates maxLocals
<span class="fc" id="L513">            int size = Type.getArgumentsAndReturnSizes(descriptor) &gt;&gt; 2;</span>
<span class="fc bfc" id="L514" title="All 2 branches covered.">            if ((access &amp; Opcodes.ACC_STATIC) != 0) {</span>
<span class="fc" id="L515">                --size;</span>
            }
<span class="fc" id="L517">            maxLocals = size;</span>
<span class="fc" id="L518">            currentLocals = size;</span>
            // creates and visits the label for the first basic block
<span class="fc" id="L520">            labels = new Label();</span>
<span class="fc" id="L521">            labels.status |= Label.PUSHED;</span>
<span class="fc" id="L522">            visitLabel(labels);</span>
        }
<span class="fc" id="L524">    }</span>

    // ------------------------------------------------------------------------
    // Implementation of the MethodVisitor abstract class
    // ------------------------------------------------------------------------

    @Override
    public void visitParameter(String name, int access) {
<span class="nc bnc" id="L532" title="All 2 branches missed.">        if (methodParameters == null) {</span>
<span class="nc" id="L533">            methodParameters = new ByteVector();</span>
        }
<span class="nc" id="L535">        ++methodParametersCount;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        methodParameters.putShort((name == null) ? 0 : cw.newUTF8(name))</span>
<span class="nc" id="L537">                .putShort(access);</span>
<span class="nc" id="L538">    }</span>

    @Override
    public AnnotationVisitor visitAnnotationDefault() {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L545">        annd = new ByteVector();</span>
<span class="nc" id="L546">        return new AnnotationWriter(cw, false, annd, null, 0);</span>
    }

    @Override
    public AnnotationVisitor visitAnnotation(final String desc,
            final boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="fc" id="L555">        ByteVector bv = new ByteVector();</span>
        // write type, and reserve space for values count
<span class="fc" id="L557">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="fc" id="L558">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);</span>
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">        if (visible) {</span>
<span class="fc" id="L560">            aw.next = anns;</span>
<span class="fc" id="L561">            anns = aw;</span>
        } else {
<span class="nc" id="L563">            aw.next = ianns;</span>
<span class="nc" id="L564">            ianns = aw;</span>
        }
<span class="fc" id="L566">        return aw;</span>
    }

    @Override
    public AnnotationVisitor visitTypeAnnotation(final int typeRef,
            final TypePath typePath, final String desc, final boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L575">        ByteVector bv = new ByteVector();</span>
        // write target_type and target_info
<span class="nc" id="L577">        AnnotationWriter.putTarget(typeRef, typePath, bv);</span>
        // write type, and reserve space for values count
<span class="nc" id="L579">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L580">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv,</span>
                bv.length - 2);
<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L583">            aw.next = tanns;</span>
<span class="nc" id="L584">            tanns = aw;</span>
        } else {
<span class="nc" id="L586">            aw.next = itanns;</span>
<span class="nc" id="L587">            itanns = aw;</span>
        }
<span class="nc" id="L589">        return aw;</span>
    }

    @Override
    public AnnotationVisitor visitParameterAnnotation(final int parameter,
            final String desc, final boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L598">        ByteVector bv = new ByteVector();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (&quot;Ljava/lang/Synthetic;&quot;.equals(desc)) {</span>
            // workaround for a bug in javac with synthetic parameters
            // see ClassReader.readParameterAnnotations
<span class="nc" id="L602">            synthetics = Math.max(synthetics, parameter + 1);</span>
<span class="nc" id="L603">            return new AnnotationWriter(cw, false, bv, null, 0);</span>
        }
        // write type, and reserve space for values count
<span class="nc" id="L606">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L607">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">            if (panns == null) {</span>
<span class="nc" id="L610">                panns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];</span>
            }
<span class="nc" id="L612">            aw.next = panns[parameter];</span>
<span class="nc" id="L613">            panns[parameter] = aw;</span>
        } else {
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (ipanns == null) {</span>
<span class="nc" id="L616">                ipanns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];</span>
            }
<span class="nc" id="L618">            aw.next = ipanns[parameter];</span>
<span class="nc" id="L619">            ipanns[parameter] = aw;</span>
        }
<span class="nc" id="L621">        return aw;</span>
    }

    @Override
    public void visitAttribute(final Attribute attr) {
<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (attr.isCodeAttribute()) {</span>
<span class="nc" id="L627">            attr.next = cattrs;</span>
<span class="nc" id="L628">            cattrs = attr;</span>
        } else {
<span class="nc" id="L630">            attr.next = attrs;</span>
<span class="nc" id="L631">            attrs = attr;</span>
        }
<span class="nc" id="L633">    }</span>

    @Override
    public void visitCode() {
<span class="fc" id="L637">    }</span>

    @Override
    public void visitFrame(final int type, final int nLocal,
            final Object[] local, final int nStack, final Object[] stack) {
<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (!ClassReader.FRAMES || compute == FRAMES) {</span>
<span class="nc" id="L643">            return;</span>
        }

<span class="nc bnc" id="L646" title="All 2 branches missed.">        if (type == Opcodes.F_NEW) {</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">            if (previousFrame == null) {</span>
<span class="nc" id="L648">                visitImplicitFirstFrame();</span>
            }
<span class="nc" id="L650">            currentLocals = nLocal;</span>
<span class="nc" id="L651">            int frameIndex = startFrame(code.length, nLocal, nStack);</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">            for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                if (local[i] instanceof String) {</span>
<span class="nc" id="L654">                    frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L655">                            | cw.addType((String) local[i]);</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                } else if (local[i] instanceof Integer) {</span>
<span class="nc" id="L657">                    frame[frameIndex++] = ((Integer) local[i]).intValue();</span>
                } else {
<span class="nc" id="L659">                    frame[frameIndex++] = Frame.UNINITIALIZED</span>
<span class="nc" id="L660">                            | cw.addUninitializedType(&quot;&quot;,</span>
                                    ((Label) local[i]).position);
                }
            }
<span class="nc bnc" id="L664" title="All 2 branches missed.">            for (int i = 0; i &lt; nStack; ++i) {</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">                if (stack[i] instanceof String) {</span>
<span class="nc" id="L666">                    frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L667">                            | cw.addType((String) stack[i]);</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">                } else if (stack[i] instanceof Integer) {</span>
<span class="nc" id="L669">                    frame[frameIndex++] = ((Integer) stack[i]).intValue();</span>
                } else {
<span class="nc" id="L671">                    frame[frameIndex++] = Frame.UNINITIALIZED</span>
<span class="nc" id="L672">                            | cw.addUninitializedType(&quot;&quot;,</span>
                                    ((Label) stack[i]).position);
                }
            }
<span class="nc" id="L676">            endFrame();</span>
<span class="nc" id="L677">        } else {</span>
            int delta;
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if (stackMap == null) {</span>
<span class="nc" id="L680">                stackMap = new ByteVector();</span>
<span class="nc" id="L681">                delta = code.length;</span>
            } else {
<span class="nc" id="L683">                delta = code.length - previousFrameOffset - 1;</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                if (delta &lt; 0) {</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">                    if (type == Opcodes.F_SAME) {</span>
<span class="nc" id="L686">                        return;</span>
                    } else {
<span class="nc" id="L688">                        throw new IllegalStateException();</span>
                    }
                }
            }

<span class="nc bnc" id="L693" title="All 6 branches missed.">            switch (type) {</span>
            case Opcodes.F_FULL:
<span class="nc" id="L695">                currentLocals = nLocal;</span>
<span class="nc" id="L696">                stackMap.putByte(FULL_FRAME).putShort(delta).putShort(nLocal);</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="nc" id="L698">                    writeFrameType(local[i]);</span>
                }
<span class="nc" id="L700">                stackMap.putShort(nStack);</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">                for (int i = 0; i &lt; nStack; ++i) {</span>
<span class="nc" id="L702">                    writeFrameType(stack[i]);</span>
                }
<span class="nc" id="L704">                break;</span>
            case Opcodes.F_APPEND:
<span class="nc" id="L706">                currentLocals += nLocal;</span>
<span class="nc" id="L707">                stackMap.putByte(SAME_FRAME_EXTENDED + nLocal).putShort(delta);</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">                for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="nc" id="L709">                    writeFrameType(local[i]);</span>
                }
<span class="nc" id="L711">                break;</span>
            case Opcodes.F_CHOP:
<span class="nc" id="L713">                currentLocals -= nLocal;</span>
<span class="nc" id="L714">                stackMap.putByte(SAME_FRAME_EXTENDED - nLocal).putShort(delta);</span>
<span class="nc" id="L715">                break;</span>
            case Opcodes.F_SAME:
<span class="nc bnc" id="L717" title="All 2 branches missed.">                if (delta &lt; 64) {</span>
<span class="nc" id="L718">                    stackMap.putByte(delta);</span>
                } else {
<span class="nc" id="L720">                    stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);</span>
                }
<span class="nc" id="L722">                break;</span>
            case Opcodes.F_SAME1:
<span class="nc bnc" id="L724" title="All 2 branches missed.">                if (delta &lt; 64) {</span>
<span class="nc" id="L725">                    stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);</span>
                } else {
<span class="nc" id="L727">                    stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)</span>
<span class="nc" id="L728">                            .putShort(delta);</span>
                }
<span class="nc" id="L730">                writeFrameType(stack[0]);</span>
                break;
            }

<span class="nc" id="L734">            previousFrameOffset = code.length;</span>
<span class="nc" id="L735">            ++frameCount;</span>
        }

<span class="nc" id="L738">        maxStack = Math.max(maxStack, nStack);</span>
<span class="nc" id="L739">        maxLocals = Math.max(maxLocals, currentLocals);</span>
<span class="nc" id="L740">    }</span>

    @Override
    public void visitInsn(final int opcode) {
<span class="fc" id="L744">        lastCodeOffset = code.length;</span>
        // adds the instruction to the bytecode of the method
<span class="fc" id="L746">        code.putByte(opcode);</span>
        // update currentBlock
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L749" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L750" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L751">                currentBlock.frame.execute(opcode, 0, null, null);</span>
            } else {
                // updates current and max stack sizes
<span class="fc" id="L754">                int size = stackSize + Frame.SIZE[opcode];</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L756">                    maxStackSize = size;</span>
                }
<span class="fc" id="L758">                stackSize = size;</span>
            }
            // if opcode == ATHROW or xRETURN, ends current block (no successor)
<span class="fc bfc" id="L761" title="All 6 branches covered.">            if ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)</span>
                    || opcode == Opcodes.ATHROW) {
<span class="fc" id="L763">                noSuccessor();</span>
            }
        }
<span class="fc" id="L766">    }</span>

    @Override
    public void visitIntInsn(final int opcode, final int operand) {
<span class="fc" id="L770">        lastCodeOffset = code.length;</span>
        // Label currentBlock = this.currentBlock;
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L773" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="fc" id="L774">                currentBlock.frame.execute(opcode, operand, null, null);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">            } else if (opcode != Opcodes.NEWARRAY) {</span>
                // updates current and max stack sizes only for NEWARRAY
                // (stack size variation = 0 for BIPUSH or SIPUSH)
<span class="nc" id="L778">                int size = stackSize + 1;</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L780">                    maxStackSize = size;</span>
                }
<span class="nc" id="L782">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc bfc" id="L786" title="All 2 branches covered.">        if (opcode == Opcodes.SIPUSH) {</span>
<span class="fc" id="L787">            code.put12(opcode, operand);</span>
        } else { // BIPUSH or NEWARRAY
<span class="fc" id="L789">            code.put11(opcode, operand);</span>
        }
<span class="fc" id="L791">    }</span>

    @Override
    public void visitVarInsn(final int opcode, final int var) {
<span class="fc" id="L795">        lastCodeOffset = code.length;</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L797" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L798" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L799">                currentBlock.frame.execute(opcode, var, null, null);</span>
            } else {
                // updates current and max stack sizes
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">                if (opcode == Opcodes.RET) {</span>
                    // no stack change, but end of current block (no successor)
<span class="nc" id="L804">                    currentBlock.status |= Label.RET;</span>
                    // save 'stackSize' here for future use
                    // (see {@link #findSubroutineSuccessors})
<span class="nc" id="L807">                    currentBlock.inputStackTop = stackSize;</span>
<span class="nc" id="L808">                    noSuccessor();</span>
                } else { // xLOAD or xSTORE
<span class="fc" id="L810">                    int size = stackSize + Frame.SIZE[opcode];</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">                    if (size &gt; maxStackSize) {</span>
<span class="fc" id="L812">                        maxStackSize = size;</span>
                    }
<span class="fc" id="L814">                    stackSize = size;</span>
                }
            }
        }
<span class="fc bfc" id="L818" title="All 2 branches covered.">        if (compute != NOTHING) {</span>
            // updates max locals
            int n;
<span class="fc bfc" id="L821" title="All 8 branches covered.">            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD</span>
                    || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE) {
<span class="fc" id="L823">                n = var + 2;</span>
            } else {
<span class="fc" id="L825">                n = var + 1;</span>
            }
<span class="fc bfc" id="L827" title="All 2 branches covered.">            if (n &gt; maxLocals) {</span>
<span class="fc" id="L828">                maxLocals = n;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="pc bpc" id="L832" title="1 of 4 branches missed.">        if (var &lt; 4 &amp;&amp; opcode != Opcodes.RET) {</span>
            int opt;
<span class="fc bfc" id="L834" title="All 2 branches covered.">            if (opcode &lt; Opcodes.ISTORE) {</span>
                /* ILOAD_0 */
<span class="fc" id="L836">                opt = 26 + ((opcode - Opcodes.ILOAD) &lt;&lt; 2) + var;</span>
            } else {
                /* ISTORE_0 */
<span class="fc" id="L839">                opt = 59 + ((opcode - Opcodes.ISTORE) &lt;&lt; 2) + var;</span>
            }
<span class="fc" id="L841">            code.putByte(opt);</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">        } else if (var &gt;= 256) {</span>
<span class="fc" id="L843">            code.putByte(196 /* WIDE */).put12(opcode, var);</span>
        } else {
<span class="fc" id="L845">            code.put11(opcode, var);</span>
        }
<span class="pc bpc" id="L847" title="1 of 6 branches missed.">        if (opcode &gt;= Opcodes.ISTORE &amp;&amp; compute == FRAMES &amp;&amp; handlerCount &gt; 0) {</span>
<span class="fc" id="L848">            visitLabel(new Label());</span>
        }
<span class="fc" id="L850">    }</span>

    @Override
    public void visitTypeInsn(final int opcode, final String type) {
<span class="fc" id="L854">        lastCodeOffset = code.length;</span>
<span class="fc" id="L855">        Item i = cw.newClassItem(type);</span>
        // Label currentBlock = this.currentBlock;
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L859">                currentBlock.frame.execute(opcode, code.length, cw, i);</span>
<span class="fc bfc" id="L860" title="All 2 branches covered.">            } else if (opcode == Opcodes.NEW) {</span>
                // updates current and max stack sizes only if opcode == NEW
                // (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)
<span class="fc" id="L863">                int size = stackSize + 1;</span>
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L865">                    maxStackSize = size;</span>
                }
<span class="fc" id="L867">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L871">        code.put12(opcode, i.index);</span>
<span class="fc" id="L872">    }</span>

    @Override
    public void visitFieldInsn(final int opcode, final String owner,
            final String name, final String desc) {
<span class="fc" id="L877">        lastCodeOffset = code.length;</span>
<span class="fc" id="L878">        Item i = cw.newFieldItem(owner, name, desc);</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L880" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L881" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L882">                currentBlock.frame.execute(opcode, 0, cw, i);</span>
            } else {
                int size;
                // computes the stack size variation
<span class="fc" id="L886">                char c = desc.charAt(0);</span>
<span class="pc bpc" id="L887" title="2 of 4 branches missed.">                switch (opcode) {</span>
                case Opcodes.GETSTATIC:
<span class="nc bnc" id="L889" title="All 4 branches missed.">                    size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);</span>
<span class="nc" id="L890">                    break;</span>
                case Opcodes.PUTSTATIC:
<span class="nc bnc" id="L892" title="All 4 branches missed.">                    size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);</span>
<span class="nc" id="L893">                    break;</span>
                case Opcodes.GETFIELD:
<span class="fc bfc" id="L895" title="All 4 branches covered.">                    size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);</span>
<span class="fc" id="L896">                    break;</span>
                // case Constants.PUTFIELD:
                default:
<span class="fc bfc" id="L899" title="All 4 branches covered.">                    size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);</span>
                    break;
                }
                // updates current and max stack sizes
<span class="fc bfc" id="L903" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L904">                    maxStackSize = size;</span>
                }
<span class="fc" id="L906">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L910">        code.put12(opcode, i.index);</span>
<span class="fc" id="L911">    }</span>

    @Override
    public void visitMethodInsn(final int opcode, final String owner,
            final String name, final String desc, final boolean itf) {
<span class="fc" id="L916">        lastCodeOffset = code.length;</span>
<span class="fc" id="L917">        Item i = cw.newMethodItem(owner, name, desc, itf);</span>
<span class="fc" id="L918">        int argSize = i.intVal;</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L920" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L921" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L922">                currentBlock.frame.execute(opcode, 0, cw, i);</span>
            } else {
                /*
                 * computes the stack size variation. In order not to recompute
                 * several times this variation for the same Item, we use the
                 * intVal field of this item to store this variation, once it
                 * has been computed. More precisely this intVal field stores
                 * the sizes of the arguments and of the return value
                 * corresponding to desc.
                 */
<span class="fc bfc" id="L932" title="All 2 branches covered.">                if (argSize == 0) {</span>
                    // the above sizes have not been computed yet,
                    // so we compute them...
<span class="fc" id="L935">                    argSize = Type.getArgumentsAndReturnSizes(desc);</span>
                    // ... and we save them in order
                    // not to recompute them in the future
<span class="fc" id="L938">                    i.intVal = argSize;</span>
                }
                int size;
<span class="fc bfc" id="L941" title="All 2 branches covered.">                if (opcode == Opcodes.INVOKESTATIC) {</span>
<span class="fc" id="L942">                    size = stackSize - (argSize &gt;&gt; 2) + (argSize &amp; 0x03) + 1;</span>
                } else {
<span class="fc" id="L944">                    size = stackSize - (argSize &gt;&gt; 2) + (argSize &amp; 0x03);</span>
                }
                // updates current and max stack sizes
<span class="fc bfc" id="L947" title="All 2 branches covered.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L948">                    maxStackSize = size;</span>
                }
<span class="fc" id="L950">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc bfc" id="L954" title="All 2 branches covered.">        if (opcode == Opcodes.INVOKEINTERFACE) {</span>
<span class="fc bfc" id="L955" title="All 2 branches covered.">            if (argSize == 0) {</span>
<span class="fc" id="L956">                argSize = Type.getArgumentsAndReturnSizes(desc);</span>
<span class="fc" id="L957">                i.intVal = argSize;</span>
            }
<span class="fc" id="L959">            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize &gt;&gt; 2, 0);</span>
        } else {
<span class="fc" id="L961">            code.put12(opcode, i.index);</span>
        }
<span class="fc" id="L963">    }</span>

    @Override
    public void visitInvokeDynamicInsn(final String name, final String desc,
            final Handle bsm, final Object... bsmArgs) {
<span class="fc" id="L968">        lastCodeOffset = code.length;</span>
<span class="fc" id="L969">        Item i = cw.newInvokeDynamicItem(name, desc, bsm, bsmArgs);</span>
<span class="fc" id="L970">        int argSize = i.intVal;</span>
        // Label currentBlock = this.currentBlock;
<span class="pc bpc" id="L972" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="fc" id="L974">                currentBlock.frame.execute(Opcodes.INVOKEDYNAMIC, 0, cw, i);</span>
            } else {
                /*
                 * computes the stack size variation. In order not to recompute
                 * several times this variation for the same Item, we use the
                 * intVal field of this item to store this variation, once it
                 * has been computed. More precisely this intVal field stores
                 * the sizes of the arguments and of the return value
                 * corresponding to desc.
                 */
<span class="nc bnc" id="L984" title="All 2 branches missed.">                if (argSize == 0) {</span>
                    // the above sizes have not been computed yet,
                    // so we compute them...
<span class="nc" id="L987">                    argSize = Type.getArgumentsAndReturnSizes(desc);</span>
                    // ... and we save them in order
                    // not to recompute them in the future
<span class="nc" id="L990">                    i.intVal = argSize;</span>
                }
<span class="nc" id="L992">                int size = stackSize - (argSize &gt;&gt; 2) + (argSize &amp; 0x03) + 1;</span>

                // updates current and max stack sizes
<span class="nc bnc" id="L995" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L996">                    maxStackSize = size;</span>
                }
<span class="nc" id="L998">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L1002">        code.put12(Opcodes.INVOKEDYNAMIC, i.index);</span>
<span class="fc" id="L1003">        code.putShort(0);</span>
<span class="fc" id="L1004">    }</span>

    @Override
    public void visitJumpInsn(final int opcode, final Label label) {
<span class="fc" id="L1008">        lastCodeOffset = code.length;</span>
<span class="fc" id="L1009">        Label nextInsn = null;</span>
        // Label currentBlock = this.currentBlock;
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="fc" id="L1013">                currentBlock.frame.execute(opcode, 0, null, null);</span>
                // 'label' is the target of a jump instruction
<span class="fc" id="L1015">                label.getFirst().status |= Label.TARGET;</span>
                // adds 'label' as a successor of this basic block
<span class="fc" id="L1017">                addSuccessor(Edge.NORMAL, label);</span>
<span class="fc bfc" id="L1018" title="All 2 branches covered.">                if (opcode != Opcodes.GOTO) {</span>
                    // creates a Label for the next basic block
<span class="fc" id="L1020">                    nextInsn = new Label();</span>
                }
            } else {
<span class="nc bnc" id="L1023" title="All 2 branches missed.">                if (opcode == Opcodes.JSR) {</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                    if ((label.status &amp; Label.SUBROUTINE) == 0) {</span>
<span class="nc" id="L1025">                        label.status |= Label.SUBROUTINE;</span>
<span class="nc" id="L1026">                        ++subroutines;</span>
                    }
<span class="nc" id="L1028">                    currentBlock.status |= Label.JSR;</span>
<span class="nc" id="L1029">                    addSuccessor(stackSize + 1, label);</span>
                    // creates a Label for the next basic block
<span class="nc" id="L1031">                    nextInsn = new Label();</span>
                    /*
                     * note that, by construction in this method, a JSR block
                     * has at least two successors in the control flow graph:
                     * the first one leads the next instruction after the JSR,
                     * while the second one leads to the JSR target.
                     */
                } else {
                    // updates current stack size (max stack size unchanged
                    // because stack size variation always negative in this
                    // case)
<span class="nc" id="L1042">                    stackSize += Frame.SIZE[opcode];</span>
<span class="nc" id="L1043">                    addSuccessor(stackSize, label);</span>
                }
            }
        }
        // adds the instruction to the bytecode of the method
<span class="pc bpc" id="L1048" title="1 of 4 branches missed.">        if ((label.status &amp; Label.RESOLVED) != 0</span>
                &amp;&amp; label.position - code.length &lt; Short.MIN_VALUE) {
            /*
             * case of a backward jump with an offset &lt; -32768. In this case we
             * automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx
             * &lt;l&gt; with IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx is the
             * &quot;opposite&quot; opcode of IFxxx (i.e., IFNE for IFEQ) and where &lt;l'&gt;
             * designates the instruction just after the GOTO_W.
             */
<span class="nc bnc" id="L1057" title="All 2 branches missed.">            if (opcode == Opcodes.GOTO) {</span>
<span class="nc" id="L1058">                code.putByte(200); // GOTO_W</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">            } else if (opcode == Opcodes.JSR) {</span>
<span class="nc" id="L1060">                code.putByte(201); // JSR_W</span>
            } else {
                // if the IF instruction is transformed into IFNOT GOTO_W the
                // next instruction becomes the target of the IFNOT instruction
<span class="nc bnc" id="L1064" title="All 2 branches missed.">                if (nextInsn != null) {</span>
<span class="nc" id="L1065">                    nextInsn.status |= Label.TARGET;</span>
                }
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                code.putByte(opcode &lt;= 166 ? ((opcode + 1) ^ 1) - 1</span>
                        : opcode ^ 1);
<span class="nc" id="L1069">                code.putShort(8); // jump offset</span>
<span class="nc" id="L1070">                code.putByte(200); // GOTO_W</span>
            }
<span class="nc" id="L1072">            label.put(this, code, code.length - 1, true);</span>
        } else {
            /*
             * case of a backward jump with an offset &gt;= -32768, or of a forward
             * jump with, of course, an unknown offset. In these cases we store
             * the offset in 2 bytes (which will be increased in
             * resizeInstructions, if needed).
             */
<span class="fc" id="L1080">            code.putByte(opcode);</span>
<span class="fc" id="L1081">            label.put(this, code, code.length - 1, false);</span>
        }
<span class="pc bpc" id="L1083" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">            if (nextInsn != null) {</span>
                // if the jump instruction is not a GOTO, the next instruction
                // is also a successor of this instruction. Calling visitLabel
                // adds the label of this next instruction as a successor of the
                // current block, and starts a new basic block
<span class="fc" id="L1089">                visitLabel(nextInsn);</span>
            }
<span class="fc bfc" id="L1091" title="All 2 branches covered.">            if (opcode == Opcodes.GOTO) {</span>
<span class="fc" id="L1092">                noSuccessor();</span>
            }
        }
<span class="fc" id="L1095">    }</span>

    @Override
    public void visitLabel(final Label label) {
        // resolves previous forward references to label, if any
<span class="fc" id="L1100">        resize |= label.resolve(this, code.length, code.data);</span>
        // updates currentBlock
<span class="fc bfc" id="L1102" title="All 2 branches covered.">        if ((label.status &amp; Label.DEBUG) != 0) {</span>
<span class="fc" id="L1103">            return;</span>
        }
<span class="fc bfc" id="L1105" title="All 2 branches covered.">        if (compute == FRAMES) {</span>
<span class="fc bfc" id="L1106" title="All 2 branches covered.">            if (currentBlock != null) {</span>
<span class="fc bfc" id="L1107" title="All 2 branches covered.">                if (label.position == currentBlock.position) {</span>
                    // successive labels, do not start a new basic block
<span class="fc" id="L1109">                    currentBlock.status |= (label.status &amp; Label.TARGET);</span>
<span class="fc" id="L1110">                    label.frame = currentBlock.frame;</span>
<span class="fc" id="L1111">                    return;</span>
                }
                // ends current block (with one new successor)
<span class="fc" id="L1114">                addSuccessor(Edge.NORMAL, label);</span>
            }
            // begins a new current block
<span class="fc" id="L1117">            currentBlock = label;</span>
<span class="pc bpc" id="L1118" title="1 of 2 branches missed.">            if (label.frame == null) {</span>
<span class="fc" id="L1119">                label.frame = new Frame();</span>
<span class="fc" id="L1120">                label.frame.owner = label;</span>
            }
            // updates the basic block list
<span class="fc bfc" id="L1123" title="All 2 branches covered.">            if (previousBlock != null) {</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">                if (label.position == previousBlock.position) {</span>
<span class="fc" id="L1125">                    previousBlock.status |= (label.status &amp; Label.TARGET);</span>
<span class="fc" id="L1126">                    label.frame = previousBlock.frame;</span>
<span class="fc" id="L1127">                    currentBlock = previousBlock;</span>
<span class="fc" id="L1128">                    return;</span>
                }
<span class="fc" id="L1130">                previousBlock.successor = label;</span>
            }
<span class="fc" id="L1132">            previousBlock = label;</span>
<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">        } else if (compute == MAXS) {</span>
<span class="pc bpc" id="L1134" title="1 of 2 branches missed.">            if (currentBlock != null) {</span>
                // ends current block (with one new successor)
<span class="nc" id="L1136">                currentBlock.outputStackMax = maxStackSize;</span>
<span class="nc" id="L1137">                addSuccessor(stackSize, label);</span>
            }
            // begins a new current block
<span class="fc" id="L1140">            currentBlock = label;</span>
            // resets the relative current and max stack sizes
<span class="fc" id="L1142">            stackSize = 0;</span>
<span class="fc" id="L1143">            maxStackSize = 0;</span>
            // updates the basic block list
<span class="pc bpc" id="L1145" title="1 of 2 branches missed.">            if (previousBlock != null) {</span>
<span class="nc" id="L1146">                previousBlock.successor = label;</span>
            }
<span class="fc" id="L1148">            previousBlock = label;</span>
        }
<span class="fc" id="L1150">    }</span>

    @Override
    public void visitLdcInsn(final Object cst) {
<span class="fc" id="L1154">        lastCodeOffset = code.length;</span>
<span class="fc" id="L1155">        Item i = cw.newConstItem(cst);</span>
        // Label currentBlock = this.currentBlock;
<span class="fc bfc" id="L1157" title="All 2 branches covered.">        if (currentBlock != null) {</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">            if (compute == FRAMES) {</span>
<span class="fc" id="L1159">                currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);</span>
            } else {
                int size;
                // computes the stack size variation
<span class="pc bpc" id="L1163" title="2 of 4 branches missed.">                if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {</span>
<span class="nc" id="L1164">                    size = stackSize + 2;</span>
                } else {
<span class="fc" id="L1166">                    size = stackSize + 1;</span>
                }
                // updates current and max stack sizes
<span class="pc bpc" id="L1169" title="1 of 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="fc" id="L1170">                    maxStackSize = size;</span>
                }
<span class="fc" id="L1172">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="fc" id="L1176">        int index = i.index;</span>
<span class="pc bpc" id="L1177" title="1 of 4 branches missed.">        if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {</span>
<span class="fc" id="L1178">            code.put12(20 /* LDC2_W */, index);</span>
<span class="fc bfc" id="L1179" title="All 2 branches covered.">        } else if (index &gt;= 256) {</span>
<span class="fc" id="L1180">            code.put12(19 /* LDC_W */, index);</span>
        } else {
<span class="fc" id="L1182">            code.put11(Opcodes.LDC, index);</span>
        }
<span class="fc" id="L1184">    }</span>

    @Override
    public void visitIincInsn(final int var, final int increment) {
<span class="fc" id="L1188">        lastCodeOffset = code.length;</span>
<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L1190" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="fc" id="L1191">                currentBlock.frame.execute(Opcodes.IINC, var, null, null);</span>
            }
        }
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">        if (compute != NOTHING) {</span>
            // updates max locals
<span class="fc" id="L1196">            int n = var + 1;</span>
<span class="pc bpc" id="L1197" title="1 of 2 branches missed.">            if (n &gt; maxLocals) {</span>
<span class="nc" id="L1198">                maxLocals = n;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="pc bpc" id="L1202" title="3 of 6 branches missed.">        if ((var &gt; 255) || (increment &gt; 127) || (increment &lt; -128)) {</span>
<span class="nc" id="L1203">            code.putByte(196 /* WIDE */).put12(Opcodes.IINC, var)</span>
<span class="nc" id="L1204">                    .putShort(increment);</span>
        } else {
<span class="fc" id="L1206">            code.putByte(Opcodes.IINC).put11(var, increment);</span>
        }
<span class="fc" id="L1208">    }</span>

    @Override
    public void visitTableSwitchInsn(final int min, final int max,
            final Label dflt, final Label... labels) {
<span class="nc" id="L1213">        lastCodeOffset = code.length;</span>
        // adds the instruction to the bytecode of the method
<span class="nc" id="L1215">        int source = code.length;</span>
<span class="nc" id="L1216">        code.putByte(Opcodes.TABLESWITCH);</span>
<span class="nc" id="L1217">        code.putByteArray(null, 0, (4 - code.length % 4) % 4);</span>
<span class="nc" id="L1218">        dflt.put(this, code, source, true);</span>
<span class="nc" id="L1219">        code.putInt(min).putInt(max);</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L1221">            labels[i].put(this, code, source, true);</span>
        }
        // updates currentBlock
<span class="nc" id="L1224">        visitSwitchInsn(dflt, labels);</span>
<span class="nc" id="L1225">    }</span>

    @Override
    public void visitLookupSwitchInsn(final Label dflt, final int[] keys,
            final Label[] labels) {
<span class="fc" id="L1230">        lastCodeOffset = code.length;</span>
        // adds the instruction to the bytecode of the method
<span class="fc" id="L1232">        int source = code.length;</span>
<span class="fc" id="L1233">        code.putByte(Opcodes.LOOKUPSWITCH);</span>
<span class="fc" id="L1234">        code.putByteArray(null, 0, (4 - code.length % 4) % 4);</span>
<span class="fc" id="L1235">        dflt.put(this, code, source, true);</span>
<span class="fc" id="L1236">        code.putInt(labels.length);</span>
<span class="fc bfc" id="L1237" title="All 2 branches covered.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="fc" id="L1238">            code.putInt(keys[i]);</span>
<span class="fc" id="L1239">            labels[i].put(this, code, source, true);</span>
        }
        // updates currentBlock
<span class="fc" id="L1242">        visitSwitchInsn(dflt, labels);</span>
<span class="fc" id="L1243">    }</span>

    private void visitSwitchInsn(final Label dflt, final Label[] labels) {
        // Label currentBlock = this.currentBlock;
<span class="pc bpc" id="L1247" title="1 of 2 branches missed.">        if (currentBlock != null) {</span>
<span class="pc bpc" id="L1248" title="1 of 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="fc" id="L1249">                currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);</span>
                // adds current block successors
<span class="fc" id="L1251">                addSuccessor(Edge.NORMAL, dflt);</span>
<span class="fc" id="L1252">                dflt.getFirst().status |= Label.TARGET;</span>
<span class="fc bfc" id="L1253" title="All 2 branches covered.">                for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="fc" id="L1254">                    addSuccessor(Edge.NORMAL, labels[i]);</span>
<span class="fc" id="L1255">                    labels[i].getFirst().status |= Label.TARGET;</span>
                }
            } else {
                // updates current stack size (max stack size unchanged)
<span class="nc" id="L1259">                --stackSize;</span>
                // adds current block successors
<span class="nc" id="L1261">                addSuccessor(stackSize, dflt);</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">                for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L1263">                    addSuccessor(stackSize, labels[i]);</span>
                }
            }
            // ends current block
<span class="fc" id="L1267">            noSuccessor();</span>
        }
<span class="fc" id="L1269">    }</span>

    @Override
    public void visitMultiANewArrayInsn(final String desc, final int dims) {
<span class="nc" id="L1273">        lastCodeOffset = code.length;</span>
<span class="nc" id="L1274">        Item i = cw.newClassItem(desc);</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L1276" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L1278">                currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);</span>
            } else {
                // updates current stack size (max stack size unchanged because
                // stack size variation always negative or null)
<span class="nc" id="L1282">                stackSize += 1 - dims;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc" id="L1286">        code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);</span>
<span class="nc" id="L1287">    }</span>

    @Override
    public AnnotationVisitor visitInsnAnnotation(int typeRef,
            TypePath typePath, String desc, boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L1295">        ByteVector bv = new ByteVector();</span>
        // write target_type and target_info
<span class="nc" id="L1297">        typeRef = (typeRef &amp; 0xFF0000FF) | (lastCodeOffset &lt;&lt; 8);</span>
<span class="nc" id="L1298">        AnnotationWriter.putTarget(typeRef, typePath, bv);</span>
        // write type, and reserve space for values count
<span class="nc" id="L1300">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L1301">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv,</span>
                bv.length - 2);
<span class="nc bnc" id="L1303" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L1304">            aw.next = ctanns;</span>
<span class="nc" id="L1305">            ctanns = aw;</span>
        } else {
<span class="nc" id="L1307">            aw.next = ictanns;</span>
<span class="nc" id="L1308">            ictanns = aw;</span>
        }
<span class="nc" id="L1310">        return aw;</span>
    }

    @Override
    public void visitTryCatchBlock(final Label start, final Label end,
            final Label handler, final String type) {
<span class="fc" id="L1316">        ++handlerCount;</span>
<span class="fc" id="L1317">        Handler h = new Handler();</span>
<span class="fc" id="L1318">        h.start = start;</span>
<span class="fc" id="L1319">        h.end = end;</span>
<span class="fc" id="L1320">        h.handler = handler;</span>
<span class="fc" id="L1321">        h.desc = type;</span>
<span class="pc bpc" id="L1322" title="1 of 2 branches missed.">        h.type = type != null ? cw.newClass(type) : 0;</span>
<span class="fc bfc" id="L1323" title="All 2 branches covered.">        if (lastHandler == null) {</span>
<span class="fc" id="L1324">            firstHandler = h;</span>
        } else {
<span class="fc" id="L1326">            lastHandler.next = h;</span>
        }
<span class="fc" id="L1328">        lastHandler = h;</span>
<span class="fc" id="L1329">    }</span>

    @Override
    public AnnotationVisitor visitTryCatchAnnotation(int typeRef,
            TypePath typePath, String desc, boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L1337">        ByteVector bv = new ByteVector();</span>
        // write target_type and target_info
<span class="nc" id="L1339">        AnnotationWriter.putTarget(typeRef, typePath, bv);</span>
        // write type, and reserve space for values count
<span class="nc" id="L1341">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L1342">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv,</span>
                bv.length - 2);
<span class="nc bnc" id="L1344" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L1345">            aw.next = ctanns;</span>
<span class="nc" id="L1346">            ctanns = aw;</span>
        } else {
<span class="nc" id="L1348">            aw.next = ictanns;</span>
<span class="nc" id="L1349">            ictanns = aw;</span>
        }
<span class="nc" id="L1351">        return aw;</span>
    }

    @Override
    public void visitLocalVariable(final String name, final String desc,
            final String signature, final Label start, final Label end,
            final int index) {
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">        if (signature != null) {</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">            if (localVarType == null) {</span>
<span class="nc" id="L1360">                localVarType = new ByteVector();</span>
            }
<span class="nc" id="L1362">            ++localVarTypeCount;</span>
<span class="nc" id="L1363">            localVarType.putShort(start.position)</span>
<span class="nc" id="L1364">                    .putShort(end.position - start.position)</span>
<span class="nc" id="L1365">                    .putShort(cw.newUTF8(name)).putShort(cw.newUTF8(signature))</span>
<span class="nc" id="L1366">                    .putShort(index);</span>
        }
<span class="fc bfc" id="L1368" title="All 2 branches covered.">        if (localVar == null) {</span>
<span class="fc" id="L1369">            localVar = new ByteVector();</span>
        }
<span class="fc" id="L1371">        ++localVarCount;</span>
<span class="fc" id="L1372">        localVar.putShort(start.position)</span>
<span class="fc" id="L1373">                .putShort(end.position - start.position)</span>
<span class="fc" id="L1374">                .putShort(cw.newUTF8(name)).putShort(cw.newUTF8(desc))</span>
<span class="fc" id="L1375">                .putShort(index);</span>
<span class="pc bpc" id="L1376" title="1 of 2 branches missed.">        if (compute != NOTHING) {</span>
            // updates max locals
<span class="fc" id="L1378">            char c = desc.charAt(0);</span>
<span class="pc bpc" id="L1379" title="1 of 4 branches missed.">            int n = index + (c == 'J' || c == 'D' ? 2 : 1);</span>
<span class="fc bfc" id="L1380" title="All 2 branches covered.">            if (n &gt; maxLocals) {</span>
<span class="fc" id="L1381">                maxLocals = n;</span>
            }
        }
<span class="fc" id="L1384">    }</span>

    @Override
    public AnnotationVisitor visitLocalVariableAnnotation(int typeRef,
            TypePath typePath, Label[] start, Label[] end, int[] index,
            String desc, boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L1393">        ByteVector bv = new ByteVector();</span>
        // write target_type and target_info
<span class="nc" id="L1395">        bv.putByte(typeRef &gt;&gt;&gt; 24).putShort(start.length);</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">        for (int i = 0; i &lt; start.length; ++i) {</span>
<span class="nc" id="L1397">            bv.putShort(start[i].position)</span>
<span class="nc" id="L1398">                    .putShort(end[i].position - start[i].position)</span>
<span class="nc" id="L1399">                    .putShort(index[i]);</span>
        }
<span class="nc bnc" id="L1401" title="All 2 branches missed.">        if (typePath == null) {</span>
<span class="nc" id="L1402">            bv.putByte(0);</span>
        } else {
<span class="nc" id="L1404">            int length = typePath.b[typePath.offset] * 2 + 1;</span>
<span class="nc" id="L1405">            bv.putByteArray(typePath.b, typePath.offset, length);</span>
        }
        // write type, and reserve space for values count
<span class="nc" id="L1408">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L1409">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv,</span>
                bv.length - 2);
<span class="nc bnc" id="L1411" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L1412">            aw.next = ctanns;</span>
<span class="nc" id="L1413">            ctanns = aw;</span>
        } else {
<span class="nc" id="L1415">            aw.next = ictanns;</span>
<span class="nc" id="L1416">            ictanns = aw;</span>
        }
<span class="nc" id="L1418">        return aw;</span>
    }

    @Override
    public void visitLineNumber(final int line, final Label start) {
<span class="fc bfc" id="L1423" title="All 2 branches covered.">        if (lineNumber == null) {</span>
<span class="fc" id="L1424">            lineNumber = new ByteVector();</span>
        }
<span class="fc" id="L1426">        ++lineNumberCount;</span>
<span class="fc" id="L1427">        lineNumber.putShort(start.position);</span>
<span class="fc" id="L1428">        lineNumber.putShort(line);</span>
<span class="fc" id="L1429">    }</span>

    @Override
    public void visitMaxs(final int maxStack, final int maxLocals) {
<span class="fc bfc" id="L1433" title="All 2 branches covered.">        if (ClassReader.FRAMES &amp;&amp; compute == FRAMES) {</span>
            // completes the control flow graph with exception handler blocks
<span class="fc" id="L1435">            Handler handler = firstHandler;</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">            while (handler != null) {</span>
<span class="fc" id="L1437">                Label l = handler.start.getFirst();</span>
<span class="fc" id="L1438">                Label h = handler.handler.getFirst();</span>
<span class="fc" id="L1439">                Label e = handler.end.getFirst();</span>
                // computes the kind of the edges to 'h'
<span class="pc bpc" id="L1441" title="1 of 2 branches missed.">                String t = handler.desc == null ? &quot;java/lang/Throwable&quot;</span>
                        : handler.desc;
<span class="fc" id="L1443">                int kind = Frame.OBJECT | cw.addType(t);</span>
                // h is an exception handler
<span class="fc" id="L1445">                h.status |= Label.TARGET;</span>
                // adds 'h' as a successor of labels between 'start' and 'end'
<span class="fc bfc" id="L1447" title="All 2 branches covered.">                while (l != e) {</span>
                    // creates an edge to 'h'
<span class="fc" id="L1449">                    Edge b = new Edge();</span>
<span class="fc" id="L1450">                    b.info = kind;</span>
<span class="fc" id="L1451">                    b.successor = h;</span>
                    // adds it to the successors of 'l'
<span class="fc" id="L1453">                    b.next = l.successors;</span>
<span class="fc" id="L1454">                    l.successors = b;</span>
                    // goes to the next label
<span class="fc" id="L1456">                    l = l.successor;</span>
<span class="fc" id="L1457">                }</span>
<span class="fc" id="L1458">                handler = handler.next;</span>
<span class="fc" id="L1459">            }</span>

            // creates and visits the first (implicit) frame
<span class="fc" id="L1462">            Frame f = labels.frame;</span>
<span class="fc" id="L1463">            Type[] args = Type.getArgumentTypes(descriptor);</span>
<span class="fc" id="L1464">            f.initInputFrame(cw, access, args, this.maxLocals);</span>
<span class="fc" id="L1465">            visitFrame(f);</span>

            /*
             * fix point algorithm: mark the first basic block as 'changed'
             * (i.e. put it in the 'changed' list) and, while there are changed
             * basic blocks, choose one, mark it as unchanged, and update its
             * successors (which can be changed in the process).
             */
<span class="fc" id="L1473">            int max = 0;</span>
<span class="fc" id="L1474">            Label changed = labels;</span>
<span class="fc bfc" id="L1475" title="All 2 branches covered.">            while (changed != null) {</span>
                // removes a basic block from the list of changed basic blocks
<span class="fc" id="L1477">                Label l = changed;</span>
<span class="fc" id="L1478">                changed = changed.next;</span>
<span class="fc" id="L1479">                l.next = null;</span>
<span class="fc" id="L1480">                f = l.frame;</span>
                // a reachable jump target must be stored in the stack map
<span class="fc bfc" id="L1482" title="All 2 branches covered.">                if ((l.status &amp; Label.TARGET) != 0) {</span>
<span class="fc" id="L1483">                    l.status |= Label.STORE;</span>
                }
                // all visited labels are reachable, by definition
<span class="fc" id="L1486">                l.status |= Label.REACHABLE;</span>
                // updates the (absolute) maximum stack size
<span class="fc" id="L1488">                int blockMax = f.inputStack.length + l.outputStackMax;</span>
<span class="fc bfc" id="L1489" title="All 2 branches covered.">                if (blockMax &gt; max) {</span>
<span class="fc" id="L1490">                    max = blockMax;</span>
                }
                // updates the successors of the current basic block
<span class="fc" id="L1493">                Edge e = l.successors;</span>
<span class="fc bfc" id="L1494" title="All 2 branches covered.">                while (e != null) {</span>
<span class="fc" id="L1495">                    Label n = e.successor.getFirst();</span>
<span class="fc" id="L1496">                    boolean change = f.merge(cw, n.frame, e.info);</span>
<span class="fc bfc" id="L1497" title="All 4 branches covered.">                    if (change &amp;&amp; n.next == null) {</span>
                        // if n has changed and is not already in the 'changed'
                        // list, adds it to this list
<span class="fc" id="L1500">                        n.next = changed;</span>
<span class="fc" id="L1501">                        changed = n;</span>
                    }
<span class="fc" id="L1503">                    e = e.next;</span>
<span class="fc" id="L1504">                }</span>
<span class="fc" id="L1505">            }</span>

            // visits all the frames that must be stored in the stack map
<span class="fc" id="L1508">            Label l = labels;</span>
<span class="fc bfc" id="L1509" title="All 2 branches covered.">            while (l != null) {</span>
<span class="fc" id="L1510">                f = l.frame;</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">                if ((l.status &amp; Label.STORE) != 0) {</span>
<span class="fc" id="L1512">                    visitFrame(f);</span>
                }
<span class="fc bfc" id="L1514" title="All 2 branches covered.">                if ((l.status &amp; Label.REACHABLE) == 0) {</span>
                    // finds start and end of dead basic block
<span class="fc" id="L1516">                    Label k = l.successor;</span>
<span class="fc" id="L1517">                    int start = l.position;</span>
<span class="fc bfc" id="L1518" title="All 2 branches covered.">                    int end = (k == null ? code.length : k.position) - 1;</span>
                    // if non empty basic block
<span class="fc bfc" id="L1520" title="All 2 branches covered.">                    if (end &gt;= start) {</span>
<span class="fc" id="L1521">                        max = Math.max(max, 1);</span>
                        // replaces instructions with NOP ... NOP ATHROW
<span class="fc bfc" id="L1523" title="All 2 branches covered.">                        for (int i = start; i &lt; end; ++i) {</span>
<span class="fc" id="L1524">                            code.data[i] = Opcodes.NOP;</span>
                        }
<span class="fc" id="L1526">                        code.data[end] = (byte) Opcodes.ATHROW;</span>
                        // emits a frame for this unreachable block
<span class="fc" id="L1528">                        int frameIndex = startFrame(start, 0, 1);</span>
<span class="fc" id="L1529">                        frame[frameIndex] = Frame.OBJECT</span>
<span class="fc" id="L1530">                                | cw.addType(&quot;java/lang/Throwable&quot;);</span>
<span class="fc" id="L1531">                        endFrame();</span>
                        // removes the start-end range from the exception
                        // handlers
<span class="fc" id="L1534">                        firstHandler = Handler.remove(firstHandler, l, k);</span>
                    }
                }
<span class="fc" id="L1537">                l = l.successor;</span>
            }

<span class="fc" id="L1540">            handler = firstHandler;</span>
<span class="fc" id="L1541">            handlerCount = 0;</span>
<span class="fc bfc" id="L1542" title="All 2 branches covered.">            while (handler != null) {</span>
<span class="fc" id="L1543">                handlerCount += 1;</span>
<span class="fc" id="L1544">                handler = handler.next;</span>
            }

<span class="fc" id="L1547">            this.maxStack = max;</span>
<span class="fc bfc" id="L1548" title="All 2 branches covered.">        } else if (compute == MAXS) {</span>
            // completes the control flow graph with exception handler blocks
<span class="fc" id="L1550">            Handler handler = firstHandler;</span>
<span class="pc bpc" id="L1551" title="1 of 2 branches missed.">            while (handler != null) {</span>
<span class="nc" id="L1552">                Label l = handler.start;</span>
<span class="nc" id="L1553">                Label h = handler.handler;</span>
<span class="nc" id="L1554">                Label e = handler.end;</span>
                // adds 'h' as a successor of labels between 'start' and 'end'
<span class="nc bnc" id="L1556" title="All 2 branches missed.">                while (l != e) {</span>
                    // creates an edge to 'h'
<span class="nc" id="L1558">                    Edge b = new Edge();</span>
<span class="nc" id="L1559">                    b.info = Edge.EXCEPTION;</span>
<span class="nc" id="L1560">                    b.successor = h;</span>
                    // adds it to the successors of 'l'
<span class="nc bnc" id="L1562" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) == 0) {</span>
<span class="nc" id="L1563">                        b.next = l.successors;</span>
<span class="nc" id="L1564">                        l.successors = b;</span>
                    } else {
                        // if l is a JSR block, adds b after the first two edges
                        // to preserve the hypothesis about JSR block successors
                        // order (see {@link #visitJumpInsn})
<span class="nc" id="L1569">                        b.next = l.successors.next.next;</span>
<span class="nc" id="L1570">                        l.successors.next.next = b;</span>
                    }
                    // goes to the next label
<span class="nc" id="L1573">                    l = l.successor;</span>
<span class="nc" id="L1574">                }</span>
<span class="nc" id="L1575">                handler = handler.next;</span>
<span class="nc" id="L1576">            }</span>

<span class="pc bpc" id="L1578" title="1 of 2 branches missed.">            if (subroutines &gt; 0) {</span>
                // completes the control flow graph with the RET successors
                /*
                 * first step: finds the subroutines. This step determines, for
                 * each basic block, to which subroutine(s) it belongs.
                 */
                // finds the basic blocks that belong to the &quot;main&quot; subroutine
<span class="nc" id="L1585">                int id = 0;</span>
<span class="nc" id="L1586">                labels.visitSubroutine(null, 1, subroutines);</span>
                // finds the basic blocks that belong to the real subroutines
<span class="nc" id="L1588">                Label l = labels;</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">                while (l != null) {</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) != 0) {</span>
                        // the subroutine is defined by l's TARGET, not by l
<span class="nc" id="L1592">                        Label subroutine = l.successors.next.successor;</span>
                        // if this subroutine has not been visited yet...
<span class="nc bnc" id="L1594" title="All 2 branches missed.">                        if ((subroutine.status &amp; Label.VISITED) == 0) {</span>
                            // ...assigns it a new id and finds its basic blocks
<span class="nc" id="L1596">                            id += 1;</span>
<span class="nc" id="L1597">                            subroutine.visitSubroutine(null, (id / 32L) &lt;&lt; 32</span>
                                    | (1L &lt;&lt; (id % 32)), subroutines);
                        }
                    }
<span class="nc" id="L1601">                    l = l.successor;</span>
                }
                // second step: finds the successors of RET blocks
<span class="nc" id="L1604">                l = labels;</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">                while (l != null) {</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) != 0) {</span>
<span class="nc" id="L1607">                        Label L = labels;</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">                        while (L != null) {</span>
<span class="nc" id="L1609">                            L.status &amp;= ~Label.VISITED2;</span>
<span class="nc" id="L1610">                            L = L.successor;</span>
                        }
                        // the subroutine is defined by l's TARGET, not by l
<span class="nc" id="L1613">                        Label subroutine = l.successors.next.successor;</span>
<span class="nc" id="L1614">                        subroutine.visitSubroutine(l, 0, subroutines);</span>
                    }
<span class="nc" id="L1616">                    l = l.successor;</span>
                }
            }

            /*
             * control flow analysis algorithm: while the block stack is not
             * empty, pop a block from this stack, update the max stack size,
             * compute the true (non relative) begin stack size of the
             * successors of this block, and push these successors onto the
             * stack (unless they have already been pushed onto the stack).
             * Note: by hypothesis, the {@link Label#inputStackTop} of the
             * blocks in the block stack are the true (non relative) beginning
             * stack sizes of these blocks.
             */
<span class="fc" id="L1630">            int max = 0;</span>
<span class="fc" id="L1631">            Label stack = labels;</span>
<span class="fc bfc" id="L1632" title="All 2 branches covered.">            while (stack != null) {</span>
                // pops a block from the stack
<span class="fc" id="L1634">                Label l = stack;</span>
<span class="fc" id="L1635">                stack = stack.next;</span>
                // computes the true (non relative) max stack size of this block
<span class="fc" id="L1637">                int start = l.inputStackTop;</span>
<span class="fc" id="L1638">                int blockMax = start + l.outputStackMax;</span>
                // updates the global max stack size
<span class="fc bfc" id="L1640" title="All 2 branches covered.">                if (blockMax &gt; max) {</span>
<span class="fc" id="L1641">                    max = blockMax;</span>
                }
                // analyzes the successors of the block
<span class="fc" id="L1644">                Edge b = l.successors;</span>
<span class="pc bpc" id="L1645" title="1 of 2 branches missed.">                if ((l.status &amp; Label.JSR) != 0) {</span>
                    // ignores the first edge of JSR blocks (virtual successor)
<span class="nc" id="L1647">                    b = b.next;</span>
                }
<span class="pc bpc" id="L1649" title="1 of 2 branches missed.">                while (b != null) {</span>
<span class="nc" id="L1650">                    l = b.successor;</span>
                    // if this successor has not already been pushed...
<span class="nc bnc" id="L1652" title="All 2 branches missed.">                    if ((l.status &amp; Label.PUSHED) == 0) {</span>
                        // computes its true beginning stack size...
<span class="nc bnc" id="L1654" title="All 2 branches missed.">                        l.inputStackTop = b.info == Edge.EXCEPTION ? 1 : start</span>
                                + b.info;
                        // ...and pushes it onto the stack
<span class="nc" id="L1657">                        l.status |= Label.PUSHED;</span>
<span class="nc" id="L1658">                        l.next = stack;</span>
<span class="nc" id="L1659">                        stack = l;</span>
                    }
<span class="nc" id="L1661">                    b = b.next;</span>
                }
<span class="fc" id="L1663">            }</span>
<span class="fc" id="L1664">            this.maxStack = Math.max(maxStack, max);</span>
<span class="fc" id="L1665">        } else {</span>
<span class="fc" id="L1666">            this.maxStack = maxStack;</span>
<span class="fc" id="L1667">            this.maxLocals = maxLocals;</span>
        }
<span class="fc" id="L1669">    }</span>

    @Override
    public void visitEnd() {
<span class="fc" id="L1673">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: control flow analysis algorithm
    // ------------------------------------------------------------------------

    /**
     * Adds a successor to the {@link #currentBlock currentBlock} block.
     *
     * @param info
     *            information about the control flow edge to be added.
     * @param successor
     *            the successor block to be added to the current block.
     */
    private void addSuccessor(final int info, final Label successor) {
        // creates and initializes an Edge object...
<span class="fc" id="L1689">        Edge b = new Edge();</span>
<span class="fc" id="L1690">        b.info = info;</span>
<span class="fc" id="L1691">        b.successor = successor;</span>
        // ...and adds it to the successor list of the currentBlock block
<span class="fc" id="L1693">        b.next = currentBlock.successors;</span>
<span class="fc" id="L1694">        currentBlock.successors = b;</span>
<span class="fc" id="L1695">    }</span>

    /**
     * Ends the current basic block. This method must be used in the case where
     * the current basic block does not have any successor.
     */
    private void noSuccessor() {
<span class="fc bfc" id="L1702" title="All 2 branches covered.">        if (compute == FRAMES) {</span>
<span class="fc" id="L1703">            Label l = new Label();</span>
<span class="fc" id="L1704">            l.frame = new Frame();</span>
<span class="fc" id="L1705">            l.frame.owner = l;</span>
<span class="fc" id="L1706">            l.resolve(this, code.length, code.data);</span>
<span class="fc" id="L1707">            previousBlock.successor = l;</span>
<span class="fc" id="L1708">            previousBlock = l;</span>
<span class="fc" id="L1709">        } else {</span>
<span class="fc" id="L1710">            currentBlock.outputStackMax = maxStackSize;</span>
        }
<span class="fc" id="L1712">        currentBlock = null;</span>
<span class="fc" id="L1713">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: stack map frames
    // ------------------------------------------------------------------------

    /**
     * Visits a frame that has been computed from scratch.
     *
     * @param f
     *            the frame that must be visited.
     */
    private void visitFrame(final Frame f) {
        int i, t;
<span class="fc" id="L1727">        int nTop = 0;</span>
<span class="fc" id="L1728">        int nLocal = 0;</span>
<span class="fc" id="L1729">        int nStack = 0;</span>
<span class="fc" id="L1730">        int[] locals = f.inputLocals;</span>
<span class="fc" id="L1731">        int[] stacks = f.inputStack;</span>
        // computes the number of locals (ignores TOP types that are just after
        // a LONG or a DOUBLE, and all trailing TOP types)
<span class="fc bfc" id="L1734" title="All 2 branches covered.">        for (i = 0; i &lt; locals.length; ++i) {</span>
<span class="fc" id="L1735">            t = locals[i];</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">            if (t == Frame.TOP) {</span>
<span class="fc" id="L1737">                ++nTop;</span>
            } else {
<span class="fc" id="L1739">                nLocal += nTop + 1;</span>
<span class="fc" id="L1740">                nTop = 0;</span>
            }
<span class="fc bfc" id="L1742" title="All 4 branches covered.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="fc" id="L1743">                ++i;</span>
            }
        }
        // computes the stack size (ignores TOP types that are just after
        // a LONG or a DOUBLE)
<span class="fc bfc" id="L1748" title="All 2 branches covered.">        for (i = 0; i &lt; stacks.length; ++i) {</span>
<span class="fc" id="L1749">            t = stacks[i];</span>
<span class="fc" id="L1750">            ++nStack;</span>
<span class="pc bpc" id="L1751" title="2 of 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1752">                ++i;</span>
            }
        }
        // visits the frame and its content
<span class="fc" id="L1756">        int frameIndex = startFrame(f.owner.position, nLocal, nStack);</span>
<span class="fc bfc" id="L1757" title="All 2 branches covered.">        for (i = 0; nLocal &gt; 0; ++i, --nLocal) {</span>
<span class="fc" id="L1758">            t = locals[i];</span>
<span class="fc" id="L1759">            frame[frameIndex++] = t;</span>
<span class="fc bfc" id="L1760" title="All 4 branches covered.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="fc" id="L1761">                ++i;</span>
            }
        }
<span class="fc bfc" id="L1764" title="All 2 branches covered.">        for (i = 0; i &lt; stacks.length; ++i) {</span>
<span class="fc" id="L1765">            t = stacks[i];</span>
<span class="fc" id="L1766">            frame[frameIndex++] = t;</span>
<span class="pc bpc" id="L1767" title="2 of 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1768">                ++i;</span>
            }
        }
<span class="fc" id="L1771">        endFrame();</span>
<span class="fc" id="L1772">    }</span>

    /**
     * Visit the implicit first frame of this method.
     */
    private void visitImplicitFirstFrame() {
        // There can be at most descriptor.length() + 1 locals
<span class="nc" id="L1779">        int frameIndex = startFrame(0, descriptor.length() + 1, 0);</span>
<span class="nc bnc" id="L1780" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_STATIC) == 0) {</span>
<span class="nc bnc" id="L1781" title="All 2 branches missed.">            if ((access &amp; ACC_CONSTRUCTOR) == 0) {</span>
<span class="nc" id="L1782">                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);</span>
            } else {
<span class="nc" id="L1784">                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;</span>
            }
        }
<span class="nc" id="L1787">        int i = 1;</span>
        loop: while (true) {
<span class="nc" id="L1789">            int j = i;</span>
<span class="nc bnc" id="L1790" title="All 7 branches missed.">            switch (descriptor.charAt(i++)) {</span>
            case 'Z':
            case 'C':
            case 'B':
            case 'S':
            case 'I':
<span class="nc" id="L1796">                frame[frameIndex++] = 1; // Opcodes.INTEGER;</span>
<span class="nc" id="L1797">                break;</span>
            case 'F':
<span class="nc" id="L1799">                frame[frameIndex++] = 2; // Opcodes.FLOAT;</span>
<span class="nc" id="L1800">                break;</span>
            case 'J':
<span class="nc" id="L1802">                frame[frameIndex++] = 4; // Opcodes.LONG;</span>
<span class="nc" id="L1803">                break;</span>
            case 'D':
<span class="nc" id="L1805">                frame[frameIndex++] = 3; // Opcodes.DOUBLE;</span>
<span class="nc" id="L1806">                break;</span>
            case '[':
<span class="nc bnc" id="L1808" title="All 2 branches missed.">                while (descriptor.charAt(i) == '[') {</span>
<span class="nc" id="L1809">                    ++i;</span>
                }
<span class="nc bnc" id="L1811" title="All 2 branches missed.">                if (descriptor.charAt(i) == 'L') {</span>
<span class="nc" id="L1812">                    ++i;</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">                    while (descriptor.charAt(i) != ';') {</span>
<span class="nc" id="L1814">                        ++i;</span>
                    }
                }
<span class="nc" id="L1817">                frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L1818">                        | cw.addType(descriptor.substring(j, ++i));</span>
<span class="nc" id="L1819">                break;</span>
            case 'L':
<span class="nc bnc" id="L1821" title="All 2 branches missed.">                while (descriptor.charAt(i) != ';') {</span>
<span class="nc" id="L1822">                    ++i;</span>
                }
<span class="nc" id="L1824">                frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L1825">                        | cw.addType(descriptor.substring(j + 1, i++));</span>
<span class="nc" id="L1826">                break;</span>
            default:
<span class="nc" id="L1828">                break loop;</span>
            }
<span class="nc" id="L1830">        }</span>
<span class="nc" id="L1831">        frame[1] = frameIndex - 3;</span>
<span class="nc" id="L1832">        endFrame();</span>
<span class="nc" id="L1833">    }</span>

    /**
     * Starts the visit of a stack map frame.
     *
     * @param offset
     *            the offset of the instruction to which the frame corresponds.
     * @param nLocal
     *            the number of local variables in the frame.
     * @param nStack
     *            the number of stack elements in the frame.
     * @return the index of the next element to be written in this frame.
     */
    private int startFrame(final int offset, final int nLocal, final int nStack) {
<span class="fc" id="L1847">        int n = 3 + nLocal + nStack;</span>
<span class="pc bpc" id="L1848" title="3 of 4 branches missed.">        if (frame == null || frame.length &lt; n) {</span>
<span class="fc" id="L1849">            frame = new int[n];</span>
        }
<span class="fc" id="L1851">        frame[0] = offset;</span>
<span class="fc" id="L1852">        frame[1] = nLocal;</span>
<span class="fc" id="L1853">        frame[2] = nStack;</span>
<span class="fc" id="L1854">        return 3;</span>
    }

    /**
     * Checks if the visit of the current frame {@link #frame} is finished, and
     * if yes, write it in the StackMapTable attribute.
     */
    private void endFrame() {
<span class="fc bfc" id="L1862" title="All 2 branches covered.">        if (previousFrame != null) { // do not write the first frame</span>
<span class="fc bfc" id="L1863" title="All 2 branches covered.">            if (stackMap == null) {</span>
<span class="fc" id="L1864">                stackMap = new ByteVector();</span>
            }
<span class="fc" id="L1866">            writeFrame();</span>
<span class="fc" id="L1867">            ++frameCount;</span>
        }
<span class="fc" id="L1869">        previousFrame = frame;</span>
<span class="fc" id="L1870">        frame = null;</span>
<span class="fc" id="L1871">    }</span>

    /**
     * Compress and writes the current frame {@link #frame} in the StackMapTable
     * attribute.
     */
    private void writeFrame() {
<span class="fc" id="L1878">        int clocalsSize = frame[1];</span>
<span class="fc" id="L1879">        int cstackSize = frame[2];</span>
<span class="pc bpc" id="L1880" title="1 of 2 branches missed.">        if ((cw.version &amp; 0xFFFF) &lt; Opcodes.V1_6) {</span>
<span class="nc" id="L1881">            stackMap.putShort(frame[0]).putShort(clocalsSize);</span>
<span class="nc" id="L1882">            writeFrameTypes(3, 3 + clocalsSize);</span>
<span class="nc" id="L1883">            stackMap.putShort(cstackSize);</span>
<span class="nc" id="L1884">            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);</span>
<span class="nc" id="L1885">            return;</span>
        }
<span class="fc" id="L1887">        int localsSize = previousFrame[1];</span>
<span class="fc" id="L1888">        int type = FULL_FRAME;</span>
<span class="fc" id="L1889">        int k = 0;</span>
        int delta;
<span class="fc bfc" id="L1891" title="All 2 branches covered.">        if (frameCount == 0) {</span>
<span class="fc" id="L1892">            delta = frame[0];</span>
        } else {
<span class="fc" id="L1894">            delta = frame[0] - previousFrame[0] - 1;</span>
        }
<span class="fc bfc" id="L1896" title="All 2 branches covered.">        if (cstackSize == 0) {</span>
<span class="fc" id="L1897">            k = clocalsSize - localsSize;</span>
<span class="fc bfc" id="L1898" title="All 4 branches covered.">            switch (k) {</span>
            case -3:
            case -2:
            case -1:
<span class="fc" id="L1902">                type = CHOP_FRAME;</span>
<span class="fc" id="L1903">                localsSize = clocalsSize;</span>
<span class="fc" id="L1904">                break;</span>
            case 0:
<span class="fc bfc" id="L1906" title="All 2 branches covered.">                type = delta &lt; 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;</span>
<span class="fc" id="L1907">                break;</span>
            case 1:
            case 2:
            case 3:
<span class="fc" id="L1911">                type = APPEND_FRAME;</span>
<span class="fc" id="L1912">                break;</span>
            }
<span class="fc bfc" id="L1914" title="All 4 branches covered.">        } else if (clocalsSize == localsSize &amp;&amp; cstackSize == 1) {</span>
<span class="pc bpc" id="L1915" title="1 of 2 branches missed.">            type = delta &lt; 63 ? SAME_LOCALS_1_STACK_ITEM_FRAME</span>
                    : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;
        }
<span class="fc bfc" id="L1918" title="All 2 branches covered.">        if (type != FULL_FRAME) {</span>
            // verify if locals are the same
<span class="fc" id="L1920">            int l = 3;</span>
<span class="fc bfc" id="L1921" title="All 2 branches covered.">            for (int j = 0; j &lt; localsSize; j++) {</span>
<span class="fc bfc" id="L1922" title="All 2 branches covered.">                if (frame[l] != previousFrame[l]) {</span>
<span class="fc" id="L1923">                    type = FULL_FRAME;</span>
<span class="fc" id="L1924">                    break;</span>
                }
<span class="fc" id="L1926">                l++;</span>
            }
        }
<span class="pc bpc" id="L1929" title="1 of 7 branches missed.">        switch (type) {</span>
        case SAME_FRAME:
<span class="fc" id="L1931">            stackMap.putByte(delta);</span>
<span class="fc" id="L1932">            break;</span>
        case SAME_LOCALS_1_STACK_ITEM_FRAME:
<span class="fc" id="L1934">            stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);</span>
<span class="fc" id="L1935">            writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);</span>
<span class="fc" id="L1936">            break;</span>
        case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:
<span class="nc" id="L1938">            stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(</span>
                    delta);
<span class="nc" id="L1940">            writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);</span>
<span class="nc" id="L1941">            break;</span>
        case SAME_FRAME_EXTENDED:
<span class="fc" id="L1943">            stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);</span>
<span class="fc" id="L1944">            break;</span>
        case CHOP_FRAME:
<span class="fc" id="L1946">            stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);</span>
<span class="fc" id="L1947">            break;</span>
        case APPEND_FRAME:
<span class="fc" id="L1949">            stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);</span>
<span class="fc" id="L1950">            writeFrameTypes(3 + localsSize, 3 + clocalsSize);</span>
<span class="fc" id="L1951">            break;</span>
        // case FULL_FRAME:
        default:
<span class="fc" id="L1954">            stackMap.putByte(FULL_FRAME).putShort(delta).putShort(clocalsSize);</span>
<span class="fc" id="L1955">            writeFrameTypes(3, 3 + clocalsSize);</span>
<span class="fc" id="L1956">            stackMap.putShort(cstackSize);</span>
<span class="fc" id="L1957">            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);</span>
        }
<span class="fc" id="L1959">    }</span>

    /**
     * Writes some types of the current frame {@link #frame} into the
     * StackMapTableAttribute. This method converts types from the format used
     * in {@link Label} to the format used in StackMapTable attributes. In
     * particular, it converts type table indexes to constant pool indexes.
     *
     * @param start
     *            index of the first type in {@link #frame} to write.
     * @param end
     *            index of last type in {@link #frame} to write (exclusive).
     */
    private void writeFrameTypes(final int start, final int end) {
<span class="fc bfc" id="L1973" title="All 2 branches covered.">        for (int i = start; i &lt; end; ++i) {</span>
<span class="fc" id="L1974">            int t = frame[i];</span>
<span class="fc" id="L1975">            int d = t &amp; Frame.DIM;</span>
<span class="fc bfc" id="L1976" title="All 2 branches covered.">            if (d == 0) {</span>
<span class="fc" id="L1977">                int v = t &amp; Frame.BASE_VALUE;</span>
<span class="pc bpc" id="L1978" title="1 of 3 branches missed.">                switch (t &amp; Frame.BASE_KIND) {</span>
                case Frame.OBJECT:
<span class="fc" id="L1980">                    stackMap.putByte(7).putShort(</span>
<span class="fc" id="L1981">                            cw.newClass(cw.typeTable[v].strVal1));</span>
<span class="fc" id="L1982">                    break;</span>
                case Frame.UNINITIALIZED:
<span class="nc" id="L1984">                    stackMap.putByte(8).putShort(cw.typeTable[v].intVal);</span>
<span class="nc" id="L1985">                    break;</span>
                default:
<span class="fc" id="L1987">                    stackMap.putByte(v);</span>
                }
<span class="fc" id="L1989">            } else {</span>
<span class="fc" id="L1990">                StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L1991">                d &gt;&gt;= 28;</span>
<span class="fc bfc" id="L1992" title="All 2 branches covered.">                while (d-- &gt; 0) {</span>
<span class="fc" id="L1993">                    buf.append('[');</span>
                }
<span class="pc bpc" id="L1995" title="1 of 2 branches missed.">                if ((t &amp; Frame.BASE_KIND) == Frame.OBJECT) {</span>
<span class="fc" id="L1996">                    buf.append('L');</span>
<span class="fc" id="L1997">                    buf.append(cw.typeTable[t &amp; Frame.BASE_VALUE].strVal1);</span>
<span class="fc" id="L1998">                    buf.append(';');</span>
                } else {
<span class="nc bnc" id="L2000" title="All 8 branches missed.">                    switch (t &amp; 0xF) {</span>
                    case 1:
<span class="nc" id="L2002">                        buf.append('I');</span>
<span class="nc" id="L2003">                        break;</span>
                    case 2:
<span class="nc" id="L2005">                        buf.append('F');</span>
<span class="nc" id="L2006">                        break;</span>
                    case 3:
<span class="nc" id="L2008">                        buf.append('D');</span>
<span class="nc" id="L2009">                        break;</span>
                    case 9:
<span class="nc" id="L2011">                        buf.append('Z');</span>
<span class="nc" id="L2012">                        break;</span>
                    case 10:
<span class="nc" id="L2014">                        buf.append('B');</span>
<span class="nc" id="L2015">                        break;</span>
                    case 11:
<span class="nc" id="L2017">                        buf.append('C');</span>
<span class="nc" id="L2018">                        break;</span>
                    case 12:
<span class="nc" id="L2020">                        buf.append('S');</span>
<span class="nc" id="L2021">                        break;</span>
                    default:
<span class="nc" id="L2023">                        buf.append('J');</span>
                    }
                }
<span class="fc" id="L2026">                stackMap.putByte(7).putShort(cw.newClass(buf.toString()));</span>
            }
        }
<span class="fc" id="L2029">    }</span>

    private void writeFrameType(final Object type) {
<span class="nc bnc" id="L2032" title="All 2 branches missed.">        if (type instanceof String) {</span>
<span class="nc" id="L2033">            stackMap.putByte(7).putShort(cw.newClass((String) type));</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">        } else if (type instanceof Integer) {</span>
<span class="nc" id="L2035">            stackMap.putByte(((Integer) type).intValue());</span>
        } else {
<span class="nc" id="L2037">            stackMap.putByte(8).putShort(((Label) type).position);</span>
        }
<span class="nc" id="L2039">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: dump bytecode array
    // ------------------------------------------------------------------------

    /**
     * Returns the size of the bytecode of this method.
     *
     * @return the size of the bytecode of this method.
     */
    final int getSize() {
<span class="pc bpc" id="L2051" title="1 of 2 branches missed.">        if (classReaderOffset != 0) {</span>
<span class="nc" id="L2052">            return 6 + classReaderLength;</span>
        }
<span class="pc bpc" id="L2054" title="1 of 2 branches missed.">        if (resize) {</span>
            // replaces the temporary jump opcodes introduced by Label.resolve.
            if (ClassReader.RESIZE) {
<span class="nc" id="L2057">                resizeInstructions();</span>
            } else {
                throw new RuntimeException(&quot;Method code too large!&quot;);
            }
        }
<span class="fc" id="L2062">        int size = 8;</span>
<span class="pc bpc" id="L2063" title="1 of 2 branches missed.">        if (code.length &gt; 0) {</span>
<span class="pc bpc" id="L2064" title="1 of 2 branches missed.">            if (code.length &gt; 65536) {</span>
<span class="nc" id="L2065">                throw new RuntimeException(&quot;Method code too large!&quot;);</span>
            }
<span class="fc" id="L2067">            cw.newUTF8(&quot;Code&quot;);</span>
<span class="fc" id="L2068">            size += 18 + code.length + 8 * handlerCount;</span>
<span class="fc bfc" id="L2069" title="All 2 branches covered.">            if (localVar != null) {</span>
<span class="fc" id="L2070">                cw.newUTF8(&quot;LocalVariableTable&quot;);</span>
<span class="fc" id="L2071">                size += 8 + localVar.length;</span>
            }
<span class="pc bpc" id="L2073" title="1 of 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L2074">                cw.newUTF8(&quot;LocalVariableTypeTable&quot;);</span>
<span class="nc" id="L2075">                size += 8 + localVarType.length;</span>
            }
<span class="fc bfc" id="L2077" title="All 2 branches covered.">            if (lineNumber != null) {</span>
<span class="fc" id="L2078">                cw.newUTF8(&quot;LineNumberTable&quot;);</span>
<span class="fc" id="L2079">                size += 8 + lineNumber.length;</span>
            }
<span class="fc bfc" id="L2081" title="All 2 branches covered.">            if (stackMap != null) {</span>
<span class="pc bpc" id="L2082" title="1 of 2 branches missed.">                boolean zip = (cw.version &amp; 0xFFFF) &gt;= Opcodes.V1_6;</span>
<span class="pc bpc" id="L2083" title="1 of 2 branches missed.">                cw.newUTF8(zip ? &quot;StackMapTable&quot; : &quot;StackMap&quot;);</span>
<span class="fc" id="L2084">                size += 8 + stackMap.length;</span>
            }
<span class="pc bpc" id="L2086" title="1 of 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ctanns != null) {</span>
<span class="nc" id="L2087">                cw.newUTF8(&quot;RuntimeVisibleTypeAnnotations&quot;);</span>
<span class="nc" id="L2088">                size += 8 + ctanns.getSize();</span>
            }
<span class="pc bpc" id="L2090" title="1 of 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ictanns != null) {</span>
<span class="nc" id="L2091">                cw.newUTF8(&quot;RuntimeInvisibleTypeAnnotations&quot;);</span>
<span class="nc" id="L2092">                size += 8 + ictanns.getSize();</span>
            }
<span class="pc bpc" id="L2094" title="1 of 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L2095">                size += cattrs.getSize(cw, code.data, code.length, maxStack,</span>
                        maxLocals);
            }
        }
<span class="fc bfc" id="L2099" title="All 2 branches covered.">        if (exceptionCount &gt; 0) {</span>
<span class="fc" id="L2100">            cw.newUTF8(&quot;Exceptions&quot;);</span>
<span class="fc" id="L2101">            size += 8 + 2 * exceptionCount;</span>
        }
<span class="pc bpc" id="L2103" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0) {</span>
<span class="nc bnc" id="L2104" title="All 4 branches missed.">            if ((cw.version &amp; 0xFFFF) &lt; Opcodes.V1_5</span>
                    || (access &amp; ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0) {
<span class="nc" id="L2106">                cw.newUTF8(&quot;Synthetic&quot;);</span>
<span class="nc" id="L2107">                size += 6;</span>
            }
        }
<span class="pc bpc" id="L2110" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="nc" id="L2111">            cw.newUTF8(&quot;Deprecated&quot;);</span>
<span class="nc" id="L2112">            size += 6;</span>
        }
<span class="pc bpc" id="L2114" title="1 of 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="nc" id="L2115">            cw.newUTF8(&quot;Signature&quot;);</span>
<span class="nc" id="L2116">            cw.newUTF8(signature);</span>
<span class="nc" id="L2117">            size += 8;</span>
        }
<span class="pc bpc" id="L2119" title="1 of 2 branches missed.">        if (methodParameters != null) {</span>
<span class="nc" id="L2120">            cw.newUTF8(&quot;MethodParameters&quot;);</span>
<span class="nc" id="L2121">            size += 7 + methodParameters.length;</span>
        }
<span class="pc bpc" id="L2123" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L2124">            cw.newUTF8(&quot;AnnotationDefault&quot;);</span>
<span class="nc" id="L2125">            size += 6 + annd.length;</span>
        }
<span class="fc bfc" id="L2127" title="All 2 branches covered.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="fc" id="L2128">            cw.newUTF8(&quot;RuntimeVisibleAnnotations&quot;);</span>
<span class="fc" id="L2129">            size += 8 + anns.getSize();</span>
        }
<span class="pc bpc" id="L2131" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="nc" id="L2132">            cw.newUTF8(&quot;RuntimeInvisibleAnnotations&quot;);</span>
<span class="nc" id="L2133">            size += 8 + ianns.getSize();</span>
        }
<span class="pc bpc" id="L2135" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; tanns != null) {</span>
<span class="nc" id="L2136">            cw.newUTF8(&quot;RuntimeVisibleTypeAnnotations&quot;);</span>
<span class="nc" id="L2137">            size += 8 + tanns.getSize();</span>
        }
<span class="pc bpc" id="L2139" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; itanns != null) {</span>
<span class="nc" id="L2140">            cw.newUTF8(&quot;RuntimeInvisibleTypeAnnotations&quot;);</span>
<span class="nc" id="L2141">            size += 8 + itanns.getSize();</span>
        }
<span class="pc bpc" id="L2143" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L2144">            cw.newUTF8(&quot;RuntimeVisibleParameterAnnotations&quot;);</span>
<span class="nc" id="L2145">            size += 7 + 2 * (panns.length - synthetics);</span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">            for (int i = panns.length - 1; i &gt;= synthetics; --i) {</span>
<span class="nc bnc" id="L2147" title="All 2 branches missed.">                size += panns[i] == null ? 0 : panns[i].getSize();</span>
            }
        }
<span class="pc bpc" id="L2150" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L2151">            cw.newUTF8(&quot;RuntimeInvisibleParameterAnnotations&quot;);</span>
<span class="nc" id="L2152">            size += 7 + 2 * (ipanns.length - synthetics);</span>
<span class="nc bnc" id="L2153" title="All 2 branches missed.">            for (int i = ipanns.length - 1; i &gt;= synthetics; --i) {</span>
<span class="nc bnc" id="L2154" title="All 2 branches missed.">                size += ipanns[i] == null ? 0 : ipanns[i].getSize();</span>
            }
        }
<span class="pc bpc" id="L2157" title="1 of 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L2158">            size += attrs.getSize(cw, null, 0, -1, -1);</span>
        }
<span class="fc" id="L2160">        return size;</span>
    }

    /**
     * Puts the bytecode of this method in the given byte vector.
     *
     * @param out
     *            the byte vector into which the bytecode of this method must be
     *            copied.
     */
    final void put(final ByteVector out) {
        final int FACTOR = ClassWriter.TO_ACC_SYNTHETIC;
<span class="fc" id="L2172">        int mask = ACC_CONSTRUCTOR | Opcodes.ACC_DEPRECATED</span>
                | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
                | ((access &amp; ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / FACTOR);
<span class="fc" id="L2175">        out.putShort(access &amp; ~mask).putShort(name).putShort(desc);</span>
<span class="pc bpc" id="L2176" title="1 of 2 branches missed.">        if (classReaderOffset != 0) {</span>
<span class="nc" id="L2177">            out.putByteArray(cw.cr.b, classReaderOffset, classReaderLength);</span>
<span class="nc" id="L2178">            return;</span>
        }
<span class="fc" id="L2180">        int attributeCount = 0;</span>
<span class="pc bpc" id="L2181" title="1 of 2 branches missed.">        if (code.length &gt; 0) {</span>
<span class="fc" id="L2182">            ++attributeCount;</span>
        }
<span class="fc bfc" id="L2184" title="All 2 branches covered.">        if (exceptionCount &gt; 0) {</span>
<span class="fc" id="L2185">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L2187" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0) {</span>
<span class="nc bnc" id="L2188" title="All 4 branches missed.">            if ((cw.version &amp; 0xFFFF) &lt; Opcodes.V1_5</span>
                    || (access &amp; ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0) {
<span class="nc" id="L2190">                ++attributeCount;</span>
            }
        }
<span class="pc bpc" id="L2193" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="nc" id="L2194">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L2196" title="1 of 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="nc" id="L2197">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L2199" title="1 of 2 branches missed.">        if (methodParameters != null) {</span>
<span class="nc" id="L2200">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L2202" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L2203">            ++attributeCount;</span>
        }
<span class="fc bfc" id="L2205" title="All 2 branches covered.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="fc" id="L2206">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L2208" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="nc" id="L2209">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L2211" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; tanns != null) {</span>
<span class="nc" id="L2212">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L2214" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; itanns != null) {</span>
<span class="nc" id="L2215">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L2217" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L2218">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L2220" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L2221">            ++attributeCount;</span>
        }
<span class="pc bpc" id="L2223" title="1 of 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L2224">            attributeCount += attrs.getCount();</span>
        }
<span class="fc" id="L2226">        out.putShort(attributeCount);</span>
<span class="pc bpc" id="L2227" title="1 of 2 branches missed.">        if (code.length &gt; 0) {</span>
<span class="fc" id="L2228">            int size = 12 + code.length + 8 * handlerCount;</span>
<span class="fc bfc" id="L2229" title="All 2 branches covered.">            if (localVar != null) {</span>
<span class="fc" id="L2230">                size += 8 + localVar.length;</span>
            }
<span class="pc bpc" id="L2232" title="1 of 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L2233">                size += 8 + localVarType.length;</span>
            }
<span class="fc bfc" id="L2235" title="All 2 branches covered.">            if (lineNumber != null) {</span>
<span class="fc" id="L2236">                size += 8 + lineNumber.length;</span>
            }
<span class="fc bfc" id="L2238" title="All 2 branches covered.">            if (stackMap != null) {</span>
<span class="fc" id="L2239">                size += 8 + stackMap.length;</span>
            }
<span class="pc bpc" id="L2241" title="1 of 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ctanns != null) {</span>
<span class="nc" id="L2242">                size += 8 + ctanns.getSize();</span>
            }
<span class="pc bpc" id="L2244" title="1 of 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ictanns != null) {</span>
<span class="nc" id="L2245">                size += 8 + ictanns.getSize();</span>
            }
<span class="pc bpc" id="L2247" title="1 of 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L2248">                size += cattrs.getSize(cw, code.data, code.length, maxStack,</span>
                        maxLocals);
            }
<span class="fc" id="L2251">            out.putShort(cw.newUTF8(&quot;Code&quot;)).putInt(size);</span>
<span class="fc" id="L2252">            out.putShort(maxStack).putShort(maxLocals);</span>
<span class="fc" id="L2253">            out.putInt(code.length).putByteArray(code.data, 0, code.length);</span>
<span class="fc" id="L2254">            out.putShort(handlerCount);</span>
<span class="fc bfc" id="L2255" title="All 2 branches covered.">            if (handlerCount &gt; 0) {</span>
<span class="fc" id="L2256">                Handler h = firstHandler;</span>
<span class="fc bfc" id="L2257" title="All 2 branches covered.">                while (h != null) {</span>
<span class="fc" id="L2258">                    out.putShort(h.start.position).putShort(h.end.position)</span>
<span class="fc" id="L2259">                            .putShort(h.handler.position).putShort(h.type);</span>
<span class="fc" id="L2260">                    h = h.next;</span>
                }
            }
<span class="fc" id="L2263">            attributeCount = 0;</span>
<span class="fc bfc" id="L2264" title="All 2 branches covered.">            if (localVar != null) {</span>
<span class="fc" id="L2265">                ++attributeCount;</span>
            }
<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L2268">                ++attributeCount;</span>
            }
<span class="fc bfc" id="L2270" title="All 2 branches covered.">            if (lineNumber != null) {</span>
<span class="fc" id="L2271">                ++attributeCount;</span>
            }
<span class="fc bfc" id="L2273" title="All 2 branches covered.">            if (stackMap != null) {</span>
<span class="fc" id="L2274">                ++attributeCount;</span>
            }
<span class="pc bpc" id="L2276" title="1 of 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ctanns != null) {</span>
<span class="nc" id="L2277">                ++attributeCount;</span>
            }
<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ictanns != null) {</span>
<span class="nc" id="L2280">                ++attributeCount;</span>
            }
<span class="pc bpc" id="L2282" title="1 of 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L2283">                attributeCount += cattrs.getCount();</span>
            }
<span class="fc" id="L2285">            out.putShort(attributeCount);</span>
<span class="fc bfc" id="L2286" title="All 2 branches covered.">            if (localVar != null) {</span>
<span class="fc" id="L2287">                out.putShort(cw.newUTF8(&quot;LocalVariableTable&quot;));</span>
<span class="fc" id="L2288">                out.putInt(localVar.length + 2).putShort(localVarCount);</span>
<span class="fc" id="L2289">                out.putByteArray(localVar.data, 0, localVar.length);</span>
            }
<span class="pc bpc" id="L2291" title="1 of 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L2292">                out.putShort(cw.newUTF8(&quot;LocalVariableTypeTable&quot;));</span>
<span class="nc" id="L2293">                out.putInt(localVarType.length + 2).putShort(localVarTypeCount);</span>
<span class="nc" id="L2294">                out.putByteArray(localVarType.data, 0, localVarType.length);</span>
            }
<span class="fc bfc" id="L2296" title="All 2 branches covered.">            if (lineNumber != null) {</span>
<span class="fc" id="L2297">                out.putShort(cw.newUTF8(&quot;LineNumberTable&quot;));</span>
<span class="fc" id="L2298">                out.putInt(lineNumber.length + 2).putShort(lineNumberCount);</span>
<span class="fc" id="L2299">                out.putByteArray(lineNumber.data, 0, lineNumber.length);</span>
            }
<span class="fc bfc" id="L2301" title="All 2 branches covered.">            if (stackMap != null) {</span>
<span class="pc bpc" id="L2302" title="1 of 2 branches missed.">                boolean zip = (cw.version &amp; 0xFFFF) &gt;= Opcodes.V1_6;</span>
<span class="pc bpc" id="L2303" title="1 of 2 branches missed.">                out.putShort(cw.newUTF8(zip ? &quot;StackMapTable&quot; : &quot;StackMap&quot;));</span>
<span class="fc" id="L2304">                out.putInt(stackMap.length + 2).putShort(frameCount);</span>
<span class="fc" id="L2305">                out.putByteArray(stackMap.data, 0, stackMap.length);</span>
            }
<span class="pc bpc" id="L2307" title="1 of 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ctanns != null) {</span>
<span class="nc" id="L2308">                out.putShort(cw.newUTF8(&quot;RuntimeVisibleTypeAnnotations&quot;));</span>
<span class="nc" id="L2309">                ctanns.put(out);</span>
            }
<span class="pc bpc" id="L2311" title="1 of 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ictanns != null) {</span>
<span class="nc" id="L2312">                out.putShort(cw.newUTF8(&quot;RuntimeInvisibleTypeAnnotations&quot;));</span>
<span class="nc" id="L2313">                ictanns.put(out);</span>
            }
<span class="pc bpc" id="L2315" title="1 of 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L2316">                cattrs.put(cw, code.data, code.length, maxLocals, maxStack, out);</span>
            }
        }
<span class="fc bfc" id="L2319" title="All 2 branches covered.">        if (exceptionCount &gt; 0) {</span>
<span class="fc" id="L2320">            out.putShort(cw.newUTF8(&quot;Exceptions&quot;)).putInt(</span>
                    2 * exceptionCount + 2);
<span class="fc" id="L2322">            out.putShort(exceptionCount);</span>
<span class="fc bfc" id="L2323" title="All 2 branches covered.">            for (int i = 0; i &lt; exceptionCount; ++i) {</span>
<span class="fc" id="L2324">                out.putShort(exceptions[i]);</span>
            }
        }
<span class="pc bpc" id="L2327" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0) {</span>
<span class="nc bnc" id="L2328" title="All 4 branches missed.">            if ((cw.version &amp; 0xFFFF) &lt; Opcodes.V1_5</span>
                    || (access &amp; ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0) {
<span class="nc" id="L2330">                out.putShort(cw.newUTF8(&quot;Synthetic&quot;)).putInt(0);</span>
            }
        }
<span class="pc bpc" id="L2333" title="1 of 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="nc" id="L2334">            out.putShort(cw.newUTF8(&quot;Deprecated&quot;)).putInt(0);</span>
        }
<span class="pc bpc" id="L2336" title="1 of 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="nc" id="L2337">            out.putShort(cw.newUTF8(&quot;Signature&quot;)).putInt(2)</span>
<span class="nc" id="L2338">                    .putShort(cw.newUTF8(signature));</span>
        }
<span class="pc bpc" id="L2340" title="1 of 2 branches missed.">        if (methodParameters != null) {</span>
<span class="nc" id="L2341">            out.putShort(cw.newUTF8(&quot;MethodParameters&quot;));</span>
<span class="nc" id="L2342">            out.putInt(methodParameters.length + 1).putByte(</span>
                    methodParametersCount);
<span class="nc" id="L2344">            out.putByteArray(methodParameters.data, 0, methodParameters.length);</span>
        }
<span class="pc bpc" id="L2346" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L2347">            out.putShort(cw.newUTF8(&quot;AnnotationDefault&quot;));</span>
<span class="nc" id="L2348">            out.putInt(annd.length);</span>
<span class="nc" id="L2349">            out.putByteArray(annd.data, 0, annd.length);</span>
        }
<span class="fc bfc" id="L2351" title="All 2 branches covered.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="fc" id="L2352">            out.putShort(cw.newUTF8(&quot;RuntimeVisibleAnnotations&quot;));</span>
<span class="fc" id="L2353">            anns.put(out);</span>
        }
<span class="pc bpc" id="L2355" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="nc" id="L2356">            out.putShort(cw.newUTF8(&quot;RuntimeInvisibleAnnotations&quot;));</span>
<span class="nc" id="L2357">            ianns.put(out);</span>
        }
<span class="pc bpc" id="L2359" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; tanns != null) {</span>
<span class="nc" id="L2360">            out.putShort(cw.newUTF8(&quot;RuntimeVisibleTypeAnnotations&quot;));</span>
<span class="nc" id="L2361">            tanns.put(out);</span>
        }
<span class="pc bpc" id="L2363" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; itanns != null) {</span>
<span class="nc" id="L2364">            out.putShort(cw.newUTF8(&quot;RuntimeInvisibleTypeAnnotations&quot;));</span>
<span class="nc" id="L2365">            itanns.put(out);</span>
        }
<span class="pc bpc" id="L2367" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L2368">            out.putShort(cw.newUTF8(&quot;RuntimeVisibleParameterAnnotations&quot;));</span>
<span class="nc" id="L2369">            AnnotationWriter.put(panns, synthetics, out);</span>
        }
<span class="pc bpc" id="L2371" title="1 of 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L2372">            out.putShort(cw.newUTF8(&quot;RuntimeInvisibleParameterAnnotations&quot;));</span>
<span class="nc" id="L2373">            AnnotationWriter.put(ipanns, synthetics, out);</span>
        }
<span class="pc bpc" id="L2375" title="1 of 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L2376">            attrs.put(cw, null, 0, -1, -1, out);</span>
        }
<span class="fc" id="L2378">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)
    // ------------------------------------------------------------------------

    /**
     * Resizes and replaces the temporary instructions inserted by
     * {@link Label#resolve} for wide forward jumps, while keeping jump offsets
     * and instruction addresses consistent. This may require to resize other
     * existing instructions, or even to introduce new instructions: for
     * example, increasing the size of an instruction by 2 at the middle of a
     * method can increases the offset of an IFEQ instruction from 32766 to
     * 32768, in which case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W
     * 32765. This, in turn, may require to increase the size of another jump
     * instruction, and so on... All these operations are handled automatically
     * by this method.
     * &lt;p&gt;
     * &lt;i&gt;This method must be called after all the method that is being built
     * has been visited&lt;/i&gt;. In particular, the {@link Label Label} objects used
     * to construct the method are no longer valid after this method has been
     * called.
     */
    private void resizeInstructions() {
<span class="nc" id="L2402">        byte[] b = code.data; // bytecode of the method</span>
        int u, v, label; // indexes in b
        int i, j; // loop indexes
        /*
         * 1st step: As explained above, resizing an instruction may require to
         * resize another one, which may require to resize yet another one, and
         * so on. The first step of the algorithm consists in finding all the
         * instructions that need to be resized, without modifying the code.
         * This is done by the following &quot;fix point&quot; algorithm:
         *
         * Parse the code to find the jump instructions whose offset will need
         * more than 2 bytes to be stored (the future offset is computed from
         * the current offset and from the number of bytes that will be inserted
         * or removed between the source and target instructions). For each such
         * instruction, adds an entry in (a copy of) the indexes and sizes
         * arrays (if this has not already been done in a previous iteration!).
         *
         * If at least one entry has been added during the previous step, go
         * back to the beginning, otherwise stop.
         *
         * In fact the real algorithm is complicated by the fact that the size
         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their
         * position in the bytecode (because of padding). In order to ensure the
         * convergence of the algorithm, the number of bytes to be added or
         * removed from these instructions is over estimated during the previous
         * loop, and computed exactly only after the loop is finished (this
         * requires another pass to parse the bytecode of the method).
         */
<span class="nc" id="L2430">        int[] allIndexes = new int[0]; // copy of indexes</span>
<span class="nc" id="L2431">        int[] allSizes = new int[0]; // copy of sizes</span>
        boolean[] resize; // instructions to be resized
        int newOffset; // future offset of a jump instruction

<span class="nc" id="L2435">        resize = new boolean[code.length];</span>

        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done
<span class="nc" id="L2438">        int state = 3;</span>
        do {
<span class="nc bnc" id="L2440" title="All 2 branches missed.">            if (state == 3) {</span>
<span class="nc" id="L2441">                state = 2;</span>
            }
<span class="nc" id="L2443">            u = 0;</span>
<span class="nc bnc" id="L2444" title="All 2 branches missed.">            while (u &lt; b.length) {</span>
<span class="nc" id="L2445">                int opcode = b[u] &amp; 0xFF; // opcode of current instruction</span>
<span class="nc" id="L2446">                int insert = 0; // bytes to be added after this instruction</span>

<span class="nc bnc" id="L2448" title="All 10 branches missed.">                switch (ClassWriter.TYPE[opcode]) {</span>
                case ClassWriter.NOARG_INSN:
                case ClassWriter.IMPLVAR_INSN:
<span class="nc" id="L2451">                    u += 1;</span>
<span class="nc" id="L2452">                    break;</span>
                case ClassWriter.LABEL_INSN:
<span class="nc bnc" id="L2454" title="All 2 branches missed.">                    if (opcode &gt; 201) {</span>
                        // converts temporary opcodes 202 to 217, 218 and
                        // 219 to IFEQ ... JSR (inclusive), IFNULL and
                        // IFNONNULL
<span class="nc bnc" id="L2458" title="All 2 branches missed.">                        opcode = opcode &lt; 218 ? opcode - 49 : opcode - 20;</span>
<span class="nc" id="L2459">                        label = u + readUnsignedShort(b, u + 1);</span>
                    } else {
<span class="nc" id="L2461">                        label = u + readShort(b, u + 1);</span>
                    }
<span class="nc" id="L2463">                    newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc bnc" id="L2464" title="All 4 branches missed.">                    if (newOffset &lt; Short.MIN_VALUE</span>
                            || newOffset &gt; Short.MAX_VALUE) {
<span class="nc bnc" id="L2466" title="All 2 branches missed.">                        if (!resize[u]) {</span>
<span class="nc bnc" id="L2467" title="All 4 branches missed.">                            if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {</span>
                                // two additional bytes will be required to
                                // replace this GOTO or JSR instruction with
                                // a GOTO_W or a JSR_W
<span class="nc" id="L2471">                                insert = 2;</span>
                            } else {
                                // five additional bytes will be required to
                                // replace this IFxxx &lt;l&gt; instruction with
                                // IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx
                                // is the &quot;opposite&quot; opcode of IFxxx (i.e.,
                                // IFNE for IFEQ) and where &lt;l'&gt; designates
                                // the instruction just after the GOTO_W.
<span class="nc" id="L2479">                                insert = 5;</span>
                            }
<span class="nc" id="L2481">                            resize[u] = true;</span>
                        }
                    }
<span class="nc" id="L2484">                    u += 3;</span>
<span class="nc" id="L2485">                    break;</span>
                case ClassWriter.LABELW_INSN:
<span class="nc" id="L2487">                    u += 5;</span>
<span class="nc" id="L2488">                    break;</span>
                case ClassWriter.TABL_INSN:
<span class="nc bnc" id="L2490" title="All 2 branches missed.">                    if (state == 1) {</span>
                        // true number of bytes to be added (or removed)
                        // from this instruction = (future number of padding
                        // bytes - current number of padding byte) -
                        // previously over estimated variation =
                        // = ((3 - newOffset%4) - (3 - u%4)) - u%4
                        // = (-newOffset%4 + u%4) - u%4
                        // = -(newOffset &amp; 3)
<span class="nc" id="L2498">                        newOffset = getNewOffset(allIndexes, allSizes, 0, u);</span>
<span class="nc" id="L2499">                        insert = -(newOffset &amp; 3);</span>
<span class="nc bnc" id="L2500" title="All 2 branches missed.">                    } else if (!resize[u]) {</span>
                        // over estimation of the number of bytes to be
                        // added to this instruction = 3 - current number
                        // of padding bytes = 3 - (3 - u%4) = u%4 = u &amp; 3
<span class="nc" id="L2504">                        insert = u &amp; 3;</span>
<span class="nc" id="L2505">                        resize[u] = true;</span>
                    }
                    // skips instruction
<span class="nc" id="L2508">                    u = u + 4 - (u &amp; 3);</span>
<span class="nc" id="L2509">                    u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;</span>
<span class="nc" id="L2510">                    break;</span>
                case ClassWriter.LOOK_INSN:
<span class="nc bnc" id="L2512" title="All 2 branches missed.">                    if (state == 1) {</span>
                        // like TABL_INSN
<span class="nc" id="L2514">                        newOffset = getNewOffset(allIndexes, allSizes, 0, u);</span>
<span class="nc" id="L2515">                        insert = -(newOffset &amp; 3);</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">                    } else if (!resize[u]) {</span>
                        // like TABL_INSN
<span class="nc" id="L2518">                        insert = u &amp; 3;</span>
<span class="nc" id="L2519">                        resize[u] = true;</span>
                    }
                    // skips instruction
<span class="nc" id="L2522">                    u = u + 4 - (u &amp; 3);</span>
<span class="nc" id="L2523">                    u += 8 * readInt(b, u + 4) + 8;</span>
<span class="nc" id="L2524">                    break;</span>
                case ClassWriter.WIDE_INSN:
<span class="nc" id="L2526">                    opcode = b[u + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L2527" title="All 2 branches missed.">                    if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L2528">                        u += 6;</span>
                    } else {
<span class="nc" id="L2530">                        u += 4;</span>
                    }
<span class="nc" id="L2532">                    break;</span>
                case ClassWriter.VAR_INSN:
                case ClassWriter.SBYTE_INSN:
                case ClassWriter.LDC_INSN:
<span class="nc" id="L2536">                    u += 2;</span>
<span class="nc" id="L2537">                    break;</span>
                case ClassWriter.SHORT_INSN:
                case ClassWriter.LDCW_INSN:
                case ClassWriter.FIELDORMETH_INSN:
                case ClassWriter.TYPE_INSN:
                case ClassWriter.IINC_INSN:
<span class="nc" id="L2543">                    u += 3;</span>
<span class="nc" id="L2544">                    break;</span>
                case ClassWriter.ITFMETH_INSN:
                case ClassWriter.INDYMETH_INSN:
<span class="nc" id="L2547">                    u += 5;</span>
<span class="nc" id="L2548">                    break;</span>
                // case ClassWriter.MANA_INSN:
                default:
<span class="nc" id="L2551">                    u += 4;</span>
                    break;
                }
<span class="nc bnc" id="L2554" title="All 2 branches missed.">                if (insert != 0) {</span>
                    // adds a new (u, insert) entry in the allIndexes and
                    // allSizes arrays
<span class="nc" id="L2557">                    int[] newIndexes = new int[allIndexes.length + 1];</span>
<span class="nc" id="L2558">                    int[] newSizes = new int[allSizes.length + 1];</span>
<span class="nc" id="L2559">                    System.arraycopy(allIndexes, 0, newIndexes, 0,</span>
                            allIndexes.length);
<span class="nc" id="L2561">                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);</span>
<span class="nc" id="L2562">                    newIndexes[allIndexes.length] = u;</span>
<span class="nc" id="L2563">                    newSizes[allSizes.length] = insert;</span>
<span class="nc" id="L2564">                    allIndexes = newIndexes;</span>
<span class="nc" id="L2565">                    allSizes = newSizes;</span>
<span class="nc bnc" id="L2566" title="All 2 branches missed.">                    if (insert &gt; 0) {</span>
<span class="nc" id="L2567">                        state = 3;</span>
                    }
                }
<span class="nc" id="L2570">            }</span>
<span class="nc bnc" id="L2571" title="All 2 branches missed.">            if (state &lt; 3) {</span>
<span class="nc" id="L2572">                --state;</span>
            }
<span class="nc bnc" id="L2574" title="All 2 branches missed.">        } while (state != 0);</span>

        // 2nd step:
        // copies the bytecode of the method into a new bytevector, updates the
        // offsets, and inserts (or removes) bytes as requested.

<span class="nc" id="L2580">        ByteVector newCode = new ByteVector(code.length);</span>

<span class="nc" id="L2582">        u = 0;</span>
<span class="nc bnc" id="L2583" title="All 2 branches missed.">        while (u &lt; code.length) {</span>
<span class="nc" id="L2584">            int opcode = b[u] &amp; 0xFF;</span>
<span class="nc bnc" id="L2585" title="All 10 branches missed.">            switch (ClassWriter.TYPE[opcode]) {</span>
            case ClassWriter.NOARG_INSN:
            case ClassWriter.IMPLVAR_INSN:
<span class="nc" id="L2588">                newCode.putByte(opcode);</span>
<span class="nc" id="L2589">                u += 1;</span>
<span class="nc" id="L2590">                break;</span>
            case ClassWriter.LABEL_INSN:
<span class="nc bnc" id="L2592" title="All 2 branches missed.">                if (opcode &gt; 201) {</span>
                    // changes temporary opcodes 202 to 217 (inclusive), 218
                    // and 219 to IFEQ ... JSR (inclusive), IFNULL and
                    // IFNONNULL
<span class="nc bnc" id="L2596" title="All 2 branches missed.">                    opcode = opcode &lt; 218 ? opcode - 49 : opcode - 20;</span>
<span class="nc" id="L2597">                    label = u + readUnsignedShort(b, u + 1);</span>
                } else {
<span class="nc" id="L2599">                    label = u + readShort(b, u + 1);</span>
                }
<span class="nc" id="L2601">                newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc bnc" id="L2602" title="All 2 branches missed.">                if (resize[u]) {</span>
                    // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx
                    // &lt;l&gt; with IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx is
                    // the &quot;opposite&quot; opcode of IFxxx (i.e., IFNE for IFEQ)
                    // and where &lt;l'&gt; designates the instruction just after
                    // the GOTO_W.
<span class="nc bnc" id="L2608" title="All 2 branches missed.">                    if (opcode == Opcodes.GOTO) {</span>
<span class="nc" id="L2609">                        newCode.putByte(200); // GOTO_W</span>
<span class="nc bnc" id="L2610" title="All 2 branches missed.">                    } else if (opcode == Opcodes.JSR) {</span>
<span class="nc" id="L2611">                        newCode.putByte(201); // JSR_W</span>
                    } else {
<span class="nc bnc" id="L2613" title="All 2 branches missed.">                        newCode.putByte(opcode &lt;= 166 ? ((opcode + 1) ^ 1) - 1</span>
                                : opcode ^ 1);
<span class="nc" id="L2615">                        newCode.putShort(8); // jump offset</span>
<span class="nc" id="L2616">                        newCode.putByte(200); // GOTO_W</span>
                        // newOffset now computed from start of GOTO_W
<span class="nc" id="L2618">                        newOffset -= 3;</span>
                    }
<span class="nc" id="L2620">                    newCode.putInt(newOffset);</span>
                } else {
<span class="nc" id="L2622">                    newCode.putByte(opcode);</span>
<span class="nc" id="L2623">                    newCode.putShort(newOffset);</span>
                }
<span class="nc" id="L2625">                u += 3;</span>
<span class="nc" id="L2626">                break;</span>
            case ClassWriter.LABELW_INSN:
<span class="nc" id="L2628">                label = u + readInt(b, u + 1);</span>
<span class="nc" id="L2629">                newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc" id="L2630">                newCode.putByte(opcode);</span>
<span class="nc" id="L2631">                newCode.putInt(newOffset);</span>
<span class="nc" id="L2632">                u += 5;</span>
<span class="nc" id="L2633">                break;</span>
            case ClassWriter.TABL_INSN:
                // skips 0 to 3 padding bytes
<span class="nc" id="L2636">                v = u;</span>
<span class="nc" id="L2637">                u = u + 4 - (v &amp; 3);</span>
                // reads and copies instruction
<span class="nc" id="L2639">                newCode.putByte(Opcodes.TABLESWITCH);</span>
<span class="nc" id="L2640">                newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);</span>
<span class="nc" id="L2641">                label = v + readInt(b, u);</span>
<span class="nc" id="L2642">                u += 4;</span>
<span class="nc" id="L2643">                newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2644">                newCode.putInt(newOffset);</span>
<span class="nc" id="L2645">                j = readInt(b, u);</span>
<span class="nc" id="L2646">                u += 4;</span>
<span class="nc" id="L2647">                newCode.putInt(j);</span>
<span class="nc" id="L2648">                j = readInt(b, u) - j + 1;</span>
<span class="nc" id="L2649">                u += 4;</span>
<span class="nc" id="L2650">                newCode.putInt(readInt(b, u - 4));</span>
<span class="nc bnc" id="L2651" title="All 2 branches missed.">                for (; j &gt; 0; --j) {</span>
<span class="nc" id="L2652">                    label = v + readInt(b, u);</span>
<span class="nc" id="L2653">                    u += 4;</span>
<span class="nc" id="L2654">                    newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2655">                    newCode.putInt(newOffset);</span>
                }
                break;
            case ClassWriter.LOOK_INSN:
                // skips 0 to 3 padding bytes
<span class="nc" id="L2660">                v = u;</span>
<span class="nc" id="L2661">                u = u + 4 - (v &amp; 3);</span>
                // reads and copies instruction
<span class="nc" id="L2663">                newCode.putByte(Opcodes.LOOKUPSWITCH);</span>
<span class="nc" id="L2664">                newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);</span>
<span class="nc" id="L2665">                label = v + readInt(b, u);</span>
<span class="nc" id="L2666">                u += 4;</span>
<span class="nc" id="L2667">                newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2668">                newCode.putInt(newOffset);</span>
<span class="nc" id="L2669">                j = readInt(b, u);</span>
<span class="nc" id="L2670">                u += 4;</span>
<span class="nc" id="L2671">                newCode.putInt(j);</span>
<span class="nc bnc" id="L2672" title="All 2 branches missed.">                for (; j &gt; 0; --j) {</span>
<span class="nc" id="L2673">                    newCode.putInt(readInt(b, u));</span>
<span class="nc" id="L2674">                    u += 4;</span>
<span class="nc" id="L2675">                    label = v + readInt(b, u);</span>
<span class="nc" id="L2676">                    u += 4;</span>
<span class="nc" id="L2677">                    newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2678">                    newCode.putInt(newOffset);</span>
                }
                break;
            case ClassWriter.WIDE_INSN:
<span class="nc" id="L2682">                opcode = b[u + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L2683" title="All 2 branches missed.">                if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L2684">                    newCode.putByteArray(b, u, 6);</span>
<span class="nc" id="L2685">                    u += 6;</span>
                } else {
<span class="nc" id="L2687">                    newCode.putByteArray(b, u, 4);</span>
<span class="nc" id="L2688">                    u += 4;</span>
                }
<span class="nc" id="L2690">                break;</span>
            case ClassWriter.VAR_INSN:
            case ClassWriter.SBYTE_INSN:
            case ClassWriter.LDC_INSN:
<span class="nc" id="L2694">                newCode.putByteArray(b, u, 2);</span>
<span class="nc" id="L2695">                u += 2;</span>
<span class="nc" id="L2696">                break;</span>
            case ClassWriter.SHORT_INSN:
            case ClassWriter.LDCW_INSN:
            case ClassWriter.FIELDORMETH_INSN:
            case ClassWriter.TYPE_INSN:
            case ClassWriter.IINC_INSN:
<span class="nc" id="L2702">                newCode.putByteArray(b, u, 3);</span>
<span class="nc" id="L2703">                u += 3;</span>
<span class="nc" id="L2704">                break;</span>
            case ClassWriter.ITFMETH_INSN:
            case ClassWriter.INDYMETH_INSN:
<span class="nc" id="L2707">                newCode.putByteArray(b, u, 5);</span>
<span class="nc" id="L2708">                u += 5;</span>
<span class="nc" id="L2709">                break;</span>
            // case MANA_INSN:
            default:
<span class="nc" id="L2712">                newCode.putByteArray(b, u, 4);</span>
<span class="nc" id="L2713">                u += 4;</span>
                break;
            }
<span class="nc" id="L2716">        }</span>

        // recomputes the stack map frames
<span class="nc bnc" id="L2719" title="All 2 branches missed.">        if (frameCount &gt; 0) {</span>
<span class="nc bnc" id="L2720" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L2721">                frameCount = 0;</span>
<span class="nc" id="L2722">                stackMap = null;</span>
<span class="nc" id="L2723">                previousFrame = null;</span>
<span class="nc" id="L2724">                frame = null;</span>
<span class="nc" id="L2725">                Frame f = new Frame();</span>
<span class="nc" id="L2726">                f.owner = labels;</span>
<span class="nc" id="L2727">                Type[] args = Type.getArgumentTypes(descriptor);</span>
<span class="nc" id="L2728">                f.initInputFrame(cw, access, args, maxLocals);</span>
<span class="nc" id="L2729">                visitFrame(f);</span>
<span class="nc" id="L2730">                Label l = labels;</span>
<span class="nc bnc" id="L2731" title="All 2 branches missed.">                while (l != null) {</span>
                    /*
                     * here we need the original label position. getNewOffset
                     * must therefore never have been called for this label.
                     */
<span class="nc" id="L2736">                    u = l.position - 3;</span>
<span class="nc bnc" id="L2737" title="All 6 branches missed.">                    if ((l.status &amp; Label.STORE) != 0 || (u &gt;= 0 &amp;&amp; resize[u])) {</span>
<span class="nc" id="L2738">                        getNewOffset(allIndexes, allSizes, l);</span>
                        // TODO update offsets in UNINITIALIZED values
<span class="nc" id="L2740">                        visitFrame(l.frame);</span>
                    }
<span class="nc" id="L2742">                    l = l.successor;</span>
                }
<span class="nc" id="L2744">            } else {</span>
                /*
                 * Resizing an existing stack map frame table is really hard.
                 * Not only the table must be parsed to update the offets, but
                 * new frames may be needed for jump instructions that were
                 * inserted by this method. And updating the offsets or
                 * inserting frames can change the format of the following
                 * frames, in case of packed frames. In practice the whole table
                 * must be recomputed. For this the frames are marked as
                 * potentially invalid. This will cause the whole class to be
                 * reread and rewritten with the COMPUTE_FRAMES option (see the
                 * ClassWriter.toByteArray method). This is not very efficient
                 * but is much easier and requires much less code than any other
                 * method I can think of.
                 */
<span class="nc" id="L2759">                cw.invalidFrames = true;</span>
            }
        }
        // updates the exception handler block labels
<span class="nc" id="L2763">        Handler h = firstHandler;</span>
<span class="nc bnc" id="L2764" title="All 2 branches missed.">        while (h != null) {</span>
<span class="nc" id="L2765">            getNewOffset(allIndexes, allSizes, h.start);</span>
<span class="nc" id="L2766">            getNewOffset(allIndexes, allSizes, h.end);</span>
<span class="nc" id="L2767">            getNewOffset(allIndexes, allSizes, h.handler);</span>
<span class="nc" id="L2768">            h = h.next;</span>
        }
        // updates the instructions addresses in the
        // local var and line number tables
<span class="nc bnc" id="L2772" title="All 2 branches missed.">        for (i = 0; i &lt; 2; ++i) {</span>
<span class="nc bnc" id="L2773" title="All 2 branches missed.">            ByteVector bv = i == 0 ? localVar : localVarType;</span>
<span class="nc bnc" id="L2774" title="All 2 branches missed.">            if (bv != null) {</span>
<span class="nc" id="L2775">                b = bv.data;</span>
<span class="nc" id="L2776">                u = 0;</span>
<span class="nc bnc" id="L2777" title="All 2 branches missed.">                while (u &lt; bv.length) {</span>
<span class="nc" id="L2778">                    label = readUnsignedShort(b, u);</span>
<span class="nc" id="L2779">                    newOffset = getNewOffset(allIndexes, allSizes, 0, label);</span>
<span class="nc" id="L2780">                    writeShort(b, u, newOffset);</span>
<span class="nc" id="L2781">                    label += readUnsignedShort(b, u + 2);</span>
<span class="nc" id="L2782">                    newOffset = getNewOffset(allIndexes, allSizes, 0, label)</span>
                            - newOffset;
<span class="nc" id="L2784">                    writeShort(b, u + 2, newOffset);</span>
<span class="nc" id="L2785">                    u += 10;</span>
                }
            }
        }
<span class="nc bnc" id="L2789" title="All 2 branches missed.">        if (lineNumber != null) {</span>
<span class="nc" id="L2790">            b = lineNumber.data;</span>
<span class="nc" id="L2791">            u = 0;</span>
<span class="nc bnc" id="L2792" title="All 2 branches missed.">            while (u &lt; lineNumber.length) {</span>
<span class="nc" id="L2793">                writeShort(</span>
                        b,
                        u,
<span class="nc" id="L2796">                        getNewOffset(allIndexes, allSizes, 0,</span>
<span class="nc" id="L2797">                                readUnsignedShort(b, u)));</span>
<span class="nc" id="L2798">                u += 4;</span>
            }
        }
        // updates the labels of the other attributes
<span class="nc" id="L2802">        Attribute attr = cattrs;</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">        while (attr != null) {</span>
<span class="nc" id="L2804">            Label[] labels = attr.getLabels();</span>
<span class="nc bnc" id="L2805" title="All 2 branches missed.">            if (labels != null) {</span>
<span class="nc bnc" id="L2806" title="All 2 branches missed.">                for (i = labels.length - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L2807">                    getNewOffset(allIndexes, allSizes, labels[i]);</span>
                }
            }
<span class="nc" id="L2810">            attr = attr.next;</span>
<span class="nc" id="L2811">        }</span>

        // replaces old bytecodes with new ones
<span class="nc" id="L2814">        code = newCode;</span>
<span class="nc" id="L2815">    }</span>

    /**
     * Reads an unsigned short value in the given byte array.
     *
     * @param b
     *            a byte array.
     * @param index
     *            the start index of the value to be read.
     * @return the read value.
     */
    static int readUnsignedShort(final byte[] b, final int index) {
<span class="nc" id="L2827">        return ((b[index] &amp; 0xFF) &lt;&lt; 8) | (b[index + 1] &amp; 0xFF);</span>
    }

    /**
     * Reads a signed short value in the given byte array.
     *
     * @param b
     *            a byte array.
     * @param index
     *            the start index of the value to be read.
     * @return the read value.
     */
    static short readShort(final byte[] b, final int index) {
<span class="nc" id="L2840">        return (short) (((b[index] &amp; 0xFF) &lt;&lt; 8) | (b[index + 1] &amp; 0xFF));</span>
    }

    /**
     * Reads a signed int value in the given byte array.
     *
     * @param b
     *            a byte array.
     * @param index
     *            the start index of the value to be read.
     * @return the read value.
     */
    static int readInt(final byte[] b, final int index) {
<span class="nc" id="L2853">        return ((b[index] &amp; 0xFF) &lt;&lt; 24) | ((b[index + 1] &amp; 0xFF) &lt;&lt; 16)</span>
                | ((b[index + 2] &amp; 0xFF) &lt;&lt; 8) | (b[index + 3] &amp; 0xFF);
    }

    /**
     * Writes a short value in the given byte array.
     *
     * @param b
     *            a byte array.
     * @param index
     *            where the first byte of the short value must be written.
     * @param s
     *            the value to be written in the given byte array.
     */
    static void writeShort(final byte[] b, final int index, final int s) {
<span class="nc" id="L2868">        b[index] = (byte) (s &gt;&gt;&gt; 8);</span>
<span class="nc" id="L2869">        b[index + 1] = (byte) s;</span>
<span class="nc" id="L2870">    }</span>

    /**
     * Computes the future value of a bytecode offset.
     * &lt;p&gt;
     * Note: it is possible to have several entries for the same instruction in
     * the &lt;tt&gt;indexes&lt;/tt&gt; and &lt;tt&gt;sizes&lt;/tt&gt;: two entries (index=a,size=b) and
     * (index=a,size=b') are equivalent to a single entry (index=a,size=b+b').
     *
     * @param indexes
     *            current positions of the instructions to be resized. Each
     *            instruction must be designated by the index of its &lt;i&gt;last&lt;/i&gt;
     *            byte, plus one (or, in other words, by the index of the
     *            &lt;i&gt;first&lt;/i&gt; byte of the &lt;i&gt;next&lt;/i&gt; instruction).
     * @param sizes
     *            the number of bytes to be &lt;i&gt;added&lt;/i&gt; to the above
     *            instructions. More precisely, for each i &lt; &lt;tt&gt;len&lt;/tt&gt;,
     *            &lt;tt&gt;sizes&lt;/tt&gt;[i] bytes will be added at the end of the
     *            instruction designated by &lt;tt&gt;indexes&lt;/tt&gt;[i] or, if
     *            &lt;tt&gt;sizes&lt;/tt&gt;[i] is negative, the &lt;i&gt;last&lt;/i&gt; |
     *            &lt;tt&gt;sizes[i]&lt;/tt&gt;| bytes of the instruction will be removed
     *            (the instruction size &lt;i&gt;must not&lt;/i&gt; become negative or
     *            null).
     * @param begin
     *            index of the first byte of the source instruction.
     * @param end
     *            index of the first byte of the target instruction.
     * @return the future value of the given bytecode offset.
     */
    static int getNewOffset(final int[] indexes, final int[] sizes,
            final int begin, final int end) {
<span class="nc" id="L2901">        int offset = end - begin;</span>
<span class="nc bnc" id="L2902" title="All 2 branches missed.">        for (int i = 0; i &lt; indexes.length; ++i) {</span>
<span class="nc bnc" id="L2903" title="All 4 branches missed.">            if (begin &lt; indexes[i] &amp;&amp; indexes[i] &lt;= end) {</span>
                // forward jump
<span class="nc" id="L2905">                offset += sizes[i];</span>
<span class="nc bnc" id="L2906" title="All 4 branches missed.">            } else if (end &lt; indexes[i] &amp;&amp; indexes[i] &lt;= begin) {</span>
                // backward jump
<span class="nc" id="L2908">                offset -= sizes[i];</span>
            }
        }
<span class="nc" id="L2911">        return offset;</span>
    }

    /**
     * Updates the offset of the given label.
     *
     * @param indexes
     *            current positions of the instructions to be resized. Each
     *            instruction must be designated by the index of its &lt;i&gt;last&lt;/i&gt;
     *            byte, plus one (or, in other words, by the index of the
     *            &lt;i&gt;first&lt;/i&gt; byte of the &lt;i&gt;next&lt;/i&gt; instruction).
     * @param sizes
     *            the number of bytes to be &lt;i&gt;added&lt;/i&gt; to the above
     *            instructions. More precisely, for each i &lt; &lt;tt&gt;len&lt;/tt&gt;,
     *            &lt;tt&gt;sizes&lt;/tt&gt;[i] bytes will be added at the end of the
     *            instruction designated by &lt;tt&gt;indexes&lt;/tt&gt;[i] or, if
     *            &lt;tt&gt;sizes&lt;/tt&gt;[i] is negative, the &lt;i&gt;last&lt;/i&gt; |
     *            &lt;tt&gt;sizes[i]&lt;/tt&gt;| bytes of the instruction will be removed
     *            (the instruction size &lt;i&gt;must not&lt;/i&gt; become negative or
     *            null).
     * @param label
     *            the label whose offset must be updated.
     */
    static void getNewOffset(final int[] indexes, final int[] sizes,
            final Label label) {
<span class="nc bnc" id="L2936" title="All 2 branches missed.">        if ((label.status &amp; Label.RESIZED) == 0) {</span>
<span class="nc" id="L2937">            label.position = getNewOffset(indexes, sizes, 0, label.position);</span>
<span class="nc" id="L2938">            label.status |= Label.RESIZED;</span>
        }
<span class="nc" id="L2940">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>