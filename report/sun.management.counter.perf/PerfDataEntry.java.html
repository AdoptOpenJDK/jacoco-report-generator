<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PerfDataEntry.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.management.counter.perf</a> &gt; <span class="el_source">PerfDataEntry.java</span></div><h1>PerfDataEntry.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.management.counter.perf;

import sun.management.counter.*;
import java.nio.*;
import java.io.UnsupportedEncodingException;

<span class="nc bnc" id="L32" title="All 2 branches missed.">class PerfDataEntry {</span>
<span class="nc" id="L33">    private class EntryFieldOffset {</span>
        private final static int SIZEOF_BYTE = 1;
        private final static int SIZEOF_INT  = 4;
        private final static int SIZEOF_LONG = 8;

        private final static int ENTRY_LENGTH_SIZE    = SIZEOF_INT;
        private final static int NAME_OFFSET_SIZE     = SIZEOF_INT;
        private final static int VECTOR_LENGTH_SIZE   = SIZEOF_INT;
        private final static int DATA_TYPE_SIZE       = SIZEOF_BYTE;
        private final static int FLAGS_SIZE           = SIZEOF_BYTE;
        private final static int DATA_UNIT_SIZE       = SIZEOF_BYTE;
        private final static int DATA_VAR_SIZE        = SIZEOF_BYTE;
        private final static int DATA_OFFSET_SIZE     = SIZEOF_INT;

        final static int ENTRY_LENGTH  = 0;
        final static int NAME_OFFSET   = ENTRY_LENGTH + ENTRY_LENGTH_SIZE;
        final static int VECTOR_LENGTH = NAME_OFFSET + NAME_OFFSET_SIZE;;
        final static int DATA_TYPE     = VECTOR_LENGTH + VECTOR_LENGTH_SIZE;
        final static int FLAGS         = DATA_TYPE + DATA_TYPE_SIZE;
        final static int DATA_UNIT     = FLAGS + FLAGS_SIZE;
        final static int DATA_VAR      = DATA_UNIT + DATA_UNIT_SIZE;
        final static int DATA_OFFSET   = DATA_VAR + DATA_VAR_SIZE;
    }

    private String       name;
    private int          entryStart;
    private int          entryLength;
    private int          vectorLength;
    private PerfDataType dataType;
    private int          flags;
    private Units        unit;
    private Variability  variability;
    private int          dataOffset;
    private int          dataSize;
    private ByteBuffer   data;

<span class="nc" id="L69">    PerfDataEntry(ByteBuffer b) {</span>
<span class="nc" id="L70">        entryStart = b.position();</span>
<span class="nc" id="L71">        entryLength = b.getInt();</span>

        // check for valid entry length
<span class="nc bnc" id="L74" title="All 4 branches missed.">        if (entryLength &lt;= 0 || entryLength &gt; b.limit()) {</span>
<span class="nc" id="L75">            throw new InstrumentationException(&quot;Invalid entry length: &quot; +</span>
                                               &quot; entryLength = &quot; + entryLength);
        }
        // check if last entry occurs before the eof.
<span class="nc bnc" id="L79" title="All 2 branches missed.">        if ((entryStart + entryLength) &gt; b.limit()) {</span>
<span class="nc" id="L80">            throw new InstrumentationException(&quot;Entry extends beyond end of buffer: &quot; +</span>
                                               &quot; entryStart = &quot; + entryStart +
                                               &quot; entryLength = &quot; + entryLength +
<span class="nc" id="L83">                                               &quot; buffer limit = &quot; + b.limit());</span>
        }

<span class="nc" id="L86">        b.position(entryStart + EntryFieldOffset.NAME_OFFSET);</span>
<span class="nc" id="L87">        int nameOffset = b.getInt();</span>

<span class="nc bnc" id="L89" title="All 2 branches missed.">        if ((entryStart + nameOffset) &gt; b.limit()) {</span>
<span class="nc" id="L90">            throw new InstrumentationException(&quot;Invalid name offset: &quot; +</span>
                                               &quot; entryStart = &quot; + entryStart +
                                               &quot; nameOffset = &quot; + nameOffset +
<span class="nc" id="L93">                                               &quot; buffer limit = &quot; + b.limit());</span>
        }


<span class="nc" id="L97">        b.position(entryStart + EntryFieldOffset.VECTOR_LENGTH);</span>
<span class="nc" id="L98">        vectorLength = b.getInt();</span>

<span class="nc" id="L100">        b.position(entryStart + EntryFieldOffset.DATA_TYPE);</span>
<span class="nc" id="L101">        dataType = PerfDataType.toPerfDataType(b.get());</span>

<span class="nc" id="L103">        b.position(entryStart + EntryFieldOffset.FLAGS);</span>
<span class="nc" id="L104">        flags = b.get();</span>

<span class="nc" id="L106">        b.position(entryStart + EntryFieldOffset.DATA_UNIT);</span>
<span class="nc" id="L107">        unit = Units.toUnits(b.get());</span>

<span class="nc" id="L109">        b.position(entryStart + EntryFieldOffset.DATA_VAR);</span>
<span class="nc" id="L110">        variability = Variability.toVariability(b.get());</span>

<span class="nc" id="L112">        b.position(entryStart + EntryFieldOffset.DATA_OFFSET);</span>
<span class="nc" id="L113">        dataOffset = b.getInt();</span>

        // read in the perfData item name, casting bytes to chars. skip the
        // null terminator
<span class="nc" id="L117">        b.position(entryStart + nameOffset);</span>
        // calculate the length of the name
<span class="nc" id="L119">        int nameLength = 0;</span>
        byte c;
<span class="nc bnc" id="L121" title="All 2 branches missed.">        for (; (c = b.get()) != (byte)0; nameLength++);</span>

<span class="nc" id="L123">        byte[] symbolBytes = new byte[nameLength];</span>
<span class="nc" id="L124">        b.position(entryStart + nameOffset);</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">        for (int i = 0; i &lt; nameLength; i++) {</span>
<span class="nc" id="L126">            symbolBytes[i] = b.get();</span>
        }

        // convert name into a String
        try {
<span class="nc" id="L131">            name = new String(symbolBytes, &quot;UTF-8&quot;);</span>
        }
<span class="nc" id="L133">        catch (UnsupportedEncodingException e) {</span>
            // should not reach here
            // &quot;UTF-8&quot; is always a known encoding
<span class="nc" id="L136">            throw new InternalError(e.getMessage(), e);</span>
<span class="nc" id="L137">        }</span>

<span class="nc bnc" id="L139" title="All 2 branches missed.">        if (variability == Variability.INVALID) {</span>
<span class="nc" id="L140">            throw new InstrumentationException(&quot;Invalid variability attribute:&quot; +</span>
                                               &quot; name = &quot; + name);
        }
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (unit == Units.INVALID) {</span>
<span class="nc" id="L144">            throw new InstrumentationException(&quot;Invalid units attribute: &quot; +</span>
                                               &quot; name = &quot; + name);
        }

<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (vectorLength &gt; 0) {</span>
<span class="nc" id="L149">            dataSize = vectorLength * dataType.size();</span>
        } else {
<span class="nc" id="L151">            dataSize = dataType.size();</span>
        }

        // check if data beyond the eof.
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if ((entryStart + dataOffset + dataSize) &gt; b.limit()) {</span>
<span class="nc" id="L156">            throw new InstrumentationException(&quot;Data extends beyond end of buffer: &quot; +</span>
                                               &quot; entryStart = &quot; + entryStart +
                                               &quot; dataOffset = &quot; + dataOffset+
                                               &quot; dataSize = &quot; + dataSize +
<span class="nc" id="L160">                                               &quot; buffer limit = &quot; + b.limit());</span>
        }
        // Construct a ByteBuffer for the data
<span class="nc" id="L163">        b.position(entryStart + dataOffset);</span>
<span class="nc" id="L164">        data = b.slice();</span>
<span class="nc" id="L165">        data.order(b.order());</span>
<span class="nc" id="L166">        data.limit(dataSize);</span>
<span class="nc" id="L167">    }</span>


    public int size() {
<span class="nc" id="L171">        return entryLength;</span>
    }

    public String name() {
<span class="nc" id="L175">        return name;</span>
    }

    public PerfDataType type() {
<span class="nc" id="L179">        return dataType;</span>
    }

    public Units units() {
<span class="nc" id="L183">        return unit;</span>
    }

    public int flags() {
<span class="nc" id="L187">        return flags;</span>
    }

    /**
     * Returns the number of elements in the data.
     */
    public int vectorLength() {
<span class="nc" id="L194">        return vectorLength;</span>
    }

    public Variability variability() {
<span class="nc" id="L198">        return variability;</span>
    }

    public ByteBuffer byteData() {
<span class="nc" id="L202">        data.position(0);</span>
<span class="nc bnc" id="L203" title="All 4 branches missed.">        assert data.remaining() == vectorLength();</span>
<span class="nc" id="L204">        return data.duplicate();</span>
    }

    public LongBuffer longData() {
<span class="nc" id="L208">        LongBuffer lb = data.asLongBuffer();</span>
<span class="nc" id="L209">        return lb;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>