<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AudioFormat.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.sound.sampled</a> &gt; <span class="el_source">AudioFormat.java</span></div><h1>AudioFormat.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.sound.sampled;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

/**
 * &lt;code&gt;AudioFormat&lt;/code&gt; is the class that specifies a particular arrangement of data in a sound stream.
 * By examining the information stored in the audio format, you can discover how to interpret the bits in the
 * binary sound data.
 * &lt;p&gt;
 * Every data line has an audio format associated with its data stream. The audio format of a source (playback) data line indicates
 * what kind of data the data line expects to receive for output.  For a target (capture) data line, the audio format specifies the kind
 * of the data that can be read from the line.
 * Sound files also have audio formats, of course.  The &lt;code&gt;{@link AudioFileFormat}&lt;/code&gt;
 * class encapsulates an &lt;code&gt;AudioFormat&lt;/code&gt; in addition to other,
 * file-specific information.  Similarly, an &lt;code&gt;{@link AudioInputStream}&lt;/code&gt; has an
 * &lt;code&gt;AudioFormat&lt;/code&gt;.
 * &lt;p&gt;
 * The &lt;code&gt;AudioFormat&lt;/code&gt; class accommodates a number of common sound-file encoding techniques, including
 * pulse-code modulation (PCM), mu-law encoding, and a-law encoding.  These encoding techniques are predefined,
 * but service providers can create new encoding types.
 * The encoding that a specific format uses is named by its &lt;code&gt;encoding&lt;/code&gt; field.
 *&lt;p&gt;
 * In addition to the encoding, the audio format includes other properties that further specify the exact
 * arrangement of the data.
 * These include the number of channels, sample rate, sample size, byte order, frame rate, and frame size.
 * Sounds may have different numbers of audio channels: one for mono, two for stereo.
 * The sample rate measures how many &quot;snapshots&quot; (samples) of the sound pressure are taken per second, per channel.
 * (If the sound is stereo rather than mono, two samples are actually measured at each instant of time: one for the left channel,
 * and another for the right channel; however, the sample rate still measures the number per channel, so the rate is the same
 * regardless of the number of channels.   This is the standard use of the term.)
 * The sample size indicates how many bits are used to store each snapshot; 8 and 16 are typical values.
 * For 16-bit samples (or any other sample size larger than a byte),
 * byte order is important; the bytes in each sample are arranged in
 * either the &quot;little-endian&quot; or &quot;big-endian&quot; style.
 * For encodings like PCM, a frame consists of the set of samples for all channels at a given
 * point in time, and so the size of a frame (in bytes) is always equal to the size of a sample (in bytes) times
 * the number of channels.  However, with some other sorts of encodings a frame can contain
 * a bundle of compressed data for a whole series of samples, as well as additional, non-sample
 * data.  For such encodings, the sample rate and sample size refer to the data after it is decoded into PCM,
 * and so they are completely different from the frame rate and frame size.
 *
 * &lt;p&gt;An &lt;code&gt;AudioFormat&lt;/code&gt; object can include a set of
 * properties. A property is a pair of key and value: the key
 * is of type &lt;code&gt;String&lt;/code&gt;, the associated property
 * value is an arbitrary object. Properties specify
 * additional format specifications, like the bit rate for
 * compressed formats. Properties are mainly used as a means
 * to transport additional information of the audio format
 * to and from the service providers. Therefore, properties
 * are ignored in the {@link #matches(AudioFormat)} method.
 * However, methods which rely on the installed service
 * providers, like {@link AudioSystem#isConversionSupported
 * (AudioFormat, AudioFormat) isConversionSupported} may consider
 * properties, depending on the respective service provider
 * implementation.
 *
 * &lt;p&gt;The following table lists some common properties which
 * service providers should use, if applicable:
 *
 * &lt;table border=0&gt;
 *  &lt;caption&gt;Audio Format Properties&lt;/caption&gt;
 *  &lt;tr&gt;
 *   &lt;th&gt;Property key&lt;/th&gt;
 *   &lt;th&gt;Value type&lt;/th&gt;
 *   &lt;th&gt;Description&lt;/th&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;&amp;quot;bitrate&amp;quot;&lt;/td&gt;
 *   &lt;td&gt;{@link java.lang.Integer Integer}&lt;/td&gt;
 *   &lt;td&gt;average bit rate in bits per second&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;&amp;quot;vbr&amp;quot;&lt;/td&gt;
 *   &lt;td&gt;{@link java.lang.Boolean Boolean}&lt;/td&gt;
 *   &lt;td&gt;&lt;code&gt;true&lt;/code&gt;, if the file is encoded in variable bit
 *       rate (VBR)&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;&amp;quot;quality&amp;quot;&lt;/td&gt;
 *   &lt;td&gt;{@link java.lang.Integer Integer}&lt;/td&gt;
 *   &lt;td&gt;encoding/conversion quality, 1..100&lt;/td&gt;
 *  &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * &lt;p&gt;Vendors of service providers (plugins) are encouraged
 * to seek information about other already established
 * properties in third party plugins, and follow the same
 * conventions.
 *
 * @author Kara Kytle
 * @author Florian Bomers
 * @see DataLine#getFormat
 * @see AudioInputStream#getFormat
 * @see AudioFileFormat
 * @see javax.sound.sampled.spi.FormatConversionProvider
 * @since 1.3
 */
public class AudioFormat {

    // INSTANCE VARIABLES


    /**
     * The audio encoding technique used by this format.
     */
    protected Encoding encoding;

    /**
     * The number of samples played or recorded per second, for sounds that have this format.
     */
    protected float sampleRate;

    /**
     * The number of bits in each sample of a sound that has this format.
     */
    protected int sampleSizeInBits;

    /**
     * The number of audio channels in this format (1 for mono, 2 for stereo).
     */
    protected int channels;

    /**
     * The number of bytes in each frame of a sound that has this format.
     */
    protected int frameSize;

    /**
     * The number of frames played or recorded per second, for sounds that have this format.
     */
    protected float frameRate;

    /**
     * Indicates whether the audio data is stored in big-endian or little-endian order.
     */
    protected boolean bigEndian;


    /** The set of properties */
    private HashMap&lt;String, Object&gt; properties;


    /**
     * Constructs an &lt;code&gt;AudioFormat&lt;/code&gt; with the given parameters.
     * The encoding specifies the convention used to represent the data.
     * The other parameters are further explained in the {@link AudioFormat
     * class description}.
     * @param encoding                  the audio encoding technique
     * @param sampleRate                the number of samples per second
     * @param sampleSizeInBits  the number of bits in each sample
     * @param channels                  the number of channels (1 for mono, 2 for stereo, and so on)
     * @param frameSize                 the number of bytes in each frame
     * @param frameRate                 the number of frames per second
     * @param bigEndian                 indicates whether the data for a single sample
     *                                                  is stored in big-endian byte order (&lt;code&gt;false&lt;/code&gt;
     *                                                  means little-endian)
     */
    public AudioFormat(Encoding encoding, float sampleRate, int sampleSizeInBits,
<span class="nc" id="L186">                       int channels, int frameSize, float frameRate, boolean bigEndian) {</span>

<span class="nc" id="L188">        this.encoding = encoding;</span>
<span class="nc" id="L189">        this.sampleRate = sampleRate;</span>
<span class="nc" id="L190">        this.sampleSizeInBits = sampleSizeInBits;</span>
<span class="nc" id="L191">        this.channels = channels;</span>
<span class="nc" id="L192">        this.frameSize = frameSize;</span>
<span class="nc" id="L193">        this.frameRate = frameRate;</span>
<span class="nc" id="L194">        this.bigEndian = bigEndian;</span>
<span class="nc" id="L195">        this.properties = null;</span>
<span class="nc" id="L196">    }</span>


    /**
     * Constructs an &lt;code&gt;AudioFormat&lt;/code&gt; with the given parameters.
     * The encoding specifies the convention used to represent the data.
     * The other parameters are further explained in the {@link AudioFormat
     * class description}.
     * @param encoding         the audio encoding technique
     * @param sampleRate       the number of samples per second
     * @param sampleSizeInBits the number of bits in each sample
     * @param channels         the number of channels (1 for mono, 2 for
     *                         stereo, and so on)
     * @param frameSize        the number of bytes in each frame
     * @param frameRate        the number of frames per second
     * @param bigEndian        indicates whether the data for a single sample
     *                         is stored in big-endian byte order
     *                         (&lt;code&gt;false&lt;/code&gt; means little-endian)
     * @param properties       a &lt;code&gt;Map&amp;lt;String,Object&amp;gt;&lt;/code&gt; object
     *                         containing format properties
     *
     * @since 1.5
     */
    public AudioFormat(Encoding encoding, float sampleRate,
                       int sampleSizeInBits, int channels,
                       int frameSize, float frameRate,
                       boolean bigEndian, Map&lt;String, Object&gt; properties) {
<span class="nc" id="L223">        this(encoding, sampleRate, sampleSizeInBits, channels,</span>
             frameSize, frameRate, bigEndian);
<span class="nc" id="L225">        this.properties = new HashMap&lt;String, Object&gt;(properties);</span>
<span class="nc" id="L226">    }</span>


    /**
     * Constructs an &lt;code&gt;AudioFormat&lt;/code&gt; with a linear PCM encoding and
     * the given parameters.  The frame size is set to the number of bytes
     * required to contain one sample from each channel, and the frame rate
     * is set to the sample rate.
     *
     * @param sampleRate                the number of samples per second
     * @param sampleSizeInBits  the number of bits in each sample
     * @param channels                  the number of channels (1 for mono, 2 for stereo, and so on)
     * @param signed                    indicates whether the data is signed or unsigned
     * @param bigEndian                 indicates whether the data for a single sample
     *                                                  is stored in big-endian byte order (&lt;code&gt;false&lt;/code&gt;
     *                                                  means little-endian)
     */
    public AudioFormat(float sampleRate, int sampleSizeInBits,
                       int channels, boolean signed, boolean bigEndian) {

<span class="nc bnc" id="L246" title="All 6 branches missed.">        this((signed == true ? Encoding.PCM_SIGNED : Encoding.PCM_UNSIGNED),</span>
             sampleRate,
             sampleSizeInBits,
             channels,
             (channels == AudioSystem.NOT_SPECIFIED || sampleSizeInBits == AudioSystem.NOT_SPECIFIED)?
             AudioSystem.NOT_SPECIFIED:
             ((sampleSizeInBits + 7) / 8) * channels,
             sampleRate,
             bigEndian);
<span class="nc" id="L255">    }</span>

    /**
     * Obtains the type of encoding for sounds in this format.
     *
     * @return the encoding type
     * @see Encoding#PCM_SIGNED
     * @see Encoding#PCM_UNSIGNED
     * @see Encoding#ULAW
     * @see Encoding#ALAW
     */
    public Encoding getEncoding() {

<span class="nc" id="L268">        return encoding;</span>
    }

    /**
     * Obtains the sample rate.
     * For compressed formats, the return value is the sample rate of the uncompressed
     * audio data.
     * When this AudioFormat is used for queries (e.g. {@link
     * AudioSystem#isConversionSupported(AudioFormat, AudioFormat)
     * AudioSystem.isConversionSupported}) or capabilities (e.g. {@link
     * DataLine.Info#getFormats() DataLine.Info.getFormats}), a sample rate of
     * &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; means that any sample rate is
     * acceptable. &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; is also returned when
     * the sample rate is not defined for this audio format.
     * @return the number of samples per second,
     * or &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;
     *
     * @see #getFrameRate()
     * @see AudioSystem#NOT_SPECIFIED
     */
    public float getSampleRate() {

<span class="nc" id="L290">        return sampleRate;</span>
    }

    /**
     * Obtains the size of a sample.
     * For compressed formats, the return value is the sample size of the
     * uncompressed audio data.
     * When this AudioFormat is used for queries (e.g. {@link
     * AudioSystem#isConversionSupported(AudioFormat, AudioFormat)
     * AudioSystem.isConversionSupported}) or capabilities (e.g. {@link
     * DataLine.Info#getFormats() DataLine.Info.getFormats}), a sample size of
     * &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; means that any sample size is
     * acceptable. &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; is also returned when
     * the sample size is not defined for this audio format.
     * @return the number of bits in each sample,
     * or &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;
     *
     * @see #getFrameSize()
     * @see AudioSystem#NOT_SPECIFIED
     */
    public int getSampleSizeInBits() {

<span class="nc" id="L312">        return sampleSizeInBits;</span>
    }

    /**
     * Obtains the number of channels.
     * When this AudioFormat is used for queries (e.g. {@link
     * AudioSystem#isConversionSupported(AudioFormat, AudioFormat)
     * AudioSystem.isConversionSupported}) or capabilities (e.g. {@link
     * DataLine.Info#getFormats() DataLine.Info.getFormats}), a return value of
     * &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; means that any (positive) number of channels is
     * acceptable.
     * @return The number of channels (1 for mono, 2 for stereo, etc.),
     * or &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;
     *
     * @see AudioSystem#NOT_SPECIFIED
     */
    public int getChannels() {

<span class="nc" id="L330">        return channels;</span>
    }

    /**
     * Obtains the frame size in bytes.
     * When this AudioFormat is used for queries (e.g. {@link
     * AudioSystem#isConversionSupported(AudioFormat, AudioFormat)
     * AudioSystem.isConversionSupported}) or capabilities (e.g. {@link
     * DataLine.Info#getFormats() DataLine.Info.getFormats}), a frame size of
     * &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; means that any frame size is
     * acceptable. &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; is also returned when
     * the frame size is not defined for this audio format.
     * @return the number of bytes per frame,
     * or &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;
     *
     * @see #getSampleSizeInBits()
     * @see AudioSystem#NOT_SPECIFIED
     */
    public int getFrameSize() {

<span class="nc" id="L350">        return frameSize;</span>
    }

    /**
     * Obtains the frame rate in frames per second.
     * When this AudioFormat is used for queries (e.g. {@link
     * AudioSystem#isConversionSupported(AudioFormat, AudioFormat)
     * AudioSystem.isConversionSupported}) or capabilities (e.g. {@link
     * DataLine.Info#getFormats() DataLine.Info.getFormats}), a frame rate of
     * &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; means that any frame rate is
     * acceptable. &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt; is also returned when
     * the frame rate is not defined for this audio format.
     * @return the number of frames per second,
     * or &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;
     *
     * @see #getSampleRate()
     * @see AudioSystem#NOT_SPECIFIED
     */
    public float getFrameRate() {

<span class="nc" id="L370">        return frameRate;</span>
    }


    /**
     * Indicates whether the audio data is stored in big-endian or little-endian
     * byte order.  If the sample size is not more than one byte, the return value is
     * irrelevant.
     * @return &lt;code&gt;true&lt;/code&gt; if the data is stored in big-endian byte order,
     * &lt;code&gt;false&lt;/code&gt; if little-endian
     */
    public boolean isBigEndian() {

<span class="nc" id="L383">        return bigEndian;</span>
    }


    /**
     * Obtain an unmodifiable map of properties.
     * The concept of properties is further explained in
     * the {@link AudioFileFormat class description}.
     *
     * @return a &lt;code&gt;Map&amp;lt;String,Object&amp;gt;&lt;/code&gt; object containing
     *         all properties. If no properties are recognized, an empty map is
     *         returned.
     *
     * @see #getProperty(String)
     * @since 1.5
     */
    public Map&lt;String,Object&gt; properties() {
        Map&lt;String,Object&gt; ret;
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (properties == null) {</span>
<span class="nc" id="L402">            ret = new HashMap&lt;String,Object&gt;(0);</span>
        } else {
<span class="nc" id="L404">            ret = (Map&lt;String,Object&gt;) (properties.clone());</span>
        }
<span class="nc" id="L406">        return (Map&lt;String,Object&gt;) Collections.unmodifiableMap(ret);</span>
    }


    /**
     * Obtain the property value specified by the key.
     * The concept of properties is further explained in
     * the {@link AudioFileFormat class description}.
     *
     * &lt;p&gt;If the specified property is not defined for a
     * particular file format, this method returns
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @param key the key of the desired property
     * @return the value of the property with the specified key,
     *         or &lt;code&gt;null&lt;/code&gt; if the property does not exist.
     *
     * @see #properties()
     * @since 1.5
     */
    public Object getProperty(String key) {
<span class="nc bnc" id="L427" title="All 2 branches missed.">        if (properties == null) {</span>
<span class="nc" id="L428">            return null;</span>
        }
<span class="nc" id="L430">        return properties.get(key);</span>
    }


    /**
     * Indicates whether this format matches the one specified.
     * To match, two formats must have the same encoding,
     * and consistent values of the number of channels, sample rate, sample size,
     * frame rate, and frame size.
     * The values of the property are consistent if they are equal
     * or the specified format has the property value
     * {@code AudioSystem.NOT_SPECIFIED}.
     * The byte order (big-endian or little-endian) must be the same
     * if the sample size is greater than one byte.
     *
     * @param format format to test for match
     * @return {@code true} if this format matches the one specified,
     *         {@code false} otherwise.
     */
    public boolean matches(AudioFormat format) {
<span class="nc bnc" id="L450" title="All 2 branches missed.">        if (format.getEncoding().equals(getEncoding())</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">                &amp;&amp; (format.getChannels() == AudioSystem.NOT_SPECIFIED</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                    || format.getChannels() == getChannels())</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">                &amp;&amp; (format.getSampleRate() == (float)AudioSystem.NOT_SPECIFIED</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">                    || format.getSampleRate() == getSampleRate())</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">                &amp;&amp; (format.getSampleSizeInBits() == AudioSystem.NOT_SPECIFIED</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                    || format.getSampleSizeInBits() == getSampleSizeInBits())</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                &amp;&amp; (format.getFrameRate() == (float)AudioSystem.NOT_SPECIFIED</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                    || format.getFrameRate() == getFrameRate())</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">                &amp;&amp; (format.getFrameSize() == AudioSystem.NOT_SPECIFIED</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                    || format.getFrameSize() == getFrameSize())</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                &amp;&amp; (getSampleSizeInBits() &lt;= 8</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                    || format.isBigEndian() == isBigEndian())) {</span>
<span class="nc" id="L463">            return true;</span>
        }
<span class="nc" id="L465">        return false;</span>
    }


    /**
     * Returns a string that describes the format, such as:
     * &quot;PCM SIGNED 22050 Hz 16 bit mono big-endian&quot;.  The contents of the string
     * may vary between implementations of Java Sound.
     *
     * @return a string that describes the format parameters
     */
    public String toString() {
<span class="nc" id="L477">        String sEncoding = &quot;&quot;;</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if (getEncoding() != null) {</span>
<span class="nc" id="L479">            sEncoding = getEncoding().toString() + &quot; &quot;;</span>
        }

        String sSampleRate;
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (getSampleRate() == (float) AudioSystem.NOT_SPECIFIED) {</span>
<span class="nc" id="L484">            sSampleRate = &quot;unknown sample rate, &quot;;</span>
        } else {
<span class="nc" id="L486">            sSampleRate = &quot;&quot; + getSampleRate() + &quot; Hz, &quot;;</span>
        }

        String sSampleSizeInBits;
<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (getSampleSizeInBits() == (float) AudioSystem.NOT_SPECIFIED) {</span>
<span class="nc" id="L491">            sSampleSizeInBits = &quot;unknown bits per sample, &quot;;</span>
        } else {
<span class="nc" id="L493">            sSampleSizeInBits = &quot;&quot; + getSampleSizeInBits() + &quot; bit, &quot;;</span>
        }

        String sChannels;
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if (getChannels() == 1) {</span>
<span class="nc" id="L498">            sChannels = &quot;mono, &quot;;</span>
        } else
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (getChannels() == 2) {</span>
<span class="nc" id="L501">                sChannels = &quot;stereo, &quot;;</span>
            } else {
<span class="nc bnc" id="L503" title="All 2 branches missed.">                if (getChannels() == AudioSystem.NOT_SPECIFIED) {</span>
<span class="nc" id="L504">                    sChannels = &quot; unknown number of channels, &quot;;</span>
                } else {
<span class="nc" id="L506">                    sChannels = &quot;&quot;+getChannels()+&quot; channels, &quot;;</span>
                }
            }

        String sFrameSize;
<span class="nc bnc" id="L511" title="All 2 branches missed.">        if (getFrameSize() == (float) AudioSystem.NOT_SPECIFIED) {</span>
<span class="nc" id="L512">            sFrameSize = &quot;unknown frame size, &quot;;</span>
        } else {
<span class="nc" id="L514">            sFrameSize = &quot;&quot; + getFrameSize()+ &quot; bytes/frame, &quot;;</span>
        }

<span class="nc" id="L517">        String sFrameRate = &quot;&quot;;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">        if (Math.abs(getSampleRate() - getFrameRate()) &gt; 0.00001) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            if (getFrameRate() == (float) AudioSystem.NOT_SPECIFIED) {</span>
<span class="nc" id="L520">                sFrameRate = &quot;unknown frame rate, &quot;;</span>
            } else {
<span class="nc" id="L522">                sFrameRate = getFrameRate() + &quot; frames/second, &quot;;</span>
            }
        }

<span class="nc" id="L526">        String sEndian = &quot;&quot;;</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if ((getEncoding().equals(Encoding.PCM_SIGNED)</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">             || getEncoding().equals(Encoding.PCM_UNSIGNED))</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">            &amp;&amp; ((getSampleSizeInBits() &gt; 8)</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">                || (getSampleSizeInBits() == AudioSystem.NOT_SPECIFIED))) {</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">            if (isBigEndian()) {</span>
<span class="nc" id="L532">                sEndian = &quot;big-endian&quot;;</span>
            } else {
<span class="nc" id="L534">                sEndian = &quot;little-endian&quot;;</span>
            }
        }

<span class="nc" id="L538">        return sEncoding</span>
            + sSampleRate
            + sSampleSizeInBits
            + sChannels
            + sFrameSize
            + sFrameRate
            + sEndian;

    }

    /**
     * The &lt;code&gt;Encoding&lt;/code&gt; class  names the  specific type of data representation
     * used for an audio stream.   The encoding includes aspects of the
     * sound format other than the number of channels, sample rate, sample size,
     * frame rate, frame size, and byte order.
     * &lt;p&gt;
     * One ubiquitous type of audio encoding is pulse-code modulation (PCM),
     * which is simply a linear (proportional) representation of the sound
     * waveform.  With PCM, the number stored in each sample is proportional
     * to the instantaneous amplitude of the sound pressure at that point in
     * time.  The numbers may be signed or unsigned integers or floats.
     * Besides PCM, other encodings include mu-law and a-law, which are nonlinear
     * mappings of the sound amplitude that are often used for recording speech.
     * &lt;p&gt;
     * You can use a predefined encoding by referring to one of the static
     * objects created by this class, such as PCM_SIGNED or
     * PCM_UNSIGNED.  Service providers can create new encodings, such as
     * compressed audio formats, and make
     * these available through the &lt;code&gt;{@link AudioSystem}&lt;/code&gt; class.
     * &lt;p&gt;
     * The &lt;code&gt;Encoding&lt;/code&gt; class is static, so that all
     * &lt;code&gt;AudioFormat&lt;/code&gt; objects that have the same encoding will refer
     * to the same object (rather than different instances of the same class).
     * This allows matches to be made by checking that two format's encodings
     * are equal.
     *
     * @see AudioFormat
     * @see javax.sound.sampled.spi.FormatConversionProvider
     *
     * @author Kara Kytle
     * @since 1.3
     */
    public static class Encoding {


        // ENCODING DEFINES

        /**
         * Specifies signed, linear PCM data.
         */
<span class="nc" id="L588">        public static final Encoding PCM_SIGNED = new Encoding(&quot;PCM_SIGNED&quot;);</span>

        /**
         * Specifies unsigned, linear PCM data.
         */
<span class="nc" id="L593">        public static final Encoding PCM_UNSIGNED = new Encoding(&quot;PCM_UNSIGNED&quot;);</span>

        /**
         * Specifies floating-point PCM data.
         *
         * @since 1.7
         */
<span class="nc" id="L600">        public static final Encoding PCM_FLOAT = new Encoding(&quot;PCM_FLOAT&quot;);</span>

        /**
         * Specifies u-law encoded data.
         */
<span class="nc" id="L605">        public static final Encoding ULAW = new Encoding(&quot;ULAW&quot;);</span>

        /**
         * Specifies a-law encoded data.
         */
<span class="nc" id="L610">        public static final Encoding ALAW = new Encoding(&quot;ALAW&quot;);</span>


        // INSTANCE VARIABLES

        /**
         * Encoding name.
         */
        private String name;


        // CONSTRUCTOR

        /**
         * Constructs a new encoding.
         * @param name  the name of the new type of encoding
         */
<span class="nc" id="L627">        public Encoding(String name) {</span>
<span class="nc" id="L628">            this.name = name;</span>
<span class="nc" id="L629">        }</span>


        // METHODS

        /**
         * Finalizes the equals method
         */
        public final boolean equals(Object obj) {
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (toString() == null) {</span>
<span class="nc bnc" id="L639" title="All 4 branches missed.">                return (obj != null) &amp;&amp; (obj.toString() == null);</span>
            }
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (obj instanceof Encoding) {</span>
<span class="nc" id="L642">                return toString().equals(obj.toString());</span>
            }
<span class="nc" id="L644">            return false;</span>
        }

        /**
         * Finalizes the hashCode method
         */
        public final int hashCode() {
<span class="nc bnc" id="L651" title="All 2 branches missed.">            if (toString() == null) {</span>
<span class="nc" id="L652">                return 0;</span>
            }
<span class="nc" id="L654">            return toString().hashCode();</span>
        }

        /**
         * Provides the &lt;code&gt;String&lt;/code&gt; representation of the encoding.  This &lt;code&gt;String&lt;/code&gt; is
         * the same name that was passed to the constructor.  For the predefined encodings, the name
         * is similar to the encoding's variable (field) name.  For example, &lt;code&gt;PCM_SIGNED.toString()&lt;/code&gt; returns
         * the name &quot;pcm_signed&quot;.
         *
         * @return the encoding name
         */
        public final String toString() {
<span class="nc" id="L666">            return name;</span>
        }

    } // class Encoding
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>