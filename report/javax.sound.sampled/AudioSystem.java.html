<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AudioSystem.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.sound.sampled</a> &gt; <span class="el_source">AudioSystem.java</span></div><h1>AudioSystem.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.sound.sampled;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.URL;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Vector;
import java.util.ArrayList;

import javax.sound.sampled.spi.AudioFileWriter;
import javax.sound.sampled.spi.AudioFileReader;
import javax.sound.sampled.spi.FormatConversionProvider;
import javax.sound.sampled.spi.MixerProvider;

import com.sun.media.sound.JDK13Services;

/* $fb TODO:
 * - consistent usage of (typed) collections
 */


/**
 * The &lt;code&gt;AudioSystem&lt;/code&gt; class acts as the entry point to the
 * sampled-audio system resources. This class lets you query and
 * access the mixers that are installed on the system.
 * &lt;code&gt;AudioSystem&lt;/code&gt; includes a number of
 * methods for converting audio data between different formats, and for
 * translating between audio files and streams. It also provides a method
 * for obtaining a &lt;code&gt;{@link Line}&lt;/code&gt; directly from the
 * &lt;code&gt;AudioSystem&lt;/code&gt; without dealing explicitly
 * with mixers.
 *
 * &lt;p&gt;Properties can be used to specify the default mixer
 * for specific line types.
 * Both system properties and a properties file are considered.
 * The &lt;code&gt;sound.properties&lt;/code&gt; properties file is read from
 * an implementation-specific location (typically it is the &lt;code&gt;lib&lt;/code&gt;
 * directory in the Java installation directory).
 * If a property exists both as a system property and in the
 * properties file, the system property takes precedence. If none is
 * specified, a suitable default is chosen among the available devices.
 * The syntax of the properties file is specified in
 * {@link java.util.Properties#load(InputStream) Properties.load}. The
 * following table lists the available property keys and which methods
 * consider them:
 *
 * &lt;table border=0&gt;
 *  &lt;caption&gt;Audio System Property Keys&lt;/caption&gt;
 *  &lt;tr&gt;
 *   &lt;th&gt;Property Key&lt;/th&gt;
 *   &lt;th&gt;Interface&lt;/th&gt;
 *   &lt;th&gt;Affected Method(s)&lt;/th&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;&lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt;&lt;/td&gt;
 *   &lt;td&gt;{@link Clip}&lt;/td&gt;
 *   &lt;td&gt;{@link #getLine}, {@link #getClip}&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;&lt;code&gt;javax.sound.sampled.Port&lt;/code&gt;&lt;/td&gt;
 *   &lt;td&gt;{@link Port}&lt;/td&gt;
 *   &lt;td&gt;{@link #getLine}&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;&lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt;&lt;/td&gt;
 *   &lt;td&gt;{@link SourceDataLine}&lt;/td&gt;
 *   &lt;td&gt;{@link #getLine}, {@link #getSourceDataLine}&lt;/td&gt;
 *  &lt;/tr&gt;
 *  &lt;tr&gt;
 *   &lt;td&gt;&lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt;&lt;/td&gt;
 *   &lt;td&gt;{@link TargetDataLine}&lt;/td&gt;
 *   &lt;td&gt;{@link #getLine}, {@link #getTargetDataLine}&lt;/td&gt;
 *  &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * The property value consists of the provider class name
 * and the mixer name, separated by the hash mark (&amp;quot;#&amp;quot;).
 * The provider class name is the fully-qualified
 * name of a concrete {@link javax.sound.sampled.spi.MixerProvider
 * mixer provider} class. The mixer name is matched against
 * the &lt;code&gt;String&lt;/code&gt; returned by the &lt;code&gt;getName&lt;/code&gt;
 * method of &lt;code&gt;Mixer.Info&lt;/code&gt;.
 * Either the class name, or the mixer name may be omitted.
 * If only the class name is specified, the trailing hash mark
 * is optional.
 *
 * &lt;p&gt;If the provider class is specified, and it can be
 * successfully retrieved from the installed providers, the list of
 * &lt;code&gt;Mixer.Info&lt;/code&gt; objects is retrieved
 * from the provider. Otherwise, or when these mixers
 * do not provide a subsequent match, the list is retrieved
 * from {@link #getMixerInfo} to contain
 * all available &lt;code&gt;Mixer.Info&lt;/code&gt; objects.
 *
 * &lt;p&gt;If a mixer name is specified, the resulting list of
 * &lt;code&gt;Mixer.Info&lt;/code&gt; objects is searched:
 * the first one with a matching name, and whose
 * &lt;code&gt;Mixer&lt;/code&gt; provides the
 * respective line interface, will be returned.
 * If no matching &lt;code&gt;Mixer.Info&lt;/code&gt; object
 * is found, or the mixer name is not specified,
 * the first mixer from the resulting
 * list, which provides the respective line
 * interface, will be returned.
 *
 * For example, the property &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt;
 * with a value
 * &lt;code&gt;&amp;quot;com.sun.media.sound.MixerProvider#SunClip&amp;quot;&lt;/code&gt;
 * will have the following consequences when
 * &lt;code&gt;getLine&lt;/code&gt; is called requesting a &lt;code&gt;Clip&lt;/code&gt;
 * instance:
 * if the class &lt;code&gt;com.sun.media.sound.MixerProvider&lt;/code&gt; exists
 * in the list of installed mixer providers,
 * the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer with name
 * &lt;code&gt;&amp;quot;SunClip&amp;quot;&lt;/code&gt; will be returned. If it cannot
 * be found, the first &lt;code&gt;Clip&lt;/code&gt; from the first mixer
 * of the specified provider will be returned, regardless of name.
 * If there is none, the first &lt;code&gt;Clip&lt;/code&gt; from the first
 * &lt;code&gt;Mixer&lt;/code&gt; with name
 * &lt;code&gt;&amp;quot;SunClip&amp;quot;&lt;/code&gt; in the list of all mixers
 * (as returned by &lt;code&gt;getMixerInfo&lt;/code&gt;) will be returned,
 * or, if not found, the first &lt;code&gt;Clip&lt;/code&gt; of the first
 * &lt;code&gt;Mixer&lt;/code&gt;that can be found in the list of all
 * mixers is returned.
 * If that fails, too, an &lt;code&gt;IllegalArgumentException&lt;/code&gt;
 * is thrown.
 *
 * @author Kara Kytle
 * @author Florian Bomers
 * @author Matthias Pfisterer
 * @author Kevin P. Smith
 *
 * @see AudioFormat
 * @see AudioInputStream
 * @see Mixer
 * @see Line
 * @see Line.Info
 * @since 1.3
 */
public class AudioSystem {

    /**
     * An integer that stands for an unknown numeric value.
     * This value is appropriate only for signed quantities that do not
     * normally take negative values.  Examples include file sizes, frame
     * sizes, buffer sizes, and sample rates.
     * A number of Java Sound constructors accept
     * a value of &lt;code&gt;NOT_SPECIFIED&lt;/code&gt; for such parameters.  Other
     * methods may also accept or return this value, as documented.
     */
    public static final int NOT_SPECIFIED = -1;

    /**
     * Private no-args constructor for ensuring against instantiation.
     */
<span class="nc" id="L186">    private AudioSystem() {</span>
<span class="nc" id="L187">    }</span>


    /**
     * Obtains an array of mixer info objects that represents
     * the set of audio mixers that are currently installed on the system.
     * @return an array of info objects for the currently installed mixers.  If no mixers
     * are available on the system, an array of length 0 is returned.
     * @see #getMixer
     */
    public static Mixer.Info[] getMixerInfo() {

<span class="nc" id="L199">        List infos = getMixerInfoList();</span>
<span class="nc" id="L200">        Mixer.Info[] allInfos = (Mixer.Info[]) infos.toArray(new Mixer.Info[infos.size()]);</span>
<span class="nc" id="L201">        return allInfos;</span>
    }


    /**
     * Obtains the requested audio mixer.
     * @param info a &lt;code&gt;Mixer.Info&lt;/code&gt; object representing the desired
     * mixer, or &lt;code&gt;null&lt;/code&gt; for the system default mixer
     * @return the requested mixer
     * @throws SecurityException if the requested mixer
     * is unavailable because of security restrictions
     * @throws IllegalArgumentException if the info object does not represent
     * a mixer installed on the system
     * @see #getMixerInfo
     */
    public static Mixer getMixer(Mixer.Info info) {

<span class="nc" id="L218">        Mixer mixer = null;</span>
<span class="nc" id="L219">        List providers = getMixerProviders();</span>

<span class="nc bnc" id="L221" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++ ) {</span>

            try {
<span class="nc" id="L224">                return ((MixerProvider)providers.get(i)).getMixer(info);</span>

<span class="nc" id="L226">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L227">            } catch (NullPointerException e) {</span>
                // $$jb 08.20.99:  If the strings in the info object aren't
                // set, then Netscape (using jdk1.1.5) tends to throw
                // NPE's when doing some string manipulation.  This is
                // probably not the best fix, but is solves the problem
                // of the NPE in Netscape using local classes
                // $$jb 11.01.99: Replacing this patch.
<span class="nc" id="L234">            }</span>
        }

        //$$fb if looking for default mixer, and not found yet, add a round of looking
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (info == null) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            for(int i = 0; i &lt; providers.size(); i++ ) {</span>
                try {
<span class="nc" id="L241">                    MixerProvider provider = (MixerProvider) providers.get(i);</span>
<span class="nc" id="L242">                    Mixer.Info[] infos = provider.getMixerInfo();</span>
                    // start from 0 to last device (do not reverse this order)
<span class="nc bnc" id="L244" title="All 2 branches missed.">                    for (int ii = 0; ii &lt; infos.length; ii++) {</span>
                        try {
<span class="nc" id="L246">                            return provider.getMixer(infos[ii]);</span>
<span class="nc" id="L247">                        } catch (IllegalArgumentException e) {</span>
                            // this is not a good default device :)
                        }
                    }
<span class="nc" id="L251">                } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L252">                } catch (NullPointerException e) {</span>
<span class="nc" id="L253">                }</span>
            }
        }


<span class="nc bnc" id="L258" title="All 2 branches missed.">        throw new IllegalArgumentException(&quot;Mixer not supported: &quot;</span>
<span class="nc" id="L259">                                           + (info!=null?info.toString():&quot;null&quot;));</span>
    }


    //$$fb 2002-11-26: fix for 4757930: DOC: AudioSystem.getTarget/SourceLineInfo() is ambiguous
    /**
     * Obtains information about all source lines of a particular type that are supported
     * by the installed mixers.
     * @param info a &lt;code&gt;Line.Info&lt;/code&gt; object that specifies the kind of
     * lines about which information is requested
     * @return an array of &lt;code&gt;Line.Info&lt;/code&gt; objects describing source lines matching
     * the type requested.  If no matching source lines are supported, an array of length 0
     * is returned.
     *
     * @see Mixer#getSourceLineInfo(Line.Info)
     */
    public static Line.Info[] getSourceLineInfo(Line.Info info) {

<span class="nc" id="L277">        Vector vector = new Vector();</span>
        Line.Info[] currentInfoArray;

        Mixer mixer;
<span class="nc" id="L281">        Line.Info fullInfo = null;</span>
<span class="nc" id="L282">        Mixer.Info[] infoArray = getMixerInfo();</span>

<span class="nc bnc" id="L284" title="All 2 branches missed.">        for (int i = 0; i &lt; infoArray.length; i++) {</span>

<span class="nc" id="L286">            mixer = getMixer(infoArray[i]);</span>

<span class="nc" id="L288">            currentInfoArray = mixer.getSourceLineInfo(info);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">            for (int j = 0; j &lt; currentInfoArray.length; j++) {</span>
<span class="nc" id="L290">                vector.addElement(currentInfoArray[j]);</span>
            }
        }

<span class="nc" id="L294">        Line.Info[] returnedArray = new Line.Info[vector.size()];</span>

<span class="nc bnc" id="L296" title="All 2 branches missed.">        for (int i = 0; i &lt; returnedArray.length; i++) {</span>
<span class="nc" id="L297">            returnedArray[i] = (Line.Info)vector.get(i);</span>
        }

<span class="nc" id="L300">        return returnedArray;</span>
    }


    /**
     * Obtains information about all target lines of a particular type that are supported
     * by the installed mixers.
     * @param info a &lt;code&gt;Line.Info&lt;/code&gt; object that specifies the kind of
     * lines about which information is requested
     * @return an array of &lt;code&gt;Line.Info&lt;/code&gt; objects describing target lines matching
     * the type requested.  If no matching target lines are supported, an array of length 0
     * is returned.
     *
     * @see Mixer#getTargetLineInfo(Line.Info)
     */
    public static Line.Info[] getTargetLineInfo(Line.Info info) {

<span class="nc" id="L317">        Vector vector = new Vector();</span>
        Line.Info[] currentInfoArray;

        Mixer mixer;
<span class="nc" id="L321">        Line.Info fullInfo = null;</span>
<span class="nc" id="L322">        Mixer.Info[] infoArray = getMixerInfo();</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">        for (int i = 0; i &lt; infoArray.length; i++) {</span>

<span class="nc" id="L326">            mixer = getMixer(infoArray[i]);</span>

<span class="nc" id="L328">            currentInfoArray = mixer.getTargetLineInfo(info);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            for (int j = 0; j &lt; currentInfoArray.length; j++) {</span>
<span class="nc" id="L330">                vector.addElement(currentInfoArray[j]);</span>
            }
        }

<span class="nc" id="L334">        Line.Info[] returnedArray = new Line.Info[vector.size()];</span>

<span class="nc bnc" id="L336" title="All 2 branches missed.">        for (int i = 0; i &lt; returnedArray.length; i++) {</span>
<span class="nc" id="L337">            returnedArray[i] = (Line.Info)vector.get(i);</span>
        }

<span class="nc" id="L340">        return returnedArray;</span>
    }


    /**
     * Indicates whether the system supports any lines that match
     * the specified &lt;code&gt;Line.Info&lt;/code&gt; object.  A line is supported if
     * any installed mixer supports it.
     * @param info a &lt;code&gt;Line.Info&lt;/code&gt; object describing the line for which support is queried
     * @return &lt;code&gt;true&lt;/code&gt; if at least one matching line is
     * supported, otherwise &lt;code&gt;false&lt;/code&gt;
     *
     * @see Mixer#isLineSupported(Line.Info)
     */
    public static boolean isLineSupported(Line.Info info) {

        Mixer mixer;
<span class="nc" id="L357">        Mixer.Info[] infoArray = getMixerInfo();</span>

<span class="nc bnc" id="L359" title="All 2 branches missed.">        for (int i = 0; i &lt; infoArray.length; i++) {</span>

<span class="nc bnc" id="L361" title="All 2 branches missed.">            if( infoArray[i] != null ) {</span>
<span class="nc" id="L362">                mixer = getMixer(infoArray[i]);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">                if (mixer.isLineSupported(info)) {</span>
<span class="nc" id="L364">                    return true;</span>
                }
            }
        }

<span class="nc" id="L369">        return false;</span>
    }

    /**
     * Obtains a line that matches the description in the specified
     * &lt;code&gt;Line.Info&lt;/code&gt; object.
     *
     * &lt;p&gt;If a &lt;code&gt;DataLine&lt;/code&gt; is requested, and &lt;code&gt;info&lt;/code&gt;
     * is an instance of &lt;code&gt;DataLine.Info&lt;/code&gt; specifying at least
     * one fully qualified audio format, the last one
     * will be used as the default format of the returned
     * &lt;code&gt;DataLine&lt;/code&gt;.
     *
     * &lt;p&gt;If system properties
     * &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt;,
     * &lt;code&gt;javax.sound.sampled.Port&lt;/code&gt;,
     * &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt; and
     * &lt;code&gt;javax.sound.sampled.TargetDataLine&lt;/code&gt; are defined
     * or they are defined in the file &amp;quot;sound.properties&amp;quot;,
     * they are used to retrieve default lines.
     * For details, refer to the {@link AudioSystem class description}.
     *
     * If the respective property is not set, or the mixer
     * requested in the property is not installed or does not provide the
     * requested line, all installed mixers are queried for the
     * requested line type. A Line will be returned from the first mixer
     * providing the requested line type.
     *
     * @param info a &lt;code&gt;Line.Info&lt;/code&gt; object describing the desired kind of line
     * @return a line of the requested kind
     *
     * @throws LineUnavailableException if a matching line
     * is not available due to resource restrictions
     * @throws SecurityException if a matching line
     * is not available due to security restrictions
     * @throws IllegalArgumentException if the system does not
     * support at least one line matching the specified
     * &lt;code&gt;Line.Info&lt;/code&gt; object
     * through any installed mixer
     */
    public static Line getLine(Line.Info info) throws LineUnavailableException {
<span class="nc" id="L410">        LineUnavailableException lue = null;</span>
<span class="nc" id="L411">        List providers = getMixerProviders();</span>


        // 1: try from default mixer for this line class
        try {
<span class="nc" id="L416">            Mixer mixer = getDefaultMixer(providers, info);</span>
<span class="nc bnc" id="L417" title="All 4 branches missed.">            if (mixer != null &amp;&amp; mixer.isLineSupported(info)) {</span>
<span class="nc" id="L418">                return mixer.getLine(info);</span>
            }
<span class="nc" id="L420">        } catch (LineUnavailableException e) {</span>
<span class="nc" id="L421">            lue = e;</span>
<span class="nc" id="L422">        } catch (IllegalArgumentException iae) {</span>
            // must not happen... but better to catch it here,
            // if plug-ins are badly written
<span class="nc" id="L425">        }</span>


        // 2: if that doesn't work, try to find any mixing mixer
<span class="nc bnc" id="L429" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++) {</span>
<span class="nc" id="L430">            MixerProvider provider = (MixerProvider) providers.get(i);</span>
<span class="nc" id="L431">            Mixer.Info[] infos = provider.getMixerInfo();</span>

<span class="nc bnc" id="L433" title="All 2 branches missed.">            for (int j = 0; j &lt; infos.length; j++) {</span>
                try {
<span class="nc" id="L435">                    Mixer mixer = provider.getMixer(infos[j]);</span>
                    // see if this is an appropriate mixer which can mix
<span class="nc bnc" id="L437" title="All 2 branches missed.">                    if (isAppropriateMixer(mixer, info, true)) {</span>
<span class="nc" id="L438">                        return mixer.getLine(info);</span>
                    }
<span class="nc" id="L440">                } catch (LineUnavailableException e) {</span>
<span class="nc" id="L441">                    lue = e;</span>
<span class="nc" id="L442">                } catch (IllegalArgumentException iae) {</span>
                    // must not happen... but better to catch it here,
                    // if plug-ins are badly written
<span class="nc" id="L445">                }</span>
            }
        }


        // 3: if that didn't work, try to find any non-mixing mixer
<span class="nc bnc" id="L451" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++) {</span>
<span class="nc" id="L452">            MixerProvider provider = (MixerProvider) providers.get(i);</span>
<span class="nc" id="L453">            Mixer.Info[] infos = provider.getMixerInfo();</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            for (int j = 0; j &lt; infos.length; j++) {</span>
                try {
<span class="nc" id="L456">                    Mixer mixer = provider.getMixer(infos[j]);</span>
                    // see if this is an appropriate mixer which can mix
<span class="nc bnc" id="L458" title="All 2 branches missed.">                    if (isAppropriateMixer(mixer, info, false)) {</span>
<span class="nc" id="L459">                        return mixer.getLine(info);</span>
                    }
<span class="nc" id="L461">                } catch (LineUnavailableException e) {</span>
<span class="nc" id="L462">                    lue = e;</span>
<span class="nc" id="L463">                } catch (IllegalArgumentException iae) {</span>
                    // must not happen... but better to catch it here,
                    // if plug-ins are badly written
<span class="nc" id="L466">                }</span>
            }
        }

        // if this line was supported but was not available, throw the last
        // LineUnavailableException we got (??).
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (lue != null) {</span>
<span class="nc" id="L473">            throw lue;</span>
        }

        // otherwise, the requested line was not supported, so throw
        // an Illegal argument exception
<span class="nc" id="L478">        throw new IllegalArgumentException(&quot;No line matching &quot; +</span>
<span class="nc" id="L479">                                           info.toString() + &quot; is supported.&quot;);</span>
    }


    /**
     * Obtains a clip that can be used for playing back
     * an audio file or an audio stream. The returned clip
     * will be provided by the default system mixer, or,
     * if not possible, by any other mixer installed in the
     * system that supports a &lt;code&gt;Clip&lt;/code&gt;
     * object.
     *
     * &lt;p&gt;The returned clip must be opened with the
     * &lt;code&gt;open(AudioFormat)&lt;/code&gt; or
     * &lt;code&gt;open(AudioInputStream)&lt;/code&gt; method.
     *
     * &lt;p&gt;This is a high-level method that uses &lt;code&gt;getMixer&lt;/code&gt;
     * and &lt;code&gt;getLine&lt;/code&gt; internally.
     *
     * &lt;p&gt;If the system property
     * &lt;code&gt;javax.sound.sampled.Clip&lt;/code&gt;
     * is defined or it is defined in the file &amp;quot;sound.properties&amp;quot;,
     * it is used to retrieve the default clip.
     * For details, refer to the {@link AudioSystem class description}.
     *
     * @return the desired clip object
     *
     * @throws LineUnavailableException if a clip object
     * is not available due to resource restrictions
     * @throws SecurityException if a clip object
     * is not available due to security restrictions
     * @throws IllegalArgumentException if the system does not
     * support at least one clip instance through any installed mixer
     *
     * @see #getClip(Mixer.Info)
     * @since 1.5
     */
    public static Clip getClip() throws LineUnavailableException{
<span class="nc" id="L517">        AudioFormat format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,</span>
                                             AudioSystem.NOT_SPECIFIED,
                                             16, 2, 4,
                                             AudioSystem.NOT_SPECIFIED, true);
<span class="nc" id="L521">        DataLine.Info info = new DataLine.Info(Clip.class, format);</span>
<span class="nc" id="L522">        return (Clip) AudioSystem.getLine(info);</span>
    }


    /**
     * Obtains a clip from the specified mixer that can be
     * used for playing back an audio file or an audio stream.
     *
     * &lt;p&gt;The returned clip must be opened with the
     * &lt;code&gt;open(AudioFormat)&lt;/code&gt; or
     * &lt;code&gt;open(AudioInputStream)&lt;/code&gt; method.
     *
     * &lt;p&gt;This is a high-level method that uses &lt;code&gt;getMixer&lt;/code&gt;
     * and &lt;code&gt;getLine&lt;/code&gt; internally.
     *
     * @param mixerInfo a &lt;code&gt;Mixer.Info&lt;/code&gt; object representing the
     * desired mixer, or &lt;code&gt;null&lt;/code&gt; for the system default mixer
     * @return a clip object from the specified mixer
     *
     * @throws LineUnavailableException if a clip
     * is not available from this mixer due to resource restrictions
     * @throws SecurityException if a clip
     * is not available from this mixer due to security restrictions
     * @throws IllegalArgumentException if the system does not
     * support at least one clip through the specified mixer
     *
     * @see #getClip()
     * @since 1.5
     */
    public static Clip getClip(Mixer.Info mixerInfo) throws LineUnavailableException{
<span class="nc" id="L552">        AudioFormat format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,</span>
                                             AudioSystem.NOT_SPECIFIED,
                                             16, 2, 4,
                                             AudioSystem.NOT_SPECIFIED, true);
<span class="nc" id="L556">        DataLine.Info info = new DataLine.Info(Clip.class, format);</span>
<span class="nc" id="L557">        Mixer mixer = AudioSystem.getMixer(mixerInfo);</span>
<span class="nc" id="L558">        return (Clip) mixer.getLine(info);</span>
    }


    /**
     * Obtains a source data line that can be used for playing back
     * audio data in the format specified by the
     * &lt;code&gt;AudioFormat&lt;/code&gt; object. The returned line
     * will be provided by the default system mixer, or,
     * if not possible, by any other mixer installed in the
     * system that supports a matching
     * &lt;code&gt;SourceDataLine&lt;/code&gt; object.
     *
     * &lt;p&gt;The returned line should be opened with the
     * &lt;code&gt;open(AudioFormat)&lt;/code&gt; or
     * &lt;code&gt;open(AudioFormat, int)&lt;/code&gt; method.
     *
     * &lt;p&gt;This is a high-level method that uses &lt;code&gt;getMixer&lt;/code&gt;
     * and &lt;code&gt;getLine&lt;/code&gt; internally.
     *
     * &lt;p&gt;The returned &lt;code&gt;SourceDataLine&lt;/code&gt;'s default
     * audio format will be initialized with &lt;code&gt;format&lt;/code&gt;.
     *
     * &lt;p&gt;If the system property
     * &lt;code&gt;javax.sound.sampled.SourceDataLine&lt;/code&gt;
     * is defined or it is defined in the file &amp;quot;sound.properties&amp;quot;,
     * it is used to retrieve the default source data line.
     * For details, refer to the {@link AudioSystem class description}.
     *
     * @param format an &lt;code&gt;AudioFormat&lt;/code&gt; object specifying
     *        the supported audio format of the returned line,
     *        or &lt;code&gt;null&lt;/code&gt; for any audio format
     * @return the desired &lt;code&gt;SourceDataLine&lt;/code&gt; object
     *
     * @throws LineUnavailableException if a matching source data line
     *         is not available due to resource restrictions
     * @throws SecurityException if a matching source data line
     *         is not available due to security restrictions
     * @throws IllegalArgumentException if the system does not
     *         support at least one source data line supporting the
     *         specified audio format through any installed mixer
     *
     * @see #getSourceDataLine(AudioFormat, Mixer.Info)
     * @since 1.5
     */
    public static SourceDataLine getSourceDataLine(AudioFormat format)
        throws LineUnavailableException{
<span class="nc" id="L605">        DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);</span>
<span class="nc" id="L606">        return (SourceDataLine) AudioSystem.getLine(info);</span>
    }


    /**
     * Obtains a source data line that can be used for playing back
     * audio data in the format specified by the
     * &lt;code&gt;AudioFormat&lt;/code&gt; object, provided by the mixer
     * specified by the &lt;code&gt;Mixer.Info&lt;/code&gt; object.
     *
     * &lt;p&gt;The returned line should be opened with the
     * &lt;code&gt;open(AudioFormat)&lt;/code&gt; or
     * &lt;code&gt;open(AudioFormat, int)&lt;/code&gt; method.
     *
     * &lt;p&gt;This is a high-level method that uses &lt;code&gt;getMixer&lt;/code&gt;
     * and &lt;code&gt;getLine&lt;/code&gt; internally.
     *
     * &lt;p&gt;The returned &lt;code&gt;SourceDataLine&lt;/code&gt;'s default
     * audio format will be initialized with &lt;code&gt;format&lt;/code&gt;.
     *
     * @param format an &lt;code&gt;AudioFormat&lt;/code&gt; object specifying
     *        the supported audio format of the returned line,
     *        or &lt;code&gt;null&lt;/code&gt; for any audio format
     * @param mixerinfo a &lt;code&gt;Mixer.Info&lt;/code&gt; object representing
     *        the desired mixer, or &lt;code&gt;null&lt;/code&gt; for the system
     *        default mixer
     * @return the desired &lt;code&gt;SourceDataLine&lt;/code&gt; object
     *
     * @throws LineUnavailableException if a matching source data
     *         line is not available from the specified mixer due
     *         to resource restrictions
     * @throws SecurityException if a matching source data line
     *         is not available from the specified mixer due to
     *         security restrictions
     * @throws IllegalArgumentException if the specified mixer does
     *         not support at least one source data line supporting
     *         the specified audio format
     *
     * @see #getSourceDataLine(AudioFormat)
     * @since 1.5
     */
    public static SourceDataLine getSourceDataLine(AudioFormat format,
                                                   Mixer.Info mixerinfo)
        throws LineUnavailableException{
<span class="nc" id="L650">        DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);</span>
<span class="nc" id="L651">        Mixer mixer = AudioSystem.getMixer(mixerinfo);</span>
<span class="nc" id="L652">        return (SourceDataLine) mixer.getLine(info);</span>
  }


    /**
     * Obtains a target data line that can be used for recording
     * audio data in the format specified by the
     * &lt;code&gt;AudioFormat&lt;/code&gt; object. The returned line
     * will be provided by the default system mixer, or,
     * if not possible, by any other mixer installed in the
     * system that supports a matching
     * &lt;code&gt;TargetDataLine&lt;/code&gt; object.
     *
     * &lt;p&gt;The returned line should be opened with the
     * &lt;code&gt;open(AudioFormat)&lt;/code&gt; or
     * &lt;code&gt;open(AudioFormat, int)&lt;/code&gt; method.
     *
     * &lt;p&gt;This is a high-level method that uses &lt;code&gt;getMixer&lt;/code&gt;
     * and &lt;code&gt;getLine&lt;/code&gt; internally.
     *
     * &lt;p&gt;The returned &lt;code&gt;TargetDataLine&lt;/code&gt;'s default
     * audio format will be initialized with &lt;code&gt;format&lt;/code&gt;.
     *
     * &lt;p&gt;If the system property
     * {@code javax.sound.sampled.TargetDataLine}
     * is defined or it is defined in the file &amp;quot;sound.properties&amp;quot;,
     * it is used to retrieve the default target data line.
     * For details, refer to the {@link AudioSystem class description}.
     *
     * @param format an &lt;code&gt;AudioFormat&lt;/code&gt; object specifying
     *        the supported audio format of the returned line,
     *        or &lt;code&gt;null&lt;/code&gt; for any audio format
     * @return the desired &lt;code&gt;TargetDataLine&lt;/code&gt; object
     *
     * @throws LineUnavailableException if a matching target data line
     *         is not available due to resource restrictions
     * @throws SecurityException if a matching target data line
     *         is not available due to security restrictions
     * @throws IllegalArgumentException if the system does not
     *         support at least one target data line supporting the
     *         specified audio format through any installed mixer
     *
     * @see #getTargetDataLine(AudioFormat, Mixer.Info)
     * @see AudioPermission
     * @since 1.5
     */
    public static TargetDataLine getTargetDataLine(AudioFormat format)
        throws LineUnavailableException{

<span class="nc" id="L701">        DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);</span>
<span class="nc" id="L702">        return (TargetDataLine) AudioSystem.getLine(info);</span>
    }



    /**
     * Obtains a target data line that can be used for recording
     * audio data in the format specified by the
     * &lt;code&gt;AudioFormat&lt;/code&gt; object, provided by the mixer
     * specified by the &lt;code&gt;Mixer.Info&lt;/code&gt; object.
     *
     * &lt;p&gt;The returned line should be opened with the
     * &lt;code&gt;open(AudioFormat)&lt;/code&gt; or
     * &lt;code&gt;open(AudioFormat, int)&lt;/code&gt; method.
     *
     * &lt;p&gt;This is a high-level method that uses &lt;code&gt;getMixer&lt;/code&gt;
     * and &lt;code&gt;getLine&lt;/code&gt; internally.
     *
     * &lt;p&gt;The returned &lt;code&gt;TargetDataLine&lt;/code&gt;'s default
     * audio format will be initialized with &lt;code&gt;format&lt;/code&gt;.
     *
     * @param format an &lt;code&gt;AudioFormat&lt;/code&gt; object specifying
     *        the supported audio format of the returned line,
     *        or &lt;code&gt;null&lt;/code&gt; for any audio format
     * @param mixerinfo a &lt;code&gt;Mixer.Info&lt;/code&gt; object representing the
     *        desired mixer, or &lt;code&gt;null&lt;/code&gt; for the system default mixer
     * @return the desired &lt;code&gt;TargetDataLine&lt;/code&gt; object
     *
     * @throws LineUnavailableException if a matching target data
     *         line is not available from the specified mixer due
     *         to resource restrictions
     * @throws SecurityException if a matching target data line
     *         is not available from the specified mixer due to
     *         security restrictions
     * @throws IllegalArgumentException if the specified mixer does
     *         not support at least one target data line supporting
     *         the specified audio format
     *
     * @see #getTargetDataLine(AudioFormat)
     * @see AudioPermission
     * @since 1.5
     */
    public static TargetDataLine getTargetDataLine(AudioFormat format,
                                                   Mixer.Info mixerinfo)
        throws LineUnavailableException {

<span class="nc" id="L748">        DataLine.Info info = new DataLine.Info(TargetDataLine.class, format);</span>
<span class="nc" id="L749">        Mixer mixer = AudioSystem.getMixer(mixerinfo);</span>
<span class="nc" id="L750">        return (TargetDataLine) mixer.getLine(info);</span>
    }


    // $$fb 2002-04-12: fix for 4662082: behavior of AudioSystem.getTargetEncodings() methods doesn't match the spec
    /**
     * Obtains the encodings that the system can obtain from an
     * audio input stream with the specified encoding using the set
     * of installed format converters.
     * @param sourceEncoding the encoding for which conversion support
     * is queried
     * @return array of encodings.  If &lt;code&gt;sourceEncoding&lt;/code&gt;is not supported,
     * an array of length 0 is returned. Otherwise, the array will have a length
     * of at least 1, representing &lt;code&gt;sourceEncoding&lt;/code&gt; (no conversion).
     */
    public static AudioFormat.Encoding[] getTargetEncodings(AudioFormat.Encoding sourceEncoding) {

<span class="nc" id="L767">        List codecs = getFormatConversionProviders();</span>
<span class="nc" id="L768">        Vector encodings = new Vector();</span>

<span class="nc" id="L770">        AudioFormat.Encoding encs[] = null;</span>

        // gather from all the codecs
<span class="nc bnc" id="L773" title="All 2 branches missed.">        for(int i=0; i&lt;codecs.size(); i++ ) {</span>
<span class="nc" id="L774">            FormatConversionProvider codec = (FormatConversionProvider) codecs.get(i);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">            if( codec.isSourceEncodingSupported( sourceEncoding ) ) {</span>
<span class="nc" id="L776">                encs = codec.getTargetEncodings();</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                for (int j = 0; j &lt; encs.length; j++) {</span>
<span class="nc" id="L778">                    encodings.addElement( encs[j] );</span>
                }
            }
        }
<span class="nc" id="L782">        AudioFormat.Encoding encs2[] = (AudioFormat.Encoding[]) encodings.toArray(new AudioFormat.Encoding[0]);</span>
<span class="nc" id="L783">        return encs2;</span>
    }



    // $$fb 2002-04-12: fix for 4662082: behavior of AudioSystem.getTargetEncodings() methods doesn't match the spec
    /**
     * Obtains the encodings that the system can obtain from an
     * audio input stream with the specified format using the set
     * of installed format converters.
     * @param sourceFormat the audio format for which conversion
     * is queried
     * @return array of encodings. If &lt;code&gt;sourceFormat&lt;/code&gt;is not supported,
     * an array of length 0 is returned. Otherwise, the array will have a length
     * of at least 1, representing the encoding of &lt;code&gt;sourceFormat&lt;/code&gt; (no conversion).
     */
    public static AudioFormat.Encoding[] getTargetEncodings(AudioFormat sourceFormat) {


<span class="nc" id="L802">        List codecs = getFormatConversionProviders();</span>
<span class="nc" id="L803">        Vector encodings = new Vector();</span>

<span class="nc" id="L805">        int size = 0;</span>
<span class="nc" id="L806">        int index = 0;</span>
<span class="nc" id="L807">        AudioFormat.Encoding encs[] = null;</span>

        // gather from all the codecs

<span class="nc bnc" id="L811" title="All 2 branches missed.">        for(int i=0; i&lt;codecs.size(); i++ ) {</span>
<span class="nc" id="L812">            encs = ((FormatConversionProvider) codecs.get(i)).getTargetEncodings(sourceFormat);</span>
<span class="nc" id="L813">            size += encs.length;</span>
<span class="nc" id="L814">            encodings.addElement( encs );</span>
        }

        // now build a new array

<span class="nc" id="L819">        AudioFormat.Encoding encs2[] = new AudioFormat.Encoding[size];</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">        for(int i=0; i&lt;encodings.size(); i++ ) {</span>
<span class="nc" id="L821">            encs = (AudioFormat.Encoding [])(encodings.get(i));</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">            for(int j=0; j&lt;encs.length; j++ ) {</span>
<span class="nc" id="L823">                encs2[index++] = encs[j];</span>
            }
        }
<span class="nc" id="L826">        return encs2;</span>
    }


    /**
     * Indicates whether an audio input stream of the specified encoding
     * can be obtained from an audio input stream that has the specified
     * format.
     * @param targetEncoding the desired encoding after conversion
     * @param sourceFormat the audio format before conversion
     * @return &lt;code&gt;true&lt;/code&gt; if the conversion is supported,
     * otherwise &lt;code&gt;false&lt;/code&gt;
     */
    public static boolean isConversionSupported(AudioFormat.Encoding targetEncoding, AudioFormat sourceFormat) {


<span class="nc" id="L842">        List codecs = getFormatConversionProviders();</span>

<span class="nc bnc" id="L844" title="All 2 branches missed.">        for(int i=0; i&lt;codecs.size(); i++ ) {</span>
<span class="nc" id="L845">            FormatConversionProvider codec = (FormatConversionProvider) codecs.get(i);</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">            if(codec.isConversionSupported(targetEncoding,sourceFormat) ) {</span>
<span class="nc" id="L847">                return true;</span>
            }
        }
<span class="nc" id="L850">        return false;</span>
    }


    /**
     * Obtains an audio input stream of the indicated encoding, by converting the
     * provided audio input stream.
     * @param targetEncoding the desired encoding after conversion
     * @param sourceStream the stream to be converted
     * @return an audio input stream of the indicated encoding
     * @throws IllegalArgumentException if the conversion is not supported
     * @see #getTargetEncodings(AudioFormat.Encoding)
     * @see #getTargetEncodings(AudioFormat)
     * @see #isConversionSupported(AudioFormat.Encoding, AudioFormat)
     * @see #getAudioInputStream(AudioFormat, AudioInputStream)
     */
    public static AudioInputStream getAudioInputStream(AudioFormat.Encoding targetEncoding,
                                                       AudioInputStream sourceStream) {

<span class="nc" id="L869">        List codecs = getFormatConversionProviders();</span>

<span class="nc bnc" id="L871" title="All 2 branches missed.">        for(int i = 0; i &lt; codecs.size(); i++) {</span>
<span class="nc" id="L872">            FormatConversionProvider codec = (FormatConversionProvider) codecs.get(i);</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">            if( codec.isConversionSupported( targetEncoding, sourceStream.getFormat() ) ) {</span>
<span class="nc" id="L874">                return codec.getAudioInputStream( targetEncoding, sourceStream );</span>
            }
        }
        // we ran out of options, throw an exception
<span class="nc" id="L878">        throw new IllegalArgumentException(&quot;Unsupported conversion: &quot; + targetEncoding + &quot; from &quot; + sourceStream.getFormat());</span>
    }


    /**
     * Obtains the formats that have a particular encoding and that the system can
     * obtain from a stream of the specified format using the set of
     * installed format converters.
     * @param targetEncoding the desired encoding after conversion
     * @param sourceFormat the audio format before conversion
     * @return array of formats.  If no formats of the specified
     * encoding are supported, an array of length 0 is returned.
     */
    public static AudioFormat[] getTargetFormats(AudioFormat.Encoding targetEncoding, AudioFormat sourceFormat) {

<span class="nc" id="L893">        List codecs = getFormatConversionProviders();</span>
<span class="nc" id="L894">        Vector formats = new Vector();</span>

<span class="nc" id="L896">        int size = 0;</span>
<span class="nc" id="L897">        int index = 0;</span>
<span class="nc" id="L898">        AudioFormat fmts[] = null;</span>

        // gather from all the codecs

<span class="nc bnc" id="L902" title="All 2 branches missed.">        for(int i=0; i&lt;codecs.size(); i++ ) {</span>
<span class="nc" id="L903">            FormatConversionProvider codec = (FormatConversionProvider) codecs.get(i);</span>
<span class="nc" id="L904">            fmts = codec.getTargetFormats(targetEncoding, sourceFormat);</span>
<span class="nc" id="L905">            size += fmts.length;</span>
<span class="nc" id="L906">            formats.addElement( fmts );</span>
        }

        // now build a new array

<span class="nc" id="L911">        AudioFormat fmts2[] = new AudioFormat[size];</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">        for(int i=0; i&lt;formats.size(); i++ ) {</span>
<span class="nc" id="L913">            fmts = (AudioFormat [])(formats.get(i));</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">            for(int j=0; j&lt;fmts.length; j++ ) {</span>
<span class="nc" id="L915">                fmts2[index++] = fmts[j];</span>
            }
        }
<span class="nc" id="L918">        return fmts2;</span>
    }


    /**
     * Indicates whether an audio input stream of a specified format
     * can be obtained from an audio input stream of another specified format.
     * @param targetFormat the desired audio format after conversion
     * @param sourceFormat the audio format before conversion
     * @return &lt;code&gt;true&lt;/code&gt; if the conversion is supported,
     * otherwise &lt;code&gt;false&lt;/code&gt;
     */

    public static boolean isConversionSupported(AudioFormat targetFormat, AudioFormat sourceFormat) {

<span class="nc" id="L933">        List codecs = getFormatConversionProviders();</span>

<span class="nc bnc" id="L935" title="All 2 branches missed.">        for(int i=0; i&lt;codecs.size(); i++ ) {</span>
<span class="nc" id="L936">            FormatConversionProvider codec = (FormatConversionProvider) codecs.get(i);</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">            if(codec.isConversionSupported(targetFormat, sourceFormat) ) {</span>
<span class="nc" id="L938">                return true;</span>
            }
        }
<span class="nc" id="L941">        return false;</span>
    }


    /**
     * Obtains an audio input stream of the indicated format, by converting the
     * provided audio input stream.
     * @param targetFormat the desired audio format after conversion
     * @param sourceStream the stream to be converted
     * @return an audio input stream of the indicated format
     * @throws IllegalArgumentException if the conversion is not supported
     * #see #getTargetEncodings(AudioFormat)
     * @see #getTargetFormats(AudioFormat.Encoding, AudioFormat)
     * @see #isConversionSupported(AudioFormat, AudioFormat)
     * @see #getAudioInputStream(AudioFormat.Encoding, AudioInputStream)
     */
    public static AudioInputStream getAudioInputStream(AudioFormat targetFormat,
                                                       AudioInputStream sourceStream) {

<span class="nc bnc" id="L960" title="All 2 branches missed.">        if (sourceStream.getFormat().matches(targetFormat)) {</span>
<span class="nc" id="L961">            return sourceStream;</span>
        }

<span class="nc" id="L964">        List codecs = getFormatConversionProviders();</span>

<span class="nc bnc" id="L966" title="All 2 branches missed.">        for(int i = 0; i &lt; codecs.size(); i++) {</span>
<span class="nc" id="L967">            FormatConversionProvider codec = (FormatConversionProvider) codecs.get(i);</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">            if(codec.isConversionSupported(targetFormat,sourceStream.getFormat()) ) {</span>
<span class="nc" id="L969">                return codec.getAudioInputStream(targetFormat,sourceStream);</span>
            }
        }

        // we ran out of options...
<span class="nc" id="L974">        throw new IllegalArgumentException(&quot;Unsupported conversion: &quot; + targetFormat + &quot; from &quot; + sourceStream.getFormat());</span>
    }


    /**
     * Obtains the audio file format of the provided input stream.  The stream must
     * point to valid audio file data.  The implementation of this method may require
     * multiple parsers to examine the stream to determine whether they support it.
     * These parsers must be able to mark the stream, read enough data to determine whether they
     * support the stream, and, if not, reset the stream's read pointer to its original
     * position.  If the input stream does not support these operations, this method may fail
     * with an &lt;code&gt;IOException&lt;/code&gt;.
     * @param stream the input stream from which file format information should be
     * extracted
     * @return an &lt;code&gt;AudioFileFormat&lt;/code&gt; object describing the stream's audio file format
     * @throws UnsupportedAudioFileException if the stream does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an input/output exception occurs
     * @see InputStream#markSupported
     * @see InputStream#mark
     */
    public static AudioFileFormat getAudioFileFormat(InputStream stream)
        throws UnsupportedAudioFileException, IOException {

<span class="nc" id="L998">        List providers = getAudioFileReaders();</span>
<span class="nc" id="L999">        AudioFileFormat format = null;</span>

<span class="nc bnc" id="L1001" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++ ) {</span>
<span class="nc" id="L1002">            AudioFileReader reader = (AudioFileReader) providers.get(i);</span>
            try {
<span class="nc" id="L1004">                format = reader.getAudioFileFormat( stream ); // throws IOException</span>
<span class="nc" id="L1005">                break;</span>
<span class="nc" id="L1006">            } catch (UnsupportedAudioFileException e) {</span>
<span class="nc" id="L1007">                continue;</span>
            }
        }

<span class="nc bnc" id="L1011" title="All 2 branches missed.">        if( format==null ) {</span>
<span class="nc" id="L1012">            throw new UnsupportedAudioFileException(&quot;file is not a supported file type&quot;);</span>
        } else {
<span class="nc" id="L1014">            return format;</span>
        }
    }

    /**
     * Obtains the audio file format of the specified URL.  The URL must
     * point to valid audio file data.
     * @param url the URL from which file format information should be
     * extracted
     * @return an &lt;code&gt;AudioFileFormat&lt;/code&gt; object describing the audio file format
     * @throws UnsupportedAudioFileException if the URL does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an input/output exception occurs
     */
    public static AudioFileFormat getAudioFileFormat(URL url)
        throws UnsupportedAudioFileException, IOException {

<span class="nc" id="L1031">        List providers = getAudioFileReaders();</span>
<span class="nc" id="L1032">        AudioFileFormat format = null;</span>

<span class="nc bnc" id="L1034" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++ ) {</span>
<span class="nc" id="L1035">            AudioFileReader reader = (AudioFileReader) providers.get(i);</span>
            try {
<span class="nc" id="L1037">                format = reader.getAudioFileFormat( url ); // throws IOException</span>
<span class="nc" id="L1038">                break;</span>
<span class="nc" id="L1039">            } catch (UnsupportedAudioFileException e) {</span>
<span class="nc" id="L1040">                continue;</span>
            }
        }

<span class="nc bnc" id="L1044" title="All 2 branches missed.">        if( format==null ) {</span>
<span class="nc" id="L1045">            throw new UnsupportedAudioFileException(&quot;file is not a supported file type&quot;);</span>
        } else {
<span class="nc" id="L1047">            return format;</span>
        }
    }

    /**
     * Obtains the audio file format of the specified &lt;code&gt;File&lt;/code&gt;.  The &lt;code&gt;File&lt;/code&gt; must
     * point to valid audio file data.
     * @param file the &lt;code&gt;File&lt;/code&gt; from which file format information should be
     * extracted
     * @return an &lt;code&gt;AudioFileFormat&lt;/code&gt; object describing the audio file format
     * @throws UnsupportedAudioFileException if the &lt;code&gt;File&lt;/code&gt; does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public static AudioFileFormat getAudioFileFormat(File file)
        throws UnsupportedAudioFileException, IOException {

<span class="nc" id="L1064">        List providers = getAudioFileReaders();</span>
<span class="nc" id="L1065">        AudioFileFormat format = null;</span>

<span class="nc bnc" id="L1067" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++ ) {</span>
<span class="nc" id="L1068">            AudioFileReader reader = (AudioFileReader) providers.get(i);</span>
            try {
<span class="nc" id="L1070">                format = reader.getAudioFileFormat( file ); // throws IOException</span>
<span class="nc" id="L1071">                break;</span>
<span class="nc" id="L1072">            } catch (UnsupportedAudioFileException e) {</span>
<span class="nc" id="L1073">                continue;</span>
            }
        }

<span class="nc bnc" id="L1077" title="All 2 branches missed.">        if( format==null ) {</span>
<span class="nc" id="L1078">            throw new UnsupportedAudioFileException(&quot;file is not a supported file type&quot;);</span>
        } else {
<span class="nc" id="L1080">            return format;</span>
        }
    }


    /**
     * Obtains an audio input stream from the provided input stream.  The stream must
     * point to valid audio file data.  The implementation of this method may
     * require multiple parsers to
     * examine the stream to determine whether they support it.  These parsers must
     * be able to mark the stream, read enough data to determine whether they
     * support the stream, and, if not, reset the stream's read pointer to its original
     * position.  If the input stream does not support these operation, this method may fail
     * with an &lt;code&gt;IOException&lt;/code&gt;.
     * @param stream the input stream from which the &lt;code&gt;AudioInputStream&lt;/code&gt; should be
     * constructed
     * @return an &lt;code&gt;AudioInputStream&lt;/code&gt; object based on the audio file data contained
     * in the input stream.
     * @throws UnsupportedAudioFileException if the stream does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     * @see InputStream#markSupported
     * @see InputStream#mark
     */
    public static AudioInputStream getAudioInputStream(InputStream stream)
        throws UnsupportedAudioFileException, IOException {

<span class="nc" id="L1107">        List providers = getAudioFileReaders();</span>
<span class="nc" id="L1108">        AudioInputStream audioStream = null;</span>

<span class="nc bnc" id="L1110" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++ ) {</span>
<span class="nc" id="L1111">            AudioFileReader reader = (AudioFileReader) providers.get(i);</span>
            try {
<span class="nc" id="L1113">                audioStream = reader.getAudioInputStream( stream ); // throws IOException</span>
<span class="nc" id="L1114">                break;</span>
<span class="nc" id="L1115">            } catch (UnsupportedAudioFileException e) {</span>
<span class="nc" id="L1116">                continue;</span>
            }
        }

<span class="nc bnc" id="L1120" title="All 2 branches missed.">        if( audioStream==null ) {</span>
<span class="nc" id="L1121">            throw new UnsupportedAudioFileException(&quot;could not get audio input stream from input stream&quot;);</span>
        } else {
<span class="nc" id="L1123">            return audioStream;</span>
        }
    }

    /**
     * Obtains an audio input stream from the URL provided.  The URL must
     * point to valid audio file data.
     * @param url the URL for which the &lt;code&gt;AudioInputStream&lt;/code&gt; should be
     * constructed
     * @return an &lt;code&gt;AudioInputStream&lt;/code&gt; object based on the audio file data pointed
     * to by the URL
     * @throws UnsupportedAudioFileException if the URL does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public static AudioInputStream getAudioInputStream(URL url)
        throws UnsupportedAudioFileException, IOException {

<span class="nc" id="L1141">        List providers = getAudioFileReaders();</span>
<span class="nc" id="L1142">        AudioInputStream audioStream = null;</span>

<span class="nc bnc" id="L1144" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++ ) {</span>
<span class="nc" id="L1145">            AudioFileReader reader = (AudioFileReader) providers.get(i);</span>
            try {
<span class="nc" id="L1147">                audioStream = reader.getAudioInputStream( url ); // throws IOException</span>
<span class="nc" id="L1148">                break;</span>
<span class="nc" id="L1149">            } catch (UnsupportedAudioFileException e) {</span>
<span class="nc" id="L1150">                continue;</span>
            }
        }

<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if( audioStream==null ) {</span>
<span class="nc" id="L1155">            throw new UnsupportedAudioFileException(&quot;could not get audio input stream from input URL&quot;);</span>
        } else {
<span class="nc" id="L1157">            return audioStream;</span>
        }
    }

    /**
     * Obtains an audio input stream from the provided &lt;code&gt;File&lt;/code&gt;.  The &lt;code&gt;File&lt;/code&gt; must
     * point to valid audio file data.
     * @param file the &lt;code&gt;File&lt;/code&gt; for which the &lt;code&gt;AudioInputStream&lt;/code&gt; should be
     * constructed
     * @return an &lt;code&gt;AudioInputStream&lt;/code&gt; object based on the audio file data pointed
     * to by the &lt;code&gt;File&lt;/code&gt;
     * @throws UnsupportedAudioFileException if the &lt;code&gt;File&lt;/code&gt; does not point to valid audio
     * file data recognized by the system
     * @throws IOException if an I/O exception occurs
     */
    public static AudioInputStream getAudioInputStream(File file)
        throws UnsupportedAudioFileException, IOException {

<span class="nc" id="L1175">        List providers = getAudioFileReaders();</span>
<span class="nc" id="L1176">        AudioInputStream audioStream = null;</span>

<span class="nc bnc" id="L1178" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++ ) {</span>
<span class="nc" id="L1179">            AudioFileReader reader = (AudioFileReader) providers.get(i);</span>
            try {
<span class="nc" id="L1181">                audioStream = reader.getAudioInputStream( file ); // throws IOException</span>
<span class="nc" id="L1182">                break;</span>
<span class="nc" id="L1183">            } catch (UnsupportedAudioFileException e) {</span>
<span class="nc" id="L1184">                continue;</span>
            }
        }

<span class="nc bnc" id="L1188" title="All 2 branches missed.">        if( audioStream==null ) {</span>
<span class="nc" id="L1189">            throw new UnsupportedAudioFileException(&quot;could not get audio input stream from input file&quot;);</span>
        } else {
<span class="nc" id="L1191">            return audioStream;</span>
        }
    }


    /**
     * Obtains the file types for which file writing support is provided by the system.
     * @return array of unique file types.  If no file types are supported,
     * an array of length 0 is returned.
     */
    public static AudioFileFormat.Type[] getAudioFileTypes() {
<span class="nc" id="L1202">        List providers = getAudioFileWriters();</span>
<span class="nc" id="L1203">        Set returnTypesSet = new HashSet();</span>

<span class="nc bnc" id="L1205" title="All 2 branches missed.">        for(int i=0; i &lt; providers.size(); i++) {</span>
<span class="nc" id="L1206">            AudioFileWriter writer = (AudioFileWriter) providers.get(i);</span>
<span class="nc" id="L1207">            AudioFileFormat.Type[] fileTypes = writer.getAudioFileTypes();</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">            for(int j=0; j &lt; fileTypes.length; j++) {</span>
<span class="nc" id="L1209">                returnTypesSet.add(fileTypes[j]);</span>
            }
        }
<span class="nc" id="L1212">        AudioFileFormat.Type returnTypes[] = (AudioFileFormat.Type[])</span>
<span class="nc" id="L1213">            returnTypesSet.toArray(new AudioFileFormat.Type[0]);</span>
<span class="nc" id="L1214">        return returnTypes;</span>
    }


    /**
     * Indicates whether file writing support for the specified file type is provided
     * by the system.
     * @param fileType the file type for which write capabilities are queried
     * @return &lt;code&gt;true&lt;/code&gt; if the file type is supported,
     * otherwise &lt;code&gt;false&lt;/code&gt;
     */
    public static boolean isFileTypeSupported(AudioFileFormat.Type fileType) {

<span class="nc" id="L1227">        List providers = getAudioFileWriters();</span>

<span class="nc bnc" id="L1229" title="All 2 branches missed.">        for(int i=0; i &lt; providers.size(); i++) {</span>
<span class="nc" id="L1230">            AudioFileWriter writer = (AudioFileWriter) providers.get(i);</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            if (writer.isFileTypeSupported(fileType)) {</span>
<span class="nc" id="L1232">                return true;</span>
            }
        }
<span class="nc" id="L1235">        return false;</span>
    }


    /**
     * Obtains the file types that the system can write from the
     * audio input stream specified.
     * @param stream the audio input stream for which audio file type support
     * is queried
     * @return array of file types.  If no file types are supported,
     * an array of length 0 is returned.
     */
    public static AudioFileFormat.Type[] getAudioFileTypes(AudioInputStream stream) {
<span class="nc" id="L1248">        List providers = getAudioFileWriters();</span>
<span class="nc" id="L1249">        Set returnTypesSet = new HashSet();</span>

<span class="nc bnc" id="L1251" title="All 2 branches missed.">        for(int i=0; i &lt; providers.size(); i++) {</span>
<span class="nc" id="L1252">            AudioFileWriter writer = (AudioFileWriter) providers.get(i);</span>
<span class="nc" id="L1253">            AudioFileFormat.Type[] fileTypes = writer.getAudioFileTypes(stream);</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">            for(int j=0; j &lt; fileTypes.length; j++) {</span>
<span class="nc" id="L1255">                returnTypesSet.add(fileTypes[j]);</span>
            }
        }
<span class="nc" id="L1258">        AudioFileFormat.Type returnTypes[] = (AudioFileFormat.Type[])</span>
<span class="nc" id="L1259">            returnTypesSet.toArray(new AudioFileFormat.Type[0]);</span>
<span class="nc" id="L1260">        return returnTypes;</span>
    }


    /**
     * Indicates whether an audio file of the specified file type can be written
     * from the indicated audio input stream.
     * @param fileType the file type for which write capabilities are queried
     * @param stream the stream for which file-writing support is queried
     * @return &lt;code&gt;true&lt;/code&gt; if the file type is supported for this audio input stream,
     * otherwise &lt;code&gt;false&lt;/code&gt;
     */
    public static boolean isFileTypeSupported(AudioFileFormat.Type fileType,
                                              AudioInputStream stream) {

<span class="nc" id="L1275">        List providers = getAudioFileWriters();</span>

<span class="nc bnc" id="L1277" title="All 2 branches missed.">        for(int i=0; i &lt; providers.size(); i++) {</span>
<span class="nc" id="L1278">            AudioFileWriter writer = (AudioFileWriter) providers.get(i);</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">            if(writer.isFileTypeSupported(fileType, stream)) {</span>
<span class="nc" id="L1280">                return true;</span>
            }
        }
<span class="nc" id="L1283">        return false;</span>
    }


    /**
     * Writes a stream of bytes representing an audio file of the specified file type
     * to the output stream provided.  Some file types require that
     * the length be written into the file header; such files cannot be written from
     * start to finish unless the length is known in advance.  An attempt
     * to write a file of such a type will fail with an IOException if the length in
     * the audio file type is &lt;code&gt;AudioSystem.NOT_SPECIFIED&lt;/code&gt;.
     *
     * @param stream the audio input stream containing audio data to be
     * written to the file
     * @param fileType the kind of audio file to write
     * @param out the stream to which the file data should be written
     * @return the number of bytes written to the output stream
     * @throws IOException if an input/output exception occurs
     * @throws IllegalArgumentException if the file type is not supported by
     * the system
     * @see #isFileTypeSupported
     * @see     #getAudioFileTypes
     */
    public static int write(AudioInputStream stream, AudioFileFormat.Type fileType,
                            OutputStream out) throws IOException {

<span class="nc" id="L1309">        List providers = getAudioFileWriters();</span>
<span class="nc" id="L1310">        int bytesWritten = 0;</span>
<span class="nc" id="L1311">        boolean flag = false;</span>

<span class="nc bnc" id="L1313" title="All 2 branches missed.">        for(int i=0; i &lt; providers.size(); i++) {</span>
<span class="nc" id="L1314">            AudioFileWriter writer = (AudioFileWriter) providers.get(i);</span>
            try {
<span class="nc" id="L1316">                bytesWritten = writer.write( stream, fileType, out ); // throws IOException</span>
<span class="nc" id="L1317">                flag = true;</span>
<span class="nc" id="L1318">                break;</span>
<span class="nc" id="L1319">            } catch (IllegalArgumentException e) {</span>
                // thrown if this provider cannot write the sequence, try the next
<span class="nc" id="L1321">                continue;</span>
            }
        }
<span class="nc bnc" id="L1324" title="All 2 branches missed.">        if(!flag) {</span>
<span class="nc" id="L1325">            throw new IllegalArgumentException(&quot;could not write audio file: file type not supported: &quot; + fileType);</span>
        } else {
<span class="nc" id="L1327">            return bytesWritten;</span>
        }
    }


    /**
     * Writes a stream of bytes representing an audio file of the specified file type
     * to the external file provided.
     * @param stream the audio input stream containing audio data to be
     * written to the file
     * @param fileType the kind of audio file to write
     * @param out the external file to which the file data should be written
     * @return the number of bytes written to the file
     * @throws IOException if an I/O exception occurs
     * @throws IllegalArgumentException if the file type is not supported by
     * the system
     * @see #isFileTypeSupported
     * @see     #getAudioFileTypes
     */
    public static int write(AudioInputStream stream, AudioFileFormat.Type fileType,
                            File out) throws IOException {

<span class="nc" id="L1349">        List providers = getAudioFileWriters();</span>
<span class="nc" id="L1350">        int bytesWritten = 0;</span>
<span class="nc" id="L1351">        boolean flag = false;</span>

<span class="nc bnc" id="L1353" title="All 2 branches missed.">        for(int i=0; i &lt; providers.size(); i++) {</span>
<span class="nc" id="L1354">            AudioFileWriter writer = (AudioFileWriter) providers.get(i);</span>
            try {
<span class="nc" id="L1356">                bytesWritten = writer.write( stream, fileType, out ); // throws IOException</span>
<span class="nc" id="L1357">                flag = true;</span>
<span class="nc" id="L1358">                break;</span>
<span class="nc" id="L1359">            } catch (IllegalArgumentException e) {</span>
                // thrown if this provider cannot write the sequence, try the next
<span class="nc" id="L1361">                continue;</span>
            }
        }
<span class="nc bnc" id="L1364" title="All 2 branches missed.">        if (!flag) {</span>
<span class="nc" id="L1365">            throw new IllegalArgumentException(&quot;could not write audio file: file type not supported: &quot; + fileType);</span>
        } else {
<span class="nc" id="L1367">            return bytesWritten;</span>
        }
    }


    // METHODS FOR INTERNAL IMPLEMENTATION USE

    /**
     * Obtains the set of MixerProviders on the system.
     */
    private static List getMixerProviders() {
<span class="nc" id="L1378">        return getProviders(MixerProvider.class);</span>
    }


    /**
     * Obtains the set of format converters (codecs, transcoders, etc.)
     * that are currently installed on the system.
     * @return an array of
     * {@link javax.sound.sampled.spi.FormatConversionProvider
     * FormatConversionProvider}
     * objects representing the available format converters.  If no format
     * converters readers are available on the system, an array of length 0 is
     * returned.
     */
    private static List getFormatConversionProviders() {
<span class="nc" id="L1393">        return getProviders(FormatConversionProvider.class);</span>
    }


    /**
     * Obtains the set of audio file readers that are currently installed on the system.
     * @return a List of
     * {@link javax.sound.sampled.spi.AudioFileReader
     * AudioFileReader}
     * objects representing the installed audio file readers.  If no audio file
     * readers are available on the system, an empty List is returned.
     */
    private static List getAudioFileReaders() {
<span class="nc" id="L1406">        return getProviders(AudioFileReader.class);</span>
    }


    /**
     * Obtains the set of audio file writers that are currently installed on the system.
     * @return a List of
     * {@link javax.sound.samples.spi.AudioFileWriter AudioFileWriter}
     * objects representing the available audio file writers.  If no audio file
     * writers are available on the system, an empty List is returned.
     */
    private static List getAudioFileWriters() {
<span class="nc" id="L1418">        return getProviders(AudioFileWriter.class);</span>
    }



    /** Attempts to locate and return a default Mixer that provides lines
     * of the specified type.
     *
     * @param providers the installed mixer providers
     * @param info The requested line type
     * TargetDataLine.class, Clip.class or Port.class.
     * @return a Mixer that matches the requirements, or null if no default mixer found
     */
    private static Mixer getDefaultMixer(List providers, Line.Info info) {
<span class="nc" id="L1432">        Class lineClass = info.getLineClass();</span>
<span class="nc" id="L1433">        String providerClassName = JDK13Services.getDefaultProviderClassName(lineClass);</span>
<span class="nc" id="L1434">        String instanceName = JDK13Services.getDefaultInstanceName(lineClass);</span>
        Mixer mixer;

<span class="nc bnc" id="L1437" title="All 2 branches missed.">        if (providerClassName != null) {</span>
<span class="nc" id="L1438">            MixerProvider defaultProvider = getNamedProvider(providerClassName, providers);</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">            if (defaultProvider != null) {</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">                if (instanceName != null) {</span>
<span class="nc" id="L1441">                    mixer = getNamedMixer(instanceName, defaultProvider, info);</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">                    if (mixer != null) {</span>
<span class="nc" id="L1443">                        return mixer;</span>
                    }
                } else {
<span class="nc" id="L1446">                    mixer = getFirstMixer(defaultProvider, info,</span>
                                          false /* mixing not required*/);
<span class="nc bnc" id="L1448" title="All 2 branches missed.">                    if (mixer != null) {</span>
<span class="nc" id="L1449">                        return mixer;</span>
                    }
                }

            }
        }

        /* Provider class not specified or
           provider class cannot be found, or
           provider class and instance specified and instance cannot be found or is not appropriate */
<span class="nc bnc" id="L1459" title="All 2 branches missed.">        if (instanceName != null) {</span>
<span class="nc" id="L1460">            mixer = getNamedMixer(instanceName, providers, info);</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">            if (mixer != null) {</span>
<span class="nc" id="L1462">                return mixer;</span>
            }
        }


        /* No default are specified, or if something is specified, everything
           failed. */
<span class="nc" id="L1469">        return null;</span>
    }



    /** Return a MixerProvider of a given class from the list of
        MixerProviders.

        This method never requires the returned Mixer to do mixing.
        @param providerClassName The class name of the provider to be returned.
        @param providers The list of MixerProviders that is searched.
        @return A MixerProvider of the requested class, or null if none is
        found.
     */
    private static MixerProvider getNamedProvider(String providerClassName,
                                                  List providers) {
<span class="nc bnc" id="L1485" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++) {</span>
<span class="nc" id="L1486">            MixerProvider provider = (MixerProvider) providers.get(i);</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">            if (provider.getClass().getName().equals(providerClassName)) {</span>
<span class="nc" id="L1488">                return provider;</span>
            }
        }
<span class="nc" id="L1491">        return null;</span>
    }


    /** Return a Mixer with a given name from a given MixerProvider.
      This method never requires the returned Mixer to do mixing.
      @param mixerName The name of the Mixer to be returned.
      @param provider The MixerProvider to check for Mixers.
      @param info The type of line the returned Mixer is required to
      support.

      @return A Mixer matching the requirements, or null if none is found.
     */
    private static Mixer getNamedMixer(String mixerName,
                                       MixerProvider provider,
                                       Line.Info info) {
<span class="nc" id="L1507">        Mixer.Info[] infos = provider.getMixerInfo();</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">        for (int i = 0; i &lt; infos.length; i++) {</span>
<span class="nc bnc" id="L1509" title="All 2 branches missed.">            if (infos[i].getName().equals(mixerName)) {</span>
<span class="nc" id="L1510">                Mixer mixer = provider.getMixer(infos[i]);</span>
<span class="nc bnc" id="L1511" title="All 2 branches missed.">                if (isAppropriateMixer(mixer, info, false)) {</span>
<span class="nc" id="L1512">                    return mixer;</span>
                }
            }
        }
<span class="nc" id="L1516">        return null;</span>
    }


    /** From a List of MixerProviders, return a Mixer with a given name.
        This method never requires the returned Mixer to do mixing.
        @param mixerName The name of the Mixer to be returned.
        @param providers The List of MixerProviders to check for Mixers.
        @param info The type of line the returned Mixer is required to
        support.
        @return A Mixer matching the requirements, or null if none is found.
     */
    private static Mixer getNamedMixer(String mixerName,
                                       List providers,
                                       Line.Info info) {
<span class="nc bnc" id="L1531" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++) {</span>
<span class="nc" id="L1532">            MixerProvider provider = (MixerProvider) providers.get(i);</span>
<span class="nc" id="L1533">            Mixer mixer = getNamedMixer(mixerName, provider, info);</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">            if (mixer != null) {</span>
<span class="nc" id="L1535">                return mixer;</span>
            }
        }
<span class="nc" id="L1538">        return null;</span>
    }


    /** From a given MixerProvider, return the first appropriate Mixer.
        @param provider The MixerProvider to check for Mixers.
        @param info The type of line the returned Mixer is required to
        support.
        @param isMixingRequired If true, only Mixers that support mixing are
        returned for line types of SourceDataLine and Clip.

        @return A Mixer that is considered appropriate, or null
        if none is found.
     */
    private static Mixer getFirstMixer(MixerProvider provider,
                                       Line.Info info,
                                       boolean isMixingRequired) {
<span class="nc" id="L1555">        Mixer.Info[] infos = provider.getMixerInfo();</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">        for (int j = 0; j &lt; infos.length; j++) {</span>
<span class="nc" id="L1557">            Mixer mixer = provider.getMixer(infos[j]);</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">            if (isAppropriateMixer(mixer, info, isMixingRequired)) {</span>
<span class="nc" id="L1559">                return mixer;</span>
            }
        }
<span class="nc" id="L1562">        return null;</span>
    }


    /** Checks if a Mixer is appropriate.
        A Mixer is considered appropriate if it support the given line type.
        If isMixingRequired is true and the line type is an output one
        (SourceDataLine, Clip), the mixer is appropriate if it supports
        at least 2 (concurrent) lines of the given type.

        @return true if the mixer is considered appropriate according to the
        rules given above, false otherwise.
     */
    private static boolean isAppropriateMixer(Mixer mixer,
                                              Line.Info lineInfo,
                                              boolean isMixingRequired) {
<span class="nc bnc" id="L1578" title="All 2 branches missed.">        if (! mixer.isLineSupported(lineInfo)) {</span>
<span class="nc" id="L1579">            return false;</span>
        }
<span class="nc" id="L1581">        Class lineClass = lineInfo.getLineClass();</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">        if (isMixingRequired</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">            &amp;&amp; (SourceDataLine.class.isAssignableFrom(lineClass) ||</span>
<span class="nc bnc" id="L1584" title="All 2 branches missed.">                Clip.class.isAssignableFrom(lineClass))) {</span>
<span class="nc" id="L1585">            int maxLines = mixer.getMaxLines(lineInfo);</span>
<span class="nc bnc" id="L1586" title="All 4 branches missed.">            return ((maxLines == NOT_SPECIFIED) || (maxLines &gt; 1));</span>
        }
<span class="nc" id="L1588">        return true;</span>
    }



    /**
     * Like getMixerInfo, but return List
     */
    private static List getMixerInfoList() {
<span class="nc" id="L1597">        List providers = getMixerProviders();</span>
<span class="nc" id="L1598">        return getMixerInfoList(providers);</span>
    }


    /**
     * Like getMixerInfo, but return List
     */
    private static List getMixerInfoList(List providers) {
<span class="nc" id="L1606">        List infos = new ArrayList();</span>

        Mixer.Info[] someInfos; // per-mixer
        Mixer.Info[] allInfos;  // for all mixers

<span class="nc bnc" id="L1611" title="All 2 branches missed.">        for(int i = 0; i &lt; providers.size(); i++ ) {</span>
<span class="nc" id="L1612">            someInfos = (Mixer.Info[])</span>
<span class="nc" id="L1613">                ((MixerProvider)providers.get(i)).getMixerInfo();</span>

<span class="nc bnc" id="L1615" title="All 2 branches missed.">            for (int j = 0; j &lt; someInfos.length; j++) {</span>
<span class="nc" id="L1616">                infos.add(someInfos[j]);</span>
            }
        }

<span class="nc" id="L1620">        return infos;</span>
    }


    /**
     * Obtains the set of services currently installed on the system
     * using sun.misc.Service, the SPI mechanism in 1.3.
     * @return a List of instances of providers for the requested service.
     * If no providers are available, a vector of length 0 will be returned.
     */
    private static List getProviders(Class providerClass) {
<span class="nc" id="L1631">        return JDK13Services.getProviders(providerClass);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>