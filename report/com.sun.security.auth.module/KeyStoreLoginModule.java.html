<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>KeyStoreLoginModule.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.security.auth.module</a> &gt; <span class="el_source">KeyStoreLoginModule.java</span></div><h1>KeyStoreLoginModule.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.security.auth.module;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.*;
import java.security.cert.*;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.*;
import javax.security.auth.Destroyable;
import javax.security.auth.DestroyFailedException;
import javax.security.auth.Subject;
import javax.security.auth.x500.*;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.ConfirmationCallback;
import javax.security.auth.callback.NameCallback;
import javax.security.auth.callback.PasswordCallback;
import javax.security.auth.callback.TextOutputCallback;
import javax.security.auth.callback.UnsupportedCallbackException;
import javax.security.auth.login.FailedLoginException;
import javax.security.auth.login.LoginException;
import javax.security.auth.spi.LoginModule;

import sun.security.util.Password;

/**
 * Provides a JAAS login module that prompts for a key store alias and
 * populates the subject with the alias's principal and credentials. Stores
 * an &lt;code&gt;X500Principal&lt;/code&gt; for the subject distinguished name of the
 * first certificate in the alias's credentials in the subject's principals,
 * the alias's certificate path in the subject's public credentials, and a
 * &lt;code&gt;X500PrivateCredential&lt;/code&gt; whose certificate is the first
 * certificate in the alias's certificate path and whose private key is the
 * alias's private key in the subject's private credentials. &lt;p&gt;
 *
 * Recognizes the following options in the configuration file:
 * &lt;dl&gt;
 *
 * &lt;dt&gt; &lt;code&gt;keyStoreURL&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; A URL that specifies the location of the key store.  Defaults to
 *      a URL pointing to the .keystore file in the directory specified by the
 *      &lt;code&gt;user.home&lt;/code&gt; system property.  The input stream from this
 *      URL is passed to the &lt;code&gt;KeyStore.load&lt;/code&gt; method.
 *      &quot;NONE&quot; may be specified if a &lt;code&gt;null&lt;/code&gt; stream must be
 *      passed to the &lt;code&gt;KeyStore.load&lt;/code&gt; method.
 *      &quot;NONE&quot; should be specified if the KeyStore resides
 *      on a hardware token device, for example.&lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;keyStoreType&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; The key store type.  If not specified, defaults to the result of
 *      calling &lt;code&gt;KeyStore.getDefaultType()&lt;/code&gt;.
 *      If the type is &quot;PKCS11&quot;, then keyStoreURL must be &quot;NONE&quot;
 *      and privateKeyPasswordURL must not be specified.&lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;keyStoreProvider&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; The key store provider.  If not specified, uses the standard search
 *      order to find the provider. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;keyStoreAlias&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; The alias in the key store to login as.  Required when no callback
 *      handler is provided.  No default value. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;keyStorePasswordURL&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; A URL that specifies the location of the key store password.  Required
 *      when no callback handler is provided and
 *      &lt;code&gt;protected&lt;/code&gt; is false.
 *      No default value. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;privateKeyPasswordURL&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; A URL that specifies the location of the specific private key password
 *      needed to access the private key for this alias.
 *      The keystore password
 *      is used if this value is needed and not specified. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;protected&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; This value should be set to &quot;true&quot; if the KeyStore
 *      has a separate, protected authentication path
 *      (for example, a dedicated PIN-pad attached to a smart card).
 *      Defaults to &quot;false&quot;. If &quot;true&quot; keyStorePasswordURL and
 *      privateKeyPasswordURL must not be specified.&lt;/dd&gt;
 *
 * &lt;/dl&gt;
 */
@jdk.Exported
<span class="fc" id="L114">public class KeyStoreLoginModule implements LoginModule {</span>

<span class="fc" id="L116">    private static final ResourceBundle rb = AccessController.doPrivileged(</span>
<span class="fc" id="L117">            new PrivilegedAction&lt;ResourceBundle&gt;() {</span>
                public ResourceBundle run() {
<span class="fc" id="L119">                    return ResourceBundle.getBundle(</span>
                            &quot;sun.security.util.AuthResources&quot;);
                }
            }
    );

    /* -- Fields -- */

    private static final int UNINITIALIZED = 0;
    private static final int INITIALIZED = 1;
    private static final int AUTHENTICATED = 2;
    private static final int LOGGED_IN = 3;

    private static final int PROTECTED_PATH = 0;
    private static final int TOKEN = 1;
    private static final int NORMAL = 2;

    private static final String NONE = &quot;NONE&quot;;
    private static final String P11KEYSTORE = &quot;PKCS11&quot;;

<span class="fc" id="L139">    private static final TextOutputCallback bannerCallback =</span>
                new TextOutputCallback
                        (TextOutputCallback.INFORMATION,
<span class="fc" id="L142">                        rb.getString(&quot;Please.enter.keystore.information&quot;));</span>
<span class="fc" id="L143">    private final ConfirmationCallback confirmationCallback =</span>
                new ConfirmationCallback
                        (ConfirmationCallback.INFORMATION,
                        ConfirmationCallback.OK_CANCEL_OPTION,
                        ConfirmationCallback.OK);

    private Subject subject;
    private CallbackHandler callbackHandler;
    private Map&lt;String, Object&gt; sharedState;
    private Map&lt;String, ?&gt; options;

    private char[] keyStorePassword;
    private char[] privateKeyPassword;
    private KeyStore keyStore;

    private String keyStoreURL;
    private String keyStoreType;
    private String keyStoreProvider;
    private String keyStoreAlias;
    private String keyStorePasswordURL;
    private String privateKeyPasswordURL;
    private boolean debug;
    private javax.security.auth.x500.X500Principal principal;
    private Certificate[] fromKeyStore;
<span class="fc" id="L167">    private java.security.cert.CertPath certP = null;</span>
    private X500PrivateCredential privateCredential;
<span class="fc" id="L169">    private int status = UNINITIALIZED;</span>
<span class="fc" id="L170">    private boolean nullStream = false;</span>
<span class="fc" id="L171">    private boolean token = false;</span>
<span class="fc" id="L172">    private boolean protectedPath = false;</span>

    /* -- Methods -- */

    /**
     * Initialize this &lt;code&gt;LoginModule&lt;/code&gt;.
     *
     * &lt;p&gt;
     *
     * @param subject the &lt;code&gt;Subject&lt;/code&gt; to be authenticated. &lt;p&gt;
     *
     * @param callbackHandler a &lt;code&gt;CallbackHandler&lt;/code&gt; for communicating
     *                  with the end user (prompting for usernames and
     *                  passwords, for example),
     *                  which may be &lt;code&gt;null&lt;/code&gt;. &lt;p&gt;
     *
     * @param sharedState shared &lt;code&gt;LoginModule&lt;/code&gt; state. &lt;p&gt;
     *
     * @param options options specified in the login
     *                  &lt;code&gt;Configuration&lt;/code&gt; for this particular
     *                  &lt;code&gt;LoginModule&lt;/code&gt;.
     */
    // Unchecked warning from (Map&lt;String, Object&gt;)sharedState is safe
    // since javax.security.auth.login.LoginContext passes a raw HashMap.
    @SuppressWarnings(&quot;unchecked&quot;)
    public void initialize(Subject subject,
                           CallbackHandler callbackHandler,
                           Map&lt;String,?&gt; sharedState,
                           Map&lt;String,?&gt; options)
    {
<span class="fc" id="L202">        this.subject = subject;</span>
<span class="fc" id="L203">        this.callbackHandler = callbackHandler;</span>
<span class="fc" id="L204">        this.sharedState = (Map&lt;String, Object&gt;)sharedState;</span>
<span class="fc" id="L205">        this.options = options;</span>

<span class="fc" id="L207">        processOptions();</span>
<span class="fc" id="L208">        status = INITIALIZED;</span>
<span class="fc" id="L209">    }</span>

    private void processOptions() {
<span class="fc" id="L212">        keyStoreURL = (String) options.get(&quot;keyStoreURL&quot;);</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (keyStoreURL == null) {</span>
<span class="fc" id="L214">            keyStoreURL =</span>
                &quot;file:&quot; +
<span class="fc" id="L216">                System.getProperty(&quot;user.home&quot;).replace(</span>
                    File.separatorChar, '/') +
                '/' + &quot;.keystore&quot;;
<span class="fc bfc" id="L219" title="All 2 branches covered.">        } else if (NONE.equals(keyStoreURL)) {</span>
<span class="fc" id="L220">            nullStream = true;</span>
        }
<span class="fc" id="L222">        keyStoreType = (String) options.get(&quot;keyStoreType&quot;);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (keyStoreType == null) {</span>
<span class="fc" id="L224">            keyStoreType = KeyStore.getDefaultType();</span>
        }
<span class="fc bfc" id="L226" title="All 2 branches covered.">        if (P11KEYSTORE.equalsIgnoreCase(keyStoreType)) {</span>
<span class="fc" id="L227">            token = true;</span>
        }

<span class="fc" id="L230">        keyStoreProvider = (String) options.get(&quot;keyStoreProvider&quot;);</span>

<span class="fc" id="L232">        keyStoreAlias = (String) options.get(&quot;keyStoreAlias&quot;);</span>

<span class="fc" id="L234">        keyStorePasswordURL = (String) options.get(&quot;keyStorePasswordURL&quot;);</span>

<span class="fc" id="L236">        privateKeyPasswordURL = (String) options.get(&quot;privateKeyPasswordURL&quot;);</span>

<span class="fc" id="L238">        protectedPath = &quot;true&quot;.equalsIgnoreCase((String)options.get</span>
<span class="fc" id="L239">                                        (&quot;protected&quot;));</span>

<span class="fc" id="L241">        debug = &quot;true&quot;.equalsIgnoreCase((String) options.get(&quot;debug&quot;));</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L243">            debugPrint(null);</span>
<span class="nc" id="L244">            debugPrint(&quot;keyStoreURL=&quot; + keyStoreURL);</span>
<span class="nc" id="L245">            debugPrint(&quot;keyStoreType=&quot; + keyStoreType);</span>
<span class="nc" id="L246">            debugPrint(&quot;keyStoreProvider=&quot; + keyStoreProvider);</span>
<span class="nc" id="L247">            debugPrint(&quot;keyStoreAlias=&quot; + keyStoreAlias);</span>
<span class="nc" id="L248">            debugPrint(&quot;keyStorePasswordURL=&quot; + keyStorePasswordURL);</span>
<span class="nc" id="L249">            debugPrint(&quot;privateKeyPasswordURL=&quot; + privateKeyPasswordURL);</span>
<span class="nc" id="L250">            debugPrint(&quot;protectedPath=&quot; + protectedPath);</span>
<span class="nc" id="L251">            debugPrint(null);</span>
        }
<span class="fc" id="L253">    }</span>

    /**
     * Authenticate the user.
     *
     * &lt;p&gt; Get the Keystore alias and relevant passwords.
     * Retrieve the alias's principal and credentials from the Keystore.
     *
     * &lt;p&gt;
     *
     * @exception FailedLoginException if the authentication fails. &lt;p&gt;
     *
     * @return true in all cases (this &lt;code&gt;LoginModule&lt;/code&gt;
     *          should not be ignored).
     */

    public boolean login() throws LoginException {
<span class="pc bpc" id="L270" title="2 of 3 branches missed.">        switch (status) {</span>
        case UNINITIALIZED:
        default:
<span class="nc" id="L273">            throw new LoginException(&quot;The login module is not initialized&quot;);</span>
        case INITIALIZED:
        case AUTHENTICATED:

<span class="fc bfc" id="L277" title="All 4 branches covered.">            if (token &amp;&amp; !nullStream) {</span>
<span class="fc" id="L278">                throw new LoginException</span>
                        (&quot;if keyStoreType is &quot; + P11KEYSTORE +
                        &quot; then keyStoreURL must be &quot; + NONE);
            }

<span class="fc bfc" id="L283" title="All 4 branches covered.">            if (token &amp;&amp; privateKeyPasswordURL != null) {</span>
<span class="fc" id="L284">                throw new LoginException</span>
                        (&quot;if keyStoreType is &quot; + P11KEYSTORE +
                        &quot; then privateKeyPasswordURL must not be specified&quot;);
            }

<span class="pc bpc" id="L289" title="3 of 6 branches missed.">            if (protectedPath &amp;&amp;</span>
                (keyStorePasswordURL != null ||
                        privateKeyPasswordURL != null)) {
<span class="fc" id="L292">                throw new LoginException</span>
                        (&quot;if protected is true then keyStorePasswordURL and &quot; +
                        &quot;privateKeyPasswordURL must not be specified&quot;);
            }

            // get relevant alias and password info

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">            if (protectedPath) {</span>
<span class="nc" id="L300">                getAliasAndPasswords(PROTECTED_PATH);</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            } else if (token) {</span>
<span class="nc" id="L302">                getAliasAndPasswords(TOKEN);</span>
            } else {
<span class="fc" id="L304">                getAliasAndPasswords(NORMAL);</span>
            }

            // log into KeyStore to retrieve data,
            // then clear passwords

            try {
<span class="fc" id="L311">                getKeyStoreInfo();</span>
            } finally {
<span class="pc bpc" id="L313" title="3 of 8 branches missed.">                if (privateKeyPassword != null &amp;&amp;</span>
                    privateKeyPassword != keyStorePassword) {
<span class="fc" id="L315">                    Arrays.fill(privateKeyPassword, '\0');</span>
<span class="fc" id="L316">                    privateKeyPassword = null;</span>
                }
<span class="pc bpc" id="L318" title="2 of 4 branches missed.">                if (keyStorePassword != null) {</span>
<span class="fc" id="L319">                    Arrays.fill(keyStorePassword, '\0');</span>
<span class="fc" id="L320">                    keyStorePassword = null;</span>
                }
            }
<span class="fc" id="L323">            status = AUTHENTICATED;</span>
<span class="fc" id="L324">            return true;</span>
        case LOGGED_IN:
<span class="nc" id="L326">            return true;</span>
        }
    }

    /** Get the alias and passwords to use for looking up in the KeyStore. */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void getAliasAndPasswords(int env) throws LoginException {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        if (callbackHandler == null) {</span>

            // No callback handler - check for alias and password options

<span class="pc bpc" id="L337" title="3 of 4 branches missed.">            switch (env) {</span>
            case PROTECTED_PATH:
<span class="nc" id="L339">                checkAlias();</span>
<span class="nc" id="L340">                break;</span>
            case TOKEN:
<span class="nc" id="L342">                checkAlias();</span>
<span class="nc" id="L343">                checkStorePass();</span>
<span class="nc" id="L344">                break;</span>
            case NORMAL:
<span class="fc" id="L346">                checkAlias();</span>
<span class="fc" id="L347">                checkStorePass();</span>
<span class="fc" id="L348">                checkKeyPass();</span>
<span class="fc" id="L349">                break;</span>
            }

        } else {

            // Callback handler available - prompt for alias and passwords

            NameCallback aliasCallback;
<span class="pc bpc" id="L357" title="3 of 4 branches missed.">            if (keyStoreAlias == null || keyStoreAlias.length() == 0) {</span>
<span class="fc" id="L358">                aliasCallback = new NameCallback(</span>
<span class="fc" id="L359">                                        rb.getString(&quot;Keystore.alias.&quot;));</span>
            } else {
<span class="nc" id="L361">                aliasCallback =</span>
<span class="nc" id="L362">                    new NameCallback(rb.getString(&quot;Keystore.alias.&quot;),</span>
                                     keyStoreAlias);
            }

<span class="fc" id="L366">            PasswordCallback storePassCallback = null;</span>
<span class="fc" id="L367">            PasswordCallback keyPassCallback = null;</span>

<span class="pc bpc" id="L369" title="3 of 4 branches missed.">            switch (env) {</span>
            case PROTECTED_PATH:
<span class="nc" id="L371">                break;</span>
            case NORMAL:
<span class="fc" id="L373">                keyPassCallback = new PasswordCallback</span>
<span class="fc" id="L374">                    (rb.getString(&quot;Private.key.password.optional.&quot;), false);</span>
                // fall thru
            case TOKEN:
<span class="fc" id="L377">                storePassCallback = new PasswordCallback</span>
<span class="fc" id="L378">                    (rb.getString(&quot;Keystore.password.&quot;), false);</span>
                break;
            }
<span class="fc" id="L381">            prompt(aliasCallback, storePassCallback, keyPassCallback);</span>
        }

<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L385">            debugPrint(&quot;alias=&quot; + keyStoreAlias);</span>
        }
<span class="fc" id="L387">    }</span>

    private void checkAlias() throws LoginException {
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (keyStoreAlias == null) {</span>
<span class="fc" id="L391">            throw new LoginException</span>
                (&quot;Need to specify an alias option to use &quot; +
                &quot;KeyStoreLoginModule non-interactively.&quot;);
        }
<span class="fc" id="L395">    }</span>

    private void checkStorePass() throws LoginException {
<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (keyStorePasswordURL == null) {</span>
<span class="fc" id="L399">            throw new LoginException</span>
                (&quot;Need to specify keyStorePasswordURL option to use &quot; +
                &quot;KeyStoreLoginModule non-interactively.&quot;);
        }
<span class="fc" id="L403">        InputStream in = null;</span>
        try {
<span class="fc" id="L405">            in = new URL(keyStorePasswordURL).openStream();</span>
<span class="fc" id="L406">            keyStorePassword = Password.readPassword(in);</span>
<span class="nc" id="L407">        } catch (IOException e) {</span>
<span class="nc" id="L408">            LoginException le = new LoginException</span>
                (&quot;Problem accessing keystore password \&quot;&quot; +
                keyStorePasswordURL + &quot;\&quot;&quot;);
<span class="nc" id="L411">            le.initCause(e);</span>
<span class="nc" id="L412">            throw le;</span>
        } finally {
<span class="pc bpc" id="L414" title="3 of 4 branches missed.">            if (in != null) {</span>
                try {
<span class="pc" id="L416">                    in.close();</span>
<span class="nc" id="L417">                } catch (IOException ioe) {</span>
<span class="nc" id="L418">                    LoginException le = new LoginException(</span>
                        &quot;Problem closing the keystore password stream&quot;);
<span class="nc" id="L420">                    le.initCause(ioe);</span>
<span class="nc" id="L421">                    throw le;</span>
<span class="pc" id="L422">                }</span>
            }
        }
<span class="fc" id="L425">    }</span>

    private void checkKeyPass() throws LoginException {
<span class="fc bfc" id="L428" title="All 2 branches covered.">        if (privateKeyPasswordURL == null) {</span>
<span class="fc" id="L429">            privateKeyPassword = keyStorePassword;</span>
        } else {
<span class="fc" id="L431">            InputStream in = null;</span>
            try {
<span class="fc" id="L433">                in = new URL(privateKeyPasswordURL).openStream();</span>
<span class="fc" id="L434">                privateKeyPassword = Password.readPassword(in);</span>
<span class="nc" id="L435">            } catch (IOException e) {</span>
<span class="nc" id="L436">                LoginException le = new LoginException</span>
                        (&quot;Problem accessing private key password \&quot;&quot; +
                        privateKeyPasswordURL + &quot;\&quot;&quot;);
<span class="nc" id="L439">                le.initCause(e);</span>
<span class="nc" id="L440">                throw le;</span>
            } finally {
<span class="pc bpc" id="L442" title="3 of 4 branches missed.">                if (in != null) {</span>
                    try {
<span class="pc" id="L444">                        in.close();</span>
<span class="nc" id="L445">                    } catch (IOException ioe) {</span>
<span class="nc" id="L446">                        LoginException le = new LoginException(</span>
                            &quot;Problem closing the private key password stream&quot;);
<span class="nc" id="L448">                        le.initCause(ioe);</span>
<span class="nc" id="L449">                        throw le;</span>
<span class="pc" id="L450">                    }</span>
                }
            }
        }
<span class="fc" id="L454">    }</span>

    private void prompt(NameCallback aliasCallback,
                        PasswordCallback storePassCallback,
                        PasswordCallback keyPassCallback)
                throws LoginException {

<span class="pc bpc" id="L461" title="1 of 2 branches missed.">        if (storePassCallback == null) {</span>

            // only prompt for alias

            try {
<span class="nc" id="L466">                callbackHandler.handle(</span>
                    new Callback[] {
                        bannerCallback, aliasCallback, confirmationCallback
                    });
<span class="nc" id="L470">            } catch (IOException e) {</span>
<span class="nc" id="L471">                LoginException le = new LoginException</span>
                        (&quot;Problem retrieving keystore alias&quot;);
<span class="nc" id="L473">                le.initCause(e);</span>
<span class="nc" id="L474">                throw le;</span>
<span class="nc" id="L475">            } catch (UnsupportedCallbackException e) {</span>
<span class="nc" id="L476">                throw new LoginException(</span>
<span class="nc" id="L477">                    &quot;Error: &quot; + e.getCallback().toString() +</span>
                    &quot; is not available to retrieve authentication &quot; +
                    &quot; information from the user&quot;);
<span class="nc" id="L480">            }</span>

<span class="nc" id="L482">            int confirmationResult = confirmationCallback.getSelectedIndex();</span>

<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (confirmationResult == ConfirmationCallback.CANCEL) {</span>
<span class="nc" id="L485">                throw new LoginException(&quot;Login cancelled&quot;);</span>
            }

<span class="nc" id="L488">            saveAlias(aliasCallback);</span>

<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        } else if (keyPassCallback == null) {</span>

            // prompt for alias and key store password

            try {
<span class="nc" id="L495">                callbackHandler.handle(</span>
                    new Callback[] {
                        bannerCallback, aliasCallback,
                        storePassCallback, confirmationCallback
                    });
<span class="nc" id="L500">            } catch (IOException e) {</span>
<span class="nc" id="L501">                LoginException le = new LoginException</span>
                        (&quot;Problem retrieving keystore alias and password&quot;);
<span class="nc" id="L503">                le.initCause(e);</span>
<span class="nc" id="L504">                throw le;</span>
<span class="nc" id="L505">            } catch (UnsupportedCallbackException e) {</span>
<span class="nc" id="L506">                throw new LoginException(</span>
<span class="nc" id="L507">                    &quot;Error: &quot; + e.getCallback().toString() +</span>
                    &quot; is not available to retrieve authentication &quot; +
                    &quot; information from the user&quot;);
<span class="nc" id="L510">            }</span>

<span class="nc" id="L512">            int confirmationResult = confirmationCallback.getSelectedIndex();</span>

<span class="nc bnc" id="L514" title="All 2 branches missed.">            if (confirmationResult == ConfirmationCallback.CANCEL) {</span>
<span class="nc" id="L515">                throw new LoginException(&quot;Login cancelled&quot;);</span>
            }

<span class="nc" id="L518">            saveAlias(aliasCallback);</span>
<span class="nc" id="L519">            saveStorePass(storePassCallback);</span>

<span class="nc" id="L521">        } else {</span>

            // prompt for alias, key store password, and key password

            try {
<span class="fc" id="L526">                callbackHandler.handle(</span>
                    new Callback[] {
                        bannerCallback, aliasCallback,
                        storePassCallback, keyPassCallback,
                        confirmationCallback
                    });
<span class="nc" id="L532">            } catch (IOException e) {</span>
<span class="nc" id="L533">                LoginException le = new LoginException</span>
                        (&quot;Problem retrieving keystore alias and passwords&quot;);
<span class="nc" id="L535">                le.initCause(e);</span>
<span class="nc" id="L536">                throw le;</span>
<span class="nc" id="L537">            } catch (UnsupportedCallbackException e) {</span>
<span class="nc" id="L538">                throw new LoginException(</span>
<span class="nc" id="L539">                    &quot;Error: &quot; + e.getCallback().toString() +</span>
                    &quot; is not available to retrieve authentication &quot; +
                    &quot; information from the user&quot;);
<span class="fc" id="L542">            }</span>

<span class="fc" id="L544">            int confirmationResult = confirmationCallback.getSelectedIndex();</span>

<span class="pc bpc" id="L546" title="1 of 2 branches missed.">            if (confirmationResult == ConfirmationCallback.CANCEL) {</span>
<span class="nc" id="L547">                throw new LoginException(&quot;Login cancelled&quot;);</span>
            }

<span class="fc" id="L550">            saveAlias(aliasCallback);</span>
<span class="fc" id="L551">            saveStorePass(storePassCallback);</span>
<span class="fc" id="L552">            saveKeyPass(keyPassCallback);</span>
        }
<span class="fc" id="L554">    }</span>

    private void saveAlias(NameCallback cb) {
<span class="fc" id="L557">        keyStoreAlias = cb.getName();</span>
<span class="fc" id="L558">    }</span>

    private void saveStorePass(PasswordCallback c) {
<span class="fc" id="L561">        keyStorePassword = c.getPassword();</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">        if (keyStorePassword == null) {</span>
            /* Treat a NULL password as an empty password */
<span class="nc" id="L564">            keyStorePassword = new char[0];</span>
        }
<span class="fc" id="L566">        c.clearPassword();</span>
<span class="fc" id="L567">    }</span>

    private void saveKeyPass(PasswordCallback c) {
<span class="fc" id="L570">        privateKeyPassword = c.getPassword();</span>
<span class="pc bpc" id="L571" title="2 of 4 branches missed.">        if (privateKeyPassword == null || privateKeyPassword.length == 0) {</span>
            /*
             * Use keystore password if no private key password is
             * specified.
             */
<span class="nc" id="L576">            privateKeyPassword = keyStorePassword;</span>
        }
<span class="fc" id="L578">        c.clearPassword();</span>
<span class="fc" id="L579">    }</span>

    /** Get the credentials from the KeyStore. */
    private void getKeyStoreInfo() throws LoginException {

        /* Get KeyStore instance */
        try {
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">            if (keyStoreProvider == null) {</span>
<span class="fc" id="L587">                keyStore = KeyStore.getInstance(keyStoreType);</span>
            } else {
<span class="nc" id="L589">                keyStore =</span>
<span class="nc" id="L590">                    KeyStore.getInstance(keyStoreType, keyStoreProvider);</span>
            }
<span class="nc" id="L592">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L593">            LoginException le = new LoginException</span>
                (&quot;The specified keystore type was not available&quot;);
<span class="nc" id="L595">            le.initCause(e);</span>
<span class="nc" id="L596">            throw le;</span>
<span class="nc" id="L597">        } catch (NoSuchProviderException e) {</span>
<span class="nc" id="L598">            LoginException le = new LoginException</span>
                (&quot;The specified keystore provider was not available&quot;);
<span class="nc" id="L600">            le.initCause(e);</span>
<span class="nc" id="L601">            throw le;</span>
<span class="fc" id="L602">        }</span>

        /* Load KeyStore contents from file */
<span class="fc" id="L605">        InputStream in = null;</span>
        try {
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">            if (nullStream) {</span>
                // if using protected auth path, keyStorePassword will be null
<span class="nc" id="L609">                keyStore.load(null, keyStorePassword);</span>
            } else {
<span class="fc" id="L611">                in = new URL(keyStoreURL).openStream();</span>
<span class="fc" id="L612">                keyStore.load(in, keyStorePassword);</span>
            }
<span class="nc" id="L614">        } catch (MalformedURLException e) {</span>
<span class="nc" id="L615">            LoginException le = new LoginException</span>
                                (&quot;Incorrect keyStoreURL option&quot;);
<span class="nc" id="L617">            le.initCause(e);</span>
<span class="nc" id="L618">            throw le;</span>
<span class="nc" id="L619">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L620">            LoginException le = new LoginException</span>
                                (&quot;Error initializing keystore&quot;);
<span class="nc" id="L622">            le.initCause(e);</span>
<span class="nc" id="L623">            throw le;</span>
<span class="fc" id="L624">        } catch (IOException e) {</span>
<span class="fc" id="L625">            LoginException le = new LoginException</span>
                                (&quot;Error initializing keystore&quot;);
<span class="fc" id="L627">            le.initCause(e);</span>
<span class="fc" id="L628">            throw le;</span>
        } finally {
<span class="pc bpc" id="L630" title="2 of 4 branches missed.">            if (in != null) {</span>
                try {
<span class="pc" id="L632">                    in.close();</span>
<span class="nc" id="L633">                } catch (IOException ioe) {</span>
<span class="nc" id="L634">                    LoginException le = new LoginException</span>
                                (&quot;Error initializing keystore&quot;);
<span class="nc" id="L636">                    le.initCause(ioe);</span>
<span class="pc" id="L637">                    throw le;</span>
<span class="pc" id="L638">                }</span>
            }
        }

        /* Get certificate chain and create a certificate path */
        try {
<span class="fc" id="L644">            fromKeyStore =</span>
<span class="fc" id="L645">                keyStore.getCertificateChain(keyStoreAlias);</span>
<span class="pc bpc" id="L646" title="2 of 6 branches missed.">            if (fromKeyStore == null</span>
                || fromKeyStore.length == 0
                || !(fromKeyStore[0] instanceof X509Certificate))
            {
<span class="fc" id="L650">                throw new FailedLoginException(</span>
                    &quot;Unable to find X.509 certificate chain in keystore&quot;);
            } else {
<span class="fc" id="L653">                LinkedList&lt;Certificate&gt; certList = new LinkedList&lt;&gt;();</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">                for (int i=0; i &lt; fromKeyStore.length; i++) {</span>
<span class="fc" id="L655">                    certList.add(fromKeyStore[i]);</span>
                }
<span class="fc" id="L657">                CertificateFactory certF=</span>
<span class="fc" id="L658">                    CertificateFactory.getInstance(&quot;X.509&quot;);</span>
<span class="fc" id="L659">                certP =</span>
<span class="fc" id="L660">                    certF.generateCertPath(certList);</span>
            }
<span class="nc" id="L662">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L663">            LoginException le = new LoginException(&quot;Error using keystore&quot;);</span>
<span class="nc" id="L664">            le.initCause(e);</span>
<span class="nc" id="L665">            throw le;</span>
<span class="nc" id="L666">        } catch (CertificateException ce) {</span>
<span class="nc" id="L667">            LoginException le = new LoginException</span>
                (&quot;Error: X.509 Certificate type unavailable&quot;);
<span class="nc" id="L669">            le.initCause(ce);</span>
<span class="nc" id="L670">            throw le;</span>
<span class="fc" id="L671">        }</span>

        /* Get principal and keys */
        try {
<span class="fc" id="L675">            X509Certificate certificate = (X509Certificate)fromKeyStore[0];</span>
<span class="fc" id="L676">            principal = new javax.security.auth.x500.X500Principal</span>
<span class="fc" id="L677">                (certificate.getSubjectDN().getName());</span>

            // if token, privateKeyPassword will be null
<span class="fc" id="L680">            Key privateKey = keyStore.getKey(keyStoreAlias, privateKeyPassword);</span>
<span class="pc bpc" id="L681" title="2 of 4 branches missed.">            if (privateKey == null</span>
                || !(privateKey instanceof PrivateKey))
            {
<span class="nc" id="L684">                throw new FailedLoginException(</span>
                    &quot;Unable to recover key from keystore&quot;);
            }

<span class="fc" id="L688">            privateCredential = new X500PrivateCredential(</span>
                certificate, (PrivateKey) privateKey, keyStoreAlias);
<span class="nc" id="L690">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L691">            LoginException le = new LoginException(&quot;Error using keystore&quot;);</span>
<span class="nc" id="L692">            le.initCause(e);</span>
<span class="nc" id="L693">            throw le;</span>
<span class="nc" id="L694">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L695">            LoginException le = new LoginException(&quot;Error using keystore&quot;);</span>
<span class="nc" id="L696">            le.initCause(e);</span>
<span class="nc" id="L697">            throw le;</span>
<span class="nc" id="L698">        } catch (UnrecoverableKeyException e) {</span>
<span class="nc" id="L699">            FailedLoginException fle = new FailedLoginException</span>
                                (&quot;Unable to recover key from keystore&quot;);
<span class="nc" id="L701">            fle.initCause(e);</span>
<span class="nc" id="L702">            throw fle;</span>
<span class="fc" id="L703">        }</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L705">            debugPrint(&quot;principal=&quot; + principal +</span>
                       &quot;\n certificate=&quot;
<span class="nc" id="L707">                       + privateCredential.getCertificate() +</span>
<span class="nc" id="L708">                       &quot;\n alias =&quot; + privateCredential.getAlias());</span>
        }
<span class="fc" id="L710">    }</span>

    /**
     * Abstract method to commit the authentication process (phase 2).
     *
     * &lt;p&gt; This method is called if the LoginContext's
     * overall authentication succeeded
     * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules
     * succeeded).
     *
     * &lt;p&gt; If this LoginModule's own authentication attempt
     * succeeded (checked by retrieving the private state saved by the
     * &lt;code&gt;login&lt;/code&gt; method), then this method associates a
     * &lt;code&gt;X500Principal&lt;/code&gt; for the subject distinguished name of the
     * first certificate in the alias's credentials in the subject's
     * principals,the alias's certificate path in the subject's public
     * credentials, and a&lt;code&gt;X500PrivateCredential&lt;/code&gt; whose certificate
     * is the first  certificate in the alias's certificate path and whose
     * private key is the alias's private key in the subject's private
     * credentials.  If this LoginModule's own
     * authentication attempted failed, then this method removes
     * any state that was originally saved.
     *
     * &lt;p&gt;
     *
     * @exception LoginException if the commit fails
     *
     * @return true if this LoginModule's own login and commit
     *          attempts succeeded, or false otherwise.
     */

    public boolean commit() throws LoginException {
<span class="nc bnc" id="L742" title="All 4 branches missed.">        switch (status) {</span>
        case UNINITIALIZED:
        default:
<span class="nc" id="L745">            throw new LoginException(&quot;The login module is not initialized&quot;);</span>
        case INITIALIZED:
<span class="nc" id="L747">            logoutInternal();</span>
<span class="nc" id="L748">            throw new LoginException(&quot;Authentication failed&quot;);</span>
        case AUTHENTICATED:
<span class="nc bnc" id="L750" title="All 2 branches missed.">            if (commitInternal()) {</span>
<span class="nc" id="L751">                return true;</span>
            } else {
<span class="nc" id="L753">                logoutInternal();</span>
<span class="nc" id="L754">                throw new LoginException(&quot;Unable to retrieve certificates&quot;);</span>
            }
        case LOGGED_IN:
<span class="nc" id="L757">            return true;</span>
        }
    }

    private boolean commitInternal() throws LoginException {
        /* If the subject is not readonly add to the principal and credentials
         * set; otherwise just return true
         */
<span class="nc bnc" id="L765" title="All 2 branches missed.">        if (subject.isReadOnly()) {</span>
<span class="nc" id="L766">            throw new LoginException (&quot;Subject is set readonly&quot;);</span>
        } else {
<span class="nc" id="L768">            subject.getPrincipals().add(principal);</span>
<span class="nc" id="L769">            subject.getPublicCredentials().add(certP);</span>
<span class="nc" id="L770">            subject.getPrivateCredentials().add(privateCredential);</span>
<span class="nc" id="L771">            status = LOGGED_IN;</span>
<span class="nc" id="L772">            return true;</span>
        }
    }

    /**
     * &lt;p&gt; This method is called if the LoginContext's
     * overall authentication failed.
     * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules
     * did not succeed).
     *
     * &lt;p&gt; If this LoginModule's own authentication attempt
     * succeeded (checked by retrieving the private state saved by the
     * &lt;code&gt;login&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt; methods),
     * then this method cleans up any state that was originally saved.
     *
     * &lt;p&gt; If the loaded KeyStore's provider extends
     * &lt;code&gt;java.security.AuthProvider&lt;/code&gt;,
     * then the provider's &lt;code&gt;logout&lt;/code&gt; method is invoked.
     *
     * &lt;p&gt;
     *
     * @exception LoginException if the abort fails.
     *
     * @return false if this LoginModule's own login and/or commit attempts
     *          failed, and true otherwise.
     */

    public boolean abort() throws LoginException {
<span class="nc bnc" id="L800" title="All 4 branches missed.">        switch (status) {</span>
        case UNINITIALIZED:
        default:
<span class="nc" id="L803">            return false;</span>
        case INITIALIZED:
<span class="nc" id="L805">            return false;</span>
        case AUTHENTICATED:
<span class="nc" id="L807">            logoutInternal();</span>
<span class="nc" id="L808">            return true;</span>
        case LOGGED_IN:
<span class="nc" id="L810">            logoutInternal();</span>
<span class="nc" id="L811">            return true;</span>
        }
    }
    /**
     * Logout a user.
     *
     * &lt;p&gt; This method removes the Principals, public credentials and the
     * private credentials that were added by the &lt;code&gt;commit&lt;/code&gt; method.
     *
     * &lt;p&gt; If the loaded KeyStore's provider extends
     * &lt;code&gt;java.security.AuthProvider&lt;/code&gt;,
     * then the provider's &lt;code&gt;logout&lt;/code&gt; method is invoked.
     *
     * &lt;p&gt;
     *
     * @exception LoginException if the logout fails.
     *
     * @return true in all cases since this &lt;code&gt;LoginModule&lt;/code&gt;
     *          should not be ignored.
     */

    public boolean logout() throws LoginException {
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (debug)</span>
<span class="nc" id="L834">            debugPrint(&quot;Entering logout &quot; + status);</span>
<span class="nc bnc" id="L835" title="All 3 branches missed.">        switch (status) {</span>
        case UNINITIALIZED:
<span class="nc" id="L837">            throw new LoginException</span>
                (&quot;The login module is not initialized&quot;);
        case INITIALIZED:
        case AUTHENTICATED:
        default:
           // impossible for LoginModule to be in AUTHENTICATED
           // state
           // assert status != AUTHENTICATED;
<span class="nc" id="L845">            return false;</span>
        case LOGGED_IN:
<span class="nc" id="L847">            logoutInternal();</span>
<span class="nc" id="L848">            return true;</span>
        }
    }

    private void logoutInternal() throws LoginException {
<span class="nc bnc" id="L853" title="All 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L854">            debugPrint(&quot;Entering logoutInternal&quot;);</span>
        }

        // assumption is that KeyStore.load did a login -
        // perform explicit logout if possible
<span class="nc" id="L859">        LoginException logoutException = null;</span>
<span class="nc" id="L860">        Provider provider = keyStore.getProvider();</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">        if (provider instanceof AuthProvider) {</span>
<span class="nc" id="L862">            AuthProvider ap = (AuthProvider)provider;</span>
            try {
<span class="nc" id="L864">                ap.logout();</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L866">                    debugPrint(&quot;logged out of KeyStore AuthProvider&quot;);</span>
                }
<span class="nc" id="L868">            } catch (LoginException le) {</span>
                // save but continue below
<span class="nc" id="L870">                logoutException = le;</span>
<span class="nc" id="L871">            }</span>
        }

<span class="nc bnc" id="L874" title="All 2 branches missed.">        if (subject.isReadOnly()) {</span>
            // attempt to destroy the private credential
            // even if the Subject is read-only
<span class="nc" id="L877">            principal = null;</span>
<span class="nc" id="L878">            certP = null;</span>
<span class="nc" id="L879">            status = INITIALIZED;</span>
            // destroy the private credential
<span class="nc" id="L881">            Iterator&lt;Object&gt; it = subject.getPrivateCredentials().iterator();</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L883">                Object obj = it.next();</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                if (privateCredential.equals(obj)) {</span>
<span class="nc" id="L885">                    privateCredential = null;</span>
                    try {
<span class="nc" id="L887">                        ((Destroyable)obj).destroy();</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">                        if (debug)</span>
<span class="nc" id="L889">                            debugPrint(&quot;Destroyed private credential, &quot; +</span>
<span class="nc" id="L890">                                       obj.getClass().getName());</span>
<span class="nc" id="L891">                        break;</span>
<span class="nc" id="L892">                    } catch (DestroyFailedException dfe) {</span>
<span class="nc" id="L893">                        LoginException le = new LoginException</span>
                            (&quot;Unable to destroy private credential, &quot;
<span class="nc" id="L895">                             + obj.getClass().getName());</span>
<span class="nc" id="L896">                        le.initCause(dfe);</span>
<span class="nc" id="L897">                        throw le;</span>
                    }
                }
<span class="nc" id="L900">            }</span>

            // throw an exception because we can not remove
            // the principal and public credential from this
            // read-only Subject
<span class="nc" id="L905">            throw new LoginException</span>
                (&quot;Unable to remove Principal (&quot;
                 + &quot;X500Principal &quot;
                 + &quot;) and public credential (certificatepath) &quot;
                 + &quot;from read-only Subject&quot;);
        }
<span class="nc bnc" id="L911" title="All 2 branches missed.">        if (principal != null) {</span>
<span class="nc" id="L912">            subject.getPrincipals().remove(principal);</span>
<span class="nc" id="L913">            principal = null;</span>
        }
<span class="nc bnc" id="L915" title="All 2 branches missed.">        if (certP != null) {</span>
<span class="nc" id="L916">            subject.getPublicCredentials().remove(certP);</span>
<span class="nc" id="L917">            certP = null;</span>
        }
<span class="nc bnc" id="L919" title="All 2 branches missed.">        if (privateCredential != null) {</span>
<span class="nc" id="L920">            subject.getPrivateCredentials().remove(privateCredential);</span>
<span class="nc" id="L921">            privateCredential = null;</span>
        }

        // throw pending logout exception if there is one
<span class="nc bnc" id="L925" title="All 2 branches missed.">        if (logoutException != null) {</span>
<span class="nc" id="L926">            throw logoutException;</span>
        }
<span class="nc" id="L928">        status = INITIALIZED;</span>
<span class="nc" id="L929">    }</span>

    private void debugPrint(String message) {
        // we should switch to logging API
<span class="nc bnc" id="L933" title="All 2 branches missed.">        if (message == null) {</span>
<span class="nc" id="L934">            System.err.println();</span>
        } else {
<span class="nc" id="L936">            System.err.println(&quot;Debug KeyStoreLoginModule: &quot; + message);</span>
        }
<span class="nc" id="L938">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>