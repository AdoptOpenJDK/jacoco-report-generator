<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LdapLoginModule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.security.auth.module</a> &gt; <span class="el_source">LdapLoginModule.java</span></div><h1>LdapLoginModule.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.security.auth.module;

import java.security.AccessController;
import java.net.SocketPermission;
import java.security.Principal;
import java.security.PrivilegedAction;
import java.util.Arrays;
import java.util.Hashtable;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Set;

import javax.naming.*;
import javax.naming.directory.*;
import javax.naming.ldap.*;
import javax.security.auth.*;
import javax.security.auth.callback.*;
import javax.security.auth.login.*;
import javax.security.auth.spi.*;

import com.sun.security.auth.LdapPrincipal;
import com.sun.security.auth.UserPrincipal;


/**
 * This {@link LoginModule} performs LDAP-based authentication.
 * A username and password is verified against the corresponding user
 * credentials stored in an LDAP directory.
 * This module requires the supplied {@link CallbackHandler} to support a
 * {@link NameCallback} and a {@link PasswordCallback}.
 * If authentication is successful then a new {@link LdapPrincipal} is created
 * using the user's distinguished name and a new {@link UserPrincipal} is
 * created using the user's username and both are associated
 * with the current {@link Subject}.
 *
 * &lt;p&gt; This module operates in one of three modes: &lt;i&gt;search-first&lt;/i&gt;,
 * &lt;i&gt;authentication-first&lt;/i&gt; or &lt;i&gt;authentication-only&lt;/i&gt;.
 * A mode is selected by specifying a particular set of options.
 *
 * &lt;p&gt; In search-first mode, the LDAP directory is searched to determine the
 * user's distinguished name and then authentication is attempted.
 * An (anonymous) search is performed using the supplied username in
 * conjunction with a specified search filter.
 * If successful then authentication is attempted using the user's
 * distinguished name and the supplied password.
 * To enable this mode, set the &lt;code&gt;userFilter&lt;/code&gt; option and omit the
 * &lt;code&gt;authIdentity&lt;/code&gt; option.
 * Use search-first mode when the user's distinguished name is not
 * known in advance.
 *
 * &lt;p&gt; In authentication-first mode, authentication is attempted using the
 * supplied username and password and then the LDAP directory is searched.
 * If authentication is successful then a search is performed using the
 * supplied username in conjunction with a specified search filter.
 * To enable this mode, set the &lt;code&gt;authIdentity&lt;/code&gt; and the
 * &lt;code&gt;userFilter&lt;/code&gt; options.
 * Use authentication-first mode when accessing an LDAP directory
 * that has been configured to disallow anonymous searches.
 *
 * &lt;p&gt; In authentication-only mode, authentication is attempted using the
 * supplied username and password. The LDAP directory is not searched because
 * the user's distinguished name is already known.
 * To enable this mode, set the &lt;code&gt;authIdentity&lt;/code&gt; option to a valid
 * distinguished name and omit the &lt;code&gt;userFilter&lt;/code&gt; option.
 * Use authentication-only mode when the user's distinguished name is
 * known in advance.
 *
 * &lt;p&gt; The following option is mandatory and must be specified in this
 * module's login {@link Configuration}:
 * &lt;dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;
 * &lt;dl&gt;
 * &lt;dt&gt; &lt;code&gt;userProvider=&lt;b&gt;ldap_urls&lt;/b&gt;&lt;/code&gt;
 * &lt;/dt&gt;
 * &lt;dd&gt; This option identifies the LDAP directory that stores user entries.
 *      &lt;b&gt;ldap_urls&lt;/b&gt; is a list of space-separated LDAP URLs
 *      (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2255.txt&quot;&gt;RFC 2255&lt;/a&gt;)
 *      that identifies the LDAP server to use and the position in
 *      its directory tree where user entries are located.
 *      When several LDAP URLs are specified then each is attempted,
 *      in turn, until the first successful connection is established.
 *      Spaces in the distinguished name component of the URL must be escaped
 *      using the standard mechanism of percent character ('&lt;code&gt;%&lt;/code&gt;')
 *      followed by two hexadecimal digits (see {@link java.net.URI}).
 *      Query components must also be omitted from the URL.
 *
 *      &lt;p&gt;
 *      Automatic discovery of the LDAP server via DNS
 *      (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2782.txt&quot;&gt;RFC 2782&lt;/a&gt;)
 *      is supported (once DNS has been configured to support such a service).
 *      It is enabled by omitting the hostname and port number components from
 *      the LDAP URL. &lt;/dd&gt;
 * &lt;/dl&gt;&lt;/dl&gt;
 *
 * &lt;p&gt; This module also recognizes the following optional {@link Configuration}
 *     options:
 * &lt;dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;dd&gt;
 * &lt;dl&gt;
 * &lt;dt&gt; &lt;code&gt;userFilter=&lt;b&gt;ldap_filter&lt;/b&gt;&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; This option specifies the search filter to use to locate a user's
 *      entry in the LDAP directory. It is used to determine a user's
 *      distinguished name.
 *      &lt;code&gt;&lt;b&gt;ldap_filter&lt;/b&gt;&lt;/code&gt; is an LDAP filter string
 *      (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2254.txt&quot;&gt;RFC 2254&lt;/a&gt;).
 *      If it contains the special token &quot;&lt;code&gt;&lt;b&gt;{USERNAME}&lt;/b&gt;&lt;/code&gt;&quot;
 *      then that token will be replaced with the supplied username value
 *      before the filter is used to search the directory. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;authIdentity=&lt;b&gt;auth_id&lt;/b&gt;&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; This option specifies the identity to use when authenticating a user
 *      to the LDAP directory.
 *      &lt;code&gt;&lt;b&gt;auth_id&lt;/b&gt;&lt;/code&gt; may be an LDAP distinguished name string
 *      (&lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;) or some
 *      other string name.
 *      It must contain the special token &quot;&lt;code&gt;&lt;b&gt;{USERNAME}&lt;/b&gt;&lt;/code&gt;&quot;
 *      which will be replaced with the supplied username value before the
 *      name is used for authentication.
 *      Note that if this option does not contain a distinguished name then
 *      the &lt;code&gt;userFilter&lt;/code&gt; option must also be specified. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;authzIdentity=&lt;b&gt;authz_id&lt;/b&gt;&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; This option specifies an authorization identity for the user.
 *      &lt;code&gt;&lt;b&gt;authz_id&lt;/b&gt;&lt;/code&gt; is any string name.
 *      If it comprises a single special token with curly braces then
 *      that token is treated as a attribute name and will be replaced with a
 *      single value of that attribute from the user's LDAP entry.
 *      If the attribute cannot be found then the option is ignored.
 *      When this option is supplied and the user has been successfully
 *      authenticated then an additional {@link UserPrincipal}
 *      is created using the authorization identity and it is associated with
 *      the current {@link Subject}. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;useSSL&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; if &lt;code&gt;false&lt;/code&gt;, this module does not establish an SSL connection
 *      to the LDAP server before attempting authentication. SSL is used to
 *      protect the privacy of the user's password because it is transmitted
 *      in the clear over LDAP.
 *      By default, this module uses SSL. &lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;useFirstPass&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; if &lt;code&gt;true&lt;/code&gt;, this module retrieves the username and password
 *      from the module's shared state, using &quot;javax.security.auth.login.name&quot;
 *      and &quot;javax.security.auth.login.password&quot; as the respective keys. The
 *      retrieved values are used for authentication. If authentication fails,
 *      no attempt for a retry is made, and the failure is reported back to
 *      the calling application.&lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;tryFirstPass&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; if &lt;code&gt;true&lt;/code&gt;, this module retrieves the username and password
 *      from the module's shared state, using &quot;javax.security.auth.login.name&quot;
 *       and &quot;javax.security.auth.login.password&quot; as the respective keys.  The
 *      retrieved values are used for authentication. If authentication fails,
 *      the module uses the {@link CallbackHandler} to retrieve a new username
 *      and password, and another attempt to authenticate is made. If the
 *      authentication fails, the failure is reported back to the calling
 *      application.&lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;storePass&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; if &lt;code&gt;true&lt;/code&gt;, this module stores the username and password
 *      obtained from the {@link CallbackHandler} in the module's shared state,
 *      using
 *      &quot;javax.security.auth.login.name&quot; and
 *      &quot;javax.security.auth.login.password&quot; as the respective keys.  This is
 *      not performed if existing values already exist for the username and
 *      password in the shared state, or if authentication fails.&lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;clearPass&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; if &lt;code&gt;true&lt;/code&gt;, this module clears the username and password
 *      stored in the module's shared state after both phases of authentication
 *      (login and commit) have completed.&lt;/dd&gt;
 *
 * &lt;dt&gt; &lt;code&gt;debug&lt;/code&gt; &lt;/dt&gt;
 * &lt;dd&gt; if &lt;code&gt;true&lt;/code&gt;, debug messages are displayed on the standard
 *      output stream.
 * &lt;/dl&gt;
 * &lt;/dl&gt;
 *
 * &lt;p&gt;
 * Arbitrary
 * &lt;a href=&quot;{@docRoot}/../../../../../technotes/guides/jndi/jndi-ldap-gl.html#PROP&quot;&gt;JNDI properties&lt;/a&gt;
 * may also be specified in the {@link Configuration}.
 * They are added to the environment and passed to the LDAP provider.
 * Note that the following four JNDI properties are set by this module directly
 * and are ignored if also present in the configuration:
 * &lt;ul&gt;
 * &lt;li&gt; &lt;code&gt;java.naming.provider.url&lt;/code&gt;
 * &lt;li&gt; &lt;code&gt;java.naming.security.principal&lt;/code&gt;
 * &lt;li&gt; &lt;code&gt;java.naming.security.credentials&lt;/code&gt;
 * &lt;li&gt; &lt;code&gt;java.naming.security.protocol&lt;/code&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * Three sample {@link Configuration}s are shown below.
 * The first one activates search-first mode. It identifies the LDAP server
 * and specifies that users' entries be located by their &lt;code&gt;uid&lt;/code&gt; and
 * &lt;code&gt;objectClass&lt;/code&gt; attributes. It also specifies that an identity
 * based on the user's &lt;code&gt;employeeNumber&lt;/code&gt; attribute should be created.
 * The second one activates authentication-first mode. It requests that the
 * LDAP server be located dynamically, that authentication be performed using
 * the supplied username directly but without the protection of SSL and that
 * users' entries be located by one of three naming attributes and their
 * &lt;code&gt;objectClass&lt;/code&gt; attribute.
 * The third one activates authentication-only mode. It identifies alternative
 * LDAP servers, it specifies the distinguished name to use for
 * authentication and a fixed identity to use for authorization. No directory
 * search is performed.
 *
 * &lt;pre&gt;
 *
 *     ExampleApplication {
 *         com.sun.security.auth.module.LdapLoginModule REQUIRED
 *             userProvider=&quot;ldap://ldap-svr/ou=people,dc=example,dc=com&quot;
 *             userFilter=&quot;(&amp;(uid={USERNAME})(objectClass=inetOrgPerson))&quot;
 *             authzIdentity=&quot;{EMPLOYEENUMBER}&quot;
 *             debug=true;
 *     };
 *
 *     ExampleApplication {
 *         com.sun.security.auth.module.LdapLoginModule REQUIRED
 *             userProvider=&quot;ldap:///cn=users,dc=example,dc=com&quot;
 *             authIdentity=&quot;{USERNAME}&quot;
 *             userFilter=&quot;(&amp;(|(samAccountName={USERNAME})(userPrincipalName={USERNAME})(cn={USERNAME}))(objectClass=user))&quot;
 *             useSSL=false
 *             debug=true;
 *     };
 *
 *     ExampleApplication {
 *         com.sun.security.auth.module.LdapLoginModule REQUIRED
 *             userProvider=&quot;ldap://ldap-svr1 ldap://ldap-svr2&quot;
 *             authIdentity=&quot;cn={USERNAME},ou=people,dc=example,dc=com&quot;
 *             authzIdentity=&quot;staff&quot;
 *             debug=true;
 *     };
 *
 * &lt;/pre&gt;
 *
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;b&gt;Note:&lt;/b&gt; &lt;/dt&gt;
 * &lt;dd&gt;When a {@link SecurityManager} is active then an application
 *     that creates a {@link LoginContext} and uses a {@link LoginModule}
 *     must be granted certain permissions.
 *     &lt;p&gt;
 *     If the application creates a login context using an &lt;em&gt;installed&lt;/em&gt;
 *     {@link Configuration} then the application must be granted the
 *     {@link AuthPermission} to create login contexts.
 *     For example, the following security policy allows an application in
 *     the user's current directory to instantiate &lt;em&gt;any&lt;/em&gt; login context:
 *     &lt;pre&gt;
 *
 *     grant codebase &quot;file:${user.dir}/&quot; {
 *         permission javax.security.auth.AuthPermission &quot;createLoginContext.*&quot;;
 *     };
 *     &lt;/pre&gt;
 *
 *     Alternatively, if the application creates a login context using a
 *     &lt;em&gt;caller-specified&lt;/em&gt; {@link Configuration} then the application
 *     must be granted the permissions required by the {@link LoginModule}.
 *     &lt;em&gt;This&lt;/em&gt; module requires the following two permissions:
 *     &lt;p&gt;
 *     &lt;ul&gt;
 *     &lt;li&gt; The {@link SocketPermission} to connect to an LDAP server.
 *     &lt;li&gt; The {@link AuthPermission} to modify the set of {@link Principal}s
 *          associated with a {@link Subject}.
 *     &lt;/ul&gt;
 *     &lt;p&gt;
 *     For example, the following security policy grants an application in the
 *     user's current directory all the permissions required by this module:
 *     &lt;pre&gt;
 *
 *     grant codebase &quot;file:${user.dir}/&quot; {
 *         permission java.net.SocketPermission &quot;*:389&quot;, &quot;connect&quot;;
 *         permission java.net.SocketPermission &quot;*:636&quot;, &quot;connect&quot;;
 *         permission javax.security.auth.AuthPermission &quot;modifyPrincipals&quot;;
 *     };
 *     &lt;/pre&gt;
 * &lt;/dd&gt;
 * &lt;/dl&gt;
 *
 * @since 1.6
 */
@jdk.Exported
<span class="fc" id="L308">public class LdapLoginModule implements LoginModule {</span>

    // Use the default classloader for this class to load the prompt strings.
<span class="fc" id="L311">    private static final ResourceBundle rb = AccessController.doPrivileged(</span>
<span class="fc" id="L312">            new PrivilegedAction&lt;ResourceBundle&gt;() {</span>
                public ResourceBundle run() {
<span class="fc" id="L314">                    return ResourceBundle.getBundle(</span>
                        &quot;sun.security.util.AuthResources&quot;);
                }
            }
        );

    // Keys to retrieve the stored username and password
    private static final String USERNAME_KEY = &quot;javax.security.auth.login.name&quot;;
    private static final String PASSWORD_KEY =
        &quot;javax.security.auth.login.password&quot;;

    // Option names
    private static final String USER_PROVIDER = &quot;userProvider&quot;;
    private static final String USER_FILTER = &quot;userFilter&quot;;
    private static final String AUTHC_IDENTITY = &quot;authIdentity&quot;;
    private static final String AUTHZ_IDENTITY = &quot;authzIdentity&quot;;

    // Used for the username token replacement
    private static final String USERNAME_TOKEN = &quot;{USERNAME}&quot;;
<span class="fc" id="L333">    private static final Pattern USERNAME_PATTERN =</span>
<span class="fc" id="L334">        Pattern.compile(&quot;\\{USERNAME\\}&quot;);</span>

    // Configurable options
    private String userProvider;
    private String userFilter;
    private String authcIdentity;
    private String authzIdentity;
<span class="fc" id="L341">    private String authzIdentityAttr = null;</span>
<span class="fc" id="L342">    private boolean useSSL = true;</span>
<span class="fc" id="L343">    private boolean authFirst = false;</span>
<span class="fc" id="L344">    private boolean authOnly = false;</span>
<span class="fc" id="L345">    private boolean useFirstPass = false;</span>
<span class="fc" id="L346">    private boolean tryFirstPass = false;</span>
<span class="fc" id="L347">    private boolean storePass = false;</span>
<span class="fc" id="L348">    private boolean clearPass = false;</span>
<span class="fc" id="L349">    private boolean debug = false;</span>

    // Authentication status
<span class="fc" id="L352">    private boolean succeeded = false;</span>
<span class="fc" id="L353">    private boolean commitSucceeded = false;</span>

    // Supplied username and password
    private String username;
    private char[] password;

    // User's identities
    private LdapPrincipal ldapPrincipal;
    private UserPrincipal userPrincipal;
    private UserPrincipal authzPrincipal;

    // Initial state
    private Subject subject;
    private CallbackHandler callbackHandler;
    private Map&lt;String, Object&gt; sharedState;
    private Map&lt;String, ?&gt; options;
    private LdapContext ctx;
<span class="fc" id="L370">    private Matcher identityMatcher = null;</span>
<span class="fc" id="L371">    private Matcher filterMatcher = null;</span>
    private Hashtable&lt;String, Object&gt; ldapEnvironment;
<span class="fc" id="L373">    private SearchControls constraints = null;</span>

    /**
     * Initialize this &lt;code&gt;LoginModule&lt;/code&gt;.
     *
     * @param subject the &lt;code&gt;Subject&lt;/code&gt; to be authenticated.
     * @param callbackHandler a &lt;code&gt;CallbackHandler&lt;/code&gt; to acquire the
     *                  username and password.
     * @param sharedState shared &lt;code&gt;LoginModule&lt;/code&gt; state.
     * @param options options specified in the login
     *                  &lt;code&gt;Configuration&lt;/code&gt; for this particular
     *                  &lt;code&gt;LoginModule&lt;/code&gt;.
     */
    // Unchecked warning from (Map&lt;String, Object&gt;)sharedState is safe
    // since javax.security.auth.login.LoginContext passes a raw HashMap.
    @SuppressWarnings(&quot;unchecked&quot;)
    public void initialize(Subject subject, CallbackHandler callbackHandler,
                        Map&lt;String, ?&gt; sharedState, Map&lt;String, ?&gt; options) {

<span class="fc" id="L392">        this.subject = subject;</span>
<span class="fc" id="L393">        this.callbackHandler = callbackHandler;</span>
<span class="fc" id="L394">        this.sharedState = (Map&lt;String, Object&gt;)sharedState;</span>
<span class="fc" id="L395">        this.options = options;</span>

<span class="fc" id="L397">        ldapEnvironment = new Hashtable&lt;String, Object&gt;(9);</span>
<span class="fc" id="L398">        ldapEnvironment.put(Context.INITIAL_CONTEXT_FACTORY,</span>
            &quot;com.sun.jndi.ldap.LdapCtxFactory&quot;);

        // Add any JNDI properties to the environment
<span class="fc bfc" id="L402" title="All 2 branches covered.">        for (String key : options.keySet()) {</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">            if (key.indexOf(&quot;.&quot;) &gt; -1) {</span>
<span class="nc" id="L404">                ldapEnvironment.put(key, options.get(key));</span>
            }
<span class="fc" id="L406">        }</span>

        // initialize any configured options

<span class="fc" id="L410">        userProvider = (String)options.get(USER_PROVIDER);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (userProvider != null) {</span>
<span class="fc" id="L412">            ldapEnvironment.put(Context.PROVIDER_URL, userProvider);</span>
        }

<span class="fc" id="L415">        authcIdentity = (String)options.get(AUTHC_IDENTITY);</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (authcIdentity != null &amp;&amp;</span>
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">            (authcIdentity.indexOf(USERNAME_TOKEN) != -1)) {</span>
<span class="fc" id="L418">            identityMatcher = USERNAME_PATTERN.matcher(authcIdentity);</span>
        }

<span class="fc" id="L421">        userFilter = (String)options.get(USER_FILTER);</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (userFilter != null) {</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            if (userFilter.indexOf(USERNAME_TOKEN) != -1) {</span>
<span class="fc" id="L424">                filterMatcher = USERNAME_PATTERN.matcher(userFilter);</span>
            }
<span class="fc" id="L426">            constraints = new SearchControls();</span>
<span class="fc" id="L427">            constraints.setSearchScope(SearchControls.SUBTREE_SCOPE);</span>
<span class="fc" id="L428">            constraints.setReturningAttributes(new String[0]); //return no attrs</span>
<span class="fc" id="L429">            constraints.setReturningObjFlag(true); // to get the full DN</span>
        }

<span class="fc" id="L432">        authzIdentity = (String)options.get(AUTHZ_IDENTITY);</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (authzIdentity != null &amp;&amp;</span>
<span class="pc bpc" id="L434" title="1 of 4 branches missed.">            authzIdentity.startsWith(&quot;{&quot;) &amp;&amp; authzIdentity.endsWith(&quot;}&quot;)) {</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">            if (constraints != null) {</span>
<span class="fc" id="L436">                authzIdentityAttr =</span>
<span class="fc" id="L437">                    authzIdentity.substring(1, authzIdentity.length() - 1);</span>
<span class="fc" id="L438">                constraints.setReturningAttributes(</span>
                    new String[]{authzIdentityAttr});
            }
<span class="fc" id="L441">            authzIdentity = null; // set later, from the specified attribute</span>
        }

        // determine mode
<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (authcIdentity != null) {</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">            if (userFilter != null) {</span>
<span class="fc" id="L447">                authFirst = true; // authentication-first mode</span>
            } else {
<span class="fc" id="L449">                authOnly = true; // authentication-only mode</span>
            }
        }

<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (&quot;false&quot;.equalsIgnoreCase((String)options.get(&quot;useSSL&quot;))) {</span>
<span class="fc" id="L454">            useSSL = false;</span>
<span class="fc" id="L455">            ldapEnvironment.remove(Context.SECURITY_PROTOCOL);</span>
        } else {
<span class="fc" id="L457">            ldapEnvironment.put(Context.SECURITY_PROTOCOL, &quot;ssl&quot;);</span>
        }

<span class="fc" id="L460">        tryFirstPass =</span>
<span class="fc" id="L461">                &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;tryFirstPass&quot;));</span>

<span class="fc" id="L463">        useFirstPass =</span>
<span class="fc" id="L464">                &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;useFirstPass&quot;));</span>

<span class="fc" id="L466">        storePass = &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;storePass&quot;));</span>

<span class="fc" id="L468">        clearPass = &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;clearPass&quot;));</span>

<span class="fc" id="L470">        debug = &quot;true&quot;.equalsIgnoreCase((String)options.get(&quot;debug&quot;));</span>

<span class="fc bfc" id="L472" title="All 2 branches covered.">        if (debug) {</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">            if (authFirst) {</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                    &quot;authentication-first mode; &quot; +
                    (useSSL ? &quot;SSL enabled&quot; : &quot;SSL disabled&quot;));
<span class="fc bfc" id="L477" title="All 2 branches covered.">            } else if (authOnly) {</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                    &quot;authentication-only mode; &quot; +
                    (useSSL ? &quot;SSL enabled&quot; : &quot;SSL disabled&quot;));
            } else {
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                    &quot;search-first mode; &quot; +
                    (useSSL ? &quot;SSL enabled&quot; : &quot;SSL disabled&quot;));
            }
        }
<span class="fc" id="L487">    }</span>

    /**
     * Begin user authentication.
     *
     * &lt;p&gt; Acquire the user's credentials and verify them against the
     * specified LDAP directory.
     *
     * @return true always, since this &lt;code&gt;LoginModule&lt;/code&gt;
     *          should not be ignored.
     * @exception FailedLoginException if the authentication fails.
     * @exception LoginException if this &lt;code&gt;LoginModule&lt;/code&gt;
     *          is unable to perform the authentication.
     */
    public boolean login() throws LoginException {

<span class="fc bfc" id="L503" title="All 2 branches covered.">        if (userProvider == null) {</span>
<span class="fc" id="L504">            throw new LoginException</span>
                (&quot;Unable to locate the LDAP directory service&quot;);
        }

<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        if (debug) {</span>
<span class="fc" id="L509">            System.out.println(&quot;\t\t[LdapLoginModule] user provider: &quot; +</span>
                userProvider);
        }

        // attempt the authentication
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">        if (tryFirstPass) {</span>

            try {
                // attempt the authentication by getting the
                // username and password from shared state
<span class="nc" id="L519">                attemptAuthentication(true);</span>

                // authentication succeeded
<span class="nc" id="L522">                succeeded = true;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L524">                    System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                                &quot;tryFirstPass succeeded&quot;);
                }
<span class="nc" id="L527">                return true;</span>

<span class="nc" id="L529">            } catch (LoginException le) {</span>
                // authentication failed -- try again below by prompting
<span class="nc" id="L531">                cleanState();</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L533">                    System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
<span class="nc" id="L534">                                &quot;tryFirstPass failed: &quot; + le.toString());</span>
                }
<span class="nc" id="L536">            }</span>

<span class="pc bpc" id="L538" title="1 of 2 branches missed.">        } else if (useFirstPass) {</span>

            try {
                // attempt the authentication by getting the
                // username and password from shared state
<span class="nc" id="L543">                attemptAuthentication(true);</span>

                // authentication succeeded
<span class="nc" id="L546">                succeeded = true;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L548">                    System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                                &quot;useFirstPass succeeded&quot;);
                }
<span class="nc" id="L551">                return true;</span>

<span class="nc" id="L553">            } catch (LoginException le) {</span>
                // authentication failed
<span class="nc" id="L555">                cleanState();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L557">                    System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                                &quot;useFirstPass failed&quot;);
                }
<span class="nc" id="L560">                throw le;</span>
            }
        }

        // attempt the authentication by prompting for the username and pwd
        try {
<span class="nc" id="L566">            attemptAuthentication(false);</span>

            // authentication succeeded
<span class="nc" id="L569">           succeeded = true;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L571">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                                &quot;authentication succeeded&quot;);
            }
<span class="nc" id="L574">            return true;</span>

<span class="fc" id="L576">        } catch (LoginException le) {</span>
<span class="fc" id="L577">            cleanState();</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="fc" id="L579">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                                &quot;authentication failed&quot;);
            }
<span class="fc" id="L582">            throw le;</span>
        }
    }

    /**
     * Complete user authentication.
     *
     * &lt;p&gt; This method is called if the LoginContext's
     * overall authentication succeeded
     * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules
     * succeeded).
     *
     * &lt;p&gt; If this LoginModule's own authentication attempt
     * succeeded (checked by retrieving the private state saved by the
     * &lt;code&gt;login&lt;/code&gt; method), then this method associates an
     * &lt;code&gt;LdapPrincipal&lt;/code&gt; and one or more &lt;code&gt;UserPrincipal&lt;/code&gt;s
     * with the &lt;code&gt;Subject&lt;/code&gt; located in the
     * &lt;code&gt;LoginModule&lt;/code&gt;.  If this LoginModule's own
     * authentication attempted failed, then this method removes
     * any state that was originally saved.
     *
     * @exception LoginException if the commit fails
     * @return true if this LoginModule's own login and commit
     *          attempts succeeded, or false otherwise.
     */
    public boolean commit() throws LoginException {

<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (succeeded == false) {</span>
<span class="nc" id="L610">            return false;</span>
        } else {
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (subject.isReadOnly()) {</span>
<span class="nc" id="L613">                cleanState();</span>
<span class="nc" id="L614">                throw new LoginException (&quot;Subject is read-only&quot;);</span>
            }
            // add Principals to the Subject
<span class="nc" id="L617">            Set&lt;Principal&gt; principals = subject.getPrincipals();</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (! principals.contains(ldapPrincipal)) {</span>
<span class="nc" id="L619">                principals.add(ldapPrincipal);</span>
            }
<span class="nc bnc" id="L621" title="All 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L622">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                                   &quot;added LdapPrincipal \&quot;&quot; +
                                   ldapPrincipal +
                                   &quot;\&quot; to Subject&quot;);
            }

<span class="nc bnc" id="L628" title="All 2 branches missed.">            if (! principals.contains(userPrincipal)) {</span>
<span class="nc" id="L629">                principals.add(userPrincipal);</span>
            }
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L632">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                                   &quot;added UserPrincipal \&quot;&quot; +
                                   userPrincipal +
                                   &quot;\&quot; to Subject&quot;);
            }

<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (authzPrincipal != null &amp;&amp;</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">                (! principals.contains(authzPrincipal))) {</span>
<span class="nc" id="L640">                principals.add(authzPrincipal);</span>

<span class="nc bnc" id="L642" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L643">                    System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                                   &quot;added UserPrincipal \&quot;&quot; +
                                   authzPrincipal +
                                   &quot;\&quot; to Subject&quot;);
                }
            }
        }
        // in any case, clean out state
<span class="nc" id="L651">        cleanState();</span>
<span class="nc" id="L652">        commitSucceeded = true;</span>
<span class="nc" id="L653">        return true;</span>
    }

    /**
     * Abort user authentication.
     *
     * &lt;p&gt; This method is called if the overall authentication failed.
     * (the relevant REQUIRED, REQUISITE, SUFFICIENT and OPTIONAL LoginModules
     * did not succeed).
     *
     * &lt;p&gt; If this LoginModule's own authentication attempt
     * succeeded (checked by retrieving the private state saved by the
     * &lt;code&gt;login&lt;/code&gt; and &lt;code&gt;commit&lt;/code&gt; methods),
     * then this method cleans up any state that was originally saved.
     *
     * @exception LoginException if the abort fails.
     * @return false if this LoginModule's own login and/or commit attempts
     *          failed, and true otherwise.
     */
    public boolean abort() throws LoginException {
<span class="pc bpc" id="L673" title="1 of 2 branches missed.">        if (debug)</span>
<span class="fc" id="L674">            System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                &quot;aborted authentication&quot;);

<span class="pc bpc" id="L677" title="1 of 2 branches missed.">        if (succeeded == false) {</span>
<span class="fc" id="L678">            return false;</span>
<span class="nc bnc" id="L679" title="All 4 branches missed.">        } else if (succeeded == true &amp;&amp; commitSucceeded == false) {</span>

            // Clean out state
<span class="nc" id="L682">            succeeded = false;</span>
<span class="nc" id="L683">            cleanState();</span>

<span class="nc" id="L685">            ldapPrincipal = null;</span>
<span class="nc" id="L686">            userPrincipal = null;</span>
<span class="nc" id="L687">            authzPrincipal = null;</span>
        } else {
            // overall authentication succeeded and commit succeeded,
            // but someone else's commit failed
<span class="nc" id="L691">            logout();</span>
        }
<span class="nc" id="L693">        return true;</span>
    }

    /**
     * Logout a user.
     *
     * &lt;p&gt; This method removes the Principals
     * that were added by the &lt;code&gt;commit&lt;/code&gt; method.
     *
     * @exception LoginException if the logout fails.
     * @return true in all cases since this &lt;code&gt;LoginModule&lt;/code&gt;
     *          should not be ignored.
     */
    public boolean logout() throws LoginException {
<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (subject.isReadOnly()) {</span>
<span class="nc" id="L708">            cleanState();</span>
<span class="nc" id="L709">            throw new LoginException (&quot;Subject is read-only&quot;);</span>
        }
<span class="nc" id="L711">        Set&lt;Principal&gt; principals = subject.getPrincipals();</span>
<span class="nc" id="L712">        principals.remove(ldapPrincipal);</span>
<span class="nc" id="L713">        principals.remove(userPrincipal);</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (authzIdentity != null) {</span>
<span class="nc" id="L715">            principals.remove(authzPrincipal);</span>
        }

        // clean out state
<span class="nc" id="L719">        cleanState();</span>
<span class="nc" id="L720">        succeeded = false;</span>
<span class="nc" id="L721">        commitSucceeded = false;</span>

<span class="nc" id="L723">        ldapPrincipal = null;</span>
<span class="nc" id="L724">        userPrincipal = null;</span>
<span class="nc" id="L725">        authzPrincipal = null;</span>

<span class="nc bnc" id="L727" title="All 2 branches missed.">        if (debug) {</span>
<span class="nc" id="L728">            System.out.println(&quot;\t\t[LdapLoginModule] logged out Subject&quot;);</span>
        }
<span class="nc" id="L730">        return true;</span>
    }

    /**
     * Attempt authentication
     *
     * @param getPasswdFromSharedState boolean that tells this method whether
     *          to retrieve the password from the sharedState.
     * @exception LoginException if the authentication attempt fails.
     */
    private void attemptAuthentication(boolean getPasswdFromSharedState)
        throws LoginException {

        // first get the username and password
<span class="fc" id="L744">        getUsernamePassword(getPasswdFromSharedState);</span>

<span class="pc bpc" id="L746" title="2 of 4 branches missed.">        if (password == null || password.length == 0) {</span>
<span class="nc" id="L747">            throw (LoginException)</span>
                new FailedLoginException(&quot;No password was supplied&quot;);
        }

<span class="fc" id="L751">        String dn = &quot;&quot;;</span>

<span class="fc bfc" id="L753" title="All 4 branches covered.">        if (authFirst || authOnly) {</span>

<span class="fc" id="L755">            String id = replaceUsernameToken(identityMatcher, authcIdentity);</span>

            // Prepare to bind using user's username and password
<span class="fc" id="L758">            ldapEnvironment.put(Context.SECURITY_CREDENTIALS, password);</span>
<span class="fc" id="L759">            ldapEnvironment.put(Context.SECURITY_PRINCIPAL, id);</span>

<span class="pc bpc" id="L761" title="1 of 2 branches missed.">            if (debug) {</span>
<span class="fc" id="L762">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                    &quot;attempting to authenticate user: &quot; + username);
            }

            try {
                // Connect to the LDAP server (using simple bind)
<span class="nc" id="L768">                ctx = new InitialLdapContext(ldapEnvironment, null);</span>

<span class="fc" id="L770">            } catch (NamingException e) {</span>
<span class="fc" id="L771">                throw (LoginException)</span>
                    new FailedLoginException(&quot;Cannot bind to LDAP server&quot;)
<span class="fc" id="L773">                        .initCause(e);</span>
<span class="nc" id="L774">            }</span>

            // Authentication has succeeded

            // Locate the user's distinguished name
<span class="nc bnc" id="L779" title="All 2 branches missed.">            if (userFilter != null) {</span>
<span class="nc" id="L780">                dn = findUserDN(ctx);</span>
            } else {
<span class="nc" id="L782">                dn = id;</span>
            }

<span class="nc" id="L785">        } else {</span>

            try {
                // Connect to the LDAP server (using anonymous bind)
<span class="nc" id="L789">                ctx = new InitialLdapContext(ldapEnvironment, null);</span>

<span class="fc" id="L791">            } catch (NamingException e) {</span>
<span class="fc" id="L792">                throw (LoginException)</span>
                    new FailedLoginException(&quot;Cannot connect to LDAP server&quot;)
<span class="fc" id="L794">                        .initCause(e);</span>
<span class="nc" id="L795">            }</span>

            // Locate the user's distinguished name
<span class="nc" id="L798">            dn = findUserDN(ctx);</span>

            try {

                // Prepare to bind using user's distinguished name and password
<span class="nc" id="L803">                ctx.addToEnvironment(Context.SECURITY_AUTHENTICATION, &quot;simple&quot;);</span>
<span class="nc" id="L804">                ctx.addToEnvironment(Context.SECURITY_PRINCIPAL, dn);</span>
<span class="nc" id="L805">                ctx.addToEnvironment(Context.SECURITY_CREDENTIALS, password);</span>

<span class="nc bnc" id="L807" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L808">                    System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                        &quot;attempting to authenticate user: &quot; + username);
                }
                // Connect to the LDAP server (using simple bind)
<span class="nc" id="L812">                ctx.reconnect(null);</span>

                // Authentication has succeeded

<span class="nc" id="L816">            } catch (NamingException e) {</span>
<span class="nc" id="L817">                throw (LoginException)</span>
                    new FailedLoginException(&quot;Cannot bind to LDAP server&quot;)
<span class="nc" id="L819">                        .initCause(e);</span>
<span class="nc" id="L820">            }</span>
        }

        // Save input as shared state only if authentication succeeded
<span class="nc bnc" id="L824" title="All 2 branches missed.">        if (storePass &amp;&amp;</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">            !sharedState.containsKey(USERNAME_KEY) &amp;&amp;</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">            !sharedState.containsKey(PASSWORD_KEY)) {</span>
<span class="nc" id="L827">            sharedState.put(USERNAME_KEY, username);</span>
<span class="nc" id="L828">            sharedState.put(PASSWORD_KEY, password);</span>
        }

        // Create the user principals
<span class="nc" id="L832">        userPrincipal = new UserPrincipal(username);</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (authzIdentity != null) {</span>
<span class="nc" id="L834">            authzPrincipal = new UserPrincipal(authzIdentity);</span>
        }

        try {

<span class="nc" id="L839">            ldapPrincipal = new LdapPrincipal(dn);</span>

<span class="nc" id="L841">        } catch (InvalidNameException e) {</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L843">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                                   &quot;cannot create LdapPrincipal: bad DN&quot;);
            }
<span class="nc" id="L846">            throw (LoginException)</span>
                new FailedLoginException(&quot;Cannot create LdapPrincipal&quot;)
<span class="nc" id="L848">                    .initCause(e);</span>
<span class="nc" id="L849">        }</span>
<span class="nc" id="L850">    }</span>

    /**
     * Search for the user's entry.
     * Determine the distinguished name of the user's entry and optionally
     * an authorization identity for the user.
     *
     * @param ctx an LDAP context to use for the search
     * @return the user's distinguished name or an empty string if none
     *         was found.
     * @exception LoginException if the user's entry cannot be found.
     */
    private String findUserDN(LdapContext ctx) throws LoginException {

<span class="nc" id="L864">        String userDN = &quot;&quot;;</span>

        // Locate the user's LDAP entry
<span class="nc bnc" id="L867" title="All 2 branches missed.">        if (userFilter != null) {</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L869">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                    &quot;searching for entry belonging to user: &quot; + username);
            }
        } else {
<span class="nc bnc" id="L873" title="All 2 branches missed.">            if (debug) {</span>
<span class="nc" id="L874">                System.out.println(&quot;\t\t[LdapLoginModule] &quot; +</span>
                    &quot;cannot search for entry belonging to user: &quot; + username);
            }
<span class="nc" id="L877">            throw (LoginException)</span>
                new FailedLoginException(&quot;Cannot find user's LDAP entry&quot;);
        }

        try {
<span class="nc" id="L882">            NamingEnumeration&lt;SearchResult&gt; results = ctx.search(&quot;&quot;,</span>
<span class="nc" id="L883">                replaceUsernameToken(filterMatcher, userFilter), constraints);</span>

            // Extract the distinguished name of the user's entry
            // (Use the first entry if more than one is returned)
<span class="nc bnc" id="L887" title="All 2 branches missed.">            if (results.hasMore()) {</span>
<span class="nc" id="L888">                SearchResult entry = results.next();</span>

                // %%% - use the SearchResult.getNameInNamespace method
                //        available in JDK 1.5 and later.
                //        (can remove call to constraints.setReturningObjFlag)
<span class="nc" id="L893">                userDN = ((Context)entry.getObject()).getNameInNamespace();</span>

<span class="nc bnc" id="L895" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L896">                    System.out.println(&quot;\t\t[LdapLoginModule] found entry: &quot; +</span>
                        userDN);
                }

                // Extract a value from user's authorization identity attribute
<span class="nc bnc" id="L901" title="All 2 branches missed.">                if (authzIdentityAttr != null) {</span>
<span class="nc" id="L902">                    Attribute attr =</span>
<span class="nc" id="L903">                        entry.getAttributes().get(authzIdentityAttr);</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                    if (attr != null) {</span>
<span class="nc" id="L905">                        Object val = attr.get();</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">                        if (val instanceof String) {</span>
<span class="nc" id="L907">                            authzIdentity = (String) val;</span>
                        }
                    }
                }

<span class="nc" id="L912">                results.close();</span>

<span class="nc" id="L914">            } else {</span>
                // Bad username
<span class="nc bnc" id="L916" title="All 2 branches missed.">                if (debug) {</span>
<span class="nc" id="L917">                    System.out.println(&quot;\t\t[LdapLoginModule] user's entry &quot; +</span>
                        &quot;not found&quot;);
                }
            }

<span class="nc" id="L922">        } catch (NamingException e) {</span>
            // ignore
<span class="nc" id="L924">        }</span>

<span class="nc bnc" id="L926" title="All 2 branches missed.">        if (userDN.equals(&quot;&quot;)) {</span>
<span class="nc" id="L927">            throw (LoginException)</span>
                new FailedLoginException(&quot;Cannot find user's LDAP entry&quot;);
        } else {
<span class="nc" id="L930">            return userDN;</span>
        }
    }

    /**
     * Replace the username token
     *
     * @param string the target string
     * @return the modified string
     */
    private String replaceUsernameToken(Matcher matcher, String string) {
<span class="pc bpc" id="L941" title="1 of 2 branches missed.">        return matcher != null ? matcher.replaceAll(username) : string;</span>
    }

    /**
     * Get the username and password.
     * This method does not return any value.
     * Instead, it sets global name and password variables.
     *
     * &lt;p&gt; Also note that this method will set the username and password
     * values in the shared state in case subsequent LoginModules
     * want to use them via use/tryFirstPass.
     *
     * @param getPasswdFromSharedState boolean that tells this method whether
     *          to retrieve the password from the sharedState.
     * @exception LoginException if the username/password cannot be acquired.
     */
    private void getUsernamePassword(boolean getPasswdFromSharedState)
        throws LoginException {

<span class="pc bpc" id="L960" title="1 of 2 branches missed.">        if (getPasswdFromSharedState) {</span>
            // use the password saved by the first module in the stack
<span class="nc" id="L962">            username = (String)sharedState.get(USERNAME_KEY);</span>
<span class="nc" id="L963">            password = (char[])sharedState.get(PASSWORD_KEY);</span>
<span class="nc" id="L964">            return;</span>
        }

        // prompt for a username and password
<span class="pc bpc" id="L968" title="1 of 2 branches missed.">        if (callbackHandler == null)</span>
<span class="nc" id="L969">            throw new LoginException(&quot;No CallbackHandler available &quot; +</span>
                &quot;to acquire authentication information from the user&quot;);

<span class="fc" id="L972">        Callback[] callbacks = new Callback[2];</span>
<span class="fc" id="L973">        callbacks[0] = new NameCallback(rb.getString(&quot;username.&quot;));</span>
<span class="fc" id="L974">        callbacks[1] = new PasswordCallback(rb.getString(&quot;password.&quot;), false);</span>

        try {
<span class="fc" id="L977">            callbackHandler.handle(callbacks);</span>
<span class="fc" id="L978">            username = ((NameCallback)callbacks[0]).getName();</span>
<span class="fc" id="L979">            char[] tmpPassword = ((PasswordCallback)callbacks[1]).getPassword();</span>
<span class="fc" id="L980">            password = new char[tmpPassword.length];</span>
<span class="fc" id="L981">            System.arraycopy(tmpPassword, 0,</span>
                                password, 0, tmpPassword.length);
<span class="fc" id="L983">            ((PasswordCallback)callbacks[1]).clearPassword();</span>

<span class="nc" id="L985">        } catch (java.io.IOException ioe) {</span>
<span class="nc" id="L986">            throw new LoginException(ioe.toString());</span>

<span class="nc" id="L988">        } catch (UnsupportedCallbackException uce) {</span>
<span class="nc" id="L989">            throw new LoginException(&quot;Error: &quot; + uce.getCallback().toString() +</span>
                        &quot; not available to acquire authentication information&quot; +
                        &quot; from the user&quot;);
<span class="fc" id="L992">        }</span>
<span class="fc" id="L993">    }</span>

    /**
     * Clean out state because of a failed authentication attempt
     */
    private void cleanState() {
<span class="fc" id="L999">        username = null;</span>
<span class="pc bpc" id="L1000" title="1 of 2 branches missed.">        if (password != null) {</span>
<span class="fc" id="L1001">            Arrays.fill(password, ' ');</span>
<span class="fc" id="L1002">            password = null;</span>
        }
        try {
<span class="pc bpc" id="L1005" title="1 of 2 branches missed.">            if (ctx != null) {</span>
<span class="nc" id="L1006">                ctx.close();</span>
            }
<span class="nc" id="L1008">        } catch (NamingException e) {</span>
            // ignore
<span class="fc" id="L1010">        }</span>
<span class="fc" id="L1011">        ctx = null;</span>

<span class="pc bpc" id="L1013" title="1 of 2 branches missed.">        if (clearPass) {</span>
<span class="nc" id="L1014">            sharedState.remove(USERNAME_KEY);</span>
<span class="nc" id="L1015">            sharedState.remove(PASSWORD_KEY);</span>
        }
<span class="fc" id="L1017">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>