<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KeyFactory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">KeyFactory.java</span></div><h1>KeyFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.util.*;

import java.security.Provider.Service;
import java.security.spec.KeySpec;
import java.security.spec.InvalidKeySpecException;

import sun.security.util.Debug;
import sun.security.jca.*;
import sun.security.jca.GetInstance.Instance;

/**
 * Key factories are used to convert &lt;I&gt;keys&lt;/I&gt; (opaque
 * cryptographic keys of type {@code Key}) into &lt;I&gt;key specifications&lt;/I&gt;
 * (transparent representations of the underlying key material), and vice
 * versa.
 *
 * &lt;P&gt; Key factories are bi-directional. That is, they allow you to build an
 * opaque key object from a given key specification (key material), or to
 * retrieve the underlying key material of a key object in a suitable format.
 *
 * &lt;P&gt; Multiple compatible key specifications may exist for the same key.
 * For example, a DSA public key may be specified using
 * {@code DSAPublicKeySpec} or
 * {@code X509EncodedKeySpec}. A key factory can be used to translate
 * between compatible key specifications.
 *
 * &lt;P&gt; The following is an example of how to use a key factory in order to
 * instantiate a DSA public key from its encoding.
 * Assume Alice has received a digital signature from Bob.
 * Bob also sent her his public key (in encoded format) to verify
 * his signature. Alice then performs the following actions:
 *
 * &lt;pre&gt;
 * X509EncodedKeySpec bobPubKeySpec = new X509EncodedKeySpec(bobEncodedPubKey);
 * KeyFactory keyFactory = KeyFactory.getInstance(&quot;DSA&quot;);
 * PublicKey bobPubKey = keyFactory.generatePublic(bobPubKeySpec);
 * Signature sig = Signature.getInstance(&quot;DSA&quot;);
 * sig.initVerify(bobPubKey);
 * sig.update(data);
 * sig.verify(signature);
 * &lt;/pre&gt;
 *
 * &lt;p&gt; Every implementation of the Java platform is required to support the
 * following standard {@code KeyFactory} algorithms:
 * &lt;ul&gt;
 * &lt;li&gt;{@code DiffieHellman}&lt;/li&gt;
 * &lt;li&gt;{@code DSA}&lt;/li&gt;
 * &lt;li&gt;{@code RSA}&lt;/li&gt;
 * &lt;/ul&gt;
 * These algorithms are described in the &lt;a href=
 * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyFactory&quot;&gt;
 * KeyFactory section&lt;/a&gt; of the
 * Java Cryptography Architecture Standard Algorithm Name Documentation.
 * Consult the release documentation for your implementation to see if any
 * other algorithms are supported.
 *
 * @author Jan Luehe
 *
 * @see Key
 * @see PublicKey
 * @see PrivateKey
 * @see java.security.spec.KeySpec
 * @see java.security.spec.DSAPublicKeySpec
 * @see java.security.spec.X509EncodedKeySpec
 *
 * @since 1.2
 */

public class KeyFactory {

<span class="fc" id="L98">    private static final Debug debug =</span>
<span class="fc" id="L99">                        Debug.getInstance(&quot;jca&quot;, &quot;KeyFactory&quot;);</span>

    // The algorithm associated with this key factory
    private final String algorithm;

    // The provider
    private Provider provider;

    // The provider implementation (delegate)
    private volatile KeyFactorySpi spi;

    // lock for mutex during provider selection
<span class="fc" id="L111">    private final Object lock = new Object();</span>

    // remaining services to try in provider selection
    // null once provider is selected
    private Iterator&lt;Service&gt; serviceIterator;

    /**
     * Creates a KeyFactory object.
     *
     * @param keyFacSpi the delegate
     * @param provider the provider
     * @param algorithm the name of the algorithm
     * to associate with this {@code KeyFactory}
     */
    protected KeyFactory(KeyFactorySpi keyFacSpi, Provider provider,
<span class="fc" id="L126">                         String algorithm) {</span>
<span class="fc" id="L127">        this.spi = keyFacSpi;</span>
<span class="fc" id="L128">        this.provider = provider;</span>
<span class="fc" id="L129">        this.algorithm = algorithm;</span>
<span class="fc" id="L130">    }</span>

<span class="fc" id="L132">    private KeyFactory(String algorithm) throws NoSuchAlgorithmException {</span>
<span class="fc" id="L133">        this.algorithm = algorithm;</span>
<span class="fc" id="L134">        List&lt;Service&gt; list = GetInstance.getServices(&quot;KeyFactory&quot;, algorithm);</span>
<span class="fc" id="L135">        serviceIterator = list.iterator();</span>
        // fetch and instantiate initial spi
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (nextSpi(null) == null) {</span>
<span class="nc" id="L138">            throw new NoSuchAlgorithmException</span>
                (algorithm + &quot; KeyFactory not available&quot;);
        }
<span class="fc" id="L141">    }</span>

    /**
     * Returns a KeyFactory object that converts
     * public/private keys of the specified algorithm.
     *
     * &lt;p&gt; This method traverses the list of registered security Providers,
     * starting with the most preferred Provider.
     * A new KeyFactory object encapsulating the
     * KeyFactorySpi implementation from the first
     * Provider that supports the specified algorithm is returned.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param algorithm the name of the requested key algorithm.
     * See the KeyFactory section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyFactory&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @return the new KeyFactory object.
     *
     * @exception NoSuchAlgorithmException if no Provider supports a
     *          KeyFactorySpi implementation for the
     *          specified algorithm.
     *
     * @see Provider
     */
    public static KeyFactory getInstance(String algorithm)
            throws NoSuchAlgorithmException {
<span class="fc" id="L172">        return new KeyFactory(algorithm);</span>
    }

    /**
     * Returns a KeyFactory object that converts
     * public/private keys of the specified algorithm.
     *
     * &lt;p&gt; A new KeyFactory object encapsulating the
     * KeyFactorySpi implementation from the specified provider
     * is returned.  The specified provider must be registered
     * in the security provider list.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param algorithm the name of the requested key algorithm.
     * See the KeyFactory section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyFactory&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @param provider the name of the provider.
     *
     * @return the new KeyFactory object.
     *
     * @exception NoSuchAlgorithmException if a KeyFactorySpi
     *          implementation for the specified algorithm is not
     *          available from the specified provider.
     *
     * @exception NoSuchProviderException if the specified provider is not
     *          registered in the security provider list.
     *
     * @exception IllegalArgumentException if the provider name is null
     *          or empty.
     *
     * @see Provider
     */
    public static KeyFactory getInstance(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
<span class="fc" id="L211">        Instance instance = GetInstance.getInstance(&quot;KeyFactory&quot;,</span>
            KeyFactorySpi.class, algorithm, provider);
<span class="fc" id="L213">        return new KeyFactory((KeyFactorySpi)instance.impl,</span>
            instance.provider, algorithm);
    }

    /**
     * Returns a KeyFactory object that converts
     * public/private keys of the specified algorithm.
     *
     * &lt;p&gt; A new KeyFactory object encapsulating the
     * KeyFactorySpi implementation from the specified Provider
     * object is returned.  Note that the specified Provider object
     * does not have to be registered in the provider list.
     *
     * @param algorithm the name of the requested key algorithm.
     * See the KeyFactory section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyFactory&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @param provider the provider.
     *
     * @return the new KeyFactory object.
     *
     * @exception NoSuchAlgorithmException if a KeyFactorySpi
     *          implementation for the specified algorithm is not available
     *          from the specified Provider object.
     *
     * @exception IllegalArgumentException if the specified provider is null.
     *
     * @see Provider
     *
     * @since 1.4
     */
    public static KeyFactory getInstance(String algorithm, Provider provider)
            throws NoSuchAlgorithmException {
<span class="fc" id="L248">        Instance instance = GetInstance.getInstance(&quot;KeyFactory&quot;,</span>
            KeyFactorySpi.class, algorithm, provider);
<span class="fc" id="L250">        return new KeyFactory((KeyFactorySpi)instance.impl,</span>
            instance.provider, algorithm);
    }

    /**
     * Returns the provider of this key factory object.
     *
     * @return the provider of this key factory object
     */
    public final Provider getProvider() {
<span class="nc" id="L260">        synchronized (lock) {</span>
            // disable further failover after this call
<span class="nc" id="L262">            serviceIterator = null;</span>
<span class="nc" id="L263">            return provider;</span>
<span class="nc" id="L264">        }</span>
    }

    /**
     * Gets the name of the algorithm
     * associated with this {@code KeyFactory}.
     *
     * @return the name of the algorithm associated with this
     * {@code KeyFactory}
     */
    public final String getAlgorithm() {
<span class="nc" id="L275">        return this.algorithm;</span>
    }

    /**
     * Update the active KeyFactorySpi of this class and return the next
     * implementation for failover. If no more implemenations are
     * available, this method returns null. However, the active spi of
     * this class is never set to null.
     */
    private KeyFactorySpi nextSpi(KeyFactorySpi oldSpi) {
<span class="fc" id="L285">        synchronized (lock) {</span>
            // somebody else did a failover concurrently
            // try that spi now
<span class="pc bpc" id="L288" title="1 of 4 branches missed.">            if ((oldSpi != null) &amp;&amp; (oldSpi != spi)) {</span>
<span class="nc" id="L289">                return spi;</span>
            }
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">            if (serviceIterator == null) {</span>
<span class="nc" id="L292">                return null;</span>
            }
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            while (serviceIterator.hasNext()) {</span>
<span class="fc" id="L295">                Service s = serviceIterator.next();</span>
                try {
<span class="fc" id="L297">                    Object obj = s.newInstance(null);</span>
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">                    if (obj instanceof KeyFactorySpi == false) {</span>
<span class="nc" id="L299">                        continue;</span>
                    }
<span class="fc" id="L301">                    KeyFactorySpi spi = (KeyFactorySpi)obj;</span>
<span class="fc" id="L302">                    provider = s.getProvider();</span>
<span class="fc" id="L303">                    this.spi = spi;</span>
<span class="fc" id="L304">                    return spi;</span>
<span class="nc" id="L305">                } catch (NoSuchAlgorithmException e) {</span>
                    // ignore
                }
<span class="nc" id="L308">            }</span>
<span class="nc" id="L309">            serviceIterator = null;</span>
<span class="nc" id="L310">            return null;</span>
<span class="nc" id="L311">        }</span>
    }

    /**
     * Generates a public key object from the provided key specification
     * (key material).
     *
     * @param keySpec the specification (key material) of the public key.
     *
     * @return the public key.
     *
     * @exception InvalidKeySpecException if the given key specification
     * is inappropriate for this key factory to produce a public key.
     */
    public final PublicKey generatePublic(KeySpec keySpec)
            throws InvalidKeySpecException {
<span class="fc bfc" id="L327" title="All 2 branches covered.">        if (serviceIterator == null) {</span>
<span class="fc" id="L328">            return spi.engineGeneratePublic(keySpec);</span>
        }
<span class="fc" id="L330">        Exception failure = null;</span>
<span class="fc" id="L331">        KeyFactorySpi mySpi = spi;</span>
        do {
            try {
<span class="fc" id="L334">                return mySpi.engineGeneratePublic(keySpec);</span>
<span class="fc" id="L335">            } catch (Exception e) {</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                if (failure == null) {</span>
<span class="fc" id="L337">                    failure = e;</span>
                }
<span class="fc" id="L339">                mySpi = nextSpi(mySpi);</span>
            }
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        } while (mySpi != null);</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (failure instanceof RuntimeException) {</span>
<span class="nc" id="L343">            throw (RuntimeException)failure;</span>
        }
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (failure instanceof InvalidKeySpecException) {</span>
<span class="nc" id="L346">            throw (InvalidKeySpecException)failure;</span>
        }
<span class="nc" id="L348">        throw new InvalidKeySpecException</span>
                (&quot;Could not generate public key&quot;, failure);
    }

    /**
     * Generates a private key object from the provided key specification
     * (key material).
     *
     * @param keySpec the specification (key material) of the private key.
     *
     * @return the private key.
     *
     * @exception InvalidKeySpecException if the given key specification
     * is inappropriate for this key factory to produce a private key.
     */
    public final PrivateKey generatePrivate(KeySpec keySpec)
            throws InvalidKeySpecException {
<span class="fc bfc" id="L365" title="All 2 branches covered.">        if (serviceIterator == null) {</span>
<span class="fc" id="L366">            return spi.engineGeneratePrivate(keySpec);</span>
        }
<span class="fc" id="L368">        Exception failure = null;</span>
<span class="fc" id="L369">        KeyFactorySpi mySpi = spi;</span>
        do {
            try {
<span class="fc" id="L372">                return mySpi.engineGeneratePrivate(keySpec);</span>
<span class="fc" id="L373">            } catch (Exception e) {</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">                if (failure == null) {</span>
<span class="fc" id="L375">                    failure = e;</span>
                }
<span class="fc" id="L377">                mySpi = nextSpi(mySpi);</span>
            }
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        } while (mySpi != null);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (failure instanceof RuntimeException) {</span>
<span class="nc" id="L381">            throw (RuntimeException)failure;</span>
        }
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (failure instanceof InvalidKeySpecException) {</span>
<span class="nc" id="L384">            throw (InvalidKeySpecException)failure;</span>
        }
<span class="nc" id="L386">        throw new InvalidKeySpecException</span>
                (&quot;Could not generate private key&quot;, failure);
    }

    /**
     * Returns a specification (key material) of the given key object.
     * {@code keySpec} identifies the specification class in which
     * the key material should be returned. It could, for example, be
     * {@code DSAPublicKeySpec.class}, to indicate that the
     * key material should be returned in an instance of the
     * {@code DSAPublicKeySpec} class.
     *
     * @param &lt;T&gt; the type of the key specification to be returned
     *
     * @param key the key.
     *
     * @param keySpec the specification class in which
     * the key material should be returned.
     *
     * @return the underlying key specification (key material) in an instance
     * of the requested specification class.
     *
     * @exception InvalidKeySpecException if the requested key specification is
     * inappropriate for the given key, or the given key cannot be processed
     * (e.g., the given key has an unrecognized algorithm or format).
     */
    public final &lt;T extends KeySpec&gt; T getKeySpec(Key key, Class&lt;T&gt; keySpec)
            throws InvalidKeySpecException {
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if (serviceIterator == null) {</span>
<span class="fc" id="L415">            return spi.engineGetKeySpec(key, keySpec);</span>
        }
<span class="nc" id="L417">        Exception failure = null;</span>
<span class="nc" id="L418">        KeyFactorySpi mySpi = spi;</span>
        do {
            try {
<span class="nc" id="L421">                return mySpi.engineGetKeySpec(key, keySpec);</span>
<span class="nc" id="L422">            } catch (Exception e) {</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                if (failure == null) {</span>
<span class="nc" id="L424">                    failure = e;</span>
                }
<span class="nc" id="L426">                mySpi = nextSpi(mySpi);</span>
            }
<span class="nc bnc" id="L428" title="All 2 branches missed.">        } while (mySpi != null);</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if (failure instanceof RuntimeException) {</span>
<span class="nc" id="L430">            throw (RuntimeException)failure;</span>
        }
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (failure instanceof InvalidKeySpecException) {</span>
<span class="nc" id="L433">            throw (InvalidKeySpecException)failure;</span>
        }
<span class="nc" id="L435">        throw new InvalidKeySpecException</span>
                (&quot;Could not get key spec&quot;, failure);
    }

    /**
     * Translates a key object, whose provider may be unknown or potentially
     * untrusted, into a corresponding key object of this key factory.
     *
     * @param key the key whose provider is unknown or untrusted.
     *
     * @return the translated key.
     *
     * @exception InvalidKeyException if the given key cannot be processed
     * by this key factory.
     */
    public final Key translateKey(Key key) throws InvalidKeyException {
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">        if (serviceIterator == null) {</span>
<span class="fc" id="L452">            return spi.engineTranslateKey(key);</span>
        }
<span class="nc" id="L454">        Exception failure = null;</span>
<span class="nc" id="L455">        KeyFactorySpi mySpi = spi;</span>
        do {
            try {
<span class="nc" id="L458">                return mySpi.engineTranslateKey(key);</span>
<span class="nc" id="L459">            } catch (Exception e) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                if (failure == null) {</span>
<span class="nc" id="L461">                    failure = e;</span>
                }
<span class="nc" id="L463">                mySpi = nextSpi(mySpi);</span>
            }
<span class="nc bnc" id="L465" title="All 2 branches missed.">        } while (mySpi != null);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (failure instanceof RuntimeException) {</span>
<span class="nc" id="L467">            throw (RuntimeException)failure;</span>
        }
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (failure instanceof InvalidKeyException) {</span>
<span class="nc" id="L470">            throw (InvalidKeyException)failure;</span>
        }
<span class="nc" id="L472">        throw new InvalidKeyException</span>
                (&quot;Could not translate key&quot;, failure);
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>