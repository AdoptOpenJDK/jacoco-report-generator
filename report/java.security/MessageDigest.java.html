<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MessageDigest.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">MessageDigest.java</span></div><h1>MessageDigest.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.util.*;
import java.lang.*;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.io.InputStream;
import java.io.ByteArrayInputStream;

import java.nio.ByteBuffer;

/**
 * This MessageDigest class provides applications the functionality of a
 * message digest algorithm, such as SHA-1 or SHA-256.
 * Message digests are secure one-way hash functions that take arbitrary-sized
 * data and output a fixed-length hash value.
 *
 * &lt;p&gt;A MessageDigest object starts out initialized. The data is
 * processed through it using the {@link #update(byte) update}
 * methods. At any point {@link #reset() reset} can be called
 * to reset the digest. Once all the data to be updated has been
 * updated, one of the {@link #digest() digest} methods should
 * be called to complete the hash computation.
 *
 * &lt;p&gt;The {@code digest} method can be called once for a given number
 * of updates. After {@code digest} has been called, the MessageDigest
 * object is reset to its initialized state.
 *
 * &lt;p&gt;Implementations are free to implement the Cloneable interface.
 * Client applications can test cloneability by attempting cloning
 * and catching the CloneNotSupportedException:
 *
 * &lt;pre&gt;{@code
 * MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);
 *
 * try {
 *     md.update(toChapter1);
 *     MessageDigest tc1 = md.clone();
 *     byte[] toChapter1Digest = tc1.digest();
 *     md.update(toChapter2);
 *     ...etc.
 * } catch (CloneNotSupportedException cnse) {
 *     throw new DigestException(&quot;couldn't make digest of partial content&quot;);
 * }
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;Note that if a given implementation is not cloneable, it is
 * still possible to compute intermediate digests by instantiating
 * several instances, if the number of digests is known in advance.
 *
 * &lt;p&gt;Note that this class is abstract and extends from
 * {@code MessageDigestSpi} for historical reasons.
 * Application developers should only take notice of the methods defined in
 * this {@code MessageDigest} class; all the methods in
 * the superclass are intended for cryptographic service providers who wish to
 * supply their own implementations of message digest algorithms.
 *
 * &lt;p&gt; Every implementation of the Java platform is required to support
 * the following standard {@code MessageDigest} algorithms:
 * &lt;ul&gt;
 * &lt;li&gt;{@code MD5}&lt;/li&gt;
 * &lt;li&gt;{@code SHA-1}&lt;/li&gt;
 * &lt;li&gt;{@code SHA-256}&lt;/li&gt;
 * &lt;/ul&gt;
 * These algorithms are described in the &lt;a href=
 * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#MessageDigest&quot;&gt;
 * MessageDigest section&lt;/a&gt; of the
 * Java Cryptography Architecture Standard Algorithm Name Documentation.
 * Consult the release documentation for your implementation to see if any
 * other algorithms are supported.
 *
 * @author Benjamin Renaud
 *
 * @see DigestInputStream
 * @see DigestOutputStream
 */

public abstract class MessageDigest extends MessageDigestSpi {

    private String algorithm;

    // The state of this digest
    private static final int INITIAL = 0;
    private static final int IN_PROGRESS = 1;
<span class="fc" id="L111">    private int state = INITIAL;</span>

    // The provider
    private Provider provider;

    /**
     * Creates a message digest with the specified algorithm name.
     *
     * @param algorithm the standard name of the digest algorithm.
     * See the MessageDigest section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#MessageDigest&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     */
<span class="fc" id="L125">    protected MessageDigest(String algorithm) {</span>
<span class="fc" id="L126">        this.algorithm = algorithm;</span>
<span class="fc" id="L127">    }</span>

    /**
     * Returns a MessageDigest object that implements the specified digest
     * algorithm.
     *
     * &lt;p&gt; This method traverses the list of registered security Providers,
     * starting with the most preferred Provider.
     * A new MessageDigest object encapsulating the
     * MessageDigestSpi implementation from the first
     * Provider that supports the specified algorithm is returned.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param algorithm the name of the algorithm requested.
     * See the MessageDigest section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#MessageDigest&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @return a Message Digest object that implements the specified algorithm.
     *
     * @exception NoSuchAlgorithmException if no Provider supports a
     *          MessageDigestSpi implementation for the
     *          specified algorithm.
     *
     * @see Provider
     */
    public static MessageDigest getInstance(String algorithm)
    throws NoSuchAlgorithmException {
        try {
<span class="fc" id="L159">            Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;,</span>
                                             (String)null);
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">            if (objs[0] instanceof MessageDigest) {</span>
<span class="nc" id="L162">                MessageDigest md = (MessageDigest)objs[0];</span>
<span class="nc" id="L163">                md.provider = (Provider)objs[1];</span>
<span class="nc" id="L164">                return md;</span>
            } else {
<span class="fc" id="L166">                MessageDigest delegate =</span>
                    new Delegate((MessageDigestSpi)objs[0], algorithm);
<span class="fc" id="L168">                delegate.provider = (Provider)objs[1];</span>
<span class="fc" id="L169">                return delegate;</span>
            }
<span class="nc" id="L171">        } catch(NoSuchProviderException e) {</span>
<span class="nc" id="L172">            throw new NoSuchAlgorithmException(algorithm + &quot; not found&quot;);</span>
        }
    }

    /**
     * Returns a MessageDigest object that implements the specified digest
     * algorithm.
     *
     * &lt;p&gt; A new MessageDigest object encapsulating the
     * MessageDigestSpi implementation from the specified provider
     * is returned.  The specified provider must be registered
     * in the security provider list.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param algorithm the name of the algorithm requested.
     * See the MessageDigest section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#MessageDigest&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @param provider the name of the provider.
     *
     * @return a MessageDigest object that implements the specified algorithm.
     *
     * @exception NoSuchAlgorithmException if a MessageDigestSpi
     *          implementation for the specified algorithm is not
     *          available from the specified provider.
     *
     * @exception NoSuchProviderException if the specified provider is not
     *          registered in the security provider list.
     *
     * @exception IllegalArgumentException if the provider name is null
     *          or empty.
     *
     * @see Provider
     */
    public static MessageDigest getInstance(String algorithm, String provider)
        throws NoSuchAlgorithmException, NoSuchProviderException
    {
<span class="pc bpc" id="L213" title="2 of 4 branches missed.">        if (provider == null || provider.length() == 0)</span>
<span class="nc" id="L214">            throw new IllegalArgumentException(&quot;missing provider&quot;);</span>
<span class="fc" id="L215">        Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;, provider);</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (objs[0] instanceof MessageDigest) {</span>
<span class="nc" id="L217">            MessageDigest md = (MessageDigest)objs[0];</span>
<span class="nc" id="L218">            md.provider = (Provider)objs[1];</span>
<span class="nc" id="L219">            return md;</span>
        } else {
<span class="fc" id="L221">            MessageDigest delegate =</span>
                new Delegate((MessageDigestSpi)objs[0], algorithm);
<span class="fc" id="L223">            delegate.provider = (Provider)objs[1];</span>
<span class="fc" id="L224">            return delegate;</span>
        }
    }

    /**
     * Returns a MessageDigest object that implements the specified digest
     * algorithm.
     *
     * &lt;p&gt; A new MessageDigest object encapsulating the
     * MessageDigestSpi implementation from the specified Provider
     * object is returned.  Note that the specified Provider object
     * does not have to be registered in the provider list.
     *
     * @param algorithm the name of the algorithm requested.
     * See the MessageDigest section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#MessageDigest&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @param provider the provider.
     *
     * @return a MessageDigest object that implements the specified algorithm.
     *
     * @exception NoSuchAlgorithmException if a MessageDigestSpi
     *          implementation for the specified algorithm is not available
     *          from the specified Provider object.
     *
     * @exception IllegalArgumentException if the specified provider is null.
     *
     * @see Provider
     *
     * @since 1.4
     */
    public static MessageDigest getInstance(String algorithm,
                                            Provider provider)
        throws NoSuchAlgorithmException
    {
<span class="pc bpc" id="L261" title="1 of 2 branches missed.">        if (provider == null)</span>
<span class="nc" id="L262">            throw new IllegalArgumentException(&quot;missing provider&quot;);</span>
<span class="fc" id="L263">        Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;, provider);</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (objs[0] instanceof MessageDigest) {</span>
<span class="nc" id="L265">            MessageDigest md = (MessageDigest)objs[0];</span>
<span class="nc" id="L266">            md.provider = (Provider)objs[1];</span>
<span class="nc" id="L267">            return md;</span>
        } else {
<span class="fc" id="L269">            MessageDigest delegate =</span>
                new Delegate((MessageDigestSpi)objs[0], algorithm);
<span class="fc" id="L271">            delegate.provider = (Provider)objs[1];</span>
<span class="fc" id="L272">            return delegate;</span>
        }
    }

    /**
     * Returns the provider of this message digest object.
     *
     * @return the provider of this message digest object
     */
    public final Provider getProvider() {
<span class="fc" id="L282">        return this.provider;</span>
    }

    /**
     * Updates the digest using the specified byte.
     *
     * @param input the byte with which to update the digest.
     */
    public void update(byte input) {
<span class="fc" id="L291">        engineUpdate(input);</span>
<span class="fc" id="L292">        state = IN_PROGRESS;</span>
<span class="fc" id="L293">    }</span>

    /**
     * Updates the digest using the specified array of bytes, starting
     * at the specified offset.
     *
     * @param input the array of bytes.
     *
     * @param offset the offset to start from in the array of bytes.
     *
     * @param len the number of bytes to use, starting at
     * {@code offset}.
     */
    public void update(byte[] input, int offset, int len) {
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L308">            throw new IllegalArgumentException(&quot;No input buffer given&quot;);</span>
        }
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">        if (input.length - offset &lt; len) {</span>
<span class="nc" id="L311">            throw new IllegalArgumentException(&quot;Input buffer too short&quot;);</span>
        }
<span class="fc" id="L313">        engineUpdate(input, offset, len);</span>
<span class="fc" id="L314">        state = IN_PROGRESS;</span>
<span class="fc" id="L315">    }</span>

    /**
     * Updates the digest using the specified array of bytes.
     *
     * @param input the array of bytes.
     */
    public void update(byte[] input) {
<span class="fc" id="L323">        engineUpdate(input, 0, input.length);</span>
<span class="fc" id="L324">        state = IN_PROGRESS;</span>
<span class="fc" id="L325">    }</span>

    /**
     * Update the digest using the specified ByteBuffer. The digest is
     * updated using the {@code input.remaining()} bytes starting
     * at {@code input.position()}.
     * Upon return, the buffer's position will be equal to its limit;
     * its limit will not have changed.
     *
     * @param input the ByteBuffer
     * @since 1.5
     */
    public final void update(ByteBuffer input) {
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L339">            throw new NullPointerException();</span>
        }
<span class="fc" id="L341">        engineUpdate(input);</span>
<span class="fc" id="L342">        state = IN_PROGRESS;</span>
<span class="fc" id="L343">    }</span>

    /**
     * Completes the hash computation by performing final operations
     * such as padding. The digest is reset after this call is made.
     *
     * @return the array of bytes for the resulting hash value.
     */
    public byte[] digest() {
        /* Resetting is the responsibility of implementors. */
<span class="fc" id="L353">        byte[] result = engineDigest();</span>
<span class="fc" id="L354">        state = INITIAL;</span>
<span class="fc" id="L355">        return result;</span>
    }

    /**
     * Completes the hash computation by performing final operations
     * such as padding. The digest is reset after this call is made.
     *
     * @param buf output buffer for the computed digest
     *
     * @param offset offset into the output buffer to begin storing the digest
     *
     * @param len number of bytes within buf allotted for the digest
     *
     * @return the number of bytes placed into {@code buf}
     *
     * @exception DigestException if an error occurs.
     */
    public int digest(byte[] buf, int offset, int len) throws DigestException {
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">        if (buf == null) {</span>
<span class="nc" id="L374">            throw new IllegalArgumentException(&quot;No output buffer given&quot;);</span>
        }
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        if (buf.length - offset &lt; len) {</span>
<span class="nc" id="L377">            throw new IllegalArgumentException</span>
                (&quot;Output buffer too small for specified offset and length&quot;);
        }
<span class="fc" id="L380">        int numBytes = engineDigest(buf, offset, len);</span>
<span class="fc" id="L381">        state = INITIAL;</span>
<span class="fc" id="L382">        return numBytes;</span>
    }

    /**
     * Performs a final update on the digest using the specified array
     * of bytes, then completes the digest computation. That is, this
     * method first calls {@link #update(byte[]) update(input)},
     * passing the &lt;i&gt;input&lt;/i&gt; array to the {@code update} method,
     * then calls {@link #digest() digest()}.
     *
     * @param input the input to be updated before the digest is
     * completed.
     *
     * @return the array of bytes for the resulting hash value.
     */
    public byte[] digest(byte[] input) {
<span class="fc" id="L398">        update(input);</span>
<span class="fc" id="L399">        return digest();</span>
    }

    /**
     * Returns a string representation of this message digest object.
     */
    public String toString() {
<span class="nc" id="L406">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L407">        PrintStream p = new PrintStream(baos);</span>
<span class="nc" id="L408">        p.print(algorithm+&quot; Message Digest from &quot;+provider.getName()+&quot;, &quot;);</span>
<span class="nc bnc" id="L409" title="All 3 branches missed.">        switch (state) {</span>
        case INITIAL:
<span class="nc" id="L411">            p.print(&quot;&lt;initialized&gt;&quot;);</span>
<span class="nc" id="L412">            break;</span>
        case IN_PROGRESS:
<span class="nc" id="L414">            p.print(&quot;&lt;in progress&gt;&quot;);</span>
            break;
        }
<span class="nc" id="L417">        p.println();</span>
<span class="nc" id="L418">        return (baos.toString());</span>
    }

    /**
     * Compares two digests for equality. Does a simple byte compare.
     *
     * @param digesta one of the digests to compare.
     *
     * @param digestb the other digest to compare.
     *
     * @return true if the digests are equal, false otherwise.
     */
    public static boolean isEqual(byte[] digesta, byte[] digestb) {
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">        if (digesta.length != digestb.length) {</span>
<span class="nc" id="L432">            return false;</span>
        }

<span class="fc" id="L435">        int result = 0;</span>
        // time-constant comparison
<span class="fc bfc" id="L437" title="All 2 branches covered.">        for (int i = 0; i &lt; digesta.length; i++) {</span>
<span class="fc" id="L438">            result |= digesta[i] ^ digestb[i];</span>
        }
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        return result == 0;</span>
    }

    /**
     * Resets the digest for further use.
     */
    public void reset() {
<span class="fc" id="L447">        engineReset();</span>
<span class="fc" id="L448">        state = INITIAL;</span>
<span class="fc" id="L449">    }</span>

    /**
     * Returns a string that identifies the algorithm, independent of
     * implementation details. The name should be a standard
     * Java Security name (such as &quot;SHA&quot;, &quot;MD5&quot;, and so on).
     * See the MessageDigest section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#MessageDigest&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @return the name of the algorithm
     */
    public final String getAlgorithm() {
<span class="fc" id="L463">        return this.algorithm;</span>
    }

    /**
     * Returns the length of the digest in bytes, or 0 if this operation is
     * not supported by the provider and the implementation is not cloneable.
     *
     * @return the digest length in bytes, or 0 if this operation is not
     * supported by the provider and the implementation is not cloneable.
     *
     * @since 1.2
     */
    public final int getDigestLength() {
<span class="fc" id="L476">        int digestLen = engineGetDigestLength();</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">        if (digestLen == 0) {</span>
            try {
<span class="nc" id="L479">                MessageDigest md = (MessageDigest)clone();</span>
<span class="nc" id="L480">                byte[] digest = md.digest();</span>
<span class="nc" id="L481">                return digest.length;</span>
<span class="nc" id="L482">            } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L483">                return digestLen;</span>
            }
        }
<span class="fc" id="L486">        return digestLen;</span>
    }

    /**
     * Returns a clone if the implementation is cloneable.
     *
     * @return a clone if the implementation is cloneable.
     *
     * @exception CloneNotSupportedException if this is called on an
     * implementation that does not support {@code Cloneable}.
     */
    public Object clone() throws CloneNotSupportedException {
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (this instanceof Cloneable) {</span>
<span class="nc" id="L499">            return super.clone();</span>
        } else {
<span class="nc" id="L501">            throw new CloneNotSupportedException();</span>
        }
    }




    /*
     * The following class allows providers to extend from MessageDigestSpi
     * rather than from MessageDigest. It represents a MessageDigest with an
     * encapsulated, provider-supplied SPI object (of type MessageDigestSpi).
     * If the provider implementation is an instance of MessageDigestSpi,
     * the getInstance() methods above return an instance of this class, with
     * the SPI object encapsulated.
     *
     * Note: All SPI methods from the original MessageDigest class have been
     * moved up the hierarchy into a new class (MessageDigestSpi), which has
     * been interposed in the hierarchy between the API (MessageDigest)
     * and its original parent (Object).
     */

    static class Delegate extends MessageDigest {

        // The provider implementation (delegate)
        private MessageDigestSpi digestSpi;

        // constructor
        public Delegate(MessageDigestSpi digestSpi, String algorithm) {
<span class="fc" id="L529">            super(algorithm);</span>
<span class="fc" id="L530">            this.digestSpi = digestSpi;</span>
<span class="fc" id="L531">        }</span>

        /**
         * Returns a clone if the delegate is cloneable.
         *
         * @return a clone if the delegate is cloneable.
         *
         * @exception CloneNotSupportedException if this is called on a
         * delegate that does not support {@code Cloneable}.
         */
        public Object clone() throws CloneNotSupportedException {
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">            if (digestSpi instanceof Cloneable) {</span>
<span class="fc" id="L543">                MessageDigestSpi digestSpiClone =</span>
<span class="fc" id="L544">                    (MessageDigestSpi)digestSpi.clone();</span>
                // Because 'algorithm', 'provider', and 'state' are private
                // members of our supertype, we must perform a cast to
                // access them.
<span class="fc" id="L548">                MessageDigest that =</span>
                    new Delegate(digestSpiClone,
<span class="fc" id="L550">                                 ((MessageDigest)this).algorithm);</span>
<span class="fc" id="L551">                that.provider = ((MessageDigest)this).provider;</span>
<span class="fc" id="L552">                that.state = ((MessageDigest)this).state;</span>
<span class="fc" id="L553">                return that;</span>
            } else {
<span class="nc" id="L555">                throw new CloneNotSupportedException();</span>
            }
        }

        protected int engineGetDigestLength() {
<span class="fc" id="L560">            return digestSpi.engineGetDigestLength();</span>
        }

        protected void engineUpdate(byte input) {
<span class="fc" id="L564">            digestSpi.engineUpdate(input);</span>
<span class="fc" id="L565">        }</span>

        protected void engineUpdate(byte[] input, int offset, int len) {
<span class="fc" id="L568">            digestSpi.engineUpdate(input, offset, len);</span>
<span class="fc" id="L569">        }</span>

        protected void engineUpdate(ByteBuffer input) {
<span class="fc" id="L572">            digestSpi.engineUpdate(input);</span>
<span class="fc" id="L573">        }</span>

        protected byte[] engineDigest() {
<span class="fc" id="L576">            return digestSpi.engineDigest();</span>
        }

        protected int engineDigest(byte[] buf, int offset, int len)
            throws DigestException {
<span class="fc" id="L581">                return digestSpi.engineDigest(buf, offset, len);</span>
        }

        protected void engineReset() {
<span class="fc" id="L585">            digestSpi.engineReset();</span>
<span class="fc" id="L586">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>