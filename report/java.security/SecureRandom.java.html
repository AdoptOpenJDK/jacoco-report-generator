<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SecureRandom.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">SecureRandom.java</span></div><h1>SecureRandom.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.util.*;
import java.util.regex.*;

import java.security.Provider.Service;

import sun.security.jca.*;
import sun.security.jca.GetInstance.Instance;

/**
 * This class provides a cryptographically strong random number
 * generator (RNG).
 *
 * &lt;p&gt;A cryptographically strong random number
 * minimally complies with the statistical random number generator tests
 * specified in &lt;a href=&quot;http://csrc.nist.gov/cryptval/140-2.htm&quot;&gt;
 * &lt;i&gt;FIPS 140-2, Security Requirements for Cryptographic Modules&lt;/i&gt;&lt;/a&gt;,
 * section 4.9.1.
 * Additionally, SecureRandom must produce non-deterministic output.
 * Therefore any seed material passed to a SecureRandom object must be
 * unpredictable, and all SecureRandom output sequences must be
 * cryptographically strong, as described in
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc1750.txt&quot;&gt;
 * &lt;i&gt;RFC 1750: Randomness Recommendations for Security&lt;/i&gt;&lt;/a&gt;.
 *
 * &lt;p&gt;A caller obtains a SecureRandom instance via the
 * no-argument constructor or one of the {@code getInstance} methods:
 *
 * &lt;pre&gt;
 *      SecureRandom random = new SecureRandom();
 * &lt;/pre&gt;
 *
 * &lt;p&gt; Many SecureRandom implementations are in the form of a pseudo-random
 * number generator (PRNG), which means they use a deterministic algorithm
 * to produce a pseudo-random sequence from a true random seed.
 * Other implementations may produce true random numbers,
 * and yet others may use a combination of both techniques.
 *
 * &lt;p&gt; Typical callers of SecureRandom invoke the following methods
 * to retrieve random bytes:
 *
 * &lt;pre&gt;
 *      SecureRandom random = new SecureRandom();
 *      byte bytes[] = new byte[20];
 *      random.nextBytes(bytes);
 * &lt;/pre&gt;
 *
 * &lt;p&gt; Callers may also invoke the {@code generateSeed} method
 * to generate a given number of seed bytes (to seed other random number
 * generators, for example):
 * &lt;pre&gt;
 *      byte seed[] = random.generateSeed(20);
 * &lt;/pre&gt;
 *
 * Note: Depending on the implementation, the {@code generateSeed} and
 * {@code nextBytes} methods may block as entropy is being gathered,
 * for example, if they need to read from /dev/random on various Unix-like
 * operating systems.
 *
 * @see java.security.SecureRandomSpi
 * @see java.util.Random
 *
 * @author Benjamin Renaud
 * @author Josh Bloch
 */

public class SecureRandom extends java.util.Random {

    /**
     * The provider.
     *
     * @serial
     * @since 1.2
     */
<span class="pc" id="L101">    private Provider provider = null;</span>

    /**
     * The provider implementation.
     *
     * @serial
     * @since 1.2
     */
<span class="pc" id="L109">    private SecureRandomSpi secureRandomSpi = null;</span>

    /*
     * The algorithm name of null if unknown.
     *
     * @serial
     * @since 1.5
     */
    private String algorithm;

    // Seed Generator
<span class="fc" id="L120">    private static volatile SecureRandom seedGenerator = null;</span>

    /**
     * Constructs a secure random number generator (RNG) implementing the
     * default random number algorithm.
     *
     * &lt;p&gt; This constructor traverses the list of registered security Providers,
     * starting with the most preferred Provider.
     * A new SecureRandom object encapsulating the
     * SecureRandomSpi implementation from the first
     * Provider that supports a SecureRandom (RNG) algorithm is returned.
     * If none of the Providers support a RNG algorithm,
     * then an implementation-specific default is returned.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * &lt;p&gt; See the SecureRandom section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#SecureRandom&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard RNG algorithm names.
     *
     * &lt;p&gt; The returned SecureRandom object has not been seeded.  To seed the
     * returned object, call the {@code setSeed} method.
     * If {@code setSeed} is not called, the first call to
     * {@code nextBytes} will force the SecureRandom object to seed itself.
     * This self-seeding will not occur if {@code setSeed} was
     * previously called.
     */
    public SecureRandom() {
        /*
         * This call to our superclass constructor will result in a call
         * to our own {@code setSeed} method, which will return
         * immediately when it is passed zero.
         */
<span class="fc" id="L155">        super(0);</span>
<span class="fc" id="L156">        getDefaultPRNG(false, null);</span>
<span class="fc" id="L157">    }</span>

    /**
     * Constructs a secure random number generator (RNG) implementing the
     * default random number algorithm.
     * The SecureRandom instance is seeded with the specified seed bytes.
     *
     * &lt;p&gt; This constructor traverses the list of registered security Providers,
     * starting with the most preferred Provider.
     * A new SecureRandom object encapsulating the
     * SecureRandomSpi implementation from the first
     * Provider that supports a SecureRandom (RNG) algorithm is returned.
     * If none of the Providers support a RNG algorithm,
     * then an implementation-specific default is returned.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * &lt;p&gt; See the SecureRandom section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#SecureRandom&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard RNG algorithm names.
     *
     * @param seed the seed.
     */
    public SecureRandom(byte seed[]) {
<span class="nc" id="L183">        super(0);</span>
<span class="nc" id="L184">        getDefaultPRNG(true, seed);</span>
<span class="nc" id="L185">    }</span>

    private void getDefaultPRNG(boolean setSeed, byte[] seed) {
<span class="fc" id="L188">        String prng = getPrngAlgorithm();</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (prng == null) {</span>
            // bummer, get the SUN implementation
<span class="nc" id="L191">            prng = &quot;SHA1PRNG&quot;;</span>
<span class="nc" id="L192">            this.secureRandomSpi = new sun.security.provider.SecureRandom();</span>
<span class="nc" id="L193">            this.provider = Providers.getSunProvider();</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">            if (setSeed) {</span>
<span class="nc" id="L195">                this.secureRandomSpi.engineSetSeed(seed);</span>
            }
        } else {
            try {
<span class="fc" id="L199">                SecureRandom random = SecureRandom.getInstance(prng);</span>
<span class="fc" id="L200">                this.secureRandomSpi = random.getSecureRandomSpi();</span>
<span class="fc" id="L201">                this.provider = random.getProvider();</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                if (setSeed) {</span>
<span class="nc" id="L203">                    this.secureRandomSpi.engineSetSeed(seed);</span>
                }
<span class="nc" id="L205">            } catch (NoSuchAlgorithmException nsae) {</span>
                // never happens, because we made sure the algorithm exists
<span class="nc" id="L207">                throw new RuntimeException(nsae);</span>
<span class="fc" id="L208">            }</span>
        }
        // JDK 1.1 based implementations subclass SecureRandom instead of
        // SecureRandomSpi. They will also go through this code path because
        // they must call a SecureRandom constructor as it is their superclass.
        // If we are dealing with such an implementation, do not set the
        // algorithm value as it would be inaccurate.
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">        if (getClass() == SecureRandom.class) {</span>
<span class="fc" id="L216">            this.algorithm = prng;</span>
        }
<span class="fc" id="L218">    }</span>

    /**
     * Creates a SecureRandom object.
     *
     * @param secureRandomSpi the SecureRandom implementation.
     * @param provider the provider.
     */
    protected SecureRandom(SecureRandomSpi secureRandomSpi,
                           Provider provider) {
<span class="nc" id="L228">        this(secureRandomSpi, provider, null);</span>
<span class="nc" id="L229">    }</span>

    private SecureRandom(SecureRandomSpi secureRandomSpi, Provider provider,
            String algorithm) {
<span class="fc" id="L233">        super(0);</span>
<span class="fc" id="L234">        this.secureRandomSpi = secureRandomSpi;</span>
<span class="fc" id="L235">        this.provider = provider;</span>
<span class="fc" id="L236">        this.algorithm = algorithm;</span>
<span class="fc" id="L237">    }</span>

    /**
     * Returns a SecureRandom object that implements the specified
     * Random Number Generator (RNG) algorithm.
     *
     * &lt;p&gt; This method traverses the list of registered security Providers,
     * starting with the most preferred Provider.
     * A new SecureRandom object encapsulating the
     * SecureRandomSpi implementation from the first
     * Provider that supports the specified algorithm is returned.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * &lt;p&gt; The returned SecureRandom object has not been seeded.  To seed the
     * returned object, call the {@code setSeed} method.
     * If {@code setSeed} is not called, the first call to
     * {@code nextBytes} will force the SecureRandom object to seed itself.
     * This self-seeding will not occur if {@code setSeed} was
     * previously called.
     *
     * @param algorithm the name of the RNG algorithm.
     * See the SecureRandom section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#SecureRandom&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard RNG algorithm names.
     *
     * @return the new SecureRandom object.
     *
     * @exception NoSuchAlgorithmException if no Provider supports a
     *          SecureRandomSpi implementation for the
     *          specified algorithm.
     *
     * @see Provider
     *
     * @since 1.2
     */
    public static SecureRandom getInstance(String algorithm)
            throws NoSuchAlgorithmException {
<span class="fc" id="L277">        Instance instance = GetInstance.getInstance(&quot;SecureRandom&quot;,</span>
            SecureRandomSpi.class, algorithm);
<span class="fc" id="L279">        return new SecureRandom((SecureRandomSpi)instance.impl,</span>
            instance.provider, algorithm);
    }

    /**
     * Returns a SecureRandom object that implements the specified
     * Random Number Generator (RNG) algorithm.
     *
     * &lt;p&gt; A new SecureRandom object encapsulating the
     * SecureRandomSpi implementation from the specified provider
     * is returned.  The specified provider must be registered
     * in the security provider list.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * &lt;p&gt; The returned SecureRandom object has not been seeded.  To seed the
     * returned object, call the {@code setSeed} method.
     * If {@code setSeed} is not called, the first call to
     * {@code nextBytes} will force the SecureRandom object to seed itself.
     * This self-seeding will not occur if {@code setSeed} was
     * previously called.
     *
     * @param algorithm the name of the RNG algorithm.
     * See the SecureRandom section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#SecureRandom&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard RNG algorithm names.
     *
     * @param provider the name of the provider.
     *
     * @return the new SecureRandom object.
     *
     * @exception NoSuchAlgorithmException if a SecureRandomSpi
     *          implementation for the specified algorithm is not
     *          available from the specified provider.
     *
     * @exception NoSuchProviderException if the specified provider is not
     *          registered in the security provider list.
     *
     * @exception IllegalArgumentException if the provider name is null
     *          or empty.
     *
     * @see Provider
     *
     * @since 1.2
     */
    public static SecureRandom getInstance(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
<span class="fc" id="L328">        Instance instance = GetInstance.getInstance(&quot;SecureRandom&quot;,</span>
            SecureRandomSpi.class, algorithm, provider);
<span class="fc" id="L330">        return new SecureRandom((SecureRandomSpi)instance.impl,</span>
            instance.provider, algorithm);
    }

    /**
     * Returns a SecureRandom object that implements the specified
     * Random Number Generator (RNG) algorithm.
     *
     * &lt;p&gt; A new SecureRandom object encapsulating the
     * SecureRandomSpi implementation from the specified Provider
     * object is returned.  Note that the specified Provider object
     * does not have to be registered in the provider list.
     *
     * &lt;p&gt; The returned SecureRandom object has not been seeded.  To seed the
     * returned object, call the {@code setSeed} method.
     * If {@code setSeed} is not called, the first call to
     * {@code nextBytes} will force the SecureRandom object to seed itself.
     * This self-seeding will not occur if {@code setSeed} was
     * previously called.
     *
     * @param algorithm the name of the RNG algorithm.
     * See the SecureRandom section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#SecureRandom&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard RNG algorithm names.
     *
     * @param provider the provider.
     *
     * @return the new SecureRandom object.
     *
     * @exception NoSuchAlgorithmException if a SecureRandomSpi
     *          implementation for the specified algorithm is not available
     *          from the specified Provider object.
     *
     * @exception IllegalArgumentException if the specified provider is null.
     *
     * @see Provider
     *
     * @since 1.4
     */
    public static SecureRandom getInstance(String algorithm,
            Provider provider) throws NoSuchAlgorithmException {
<span class="nc" id="L372">        Instance instance = GetInstance.getInstance(&quot;SecureRandom&quot;,</span>
            SecureRandomSpi.class, algorithm, provider);
<span class="nc" id="L374">        return new SecureRandom((SecureRandomSpi)instance.impl,</span>
            instance.provider, algorithm);
    }

    /**
     * Returns the SecureRandomSpi of this SecureRandom object.
     */
    SecureRandomSpi getSecureRandomSpi() {
<span class="fc" id="L382">        return secureRandomSpi;</span>
    }

    /**
     * Returns the provider of this SecureRandom object.
     *
     * @return the provider of this SecureRandom object.
     */
    public final Provider getProvider() {
<span class="fc" id="L391">        return provider;</span>
    }

    /**
     * Returns the name of the algorithm implemented by this SecureRandom
     * object.
     *
     * @return the name of the algorithm or {@code unknown}
     *          if the algorithm name cannot be determined.
     * @since 1.5
     */
    public String getAlgorithm() {
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        return (algorithm != null) ? algorithm : &quot;unknown&quot;;</span>
    }

    /**
     * Reseeds this random object. The given seed supplements, rather than
     * replaces, the existing seed. Thus, repeated calls are guaranteed
     * never to reduce randomness.
     *
     * @param seed the seed.
     *
     * @see #getSeed
     */
    synchronized public void setSeed(byte[] seed) {
<span class="fc" id="L416">        secureRandomSpi.engineSetSeed(seed);</span>
<span class="fc" id="L417">    }</span>

    /**
     * Reseeds this random object, using the eight bytes contained
     * in the given {@code long seed}. The given seed supplements,
     * rather than replaces, the existing seed. Thus, repeated calls
     * are guaranteed never to reduce randomness.
     *
     * &lt;p&gt;This method is defined for compatibility with
     * {@code java.util.Random}.
     *
     * @param seed the seed.
     *
     * @see #getSeed
     */
    @Override
    public void setSeed(long seed) {
        /*
         * Ignore call from super constructor (as well as any other calls
         * unfortunate enough to be passing 0).  It's critical that we
         * ignore call from superclass constructor, as digest has not
         * yet been initialized at that point.
         */
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">        if (seed != 0) {</span>
<span class="nc" id="L441">            secureRandomSpi.engineSetSeed(longToByteArray(seed));</span>
        }
<span class="fc" id="L443">    }</span>

    /**
     * Generates a user-specified number of random bytes.
     *
     * &lt;p&gt; If a call to {@code setSeed} had not occurred previously,
     * the first call to this method forces this SecureRandom object
     * to seed itself.  This self-seeding will not occur if
     * {@code setSeed} was previously called.
     *
     * @param bytes the array to be filled in with random bytes.
     */
    @Override
    synchronized public void nextBytes(byte[] bytes) {
<span class="fc" id="L457">        secureRandomSpi.engineNextBytes(bytes);</span>
<span class="fc" id="L458">    }</span>

    /**
     * Generates an integer containing the user-specified number of
     * pseudo-random bits (right justified, with leading zeros).  This
     * method overrides a {@code java.util.Random} method, and serves
     * to provide a source of random bits to all of the methods inherited
     * from that class (for example, {@code nextInt},
     * {@code nextLong}, and {@code nextFloat}).
     *
     * @param numBits number of pseudo-random bits to be generated, where
     * {@code 0 &lt;= numBits &lt;= 32}.
     *
     * @return an {@code int} containing the user-specified number
     * of pseudo-random bits (right justified, with leading zeros).
     */
    @Override
    final protected int next(int numBits) {
<span class="fc" id="L476">        int numBytes = (numBits+7)/8;</span>
<span class="fc" id="L477">        byte b[] = new byte[numBytes];</span>
<span class="fc" id="L478">        int next = 0;</span>

<span class="fc" id="L480">        nextBytes(b);</span>
<span class="fc bfc" id="L481" title="All 2 branches covered.">        for (int i = 0; i &lt; numBytes; i++) {</span>
<span class="fc" id="L482">            next = (next &lt;&lt; 8) + (b[i] &amp; 0xFF);</span>
        }

<span class="fc" id="L485">        return next &gt;&gt;&gt; (numBytes*8 - numBits);</span>
    }

    /**
     * Returns the given number of seed bytes, computed using the seed
     * generation algorithm that this class uses to seed itself.  This
     * call may be used to seed other random number generators.
     *
     * &lt;p&gt;This method is only included for backwards compatibility.
     * The caller is encouraged to use one of the alternative
     * {@code getInstance} methods to obtain a SecureRandom object, and
     * then call the {@code generateSeed} method to obtain seed bytes
     * from that object.
     *
     * @param numBytes the number of seed bytes to generate.
     *
     * @return the seed bytes.
     *
     * @see #setSeed
     */
    public static byte[] getSeed(int numBytes) {
<span class="nc bnc" id="L506" title="All 2 branches missed.">        if (seedGenerator == null) {</span>
<span class="nc" id="L507">            seedGenerator = new SecureRandom();</span>
        }
<span class="nc" id="L509">        return seedGenerator.generateSeed(numBytes);</span>
    }

    /**
     * Returns the given number of seed bytes, computed using the seed
     * generation algorithm that this class uses to seed itself.  This
     * call may be used to seed other random number generators.
     *
     * @param numBytes the number of seed bytes to generate.
     *
     * @return the seed bytes.
     */
    public byte[] generateSeed(int numBytes) {
<span class="fc" id="L522">        return secureRandomSpi.engineGenerateSeed(numBytes);</span>
    }

    /**
     * Helper function to convert a long into a byte array (least significant
     * byte first).
     */
    private static byte[] longToByteArray(long l) {
<span class="nc" id="L530">        byte[] retVal = new byte[8];</span>

<span class="nc bnc" id="L532" title="All 2 branches missed.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="nc" id="L533">            retVal[i] = (byte) l;</span>
<span class="nc" id="L534">            l &gt;&gt;= 8;</span>
        }

<span class="nc" id="L537">        return retVal;</span>
    }

    /**
     * Gets a default PRNG algorithm by looking through all registered
     * providers. Returns the first PRNG algorithm of the first provider that
     * has registered a SecureRandom implementation, or null if none of the
     * registered providers supplies a SecureRandom implementation.
     */
    private static String getPrngAlgorithm() {
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">        for (Provider p : Providers.getProviderList().providers()) {</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">            for (Service s : p.getServices()) {</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">                if (s.getType().equals(&quot;SecureRandom&quot;)) {</span>
<span class="fc" id="L550">                    return s.getAlgorithm();</span>
                }
<span class="fc" id="L552">            }</span>
<span class="fc" id="L553">        }</span>
<span class="nc" id="L554">        return null;</span>
    }

    /*
     * Lazily initialize since Pattern.compile() is heavy.
     * Effective Java (2nd Edition), Item 71.
     */
<span class="nc" id="L561">    private static final class StrongPatternHolder {</span>
        /*
         * Entries are alg:prov separated by ,
         * Allow for prepended/appended whitespace between entries.
         *
         * Capture groups:
         *     1 - alg
         *     2 - :prov (optional)
         *     3 - prov (optional)
         *     4 - ,nextEntry (optional)
         *     5 - nextEntry (optional)
         */
<span class="fc" id="L573">        private static Pattern pattern =</span>
<span class="fc" id="L574">            Pattern.compile(</span>
                &quot;\\s*([\\S&amp;&amp;[^:,]]*)(\\:([\\S&amp;&amp;[^,]]*))?\\s*(\\,(.*))?&quot;);
    }

    /**
     * Returns a {@code SecureRandom} object that was selected by using
     * the algorithms/providers specified in the {@code
     * securerandom.strongAlgorithms} {@link Security} property.
     * &lt;p&gt;
     * Some situations require strong random values, such as when
     * creating high-value/long-lived secrets like RSA public/private
     * keys.  To help guide applications in selecting a suitable strong
     * {@code SecureRandom} implementation, Java distributions
     * include a list of known strong {@code SecureRandom}
     * implementations in the {@code securerandom.strongAlgorithms}
     * Security property.
     * &lt;p&gt;
     * Every implementation of the Java platform is required to
     * support at least one strong {@code SecureRandom} implementation.
     *
     * @return a strong {@code SecureRandom} implementation as indicated
     * by the {@code securerandom.strongAlgorithms} Security property
     *
     * @throws NoSuchAlgorithmException if no algorithm is available
     *
     * @see Security#getProperty(String)
     *
     * @since 1.8
     */
    public static SecureRandom getInstanceStrong()
            throws NoSuchAlgorithmException {

<span class="fc" id="L606">        String property = AccessController.doPrivileged(</span>
<span class="fc" id="L607">            new PrivilegedAction&lt;String&gt;() {</span>
                @Override
                public String run() {
<span class="fc" id="L610">                    return Security.getProperty(</span>
                        &quot;securerandom.strongAlgorithms&quot;);
                }
            });

<span class="pc bpc" id="L615" title="1 of 4 branches missed.">        if ((property == null) || (property.length() == 0)) {</span>
<span class="fc" id="L616">            throw new NoSuchAlgorithmException(</span>
                &quot;Null/empty securerandom.strongAlgorithms Security Property&quot;);
        }

<span class="fc" id="L620">        String remainder = property;</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">        while (remainder != null) {</span>
            Matcher m;
<span class="fc" id="L623">            if ((m = StrongPatternHolder.pattern.matcher(</span>
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">                    remainder)).matches()) {</span>

<span class="fc" id="L626">                String alg = m.group(1);</span>
<span class="fc" id="L627">                String prov = m.group(3);</span>

                try {
<span class="fc bfc" id="L630" title="All 2 branches covered.">                    if (prov == null) {</span>
<span class="fc" id="L631">                        return SecureRandom.getInstance(alg);</span>
                    } else {
<span class="fc" id="L633">                        return SecureRandom.getInstance(alg, prov);</span>
                    }
<span class="fc" id="L635">                } catch (NoSuchAlgorithmException |</span>
                        NoSuchProviderException e) {
                }
<span class="fc" id="L638">                remainder = m.group(5);</span>
<span class="fc" id="L639">            } else {</span>
<span class="nc" id="L640">                remainder = null;</span>
            }
<span class="fc" id="L642">        }</span>

<span class="fc" id="L644">        throw new NoSuchAlgorithmException(</span>
            &quot;No strong SecureRandom impls available: &quot; + property);
    }

    // Declare serialVersionUID to be compatible with JDK1.1
    static final long serialVersionUID = 4940670005562187L;

    // Retain unused values serialized from JDK1.1
    /**
     * @serial
     */
    private byte[] state;
    /**
     * @serial
     */
<span class="pc" id="L659">    private MessageDigest digest = null;</span>
    /**
     * @serial
     *
     * We know that the MessageDigest class does not implement
     * java.io.Serializable.  However, since this field is no longer
     * used, it will always be NULL and won't affect the serialization
     * of the SecureRandom class itself.
     */
    private byte[] randomBytes;
    /**
     * @serial
     */
    private int randomBytesUsed;
    /**
     * @serial
     */
    private long counter;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>