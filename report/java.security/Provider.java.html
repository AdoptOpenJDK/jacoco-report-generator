<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Provider.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">Provider.java</span></div><h1>Provider.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.io.*;
import java.util.*;
import static java.util.Locale.ENGLISH;
import java.lang.ref.*;
import java.lang.reflect.*;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;

/**
 * This class represents a &quot;provider&quot; for the
 * Java Security API, where a provider implements some or all parts of
 * Java Security. Services that a provider may implement include:
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt;Algorithms (such as DSA, RSA, MD5 or SHA-1).
 *
 * &lt;li&gt;Key generation, conversion, and management facilities (such as for
 * algorithm-specific keys).
 *
 *&lt;/ul&gt;
 *
 * &lt;p&gt;Each provider has a name and a version number, and is configured
 * in each runtime it is installed in.
 *
 * &lt;p&gt;See &lt;a href =
 * &quot;../../../technotes/guides/security/crypto/CryptoSpec.html#Provider&quot;&gt;The Provider Class&lt;/a&gt;
 * in the &quot;Java Cryptography Architecture API Specification &amp;amp; Reference&quot;
 * for information about how a particular type of provider, the
 * cryptographic service provider, works and is installed. However,
 * please note that a provider can be used to implement any security
 * service in Java that uses a pluggable architecture with a choice
 * of implementations that fit underneath.
 *
 * &lt;p&gt;Some provider implementations may encounter unrecoverable internal
 * errors during their operation, for example a failure to communicate with a
 * security token. A {@link ProviderException} should be used to indicate
 * such errors.
 *
 * &lt;p&gt;The service type {@code Provider} is reserved for use by the
 * security framework. Services of this type cannot be added, removed,
 * or modified by applications.
 * The following attributes are automatically placed in each Provider object:
 * &lt;table cellspacing=4&gt;
 * &lt;caption&gt;&lt;b&gt;Attributes Automatically Placed in a Provider Object&lt;/b&gt;&lt;/caption&gt;
 * &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;
 * &lt;tr&gt;&lt;td&gt;{@code Provider.id name}&lt;/td&gt;
  *    &lt;td&gt;{@code String.valueOf(provider.getName())}&lt;/td&gt;
 * &lt;tr&gt;&lt;td&gt;{@code Provider.id version}&lt;/td&gt;
 *     &lt;td&gt;{@code String.valueOf(provider.getVersion())}&lt;/td&gt;
 * &lt;tr&gt;&lt;td&gt;{@code Provider.id info}&lt;/td&gt;
       &lt;td&gt;{@code String.valueOf(provider.getInfo())}&lt;/td&gt;
 * &lt;tr&gt;&lt;td&gt;{@code Provider.id className}&lt;/td&gt;
 *     &lt;td&gt;{@code provider.getClass().getName()}&lt;/td&gt;
 * &lt;/table&gt;
 *
 * @author Benjamin Renaud
 * @author Andreas Sterbenz
 */
public abstract class Provider extends Properties {

    // Declare serialVersionUID to be compatible with JDK1.1
    static final long serialVersionUID = -4298000515446427739L;

<span class="fc" id="L93">    private static final sun.security.util.Debug debug =</span>
        sun.security.util.Debug.getInstance
<span class="fc" id="L95">        (&quot;provider&quot;, &quot;Provider&quot;);</span>

    /**
     * The provider name.
     *
     * @serial
     */
    private String name;

    /**
     * A description of the provider and its services.
     *
     * @serial
     */
    private String info;

    /**
     * The provider version number.
     *
     * @serial
     */
    private double version;


<span class="fc" id="L119">    private transient Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet = null;</span>
<span class="fc" id="L120">    private transient int entrySetCallCount = 0;</span>

    private transient boolean initialized;

    /**
     * Constructs a provider with the specified name, version number,
     * and information.
     *
     * @param name the provider name.
     *
     * @param version the provider version number.
     *
     * @param info a description of the provider and its services.
     */
<span class="fc" id="L134">    protected Provider(String name, double version, String info) {</span>
<span class="fc" id="L135">        this.name = name;</span>
<span class="fc" id="L136">        this.version = version;</span>
<span class="fc" id="L137">        this.info = info;</span>
<span class="fc" id="L138">        putId();</span>
<span class="fc" id="L139">        initialized = true;</span>
<span class="fc" id="L140">    }</span>

    /**
     * Returns the name of this provider.
     *
     * @return the name of this provider.
     */
    public String getName() {
<span class="fc" id="L148">        return name;</span>
    }

    /**
     * Returns the version number for this provider.
     *
     * @return the version number for this provider.
     */
    public double getVersion() {
<span class="fc" id="L157">        return version;</span>
    }

    /**
     * Returns a human-readable description of the provider and its
     * services.  This may return an HTML page, with relevant links.
     *
     * @return a description of the provider and its services.
     */
    public String getInfo() {
<span class="nc" id="L167">        return info;</span>
    }

    /**
     * Returns a string with the name and the version number
     * of this provider.
     *
     * @return the string with the name and the version number
     * for this provider.
     */
    public String toString() {
<span class="fc" id="L178">        return name + &quot; version &quot; + version;</span>
    }

    /*
     * override the following methods to ensure that provider
     * information can only be changed if the caller has the appropriate
     * permissions.
     */

    /**
     * Clears this provider so that it no longer contains the properties
     * used to look up facilities implemented by the provider.
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the string {@code &quot;clearProviderProperties.&quot;+name}
     * (where {@code name} is the provider name) to see if it's ok to clear
     * this provider.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to clear this provider
     *
     * @since 1.2
     */
    @Override
    public synchronized void clear() {
<span class="nc" id="L205">        check(&quot;clearProviderProperties.&quot;+name);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L207">            debug.println(&quot;Remove &quot; + name + &quot; provider properties&quot;);</span>
        }
<span class="nc" id="L209">        implClear();</span>
<span class="nc" id="L210">    }</span>

    /**
     * Reads a property list (key and element pairs) from the input stream.
     *
     * @param inStream   the input stream.
     * @exception  IOException  if an error occurred when reading from the
     *               input stream.
     * @see java.util.Properties#load
     */
    @Override
    public synchronized void load(InputStream inStream) throws IOException {
<span class="nc" id="L222">        check(&quot;putProviderProperty.&quot;+name);</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L224">            debug.println(&quot;Load &quot; + name + &quot; provider properties&quot;);</span>
        }
<span class="nc" id="L226">        Properties tempProperties = new Properties();</span>
<span class="nc" id="L227">        tempProperties.load(inStream);</span>
<span class="nc" id="L228">        implPutAll(tempProperties);</span>
<span class="nc" id="L229">    }</span>

    /**
     * Copies all of the mappings from the specified Map to this provider.
     * These mappings will replace any properties that this provider had
     * for any of the keys currently in the specified Map.
     *
     * @since 1.2
     */
    @Override
    public synchronized void putAll(Map&lt;?,?&gt; t) {
<span class="fc" id="L240">        check(&quot;putProviderProperty.&quot;+name);</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L242">            debug.println(&quot;Put all &quot; + name + &quot; provider properties&quot;);</span>
        }
<span class="fc" id="L244">        implPutAll(t);</span>
<span class="fc" id="L245">    }</span>

    /**
     * Returns an unmodifiable Set view of the property entries contained
     * in this Provider.
     *
     * @see   java.util.Map.Entry
     * @since 1.2
     */
    @Override
    public synchronized Set&lt;Map.Entry&lt;Object,Object&gt;&gt; entrySet() {
<span class="fc" id="L256">        checkInitialized();</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (entrySet == null) {</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            if (entrySetCallCount++ == 0)  // Initial call</span>
<span class="fc" id="L259">                entrySet = Collections.unmodifiableMap(this).entrySet();</span>
            else
<span class="fc" id="L261">                return super.entrySet();   // Recursive call</span>
        }

        // This exception will be thrown if the implementation of
        // Collections.unmodifiableMap.entrySet() is changed such that it
        // no longer calls entrySet() on the backing Map.  (Provider's
        // entrySet implementation depends on this &quot;implementation detail&quot;,
        // which is unlikely to change.
<span class="pc bpc" id="L269" title="1 of 2 branches missed.">        if (entrySetCallCount != 2)</span>
<span class="nc" id="L270">            throw new RuntimeException(&quot;Internal error.&quot;);</span>

<span class="fc" id="L272">        return entrySet;</span>
    }

    /**
     * Returns an unmodifiable Set view of the property keys contained in
     * this provider.
     *
     * @since 1.2
     */
    @Override
    public Set&lt;Object&gt; keySet() {
<span class="fc" id="L283">        checkInitialized();</span>
<span class="fc" id="L284">        return Collections.unmodifiableSet(super.keySet());</span>
    }

    /**
     * Returns an unmodifiable Collection view of the property values
     * contained in this provider.
     *
     * @since 1.2
     */
    @Override
    public Collection&lt;Object&gt; values() {
<span class="fc" id="L295">        checkInitialized();</span>
<span class="fc" id="L296">        return Collections.unmodifiableCollection(super.values());</span>
    }

    /**
     * Sets the {@code key} property to have the specified
     * {@code value}.
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
     * where {@code name} is the provider name, to see if it's ok to set this
     * provider's property values.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to set property values.
     *
     * @since 1.2
     */
    @Override
    public synchronized Object put(Object key, Object value) {
<span class="fc" id="L317">        check(&quot;putProviderProperty.&quot;+name);</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L319">            debug.println(&quot;Set &quot; + name + &quot; provider property [&quot; +</span>
                          key + &quot;/&quot; + value +&quot;]&quot;);
        }
<span class="fc" id="L322">        return implPut(key, value);</span>
    }

    /**
     * If the specified key is not already associated with a value (or is mapped
     * to {@code null}) associates it with the given value and returns
     * {@code null}, else returns the current value.
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
     * where {@code name} is the provider name, to see if it's ok to set this
     * provider's property values.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to set property values.
     */
    @Override
    public synchronized Object putIfAbsent(Object key, Object value) {
<span class="nc" id="L342">        check(&quot;putProviderProperty.&quot;+name);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L344">            debug.println(&quot;Set &quot; + name + &quot; provider property [&quot; +</span>
                          key + &quot;/&quot; + value +&quot;]&quot;);
        }
<span class="nc" id="L347">        return implPutIfAbsent(key, value);</span>
    }

    /**
     * Removes the {@code key} property (and its corresponding
     * {@code value}).
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the string {@code &quot;removeProviderProperty.&quot;+name},
     * where {@code name} is the provider name, to see if it's ok to remove this
     * provider's properties.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to remove this provider's properties.
     *
     * @since 1.2
     */
    @Override
    public synchronized Object remove(Object key) {
<span class="fc" id="L368">        check(&quot;removeProviderProperty.&quot;+name);</span>
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L370">            debug.println(&quot;Remove &quot; + name + &quot; provider property &quot; + key);</span>
        }
<span class="fc" id="L372">        return implRemove(key);</span>
    }

    /**
     * Removes the entry for the specified key only if it is currently
     * mapped to the specified value.
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the string {@code &quot;removeProviderProperty.&quot;+name},
     * where {@code name} is the provider name, to see if it's ok to remove this
     * provider's properties.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to remove this provider's properties.
     */
    @Override
    public synchronized boolean remove(Object key, Object value) {
<span class="nc" id="L391">        check(&quot;removeProviderProperty.&quot;+name);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L393">            debug.println(&quot;Remove &quot; + name + &quot; provider property &quot; + key);</span>
        }
<span class="nc" id="L395">        return implRemove(key, value);</span>
    }

    /**
     * Replaces the entry for the specified key only if currently
     * mapped to the specified value.
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
     * where {@code name} is the provider name, to see if it's ok to set this
     * provider's property values.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to set property values.
     */
    @Override
    public synchronized boolean replace(Object key, Object oldValue,
            Object newValue) {
<span class="nc" id="L415">        check(&quot;putProviderProperty.&quot; + name);</span>

<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L418">            debug.println(&quot;Replace &quot; + name + &quot; provider property &quot; + key);</span>
        }
<span class="nc" id="L420">        return implReplace(key, oldValue, newValue);</span>
    }

    /**
     * Replaces the entry for the specified key only if it is
     * currently mapped to some value.
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
     * where {@code name} is the provider name, to see if it's ok to set this
     * provider's property values.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to set property values.
     */
    @Override
    public synchronized Object replace(Object key, Object value) {
<span class="nc" id="L439">        check(&quot;putProviderProperty.&quot; + name);</span>

<span class="nc bnc" id="L441" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L442">            debug.println(&quot;Replace &quot; + name + &quot; provider property &quot; + key);</span>
        }
<span class="nc" id="L444">        return implReplace(key, value);</span>
    }

    /**
     * Replaces each entry's value with the result of invoking the given
     * function on that entry, in the order entries are returned by an entry
     * set iterator, until all entries have been processed or the function
     * throws an exception.
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the string {@code &quot;putProviderProperty.&quot;+name},
     * where {@code name} is the provider name, to see if it's ok to set this
     * provider's property values.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to set property values.
     */
    @Override
    public synchronized void replaceAll(BiFunction&lt;? super Object, ? super Object, ? extends Object&gt; function) {
<span class="nc" id="L465">        check(&quot;putProviderProperty.&quot; + name);</span>

<span class="nc bnc" id="L467" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L468">            debug.println(&quot;ReplaceAll &quot; + name + &quot; provider property &quot;);</span>
        }
<span class="nc" id="L470">        implReplaceAll(function);</span>
<span class="nc" id="L471">    }</span>

    /**
     * Attempts to compute a mapping for the specified key and its
     * current mapped value (or {@code null} if there is no current
     * mapping).
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
     * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
     * provider name, to see if it's ok to set this provider's property values
     * and remove this provider's properties.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to set property values or remove properties.
     */
    @Override
    public synchronized Object compute(Object key,
        BiFunction&lt;? super Object, ? super Object, ? extends Object&gt; remappingFunction) {
<span class="nc" id="L492">        check(&quot;putProviderProperty.&quot; + name);</span>
<span class="nc" id="L493">        check(&quot;removeProviderProperty&quot; + name);</span>

<span class="nc bnc" id="L495" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L496">            debug.println(&quot;Compute &quot; + name + &quot; provider property &quot; + key);</span>
        }
<span class="nc" id="L498">        return implCompute(key, remappingFunction);</span>
    }

    /**
     * If the specified key is not already associated with a value (or
     * is mapped to {@code null}), attempts to compute its value using
     * the given mapping function and enters it into this map unless
     * {@code null}.
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
     * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
     * provider name, to see if it's ok to set this provider's property values
     * and remove this provider's properties.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to set property values and remove properties.
     */
    @Override
    public synchronized Object computeIfAbsent(Object key, Function&lt;? super Object, ? extends Object&gt; mappingFunction) {
<span class="nc" id="L520">        check(&quot;putProviderProperty.&quot; + name);</span>
<span class="nc" id="L521">        check(&quot;removeProviderProperty&quot; + name);</span>

<span class="nc bnc" id="L523" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L524">            debug.println(&quot;ComputeIfAbsent &quot; + name + &quot; provider property &quot; +</span>
                    key);
        }
<span class="nc" id="L527">        return implComputeIfAbsent(key, mappingFunction);</span>
    }

    /**
     * If the value for the specified key is present and non-null, attempts to
     * compute a new mapping given the key and its current mapped value.
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
     * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
     * provider name, to see if it's ok to set this provider's property values
     * and remove this provider's properties.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to set property values or remove properties.
     */
    @Override
    public synchronized Object computeIfPresent(Object key, BiFunction&lt;? super Object, ? super Object, ? extends Object&gt; remappingFunction) {
<span class="nc" id="L547">        check(&quot;putProviderProperty.&quot; + name);</span>
<span class="nc" id="L548">        check(&quot;removeProviderProperty&quot; + name);</span>

<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L551">            debug.println(&quot;ComputeIfPresent &quot; + name + &quot; provider property &quot; +</span>
                    key);
        }
<span class="nc" id="L554">        return implComputeIfPresent(key, remappingFunction);</span>
    }

    /**
     * If the specified key is not already associated with a value or is
     * associated with null, associates it with the given value. Otherwise,
     * replaces the value with the results of the given remapping function,
     * or removes if the result is null. This method may be of use when
     * combining multiple mapped values for a key.
     *
     * &lt;p&gt;If a security manager is enabled, its {@code checkSecurityAccess}
     * method is called with the strings {@code &quot;putProviderProperty.&quot;+name}
     * and {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is the
     * provider name, to see if it's ok to set this provider's property values
     * and remove this provider's properties.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to set property values or remove properties.
     */
    @Override
    public synchronized Object merge(Object key, Object value,  BiFunction&lt;? super Object, ? super Object, ? extends Object&gt;  remappingFunction) {
<span class="nc" id="L577">        check(&quot;putProviderProperty.&quot; + name);</span>
<span class="nc" id="L578">        check(&quot;removeProviderProperty&quot; + name);</span>

<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L581">            debug.println(&quot;Merge &quot; + name + &quot; provider property &quot; + key);</span>
        }
<span class="nc" id="L583">        return implMerge(key, value, remappingFunction);</span>
    }

    // let javadoc show doc from superclass
    @Override
    public Object get(Object key) {
<span class="fc" id="L589">        checkInitialized();</span>
<span class="fc" id="L590">        return super.get(key);</span>
    }

    @Override
    public synchronized Object getOrDefault(Object key, Object defaultValue) {
<span class="nc" id="L595">        checkInitialized();</span>
<span class="nc" id="L596">        return super.getOrDefault(key, defaultValue);</span>
    }

    @Override
    public synchronized void forEach(BiConsumer&lt;? super Object, ? super Object&gt; action) {
<span class="nc" id="L601">        checkInitialized();</span>
<span class="nc" id="L602">        super.forEach(action);</span>
<span class="nc" id="L603">    }</span>

    // let javadoc show doc from superclass
    @Override
    public Enumeration&lt;Object&gt; keys() {
<span class="fc" id="L608">        checkInitialized();</span>
<span class="fc" id="L609">        return super.keys();</span>
    }

    // let javadoc show doc from superclass
    @Override
    public Enumeration&lt;Object&gt; elements() {
<span class="nc" id="L615">        checkInitialized();</span>
<span class="nc" id="L616">        return super.elements();</span>
    }

    // let javadoc show doc from superclass
    public String getProperty(String key) {
<span class="fc" id="L621">        checkInitialized();</span>
<span class="fc" id="L622">        return super.getProperty(key);</span>
    }

    private void checkInitialized() {
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L627">            throw new IllegalStateException();</span>
        }
<span class="fc" id="L629">    }</span>

    private void check(String directive) {
<span class="fc" id="L632">        checkInitialized();</span>
<span class="fc" id="L633">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">        if (security != null) {</span>
<span class="fc" id="L635">            security.checkSecurityAccess(directive);</span>
        }
<span class="fc" id="L637">    }</span>

    // legacy properties changed since last call to any services method?
    private transient boolean legacyChanged;
    // serviceMap changed since last call to getServices()
    private transient boolean servicesChanged;

    // Map&lt;String,String&gt;
    private transient Map&lt;String,String&gt; legacyStrings;

    // Map&lt;ServiceKey,Service&gt;
    // used for services added via putService(), initialized on demand
    private transient Map&lt;ServiceKey,Service&gt; serviceMap;

    // Map&lt;ServiceKey,Service&gt;
    // used for services added via legacy methods, init on demand
    private transient Map&lt;ServiceKey,Service&gt; legacyMap;

    // Set&lt;Service&gt;
    // Unmodifiable set of all services. Initialized on demand.
    private transient Set&lt;Service&gt; serviceSet;

    // register the id attributes for this provider
    // this is to ensure that equals() and hashCode() do not incorrectly
    // report to different provider objects as the same
    private void putId() {
        // note: name and info may be null
<span class="fc" id="L664">        super.put(&quot;Provider.id name&quot;, String.valueOf(name));</span>
<span class="fc" id="L665">        super.put(&quot;Provider.id version&quot;, String.valueOf(version));</span>
<span class="fc" id="L666">        super.put(&quot;Provider.id info&quot;, String.valueOf(info));</span>
<span class="fc" id="L667">        super.put(&quot;Provider.id className&quot;, this.getClass().getName());</span>
<span class="fc" id="L668">    }</span>

    private void readObject(ObjectInputStream in)
                throws IOException, ClassNotFoundException {
<span class="fc" id="L672">        Map&lt;Object,Object&gt; copy = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">        for (Map.Entry&lt;Object,Object&gt; entry : super.entrySet()) {</span>
<span class="fc" id="L674">            copy.put(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L675">        }</span>
<span class="fc" id="L676">        defaults = null;</span>
<span class="fc" id="L677">        in.defaultReadObject();</span>
<span class="fc" id="L678">        implClear();</span>
<span class="fc" id="L679">        initialized = true;</span>
<span class="fc" id="L680">        putAll(copy);</span>
<span class="fc" id="L681">    }</span>

    private boolean checkLegacy(Object key) {
<span class="fc" id="L684">        String keyString = (String)key;</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">        if (keyString.startsWith(&quot;Provider.&quot;)) {</span>
<span class="fc" id="L686">            return false;</span>
        }

<span class="fc" id="L689">        legacyChanged = true;</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">        if (legacyStrings == null) {</span>
<span class="fc" id="L691">            legacyStrings = new LinkedHashMap&lt;String,String&gt;();</span>
        }
<span class="fc" id="L693">        return true;</span>
    }

    /**
     * Copies all of the mappings from the specified Map to this provider.
     * Internal method to be called AFTER the security check has been
     * performed.
     */
    private void implPutAll(Map&lt;?,?&gt; t) {
<span class="fc bfc" id="L702" title="All 2 branches covered.">        for (Map.Entry&lt;?,?&gt; e : t.entrySet()) {</span>
<span class="fc" id="L703">            implPut(e.getKey(), e.getValue());</span>
<span class="fc" id="L704">        }</span>
<span class="fc" id="L705">    }</span>

    private Object implRemove(Object key) {
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">        if (key instanceof String) {</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">            if (!checkLegacy(key)) {</span>
<span class="nc" id="L710">                return null;</span>
            }
<span class="fc" id="L712">            legacyStrings.remove((String)key);</span>
        }
<span class="fc" id="L714">        return super.remove(key);</span>
    }

    private boolean implRemove(Object key, Object value) {
<span class="nc bnc" id="L718" title="All 4 branches missed.">        if (key instanceof String &amp;&amp; value instanceof String) {</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">            if (!checkLegacy(key)) {</span>
<span class="nc" id="L720">                return false;</span>
            }
<span class="nc" id="L722">            legacyStrings.remove((String)key, value);</span>
        }
<span class="nc" id="L724">        return super.remove(key, value);</span>
    }

    private boolean implReplace(Object key, Object oldValue, Object newValue) {
<span class="nc bnc" id="L728" title="All 6 branches missed.">        if ((key instanceof String) &amp;&amp; (oldValue instanceof String) &amp;&amp;</span>
                (newValue instanceof String)) {
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (!checkLegacy(key)) {</span>
<span class="nc" id="L731">                return false;</span>
            }
<span class="nc" id="L733">            legacyStrings.replace((String)key, (String)oldValue,</span>
                    (String)newValue);
        }
<span class="nc" id="L736">        return super.replace(key, oldValue, newValue);</span>
    }

    private Object implReplace(Object key, Object value) {
<span class="nc bnc" id="L740" title="All 4 branches missed.">        if ((key instanceof String) &amp;&amp; (value instanceof String)) {</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">            if (!checkLegacy(key)) {</span>
<span class="nc" id="L742">                return null;</span>
            }
<span class="nc" id="L744">            legacyStrings.replace((String)key, (String)value);</span>
        }
<span class="nc" id="L746">        return super.replace(key, value);</span>
    }

    private void implReplaceAll(BiFunction&lt;? super Object, ? super Object, ? extends Object&gt; function) {
<span class="nc" id="L750">        legacyChanged = true;</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">        if (legacyStrings == null) {</span>
<span class="nc" id="L752">            legacyStrings = new LinkedHashMap&lt;String,String&gt;();</span>
        } else {
<span class="nc" id="L754">            legacyStrings.replaceAll((BiFunction&lt;? super String, ? super String, ? extends String&gt;) function);</span>
        }
<span class="nc" id="L756">        super.replaceAll(function);</span>
<span class="nc" id="L757">    }</span>


    private Object implMerge(Object key, Object value, BiFunction&lt;? super Object, ? super Object, ? extends Object&gt; remappingFunction) {
<span class="nc bnc" id="L761" title="All 4 branches missed.">        if ((key instanceof String) &amp;&amp; (value instanceof String)) {</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">            if (!checkLegacy(key)) {</span>
<span class="nc" id="L763">                return null;</span>
            }
<span class="nc" id="L765">            legacyStrings.merge((String)key, (String)value,</span>
                    (BiFunction&lt;? super String, ? super String, ? extends String&gt;) remappingFunction);
        }
<span class="nc" id="L768">        return super.merge(key, value, remappingFunction);</span>
    }

    private Object implCompute(Object key, BiFunction&lt;? super Object, ? super Object, ? extends Object&gt; remappingFunction) {
<span class="nc bnc" id="L772" title="All 2 branches missed.">        if (key instanceof String) {</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">            if (!checkLegacy(key)) {</span>
<span class="nc" id="L774">                return null;</span>
            }
<span class="nc" id="L776">            legacyStrings.computeIfAbsent((String) key,</span>
                    (Function&lt;? super String, ? extends String&gt;) remappingFunction);
        }
<span class="nc" id="L779">        return super.compute(key, remappingFunction);</span>
    }

    private Object implComputeIfAbsent(Object key, Function&lt;? super Object, ? extends Object&gt; mappingFunction) {
<span class="nc bnc" id="L783" title="All 2 branches missed.">        if (key instanceof String) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">            if (!checkLegacy(key)) {</span>
<span class="nc" id="L785">                return null;</span>
            }
<span class="nc" id="L787">            legacyStrings.computeIfAbsent((String) key,</span>
                    (Function&lt;? super String, ? extends String&gt;) mappingFunction);
        }
<span class="nc" id="L790">        return super.computeIfAbsent(key, mappingFunction);</span>
    }

    private Object implComputeIfPresent(Object key, BiFunction&lt;? super Object, ? super Object, ? extends Object&gt; remappingFunction) {
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (key instanceof String) {</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">            if (!checkLegacy(key)) {</span>
<span class="nc" id="L796">                return null;</span>
            }
<span class="nc" id="L798">            legacyStrings.computeIfPresent((String) key,</span>
                    (BiFunction&lt;? super String, ? super String, ? extends String&gt;) remappingFunction);
        }
<span class="nc" id="L801">        return super.computeIfPresent(key, remappingFunction);</span>
    }

    private Object implPut(Object key, Object value) {
<span class="pc bpc" id="L805" title="2 of 4 branches missed.">        if ((key instanceof String) &amp;&amp; (value instanceof String)) {</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">            if (!checkLegacy(key)) {</span>
<span class="fc" id="L807">                return null;</span>
            }
<span class="fc" id="L809">            legacyStrings.put((String)key, (String)value);</span>
        }
<span class="fc" id="L811">        return super.put(key, value);</span>
    }

    private Object implPutIfAbsent(Object key, Object value) {
<span class="nc bnc" id="L815" title="All 4 branches missed.">        if ((key instanceof String) &amp;&amp; (value instanceof String)) {</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">            if (!checkLegacy(key)) {</span>
<span class="nc" id="L817">                return null;</span>
            }
<span class="nc" id="L819">            legacyStrings.putIfAbsent((String)key, (String)value);</span>
        }
<span class="nc" id="L821">        return super.putIfAbsent(key, value);</span>
    }

    private void implClear() {
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">        if (legacyStrings != null) {</span>
<span class="nc" id="L826">            legacyStrings.clear();</span>
        }
<span class="pc bpc" id="L828" title="1 of 2 branches missed.">        if (legacyMap != null) {</span>
<span class="nc" id="L829">            legacyMap.clear();</span>
        }
<span class="pc bpc" id="L831" title="1 of 2 branches missed.">        if (serviceMap != null) {</span>
<span class="nc" id="L832">            serviceMap.clear();</span>
        }
<span class="fc" id="L834">        legacyChanged = false;</span>
<span class="fc" id="L835">        servicesChanged = false;</span>
<span class="fc" id="L836">        serviceSet = null;</span>
<span class="fc" id="L837">        super.clear();</span>
<span class="fc" id="L838">        putId();</span>
<span class="fc" id="L839">    }</span>

    // used as key in the serviceMap and legacyMap HashMaps
    private static class ServiceKey {
        private final String type;
        private final String algorithm;
        private final String originalAlgorithm;
<span class="fc" id="L846">        private ServiceKey(String type, String algorithm, boolean intern) {</span>
<span class="fc" id="L847">            this.type = type;</span>
<span class="fc" id="L848">            this.originalAlgorithm = algorithm;</span>
<span class="fc" id="L849">            algorithm = algorithm.toUpperCase(ENGLISH);</span>
<span class="fc bfc" id="L850" title="All 2 branches covered.">            this.algorithm = intern ? algorithm.intern() : algorithm;</span>
<span class="fc" id="L851">        }</span>
        public int hashCode() {
<span class="fc" id="L853">            return type.hashCode() + algorithm.hashCode();</span>
        }
        public boolean equals(Object obj) {
<span class="pc bpc" id="L856" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L857">                return true;</span>
            }
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">            if (obj instanceof ServiceKey == false) {</span>
<span class="nc" id="L860">                return false;</span>
            }
<span class="fc" id="L862">            ServiceKey other = (ServiceKey)obj;</span>
<span class="pc bpc" id="L863" title="1 of 2 branches missed.">            return this.type.equals(other.type)</span>
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">                &amp;&amp; this.algorithm.equals(other.algorithm);</span>
        }
        boolean matches(String type, String algorithm) {
<span class="fc bfc" id="L867" title="All 4 branches covered.">            return (this.type == type) &amp;&amp; (this.originalAlgorithm == algorithm);</span>
        }
    }

    /**
     * Ensure all the legacy String properties are fully parsed into
     * service objects.
     */
    private void ensureLegacyParsed() {
<span class="pc bpc" id="L876" title="1 of 4 branches missed.">        if ((legacyChanged == false) || (legacyStrings == null)) {</span>
<span class="fc" id="L877">            return;</span>
        }
<span class="fc" id="L879">        serviceSet = null;</span>
<span class="pc bpc" id="L880" title="1 of 2 branches missed.">        if (legacyMap == null) {</span>
<span class="fc" id="L881">            legacyMap = new LinkedHashMap&lt;ServiceKey,Service&gt;();</span>
        } else {
<span class="nc" id="L883">            legacyMap.clear();</span>
        }
<span class="fc bfc" id="L885" title="All 2 branches covered.">        for (Map.Entry&lt;String,String&gt; entry : legacyStrings.entrySet()) {</span>
<span class="fc" id="L886">            parseLegacyPut(entry.getKey(), entry.getValue());</span>
<span class="fc" id="L887">        }</span>
<span class="fc" id="L888">        removeInvalidServices(legacyMap);</span>
<span class="fc" id="L889">        legacyChanged = false;</span>
<span class="fc" id="L890">    }</span>

    /**
     * Remove all invalid services from the Map. Invalid services can only
     * occur if the legacy properties are inconsistent or incomplete.
     */
    private void removeInvalidServices(Map&lt;ServiceKey,Service&gt; map) {
<span class="fc" id="L897">        for (Iterator&lt;Map.Entry&lt;ServiceKey, Service&gt;&gt; t =</span>
<span class="fc bfc" id="L898" title="All 2 branches covered.">                map.entrySet().iterator(); t.hasNext(); ) {</span>
<span class="fc" id="L899">            Service s = t.next().getValue();</span>
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">            if (s.isValid() == false) {</span>
<span class="nc" id="L901">                t.remove();</span>
            }
<span class="fc" id="L903">        }</span>
<span class="fc" id="L904">    }</span>

    private String[] getTypeAndAlgorithm(String key) {
<span class="fc" id="L907">        int i = key.indexOf(&quot;.&quot;);</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">        if (i &lt; 1) {</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L910">                debug.println(&quot;Ignoring invalid entry in provider &quot;</span>
                        + name + &quot;:&quot; + key);
            }
<span class="nc" id="L913">            return null;</span>
        }
<span class="fc" id="L915">        String type = key.substring(0, i);</span>
<span class="fc" id="L916">        String alg = key.substring(i + 1);</span>
<span class="fc" id="L917">        return new String[] {type, alg};</span>
    }

    private final static String ALIAS_PREFIX = &quot;Alg.Alias.&quot;;
    private final static String ALIAS_PREFIX_LOWER = &quot;alg.alias.&quot;;
<span class="fc" id="L922">    private final static int ALIAS_LENGTH = ALIAS_PREFIX.length();</span>

    private void parseLegacyPut(String name, String value) {
<span class="fc bfc" id="L925" title="All 2 branches covered.">        if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {</span>
            // e.g. put(&quot;Alg.Alias.MessageDigest.SHA&quot;, &quot;SHA-1&quot;);
            // aliasKey ~ MessageDigest.SHA
<span class="fc" id="L928">            String stdAlg = value;</span>
<span class="fc" id="L929">            String aliasKey = name.substring(ALIAS_LENGTH);</span>
<span class="fc" id="L930">            String[] typeAndAlg = getTypeAndAlgorithm(aliasKey);</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">            if (typeAndAlg == null) {</span>
<span class="nc" id="L932">                return;</span>
            }
<span class="fc" id="L934">            String type = getEngineName(typeAndAlg[0]);</span>
<span class="fc" id="L935">            String aliasAlg = typeAndAlg[1].intern();</span>
<span class="fc" id="L936">            ServiceKey key = new ServiceKey(type, stdAlg, true);</span>
<span class="fc" id="L937">            Service s = legacyMap.get(key);</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">            if (s == null) {</span>
<span class="fc" id="L939">                s = new Service(this);</span>
<span class="fc" id="L940">                s.type = type;</span>
<span class="fc" id="L941">                s.algorithm = stdAlg;</span>
<span class="fc" id="L942">                legacyMap.put(key, s);</span>
            }
<span class="fc" id="L944">            legacyMap.put(new ServiceKey(type, aliasAlg, true), s);</span>
<span class="fc" id="L945">            s.addAlias(aliasAlg);</span>
<span class="fc" id="L946">        } else {</span>
<span class="fc" id="L947">            String[] typeAndAlg = getTypeAndAlgorithm(name);</span>
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">            if (typeAndAlg == null) {</span>
<span class="nc" id="L949">                return;</span>
            }
<span class="fc" id="L951">            int i = typeAndAlg[1].indexOf(' ');</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">            if (i == -1) {</span>
                // e.g. put(&quot;MessageDigest.SHA-1&quot;, &quot;sun.security.provider.SHA&quot;);
<span class="fc" id="L954">                String type = getEngineName(typeAndAlg[0]);</span>
<span class="fc" id="L955">                String stdAlg = typeAndAlg[1].intern();</span>
<span class="fc" id="L956">                String className = value;</span>
<span class="fc" id="L957">                ServiceKey key = new ServiceKey(type, stdAlg, true);</span>
<span class="fc" id="L958">                Service s = legacyMap.get(key);</span>
<span class="fc bfc" id="L959" title="All 2 branches covered.">                if (s == null) {</span>
<span class="fc" id="L960">                    s = new Service(this);</span>
<span class="fc" id="L961">                    s.type = type;</span>
<span class="fc" id="L962">                    s.algorithm = stdAlg;</span>
<span class="fc" id="L963">                    legacyMap.put(key, s);</span>
                }
<span class="fc" id="L965">                s.className = className;</span>
<span class="fc" id="L966">            } else { // attribute</span>
                // e.g. put(&quot;MessageDigest.SHA-1 ImplementedIn&quot;, &quot;Software&quot;);
<span class="fc" id="L968">                String attributeValue = value;</span>
<span class="fc" id="L969">                String type = getEngineName(typeAndAlg[0]);</span>
<span class="fc" id="L970">                String attributeString = typeAndAlg[1];</span>
<span class="fc" id="L971">                String stdAlg = attributeString.substring(0, i).intern();</span>
<span class="fc" id="L972">                String attributeName = attributeString.substring(i + 1);</span>
                // kill additional spaces
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">                while (attributeName.startsWith(&quot; &quot;)) {</span>
<span class="nc" id="L975">                    attributeName = attributeName.substring(1);</span>
                }
<span class="fc" id="L977">                attributeName = attributeName.intern();</span>
<span class="fc" id="L978">                ServiceKey key = new ServiceKey(type, stdAlg, true);</span>
<span class="fc" id="L979">                Service s = legacyMap.get(key);</span>
<span class="fc bfc" id="L980" title="All 2 branches covered.">                if (s == null) {</span>
<span class="fc" id="L981">                    s = new Service(this);</span>
<span class="fc" id="L982">                    s.type = type;</span>
<span class="fc" id="L983">                    s.algorithm = stdAlg;</span>
<span class="fc" id="L984">                    legacyMap.put(key, s);</span>
                }
<span class="fc" id="L986">                s.addAttribute(attributeName, attributeValue);</span>
            }
        }
<span class="fc" id="L989">    }</span>

    /**
     * Get the service describing this Provider's implementation of the
     * specified type of this algorithm or alias. If no such
     * implementation exists, this method returns null. If there are two
     * matching services, one added to this provider using
     * {@link #putService putService()} and one added via {@link #put put()},
     * the service added via {@link #putService putService()} is returned.
     *
     * @param type the type of {@link Service service} requested
     * (for example, {@code MessageDigest})
     * @param algorithm the case insensitive algorithm name (or alternate
     * alias) of the service requested (for example, {@code SHA-1})
     *
     * @return the service describing this Provider's matching service
     * or null if no such service exists
     *
     * @throws NullPointerException if type or algorithm is null
     *
     * @since 1.5
     */
    public synchronized Service getService(String type, String algorithm) {
<span class="fc" id="L1012">        checkInitialized();</span>
        // avoid allocating a new key object if possible
<span class="fc" id="L1014">        ServiceKey key = previousKey;</span>
<span class="fc bfc" id="L1015" title="All 2 branches covered.">        if (key.matches(type, algorithm) == false) {</span>
<span class="fc" id="L1016">            key = new ServiceKey(type, algorithm, false);</span>
<span class="fc" id="L1017">            previousKey = key;</span>
        }
<span class="fc bfc" id="L1019" title="All 2 branches covered.">        if (serviceMap != null) {</span>
<span class="fc" id="L1020">            Service service = serviceMap.get(key);</span>
<span class="fc bfc" id="L1021" title="All 2 branches covered.">            if (service != null) {</span>
<span class="fc" id="L1022">                return service;</span>
            }
        }
<span class="fc" id="L1025">        ensureLegacyParsed();</span>
<span class="fc bfc" id="L1026" title="All 2 branches covered.">        return (legacyMap != null) ? legacyMap.get(key) : null;</span>
    }

    // ServiceKey from previous getService() call
    // by re-using it if possible we avoid allocating a new object
    // and the toUpperCase() call.
    // re-use will occur e.g. as the framework traverses the provider
    // list and queries each provider with the same values until it finds
    // a matching service
<span class="fc" id="L1035">    private static volatile ServiceKey previousKey =</span>
                                            new ServiceKey(&quot;&quot;, &quot;&quot;, false);

    /**
     * Get an unmodifiable Set of all services supported by
     * this Provider.
     *
     * @return an unmodifiable Set of all services supported by
     * this Provider
     *
     * @since 1.5
     */
    public synchronized Set&lt;Service&gt; getServices() {
<span class="fc" id="L1048">        checkInitialized();</span>
<span class="fc bfc" id="L1049" title="All 4 branches covered.">        if (legacyChanged || servicesChanged) {</span>
<span class="fc" id="L1050">            serviceSet = null;</span>
        }
<span class="fc bfc" id="L1052" title="All 2 branches covered.">        if (serviceSet == null) {</span>
<span class="fc" id="L1053">            ensureLegacyParsed();</span>
<span class="fc" id="L1054">            Set&lt;Service&gt; set = new LinkedHashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            if (serviceMap != null) {</span>
<span class="fc" id="L1056">                set.addAll(serviceMap.values());</span>
            }
<span class="fc bfc" id="L1058" title="All 2 branches covered.">            if (legacyMap != null) {</span>
<span class="fc" id="L1059">                set.addAll(legacyMap.values());</span>
            }
<span class="fc" id="L1061">            serviceSet = Collections.unmodifiableSet(set);</span>
<span class="fc" id="L1062">            servicesChanged = false;</span>
        }
<span class="fc" id="L1064">        return serviceSet;</span>
    }

    /**
     * Add a service. If a service of the same type with the same algorithm
     * name exists and it was added using {@link #putService putService()},
     * it is replaced by the new service.
     * This method also places information about this service
     * in the provider's Hashtable values in the format described in the
     * &lt;a href=&quot;../../../technotes/guides/security/crypto/CryptoSpec.html&quot;&gt;
     * Java Cryptography Architecture API Specification &amp;amp; Reference &lt;/a&gt;.
     *
     * &lt;p&gt;Also, if there is a security manager, its
     * {@code checkSecurityAccess} method is called with the string
     * {@code &quot;putProviderProperty.&quot;+name}, where {@code name} is
     * the provider name, to see if it's ok to set this provider's property
     * values. If the default implementation of {@code checkSecurityAccess}
     * is used (that is, that method is not overriden), then this results in
     * a call to the security manager's {@code checkPermission} method with
     * a {@code SecurityPermission(&quot;putProviderProperty.&quot;+name)}
     * permission.
     *
     * @param s the Service to add
     *
     * @throws SecurityException
     *      if a security manager exists and its {@link
     *      java.lang.SecurityManager#checkSecurityAccess} method denies
     *      access to set property values.
     * @throws NullPointerException if s is null
     *
     * @since 1.5
     */
    protected synchronized void putService(Service s) {
<span class="fc" id="L1097">        check(&quot;putProviderProperty.&quot; + name);</span>
<span class="pc bpc" id="L1098" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L1099">            debug.println(name + &quot;.putService(): &quot; + s);</span>
        }
<span class="pc bpc" id="L1101" title="1 of 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1102">            throw new NullPointerException();</span>
        }
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">        if (s.getProvider() != this) {</span>
<span class="nc" id="L1105">            throw new IllegalArgumentException</span>
                    (&quot;service.getProvider() must match this Provider object&quot;);
        }
<span class="fc bfc" id="L1108" title="All 2 branches covered.">        if (serviceMap == null) {</span>
<span class="fc" id="L1109">            serviceMap = new LinkedHashMap&lt;ServiceKey,Service&gt;();</span>
        }
<span class="fc" id="L1111">        servicesChanged = true;</span>
<span class="fc" id="L1112">        String type = s.getType();</span>
<span class="fc" id="L1113">        String algorithm = s.getAlgorithm();</span>
<span class="fc" id="L1114">        ServiceKey key = new ServiceKey(type, algorithm, true);</span>
        // remove existing service
<span class="fc" id="L1116">        implRemoveService(serviceMap.get(key));</span>
<span class="fc" id="L1117">        serviceMap.put(key, s);</span>
<span class="fc bfc" id="L1118" title="All 2 branches covered.">        for (String alias : s.getAliases()) {</span>
<span class="fc" id="L1119">            serviceMap.put(new ServiceKey(type, alias, true), s);</span>
<span class="fc" id="L1120">        }</span>
<span class="fc" id="L1121">        putPropertyStrings(s);</span>
<span class="fc" id="L1122">    }</span>

    /**
     * Put the string properties for this Service in this Provider's
     * Hashtable.
     */
    private void putPropertyStrings(Service s) {
<span class="fc" id="L1129">        String type = s.getType();</span>
<span class="fc" id="L1130">        String algorithm = s.getAlgorithm();</span>
        // use super() to avoid permission check and other processing
<span class="fc" id="L1132">        super.put(type + &quot;.&quot; + algorithm, s.getClassName());</span>
<span class="fc bfc" id="L1133" title="All 2 branches covered.">        for (String alias : s.getAliases()) {</span>
<span class="fc" id="L1134">            super.put(ALIAS_PREFIX + type + &quot;.&quot; + alias, algorithm);</span>
<span class="fc" id="L1135">        }</span>
<span class="pc bpc" id="L1136" title="1 of 2 branches missed.">        for (Map.Entry&lt;UString,String&gt; entry : s.attributes.entrySet()) {</span>
<span class="nc" id="L1137">            String key = type + &quot;.&quot; + algorithm + &quot; &quot; + entry.getKey();</span>
<span class="nc" id="L1138">            super.put(key, entry.getValue());</span>
<span class="nc" id="L1139">        }</span>
<span class="fc" id="L1140">    }</span>

    /**
     * Remove the string properties for this Service from this Provider's
     * Hashtable.
     */
    private void removePropertyStrings(Service s) {
<span class="nc" id="L1147">        String type = s.getType();</span>
<span class="nc" id="L1148">        String algorithm = s.getAlgorithm();</span>
        // use super() to avoid permission check and other processing
<span class="nc" id="L1150">        super.remove(type + &quot;.&quot; + algorithm);</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">        for (String alias : s.getAliases()) {</span>
<span class="nc" id="L1152">            super.remove(ALIAS_PREFIX + type + &quot;.&quot; + alias);</span>
<span class="nc" id="L1153">        }</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        for (Map.Entry&lt;UString,String&gt; entry : s.attributes.entrySet()) {</span>
<span class="nc" id="L1155">            String key = type + &quot;.&quot; + algorithm + &quot; &quot; + entry.getKey();</span>
<span class="nc" id="L1156">            super.remove(key);</span>
<span class="nc" id="L1157">        }</span>
<span class="nc" id="L1158">    }</span>

    /**
     * Remove a service previously added using
     * {@link #putService putService()}. The specified service is removed from
     * this provider. It will no longer be returned by
     * {@link #getService getService()} and its information will be removed
     * from this provider's Hashtable.
     *
     * &lt;p&gt;Also, if there is a security manager, its
     * {@code checkSecurityAccess} method is called with the string
     * {@code &quot;removeProviderProperty.&quot;+name}, where {@code name} is
     * the provider name, to see if it's ok to remove this provider's
     * properties. If the default implementation of
     * {@code checkSecurityAccess} is used (that is, that method is not
     * overriden), then this results in a call to the security manager's
     * {@code checkPermission} method with a
     * {@code SecurityPermission(&quot;removeProviderProperty.&quot;+name)}
     * permission.
     *
     * @param s the Service to be removed
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method denies
     *          access to remove this provider's properties.
     * @throws NullPointerException if s is null
     *
     * @since 1.5
     */
    protected synchronized void removeService(Service s) {
<span class="nc" id="L1189">        check(&quot;removeProviderProperty.&quot; + name);</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L1191">            debug.println(name + &quot;.removeService(): &quot; + s);</span>
        }
<span class="nc bnc" id="L1193" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L1194">            throw new NullPointerException();</span>
        }
<span class="nc" id="L1196">        implRemoveService(s);</span>
<span class="nc" id="L1197">    }</span>

    private void implRemoveService(Service s) {
<span class="pc bpc" id="L1200" title="3 of 4 branches missed.">        if ((s == null) || (serviceMap == null)) {</span>
<span class="fc" id="L1201">            return;</span>
        }
<span class="nc" id="L1203">        String type = s.getType();</span>
<span class="nc" id="L1204">        String algorithm = s.getAlgorithm();</span>
<span class="nc" id="L1205">        ServiceKey key = new ServiceKey(type, algorithm, false);</span>
<span class="nc" id="L1206">        Service oldService = serviceMap.get(key);</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">        if (s != oldService) {</span>
<span class="nc" id="L1208">            return;</span>
        }
<span class="nc" id="L1210">        servicesChanged = true;</span>
<span class="nc" id="L1211">        serviceMap.remove(key);</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">        for (String alias : s.getAliases()) {</span>
<span class="nc" id="L1213">            serviceMap.remove(new ServiceKey(type, alias, false));</span>
<span class="nc" id="L1214">        }</span>
<span class="nc" id="L1215">        removePropertyStrings(s);</span>
<span class="nc" id="L1216">    }</span>

    // Wrapped String that behaves in a case insensitive way for equals/hashCode
    private static class UString {
        final String string;
        final String lowerString;

<span class="fc" id="L1223">        UString(String s) {</span>
<span class="fc" id="L1224">            this.string = s;</span>
<span class="fc" id="L1225">            this.lowerString = s.toLowerCase(ENGLISH);</span>
<span class="fc" id="L1226">        }</span>

        public int hashCode() {
<span class="fc" id="L1229">            return lowerString.hashCode();</span>
        }

        public boolean equals(Object obj) {
<span class="pc bpc" id="L1233" title="1 of 2 branches missed.">            if (this == obj) {</span>
<span class="nc" id="L1234">                return true;</span>
            }
<span class="pc bpc" id="L1236" title="1 of 2 branches missed.">            if (obj instanceof UString == false) {</span>
<span class="nc" id="L1237">                return false;</span>
            }
<span class="fc" id="L1239">            UString other = (UString)obj;</span>
<span class="fc" id="L1240">            return lowerString.equals(other.lowerString);</span>
        }

        public String toString() {
<span class="nc" id="L1244">            return string;</span>
        }
    }

    // describe relevant properties of a type of engine
    private static class EngineDescription {
        final String name;
        final boolean supportsParameter;
        final String constructorParameterClassName;
        private volatile Class&lt;?&gt; constructorParameterClass;

<span class="fc" id="L1255">        EngineDescription(String name, boolean sp, String paramName) {</span>
<span class="fc" id="L1256">            this.name = name;</span>
<span class="fc" id="L1257">            this.supportsParameter = sp;</span>
<span class="fc" id="L1258">            this.constructorParameterClassName = paramName;</span>
<span class="fc" id="L1259">        }</span>
        Class&lt;?&gt; getConstructorParameterClass() throws ClassNotFoundException {
<span class="fc" id="L1261">            Class&lt;?&gt; clazz = constructorParameterClass;</span>
<span class="fc bfc" id="L1262" title="All 2 branches covered.">            if (clazz == null) {</span>
<span class="fc" id="L1263">                clazz = Class.forName(constructorParameterClassName);</span>
<span class="fc" id="L1264">                constructorParameterClass = clazz;</span>
            }
<span class="fc" id="L1266">            return clazz;</span>
        }
    }

    // built in knowledge of the engine types shipped as part of the JDK
    private static final Map&lt;String,EngineDescription&gt; knownEngines;

    private static void addEngine(String name, boolean sp, String paramName) {
<span class="fc" id="L1274">        EngineDescription ed = new EngineDescription(name, sp, paramName);</span>
        // also index by canonical name to avoid toLowerCase() for some lookups
<span class="fc" id="L1276">        knownEngines.put(name.toLowerCase(ENGLISH), ed);</span>
<span class="fc" id="L1277">        knownEngines.put(name, ed);</span>
<span class="fc" id="L1278">    }</span>

    static {
<span class="fc" id="L1281">        knownEngines = new HashMap&lt;String,EngineDescription&gt;();</span>
        // JCA
<span class="fc" id="L1283">        addEngine(&quot;AlgorithmParameterGenerator&quot;,        false, null);</span>
<span class="fc" id="L1284">        addEngine(&quot;AlgorithmParameters&quot;,                false, null);</span>
<span class="fc" id="L1285">        addEngine(&quot;KeyFactory&quot;,                         false, null);</span>
<span class="fc" id="L1286">        addEngine(&quot;KeyPairGenerator&quot;,                   false, null);</span>
<span class="fc" id="L1287">        addEngine(&quot;KeyStore&quot;,                           false, null);</span>
<span class="fc" id="L1288">        addEngine(&quot;MessageDigest&quot;,                      false, null);</span>
<span class="fc" id="L1289">        addEngine(&quot;SecureRandom&quot;,                       false, null);</span>
<span class="fc" id="L1290">        addEngine(&quot;Signature&quot;,                          true,  null);</span>
<span class="fc" id="L1291">        addEngine(&quot;CertificateFactory&quot;,                 false, null);</span>
<span class="fc" id="L1292">        addEngine(&quot;CertPathBuilder&quot;,                    false, null);</span>
<span class="fc" id="L1293">        addEngine(&quot;CertPathValidator&quot;,                  false, null);</span>
<span class="fc" id="L1294">        addEngine(&quot;CertStore&quot;,                          false,</span>
                            &quot;java.security.cert.CertStoreParameters&quot;);
        // JCE
<span class="fc" id="L1297">        addEngine(&quot;Cipher&quot;,                             true,  null);</span>
<span class="fc" id="L1298">        addEngine(&quot;ExemptionMechanism&quot;,                 false, null);</span>
<span class="fc" id="L1299">        addEngine(&quot;Mac&quot;,                                true,  null);</span>
<span class="fc" id="L1300">        addEngine(&quot;KeyAgreement&quot;,                       true,  null);</span>
<span class="fc" id="L1301">        addEngine(&quot;KeyGenerator&quot;,                       false, null);</span>
<span class="fc" id="L1302">        addEngine(&quot;SecretKeyFactory&quot;,                   false, null);</span>
        // JSSE
<span class="fc" id="L1304">        addEngine(&quot;KeyManagerFactory&quot;,                  false, null);</span>
<span class="fc" id="L1305">        addEngine(&quot;SSLContext&quot;,                         false, null);</span>
<span class="fc" id="L1306">        addEngine(&quot;TrustManagerFactory&quot;,                false, null);</span>
        // JGSS
<span class="fc" id="L1308">        addEngine(&quot;GssApiMechanism&quot;,                    false, null);</span>
        // SASL
<span class="fc" id="L1310">        addEngine(&quot;SaslClientFactory&quot;,                  false, null);</span>
<span class="fc" id="L1311">        addEngine(&quot;SaslServerFactory&quot;,                  false, null);</span>
        // POLICY
<span class="fc" id="L1313">        addEngine(&quot;Policy&quot;,                             false,</span>
                            &quot;java.security.Policy$Parameters&quot;);
        // CONFIGURATION
<span class="fc" id="L1316">        addEngine(&quot;Configuration&quot;,                      false,</span>
                            &quot;javax.security.auth.login.Configuration$Parameters&quot;);
        // XML DSig
<span class="fc" id="L1319">        addEngine(&quot;XMLSignatureFactory&quot;,                false, null);</span>
<span class="fc" id="L1320">        addEngine(&quot;KeyInfoFactory&quot;,                     false, null);</span>
<span class="fc" id="L1321">        addEngine(&quot;TransformService&quot;,                   false, null);</span>
        // Smart Card I/O
<span class="fc" id="L1323">        addEngine(&quot;TerminalFactory&quot;,                    false,</span>
                            &quot;java.lang.Object&quot;);
<span class="fc" id="L1325">    }</span>

    // get the &quot;standard&quot; (mixed-case) engine name for arbitary case engine name
    // if there is no known engine by that name, return s
    private static String getEngineName(String s) {
        // try original case first, usually correct
<span class="fc" id="L1331">        EngineDescription e = knownEngines.get(s);</span>
<span class="fc bfc" id="L1332" title="All 2 branches covered.">        if (e == null) {</span>
<span class="fc" id="L1333">            e = knownEngines.get(s.toLowerCase(ENGLISH));</span>
        }
<span class="pc bpc" id="L1335" title="1 of 2 branches missed.">        return (e == null) ? s : e.name;</span>
    }

    /**
     * The description of a security service. It encapsulates the properties
     * of a service and contains a factory method to obtain new implementation
     * instances of this service.
     *
     * &lt;p&gt;Each service has a provider that offers the service, a type,
     * an algorithm name, and the name of the class that implements the
     * service. Optionally, it also includes a list of alternate algorithm
     * names for this service (aliases) and attributes, which are a map of
     * (name, value) String pairs.
     *
     * &lt;p&gt;This class defines the methods {@link #supportsParameter
     * supportsParameter()} and {@link #newInstance newInstance()}
     * which are used by the Java security framework when it searches for
     * suitable services and instantes them. The valid arguments to those
     * methods depend on the type of service. For the service types defined
     * within Java SE, see the
     * &lt;a href=&quot;../../../technotes/guides/security/crypto/CryptoSpec.html&quot;&gt;
     * Java Cryptography Architecture API Specification &amp;amp; Reference &lt;/a&gt;
     * for the valid values.
     * Note that components outside of Java SE can define additional types of
     * services and their behavior.
     *
     * &lt;p&gt;Instances of this class are immutable.
     *
     * @since 1.5
     */
    public static class Service {

        private String type, algorithm, className;
        private final Provider provider;
        private List&lt;String&gt; aliases;
        private Map&lt;UString,String&gt; attributes;

        // Reference to the cached implementation Class object
        private volatile Reference&lt;Class&lt;?&gt;&gt; classRef;

        // flag indicating whether this service has its attributes for
        // supportedKeyFormats or supportedKeyClasses set
        // if null, the values have not been initialized
        // if TRUE, at least one of supportedFormats/Classes is non null
        private volatile Boolean hasKeyAttributes;

        // supported encoding formats
        private String[] supportedFormats;

        // names of the supported key (super) classes
        private Class[] supportedClasses;

        // whether this service has been registered with the Provider
        private boolean registered;

<span class="fc" id="L1390">        private static final Class&lt;?&gt;[] CLASS0 = new Class&lt;?&gt;[0];</span>

        // this constructor and these methods are used for parsing
        // the legacy string properties.

<span class="fc" id="L1395">        private Service(Provider provider) {</span>
<span class="fc" id="L1396">            this.provider = provider;</span>
<span class="fc" id="L1397">            aliases = Collections.&lt;String&gt;emptyList();</span>
<span class="fc" id="L1398">            attributes = Collections.&lt;UString,String&gt;emptyMap();</span>
<span class="fc" id="L1399">        }</span>

        private boolean isValid() {
<span class="pc bpc" id="L1402" title="3 of 6 branches missed.">            return (type != null) &amp;&amp; (algorithm != null) &amp;&amp; (className != null);</span>
        }

        private void addAlias(String alias) {
<span class="fc bfc" id="L1406" title="All 2 branches covered.">            if (aliases.isEmpty()) {</span>
<span class="fc" id="L1407">                aliases = new ArrayList&lt;String&gt;(2);</span>
            }
<span class="fc" id="L1409">            aliases.add(alias);</span>
<span class="fc" id="L1410">        }</span>

        void addAttribute(String type, String value) {
<span class="fc bfc" id="L1413" title="All 2 branches covered.">            if (attributes.isEmpty()) {</span>
<span class="fc" id="L1414">                attributes = new HashMap&lt;UString,String&gt;(8);</span>
            }
<span class="fc" id="L1416">            attributes.put(new UString(type), value);</span>
<span class="fc" id="L1417">        }</span>

        /**
         * Construct a new service.
         *
         * @param provider the provider that offers this service
         * @param type the type of this service
         * @param algorithm the algorithm name
         * @param className the name of the class implementing this service
         * @param aliases List of aliases or null if algorithm has no aliases
         * @param attributes Map of attributes or null if this implementation
         *                   has no attributes
         *
         * @throws NullPointerException if provider, type, algorithm, or
         * className is null
         */
        public Service(Provider provider, String type, String algorithm,
                String className, List&lt;String&gt; aliases,
<span class="fc" id="L1435">                Map&lt;String,String&gt; attributes) {</span>
<span class="pc bpc" id="L1436" title="4 of 8 branches missed.">            if ((provider == null) || (type == null) ||</span>
                    (algorithm == null) || (className == null)) {
<span class="nc" id="L1438">                throw new NullPointerException();</span>
            }
<span class="fc" id="L1440">            this.provider = provider;</span>
<span class="fc" id="L1441">            this.type = getEngineName(type);</span>
<span class="fc" id="L1442">            this.algorithm = algorithm;</span>
<span class="fc" id="L1443">            this.className = className;</span>
<span class="fc bfc" id="L1444" title="All 2 branches covered.">            if (aliases == null) {</span>
<span class="fc" id="L1445">                this.aliases = Collections.&lt;String&gt;emptyList();</span>
            } else {
<span class="fc" id="L1447">                this.aliases = new ArrayList&lt;String&gt;(aliases);</span>
            }
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">            if (attributes == null) {</span>
<span class="fc" id="L1450">                this.attributes = Collections.&lt;UString,String&gt;emptyMap();</span>
            } else {
<span class="nc" id="L1452">                this.attributes = new HashMap&lt;UString,String&gt;();</span>
<span class="nc bnc" id="L1453" title="All 2 branches missed.">                for (Map.Entry&lt;String,String&gt; entry : attributes.entrySet()) {</span>
<span class="nc" id="L1454">                    this.attributes.put(new UString(entry.getKey()), entry.getValue());</span>
<span class="nc" id="L1455">                }</span>
            }
<span class="fc" id="L1457">        }</span>

        /**
         * Get the type of this service. For example, {@code MessageDigest}.
         *
         * @return the type of this service
         */
        public final String getType() {
<span class="fc" id="L1465">            return type;</span>
        }

        /**
         * Return the name of the algorithm of this service. For example,
         * {@code SHA-1}.
         *
         * @return the algorithm of this service
         */
        public final String getAlgorithm() {
<span class="fc" id="L1475">            return algorithm;</span>
        }

        /**
         * Return the Provider of this service.
         *
         * @return the Provider of this service
         */
        public final Provider getProvider() {
<span class="fc" id="L1484">            return provider;</span>
        }

        /**
         * Return the name of the class implementing this service.
         *
         * @return the name of the class implementing this service
         */
        public final String getClassName() {
<span class="fc" id="L1493">            return className;</span>
        }

        // internal only
        private final List&lt;String&gt; getAliases() {
<span class="fc" id="L1498">            return aliases;</span>
        }

        /**
         * Return the value of the specified attribute or null if this
         * attribute is not set for this Service.
         *
         * @param name the name of the requested attribute
         *
         * @return the value of the specified attribute or null if the
         *         attribute is not present
         *
         * @throws NullPointerException if name is null
         */
        public final String getAttribute(String name) {
<span class="pc bpc" id="L1513" title="1 of 2 branches missed.">            if (name == null) {</span>
<span class="nc" id="L1514">                throw new NullPointerException();</span>
            }
<span class="fc" id="L1516">            return attributes.get(new UString(name));</span>
        }

        /**
         * Return a new instance of the implementation described by this
         * service. The security provider framework uses this method to
         * construct implementations. Applications will typically not need
         * to call it.
         *
         * &lt;p&gt;The default implementation uses reflection to invoke the
         * standard constructor for this type of service.
         * Security providers can override this method to implement
         * instantiation in a different way.
         * For details and the values of constructorParameter that are
         * valid for the various types of services see the
         * &lt;a href=&quot;../../../technotes/guides/security/crypto/CryptoSpec.html&quot;&gt;
         * Java Cryptography Architecture API Specification &amp;amp;
         * Reference&lt;/a&gt;.
         *
         * @param constructorParameter the value to pass to the constructor,
         * or null if this type of service does not use a constructorParameter.
         *
         * @return a new implementation of this service
         *
         * @throws InvalidParameterException if the value of
         * constructorParameter is invalid for this type of service.
         * @throws NoSuchAlgorithmException if instantation failed for
         * any other reason.
         */
        public Object newInstance(Object constructorParameter)
                throws NoSuchAlgorithmException {
<span class="fc bfc" id="L1547" title="All 2 branches covered.">            if (registered == false) {</span>
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">                if (provider.getService(type, algorithm) != this) {</span>
<span class="nc" id="L1549">                    throw new NoSuchAlgorithmException</span>
                        (&quot;Service not registered with Provider &quot;
<span class="nc" id="L1551">                        + provider.getName() + &quot;: &quot; + this);</span>
                }
<span class="fc" id="L1553">                registered = true;</span>
            }
            try {
<span class="fc" id="L1556">                EngineDescription cap = knownEngines.get(type);</span>
<span class="pc bpc" id="L1557" title="1 of 2 branches missed.">                if (cap == null) {</span>
                    // unknown engine type, use generic code
                    // this is the code path future for non-core
                    // optional packages
<span class="nc" id="L1561">                    return newInstanceGeneric(constructorParameter);</span>
                }
<span class="fc bfc" id="L1563" title="All 2 branches covered.">                if (cap.constructorParameterClassName == null) {</span>
<span class="pc bpc" id="L1564" title="1 of 2 branches missed.">                    if (constructorParameter != null) {</span>
<span class="nc" id="L1565">                        throw new InvalidParameterException</span>
                            (&quot;constructorParameter not used with &quot; + type
                            + &quot; engines&quot;);
                    }
<span class="fc" id="L1569">                    Class&lt;?&gt; clazz = getImplClass();</span>
<span class="fc" id="L1570">                    return clazz.newInstance();</span>
                } else {
<span class="fc" id="L1572">                    Class&lt;?&gt; paramClass = cap.getConstructorParameterClass();</span>
<span class="fc bfc" id="L1573" title="All 2 branches covered.">                    if (constructorParameter != null) {</span>
<span class="fc" id="L1574">                        Class&lt;?&gt; argClass = constructorParameter.getClass();</span>
<span class="fc bfc" id="L1575" title="All 2 branches covered.">                        if (paramClass.isAssignableFrom(argClass) == false) {</span>
<span class="fc" id="L1576">                            throw new InvalidParameterException</span>
                            (&quot;constructorParameter must be instanceof &quot;
<span class="fc" id="L1578">                            + cap.constructorParameterClassName.replace('$', '.')</span>
                            + &quot; for engine type &quot; + type);
                        }
                    }
<span class="fc" id="L1582">                    Class&lt;?&gt; clazz = getImplClass();</span>
<span class="fc" id="L1583">                    Constructor&lt;?&gt; cons = clazz.getConstructor(paramClass);</span>
<span class="fc" id="L1584">                    return cons.newInstance(constructorParameter);</span>
                }
<span class="nc" id="L1586">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1587">                throw e;</span>
<span class="fc" id="L1588">            } catch (InvocationTargetException e) {</span>
<span class="fc" id="L1589">                throw new NoSuchAlgorithmException</span>
                    (&quot;Error constructing implementation (algorithm: &quot;
<span class="fc" id="L1591">                    + algorithm + &quot;, provider: &quot; + provider.getName()</span>
<span class="fc" id="L1592">                    + &quot;, class: &quot; + className + &quot;)&quot;, e.getCause());</span>
<span class="fc" id="L1593">            } catch (Exception e) {</span>
<span class="fc" id="L1594">                throw new NoSuchAlgorithmException</span>
                    (&quot;Error constructing implementation (algorithm: &quot;
<span class="fc" id="L1596">                    + algorithm + &quot;, provider: &quot; + provider.getName()</span>
                    + &quot;, class: &quot; + className + &quot;)&quot;, e);
            }
        }

        // return the implementation Class object for this service
        private Class&lt;?&gt; getImplClass() throws NoSuchAlgorithmException {
            try {
<span class="fc" id="L1604">                Reference&lt;Class&lt;?&gt;&gt; ref = classRef;</span>
<span class="fc bfc" id="L1605" title="All 2 branches covered.">                Class&lt;?&gt; clazz = (ref == null) ? null : ref.get();</span>
<span class="fc bfc" id="L1606" title="All 2 branches covered.">                if (clazz == null) {</span>
<span class="fc" id="L1607">                    ClassLoader cl = provider.getClass().getClassLoader();</span>
<span class="fc bfc" id="L1608" title="All 2 branches covered.">                    if (cl == null) {</span>
<span class="fc" id="L1609">                        clazz = Class.forName(className);</span>
                    } else {
<span class="fc" id="L1611">                        clazz = cl.loadClass(className);</span>
                    }
<span class="fc" id="L1613">                    classRef = new WeakReference&lt;Class&lt;?&gt;&gt;(clazz);</span>
                }
<span class="fc" id="L1615">                return clazz;</span>
<span class="nc" id="L1616">            } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1617">                throw new NoSuchAlgorithmException</span>
                    (&quot;class configured for &quot; + type + &quot;(provider: &quot; +
<span class="nc" id="L1619">                    provider.getName() + &quot;)&quot; + &quot;cannot be found.&quot;, e);</span>
            }
        }

        /**
         * Generic code path for unknown engine types. Call the
         * no-args constructor if constructorParameter is null, otherwise
         * use the first matching constructor.
         */
        private Object newInstanceGeneric(Object constructorParameter)
                throws Exception {
<span class="nc" id="L1630">            Class&lt;?&gt; clazz = getImplClass();</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">            if (constructorParameter == null) {</span>
<span class="nc" id="L1632">                Object o = clazz.newInstance();</span>
<span class="nc" id="L1633">                return o;</span>
            }
<span class="nc" id="L1635">            Class&lt;?&gt; argClass = constructorParameter.getClass();</span>
<span class="nc" id="L1636">            Constructor[] cons = clazz.getConstructors();</span>
            // find first public constructor that can take the
            // argument as parameter
<span class="nc bnc" id="L1639" title="All 2 branches missed.">            for (int i = 0; i &lt; cons.length; i++) {</span>
<span class="nc" id="L1640">                Constructor&lt;?&gt; con = cons[i];</span>
<span class="nc" id="L1641">                Class&lt;?&gt;[] paramTypes = con.getParameterTypes();</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">                if (paramTypes.length != 1) {</span>
<span class="nc" id="L1643">                    continue;</span>
                }
<span class="nc bnc" id="L1645" title="All 2 branches missed.">                if (paramTypes[0].isAssignableFrom(argClass) == false) {</span>
<span class="nc" id="L1646">                    continue;</span>
                }
<span class="nc" id="L1648">                Object o = con.newInstance(new Object[] {constructorParameter});</span>
<span class="nc" id="L1649">                return o;</span>
            }
<span class="nc" id="L1651">            throw new NoSuchAlgorithmException(&quot;No constructor matching &quot;</span>
<span class="nc" id="L1652">                + argClass.getName() + &quot; found in class &quot; + className);</span>
        }

        /**
         * Test whether this Service can use the specified parameter.
         * Returns false if this service cannot use the parameter. Returns
         * true if this service can use the parameter, if a fast test is
         * infeasible, or if the status is unknown.
         *
         * &lt;p&gt;The security provider framework uses this method with
         * some types of services to quickly exclude non-matching
         * implementations for consideration.
         * Applications will typically not need to call it.
         *
         * &lt;p&gt;For details and the values of parameter that are valid for the
         * various types of services see the top of this class and the
         * &lt;a href=&quot;../../../technotes/guides/security/crypto/CryptoSpec.html&quot;&gt;
         * Java Cryptography Architecture API Specification &amp;amp;
         * Reference&lt;/a&gt;.
         * Security providers can override it to implement their own test.
         *
         * @param parameter the parameter to test
         *
         * @return false if this this service cannot use the specified
         * parameter; true if it can possibly use the parameter
         *
         * @throws InvalidParameterException if the value of parameter is
         * invalid for this type of service or if this method cannot be
         * used with this type of service
         */
        public boolean supportsParameter(Object parameter) {
<span class="fc" id="L1683">            EngineDescription cap = knownEngines.get(type);</span>
<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">            if (cap == null) {</span>
                // unknown engine type, return true by default
<span class="nc" id="L1686">                return true;</span>
            }
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">            if (cap.supportsParameter == false) {</span>
<span class="nc" id="L1689">                throw new InvalidParameterException(&quot;supportsParameter() not &quot;</span>
                    + &quot;used with &quot; + type + &quot; engines&quot;);
            }
            // allow null for keys without attributes for compatibility
<span class="pc bpc" id="L1693" title="2 of 4 branches missed.">            if ((parameter != null) &amp;&amp; (parameter instanceof Key == false)) {</span>
<span class="nc" id="L1694">                throw new InvalidParameterException</span>
                    (&quot;Parameter must be instanceof Key for engine &quot; + type);
            }
<span class="fc bfc" id="L1697" title="All 2 branches covered.">            if (hasKeyAttributes() == false) {</span>
<span class="fc" id="L1698">                return true;</span>
            }
<span class="pc bpc" id="L1700" title="1 of 2 branches missed.">            if (parameter == null) {</span>
<span class="nc" id="L1701">                return false;</span>
            }
<span class="fc" id="L1703">            Key key = (Key)parameter;</span>
<span class="fc bfc" id="L1704" title="All 2 branches covered.">            if (supportsKeyFormat(key)) {</span>
<span class="fc" id="L1705">                return true;</span>
            }
<span class="fc bfc" id="L1707" title="All 2 branches covered.">            if (supportsKeyClass(key)) {</span>
<span class="fc" id="L1708">                return true;</span>
            }
<span class="fc" id="L1710">            return false;</span>
        }

        /**
         * Return whether this service has its Supported* properties for
         * keys defined. Parses the attributes if not yet initialized.
         */
        private boolean hasKeyAttributes() {
<span class="fc" id="L1718">            Boolean b = hasKeyAttributes;</span>
<span class="fc bfc" id="L1719" title="All 2 branches covered.">            if (b == null) {</span>
<span class="fc" id="L1720">                synchronized (this) {</span>
                    String s;
<span class="fc" id="L1722">                    s = getAttribute(&quot;SupportedKeyFormats&quot;);</span>
<span class="fc bfc" id="L1723" title="All 2 branches covered.">                    if (s != null) {</span>
<span class="fc" id="L1724">                        supportedFormats = s.split(&quot;\\|&quot;);</span>
                    }
<span class="fc" id="L1726">                    s = getAttribute(&quot;SupportedKeyClasses&quot;);</span>
<span class="fc bfc" id="L1727" title="All 2 branches covered.">                    if (s != null) {</span>
<span class="fc" id="L1728">                        String[] classNames = s.split(&quot;\\|&quot;);</span>
<span class="fc" id="L1729">                        List&lt;Class&lt;?&gt;&gt; classList =</span>
                            new ArrayList&lt;&gt;(classNames.length);
<span class="fc bfc" id="L1731" title="All 2 branches covered.">                        for (String className : classNames) {</span>
<span class="fc" id="L1732">                            Class&lt;?&gt; clazz = getKeyClass(className);</span>
<span class="pc bpc" id="L1733" title="1 of 2 branches missed.">                            if (clazz != null) {</span>
<span class="fc" id="L1734">                                classList.add(clazz);</span>
                            }
                        }
<span class="fc" id="L1737">                        supportedClasses = classList.toArray(CLASS0);</span>
                    }
<span class="fc bfc" id="L1739" title="All 4 branches covered.">                    boolean bool = (supportedFormats != null)</span>
                        || (supportedClasses != null);
<span class="fc" id="L1741">                    b = Boolean.valueOf(bool);</span>
<span class="fc" id="L1742">                    hasKeyAttributes = b;</span>
<span class="pc" id="L1743">                }</span>
            }
<span class="fc" id="L1745">            return b.booleanValue();</span>
        }

        // get the key class object of the specified name
        private Class&lt;?&gt; getKeyClass(String name) {
            try {
<span class="fc" id="L1751">                return Class.forName(name);</span>
<span class="nc" id="L1752">            } catch (ClassNotFoundException e) {</span>
                // ignore
            }
            try {
<span class="nc" id="L1756">                ClassLoader cl = provider.getClass().getClassLoader();</span>
<span class="nc bnc" id="L1757" title="All 2 branches missed.">                if (cl != null) {</span>
<span class="nc" id="L1758">                    return cl.loadClass(name);</span>
                }
<span class="nc" id="L1760">            } catch (ClassNotFoundException e) {</span>
                // ignore
<span class="nc" id="L1762">            }</span>
<span class="nc" id="L1763">            return null;</span>
        }

        private boolean supportsKeyFormat(Key key) {
<span class="fc bfc" id="L1767" title="All 2 branches covered.">            if (supportedFormats == null) {</span>
<span class="fc" id="L1768">                return false;</span>
            }
<span class="fc" id="L1770">            String format = key.getFormat();</span>
<span class="pc bpc" id="L1771" title="1 of 2 branches missed.">            if (format == null) {</span>
<span class="nc" id="L1772">                return false;</span>
            }
<span class="pc bpc" id="L1774" title="1 of 2 branches missed.">            for (String supportedFormat : supportedFormats) {</span>
<span class="pc bpc" id="L1775" title="1 of 2 branches missed.">                if (supportedFormat.equals(format)) {</span>
<span class="fc" id="L1776">                    return true;</span>
                }
            }
<span class="nc" id="L1779">            return false;</span>
        }

        private boolean supportsKeyClass(Key key) {
<span class="pc bpc" id="L1783" title="1 of 2 branches missed.">            if (supportedClasses == null) {</span>
<span class="nc" id="L1784">                return false;</span>
            }
<span class="fc" id="L1786">            Class&lt;?&gt; keyClass = key.getClass();</span>
<span class="fc bfc" id="L1787" title="All 2 branches covered.">            for (Class&lt;?&gt; clazz : supportedClasses) {</span>
<span class="fc bfc" id="L1788" title="All 2 branches covered.">                if (clazz.isAssignableFrom(keyClass)) {</span>
<span class="fc" id="L1789">                    return true;</span>
                }
            }
<span class="fc" id="L1792">            return false;</span>
        }

        /**
         * Return a String representation of this service.
         *
         * @return a String representation of this service.
         */
        public String toString() {
<span class="nc bnc" id="L1801" title="All 2 branches missed.">            String aString = aliases.isEmpty()</span>
<span class="nc" id="L1802">                ? &quot;&quot; : &quot;\r\n  aliases: &quot; + aliases.toString();</span>
<span class="nc bnc" id="L1803" title="All 2 branches missed.">            String attrs = attributes.isEmpty()</span>
<span class="nc" id="L1804">                ? &quot;&quot; : &quot;\r\n  attributes: &quot; + attributes.toString();</span>
<span class="nc" id="L1805">            return provider.getName() + &quot;: &quot; + type + &quot;.&quot; + algorithm</span>
                + &quot; -&gt; &quot; + className + aString + attrs + &quot;\r\n&quot;;
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>