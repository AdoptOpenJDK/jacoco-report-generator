<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AccessControlContext.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">AccessControlContext.java</span></div><h1>AccessControlContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.util.ArrayList;
import java.util.List;
import sun.security.util.Debug;
import sun.security.util.SecurityConstants;


/**
 * An AccessControlContext is used to make system resource access decisions
 * based on the context it encapsulates.
 *
 * &lt;p&gt;More specifically, it encapsulates a context and
 * has a single method, {@code checkPermission},
 * that is equivalent to the {@code checkPermission} method
 * in the AccessController class, with one difference: The AccessControlContext
 * {@code checkPermission} method makes access decisions based on the
 * context it encapsulates,
 * rather than that of the current execution thread.
 *
 * &lt;p&gt;Thus, the purpose of AccessControlContext is for those situations where
 * a security check that should be made within a given context
 * actually needs to be done from within a
 * &lt;i&gt;different&lt;/i&gt; context (for example, from within a worker thread).
 *
 * &lt;p&gt; An AccessControlContext is created by calling the
 * {@code AccessController.getContext} method.
 * The {@code getContext} method takes a &quot;snapshot&quot;
 * of the current calling context, and places
 * it in an AccessControlContext object, which it returns. A sample call is
 * the following:
 *
 * &lt;pre&gt;
 *   AccessControlContext acc = AccessController.getContext()
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Code within a different context can subsequently call the
 * {@code checkPermission} method on the
 * previously-saved AccessControlContext object. A sample call is the
 * following:
 *
 * &lt;pre&gt;
 *   acc.checkPermission(permission)
 * &lt;/pre&gt;
 *
 * @see AccessController
 *
 * @author Roland Schemers
 */

public final class AccessControlContext {

    private ProtectionDomain context[];
    // isPrivileged and isAuthorized are referenced by the VM - do not remove
    // or change their names
    private boolean isPrivileged;
<span class="pc" id="L83">    private boolean isAuthorized = false;</span>

    // Note: This field is directly used by the virtual machine
    // native codes. Don't touch it.
    private AccessControlContext privilegedContext;

<span class="pc" id="L89">    private DomainCombiner combiner = null;</span>

    // limited privilege scope
    private Permission permissions[];
    private AccessControlContext parent;
    private boolean isWrapped;

    // is constrained by limited privilege scope?
    private boolean isLimited;
    private ProtectionDomain limitedContext[];

<span class="fc" id="L100">    private static boolean debugInit = false;</span>
<span class="fc" id="L101">    private static Debug debug = null;</span>

    static Debug getDebug()
    {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (debugInit)</span>
<span class="fc" id="L106">            return debug;</span>
        else {
<span class="fc bfc" id="L108" title="All 2 branches covered.">            if (Policy.isSet()) {</span>
<span class="fc" id="L109">                debug = Debug.getInstance(&quot;access&quot;);</span>
<span class="fc" id="L110">                debugInit = true;</span>
            }
<span class="fc" id="L112">            return debug;</span>
        }
    }

    /**
     * Create an AccessControlContext with the given array of ProtectionDomains.
     * Context must not be null. Duplicate domains will be removed from the
     * context.
     *
     * @param context the ProtectionDomains associated with this context.
     * The non-duplicate domains are copied from the array. Subsequent
     * changes to the array will not affect this AccessControlContext.
     * @throws NullPointerException if {@code context} is {@code null}
     */
    public AccessControlContext(ProtectionDomain context[])
<span class="fc" id="L127">    {</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (context.length == 0) {</span>
<span class="fc" id="L129">            this.context = null;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        } else if (context.length == 1) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            if (context[0] != null) {</span>
<span class="fc" id="L132">                this.context = context.clone();</span>
            } else {
<span class="fc" id="L134">                this.context = null;</span>
            }
        } else {
<span class="fc" id="L137">            List&lt;ProtectionDomain&gt; v = new ArrayList&lt;&gt;(context.length);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">            for (int i =0; i&lt; context.length; i++) {</span>
<span class="pc bpc" id="L139" title="3 of 4 branches missed.">                if ((context[i] != null) &amp;&amp;  (!v.contains(context[i])))</span>
<span class="nc" id="L140">                    v.add(context[i]);</span>
            }
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            if (!v.isEmpty()) {</span>
<span class="nc" id="L143">                this.context = new ProtectionDomain[v.size()];</span>
<span class="nc" id="L144">                this.context = v.toArray(this.context);</span>
            }
        }
<span class="fc" id="L147">    }</span>

    /**
     * Create a new {@code AccessControlContext} with the given
     * {@code AccessControlContext} and {@code DomainCombiner}.
     * This constructor associates the provided
     * {@code DomainCombiner} with the provided
     * {@code AccessControlContext}.
     *
     * &lt;p&gt;
     *
     * @param acc the {@code AccessControlContext} associated
     *          with the provided {@code DomainCombiner}.
     *
     * @param combiner the {@code DomainCombiner} to be associated
     *          with the provided {@code AccessControlContext}.
     *
     * @exception NullPointerException if the provided
     *          {@code context} is {@code null}.
     *
     * @exception SecurityException if a security manager is installed and the
     *          caller does not have the &quot;createAccessControlContext&quot;
     *          {@link SecurityPermission}
     * @since 1.3
     */
    public AccessControlContext(AccessControlContext acc,
<span class="fc" id="L173">                                DomainCombiner combiner) {</span>

<span class="fc" id="L175">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (sm != null) {</span>
<span class="fc" id="L177">            sm.checkPermission(SecurityConstants.CREATE_ACC_PERMISSION);</span>
<span class="fc" id="L178">            this.isAuthorized = true;</span>
        }

<span class="fc" id="L181">        this.context = acc.context;</span>

        // we do not need to run the combine method on the
        // provided ACC.  it was already &quot;combined&quot; when the
        // context was originally retrieved.
        //
        // at this point in time, we simply throw away the old
        // combiner and use the newly provided one.
<span class="fc" id="L189">        this.combiner = combiner;</span>
<span class="fc" id="L190">    }</span>

    /**
     * package private for AccessController
     *
     * This &quot;argument wrapper&quot; context will be passed as the actual context
     * parameter on an internal doPrivileged() call used in the implementation.
     */
    AccessControlContext(ProtectionDomain caller, DomainCombiner combiner,
        AccessControlContext parent, AccessControlContext context,
        Permission[] perms)
<span class="fc" id="L201">    {</span>
        /*
         * Combine the domains from the doPrivileged() context into our
         * wrapper context, if necessary.
         */
<span class="fc" id="L206">        ProtectionDomain[] callerPDs = null;</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (caller != null) {</span>
<span class="fc" id="L208">             callerPDs = new ProtectionDomain[] { caller };</span>
        }
<span class="fc bfc" id="L210" title="All 2 branches covered.">        if (context != null) {</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (combiner != null) {</span>
<span class="nc" id="L212">                this.context = combiner.combine(callerPDs, context.context);</span>
            } else {
<span class="fc" id="L214">                this.context = combine(callerPDs, context.context);</span>
            }
        } else {
            /*
             * Call combiner even if there is seemingly nothing to combine.
             */
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (combiner != null) {</span>
<span class="fc" id="L221">                this.context = combiner.combine(callerPDs, null);</span>
            } else {
<span class="fc" id="L223">                this.context = combine(callerPDs, null);</span>
            }
        }
<span class="fc" id="L226">        this.combiner = combiner;</span>

<span class="fc" id="L228">        Permission[] tmp = null;</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">        if (perms != null) {</span>
<span class="fc" id="L230">            tmp = new Permission[perms.length];</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">            for (int i=0; i &lt; perms.length; i++) {</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">                if (perms[i] == null) {</span>
<span class="nc" id="L233">                    throw new NullPointerException(&quot;permission can't be null&quot;);</span>
                }

                /*
                 * An AllPermission argument is equivalent to calling
                 * doPrivileged() without any limit permissions.
                 */
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">                if (perms[i].getClass() == AllPermission.class) {</span>
<span class="nc" id="L241">                    parent = null;</span>
                }
<span class="fc" id="L243">                tmp[i] = perms[i];</span>
            }
        }

        /*
         * For a doPrivileged() with limited privilege scope, initialize
         * the relevant fields.
         *
         * The limitedContext field contains the union of all domains which
         * are enclosed by this limited privilege scope. In other words,
         * it contains all of the domains which could potentially be checked
         * if none of the limiting permissions implied a requested permission.
         */
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L257">            this.limitedContext = combine(parent.context, parent.limitedContext);</span>
<span class="fc" id="L258">            this.isLimited = true;</span>
<span class="fc" id="L259">            this.isWrapped = true;</span>
<span class="fc" id="L260">            this.permissions = tmp;</span>
<span class="fc" id="L261">            this.parent = parent;</span>
<span class="fc" id="L262">            this.privilegedContext = context; // used in checkPermission2()</span>
        }
<span class="fc" id="L264">        this.isAuthorized = true;</span>
<span class="fc" id="L265">    }</span>


    /**
     * package private constructor for AccessController.getContext()
     */

    AccessControlContext(ProtectionDomain context[],
                         boolean isPrivileged)
<span class="fc" id="L274">    {</span>
<span class="fc" id="L275">        this.context = context;</span>
<span class="fc" id="L276">        this.isPrivileged = isPrivileged;</span>
<span class="fc" id="L277">        this.isAuthorized = true;</span>
<span class="fc" id="L278">    }</span>

    /**
     * Constructor for JavaSecurityAccess.doIntersectionPrivilege()
     */
    AccessControlContext(ProtectionDomain[] context,
                         AccessControlContext privilegedContext)
<span class="nc" id="L285">    {</span>
<span class="nc" id="L286">        this.context = context;</span>
<span class="nc" id="L287">        this.privilegedContext = privilegedContext;</span>
<span class="nc" id="L288">        this.isPrivileged = true;</span>
<span class="nc" id="L289">    }</span>

    /**
     * Returns this context's context.
     */
    ProtectionDomain[] getContext() {
<span class="nc" id="L295">        return context;</span>
    }

    /**
     * Returns true if this context is privileged.
     */
    boolean isPrivileged()
    {
<span class="nc" id="L303">        return isPrivileged;</span>
    }

    /**
     * get the assigned combiner from the privileged or inherited context
     */
    DomainCombiner getAssignedCombiner() {
        AccessControlContext acc;
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        if (isPrivileged) {</span>
<span class="fc" id="L312">            acc = privilegedContext;</span>
        } else {
<span class="nc" id="L314">            acc = AccessController.getInheritedAccessControlContext();</span>
        }
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (acc != null) {</span>
<span class="fc" id="L317">            return acc.combiner;</span>
        }
<span class="nc" id="L319">        return null;</span>
    }

    /**
     * Get the {@code DomainCombiner} associated with this
     * {@code AccessControlContext}.
     *
     * &lt;p&gt;
     *
     * @return the {@code DomainCombiner} associated with this
     *          {@code AccessControlContext}, or {@code null}
     *          if there is none.
     *
     * @exception SecurityException if a security manager is installed and
     *          the caller does not have the &quot;getDomainCombiner&quot;
     *          {@link SecurityPermission}
     * @since 1.3
     */
    public DomainCombiner getDomainCombiner() {

<span class="fc" id="L339">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">        if (sm != null) {</span>
<span class="fc" id="L341">            sm.checkPermission(SecurityConstants.GET_COMBINER_PERMISSION);</span>
        }
<span class="fc" id="L343">        return getCombiner();</span>
    }

    /**
     * package private for AccessController
     */
    DomainCombiner getCombiner() {
<span class="fc" id="L350">        return combiner;</span>
    }

    boolean isAuthorized() {
<span class="fc" id="L354">        return isAuthorized;</span>
    }

    /**
     * Determines whether the access request indicated by the
     * specified permission should be allowed or denied, based on
     * the security policy currently in effect, and the context in
     * this object. The request is allowed only if every ProtectionDomain
     * in the context implies the permission. Otherwise the request is
     * denied.
     *
     * &lt;p&gt;
     * This method quietly returns if the access request
     * is permitted, or throws a suitable AccessControlException otherwise.
     *
     * @param perm the requested permission.
     *
     * @exception AccessControlException if the specified permission
     * is not permitted, based on the current security policy and the
     * context encapsulated by this object.
     * @exception NullPointerException if the permission to check for is null.
     */
    public void checkPermission(Permission perm)
        throws AccessControlException
    {
<span class="fc" id="L379">        boolean dumpDebug = false;</span>

<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (perm == null) {</span>
<span class="fc" id="L382">            throw new NullPointerException(&quot;permission can't be null&quot;);</span>
        }
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (getDebug() != null) {</span>
            // If &quot;codebase&quot; is not specified, we dump the info by default.
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            dumpDebug = !Debug.isOn(&quot;codebase=&quot;);</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">            if (!dumpDebug) {</span>
                // If &quot;codebase&quot; is specified, only dump if the specified code
                // value is in the stack.
<span class="nc bnc" id="L390" title="All 4 branches missed.">                for (int i = 0; context != null &amp;&amp; i &lt; context.length; i++) {</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">                    if (context[i].getCodeSource() != null &amp;&amp;</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                        context[i].getCodeSource().getLocation() != null &amp;&amp;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">                        Debug.isOn(&quot;codebase=&quot; + context[i].getCodeSource().getLocation().toString())) {</span>
<span class="nc" id="L394">                        dumpDebug = true;</span>
<span class="nc" id="L395">                        break;</span>
                    }
                }
            }

<span class="pc bpc" id="L400" title="1 of 2 branches missed.">            dumpDebug &amp;= !Debug.isOn(&quot;permission=&quot;) ||</span>
<span class="pc bnc" id="L401" title="All 2 branches missed.">                Debug.isOn(&quot;permission=&quot; + perm.getClass().getCanonicalName());</span>

<span class="pc bpc" id="L403" title="2 of 4 branches missed.">            if (dumpDebug &amp;&amp; Debug.isOn(&quot;stack&quot;)) {</span>
<span class="nc" id="L404">                Thread.dumpStack();</span>
            }

<span class="pc bpc" id="L407" title="2 of 4 branches missed.">            if (dumpDebug &amp;&amp; Debug.isOn(&quot;domain&quot;)) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">                if (context == null) {</span>
<span class="nc" id="L409">                    debug.println(&quot;domain (context is null)&quot;);</span>
                } else {
<span class="nc bnc" id="L411" title="All 2 branches missed.">                    for (int i=0; i&lt; context.length; i++) {</span>
<span class="nc" id="L412">                        debug.println(&quot;domain &quot;+i+&quot; &quot;+context[i]);</span>
                    }
                }
            }
        }

        /*
         * iterate through the ProtectionDomains in the context.
         * Stop at the first one that doesn't allow the
         * requested permission (throwing an exception).
         *
         */

        /* if ctxt is null, all we had on the stack were system domains,
           or the first domain was a Privileged system domain. This
           is to make the common case for system code very fast */

<span class="fc bfc" id="L429" title="All 2 branches covered.">        if (context == null) {</span>
<span class="fc" id="L430">            checkPermission2(perm);</span>
<span class="fc" id="L431">            return;</span>
        }

<span class="fc bfc" id="L434" title="All 2 branches covered.">        for (int i=0; i&lt; context.length; i++) {</span>
<span class="pc bpc" id="L435" title="1 of 4 branches missed.">            if (context[i] != null &amp;&amp;  !context[i].implies(perm)) {</span>
<span class="fc bfc" id="L436" title="All 2 branches covered.">                if (dumpDebug) {</span>
<span class="fc" id="L437">                    debug.println(&quot;access denied &quot; + perm);</span>
                }

<span class="pc bpc" id="L440" title="1 of 4 branches missed.">                if (Debug.isOn(&quot;failure&quot;) &amp;&amp; debug != null) {</span>
                    // Want to make sure this is always displayed for failure,
                    // but do not want to display again if already displayed
                    // above.
<span class="nc bnc" id="L444" title="All 2 branches missed.">                    if (!dumpDebug) {</span>
<span class="nc" id="L445">                        debug.println(&quot;access denied &quot; + perm);</span>
                    }
<span class="nc" id="L447">                    Thread.dumpStack();</span>
<span class="nc" id="L448">                    final ProtectionDomain pd = context[i];</span>
<span class="nc" id="L449">                    final Debug db = debug;</span>
<span class="nc" id="L450">                    AccessController.doPrivileged (new PrivilegedAction&lt;Void&gt;() {</span>
                        public Void run() {
<span class="nc" id="L452">                            db.println(&quot;domain that failed &quot;+pd);</span>
<span class="nc" id="L453">                            return null;</span>
                        }
                    });
                }
<span class="fc" id="L457">                throw new AccessControlException(&quot;access denied &quot;+perm, perm);</span>
            }
        }

        // allow if all of them allowed access
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (dumpDebug) {</span>
<span class="fc" id="L463">            debug.println(&quot;access allowed &quot;+perm);</span>
        }

<span class="fc" id="L466">        checkPermission2(perm);</span>
<span class="fc" id="L467">    }</span>

    /*
     * Check the domains associated with the limited privilege scope.
     */
    private void checkPermission2(Permission perm) {
<span class="fc bfc" id="L473" title="All 2 branches covered.">        if (!isLimited) {</span>
<span class="fc" id="L474">            return;</span>
        }

        /*
         * Check the doPrivileged() context parameter, if present.
         */
<span class="fc bfc" id="L480" title="All 2 branches covered.">        if (privilegedContext != null) {</span>
<span class="fc" id="L481">            privilegedContext.checkPermission2(perm);</span>
        }

        /*
         * Ignore the limited permissions and parent fields of a wrapper
         * context since they were already carried down into the unwrapped
         * context.
         */
<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (isWrapped) {</span>
<span class="fc" id="L490">            return;</span>
        }

        /*
         * Try to match any limited privilege scope.
         */
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        if (permissions != null) {</span>
<span class="fc" id="L497">            Class&lt;?&gt; permClass = perm.getClass();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">            for (int i=0; i &lt; permissions.length; i++) {</span>
<span class="fc" id="L499">                Permission limit = permissions[i];</span>
<span class="pc bpc" id="L500" title="1 of 4 branches missed.">                if (limit.getClass().equals(permClass) &amp;&amp; limit.implies(perm)) {</span>
<span class="fc" id="L501">                    return;</span>
                }
            }
        }

        /*
         * Check the limited privilege scope up the call stack or the inherited
         * parent thread call stack of this ACC.
         */
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (parent != null) {</span>
            /*
             * As an optimization, if the parent context is the inherited call
             * stack context from a parent thread then checking the protection
             * domains of the parent context is redundant since they have
             * already been merged into the child thread's context by
             * optimize(). When parent is set to an inherited context this
             * context was not directly created by a limited scope
             * doPrivileged() and it does not have its own limited permissions.
             */
<span class="nc bnc" id="L520" title="All 2 branches missed.">            if (permissions == null) {</span>
<span class="nc" id="L521">                parent.checkPermission2(perm);</span>
            } else {
<span class="nc" id="L523">                parent.checkPermission(perm);</span>
            }
        }
<span class="nc" id="L526">    }</span>

    /**
     * Take the stack-based context (this) and combine it with the
     * privileged or inherited context, if need be. Any limited
     * privilege scope is flagged regardless of whether the assigned
     * context comes from an immediately enclosing limited doPrivileged().
     * The limited privilege scope can indirectly flow from the inherited
     * parent thread or an assigned context previously captured by getContext().
     */
    AccessControlContext optimize() {
        // the assigned (privileged or inherited) context
        AccessControlContext acc;
<span class="fc" id="L539">        DomainCombiner combiner = null;</span>
<span class="fc" id="L540">        AccessControlContext parent = null;</span>
<span class="fc" id="L541">        Permission[] permissions = null;</span>

<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (isPrivileged) {</span>
<span class="fc" id="L544">            acc = privilegedContext;</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">            if (acc != null) {</span>
                /*
                 * If the context is from a limited scope doPrivileged() then
                 * copy the permissions and parent fields out of the wrapper
                 * context that was created to hold them.
                 */
<span class="fc bfc" id="L551" title="All 2 branches covered.">                if (acc.isWrapped) {</span>
<span class="fc" id="L552">                    permissions = acc.permissions;</span>
<span class="fc" id="L553">                    parent = acc.parent;</span>
                }
            }
        } else {
<span class="fc" id="L557">            acc = AccessController.getInheritedAccessControlContext();</span>
<span class="fc bfc" id="L558" title="All 2 branches covered.">            if (acc != null) {</span>
                /*
                 * If the inherited context is constrained by a limited scope
                 * doPrivileged() then set it as our parent so we will process
                 * the non-domain-related state.
                 */
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">                if (acc.isLimited) {</span>
<span class="nc" id="L565">                    parent = acc;</span>
                }
            }
        }

        // this.context could be null if only system code is on the stack;
        // in that case, ignore the stack context
<span class="fc bfc" id="L572" title="All 2 branches covered.">        boolean skipStack = (context == null);</span>

        // acc.context could be null if only system code was involved;
        // in that case, ignore the assigned context
<span class="fc bfc" id="L576" title="All 4 branches covered.">        boolean skipAssigned = (acc == null || acc.context == null);</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">        ProtectionDomain[] assigned = (skipAssigned) ? null : acc.context;</span>
        ProtectionDomain[] pd;

        // if there is no enclosing limited privilege scope on the stack or
        // inherited from a parent thread
<span class="pc bpc" id="L582" title="1 of 6 branches missed.">        boolean skipLimited = ((acc == null || !acc.isWrapped) &amp;&amp; parent == null);</span>

<span class="fc bfc" id="L584" title="All 4 branches covered.">        if (acc != null &amp;&amp; acc.combiner != null) {</span>
            // let the assigned acc's combiner do its thing
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">            if (getDebug() != null) {</span>
<span class="nc" id="L587">                debug.println(&quot;AccessControlContext invoking the Combiner&quot;);</span>
            }

            // No need to clone current and assigned.context
            // combine() will not update them
<span class="fc" id="L592">            combiner = acc.combiner;</span>
<span class="fc" id="L593">            pd = combiner.combine(context, assigned);</span>
        } else {
<span class="fc bfc" id="L595" title="All 2 branches covered.">            if (skipStack) {</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">                if (skipAssigned) {</span>
<span class="fc" id="L597">                    calculateFields(acc, parent, permissions);</span>
<span class="fc" id="L598">                    return this;</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">                } else if (skipLimited) {</span>
<span class="fc" id="L600">                    return acc;</span>
                }
<span class="fc bfc" id="L602" title="All 2 branches covered.">            } else if (assigned != null) {</span>
<span class="fc bfc" id="L603" title="All 2 branches covered.">                if (skipLimited) {</span>
                    // optimization: if there is a single stack domain and
                    // that domain is already in the assigned context; no
                    // need to combine
<span class="fc bfc" id="L607" title="All 4 branches covered.">                    if (context.length == 1 &amp;&amp; context[0] == assigned[0]) {</span>
<span class="fc" id="L608">                        return acc;</span>
                    }
                }
            }

<span class="fc" id="L613">            pd = combine(context, assigned);</span>
<span class="fc bfc" id="L614" title="All 6 branches covered.">            if (skipLimited &amp;&amp; !skipAssigned &amp;&amp; pd == assigned) {</span>
<span class="fc" id="L615">                return acc;</span>
<span class="pc bpc" id="L616" title="1 of 4 branches missed.">            } else if (skipAssigned &amp;&amp; pd == context) {</span>
<span class="fc" id="L617">                calculateFields(acc, parent, permissions);</span>
<span class="fc" id="L618">                return this;</span>
            }
        }

        // Reuse existing ACC
<span class="fc" id="L623">        this.context = pd;</span>
<span class="fc" id="L624">        this.combiner = combiner;</span>
<span class="fc" id="L625">        this.isPrivileged = false;</span>

<span class="fc" id="L627">        calculateFields(acc, parent, permissions);</span>
<span class="fc" id="L628">        return this;</span>
    }


    /*
     * Combine the current (stack) and assigned domains.
     */
    private static ProtectionDomain[] combine(ProtectionDomain[]current,
        ProtectionDomain[] assigned) {

        // current could be null if only system code is on the stack;
        // in that case, ignore the stack context
<span class="fc bfc" id="L640" title="All 2 branches covered.">        boolean skipStack = (current == null);</span>

        // assigned could be null if only system code was involved;
        // in that case, ignore the assigned context
<span class="fc bfc" id="L644" title="All 2 branches covered.">        boolean skipAssigned = (assigned == null);</span>

<span class="fc bfc" id="L646" title="All 2 branches covered.">        int slen = (skipStack) ? 0 : current.length;</span>

        // optimization: if there is no assigned context and the stack length
        // is less then or equal to two; there is no reason to compress the
        // stack context, it already is
<span class="fc bfc" id="L651" title="All 4 branches covered.">        if (skipAssigned &amp;&amp; slen &lt;= 2) {</span>
<span class="fc" id="L652">            return current;</span>
        }

<span class="fc bfc" id="L655" title="All 2 branches covered.">        int n = (skipAssigned) ? 0 : assigned.length;</span>

        // now we combine both of them, and create a new context
<span class="fc" id="L658">        ProtectionDomain pd[] = new ProtectionDomain[slen + n];</span>

        // first copy in the assigned context domains, no need to compress
<span class="fc bfc" id="L661" title="All 2 branches covered.">        if (!skipAssigned) {</span>
<span class="fc" id="L662">            System.arraycopy(assigned, 0, pd, 0, n);</span>
        }

        // now add the stack context domains, discarding nulls and duplicates
    outer:
<span class="fc bfc" id="L667" title="All 2 branches covered.">        for (int i = 0; i &lt; slen; i++) {</span>
<span class="fc" id="L668">            ProtectionDomain sd = current[i];</span>
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">            if (sd != null) {</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">                for (int j = 0; j &lt; n; j++) {</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">                    if (sd == pd[j]) {</span>
<span class="fc" id="L672">                        continue outer;</span>
                    }
                }
<span class="fc" id="L675">                pd[n++] = sd;</span>
            }
        }

        // if length isn't equal, we need to shorten the array
<span class="fc bfc" id="L680" title="All 2 branches covered.">        if (n != pd.length) {</span>
            // optimization: if we didn't really combine anything
<span class="pc bpc" id="L682" title="1 of 4 branches missed.">            if (!skipAssigned &amp;&amp; n == assigned.length) {</span>
<span class="fc" id="L683">                return assigned;</span>
<span class="pc bpc" id="L684" title="3 of 4 branches missed.">            } else if (skipAssigned &amp;&amp; n == slen) {</span>
<span class="nc" id="L685">                return current;</span>
            }
<span class="fc" id="L687">            ProtectionDomain tmp[] = new ProtectionDomain[n];</span>
<span class="fc" id="L688">            System.arraycopy(pd, 0, tmp, 0, n);</span>
<span class="fc" id="L689">            pd = tmp;</span>
        }

<span class="fc" id="L692">        return pd;</span>
    }


    /*
     * Calculate the additional domains that could potentially be reached via
     * limited privilege scope. Mark the context as being subject to limited
     * privilege scope unless the reachable domains (if any) are already
     * contained in this domain context (in which case any limited
     * privilege scope checking would be redundant).
     */
    private void calculateFields(AccessControlContext assigned,
        AccessControlContext parent, Permission[] permissions)
    {
<span class="fc" id="L706">        ProtectionDomain[] parentLimit = null;</span>
<span class="fc" id="L707">        ProtectionDomain[] assignedLimit = null;</span>
        ProtectionDomain[] newLimit;

<span class="fc bfc" id="L710" title="All 2 branches covered.">        parentLimit = (parent != null)? parent.limitedContext: null;</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">        assignedLimit = (assigned != null)? assigned.limitedContext: null;</span>
<span class="fc" id="L712">        newLimit = combine(parentLimit, assignedLimit);</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">        if (newLimit != null) {</span>
<span class="pc bpc" id="L714" title="1 of 4 branches missed.">            if (context == null || !containsAllPDs(newLimit, context)) {</span>
<span class="fc" id="L715">                this.limitedContext = newLimit;</span>
<span class="fc" id="L716">                this.permissions = permissions;</span>
<span class="fc" id="L717">                this.parent = parent;</span>
<span class="fc" id="L718">                this.isLimited = true;</span>
            }
        }
<span class="fc" id="L721">    }</span>


    /**
     * Checks two AccessControlContext objects for equality.
     * Checks that &lt;i&gt;obj&lt;/i&gt; is
     * an AccessControlContext and has the same set of ProtectionDomains
     * as this context.
     * &lt;P&gt;
     * @param obj the object we are testing for equality with this object.
     * @return true if &lt;i&gt;obj&lt;/i&gt; is an AccessControlContext, and has the
     * same set of ProtectionDomains as this context, false otherwise.
     */
    public boolean equals(Object obj) {
<span class="fc bfc" id="L735" title="All 2 branches covered.">        if (obj == this)</span>
<span class="fc" id="L736">            return true;</span>

<span class="fc bfc" id="L738" title="All 2 branches covered.">        if (! (obj instanceof AccessControlContext))</span>
<span class="fc" id="L739">            return false;</span>

<span class="fc" id="L741">        AccessControlContext that = (AccessControlContext) obj;</span>

<span class="fc bfc" id="L743" title="All 2 branches covered.">        if (!equalContext(that))</span>
<span class="fc" id="L744">            return false;</span>

<span class="pc bpc" id="L746" title="1 of 2 branches missed.">        if (!equalLimitedContext(that))</span>
<span class="nc" id="L747">            return false;</span>

<span class="fc" id="L749">        return true;</span>
    }

    /*
     * Compare for equality based on state that is free of limited
     * privilege complications.
     */
    private boolean equalContext(AccessControlContext that) {
<span class="fc bfc" id="L757" title="All 2 branches covered.">        if (!equalPDs(this.context, that.context))</span>
<span class="fc" id="L758">            return false;</span>

<span class="pc bpc" id="L760" title="2 of 4 branches missed.">        if (this.combiner == null &amp;&amp; that.combiner != null)</span>
<span class="nc" id="L761">            return false;</span>

<span class="pc bpc" id="L763" title="3 of 4 branches missed.">        if (this.combiner != null &amp;&amp; !this.combiner.equals(that.combiner))</span>
<span class="nc" id="L764">            return false;</span>

<span class="fc" id="L766">        return true;</span>
    }

    private boolean equalPDs(ProtectionDomain[] a, ProtectionDomain[] b) {
<span class="fc bfc" id="L770" title="All 2 branches covered.">        if (a == null) {</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">            return (b == null);</span>
        }

<span class="fc bfc" id="L774" title="All 2 branches covered.">        if (b == null)</span>
<span class="fc" id="L775">            return false;</span>

<span class="fc bfc" id="L777" title="All 4 branches covered.">        if (!(containsAllPDs(a, b) &amp;&amp; containsAllPDs(b, a)))</span>
<span class="fc" id="L778">            return false;</span>

<span class="fc" id="L780">        return true;</span>
    }

    /*
     * Compare for equality based on state that is captured during a
     * call to AccessController.getContext() when a limited privilege
     * scope is in effect.
     */
    private boolean equalLimitedContext(AccessControlContext that) {
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">        if (that == null)</span>
<span class="nc" id="L790">            return false;</span>

        /*
         * If neither instance has limited privilege scope then we're done.
         */
<span class="pc bpc" id="L795" title="2 of 4 branches missed.">        if (!this.isLimited &amp;&amp; !that.isLimited)</span>
<span class="fc" id="L796">            return true;</span>

        /*
         * If only one instance has limited privilege scope then we're done.
         */
<span class="nc bnc" id="L801" title="All 4 branches missed.">         if (!(this.isLimited &amp;&amp; that.isLimited))</span>
<span class="nc" id="L802">             return false;</span>

        /*
         * Wrapped instances should never escape outside the implementation
         * this class and AccessController so this will probably never happen
         * but it only makes any sense to compare if they both have the same
         * isWrapped state.
         */
<span class="nc bnc" id="L810" title="All 8 branches missed.">        if ((this.isWrapped &amp;&amp; !that.isWrapped) ||</span>
            (!this.isWrapped &amp;&amp; that.isWrapped)) {
<span class="nc" id="L812">            return false;</span>
        }

<span class="nc bnc" id="L815" title="All 4 branches missed.">        if (this.permissions == null &amp;&amp; that.permissions != null)</span>
<span class="nc" id="L816">            return false;</span>

<span class="nc bnc" id="L818" title="All 4 branches missed.">        if (this.permissions != null &amp;&amp; that.permissions == null)</span>
<span class="nc" id="L819">            return false;</span>

<span class="nc bnc" id="L821" title="All 4 branches missed.">        if (!(this.containsAllLimits(that) &amp;&amp; that.containsAllLimits(this)))</span>
<span class="nc" id="L822">            return false;</span>

        /*
         * Skip through any wrapped contexts.
         */
<span class="nc" id="L827">        AccessControlContext thisNextPC = getNextPC(this);</span>
<span class="nc" id="L828">        AccessControlContext thatNextPC = getNextPC(that);</span>

        /*
         * The protection domains and combiner of a privilegedContext are
         * not relevant because they have already been included in the context
         * of this instance by optimize() so we only care about any limited
         * privilege state they may have.
         */
<span class="nc bnc" id="L836" title="All 6 branches missed.">        if (thisNextPC == null &amp;&amp; thatNextPC != null &amp;&amp; thatNextPC.isLimited)</span>
<span class="nc" id="L837">            return false;</span>

<span class="nc bnc" id="L839" title="All 4 branches missed.">        if (thisNextPC != null &amp;&amp; !thisNextPC.equalLimitedContext(thatNextPC))</span>
<span class="nc" id="L840">            return false;</span>

<span class="nc bnc" id="L842" title="All 4 branches missed.">        if (this.parent == null &amp;&amp; that.parent != null)</span>
<span class="nc" id="L843">            return false;</span>

<span class="nc bnc" id="L845" title="All 4 branches missed.">        if (this.parent != null &amp;&amp; !this.parent.equals(that.parent))</span>
<span class="nc" id="L846">            return false;</span>

<span class="nc" id="L848">        return true;</span>
    }

    /*
     * Follow the privilegedContext link making our best effort to skip
     * through any wrapper contexts.
     */
    private static AccessControlContext getNextPC(AccessControlContext acc) {
<span class="nc bnc" id="L856" title="All 4 branches missed.">        while (acc != null &amp;&amp; acc.privilegedContext != null) {</span>
<span class="nc" id="L857">            acc = acc.privilegedContext;</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">            if (!acc.isWrapped)</span>
<span class="nc" id="L859">                return acc;</span>
        }
<span class="nc" id="L861">        return null;</span>
    }

    private static boolean containsAllPDs(ProtectionDomain[] thisContext,
        ProtectionDomain[] thatContext) {
<span class="fc" id="L866">        boolean match = false;</span>

        //
        // ProtectionDomains within an ACC currently cannot be null
        // and this is enforced by the constructor and the various
        // optimize methods. However, historically this logic made attempts
        // to support the notion of a null PD and therefore this logic continues
        // to support that notion.
        ProtectionDomain thisPd;
<span class="fc bfc" id="L875" title="All 2 branches covered.">        for (int i = 0; i &lt; thisContext.length; i++) {</span>
<span class="fc" id="L876">            match = false;</span>
<span class="pc bpc" id="L877" title="1 of 2 branches missed.">            if ((thisPd = thisContext[i]) == null) {</span>
<span class="nc bnc" id="L878" title="All 4 branches missed.">                for (int j = 0; (j &lt; thatContext.length) &amp;&amp; !match; j++) {</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">                    match = (thatContext[j] == null);</span>
                }
            } else {
<span class="fc" id="L882">                Class&lt;?&gt; thisPdClass = thisPd.getClass();</span>
                ProtectionDomain thatPd;
<span class="fc bfc" id="L884" title="All 4 branches covered.">                for (int j = 0; (j &lt; thatContext.length) &amp;&amp; !match; j++) {</span>
<span class="fc" id="L885">                    thatPd = thatContext[j];</span>

                    // Class check required to avoid PD exposure (4285406)
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">                    match = (thatPd != null &amp;&amp;</span>
<span class="pc bpc" id="L889" title="1 of 4 branches missed.">                        thisPdClass == thatPd.getClass() &amp;&amp; thisPd.equals(thatPd));</span>
                }
            }
<span class="fc bfc" id="L892" title="All 2 branches covered.">            if (!match) return false;</span>
        }
<span class="fc" id="L894">        return match;</span>
    }

    private boolean containsAllLimits(AccessControlContext that) {
<span class="nc" id="L898">        boolean match = false;</span>
        Permission thisPerm;

<span class="nc bnc" id="L901" title="All 4 branches missed.">        if (this.permissions == null &amp;&amp; that.permissions == null)</span>
<span class="nc" id="L902">            return true;</span>

<span class="nc bnc" id="L904" title="All 2 branches missed.">        for (int i = 0; i &lt; this.permissions.length; i++) {</span>
<span class="nc" id="L905">            Permission limit = this.permissions[i];</span>
<span class="nc" id="L906">            Class &lt;?&gt; limitClass = limit.getClass();</span>
<span class="nc" id="L907">            match = false;</span>
<span class="nc bnc" id="L908" title="All 4 branches missed.">            for (int j = 0; (j &lt; that.permissions.length) &amp;&amp; !match; j++) {</span>
<span class="nc" id="L909">                Permission perm = that.permissions[j];</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">                match = (limitClass.equals(perm.getClass()) &amp;&amp;</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">                    limit.equals(perm));</span>
            }
<span class="nc bnc" id="L913" title="All 2 branches missed.">            if (!match) return false;</span>
        }
<span class="nc" id="L915">        return match;</span>
    }


    /**
     * Returns the hash code value for this context. The hash code
     * is computed by exclusive or-ing the hash code of all the protection
     * domains in the context together.
     *
     * @return a hash code value for this context.
     */

    public int hashCode() {
<span class="fc" id="L928">        int hashCode = 0;</span>

<span class="fc bfc" id="L930" title="All 2 branches covered.">        if (context == null)</span>
<span class="fc" id="L931">            return hashCode;</span>

<span class="fc bfc" id="L933" title="All 2 branches covered.">        for (int i =0; i &lt; context.length; i++) {</span>
<span class="pc bpc" id="L934" title="1 of 2 branches missed.">            if (context[i] != null)</span>
<span class="fc" id="L935">                hashCode ^= context[i].hashCode();</span>
        }

<span class="fc" id="L938">        return hashCode;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>