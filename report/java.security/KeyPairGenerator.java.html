<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KeyPairGenerator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">KeyPairGenerator.java</span></div><h1>KeyPairGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.util.*;

import java.security.spec.AlgorithmParameterSpec;

import java.security.Provider.Service;

import sun.security.jca.*;
import sun.security.jca.GetInstance.Instance;

/**
 * The KeyPairGenerator class is used to generate pairs of
 * public and private keys. Key pair generators are constructed using the
 * {@code getInstance} factory methods (static methods that
 * return instances of a given class).
 *
 * &lt;p&gt;A Key pair generator for a particular algorithm creates a public/private
 * key pair that can be used with this algorithm. It also associates
 * algorithm-specific parameters with each of the generated keys.
 *
 * &lt;p&gt;There are two ways to generate a key pair: in an algorithm-independent
 * manner, and in an algorithm-specific manner.
 * The only difference between the two is the initialization of the object:
 *
 * &lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;Algorithm-Independent Initialization&lt;/b&gt;
 * &lt;p&gt;All key pair generators share the concepts of a keysize and a
 * source of randomness. The keysize is interpreted differently for different
 * algorithms (e.g., in the case of the &lt;i&gt;DSA&lt;/i&gt; algorithm, the keysize
 * corresponds to the length of the modulus).
 * There is an
 * {@link #initialize(int, java.security.SecureRandom) initialize}
 * method in this KeyPairGenerator class that takes these two universally
 * shared types of arguments. There is also one that takes just a
 * {@code keysize} argument, and uses the {@code SecureRandom}
 * implementation of the highest-priority installed provider as the source
 * of randomness. (If none of the installed providers supply an implementation
 * of {@code SecureRandom}, a system-provided source of randomness is
 * used.)
 *
 * &lt;p&gt;Since no other parameters are specified when you call the above
 * algorithm-independent {@code initialize} methods, it is up to the
 * provider what to do about the algorithm-specific parameters (if any) to be
 * associated with each of the keys.
 *
 * &lt;p&gt;If the algorithm is the &lt;i&gt;DSA&lt;/i&gt; algorithm, and the keysize (modulus
 * size) is 512, 768, or 1024, then the &lt;i&gt;Sun&lt;/i&gt; provider uses a set of
 * precomputed values for the {@code p}, {@code q}, and
 * {@code g} parameters. If the modulus size is not one of the above
 * values, the &lt;i&gt;Sun&lt;/i&gt; provider creates a new set of parameters. Other
 * providers might have precomputed parameter sets for more than just the
 * three modulus sizes mentioned above. Still others might not have a list of
 * precomputed parameters at all and instead always create new parameter sets.
 *
 * &lt;li&gt;&lt;b&gt;Algorithm-Specific Initialization&lt;/b&gt;
 * &lt;p&gt;For situations where a set of algorithm-specific parameters already
 * exists (e.g., so-called &lt;i&gt;community parameters&lt;/i&gt; in DSA), there are two
 * {@link #initialize(java.security.spec.AlgorithmParameterSpec)
 * initialize} methods that have an {@code AlgorithmParameterSpec}
 * argument. One also has a {@code SecureRandom} argument, while the
 * the other uses the {@code SecureRandom}
 * implementation of the highest-priority installed provider as the source
 * of randomness. (If none of the installed providers supply an implementation
 * of {@code SecureRandom}, a system-provided source of randomness is
 * used.)
 * &lt;/ul&gt;
 *
 * &lt;p&gt;In case the client does not explicitly initialize the KeyPairGenerator
 * (via a call to an {@code initialize} method), each provider must
 * supply (and document) a default initialization.
 * For example, the &lt;i&gt;Sun&lt;/i&gt; provider uses a default modulus size (keysize)
 * of 1024 bits.
 *
 * &lt;p&gt;Note that this class is abstract and extends from
 * {@code KeyPairGeneratorSpi} for historical reasons.
 * Application developers should only take notice of the methods defined in
 * this {@code KeyPairGenerator} class; all the methods in
 * the superclass are intended for cryptographic service providers who wish to
 * supply their own implementations of key pair generators.
 *
 * &lt;p&gt; Every implementation of the Java platform is required to support the
 * following standard {@code KeyPairGenerator} algorithms and keysizes in
 * parentheses:
 * &lt;ul&gt;
 * &lt;li&gt;{@code DiffieHellman} (1024)&lt;/li&gt;
 * &lt;li&gt;{@code DSA} (1024)&lt;/li&gt;
 * &lt;li&gt;{@code RSA} (1024, 2048)&lt;/li&gt;
 * &lt;/ul&gt;
 * These algorithms are described in the &lt;a href=
 * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt;
 * KeyPairGenerator section&lt;/a&gt; of the
 * Java Cryptography Architecture Standard Algorithm Name Documentation.
 * Consult the release documentation for your implementation to see if any
 * other algorithms are supported.
 *
 * @author Benjamin Renaud
 *
 * @see java.security.spec.AlgorithmParameterSpec
 */

public abstract class KeyPairGenerator extends KeyPairGeneratorSpi {

    private final String algorithm;

    // The provider
    Provider provider;

    /**
     * Creates a KeyPairGenerator object for the specified algorithm.
     *
     * @param algorithm the standard string name of the algorithm.
     * See the KeyPairGenerator section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     */
<span class="fc" id="L143">    protected KeyPairGenerator(String algorithm) {</span>
<span class="fc" id="L144">        this.algorithm = algorithm;</span>
<span class="fc" id="L145">    }</span>

    /**
     * Returns the standard name of the algorithm for this key pair generator.
     * See the KeyPairGenerator section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @return the standard string name of the algorithm.
     */
    public String getAlgorithm() {
<span class="nc" id="L157">        return this.algorithm;</span>
    }

    private static KeyPairGenerator getInstance(Instance instance,
            String algorithm) {
        KeyPairGenerator kpg;
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (instance.impl instanceof KeyPairGenerator) {</span>
<span class="fc" id="L164">            kpg = (KeyPairGenerator)instance.impl;</span>
        } else {
<span class="fc" id="L166">            KeyPairGeneratorSpi spi = (KeyPairGeneratorSpi)instance.impl;</span>
<span class="fc" id="L167">            kpg = new Delegate(spi, algorithm);</span>
        }
<span class="fc" id="L169">        kpg.provider = instance.provider;</span>
<span class="fc" id="L170">        return kpg;</span>
    }

    /**
     * Returns a KeyPairGenerator object that generates public/private
     * key pairs for the specified algorithm.
     *
     * &lt;p&gt; This method traverses the list of registered security Providers,
     * starting with the most preferred Provider.
     * A new KeyPairGenerator object encapsulating the
     * KeyPairGeneratorSpi implementation from the first
     * Provider that supports the specified algorithm is returned.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param algorithm the standard string name of the algorithm.
     * See the KeyPairGenerator section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @return the new KeyPairGenerator object.
     *
     * @exception NoSuchAlgorithmException if no Provider supports a
     *          KeyPairGeneratorSpi implementation for the
     *          specified algorithm.
     *
     * @see Provider
     */
    public static KeyPairGenerator getInstance(String algorithm)
            throws NoSuchAlgorithmException {
<span class="fc" id="L202">        List&lt;Service&gt; list =</span>
<span class="fc" id="L203">                GetInstance.getServices(&quot;KeyPairGenerator&quot;, algorithm);</span>
<span class="fc" id="L204">        Iterator&lt;Service&gt; t = list.iterator();</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        if (t.hasNext() == false) {</span>
<span class="nc" id="L206">            throw new NoSuchAlgorithmException</span>
                (algorithm + &quot; KeyPairGenerator not available&quot;);
        }
        // find a working Spi or KeyPairGenerator subclass
<span class="fc" id="L210">        NoSuchAlgorithmException failure = null;</span>
        do {
<span class="fc" id="L212">            Service s = t.next();</span>
            try {
<span class="fc" id="L214">                Instance instance =</span>
<span class="fc" id="L215">                    GetInstance.getInstance(s, KeyPairGeneratorSpi.class);</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">                if (instance.impl instanceof KeyPairGenerator) {</span>
<span class="nc" id="L217">                    return getInstance(instance, algorithm);</span>
                } else {
<span class="fc" id="L219">                    return new Delegate(instance, t, algorithm);</span>
                }
<span class="nc" id="L221">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">                if (failure == null) {</span>
<span class="nc" id="L223">                    failure = e;</span>
                }
            }
<span class="nc bnc" id="L226" title="All 2 branches missed.">        } while (t.hasNext());</span>
<span class="nc" id="L227">        throw failure;</span>
    }

    /**
     * Returns a KeyPairGenerator object that generates public/private
     * key pairs for the specified algorithm.
     *
     * &lt;p&gt; A new KeyPairGenerator object encapsulating the
     * KeyPairGeneratorSpi implementation from the specified provider
     * is returned.  The specified provider must be registered
     * in the security provider list.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param algorithm the standard string name of the algorithm.
     * See the KeyPairGenerator section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @param provider the string name of the provider.
     *
     * @return the new KeyPairGenerator object.
     *
     * @exception NoSuchAlgorithmException if a KeyPairGeneratorSpi
     *          implementation for the specified algorithm is not
     *          available from the specified provider.
     *
     * @exception NoSuchProviderException if the specified provider is not
     *          registered in the security provider list.
     *
     * @exception IllegalArgumentException if the provider name is null
     *          or empty.
     *
     * @see Provider
     */
    public static KeyPairGenerator getInstance(String algorithm,
            String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
<span class="fc" id="L267">        Instance instance = GetInstance.getInstance(&quot;KeyPairGenerator&quot;,</span>
                KeyPairGeneratorSpi.class, algorithm, provider);
<span class="fc" id="L269">        return getInstance(instance, algorithm);</span>
    }

    /**
     * Returns a KeyPairGenerator object that generates public/private
     * key pairs for the specified algorithm.
     *
     * &lt;p&gt; A new KeyPairGenerator object encapsulating the
     * KeyPairGeneratorSpi implementation from the specified Provider
     * object is returned.  Note that the specified Provider object
     * does not have to be registered in the provider list.
     *
     * @param algorithm the standard string name of the algorithm.
     * See the KeyPairGenerator section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyPairGenerator&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @param provider the provider.
     *
     * @return the new KeyPairGenerator object.
     *
     * @exception NoSuchAlgorithmException if a KeyPairGeneratorSpi
     *          implementation for the specified algorithm is not available
     *          from the specified Provider object.
     *
     * @exception IllegalArgumentException if the specified provider is null.
     *
     * @see Provider
     *
     * @since 1.4
     */
    public static KeyPairGenerator getInstance(String algorithm,
            Provider provider) throws NoSuchAlgorithmException {
<span class="fc" id="L303">        Instance instance = GetInstance.getInstance(&quot;KeyPairGenerator&quot;,</span>
                KeyPairGeneratorSpi.class, algorithm, provider);
<span class="fc" id="L305">        return getInstance(instance, algorithm);</span>
    }

    /**
     * Returns the provider of this key pair generator object.
     *
     * @return the provider of this key pair generator object
     */
    public final Provider getProvider() {
<span class="fc" id="L314">        disableFailover();</span>
<span class="fc" id="L315">        return this.provider;</span>
    }

    void disableFailover() {
        // empty, overridden in Delegate
<span class="nc" id="L320">    }</span>

    /**
     * Initializes the key pair generator for a certain keysize using
     * a default parameter set and the {@code SecureRandom}
     * implementation of the highest-priority installed provider as the source
     * of randomness.
     * (If none of the installed providers supply an implementation of
     * {@code SecureRandom}, a system-provided source of randomness is
     * used.)
     *
     * @param keysize the keysize. This is an
     * algorithm-specific metric, such as modulus length, specified in
     * number of bits.
     *
     * @exception InvalidParameterException if the {@code keysize} is not
     * supported by this KeyPairGenerator object.
     */
    public void initialize(int keysize) {
<span class="fc" id="L339">        initialize(keysize, JCAUtil.getSecureRandom());</span>
<span class="fc" id="L340">    }</span>

    /**
     * Initializes the key pair generator for a certain keysize with
     * the given source of randomness (and a default parameter set).
     *
     * @param keysize the keysize. This is an
     * algorithm-specific metric, such as modulus length, specified in
     * number of bits.
     * @param random the source of randomness.
     *
     * @exception InvalidParameterException if the {@code keysize} is not
     * supported by this KeyPairGenerator object.
     *
     * @since 1.2
     */
    public void initialize(int keysize, SecureRandom random) {
        // This does nothing, because either
        // 1. the implementation object returned by getInstance() is an
        //    instance of KeyPairGenerator which has its own
        //    initialize(keysize, random) method, so the application would
        //    be calling that method directly, or
        // 2. the implementation returned by getInstance() is an instance
        //    of Delegate, in which case initialize(keysize, random) is
        //    overridden to call the corresponding SPI method.
        // (This is a special case, because the API and SPI method have the
        // same name.)
<span class="nc" id="L367">    }</span>

    /**
     * Initializes the key pair generator using the specified parameter
     * set and the {@code SecureRandom}
     * implementation of the highest-priority installed provider as the source
     * of randomness.
     * (If none of the installed providers supply an implementation of
     * {@code SecureRandom}, a system-provided source of randomness is
     * used.).
     *
     * &lt;p&gt;This concrete method has been added to this previously-defined
     * abstract class.
     * This method calls the KeyPairGeneratorSpi
     * {@link KeyPairGeneratorSpi#initialize(
     * java.security.spec.AlgorithmParameterSpec,
     * java.security.SecureRandom) initialize} method,
     * passing it {@code params} and a source of randomness (obtained
     * from the highest-priority installed provider or system-provided if none
     * of the installed providers supply one).
     * That {@code initialize} method always throws an
     * UnsupportedOperationException if it is not overridden by the provider.
     *
     * @param params the parameter set used to generate the keys.
     *
     * @exception InvalidAlgorithmParameterException if the given parameters
     * are inappropriate for this key pair generator.
     *
     * @since 1.2
     */
    public void initialize(AlgorithmParameterSpec params)
            throws InvalidAlgorithmParameterException {
<span class="fc" id="L399">        initialize(params, JCAUtil.getSecureRandom());</span>
<span class="fc" id="L400">    }</span>

    /**
     * Initializes the key pair generator with the given parameter
     * set and source of randomness.
     *
     * &lt;p&gt;This concrete method has been added to this previously-defined
     * abstract class.
     * This method calls the KeyPairGeneratorSpi {@link
     * KeyPairGeneratorSpi#initialize(
     * java.security.spec.AlgorithmParameterSpec,
     * java.security.SecureRandom) initialize} method,
     * passing it {@code params} and {@code random}.
     * That {@code initialize}
     * method always throws an
     * UnsupportedOperationException if it is not overridden by the provider.
     *
     * @param params the parameter set used to generate the keys.
     * @param random the source of randomness.
     *
     * @exception InvalidAlgorithmParameterException if the given parameters
     * are inappropriate for this key pair generator.
     *
     * @since 1.2
     */
    public void initialize(AlgorithmParameterSpec params,
                           SecureRandom random)
        throws InvalidAlgorithmParameterException
    {
        // This does nothing, because either
        // 1. the implementation object returned by getInstance() is an
        //    instance of KeyPairGenerator which has its own
        //    initialize(params, random) method, so the application would
        //    be calling that method directly, or
        // 2. the implementation returned by getInstance() is an instance
        //    of Delegate, in which case initialize(params, random) is
        //    overridden to call the corresponding SPI method.
        // (This is a special case, because the API and SPI method have the
        // same name.)
<span class="nc" id="L439">    }</span>

    /**
     * Generates a key pair.
     *
     * &lt;p&gt;If this KeyPairGenerator has not been initialized explicitly,
     * provider-specific defaults will be used for the size and other
     * (algorithm-specific) values of the generated keys.
     *
     * &lt;p&gt;This will generate a new key pair every time it is called.
     *
     * &lt;p&gt;This method is functionally equivalent to
     * {@link #generateKeyPair() generateKeyPair}.
     *
     * @return the generated key pair
     *
     * @since 1.2
     */
    public final KeyPair genKeyPair() {
<span class="fc" id="L458">        return generateKeyPair();</span>
    }

    /**
     * Generates a key pair.
     *
     * &lt;p&gt;If this KeyPairGenerator has not been initialized explicitly,
     * provider-specific defaults will be used for the size and other
     * (algorithm-specific) values of the generated keys.
     *
     * &lt;p&gt;This will generate a new key pair every time it is called.
     *
     * &lt;p&gt;This method is functionally equivalent to
     * {@link #genKeyPair() genKeyPair}.
     *
     * @return the generated key pair
     */
    public KeyPair generateKeyPair() {
        // This does nothing (except returning null), because either:
        //
        // 1. the implementation object returned by getInstance() is an
        //    instance of KeyPairGenerator which has its own implementation
        //    of generateKeyPair (overriding this one), so the application
        //    would be calling that method directly, or
        //
        // 2. the implementation returned by getInstance() is an instance
        //    of Delegate, in which case generateKeyPair is
        //    overridden to invoke the corresponding SPI method.
        //
        // (This is a special case, because in JDK 1.1.x the generateKeyPair
        // method was used both as an API and a SPI method.)
<span class="nc" id="L489">        return null;</span>
    }


    /*
     * The following class allows providers to extend from KeyPairGeneratorSpi
     * rather than from KeyPairGenerator. It represents a KeyPairGenerator
     * with an encapsulated, provider-supplied SPI object (of type
     * KeyPairGeneratorSpi).
     * If the provider implementation is an instance of KeyPairGeneratorSpi,
     * the getInstance() methods above return an instance of this class, with
     * the SPI object encapsulated.
     *
     * Note: All SPI methods from the original KeyPairGenerator class have been
     * moved up the hierarchy into a new class (KeyPairGeneratorSpi), which has
     * been interposed in the hierarchy between the API (KeyPairGenerator)
     * and its original parent (Object).
     */

    //
    // error failover notes:
    //
    //  . we failover if the implementation throws an error during init
    //    by retrying the init on other providers
    //
    //  . we also failover if the init succeeded but the subsequent call
    //    to generateKeyPair() fails. In order for this to work, we need
    //    to remember the parameters to the last successful call to init
    //    and initialize() the next spi using them.
    //
    //  . although not specified, KeyPairGenerators could be thread safe,
    //    so we make sure we do not interfere with that
    //
    //  . failover is not available, if:
    //    . getInstance(algorithm, provider) was used
    //    . a provider extends KeyPairGenerator rather than
    //      KeyPairGeneratorSpi (JDK 1.1 style)
    //    . once getProvider() is called
    //

    private static final class Delegate extends KeyPairGenerator {

        // The provider implementation (delegate)
        private volatile KeyPairGeneratorSpi spi;

<span class="fc" id="L534">        private final Object lock = new Object();</span>

        private Iterator&lt;Service&gt; serviceIterator;

        private final static int I_NONE   = 1;
        private final static int I_SIZE   = 2;
        private final static int I_PARAMS = 3;

        private int initType;
        private int initKeySize;
        private AlgorithmParameterSpec initParams;
        private SecureRandom initRandom;

        // constructor
        Delegate(KeyPairGeneratorSpi spi, String algorithm) {
<span class="fc" id="L549">            super(algorithm);</span>
<span class="fc" id="L550">            this.spi = spi;</span>
<span class="fc" id="L551">        }</span>

        Delegate(Instance instance, Iterator&lt;Service&gt; serviceIterator,
                String algorithm) {
<span class="fc" id="L555">            super(algorithm);</span>
<span class="fc" id="L556">            spi = (KeyPairGeneratorSpi)instance.impl;</span>
<span class="fc" id="L557">            provider = instance.provider;</span>
<span class="fc" id="L558">            this.serviceIterator = serviceIterator;</span>
<span class="fc" id="L559">            initType = I_NONE;</span>
<span class="fc" id="L560">        }</span>

        /**
         * Update the active spi of this class and return the next
         * implementation for failover. If no more implemenations are
         * available, this method returns null. However, the active spi of
         * this class is never set to null.
         */
        private KeyPairGeneratorSpi nextSpi(KeyPairGeneratorSpi oldSpi,
                boolean reinit) {
<span class="fc" id="L570">            synchronized (lock) {</span>
                // somebody else did a failover concurrently
                // try that spi now
<span class="pc bpc" id="L573" title="2 of 4 branches missed.">                if ((oldSpi != null) &amp;&amp; (oldSpi != spi)) {</span>
<span class="nc" id="L574">                    return spi;</span>
                }
<span class="pc bpc" id="L576" title="1 of 2 branches missed.">                if (serviceIterator == null) {</span>
<span class="nc" id="L577">                    return null;</span>
                }
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">                while (serviceIterator.hasNext()) {</span>
<span class="fc" id="L580">                    Service s = serviceIterator.next();</span>
                    try {
<span class="fc" id="L582">                        Object inst = s.newInstance(null);</span>
                        // ignore non-spis
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">                        if (inst instanceof KeyPairGeneratorSpi == false) {</span>
<span class="nc" id="L585">                            continue;</span>
                        }
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">                        if (inst instanceof KeyPairGenerator) {</span>
<span class="nc" id="L588">                            continue;</span>
                        }
<span class="fc" id="L590">                        KeyPairGeneratorSpi spi = (KeyPairGeneratorSpi)inst;</span>
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">                        if (reinit) {</span>
<span class="pc bpc" id="L592" title="1 of 2 branches missed.">                            if (initType == I_SIZE) {</span>
<span class="nc" id="L593">                                spi.initialize(initKeySize, initRandom);</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">                            } else if (initType == I_PARAMS) {</span>
<span class="fc" id="L595">                                spi.initialize(initParams, initRandom);</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                            } else if (initType != I_NONE) {</span>
<span class="nc" id="L597">                                throw new AssertionError</span>
                                    (&quot;KeyPairGenerator initType: &quot; + initType);
                            }
                        }
<span class="fc" id="L601">                        provider = s.getProvider();</span>
<span class="fc" id="L602">                        this.spi = spi;</span>
<span class="fc" id="L603">                        return spi;</span>
<span class="nc" id="L604">                    } catch (Exception e) {</span>
                        // ignore
                    }
<span class="nc" id="L607">                }</span>
<span class="nc" id="L608">                disableFailover();</span>
<span class="nc" id="L609">                return null;</span>
<span class="nc" id="L610">            }</span>
        }

        void disableFailover() {
<span class="fc" id="L614">            serviceIterator = null;</span>
<span class="fc" id="L615">            initType = 0;</span>
<span class="fc" id="L616">            initParams = null;</span>
<span class="fc" id="L617">            initRandom = null;</span>
<span class="fc" id="L618">        }</span>

        // engine method
        public void initialize(int keysize, SecureRandom random) {
<span class="fc bfc" id="L622" title="All 2 branches covered.">            if (serviceIterator == null) {</span>
<span class="fc" id="L623">                spi.initialize(keysize, random);</span>
<span class="fc" id="L624">                return;</span>
            }
<span class="fc" id="L626">            RuntimeException failure = null;</span>
<span class="fc" id="L627">            KeyPairGeneratorSpi mySpi = spi;</span>
            do {
                try {
<span class="fc" id="L630">                    mySpi.initialize(keysize, random);</span>
<span class="fc" id="L631">                    initType = I_SIZE;</span>
<span class="fc" id="L632">                    initKeySize = keysize;</span>
<span class="fc" id="L633">                    initParams = null;</span>
<span class="fc" id="L634">                    initRandom = random;</span>
<span class="fc" id="L635">                    return;</span>
<span class="nc" id="L636">                } catch (RuntimeException e) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">                    if (failure == null) {</span>
<span class="nc" id="L638">                        failure = e;</span>
                    }
<span class="nc" id="L640">                    mySpi = nextSpi(mySpi, false);</span>
                }
<span class="nc bnc" id="L642" title="All 2 branches missed.">            } while (mySpi != null);</span>
<span class="nc" id="L643">            throw failure;</span>
        }

        // engine method
        public void initialize(AlgorithmParameterSpec params,
                SecureRandom random) throws InvalidAlgorithmParameterException {
<span class="fc bfc" id="L649" title="All 2 branches covered.">            if (serviceIterator == null) {</span>
<span class="fc" id="L650">                spi.initialize(params, random);</span>
<span class="fc" id="L651">                return;</span>
            }
<span class="fc" id="L653">            Exception failure = null;</span>
<span class="fc" id="L654">            KeyPairGeneratorSpi mySpi = spi;</span>
            do {
                try {
<span class="fc" id="L657">                    mySpi.initialize(params, random);</span>
<span class="fc" id="L658">                    initType = I_PARAMS;</span>
<span class="fc" id="L659">                    initKeySize = 0;</span>
<span class="fc" id="L660">                    initParams = params;</span>
<span class="fc" id="L661">                    initRandom = random;</span>
<span class="fc" id="L662">                    return;</span>
<span class="nc" id="L663">                } catch (Exception e) {</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">                    if (failure == null) {</span>
<span class="nc" id="L665">                        failure = e;</span>
                    }
<span class="nc" id="L667">                    mySpi = nextSpi(mySpi, false);</span>
                }
<span class="nc bnc" id="L669" title="All 2 branches missed.">            } while (mySpi != null);</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            if (failure instanceof RuntimeException) {</span>
<span class="nc" id="L671">                throw (RuntimeException)failure;</span>
            }
            // must be an InvalidAlgorithmParameterException
<span class="nc" id="L674">            throw (InvalidAlgorithmParameterException)failure;</span>
        }

        // engine method
        public KeyPair generateKeyPair() {
<span class="fc bfc" id="L679" title="All 2 branches covered.">            if (serviceIterator == null) {</span>
<span class="fc" id="L680">                return spi.generateKeyPair();</span>
            }
<span class="fc" id="L682">            RuntimeException failure = null;</span>
<span class="fc" id="L683">            KeyPairGeneratorSpi mySpi = spi;</span>
            do {
                try {
<span class="fc" id="L686">                    return mySpi.generateKeyPair();</span>
<span class="fc" id="L687">                } catch (RuntimeException e) {</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">                    if (failure == null) {</span>
<span class="fc" id="L689">                        failure = e;</span>
                    }
<span class="fc" id="L691">                    mySpi = nextSpi(mySpi, true);</span>
                }
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">            } while (mySpi != null);</span>
<span class="nc" id="L694">            throw failure;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>