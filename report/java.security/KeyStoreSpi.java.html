<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>KeyStoreSpi.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">KeyStoreSpi.java</span></div><h1>KeyStoreSpi.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.io.*;
import java.util.*;

import java.security.KeyStore.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;

import javax.crypto.SecretKey;

import javax.security.auth.callback.*;

/**
 * This class defines the &lt;i&gt;Service Provider Interface&lt;/i&gt; (&lt;b&gt;SPI&lt;/b&gt;)
 * for the {@code KeyStore} class.
 * All the abstract methods in this class must be implemented by each
 * cryptographic service provider who wishes to supply the implementation
 * of a keystore for a particular keystore type.
 *
 * @author Jan Luehe
 *
 *
 * @see KeyStore
 *
 * @since 1.2
 */

<span class="fc" id="L54">public abstract class KeyStoreSpi {</span>

    /**
     * Returns the key associated with the given alias, using the given
     * password to recover it.  The key must have been associated with
     * the alias by a call to {@code setKeyEntry},
     * or by a call to {@code setEntry} with a
     * {@code PrivateKeyEntry} or {@code SecretKeyEntry}.
     *
     * @param alias the alias name
     * @param password the password for recovering the key
     *
     * @return the requested key, or null if the given alias does not exist
     * or does not identify a key-related entry.
     *
     * @exception NoSuchAlgorithmException if the algorithm for recovering the
     * key cannot be found
     * @exception UnrecoverableKeyException if the key cannot be recovered
     * (e.g., the given password is wrong).
     */
    public abstract Key engineGetKey(String alias, char[] password)
        throws NoSuchAlgorithmException, UnrecoverableKeyException;

    /**
     * Returns the certificate chain associated with the given alias.
     * The certificate chain must have been associated with the alias
     * by a call to {@code setKeyEntry},
     * or by a call to {@code setEntry} with a
     * {@code PrivateKeyEntry}.
     *
     * @param alias the alias name
     *
     * @return the certificate chain (ordered with the user's certificate first
     * and the root certificate authority last), or null if the given alias
     * does not exist or does not contain a certificate chain
     */
    public abstract Certificate[] engineGetCertificateChain(String alias);

    /**
     * Returns the certificate associated with the given alias.
     *
     * &lt;p&gt; If the given alias name identifies an entry
     * created by a call to {@code setCertificateEntry},
     * or created by a call to {@code setEntry} with a
     * {@code TrustedCertificateEntry},
     * then the trusted certificate contained in that entry is returned.
     *
     * &lt;p&gt; If the given alias name identifies an entry
     * created by a call to {@code setKeyEntry},
     * or created by a call to {@code setEntry} with a
     * {@code PrivateKeyEntry},
     * then the first element of the certificate chain in that entry
     * (if a chain exists) is returned.
     *
     * @param alias the alias name
     *
     * @return the certificate, or null if the given alias does not exist or
     * does not contain a certificate.
     */
    public abstract Certificate engineGetCertificate(String alias);

    /**
     * Returns the creation date of the entry identified by the given alias.
     *
     * @param alias the alias name
     *
     * @return the creation date of this entry, or null if the given alias does
     * not exist
     */
    public abstract Date engineGetCreationDate(String alias);

    /**
     * Assigns the given key to the given alias, protecting it with the given
     * password.
     *
     * &lt;p&gt;If the given key is of type {@code java.security.PrivateKey},
     * it must be accompanied by a certificate chain certifying the
     * corresponding public key.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key (and possibly
     * certificate chain).
     *
     * @param alias the alias name
     * @param key the key to be associated with the alias
     * @param password the password to protect the key
     * @param chain the certificate chain for the corresponding public
     * key (only required if the given key is of type
     * {@code java.security.PrivateKey}).
     *
     * @exception KeyStoreException if the given key cannot be protected, or
     * this operation fails for some other reason
     */
    public abstract void engineSetKeyEntry(String alias, Key key,
                                           char[] password,
                                           Certificate[] chain)
        throws KeyStoreException;

    /**
     * Assigns the given key (that has already been protected) to the given
     * alias.
     *
     * &lt;p&gt;If the protected key is of type
     * {@code java.security.PrivateKey},
     * it must be accompanied by a certificate chain certifying the
     * corresponding public key.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key (and possibly
     * certificate chain).
     *
     * @param alias the alias name
     * @param key the key (in protected format) to be associated with the alias
     * @param chain the certificate chain for the corresponding public
     * key (only useful if the protected key is of type
     * {@code java.security.PrivateKey}).
     *
     * @exception KeyStoreException if this operation fails.
     */
    public abstract void engineSetKeyEntry(String alias, byte[] key,
                                           Certificate[] chain)
        throws KeyStoreException;

    /**
     * Assigns the given certificate to the given alias.
     *
     * &lt;p&gt; If the given alias identifies an existing entry
     * created by a call to {@code setCertificateEntry},
     * or created by a call to {@code setEntry} with a
     * {@code TrustedCertificateEntry},
     * the trusted certificate in the existing entry
     * is overridden by the given certificate.
     *
     * @param alias the alias name
     * @param cert the certificate
     *
     * @exception KeyStoreException if the given alias already exists and does
     * not identify an entry containing a trusted certificate,
     * or this operation fails for some other reason.
     */
    public abstract void engineSetCertificateEntry(String alias,
                                                   Certificate cert)
        throws KeyStoreException;

    /**
     * Deletes the entry identified by the given alias from this keystore.
     *
     * @param alias the alias name
     *
     * @exception KeyStoreException if the entry cannot be removed.
     */
    public abstract void engineDeleteEntry(String alias)
        throws KeyStoreException;

    /**
     * Lists all the alias names of this keystore.
     *
     * @return enumeration of the alias names
     */
    public abstract Enumeration&lt;String&gt; engineAliases();

    /**
     * Checks if the given alias exists in this keystore.
     *
     * @param alias the alias name
     *
     * @return true if the alias exists, false otherwise
     */
    public abstract boolean engineContainsAlias(String alias);

    /**
     * Retrieves the number of entries in this keystore.
     *
     * @return the number of entries in this keystore
     */
    public abstract int engineSize();

    /**
     * Returns true if the entry identified by the given alias
     * was created by a call to {@code setKeyEntry},
     * or created by a call to {@code setEntry} with a
     * {@code PrivateKeyEntry} or a {@code SecretKeyEntry}.
     *
     * @param alias the alias for the keystore entry to be checked
     *
     * @return true if the entry identified by the given alias is a
     * key-related, false otherwise.
     */
    public abstract boolean engineIsKeyEntry(String alias);

    /**
     * Returns true if the entry identified by the given alias
     * was created by a call to {@code setCertificateEntry},
     * or created by a call to {@code setEntry} with a
     * {@code TrustedCertificateEntry}.
     *
     * @param alias the alias for the keystore entry to be checked
     *
     * @return true if the entry identified by the given alias contains a
     * trusted certificate, false otherwise.
     */
    public abstract boolean engineIsCertificateEntry(String alias);

    /**
     * Returns the (alias) name of the first keystore entry whose certificate
     * matches the given certificate.
     *
     * &lt;p&gt;This method attempts to match the given certificate with each
     * keystore entry. If the entry being considered was
     * created by a call to {@code setCertificateEntry},
     * or created by a call to {@code setEntry} with a
     * {@code TrustedCertificateEntry},
     * then the given certificate is compared to that entry's certificate.
     *
     * &lt;p&gt; If the entry being considered was
     * created by a call to {@code setKeyEntry},
     * or created by a call to {@code setEntry} with a
     * {@code PrivateKeyEntry},
     * then the given certificate is compared to the first
     * element of that entry's certificate chain.
     *
     * @param cert the certificate to match with.
     *
     * @return the alias name of the first entry with matching certificate,
     * or null if no such entry exists in this keystore.
     */
    public abstract String engineGetCertificateAlias(Certificate cert);

    /**
     * Stores this keystore to the given output stream, and protects its
     * integrity with the given password.
     *
     * @param stream the output stream to which this keystore is written.
     * @param password the password to generate the keystore integrity check
     *
     * @exception IOException if there was an I/O problem with data
     * @exception NoSuchAlgorithmException if the appropriate data integrity
     * algorithm could not be found
     * @exception CertificateException if any of the certificates included in
     * the keystore data could not be stored
     */
    public abstract void engineStore(OutputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException;

    /**
     * Stores this keystore using the given
     * {@code KeyStore.LoadStoreParmeter}.
     *
     * @param param the {@code KeyStore.LoadStoreParmeter}
     *          that specifies how to store the keystore,
     *          which may be {@code null}
     *
     * @exception IllegalArgumentException if the given
     *          {@code KeyStore.LoadStoreParmeter}
     *          input is not recognized
     * @exception IOException if there was an I/O problem with data
     * @exception NoSuchAlgorithmException if the appropriate data integrity
     *          algorithm could not be found
     * @exception CertificateException if any of the certificates included in
     *          the keystore data could not be stored
     *
     * @since 1.5
     */
    public void engineStore(KeyStore.LoadStoreParameter param)
                throws IOException, NoSuchAlgorithmException,
                CertificateException {
<span class="nc" id="L320">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Loads the keystore from the given input stream.
     *
     * &lt;p&gt;A password may be given to unlock the keystore
     * (e.g. the keystore resides on a hardware token device),
     * or to check the integrity of the keystore data.
     * If a password is not given for integrity checking,
     * then integrity checking is not performed.
     *
     * @param stream the input stream from which the keystore is loaded,
     * or {@code null}
     * @param password the password used to check the integrity of
     * the keystore, the password used to unlock the keystore,
     * or {@code null}
     *
     * @exception IOException if there is an I/O or format problem with the
     * keystore data, if a password is required but not given,
     * or if the given password was incorrect. If the error is due to a
     * wrong password, the {@link Throwable#getCause cause} of the
     * {@code IOException} should be an
     * {@code UnrecoverableKeyException}
     * @exception NoSuchAlgorithmException if the algorithm used to check
     * the integrity of the keystore cannot be found
     * @exception CertificateException if any of the certificates in the
     * keystore could not be loaded
     */
    public abstract void engineLoad(InputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException;

    /**
     * Loads the keystore using the given
     * {@code KeyStore.LoadStoreParameter}.
     *
     * &lt;p&gt; Note that if this KeyStore has already been loaded, it is
     * reinitialized and loaded again from the given parameter.
     *
     * @param param the {@code KeyStore.LoadStoreParameter}
     *          that specifies how to load the keystore,
     *          which may be {@code null}
     *
     * @exception IllegalArgumentException if the given
     *          {@code KeyStore.LoadStoreParameter}
     *          input is not recognized
     * @exception IOException if there is an I/O or format problem with the
     *          keystore data. If the error is due to an incorrect
     *         {@code ProtectionParameter} (e.g. wrong password)
     *         the {@link Throwable#getCause cause} of the
     *         {@code IOException} should be an
     *         {@code UnrecoverableKeyException}
     * @exception NoSuchAlgorithmException if the algorithm used to check
     *          the integrity of the keystore cannot be found
     * @exception CertificateException if any of the certificates in the
     *          keystore could not be loaded
     *
     * @since 1.5
     */
    public void engineLoad(KeyStore.LoadStoreParameter param)
                throws IOException, NoSuchAlgorithmException,
                CertificateException {

<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (param == null) {</span>
<span class="nc" id="L384">            engineLoad((InputStream)null, (char[])null);</span>
<span class="nc" id="L385">            return;</span>
        }

<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (param instanceof KeyStore.SimpleLoadStoreParameter) {</span>
<span class="nc" id="L389">            ProtectionParameter protection = param.getProtectionParameter();</span>
            char[] password;
<span class="nc bnc" id="L391" title="All 2 branches missed.">            if (protection instanceof PasswordProtection) {</span>
<span class="nc" id="L392">                password = ((PasswordProtection)protection).getPassword();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            } else if (protection instanceof CallbackHandlerProtection) {</span>
<span class="nc" id="L394">                CallbackHandler handler =</span>
<span class="nc" id="L395">                    ((CallbackHandlerProtection)protection).getCallbackHandler();</span>
<span class="nc" id="L396">                PasswordCallback callback =</span>
                    new PasswordCallback(&quot;Password: &quot;, false);
                try {
<span class="nc" id="L399">                    handler.handle(new Callback[] {callback});</span>
<span class="nc" id="L400">                } catch (UnsupportedCallbackException e) {</span>
<span class="nc" id="L401">                    throw new NoSuchAlgorithmException</span>
                        (&quot;Could not obtain password&quot;, e);
<span class="nc" id="L403">                }</span>
<span class="nc" id="L404">                password = callback.getPassword();</span>
<span class="nc" id="L405">                callback.clearPassword();</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                if (password == null) {</span>
<span class="nc" id="L407">                    throw new NoSuchAlgorithmException</span>
                        (&quot;No password provided&quot;);
                }
<span class="nc" id="L410">            } else {</span>
<span class="nc" id="L411">                throw new NoSuchAlgorithmException(&quot;ProtectionParameter must&quot;</span>
                    + &quot; be PasswordProtection or CallbackHandlerProtection&quot;);
            }
<span class="nc" id="L414">            engineLoad(null, password);</span>
<span class="nc" id="L415">            return;</span>
        }

<span class="nc" id="L418">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Gets a {@code KeyStore.Entry} for the specified alias
     * with the specified protection parameter.
     *
     * @param alias get the {@code KeyStore.Entry} for this alias
     * @param protParam the {@code ProtectionParameter}
     *          used to protect the {@code Entry},
     *          which may be {@code null}
     *
     * @return the {@code KeyStore.Entry} for the specified alias,
     *          or {@code null} if there is no such entry
     *
     * @exception KeyStoreException if the operation failed
     * @exception NoSuchAlgorithmException if the algorithm for recovering the
     *          entry cannot be found
     * @exception UnrecoverableEntryException if the specified
     *          {@code protParam} were insufficient or invalid
     * @exception UnrecoverableKeyException if the entry is a
     *          {@code PrivateKeyEntry} or {@code SecretKeyEntry}
     *          and the specified {@code protParam} does not contain
     *          the information needed to recover the key (e.g. wrong password)
     *
     * @since 1.5
     */
    public KeyStore.Entry engineGetEntry(String alias,
                        KeyStore.ProtectionParameter protParam)
                throws KeyStoreException, NoSuchAlgorithmException,
                UnrecoverableEntryException {

<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (!engineContainsAlias(alias)) {</span>
<span class="nc" id="L451">            return null;</span>
        }

<span class="pc bpc" id="L454" title="1 of 2 branches missed.">        if (protParam == null) {</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (engineIsCertificateEntry(alias)) {</span>
<span class="nc" id="L456">                return new KeyStore.TrustedCertificateEntry</span>
<span class="nc" id="L457">                                (engineGetCertificate(alias));</span>
            } else {
<span class="nc" id="L459">                throw new UnrecoverableKeyException</span>
                        (&quot;requested entry requires a password&quot;);
            }
        }

<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (protParam instanceof KeyStore.PasswordProtection) {</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">            if (engineIsCertificateEntry(alias)) {</span>
<span class="nc" id="L466">                throw new UnsupportedOperationException</span>
                    (&quot;trusted certificate entries are not password-protected&quot;);
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">            } else if (engineIsKeyEntry(alias)) {</span>
<span class="fc" id="L469">                KeyStore.PasswordProtection pp =</span>
                        (KeyStore.PasswordProtection)protParam;
<span class="fc" id="L471">                char[] password = pp.getPassword();</span>

<span class="fc" id="L473">                Key key = engineGetKey(alias, password);</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">                if (key instanceof PrivateKey) {</span>
<span class="fc" id="L475">                    Certificate[] chain = engineGetCertificateChain(alias);</span>
<span class="fc" id="L476">                    return new KeyStore.PrivateKeyEntry((PrivateKey)key, chain);</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">                } else if (key instanceof SecretKey) {</span>
<span class="nc" id="L478">                    return new KeyStore.SecretKeyEntry((SecretKey)key);</span>
                }
            }
        }

<span class="nc" id="L483">        throw new UnsupportedOperationException();</span>
    }

    /**
     * Saves a {@code KeyStore.Entry} under the specified alias.
     * The specified protection parameter is used to protect the
     * {@code Entry}.
     *
     * &lt;p&gt; If an entry already exists for the specified alias,
     * it is overridden.
     *
     * @param alias save the {@code KeyStore.Entry} under this alias
     * @param entry the {@code Entry} to save
     * @param protParam the {@code ProtectionParameter}
     *          used to protect the {@code Entry},
     *          which may be {@code null}
     *
     * @exception KeyStoreException if this operation fails
     *
     * @since 1.5
     */
    public void engineSetEntry(String alias, KeyStore.Entry entry,
                        KeyStore.ProtectionParameter protParam)
                throws KeyStoreException {

        // get password
<span class="nc bnc" id="L509" title="All 4 branches missed.">        if (protParam != null &amp;&amp;</span>
            !(protParam instanceof KeyStore.PasswordProtection)) {
<span class="nc" id="L511">            throw new KeyStoreException(&quot;unsupported protection parameter&quot;);</span>
        }
<span class="nc" id="L513">        KeyStore.PasswordProtection pProtect = null;</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">        if (protParam != null) {</span>
<span class="nc" id="L515">            pProtect = (KeyStore.PasswordProtection)protParam;</span>
        }

        // set entry
<span class="nc bnc" id="L519" title="All 2 branches missed.">        if (entry instanceof KeyStore.TrustedCertificateEntry) {</span>
<span class="nc bnc" id="L520" title="All 4 branches missed.">            if (protParam != null &amp;&amp; pProtect.getPassword() != null) {</span>
                // pre-1.5 style setCertificateEntry did not allow password
<span class="nc" id="L522">                throw new KeyStoreException</span>
                    (&quot;trusted certificate entries are not password-protected&quot;);
            } else {
<span class="nc" id="L525">                KeyStore.TrustedCertificateEntry tce =</span>
                        (KeyStore.TrustedCertificateEntry)entry;
<span class="nc" id="L527">                engineSetCertificateEntry(alias, tce.getTrustedCertificate());</span>
<span class="nc" id="L528">                return;</span>
            }
<span class="nc bnc" id="L530" title="All 2 branches missed.">        } else if (entry instanceof KeyStore.PrivateKeyEntry) {</span>
<span class="nc bnc" id="L531" title="All 4 branches missed.">            if (pProtect == null || pProtect.getPassword() == null) {</span>
                // pre-1.5 style setKeyEntry required password
<span class="nc" id="L533">                throw new KeyStoreException</span>
                    (&quot;non-null password required to create PrivateKeyEntry&quot;);
            } else {
<span class="nc" id="L536">                engineSetKeyEntry</span>
<span class="nc" id="L537">                    (alias,</span>
<span class="nc" id="L538">                    ((KeyStore.PrivateKeyEntry)entry).getPrivateKey(),</span>
<span class="nc" id="L539">                    pProtect.getPassword(),</span>
<span class="nc" id="L540">                    ((KeyStore.PrivateKeyEntry)entry).getCertificateChain());</span>
<span class="nc" id="L541">                return;</span>
            }
<span class="nc bnc" id="L543" title="All 2 branches missed.">        } else if (entry instanceof KeyStore.SecretKeyEntry) {</span>
<span class="nc bnc" id="L544" title="All 4 branches missed.">            if (pProtect == null || pProtect.getPassword() == null) {</span>
                // pre-1.5 style setKeyEntry required password
<span class="nc" id="L546">                throw new KeyStoreException</span>
                    (&quot;non-null password required to create SecretKeyEntry&quot;);
            } else {
<span class="nc" id="L549">                engineSetKeyEntry</span>
<span class="nc" id="L550">                    (alias,</span>
<span class="nc" id="L551">                    ((KeyStore.SecretKeyEntry)entry).getSecretKey(),</span>
<span class="nc" id="L552">                    pProtect.getPassword(),</span>
                    (Certificate[])null);
<span class="nc" id="L554">                return;</span>
            }
        }

<span class="nc" id="L558">        throw new KeyStoreException</span>
<span class="nc" id="L559">                (&quot;unsupported entry type: &quot; + entry.getClass().getName());</span>
    }

    /**
     * Determines if the keystore {@code Entry} for the specified
     * {@code alias} is an instance or subclass of the specified
     * {@code entryClass}.
     *
     * @param alias the alias name
     * @param entryClass the entry class
     *
     * @return true if the keystore {@code Entry} for the specified
     *          {@code alias} is an instance or subclass of the
     *          specified {@code entryClass}, false otherwise
     *
     * @since 1.5
     */
    public boolean
        engineEntryInstanceOf(String alias,
                              Class&lt;? extends KeyStore.Entry&gt; entryClass)
    {
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">        if (entryClass == KeyStore.TrustedCertificateEntry.class) {</span>
<span class="nc" id="L581">            return engineIsCertificateEntry(alias);</span>
        }
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (entryClass == KeyStore.PrivateKeyEntry.class) {</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">            return engineIsKeyEntry(alias) &amp;&amp;</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">                        engineGetCertificate(alias) != null;</span>
        }
<span class="nc bnc" id="L587" title="All 2 branches missed.">        if (entryClass == KeyStore.SecretKeyEntry.class) {</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">            return engineIsKeyEntry(alias) &amp;&amp;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                        engineGetCertificate(alias) == null;</span>
        }
<span class="nc" id="L591">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>