<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ProtectionDomain.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">ProtectionDomain.java</span></div><h1>ProtectionDomain.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;
import sun.misc.JavaSecurityProtectionDomainAccess;
import static sun.misc.JavaSecurityProtectionDomainAccess.ProtectionDomainCache;
import sun.security.util.Debug;
import sun.security.util.SecurityConstants;
import sun.misc.JavaSecurityAccess;
import sun.misc.SharedSecrets;

/**
 *
 *&lt;p&gt;
 * This ProtectionDomain class encapsulates the characteristics of a domain,
 * which encloses a set of classes whose instances are granted a set
 * of permissions when being executed on behalf of a given set of Principals.
 * &lt;p&gt;
 * A static set of permissions can be bound to a ProtectionDomain when it is
 * constructed; such permissions are granted to the domain regardless of the
 * Policy in force. However, to support dynamic security policies, a
 * ProtectionDomain can also be constructed such that it is dynamically
 * mapped to a set of permissions by the current Policy whenever a permission
 * is checked.
 * &lt;p&gt;
 *
 * @author Li Gong
 * @author Roland Schemers
 * @author Gary Ellison
 */

public class ProtectionDomain {

    static {
        // Set up JavaSecurityAccess in SharedSecrets
<span class="fc" id="L65">        SharedSecrets.setJavaSecurityAccess(</span>
<span class="fc" id="L66">            new JavaSecurityAccess() {</span>
                public &lt;T&gt; T doIntersectionPrivilege(
                    PrivilegedAction&lt;T&gt; action,
                    final AccessControlContext stack,
                    final AccessControlContext context)
                {
<span class="nc bnc" id="L72" title="All 2 branches missed.">                    if (action == null) {</span>
<span class="nc" id="L73">                        throw new NullPointerException();</span>
                    }
<span class="nc" id="L75">                    return AccessController.doPrivileged(</span>
                        action,
                        new AccessControlContext(
<span class="nc" id="L78">                            stack.getContext(), context).optimize()</span>
                    );
                }

                public &lt;T&gt; T doIntersectionPrivilege(
                    PrivilegedAction&lt;T&gt; action,
                    AccessControlContext context)
                {
<span class="nc" id="L86">                    return doIntersectionPrivilege(action,</span>
<span class="nc" id="L87">                        AccessController.getContext(), context);</span>
                }
            }
       );
    }

    /* CodeSource */
    private CodeSource codesource ;

    /* ClassLoader the protection domain was consed from */
    private ClassLoader classloader;

    /* Principals running-as within this protection domain */
    private Principal[] principals;

    /* the rights this protection domain is granted */
    private PermissionCollection permissions;

    /* if the permissions object has AllPermission */
<span class="fc" id="L106">    private boolean hasAllPerm = false;</span>

    /* the PermissionCollection is static (pre 1.4 constructor)
       or dynamic (via a policy refresh) */
    private boolean staticPermissions;

    /*
     * An object used as a key when the ProtectionDomain is stored in a Map.
     */
<span class="fc" id="L115">    final Key key = new Key();</span>

<span class="fc" id="L117">    private static final Debug debug = Debug.getInstance(&quot;domain&quot;);</span>

    /**
     * Creates a new ProtectionDomain with the given CodeSource and
     * Permissions. If the permissions object is not null, then
     *  {@code setReadOnly())} will be called on the passed in
     * Permissions object. The only permissions granted to this domain
     * are the ones specified; the current Policy will not be consulted.
     *
     * @param codesource the codesource associated with this domain
     * @param permissions the permissions granted to this domain
     */
    public ProtectionDomain(CodeSource codesource,
<span class="fc" id="L130">                            PermissionCollection permissions) {</span>
<span class="fc" id="L131">        this.codesource = codesource;</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (permissions != null) {</span>
<span class="fc" id="L133">            this.permissions = permissions;</span>
<span class="fc" id="L134">            this.permissions.setReadOnly();</span>
<span class="pc bpc" id="L135" title="1 of 4 branches missed.">            if (permissions instanceof Permissions &amp;&amp;</span>
                ((Permissions)permissions).allPermission != null) {
<span class="fc" id="L137">                hasAllPerm = true;</span>
            }
        }
<span class="fc" id="L140">        this.classloader = null;</span>
<span class="fc" id="L141">        this.principals = new Principal[0];</span>
<span class="fc" id="L142">        staticPermissions = true;</span>
<span class="fc" id="L143">    }</span>

    /**
     * Creates a new ProtectionDomain qualified by the given CodeSource,
     * Permissions, ClassLoader and array of Principals. If the
     * permissions object is not null, then {@code setReadOnly()}
     * will be called on the passed in Permissions object.
     * The permissions granted to this domain are dynamic; they include
     * both the static permissions passed to this constructor, and any
     * permissions granted to this domain by the current Policy at the
     * time a permission is checked.
     * &lt;p&gt;
     * This constructor is typically used by
     * {@link SecureClassLoader ClassLoaders}
     * and {@link DomainCombiner DomainCombiners} which delegate to
     * {@code Policy} to actively associate the permissions granted to
     * this domain. This constructor affords the
     * Policy provider the opportunity to augment the supplied
     * PermissionCollection to reflect policy changes.
     * &lt;p&gt;
     *
     * @param codesource the CodeSource associated with this domain
     * @param permissions the permissions granted to this domain
     * @param classloader the ClassLoader associated with this domain
     * @param principals the array of Principals associated with this
     * domain. The contents of the array are copied to protect against
     * subsequent modification.
     * @see Policy#refresh
     * @see Policy#getPermissions(ProtectionDomain)
     * @since 1.4
     */
    public ProtectionDomain(CodeSource codesource,
                            PermissionCollection permissions,
                            ClassLoader classloader,
<span class="fc" id="L177">                            Principal[] principals) {</span>
<span class="fc" id="L178">        this.codesource = codesource;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        if (permissions != null) {</span>
<span class="fc" id="L180">            this.permissions = permissions;</span>
<span class="fc" id="L181">            this.permissions.setReadOnly();</span>
<span class="pc bpc" id="L182" title="2 of 4 branches missed.">            if (permissions instanceof Permissions &amp;&amp;</span>
                ((Permissions)permissions).allPermission != null) {
<span class="nc" id="L184">                hasAllPerm = true;</span>
            }
        }
<span class="fc" id="L187">        this.classloader = classloader;</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        this.principals = (principals != null ? principals.clone():</span>
                           new Principal[0]);
<span class="fc" id="L190">        staticPermissions = false;</span>
<span class="fc" id="L191">    }</span>

    /**
     * Returns the CodeSource of this domain.
     * @return the CodeSource of this domain which may be null.
     * @since 1.2
     */
    public final CodeSource getCodeSource() {
<span class="fc" id="L199">        return this.codesource;</span>
    }


    /**
     * Returns the ClassLoader of this domain.
     * @return the ClassLoader of this domain which may be null.
     *
     * @since 1.4
     */
    public final ClassLoader getClassLoader() {
<span class="fc" id="L210">        return this.classloader;</span>
    }


    /**
     * Returns an array of principals for this domain.
     * @return a non-null array of principals for this domain.
     * Returns a new array each time this method is called.
     *
     * @since 1.4
     */
    public final Principal[] getPrincipals() {
<span class="fc" id="L222">        return this.principals.clone();</span>
    }

    /**
     * Returns the static permissions granted to this domain.
     *
     * @return the static set of permissions for this domain which may be null.
     * @see Policy#refresh
     * @see Policy#getPermissions(ProtectionDomain)
     */
    public final PermissionCollection getPermissions() {
<span class="fc" id="L233">        return permissions;</span>
    }

    /**
     * Check and see if this ProtectionDomain implies the permissions
     * expressed in the Permission object.
     * &lt;p&gt;
     * The set of permissions evaluated is a function of whether the
     * ProtectionDomain was constructed with a static set of permissions
     * or it was bound to a dynamically mapped set of permissions.
     * &lt;p&gt;
     * If the ProtectionDomain was constructed to a
     * {@link #ProtectionDomain(CodeSource, PermissionCollection)
     * statically bound} PermissionCollection then the permission will
     * only be checked against the PermissionCollection supplied at
     * construction.
     * &lt;p&gt;
     * However, if the ProtectionDomain was constructed with
     * the constructor variant which supports
     * {@link #ProtectionDomain(CodeSource, PermissionCollection,
     * ClassLoader, java.security.Principal[]) dynamically binding}
     * permissions, then the permission will be checked against the
     * combination of the PermissionCollection supplied at construction and
     * the current Policy binding.
     * &lt;p&gt;
     *
     * @param permission the Permission object to check.
     *
     * @return true if &quot;permission&quot; is implicit to this ProtectionDomain.
     */
    public boolean implies(Permission permission) {

<span class="fc bfc" id="L265" title="All 2 branches covered.">        if (hasAllPerm) {</span>
            // internal permission collection already has AllPermission -
            // no need to go to policy
<span class="fc" id="L268">            return true;</span>
        }

<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (!staticPermissions &amp;&amp;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">            Policy.getPolicyNoCheck().implies(this, permission))</span>
<span class="fc" id="L273">            return true;</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (permissions != null)</span>
<span class="fc" id="L275">            return permissions.implies(permission);</span>

<span class="fc" id="L277">        return false;</span>
    }

    // called by the VM -- do not remove
    boolean impliesCreateAccessControlContext() {
<span class="fc" id="L282">        return implies(SecurityConstants.CREATE_ACC_PERMISSION);</span>
    }

    /**
     * Convert a ProtectionDomain to a String.
     */
    @Override public String toString() {
<span class="fc" id="L289">        String pals = &quot;&lt;no principals&gt;&quot;;</span>
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">        if (principals != null &amp;&amp; principals.length &gt; 0) {</span>
<span class="fc" id="L291">            StringBuilder palBuf = new StringBuilder(&quot;(principals &quot;);</span>

<span class="fc bfc" id="L293" title="All 2 branches covered.">            for (int i = 0; i &lt; principals.length; i++) {</span>
<span class="fc" id="L294">                palBuf.append(principals[i].getClass().getName() +</span>
<span class="fc" id="L295">                            &quot; \&quot;&quot; + principals[i].getName() +</span>
                            &quot;\&quot;&quot;);
<span class="fc bfc" id="L297" title="All 2 branches covered.">                if (i &lt; principals.length-1)</span>
<span class="fc" id="L298">                    palBuf.append(&quot;,\n&quot;);</span>
                else
<span class="fc" id="L300">                    palBuf.append(&quot;)\n&quot;);</span>
            }
<span class="fc" id="L302">            pals = palBuf.toString();</span>
        }

        // Check if policy is set; we don't want to load
        // the policy prematurely here
<span class="pc bpc" id="L307" title="1 of 4 branches missed.">        PermissionCollection pc = Policy.isSet() &amp;&amp; seeAllp() ?</span>
<span class="fc" id="L308">                                      mergePermissions():</span>
<span class="fc" id="L309">                                      getPermissions();</span>

<span class="fc" id="L311">        return &quot;ProtectionDomain &quot;+</span>
            &quot; &quot;+codesource+&quot;\n&quot;+
            &quot; &quot;+classloader+&quot;\n&quot;+
            &quot; &quot;+pals+&quot;\n&quot;+
            &quot; &quot;+pc+&quot;\n&quot;;
    }

    /**
     * Return true (merge policy permissions) in the following cases:
     *
     * . SecurityManager is null
     *
     * . SecurityManager is not null,
     *          debug is not null,
     *          SecurityManager impelmentation is in bootclasspath,
     *          Policy implementation is in bootclasspath
     *          (the bootclasspath restrictions avoid recursion)
     *
     * . SecurityManager is not null,
     *          debug is null,
     *          caller has Policy.getPolicy permission
     */
    private static boolean seeAllp() {
<span class="fc" id="L334">        SecurityManager sm = System.getSecurityManager();</span>

<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (sm == null) {</span>
<span class="fc" id="L337">            return true;</span>
        } else {
<span class="fc bfc" id="L339" title="All 2 branches covered.">            if (debug != null) {</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">                if (sm.getClass().getClassLoader() == null &amp;&amp;</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">                    Policy.getPolicyNoCheck().getClass().getClassLoader()</span>
                                                                == null) {
<span class="fc" id="L343">                    return true;</span>
                }
            } else {
                try {
<span class="fc" id="L347">                    sm.checkPermission(SecurityConstants.GET_POLICY_PERMISSION);</span>
<span class="fc" id="L348">                    return true;</span>
<span class="nc" id="L349">                } catch (SecurityException se) {</span>
                    // fall thru and return false
                }
            }
        }

<span class="fc" id="L355">        return false;</span>
    }

    private PermissionCollection mergePermissions() {
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">        if (staticPermissions)</span>
<span class="nc" id="L360">            return permissions;</span>

<span class="fc" id="L362">        PermissionCollection perms =</span>
            java.security.AccessController.doPrivileged
<span class="fc" id="L364">            (new java.security.PrivilegedAction&lt;PermissionCollection&gt;() {</span>
                    public PermissionCollection run() {
<span class="fc" id="L366">                        Policy p = Policy.getPolicyNoCheck();</span>
<span class="fc" id="L367">                        return p.getPermissions(ProtectionDomain.this);</span>
                    }
                });

<span class="fc" id="L371">        Permissions mergedPerms = new Permissions();</span>
<span class="fc" id="L372">        int swag = 32;</span>
<span class="fc" id="L373">        int vcap = 8;</span>
        Enumeration&lt;Permission&gt; e;
<span class="fc" id="L375">        List&lt;Permission&gt; pdVector = new ArrayList&lt;&gt;(vcap);</span>
<span class="fc" id="L376">        List&lt;Permission&gt; plVector = new ArrayList&lt;&gt;(swag);</span>

        //
        // Build a vector of domain permissions for subsequent merge
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (permissions != null) {</span>
<span class="fc" id="L381">            synchronized (permissions) {</span>
<span class="fc" id="L382">                e = permissions.elements();</span>
<span class="fc bfc" id="L383" title="All 2 branches covered.">                while (e.hasMoreElements()) {</span>
<span class="fc" id="L384">                    pdVector.add(e.nextElement());</span>
                }
<span class="pc" id="L386">            }</span>
        }

        //
        // Build a vector of Policy permissions for subsequent merge
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (perms != null) {</span>
<span class="fc" id="L392">            synchronized (perms) {</span>
<span class="fc" id="L393">                e = perms.elements();</span>
<span class="fc bfc" id="L394" title="All 2 branches covered.">                while (e.hasMoreElements()) {</span>
<span class="fc" id="L395">                    plVector.add(e.nextElement());</span>
<span class="fc" id="L396">                    vcap++;</span>
                }
<span class="pc" id="L398">            }</span>
        }

<span class="pc bpc" id="L401" title="1 of 4 branches missed.">        if (perms != null &amp;&amp; permissions != null) {</span>
            //
            // Weed out the duplicates from the policy. Unless a refresh
            // has occurred since the pd was consed this should result in
            // an empty vector.
<span class="fc" id="L406">            synchronized (permissions) {</span>
<span class="fc" id="L407">                e = permissions.elements();   // domain vs policy</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">                while (e.hasMoreElements()) {</span>
<span class="fc" id="L409">                    Permission pdp = e.nextElement();</span>
<span class="fc" id="L410">                    Class&lt;?&gt; pdpClass = pdp.getClass();</span>
<span class="fc" id="L411">                    String pdpActions = pdp.getActions();</span>
<span class="fc" id="L412">                    String pdpName = pdp.getName();</span>
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">                    for (int i = 0; i &lt; plVector.size(); i++) {</span>
<span class="fc" id="L414">                        Permission pp = plVector.get(i);</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">                        if (pdpClass.isInstance(pp)) {</span>
                            // The equals() method on some permissions
                            // have some side effects so this manual
                            // comparison is sufficient.
<span class="fc bfc" id="L419" title="All 2 branches covered.">                            if (pdpName.equals(pp.getName()) &amp;&amp;</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">                                pdpActions.equals(pp.getActions())) {</span>
<span class="fc" id="L421">                                plVector.remove(i);</span>
<span class="fc" id="L422">                                break;</span>
                            }
                        }
                    }
<span class="fc" id="L426">                }</span>
<span class="pc" id="L427">            }</span>
        }

<span class="pc bpc" id="L430" title="1 of 2 branches missed.">        if (perms !=null) {</span>
            // the order of adding to merged perms and permissions
            // needs to preserve the bugfix 4301064

<span class="fc bfc" id="L434" title="All 2 branches covered.">            for (int i = plVector.size()-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L435">                mergedPerms.add(plVector.get(i));</span>
            }
        }
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (permissions != null) {</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">            for (int i = pdVector.size()-1; i &gt;= 0; i--) {</span>
<span class="fc" id="L440">                mergedPerms.add(pdVector.get(i));</span>
            }
        }

<span class="fc" id="L444">        return mergedPerms;</span>
    }

    /**
     * Used for storing ProtectionDomains as keys in a Map.
     */
<span class="fc" id="L450">    final class Key {}</span>

    static {
<span class="fc" id="L453">        SharedSecrets.setJavaSecurityProtectionDomainAccess(</span>
<span class="fc" id="L454">            new JavaSecurityProtectionDomainAccess() {</span>
                public ProtectionDomainCache getProtectionDomainCache() {
<span class="fc" id="L456">                    return new ProtectionDomainCache() {</span>
<span class="fc" id="L457">                        private final Map&lt;Key, PermissionCollection&gt; map =</span>
                            Collections.synchronizedMap
<span class="fc" id="L459">                                (new WeakHashMap&lt;Key, PermissionCollection&gt;());</span>
                        public void put(ProtectionDomain pd,
                            PermissionCollection pc) {
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">                            map.put((pd == null ? null : pd.key), pc);</span>
<span class="fc" id="L463">                        }</span>
                        public PermissionCollection get(ProtectionDomain pd) {
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">                            return pd == null ? map.get(null) : map.get(pd.key);</span>
                        }
                    };
                }
            });
<span class="fc" id="L470">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>