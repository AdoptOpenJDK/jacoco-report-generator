<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CodeSource.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">CodeSource.java</span></div><h1>CodeSource.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;


import java.net.URL;
import java.net.SocketPermission;
import java.util.ArrayList;
import java.util.List;
import java.util.Hashtable;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.security.cert.*;

/**
 *
 * &lt;p&gt;This class extends the concept of a codebase to
 * encapsulate not only the location (URL) but also the certificate chains
 * that were used to verify signed code originating from that location.
 *
 * @author Li Gong
 * @author Roland Schemers
 */

public class CodeSource implements java.io.Serializable {

    private static final long serialVersionUID = 4977541819976013951L;

    /**
     * The code location.
     *
     * @serial
     */
    private URL location;

    /*
     * The code signers.
     */
<span class="fc" id="L62">    private transient CodeSigner[] signers = null;</span>

    /*
     * The code signers. Certificate chains are concatenated.
     */
<span class="fc" id="L67">    private transient java.security.cert.Certificate certs[] = null;</span>

    // cached SocketPermission used for matchLocation
    private transient SocketPermission sp;

    // for generating cert paths
<span class="fc" id="L73">    private transient CertificateFactory factory = null;</span>

    /**
     * Constructs a CodeSource and associates it with the specified
     * location and set of certificates.
     *
     * @param url the location (URL).
     *
     * @param certs the certificate(s). It may be null. The contents of the
     * array are copied to protect against subsequent modification.
     */
<span class="fc" id="L84">    public CodeSource(URL url, java.security.cert.Certificate certs[]) {</span>
<span class="fc" id="L85">        this.location = url;</span>

        // Copy the supplied certs
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (certs != null) {</span>
<span class="fc" id="L89">            this.certs = certs.clone();</span>
        }
<span class="fc" id="L91">    }</span>

    /**
     * Constructs a CodeSource and associates it with the specified
     * location and set of code signers.
     *
     * @param url the location (URL).
     * @param signers the code signers. It may be null. The contents of the
     * array are copied to protect against subsequent modification.
     *
     * @since 1.5
     */
<span class="fc" id="L103">    public CodeSource(URL url, CodeSigner[] signers) {</span>
<span class="fc" id="L104">        this.location = url;</span>

        // Copy the supplied signers
<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (signers != null) {</span>
<span class="fc" id="L108">            this.signers = signers.clone();</span>
        }
<span class="fc" id="L110">    }</span>

    /**
     * Returns the hash code value for this object.
     *
     * @return a hash code value for this object.
     */
    @Override
    public int hashCode() {
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if (location != null)</span>
<span class="fc" id="L120">            return location.hashCode();</span>
        else
<span class="nc" id="L122">            return 0;</span>
    }

    /**
     * Tests for equality between the specified object and this
     * object. Two CodeSource objects are considered equal if their
     * locations are of identical value and if their signer certificate
     * chains are of identical value. It is not required that
     * the certificate chains be in the same order.
     *
     * @param obj the object to test for equality with this object.
     *
     * @return true if the objects are considered equal, false otherwise.
     */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L139">            return true;</span>

        // objects types must be equal
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if (!(obj instanceof CodeSource))</span>
<span class="nc" id="L143">            return false;</span>

<span class="fc" id="L145">        CodeSource cs = (CodeSource) obj;</span>

        // URLs must match
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">        if (location == null) {</span>
            // if location is null, then cs.location must be null as well
<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (cs.location != null) return false;</span>
        } else {
            // if location is not null, then it must equal cs.location
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">            if (!location.equals(cs.location)) return false;</span>
        }

        // certs must match
<span class="fc" id="L157">        return matchCerts(cs, true);</span>
    }

    /**
     * Returns the location associated with this CodeSource.
     *
     * @return the location (URL).
     */
    public final URL getLocation() {
        /* since URL is practically immutable, returning itself is not
           a security problem */
<span class="fc" id="L168">        return this.location;</span>
    }

    /**
     * Returns the certificates associated with this CodeSource.
     * &lt;p&gt;
     * If this CodeSource object was created using the
     * {@link #CodeSource(URL url, CodeSigner[] signers)}
     * constructor then its certificate chains are extracted and used to
     * create an array of Certificate objects. Each signer certificate is
     * followed by its supporting certificate chain (which may be empty).
     * Each signer certificate and its supporting certificate chain is ordered
     * bottom-to-top (i.e., with the signer certificate first and the (root)
     * certificate authority last).
     *
     * @return A copy of the certificates array, or null if there is none.
     */
    public final java.security.cert.Certificate[] getCertificates() {
<span class="fc bfc" id="L186" title="All 2 branches covered.">        if (certs != null) {</span>
<span class="fc" id="L187">            return certs.clone();</span>

<span class="fc bfc" id="L189" title="All 2 branches covered.">        } else if (signers != null) {</span>
            // Convert the code signers to certs
<span class="fc" id="L191">            ArrayList&lt;java.security.cert.Certificate&gt; certChains =</span>
                        new ArrayList&lt;&gt;();
<span class="fc bfc" id="L193" title="All 2 branches covered.">            for (int i = 0; i &lt; signers.length; i++) {</span>
<span class="fc" id="L194">                certChains.addAll(</span>
<span class="fc" id="L195">                    signers[i].getSignerCertPath().getCertificates());</span>
            }
<span class="fc" id="L197">            certs = certChains.toArray(</span>
<span class="fc" id="L198">                        new java.security.cert.Certificate[certChains.size()]);</span>
<span class="fc" id="L199">            return certs.clone();</span>

        } else {
<span class="fc" id="L202">            return null;</span>
        }
    }

    /**
     * Returns the code signers associated with this CodeSource.
     * &lt;p&gt;
     * If this CodeSource object was created using the
     * {@link #CodeSource(URL url, java.security.cert.Certificate[] certs)}
     * constructor then its certificate chains are extracted and used to
     * create an array of CodeSigner objects. Note that only X.509 certificates
     * are examined - all other certificate types are ignored.
     *
     * @return A copy of the code signer array, or null if there is none.
     *
     * @since 1.5
     */
    public final CodeSigner[] getCodeSigners() {
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (signers != null) {</span>
<span class="nc" id="L221">            return signers.clone();</span>

<span class="nc bnc" id="L223" title="All 2 branches missed.">        } else if (certs != null) {</span>
            // Convert the certs to code signers
<span class="nc" id="L225">            signers = convertCertArrayToSignerArray(certs);</span>
<span class="nc" id="L226">            return signers.clone();</span>

        } else {
<span class="nc" id="L229">            return null;</span>
        }
    }

    /**
     * Returns true if this CodeSource object &quot;implies&quot; the specified CodeSource.
     * &lt;p&gt;
     * More specifically, this method makes the following checks.
     * If any fail, it returns false. If they all succeed, it returns true.
     * &lt;ul&gt;
     * &lt;li&gt; &lt;i&gt;codesource&lt;/i&gt; must not be null.
     * &lt;li&gt; If this object's certificates are not null, then all
     * of this object's certificates must be present in &lt;i&gt;codesource&lt;/i&gt;'s
     * certificates.
     * &lt;li&gt; If this object's location (getLocation()) is not null, then the
     * following checks are made against this object's location and
     * &lt;i&gt;codesource&lt;/i&gt;'s:
     *   &lt;ul&gt;
     *     &lt;li&gt;  &lt;i&gt;codesource&lt;/i&gt;'s location must not be null.
     *
     *     &lt;li&gt;  If this object's location
     *           equals &lt;i&gt;codesource&lt;/i&gt;'s location, then return true.
     *
     *     &lt;li&gt;  This object's protocol (getLocation().getProtocol()) must be
     *           equal to &lt;i&gt;codesource&lt;/i&gt;'s protocol, ignoring case.
     *
     *     &lt;li&gt;  If this object's host (getLocation().getHost()) is not null,
     *           then the SocketPermission
     *           constructed with this object's host must imply the
     *           SocketPermission constructed with &lt;i&gt;codesource&lt;/i&gt;'s host.
     *
     *     &lt;li&gt;  If this object's port (getLocation().getPort()) is not
     *           equal to -1 (that is, if a port is specified), it must equal
     *           &lt;i&gt;codesource&lt;/i&gt;'s port or default port
     *           (codesource.getLocation().getDefaultPort()).
     *
     *     &lt;li&gt;  If this object's file (getLocation().getFile()) doesn't equal
     *           &lt;i&gt;codesource&lt;/i&gt;'s file, then the following checks are made:
     *           If this object's file ends with &quot;/-&quot;,
     *           then &lt;i&gt;codesource&lt;/i&gt;'s file must start with this object's
     *           file (exclusive the trailing &quot;-&quot;).
     *           If this object's file ends with a &quot;/*&quot;,
     *           then &lt;i&gt;codesource&lt;/i&gt;'s file must start with this object's
     *           file and must not have any further &quot;/&quot; separators.
     *           If this object's file doesn't end with a &quot;/&quot;,
     *           then &lt;i&gt;codesource&lt;/i&gt;'s file must match this object's
     *           file with a '/' appended.
     *
     *     &lt;li&gt;  If this object's reference (getLocation().getRef()) is
     *           not null, it must equal &lt;i&gt;codesource&lt;/i&gt;'s reference.
     *
     *   &lt;/ul&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * For example, the codesource objects with the following locations
     * and null certificates all imply
     * the codesource with the location &quot;http://java.sun.com/classes/foo.jar&quot;
     * and null certificates:
     * &lt;pre&gt;
     *     http:
     *     http://*.sun.com/classes/*
     *     http://java.sun.com/classes/-
     *     http://java.sun.com/classes/foo.jar
     * &lt;/pre&gt;
     *
     * Note that if this CodeSource has a null location and a null
     * certificate chain, then it implies every other CodeSource.
     *
     * @param codesource CodeSource to compare against.
     *
     * @return true if the specified codesource is implied by this codesource,
     * false if not.
     */

    public boolean implies(CodeSource codesource)
    {
<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        if (codesource == null)</span>
<span class="nc" id="L306">            return false;</span>

<span class="pc bpc" id="L308" title="1 of 4 branches missed.">        return matchCerts(codesource, false) &amp;&amp; matchLocation(codesource);</span>
    }

    /**
     * Returns true if all the certs in this
     * CodeSource are also in &lt;i&gt;that&lt;/i&gt;.
     *
     * @param that the CodeSource to check against.
     * @param strict If true then a strict equality match is performed.
     *               Otherwise a subset match is performed.
     */
    private boolean matchCerts(CodeSource that, boolean strict)
    {
        boolean match;

        // match any key
<span class="pc bpc" id="L324" title="1 of 4 branches missed.">        if (certs == null &amp;&amp; signers == null) {</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">            if (strict) {</span>
<span class="pc bpc" id="L326" title="2 of 4 branches missed.">                return (that.certs == null &amp;&amp; that.signers == null);</span>
            } else {
<span class="fc" id="L328">                return true;</span>
            }
        // both have signers
<span class="pc bpc" id="L331" title="2 of 4 branches missed.">        } else if (signers != null &amp;&amp; that.signers != null) {</span>
<span class="pc bpc" id="L332" title="2 of 4 branches missed.">            if (strict &amp;&amp; signers.length != that.signers.length) {</span>
<span class="nc" id="L333">                return false;</span>
            }
<span class="fc bfc" id="L335" title="All 2 branches covered.">            for (int i = 0; i &lt; signers.length; i++) {</span>
<span class="fc" id="L336">                match = false;</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                for (int j = 0; j &lt; that.signers.length; j++) {</span>
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">                    if (signers[i].equals(that.signers[j])) {</span>
<span class="fc" id="L339">                        match = true;</span>
<span class="fc" id="L340">                        break;</span>
                    }
                }
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">                if (!match) return false;</span>
            }
<span class="fc" id="L345">            return true;</span>

        // both have certs
<span class="nc bnc" id="L348" title="All 4 branches missed.">        } else if (certs != null &amp;&amp; that.certs != null) {</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">            if (strict &amp;&amp; certs.length != that.certs.length) {</span>
<span class="nc" id="L350">                return false;</span>
            }
<span class="nc bnc" id="L352" title="All 2 branches missed.">            for (int i = 0; i &lt; certs.length; i++) {</span>
<span class="nc" id="L353">                match = false;</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">                for (int j = 0; j &lt; that.certs.length; j++) {</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">                    if (certs[i].equals(that.certs[j])) {</span>
<span class="nc" id="L356">                        match = true;</span>
<span class="nc" id="L357">                        break;</span>
                    }
                }
<span class="nc bnc" id="L360" title="All 2 branches missed.">                if (!match) return false;</span>
            }
<span class="nc" id="L362">            return true;</span>
        }

<span class="nc" id="L365">        return false;</span>
    }


    /**
     * Returns true if two CodeSource's have the &quot;same&quot; location.
     *
     * @param that CodeSource to compare against
     */
    private boolean matchLocation(CodeSource that) {
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (location == null)</span>
<span class="fc" id="L376">            return true;</span>

<span class="pc bpc" id="L378" title="1 of 4 branches missed.">        if ((that == null) || (that.location == null))</span>
<span class="fc" id="L379">            return false;</span>

<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (location.equals(that.location))</span>
<span class="fc" id="L382">            return true;</span>

<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (!location.getProtocol().equalsIgnoreCase(that.location.getProtocol()))</span>
<span class="fc" id="L385">            return false;</span>

<span class="fc" id="L387">        int thisPort = location.getPort();</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">        if (thisPort != -1) {</span>
<span class="nc" id="L389">            int thatPort = that.location.getPort();</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">            int port = thatPort != -1 ? thatPort</span>
<span class="nc" id="L391">                                      : that.location.getDefaultPort();</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if (thisPort != port)</span>
<span class="nc" id="L393">                return false;</span>
        }

<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (location.getFile().endsWith(&quot;/-&quot;)) {</span>
            // Matches the directory and (recursively) all files
            // and subdirectories contained in that directory.
            // For example, &quot;/a/b/-&quot; implies anything that starts with
            // &quot;/a/b/&quot;
<span class="fc" id="L401">            String thisPath = location.getFile().substring(0,</span>
<span class="fc" id="L402">                                            location.getFile().length()-1);</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">            if (!that.location.getFile().startsWith(thisPath))</span>
<span class="fc" id="L404">                return false;</span>
<span class="pc bfc" id="L405" title="All 2 branches covered.">        } else if (location.getFile().endsWith(&quot;/*&quot;)) {</span>
            // Matches the directory and all the files contained in that
            // directory.
            // For example, &quot;/a/b/*&quot; implies anything that starts with
            // &quot;/a/b/&quot; but has no further slashes
<span class="fc" id="L410">            int last = that.location.getFile().lastIndexOf('/');</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">            if (last == -1)</span>
<span class="nc" id="L412">                return false;</span>
<span class="fc" id="L413">            String thisPath = location.getFile().substring(0,</span>
<span class="fc" id="L414">                                            location.getFile().length()-1);</span>
<span class="fc" id="L415">            String thatPath = that.location.getFile().substring(0, last+1);</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">            if (!thatPath.equals(thisPath))</span>
<span class="fc" id="L417">                return false;</span>
<span class="fc" id="L418">        } else {</span>
            // Exact matches only.
            // For example, &quot;/a/b&quot; and &quot;/a/b/&quot; both imply &quot;/a/b/&quot;
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">            if ((!that.location.getFile().equals(location.getFile()))</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">                &amp;&amp; (!that.location.getFile().equals(location.getFile()+&quot;/&quot;))) {</span>
<span class="fc" id="L423">                return false;</span>
            }
        }

<span class="pc bpc" id="L427" title="1 of 2 branches missed.">        if (location.getRef() != null</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            &amp;&amp; !location.getRef().equals(that.location.getRef())) {</span>
<span class="nc" id="L429">            return false;</span>
        }

<span class="fc" id="L432">        String thisHost = location.getHost();</span>
<span class="fc" id="L433">        String thatHost = that.location.getHost();</span>
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if (thisHost != null) {</span>
<span class="pc bpc" id="L435" title="3 of 4 branches missed.">            if ((&quot;&quot;.equals(thisHost) || &quot;localhost&quot;.equals(thisHost)) &amp;&amp;</span>
<span class="pc bpc" id="L436" title="3 of 4 branches missed.">                (&quot;&quot;.equals(thatHost) || &quot;localhost&quot;.equals(thatHost))) {</span>
                // ok
<span class="nc bnc" id="L438" title="All 2 branches missed.">            } else if (!thisHost.equals(thatHost)) {</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">                if (thatHost == null) {</span>
<span class="nc" id="L440">                    return false;</span>
                }
<span class="nc bnc" id="L442" title="All 2 branches missed.">                if (this.sp == null) {</span>
<span class="nc" id="L443">                    this.sp = new SocketPermission(thisHost, &quot;resolve&quot;);</span>
                }
<span class="nc bnc" id="L445" title="All 2 branches missed.">                if (that.sp == null) {</span>
<span class="nc" id="L446">                    that.sp = new SocketPermission(thatHost, &quot;resolve&quot;);</span>
                }
<span class="nc bnc" id="L448" title="All 2 branches missed.">                if (!this.sp.implies(that.sp)) {</span>
<span class="nc" id="L449">                    return false;</span>
                }
            }
        }
        // everything matches
<span class="fc" id="L454">        return true;</span>
    }

    /**
     * Returns a string describing this CodeSource, telling its
     * URL and certificates.
     *
     * @return information about this CodeSource.
     */
    @Override
    public String toString() {
<span class="fc" id="L465">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L466">        sb.append(&quot;(&quot;);</span>
<span class="fc" id="L467">        sb.append(this.location);</span>

<span class="pc bpc" id="L469" title="3 of 4 branches missed.">        if (this.certs != null &amp;&amp; this.certs.length &gt; 0) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">            for (int i = 0; i &lt; this.certs.length; i++) {</span>
<span class="nc" id="L471">                sb.append( &quot; &quot; + this.certs[i]);</span>
            }

<span class="pc bpc" id="L474" title="3 of 4 branches missed.">        } else if (this.signers != null &amp;&amp; this.signers.length &gt; 0) {</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">            for (int i = 0; i &lt; this.signers.length; i++) {</span>
<span class="nc" id="L476">                sb.append( &quot; &quot; + this.signers[i]);</span>
            }
        } else {
<span class="fc" id="L479">            sb.append(&quot; &lt;no signer certificates&gt;&quot;);</span>
        }
<span class="fc" id="L481">        sb.append(&quot;)&quot;);</span>
<span class="fc" id="L482">        return sb.toString();</span>
    }

    /**
     * Writes this object out to a stream (i.e., serializes it).
     *
     * @serialData An initial {@code URL} is followed by an
     * {@code int} indicating the number of certificates to follow
     * (a value of &quot;zero&quot; denotes that there are no certificates associated
     * with this object).
     * Each certificate is written out starting with a {@code String}
     * denoting the certificate type, followed by an
     * {@code int} specifying the length of the certificate encoding,
     * followed by the certificate encoding itself which is written out as an
     * array of bytes. Finally, if any code signers are present then the array
     * of code signers is serialized and written out too.
     */
    private void writeObject(java.io.ObjectOutputStream oos)
        throws IOException
    {
<span class="nc" id="L502">        oos.defaultWriteObject(); // location</span>

        // Serialize the array of certs
<span class="nc bnc" id="L505" title="All 4 branches missed.">        if (certs == null || certs.length == 0) {</span>
<span class="nc" id="L506">            oos.writeInt(0);</span>
        } else {
            // write out the total number of certs
<span class="nc" id="L509">            oos.writeInt(certs.length);</span>
            // write out each cert, including its type
<span class="nc bnc" id="L511" title="All 2 branches missed.">            for (int i = 0; i &lt; certs.length; i++) {</span>
<span class="nc" id="L512">                java.security.cert.Certificate cert = certs[i];</span>
                try {
<span class="nc" id="L514">                    oos.writeUTF(cert.getType());</span>
<span class="nc" id="L515">                    byte[] encoded = cert.getEncoded();</span>
<span class="nc" id="L516">                    oos.writeInt(encoded.length);</span>
<span class="nc" id="L517">                    oos.write(encoded);</span>
<span class="nc" id="L518">                } catch (CertificateEncodingException cee) {</span>
<span class="nc" id="L519">                    throw new IOException(cee.getMessage());</span>
<span class="nc" id="L520">                }</span>
            }
        }

        // Serialize the array of code signers (if any)
<span class="nc bnc" id="L525" title="All 4 branches missed.">        if (signers != null &amp;&amp; signers.length &gt; 0) {</span>
<span class="nc" id="L526">            oos.writeObject(signers);</span>
        }
<span class="nc" id="L528">    }</span>

    /**
     * Restores this object from a stream (i.e., deserializes it).
     */
    private void readObject(java.io.ObjectInputStream ois)
        throws IOException, ClassNotFoundException
    {
        CertificateFactory cf;
<span class="nc" id="L537">        Hashtable&lt;String, CertificateFactory&gt; cfs = null;</span>

<span class="nc" id="L539">        ois.defaultReadObject(); // location</span>

        // process any new-style certs in the stream (if present)
<span class="nc" id="L542">        int size = ois.readInt();</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (size &gt; 0) {</span>
            // we know of 3 different cert types: X.509, PGP, SDSI, which
            // could all be present in the stream at the same time
<span class="nc" id="L546">            cfs = new Hashtable&lt;String, CertificateFactory&gt;(3);</span>
<span class="nc" id="L547">            this.certs = new java.security.cert.Certificate[size];</span>
        }

<span class="nc bnc" id="L550" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
            // read the certificate type, and instantiate a certificate
            // factory of that type (reuse existing factory if possible)
<span class="nc" id="L553">            String certType = ois.readUTF();</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">            if (cfs.containsKey(certType)) {</span>
                // reuse certificate factory
<span class="nc" id="L556">                cf = cfs.get(certType);</span>
            } else {
                // create new certificate factory
                try {
<span class="nc" id="L560">                    cf = CertificateFactory.getInstance(certType);</span>
<span class="nc" id="L561">                } catch (CertificateException ce) {</span>
<span class="nc" id="L562">                    throw new ClassNotFoundException</span>
                        (&quot;Certificate factory for &quot; + certType + &quot; not found&quot;);
<span class="nc" id="L564">                }</span>
                // store the certificate factory so we can reuse it later
<span class="nc" id="L566">                cfs.put(certType, cf);</span>
            }
            // parse the certificate
<span class="nc" id="L569">            byte[] encoded = null;</span>
            try {
<span class="nc" id="L571">                encoded = new byte[ois.readInt()];</span>
<span class="nc" id="L572">            } catch (OutOfMemoryError oome) {</span>
<span class="nc" id="L573">                throw new IOException(&quot;Certificate too big&quot;);</span>
<span class="nc" id="L574">            }</span>
<span class="nc" id="L575">            ois.readFully(encoded);</span>
<span class="nc" id="L576">            ByteArrayInputStream bais = new ByteArrayInputStream(encoded);</span>
            try {
<span class="nc" id="L578">                this.certs[i] = cf.generateCertificate(bais);</span>
<span class="nc" id="L579">            } catch (CertificateException ce) {</span>
<span class="nc" id="L580">                throw new IOException(ce.getMessage());</span>
<span class="nc" id="L581">            }</span>
<span class="nc" id="L582">            bais.close();</span>
        }

        // Deserialize array of code signers (if any)
        try {
<span class="nc" id="L587">            this.signers = ((CodeSigner[])ois.readObject()).clone();</span>
<span class="nc" id="L588">        } catch (IOException ioe) {</span>
            // no signers present
<span class="nc" id="L590">        }</span>
<span class="nc" id="L591">    }</span>

    /*
     * Convert an array of certificates to an array of code signers.
     * The array of certificates is a concatenation of certificate chains
     * where the initial certificate in each chain is the end-entity cert.
     *
     * @return An array of code signers or null if none are generated.
     */
    private CodeSigner[] convertCertArrayToSignerArray(
        java.security.cert.Certificate[] certs) {

<span class="nc bnc" id="L603" title="All 2 branches missed.">        if (certs == null) {</span>
<span class="nc" id="L604">            return null;</span>
        }

        try {
            // Initialize certificate factory
<span class="nc bnc" id="L609" title="All 2 branches missed.">            if (factory == null) {</span>
<span class="nc" id="L610">                factory = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
            }

            // Iterate through all the certificates
<span class="nc" id="L614">            int i = 0;</span>
<span class="nc" id="L615">            List&lt;CodeSigner&gt; signers = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">            while (i &lt; certs.length) {</span>
<span class="nc" id="L617">                List&lt;java.security.cert.Certificate&gt; certChain =</span>
                        new ArrayList&lt;&gt;();
<span class="nc" id="L619">                certChain.add(certs[i++]); // first cert is an end-entity cert</span>
<span class="nc" id="L620">                int j = i;</span>

                // Extract chain of certificates
                // (loop while certs are not end-entity certs)
<span class="nc bnc" id="L624" title="All 4 branches missed.">                while (j &lt; certs.length &amp;&amp;</span>
                    certs[j] instanceof X509Certificate &amp;&amp;
<span class="nc bnc" id="L626" title="All 2 branches missed.">                    ((X509Certificate)certs[j]).getBasicConstraints() != -1) {</span>
<span class="nc" id="L627">                    certChain.add(certs[j]);</span>
<span class="nc" id="L628">                    j++;</span>
                }
<span class="nc" id="L630">                i = j;</span>
<span class="nc" id="L631">                CertPath certPath = factory.generateCertPath(certChain);</span>
<span class="nc" id="L632">                signers.add(new CodeSigner(certPath, null));</span>
<span class="nc" id="L633">            }</span>

<span class="nc bnc" id="L635" title="All 2 branches missed.">            if (signers.isEmpty()) {</span>
<span class="nc" id="L636">                return null;</span>
            } else {
<span class="nc" id="L638">                return signers.toArray(new CodeSigner[signers.size()]);</span>
            }

<span class="nc" id="L641">        } catch (CertificateException e) {</span>
<span class="nc" id="L642">            return null; //TODO - may be better to throw an ex. here</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>