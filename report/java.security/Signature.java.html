<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Signature.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">Signature.java</span></div><h1>Signature.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.security.spec.AlgorithmParameterSpec;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.io.*;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;

import java.nio.ByteBuffer;

import java.security.Provider.Service;

import javax.crypto.Cipher;
import javax.crypto.CipherSpi;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.BadPaddingException;
import javax.crypto.NoSuchPaddingException;

import sun.security.util.Debug;
import sun.security.jca.*;
import sun.security.jca.GetInstance.Instance;

/**
 * The Signature class is used to provide applications the functionality
 * of a digital signature algorithm. Digital signatures are used for
 * authentication and integrity assurance of digital data.
 *
 * &lt;p&gt; The signature algorithm can be, among others, the NIST standard
 * DSA, using DSA and SHA-1. The DSA algorithm using the
 * SHA-1 message digest algorithm can be specified as {@code SHA1withDSA}.
 * In the case of RSA, there are multiple choices for the message digest
 * algorithm, so the signing algorithm could be specified as, for example,
 * {@code MD2withRSA}, {@code MD5withRSA}, or {@code SHA1withRSA}.
 * The algorithm name must be specified, as there is no default.
 *
 * &lt;p&gt; A Signature object can be used to generate and verify digital
 * signatures.
 *
 * &lt;p&gt; There are three phases to the use of a Signature object for
 * either signing data or verifying a signature:&lt;ol&gt;
 *
 * &lt;li&gt;Initialization, with either
 *
 *     &lt;ul&gt;
 *
 *     &lt;li&gt;a public key, which initializes the signature for
 *     verification (see {@link #initVerify(PublicKey) initVerify}), or
 *
 *     &lt;li&gt;a private key (and optionally a Secure Random Number Generator),
 *     which initializes the signature for signing
 *     (see {@link #initSign(PrivateKey)}
 *     and {@link #initSign(PrivateKey, SecureRandom)}).
 *
 *     &lt;/ul&gt;
 *
 * &lt;li&gt;Updating
 *
 * &lt;p&gt;Depending on the type of initialization, this will update the
 * bytes to be signed or verified. See the
 * {@link #update(byte) update} methods.
 *
 * &lt;li&gt;Signing or Verifying a signature on all updated bytes. See the
 * {@link #sign() sign} methods and the {@link #verify(byte[]) verify}
 * method.
 *
 * &lt;/ol&gt;
 *
 * &lt;p&gt;Note that this class is abstract and extends from
 * {@code SignatureSpi} for historical reasons.
 * Application developers should only take notice of the methods defined in
 * this {@code Signature} class; all the methods in
 * the superclass are intended for cryptographic service providers who wish to
 * supply their own implementations of digital signature algorithms.
 *
 * &lt;p&gt; Every implementation of the Java platform is required to support the
 * following standard {@code Signature} algorithms:
 * &lt;ul&gt;
 * &lt;li&gt;{@code SHA1withDSA}&lt;/li&gt;
 * &lt;li&gt;{@code SHA1withRSA}&lt;/li&gt;
 * &lt;li&gt;{@code SHA256withRSA}&lt;/li&gt;
 * &lt;/ul&gt;
 * These algorithms are described in the &lt;a href=
 * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Signature&quot;&gt;
 * Signature section&lt;/a&gt; of the
 * Java Cryptography Architecture Standard Algorithm Name Documentation.
 * Consult the release documentation for your implementation to see if any
 * other algorithms are supported.
 *
 * @author Benjamin Renaud
 *
 */

public abstract class Signature extends SignatureSpi {

<span class="fc" id="L121">    private static final Debug debug =</span>
<span class="fc" id="L122">                        Debug.getInstance(&quot;jca&quot;, &quot;Signature&quot;);</span>

    /*
     * The algorithm for this signature object.
     * This value is used to map an OID to the particular algorithm.
     * The mapping is done in AlgorithmObject.algOID(String algorithm)
     */
    private String algorithm;

    // The provider
    Provider provider;

    /**
     * Possible {@link #state} value, signifying that
     * this signature object has not yet been initialized.
     */
    protected final static int UNINITIALIZED = 0;

    /**
     * Possible {@link #state} value, signifying that
     * this signature object has been initialized for signing.
     */
    protected final static int SIGN = 2;

    /**
     * Possible {@link #state} value, signifying that
     * this signature object has been initialized for verification.
     */
    protected final static int VERIFY = 3;

    /**
     * Current state of this signature object.
     */
<span class="fc" id="L155">    protected int state = UNINITIALIZED;</span>

    /**
     * Creates a Signature object for the specified algorithm.
     *
     * @param algorithm the standard string name of the algorithm.
     * See the Signature section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Signature&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     */
<span class="fc" id="L166">    protected Signature(String algorithm) {</span>
<span class="fc" id="L167">        this.algorithm = algorithm;</span>
<span class="fc" id="L168">    }</span>

    // name of the special signature alg
    private final static String RSA_SIGNATURE = &quot;NONEwithRSA&quot;;

    // name of the equivalent cipher alg
    private final static String RSA_CIPHER = &quot;RSA/ECB/PKCS1Padding&quot;;

    // all the services we need to lookup for compatibility with Cipher
<span class="fc" id="L177">    private final static List&lt;ServiceId&gt; rsaIds = Arrays.asList(</span>
        new ServiceId[] {
            new ServiceId(&quot;Signature&quot;, &quot;NONEwithRSA&quot;),
            new ServiceId(&quot;Cipher&quot;, &quot;RSA/ECB/PKCS1Padding&quot;),
            new ServiceId(&quot;Cipher&quot;, &quot;RSA/ECB&quot;),
            new ServiceId(&quot;Cipher&quot;, &quot;RSA//PKCS1Padding&quot;),
            new ServiceId(&quot;Cipher&quot;, &quot;RSA&quot;),
        }
    );

    /**
     * Returns a Signature object that implements the specified signature
     * algorithm.
     *
     * &lt;p&gt; This method traverses the list of registered security Providers,
     * starting with the most preferred Provider.
     * A new Signature object encapsulating the
     * SignatureSpi implementation from the first
     * Provider that supports the specified algorithm is returned.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param algorithm the standard name of the algorithm requested.
     * See the Signature section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Signature&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @return the new Signature object.
     *
     * @exception NoSuchAlgorithmException if no Provider supports a
     *          Signature implementation for the
     *          specified algorithm.
     *
     * @see Provider
     */
    public static Signature getInstance(String algorithm)
            throws NoSuchAlgorithmException {
        List&lt;Service&gt; list;
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {</span>
<span class="fc" id="L218">            list = GetInstance.getServices(rsaIds);</span>
        } else {
<span class="fc" id="L220">            list = GetInstance.getServices(&quot;Signature&quot;, algorithm);</span>
        }
<span class="fc" id="L222">        Iterator&lt;Service&gt; t = list.iterator();</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if (t.hasNext() == false) {</span>
<span class="nc" id="L224">            throw new NoSuchAlgorithmException</span>
                (algorithm + &quot; Signature not available&quot;);
        }
        // try services until we find an Spi or a working Signature subclass
        NoSuchAlgorithmException failure;
        do {
<span class="fc" id="L230">            Service s = t.next();</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (isSpi(s)) {</span>
<span class="fc" id="L232">                return new Delegate(s, t, algorithm);</span>
            } else {
                // must be a subclass of Signature, disable dynamic selection
                try {
<span class="fc" id="L236">                    Instance instance =</span>
<span class="fc" id="L237">                        GetInstance.getInstance(s, SignatureSpi.class);</span>
<span class="fc" id="L238">                    return getInstance(instance, algorithm);</span>
<span class="fc" id="L239">                } catch (NoSuchAlgorithmException e) {</span>
<span class="fc" id="L240">                    failure = e;</span>
                }
            }
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        } while (t.hasNext());</span>
<span class="nc" id="L244">        throw failure;</span>
    }

    private static Signature getInstance(Instance instance, String algorithm) {
        Signature sig;
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (instance.impl instanceof Signature) {</span>
<span class="fc" id="L250">            sig = (Signature)instance.impl;</span>
<span class="fc" id="L251">            sig.algorithm = algorithm;</span>
        } else {
<span class="fc" id="L253">            SignatureSpi spi = (SignatureSpi)instance.impl;</span>
<span class="fc" id="L254">            sig = new Delegate(spi, algorithm);</span>
        }
<span class="fc" id="L256">        sig.provider = instance.provider;</span>
<span class="fc" id="L257">        return sig;</span>
    }

    private final static Map&lt;String,Boolean&gt; signatureInfo;

    static {
<span class="fc" id="L263">        signatureInfo = new ConcurrentHashMap&lt;String,Boolean&gt;();</span>
<span class="fc" id="L264">        Boolean TRUE = Boolean.TRUE;</span>
        // pre-initialize with values for our SignatureSpi implementations
<span class="fc" id="L266">        signatureInfo.put(&quot;sun.security.provider.DSA$RawDSA&quot;, TRUE);</span>
<span class="fc" id="L267">        signatureInfo.put(&quot;sun.security.provider.DSA$SHA1withDSA&quot;, TRUE);</span>
<span class="fc" id="L268">        signatureInfo.put(&quot;sun.security.rsa.RSASignature$MD2withRSA&quot;, TRUE);</span>
<span class="fc" id="L269">        signatureInfo.put(&quot;sun.security.rsa.RSASignature$MD5withRSA&quot;, TRUE);</span>
<span class="fc" id="L270">        signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA1withRSA&quot;, TRUE);</span>
<span class="fc" id="L271">        signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA256withRSA&quot;, TRUE);</span>
<span class="fc" id="L272">        signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA384withRSA&quot;, TRUE);</span>
<span class="fc" id="L273">        signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA512withRSA&quot;, TRUE);</span>
<span class="fc" id="L274">        signatureInfo.put(&quot;com.sun.net.ssl.internal.ssl.RSASignature&quot;, TRUE);</span>
<span class="fc" id="L275">        signatureInfo.put(&quot;sun.security.pkcs11.P11Signature&quot;, TRUE);</span>
<span class="fc" id="L276">    }</span>

    private static boolean isSpi(Service s) {
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (s.getType().equals(&quot;Cipher&quot;)) {</span>
            // must be a CipherSpi, which we can wrap with the CipherAdapter
<span class="fc" id="L281">            return true;</span>
        }
<span class="fc" id="L283">        String className = s.getClassName();</span>
<span class="fc" id="L284">        Boolean result = signatureInfo.get(className);</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (result == null) {</span>
            try {
<span class="fc" id="L287">                Object instance = s.newInstance(null);</span>
                // Signature extends SignatureSpi
                // so it is a &quot;real&quot; Spi if it is an
                // instance of SignatureSpi but not Signature
<span class="pc bpc" id="L291" title="1 of 4 branches missed.">                boolean r = (instance instanceof SignatureSpi)</span>
                                &amp;&amp; (instance instanceof Signature == false);
<span class="pc bpc" id="L293" title="3 of 4 branches missed.">                if ((debug != null) &amp;&amp; (r == false)) {</span>
<span class="nc" id="L294">                    debug.println(&quot;Not a SignatureSpi &quot; + className);</span>
<span class="nc" id="L295">                    debug.println(&quot;Delayed provider selection may not be &quot;</span>
<span class="nc" id="L296">                        + &quot;available for algorithm &quot; + s.getAlgorithm());</span>
                }
<span class="fc" id="L298">                result = Boolean.valueOf(r);</span>
<span class="fc" id="L299">                signatureInfo.put(className, result);</span>
<span class="fc" id="L300">            } catch (Exception e) {</span>
                // something is wrong, assume not an SPI
<span class="fc" id="L302">                return false;</span>
<span class="fc" id="L303">            }</span>
        }
<span class="fc" id="L305">        return result.booleanValue();</span>
    }

    /**
     * Returns a Signature object that implements the specified signature
     * algorithm.
     *
     * &lt;p&gt; A new Signature object encapsulating the
     * SignatureSpi implementation from the specified provider
     * is returned.  The specified provider must be registered
     * in the security provider list.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param algorithm the name of the algorithm requested.
     * See the Signature section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Signature&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @param provider the name of the provider.
     *
     * @return the new Signature object.
     *
     * @exception NoSuchAlgorithmException if a SignatureSpi
     *          implementation for the specified algorithm is not
     *          available from the specified provider.
     *
     * @exception NoSuchProviderException if the specified provider is not
     *          registered in the security provider list.
     *
     * @exception IllegalArgumentException if the provider name is null
     *          or empty.
     *
     * @see Provider
     */
    public static Signature getInstance(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {</span>
            // exception compatibility with existing code
<span class="nc bnc" id="L346" title="All 4 branches missed.">            if ((provider == null) || (provider.length() == 0)) {</span>
<span class="nc" id="L347">                throw new IllegalArgumentException(&quot;missing provider&quot;);</span>
            }
<span class="nc" id="L349">            Provider p = Security.getProvider(provider);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (p == null) {</span>
<span class="nc" id="L351">                throw new NoSuchProviderException</span>
                    (&quot;no such provider: &quot; + provider);
            }
<span class="nc" id="L354">            return getInstanceRSA(p);</span>
        }
<span class="fc" id="L356">        Instance instance = GetInstance.getInstance</span>
<span class="fc" id="L357">                (&quot;Signature&quot;, SignatureSpi.class, algorithm, provider);</span>
<span class="fc" id="L358">        return getInstance(instance, algorithm);</span>
    }

    /**
     * Returns a Signature object that implements the specified
     * signature algorithm.
     *
     * &lt;p&gt; A new Signature object encapsulating the
     * SignatureSpi implementation from the specified Provider
     * object is returned.  Note that the specified Provider object
     * does not have to be registered in the provider list.
     *
     * @param algorithm the name of the algorithm requested.
     * See the Signature section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Signature&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @param provider the provider.
     *
     * @return the new Signature object.
     *
     * @exception NoSuchAlgorithmException if a SignatureSpi
     *          implementation for the specified algorithm is not available
     *          from the specified Provider object.
     *
     * @exception IllegalArgumentException if the provider is null.
     *
     * @see Provider
     *
     * @since 1.4
     */
    public static Signature getInstance(String algorithm, Provider provider)
            throws NoSuchAlgorithmException {
<span class="pc bpc" id="L392" title="1 of 2 branches missed.">        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {</span>
            // exception compatibility with existing code
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (provider == null) {</span>
<span class="nc" id="L395">                throw new IllegalArgumentException(&quot;missing provider&quot;);</span>
            }
<span class="nc" id="L397">            return getInstanceRSA(provider);</span>
        }
<span class="fc" id="L399">        Instance instance = GetInstance.getInstance</span>
<span class="fc" id="L400">                (&quot;Signature&quot;, SignatureSpi.class, algorithm, provider);</span>
<span class="fc" id="L401">        return getInstance(instance, algorithm);</span>
    }

    // return an implementation for NONEwithRSA, which is a special case
    // because of the Cipher.RSA/ECB/PKCS1Padding compatibility wrapper
    private static Signature getInstanceRSA(Provider p)
            throws NoSuchAlgorithmException {
        // try Signature first
<span class="nc" id="L409">        Service s = p.getService(&quot;Signature&quot;, RSA_SIGNATURE);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (s != null) {</span>
<span class="nc" id="L411">            Instance instance = GetInstance.getInstance(s, SignatureSpi.class);</span>
<span class="nc" id="L412">            return getInstance(instance, RSA_SIGNATURE);</span>
        }
        // check Cipher
        try {
<span class="nc" id="L416">            Cipher c = Cipher.getInstance(RSA_CIPHER, p);</span>
<span class="nc" id="L417">            return new Delegate(new CipherAdapter(c), RSA_SIGNATURE);</span>
<span class="nc" id="L418">        } catch (GeneralSecurityException e) {</span>
            // throw Signature style exception message to avoid confusion,
            // but append Cipher exception as cause
<span class="nc" id="L421">            throw new NoSuchAlgorithmException(&quot;no such algorithm: &quot;</span>
<span class="nc" id="L422">                + RSA_SIGNATURE + &quot; for provider &quot; + p.getName(), e);</span>
        }
    }

    /**
     * Returns the provider of this signature object.
     *
     * @return the provider of this signature object
     */
    public final Provider getProvider() {
<span class="fc" id="L432">        chooseFirstProvider();</span>
<span class="fc" id="L433">        return this.provider;</span>
    }

    void chooseFirstProvider() {
        // empty, overridden in Delegate
<span class="fc" id="L438">    }</span>

    /**
     * Initializes this object for verification. If this method is called
     * again with a different argument, it negates the effect
     * of this call.
     *
     * @param publicKey the public key of the identity whose signature is
     * going to be verified.
     *
     * @exception InvalidKeyException if the key is invalid.
     */
    public final void initVerify(PublicKey publicKey)
            throws InvalidKeyException {
<span class="fc" id="L452">        engineInitVerify(publicKey);</span>
<span class="fc" id="L453">        state = VERIFY;</span>
<span class="fc" id="L454">    }</span>

    /**
     * Initializes this object for verification, using the public key from
     * the given certificate.
     * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
     * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
     * extension field implies that the public key in
     * the certificate and its corresponding private key are not
     * supposed to be used for digital signatures, an
     * {@code InvalidKeyException} is thrown.
     *
     * @param certificate the certificate of the identity whose signature is
     * going to be verified.
     *
     * @exception InvalidKeyException  if the public key in the certificate
     * is not encoded properly or does not include required  parameter
     * information or cannot be used for digital signature purposes.
     * @since 1.3
     */
    public final void initVerify(Certificate certificate)
            throws InvalidKeyException {
        // If the certificate is of type X509Certificate,
        // we should check whether it has a Key Usage
        // extension marked as critical.
<span class="nc bnc" id="L479" title="All 2 branches missed.">        if (certificate instanceof java.security.cert.X509Certificate) {</span>
            // Check whether the cert has a key usage extension
            // marked as a critical extension.
            // The OID for KeyUsage extension is 2.5.29.15.
<span class="nc" id="L483">            X509Certificate cert = (X509Certificate)certificate;</span>
<span class="nc" id="L484">            Set&lt;String&gt; critSet = cert.getCriticalExtensionOIDs();</span>

<span class="nc bnc" id="L486" title="All 4 branches missed.">            if (critSet != null &amp;&amp; !critSet.isEmpty()</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                &amp;&amp; critSet.contains(&quot;2.5.29.15&quot;)) {</span>
<span class="nc" id="L488">                boolean[] keyUsageInfo = cert.getKeyUsage();</span>
                // keyUsageInfo[0] is for digitalSignature.
<span class="nc bnc" id="L490" title="All 4 branches missed.">                if ((keyUsageInfo != null) &amp;&amp; (keyUsageInfo[0] == false))</span>
<span class="nc" id="L491">                    throw new InvalidKeyException(&quot;Wrong key usage&quot;);</span>
            }
        }

<span class="nc" id="L495">        PublicKey publicKey = certificate.getPublicKey();</span>
<span class="nc" id="L496">        engineInitVerify(publicKey);</span>
<span class="nc" id="L497">        state = VERIFY;</span>
<span class="nc" id="L498">    }</span>

    /**
     * Initialize this object for signing. If this method is called
     * again with a different argument, it negates the effect
     * of this call.
     *
     * @param privateKey the private key of the identity whose signature
     * is going to be generated.
     *
     * @exception InvalidKeyException if the key is invalid.
     */
    public final void initSign(PrivateKey privateKey)
            throws InvalidKeyException {
<span class="fc" id="L512">        engineInitSign(privateKey);</span>
<span class="fc" id="L513">        state = SIGN;</span>
<span class="fc" id="L514">    }</span>

    /**
     * Initialize this object for signing. If this method is called
     * again with a different argument, it negates the effect
     * of this call.
     *
     * @param privateKey the private key of the identity whose signature
     * is going to be generated.
     *
     * @param random the source of randomness for this signature.
     *
     * @exception InvalidKeyException if the key is invalid.
     */
    public final void initSign(PrivateKey privateKey, SecureRandom random)
            throws InvalidKeyException {
<span class="fc" id="L530">        engineInitSign(privateKey, random);</span>
<span class="fc" id="L531">        state = SIGN;</span>
<span class="fc" id="L532">    }</span>

    /**
     * Returns the signature bytes of all the data updated.
     * The format of the signature depends on the underlying
     * signature scheme.
     *
     * &lt;p&gt;A call to this method resets this signature object to the state
     * it was in when previously initialized for signing via a
     * call to {@code initSign(PrivateKey)}. That is, the object is
     * reset and available to generate another signature from the same
     * signer, if desired, via new calls to {@code update} and
     * {@code sign}.
     *
     * @return the signature bytes of the signing operation's result.
     *
     * @exception SignatureException if this signature object is not
     * initialized properly or if this signature algorithm is unable to
     * process the input data provided.
     */
    public final byte[] sign() throws SignatureException {
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">        if (state == SIGN) {</span>
<span class="fc" id="L554">            return engineSign();</span>
        }
<span class="nc" id="L556">        throw new SignatureException(&quot;object not initialized for &quot; +</span>
                                     &quot;signing&quot;);
    }

    /**
     * Finishes the signature operation and stores the resulting signature
     * bytes in the provided buffer {@code outbuf}, starting at
     * {@code offset}.
     * The format of the signature depends on the underlying
     * signature scheme.
     *
     * &lt;p&gt;This signature object is reset to its initial state (the state it
     * was in after a call to one of the {@code initSign} methods) and
     * can be reused to generate further signatures with the same private key.
     *
     * @param outbuf buffer for the signature result.
     *
     * @param offset offset into {@code outbuf} where the signature is
     * stored.
     *
     * @param len number of bytes within {@code outbuf} allotted for the
     * signature.
     *
     * @return the number of bytes placed into {@code outbuf}.
     *
     * @exception SignatureException if this signature object is not
     * initialized properly, if this signature algorithm is unable to
     * process the input data provided, or if {@code len} is less
     * than the actual signature length.
     *
     * @since 1.2
     */
    public final int sign(byte[] outbuf, int offset, int len)
        throws SignatureException {
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if (outbuf == null) {</span>
<span class="nc" id="L591">            throw new IllegalArgumentException(&quot;No output buffer given&quot;);</span>
        }
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (outbuf.length - offset &lt; len) {</span>
<span class="nc" id="L594">            throw new IllegalArgumentException</span>
                (&quot;Output buffer too small for specified offset and length&quot;);
        }
<span class="nc bnc" id="L597" title="All 2 branches missed.">        if (state != SIGN) {</span>
<span class="nc" id="L598">            throw new SignatureException(&quot;object not initialized for &quot; +</span>
                                         &quot;signing&quot;);
        }
<span class="nc" id="L601">        return engineSign(outbuf, offset, len);</span>
    }

    /**
     * Verifies the passed-in signature.
     *
     * &lt;p&gt;A call to this method resets this signature object to the state
     * it was in when previously initialized for verification via a
     * call to {@code initVerify(PublicKey)}. That is, the object is
     * reset and available to verify another signature from the identity
     * whose public key was specified in the call to {@code initVerify}.
     *
     * @param signature the signature bytes to be verified.
     *
     * @return true if the signature was verified, false if not.
     *
     * @exception SignatureException if this signature object is not
     * initialized properly, the passed-in signature is improperly
     * encoded or of the wrong type, if this signature algorithm is unable to
     * process the input data provided, etc.
     */
    public final boolean verify(byte[] signature) throws SignatureException {
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">        if (state == VERIFY) {</span>
<span class="fc" id="L624">            return engineVerify(signature);</span>
        }
<span class="nc" id="L626">        throw new SignatureException(&quot;object not initialized for &quot; +</span>
                                     &quot;verification&quot;);
    }

    /**
     * Verifies the passed-in signature in the specified array
     * of bytes, starting at the specified offset.
     *
     * &lt;p&gt;A call to this method resets this signature object to the state
     * it was in when previously initialized for verification via a
     * call to {@code initVerify(PublicKey)}. That is, the object is
     * reset and available to verify another signature from the identity
     * whose public key was specified in the call to {@code initVerify}.
     *
     *
     * @param signature the signature bytes to be verified.
     * @param offset the offset to start from in the array of bytes.
     * @param length the number of bytes to use, starting at offset.
     *
     * @return true if the signature was verified, false if not.
     *
     * @exception SignatureException if this signature object is not
     * initialized properly, the passed-in signature is improperly
     * encoded or of the wrong type, if this signature algorithm is unable to
     * process the input data provided, etc.
     * @exception IllegalArgumentException if the {@code signature}
     * byte array is null, or the {@code offset} or {@code length}
     * is less than 0, or the sum of the {@code offset} and
     * {@code length} is greater than the length of the
     * {@code signature} byte array.
     * @since 1.4
     */
    public final boolean verify(byte[] signature, int offset, int length)
        throws SignatureException {
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">        if (state == VERIFY) {</span>
<span class="pc bpc" id="L661" title="4 of 8 branches missed.">            if ((signature == null) || (offset &lt; 0) || (length &lt; 0) ||</span>
                (length &gt; signature.length - offset)) {
<span class="nc" id="L663">                throw new IllegalArgumentException(&quot;Bad arguments&quot;);</span>
            }

<span class="fc" id="L666">            return engineVerify(signature, offset, length);</span>
        }
<span class="nc" id="L668">        throw new SignatureException(&quot;object not initialized for &quot; +</span>
                                     &quot;verification&quot;);
    }

    /**
     * Updates the data to be signed or verified by a byte.
     *
     * @param b the byte to use for the update.
     *
     * @exception SignatureException if this signature object is not
     * initialized properly.
     */
    public final void update(byte b) throws SignatureException {
<span class="pc bpc" id="L681" title="1 of 4 branches missed.">        if (state == VERIFY || state == SIGN) {</span>
<span class="fc" id="L682">            engineUpdate(b);</span>
        } else {
<span class="nc" id="L684">            throw new SignatureException(&quot;object not initialized for &quot;</span>
                                         + &quot;signature or verification&quot;);
        }
<span class="fc" id="L687">    }</span>

    /**
     * Updates the data to be signed or verified, using the specified
     * array of bytes.
     *
     * @param data the byte array to use for the update.
     *
     * @exception SignatureException if this signature object is not
     * initialized properly.
     */
    public final void update(byte[] data) throws SignatureException {
<span class="fc" id="L699">        update(data, 0, data.length);</span>
<span class="fc" id="L700">    }</span>

    /**
     * Updates the data to be signed or verified, using the specified
     * array of bytes, starting at the specified offset.
     *
     * @param data the array of bytes.
     * @param off the offset to start from in the array of bytes.
     * @param len the number of bytes to use, starting at offset.
     *
     * @exception SignatureException if this signature object is not
     * initialized properly.
     */
    public final void update(byte[] data, int off, int len)
            throws SignatureException {
<span class="pc bpc" id="L715" title="1 of 4 branches missed.">        if (state == SIGN || state == VERIFY) {</span>
<span class="fc" id="L716">            engineUpdate(data, off, len);</span>
        } else {
<span class="nc" id="L718">            throw new SignatureException(&quot;object not initialized for &quot;</span>
                                         + &quot;signature or verification&quot;);
        }
<span class="fc" id="L721">    }</span>

    /**
     * Updates the data to be signed or verified using the specified
     * ByteBuffer. Processes the {@code data.remaining()} bytes
     * starting at at {@code data.position()}.
     * Upon return, the buffer's position will be equal to its limit;
     * its limit will not have changed.
     *
     * @param data the ByteBuffer
     *
     * @exception SignatureException if this signature object is not
     * initialized properly.
     * @since 1.5
     */
    public final void update(ByteBuffer data) throws SignatureException {
<span class="nc bnc" id="L737" title="All 4 branches missed.">        if ((state != SIGN) &amp;&amp; (state != VERIFY)) {</span>
<span class="nc" id="L738">            throw new SignatureException(&quot;object not initialized for &quot;</span>
                                         + &quot;signature or verification&quot;);
        }
<span class="nc bnc" id="L741" title="All 2 branches missed.">        if (data == null) {</span>
<span class="nc" id="L742">            throw new NullPointerException();</span>
        }
<span class="nc" id="L744">        engineUpdate(data);</span>
<span class="nc" id="L745">    }</span>

    /**
     * Returns the name of the algorithm for this signature object.
     *
     * @return the name of the algorithm for this signature object.
     */
    public final String getAlgorithm() {
<span class="fc" id="L753">        return this.algorithm;</span>
    }

    /**
     * Returns a string representation of this signature object,
     * providing information that includes the state of the object
     * and the name of the algorithm used.
     *
     * @return a string representation of this signature object.
     */
    public String toString() {
<span class="nc" id="L764">        String initState = &quot;&quot;;</span>
<span class="nc bnc" id="L765" title="All 4 branches missed.">        switch (state) {</span>
        case UNINITIALIZED:
<span class="nc" id="L767">            initState = &quot;&lt;not initialized&gt;&quot;;</span>
<span class="nc" id="L768">            break;</span>
        case VERIFY:
<span class="nc" id="L770">            initState = &quot;&lt;initialized for verifying&gt;&quot;;</span>
<span class="nc" id="L771">            break;</span>
        case SIGN:
<span class="nc" id="L773">            initState = &quot;&lt;initialized for signing&gt;&quot;;</span>
            break;
        }
<span class="nc" id="L776">        return &quot;Signature object: &quot; + getAlgorithm() + initState;</span>
    }

    /**
     * Sets the specified algorithm parameter to the specified value.
     * This method supplies a general-purpose mechanism through
     * which it is possible to set the various parameters of this object.
     * A parameter may be any settable parameter for the algorithm, such as
     * a parameter size, or a source of random bits for signature generation
     * (if appropriate), or an indication of whether or not to perform
     * a specific but optional computation. A uniform algorithm-specific
     * naming scheme for each parameter is desirable but left unspecified
     * at this time.
     *
     * @param param the string identifier of the parameter.
     * @param value the parameter value.
     *
     * @exception InvalidParameterException if {@code param} is an
     * invalid parameter for this signature algorithm engine,
     * the parameter is already set
     * and cannot be set again, a security exception occurs, and so on.
     *
     * @see #getParameter
     *
     * @deprecated Use
     * {@link #setParameter(java.security.spec.AlgorithmParameterSpec)
     * setParameter}.
     */
    @Deprecated
    public final void setParameter(String param, Object value)
            throws InvalidParameterException {
<span class="fc" id="L807">        engineSetParameter(param, value);</span>
<span class="fc" id="L808">    }</span>

    /**
     * Initializes this signature engine with the specified parameter set.
     *
     * @param params the parameters
     *
     * @exception InvalidAlgorithmParameterException if the given parameters
     * are inappropriate for this signature engine
     *
     * @see #getParameters
     */
    public final void setParameter(AlgorithmParameterSpec params)
            throws InvalidAlgorithmParameterException {
<span class="nc" id="L822">        engineSetParameter(params);</span>
<span class="nc" id="L823">    }</span>

    /**
     * Returns the parameters used with this signature object.
     *
     * &lt;p&gt;The returned parameters may be the same that were used to initialize
     * this signature, or may contain a combination of default and randomly
     * generated parameter values used by the underlying signature
     * implementation if this signature requires algorithm parameters but
     * was not initialized with any.
     *
     * @return the parameters used with this signature, or null if this
     * signature does not use any parameters.
     *
     * @see #setParameter(AlgorithmParameterSpec)
     * @since 1.4
     */
    public final AlgorithmParameters getParameters() {
<span class="nc" id="L841">        return engineGetParameters();</span>
    }

    /**
     * Gets the value of the specified algorithm parameter. This method
     * supplies a general-purpose mechanism through which it is possible to
     * get the various parameters of this object. A parameter may be any
     * settable parameter for the algorithm, such as a parameter size, or
     * a source of random bits for signature generation (if appropriate),
     * or an indication of whether or not to perform a specific but optional
     * computation. A uniform algorithm-specific naming scheme for each
     * parameter is desirable but left unspecified at this time.
     *
     * @param param the string name of the parameter.
     *
     * @return the object that represents the parameter value, or null if
     * there is none.
     *
     * @exception InvalidParameterException if {@code param} is an invalid
     * parameter for this engine, or another exception occurs while
     * trying to get this parameter.
     *
     * @see #setParameter(String, Object)
     *
     * @deprecated
     */
    @Deprecated
    public final Object getParameter(String param)
            throws InvalidParameterException {
<span class="nc" id="L870">        return engineGetParameter(param);</span>
    }

    /**
     * Returns a clone if the implementation is cloneable.
     *
     * @return a clone if the implementation is cloneable.
     *
     * @exception CloneNotSupportedException if this is called
     * on an implementation that does not support {@code Cloneable}.
     */
    public Object clone() throws CloneNotSupportedException {
<span class="nc bnc" id="L882" title="All 2 branches missed.">        if (this instanceof Cloneable) {</span>
<span class="nc" id="L883">            return super.clone();</span>
        } else {
<span class="nc" id="L885">            throw new CloneNotSupportedException();</span>
        }
    }

    /*
     * The following class allows providers to extend from SignatureSpi
     * rather than from Signature. It represents a Signature with an
     * encapsulated, provider-supplied SPI object (of type SignatureSpi).
     * If the provider implementation is an instance of SignatureSpi, the
     * getInstance() methods above return an instance of this class, with
     * the SPI object encapsulated.
     *
     * Note: All SPI methods from the original Signature class have been
     * moved up the hierarchy into a new class (SignatureSpi), which has
     * been interposed in the hierarchy between the API (Signature)
     * and its original parent (Object).
     */

    @SuppressWarnings(&quot;deprecation&quot;)
    private static class Delegate extends Signature {

        // The provider implementation (delegate)
        // filled in once the provider is selected
        private SignatureSpi sigSpi;

        // lock for mutex during provider selection
        private final Object lock;

        // next service to try in provider selection
        // null once provider is selected
        private Service firstService;

        // remaining services to try in provider selection
        // null once provider is selected
        private Iterator&lt;Service&gt; serviceIterator;

        // constructor
        Delegate(SignatureSpi sigSpi, String algorithm) {
<span class="fc" id="L923">            super(algorithm);</span>
<span class="fc" id="L924">            this.sigSpi = sigSpi;</span>
<span class="fc" id="L925">            this.lock = null; // no lock needed</span>
<span class="fc" id="L926">        }</span>

        // used with delayed provider selection
        Delegate(Service service,
                        Iterator&lt;Service&gt; iterator, String algorithm) {
<span class="fc" id="L931">            super(algorithm);</span>
<span class="fc" id="L932">            this.firstService = service;</span>
<span class="fc" id="L933">            this.serviceIterator = iterator;</span>
<span class="fc" id="L934">            this.lock = new Object();</span>
<span class="fc" id="L935">        }</span>

        /**
         * Returns a clone if the delegate is cloneable.
         *
         * @return a clone if the delegate is cloneable.
         *
         * @exception CloneNotSupportedException if this is called on a
         * delegate that does not support {@code Cloneable}.
         */
        public Object clone() throws CloneNotSupportedException {
<span class="nc" id="L946">            chooseFirstProvider();</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">            if (sigSpi instanceof Cloneable) {</span>
<span class="nc" id="L948">                SignatureSpi sigSpiClone = (SignatureSpi)sigSpi.clone();</span>
                // Because 'algorithm' and 'provider' are private
                // members of our supertype, we must perform a cast to
                // access them.
<span class="nc" id="L952">                Signature that =</span>
<span class="nc" id="L953">                    new Delegate(sigSpiClone, ((Signature)this).algorithm);</span>
<span class="nc" id="L954">                that.provider = ((Signature)this).provider;</span>
<span class="nc" id="L955">                return that;</span>
            } else {
<span class="nc" id="L957">                throw new CloneNotSupportedException();</span>
            }
        }

        private static SignatureSpi newInstance(Service s)
                throws NoSuchAlgorithmException {
<span class="fc bfc" id="L963" title="All 2 branches covered.">            if (s.getType().equals(&quot;Cipher&quot;)) {</span>
                // must be NONEwithRSA
                try {
<span class="fc" id="L966">                    Cipher c = Cipher.getInstance(RSA_CIPHER, s.getProvider());</span>
<span class="fc" id="L967">                    return new CipherAdapter(c);</span>
<span class="nc" id="L968">                } catch (NoSuchPaddingException e) {</span>
<span class="nc" id="L969">                    throw new NoSuchAlgorithmException(e);</span>
                }
            } else {
<span class="fc" id="L972">                Object o = s.newInstance(null);</span>
<span class="pc bpc" id="L973" title="1 of 2 branches missed.">                if (o instanceof SignatureSpi == false) {</span>
<span class="nc" id="L974">                    throw new NoSuchAlgorithmException</span>
<span class="nc" id="L975">                        (&quot;Not a SignatureSpi: &quot; + o.getClass().getName());</span>
                }
<span class="fc" id="L977">                return (SignatureSpi)o;</span>
            }
        }

        // max number of debug warnings to print from chooseFirstProvider()
<span class="fc" id="L982">        private static int warnCount = 10;</span>

        /**
         * Choose the Spi from the first provider available. Used if
         * delayed provider selection is not possible because initSign()/
         * initVerify() is not the first method called.
         */
        void chooseFirstProvider() {
<span class="fc bfc" id="L990" title="All 2 branches covered.">            if (sigSpi != null) {</span>
<span class="fc" id="L991">                return;</span>
            }
<span class="fc" id="L993">            synchronized (lock) {</span>
<span class="pc bpc" id="L994" title="1 of 2 branches missed.">                if (sigSpi != null) {</span>
<span class="nc" id="L995">                    return;</span>
                }
<span class="pc bpc" id="L997" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L998">                    int w = --warnCount;</span>
<span class="nc bnc" id="L999" title="All 2 branches missed.">                    if (w &gt;= 0) {</span>
<span class="nc" id="L1000">                        debug.println(&quot;Signature.init() not first method &quot;</span>
                            + &quot;called, disabling delayed provider selection&quot;);
<span class="nc bnc" id="L1002" title="All 2 branches missed.">                        if (w == 0) {</span>
<span class="nc" id="L1003">                            debug.println(&quot;Further warnings of this type will &quot;</span>
                                + &quot;be suppressed&quot;);
                        }
<span class="nc" id="L1006">                        new Exception(&quot;Call trace&quot;).printStackTrace();</span>
                    }
                }
<span class="fc" id="L1009">                Exception lastException = null;</span>
<span class="pc bpc" id="L1010" title="3 of 4 branches missed.">                while ((firstService != null) || serviceIterator.hasNext()) {</span>
                    Service s;
<span class="pc bpc" id="L1012" title="1 of 2 branches missed.">                    if (firstService != null) {</span>
<span class="fc" id="L1013">                        s = firstService;</span>
<span class="fc" id="L1014">                        firstService = null;</span>
                    } else {
<span class="nc" id="L1016">                        s = serviceIterator.next();</span>
                    }
<span class="pc bpc" id="L1018" title="1 of 2 branches missed.">                    if (isSpi(s) == false) {</span>
<span class="nc" id="L1019">                        continue;</span>
                    }
                    try {
<span class="fc" id="L1022">                        sigSpi = newInstance(s);</span>
<span class="fc" id="L1023">                        provider = s.getProvider();</span>
                        // not needed any more
<span class="fc" id="L1025">                        firstService = null;</span>
<span class="fc" id="L1026">                        serviceIterator = null;</span>
<span class="fc" id="L1027">                        return;</span>
<span class="nc" id="L1028">                    } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L1029">                        lastException = e;</span>
                    }
<span class="nc" id="L1031">                }</span>
<span class="nc" id="L1032">                ProviderException e = new ProviderException</span>
                        (&quot;Could not construct SignatureSpi instance&quot;);
<span class="nc bnc" id="L1034" title="All 2 branches missed.">                if (lastException != null) {</span>
<span class="nc" id="L1035">                    e.initCause(lastException);</span>
                }
<span class="nc" id="L1037">                throw e;</span>
<span class="nc" id="L1038">            }</span>
        }

        private void chooseProvider(int type, Key key, SecureRandom random)
                throws InvalidKeyException {
<span class="fc" id="L1043">            synchronized (lock) {</span>
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">                if (sigSpi != null) {</span>
<span class="nc" id="L1045">                    init(sigSpi, type, key, random);</span>
<span class="nc" id="L1046">                    return;</span>
                }
<span class="fc" id="L1048">                Exception lastException = null;</span>
<span class="fc bfc" id="L1049" title="All 4 branches covered.">                while ((firstService != null) || serviceIterator.hasNext()) {</span>
                    Service s;
<span class="fc bfc" id="L1051" title="All 2 branches covered.">                    if (firstService != null) {</span>
<span class="fc" id="L1052">                        s = firstService;</span>
<span class="fc" id="L1053">                        firstService = null;</span>
                    } else {
<span class="fc" id="L1055">                        s = serviceIterator.next();</span>
                    }
                    // if provider says it does not support this key, ignore it
<span class="fc bfc" id="L1058" title="All 2 branches covered.">                    if (s.supportsParameter(key) == false) {</span>
<span class="fc" id="L1059">                        continue;</span>
                    }
                    // if instance is not a SignatureSpi, ignore it
<span class="fc bfc" id="L1062" title="All 2 branches covered.">                    if (isSpi(s) == false) {</span>
<span class="fc" id="L1063">                        continue;</span>
                    }
                    try {
<span class="fc" id="L1066">                        SignatureSpi spi = newInstance(s);</span>
<span class="fc" id="L1067">                        init(spi, type, key, random);</span>
<span class="fc" id="L1068">                        provider = s.getProvider();</span>
<span class="fc" id="L1069">                        sigSpi = spi;</span>
<span class="fc" id="L1070">                        firstService = null;</span>
<span class="fc" id="L1071">                        serviceIterator = null;</span>
<span class="fc" id="L1072">                        return;</span>
<span class="fc" id="L1073">                    } catch (Exception e) {</span>
                        // NoSuchAlgorithmException from newInstance()
                        // InvalidKeyException from init()
                        // RuntimeException (ProviderException) from init()
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">                        if (lastException == null) {</span>
<span class="fc" id="L1078">                            lastException = e;</span>
                        }
                    }
<span class="fc" id="L1081">                }</span>
                // no working provider found, fail
<span class="fc bfc" id="L1083" title="All 2 branches covered.">                if (lastException instanceof InvalidKeyException) {</span>
<span class="fc" id="L1084">                    throw (InvalidKeyException)lastException;</span>
                }
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">                if (lastException instanceof RuntimeException) {</span>
<span class="nc" id="L1087">                    throw (RuntimeException)lastException;</span>
                }
<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">                String k = (key != null) ? key.getClass().getName() : &quot;(null)&quot;;</span>
<span class="fc" id="L1090">                throw new InvalidKeyException</span>
                    (&quot;No installed provider supports this key: &quot;
                    + k, lastException);
<span class="fc" id="L1093">            }</span>
        }

        private final static int I_PUB     = 1;
        private final static int I_PRIV    = 2;
        private final static int I_PRIV_SR = 3;

        private void init(SignatureSpi spi, int type, Key  key,
                SecureRandom random) throws InvalidKeyException {
<span class="pc bpc" id="L1102" title="1 of 4 branches missed.">            switch (type) {</span>
            case I_PUB:
<span class="fc" id="L1104">                spi.engineInitVerify((PublicKey)key);</span>
<span class="fc" id="L1105">                break;</span>
            case I_PRIV:
<span class="fc" id="L1107">                spi.engineInitSign((PrivateKey)key);</span>
<span class="fc" id="L1108">                break;</span>
            case I_PRIV_SR:
<span class="fc" id="L1110">                spi.engineInitSign((PrivateKey)key, random);</span>
<span class="fc" id="L1111">                break;</span>
            default:
<span class="nc" id="L1113">                throw new AssertionError(&quot;Internal error: &quot; + type);</span>
            }
<span class="fc" id="L1115">        }</span>

        protected void engineInitVerify(PublicKey publicKey)
                throws InvalidKeyException {
<span class="fc bfc" id="L1119" title="All 2 branches covered.">            if (sigSpi != null) {</span>
<span class="fc" id="L1120">                sigSpi.engineInitVerify(publicKey);</span>
            } else {
<span class="fc" id="L1122">                chooseProvider(I_PUB, publicKey, null);</span>
            }
<span class="fc" id="L1124">        }</span>

        protected void engineInitSign(PrivateKey privateKey)
                throws InvalidKeyException {
<span class="fc bfc" id="L1128" title="All 2 branches covered.">            if (sigSpi != null) {</span>
<span class="fc" id="L1129">                sigSpi.engineInitSign(privateKey);</span>
            } else {
<span class="fc" id="L1131">                chooseProvider(I_PRIV, privateKey, null);</span>
            }
<span class="fc" id="L1133">        }</span>

        protected void engineInitSign(PrivateKey privateKey, SecureRandom sr)
                throws InvalidKeyException {
<span class="fc bfc" id="L1137" title="All 2 branches covered.">            if (sigSpi != null) {</span>
<span class="fc" id="L1138">                sigSpi.engineInitSign(privateKey, sr);</span>
            } else {
<span class="fc" id="L1140">                chooseProvider(I_PRIV_SR, privateKey, sr);</span>
            }
<span class="fc" id="L1142">        }</span>

        protected void engineUpdate(byte b) throws SignatureException {
<span class="fc" id="L1145">            chooseFirstProvider();</span>
<span class="fc" id="L1146">            sigSpi.engineUpdate(b);</span>
<span class="fc" id="L1147">        }</span>

        protected void engineUpdate(byte[] b, int off, int len)
                throws SignatureException {
<span class="fc" id="L1151">            chooseFirstProvider();</span>
<span class="fc" id="L1152">            sigSpi.engineUpdate(b, off, len);</span>
<span class="fc" id="L1153">        }</span>

        protected void engineUpdate(ByteBuffer data) {
<span class="nc" id="L1156">            chooseFirstProvider();</span>
<span class="nc" id="L1157">            sigSpi.engineUpdate(data);</span>
<span class="nc" id="L1158">        }</span>

        protected byte[] engineSign() throws SignatureException {
<span class="fc" id="L1161">            chooseFirstProvider();</span>
<span class="fc" id="L1162">            return sigSpi.engineSign();</span>
        }

        protected int engineSign(byte[] outbuf, int offset, int len)
                throws SignatureException {
<span class="nc" id="L1167">            chooseFirstProvider();</span>
<span class="nc" id="L1168">            return sigSpi.engineSign(outbuf, offset, len);</span>
        }

        protected boolean engineVerify(byte[] sigBytes)
                throws SignatureException {
<span class="fc" id="L1173">            chooseFirstProvider();</span>
<span class="fc" id="L1174">            return sigSpi.engineVerify(sigBytes);</span>
        }

        protected boolean engineVerify(byte[] sigBytes, int offset, int length)
                throws SignatureException {
<span class="fc" id="L1179">            chooseFirstProvider();</span>
<span class="fc" id="L1180">            return sigSpi.engineVerify(sigBytes, offset, length);</span>
        }

        protected void engineSetParameter(String param, Object value)
                throws InvalidParameterException {
<span class="fc" id="L1185">            chooseFirstProvider();</span>
<span class="fc" id="L1186">            sigSpi.engineSetParameter(param, value);</span>
<span class="fc" id="L1187">        }</span>

        protected void engineSetParameter(AlgorithmParameterSpec params)
                throws InvalidAlgorithmParameterException {
<span class="nc" id="L1191">            chooseFirstProvider();</span>
<span class="nc" id="L1192">            sigSpi.engineSetParameter(params);</span>
<span class="nc" id="L1193">        }</span>

        protected Object engineGetParameter(String param)
                throws InvalidParameterException {
<span class="nc" id="L1197">            chooseFirstProvider();</span>
<span class="nc" id="L1198">            return sigSpi.engineGetParameter(param);</span>
        }

        protected AlgorithmParameters engineGetParameters() {
<span class="nc" id="L1202">            chooseFirstProvider();</span>
<span class="nc" id="L1203">            return sigSpi.engineGetParameters();</span>
        }
    }

    // adapter for RSA/ECB/PKCS1Padding ciphers
    @SuppressWarnings(&quot;deprecation&quot;)
    private static class CipherAdapter extends SignatureSpi {

        private final Cipher cipher;

        private ByteArrayOutputStream data;

<span class="fc" id="L1215">        CipherAdapter(Cipher cipher) {</span>
<span class="fc" id="L1216">            this.cipher = cipher;</span>
<span class="fc" id="L1217">        }</span>

        protected void engineInitVerify(PublicKey publicKey)
                throws InvalidKeyException {
<span class="fc" id="L1221">            cipher.init(Cipher.DECRYPT_MODE, publicKey);</span>
<span class="pc bpc" id="L1222" title="1 of 2 branches missed.">            if (data == null) {</span>
<span class="fc" id="L1223">                data = new ByteArrayOutputStream(128);</span>
            } else {
<span class="nc" id="L1225">                data.reset();</span>
            }
<span class="fc" id="L1227">        }</span>

        protected void engineInitSign(PrivateKey privateKey)
                throws InvalidKeyException {
<span class="nc" id="L1231">            cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span>
<span class="nc" id="L1232">            data = null;</span>
<span class="nc" id="L1233">        }</span>

        protected void engineInitSign(PrivateKey privateKey,
                SecureRandom random) throws InvalidKeyException {
<span class="fc" id="L1237">            cipher.init(Cipher.ENCRYPT_MODE, privateKey, random);</span>
<span class="fc" id="L1238">            data = null;</span>
<span class="fc" id="L1239">        }</span>

        protected void engineUpdate(byte b) throws SignatureException {
<span class="nc" id="L1242">            engineUpdate(new byte[] {b}, 0, 1);</span>
<span class="nc" id="L1243">        }</span>

        protected void engineUpdate(byte[] b, int off, int len)
                throws SignatureException {
<span class="fc bfc" id="L1247" title="All 2 branches covered.">            if (data != null) {</span>
<span class="fc" id="L1248">                data.write(b, off, len);</span>
<span class="fc" id="L1249">                return;</span>
            }
<span class="fc" id="L1251">            byte[] out = cipher.update(b, off, len);</span>
<span class="pc bpc" id="L1252" title="2 of 4 branches missed.">            if ((out != null) &amp;&amp; (out.length != 0)) {</span>
<span class="nc" id="L1253">                throw new SignatureException</span>
                    (&quot;Cipher unexpectedly returned data&quot;);
            }
<span class="fc" id="L1256">        }</span>

        protected byte[] engineSign() throws SignatureException {
            try {
<span class="fc" id="L1260">                return cipher.doFinal();</span>
<span class="nc" id="L1261">            } catch (IllegalBlockSizeException e) {</span>
<span class="nc" id="L1262">                throw new SignatureException(&quot;doFinal() failed&quot;, e);</span>
<span class="nc" id="L1263">            } catch (BadPaddingException e) {</span>
<span class="nc" id="L1264">                throw new SignatureException(&quot;doFinal() failed&quot;, e);</span>
            }
        }

        protected boolean engineVerify(byte[] sigBytes)
                throws SignatureException {
            try {
<span class="fc" id="L1271">                byte[] out = cipher.doFinal(sigBytes);</span>
<span class="fc" id="L1272">                byte[] dataBytes = data.toByteArray();</span>
<span class="fc" id="L1273">                data.reset();</span>
<span class="fc" id="L1274">                return Arrays.equals(out, dataBytes);</span>
<span class="nc" id="L1275">            } catch (BadPaddingException e) {</span>
                // e.g. wrong public key used
                // return false rather than throwing exception
<span class="nc" id="L1278">                return false;</span>
<span class="nc" id="L1279">            } catch (IllegalBlockSizeException e) {</span>
<span class="nc" id="L1280">                throw new SignatureException(&quot;doFinal() failed&quot;, e);</span>
            }
        }

        protected void engineSetParameter(String param, Object value)
                throws InvalidParameterException {
<span class="nc" id="L1286">            throw new InvalidParameterException(&quot;Parameters not supported&quot;);</span>
        }

        protected Object engineGetParameter(String param)
                throws InvalidParameterException {
<span class="nc" id="L1291">            throw new InvalidParameterException(&quot;Parameters not supported&quot;);</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>