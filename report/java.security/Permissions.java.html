<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Permissions.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">Permissions.java</span></div><h1>Permissions.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.NoSuchElementException;
import java.util.Map;
import java.util.HashMap;
import java.util.List;
import java.util.Iterator;
import java.util.Collections;
import java.io.Serializable;
import java.io.ObjectStreamField;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;


/**
 * This class represents a heterogeneous collection of Permissions. That is,
 * it contains different types of Permission objects, organized into
 * PermissionCollections. For example, if any
 * {@code java.io.FilePermission} objects are added to an instance of
 * this class, they are all stored in a single
 * PermissionCollection. It is the PermissionCollection returned by a call to
 * the {@code newPermissionCollection} method in the FilePermission class.
 * Similarly, any {@code java.lang.RuntimePermission} objects are
 * stored in the PermissionCollection returned by a call to the
 * {@code newPermissionCollection} method in the
 * RuntimePermission class. Thus, this class represents a collection of
 * PermissionCollections.
 *
 * &lt;p&gt;When the {@code add} method is called to add a Permission, the
 * Permission is stored in the appropriate PermissionCollection. If no such
 * collection exists yet, the Permission object's class is determined and the
 * {@code newPermissionCollection} method is called on that class to create
 * the PermissionCollection and add it to the Permissions object. If
 * {@code newPermissionCollection} returns null, then a default
 * PermissionCollection that uses a hashtable will be created and used. Each
 * hashtable entry stores a Permission object as both the key and the value.
 *
 * &lt;p&gt; Enumerations returned via the {@code elements} method are
 * not &lt;em&gt;fail-fast&lt;/em&gt;.  Modifications to a collection should not be
 * performed while enumerating over that collection.
 *
 * @see Permission
 * @see PermissionCollection
 * @see AllPermission
 *
 *
 * @author Marianne Mueller
 * @author Roland Schemers
 *
 * @serial exclude
 */

public final class Permissions extends PermissionCollection
implements Serializable
{
    /**
     * Key is permissions Class, value is PermissionCollection for that class.
     * Not serialized; see serialization section at end of class.
     */
    private transient Map&lt;Class&lt;?&gt;, PermissionCollection&gt; permsMap;

    // optimization. keep track of whether unresolved permissions need to be
    // checked
<span class="fc" id="L92">    private transient boolean hasUnresolved = false;</span>

    // optimization. keep track of the AllPermission collection
    // - package private for ProtectionDomain optimization
    PermissionCollection allPermission;

    /**
     * Creates a new Permissions object containing no PermissionCollections.
     */
<span class="fc" id="L101">    public Permissions() {</span>
<span class="fc" id="L102">        permsMap = new HashMap&lt;Class&lt;?&gt;, PermissionCollection&gt;(11);</span>
<span class="fc" id="L103">        allPermission = null;</span>
<span class="fc" id="L104">    }</span>

    /**
     * Adds a permission object to the PermissionCollection for the class the
     * permission belongs to. For example, if &lt;i&gt;permission&lt;/i&gt; is a
     * FilePermission, it is added to the FilePermissionCollection stored
     * in this Permissions object.
     *
     * This method creates
     * a new PermissionCollection object (and adds the permission to it)
     * if an appropriate collection does not yet exist. &lt;p&gt;
     *
     * @param permission the Permission object to add.
     *
     * @exception SecurityException if this Permissions object is
     * marked as readonly.
     *
     * @see PermissionCollection#isReadOnly()
     */

    public void add(Permission permission) {
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (isReadOnly())</span>
<span class="nc" id="L126">            throw new SecurityException(</span>
              &quot;attempt to add a Permission to a readonly Permissions object&quot;);

        PermissionCollection pc;

<span class="fc" id="L131">        synchronized (this) {</span>
<span class="fc" id="L132">            pc = getPermissionCollection(permission, true);</span>
<span class="fc" id="L133">            pc.add(permission);</span>
<span class="pc" id="L134">        }</span>

        // No sync; staleness -&gt; optimizations delayed, which is OK
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (permission instanceof AllPermission) {</span>
<span class="fc" id="L138">            allPermission = pc;</span>
        }
<span class="fc bfc" id="L140" title="All 2 branches covered.">        if (permission instanceof UnresolvedPermission) {</span>
<span class="fc" id="L141">            hasUnresolved = true;</span>
        }
<span class="fc" id="L143">    }</span>

    /**
     * Checks to see if this object's PermissionCollection for permissions of
     * the specified permission's class implies the permissions
     * expressed in the &lt;i&gt;permission&lt;/i&gt; object. Returns true if the
     * combination of permissions in the appropriate PermissionCollection
     * (e.g., a FilePermissionCollection for a FilePermission) together
     * imply the specified permission.
     *
     * &lt;p&gt;For example, suppose there is a FilePermissionCollection in this
     * Permissions object, and it contains one FilePermission that specifies
     * &quot;read&quot; access for  all files in all subdirectories of the &quot;/tmp&quot;
     * directory, and another FilePermission that specifies &quot;write&quot; access
     * for all files in the &quot;/tmp/scratch/foo&quot; directory.
     * Then if the {@code implies} method
     * is called with a permission specifying both &quot;read&quot; and &quot;write&quot; access
     * to files in the &quot;/tmp/scratch/foo&quot; directory, {@code true} is
     * returned.
     *
     * &lt;p&gt;Additionally, if this PermissionCollection contains the
     * AllPermission, this method will always return true.
     * &lt;p&gt;
     * @param permission the Permission object to check.
     *
     * @return true if &quot;permission&quot; is implied by the permissions in the
     * PermissionCollection it
     * belongs to, false if not.
     */

    public boolean implies(Permission permission) {
        // No sync; staleness -&gt; skip optimization, which is OK
<span class="fc bfc" id="L175" title="All 2 branches covered.">        if (allPermission != null) {</span>
<span class="fc" id="L176">            return true; // AllPermission has already been added</span>
        } else {
<span class="fc" id="L178">            synchronized (this) {</span>
<span class="fc" id="L179">                PermissionCollection pc = getPermissionCollection(permission,</span>
                    false);
<span class="fc bfc" id="L181" title="All 2 branches covered.">                if (pc != null) {</span>
<span class="fc" id="L182">                    return pc.implies(permission);</span>
                } else {
                    // none found
<span class="fc" id="L185">                    return false;</span>
                }
<span class="nc" id="L187">            }</span>
        }
    }

    /**
     * Returns an enumeration of all the Permission objects in all the
     * PermissionCollections in this Permissions object.
     *
     * @return an enumeration of all the Permissions.
     */

    public Enumeration&lt;Permission&gt; elements() {
        // go through each Permissions in the hash table
        // and call their elements() function.

<span class="fc" id="L202">        synchronized (this) {</span>
<span class="fc" id="L203">            return new PermissionsEnumerator(permsMap.values().iterator());</span>
<span class="nc" id="L204">        }</span>
    }

    /**
     * Gets the PermissionCollection in this Permissions object for
     * permissions whose type is the same as that of &lt;i&gt;p&lt;/i&gt;.
     * For example, if &lt;i&gt;p&lt;/i&gt; is a FilePermission,
     * the FilePermissionCollection
     * stored in this Permissions object will be returned.
     *
     * If createEmpty is true,
     * this method creates a new PermissionCollection object for the specified
     * type of permission objects if one does not yet exist.
     * To do so, it first calls the {@code newPermissionCollection} method
     * on &lt;i&gt;p&lt;/i&gt;.  Subclasses of class Permission
     * override that method if they need to store their permissions in a
     * particular PermissionCollection object in order to provide the
     * correct semantics when the {@code PermissionCollection.implies}
     * method is called.
     * If the call returns a PermissionCollection, that collection is stored
     * in this Permissions object. If the call returns null and createEmpty
     * is true, then
     * this method instantiates and stores a default PermissionCollection
     * that uses a hashtable to store its permission objects.
     *
     * createEmpty is ignored when creating empty PermissionCollection
     * for unresolved permissions because of the overhead of determining the
     * PermissionCollection to use.
     *
     * createEmpty should be set to false when this method is invoked from
     * implies() because it incurs the additional overhead of creating and
     * adding an empty PermissionCollection that will just return false.
     * It should be set to true when invoked from add().
     */
    private PermissionCollection getPermissionCollection(Permission p,
        boolean createEmpty) {
<span class="fc" id="L240">        Class&lt;?&gt; c = p.getClass();</span>

<span class="fc" id="L242">        PermissionCollection pc = permsMap.get(c);</span>

<span class="fc bfc" id="L244" title="All 4 branches covered.">        if (!hasUnresolved &amp;&amp; !createEmpty) {</span>
<span class="fc" id="L245">            return pc;</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        } else if (pc == null) {</span>

            // Check for unresolved permissions
<span class="fc bfc" id="L249" title="All 2 branches covered.">            pc = (hasUnresolved ? getUnresolvedPermissions(p) : null);</span>

            // if still null, create a new collection
<span class="fc bfc" id="L252" title="All 4 branches covered.">            if (pc == null &amp;&amp; createEmpty) {</span>

<span class="fc" id="L254">                pc = p.newPermissionCollection();</span>

                // still no PermissionCollection?
                // We'll give them a PermissionsHash.
<span class="fc bfc" id="L258" title="All 2 branches covered.">                if (pc == null)</span>
<span class="fc" id="L259">                    pc = new PermissionsHash();</span>
            }

<span class="fc bfc" id="L262" title="All 2 branches covered.">            if (pc != null) {</span>
<span class="fc" id="L263">                permsMap.put(c, pc);</span>
            }
        }
<span class="fc" id="L266">        return pc;</span>
    }

    /**
     * Resolves any unresolved permissions of type p.
     *
     * @param p the type of unresolved permission to resolve
     *
     * @return PermissionCollection containing the unresolved permissions,
     *  or null if there were no unresolved permissions of type p.
     *
     */
    private PermissionCollection getUnresolvedPermissions(Permission p)
    {
        // Called from within synchronized method so permsMap doesn't need lock

<span class="fc" id="L282">        UnresolvedPermissionCollection uc =</span>
<span class="fc" id="L283">        (UnresolvedPermissionCollection) permsMap.get(UnresolvedPermission.class);</span>

        // we have no unresolved permissions if uc is null
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (uc == null)</span>
<span class="nc" id="L287">            return null;</span>

<span class="fc" id="L289">        List&lt;UnresolvedPermission&gt; unresolvedPerms =</span>
<span class="fc" id="L290">                                        uc.getUnresolvedPermissions(p);</span>

        // we have no unresolved permissions of this type if unresolvedPerms is null
<span class="fc bfc" id="L293" title="All 2 branches covered.">        if (unresolvedPerms == null)</span>
<span class="fc" id="L294">            return null;</span>

<span class="fc" id="L296">        java.security.cert.Certificate certs[] = null;</span>

<span class="fc" id="L298">        Object signers[] = p.getClass().getSigners();</span>

<span class="fc" id="L300">        int n = 0;</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (signers != null) {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            for (int j=0; j &lt; signers.length; j++) {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if (signers[j] instanceof java.security.cert.Certificate) {</span>
<span class="nc" id="L304">                    n++;</span>
                }
            }
<span class="nc" id="L307">            certs = new java.security.cert.Certificate[n];</span>
<span class="nc" id="L308">            n = 0;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            for (int j=0; j &lt; signers.length; j++) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                if (signers[j] instanceof java.security.cert.Certificate) {</span>
<span class="nc" id="L311">                    certs[n++] = (java.security.cert.Certificate)signers[j];</span>
                }
            }
        }

<span class="fc" id="L316">        PermissionCollection pc = null;</span>
<span class="fc" id="L317">        synchronized (unresolvedPerms) {</span>
<span class="fc" id="L318">            int len = unresolvedPerms.size();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L320">                UnresolvedPermission up = unresolvedPerms.get(i);</span>
<span class="fc" id="L321">                Permission perm = up.resolve(p, certs);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">                if (perm != null) {</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">                    if (pc == null) {</span>
<span class="fc" id="L324">                        pc = p.newPermissionCollection();</span>
<span class="fc bfc" id="L325" title="All 2 branches covered.">                        if (pc == null)</span>
<span class="fc" id="L326">                            pc = new PermissionsHash();</span>
                    }
<span class="fc" id="L328">                    pc.add(perm);</span>
                }
            }
<span class="pc" id="L331">        }</span>
<span class="fc" id="L332">        return pc;</span>
    }

    private static final long serialVersionUID = 4858622370623524688L;

    // Need to maintain serialization interoperability with earlier releases,
    // which had the serializable field:
    // private Hashtable perms;

    /**
     * @serialField perms java.util.Hashtable
     *     A table of the Permission classes and PermissionCollections.
     * @serialField allPermission java.security.PermissionCollection
     */
<span class="fc" id="L346">    private static final ObjectStreamField[] serialPersistentFields = {</span>
        new ObjectStreamField(&quot;perms&quot;, Hashtable.class),
        new ObjectStreamField(&quot;allPermission&quot;, PermissionCollection.class),
    };

    /**
     * @serialData Default fields.
     */
    /*
     * Writes the contents of the permsMap field out as a Hashtable for
     * serialization compatibility with earlier releases. allPermission
     * unchanged.
     */
    private void writeObject(ObjectOutputStream out) throws IOException {
        // Don't call out.defaultWriteObject()

        // Copy perms into a Hashtable
<span class="nc" id="L363">        Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; perms =</span>
<span class="nc" id="L364">            new Hashtable&lt;&gt;(permsMap.size()*2); // no sync; estimate</span>
<span class="nc" id="L365">        synchronized (this) {</span>
<span class="nc" id="L366">            perms.putAll(permsMap);</span>
<span class="nc" id="L367">        }</span>

        // Write out serializable fields
<span class="nc" id="L370">        ObjectOutputStream.PutField pfields = out.putFields();</span>

<span class="nc" id="L372">        pfields.put(&quot;allPermission&quot;, allPermission); // no sync; staleness OK</span>
<span class="nc" id="L373">        pfields.put(&quot;perms&quot;, perms);</span>
<span class="nc" id="L374">        out.writeFields();</span>
<span class="nc" id="L375">    }</span>

    /*
     * Reads in a Hashtable of Class/PermissionCollections and saves them in the
     * permsMap field. Reads in allPermission.
     */
    private void readObject(ObjectInputStream in) throws IOException,
    ClassNotFoundException {
        // Don't call defaultReadObject()

        // Read in serialized fields
<span class="nc" id="L386">        ObjectInputStream.GetField gfields = in.readFields();</span>

        // Get allPermission
<span class="nc" id="L389">        allPermission = (PermissionCollection) gfields.get(&quot;allPermission&quot;, null);</span>

        // Get permissions
        // writeObject writes a Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; for
        // the perms key, so this cast is safe, unless the data is corrupt.
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L395">        Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; perms =</span>
<span class="nc" id="L396">            (Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt;)gfields.get(&quot;perms&quot;, null);</span>
<span class="nc" id="L397">        permsMap = new HashMap&lt;Class&lt;?&gt;, PermissionCollection&gt;(perms.size()*2);</span>
<span class="nc" id="L398">        permsMap.putAll(perms);</span>

        // Set hasUnresolved
<span class="nc" id="L401">        UnresolvedPermissionCollection uc =</span>
<span class="nc" id="L402">        (UnresolvedPermissionCollection) permsMap.get(UnresolvedPermission.class);</span>
<span class="nc bnc" id="L403" title="All 4 branches missed.">        hasUnresolved = (uc != null &amp;&amp; uc.elements().hasMoreElements());</span>
<span class="nc" id="L404">    }</span>
}

final class PermissionsEnumerator implements Enumeration&lt;Permission&gt; {

    // all the perms
    private Iterator&lt;PermissionCollection&gt; perms;
    // the current set
    private Enumeration&lt;Permission&gt; permset;

<span class="fc" id="L414">    PermissionsEnumerator(Iterator&lt;PermissionCollection&gt; e) {</span>
<span class="fc" id="L415">        perms = e;</span>
<span class="fc" id="L416">        permset = getNextEnumWithMore();</span>
<span class="fc" id="L417">    }</span>

    // No need to synchronize; caller should sync on object as required
    public boolean hasMoreElements() {
        // if we enter with permissionimpl null, we know
        // there are no more left.

<span class="fc bfc" id="L424" title="All 2 branches covered.">        if (permset == null)</span>
<span class="fc" id="L425">            return  false;</span>

        // try to see if there are any left in the current one

<span class="fc bfc" id="L429" title="All 2 branches covered.">        if (permset.hasMoreElements())</span>
<span class="fc" id="L430">            return true;</span>

        // get the next one that has something in it...
<span class="fc" id="L433">        permset = getNextEnumWithMore();</span>

        // if it is null, we are done!
<span class="fc bfc" id="L436" title="All 2 branches covered.">        return (permset != null);</span>
    }

    // No need to synchronize; caller should sync on object as required
    public Permission nextElement() {

        // hasMoreElements will update permset to the next permset
        // with something in it...

<span class="pc bpc" id="L445" title="1 of 2 branches missed.">        if (hasMoreElements()) {</span>
<span class="fc" id="L446">            return permset.nextElement();</span>
        } else {
<span class="nc" id="L448">            throw new NoSuchElementException(&quot;PermissionsEnumerator&quot;);</span>
        }

    }

    private Enumeration&lt;Permission&gt; getNextEnumWithMore() {
<span class="fc bfc" id="L454" title="All 2 branches covered.">        while (perms.hasNext()) {</span>
<span class="fc" id="L455">            PermissionCollection pc = perms.next();</span>
<span class="fc" id="L456">            Enumeration&lt;Permission&gt; next =pc.elements();</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">            if (next.hasMoreElements())</span>
<span class="fc" id="L458">                return next;</span>
<span class="nc" id="L459">        }</span>
<span class="fc" id="L460">        return null;</span>

    }
}

/**
 * A PermissionsHash stores a homogeneous set of permissions in a hashtable.
 *
 * @see Permission
 * @see Permissions
 *
 *
 * @author Roland Schemers
 *
 * @serial include
 */

final class PermissionsHash extends PermissionCollection
implements Serializable
{
    /**
     * Key and value are (same) permissions objects.
     * Not serialized; see serialization section at end of class.
     */
    private transient Map&lt;Permission, Permission&gt; permsMap;

    /**
     * Create an empty PermissionsHash object.
     */

<span class="fc" id="L490">    PermissionsHash() {</span>
<span class="fc" id="L491">        permsMap = new HashMap&lt;Permission, Permission&gt;(11);</span>
<span class="fc" id="L492">    }</span>

    /**
     * Adds a permission to the PermissionsHash.
     *
     * @param permission the Permission object to add.
     */

    public void add(Permission permission) {
<span class="fc" id="L501">        synchronized (this) {</span>
<span class="fc" id="L502">            permsMap.put(permission, permission);</span>
<span class="pc" id="L503">        }</span>
<span class="fc" id="L504">    }</span>

    /**
     * Check and see if this set of permissions implies the permissions
     * expressed in &quot;permission&quot;.
     *
     * @param permission the Permission object to compare
     *
     * @return true if &quot;permission&quot; is a proper subset of a permission in
     * the set, false if not.
     */

    public boolean implies(Permission permission) {
        // attempt a fast lookup and implies. If that fails
        // then enumerate through all the permissions.
<span class="fc" id="L519">        synchronized (this) {</span>
<span class="fc" id="L520">            Permission p = permsMap.get(permission);</span>

            // If permission is found, then p.equals(permission)
<span class="fc bfc" id="L523" title="All 2 branches covered.">            if (p == null) {</span>
<span class="fc bfc" id="L524" title="All 2 branches covered.">                for (Permission p_ : permsMap.values()) {</span>
<span class="fc bfc" id="L525" title="All 2 branches covered.">                    if (p_.implies(permission))</span>
<span class="fc" id="L526">                        return true;</span>
<span class="fc" id="L527">                }</span>
<span class="fc" id="L528">                return false;</span>
            } else {
<span class="fc" id="L530">                return true;</span>
            }
<span class="nc" id="L532">        }</span>
    }

    /**
     * Returns an enumeration of all the Permission objects in the container.
     *
     * @return an enumeration of all the Permissions.
     */

    public Enumeration&lt;Permission&gt; elements() {
        // Convert Iterator of Map values into an Enumeration
<span class="nc" id="L543">        synchronized (this) {</span>
<span class="nc" id="L544">            return Collections.enumeration(permsMap.values());</span>
<span class="nc" id="L545">        }</span>
    }

    private static final long serialVersionUID = -8491988220802933440L;
    // Need to maintain serialization interoperability with earlier releases,
    // which had the serializable field:
    // private Hashtable perms;
    /**
     * @serialField perms java.util.Hashtable
     *     A table of the Permissions (both key and value are same).
     */
<span class="fc" id="L556">    private static final ObjectStreamField[] serialPersistentFields = {</span>
        new ObjectStreamField(&quot;perms&quot;, Hashtable.class),
    };

    /**
     * @serialData Default fields.
     */
    /*
     * Writes the contents of the permsMap field out as a Hashtable for
     * serialization compatibility with earlier releases.
     */
    private void writeObject(ObjectOutputStream out) throws IOException {
        // Don't call out.defaultWriteObject()

        // Copy perms into a Hashtable
<span class="nc" id="L571">        Hashtable&lt;Permission, Permission&gt; perms =</span>
<span class="nc" id="L572">                new Hashtable&lt;&gt;(permsMap.size()*2);</span>
<span class="nc" id="L573">        synchronized (this) {</span>
<span class="nc" id="L574">            perms.putAll(permsMap);</span>
<span class="nc" id="L575">        }</span>

        // Write out serializable fields
<span class="nc" id="L578">        ObjectOutputStream.PutField pfields = out.putFields();</span>
<span class="nc" id="L579">        pfields.put(&quot;perms&quot;, perms);</span>
<span class="nc" id="L580">        out.writeFields();</span>
<span class="nc" id="L581">    }</span>

    /*
     * Reads in a Hashtable of Permission/Permission and saves them in the
     * permsMap field.
     */
    private void readObject(ObjectInputStream in) throws IOException,
    ClassNotFoundException {
        // Don't call defaultReadObject()

        // Read in serialized fields
<span class="nc" id="L592">        ObjectInputStream.GetField gfields = in.readFields();</span>

        // Get permissions
        // writeObject writes a Hashtable&lt;Class&lt;?&gt;, PermissionCollection&gt; for
        // the perms key, so this cast is safe, unless the data is corrupt.
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L598">        Hashtable&lt;Permission, Permission&gt; perms =</span>
<span class="nc" id="L599">                (Hashtable&lt;Permission, Permission&gt;)gfields.get(&quot;perms&quot;, null);</span>
<span class="nc" id="L600">        permsMap = new HashMap&lt;Permission, Permission&gt;(perms.size()*2);</span>
<span class="nc" id="L601">        permsMap.putAll(perms);</span>
<span class="nc" id="L602">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>