<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>KeyStore.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">KeyStore.java</span></div><h1>KeyStore.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.io.*;
import java.net.URI;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.security.cert.CertificateException;
import java.security.spec.AlgorithmParameterSpec;
import java.util.*;
import javax.crypto.SecretKey;

import javax.security.auth.DestroyFailedException;
import javax.security.auth.callback.*;

/**
 * This class represents a storage facility for cryptographic
 * keys and certificates.
 *
 * &lt;p&gt; A {@code KeyStore} manages different types of entries.
 * Each type of entry implements the {@code KeyStore.Entry} interface.
 * Three basic {@code KeyStore.Entry} implementations are provided:
 *
 * &lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;KeyStore.PrivateKeyEntry&lt;/b&gt;
 * &lt;p&gt; This type of entry holds a cryptographic {@code PrivateKey},
 * which is optionally stored in a protected format to prevent
 * unauthorized access.  It is also accompanied by a certificate chain
 * for the corresponding public key.
 *
 * &lt;p&gt; Private keys and certificate chains are used by a given entity for
 * self-authentication. Applications for this authentication include software
 * distribution organizations which sign JAR files as part of releasing
 * and/or licensing software.
 *
 * &lt;li&gt;&lt;b&gt;KeyStore.SecretKeyEntry&lt;/b&gt;
 * &lt;p&gt; This type of entry holds a cryptographic {@code SecretKey},
 * which is optionally stored in a protected format to prevent
 * unauthorized access.
 *
 * &lt;li&gt;&lt;b&gt;KeyStore.TrustedCertificateEntry&lt;/b&gt;
 * &lt;p&gt; This type of entry contains a single public key {@code Certificate}
 * belonging to another party. It is called a &lt;i&gt;trusted certificate&lt;/i&gt;
 * because the keystore owner trusts that the public key in the certificate
 * indeed belongs to the identity identified by the &lt;i&gt;subject&lt;/i&gt; (owner)
 * of the certificate.
 *
 * &lt;p&gt;This type of entry can be used to authenticate other parties.
 * &lt;/ul&gt;
 *
 * &lt;p&gt; Each entry in a keystore is identified by an &quot;alias&quot; string. In the
 * case of private keys and their associated certificate chains, these strings
 * distinguish among the different ways in which the entity may authenticate
 * itself. For example, the entity may authenticate itself using different
 * certificate authorities, or using different public key algorithms.
 *
 * &lt;p&gt; Whether aliases are case sensitive is implementation dependent. In order
 * to avoid problems, it is recommended not to use aliases in a KeyStore that
 * only differ in case.
 *
 * &lt;p&gt; Whether keystores are persistent, and the mechanisms used by the
 * keystore if it is persistent, are not specified here. This allows
 * use of a variety of techniques for protecting sensitive (e.g., private or
 * secret) keys. Smart cards or other integrated cryptographic engines
 * (SafeKeyper) are one option, and simpler mechanisms such as files may also
 * be used (in a variety of formats).
 *
 * &lt;p&gt; Typical ways to request a KeyStore object include
 * relying on the default type and providing a specific keystore type.
 *
 * &lt;ul&gt;
 * &lt;li&gt;To rely on the default type:
 * &lt;pre&gt;
 *    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
 * &lt;/pre&gt;
 * The system will return a keystore implementation for the default type.
 *
 * &lt;li&gt;To provide a specific keystore type:
 * &lt;pre&gt;
 *      KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
 * &lt;/pre&gt;
 * The system will return the most preferred implementation of the
 * specified keystore type available in the environment. &lt;p&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt; Before a keystore can be accessed, it must be
 * {@link #load(java.io.InputStream, char[]) loaded}.
 * &lt;pre&gt;
 *    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
 *
 *    // get user password and file input stream
 *    char[] password = getPassword();
 *
 *    try (FileInputStream fis = new FileInputStream(&quot;keyStoreName&quot;)) {
 *        ks.load(fis, password);
 *    }
 * &lt;/pre&gt;
 *
 * To create an empty keystore using the above {@code load} method,
 * pass {@code null} as the {@code InputStream} argument.
 *
 * &lt;p&gt; Once the keystore has been loaded, it is possible
 * to read existing entries from the keystore, or to write new entries
 * into the keystore:
 * &lt;pre&gt;
 *    KeyStore.ProtectionParameter protParam =
 *        new KeyStore.PasswordProtection(password);
 *
 *    // get my private key
 *    KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry)
 *        ks.getEntry(&quot;privateKeyAlias&quot;, protParam);
 *    PrivateKey myPrivateKey = pkEntry.getPrivateKey();
 *
 *    // save my secret key
 *    javax.crypto.SecretKey mySecretKey;
 *    KeyStore.SecretKeyEntry skEntry =
 *        new KeyStore.SecretKeyEntry(mySecretKey);
 *    ks.setEntry(&quot;secretKeyAlias&quot;, skEntry, protParam);
 *
 *    // store away the keystore
 *    try (FileOutputStream fos = new FileOutputStream(&quot;newKeyStoreName&quot;)) {
 *        ks.store(fos, password);
 *    }
 * &lt;/pre&gt;
 *
 * Note that although the same password may be used to
 * load the keystore, to protect the private key entry,
 * to protect the secret key entry, and to store the keystore
 * (as is shown in the sample code above),
 * different passwords or other protection parameters
 * may also be used.
 *
 * &lt;p&gt; Every implementation of the Java platform is required to support
 * the following standard {@code KeyStore} type:
 * &lt;ul&gt;
 * &lt;li&gt;{@code PKCS12}&lt;/li&gt;
 * &lt;/ul&gt;
 * This type is described in the &lt;a href=
 * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyStore&quot;&gt;
 * KeyStore section&lt;/a&gt; of the
 * Java Cryptography Architecture Standard Algorithm Name Documentation.
 * Consult the release documentation for your implementation to see if any
 * other types are supported.
 *
 * @author Jan Luehe
 *
 * @see java.security.PrivateKey
 * @see javax.crypto.SecretKey
 * @see java.security.cert.Certificate
 *
 * @since 1.2
 */

public class KeyStore {

    /*
     * Constant to lookup in the Security properties file to determine
     * the default keystore type.
     * In the Security properties file, the default keystore type is given as:
     * &lt;pre&gt;
     * keystore.type=jks
     * &lt;/pre&gt;
     */
    private static final String KEYSTORE_TYPE = &quot;keystore.type&quot;;

    // The keystore type
    private String type;

    // The provider
    private Provider provider;

    // The provider implementation
    private KeyStoreSpi keyStoreSpi;

    // Has this keystore been initialized (loaded)?
<span class="fc" id="L200">    private boolean initialized = false;</span>

    /**
     * A marker interface for {@code KeyStore}
     * {@link #load(KeyStore.LoadStoreParameter) load}
     * and
     * {@link #store(KeyStore.LoadStoreParameter) store}
     * parameters.
     *
     * @since 1.5
     */
    public static interface LoadStoreParameter {
        /**
         * Gets the parameter used to protect keystore data.
         *
         * @return the parameter used to protect keystore data, or null
         */
        public ProtectionParameter getProtectionParameter();
    }

    /**
     * A marker interface for keystore protection parameters.
     *
     * &lt;p&gt; The information stored in a {@code ProtectionParameter}
     * object protects the contents of a keystore.
     * For example, protection parameters may be used to check
     * the integrity of keystore data, or to protect the
     * confidentiality of sensitive keystore data
     * (such as a {@code PrivateKey}).
     *
     * @since 1.5
     */
    public static interface ProtectionParameter { }

    /**
     * A password-based implementation of {@code ProtectionParameter}.
     *
     * @since 1.5
     */
    public static class PasswordProtection implements
                ProtectionParameter, javax.security.auth.Destroyable {

        private final char[] password;
        private final String protectionAlgorithm;
        private final AlgorithmParameterSpec protectionParameters;
<span class="pc" id="L245">        private volatile boolean destroyed = false;</span>

        /**
         * Creates a password parameter.
         *
         * &lt;p&gt; The specified {@code password} is cloned before it is stored
         * in the new {@code PasswordProtection} object.
         *
         * @param password the password, which may be {@code null}
         */
<span class="fc" id="L255">        public PasswordProtection(char[] password) {</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            this.password = (password == null) ? null : password.clone();</span>
<span class="fc" id="L257">            this.protectionAlgorithm = null;</span>
<span class="fc" id="L258">            this.protectionParameters = null;</span>
<span class="fc" id="L259">        }</span>

        /**
         * Creates a password parameter and specifies the protection algorithm
         * and associated parameters to use when encrypting a keystore entry.
         * &lt;p&gt;
         * The specified {@code password} is cloned before it is stored in the
         * new {@code PasswordProtection} object.
         *
         * @param password the password, which may be {@code null}
         * @param protectionAlgorithm the encryption algorithm name, for
         *     example, {@code PBEWithHmacSHA256AndAES_256}.
         *     See the Cipher section in the &lt;a href=
         * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Cipher&quot;&gt;
         * Java Cryptography Architecture Standard Algorithm Name
         * Documentation&lt;/a&gt;
         *     for information about standard encryption algorithm names.
         * @param protectionParameters the encryption algorithm parameter
         *     specification, which may be {@code null}
         * @exception NullPointerException if {@code protectionAlgorithm} is
         *     {@code null}
         *
         * @since 1.8
         */
        public PasswordProtection(char[] password, String protectionAlgorithm,
<span class="nc" id="L284">            AlgorithmParameterSpec protectionParameters) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (protectionAlgorithm == null) {</span>
<span class="nc" id="L286">                throw new NullPointerException(&quot;invalid null input&quot;);</span>
            }
<span class="nc bnc" id="L288" title="All 2 branches missed.">            this.password = (password == null) ? null : password.clone();</span>
<span class="nc" id="L289">            this.protectionAlgorithm = protectionAlgorithm;</span>
<span class="nc" id="L290">            this.protectionParameters = protectionParameters;</span>
<span class="nc" id="L291">        }</span>

        /**
         * Gets the name of the protection algorithm.
         * If none was set then the keystore provider will use its default
         * protection algorithm. The name of the default protection algorithm
         * for a given keystore type is set using the
         * {@code 'keystore.&lt;type&gt;.keyProtectionAlgorithm'} security property.
         * For example, the
         * {@code keystore.PKCS12.keyProtectionAlgorithm} property stores the
         * name of the default key protection algorithm used for PKCS12
         * keystores. If the security property is not set, an
         * implementation-specific algorithm will be used.
         *
         * @return the algorithm name, or {@code null} if none was set
         *
         * @since 1.8
         */
        public String getProtectionAlgorithm() {
<span class="nc" id="L310">            return protectionAlgorithm;</span>
        }

        /**
         * Gets the parameters supplied for the protection algorithm.
         *
         * @return the algorithm parameter specification, or {@code  null},
         *     if none was set
         *
         * @since 1.8
         */
        public AlgorithmParameterSpec getProtectionParameters() {
<span class="nc" id="L322">            return protectionParameters;</span>
        }

        /**
         * Gets the password.
         *
         * &lt;p&gt;Note that this method returns a reference to the password.
         * If a clone of the array is created it is the caller's
         * responsibility to zero out the password information
         * after it is no longer needed.
         *
         * @see #destroy()
         * @return the password, which may be {@code null}
         * @exception IllegalStateException if the password has
         *              been cleared (destroyed)
         */
        public synchronized char[] getPassword() {
<span class="pc bpc" id="L339" title="1 of 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L340">                throw new IllegalStateException(&quot;password has been cleared&quot;);</span>
            }
<span class="fc" id="L342">            return password;</span>
        }

        /**
         * Clears the password.
         *
         * @exception DestroyFailedException if this method was unable
         *      to clear the password
         */
        public synchronized void destroy() throws DestroyFailedException {
<span class="nc" id="L352">            destroyed = true;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (password != null) {</span>
<span class="nc" id="L354">                Arrays.fill(password, ' ');</span>
            }
<span class="nc" id="L356">        }</span>

        /**
         * Determines if password has been cleared.
         *
         * @return true if the password has been cleared, false otherwise
         */
        public synchronized boolean isDestroyed() {
<span class="nc" id="L364">            return destroyed;</span>
        }
    }

    /**
     * A ProtectionParameter encapsulating a CallbackHandler.
     *
     * @since 1.5
     */
    public static class CallbackHandlerProtection
            implements ProtectionParameter {

        private final CallbackHandler handler;

        /**
         * Constructs a new CallbackHandlerProtection from a
         * CallbackHandler.
         *
         * @param handler the CallbackHandler
         * @exception NullPointerException if handler is null
         */
<span class="nc" id="L385">        public CallbackHandlerProtection(CallbackHandler handler) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">            if (handler == null) {</span>
<span class="nc" id="L387">                throw new NullPointerException(&quot;handler must not be null&quot;);</span>
            }
<span class="nc" id="L389">            this.handler = handler;</span>
<span class="nc" id="L390">        }</span>

        /**
         * Returns the CallbackHandler.
         *
         * @return the CallbackHandler.
         */
        public CallbackHandler getCallbackHandler() {
<span class="nc" id="L398">            return handler;</span>
        }

    }

    /**
     * A marker interface for {@code KeyStore} entry types.
     *
     * @since 1.5
     */
    public static interface Entry {

        /**
         * Retrieves the attributes associated with an entry.
         * &lt;p&gt;
         * The default implementation returns an empty {@code Set}.
         *
         * @return an unmodifiable {@code Set} of attributes, possibly empty
         *
         * @since 1.8
         */
        public default Set&lt;Attribute&gt; getAttributes() {
<span class="nc" id="L420">            return Collections.&lt;Attribute&gt;emptySet();</span>
        }

        /**
         * An attribute associated with a keystore entry.
         * It comprises a name and one or more values.
         *
         * @since 1.8
         */
        public interface Attribute {
            /**
             * Returns the attribute's name.
             *
             * @return the attribute name
             */
            public String getName();

            /**
             * Returns the attribute's value.
             * Multi-valued attributes encode their values as a single string.
             *
             * @return the attribute value
             */
            public String getValue();
        }
    }

    /**
     * A {@code KeyStore} entry that holds a {@code PrivateKey}
     * and corresponding certificate chain.
     *
     * @since 1.5
     */
    public static final class PrivateKeyEntry implements Entry {

        private final PrivateKey privKey;
        private final Certificate[] chain;
        private final Set&lt;Attribute&gt; attributes;

        /**
         * Constructs a {@code PrivateKeyEntry} with a
         * {@code PrivateKey} and corresponding certificate chain.
         *
         * &lt;p&gt; The specified {@code chain} is cloned before it is stored
         * in the new {@code PrivateKeyEntry} object.
         *
         * @param privateKey the {@code PrivateKey}
         * @param chain an array of {@code Certificate}s
         *      representing the certificate chain.
         *      The chain must be ordered and contain a
         *      {@code Certificate} at index 0
         *      corresponding to the private key.
         *
         * @exception NullPointerException if
         *      {@code privateKey} or {@code chain}
         *      is {@code null}
         * @exception IllegalArgumentException if the specified chain has a
         *      length of 0, if the specified chain does not contain
         *      {@code Certificate}s of the same type,
         *      or if the {@code PrivateKey} algorithm
         *      does not match the algorithm of the {@code PublicKey}
         *      in the end entity {@code Certificate} (at index 0)
         */
        public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain) {
<span class="fc" id="L484">            this(privateKey, chain, Collections.&lt;Attribute&gt;emptySet());</span>
<span class="fc" id="L485">        }</span>

        /**
         * Constructs a {@code PrivateKeyEntry} with a {@code PrivateKey} and
         * corresponding certificate chain and associated entry attributes.
         *
         * &lt;p&gt; The specified {@code chain} and {@code attributes} are cloned
         * before they are stored in the new {@code PrivateKeyEntry} object.
         *
         * @param privateKey the {@code PrivateKey}
         * @param chain an array of {@code Certificate}s
         *      representing the certificate chain.
         *      The chain must be ordered and contain a
         *      {@code Certificate} at index 0
         *      corresponding to the private key.
         * @param attributes the attributes
         *
         * @exception NullPointerException if {@code privateKey}, {@code chain}
         *      or {@code attributes} is {@code null}
         * @exception IllegalArgumentException if the specified chain has a
         *      length of 0, if the specified chain does not contain
         *      {@code Certificate}s of the same type,
         *      or if the {@code PrivateKey} algorithm
         *      does not match the algorithm of the {@code PublicKey}
         *      in the end entity {@code Certificate} (at index 0)
         *
         * @since 1.8
         */
        public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain,
<span class="fc" id="L514">           Set&lt;Attribute&gt; attributes) {</span>

<span class="pc bpc" id="L516" title="3 of 6 branches missed.">            if (privateKey == null || chain == null || attributes == null) {</span>
<span class="nc" id="L517">                throw new NullPointerException(&quot;invalid null input&quot;);</span>
            }
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">            if (chain.length == 0) {</span>
<span class="nc" id="L520">                throw new IllegalArgumentException</span>
                                (&quot;invalid zero-length input chain&quot;);
            }

<span class="fc" id="L524">            Certificate[] clonedChain = chain.clone();</span>
<span class="fc" id="L525">            String certType = clonedChain[0].getType();</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">            for (int i = 1; i &lt; clonedChain.length; i++) {</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">                if (!certType.equals(clonedChain[i].getType())) {</span>
<span class="nc" id="L528">                    throw new IllegalArgumentException</span>
                                (&quot;chain does not contain certificates &quot; +
                                &quot;of the same type&quot;);
                }
            }
<span class="fc" id="L533">            if (!privateKey.getAlgorithm().equals</span>
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">                        (clonedChain[0].getPublicKey().getAlgorithm())) {</span>
<span class="nc" id="L535">                throw new IllegalArgumentException</span>
                                (&quot;private key algorithm does not match &quot; +
                                &quot;algorithm of public key in end entity &quot; +
                                &quot;certificate (at index 0)&quot;);
            }
<span class="fc" id="L540">            this.privKey = privateKey;</span>

<span class="pc bpc" id="L542" title="1 of 4 branches missed.">            if (clonedChain[0] instanceof X509Certificate &amp;&amp;</span>
                !(clonedChain instanceof X509Certificate[])) {

<span class="fc" id="L545">                this.chain = new X509Certificate[clonedChain.length];</span>
<span class="fc" id="L546">                System.arraycopy(clonedChain, 0,</span>
                                this.chain, 0, clonedChain.length);
            } else {
<span class="fc" id="L549">                this.chain = clonedChain;</span>
            }

<span class="fc" id="L552">            this.attributes =</span>
<span class="fc" id="L553">                Collections.unmodifiableSet(new HashSet&lt;&gt;(attributes));</span>
<span class="fc" id="L554">        }</span>

        /**
         * Gets the {@code PrivateKey} from this entry.
         *
         * @return the {@code PrivateKey} from this entry
         */
        public PrivateKey getPrivateKey() {
<span class="fc" id="L562">            return privKey;</span>
        }

        /**
         * Gets the {@code Certificate} chain from this entry.
         *
         * &lt;p&gt; The stored chain is cloned before being returned.
         *
         * @return an array of {@code Certificate}s corresponding
         *      to the certificate chain for the public key.
         *      If the certificates are of type X.509,
         *      the runtime type of the returned array is
         *      {@code X509Certificate[]}.
         */
        public Certificate[] getCertificateChain() {
<span class="fc" id="L577">            return chain.clone();</span>
        }

        /**
         * Gets the end entity {@code Certificate}
         * from the certificate chain in this entry.
         *
         * @return the end entity {@code Certificate} (at index 0)
         *      from the certificate chain in this entry.
         *      If the certificate is of type X.509,
         *      the runtime type of the returned certificate is
         *      {@code X509Certificate}.
         */
        public Certificate getCertificate() {
<span class="fc" id="L591">            return chain[0];</span>
        }

        /**
         * Retrieves the attributes associated with an entry.
         * &lt;p&gt;
         *
         * @return an unmodifiable {@code Set} of attributes, possibly empty
         *
         * @since 1.8
         */
        @Override
        public Set&lt;Attribute&gt; getAttributes() {
<span class="nc" id="L604">            return attributes;</span>
        }

        /**
         * Returns a string representation of this PrivateKeyEntry.
         * @return a string representation of this PrivateKeyEntry.
         */
        public String toString() {
<span class="nc" id="L612">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L613">            sb.append(&quot;Private key entry and certificate chain with &quot;</span>
                + chain.length + &quot; elements:\r\n&quot;);
<span class="nc bnc" id="L615" title="All 2 branches missed.">            for (Certificate cert : chain) {</span>
<span class="nc" id="L616">                sb.append(cert);</span>
<span class="nc" id="L617">                sb.append(&quot;\r\n&quot;);</span>
            }
<span class="nc" id="L619">            return sb.toString();</span>
        }

    }

    /**
     * A {@code KeyStore} entry that holds a {@code SecretKey}.
     *
     * @since 1.5
     */
    public static final class SecretKeyEntry implements Entry {

        private final SecretKey sKey;
        private final Set&lt;Attribute&gt; attributes;

        /**
         * Constructs a {@code SecretKeyEntry} with a
         * {@code SecretKey}.
         *
         * @param secretKey the {@code SecretKey}
         *
         * @exception NullPointerException if {@code secretKey}
         *      is {@code null}
         */
<span class="nc" id="L643">        public SecretKeyEntry(SecretKey secretKey) {</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">            if (secretKey == null) {</span>
<span class="nc" id="L645">                throw new NullPointerException(&quot;invalid null input&quot;);</span>
            }
<span class="nc" id="L647">            this.sKey = secretKey;</span>
<span class="nc" id="L648">            this.attributes = Collections.&lt;Attribute&gt;emptySet();</span>
<span class="nc" id="L649">        }</span>

        /**
         * Constructs a {@code SecretKeyEntry} with a {@code SecretKey} and
         * associated entry attributes.
         *
         * &lt;p&gt; The specified {@code attributes} is cloned before it is stored
         * in the new {@code SecretKeyEntry} object.
         *
         * @param secretKey the {@code SecretKey}
         * @param attributes the attributes
         *
         * @exception NullPointerException if {@code secretKey} or
         *     {@code attributes} is {@code null}
         *
         * @since 1.8
         */
<span class="nc" id="L666">        public SecretKeyEntry(SecretKey secretKey, Set&lt;Attribute&gt; attributes) {</span>

<span class="nc bnc" id="L668" title="All 4 branches missed.">            if (secretKey == null || attributes == null) {</span>
<span class="nc" id="L669">                throw new NullPointerException(&quot;invalid null input&quot;);</span>
            }
<span class="nc" id="L671">            this.sKey = secretKey;</span>
<span class="nc" id="L672">            this.attributes =</span>
<span class="nc" id="L673">                Collections.unmodifiableSet(new HashSet&lt;&gt;(attributes));</span>
<span class="nc" id="L674">        }</span>

        /**
         * Gets the {@code SecretKey} from this entry.
         *
         * @return the {@code SecretKey} from this entry
         */
        public SecretKey getSecretKey() {
<span class="nc" id="L682">            return sKey;</span>
        }

        /**
         * Retrieves the attributes associated with an entry.
         * &lt;p&gt;
         *
         * @return an unmodifiable {@code Set} of attributes, possibly empty
         *
         * @since 1.8
         */
        @Override
        public Set&lt;Attribute&gt; getAttributes() {
<span class="nc" id="L695">            return attributes;</span>
        }

        /**
         * Returns a string representation of this SecretKeyEntry.
         * @return a string representation of this SecretKeyEntry.
         */
        public String toString() {
<span class="nc" id="L703">            return &quot;Secret key entry with algorithm &quot; + sKey.getAlgorithm();</span>
        }
    }

    /**
     * A {@code KeyStore} entry that holds a trusted
     * {@code Certificate}.
     *
     * @since 1.5
     */
    public static final class TrustedCertificateEntry implements Entry {

        private final Certificate cert;
        private final Set&lt;Attribute&gt; attributes;

        /**
         * Constructs a {@code TrustedCertificateEntry} with a
         * trusted {@code Certificate}.
         *
         * @param trustedCert the trusted {@code Certificate}
         *
         * @exception NullPointerException if
         *      {@code trustedCert} is {@code null}
         */
<span class="fc" id="L727">        public TrustedCertificateEntry(Certificate trustedCert) {</span>
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">            if (trustedCert == null) {</span>
<span class="nc" id="L729">                throw new NullPointerException(&quot;invalid null input&quot;);</span>
            }
<span class="fc" id="L731">            this.cert = trustedCert;</span>
<span class="fc" id="L732">            this.attributes = Collections.&lt;Attribute&gt;emptySet();</span>
<span class="fc" id="L733">        }</span>

        /**
         * Constructs a {@code TrustedCertificateEntry} with a
         * trusted {@code Certificate} and associated entry attributes.
         *
         * &lt;p&gt; The specified {@code attributes} is cloned before it is stored
         * in the new {@code TrustedCertificateEntry} object.
         *
         * @param trustedCert the trusted {@code Certificate}
         * @param attributes the attributes
         *
         * @exception NullPointerException if {@code trustedCert} or
         *     {@code attributes} is {@code null}
         *
         * @since 1.8
         */
        public TrustedCertificateEntry(Certificate trustedCert,
<span class="nc" id="L751">           Set&lt;Attribute&gt; attributes) {</span>
<span class="nc bnc" id="L752" title="All 4 branches missed.">            if (trustedCert == null || attributes == null) {</span>
<span class="nc" id="L753">                throw new NullPointerException(&quot;invalid null input&quot;);</span>
            }
<span class="nc" id="L755">            this.cert = trustedCert;</span>
<span class="nc" id="L756">            this.attributes =</span>
<span class="nc" id="L757">                Collections.unmodifiableSet(new HashSet&lt;&gt;(attributes));</span>
<span class="nc" id="L758">        }</span>

        /**
         * Gets the trusted {@code Certficate} from this entry.
         *
         * @return the trusted {@code Certificate} from this entry
         */
        public Certificate getTrustedCertificate() {
<span class="fc" id="L766">            return cert;</span>
        }

        /**
         * Retrieves the attributes associated with an entry.
         * &lt;p&gt;
         *
         * @return an unmodifiable {@code Set} of attributes, possibly empty
         *
         * @since 1.8
         */
        @Override
        public Set&lt;Attribute&gt; getAttributes() {
<span class="nc" id="L779">            return attributes;</span>
        }

        /**
         * Returns a string representation of this TrustedCertificateEntry.
         * @return a string representation of this TrustedCertificateEntry.
         */
        public String toString() {
<span class="nc" id="L787">            return &quot;Trusted certificate entry:\r\n&quot; + cert.toString();</span>
        }
    }

    /**
     * Creates a KeyStore object of the given type, and encapsulates the given
     * provider implementation (SPI object) in it.
     *
     * @param keyStoreSpi the provider implementation.
     * @param provider the provider.
     * @param type the keystore type.
     */
    protected KeyStore(KeyStoreSpi keyStoreSpi, Provider provider, String type)
<span class="fc" id="L800">    {</span>
<span class="fc" id="L801">        this.keyStoreSpi = keyStoreSpi;</span>
<span class="fc" id="L802">        this.provider = provider;</span>
<span class="fc" id="L803">        this.type = type;</span>
<span class="fc" id="L804">    }</span>

    /**
     * Returns a keystore object of the specified type.
     *
     * &lt;p&gt; This method traverses the list of registered security Providers,
     * starting with the most preferred Provider.
     * A new KeyStore object encapsulating the
     * KeyStoreSpi implementation from the first
     * Provider that supports the specified type is returned.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param type the type of keystore.
     * See the KeyStore section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyStore&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard keystore types.
     *
     * @return a keystore object of the specified type.
     *
     * @exception KeyStoreException if no Provider supports a
     *          KeyStoreSpi implementation for the
     *          specified type.
     *
     * @see Provider
     */
    public static KeyStore getInstance(String type)
        throws KeyStoreException
    {
        try {
<span class="fc" id="L836">            Object[] objs = Security.getImpl(type, &quot;KeyStore&quot;, (String)null);</span>
<span class="fc" id="L837">            return new KeyStore((KeyStoreSpi)objs[0], (Provider)objs[1], type);</span>
<span class="nc" id="L838">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L839">            throw new KeyStoreException(type + &quot; not found&quot;, nsae);</span>
<span class="nc" id="L840">        } catch (NoSuchProviderException nspe) {</span>
<span class="nc" id="L841">            throw new KeyStoreException(type + &quot; not found&quot;, nspe);</span>
        }
    }

    /**
     * Returns a keystore object of the specified type.
     *
     * &lt;p&gt; A new KeyStore object encapsulating the
     * KeyStoreSpi implementation from the specified provider
     * is returned.  The specified provider must be registered
     * in the security provider list.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param type the type of keystore.
     * See the KeyStore section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyStore&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard keystore types.
     *
     * @param provider the name of the provider.
     *
     * @return a keystore object of the specified type.
     *
     * @exception KeyStoreException if a KeyStoreSpi
     *          implementation for the specified type is not
     *          available from the specified provider.
     *
     * @exception NoSuchProviderException if the specified provider is not
     *          registered in the security provider list.
     *
     * @exception IllegalArgumentException if the provider name is null
     *          or empty.
     *
     * @see Provider
     */
    public static KeyStore getInstance(String type, String provider)
        throws KeyStoreException, NoSuchProviderException
    {
<span class="pc bpc" id="L881" title="2 of 4 branches missed.">        if (provider == null || provider.length() == 0)</span>
<span class="nc" id="L882">            throw new IllegalArgumentException(&quot;missing provider&quot;);</span>
        try {
<span class="fc" id="L884">            Object[] objs = Security.getImpl(type, &quot;KeyStore&quot;, provider);</span>
<span class="fc" id="L885">            return new KeyStore((KeyStoreSpi)objs[0], (Provider)objs[1], type);</span>
<span class="nc" id="L886">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L887">            throw new KeyStoreException(type + &quot; not found&quot;, nsae);</span>
        }
    }

    /**
     * Returns a keystore object of the specified type.
     *
     * &lt;p&gt; A new KeyStore object encapsulating the
     * KeyStoreSpi implementation from the specified Provider
     * object is returned.  Note that the specified Provider object
     * does not have to be registered in the provider list.
     *
     * @param type the type of keystore.
     * See the KeyStore section in the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#KeyStore&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard keystore types.
     *
     * @param provider the provider.
     *
     * @return a keystore object of the specified type.
     *
     * @exception KeyStoreException if KeyStoreSpi
     *          implementation for the specified type is not available
     *          from the specified Provider object.
     *
     * @exception IllegalArgumentException if the specified provider is null.
     *
     * @see Provider
     *
     * @since 1.4
     */
    public static KeyStore getInstance(String type, Provider provider)
        throws KeyStoreException
    {
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">        if (provider == null)</span>
<span class="nc" id="L923">            throw new IllegalArgumentException(&quot;missing provider&quot;);</span>
        try {
<span class="fc" id="L925">            Object[] objs = Security.getImpl(type, &quot;KeyStore&quot;, provider);</span>
<span class="fc" id="L926">            return new KeyStore((KeyStoreSpi)objs[0], (Provider)objs[1], type);</span>
<span class="nc" id="L927">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L928">            throw new KeyStoreException(type + &quot; not found&quot;, nsae);</span>
        }
    }

    /**
     * Returns the default keystore type as specified by the
     * {@code keystore.type} security property, or the string
     * {@literal &quot;jks&quot;} (acronym for {@literal &quot;Java keystore&quot;})
     * if no such property exists.
     *
     * &lt;p&gt;The default keystore type can be used by applications that do not
     * want to use a hard-coded keystore type when calling one of the
     * {@code getInstance} methods, and want to provide a default keystore
     * type in case a user does not specify its own.
     *
     * &lt;p&gt;The default keystore type can be changed by setting the value of the
     * {@code keystore.type} security property to the desired keystore type.
     *
     * @return the default keystore type as specified by the
     * {@code keystore.type} security property, or the string {@literal &quot;jks&quot;}
     * if no such property exists.
     * @see java.security.Security security properties
     */
    public final static String getDefaultType() {
        String kstype;
<span class="fc" id="L953">        kstype = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {</span>
            public String run() {
<span class="fc" id="L955">                return Security.getProperty(KEYSTORE_TYPE);</span>
            }
        });
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">        if (kstype == null) {</span>
<span class="nc" id="L959">            kstype = &quot;jks&quot;;</span>
        }
<span class="fc" id="L961">        return kstype;</span>
    }

    /**
     * Returns the provider of this keystore.
     *
     * @return the provider of this keystore.
     */
    public final Provider getProvider()
    {
<span class="fc" id="L971">        return this.provider;</span>
    }

    /**
     * Returns the type of this keystore.
     *
     * @return the type of this keystore.
     */
    public final String getType()
    {
<span class="nc" id="L981">        return this.type;</span>
    }

    /**
     * Returns the key associated with the given alias, using the given
     * password to recover it.  The key must have been associated with
     * the alias by a call to {@code setKeyEntry},
     * or by a call to {@code setEntry} with a
     * {@code PrivateKeyEntry} or {@code SecretKeyEntry}.
     *
     * @param alias the alias name
     * @param password the password for recovering the key
     *
     * @return the requested key, or null if the given alias does not exist
     * or does not identify a key-related entry.
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     * @exception NoSuchAlgorithmException if the algorithm for recovering the
     * key cannot be found
     * @exception UnrecoverableKeyException if the key cannot be recovered
     * (e.g., the given password is wrong).
     */
    public final Key getKey(String alias, char[] password)
        throws KeyStoreException, NoSuchAlgorithmException,
            UnrecoverableKeyException
    {
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1009">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1011">        return keyStoreSpi.engineGetKey(alias, password);</span>
    }

    /**
     * Returns the certificate chain associated with the given alias.
     * The certificate chain must have been associated with the alias
     * by a call to {@code setKeyEntry},
     * or by a call to {@code setEntry} with a
     * {@code PrivateKeyEntry}.
     *
     * @param alias the alias name
     *
     * @return the certificate chain (ordered with the user's certificate first
     * followed by zero or more certificate authorities), or null if the given alias
     * does not exist or does not contain a certificate chain
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     */
    public final Certificate[] getCertificateChain(String alias)
        throws KeyStoreException
    {
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1034">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1036">        return keyStoreSpi.engineGetCertificateChain(alias);</span>
    }

    /**
     * Returns the certificate associated with the given alias.
     *
     * &lt;p&gt; If the given alias name identifies an entry
     * created by a call to {@code setCertificateEntry},
     * or created by a call to {@code setEntry} with a
     * {@code TrustedCertificateEntry},
     * then the trusted certificate contained in that entry is returned.
     *
     * &lt;p&gt; If the given alias name identifies an entry
     * created by a call to {@code setKeyEntry},
     * or created by a call to {@code setEntry} with a
     * {@code PrivateKeyEntry},
     * then the first element of the certificate chain in that entry
     * is returned.
     *
     * @param alias the alias name
     *
     * @return the certificate, or null if the given alias does not exist or
     * does not contain a certificate.
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     */
    public final Certificate getCertificate(String alias)
        throws KeyStoreException
    {
<span class="pc bpc" id="L1066" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1067">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1069">        return keyStoreSpi.engineGetCertificate(alias);</span>
    }

    /**
     * Returns the creation date of the entry identified by the given alias.
     *
     * @param alias the alias name
     *
     * @return the creation date of this entry, or null if the given alias does
     * not exist
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     */
    public final Date getCreationDate(String alias)
        throws KeyStoreException
    {
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1087">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="nc" id="L1089">        return keyStoreSpi.engineGetCreationDate(alias);</span>
    }

    /**
     * Assigns the given key to the given alias, protecting it with the given
     * password.
     *
     * &lt;p&gt;If the given key is of type {@code java.security.PrivateKey},
     * it must be accompanied by a certificate chain certifying the
     * corresponding public key.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key (and possibly
     * certificate chain).
     *
     * @param alias the alias name
     * @param key the key to be associated with the alias
     * @param password the password to protect the key
     * @param chain the certificate chain for the corresponding public
     * key (only required if the given key is of type
     * {@code java.security.PrivateKey}).
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded), the given key cannot be protected, or this operation fails
     * for some other reason
     */
    public final void setKeyEntry(String alias, Key key, char[] password,
                                  Certificate[] chain)
        throws KeyStoreException
    {
<span class="pc bpc" id="L1119" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1120">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="pc bpc" id="L1122" title="3 of 6 branches missed.">        if ((key instanceof PrivateKey) &amp;&amp;</span>
            (chain == null || chain.length == 0)) {
<span class="nc" id="L1124">            throw new IllegalArgumentException(&quot;Private key must be &quot;</span>
                                               + &quot;accompanied by certificate &quot;
                                               + &quot;chain&quot;);
        }
<span class="fc" id="L1128">        keyStoreSpi.engineSetKeyEntry(alias, key, password, chain);</span>
<span class="fc" id="L1129">    }</span>

    /**
     * Assigns the given key (that has already been protected) to the given
     * alias.
     *
     * &lt;p&gt;If the protected key is of type
     * {@code java.security.PrivateKey}, it must be accompanied by a
     * certificate chain certifying the corresponding public key. If the
     * underlying keystore implementation is of type {@code jks},
     * {@code key} must be encoded as an
     * {@code EncryptedPrivateKeyInfo} as defined in the PKCS #8 standard.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key (and possibly
     * certificate chain).
     *
     * @param alias the alias name
     * @param key the key (in protected format) to be associated with the alias
     * @param chain the certificate chain for the corresponding public
     *          key (only useful if the protected key is of type
     *          {@code java.security.PrivateKey}).
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded), or if this operation fails for some other reason.
     */
    public final void setKeyEntry(String alias, byte[] key,
                                  Certificate[] chain)
        throws KeyStoreException
    {
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1160">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="nc" id="L1162">        keyStoreSpi.engineSetKeyEntry(alias, key, chain);</span>
<span class="nc" id="L1163">    }</span>

    /**
     * Assigns the given trusted certificate to the given alias.
     *
     * &lt;p&gt; If the given alias identifies an existing entry
     * created by a call to {@code setCertificateEntry},
     * or created by a call to {@code setEntry} with a
     * {@code TrustedCertificateEntry},
     * the trusted certificate in the existing entry
     * is overridden by the given certificate.
     *
     * @param alias the alias name
     * @param cert the certificate
     *
     * @exception KeyStoreException if the keystore has not been initialized,
     * or the given alias already exists and does not identify an
     * entry containing a trusted certificate,
     * or this operation fails for some other reason.
     */
    public final void setCertificateEntry(String alias, Certificate cert)
        throws KeyStoreException
    {
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1187">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1189">        keyStoreSpi.engineSetCertificateEntry(alias, cert);</span>
<span class="fc" id="L1190">    }</span>

    /**
     * Deletes the entry identified by the given alias from this keystore.
     *
     * @param alias the alias name
     *
     * @exception KeyStoreException if the keystore has not been initialized,
     * or if the entry cannot be removed.
     */
    public final void deleteEntry(String alias)
        throws KeyStoreException
    {
<span class="pc bpc" id="L1203" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1204">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1206">        keyStoreSpi.engineDeleteEntry(alias);</span>
<span class="fc" id="L1207">    }</span>

    /**
     * Lists all the alias names of this keystore.
     *
     * @return enumeration of the alias names
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     */
    public final Enumeration&lt;String&gt; aliases()
        throws KeyStoreException
    {
<span class="pc bpc" id="L1220" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1221">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1223">        return keyStoreSpi.engineAliases();</span>
    }

    /**
     * Checks if the given alias exists in this keystore.
     *
     * @param alias the alias name
     *
     * @return true if the alias exists, false otherwise
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     */
    public final boolean containsAlias(String alias)
        throws KeyStoreException
    {
<span class="nc bnc" id="L1239" title="All 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1240">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="nc" id="L1242">        return keyStoreSpi.engineContainsAlias(alias);</span>
    }

    /**
     * Retrieves the number of entries in this keystore.
     *
     * @return the number of entries in this keystore
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     */
    public final int size()
        throws KeyStoreException
    {
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1257">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1259">        return keyStoreSpi.engineSize();</span>
    }

    /**
     * Returns true if the entry identified by the given alias
     * was created by a call to {@code setKeyEntry},
     * or created by a call to {@code setEntry} with a
     * {@code PrivateKeyEntry} or a {@code SecretKeyEntry}.
     *
     * @param alias the alias for the keystore entry to be checked
     *
     * @return true if the entry identified by the given alias is a
     * key-related entry, false otherwise.
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     */
    public final boolean isKeyEntry(String alias)
        throws KeyStoreException
    {
<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1280">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1282">        return keyStoreSpi.engineIsKeyEntry(alias);</span>
    }

    /**
     * Returns true if the entry identified by the given alias
     * was created by a call to {@code setCertificateEntry},
     * or created by a call to {@code setEntry} with a
     * {@code TrustedCertificateEntry}.
     *
     * @param alias the alias for the keystore entry to be checked
     *
     * @return true if the entry identified by the given alias contains a
     * trusted certificate, false otherwise.
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     */
    public final boolean isCertificateEntry(String alias)
        throws KeyStoreException
    {
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1303">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1305">        return keyStoreSpi.engineIsCertificateEntry(alias);</span>
    }

    /**
     * Returns the (alias) name of the first keystore entry whose certificate
     * matches the given certificate.
     *
     * &lt;p&gt; This method attempts to match the given certificate with each
     * keystore entry. If the entry being considered was
     * created by a call to {@code setCertificateEntry},
     * or created by a call to {@code setEntry} with a
     * {@code TrustedCertificateEntry},
     * then the given certificate is compared to that entry's certificate.
     *
     * &lt;p&gt; If the entry being considered was
     * created by a call to {@code setKeyEntry},
     * or created by a call to {@code setEntry} with a
     * {@code PrivateKeyEntry},
     * then the given certificate is compared to the first
     * element of that entry's certificate chain.
     *
     * @param cert the certificate to match with.
     *
     * @return the alias name of the first entry with a matching certificate,
     * or null if no such entry exists in this keystore.
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     */
    public final String getCertificateAlias(Certificate cert)
        throws KeyStoreException
    {
<span class="nc bnc" id="L1337" title="All 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1338">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="nc" id="L1340">        return keyStoreSpi.engineGetCertificateAlias(cert);</span>
    }

    /**
     * Stores this keystore to the given output stream, and protects its
     * integrity with the given password.
     *
     * @param stream the output stream to which this keystore is written.
     * @param password the password to generate the keystore integrity check
     *
     * @exception KeyStoreException if the keystore has not been initialized
     * (loaded).
     * @exception IOException if there was an I/O problem with data
     * @exception NoSuchAlgorithmException if the appropriate data integrity
     * algorithm could not be found
     * @exception CertificateException if any of the certificates included in
     * the keystore data could not be stored
     */
    public final void store(OutputStream stream, char[] password)
        throws KeyStoreException, IOException, NoSuchAlgorithmException,
            CertificateException
    {
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1363">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1365">        keyStoreSpi.engineStore(stream, password);</span>
<span class="fc" id="L1366">    }</span>

    /**
     * Stores this keystore using the given {@code LoadStoreParameter}.
     *
     * @param param the {@code LoadStoreParameter}
     *          that specifies how to store the keystore,
     *          which may be {@code null}
     *
     * @exception IllegalArgumentException if the given
     *          {@code LoadStoreParameter}
     *          input is not recognized
     * @exception KeyStoreException if the keystore has not been initialized
     *          (loaded)
     * @exception IOException if there was an I/O problem with data
     * @exception NoSuchAlgorithmException if the appropriate data integrity
     *          algorithm could not be found
     * @exception CertificateException if any of the certificates included in
     *          the keystore data could not be stored
     *
     * @since 1.5
     */
    public final void store(LoadStoreParameter param)
                throws KeyStoreException, IOException,
                NoSuchAlgorithmException, CertificateException {
<span class="nc bnc" id="L1391" title="All 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1392">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="nc" id="L1394">        keyStoreSpi.engineStore(param);</span>
<span class="nc" id="L1395">    }</span>

    /**
     * Loads this KeyStore from the given input stream.
     *
     * &lt;p&gt;A password may be given to unlock the keystore
     * (e.g. the keystore resides on a hardware token device),
     * or to check the integrity of the keystore data.
     * If a password is not given for integrity checking,
     * then integrity checking is not performed.
     *
     * &lt;p&gt;In order to create an empty keystore, or if the keystore cannot
     * be initialized from a stream, pass {@code null}
     * as the {@code stream} argument.
     *
     * &lt;p&gt; Note that if this keystore has already been loaded, it is
     * reinitialized and loaded again from the given input stream.
     *
     * @param stream the input stream from which the keystore is loaded,
     * or {@code null}
     * @param password the password used to check the integrity of
     * the keystore, the password used to unlock the keystore,
     * or {@code null}
     *
     * @exception IOException if there is an I/O or format problem with the
     * keystore data, if a password is required but not given,
     * or if the given password was incorrect. If the error is due to a
     * wrong password, the {@link Throwable#getCause cause} of the
     * {@code IOException} should be an
     * {@code UnrecoverableKeyException}
     * @exception NoSuchAlgorithmException if the algorithm used to check
     * the integrity of the keystore cannot be found
     * @exception CertificateException if any of the certificates in the
     * keystore could not be loaded
     */
    public final void load(InputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
<span class="fc" id="L1433">        keyStoreSpi.engineLoad(stream, password);</span>
<span class="fc" id="L1434">        initialized = true;</span>
<span class="fc" id="L1435">    }</span>

    /**
     * Loads this keystore using the given {@code LoadStoreParameter}.
     *
     * &lt;p&gt; Note that if this KeyStore has already been loaded, it is
     * reinitialized and loaded again from the given parameter.
     *
     * @param param the {@code LoadStoreParameter}
     *          that specifies how to load the keystore,
     *          which may be {@code null}
     *
     * @exception IllegalArgumentException if the given
     *          {@code LoadStoreParameter}
     *          input is not recognized
     * @exception IOException if there is an I/O or format problem with the
     *          keystore data. If the error is due to an incorrect
     *         {@code ProtectionParameter} (e.g. wrong password)
     *         the {@link Throwable#getCause cause} of the
     *         {@code IOException} should be an
     *         {@code UnrecoverableKeyException}
     * @exception NoSuchAlgorithmException if the algorithm used to check
     *          the integrity of the keystore cannot be found
     * @exception CertificateException if any of the certificates in the
     *          keystore could not be loaded
     *
     * @since 1.5
     */
    public final void load(LoadStoreParameter param)
                throws IOException, NoSuchAlgorithmException,
                CertificateException {

<span class="fc" id="L1467">        keyStoreSpi.engineLoad(param);</span>
<span class="fc" id="L1468">        initialized = true;</span>
<span class="fc" id="L1469">    }</span>

    /**
     * Gets a keystore {@code Entry} for the specified alias
     * with the specified protection parameter.
     *
     * @param alias get the keystore {@code Entry} for this alias
     * @param protParam the {@code ProtectionParameter}
     *          used to protect the {@code Entry},
     *          which may be {@code null}
     *
     * @return the keystore {@code Entry} for the specified alias,
     *          or {@code null} if there is no such entry
     *
     * @exception NullPointerException if
     *          {@code alias} is {@code null}
     * @exception NoSuchAlgorithmException if the algorithm for recovering the
     *          entry cannot be found
     * @exception UnrecoverableEntryException if the specified
     *          {@code protParam} were insufficient or invalid
     * @exception UnrecoverableKeyException if the entry is a
     *          {@code PrivateKeyEntry} or {@code SecretKeyEntry}
     *          and the specified {@code protParam} does not contain
     *          the information needed to recover the key (e.g. wrong password)
     * @exception KeyStoreException if the keystore has not been initialized
     *          (loaded).
     * @see #setEntry(String, KeyStore.Entry, KeyStore.ProtectionParameter)
     *
     * @since 1.5
     */
    public final Entry getEntry(String alias, ProtectionParameter protParam)
                throws NoSuchAlgorithmException, UnrecoverableEntryException,
                KeyStoreException {

<span class="pc bpc" id="L1503" title="1 of 2 branches missed.">        if (alias == null) {</span>
<span class="nc" id="L1504">            throw new NullPointerException(&quot;invalid null input&quot;);</span>
        }
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1507">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1509">        return keyStoreSpi.engineGetEntry(alias, protParam);</span>
    }

    /**
     * Saves a keystore {@code Entry} under the specified alias.
     * The protection parameter is used to protect the
     * {@code Entry}.
     *
     * &lt;p&gt; If an entry already exists for the specified alias,
     * it is overridden.
     *
     * @param alias save the keystore {@code Entry} under this alias
     * @param entry the {@code Entry} to save
     * @param protParam the {@code ProtectionParameter}
     *          used to protect the {@code Entry},
     *          which may be {@code null}
     *
     * @exception NullPointerException if
     *          {@code alias} or {@code entry}
     *          is {@code null}
     * @exception KeyStoreException if the keystore has not been initialized
     *          (loaded), or if this operation fails for some other reason
     *
     * @see #getEntry(String, KeyStore.ProtectionParameter)
     *
     * @since 1.5
     */
    public final void setEntry(String alias, Entry entry,
                        ProtectionParameter protParam)
                throws KeyStoreException {
<span class="nc bnc" id="L1539" title="All 4 branches missed.">        if (alias == null || entry == null) {</span>
<span class="nc" id="L1540">            throw new NullPointerException(&quot;invalid null input&quot;);</span>
        }
<span class="nc bnc" id="L1542" title="All 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1543">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="nc" id="L1545">        keyStoreSpi.engineSetEntry(alias, entry, protParam);</span>
<span class="nc" id="L1546">    }</span>

    /**
     * Determines if the keystore {@code Entry} for the specified
     * {@code alias} is an instance or subclass of the specified
     * {@code entryClass}.
     *
     * @param alias the alias name
     * @param entryClass the entry class
     *
     * @return true if the keystore {@code Entry} for the specified
     *          {@code alias} is an instance or subclass of the
     *          specified {@code entryClass}, false otherwise
     *
     * @exception NullPointerException if
     *          {@code alias} or {@code entryClass}
     *          is {@code null}
     * @exception KeyStoreException if the keystore has not been
     *          initialized (loaded)
     *
     * @since 1.5
     */
    public final boolean
        entryInstanceOf(String alias,
                        Class&lt;? extends KeyStore.Entry&gt; entryClass)
        throws KeyStoreException
    {

<span class="pc bpc" id="L1574" title="2 of 4 branches missed.">        if (alias == null || entryClass == null) {</span>
<span class="nc" id="L1575">            throw new NullPointerException(&quot;invalid null input&quot;);</span>
        }
<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">        if (!initialized) {</span>
<span class="nc" id="L1578">            throw new KeyStoreException(&quot;Uninitialized keystore&quot;);</span>
        }
<span class="fc" id="L1580">        return keyStoreSpi.engineEntryInstanceOf(alias, entryClass);</span>
    }

    /**
     * A description of a to-be-instantiated KeyStore object.
     *
     * &lt;p&gt;An instance of this class encapsulates the information needed to
     * instantiate and initialize a KeyStore object. That process is
     * triggered when the {@linkplain #getKeyStore} method is called.
     *
     * &lt;p&gt;This makes it possible to decouple configuration from KeyStore
     * object creation and e.g. delay a password prompt until it is
     * needed.
     *
     * @see KeyStore
     * @see javax.net.ssl.KeyStoreBuilderParameters
     * @since 1.5
     */
    public static abstract class Builder {

        // maximum times to try the callbackhandler if the password is wrong
        static final int MAX_CALLBACK_TRIES = 3;

        /**
         * Construct a new Builder.
         */
<span class="fc" id="L1606">        protected Builder() {</span>
            // empty
<span class="fc" id="L1608">        }</span>

        /**
         * Returns the KeyStore described by this object.
         *
         * @return the {@code KeyStore} described by this object
         * @exception KeyStoreException if an error occurred during the
         *   operation, for example if the KeyStore could not be
         *   instantiated or loaded
         */
        public abstract KeyStore getKeyStore() throws KeyStoreException;

        /**
         * Returns the ProtectionParameters that should be used to obtain
         * the {@link KeyStore.Entry Entry} with the given alias.
         * The {@code getKeyStore} method must be invoked before this
         * method may be called.
         *
         * @return the ProtectionParameters that should be used to obtain
         *   the {@link KeyStore.Entry Entry} with the given alias.
         * @param alias the alias of the KeyStore entry
         * @throws NullPointerException if alias is null
         * @throws KeyStoreException if an error occurred during the
         *   operation
         * @throws IllegalStateException if the getKeyStore method has
         *   not been invoked prior to calling this method
         */
        public abstract ProtectionParameter getProtectionParameter(String alias)
            throws KeyStoreException;

        /**
         * Returns a new Builder that encapsulates the given KeyStore.
         * The {@linkplain #getKeyStore} method of the returned object
         * will return {@code keyStore}, the {@linkplain
         * #getProtectionParameter getProtectionParameter()} method will
         * return {@code protectionParameters}.
         *
         * &lt;p&gt; This is useful if an existing KeyStore object needs to be
         * used with Builder-based APIs.
         *
         * @return a new Builder object
         * @param keyStore the KeyStore to be encapsulated
         * @param protectionParameter the ProtectionParameter used to
         *   protect the KeyStore entries
         * @throws NullPointerException if keyStore or
         *   protectionParameters is null
         * @throws IllegalArgumentException if the keyStore has not been
         *   initialized
         */
        public static Builder newInstance(final KeyStore keyStore,
                final ProtectionParameter protectionParameter) {
<span class="pc bpc" id="L1659" title="2 of 4 branches missed.">            if ((keyStore == null) || (protectionParameter == null)) {</span>
<span class="nc" id="L1660">                throw new NullPointerException();</span>
            }
<span class="pc bpc" id="L1662" title="1 of 2 branches missed.">            if (keyStore.initialized == false) {</span>
<span class="nc" id="L1663">                throw new IllegalArgumentException(&quot;KeyStore not initialized&quot;);</span>
            }
<span class="fc" id="L1665">            return new Builder() {</span>
                private volatile boolean getCalled;

                public KeyStore getKeyStore() {
<span class="fc" id="L1669">                    getCalled = true;</span>
<span class="fc" id="L1670">                    return keyStore;</span>
                }

                public ProtectionParameter getProtectionParameter(String alias)
                {
<span class="pc bpc" id="L1675" title="1 of 2 branches missed.">                    if (alias == null) {</span>
<span class="nc" id="L1676">                        throw new NullPointerException();</span>
                    }
<span class="pc bpc" id="L1678" title="1 of 2 branches missed.">                    if (getCalled == false) {</span>
<span class="nc" id="L1679">                        throw new IllegalStateException</span>
                            (&quot;getKeyStore() must be called first&quot;);
                    }
<span class="fc" id="L1682">                    return protectionParameter;</span>
                }
            };
        }

        /**
         * Returns a new Builder object.
         *
         * &lt;p&gt;The first call to the {@link #getKeyStore} method on the returned
         * builder will create a KeyStore of type {@code type} and call
         * its {@link KeyStore#load load()} method.
         * The {@code inputStream} argument is constructed from
         * {@code file}.
         * If {@code protection} is a
         * {@code PasswordProtection}, the password is obtained by
         * calling the {@code getPassword} method.
         * Otherwise, if {@code protection} is a
         * {@code CallbackHandlerProtection}, the password is obtained
         * by invoking the CallbackHandler.
         *
         * &lt;p&gt;Subsequent calls to {@link #getKeyStore} return the same object
         * as the initial call. If the initial call to failed with a
         * KeyStoreException, subsequent calls also throw a
         * KeyStoreException.
         *
         * &lt;p&gt;The KeyStore is instantiated from {@code provider} if
         * non-null. Otherwise, all installed providers are searched.
         *
         * &lt;p&gt;Calls to {@link #getProtectionParameter getProtectionParameter()}
         * will return a {@link KeyStore.PasswordProtection PasswordProtection}
         * object encapsulating the password that was used to invoke the
         * {@code load} method.
         *
         * &lt;p&gt;&lt;em&gt;Note&lt;/em&gt; that the {@link #getKeyStore} method is executed
         * within the {@link AccessControlContext} of the code invoking this
         * method.
         *
         * @return a new Builder object
         * @param type the type of KeyStore to be constructed
         * @param provider the provider from which the KeyStore is to
         *   be instantiated (or null)
         * @param file the File that contains the KeyStore data
         * @param protection the ProtectionParameter securing the KeyStore data
         * @throws NullPointerException if type, file or protection is null
         * @throws IllegalArgumentException if protection is not an instance
         *   of either PasswordProtection or CallbackHandlerProtection; or
         *   if file does not exist or does not refer to a normal file
         */
        public static Builder newInstance(String type, Provider provider,
                File file, ProtectionParameter protection) {
<span class="pc bpc" id="L1732" title="3 of 6 branches missed.">            if ((type == null) || (file == null) || (protection == null)) {</span>
<span class="nc" id="L1733">                throw new NullPointerException();</span>
            }
<span class="pc bpc" id="L1735" title="3 of 4 branches missed.">            if ((protection instanceof PasswordProtection == false) &amp;&amp;</span>
                (protection instanceof CallbackHandlerProtection == false)) {
<span class="nc" id="L1737">                throw new IllegalArgumentException</span>
                (&quot;Protection must be PasswordProtection or &quot; +
                 &quot;CallbackHandlerProtection&quot;);
            }
<span class="pc bpc" id="L1741" title="1 of 2 branches missed.">            if (file.isFile() == false) {</span>
<span class="nc" id="L1742">                throw new IllegalArgumentException</span>
                    (&quot;File does not exist or it does not refer &quot; +
                     &quot;to a normal file: &quot; + file);
            }
<span class="fc" id="L1746">            return new FileBuilder(type, provider, file, protection,</span>
<span class="fc" id="L1747">                AccessController.getContext());</span>
        }

        private static final class FileBuilder extends Builder {

            private final String type;
            private final Provider provider;
            private final File file;
            private ProtectionParameter protection;
            private ProtectionParameter keyProtection;
            private final AccessControlContext context;

            private KeyStore keyStore;

            private Throwable oldException;

            FileBuilder(String type, Provider provider, File file,
                    ProtectionParameter protection,
<span class="fc" id="L1765">                    AccessControlContext context) {</span>
<span class="fc" id="L1766">                this.type = type;</span>
<span class="fc" id="L1767">                this.provider = provider;</span>
<span class="fc" id="L1768">                this.file = file;</span>
<span class="fc" id="L1769">                this.protection = protection;</span>
<span class="fc" id="L1770">                this.context = context;</span>
<span class="fc" id="L1771">            }</span>

            public synchronized KeyStore getKeyStore() throws KeyStoreException
            {
<span class="pc bpc" id="L1775" title="1 of 2 branches missed.">                if (keyStore != null) {</span>
<span class="nc" id="L1776">                    return keyStore;</span>
                }
<span class="pc bpc" id="L1778" title="1 of 2 branches missed.">                if (oldException != null) {</span>
<span class="nc" id="L1779">                    throw new KeyStoreException</span>
                        (&quot;Previous KeyStore instantiation failed&quot;,
                         oldException);
                }
<span class="fc" id="L1783">                PrivilegedExceptionAction&lt;KeyStore&gt; action =</span>
<span class="fc" id="L1784">                        new PrivilegedExceptionAction&lt;KeyStore&gt;() {</span>
                    public KeyStore run() throws Exception {
<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">                        if (protection instanceof CallbackHandlerProtection == false) {</span>
<span class="fc" id="L1787">                            return run0();</span>
                        }
                        // when using a CallbackHandler,
                        // reprompt if the password is wrong
<span class="nc" id="L1791">                        int tries = 0;</span>
                        while (true) {
<span class="nc" id="L1793">                            tries++;</span>
                            try {
<span class="nc" id="L1795">                                return run0();</span>
<span class="nc" id="L1796">                            } catch (IOException e) {</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">                                if ((tries &lt; MAX_CALLBACK_TRIES)</span>
<span class="nc bnc" id="L1798" title="All 2 branches missed.">                                        &amp;&amp; (e.getCause() instanceof UnrecoverableKeyException)) {</span>
<span class="nc" id="L1799">                                    continue;</span>
                                }
<span class="nc" id="L1801">                                throw e;</span>
                            }
                        }
                    }
                    public KeyStore run0() throws Exception {
                        KeyStore ks;
<span class="fc bfc" id="L1807" title="All 2 branches covered.">                        if (provider == null) {</span>
<span class="fc" id="L1808">                            ks = KeyStore.getInstance(type);</span>
                        } else {
<span class="fc" id="L1810">                            ks = KeyStore.getInstance(type, provider);</span>
                        }
<span class="fc" id="L1812">                        InputStream in = null;</span>
<span class="fc" id="L1813">                        char[] password = null;</span>
                        try {
<span class="fc" id="L1815">                            in = new FileInputStream(file);</span>
<span class="pc bpc" id="L1816" title="1 of 2 branches missed.">                            if (protection instanceof PasswordProtection) {</span>
<span class="fc" id="L1817">                                password =</span>
<span class="fc" id="L1818">                                ((PasswordProtection)protection).getPassword();</span>
<span class="fc" id="L1819">                                keyProtection = protection;</span>
                            } else {
<span class="nc" id="L1821">                                CallbackHandler handler =</span>
<span class="nc" id="L1822">                                    ((CallbackHandlerProtection)protection)</span>
<span class="nc" id="L1823">                                    .getCallbackHandler();</span>
<span class="nc" id="L1824">                                PasswordCallback callback = new PasswordCallback</span>
<span class="nc" id="L1825">                                    (&quot;Password for keystore &quot; + file.getName(),</span>
                                    false);
<span class="nc" id="L1827">                                handler.handle(new Callback[] {callback});</span>
<span class="nc" id="L1828">                                password = callback.getPassword();</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">                                if (password == null) {</span>
<span class="nc" id="L1830">                                    throw new KeyStoreException(&quot;No password&quot; +</span>
                                                                &quot; provided&quot;);
                                }
<span class="nc" id="L1833">                                callback.clearPassword();</span>
<span class="nc" id="L1834">                                keyProtection = new PasswordProtection(password);</span>
                            }
<span class="fc" id="L1836">                            ks.load(in, password);</span>
<span class="fc" id="L1837">                            return ks;</span>
                        } finally {
<span class="pc bpc" id="L1839" title="2 of 4 branches missed.">                            if (in != null) {</span>
<span class="fc" id="L1840">                                in.close();</span>
                            }
                        }
                    }
                };
                try {
<span class="fc" id="L1846">                    keyStore = AccessController.doPrivileged(action, context);</span>
<span class="fc" id="L1847">                    return keyStore;</span>
<span class="nc" id="L1848">                } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L1849">                    oldException = e.getCause();</span>
<span class="nc" id="L1850">                    throw new KeyStoreException</span>
                        (&quot;KeyStore instantiation failed&quot;, oldException);
                }
            }

            public synchronized ProtectionParameter
                        getProtectionParameter(String alias) {
<span class="nc bnc" id="L1857" title="All 2 branches missed.">                if (alias == null) {</span>
<span class="nc" id="L1858">                    throw new NullPointerException();</span>
                }
<span class="nc bnc" id="L1860" title="All 2 branches missed.">                if (keyStore == null) {</span>
<span class="nc" id="L1861">                    throw new IllegalStateException</span>
                        (&quot;getKeyStore() must be called first&quot;);
                }
<span class="nc" id="L1864">                return keyProtection;</span>
            }
        }

        /**
         * Returns a new Builder object.
         *
         * &lt;p&gt;Each call to the {@link #getKeyStore} method on the returned
         * builder will return a new KeyStore object of type {@code type}.
         * Its {@link KeyStore#load(KeyStore.LoadStoreParameter) load()}
         * method is invoked using a
         * {@code LoadStoreParameter} that encapsulates
         * {@code protection}.
         *
         * &lt;p&gt;The KeyStore is instantiated from {@code provider} if
         * non-null. Otherwise, all installed providers are searched.
         *
         * &lt;p&gt;Calls to {@link #getProtectionParameter getProtectionParameter()}
         * will return {@code protection}.
         *
         * &lt;p&gt;&lt;em&gt;Note&lt;/em&gt; that the {@link #getKeyStore} method is executed
         * within the {@link AccessControlContext} of the code invoking this
         * method.
         *
         * @return a new Builder object
         * @param type the type of KeyStore to be constructed
         * @param provider the provider from which the KeyStore is to
         *   be instantiated (or null)
         * @param protection the ProtectionParameter securing the Keystore
         * @throws NullPointerException if type or protection is null
         */
        public static Builder newInstance(final String type,
                final Provider provider, final ProtectionParameter protection) {
<span class="nc bnc" id="L1897" title="All 4 branches missed.">            if ((type == null) || (protection == null)) {</span>
<span class="nc" id="L1898">                throw new NullPointerException();</span>
            }
<span class="nc" id="L1900">            final AccessControlContext context = AccessController.getContext();</span>
<span class="nc" id="L1901">            return new Builder() {</span>
                private volatile boolean getCalled;
                private IOException oldException;

<span class="nc" id="L1905">                private final PrivilegedExceptionAction&lt;KeyStore&gt; action</span>
<span class="nc" id="L1906">                        = new PrivilegedExceptionAction&lt;KeyStore&gt;() {</span>

                    public KeyStore run() throws Exception {
                        KeyStore ks;
<span class="nc bnc" id="L1910" title="All 2 branches missed.">                        if (provider == null) {</span>
<span class="nc" id="L1911">                            ks = KeyStore.getInstance(type);</span>
                        } else {
<span class="nc" id="L1913">                            ks = KeyStore.getInstance(type, provider);</span>
                        }
<span class="nc" id="L1915">                        LoadStoreParameter param = new SimpleLoadStoreParameter(protection);</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">                        if (protection instanceof CallbackHandlerProtection == false) {</span>
<span class="nc" id="L1917">                            ks.load(param);</span>
                        } else {
                            // when using a CallbackHandler,
                            // reprompt if the password is wrong
<span class="nc" id="L1921">                            int tries = 0;</span>
                            while (true) {
<span class="nc" id="L1923">                                tries++;</span>
                                try {
<span class="nc" id="L1925">                                    ks.load(param);</span>
<span class="nc" id="L1926">                                    break;</span>
<span class="nc" id="L1927">                                } catch (IOException e) {</span>
<span class="nc bnc" id="L1928" title="All 2 branches missed.">                                    if (e.getCause() instanceof UnrecoverableKeyException) {</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">                                        if (tries &lt; MAX_CALLBACK_TRIES) {</span>
<span class="nc" id="L1930">                                            continue;</span>
                                        } else {
<span class="nc" id="L1932">                                            oldException = e;</span>
                                        }
                                    }
<span class="nc" id="L1935">                                    throw e;</span>
                                }
                            }
                        }
<span class="nc" id="L1939">                        getCalled = true;</span>
<span class="nc" id="L1940">                        return ks;</span>
                    }
                };

                public synchronized KeyStore getKeyStore()
                        throws KeyStoreException {
<span class="nc bnc" id="L1946" title="All 2 branches missed.">                    if (oldException != null) {</span>
<span class="nc" id="L1947">                        throw new KeyStoreException</span>
                            (&quot;Previous KeyStore instantiation failed&quot;,
                             oldException);
                    }
                    try {
<span class="nc" id="L1952">                        return AccessController.doPrivileged(action, context);</span>
<span class="nc" id="L1953">                    } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L1954">                        Throwable cause = e.getCause();</span>
<span class="nc" id="L1955">                        throw new KeyStoreException</span>
                            (&quot;KeyStore instantiation failed&quot;, cause);
                    }
                }

                public ProtectionParameter getProtectionParameter(String alias)
                {
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                    if (alias == null) {</span>
<span class="nc" id="L1963">                        throw new NullPointerException();</span>
                    }
<span class="nc bnc" id="L1965" title="All 2 branches missed.">                    if (getCalled == false) {</span>
<span class="nc" id="L1966">                        throw new IllegalStateException</span>
                            (&quot;getKeyStore() must be called first&quot;);
                    }
<span class="nc" id="L1969">                    return protection;</span>
                }
            };
        }

    }

    static class SimpleLoadStoreParameter implements LoadStoreParameter {

        private final ProtectionParameter protection;

<span class="nc" id="L1980">        SimpleLoadStoreParameter(ProtectionParameter protection) {</span>
<span class="nc" id="L1981">            this.protection = protection;</span>
<span class="nc" id="L1982">        }</span>

        public ProtectionParameter getProtectionParameter() {
<span class="nc" id="L1985">            return protection;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>