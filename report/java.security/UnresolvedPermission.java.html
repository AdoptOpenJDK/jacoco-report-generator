<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>UnresolvedPermission.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">UnresolvedPermission.java</span></div><h1>UnresolvedPermission.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.Hashtable;
import java.lang.reflect.*;
import java.security.cert.*;

/**
 * The UnresolvedPermission class is used to hold Permissions that
 * were &quot;unresolved&quot; when the Policy was initialized.
 * An unresolved permission is one whose actual Permission class
 * does not yet exist at the time the Policy is initialized (see below).
 *
 * &lt;p&gt;The policy for a Java runtime (specifying
 * which permissions are available for code from various principals)
 * is represented by a Policy object.
 * Whenever a Policy is initialized or refreshed, Permission objects of
 * appropriate classes are created for all permissions
 * allowed by the Policy.
 *
 * &lt;p&gt;Many permission class types
 * referenced by the policy configuration are ones that exist
 * locally (i.e., ones that can be found on CLASSPATH).
 * Objects for such permissions can be instantiated during
 * Policy initialization. For example, it is always possible
 * to instantiate a java.io.FilePermission, since the
 * FilePermission class is found on the CLASSPATH.
 *
 * &lt;p&gt;Other permission classes may not yet exist during Policy
 * initialization. For example, a referenced permission class may
 * be in a JAR file that will later be loaded.
 * For each such class, an UnresolvedPermission is instantiated.
 * Thus, an UnresolvedPermission is essentially a &quot;placeholder&quot;
 * containing information about the permission.
 *
 * &lt;p&gt;Later, when code calls AccessController.checkPermission
 * on a permission of a type that was previously unresolved,
 * but whose class has since been loaded, previously-unresolved
 * permissions of that type are &quot;resolved&quot;. That is,
 * for each such UnresolvedPermission, a new object of
 * the appropriate class type is instantiated, based on the
 * information in the UnresolvedPermission.
 *
 * &lt;p&gt; To instantiate the new class, UnresolvedPermission assumes
 * the class provides a zero, one, and/or two-argument constructor.
 * The zero-argument constructor would be used to instantiate
 * a permission without a name and without actions.
 * A one-arg constructor is assumed to take a {@code String}
 * name as input, and a two-arg constructor is assumed to take a
 * {@code String} name and {@code String} actions
 * as input.  UnresolvedPermission may invoke a
 * constructor with a {@code null} name and/or actions.
 * If an appropriate permission constructor is not available,
 * the UnresolvedPermission is ignored and the relevant permission
 * will not be granted to executing code.
 *
 * &lt;p&gt; The newly created permission object replaces the
 * UnresolvedPermission, which is removed.
 *
 * &lt;p&gt; Note that the {@code getName} method for an
 * {@code UnresolvedPermission} returns the
 * {@code type} (class name) for the underlying permission
 * that has not been resolved.
 *
 * @see java.security.Permission
 * @see java.security.Permissions
 * @see java.security.PermissionCollection
 * @see java.security.Policy
 *
 *
 * @author Roland Schemers
 */

public final class UnresolvedPermission extends Permission
implements java.io.Serializable
{

    private static final long serialVersionUID = -4821973115467008846L;

<span class="fc" id="L107">    private static final sun.security.util.Debug debug =</span>
        sun.security.util.Debug.getInstance
<span class="fc" id="L109">        (&quot;policy,access&quot;, &quot;UnresolvedPermission&quot;);</span>

    /**
     * The class name of the Permission class that will be
     * created when this unresolved permission is resolved.
     *
     * @serial
     */
    private String type;

    /**
     * The permission name.
     *
     * @serial
     */
    private String name;

    /**
     * The actions of the permission.
     *
     * @serial
     */
    private String actions;

    private transient java.security.cert.Certificate certs[];

    /**
     * Creates a new UnresolvedPermission containing the permission
     * information needed later to actually create a Permission of the
     * specified class, when the permission is resolved.
     *
     * @param type the class name of the Permission class that will be
     * created when this unresolved permission is resolved.
     * @param name the name of the permission.
     * @param actions the actions of the permission.
     * @param certs the certificates the permission's class was signed with.
     * This is a list of certificate chains, where each chain is composed of a
     * signer certificate and optionally its supporting certificate chain.
     * Each chain is ordered bottom-to-top (i.e., with the signer certificate
     * first and the (root) certificate authority last). The signer
     * certificates are copied from the array. Subsequent changes to
     * the array will not affect this UnsolvedPermission.
     */
    public UnresolvedPermission(String type,
                                String name,
                                String actions,
                                java.security.cert.Certificate certs[])
    {
<span class="fc" id="L157">        super(type);</span>

<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        if (type == null)</span>
<span class="nc" id="L160">                throw new NullPointerException(&quot;type can't be null&quot;);</span>

<span class="fc" id="L162">        this.type = type;</span>
<span class="fc" id="L163">        this.name = name;</span>
<span class="fc" id="L164">        this.actions = actions;</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">        if (certs != null) {</span>
            // Extract the signer certs from the list of certificates.
<span class="nc bnc" id="L167" title="All 2 branches missed.">            for (int i=0; i&lt;certs.length; i++) {</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">                if (!(certs[i] instanceof X509Certificate)) {</span>
                    // there is no concept of signer certs, so we store the
                    // entire cert array
<span class="nc" id="L171">                    this.certs = certs.clone();</span>
<span class="nc" id="L172">                    break;</span>
                }
            }

<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (this.certs == null) {</span>
                // Go through the list of certs and see if all the certs are
                // signer certs.
<span class="nc" id="L179">                int i = 0;</span>
<span class="nc" id="L180">                int count = 0;</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">                while (i &lt; certs.length) {</span>
<span class="nc" id="L182">                    count++;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                    while (((i+1) &lt; certs.length) &amp;&amp;</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">                           ((X509Certificate)certs[i]).getIssuerDN().equals(</span>
<span class="nc" id="L185">                               ((X509Certificate)certs[i+1]).getSubjectDN())) {</span>
<span class="nc" id="L186">                        i++;</span>
                    }
<span class="nc" id="L188">                    i++;</span>
                }
<span class="nc bnc" id="L190" title="All 2 branches missed.">                if (count == certs.length) {</span>
                    // All the certs are signer certs, so we store the entire
                    // array
<span class="nc" id="L193">                    this.certs = certs.clone();</span>
                }

<span class="nc bnc" id="L196" title="All 2 branches missed.">                if (this.certs == null) {</span>
                    // extract the signer certs
<span class="nc" id="L198">                    ArrayList&lt;java.security.cert.Certificate&gt; signerCerts =</span>
                        new ArrayList&lt;&gt;();
<span class="nc" id="L200">                    i = 0;</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                    while (i &lt; certs.length) {</span>
<span class="nc" id="L202">                        signerCerts.add(certs[i]);</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                        while (((i+1) &lt; certs.length) &amp;&amp;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">                            ((X509Certificate)certs[i]).getIssuerDN().equals(</span>
<span class="nc" id="L205">                              ((X509Certificate)certs[i+1]).getSubjectDN())) {</span>
<span class="nc" id="L206">                            i++;</span>
                        }
<span class="nc" id="L208">                        i++;</span>
                    }
<span class="nc" id="L210">                    this.certs =</span>
<span class="nc" id="L211">                        new java.security.cert.Certificate[signerCerts.size()];</span>
<span class="nc" id="L212">                    signerCerts.toArray(this.certs);</span>
                }
            }
        }
<span class="fc" id="L216">    }</span>


<span class="fc" id="L219">    private static final Class[] PARAMS0 = { };</span>
<span class="fc" id="L220">    private static final Class[] PARAMS1 = { String.class };</span>
<span class="fc" id="L221">    private static final Class[] PARAMS2 = { String.class, String.class };</span>

    /**
     * try and resolve this permission using the class loader of the permission
     * that was passed in.
     */
    Permission resolve(Permission p, java.security.cert.Certificate certs[]) {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (this.certs != null) {</span>
            // if p wasn't signed, we don't have a match
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (certs == null) {</span>
<span class="nc" id="L231">                return null;</span>
            }

            // all certs in this.certs must be present in certs
            boolean match;
<span class="nc bnc" id="L236" title="All 2 branches missed.">            for (int i = 0; i &lt; this.certs.length; i++) {</span>
<span class="nc" id="L237">                match = false;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                for (int j = 0; j &lt; certs.length; j++) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                    if (this.certs[i].equals(certs[j])) {</span>
<span class="nc" id="L240">                        match = true;</span>
<span class="nc" id="L241">                        break;</span>
                    }
                }
<span class="nc bnc" id="L244" title="All 2 branches missed.">                if (!match) return null;</span>
            }
        }
        try {
<span class="fc" id="L248">            Class&lt;?&gt; pc = p.getClass();</span>

<span class="pc bpc" id="L250" title="1 of 4 branches missed.">            if (name == null &amp;&amp; actions == null) {</span>
                try {
<span class="fc" id="L252">                    Constructor&lt;?&gt; c = pc.getConstructor(PARAMS0);</span>
<span class="fc" id="L253">                    return (Permission)c.newInstance(new Object[] {});</span>
<span class="nc" id="L254">                } catch (NoSuchMethodException ne) {</span>
                    try {
<span class="nc" id="L256">                        Constructor&lt;?&gt; c = pc.getConstructor(PARAMS1);</span>
<span class="nc" id="L257">                        return (Permission) c.newInstance(</span>
                              new Object[] { name});
<span class="nc" id="L259">                    } catch (NoSuchMethodException ne1) {</span>
<span class="nc" id="L260">                        Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);</span>
<span class="nc" id="L261">                        return (Permission) c.newInstance(</span>
                              new Object[] { name, actions });
                    }
                }
            } else {
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">                if (name != null &amp;&amp; actions == null) {</span>
                    try {
<span class="fc" id="L268">                        Constructor&lt;?&gt; c = pc.getConstructor(PARAMS1);</span>
<span class="fc" id="L269">                        return (Permission) c.newInstance(</span>
                              new Object[] { name});
<span class="fc" id="L271">                    } catch (NoSuchMethodException ne) {</span>
<span class="fc" id="L272">                        Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);</span>
<span class="fc" id="L273">                        return (Permission) c.newInstance(</span>
                              new Object[] { name, actions });
                    }
                } else {
<span class="fc" id="L277">                    Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);</span>
<span class="fc" id="L278">                    return (Permission) c.newInstance(</span>
                          new Object[] { name, actions });
                }
            }
<span class="fc" id="L282">        } catch (NoSuchMethodException nsme) {</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            if (debug != null ) {</span>
<span class="fc" id="L284">                debug.println(&quot;NoSuchMethodException:\n  could not find &quot; +</span>
                        &quot;proper constructor for &quot; + type);
<span class="fc" id="L286">                nsme.printStackTrace();</span>
            }
<span class="fc" id="L288">            return null;</span>
<span class="nc" id="L289">        } catch (Exception e) {</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (debug != null ) {</span>
<span class="nc" id="L291">                debug.println(&quot;unable to instantiate &quot; + name);</span>
<span class="nc" id="L292">                e.printStackTrace();</span>
            }
<span class="nc" id="L294">            return null;</span>
        }
    }

    /**
     * This method always returns false for unresolved permissions.
     * That is, an UnresolvedPermission is never considered to
     * imply another permission.
     *
     * @param p the permission to check against.
     *
     * @return false.
     */
    public boolean implies(Permission p) {
<span class="nc" id="L308">        return false;</span>
    }

    /**
     * Checks two UnresolvedPermission objects for equality.
     * Checks that &lt;i&gt;obj&lt;/i&gt; is an UnresolvedPermission, and has
     * the same type (class) name, permission name, actions, and
     * certificates as this object.
     *
     * &lt;p&gt; To determine certificate equality, this method only compares
     * actual signer certificates.  Supporting certificate chains
     * are not taken into consideration by this method.
     *
     * @param obj the object we are testing for equality with this object.
     *
     * @return true if obj is an UnresolvedPermission, and has the same
     * type (class) name, permission name, actions, and
     * certificates as this object.
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L329">            return true;</span>

<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (! (obj instanceof UnresolvedPermission))</span>
<span class="nc" id="L332">            return false;</span>
<span class="fc" id="L333">        UnresolvedPermission that = (UnresolvedPermission) obj;</span>

        // check type
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">        if (!this.type.equals(that.type)) {</span>
<span class="nc" id="L337">            return false;</span>
        }

        // check name
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (this.name == null) {</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            if (that.name != null) {</span>
<span class="nc" id="L343">                return false;</span>
            }
<span class="nc bnc" id="L345" title="All 2 branches missed.">        } else if (!this.name.equals(that.name)) {</span>
<span class="nc" id="L346">            return false;</span>
        }

        // check actions
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (this.actions == null) {</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">            if (that.actions != null) {</span>
<span class="nc" id="L352">                return false;</span>
            }
        } else {
<span class="nc bnc" id="L355" title="All 2 branches missed.">            if (!this.actions.equals(that.actions)) {</span>
<span class="nc" id="L356">                return false;</span>
            }
        }

        // check certs
<span class="pc bpc" id="L361" title="10 of 14 branches missed.">        if ((this.certs == null &amp;&amp; that.certs != null) ||</span>
            (this.certs != null &amp;&amp; that.certs == null) ||
            (this.certs != null &amp;&amp; that.certs != null &amp;&amp;
                this.certs.length != that.certs.length)) {
<span class="nc" id="L365">            return false;</span>
        }

        int i,j;
        boolean match;

<span class="pc bpc" id="L371" title="3 of 4 branches missed.">        for (i = 0; this.certs != null &amp;&amp; i &lt; this.certs.length; i++) {</span>
<span class="nc" id="L372">            match = false;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            for (j = 0; j &lt; that.certs.length; j++) {</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                if (this.certs[i].equals(that.certs[j])) {</span>
<span class="nc" id="L375">                    match = true;</span>
<span class="nc" id="L376">                    break;</span>
                }
            }
<span class="nc bnc" id="L379" title="All 2 branches missed.">            if (!match) return false;</span>
        }

<span class="pc bpc" id="L382" title="3 of 4 branches missed.">        for (i = 0; that.certs != null &amp;&amp; i &lt; that.certs.length; i++) {</span>
<span class="nc" id="L383">            match = false;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">            for (j = 0; j &lt; this.certs.length; j++) {</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">                if (that.certs[i].equals(this.certs[j])) {</span>
<span class="nc" id="L386">                    match = true;</span>
<span class="nc" id="L387">                    break;</span>
                }
            }
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (!match) return false;</span>
        }
<span class="fc" id="L392">        return true;</span>
    }

    /**
     * Returns the hash code value for this object.
     *
     * @return a hash code value for this object.
     */

    public int hashCode() {
<span class="nc" id="L402">        int hash = type.hashCode();</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (name != null)</span>
<span class="nc" id="L404">            hash ^= name.hashCode();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (actions != null)</span>
<span class="nc" id="L406">            hash ^= actions.hashCode();</span>
<span class="nc" id="L407">        return hash;</span>
    }

    /**
     * Returns the canonical string representation of the actions,
     * which currently is the empty string &quot;&quot;, since there are no actions for
     * an UnresolvedPermission. That is, the actions for the
     * permission that will be created when this UnresolvedPermission
     * is resolved may be non-null, but an UnresolvedPermission
     * itself is never considered to have any actions.
     *
     * @return the empty string &quot;&quot;.
     */
    public String getActions()
    {
<span class="nc" id="L422">        return &quot;&quot;;</span>
    }

    /**
     * Get the type (class name) of the underlying permission that
     * has not been resolved.
     *
     * @return the type (class name) of the underlying permission that
     *  has not been resolved
     *
     * @since 1.5
     */
    public String getUnresolvedType() {
<span class="nc" id="L435">        return type;</span>
    }

    /**
     * Get the target name of the underlying permission that
     * has not been resolved.
     *
     * @return the target name of the underlying permission that
     *          has not been resolved, or {@code null},
     *          if there is no target name
     *
     * @since 1.5
     */
    public String getUnresolvedName() {
<span class="nc" id="L449">        return name;</span>
    }

    /**
     * Get the actions for the underlying permission that
     * has not been resolved.
     *
     * @return the actions for the underlying permission that
     *          has not been resolved, or {@code null}
     *          if there are no actions
     *
     * @since 1.5
     */
    public String getUnresolvedActions() {
<span class="nc" id="L463">        return actions;</span>
    }

    /**
     * Get the signer certificates (without any supporting chain)
     * for the underlying permission that has not been resolved.
     *
     * @return the signer certificates for the underlying permission that
     * has not been resolved, or null, if there are no signer certificates.
     * Returns a new array each time this method is called.
     *
     * @since 1.5
     */
    public java.security.cert.Certificate[] getUnresolvedCerts() {
<span class="nc bnc" id="L477" title="All 2 branches missed.">        return (certs == null) ? null : certs.clone();</span>
    }

    /**
     * Returns a string describing this UnresolvedPermission.  The convention
     * is to specify the class name, the permission name, and the actions, in
     * the following format: '(unresolved &quot;ClassName&quot; &quot;name&quot; &quot;actions&quot;)'.
     *
     * @return information about this UnresolvedPermission.
     */
    public String toString() {
<span class="fc" id="L488">        return &quot;(unresolved &quot; + type + &quot; &quot; + name + &quot; &quot; + actions + &quot;)&quot;;</span>
    }

    /**
     * Returns a new PermissionCollection object for storing
     * UnresolvedPermission  objects.
     * &lt;p&gt;
     * @return a new PermissionCollection object suitable for
     * storing UnresolvedPermissions.
     */

    public PermissionCollection newPermissionCollection() {
<span class="fc" id="L500">        return new UnresolvedPermissionCollection();</span>
    }

    /**
     * Writes this object out to a stream (i.e., serializes it).
     *
     * @serialData An initial {@code String} denoting the
     * {@code type} is followed by a {@code String} denoting the
     * {@code name} is followed by a {@code String} denoting the
     * {@code actions} is followed by an {@code int} indicating the
     * number of certificates to follow
     * (a value of &quot;zero&quot; denotes that there are no certificates associated
     * with this object).
     * Each certificate is written out starting with a {@code String}
     * denoting the certificate type, followed by an
     * {@code int} specifying the length of the certificate encoding,
     * followed by the certificate encoding itself which is written out as an
     * array of bytes.
     */
    private void writeObject(java.io.ObjectOutputStream oos)
        throws IOException
    {
<span class="nc" id="L522">        oos.defaultWriteObject();</span>

<span class="nc bnc" id="L524" title="All 4 branches missed.">        if (certs==null || certs.length==0) {</span>
<span class="nc" id="L525">            oos.writeInt(0);</span>
        } else {
            // write out the total number of certs
<span class="nc" id="L528">            oos.writeInt(certs.length);</span>
            // write out each cert, including its type
<span class="nc bnc" id="L530" title="All 2 branches missed.">            for (int i=0; i &lt; certs.length; i++) {</span>
<span class="nc" id="L531">                java.security.cert.Certificate cert = certs[i];</span>
                try {
<span class="nc" id="L533">                    oos.writeUTF(cert.getType());</span>
<span class="nc" id="L534">                    byte[] encoded = cert.getEncoded();</span>
<span class="nc" id="L535">                    oos.writeInt(encoded.length);</span>
<span class="nc" id="L536">                    oos.write(encoded);</span>
<span class="nc" id="L537">                } catch (CertificateEncodingException cee) {</span>
<span class="nc" id="L538">                    throw new IOException(cee.getMessage());</span>
<span class="nc" id="L539">                }</span>
            }
        }
<span class="nc" id="L542">    }</span>

    /**
     * Restores this object from a stream (i.e., deserializes it).
     */
    private void readObject(java.io.ObjectInputStream ois)
        throws IOException, ClassNotFoundException
    {
        CertificateFactory cf;
<span class="nc" id="L551">        Hashtable&lt;String, CertificateFactory&gt; cfs = null;</span>

<span class="nc" id="L553">        ois.defaultReadObject();</span>

<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (type == null)</span>
<span class="nc" id="L556">                throw new NullPointerException(&quot;type can't be null&quot;);</span>

        // process any new-style certs in the stream (if present)
<span class="nc" id="L559">        int size = ois.readInt();</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (size &gt; 0) {</span>
            // we know of 3 different cert types: X.509, PGP, SDSI, which
            // could all be present in the stream at the same time
<span class="nc" id="L563">            cfs = new Hashtable&lt;String, CertificateFactory&gt;(3);</span>
<span class="nc" id="L564">            this.certs = new java.security.cert.Certificate[size];</span>
        }

<span class="nc bnc" id="L567" title="All 2 branches missed.">        for (int i=0; i&lt;size; i++) {</span>
            // read the certificate type, and instantiate a certificate
            // factory of that type (reuse existing factory if possible)
<span class="nc" id="L570">            String certType = ois.readUTF();</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">            if (cfs.containsKey(certType)) {</span>
                // reuse certificate factory
<span class="nc" id="L573">                cf = cfs.get(certType);</span>
            } else {
                // create new certificate factory
                try {
<span class="nc" id="L577">                    cf = CertificateFactory.getInstance(certType);</span>
<span class="nc" id="L578">                } catch (CertificateException ce) {</span>
<span class="nc" id="L579">                    throw new ClassNotFoundException</span>
                        (&quot;Certificate factory for &quot;+certType+&quot; not found&quot;);
<span class="nc" id="L581">                }</span>
                // store the certificate factory so we can reuse it later
<span class="nc" id="L583">                cfs.put(certType, cf);</span>
            }
            // parse the certificate
<span class="nc" id="L586">            byte[] encoded=null;</span>
            try {
<span class="nc" id="L588">                encoded = new byte[ois.readInt()];</span>
<span class="nc" id="L589">            } catch (OutOfMemoryError oome) {</span>
<span class="nc" id="L590">                throw new IOException(&quot;Certificate too big&quot;);</span>
<span class="nc" id="L591">            }</span>
<span class="nc" id="L592">            ois.readFully(encoded);</span>
<span class="nc" id="L593">            ByteArrayInputStream bais = new ByteArrayInputStream(encoded);</span>
            try {
<span class="nc" id="L595">                this.certs[i] = cf.generateCertificate(bais);</span>
<span class="nc" id="L596">            } catch (CertificateException ce) {</span>
<span class="nc" id="L597">                throw new IOException(ce.getMessage());</span>
<span class="nc" id="L598">            }</span>
<span class="nc" id="L599">            bais.close();</span>
        }
<span class="nc" id="L601">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>