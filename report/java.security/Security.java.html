<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Security.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.security</a> &gt; <span class="el_source">Security.java</span></div><h1>Security.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.security;

import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.io.*;
import java.net.URL;
import sun.security.util.Debug;
import sun.security.util.PropertyExpander;

import sun.security.jca.*;

/**
 * &lt;p&gt;This class centralizes all security properties and common security
 * methods. One of its primary uses is to manage providers.
 *
 * &lt;p&gt;The default values of security properties are read from an
 * implementation-specific location, which is typically the properties file
 * {@code lib/security/java.security} in the Java installation directory.
 *
 * @author Benjamin Renaud
 */

public final class Security {

    /* Are we debugging? -- for developers */
<span class="nc" id="L52">    private static final Debug sdebug =</span>
<span class="nc" id="L53">                        Debug.getInstance(&quot;properties&quot;);</span>

    /* The java.security properties */
    private static Properties props;

    // An element in the cache
<span class="nc" id="L59">    private static class ProviderProperty {</span>
        String className;
        Provider provider;
    }

    static {
        // doPrivileged here because there are multiple
        // things in initialize that might require privs.
        // (the FileInputStream call and the File.exists call,
        // the securityPropFile call, etc)
<span class="nc" id="L69">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
            public Void run() {
<span class="nc" id="L71">                initialize();</span>
<span class="nc" id="L72">                return null;</span>
            }
        });
    }

    private static void initialize() {
<span class="nc" id="L78">        props = new Properties();</span>
<span class="nc" id="L79">        boolean loadedProps = false;</span>
<span class="nc" id="L80">        boolean overrideAll = false;</span>

        // first load the system properties file
        // to determine the value of security.overridePropertiesFile
<span class="nc" id="L84">        File propFile = securityPropFile(&quot;java.security&quot;);</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (propFile.exists()) {</span>
<span class="nc" id="L86">            InputStream is = null;</span>
            try {
<span class="nc" id="L88">                FileInputStream fis = new FileInputStream(propFile);</span>
<span class="nc" id="L89">                is = new BufferedInputStream(fis);</span>
<span class="nc" id="L90">                props.load(is);</span>
<span class="nc" id="L91">                loadedProps = true;</span>

<span class="nc bnc" id="L93" title="All 2 branches missed.">                if (sdebug != null) {</span>
<span class="nc" id="L94">                    sdebug.println(&quot;reading security properties file: &quot; +</span>
                                propFile);
                }
<span class="nc" id="L97">            } catch (IOException e) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                if (sdebug != null) {</span>
<span class="nc" id="L99">                    sdebug.println(&quot;unable to load security properties from &quot; +</span>
                                propFile);
<span class="nc" id="L101">                    e.printStackTrace();</span>
                }
            } finally {
<span class="nc bnc" id="L104" title="All 6 branches missed.">                if (is != null) {</span>
                    try {
<span class="nc" id="L106">                        is.close();</span>
<span class="nc" id="L107">                    } catch (IOException ioe) {</span>
<span class="nc bnc" id="L108" title="All 6 branches missed.">                        if (sdebug != null) {</span>
<span class="nc" id="L109">                            sdebug.println(&quot;unable to close input stream&quot;);</span>
                        }
<span class="nc" id="L111">                    }</span>
                }
            }
        }

<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (&quot;true&quot;.equalsIgnoreCase(props.getProperty</span>
<span class="nc" id="L117">                (&quot;security.overridePropertiesFile&quot;))) {</span>

<span class="nc" id="L119">            String extraPropFile = System.getProperty</span>
<span class="nc" id="L120">                                        (&quot;java.security.properties&quot;);</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">            if (extraPropFile != null &amp;&amp; extraPropFile.startsWith(&quot;=&quot;)) {</span>
<span class="nc" id="L122">                overrideAll = true;</span>
<span class="nc" id="L123">                extraPropFile = extraPropFile.substring(1);</span>
            }

<span class="nc bnc" id="L126" title="All 2 branches missed.">            if (overrideAll) {</span>
<span class="nc" id="L127">                props = new Properties();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                if (sdebug != null) {</span>
<span class="nc" id="L129">                    sdebug.println</span>
<span class="nc" id="L130">                        (&quot;overriding other security properties files!&quot;);</span>
                }
            }

            // now load the user-specified file so its values
            // will win if they conflict with the earlier values
<span class="nc bnc" id="L136" title="All 2 branches missed.">            if (extraPropFile != null) {</span>
<span class="nc" id="L137">                BufferedInputStream bis = null;</span>
                try {
                    URL propURL;

<span class="nc" id="L141">                    extraPropFile = PropertyExpander.expand(extraPropFile);</span>
<span class="nc" id="L142">                    propFile = new File(extraPropFile);</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                    if (propFile.exists()) {</span>
<span class="nc" id="L144">                        propURL = new URL</span>
<span class="nc" id="L145">                                (&quot;file:&quot; + propFile.getCanonicalPath());</span>
                    } else {
<span class="nc" id="L147">                        propURL = new URL(extraPropFile);</span>
                    }
<span class="nc" id="L149">                    bis = new BufferedInputStream(propURL.openStream());</span>
<span class="nc" id="L150">                    props.load(bis);</span>
<span class="nc" id="L151">                    loadedProps = true;</span>

<span class="nc bnc" id="L153" title="All 2 branches missed.">                    if (sdebug != null) {</span>
<span class="nc" id="L154">                        sdebug.println(&quot;reading security properties file: &quot; +</span>
                                        propURL);
<span class="nc bnc" id="L156" title="All 2 branches missed.">                        if (overrideAll) {</span>
<span class="nc" id="L157">                            sdebug.println</span>
<span class="nc" id="L158">                                (&quot;overriding other security properties files!&quot;);</span>
                        }
                    }
<span class="nc" id="L161">                } catch (Exception e) {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                    if (sdebug != null) {</span>
<span class="nc" id="L163">                        sdebug.println</span>
<span class="nc" id="L164">                                (&quot;unable to load security properties from &quot; +</span>
                                extraPropFile);
<span class="nc" id="L166">                        e.printStackTrace();</span>
                    }
                } finally {
<span class="nc bnc" id="L169" title="All 6 branches missed.">                    if (bis != null) {</span>
                        try {
<span class="nc" id="L171">                            bis.close();</span>
<span class="nc" id="L172">                        } catch (IOException ioe) {</span>
<span class="nc bnc" id="L173" title="All 6 branches missed.">                            if (sdebug != null) {</span>
<span class="nc" id="L174">                                sdebug.println(&quot;unable to close input stream&quot;);</span>
                            }
<span class="nc" id="L176">                        }</span>
                    }
                }
            }
        }

<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (!loadedProps) {</span>
<span class="nc" id="L183">            initializeStatic();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (sdebug != null) {</span>
<span class="nc" id="L185">                sdebug.println(&quot;unable to load security properties &quot; +</span>
                        &quot;-- using defaults&quot;);
            }
        }

<span class="nc" id="L190">    }</span>

    /*
     * Initialize to default values, if &lt;java.home&gt;/lib/java.security
     * is not found.
     */
    private static void initializeStatic() {
<span class="nc" id="L197">        props.put(&quot;security.provider.1&quot;, &quot;sun.security.provider.Sun&quot;);</span>
<span class="nc" id="L198">        props.put(&quot;security.provider.2&quot;, &quot;sun.security.rsa.SunRsaSign&quot;);</span>
<span class="nc" id="L199">        props.put(&quot;security.provider.3&quot;, &quot;com.sun.net.ssl.internal.ssl.Provider&quot;);</span>
<span class="nc" id="L200">        props.put(&quot;security.provider.4&quot;, &quot;com.sun.crypto.provider.SunJCE&quot;);</span>
<span class="nc" id="L201">        props.put(&quot;security.provider.5&quot;, &quot;sun.security.jgss.SunProvider&quot;);</span>
<span class="nc" id="L202">        props.put(&quot;security.provider.6&quot;, &quot;com.sun.security.sasl.Provider&quot;);</span>
<span class="nc" id="L203">    }</span>

    /**
     * Don't let anyone instantiate this.
     */
<span class="nc" id="L208">    private Security() {</span>
<span class="nc" id="L209">    }</span>

    private static File securityPropFile(String filename) {
        // maybe check for a system property which will specify where to
        // look. Someday.
<span class="nc" id="L214">        String sep = File.separator;</span>
<span class="nc" id="L215">        return new File(System.getProperty(&quot;java.home&quot;) + sep + &quot;lib&quot; + sep +</span>
                        &quot;security&quot; + sep + filename);
    }

    /**
     * Looks up providers, and returns the property (and its associated
     * provider) mapping the key, if any.
     * The order in which the providers are looked up is the
     * provider-preference order, as specificed in the security
     * properties file.
     */
    private static ProviderProperty getProviderProperty(String key) {
<span class="nc" id="L227">        ProviderProperty entry = null;</span>

<span class="nc" id="L229">        List&lt;Provider&gt; providers = Providers.getProviderList().providers();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">        for (int i = 0; i &lt; providers.size(); i++) {</span>

<span class="nc" id="L232">            String matchKey = null;</span>
<span class="nc" id="L233">            Provider prov = providers.get(i);</span>
<span class="nc" id="L234">            String prop = prov.getProperty(key);</span>

<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (prop == null) {</span>
                // Is there a match if we do a case-insensitive property name
                // comparison? Let's try ...
<span class="nc" id="L239">                for (Enumeration&lt;Object&gt; e = prov.keys();</span>
<span class="nc bnc" id="L240" title="All 4 branches missed.">                                e.hasMoreElements() &amp;&amp; prop == null; ) {</span>
<span class="nc" id="L241">                    matchKey = (String)e.nextElement();</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                    if (key.equalsIgnoreCase(matchKey)) {</span>
<span class="nc" id="L243">                        prop = prov.getProperty(matchKey);</span>
<span class="nc" id="L244">                        break;</span>
                    }
                }
            }

<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (prop != null) {</span>
<span class="nc" id="L250">                ProviderProperty newEntry = new ProviderProperty();</span>
<span class="nc" id="L251">                newEntry.className = prop;</span>
<span class="nc" id="L252">                newEntry.provider = prov;</span>
<span class="nc" id="L253">                return newEntry;</span>
            }
        }

<span class="nc" id="L257">        return entry;</span>
    }

    /**
     * Returns the property (if any) mapping the key for the given provider.
     */
    private static String getProviderProperty(String key, Provider provider) {
<span class="nc" id="L264">        String prop = provider.getProperty(key);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (prop == null) {</span>
            // Is there a match if we do a case-insensitive property name
            // comparison? Let's try ...
<span class="nc" id="L268">            for (Enumeration&lt;Object&gt; e = provider.keys();</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">                                e.hasMoreElements() &amp;&amp; prop == null; ) {</span>
<span class="nc" id="L270">                String matchKey = (String)e.nextElement();</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">                if (key.equalsIgnoreCase(matchKey)) {</span>
<span class="nc" id="L272">                    prop = provider.getProperty(matchKey);</span>
<span class="nc" id="L273">                    break;</span>
                }
<span class="nc" id="L275">            }</span>
        }
<span class="nc" id="L277">        return prop;</span>
    }

    /**
     * Gets a specified property for an algorithm. The algorithm name
     * should be a standard name. See the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard algorithm names.
     *
     * One possible use is by specialized algorithm parsers, which may map
     * classes to algorithms which they understand (much like Key parsers
     * do).
     *
     * @param algName the algorithm name.
     *
     * @param propName the name of the property to get.
     *
     * @return the value of the specified property.
     *
     * @deprecated This method used to return the value of a proprietary
     * property in the master file of the &quot;SUN&quot; Cryptographic Service
     * Provider in order to determine how to parse algorithm-specific
     * parameters. Use the new provider-based and algorithm-independent
     * {@code AlgorithmParameters} and {@code KeyFactory} engine
     * classes (introduced in the J2SE version 1.2 platform) instead.
     */
    @Deprecated
    public static String getAlgorithmProperty(String algName,
                                              String propName) {
<span class="nc" id="L307">        ProviderProperty entry = getProviderProperty(&quot;Alg.&quot; + propName</span>
                                                     + &quot;.&quot; + algName);
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (entry != null) {</span>
<span class="nc" id="L310">            return entry.className;</span>
        } else {
<span class="nc" id="L312">            return null;</span>
        }
    }

    /**
     * Adds a new provider, at a specified position. The position is
     * the preference order in which providers are searched for
     * requested algorithms.  The position is 1-based, that is,
     * 1 is most preferred, followed by 2, and so on.
     *
     * &lt;p&gt;If the given provider is installed at the requested position,
     * the provider that used to be at that position, and all providers
     * with a position greater than {@code position}, are shifted up
     * one position (towards the end of the list of installed providers).
     *
     * &lt;p&gt;A provider cannot be added if it is already installed.
     *
     * &lt;p&gt;If there is a security manager, the
     * {@link java.lang.SecurityManager#checkSecurityAccess} method is called
     * with the {@code &quot;insertProvider&quot;} permission target name to see if
     * it's ok to add a new provider. If this permission check is denied,
     * {@code checkSecurityAccess} is called again with the
     * {@code &quot;insertProvider.&quot;+provider.getName()} permission target name. If
     * both checks are denied, a {@code SecurityException} is thrown.
     *
     * @param provider the provider to be added.
     *
     * @param position the preference position that the caller would
     * like for this provider.
     *
     * @return the actual preference position in which the provider was
     * added, or -1 if the provider was not added because it is
     * already installed.
     *
     * @throws  NullPointerException if provider is null
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to add a new provider
     *
     * @see #getProvider
     * @see #removeProvider
     * @see java.security.SecurityPermission
     */
    public static synchronized int insertProviderAt(Provider provider,
            int position) {
<span class="nc" id="L358">        String providerName = provider.getName();</span>
<span class="nc" id="L359">        checkInsertProvider(providerName);</span>
<span class="nc" id="L360">        ProviderList list = Providers.getFullProviderList();</span>
<span class="nc" id="L361">        ProviderList newList = ProviderList.insertAt(list, provider, position - 1);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (list == newList) {</span>
<span class="nc" id="L363">            return -1;</span>
        }
<span class="nc" id="L365">        Providers.setProviderList(newList);</span>
<span class="nc" id="L366">        return newList.getIndex(providerName) + 1;</span>
    }

    /**
     * Adds a provider to the next position available.
     *
     * &lt;p&gt;If there is a security manager, the
     * {@link java.lang.SecurityManager#checkSecurityAccess} method is called
     * with the {@code &quot;insertProvider&quot;} permission target name to see if
     * it's ok to add a new provider. If this permission check is denied,
     * {@code checkSecurityAccess} is called again with the
     * {@code &quot;insertProvider.&quot;+provider.getName()} permission target name. If
     * both checks are denied, a {@code SecurityException} is thrown.
     *
     * @param provider the provider to be added.
     *
     * @return the preference position in which the provider was
     * added, or -1 if the provider was not added because it is
     * already installed.
     *
     * @throws  NullPointerException if provider is null
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies access to add a new provider
     *
     * @see #getProvider
     * @see #removeProvider
     * @see java.security.SecurityPermission
     */
    public static int addProvider(Provider provider) {
        /*
         * We can't assign a position here because the statically
         * registered providers may not have been installed yet.
         * insertProviderAt() will fix that value after it has
         * loaded the static providers.
         */
<span class="nc" id="L403">        return insertProviderAt(provider, 0);</span>
    }

    /**
     * Removes the provider with the specified name.
     *
     * &lt;p&gt;When the specified provider is removed, all providers located
     * at a position greater than where the specified provider was are shifted
     * down one position (towards the head of the list of installed
     * providers).
     *
     * &lt;p&gt;This method returns silently if the provider is not installed or
     * if name is null.
     *
     * &lt;p&gt;First, if there is a security manager, its
     * {@code checkSecurityAccess}
     * method is called with the string {@code &quot;removeProvider.&quot;+name}
     * to see if it's ok to remove the provider.
     * If the default implementation of {@code checkSecurityAccess}
     * is used (i.e., that method is not overriden), then this will result in
     * a call to the security manager's {@code checkPermission} method
     * with a {@code SecurityPermission(&quot;removeProvider.&quot;+name)}
     * permission.
     *
     * @param name the name of the provider to remove.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkSecurityAccess} method
     *          denies
     *          access to remove the provider
     *
     * @see #getProvider
     * @see #addProvider
     */
    public static synchronized void removeProvider(String name) {
<span class="nc" id="L439">        check(&quot;removeProvider.&quot; + name);</span>
<span class="nc" id="L440">        ProviderList list = Providers.getFullProviderList();</span>
<span class="nc" id="L441">        ProviderList newList = ProviderList.remove(list, name);</span>
<span class="nc" id="L442">        Providers.setProviderList(newList);</span>
<span class="nc" id="L443">    }</span>

    /**
     * Returns an array containing all the installed providers. The order of
     * the providers in the array is their preference order.
     *
     * @return an array of all the installed providers.
     */
    public static Provider[] getProviders() {
<span class="nc" id="L452">        return Providers.getFullProviderList().toArray();</span>
    }

    /**
     * Returns the provider installed with the specified name, if
     * any. Returns null if no provider with the specified name is
     * installed or if name is null.
     *
     * @param name the name of the provider to get.
     *
     * @return the provider of the specified name.
     *
     * @see #removeProvider
     * @see #addProvider
     */
    public static Provider getProvider(String name) {
<span class="nc" id="L468">        return Providers.getProviderList().getProvider(name);</span>
    }

    /**
     * Returns an array containing all installed providers that satisfy the
     * specified selection criterion, or null if no such providers have been
     * installed. The returned providers are ordered
     * according to their
     * {@linkplain #insertProviderAt(java.security.Provider, int) preference order}.
     *
     * &lt;p&gt; A cryptographic service is always associated with a particular
     * algorithm or type. For example, a digital signature service is
     * always associated with a particular algorithm (e.g., DSA),
     * and a CertificateFactory service is always associated with
     * a particular certificate type (e.g., X.509).
     *
     * &lt;p&gt;The selection criterion must be specified in one of the following two
     * formats:
     * &lt;ul&gt;
     * &lt;li&gt; &lt;i&gt;{@literal &lt;crypto_service&gt;.&lt;algorithm_or_type&gt;}&lt;/i&gt;
     * &lt;p&gt; The cryptographic service name must not contain any dots.
     * &lt;p&gt; A
     * provider satisfies the specified selection criterion iff the provider
     * implements the
     * specified algorithm or type for the specified cryptographic service.
     * &lt;p&gt; For example, &quot;CertificateFactory.X.509&quot;
     * would be satisfied by any provider that supplied
     * a CertificateFactory implementation for X.509 certificates.
     * &lt;li&gt; &lt;i&gt;{@literal &lt;crypto_service&gt;.&lt;algorithm_or_type&gt;
     * &lt;attribute_name&gt;:&lt;attribute_value&gt;}&lt;/i&gt;
     * &lt;p&gt; The cryptographic service name must not contain any dots. There
     * must be one or more space characters between the
     * &lt;i&gt;{@literal &lt;algorithm_or_type&gt;}&lt;/i&gt; and the
     * &lt;i&gt;{@literal &lt;attribute_name&gt;}&lt;/i&gt;.
     *  &lt;p&gt; A provider satisfies this selection criterion iff the
     * provider implements the specified algorithm or type for the specified
     * cryptographic service and its implementation meets the
     * constraint expressed by the specified attribute name/value pair.
     * &lt;p&gt; For example, &quot;Signature.SHA1withDSA KeySize:1024&quot; would be
     * satisfied by any provider that implemented
     * the SHA1withDSA signature algorithm with a keysize of 1024 (or larger).
     *
     * &lt;/ul&gt;
     *
     * &lt;p&gt; See the &lt;a href=
     * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard cryptographic service names, standard
     * algorithm names and standard attribute names.
     *
     * @param filter the criterion for selecting
     * providers. The filter is case-insensitive.
     *
     * @return all the installed providers that satisfy the selection
     * criterion, or null if no such providers have been installed.
     *
     * @throws InvalidParameterException
     *         if the filter is not in the required format
     * @throws NullPointerException if filter is null
     *
     * @see #getProviders(java.util.Map)
     * @since 1.3
     */
    public static Provider[] getProviders(String filter) {
<span class="nc" id="L532">        String key = null;</span>
<span class="nc" id="L533">        String value = null;</span>
<span class="nc" id="L534">        int index = filter.indexOf(':');</span>

<span class="nc bnc" id="L536" title="All 2 branches missed.">        if (index == -1) {</span>
<span class="nc" id="L537">            key = filter;</span>
<span class="nc" id="L538">            value = &quot;&quot;;</span>
        } else {
<span class="nc" id="L540">            key = filter.substring(0, index);</span>
<span class="nc" id="L541">            value = filter.substring(index + 1);</span>
        }

<span class="nc" id="L544">        Hashtable&lt;String, String&gt; hashtableFilter = new Hashtable&lt;&gt;(1);</span>
<span class="nc" id="L545">        hashtableFilter.put(key, value);</span>

<span class="nc" id="L547">        return (getProviders(hashtableFilter));</span>
    }

    /**
     * Returns an array containing all installed providers that satisfy the
     * specified* selection criteria, or null if no such providers have been
     * installed. The returned providers are ordered
     * according to their
     * {@linkplain #insertProviderAt(java.security.Provider, int)
     * preference order}.
     *
     * &lt;p&gt;The selection criteria are represented by a map.
     * Each map entry represents a selection criterion.
     * A provider is selected iff it satisfies all selection
     * criteria. The key for any entry in such a map must be in one of the
     * following two formats:
     * &lt;ul&gt;
     * &lt;li&gt; &lt;i&gt;{@literal &lt;crypto_service&gt;.&lt;algorithm_or_type&gt;}&lt;/i&gt;
     * &lt;p&gt; The cryptographic service name must not contain any dots.
     * &lt;p&gt; The value associated with the key must be an empty string.
     * &lt;p&gt; A provider
     * satisfies this selection criterion iff the provider implements the
     * specified algorithm or type for the specified cryptographic service.
     * &lt;li&gt;  &lt;i&gt;{@literal &lt;crypto_service&gt;}.
     * {@literal &lt;algorithm_or_type&gt; &lt;attribute_name&gt;}&lt;/i&gt;
     * &lt;p&gt; The cryptographic service name must not contain any dots. There
     * must be one or more space characters between the
     * &lt;i&gt;{@literal &lt;algorithm_or_type&gt;}&lt;/i&gt;
     * and the &lt;i&gt;{@literal &lt;attribute_name&gt;}&lt;/i&gt;.
     * &lt;p&gt; The value associated with the key must be a non-empty string.
     * A provider satisfies this selection criterion iff the
     * provider implements the specified algorithm or type for the specified
     * cryptographic service and its implementation meets the
     * constraint expressed by the specified attribute name/value pair.
     * &lt;/ul&gt;
     *
     * &lt;p&gt; See the &lt;a href=
     * &quot;../../../technotes/guides/security/StandardNames.html&quot;&gt;
     * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
     * for information about standard cryptographic service names, standard
     * algorithm names and standard attribute names.
     *
     * @param filter the criteria for selecting
     * providers. The filter is case-insensitive.
     *
     * @return all the installed providers that satisfy the selection
     * criteria, or null if no such providers have been installed.
     *
     * @throws InvalidParameterException
     *         if the filter is not in the required format
     * @throws NullPointerException if filter is null
     *
     * @see #getProviders(java.lang.String)
     * @since 1.3
     */
    public static Provider[] getProviders(Map&lt;String,String&gt; filter) {
        // Get all installed providers first.
        // Then only return those providers who satisfy the selection criteria.
<span class="nc" id="L605">        Provider[] allProviders = Security.getProviders();</span>
<span class="nc" id="L606">        Set&lt;String&gt; keySet = filter.keySet();</span>
<span class="nc" id="L607">        LinkedHashSet&lt;Provider&gt; candidates = new LinkedHashSet&lt;&gt;(5);</span>

        // Returns all installed providers
        // if the selection criteria is null.
<span class="nc bnc" id="L611" title="All 4 branches missed.">        if ((keySet == null) || (allProviders == null)) {</span>
<span class="nc" id="L612">            return allProviders;</span>
        }

<span class="nc" id="L615">        boolean firstSearch = true;</span>

        // For each selection criterion, remove providers
        // which don't satisfy the criterion from the candidate set.
<span class="nc bnc" id="L619" title="All 2 branches missed.">        for (Iterator&lt;String&gt; ite = keySet.iterator(); ite.hasNext(); ) {</span>
<span class="nc" id="L620">            String key = ite.next();</span>
<span class="nc" id="L621">            String value = filter.get(key);</span>

<span class="nc" id="L623">            LinkedHashSet&lt;Provider&gt; newCandidates = getAllQualifyingCandidates(key, value,</span>
                                                               allProviders);
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (firstSearch) {</span>
<span class="nc" id="L626">                candidates = newCandidates;</span>
<span class="nc" id="L627">                firstSearch = false;</span>
            }

<span class="nc bnc" id="L630" title="All 4 branches missed.">            if ((newCandidates != null) &amp;&amp; !newCandidates.isEmpty()) {</span>
                // For each provider in the candidates set, if it
                // isn't in the newCandidate set, we should remove
                // it from the candidate set.
<span class="nc" id="L634">                for (Iterator&lt;Provider&gt; cansIte = candidates.iterator();</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                     cansIte.hasNext(); ) {</span>
<span class="nc" id="L636">                    Provider prov = cansIte.next();</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">                    if (!newCandidates.contains(prov)) {</span>
<span class="nc" id="L638">                        cansIte.remove();</span>
                    }
<span class="nc" id="L640">                }</span>
            } else {
<span class="nc" id="L642">                candidates = null;</span>
<span class="nc" id="L643">                break;</span>
            }
<span class="nc" id="L645">        }</span>

<span class="nc bnc" id="L647" title="All 4 branches missed.">        if ((candidates == null) || (candidates.isEmpty()))</span>
<span class="nc" id="L648">            return null;</span>

<span class="nc" id="L650">        Object[] candidatesArray = candidates.toArray();</span>
<span class="nc" id="L651">        Provider[] result = new Provider[candidatesArray.length];</span>

<span class="nc bnc" id="L653" title="All 2 branches missed.">        for (int i = 0; i &lt; result.length; i++) {</span>
<span class="nc" id="L654">            result[i] = (Provider)candidatesArray[i];</span>
        }

<span class="nc" id="L657">        return result;</span>
    }

    // Map containing cached Spi Class objects of the specified type
<span class="nc" id="L661">    private static final Map&lt;String, Class&lt;?&gt;&gt; spiMap =</span>
            new ConcurrentHashMap&lt;&gt;();

    /**
     * Return the Class object for the given engine type
     * (e.g. &quot;MessageDigest&quot;). Works for Spis in the java.security package
     * only.
     */
    private static Class&lt;?&gt; getSpiClass(String type) {
<span class="nc" id="L670">        Class&lt;?&gt; clazz = spiMap.get(type);</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">        if (clazz != null) {</span>
<span class="nc" id="L672">            return clazz;</span>
        }
        try {
<span class="nc" id="L675">            clazz = Class.forName(&quot;java.security.&quot; + type + &quot;Spi&quot;);</span>
<span class="nc" id="L676">            spiMap.put(type, clazz);</span>
<span class="nc" id="L677">            return clazz;</span>
<span class="nc" id="L678">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L679">            throw new AssertionError(&quot;Spi class not found&quot;, e);</span>
        }
    }

    /*
     * Returns an array of objects: the first object in the array is
     * an instance of an implementation of the requested algorithm
     * and type, and the second object in the array identifies the provider
     * of that implementation.
     * The {@code provider} argument can be null, in which case all
     * configured providers will be searched in order of preference.
     */
    static Object[] getImpl(String algorithm, String type, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L694">            return GetInstance.getInstance</span>
<span class="nc" id="L695">                (type, getSpiClass(type), algorithm).toArray();</span>
        } else {
<span class="nc" id="L697">            return GetInstance.getInstance</span>
<span class="nc" id="L698">                (type, getSpiClass(type), algorithm, provider).toArray();</span>
        }
    }

    static Object[] getImpl(String algorithm, String type, String provider,
            Object params) throws NoSuchAlgorithmException,
            NoSuchProviderException, InvalidAlgorithmParameterException {
<span class="nc bnc" id="L705" title="All 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L706">            return GetInstance.getInstance</span>
<span class="nc" id="L707">                (type, getSpiClass(type), algorithm, params).toArray();</span>
        } else {
<span class="nc" id="L709">            return GetInstance.getInstance</span>
<span class="nc" id="L710">                (type, getSpiClass(type), algorithm, params, provider).toArray();</span>
        }
    }

    /*
     * Returns an array of objects: the first object in the array is
     * an instance of an implementation of the requested algorithm
     * and type, and the second object in the array identifies the provider
     * of that implementation.
     * The {@code provider} argument cannot be null.
     */
    static Object[] getImpl(String algorithm, String type, Provider provider)
            throws NoSuchAlgorithmException {
<span class="nc" id="L723">        return GetInstance.getInstance</span>
<span class="nc" id="L724">            (type, getSpiClass(type), algorithm, provider).toArray();</span>
    }

    static Object[] getImpl(String algorithm, String type, Provider provider,
            Object params) throws NoSuchAlgorithmException,
            InvalidAlgorithmParameterException {
<span class="nc" id="L730">        return GetInstance.getInstance</span>
<span class="nc" id="L731">            (type, getSpiClass(type), algorithm, params, provider).toArray();</span>
    }

    /**
     * Gets a security property value.
     *
     * &lt;p&gt;First, if there is a security manager, its
     * {@code checkPermission}  method is called with a
     * {@code java.security.SecurityPermission(&quot;getProperty.&quot;+key)}
     * permission to see if it's ok to retrieve the specified
     * security property value..
     *
     * @param key the key of the property being retrieved.
     *
     * @return the value of the security property corresponding to key.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkPermission} method
     *          denies
     *          access to retrieve the specified security property value
     * @throws  NullPointerException is key is null
     *
     * @see #setProperty
     * @see java.security.SecurityPermission
     */
    public static String getProperty(String key) {
<span class="nc" id="L758">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L760">            sm.checkPermission(new SecurityPermission(&quot;getProperty.&quot;+</span>
                                                      key));
        }
<span class="nc" id="L763">        String name = props.getProperty(key);</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">        if (name != null)</span>
<span class="nc" id="L765">            name = name.trim(); // could be a class name with trailing ws</span>
<span class="nc" id="L766">        return name;</span>
    }

    /**
     * Sets a security property value.
     *
     * &lt;p&gt;First, if there is a security manager, its
     * {@code checkPermission} method is called with a
     * {@code java.security.SecurityPermission(&quot;setProperty.&quot;+key)}
     * permission to see if it's ok to set the specified
     * security property value.
     *
     * @param key the name of the property to be set.
     *
     * @param datum the value of the property to be set.
     *
     * @throws  SecurityException
     *          if a security manager exists and its {@link
     *          java.lang.SecurityManager#checkPermission} method
     *          denies access to set the specified security property value
     * @throws  NullPointerException if key or datum is null
     *
     * @see #getProperty
     * @see java.security.SecurityPermission
     */
    public static void setProperty(String key, String datum) {
<span class="nc" id="L792">        check(&quot;setProperty.&quot;+key);</span>
<span class="nc" id="L793">        props.put(key, datum);</span>
<span class="nc" id="L794">        invalidateSMCache(key);  /* See below. */</span>
<span class="nc" id="L795">    }</span>

    /*
     * Implementation detail:  If the property we just set in
     * setProperty() was either &quot;package.access&quot; or
     * &quot;package.definition&quot;, we need to signal to the SecurityManager
     * class that the value has just changed, and that it should
     * invalidate it's local cache values.
     *
     * Rather than create a new API entry for this function,
     * we use reflection to set a private variable.
     */
    private static void invalidateSMCache(String key) {

<span class="nc" id="L809">        final boolean pa = key.equals(&quot;package.access&quot;);</span>
<span class="nc" id="L810">        final boolean pd = key.equals(&quot;package.definition&quot;);</span>

<span class="nc bnc" id="L812" title="All 4 branches missed.">        if (pa || pd) {</span>
<span class="pc" id="L813">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
                    try {
                        /* Get the class via the bootstrap class loader. */
<span class="fc" id="L817">                        Class&lt;?&gt; cl = Class.forName(</span>
                            &quot;java.lang.SecurityManager&quot;, false, null);
<span class="fc" id="L819">                        Field f = null;</span>
<span class="fc" id="L820">                        boolean accessible = false;</span>

<span class="pc bpc" id="L822" title="1 of 2 branches missed.">                        if (pa) {</span>
<span class="fc" id="L823">                            f = cl.getDeclaredField(&quot;packageAccessValid&quot;);</span>
<span class="fc" id="L824">                            accessible = f.isAccessible();</span>
<span class="fc" id="L825">                            f.setAccessible(true);</span>
                        } else {
<span class="nc" id="L827">                            f = cl.getDeclaredField(&quot;packageDefinitionValid&quot;);</span>
<span class="nc" id="L828">                            accessible = f.isAccessible();</span>
<span class="nc" id="L829">                            f.setAccessible(true);</span>
                        }
<span class="fc" id="L831">                        f.setBoolean(f, false);</span>
<span class="fc" id="L832">                        f.setAccessible(accessible);</span>
                    }
<span class="nc" id="L834">                    catch (Exception e1) {</span>
                        /* If we couldn't get the class, it hasn't
                         * been loaded yet.  If there is no such
                         * field, we shouldn't try to set it.  There
                         * shouldn't be a security execption, as we
                         * are loaded by boot class loader, and we
                         * are inside a doPrivileged() here.
                         *
                         * NOOP: don't do anything...
                         */
<span class="fc" id="L844">                    }</span>
<span class="fc" id="L845">                    return null;</span>
                }  /* run */
            });  /* PrivilegedAction */
        }  /* if */
<span class="nc" id="L849">    }</span>

    private static void check(String directive) {
<span class="nc" id="L852">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L854">            security.checkSecurityAccess(directive);</span>
        }
<span class="nc" id="L856">    }</span>

    private static void checkInsertProvider(String name) {
<span class="nc" id="L859">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">        if (security != null) {</span>
            try {
<span class="nc" id="L862">                security.checkSecurityAccess(&quot;insertProvider&quot;);</span>
<span class="nc" id="L863">            } catch (SecurityException se1) {</span>
                try {
<span class="nc" id="L865">                    security.checkSecurityAccess(&quot;insertProvider.&quot; + name);</span>
<span class="nc" id="L866">                } catch (SecurityException se2) {</span>
                    // throw first exception, but add second to suppressed
<span class="nc" id="L868">                    se1.addSuppressed(se2);</span>
<span class="nc" id="L869">                    throw se1;</span>
<span class="nc" id="L870">                }</span>
<span class="nc" id="L871">            }</span>
        }
<span class="nc" id="L873">    }</span>

    /*
    * Returns all providers who satisfy the specified
    * criterion.
    */
    private static LinkedHashSet&lt;Provider&gt; getAllQualifyingCandidates(
                                                String filterKey,
                                                String filterValue,
                                                Provider[] allProviders) {
<span class="nc" id="L883">        String[] filterComponents = getFilterComponents(filterKey,</span>
                                                        filterValue);

        // The first component is the service name.
        // The second is the algorithm name.
        // If the third isn't null, that is the attrinute name.
<span class="nc" id="L889">        String serviceName = filterComponents[0];</span>
<span class="nc" id="L890">        String algName = filterComponents[1];</span>
<span class="nc" id="L891">        String attrName = filterComponents[2];</span>

<span class="nc" id="L893">        return getProvidersNotUsingCache(serviceName, algName, attrName,</span>
                                         filterValue, allProviders);
    }

    private static LinkedHashSet&lt;Provider&gt; getProvidersNotUsingCache(
                                                String serviceName,
                                                String algName,
                                                String attrName,
                                                String filterValue,
                                                Provider[] allProviders) {
<span class="nc" id="L903">        LinkedHashSet&lt;Provider&gt; candidates = new LinkedHashSet&lt;&gt;(5);</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">        for (int i = 0; i &lt; allProviders.length; i++) {</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">            if (isCriterionSatisfied(allProviders[i], serviceName,</span>
                                     algName,
                                     attrName, filterValue)) {
<span class="nc" id="L908">                candidates.add(allProviders[i]);</span>
            }
        }
<span class="nc" id="L911">        return candidates;</span>
    }

    /*
     * Returns true if the given provider satisfies
     * the selection criterion key:value.
     */
    private static boolean isCriterionSatisfied(Provider prov,
                                                String serviceName,
                                                String algName,
                                                String attrName,
                                                String filterValue) {
<span class="nc" id="L923">        String key = serviceName + '.' + algName;</span>

<span class="nc bnc" id="L925" title="All 2 branches missed.">        if (attrName != null) {</span>
<span class="nc" id="L926">            key += ' ' + attrName;</span>
        }
        // Check whether the provider has a property
        // whose key is the same as the given key.
<span class="nc" id="L930">        String propValue = getProviderProperty(key, prov);</span>

<span class="nc bnc" id="L932" title="All 2 branches missed.">        if (propValue == null) {</span>
            // Check whether we have an alias instead
            // of a standard name in the key.
<span class="nc" id="L935">            String standardName = getProviderProperty(&quot;Alg.Alias.&quot; +</span>
                                                      serviceName + &quot;.&quot; +
                                                      algName,
                                                      prov);
<span class="nc bnc" id="L939" title="All 2 branches missed.">            if (standardName != null) {</span>
<span class="nc" id="L940">                key = serviceName + &quot;.&quot; + standardName;</span>

<span class="nc bnc" id="L942" title="All 2 branches missed.">                if (attrName != null) {</span>
<span class="nc" id="L943">                    key += ' ' + attrName;</span>
                }

<span class="nc" id="L946">                propValue = getProviderProperty(key, prov);</span>
            }

<span class="nc bnc" id="L949" title="All 2 branches missed.">            if (propValue == null) {</span>
                // The provider doesn't have the given
                // key in its property list.
<span class="nc" id="L952">                return false;</span>
            }
        }

        // If the key is in the format of:
        // &lt;crypto_service&gt;.&lt;algorithm_or_type&gt;,
        // there is no need to check the value.

<span class="nc bnc" id="L960" title="All 2 branches missed.">        if (attrName == null) {</span>
<span class="nc" id="L961">            return true;</span>
        }

        // If we get here, the key must be in the
        // format of &lt;crypto_service&gt;.&lt;algorithm_or_provider&gt; &lt;attribute_name&gt;.
<span class="nc bnc" id="L966" title="All 2 branches missed.">        if (isStandardAttr(attrName)) {</span>
<span class="nc" id="L967">            return isConstraintSatisfied(attrName, filterValue, propValue);</span>
        } else {
<span class="nc" id="L969">            return filterValue.equalsIgnoreCase(propValue);</span>
        }
    }

    /*
     * Returns true if the attribute is a standard attribute;
     * otherwise, returns false.
     */
    private static boolean isStandardAttr(String attribute) {
        // For now, we just have two standard attributes:
        // KeySize and ImplementedIn.
<span class="nc bnc" id="L980" title="All 2 branches missed.">        if (attribute.equalsIgnoreCase(&quot;KeySize&quot;))</span>
<span class="nc" id="L981">            return true;</span>

<span class="nc bnc" id="L983" title="All 2 branches missed.">        if (attribute.equalsIgnoreCase(&quot;ImplementedIn&quot;))</span>
<span class="nc" id="L984">            return true;</span>

<span class="nc" id="L986">        return false;</span>
    }

    /*
     * Returns true if the requested attribute value is supported;
     * otherwise, returns false.
     */
    private static boolean isConstraintSatisfied(String attribute,
                                                 String value,
                                                 String prop) {
        // For KeySize, prop is the max key size the
        // provider supports for a specific &lt;crypto_service&gt;.&lt;algorithm&gt;.
<span class="nc bnc" id="L998" title="All 2 branches missed.">        if (attribute.equalsIgnoreCase(&quot;KeySize&quot;)) {</span>
<span class="nc" id="L999">            int requestedSize = Integer.parseInt(value);</span>
<span class="nc" id="L1000">            int maxSize = Integer.parseInt(prop);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">            if (requestedSize &lt;= maxSize) {</span>
<span class="nc" id="L1002">                return true;</span>
            } else {
<span class="nc" id="L1004">                return false;</span>
            }
        }

        // For Type, prop is the type of the implementation
        // for a specific &lt;crypto service&gt;.&lt;algorithm&gt;.
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        if (attribute.equalsIgnoreCase(&quot;ImplementedIn&quot;)) {</span>
<span class="nc" id="L1011">            return value.equalsIgnoreCase(prop);</span>
        }

<span class="nc" id="L1014">        return false;</span>
    }

    static String[] getFilterComponents(String filterKey, String filterValue) {
<span class="nc" id="L1018">        int algIndex = filterKey.indexOf('.');</span>

<span class="nc bnc" id="L1020" title="All 2 branches missed.">        if (algIndex &lt; 0) {</span>
            // There must be a dot in the filter, and the dot
            // shouldn't be at the beginning of this string.
<span class="nc" id="L1023">            throw new InvalidParameterException(&quot;Invalid filter&quot;);</span>
        }

<span class="nc" id="L1026">        String serviceName = filterKey.substring(0, algIndex);</span>
<span class="nc" id="L1027">        String algName = null;</span>
<span class="nc" id="L1028">        String attrName = null;</span>

<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (filterValue.length() == 0) {</span>
            // The filterValue is an empty string. So the filterKey
            // should be in the format of &lt;crypto_service&gt;.&lt;algorithm_or_type&gt;.
<span class="nc" id="L1033">            algName = filterKey.substring(algIndex + 1).trim();</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">            if (algName.length() == 0) {</span>
                // There must be a algorithm or type name.
<span class="nc" id="L1036">                throw new InvalidParameterException(&quot;Invalid filter&quot;);</span>
            }
        } else {
            // The filterValue is a non-empty string. So the filterKey must be
            // in the format of
            // &lt;crypto_service&gt;.&lt;algorithm_or_type&gt; &lt;attribute_name&gt;
<span class="nc" id="L1042">            int attrIndex = filterKey.indexOf(' ');</span>

<span class="nc bnc" id="L1044" title="All 2 branches missed.">            if (attrIndex == -1) {</span>
                // There is no attribute name in the filter.
<span class="nc" id="L1046">                throw new InvalidParameterException(&quot;Invalid filter&quot;);</span>
            } else {
<span class="nc" id="L1048">                attrName = filterKey.substring(attrIndex + 1).trim();</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                if (attrName.length() == 0) {</span>
                    // There is no attribute name in the filter.
<span class="nc" id="L1051">                    throw new InvalidParameterException(&quot;Invalid filter&quot;);</span>
                }
            }

            // There must be an algorithm name in the filter.
<span class="nc bnc" id="L1056" title="All 4 branches missed.">            if ((attrIndex &lt; algIndex) ||</span>
                (algIndex == attrIndex - 1)) {
<span class="nc" id="L1058">                throw new InvalidParameterException(&quot;Invalid filter&quot;);</span>
            } else {
<span class="nc" id="L1060">                algName = filterKey.substring(algIndex + 1, attrIndex);</span>
            }
        }

<span class="nc" id="L1064">        String[] result = new String[3];</span>
<span class="nc" id="L1065">        result[0] = serviceName;</span>
<span class="nc" id="L1066">        result[1] = algName;</span>
<span class="nc" id="L1067">        result[2] = attrName;</span>

<span class="nc" id="L1069">        return result;</span>
    }

    /**
     * Returns a Set of Strings containing the names of all available
     * algorithms or types for the specified Java cryptographic service
     * (e.g., Signature, MessageDigest, Cipher, Mac, KeyStore). Returns
     * an empty Set if there is no provider that supports the
     * specified service or if serviceName is null. For a complete list
     * of Java cryptographic services, please see the
     * &lt;a href=&quot;../../../technotes/guides/security/crypto/CryptoSpec.html&quot;&gt;Java
     * Cryptography Architecture API Specification &amp;amp; Reference&lt;/a&gt;.
     * Note: the returned set is immutable.
     *
     * @param serviceName the name of the Java cryptographic
     * service (e.g., Signature, MessageDigest, Cipher, Mac, KeyStore).
     * Note: this parameter is case-insensitive.
     *
     * @return a Set of Strings containing the names of all available
     * algorithms or types for the specified Java cryptographic service
     * or an empty set if no provider supports the specified service.
     *
     * @since 1.4
     **/
    public static Set&lt;String&gt; getAlgorithms(String serviceName) {

<span class="nc bnc" id="L1095" title="All 4 branches missed.">        if ((serviceName == null) || (serviceName.length() == 0) ||</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">            (serviceName.endsWith(&quot;.&quot;))) {</span>
<span class="nc" id="L1097">            return Collections.emptySet();</span>
        }

<span class="nc" id="L1100">        HashSet&lt;String&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1101">        Provider[] providers = Security.getProviders();</span>

<span class="nc bnc" id="L1103" title="All 2 branches missed.">        for (int i = 0; i &lt; providers.length; i++) {</span>
            // Check the keys for each provider.
<span class="nc" id="L1105">            for (Enumeration&lt;Object&gt; e = providers[i].keys();</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                                                e.hasMoreElements(); ) {</span>
<span class="nc" id="L1107">                String currentKey =</span>
<span class="nc" id="L1108">                        ((String)e.nextElement()).toUpperCase(Locale.ENGLISH);</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">                if (currentKey.startsWith(</span>
<span class="nc" id="L1110">                        serviceName.toUpperCase(Locale.ENGLISH))) {</span>
                    // We should skip the currentKey if it contains a
                    // whitespace. The reason is: such an entry in the
                    // provider property contains attributes for the
                    // implementation of an algorithm. We are only interested
                    // in entries which lead to the implementation
                    // classes.
<span class="nc bnc" id="L1117" title="All 2 branches missed.">                    if (currentKey.indexOf(&quot; &quot;) &lt; 0) {</span>
<span class="nc" id="L1118">                        result.add(currentKey.substring(</span>
<span class="nc" id="L1119">                                                serviceName.length() + 1));</span>
                    }
                }
<span class="nc" id="L1122">            }</span>
        }
<span class="nc" id="L1124">        return Collections.unmodifiableSet(result);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>