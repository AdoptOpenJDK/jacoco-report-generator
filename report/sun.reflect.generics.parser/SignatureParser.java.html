<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SignatureParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.reflect.generics.parser</a> &gt; <span class="el_source">SignatureParser.java</span></div><h1>SignatureParser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.reflect.generics.parser;

import java.lang.reflect.GenericSignatureFormatError;
import java.util.*;
import sun.reflect.generics.tree.*;

/**
 * Parser for type signatures, as defined in the Java Virtual
 * Machine Specification (JVMS) chapter 4.
 * Converts the signatures into an abstract syntax tree (AST) representation.
 * See the package sun.reflect.generics.tree for details of the AST.
 */
<span class="fc bfc" id="L38" title="All 2 branches covered.">public class SignatureParser {</span>
    // The input is conceptually a character stream (though currently it's
    // a string). This is slightly different than traditional parsers,
    // because there is no lexical scanner performing tokenization.
    // Having a separate tokenizer does not fit with the nature of the
    // input format.
    // Other than the absence of a tokenizer, this parser is a classic
    // recursive descent parser. Its structure corresponds as closely
    // as possible to the grammar in the JVMS.
    //
    // A note on asserts vs. errors: The code contains assertions
    // in situations that should never occur. An assertion failure
    // indicates a failure of the parser logic. A common pattern
    // is an assertion that the current input is a particular
    // character. This is often paired with a separate check
    // that this is the case, which seems redundant. For example:
    //
    // assert(current() != x);
    // if (current != x {error(&quot;expected an x&quot;);
    //
    // where x is some character constant.
    // The assertion indicates, that, as currently written,
    // the code should never reach this point unless the input is an
    // x. On the other hand, the test is there to check the legality
    // of the input wrt to a given production. It may be that at a later
    // time the code might be called directly, and if the input is
    // invalid, the parser should flag an error in accordance
    // with its logic.

    private char[] input; // the input signature
<span class="fc" id="L68">    private int index = 0; // index into the input</span>
    // used to mark end of input
    private static final char EOI = ':';
    private static final boolean DEBUG = false;

    // private constructor - enforces use of static factory
<span class="fc" id="L74">    private SignatureParser(){}</span>

    // Utility methods.

    // Most parsing routines use the following routines to access the
    // input stream, and advance it as necessary.
    // This makes it easy to adapt the parser to operate on streams
    // of various kinds as well as strings.

    // returns current element of the input and advances the input
    private char getNext(){
<span class="nc bnc" id="L85" title="All 4 branches missed.">        assert(index &lt;= input.length);</span>
        try {
<span class="nc" id="L87">            return input[index++];</span>
<span class="nc" id="L88">        } catch (ArrayIndexOutOfBoundsException e) { return EOI;}</span>
    }

    // returns current element of the input
    private char current(){
<span class="pc bpc" id="L93" title="1 of 4 branches missed.">        assert(index &lt;= input.length);</span>
        try {
<span class="fc" id="L95">            return input[index];</span>
<span class="fc" id="L96">        } catch (ArrayIndexOutOfBoundsException e) { return EOI;}</span>
    }

    // advance the input
    private void advance(){
<span class="pc bpc" id="L101" title="1 of 4 branches missed.">        assert(index &lt;= input.length);</span>
<span class="fc" id="L102">        index++;</span>
<span class="fc" id="L103">    }</span>

    // For debugging, prints current character to the end of the input.
    private String remainder() {
<span class="nc" id="L107">        return new String(input, index, input.length-index);</span>
    }

    // Match c against a &quot;set&quot; of characters
    private boolean matches(char c, char... set) {
<span class="nc bnc" id="L112" title="All 2 branches missed.">        for (char e : set) {</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if (c == e) return true;</span>
        }
<span class="nc" id="L115">        return false;</span>
    }

    // Error handling routine. Encapsulates error handling.
    // Takes a string error message as argument.
    // Currently throws a GenericSignatureFormatError.

    private Error error(String errorMsg) {
<span class="nc" id="L123">        return new GenericSignatureFormatError(&quot;Signature Parse error: &quot; + errorMsg +</span>
<span class="nc" id="L124">                                               &quot;\n\tRemaining input: &quot; + remainder());</span>
    }

    /**
     * Verify the parse has made forward progress; throw an exception
     * if no progress.
     */
    private void progress(int startingPosition) {
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">        if (index &lt;= startingPosition)</span>
<span class="nc" id="L133">            throw error(&quot;Failure to make progress!&quot;);</span>
<span class="fc" id="L134">    }</span>

    /**
     * Static factory method. Produces a parser instance.
     * @return an instance of &lt;tt&gt;SignatureParser&lt;/tt&gt;
     */
    public static SignatureParser make() {
<span class="fc" id="L141">        return new SignatureParser();</span>
    }

    /**
     * Parses a class signature (as defined in the JVMS, chapter 4)
     * and produces an abstract syntax tree representing it.
     * @param s a string representing the input class signature
     * @return An abstract syntax tree for a class signature
     * corresponding to the input string
     * @throws GenericSignatureFormatError if the input is not a valid
     * class signature
     */
    public ClassSignature parseClassSig(String s) {
        if (DEBUG) System.out.println(&quot;Parsing class sig:&quot; + s);
<span class="fc" id="L155">        input = s.toCharArray();</span>
<span class="fc" id="L156">        return parseClassSignature();</span>
    }

    /**
     * Parses a method signature (as defined in the JVMS, chapter 4)
     * and produces an abstract syntax tree representing it.
     * @param s a string representing the input method signature
     * @return An abstract syntax tree for a method signature
     * corresponding to the input string
     * @throws GenericSignatureFormatError if the input is not a valid
     * method signature
     */
    public MethodTypeSignature parseMethodSig(String s) {
        if (DEBUG) System.out.println(&quot;Parsing method sig:&quot; + s);
<span class="fc" id="L170">        input = s.toCharArray();</span>
<span class="fc" id="L171">        return parseMethodTypeSignature();</span>
    }


    /**
     * Parses a type signature
     * and produces an abstract syntax tree representing it.
     *
     * @param s a string representing the input type signature
     * @return An abstract syntax tree for a type signature
     * corresponding to the input string
     * @throws GenericSignatureFormatError if the input is not a valid
     * type signature
     */
    public TypeSignature parseTypeSig(String s) {
        if (DEBUG) System.out.println(&quot;Parsing type sig:&quot; + s);
<span class="fc" id="L187">        input = s.toCharArray();</span>
<span class="fc" id="L188">        return parseTypeSignature();</span>
    }

    // Parsing routines.
    // As a rule, the parsing routines access the input using the
    // utilities current(), getNext() and/or advance().
    // The convention is that when a parsing routine is invoked
    // it expects the current input to be the first character it should parse
    // and when it completes parsing, it leaves the input at the first
    // character after the input parses.

    /*
     * Note on grammar conventions: a trailing &quot;*&quot; matches zero or
     * more occurrences, a trailing &quot;+&quot; matches one or more occurrences,
     * &quot;_opt&quot; indicates an optional component.
     */

    /**
     * ClassSignature:
     *     FormalTypeParameters_opt SuperclassSignature SuperinterfaceSignature*
     */
    private ClassSignature parseClassSignature() {
        // parse a class signature based on the implicit input.
<span class="pc bpc" id="L211" title="2 of 4 branches missed.">        assert(index == 0);</span>
<span class="fc" id="L212">        return ClassSignature.make(parseZeroOrMoreFormalTypeParameters(),</span>
<span class="fc" id="L213">                                   parseClassTypeSignature(), // Only rule for SuperclassSignature</span>
<span class="fc" id="L214">                                   parseSuperInterfaces());</span>
    }

    private FormalTypeParameter[] parseZeroOrMoreFormalTypeParameters(){
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (current() == '&lt;') {</span>
<span class="fc" id="L219">            return parseFormalTypeParameters();</span>
        } else {
<span class="fc" id="L221">            return new FormalTypeParameter[0];</span>
        }
    }

    /**
     * FormalTypeParameters:
     *     &quot;&lt;&quot; FormalTypeParameter+ &quot;&gt;&quot;
     */
    private FormalTypeParameter[] parseFormalTypeParameters(){
<span class="fc" id="L230">        List&lt;FormalTypeParameter&gt; ftps =  new ArrayList&lt;&gt;(3);</span>
<span class="pc bpc" id="L231" title="2 of 4 branches missed.">        assert(current() == '&lt;'); // should not have been called at all</span>
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (current() != '&lt;') { throw error(&quot;expected '&lt;'&quot;);}</span>
<span class="fc" id="L233">        advance();</span>
<span class="fc" id="L234">        ftps.add(parseFormalTypeParameter());</span>
<span class="fc bfc" id="L235" title="All 2 branches covered.">        while (current() != '&gt;') {</span>
<span class="fc" id="L236">            int startingPosition = index;</span>
<span class="fc" id="L237">            ftps.add(parseFormalTypeParameter());</span>
<span class="fc" id="L238">            progress(startingPosition);</span>
<span class="fc" id="L239">        }</span>
<span class="fc" id="L240">        advance();</span>
<span class="fc" id="L241">        return ftps.toArray(new FormalTypeParameter[ftps.size()]);</span>
    }

    /**
     * FormalTypeParameter:
     *     Identifier ClassBound InterfaceBound*
     */
    private FormalTypeParameter parseFormalTypeParameter(){
<span class="fc" id="L249">        String id = parseIdentifier();</span>
<span class="fc" id="L250">        FieldTypeSignature[] bs = parseBounds();</span>
<span class="fc" id="L251">        return FormalTypeParameter.make(id, bs);</span>
    }

    private String parseIdentifier(){
<span class="fc" id="L255">        StringBuilder result = new StringBuilder();</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        while (!Character.isWhitespace(current())) {</span>
<span class="fc" id="L257">            char c = current();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">            switch(c) {</span>
            case ';':
            case '.':
            case '/':
            case '[':
            case ':':
            case '&gt;':
            case '&lt;':
<span class="fc" id="L266">                return result.toString();</span>
            default:{
<span class="fc" id="L268">                result.append(c);</span>
<span class="fc" id="L269">                advance();</span>
            }

            }
<span class="fc" id="L273">        }</span>
<span class="nc" id="L274">        return result.toString();</span>
    }
    /**
     * FieldTypeSignature:
     *     ClassTypeSignature
     *     ArrayTypeSignature
     *     TypeVariableSignature
     */
    private FieldTypeSignature parseFieldTypeSignature() {
<span class="fc" id="L283">        return parseFieldTypeSignature(true);</span>
    }

    private FieldTypeSignature parseFieldTypeSignature(boolean allowArrays) {
<span class="pc bpc" id="L287" title="1 of 4 branches missed.">        switch(current()) {</span>
        case 'L':
<span class="fc" id="L289">           return parseClassTypeSignature();</span>
        case 'T':
<span class="fc" id="L291">            return parseTypeVariableSignature();</span>
        case '[':
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">            if (allowArrays)</span>
<span class="fc" id="L294">                return parseArrayTypeSignature();</span>
            else
<span class="nc" id="L296">                throw error(&quot;Array signature not allowed here.&quot;);</span>
<span class="nc" id="L297">        default: throw error(&quot;Expected Field Type Signature&quot;);</span>
        }
    }

    /**
     * ClassTypeSignature:
     *     &quot;L&quot; PackageSpecifier_opt SimpleClassTypeSignature ClassTypeSignatureSuffix* &quot;;&quot;
     */
    private ClassTypeSignature parseClassTypeSignature(){
<span class="pc bpc" id="L306" title="1 of 4 branches missed.">        assert(current() == 'L');</span>
<span class="pc bpc" id="L307" title="1 of 2 branches missed.">        if (current() != 'L') { throw error(&quot;expected a class type&quot;);}</span>
<span class="fc" id="L308">        advance();</span>
<span class="fc" id="L309">        List&lt;SimpleClassTypeSignature&gt; scts = new ArrayList&lt;&gt;(5);</span>
<span class="fc" id="L310">        scts.add(parsePackageNameAndSimpleClassTypeSignature());</span>

<span class="fc" id="L312">        parseClassTypeSignatureSuffix(scts);</span>
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (current() != ';')</span>
<span class="nc" id="L314">            throw error(&quot;expected ';' got '&quot; + current() + &quot;'&quot;);</span>

<span class="fc" id="L316">        advance();</span>
<span class="fc" id="L317">        return ClassTypeSignature.make(scts);</span>
    }

    /**
     * PackageSpecifier:
     *     Identifier &quot;/&quot; PackageSpecifier*
     */
    private SimpleClassTypeSignature parsePackageNameAndSimpleClassTypeSignature() {
        // Parse both any optional leading PackageSpecifier as well as
        // the following SimpleClassTypeSignature.

<span class="fc" id="L328">        String id = parseIdentifier();</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (current() == '/') { // package name</span>
<span class="fc" id="L331">            StringBuilder idBuild = new StringBuilder(id);</span>

<span class="fc bfc" id="L333" title="All 2 branches covered.">            while(current() == '/') {</span>
<span class="fc" id="L334">                advance();</span>
<span class="fc" id="L335">                idBuild.append(&quot;.&quot;);</span>
<span class="fc" id="L336">                idBuild.append(parseIdentifier());</span>
            }
<span class="fc" id="L338">            id = idBuild.toString();</span>
        }

<span class="pc bpc" id="L341" title="1 of 3 branches missed.">        switch (current()) {</span>
        case ';':
<span class="fc" id="L343">            return SimpleClassTypeSignature.make(id, false, new TypeArgument[0]); // all done!</span>
        case '&lt;':
            if (DEBUG) System.out.println(&quot;\t remainder: &quot; + remainder());
<span class="fc" id="L346">            return SimpleClassTypeSignature.make(id, false, parseTypeArguments());</span>
        default:
<span class="nc" id="L348">            throw error(&quot;expected '&lt;' or ';' but got &quot; + current());</span>
        }
    }

    /**
     * SimpleClassTypeSignature:
     *     Identifier TypeArguments_opt
     */
    private SimpleClassTypeSignature parseSimpleClassTypeSignature(boolean dollar){
<span class="fc" id="L357">        String id = parseIdentifier();</span>
<span class="fc" id="L358">        char c = current();</span>

<span class="pc bpc" id="L360" title="1 of 3 branches missed.">        switch (c) {</span>
        case ';':
        case '.':
<span class="fc" id="L363">            return SimpleClassTypeSignature.make(id, dollar, new TypeArgument[0]) ;</span>
        case '&lt;':
<span class="fc" id="L365">            return SimpleClassTypeSignature.make(id, dollar, parseTypeArguments());</span>
        default:
<span class="nc" id="L367">            throw error(&quot;expected '&lt;' or ';' or '.', got '&quot; + c + &quot;'.&quot;);</span>
        }
    }

    /**
     * ClassTypeSignatureSuffix:
     *     &quot;.&quot; SimpleClassTypeSignature
     */
    private void parseClassTypeSignatureSuffix(List&lt;SimpleClassTypeSignature&gt; scts) {
<span class="fc bfc" id="L376" title="All 2 branches covered.">        while (current() == '.') {</span>
<span class="fc" id="L377">            advance();</span>
<span class="fc" id="L378">            scts.add(parseSimpleClassTypeSignature(true));</span>
        }
<span class="fc" id="L380">    }</span>

    private TypeArgument[] parseTypeArgumentsOpt() {
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (current() == '&lt;') {return parseTypeArguments();}</span>
<span class="nc" id="L384">        else {return new TypeArgument[0];}</span>
    }

    /**
     * TypeArguments:
     *     &quot;&lt;&quot; TypeArgument+ &quot;&gt;&quot;
     */
    private TypeArgument[] parseTypeArguments() {
<span class="fc" id="L392">        List&lt;TypeArgument&gt; tas = new ArrayList&lt;&gt;(3);</span>
<span class="pc bpc" id="L393" title="2 of 4 branches missed.">        assert(current() == '&lt;');</span>
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if (current() != '&lt;') { throw error(&quot;expected '&lt;'&quot;);}</span>
<span class="fc" id="L395">        advance();</span>
<span class="fc" id="L396">        tas.add(parseTypeArgument());</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">        while (current() != '&gt;') {</span>
                //(matches(current(),  '+', '-', 'L', '[', 'T', '*')) {
<span class="fc" id="L399">            tas.add(parseTypeArgument());</span>
        }
<span class="fc" id="L401">        advance();</span>
<span class="fc" id="L402">        return tas.toArray(new TypeArgument[tas.size()]);</span>
    }

    /**
     * TypeArgument:
     *     WildcardIndicator_opt FieldTypeSignature
     *     &quot;*&quot;
     */
    private TypeArgument parseTypeArgument() {
        FieldTypeSignature[] ub, lb;
<span class="fc" id="L412">        ub = new FieldTypeSignature[1];</span>
<span class="fc" id="L413">        lb = new FieldTypeSignature[1];</span>
<span class="fc" id="L414">        TypeArgument[] ta = new TypeArgument[0];</span>
<span class="fc" id="L415">        char c = current();</span>
<span class="fc bfc" id="L416" title="All 4 branches covered.">        switch (c) {</span>
        case '+': {
<span class="fc" id="L418">            advance();</span>
<span class="fc" id="L419">            ub[0] = parseFieldTypeSignature();</span>
<span class="fc" id="L420">            lb[0] = BottomSignature.make(); // bottom</span>
<span class="fc" id="L421">            return Wildcard.make(ub, lb);</span>
        }
        case '*':{
<span class="fc" id="L424">            advance();</span>
<span class="fc" id="L425">            ub[0] = SimpleClassTypeSignature.make(&quot;java.lang.Object&quot;, false, ta);</span>
<span class="fc" id="L426">            lb[0] = BottomSignature.make(); // bottom</span>
<span class="fc" id="L427">            return Wildcard.make(ub, lb);</span>
        }
        case '-': {
<span class="fc" id="L430">            advance();</span>
<span class="fc" id="L431">            lb[0] = parseFieldTypeSignature();</span>
<span class="fc" id="L432">            ub[0] = SimpleClassTypeSignature.make(&quot;java.lang.Object&quot;, false, ta);</span>
<span class="fc" id="L433">            return Wildcard.make(ub, lb);</span>
        }
        default:
<span class="fc" id="L436">            return parseFieldTypeSignature();</span>
        }
    }

    /**
     * TypeVariableSignature:
     *     &quot;T&quot; Identifier &quot;;&quot;
     */
    private TypeVariableSignature parseTypeVariableSignature() {
<span class="pc bpc" id="L445" title="2 of 4 branches missed.">        assert(current() == 'T');</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if (current() != 'T') { throw error(&quot;expected a type variable usage&quot;);}</span>
<span class="fc" id="L447">        advance();</span>
<span class="fc" id="L448">        TypeVariableSignature ts = TypeVariableSignature.make(parseIdentifier());</span>
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">        if (current() != ';') {</span>
<span class="nc" id="L450">            throw error(&quot;; expected in signature of type variable named&quot; +</span>
<span class="nc" id="L451">                  ts.getIdentifier());</span>
        }
<span class="fc" id="L453">        advance();</span>
<span class="fc" id="L454">        return ts;</span>
    }

    /**
     * ArrayTypeSignature:
     *     &quot;[&quot; TypeSignature
     */
    private ArrayTypeSignature parseArrayTypeSignature() {
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">        if (current() != '[') {throw error(&quot;expected array type signature&quot;);}</span>
<span class="fc" id="L463">        advance();</span>
<span class="fc" id="L464">        return ArrayTypeSignature.make(parseTypeSignature());</span>
    }

    /**
     * TypeSignature:
     *     FieldTypeSignature
     *     BaseType
     */
    private TypeSignature parseTypeSignature() {
<span class="fc bfc" id="L473" title="All 2 branches covered.">        switch (current()) {</span>
        case 'B':
        case 'C':
        case 'D':
        case 'F':
        case 'I':
        case 'J':
        case 'S':
        case 'Z':
<span class="fc" id="L482">            return parseBaseType();</span>

        default:
<span class="fc" id="L485">            return parseFieldTypeSignature();</span>
        }
    }

    private BaseType parseBaseType() {
<span class="pc bpc" id="L490" title="7 of 9 branches missed.">        switch(current()) {</span>
        case 'B':
<span class="nc" id="L492">            advance();</span>
<span class="nc" id="L493">            return ByteSignature.make();</span>
        case 'C':
<span class="nc" id="L495">            advance();</span>
<span class="nc" id="L496">            return CharSignature.make();</span>
        case 'D':
<span class="nc" id="L498">            advance();</span>
<span class="nc" id="L499">            return DoubleSignature.make();</span>
        case 'F':
<span class="nc" id="L501">            advance();</span>
<span class="nc" id="L502">            return FloatSignature.make();</span>
        case 'I':
<span class="fc" id="L504">            advance();</span>
<span class="fc" id="L505">            return IntSignature.make();</span>
        case 'J':
<span class="nc" id="L507">            advance();</span>
<span class="nc" id="L508">            return LongSignature.make();</span>
        case 'S':
<span class="nc" id="L510">            advance();</span>
<span class="nc" id="L511">            return ShortSignature.make();</span>
        case 'Z':
<span class="fc" id="L513">            advance();</span>
<span class="fc" id="L514">            return BooleanSignature.make();</span>
        default: {
<span class="nc bnc" id="L516" title="All 2 branches missed.">            assert(false);</span>
<span class="nc" id="L517">            throw error(&quot;expected primitive type&quot;);</span>
        }
        }
    }

    /**
     * ClassBound:
     *     &quot;:&quot; FieldTypeSignature_opt
     *
     * InterfaceBound:
     *     &quot;:&quot; FieldTypeSignature
     */
    private FieldTypeSignature[] parseBounds() {
<span class="fc" id="L530">        List&lt;FieldTypeSignature&gt; fts = new ArrayList&lt;&gt;(3);</span>

<span class="pc bpc" id="L532" title="1 of 2 branches missed.">        if (current() == ':') {</span>
<span class="fc" id="L533">            advance();</span>
<span class="fc bfc" id="L534" title="All 2 branches covered.">            switch(current()) {</span>
            case ':': // empty class bound
<span class="fc" id="L536">                break;</span>

            default: // parse class bound
<span class="fc" id="L539">                fts.add(parseFieldTypeSignature());</span>
            }

            // zero or more interface bounds
<span class="fc bfc" id="L543" title="All 2 branches covered.">            while (current() == ':') {</span>
<span class="fc" id="L544">                advance();</span>
<span class="fc" id="L545">                fts.add(parseFieldTypeSignature());</span>
            }
        } else
<span class="nc" id="L548">            error(&quot;Bound expected&quot;);</span>

<span class="fc" id="L550">        return fts.toArray(new FieldTypeSignature[fts.size()]);</span>
    }

    /**
     * SuperclassSignature:
     *     ClassTypeSignature
     */
    private ClassTypeSignature[] parseSuperInterfaces() {
<span class="fc" id="L558">        List&lt;ClassTypeSignature&gt; cts = new ArrayList&lt;&gt;(5);</span>
<span class="fc bfc" id="L559" title="All 2 branches covered.">        while(current() == 'L') {</span>
<span class="fc" id="L560">            cts.add(parseClassTypeSignature());</span>
        }
<span class="fc" id="L562">        return cts.toArray(new ClassTypeSignature[cts.size()]);</span>
    }


    /**
     * MethodTypeSignature:
     *     FormalTypeParameters_opt &quot;(&quot; TypeSignature* &quot;)&quot; ReturnType ThrowsSignature*
     */
    private MethodTypeSignature parseMethodTypeSignature() {
        // Parse a method signature based on the implicit input.
        FieldTypeSignature[] ets;

<span class="pc bpc" id="L574" title="2 of 4 branches missed.">        assert(index == 0);</span>
<span class="fc" id="L575">        return MethodTypeSignature.make(parseZeroOrMoreFormalTypeParameters(),</span>
<span class="fc" id="L576">                                        parseFormalParameters(),</span>
<span class="fc" id="L577">                                        parseReturnType(),</span>
<span class="fc" id="L578">                                        parseZeroOrMoreThrowsSignatures());</span>
    }

    // &quot;(&quot; TypeSignature* &quot;)&quot;
    private TypeSignature[] parseFormalParameters() {
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (current() != '(') {throw error(&quot;expected '('&quot;);}</span>
<span class="fc" id="L584">        advance();</span>
<span class="fc" id="L585">        TypeSignature[] pts = parseZeroOrMoreTypeSignatures();</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        if (current() != ')') {throw error(&quot;expected ')'&quot;);}</span>
<span class="fc" id="L587">        advance();</span>
<span class="fc" id="L588">        return pts;</span>
    }

    // TypeSignature*
    private TypeSignature[] parseZeroOrMoreTypeSignatures() {
<span class="fc" id="L593">        List&lt;TypeSignature&gt; ts = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L594">        boolean stop = false;</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">        while (!stop) {</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            switch(current()) {</span>
            case 'B':
            case 'C':
            case 'D':
            case 'F':
            case 'I':
            case 'J':
            case 'S':
            case 'Z':
            case 'L':
            case 'T':
            case '[': {
<span class="fc" id="L608">                ts.add(parseTypeSignature());</span>
<span class="fc" id="L609">                break;</span>
            }
<span class="fc" id="L611">            default: stop = true;</span>
            }
        }
<span class="fc" id="L614">        return ts.toArray(new TypeSignature[ts.size()]);</span>
    }

    /**
     * ReturnType:
     *     TypeSignature
     *     VoidDescriptor
     */
    private ReturnType parseReturnType(){
<span class="fc bfc" id="L623" title="All 2 branches covered.">        if (current() == 'V') {</span>
<span class="fc" id="L624">            advance();</span>
<span class="fc" id="L625">            return VoidDescriptor.make();</span>
        } else
<span class="fc" id="L627">            return parseTypeSignature();</span>
    }

    // ThrowSignature*
    private FieldTypeSignature[] parseZeroOrMoreThrowsSignatures(){
<span class="fc" id="L632">        List&lt;FieldTypeSignature&gt; ets = new ArrayList&lt;&gt;(3);</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">        while( current() == '^') {</span>
<span class="fc" id="L634">            ets.add(parseThrowsSignature());</span>
        }
<span class="fc" id="L636">        return ets.toArray(new FieldTypeSignature[ets.size()]);</span>
    }

    /**
     * ThrowsSignature:
     *     &quot;^&quot; ClassTypeSignature
     *     &quot;^&quot; TypeVariableSignature
     */
    private FieldTypeSignature parseThrowsSignature() {
<span class="pc bpc" id="L645" title="2 of 4 branches missed.">        assert(current() == '^');</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">        if (current() != '^') { throw error(&quot;expected throws signature&quot;);}</span>
<span class="fc" id="L647">        advance();</span>
<span class="fc" id="L648">        return parseFieldTypeSignature(false);</span>
    }
 }
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>