<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AuthTime.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.krb5.internal.rcache</a> &gt; <span class="el_source">AuthTime.java</span></div><h1>AuthTime.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 *
 *  (C) Copyright IBM Corp. 1999 All Rights Reserved.
 *  Copyright 1997 The Open Group Research Institute.  All rights reserved.
 */

package sun.security.krb5.internal.rcache;

import java.io.IOException;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.SeekableByteChannel;
import java.nio.charset.StandardCharsets;
import java.util.StringTokenizer;

/**
 * The class represents an old style replay cache entry. It is only used in
 * a dfl file.
 *
 * @author Sun/Oracle
 * @author Yanni Zhang
 */
public class AuthTime {
    final int ctime;
    final int cusec;
    final String client;
    final String server;

    /**
     * Constructs an &lt;code&gt;AuthTime&lt;/code&gt;.
     */
    public AuthTime(String client, String server,
<span class="fc" id="L59">            int ctime, int cusec) {</span>
<span class="fc" id="L60">        this.ctime = ctime;</span>
<span class="fc" id="L61">        this.cusec = cusec;</span>
<span class="fc" id="L62">        this.client = client;</span>
<span class="fc" id="L63">        this.server = server;</span>
<span class="fc" id="L64">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L68">        return String.format(&quot;%d/%06d/----/%s&quot;, ctime, cusec, client);</span>
    }

    // Methods used when saved in a dfl file. See DflCache.java

    /**
     * Reads an LC style string from a channel, which is a int32 length
     * plus a UTF-8 encoded string possibly ends with \0.
     * @throws IOException if there is a format error
     * @throws BufferUnderflowException if goes beyond the end
     */
    private static String readStringWithLength(SeekableByteChannel chan)
            throws IOException {
<span class="fc" id="L81">        ByteBuffer bb = ByteBuffer.allocate(4);</span>
<span class="fc" id="L82">        bb.order(ByteOrder.nativeOrder());</span>
<span class="fc" id="L83">        chan.read(bb);</span>
<span class="fc" id="L84">        bb.flip();</span>
<span class="fc" id="L85">        int len = bb.getInt();</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        if (len &gt; 1024) {</span>
            // Memory attack? The string should be fairly short.
<span class="nc" id="L88">            throw new IOException(&quot;Invalid string length&quot;);</span>
        }
<span class="fc" id="L90">        bb = ByteBuffer.allocate(len);</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">        if (chan.read(bb) != len) {</span>
<span class="nc" id="L92">            throw new IOException(&quot;Not enough string&quot;);</span>
        }
<span class="fc" id="L94">        byte[] data = bb.array();</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        return (data[len-1] == 0)?</span>
                new String(data, 0, len-1, StandardCharsets.UTF_8):
                new String(data, StandardCharsets.UTF_8);
    }

    /**
     * Reads an AuthTime or AuthTimeWithHash object from a channel.
     * @throws IOException if there is a format error
     * @throws BufferUnderflowException if goes beyond the end
     */
    public static AuthTime readFrom(SeekableByteChannel chan)
            throws IOException {
<span class="fc" id="L107">        String client = readStringWithLength(chan);</span>
<span class="fc" id="L108">        String server = readStringWithLength(chan);</span>
<span class="fc" id="L109">        ByteBuffer bb = ByteBuffer.allocate(8);</span>
<span class="fc" id="L110">        chan.read(bb);</span>
<span class="fc" id="L111">        bb.order(ByteOrder.nativeOrder());</span>
<span class="fc" id="L112">        int cusec = bb.getInt(0);</span>
<span class="fc" id="L113">        int ctime = bb.getInt(4);</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">        if (client.isEmpty()) {</span>
<span class="fc" id="L115">            StringTokenizer st = new StringTokenizer(server, &quot; :&quot;);</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">            if (st.countTokens() != 6) {</span>
<span class="nc" id="L117">                throw new IOException(&quot;Incorrect rcache style&quot;);</span>
            }
<span class="fc" id="L119">            st.nextToken();</span>
<span class="fc" id="L120">            String hash = st.nextToken();</span>
<span class="fc" id="L121">            st.nextToken();</span>
<span class="fc" id="L122">            client = st.nextToken();</span>
<span class="fc" id="L123">            st.nextToken();</span>
<span class="fc" id="L124">            server = st.nextToken();</span>
<span class="fc" id="L125">            return new AuthTimeWithHash(</span>
                    client, server, ctime, cusec, hash);
        } else {
<span class="fc" id="L128">            return new AuthTime(</span>
                    client, server, ctime, cusec);
        }
    }

    /**
     * Encodes to be used in a dfl file
     */
    protected byte[] encode0(String cstring, String sstring) {
<span class="fc" id="L137">        byte[] c = cstring.getBytes(StandardCharsets.UTF_8);;</span>
<span class="fc" id="L138">        byte[] s = sstring.getBytes(StandardCharsets.UTF_8);;</span>
<span class="fc" id="L139">        byte[] zero = new byte[1];</span>
<span class="fc" id="L140">        int len = 4 + c.length + 1 + 4 + s.length + 1 + 4 + 4;</span>
<span class="fc" id="L141">        ByteBuffer bb = ByteBuffer.allocate(len)</span>
<span class="fc" id="L142">                .order(ByteOrder.nativeOrder());</span>
<span class="fc" id="L143">        bb.putInt(c.length+1).put(c).put(zero)</span>
<span class="fc" id="L144">                .putInt(s.length+1).put(s).put(zero)</span>
<span class="fc" id="L145">                .putInt(cusec).putInt(ctime);</span>
<span class="fc" id="L146">        return bb.array();</span>
    }

    /**
     * Encodes to be used in a dfl file
     * @param withHash useless here
     */
    public byte[] encode(boolean withHash) {
<span class="fc" id="L154">        return encode0(client, server);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>