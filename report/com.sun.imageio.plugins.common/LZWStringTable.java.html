<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>LZWStringTable.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.imageio.plugins.common</a> &gt; <span class="el_source">LZWStringTable.java</span></div><h1>LZWStringTable.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.imageio.plugins.common;

import java.io.PrintStream;

/**
 * General purpose LZW String Table.
 * Extracted from GIFEncoder by Adam Doppelt
 * Comments added by Robin Luiten
 * &lt;code&gt;expandCode&lt;/code&gt; added by Robin Luiten
 * The strLen table to give quick access to the lenght of an expanded
 * code for use by the &lt;code&gt;expandCode&lt;/code&gt; method added by Robin.
 **/
public class LZWStringTable {
    /** codesize + Reserved Codes */
    private final static int RES_CODES = 2;

    private final static short HASH_FREE = (short)0xFFFF;
    private final static short NEXT_FIRST = (short)0xFFFF;

    private final static int MAXBITS = 12;
    private final static int MAXSTR = (1 &lt;&lt; MAXBITS);

    private final static short HASHSIZE = 9973;
    private final static short HASHSTEP = 2039;

    byte[]  strChr;  // after predecessor character
    short[] strNxt;  // predecessor string
    short[] strHsh;  // hash table to find  predecessor + char pairs
    short numStrings;  // next code if adding new prestring + char

    /*
     * each entry corresponds to a code and contains the length of data
     * that the code expands to when decoded.
     */
    int[] strLen;

    /*
     * Constructor allocate memory for string store data
     */
<span class="nc" id="L65">    public LZWStringTable() {</span>
<span class="nc" id="L66">        strChr = new byte[MAXSTR];</span>
<span class="nc" id="L67">        strNxt = new short[MAXSTR];</span>
<span class="nc" id="L68">        strLen = new int[MAXSTR];</span>
<span class="nc" id="L69">        strHsh = new short[HASHSIZE];</span>
<span class="nc" id="L70">    }</span>

    /*
     * @param index value of -1 indicates no predecessor [used in initialisation]
     * @param b the byte [character] to add to the string store which follows
     * the predecessor string specified the index.
     * @return 0xFFFF if no space in table left for addition of predecesor
     * index and byte b. Else return the code allocated for combination index + b.
     */
    public int addCharString(short index, byte b) {
        int hshidx;

<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (numStrings &gt;= MAXSTR) { // if used up all codes</span>
<span class="nc" id="L83">            return 0xFFFF;</span>
        }

<span class="nc" id="L86">        hshidx = hash(index, b);</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        while (strHsh[hshidx] != HASH_FREE) {</span>
<span class="nc" id="L88">            hshidx = (hshidx + HASHSTEP) % HASHSIZE;</span>
        }

<span class="nc" id="L91">        strHsh[hshidx] = numStrings;</span>
<span class="nc" id="L92">        strChr[numStrings] = b;</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">        if (index == HASH_FREE) {</span>
<span class="nc" id="L94">            strNxt[numStrings] = NEXT_FIRST;</span>
<span class="nc" id="L95">            strLen[numStrings] = 1;</span>
        } else {
<span class="nc" id="L97">            strNxt[numStrings] = index;</span>
<span class="nc" id="L98">            strLen[numStrings] = strLen[index] + 1;</span>
        }

<span class="nc" id="L101">        return numStrings++; // return the code and inc for next code</span>
    }

    /*
     * @param index index to prefix string
     * @param b the character that follws the index prefix
     * @return b if param index is HASH_FREE. Else return the code
     * for this prefix and byte successor
     */
    public short findCharString(short index, byte b) {
        int hshidx, nxtidx;

<span class="nc bnc" id="L113" title="All 2 branches missed.">        if (index == HASH_FREE) {</span>
<span class="nc" id="L114">            return (short)(b &amp; 0xFF);    // Rob fixed used to sign extend</span>
        }

<span class="nc" id="L117">        hshidx = hash(index, b);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        while ((nxtidx = strHsh[hshidx]) != HASH_FREE) { // search</span>
<span class="nc bnc" id="L119" title="All 4 branches missed.">            if (strNxt[nxtidx] == index &amp;&amp; strChr[nxtidx] == b) {</span>
<span class="nc" id="L120">                return (short)nxtidx;</span>
            }
<span class="nc" id="L122">            hshidx = (hshidx + HASHSTEP) % HASHSIZE;</span>
        }

<span class="nc" id="L125">        return (short)0xFFFF;</span>
    }

    /*
     * @param codesize the size of code to be preallocated for the
     * string store.
     */
    public void clearTable(int codesize) {
<span class="nc" id="L133">        numStrings = 0;</span>

<span class="nc bnc" id="L135" title="All 2 branches missed.">        for (int q = 0; q &lt; HASHSIZE; q++) {</span>
<span class="nc" id="L136">            strHsh[q] = HASH_FREE;</span>
        }

<span class="nc" id="L139">        int w = (1 &lt;&lt; codesize) + RES_CODES;</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        for (int q = 0; q &lt; w; q++) {</span>
<span class="nc" id="L141">            addCharString((short)0xFFFF, (byte)q); // init with no prefix</span>
        }
<span class="nc" id="L143">    }</span>

    static public int hash(short index, byte lastbyte) {
<span class="nc" id="L146">        return ((int)((short)(lastbyte &lt;&lt; 8) ^ index) &amp; 0xFFFF) % HASHSIZE;</span>
    }

    /*
     * If expanded data doesn't fit into array only what will fit is written
     * to buf and the return value indicates how much of the expanded code has
     * been written to the buf. The next call to expandCode() should be with
     * the same code and have the skip parameter set the negated value of the
     * previous return. Succesive negative return values should be negated and
     * added together for next skip parameter value with same code.
     *
     * @param buf buffer to place expanded data into
     * @param offset offset to place expanded data
     * @param code the code to expand to the byte array it represents.
     * PRECONDITION This code must already be in the LZSS
     * @param skipHead is the number of bytes at the start of the expanded code to
     * be skipped before data is written to buf. It is possible that skipHead is
     * equal to codeLen.
     * @return the length of data expanded into buf. If the expanded code is longer
     * than space left in buf then the value returned is a negative number which when
     * negated is equal to the number of bytes that were used of the code being expanded.
     * This negative value also indicates the buffer is full.
     */
    public int expandCode(byte[] buf, int offset, short code, int skipHead) {
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (offset == -2) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (skipHead == 1) {</span>
<span class="nc" id="L172">                skipHead = 0;</span>
            }
        }
<span class="nc bnc" id="L175" title="All 4 branches missed.">        if (code == (short)0xFFFF ||    // just in case</span>
            skipHead == strLen[code])  // DONE no more unpacked
        {
<span class="nc" id="L178">            return 0;</span>
        }

        int expandLen;  // how much data we are actually expanding
<span class="nc" id="L182">        int codeLen = strLen[code] - skipHead; // length of expanded code left</span>
<span class="nc" id="L183">        int bufSpace = buf.length - offset;  // how much space left</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (bufSpace &gt; codeLen) {</span>
<span class="nc" id="L185">            expandLen = codeLen; // only got this many to unpack</span>
        } else {
<span class="nc" id="L187">            expandLen = bufSpace;</span>
        }

<span class="nc" id="L190">        int skipTail = codeLen - expandLen;  // only &gt; 0 if codeLen &gt; bufSpace [left overs]</span>

<span class="nc" id="L192">        int idx = offset + expandLen;   // initialise to exclusive end address of buffer area</span>

        // NOTE: data unpacks in reverse direction and we are placing the
        // unpacked data directly into the array in the correct location.
<span class="nc bnc" id="L196" title="All 4 branches missed.">        while ((idx &gt; offset) &amp;&amp; (code != (short)0xFFFF)) {</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (--skipTail &lt; 0) { // skip required of expanded data</span>
<span class="nc" id="L198">                buf[--idx] = strChr[code];</span>
            }
<span class="nc" id="L200">            code = strNxt[code];    // to predecessor code</span>
        }

<span class="nc bnc" id="L203" title="All 2 branches missed.">        if (codeLen &gt; expandLen) {</span>
<span class="nc" id="L204">            return -expandLen; // indicate what part of codeLen used</span>
        } else {
<span class="nc" id="L206">            return expandLen;     // indicate length of dat unpacked</span>
        }
    }

    public void dump(PrintStream out) {
        int i;
<span class="nc bnc" id="L212" title="All 2 branches missed.">        for (i = 258; i &lt; numStrings; ++i) {</span>
<span class="nc" id="L213">            out.println(&quot; strNxt[&quot; + i + &quot;] = &quot; + strNxt[i]</span>
<span class="nc" id="L214">                        + &quot; strChr &quot; + Integer.toHexString(strChr[i] &amp; 0xFF)</span>
<span class="nc" id="L215">                        + &quot; strLen &quot; + Integer.toHexString(strLen[i]));</span>
        }
<span class="nc" id="L217">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>