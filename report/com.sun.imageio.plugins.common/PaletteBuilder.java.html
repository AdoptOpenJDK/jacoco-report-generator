<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PaletteBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.imageio.plugins.common</a> &gt; <span class="el_source">PaletteBuilder.java</span></div><h1>PaletteBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.imageio.plugins.common;

import java.awt.Transparency;
import java.awt.image.BufferedImage;
import java.awt.image.RenderedImage;
import java.awt.image.ColorModel;
import java.awt.image.IndexColorModel;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.awt.Color;
import javax.imageio.ImageTypeSpecifier;


/**
 * This class implements the octree quantization method
 *  as it is described in the &quot;Graphics Gems&quot;
 *  (ISBN 0-12-286166-3, Chapter 4, pages 297-293)
 */
public class PaletteBuilder {

    /**
     * maximum of tree depth
     */
    protected static final int MAXLEVEL = 8;

    protected RenderedImage src;
    protected ColorModel srcColorModel;
    protected Raster srcRaster;

    protected int requiredSize;

    protected ColorNode root;

    protected int numNodes;
    protected int maxNodes;
    protected int currLevel;
    protected int currSize;

    protected ColorNode[] reduceList;
    protected ColorNode[] palette;

    protected int transparency;
    protected ColorNode transColor;


    /**
     * Creates an image representing given image
     * &lt;code&gt;src&lt;/code&gt; using &lt;code&gt;IndexColorModel&lt;/code&gt;.
     *
     * Lossless conversion is not always possible (e.g. if number
     * of colors in the  given image exceeds maximum palette size).
     * Result image then is an approximation constructed by octree
     * quantization method.
     *
     * @exception IllegalArgumentException if &lt;code&gt;src&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if implemented method
     * is unable to create approximation of &lt;code&gt;src&lt;/code&gt;
     * and &lt;code&gt;canCreatePalette&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @see createIndexColorModel
     *
     * @see canCreatePalette
     *
     */
    public static RenderedImage createIndexedImage(RenderedImage src) {
<span class="nc" id="L93">        PaletteBuilder pb = new PaletteBuilder(src);</span>
<span class="nc" id="L94">        pb.buildPalette();</span>
<span class="nc" id="L95">        return pb.getIndexedImage();</span>
    }

    /**
     * Creates an palette representing colors from given image
     * &lt;code&gt;img&lt;/code&gt;. If number of colors in the given image exceeds
     * maximum palette size closest colors would be merged.
     *
     * @exception IllegalArgumentException if &lt;code&gt;img&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if implemented method
     * is unable to create approximation of &lt;code&gt;img&lt;/code&gt;
     * and &lt;code&gt;canCreatePalette&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @see createIndexedImage
     *
     * @see canCreatePalette
     *
     */
    public static IndexColorModel createIndexColorModel(RenderedImage img) {
<span class="nc" id="L116">        PaletteBuilder pb = new PaletteBuilder(img);</span>
<span class="nc" id="L117">        pb.buildPalette();</span>
<span class="nc" id="L118">        return pb.getIndexColorModel();</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if PaletteBuilder is able to create
     * palette for given image type.
     *
     * @param type an instance of &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; to be
     * indexed.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;PaletteBuilder&lt;/code&gt;
     * is likely to be able to create palette for this image type.
     *
     * @exception IllegalArgumentException if &lt;code&gt;type&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     */
    public static boolean canCreatePalette(ImageTypeSpecifier type) {
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L136">            throw new IllegalArgumentException(&quot;type == null&quot;);</span>
        }
<span class="nc" id="L138">        return true;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if PaletteBuilder is able to create
     * palette for given rendered image.
     *
     * @param image an instance of &lt;code&gt;RenderedImage&lt;/code&gt; to be
     * indexed.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;PaletteBuilder&lt;/code&gt;
     * is likely to be able to create palette for this image type.
     *
     * @exception IllegalArgumentException if &lt;code&gt;image&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     */
    public static boolean canCreatePalette(RenderedImage image) {
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (image == null) {</span>
<span class="nc" id="L156">            throw new IllegalArgumentException(&quot;image == null&quot;);</span>
        }
<span class="nc" id="L158">        ImageTypeSpecifier type = new ImageTypeSpecifier(image);</span>
<span class="nc" id="L159">        return canCreatePalette(type);</span>
    }

    protected RenderedImage getIndexedImage() {
<span class="nc" id="L163">        IndexColorModel icm = getIndexColorModel();</span>

<span class="nc" id="L165">        BufferedImage dst =</span>
<span class="nc" id="L166">            new BufferedImage(src.getWidth(), src.getHeight(),</span>
                              BufferedImage.TYPE_BYTE_INDEXED, icm);

<span class="nc" id="L169">        WritableRaster wr = dst.getRaster();</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">        for (int y =0; y &lt; dst.getHeight(); y++) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            for (int x = 0; x &lt; dst.getWidth(); x++) {</span>
<span class="nc" id="L172">                Color aColor = getSrcColor(x,y);</span>
<span class="nc" id="L173">                wr.setSample(x, y, 0, findColorIndex(root, aColor));</span>
            }
        }

<span class="nc" id="L177">        return dst;</span>
    }


    protected PaletteBuilder(RenderedImage src) {
<span class="nc" id="L182">        this(src, 256);</span>
<span class="nc" id="L183">    }</span>

<span class="nc" id="L185">    protected PaletteBuilder(RenderedImage src, int size) {</span>
<span class="nc" id="L186">        this.src = src;</span>
<span class="nc" id="L187">        this.srcColorModel = src.getColorModel();</span>
<span class="nc" id="L188">        this.srcRaster = src.getData();</span>

<span class="nc" id="L190">        this.transparency =</span>
<span class="nc" id="L191">            srcColorModel.getTransparency();</span>

<span class="nc" id="L193">        this.requiredSize = size;</span>
<span class="nc" id="L194">    }</span>

    private Color getSrcColor(int x, int y) {
<span class="nc" id="L197">        int argb = srcColorModel.getRGB(srcRaster.getDataElements(x, y, null));</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">        return new Color(argb, transparency != Transparency.OPAQUE);</span>
    }

    protected int findColorIndex(ColorNode aNode, Color aColor) {
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (transparency != Transparency.OPAQUE &amp;&amp;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            aColor.getAlpha() != 0xff)</span>
        {
<span class="nc" id="L205">            return 0; // default transparnt pixel</span>
        }

<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (aNode.isLeaf) {</span>
<span class="nc" id="L209">            return aNode.paletteIndex;</span>
        } else {
<span class="nc" id="L211">            int childIndex = getBranchIndex(aColor, aNode.level);</span>

<span class="nc" id="L213">            return findColorIndex(aNode.children[childIndex], aColor);</span>
        }
    }

    protected void buildPalette() {
<span class="nc" id="L218">        reduceList = new ColorNode[MAXLEVEL + 1];</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        for (int i = 0; i &lt; reduceList.length; i++) {</span>
<span class="nc" id="L220">            reduceList[i] = null;</span>
        }

<span class="nc" id="L223">        numNodes = 0;</span>
<span class="nc" id="L224">        maxNodes = 0;</span>
<span class="nc" id="L225">        root = null;</span>
<span class="nc" id="L226">        currSize = 0;</span>
<span class="nc" id="L227">        currLevel = MAXLEVEL;</span>

        /*
          from the book

        */

<span class="nc" id="L234">        int w = src.getWidth();</span>
<span class="nc" id="L235">        int h = src.getHeight();</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        for (int y = 0; y &lt; h; y++) {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">            for (int x = 0; x &lt; w; x++) {</span>

<span class="nc" id="L239">                Color aColor = getSrcColor(w - x - 1, h - y - 1);</span>
                /*
                 * If transparency of given image is not opaque we assume all
                 * colors with alpha less than 1.0 as fully transparent.
                 */
<span class="nc bnc" id="L244" title="All 2 branches missed.">                if (transparency != Transparency.OPAQUE &amp;&amp;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                    aColor.getAlpha() != 0xff)</span>
                {
<span class="nc bnc" id="L247" title="All 2 branches missed.">                    if (transColor == null) {</span>
<span class="nc" id="L248">                        this.requiredSize --; // one slot for transparent color</span>

<span class="nc" id="L250">                        transColor = new ColorNode();</span>
<span class="nc" id="L251">                        transColor.isLeaf = true;</span>
                    }
<span class="nc" id="L253">                    transColor = insertNode(transColor, aColor, 0);</span>
                } else {
<span class="nc" id="L255">                    root = insertNode(root, aColor, 0);</span>
                }
<span class="nc bnc" id="L257" title="All 2 branches missed.">                if (currSize &gt; requiredSize) {</span>
<span class="nc" id="L258">                    reduceTree();</span>
                }
            }
        }
<span class="nc" id="L262">    }</span>

    protected ColorNode insertNode(ColorNode aNode, Color aColor, int aLevel) {

<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (aNode == null) {</span>
<span class="nc" id="L267">            aNode = new ColorNode();</span>
<span class="nc" id="L268">            numNodes++;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (numNodes &gt; maxNodes) {</span>
<span class="nc" id="L270">                maxNodes = numNodes;</span>
            }
<span class="nc" id="L272">            aNode.level = aLevel;</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">            aNode.isLeaf = (aLevel &gt; MAXLEVEL);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">            if (aNode.isLeaf) {</span>
<span class="nc" id="L275">                currSize++;</span>
            }
        }
<span class="nc" id="L278">        aNode.colorCount++;</span>
<span class="nc" id="L279">        aNode.red   += aColor.getRed();</span>
<span class="nc" id="L280">        aNode.green += aColor.getGreen();</span>
<span class="nc" id="L281">        aNode.blue  += aColor.getBlue();</span>

<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (!aNode.isLeaf) {</span>
<span class="nc" id="L284">            int branchIndex = getBranchIndex(aColor, aLevel);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (aNode.children[branchIndex] == null) {</span>
<span class="nc" id="L286">                aNode.childCount++;</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                if (aNode.childCount == 2) {</span>
<span class="nc" id="L288">                    aNode.nextReducible = reduceList[aLevel];</span>
<span class="nc" id="L289">                    reduceList[aLevel] = aNode;</span>
                }
            }
<span class="nc" id="L292">            aNode.children[branchIndex] =</span>
<span class="nc" id="L293">                insertNode(aNode.children[branchIndex], aColor, aLevel + 1);</span>
        }
<span class="nc" id="L295">        return aNode;</span>
    }

    protected IndexColorModel getIndexColorModel() {
<span class="nc" id="L299">        int size = currSize;</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (transColor != null) {</span>
<span class="nc" id="L301">            size ++; // we need place for transparent color;</span>
        }

<span class="nc" id="L304">        byte[] red = new byte[size];</span>
<span class="nc" id="L305">        byte[] green = new byte[size];</span>
<span class="nc" id="L306">        byte[] blue = new byte[size];</span>

<span class="nc" id="L308">        int index = 0;</span>
<span class="nc" id="L309">        palette = new ColorNode[size];</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (transColor != null) {</span>
<span class="nc" id="L311">            index ++;</span>
        }

<span class="nc bnc" id="L314" title="All 2 branches missed.">        if (root != null) {</span>
<span class="nc" id="L315">            findPaletteEntry(root, index, red, green, blue);</span>
        }

<span class="nc" id="L318">        IndexColorModel icm = null;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (transColor  != null) {</span>
<span class="nc" id="L320">            icm = new IndexColorModel(8, size, red, green, blue, 0);</span>
        } else {
<span class="nc" id="L322">            icm = new IndexColorModel(8, currSize, red, green, blue);</span>
        }
<span class="nc" id="L324">        return icm;</span>
    }

    protected int findPaletteEntry(ColorNode aNode, int index,
                                   byte[] red, byte[] green, byte[] blue)
        {
<span class="nc bnc" id="L330" title="All 2 branches missed.">            if (aNode.isLeaf) {</span>
<span class="nc" id="L331">                red[index]   = (byte)(aNode.red/aNode.colorCount);</span>
<span class="nc" id="L332">                green[index] = (byte)(aNode.green/aNode.colorCount);</span>
<span class="nc" id="L333">                blue[index]  = (byte)(aNode.blue/aNode.colorCount);</span>
<span class="nc" id="L334">                aNode.paletteIndex = index;</span>

<span class="nc" id="L336">                palette[index] = aNode;</span>

<span class="nc" id="L338">                index++;</span>
            } else {
<span class="nc bnc" id="L340" title="All 2 branches missed.">                for (int i = 0; i &lt; 8; i++) {</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                    if (aNode.children[i] != null) {</span>
<span class="nc" id="L342">                        index = findPaletteEntry(aNode.children[i], index,</span>
                                                 red, green, blue);
                    }
                }
            }
<span class="nc" id="L347">            return index;</span>
        }

    protected int getBranchIndex(Color aColor, int aLevel) {
<span class="nc bnc" id="L351" title="All 4 branches missed.">        if (aLevel &gt; MAXLEVEL || aLevel &lt; 0) {</span>
<span class="nc" id="L352">            throw new IllegalArgumentException(&quot;Invalid octree node depth: &quot; +</span>
                                               aLevel);
        }

<span class="nc" id="L356">        int shift = MAXLEVEL - aLevel;</span>
<span class="nc" id="L357">        int red_index = 0x1 &amp; ((0xff &amp; aColor.getRed()) &gt;&gt; shift);</span>
<span class="nc" id="L358">        int green_index = 0x1 &amp; ((0xff &amp; aColor.getGreen()) &gt;&gt; shift);</span>
<span class="nc" id="L359">        int blue_index = 0x1 &amp; ((0xff &amp; aColor.getBlue()) &gt;&gt; shift);</span>
<span class="nc" id="L360">        int index = (red_index &lt;&lt; 2) | (green_index &lt;&lt; 1) | blue_index;</span>
<span class="nc" id="L361">        return index;</span>
    }

    protected void reduceTree() {
<span class="nc" id="L365">        int level = reduceList.length - 1;</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">        while (reduceList[level] == null &amp;&amp; level &gt;= 0) {</span>
<span class="nc" id="L367">            level--;</span>
        }

<span class="nc" id="L370">        ColorNode thisNode = reduceList[level];</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (thisNode == null) {</span>
            // nothing to reduce
<span class="nc" id="L373">            return;</span>
        }

        // look for element with lower color count
<span class="nc" id="L377">        ColorNode pList = thisNode;</span>
<span class="nc" id="L378">        int minColorCount = pList.colorCount;</span>

<span class="nc" id="L380">        int cnt = 1;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        while (pList.nextReducible != null) {</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            if (minColorCount &gt; pList.nextReducible.colorCount) {</span>
<span class="nc" id="L383">                thisNode = pList;</span>
<span class="nc" id="L384">                minColorCount = pList.colorCount;</span>
            }
<span class="nc" id="L386">            pList = pList.nextReducible;</span>
<span class="nc" id="L387">            cnt++;</span>
        }

        // save pointer to first reducible node
        // NB: current color count for node could be changed in future
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (thisNode == reduceList[level]) {</span>
<span class="nc" id="L393">            reduceList[level] = thisNode.nextReducible;</span>
        } else {
<span class="nc" id="L395">            pList = thisNode.nextReducible; // we need to process it</span>
<span class="nc" id="L396">            thisNode.nextReducible = pList.nextReducible;</span>
<span class="nc" id="L397">            thisNode = pList;</span>
        }

<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (thisNode.isLeaf) {</span>
<span class="nc" id="L401">            return;</span>
        }

        // reduce node
<span class="nc" id="L405">        int leafChildCount = thisNode.getLeafChildCount();</span>
<span class="nc" id="L406">        thisNode.isLeaf = true;</span>
<span class="nc" id="L407">        currSize -= (leafChildCount - 1);</span>
<span class="nc" id="L408">        int aDepth = thisNode.level;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="nc" id="L410">            thisNode.children[i] = freeTree(thisNode.children[i]);</span>
        }
<span class="nc" id="L412">        thisNode.childCount = 0;</span>
<span class="nc" id="L413">    }</span>

    protected ColorNode freeTree(ColorNode aNode) {
<span class="nc bnc" id="L416" title="All 2 branches missed.">        if (aNode == null) {</span>
<span class="nc" id="L417">            return null;</span>
        }
<span class="nc bnc" id="L419" title="All 2 branches missed.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="nc" id="L420">            aNode.children[i] = freeTree(aNode.children[i]);</span>
        }

<span class="nc" id="L423">        numNodes--;</span>
<span class="nc" id="L424">        return null;</span>
    }

    /**
     * The node of color tree.
     */
    protected class ColorNode {
        public boolean isLeaf;
        public int childCount;
        ColorNode[] children;

        public int colorCount;
        public long red;
        public long blue;
        public long green;

        public int paletteIndex;

        public int level;
        ColorNode nextReducible;

<span class="nc" id="L445">        public ColorNode() {</span>
<span class="nc" id="L446">            isLeaf = false;</span>
<span class="nc" id="L447">            level = 0;</span>
<span class="nc" id="L448">            childCount = 0;</span>
<span class="nc" id="L449">            children = new ColorNode[8];</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">            for (int i = 0; i &lt; 8; i++) {</span>
<span class="nc" id="L451">                children[i] = null;</span>
            }

<span class="nc" id="L454">            colorCount = 0;</span>
<span class="nc" id="L455">            red = green = blue = 0;</span>

<span class="nc" id="L457">            paletteIndex = 0;</span>
<span class="nc" id="L458">        }</span>

        public int getLeafChildCount() {
<span class="nc bnc" id="L461" title="All 2 branches missed.">            if (isLeaf) {</span>
<span class="nc" id="L462">                return 0;</span>
            }
<span class="nc" id="L464">            int cnt = 0;</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            for (int i = 0; i &lt; children.length; i++) {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if (children[i] != null) {</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                    if (children[i].isLeaf) {</span>
<span class="nc" id="L468">                        cnt ++;</span>
                    } else {
<span class="nc" id="L470">                        cnt += children[i].getLeafChildCount();</span>
                    }
                }
            }
<span class="nc" id="L474">            return cnt;</span>
        }

        public int getRGB() {
<span class="nc" id="L478">            int r = (int)red/colorCount;</span>
<span class="nc" id="L479">            int g = (int)green/colorCount;</span>
<span class="nc" id="L480">            int b = (int)blue/colorCount;</span>

<span class="nc" id="L482">            int c = 0xff &lt;&lt; 24 | (0xff&amp;r) &lt;&lt; 16 | (0xff&amp;g) &lt;&lt; 8 | (0xff&amp;b);</span>
<span class="nc" id="L483">            return c;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>