<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SwingUtilities2.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.swing</a> &gt; <span class="el_source">SwingUtilities2.java</span></div><h1>SwingUtilities2.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.swing;

import java.security.*;
import java.lang.reflect.*;
import java.awt.*;
import static java.awt.RenderingHints.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.print.PrinterGraphics;
import java.text.CharacterIterator;
import java.text.AttributedCharacterIterator;
import java.text.AttributedString;

import javax.swing.*;
import javax.swing.event.TreeModelEvent;
import javax.swing.text.Highlighter;
import javax.swing.text.JTextComponent;
import javax.swing.text.DefaultHighlighter;
import javax.swing.text.DefaultCaret;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumnModel;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;

import sun.swing.PrintColorUIResource;
import sun.swing.ImageIconUIResource;
import sun.print.ProxyPrintGraphics;
import sun.awt.*;
import sun.security.action.GetPropertyAction;
import sun.security.util.SecurityConstants;
import java.io.*;
import java.util.*;
import sun.font.FontDesignMetrics;
import sun.font.FontUtilities;
import sun.java2d.SunGraphicsEnvironment;

import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;

/**
 * A collection of utility methods for Swing.
 * &lt;p&gt;
 * &lt;b&gt;WARNING:&lt;/b&gt; While this class is public, it should not be treated as
 * public API and its API may change in incompatable ways between dot dot
 * releases and even patch releases. You should not rely on this class even
 * existing.
 *
 */
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">public class SwingUtilities2 {</span>
    /**
     * The &lt;code&gt;AppContext&lt;/code&gt; key for our one &lt;code&gt;LAFState&lt;/code&gt;
     * instance.
     */
<span class="fc" id="L81">    public static final Object LAF_STATE_KEY =</span>
            new StringBuffer(&quot;LookAndFeel State&quot;);

    // Maintain a cache of CACHE_SIZE fonts and the left side bearing
     // of the characters falling into the range MIN_CHAR_INDEX to
     // MAX_CHAR_INDEX. The values in fontCache are created as needed.
     private static LSBCacheEntry[] fontCache;
     // Windows defines 6 font desktop properties, we will therefore only
     // cache the metrics for 6 fonts.
     private static final int CACHE_SIZE = 6;
     // nextIndex in fontCache to insert a font into.
     private static int nextIndex;
     // LSBCacheEntry used to search in fontCache to see if we already
     // have an entry for a particular font
     private static LSBCacheEntry searchKey;

     // getLeftSideBearing will consult all characters that fall in the
     // range MIN_CHAR_INDEX to MAX_CHAR_INDEX.
     private static final int MIN_CHAR_INDEX = (int)'W';
     private static final int MAX_CHAR_INDEX = (int)'W' + 1;

<span class="fc" id="L102">    public static final FontRenderContext DEFAULT_FRC =</span>
        new FontRenderContext(null, false, false);

    /**
     * A JComponent client property is used to determine text aa settings.
     * To avoid having this property persist between look and feels changes
     * the value of the property is set to null in JComponent.setUI
     */
<span class="fc" id="L110">    public static final Object AA_TEXT_PROPERTY_KEY =</span>
                          new StringBuffer(&quot;AATextInfoPropertyKey&quot;);

    /**
     * Attribute key for the content elements.  If it is set on an element, the
     * element is considered to be a line break.
     */
    public static final String IMPLIED_CR = &quot;CR&quot;;

    /**
     * Used to tell a text component, being used as an editor for table
     * or tree, how many clicks it took to start editing.
     */
<span class="fc" id="L123">    private static final StringBuilder SKIP_CLICK_COUNT =</span>
        new StringBuilder(&quot;skipClickCount&quot;);

    /* Presently this class assumes default fractional metrics.
     * This may need to change to emulate future platform L&amp;Fs.
     */
    public static class AATextInfo {

        private static AATextInfo getAATextInfoFromMap(Map hints) {

<span class="nc" id="L133">            Object aaHint   = hints.get(KEY_TEXT_ANTIALIASING);</span>
<span class="nc" id="L134">            Object contHint = hints.get(KEY_TEXT_LCD_CONTRAST);</span>

<span class="nc bnc" id="L136" title="All 6 branches missed.">            if (aaHint == null ||</span>
                aaHint == VALUE_TEXT_ANTIALIAS_OFF ||
                aaHint == VALUE_TEXT_ANTIALIAS_DEFAULT) {
<span class="nc" id="L139">                return null;</span>
            } else {
<span class="nc" id="L141">                return new AATextInfo(aaHint, (Integer)contHint);</span>
            }
        }

        public static AATextInfo getAATextInfo(boolean lafCondition) {
<span class="fc" id="L146">            SunToolkit.setAAFontSettingsCondition(lafCondition);</span>
<span class="fc" id="L147">            Toolkit tk = Toolkit.getDefaultToolkit();</span>
<span class="fc" id="L148">            Object map = tk.getDesktopProperty(SunToolkit.DESKTOPFONTHINTS);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (map instanceof Map) {</span>
<span class="nc" id="L150">                return getAATextInfoFromMap((Map)map);</span>
            } else {
<span class="fc" id="L152">                return null;</span>
            }
        }

        Object aaHint;
        Integer lcdContrastHint;
        FontRenderContext frc;

        /* These are rarely constructed objects, and only when a complete
         * UI is being updated, so the cost of the tests here is minimal
         * and saves tests elsewhere.
         * We test that the values are ones we support/expect.
         */
<span class="nc" id="L165">        public AATextInfo(Object aaHint, Integer lcdContrastHint) {</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">            if (aaHint == null) {</span>
<span class="nc" id="L167">                throw new InternalError(&quot;null not allowed here&quot;);</span>
            }
<span class="nc bnc" id="L169" title="All 4 branches missed.">            if (aaHint == VALUE_TEXT_ANTIALIAS_OFF ||</span>
                aaHint == VALUE_TEXT_ANTIALIAS_DEFAULT) {
<span class="nc" id="L171">                throw new InternalError(&quot;AA must be on&quot;);</span>
            }
<span class="nc" id="L173">            this.aaHint = aaHint;</span>
<span class="nc" id="L174">            this.lcdContrastHint = lcdContrastHint;</span>
<span class="nc" id="L175">            this.frc = new FontRenderContext(null, aaHint,</span>
                                             VALUE_FRACTIONALMETRICS_DEFAULT);
<span class="nc" id="L177">        }</span>
    }

    /**
     * Key used in client properties used to indicate that the
     * &lt;code&gt;ComponentUI&lt;/code&gt; of the JComponent instance should be returned.
     */
<span class="fc" id="L184">    public static final Object COMPONENT_UI_PROPERTY_KEY =</span>
                            new StringBuffer(&quot;ComponentUIPropertyKey&quot;);

    /** Client Property key for the text maximal offsets for BasicMenuItemUI */
<span class="fc" id="L188">    public static final StringUIClientPropertyKey BASICMENUITEMUI_MAX_TEXT_OFFSET =</span>
        new StringUIClientPropertyKey (&quot;maxTextOffset&quot;);

    // security stuff
<span class="fc" id="L192">    private static Field inputEvent_CanAccessSystemClipboard_Field = null;</span>
    private static final String UntrustedClipboardAccess =
        &quot;UNTRUSTED_CLIPBOARD_ACCESS_KEY&quot;;

    //all access to  charsBuffer is to be synchronized on charsBufferLock
    private static final int CHAR_BUFFER_SIZE = 100;
<span class="fc" id="L198">    private static final Object charsBufferLock = new Object();</span>
<span class="fc" id="L199">    private static char[] charsBuffer = new char[CHAR_BUFFER_SIZE];</span>

    static {
<span class="fc" id="L202">        fontCache = new LSBCacheEntry[CACHE_SIZE];</span>
<span class="fc" id="L203">    }</span>

    /**
     * Fill the character buffer cache.  Return the buffer length.
     */
    private static int syncCharsBuffer(String s) {
<span class="nc" id="L209">        int length = s.length();</span>
<span class="nc bnc" id="L210" title="All 4 branches missed.">        if ((charsBuffer == null) || (charsBuffer.length &lt; length)) {</span>
<span class="nc" id="L211">            charsBuffer = s.toCharArray();</span>
        } else {
<span class="nc" id="L213">            s.getChars(0, length, charsBuffer, 0);</span>
        }
<span class="nc" id="L215">        return length;</span>
    }

    /**
     * checks whether TextLayout is required to handle characters.
     *
     * @param text characters to be tested
     * @param start start
     * @param limit limit
     * @return &lt;tt&gt;true&lt;/tt&gt;  if TextLayout is required
     *         &lt;tt&gt;false&lt;/tt&gt; if TextLayout is not required
     */
    public static final boolean isComplexLayout(char[] text, int start, int limit) {
<span class="nc" id="L228">        return FontUtilities.isComplexText(text, start, limit);</span>
    }

    //
    // WARNING WARNING WARNING WARNING WARNING WARNING
    // Many of the following methods are invoked from older API.
    // As this older API was not passed a Component, a null Component may
    // now be passsed in.  For example, SwingUtilities.computeStringWidth
    // is implemented to call SwingUtilities2.stringWidth, the
    // SwingUtilities variant does not take a JComponent, as such
    // SwingUtilities2.stringWidth can be passed a null Component.
    // In other words, if you add new functionality to these methods you
    // need to gracefully handle null.
    //

    /**
     * Returns whether or not text should be drawn antialiased.
     *
     * @param c JComponent to test.
     * @return Whether or not text should be drawn antialiased for the
     *         specified component.
     */
    public static AATextInfo drawTextAntialiased(JComponent c) {
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (c != null) {</span>
            /* a non-null property implies some form of AA requested */
<span class="nc" id="L253">            return (AATextInfo)c.getClientProperty(AA_TEXT_PROPERTY_KEY);</span>
        }
        // No component, assume aa is off
<span class="nc" id="L256">        return null;</span>
    }

    /**
     * Returns the left side bearing of the first character of string. The
     * left side bearing is calculated from the passed in
     * FontMetrics.  If the passed in String is less than one
     * character {@code 0} is returned.
     *
     * @param c JComponent that will display the string
     * @param fm FontMetrics used to measure the String width
     * @param string String to get the left side bearing for.
     * @throws NullPointerException if {@code string} is {@code null}
     *
     * @return the left side bearing of the first character of string
     * or {@code 0} if the string is empty
     */
    public static int getLeftSideBearing(JComponent c, FontMetrics fm,
                                         String string) {
<span class="nc bnc" id="L275" title="All 4 branches missed.">        if ((string == null) || (string.length() == 0)) {</span>
<span class="nc" id="L276">            return 0;</span>
        }
<span class="nc" id="L278">        return getLeftSideBearing(c, fm, string.charAt(0));</span>
    }

    /**
     * Returns the left side bearing of the first character of string. The
     * left side bearing is calculated from the passed in FontMetrics.
     *
     * @param c JComponent that will display the string
     * @param fm FontMetrics used to measure the String width
     * @param firstChar Character to get the left side bearing for.
     */
    public static int getLeftSideBearing(JComponent c, FontMetrics fm,
                                         char firstChar) {
<span class="nc" id="L291">        int charIndex = (int) firstChar;</span>
<span class="nc bnc" id="L292" title="All 4 branches missed.">        if (charIndex &lt; MAX_CHAR_INDEX &amp;&amp; charIndex &gt;= MIN_CHAR_INDEX) {</span>
<span class="nc" id="L293">            byte[] lsbs = null;</span>

<span class="nc" id="L295">            FontRenderContext frc = getFontRenderContext(c, fm);</span>
<span class="nc" id="L296">            Font font = fm.getFont();</span>
<span class="nc" id="L297">            synchronized (SwingUtilities2.class) {</span>
<span class="nc" id="L298">                LSBCacheEntry entry = null;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                if (searchKey == null) {</span>
<span class="nc" id="L300">                    searchKey = new LSBCacheEntry(frc, font);</span>
                } else {
<span class="nc" id="L302">                    searchKey.reset(frc, font);</span>
                }
                // See if we already have an entry for this pair
<span class="nc bnc" id="L305" title="All 2 branches missed.">                for (LSBCacheEntry cacheEntry : fontCache) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">                    if (searchKey.equals(cacheEntry)) {</span>
<span class="nc" id="L307">                        entry = cacheEntry;</span>
<span class="nc" id="L308">                        break;</span>
                    }
                }
<span class="nc bnc" id="L311" title="All 2 branches missed.">                if (entry == null) {</span>
                    // No entry for this pair, add it.
<span class="nc" id="L313">                    entry = searchKey;</span>
<span class="nc" id="L314">                    fontCache[nextIndex] = searchKey;</span>
<span class="nc" id="L315">                    searchKey = null;</span>
<span class="nc" id="L316">                    nextIndex = (nextIndex + 1) % CACHE_SIZE;</span>
                }
<span class="nc" id="L318">                return entry.getLeftSideBearing(firstChar);</span>
<span class="nc" id="L319">            }</span>
        }
<span class="nc" id="L321">        return 0;</span>
    }

    /**
     * Returns the FontMetrics for the current Font of the passed
     * in Graphics.  This method is used when a Graphics
     * is available, typically when painting.  If a Graphics is not
     * available the JComponent method of the same name should be used.
     * &lt;p&gt;
     * Callers should pass in a non-null JComponent, the exception
     * to this is if a JComponent is not readily available at the time of
     * painting.
     * &lt;p&gt;
     * This does not necessarily return the FontMetrics from the
     * Graphics.
     *
     * @param c JComponent requesting FontMetrics, may be null
     * @param g Graphics Graphics
     */
    public static FontMetrics getFontMetrics(JComponent c, Graphics g) {
<span class="nc" id="L341">        return getFontMetrics(c, g, g.getFont());</span>
    }


    /**
     * Returns the FontMetrics for the specified Font.
     * This method is used when a Graphics is available, typically when
     * painting.  If a Graphics is not available the JComponent method of
     * the same name should be used.
     * &lt;p&gt;
     * Callers should pass in a non-null JComonent, the exception
     * to this is if a JComponent is not readily available at the time of
     * painting.
     * &lt;p&gt;
     * This does not necessarily return the FontMetrics from the
     * Graphics.
     *
     * @param c JComponent requesting FontMetrics, may be null
     * @param c Graphics Graphics
     * @param font Font to get FontMetrics for
     */
    public static FontMetrics getFontMetrics(JComponent c, Graphics g,
                                             Font font) {
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (c != null) {</span>
            // Note: We assume that we're using the FontMetrics
            // from the widget to layout out text, otherwise we can get
            // mismatches when printing.
<span class="nc" id="L368">            return c.getFontMetrics(font);</span>
        }
<span class="nc" id="L370">        return Toolkit.getDefaultToolkit().getFontMetrics(font);</span>
    }


    /**
     * Returns the width of the passed in String.
     * If the passed String is &lt;code&gt;null&lt;/code&gt;, returns zero.
     *
     * @param c JComponent that will display the string, may be null
     * @param fm FontMetrics used to measure the String width
     * @param string String to get the width of
     */
    public static int stringWidth(JComponent c, FontMetrics fm, String string){
<span class="nc bnc" id="L383" title="All 4 branches missed.">        if (string == null || string.equals(&quot;&quot;)) {</span>
<span class="nc" id="L384">            return 0;</span>
        }
<span class="nc bnc" id="L386" title="All 2 branches missed.">        boolean needsTextLayout = ((c != null) &amp;&amp;</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                (c.getClientProperty(TextAttribute.NUMERIC_SHAPING) != null));</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (needsTextLayout) {</span>
<span class="nc" id="L389">            synchronized(charsBufferLock) {</span>
<span class="nc" id="L390">                int length = syncCharsBuffer(string);</span>
<span class="nc" id="L391">                needsTextLayout = isComplexLayout(charsBuffer, 0, length);</span>
<span class="nc" id="L392">            }</span>
        }
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (needsTextLayout) {</span>
<span class="nc" id="L395">            TextLayout layout = createTextLayout(c, string,</span>
<span class="nc" id="L396">                                    fm.getFont(), fm.getFontRenderContext());</span>
<span class="nc" id="L397">            return (int) layout.getAdvance();</span>
        } else {
<span class="nc" id="L399">            return fm.stringWidth(string);</span>
        }
    }


    /**
     * Clips the passed in String to the space provided.
     *
     * @param c JComponent that will display the string, may be null
     * @param fm FontMetrics used to measure the String width
     * @param string String to display
     * @param availTextWidth Amount of space that the string can be drawn in
     * @return Clipped string that can fit in the provided space.
     */
    public static String clipStringIfNecessary(JComponent c, FontMetrics fm,
                                               String string,
                                               int availTextWidth) {
<span class="nc bnc" id="L416" title="All 4 branches missed.">        if ((string == null) || (string.equals(&quot;&quot;)))  {</span>
<span class="nc" id="L417">            return &quot;&quot;;</span>
        }
<span class="nc" id="L419">        int textWidth = SwingUtilities2.stringWidth(c, fm, string);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        if (textWidth &gt; availTextWidth) {</span>
<span class="nc" id="L421">            return SwingUtilities2.clipString(c, fm, string, availTextWidth);</span>
        }
<span class="nc" id="L423">        return string;</span>
    }


    /**
     * Clips the passed in String to the space provided.  NOTE: this assumes
     * the string does not fit in the available space.
     *
     * @param c JComponent that will display the string, may be null
     * @param fm FontMetrics used to measure the String width
     * @param string String to display
     * @param availTextWidth Amount of space that the string can be drawn in
     * @return Clipped string that can fit in the provided space.
     */
    public static String clipString(JComponent c, FontMetrics fm,
                                    String string, int availTextWidth) {
        // c may be null here.
<span class="nc" id="L440">        String clipString = &quot;...&quot;;</span>
<span class="nc" id="L441">        availTextWidth -= SwingUtilities2.stringWidth(c, fm, clipString);</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (availTextWidth &lt;= 0) {</span>
            //can not fit any characters
<span class="nc" id="L444">            return clipString;</span>
        }

        boolean needsTextLayout;
<span class="nc" id="L448">        synchronized (charsBufferLock) {</span>
<span class="nc" id="L449">            int stringLength = syncCharsBuffer(string);</span>
<span class="nc" id="L450">            needsTextLayout =</span>
<span class="nc" id="L451">                isComplexLayout(charsBuffer, 0, stringLength);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (!needsTextLayout) {</span>
<span class="nc" id="L453">                int width = 0;</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">                for (int nChars = 0; nChars &lt; stringLength; nChars++) {</span>
<span class="nc" id="L455">                    width += fm.charWidth(charsBuffer[nChars]);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                    if (width &gt; availTextWidth) {</span>
<span class="nc" id="L457">                        string = string.substring(0, nChars);</span>
<span class="nc" id="L458">                        break;</span>
                    }
                }
            }
<span class="nc" id="L462">        }</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (needsTextLayout) {</span>
<span class="nc" id="L464">            FontRenderContext frc = getFontRenderContext(c, fm);</span>
<span class="nc" id="L465">            AttributedString aString = new AttributedString(string);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L467">                aString.addAttribute(TextAttribute.NUMERIC_SHAPING,</span>
<span class="nc" id="L468">                        c.getClientProperty(TextAttribute.NUMERIC_SHAPING));</span>
            }
<span class="nc" id="L470">            LineBreakMeasurer measurer =</span>
<span class="nc" id="L471">                new LineBreakMeasurer(aString.getIterator(), frc);</span>
<span class="nc" id="L472">            int nChars = measurer.nextOffset(availTextWidth);</span>
<span class="nc" id="L473">            string = string.substring(0, nChars);</span>

        }
<span class="nc" id="L476">        return string + clipString;</span>
    }


    /**
     * Draws the string at the specified location.
     *
     * @param c JComponent that will display the string, may be null
     * @param g Graphics to draw the text to
     * @param text String to display
     * @param x X coordinate to draw the text at
     * @param y Y coordinate to draw the text at
     */
    public static void drawString(JComponent c, Graphics g, String text,
                                  int x, int y) {
        // c may be null

        // All non-editable widgets that draw strings call into this
        // methods.  By non-editable that means widgets like JLabel, JButton
        // but NOT JTextComponents.
<span class="nc bnc" id="L496" title="All 4 branches missed.">        if ( text == null || text.length() &lt;= 0 ) { //no need to paint empty strings</span>
<span class="nc" id="L497">            return;</span>
        }
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (isPrinting(g)) {</span>
<span class="nc" id="L500">            Graphics2D g2d = getGraphics2D(g);</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">            if (g2d != null) {</span>
                /* The printed text must scale linearly with the UI.
                 * Calculate the width on screen, obtain a TextLayout with
                 * advances for the printer graphics FRC, and then justify
                 * it to fit in the screen width. This distributes the spacing
                 * more evenly than directly laying out to the screen advances.
                 */
<span class="nc" id="L508">                String trimmedText = trimTrailingSpaces(text);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">                if (!trimmedText.isEmpty()) {</span>
<span class="nc" id="L510">                    float screenWidth = (float) g2d.getFont().getStringBounds</span>
<span class="nc" id="L511">                            (trimmedText, DEFAULT_FRC).getWidth();</span>
<span class="nc" id="L512">                    TextLayout layout = createTextLayout(c, text, g2d.getFont(),</span>
<span class="nc" id="L513">                                                       g2d.getFontRenderContext());</span>

<span class="nc" id="L515">                    layout = layout.getJustifiedLayout(screenWidth);</span>
                    /* Use alternate print color if specified */
<span class="nc" id="L517">                    Color col = g2d.getColor();</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">                    if (col instanceof PrintColorUIResource) {</span>
<span class="nc" id="L519">                        g2d.setColor(((PrintColorUIResource)col).getPrintColor());</span>
                    }

<span class="nc" id="L522">                    layout.draw(g2d, x, y);</span>

<span class="nc" id="L524">                    g2d.setColor(col);</span>
                }

<span class="nc" id="L527">                return;</span>
            }
        }

        // If we get here we're not printing
<span class="nc bnc" id="L532" title="All 2 branches missed.">        if (g instanceof Graphics2D) {</span>
<span class="nc" id="L533">            AATextInfo info = drawTextAntialiased(c);</span>
<span class="nc" id="L534">            Graphics2D g2 = (Graphics2D)g;</span>

<span class="nc bnc" id="L536" title="All 2 branches missed.">            boolean needsTextLayout = ((c != null) &amp;&amp;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                (c.getClientProperty(TextAttribute.NUMERIC_SHAPING) != null));</span>

<span class="nc bnc" id="L539" title="All 2 branches missed.">            if (needsTextLayout) {</span>
<span class="nc" id="L540">                synchronized(charsBufferLock) {</span>
<span class="nc" id="L541">                    int length = syncCharsBuffer(text);</span>
<span class="nc" id="L542">                    needsTextLayout = isComplexLayout(charsBuffer, 0, length);</span>
<span class="nc" id="L543">                }</span>
            }

<span class="nc bnc" id="L546" title="All 2 branches missed.">            if (info != null) {</span>
<span class="nc" id="L547">                Object oldContrast = null;</span>
<span class="nc" id="L548">                Object oldAAValue = g2.getRenderingHint(KEY_TEXT_ANTIALIASING);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">                if (info.aaHint != oldAAValue) {</span>
<span class="nc" id="L550">                    g2.setRenderingHint(KEY_TEXT_ANTIALIASING, info.aaHint);</span>
                } else {
<span class="nc" id="L552">                    oldAAValue = null;</span>
                }
<span class="nc bnc" id="L554" title="All 2 branches missed.">                if (info.lcdContrastHint != null) {</span>
<span class="nc" id="L555">                    oldContrast = g2.getRenderingHint(KEY_TEXT_LCD_CONTRAST);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                    if (info.lcdContrastHint.equals(oldContrast)) {</span>
<span class="nc" id="L557">                        oldContrast = null;</span>
                    } else {
<span class="nc" id="L559">                        g2.setRenderingHint(KEY_TEXT_LCD_CONTRAST,</span>
                                            info.lcdContrastHint);
                    }
                }

<span class="nc bnc" id="L564" title="All 2 branches missed.">                if (needsTextLayout) {</span>
<span class="nc" id="L565">                    TextLayout layout = createTextLayout(c, text, g2.getFont(),</span>
<span class="nc" id="L566">                                                    g2.getFontRenderContext());</span>
<span class="nc" id="L567">                    layout.draw(g2, x, y);</span>
<span class="nc" id="L568">                } else {</span>
<span class="nc" id="L569">                    g.drawString(text, x, y);</span>
                }

<span class="nc bnc" id="L572" title="All 2 branches missed.">                if (oldAAValue != null) {</span>
<span class="nc" id="L573">                    g2.setRenderingHint(KEY_TEXT_ANTIALIASING, oldAAValue);</span>
                }
<span class="nc bnc" id="L575" title="All 2 branches missed.">                if (oldContrast != null) {</span>
<span class="nc" id="L576">                    g2.setRenderingHint(KEY_TEXT_LCD_CONTRAST, oldContrast);</span>
                }

<span class="nc" id="L579">                return;</span>
            }

<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (needsTextLayout){</span>
<span class="nc" id="L583">                TextLayout layout = createTextLayout(c, text, g2.getFont(),</span>
<span class="nc" id="L584">                                                    g2.getFontRenderContext());</span>
<span class="nc" id="L585">                layout.draw(g2, x, y);</span>
<span class="nc" id="L586">                return;</span>
            }
        }

<span class="nc" id="L590">        g.drawString(text, x, y);</span>
<span class="nc" id="L591">    }</span>

    /**
     * Draws the string at the specified location underlining the specified
     * character.
     *
     * @param c JComponent that will display the string, may be null
     * @param g Graphics to draw the text to
     * @param text String to display
     * @param underlinedIndex Index of a character in the string to underline
     * @param x X coordinate to draw the text at
     * @param y Y coordinate to draw the text at
     */
    public static void drawStringUnderlineCharAt(JComponent c,Graphics g,
                           String text, int underlinedIndex, int x,int y) {
<span class="nc bnc" id="L606" title="All 4 branches missed.">        if (text == null || text.length() &lt;= 0) {</span>
<span class="nc" id="L607">            return;</span>
        }
<span class="nc" id="L609">        SwingUtilities2.drawString(c, g, text, x, y);</span>
<span class="nc" id="L610">        int textLength = text.length();</span>
<span class="nc bnc" id="L611" title="All 4 branches missed.">        if (underlinedIndex &gt;= 0 &amp;&amp; underlinedIndex &lt; textLength ) {</span>
<span class="nc" id="L612">            int underlineRectY = y;</span>
<span class="nc" id="L613">            int underlineRectHeight = 1;</span>
<span class="nc" id="L614">            int underlineRectX = 0;</span>
<span class="nc" id="L615">            int underlineRectWidth = 0;</span>
<span class="nc" id="L616">            boolean isPrinting = isPrinting(g);</span>
<span class="nc" id="L617">            boolean needsTextLayout = isPrinting;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (!needsTextLayout) {</span>
<span class="nc" id="L619">                synchronized (charsBufferLock) {</span>
<span class="nc" id="L620">                    syncCharsBuffer(text);</span>
<span class="nc" id="L621">                    needsTextLayout =</span>
<span class="nc" id="L622">                        isComplexLayout(charsBuffer, 0, textLength);</span>
<span class="nc" id="L623">                }</span>
            }
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (!needsTextLayout) {</span>
<span class="nc" id="L626">                FontMetrics fm = g.getFontMetrics();</span>
<span class="nc" id="L627">                underlineRectX = x +</span>
<span class="nc" id="L628">                    SwingUtilities2.stringWidth(c,fm,</span>
<span class="nc" id="L629">                                        text.substring(0,underlinedIndex));</span>
<span class="nc" id="L630">                underlineRectWidth = fm.charWidth(text.</span>
<span class="nc" id="L631">                                                  charAt(underlinedIndex));</span>
<span class="nc" id="L632">            } else {</span>
<span class="nc" id="L633">                Graphics2D g2d = getGraphics2D(g);</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                if (g2d != null) {</span>
<span class="nc" id="L635">                    TextLayout layout =</span>
<span class="nc" id="L636">                        createTextLayout(c, text, g2d.getFont(),</span>
<span class="nc" id="L637">                                       g2d.getFontRenderContext());</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">                    if (isPrinting) {</span>
<span class="nc" id="L639">                        float screenWidth = (float)g2d.getFont().</span>
<span class="nc" id="L640">                            getStringBounds(text, DEFAULT_FRC).getWidth();</span>
<span class="nc" id="L641">                        layout = layout.getJustifiedLayout(screenWidth);</span>
                    }
<span class="nc" id="L643">                    TextHitInfo leading =</span>
<span class="nc" id="L644">                        TextHitInfo.leading(underlinedIndex);</span>
<span class="nc" id="L645">                    TextHitInfo trailing =</span>
<span class="nc" id="L646">                        TextHitInfo.trailing(underlinedIndex);</span>
<span class="nc" id="L647">                    Shape shape =</span>
<span class="nc" id="L648">                        layout.getVisualHighlightShape(leading, trailing);</span>
<span class="nc" id="L649">                    Rectangle rect = shape.getBounds();</span>
<span class="nc" id="L650">                    underlineRectX = x + rect.x;</span>
<span class="nc" id="L651">                    underlineRectWidth = rect.width;</span>
                }
            }
<span class="nc" id="L654">            g.fillRect(underlineRectX, underlineRectY + 1,</span>
                       underlineRectWidth, underlineRectHeight);
        }
<span class="nc" id="L657">    }</span>


    /**
     * A variation of locationToIndex() which only returns an index if the
     * Point is within the actual bounds of a list item (not just in the cell)
     * and if the JList has the &quot;List.isFileList&quot; client property set.
     * Otherwise, this method returns -1.
     * This is used to make WindowsL&amp;F JFileChooser act like native dialogs.
     */
    public static int loc2IndexFileList(JList list, Point point) {
<span class="nc" id="L668">        int index = list.locationToIndex(point);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">        if (index != -1) {</span>
<span class="nc" id="L670">            Object bySize = list.getClientProperty(&quot;List.isFileList&quot;);</span>
<span class="nc bnc" id="L671" title="All 4 branches missed.">            if (bySize instanceof Boolean &amp;&amp; ((Boolean)bySize).booleanValue() &amp;&amp;</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">                !pointIsInActualBounds(list, index, point)) {</span>
<span class="nc" id="L673">                index = -1;</span>
            }
        }
<span class="nc" id="L676">        return index;</span>
    }


    /**
     * Returns true if the given point is within the actual bounds of the
     * JList item at index (not just inside the cell).
     */
    private static boolean pointIsInActualBounds(JList list, int index,
                                                Point point) {
<span class="nc" id="L686">        ListCellRenderer renderer = list.getCellRenderer();</span>
<span class="nc" id="L687">        ListModel dataModel = list.getModel();</span>
<span class="nc" id="L688">        Object value = dataModel.getElementAt(index);</span>
<span class="nc" id="L689">        Component item = renderer.getListCellRendererComponent(list,</span>
                          value, index, false, false);
<span class="nc" id="L691">        Dimension itemSize = item.getPreferredSize();</span>
<span class="nc" id="L692">        Rectangle cellBounds = list.getCellBounds(index, index);</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">        if (!item.getComponentOrientation().isLeftToRight()) {</span>
<span class="nc" id="L694">            cellBounds.x += (cellBounds.width - itemSize.width);</span>
        }
<span class="nc" id="L696">        cellBounds.width = itemSize.width;</span>

<span class="nc" id="L698">        return cellBounds.contains(point);</span>
    }


    /**
     * Returns true if the given point is outside the preferredSize of the
     * item at the given row of the table.  (Column must be 0).
     * Does not check the &quot;Table.isFileList&quot; property. That should be checked
     * before calling this method.
     * This is used to make WindowsL&amp;F JFileChooser act like native dialogs.
     */
    public static boolean pointOutsidePrefSize(JTable table, int row, int column, Point p) {
<span class="nc bnc" id="L710" title="All 4 branches missed.">        if (table.convertColumnIndexToModel(column) != 0 || row == -1) {</span>
<span class="nc" id="L711">            return true;</span>
        }
<span class="nc" id="L713">        TableCellRenderer tcr = table.getCellRenderer(row, column);</span>
<span class="nc" id="L714">        Object value = table.getValueAt(row, column);</span>
<span class="nc" id="L715">        Component cell = tcr.getTableCellRendererComponent(table, value, false,</span>
                false, row, column);
<span class="nc" id="L717">        Dimension itemSize = cell.getPreferredSize();</span>
<span class="nc" id="L718">        Rectangle cellBounds = table.getCellRect(row, column, false);</span>
<span class="nc" id="L719">        cellBounds.width = itemSize.width;</span>
<span class="nc" id="L720">        cellBounds.height = itemSize.height;</span>

        // See if coords are inside
        // ASSUME: mouse x,y will never be &lt; cell's x,y
<span class="nc bnc" id="L724" title="All 6 branches missed.">        assert (p.x &gt;= cellBounds.x &amp;&amp; p.y &gt;= cellBounds.y);</span>
<span class="nc bnc" id="L725" title="All 4 branches missed.">        return p.x &gt; cellBounds.x + cellBounds.width ||</span>
                p.y &gt; cellBounds.y + cellBounds.height;
    }

    /**
     * Set the lead and anchor without affecting selection.
     */
    public static void setLeadAnchorWithoutSelection(ListSelectionModel model,
                                                     int lead, int anchor) {
<span class="nc bnc" id="L734" title="All 2 branches missed.">        if (anchor == -1) {</span>
<span class="nc" id="L735">            anchor = lead;</span>
        }
<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (lead == -1) {</span>
<span class="nc" id="L738">            model.setAnchorSelectionIndex(-1);</span>
<span class="nc" id="L739">            model.setLeadSelectionIndex(-1);</span>
        } else {
<span class="nc bnc" id="L741" title="All 2 branches missed.">            if (model.isSelectedIndex(lead)) {</span>
<span class="nc" id="L742">                model.addSelectionInterval(lead, lead);</span>
            } else {
<span class="nc" id="L744">                model.removeSelectionInterval(lead, lead);</span>
            }
<span class="nc" id="L746">            model.setAnchorSelectionIndex(anchor);</span>
        }
<span class="nc" id="L748">    }</span>

    /**
     * Ignore mouse events if the component is null, not enabled, the event
     * is not associated with the left mouse button, or the event has been
     * consumed.
     */
    public static boolean shouldIgnore(MouseEvent me, JComponent c) {
<span class="nc bnc" id="L756" title="All 4 branches missed.">        return c == null || !c.isEnabled()</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">                         || !SwingUtilities.isLeftMouseButton(me)</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                         || me.isConsumed();</span>
    }

    /**
     * Request focus on the given component if it doesn't already have it
     * and &lt;code&gt;isRequestFocusEnabled()&lt;/code&gt; returns true.
     */
    public static void adjustFocus(JComponent c) {
<span class="nc bnc" id="L766" title="All 4 branches missed.">        if (!c.hasFocus() &amp;&amp; c.isRequestFocusEnabled()) {</span>
<span class="nc" id="L767">            c.requestFocus();</span>
        }
<span class="nc" id="L769">    }</span>

    /**
     * The following draw functions have the same semantic as the
     * Graphics methods with the same names.
     *
     * this is used for printing
     */
    public static int drawChars(JComponent c, Graphics g,
                                 char[] data,
                                 int offset,
                                 int length,
                                 int x,
                                 int y) {
<span class="nc bnc" id="L783" title="All 2 branches missed.">        if ( length &lt;= 0 ) { //no need to paint empty strings</span>
<span class="nc" id="L784">            return x;</span>
        }
<span class="nc" id="L786">        int nextX = x + getFontMetrics(c, g).charsWidth(data, offset, length);</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (isPrinting(g)) {</span>
<span class="nc" id="L788">            Graphics2D g2d = getGraphics2D(g);</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">            if (g2d != null) {</span>
<span class="nc" id="L790">                FontRenderContext deviceFontRenderContext = g2d.</span>
<span class="nc" id="L791">                    getFontRenderContext();</span>
<span class="nc" id="L792">                FontRenderContext frc = getFontRenderContext(c);</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">                if (frc != null &amp;&amp;</span>
                    !isFontRenderContextPrintCompatible
<span class="nc bnc" id="L795" title="All 2 branches missed.">                    (deviceFontRenderContext, frc)) {</span>

<span class="nc" id="L797">                    String text = new String(data, offset, length);</span>
<span class="nc" id="L798">                    TextLayout layout = new TextLayout(text, g2d.getFont(),</span>
                                    deviceFontRenderContext);
<span class="nc" id="L800">                    String trimmedText = trimTrailingSpaces(text);</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                    if (!trimmedText.isEmpty()) {</span>
<span class="nc" id="L802">                        float screenWidth = (float)g2d.getFont().</span>
<span class="nc" id="L803">                            getStringBounds(trimmedText, frc).getWidth();</span>
<span class="nc" id="L804">                        layout = layout.getJustifiedLayout(screenWidth);</span>

                        /* Use alternate print color if specified */
<span class="nc" id="L807">                        Color col = g2d.getColor();</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">                        if (col instanceof PrintColorUIResource) {</span>
<span class="nc" id="L809">                            g2d.setColor(((PrintColorUIResource)col).getPrintColor());</span>
                        }

<span class="nc" id="L812">                        layout.draw(g2d,x,y);</span>

<span class="nc" id="L814">                        g2d.setColor(col);</span>
                    }

<span class="nc" id="L817">                    return nextX;</span>
                }
            }
        }
        // Assume we're not printing if we get here, or that we are invoked
        // via Swing text printing which is laid out for the printer.
<span class="nc" id="L823">        AATextInfo info = drawTextAntialiased(c);</span>
<span class="nc bnc" id="L824" title="All 4 branches missed.">        if (info != null &amp;&amp; (g instanceof Graphics2D)) {</span>
<span class="nc" id="L825">            Graphics2D g2 = (Graphics2D)g;</span>

<span class="nc" id="L827">            Object oldContrast = null;</span>
<span class="nc" id="L828">            Object oldAAValue = g2.getRenderingHint(KEY_TEXT_ANTIALIASING);</span>
<span class="nc bnc" id="L829" title="All 4 branches missed.">            if (info.aaHint != null &amp;&amp; info.aaHint != oldAAValue) {</span>
<span class="nc" id="L830">                g2.setRenderingHint(KEY_TEXT_ANTIALIASING, info.aaHint);</span>
            } else {
<span class="nc" id="L832">                oldAAValue = null;</span>
            }
<span class="nc bnc" id="L834" title="All 2 branches missed.">            if (info.lcdContrastHint != null) {</span>
<span class="nc" id="L835">                oldContrast = g2.getRenderingHint(KEY_TEXT_LCD_CONTRAST);</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                if (info.lcdContrastHint.equals(oldContrast)) {</span>
<span class="nc" id="L837">                    oldContrast = null;</span>
                } else {
<span class="nc" id="L839">                    g2.setRenderingHint(KEY_TEXT_LCD_CONTRAST,</span>
                                        info.lcdContrastHint);
                }
            }

<span class="nc" id="L844">            g.drawChars(data, offset, length, x, y);</span>

<span class="nc bnc" id="L846" title="All 2 branches missed.">            if (oldAAValue != null) {</span>
<span class="nc" id="L847">                g2.setRenderingHint(KEY_TEXT_ANTIALIASING, oldAAValue);</span>
            }
<span class="nc bnc" id="L849" title="All 2 branches missed.">            if (oldContrast != null) {</span>
<span class="nc" id="L850">                g2.setRenderingHint(KEY_TEXT_LCD_CONTRAST, oldContrast);</span>
            }
<span class="nc" id="L852">        }</span>
        else {
<span class="nc" id="L854">            g.drawChars(data, offset, length, x, y);</span>
        }
<span class="nc" id="L856">        return nextX;</span>
    }

    /*
     * see documentation for drawChars
     * returns the advance
     */
    public static float drawString(JComponent c, Graphics g,
                                   AttributedCharacterIterator iterator,
                                   int x,
                                   int y) {

        float retVal;
<span class="nc" id="L869">        boolean isPrinting = isPrinting(g);</span>
<span class="nc" id="L870">        Color col = g.getColor();</span>

<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (isPrinting) {</span>
            /* Use alternate print color if specified */
<span class="nc bnc" id="L874" title="All 2 branches missed.">            if (col instanceof PrintColorUIResource) {</span>
<span class="nc" id="L875">                g.setColor(((PrintColorUIResource)col).getPrintColor());</span>
            }
        }

<span class="nc" id="L879">        Graphics2D g2d = getGraphics2D(g);</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (g2d == null) {</span>
<span class="nc" id="L881">            g.drawString(iterator,x,y); //for the cases where advance</span>
                                        //matters it should not happen
<span class="nc" id="L883">            retVal = x;</span>

        } else {
            FontRenderContext frc;
<span class="nc bnc" id="L887" title="All 2 branches missed.">            if (isPrinting) {</span>
<span class="nc" id="L888">                frc = getFontRenderContext(c);</span>
<span class="nc bnc" id="L889" title="All 4 branches missed.">                if (frc.isAntiAliased() || frc.usesFractionalMetrics()) {</span>
<span class="nc" id="L890">                    frc = new FontRenderContext(frc.getTransform(), false, false);</span>
                }
<span class="nc bnc" id="L892" title="All 2 branches missed.">            } else if ((frc = getFRCProperty(c)) != null) {</span>
                /* frc = frc; ! */
            } else {
<span class="nc" id="L895">                frc = g2d.getFontRenderContext();</span>
            }
            TextLayout layout;
<span class="nc bnc" id="L898" title="All 2 branches missed.">            if (isPrinting) {</span>
<span class="nc" id="L899">                FontRenderContext deviceFRC = g2d.getFontRenderContext();</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">                if (!isFontRenderContextPrintCompatible(frc, deviceFRC)) {</span>
<span class="nc" id="L901">                    layout = new TextLayout(iterator, deviceFRC);</span>
<span class="nc" id="L902">                    AttributedCharacterIterator trimmedIt =</span>
<span class="nc" id="L903">                            getTrimmedTrailingSpacesIterator(iterator);</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                    if (trimmedIt != null) {</span>
<span class="nc" id="L905">                        float screenWidth = new TextLayout(trimmedIt, frc).</span>
<span class="nc" id="L906">                                getAdvance();</span>
<span class="nc" id="L907">                        layout = layout.getJustifiedLayout(screenWidth);</span>
                    }
<span class="nc" id="L909">                } else {</span>
<span class="nc" id="L910">                    layout = new TextLayout(iterator, frc);</span>
                }
<span class="nc" id="L912">            } else {</span>
<span class="nc" id="L913">                layout = new TextLayout(iterator, frc);</span>
            }
<span class="nc" id="L915">            layout.draw(g2d, x, y);</span>
<span class="nc" id="L916">            retVal = layout.getAdvance();</span>
        }

<span class="nc bnc" id="L919" title="All 2 branches missed.">        if (isPrinting) {</span>
<span class="nc" id="L920">            g.setColor(col);</span>
        }

<span class="nc" id="L923">        return retVal;</span>
    }

    private static TextLayout createTextLayout(JComponent c, String s,
                                            Font f, FontRenderContext frc) {
<span class="nc bnc" id="L928" title="All 2 branches missed.">        Object shaper = (c == null ?</span>
<span class="nc" id="L929">                    null : c.getClientProperty(TextAttribute.NUMERIC_SHAPING));</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">        if (shaper == null) {</span>
<span class="nc" id="L931">            return new TextLayout(s, f, frc);</span>
        } else {
<span class="nc" id="L933">            Map&lt;TextAttribute, Object&gt; a = new HashMap&lt;TextAttribute, Object&gt;();</span>
<span class="nc" id="L934">            a.put(TextAttribute.FONT, f);</span>
<span class="nc" id="L935">            a.put(TextAttribute.NUMERIC_SHAPING, shaper);</span>
<span class="nc" id="L936">            return new TextLayout(s, a, frc);</span>
        }
    }

    /*
     * Checks if two given FontRenderContexts are compatible for printing.
     * We can't just use equals as we want to exclude from the comparison :
     * + whether AA is set as irrelevant for printing and shouldn't affect
     * printed metrics anyway
     * + any translation component in the transform of either FRC, as it
     * does not affect metrics.
     * Compatible means no special handling needed for text painting
     */
    private static boolean
        isFontRenderContextPrintCompatible(FontRenderContext frc1,
                                           FontRenderContext frc2) {

<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (frc1 == frc2) {</span>
<span class="nc" id="L954">            return true;</span>
        }

<span class="nc bnc" id="L957" title="All 4 branches missed.">        if (frc1 == null || frc2 == null) { // not supposed to happen</span>
<span class="nc" id="L958">            return false;</span>
        }

<span class="nc" id="L961">        if (frc1.getFractionalMetricsHint() !=</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">            frc2.getFractionalMetricsHint()) {</span>
<span class="nc" id="L963">            return false;</span>
        }

        /* If both are identity, return true */
<span class="nc bnc" id="L967" title="All 4 branches missed.">        if (!frc1.isTransformed() &amp;&amp; !frc2.isTransformed()) {</span>
<span class="nc" id="L968">            return true;</span>
        }

        /* That's the end of the cheap tests, need to get and compare
         * the transform matrices. We don't care about the translation
         * components, so return true if they are otherwise identical.
         */
<span class="nc" id="L975">        double[] mat1 = new double[4];</span>
<span class="nc" id="L976">        double[] mat2 = new double[4];</span>
<span class="nc" id="L977">        frc1.getTransform().getMatrix(mat1);</span>
<span class="nc" id="L978">        frc2.getTransform().getMatrix(mat2);</span>
<span class="nc bnc" id="L979" title="All 8 branches missed.">        return</span>
            mat1[0] == mat2[0] &amp;&amp;
            mat1[1] == mat2[1] &amp;&amp;
            mat1[2] == mat2[2] &amp;&amp;
            mat1[3] == mat2[3];
    }

    /*
     * Tries it best to get Graphics2D out of the given Graphics
     * returns null if can not derive it.
     */
    public static Graphics2D getGraphics2D(Graphics g) {
<span class="nc bnc" id="L991" title="All 2 branches missed.">        if (g instanceof Graphics2D) {</span>
<span class="nc" id="L992">            return (Graphics2D) g;</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">        } else if (g instanceof ProxyPrintGraphics) {</span>
<span class="nc" id="L994">            return (Graphics2D)(((ProxyPrintGraphics)g).getGraphics());</span>
        } else {
<span class="nc" id="L996">            return null;</span>
        }
    }

    /*
     * Returns FontRenderContext associated with Component.
     * FontRenderContext from Component.getFontMetrics is associated
     * with the component.
     *
     * Uses Component.getFontMetrics to get the FontRenderContext from.
     * see JComponent.getFontMetrics and TextLayoutStrategy.java
     */
    public static FontRenderContext getFontRenderContext(Component c) {
<span class="nc bnc" id="L1009" title="All 4 branches missed.">        assert c != null;</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L1011">            return DEFAULT_FRC;</span>
        } else {
<span class="nc" id="L1013">            return c.getFontMetrics(c.getFont()).getFontRenderContext();</span>
        }
    }

    /**
     * A convenience method to get FontRenderContext.
     * Returns the FontRenderContext for the passed in FontMetrics or
     * for the passed in Component if FontMetrics is null
     */
    private static FontRenderContext getFontRenderContext(Component c, FontMetrics fm) {
<span class="nc bnc" id="L1023" title="All 6 branches missed.">        assert fm != null || c!= null;</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">        return (fm != null) ? fm.getFontRenderContext()</span>
<span class="nc" id="L1025">            : getFontRenderContext(c);</span>
    }

    /*
     * This method is to be used only for JComponent.getFontMetrics.
     * In all other places to get FontMetrics we need to use
     * JComponent.getFontMetrics.
     *
     */
    public static FontMetrics getFontMetrics(JComponent c, Font font) {
<span class="nc" id="L1035">        FontRenderContext  frc = getFRCProperty(c);</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">        if (frc == null) {</span>
<span class="nc" id="L1037">            frc = DEFAULT_FRC;</span>
        }
<span class="nc" id="L1039">        return FontDesignMetrics.getMetrics(font, frc);</span>
    }


    /* Get any FontRenderContext associated with a JComponent
     * - may return null
     */
    private static FontRenderContext getFRCProperty(JComponent c) {
<span class="nc bnc" id="L1047" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L1048">            AATextInfo info =</span>
<span class="nc" id="L1049">                (AATextInfo)c.getClientProperty(AA_TEXT_PROPERTY_KEY);</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            if (info != null) {</span>
<span class="nc" id="L1051">                return info.frc;</span>
            }
        }
<span class="nc" id="L1054">        return null;</span>
    }

    /*
     * returns true if the Graphics is print Graphics
     * false otherwise
     */
    static boolean isPrinting(Graphics g) {
<span class="nc bnc" id="L1062" title="All 4 branches missed.">        return (g instanceof PrinterGraphics || g instanceof PrintGraphics);</span>
    }

    private static String trimTrailingSpaces(String s) {
<span class="nc" id="L1066">        int i = s.length() - 1;</span>
<span class="nc bnc" id="L1067" title="All 4 branches missed.">        while(i &gt;= 0 &amp;&amp; Character.isWhitespace(s.charAt(i))) {</span>
<span class="nc" id="L1068">            i--;</span>
        }
<span class="nc" id="L1070">        return s.substring(0, i + 1);</span>
    }

    private static AttributedCharacterIterator getTrimmedTrailingSpacesIterator
            (AttributedCharacterIterator iterator) {
<span class="nc" id="L1075">        int curIdx = iterator.getIndex();</span>

<span class="nc" id="L1077">        char c = iterator.last();</span>
<span class="nc bnc" id="L1078" title="All 4 branches missed.">        while(c != CharacterIterator.DONE &amp;&amp; Character.isWhitespace(c)) {</span>
<span class="nc" id="L1079">            c = iterator.previous();</span>
        }

<span class="nc bnc" id="L1082" title="All 2 branches missed.">        if (c != CharacterIterator.DONE) {</span>
<span class="nc" id="L1083">            int endIdx = iterator.getIndex();</span>

<span class="nc bnc" id="L1085" title="All 2 branches missed.">            if (endIdx == iterator.getEndIndex() - 1) {</span>
<span class="nc" id="L1086">                iterator.setIndex(curIdx);</span>
<span class="nc" id="L1087">                return iterator;</span>
            } else {
<span class="nc" id="L1089">                AttributedString trimmedText = new AttributedString(iterator,</span>
<span class="nc" id="L1090">                        iterator.getBeginIndex(), endIdx + 1);</span>
<span class="nc" id="L1091">                return trimmedText.getIterator();</span>
            }
        } else {
<span class="nc" id="L1094">            return null;</span>
        }
    }

    /**
     * Determines whether the SelectedTextColor should be used for painting text
     * foreground for the specified highlight.
     *
     * Returns true only if the highlight painter for the specified highlight
     * is the swing painter (whether inner class of javax.swing.text.DefaultHighlighter
     * or com.sun.java.swing.plaf.windows.WindowsTextUI) and its background color
     * is null or equals to the selection color of the text component.
     *
     * This is a hack for fixing both bugs 4761990 and 5003294
     */
    public static boolean useSelectedTextColor(Highlighter.Highlight h, JTextComponent c) {
<span class="nc" id="L1110">        Highlighter.HighlightPainter painter = h.getPainter();</span>
<span class="nc" id="L1111">        String painterClass = painter.getClass().getName();</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        if (painterClass.indexOf(&quot;javax.swing.text.DefaultHighlighter&quot;) != 0 &amp;&amp;</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">                painterClass.indexOf(&quot;com.sun.java.swing.plaf.windows.WindowsTextUI&quot;) != 0) {</span>
<span class="nc" id="L1114">            return false;</span>
        }
        try {
<span class="nc" id="L1117">            DefaultHighlighter.DefaultHighlightPainter defPainter =</span>
                    (DefaultHighlighter.DefaultHighlightPainter) painter;
<span class="nc bnc" id="L1119" title="All 2 branches missed.">            if (defPainter.getColor() != null &amp;&amp;</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                    !defPainter.getColor().equals(c.getSelectionColor())) {</span>
<span class="nc" id="L1121">                return false;</span>
            }
<span class="nc" id="L1123">        } catch (ClassCastException e) {</span>
<span class="nc" id="L1124">            return false;</span>
<span class="nc" id="L1125">        }</span>
<span class="nc" id="L1126">        return true;</span>
    }

    /**
     * LSBCacheEntry is used to cache the left side bearing (lsb) for
     * a particular &lt;code&gt;Font&lt;/code&gt; and &lt;code&gt;FontRenderContext&lt;/code&gt;.
     * This only caches characters that fall in the range
     * &lt;code&gt;MIN_CHAR_INDEX&lt;/code&gt; to &lt;code&gt;MAX_CHAR_INDEX&lt;/code&gt;.
     */
<span class="nc bnc" id="L1135" title="All 2 branches missed.">    private static class LSBCacheEntry {</span>
        // Used to indicate a particular entry in lsb has not been set.
        private static final byte UNSET = Byte.MAX_VALUE;
        // Used in creating a GlyphVector to get the lsb
<span class="nc" id="L1139">        private static final char[] oneChar = new char[1];</span>

        private byte[] lsbCache;
        private Font font;
        private FontRenderContext frc;


<span class="nc" id="L1146">        public LSBCacheEntry(FontRenderContext frc, Font font) {</span>
<span class="nc" id="L1147">            lsbCache = new byte[MAX_CHAR_INDEX - MIN_CHAR_INDEX];</span>
<span class="nc" id="L1148">            reset(frc, font);</span>

<span class="nc" id="L1150">        }</span>

        public void reset(FontRenderContext frc, Font font) {
<span class="nc" id="L1153">            this.font = font;</span>
<span class="nc" id="L1154">            this.frc = frc;</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">            for (int counter = lsbCache.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L1156">                lsbCache[counter] = UNSET;</span>
            }
<span class="nc" id="L1158">        }</span>

        public int getLeftSideBearing(char aChar) {
<span class="nc" id="L1161">            int index = aChar - MIN_CHAR_INDEX;</span>
<span class="nc bnc" id="L1162" title="All 6 branches missed.">            assert (index &gt;= 0 &amp;&amp; index &lt; (MAX_CHAR_INDEX - MIN_CHAR_INDEX));</span>
<span class="nc" id="L1163">            byte lsb = lsbCache[index];</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">            if (lsb == UNSET) {</span>
<span class="nc" id="L1165">                oneChar[0] = aChar;</span>
<span class="nc" id="L1166">                GlyphVector gv = font.createGlyphVector(frc, oneChar);</span>
<span class="nc" id="L1167">                lsb = (byte) gv.getGlyphPixelBounds(0, frc, 0f, 0f).x;</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">                if (lsb &lt; 0) {</span>
                    /* HRGB/HBGR LCD glyph images will always have a pixel
                     * on the left used in colour fringe reduction.
                     * Text rendering positions this correctly but here
                     * we are using the glyph image to adjust that position
                     * so must account for it.
                     */
<span class="nc" id="L1175">                    Object aaHint = frc.getAntiAliasingHint();</span>
<span class="nc bnc" id="L1176" title="All 4 branches missed.">                    if (aaHint == VALUE_TEXT_ANTIALIAS_LCD_HRGB ||</span>
                            aaHint == VALUE_TEXT_ANTIALIAS_LCD_HBGR) {
<span class="nc" id="L1178">                        lsb++;</span>
                    }
                }
<span class="nc" id="L1181">                lsbCache[index] = lsb;</span>
            }
<span class="nc" id="L1183">            return lsb;</span>


        }

        public boolean equals(Object entry) {
<span class="nc bnc" id="L1189" title="All 2 branches missed.">            if (entry == this) {</span>
<span class="nc" id="L1190">                return true;</span>
            }
<span class="nc bnc" id="L1192" title="All 2 branches missed.">            if (!(entry instanceof LSBCacheEntry)) {</span>
<span class="nc" id="L1193">                return false;</span>
            }
<span class="nc" id="L1195">            LSBCacheEntry oEntry = (LSBCacheEntry) entry;</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">            return (font.equals(oEntry.font) &amp;&amp;</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">                    frc.equals(oEntry.frc));</span>
        }

        public int hashCode() {
<span class="nc" id="L1201">            int result = 17;</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">            if (font != null) {</span>
<span class="nc" id="L1203">                result = 37 * result + font.hashCode();</span>
            }
<span class="nc bnc" id="L1205" title="All 2 branches missed.">            if (frc != null) {</span>
<span class="nc" id="L1206">                result = 37 * result + frc.hashCode();</span>
            }
<span class="nc" id="L1208">            return result;</span>
        }
    }

    /*
     * here goes the fix for 4856343 [Problem with applet interaction
     * with system selection clipboard]
     *
     * NOTE. In case isTrustedContext() no checking
     * are to be performed
     */

    /**
    * checks the security permissions for accessing system clipboard
    *
    * for untrusted context (see isTrustedContext) checks the
    * permissions for the current event being handled
    *
    */
   public static boolean canAccessSystemClipboard() {
<span class="nc" id="L1228">       boolean canAccess = false;</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">       if (!GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L1230">           SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">           if (sm == null) {</span>
<span class="nc" id="L1232">               canAccess = true;</span>
           } else {
               try {
<span class="nc" id="L1235">                   sm.checkPermission(SecurityConstants.AWT.ACCESS_CLIPBOARD_PERMISSION);</span>
<span class="nc" id="L1236">                   canAccess = true;</span>
<span class="nc" id="L1237">               } catch (SecurityException e) {</span>
<span class="nc" id="L1238">               }</span>
<span class="nc bnc" id="L1239" title="All 4 branches missed.">               if (canAccess &amp;&amp; ! isTrustedContext()) {</span>
<span class="nc" id="L1240">                   canAccess = canCurrentEventAccessSystemClipboard(true);</span>
               }
           }
       }
<span class="nc" id="L1244">       return canAccess;</span>
   }
    /**
    * Returns true if EventQueue.getCurrentEvent() has the permissions to
     * access the system clipboard
     */
    public static boolean canCurrentEventAccessSystemClipboard() {
<span class="nc bnc" id="L1251" title="All 2 branches missed.">        return  isTrustedContext()</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">            || canCurrentEventAccessSystemClipboard(false);</span>
    }

    /**
     * Returns true if the given event has permissions to access the
     * system clipboard
     *
     * @param e AWTEvent to check
     */
    public static boolean canEventAccessSystemClipboard(AWTEvent e) {
<span class="nc bnc" id="L1262" title="All 2 branches missed.">        return isTrustedContext()</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">            || canEventAccessSystemClipboard(e, false);</span>
    }

    /**
     * returns canAccessSystemClipboard field from InputEvent
     *
     * @param ie InputEvent to get the field from
     */
    private static synchronized boolean inputEvent_canAccessSystemClipboard(InputEvent ie) {
<span class="nc bnc" id="L1272" title="All 2 branches missed.">        if (inputEvent_CanAccessSystemClipboard_Field == null) {</span>
<span class="nc" id="L1273">            inputEvent_CanAccessSystemClipboard_Field =</span>
<span class="nc" id="L1274">                AccessController.doPrivileged(</span>
<span class="nc" id="L1275">                    new java.security.PrivilegedAction&lt;Field&gt;() {</span>
                        public Field run() {
                            try {
<span class="nc" id="L1278">                                Field field = InputEvent.class.</span>
<span class="nc" id="L1279">                                    getDeclaredField(&quot;canAccessSystemClipboard&quot;);</span>
<span class="nc" id="L1280">                                field.setAccessible(true);</span>
<span class="nc" id="L1281">                                return field;</span>
<span class="nc" id="L1282">                            } catch (SecurityException e) {</span>
<span class="nc" id="L1283">                            } catch (NoSuchFieldException e) {</span>
<span class="nc" id="L1284">                            }</span>
<span class="nc" id="L1285">                            return null;</span>
                        }
                    });
        }
<span class="nc bnc" id="L1289" title="All 2 branches missed.">        if (inputEvent_CanAccessSystemClipboard_Field == null) {</span>
<span class="nc" id="L1290">            return false;</span>
        }
<span class="nc" id="L1292">        boolean ret = false;</span>
        try {
<span class="nc" id="L1294">            ret = inputEvent_CanAccessSystemClipboard_Field.</span>
<span class="nc" id="L1295">                getBoolean(ie);</span>
<span class="nc" id="L1296">        } catch(IllegalAccessException e) {</span>
<span class="nc" id="L1297">        }</span>
<span class="nc" id="L1298">        return ret;</span>
    }

    /**
     * Returns true if the given event is corrent gesture for
     * accessing clipboard
     *
     * @param ie InputEvent to check
     */

    private static boolean isAccessClipboardGesture(InputEvent ie) {
<span class="nc" id="L1309">        boolean allowedGesture = false;</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">        if (ie instanceof KeyEvent) { //we can validate only keyboard gestures</span>
<span class="nc" id="L1311">            KeyEvent ke = (KeyEvent)ie;</span>
<span class="nc" id="L1312">            int keyCode = ke.getKeyCode();</span>
<span class="nc" id="L1313">            int keyModifiers = ke.getModifiers();</span>
<span class="nc bnc" id="L1314" title="All 5 branches missed.">            switch(keyCode) {</span>
            case KeyEvent.VK_C:
            case KeyEvent.VK_V:
            case KeyEvent.VK_X:
<span class="nc bnc" id="L1318" title="All 2 branches missed.">                allowedGesture = (keyModifiers == InputEvent.CTRL_MASK);</span>
<span class="nc" id="L1319">                break;</span>
            case KeyEvent.VK_INSERT:
<span class="nc bnc" id="L1321" title="All 4 branches missed.">                allowedGesture = (keyModifiers == InputEvent.CTRL_MASK ||</span>
                                  keyModifiers == InputEvent.SHIFT_MASK);
<span class="nc" id="L1323">                break;</span>
            case KeyEvent.VK_COPY:
            case KeyEvent.VK_PASTE:
            case KeyEvent.VK_CUT:
<span class="nc" id="L1327">                allowedGesture = true;</span>
<span class="nc" id="L1328">                break;</span>
            case KeyEvent.VK_DELETE:
<span class="nc bnc" id="L1330" title="All 2 branches missed.">                allowedGesture = ( keyModifiers == InputEvent.SHIFT_MASK);</span>
                break;
            }
        }
<span class="nc" id="L1334">        return allowedGesture;</span>
    }

    /**
     * Returns true if e has the permissions to
     * access the system clipboard and if it is allowed gesture (if
     * checkGesture is true)
     *
     * @param e AWTEvent to check
     * @param checkGesture boolean
     */
    private static boolean canEventAccessSystemClipboard(AWTEvent e,
                                                        boolean checkGesture) {
<span class="nc bnc" id="L1347" title="All 2 branches missed.">        if (EventQueue.isDispatchThread()) {</span>
            /*
             * Checking event permissions makes sense only for event
             * dispathing thread
             */
<span class="nc bnc" id="L1352" title="All 4 branches missed.">            if (e instanceof InputEvent</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">                &amp;&amp; (! checkGesture || isAccessClipboardGesture((InputEvent)e))) {</span>
<span class="nc" id="L1354">                return inputEvent_canAccessSystemClipboard((InputEvent)e);</span>
            } else {
<span class="nc" id="L1356">                return false;</span>
            }
        } else {
<span class="nc" id="L1359">            return true;</span>
        }
    }

    /**
     * Utility method that throws SecurityException if SecurityManager is set
     * and modifiers are not public
     *
     * @param modifiers a set of modifiers
     */
    public static void checkAccess(int modifiers) {
<span class="nc bnc" id="L1370" title="All 2 branches missed.">        if (System.getSecurityManager() != null</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">                &amp;&amp; !Modifier.isPublic(modifiers)) {</span>
<span class="nc" id="L1372">            throw new SecurityException(&quot;Resource is not accessible&quot;);</span>
        }
<span class="nc" id="L1374">    }</span>

    /**
     * Returns true if EventQueue.getCurrentEvent() has the permissions to
     * access the system clipboard and if it is allowed gesture (if
     * checkGesture true)
     *
     * @param checkGesture boolean
     */
    private static boolean canCurrentEventAccessSystemClipboard(boolean
                                                               checkGesture) {
<span class="nc" id="L1385">        AWTEvent event = EventQueue.getCurrentEvent();</span>
<span class="nc" id="L1386">        return canEventAccessSystemClipboard(event, checkGesture);</span>
    }

    /**
     * see RFE 5012841 [Per AppContect security permissions] for the
     * details
     *
     */
    private static boolean isTrustedContext() {
<span class="nc bnc" id="L1395" title="All 2 branches missed.">        return (System.getSecurityManager() == null)</span>
<span class="nc" id="L1396">            || (AppContext.getAppContext().</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">                get(UntrustedClipboardAccess) == null);</span>
    }

    public static String displayPropertiesToCSS(Font font, Color fg) {
<span class="nc" id="L1401">        StringBuffer rule = new StringBuffer(&quot;body {&quot;);</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">        if (font != null) {</span>
<span class="nc" id="L1403">            rule.append(&quot; font-family: &quot;);</span>
<span class="nc" id="L1404">            rule.append(font.getFamily());</span>
<span class="nc" id="L1405">            rule.append(&quot; ; &quot;);</span>
<span class="nc" id="L1406">            rule.append(&quot; font-size: &quot;);</span>
<span class="nc" id="L1407">            rule.append(font.getSize());</span>
<span class="nc" id="L1408">            rule.append(&quot;pt ;&quot;);</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">            if (font.isBold()) {</span>
<span class="nc" id="L1410">                rule.append(&quot; font-weight: 700 ; &quot;);</span>
            }
<span class="nc bnc" id="L1412" title="All 2 branches missed.">            if (font.isItalic()) {</span>
<span class="nc" id="L1413">                rule.append(&quot; font-style: italic ; &quot;);</span>
            }
        }
<span class="nc bnc" id="L1416" title="All 2 branches missed.">        if (fg != null) {</span>
<span class="nc" id="L1417">            rule.append(&quot; color: #&quot;);</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">            if (fg.getRed() &lt; 16) {</span>
<span class="nc" id="L1419">                rule.append('0');</span>
            }
<span class="nc" id="L1421">            rule.append(Integer.toHexString(fg.getRed()));</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">            if (fg.getGreen() &lt; 16) {</span>
<span class="nc" id="L1423">                rule.append('0');</span>
            }
<span class="nc" id="L1425">            rule.append(Integer.toHexString(fg.getGreen()));</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">            if (fg.getBlue() &lt; 16) {</span>
<span class="nc" id="L1427">                rule.append('0');</span>
            }
<span class="nc" id="L1429">            rule.append(Integer.toHexString(fg.getBlue()));</span>
<span class="nc" id="L1430">            rule.append(&quot; ; &quot;);</span>
        }
<span class="nc" id="L1432">        rule.append(&quot; }&quot;);</span>
<span class="nc" id="L1433">        return rule.toString();</span>
    }

    /**
     * Utility method that creates a &lt;code&gt;UIDefaults.LazyValue&lt;/code&gt; that
     * creates an &lt;code&gt;ImageIcon&lt;/code&gt; &lt;code&gt;UIResource&lt;/code&gt; for the
     * specified image file name. The image is loaded using
     * &lt;code&gt;getResourceAsStream&lt;/code&gt;, starting with a call to that method
     * on the base class parameter. If it cannot be found, searching will
     * continue through the base class' inheritance hierarchy, up to and
     * including &lt;code&gt;rootClass&lt;/code&gt;.
     *
     * @param baseClass the first class to use in searching for the resource
     * @param rootClass an ancestor of &lt;code&gt;baseClass&lt;/code&gt; to finish the
     *                  search at
     * @param imageFile the name of the file to be found
     * @return a lazy value that creates the &lt;code&gt;ImageIcon&lt;/code&gt;
     *         &lt;code&gt;UIResource&lt;/code&gt; for the image,
     *         or null if it cannot be found
     */
    public static Object makeIcon(final Class&lt;?&gt; baseClass,
                                  final Class&lt;?&gt; rootClass,
                                  final String imageFile) {

<span class="fc" id="L1457">        return new UIDefaults.LazyValue() {</span>
            public Object createValue(UIDefaults table) {
                /* Copy resource into a byte array.  This is
                 * necessary because several browsers consider
                 * Class.getResource a security risk because it
                 * can be used to load additional classes.
                 * Class.getResourceAsStream just returns raw
                 * bytes, which we can convert to an image.
                 */
<span class="nc" id="L1466">                byte[] buffer =</span>
<span class="nc" id="L1467">                    java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L1468">                        new java.security.PrivilegedAction&lt;byte[]&gt;() {</span>
                    public byte[] run() {
                        try {
<span class="nc" id="L1471">                            InputStream resource = null;</span>
<span class="nc" id="L1472">                            Class&lt;?&gt; srchClass = baseClass;</span>

<span class="nc bnc" id="L1474" title="All 2 branches missed.">                            while (srchClass != null) {</span>
<span class="nc" id="L1475">                                resource = srchClass.getResourceAsStream(imageFile);</span>

<span class="nc bnc" id="L1477" title="All 4 branches missed.">                                if (resource != null || srchClass == rootClass) {</span>
<span class="nc" id="L1478">                                    break;</span>
                                }

<span class="nc" id="L1481">                                srchClass = srchClass.getSuperclass();</span>
                            }

<span class="nc bnc" id="L1484" title="All 2 branches missed.">                            if (resource == null) {</span>
<span class="nc" id="L1485">                                return null;</span>
                            }

<span class="nc" id="L1488">                            BufferedInputStream in =</span>
                                new BufferedInputStream(resource);
<span class="nc" id="L1490">                            ByteArrayOutputStream out =</span>
                                new ByteArrayOutputStream(1024);
<span class="nc" id="L1492">                            byte[] buffer = new byte[1024];</span>
                            int n;
<span class="nc bnc" id="L1494" title="All 2 branches missed.">                            while ((n = in.read(buffer)) &gt; 0) {</span>
<span class="nc" id="L1495">                                out.write(buffer, 0, n);</span>
                            }
<span class="nc" id="L1497">                            in.close();</span>
<span class="nc" id="L1498">                            out.flush();</span>
<span class="nc" id="L1499">                            return out.toByteArray();</span>
<span class="nc" id="L1500">                        } catch (IOException ioe) {</span>
<span class="nc" id="L1501">                            System.err.println(ioe.toString());</span>
                        }
<span class="nc" id="L1503">                        return null;</span>
                    }
                });

<span class="nc bnc" id="L1507" title="All 2 branches missed.">                if (buffer == null) {</span>
<span class="nc" id="L1508">                    return null;</span>
                }
<span class="nc bnc" id="L1510" title="All 2 branches missed.">                if (buffer.length == 0) {</span>
<span class="nc" id="L1511">                    System.err.println(&quot;warning: &quot; + imageFile +</span>
                                       &quot; is zero-length&quot;);
<span class="nc" id="L1513">                    return null;</span>
                }

<span class="nc" id="L1516">                return new ImageIconUIResource(buffer);</span>
            }
        };
    }

    /* Used to help decide if AA text rendering should be used, so
     * this local display test should be additionally qualified
     * against whether we have XRender support on both ends of the wire,
     * as with that support remote performance may be good enough to turn
     * on by default. An additional complication there is XRender does not
     * appear capable of performing gamma correction needed for LCD text.
     */
    public static boolean isLocalDisplay() {
        boolean isLocal;
<span class="fc" id="L1530">        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();</span>
<span class="pc bpc" id="L1531" title="1 of 2 branches missed.">        if (ge instanceof SunGraphicsEnvironment) {</span>
<span class="nc" id="L1532">            isLocal = ((SunGraphicsEnvironment) ge).isDisplayLocal();</span>
        } else {
<span class="fc" id="L1534">            isLocal = true;</span>
        }
<span class="fc" id="L1536">        return isLocal;</span>
    }

    /**
     * Returns an integer from the defaults table. If &lt;code&gt;key&lt;/code&gt; does
     * not map to a valid &lt;code&gt;Integer&lt;/code&gt;, or can not be convered from
     * a &lt;code&gt;String&lt;/code&gt; to an integer, the value 0 is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the int.
     * @return the int
     */
    public static int getUIDefaultsInt(Object key) {
<span class="nc" id="L1548">        return getUIDefaultsInt(key, 0);</span>
    }

    /**
     * Returns an integer from the defaults table that is appropriate
     * for the given locale. If &lt;code&gt;key&lt;/code&gt; does not map to a valid
     * &lt;code&gt;Integer&lt;/code&gt;, or can not be convered from a &lt;code&gt;String&lt;/code&gt;
     * to an integer, the value 0 is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the int. Returned value
     *             is 0 if &lt;code&gt;key&lt;/code&gt; is not available,
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the int is desired
     * @return the int
     */
    public static int getUIDefaultsInt(Object key, Locale l) {
<span class="nc" id="L1563">        return getUIDefaultsInt(key, l, 0);</span>
    }

    /**
     * Returns an integer from the defaults table. If &lt;code&gt;key&lt;/code&gt; does
     * not map to a valid &lt;code&gt;Integer&lt;/code&gt;, or can not be convered from
     * a &lt;code&gt;String&lt;/code&gt; to an integer, &lt;code&gt;default&lt;/code&gt; is
     * returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the int. Returned value
     *             is 0 if &lt;code&gt;key&lt;/code&gt; is not available,
     * @param defaultValue Returned value if &lt;code&gt;key&lt;/code&gt; is not available,
     *                     or is not an Integer
     * @return the int
     */
    public static int getUIDefaultsInt(Object key, int defaultValue) {
<span class="nc" id="L1579">        return getUIDefaultsInt(key, null, defaultValue);</span>
    }

    /**
     * Returns an integer from the defaults table that is appropriate
     * for the given locale. If &lt;code&gt;key&lt;/code&gt; does not map to a valid
     * &lt;code&gt;Integer&lt;/code&gt;, or can not be convered from a &lt;code&gt;String&lt;/code&gt;
     * to an integer, &lt;code&gt;default&lt;/code&gt; is returned.
     *
     * @param key  an &lt;code&gt;Object&lt;/code&gt; specifying the int. Returned value
     *             is 0 if &lt;code&gt;key&lt;/code&gt; is not available,
     * @param l the &lt;code&gt;Locale&lt;/code&gt; for which the int is desired
     * @param defaultValue Returned value if &lt;code&gt;key&lt;/code&gt; is not available,
     *                     or is not an Integer
     * @return the int
     */
    public static int getUIDefaultsInt(Object key, Locale l, int defaultValue) {
<span class="nc" id="L1596">        Object value = UIManager.get(key, l);</span>

<span class="nc bnc" id="L1598" title="All 2 branches missed.">        if (value instanceof Integer) {</span>
<span class="nc" id="L1599">            return ((Integer)value).intValue();</span>
        }
<span class="nc bnc" id="L1601" title="All 2 branches missed.">        if (value instanceof String) {</span>
            try {
<span class="nc" id="L1603">                return Integer.parseInt((String)value);</span>
<span class="nc" id="L1604">            } catch (NumberFormatException nfe) {}</span>
        }
<span class="nc" id="L1606">        return defaultValue;</span>
    }

    // At this point we need this method here. But we assume that there
    // will be a common method for this purpose in the future releases.
    public static Component compositeRequestFocus(Component component) {
<span class="nc bnc" id="L1612" title="All 2 branches missed.">        if (component instanceof Container) {</span>
<span class="nc" id="L1613">            Container container = (Container)component;</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">            if (container.isFocusCycleRoot()) {</span>
<span class="nc" id="L1615">                FocusTraversalPolicy policy = container.getFocusTraversalPolicy();</span>
<span class="nc" id="L1616">                Component comp = policy.getDefaultComponent(container);</span>
<span class="nc bnc" id="L1617" title="All 2 branches missed.">                if (comp!=null) {</span>
<span class="nc" id="L1618">                    comp.requestFocus();</span>
<span class="nc" id="L1619">                    return comp;</span>
                }
            }
<span class="nc" id="L1622">            Container rootAncestor = container.getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">            if (rootAncestor!=null) {</span>
<span class="nc" id="L1624">                FocusTraversalPolicy policy = rootAncestor.getFocusTraversalPolicy();</span>
<span class="nc" id="L1625">                Component comp = policy.getComponentAfter(rootAncestor, container);</span>

<span class="nc bnc" id="L1627" title="All 4 branches missed.">                if (comp!=null &amp;&amp; SwingUtilities.isDescendingFrom(comp, container)) {</span>
<span class="nc" id="L1628">                    comp.requestFocus();</span>
<span class="nc" id="L1629">                    return comp;</span>
                }
            }
        }
<span class="nc bnc" id="L1633" title="All 2 branches missed.">        if (component.isFocusable()) {</span>
<span class="nc" id="L1634">            component.requestFocus();</span>
<span class="nc" id="L1635">            return component;</span>
        }
<span class="nc" id="L1637">        return null;</span>
    }

    /**
     * Change focus to the visible component in {@code JTabbedPane}.
     * This is not a general-purpose method and is here only to permit
     * sharing code.
     */
    public static boolean tabbedPaneChangeFocusTo(Component comp) {
<span class="nc bnc" id="L1646" title="All 2 branches missed.">        if (comp != null) {</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">            if (comp.isFocusTraversable()) {</span>
<span class="nc" id="L1648">                SwingUtilities2.compositeRequestFocus(comp);</span>
<span class="nc" id="L1649">                return true;</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">            } else if (comp instanceof JComponent</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">                       &amp;&amp; ((JComponent)comp).requestDefaultFocus()) {</span>

<span class="nc" id="L1653">                 return true;</span>
            }
        }

<span class="nc" id="L1657">        return false;</span>
    }

    /**
     * Submits a value-returning task for execution on the EDT and
     * returns a Future representing the pending results of the task.
     *
     * @param task the task to submit
     * @return a Future representing pending completion of the task
     * @throws NullPointerException if the task is null
     */
    public static &lt;V&gt; Future&lt;V&gt; submit(Callable&lt;V&gt; task) {
<span class="nc bnc" id="L1669" title="All 2 branches missed.">        if (task == null) {</span>
<span class="nc" id="L1670">            throw new NullPointerException();</span>
        }
<span class="nc" id="L1672">        FutureTask&lt;V&gt; future = new FutureTask&lt;V&gt;(task);</span>
<span class="nc" id="L1673">        execute(future);</span>
<span class="nc" id="L1674">        return future;</span>
    }

    /**
     * Submits a Runnable task for execution on the EDT and returns a
     * Future representing that task.
     *
     * @param task the task to submit
     * @param result the result to return upon successful completion
     * @return a Future representing pending completion of the task,
     *         and whose &lt;tt&gt;get()&lt;/tt&gt; method will return the given
     *         result value upon completion
     * @throws NullPointerException if the task is null
     */
    public static &lt;V&gt; Future&lt;V&gt; submit(Runnable task, V result) {
<span class="nc bnc" id="L1689" title="All 2 branches missed.">        if (task == null) {</span>
<span class="nc" id="L1690">            throw new NullPointerException();</span>
        }
<span class="nc" id="L1692">        FutureTask&lt;V&gt; future = new FutureTask&lt;V&gt;(task, result);</span>
<span class="nc" id="L1693">        execute(future);</span>
<span class="nc" id="L1694">        return future;</span>
    }

    /**
     * Sends a Runnable to the EDT for the execution.
     */
    private static void execute(Runnable command) {
<span class="nc" id="L1701">        SwingUtilities.invokeLater(command);</span>
<span class="nc" id="L1702">    }</span>

    /**
     * Sets the {@code SKIP_CLICK_COUNT} client property on the component
     * if it is an instance of {@code JTextComponent} with a
     * {@code DefaultCaret}. This property, used for text components acting
     * as editors in a table or tree, tells {@code DefaultCaret} how many
     * clicks to skip before starting selection.
     */
    public static void setSkipClickCount(Component comp, int count) {
<span class="nc bnc" id="L1712" title="All 2 branches missed.">        if (comp instanceof JTextComponent</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">                &amp;&amp; ((JTextComponent) comp).getCaret() instanceof DefaultCaret) {</span>

<span class="nc" id="L1715">            ((JTextComponent) comp).putClientProperty(SKIP_CLICK_COUNT, count);</span>
        }
<span class="nc" id="L1717">    }</span>

    /**
     * Return the MouseEvent's click count, possibly reduced by the value of
     * the component's {@code SKIP_CLICK_COUNT} client property. Clears
     * the {@code SKIP_CLICK_COUNT} property if the mouse event's click count
     * is 1. In order for clearing of the property to work correctly, there
     * must be a mousePressed implementation on the caller with this
     * call as the first line.
     */
    public static int getAdjustedClickCount(JTextComponent comp, MouseEvent e) {
<span class="nc" id="L1728">        int cc = e.getClickCount();</span>

<span class="nc bnc" id="L1730" title="All 2 branches missed.">        if (cc == 1) {</span>
<span class="nc" id="L1731">            comp.putClientProperty(SKIP_CLICK_COUNT, null);</span>
        } else {
<span class="nc" id="L1733">            Integer sub = (Integer) comp.getClientProperty(SKIP_CLICK_COUNT);</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">            if (sub != null) {</span>
<span class="nc" id="L1735">                return cc - sub;</span>
            }
        }

<span class="nc" id="L1739">        return cc;</span>
    }

    /**
     * Used by the {@code liesIn} method to return which section
     * the point lies in.
     *
     * @see #liesIn
     */
<span class="nc" id="L1748">    public enum Section {</span>

        /** The leading section */
<span class="nc" id="L1751">        LEADING,</span>

        /** The middle section */
<span class="nc" id="L1754">        MIDDLE,</span>

        /** The trailing section */
<span class="nc" id="L1757">        TRAILING</span>
    }

    /**
     * This method divides a rectangle into two or three sections along
     * the specified axis and determines which section the given point
     * lies in on that axis; used by drag and drop when calculating drop
     * locations.
     * &lt;p&gt;
     * For two sections, the rectangle is divided equally and the method
     * returns whether the point lies in {@code Section.LEADING} or
     * {@code Section.TRAILING}. For horizontal divisions, the calculation
     * respects component orientation.
     * &lt;p&gt;
     * For three sections, if the rectangle is greater than or equal to
     * 30 pixels in length along the axis, the calculation gives 10 pixels
     * to each of the leading and trailing sections and the remainder to the
     * middle. For smaller sizes, the rectangle is divided equally into three
     * sections.
     * &lt;p&gt;
     * Note: This method assumes that the point is within the bounds of
     * the given rectangle on the specified axis. However, in cases where
     * it isn't, the results still have meaning: {@code Section.MIDDLE}
     * remains the same, {@code Section.LEADING} indicates that the point
     * is in or somewhere before the leading section, and
     * {@code Section.TRAILING} indicates that the point is in or somewhere
     * after the trailing section.
     *
     * @param rect the rectangle
     * @param p the point the check
     * @param horizontal {@code true} to use the horizontal axis,
     *        or {@code false} for the vertical axis
     * @param ltr {@code true} for left to right orientation,
     *        or {@code false} for right to left orientation;
     *        only used for horizontal calculations
     * @param three {@code true} for three sections,
     *        or {@code false} for two
     *
     * @return the {@code Section} where the point lies
     *
     * @throws NullPointerException if {@code rect} or {@code p} are
     *         {@code null}
     */
    private static Section liesIn(Rectangle rect, Point p, boolean horizontal,
                                  boolean ltr, boolean three) {

        /* beginning of the rectangle on the axis */
        int p0;

        /* point on the axis we're interested in */
        int pComp;

        /* length of the rectangle on the axis */
        int length;

        /* value of ltr if horizontal, else true */
        boolean forward;

<span class="nc bnc" id="L1815" title="All 2 branches missed.">        if (horizontal) {</span>
<span class="nc" id="L1816">            p0 = rect.x;</span>
<span class="nc" id="L1817">            pComp = p.x;</span>
<span class="nc" id="L1818">            length = rect.width;</span>
<span class="nc" id="L1819">            forward = ltr;</span>
        } else {
<span class="nc" id="L1821">            p0 = rect.y;</span>
<span class="nc" id="L1822">            pComp = p.y;</span>
<span class="nc" id="L1823">            length = rect.height;</span>
<span class="nc" id="L1824">            forward = true;</span>
        }

<span class="nc bnc" id="L1827" title="All 2 branches missed.">        if (three) {</span>
<span class="nc bnc" id="L1828" title="All 2 branches missed.">            int boundary = (length &gt;= 30) ? 10 : length / 3;</span>

<span class="nc bnc" id="L1830" title="All 2 branches missed.">            if (pComp &lt; p0 + boundary) {</span>
<span class="nc bnc" id="L1831" title="All 2 branches missed.">               return forward ? Section.LEADING : Section.TRAILING;</span>
<span class="nc bnc" id="L1832" title="All 2 branches missed.">           } else if (pComp &gt;= p0 + length - boundary) {</span>
<span class="nc bnc" id="L1833" title="All 2 branches missed.">               return forward ? Section.TRAILING : Section.LEADING;</span>
           }

<span class="nc" id="L1836">           return Section.MIDDLE;</span>
        } else {
<span class="nc" id="L1838">            int middle = p0 + length / 2;</span>
<span class="nc bnc" id="L1839" title="All 2 branches missed.">            if (forward) {</span>
<span class="nc bnc" id="L1840" title="All 2 branches missed.">                return pComp &gt;= middle ? Section.TRAILING : Section.LEADING;</span>
            } else {
<span class="nc bnc" id="L1842" title="All 2 branches missed.">                return pComp &lt; middle ? Section.TRAILING : Section.LEADING;</span>
            }
        }
    }

    /**
     * This method divides a rectangle into two or three sections along
     * the horizontal axis and determines which section the given point
     * lies in; used by drag and drop when calculating drop locations.
     * &lt;p&gt;
     * See the documentation for {@link #liesIn} for more information
     * on how the section is calculated.
     *
     * @param rect the rectangle
     * @param p the point the check
     * @param ltr {@code true} for left to right orientation,
     *        or {@code false} for right to left orientation
     * @param three {@code true} for three sections,
     *        or {@code false} for two
     *
     * @return the {@code Section} where the point lies
     *
     * @throws NullPointerException if {@code rect} or {@code p} are
     *         {@code null}
     */
    public static Section liesInHorizontal(Rectangle rect, Point p,
                                           boolean ltr, boolean three) {
<span class="nc" id="L1869">        return liesIn(rect, p, true, ltr, three);</span>
    }

    /**
     * This method divides a rectangle into two or three sections along
     * the vertical axis and determines which section the given point
     * lies in; used by drag and drop when calculating drop locations.
     * &lt;p&gt;
     * See the documentation for {@link #liesIn} for more information
     * on how the section is calculated.
     *
     * @param rect the rectangle
     * @param p the point the check
     * @param three {@code true} for three sections,
     *        or {@code false} for two
     *
     * @return the {@code Section} where the point lies
     *
     * @throws NullPointerException if {@code rect} or {@code p} are
     *         {@code null}
     */
    public static Section liesInVertical(Rectangle rect, Point p,
                                         boolean three) {
<span class="nc" id="L1892">        return liesIn(rect, p, false, false, three);</span>
    }

    /**
     * Maps the index of the column in the view at
     * {@code viewColumnIndex} to the index of the column
     * in the table model.  Returns the index of the corresponding
     * column in the model.  If {@code viewColumnIndex}
     * is less than zero, returns {@code viewColumnIndex}.
     *
     * @param cm the table model
     * @param   viewColumnIndex     the index of the column in the view
     * @return  the index of the corresponding column in the model
     *
     * @see JTable#convertColumnIndexToModel(int)
     * @see javax.swing.plaf.basic.BasicTableHeaderUI
     */
    public static int convertColumnIndexToModel(TableColumnModel cm,
                                                int viewColumnIndex) {
<span class="nc bnc" id="L1911" title="All 2 branches missed.">        if (viewColumnIndex &lt; 0) {</span>
<span class="nc" id="L1912">            return viewColumnIndex;</span>
        }
<span class="nc" id="L1914">        return cm.getColumn(viewColumnIndex).getModelIndex();</span>
    }

    /**
     * Maps the index of the column in the {@code cm} at
     * {@code modelColumnIndex} to the index of the column
     * in the view.  Returns the index of the
     * corresponding column in the view; returns {@code -1} if this column
     * is not being displayed. If {@code modelColumnIndex} is less than zero,
     * returns {@code modelColumnIndex}.
     *
     * @param cm the table model
     * @param modelColumnIndex the index of the column in the model
     * @return the index of the corresponding column in the view
     *
     * @see JTable#convertColumnIndexToView(int)
     * @see javax.swing.plaf.basic.BasicTableHeaderUI
     */
    public static int convertColumnIndexToView(TableColumnModel cm,
                                        int modelColumnIndex) {
<span class="nc bnc" id="L1934" title="All 2 branches missed.">        if (modelColumnIndex &lt; 0) {</span>
<span class="nc" id="L1935">            return modelColumnIndex;</span>
        }
<span class="nc bnc" id="L1937" title="All 2 branches missed.">        for (int column = 0; column &lt; cm.getColumnCount(); column++) {</span>
<span class="nc bnc" id="L1938" title="All 2 branches missed.">            if (cm.getColumn(column).getModelIndex() == modelColumnIndex) {</span>
<span class="nc" id="L1939">                return column;</span>
            }
        }
<span class="nc" id="L1942">        return -1;</span>
    }

    public static int getSystemMnemonicKeyMask() {
<span class="fc" id="L1946">        Toolkit toolkit = Toolkit.getDefaultToolkit();</span>
<span class="pc bpc" id="L1947" title="1 of 2 branches missed.">        if (toolkit instanceof SunToolkit) {</span>
<span class="nc" id="L1948">            return ((SunToolkit) toolkit).getFocusAcceleratorKeyMask();</span>
        }
<span class="fc" id="L1950">        return InputEvent.ALT_MASK;</span>
    }

    /**
     * Returns the {@link TreePath} that identifies the changed nodes.
     *
     * @param event  changes in a tree model
     * @param model  corresponing tree model
     * @return  the path to the changed nodes
     */
    public static TreePath getTreePath(TreeModelEvent event, TreeModel model) {
<span class="nc" id="L1961">        TreePath path = event.getTreePath();</span>
<span class="nc bnc" id="L1962" title="All 4 branches missed.">        if ((path == null) &amp;&amp; (model != null)) {</span>
<span class="nc" id="L1963">            Object root = model.getRoot();</span>
<span class="nc bnc" id="L1964" title="All 2 branches missed.">            if (root != null) {</span>
<span class="nc" id="L1965">                path = new TreePath(root);</span>
            }
        }
<span class="nc" id="L1968">        return path;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>