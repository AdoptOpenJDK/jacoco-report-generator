<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CachedPainter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.swing</a> &gt; <span class="el_source">CachedPainter.java</span></div><h1>CachedPainter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.swing;

import java.awt.*;
import java.awt.image.*;
import java.util.*;

/**
 * A base class used for icons or images that are expensive to paint.
 * A subclass will do the following:
 * &lt;ol&gt;
 * &lt;li&gt;Invoke &lt;code&gt;paint&lt;/code&gt; when you want to paint the image,
 *     if you are implementing &lt;code&gt;Icon&lt;/code&gt; you'll invoke this from
 *     &lt;code&gt;paintIcon&lt;/code&gt;.
 *     The args argument is useful when additional state is needed.
 * &lt;li&gt;Override &lt;code&gt;paintToImage&lt;/code&gt; to render the image.  The code that
 *     lives here is equivalent to what previously would go in
 *     &lt;code&gt;paintIcon&lt;/code&gt;, for an &lt;code&gt;Icon&lt;/code&gt;.
 * &lt;/ol&gt;
 * The two ways to use this class are:
 * &lt;ol&gt;
 * &lt;li&gt;Invoke &lt;code&gt;paint&lt;/code&gt; to draw the cached reprensentation at
 *     the specified location.
 * &lt;li&gt;Invoke &lt;code&gt;getImage&lt;/code&gt; to get the cached reprensentation and
 *     draw the image yourself.  This is primarly useful when you are not
 *     using &lt;code&gt;VolatileImage&lt;/code&gt;.
 * &lt;/ol&gt;
 *
 *
 */
public abstract class CachedPainter {
    // CacheMap maps from class to ImageCache.
<span class="nc" id="L56">    private static final Map&lt;Object,ImageCache&gt; cacheMap =</span>
                   new HashMap&lt;Object,ImageCache&gt;();


    private static ImageCache getCache(Object key) {
<span class="nc" id="L61">        synchronized(CachedPainter.class) {</span>
<span class="nc" id="L62">            ImageCache cache = cacheMap.get(key);</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">            if (cache == null) {</span>
<span class="nc" id="L64">                cache = new ImageCache(1);</span>
<span class="nc" id="L65">                cacheMap.put(key, cache);</span>
            }
<span class="nc" id="L67">            return cache;</span>
<span class="nc" id="L68">        }</span>
    }

    /**
     * Creates an instance of &lt;code&gt;CachedPainter&lt;/code&gt; that will cache up
     * to &lt;code&gt;cacheCount&lt;/code&gt; images of this class.
     *
     * @param cacheCount Max number of images to cache
     */
<span class="nc" id="L77">    public CachedPainter(int cacheCount) {</span>
<span class="nc" id="L78">        getCache(getClass()).setMaxCount(cacheCount);</span>
<span class="nc" id="L79">    }</span>

    /**
     * Renders the cached image to the the passed in &lt;code&gt;Graphic&lt;/code&gt;.
     * If there is no cached image &lt;code&gt;paintToImage&lt;/code&gt; will be invoked.
     * &lt;code&gt;paintImage&lt;/code&gt; is invoked to paint the cached image.
     *
     * @param c Component rendering to, this may be null.
     * @param g Graphics to paint to
     * @param x X-coordinate to render to
     * @param y Y-coordinate to render to
     * @param w Width to render in
     * @param h Height to render in
     * @param arg Variable arguments that will be passed to paintToImage
     */
    public void paint(Component c, Graphics g, int x,
                         int y, int w, int h, Object... args) {
<span class="nc bnc" id="L96" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;= 0) {</span>
<span class="nc" id="L97">            return;</span>
        }
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L100">            synchronized(c.getTreeLock()) {</span>
<span class="nc" id="L101">                synchronized(CachedPainter.class) {</span>
                    // If c is non-null, synchronize on the tree lock.
                    // This is necessary because asking for the
                    // GraphicsConfiguration will grab a tree lock.
<span class="nc" id="L105">                    paint0(c, g, x, y, w, h, args);</span>
<span class="nc" id="L106">                }</span>
<span class="nc" id="L107">            }</span>
        }
        else {
<span class="nc" id="L110">            synchronized(CachedPainter.class) {</span>
<span class="nc" id="L111">                paint0(c, g, x, y, w, h, args);</span>
<span class="nc" id="L112">            }</span>
        }
<span class="nc" id="L114">    }</span>

    private void paint0(Component c, Graphics g, int x,
                         int y, int w, int h, Object... args) {
<span class="nc" id="L118">        Object key = getClass();</span>
<span class="nc" id="L119">        GraphicsConfiguration config = getGraphicsConfiguration(c);</span>
<span class="nc" id="L120">        ImageCache cache = getCache(key);</span>
<span class="nc" id="L121">        Image image = cache.getImage(key, config, w, h, args);</span>
<span class="nc" id="L122">        int attempts = 0;</span>
        do {
<span class="nc" id="L124">            boolean draw = false;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (image instanceof VolatileImage) {</span>
                // See if we need to recreate the image
<span class="nc bnc" id="L127" title="All 3 branches missed.">                switch (((VolatileImage)image).validate(config)) {</span>
                case VolatileImage.IMAGE_INCOMPATIBLE:
<span class="nc" id="L129">                    ((VolatileImage)image).flush();</span>
<span class="nc" id="L130">                    image = null;</span>
<span class="nc" id="L131">                    break;</span>
                case VolatileImage.IMAGE_RESTORED:
<span class="nc" id="L133">                    draw = true;</span>
                    break;
                }
            }
<span class="nc bnc" id="L137" title="All 2 branches missed.">            if (image == null) {</span>
                // Recreate the image
<span class="nc" id="L139">                image = createImage(c, w, h, config, args);</span>
<span class="nc" id="L140">                cache.setImage(key, config, w, h, args, image);</span>
<span class="nc" id="L141">                draw = true;</span>
            }
<span class="nc bnc" id="L143" title="All 2 branches missed.">            if (draw) {</span>
                // Render to the Image
<span class="nc" id="L145">                Graphics g2 = image.getGraphics();</span>
<span class="nc" id="L146">                paintToImage(c, image, g2, w, h, args);</span>
<span class="nc" id="L147">                g2.dispose();</span>
            }

            // Render to the passed in Graphics
<span class="nc" id="L151">            paintImage(c, g, x, y, w, h, image, args);</span>

            // If we did this 3 times and the contents are still lost
            // assume we're painting to a VolatileImage that is bogus and
            // give up.  Presumably we'll be called again to paint.
<span class="nc bnc" id="L156" title="All 2 branches missed.">        } while ((image instanceof VolatileImage) &amp;&amp;</span>
<span class="nc bnc" id="L157" title="All 4 branches missed.">                 ((VolatileImage)image).contentsLost() &amp;&amp; ++attempts &lt; 3);</span>
<span class="nc" id="L158">    }</span>

    /**
     * Paints the representation to cache to the supplied Graphics.
     *
     * @param c Component painting to, may be null.
     * @param image Image to paint to
     * @param g Graphics to paint to, obtained from the passed in Image.
     * @param w Width to paint to
     * @param h Height to paint to
     * @param args Arguments supplied to &lt;code&gt;paint&lt;/code&gt;
     */
    protected abstract void paintToImage(Component c, Image image, Graphics g,
                                         int w, int h, Object[] args);


    /**
     * Paints the image to the specified location.
     *
     * @param c Component painting to
     * @param g Graphics to paint to
     * @param x X coordinate to paint to
     * @param y Y coordinate to paint to
     * @param w Width to paint to
     * @param h Height to paint to
     * @param image Image to paint
     * @param args Arguments supplied to &lt;code&gt;paint&lt;/code&gt;
     */
    protected void paintImage(Component c, Graphics g,
                              int x, int y, int w, int h, Image image,
                              Object[] args) {
<span class="nc" id="L189">        g.drawImage(image, x, y, null);</span>
<span class="nc" id="L190">    }</span>

    /**
     * Creates the image to cache.  This returns an opaque image, subclasses
     * that require translucency or transparency will need to override this
     * method.
     *
     * @param c Component painting to
     * @param w Width of image to create
     * @param h Height to image to create
     * @param config GraphicsConfiguration that will be
     *        rendered to, this may be null.
     * @param args Arguments passed to paint
     */
    protected Image createImage(Component c, int w, int h,
                                GraphicsConfiguration config, Object[] args) {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (config == null) {</span>
<span class="nc" id="L207">            return new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);</span>
        }
<span class="nc" id="L209">        return config.createCompatibleVolatileImage(w, h);</span>
    }

    /**
     * Clear the image cache
     */
    protected void flush() {
<span class="nc" id="L216">        synchronized(CachedPainter.class) {</span>
<span class="nc" id="L217">            getCache(getClass()).flush();</span>
<span class="nc" id="L218">        }</span>
<span class="nc" id="L219">    }</span>

    private GraphicsConfiguration getGraphicsConfiguration(Component c) {
<span class="nc bnc" id="L222" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L223">            return null;</span>
        }
<span class="nc" id="L225">        return c.getGraphicsConfiguration();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>