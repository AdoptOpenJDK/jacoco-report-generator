<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>XPStyle.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.java.swing.plaf.windows</a> &gt; <span class="el_source">XPStyle.java</span></div><h1>XPStyle.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * &lt;p&gt;These classes are designed to be used while the
 * corresponding &lt;code&gt;LookAndFeel&lt;/code&gt; class has been installed
 * (&lt;code&gt;UIManager.setLookAndFeel(new &lt;i&gt;XXX&lt;/i&gt;LookAndFeel())&lt;/code&gt;).
 * Using them while a different &lt;code&gt;LookAndFeel&lt;/code&gt; is installed
 * may produce unexpected results, including exceptions.
 * Additionally, changing the &lt;code&gt;LookAndFeel&lt;/code&gt;
 * maintained by the &lt;code&gt;UIManager&lt;/code&gt; without updating the
 * corresponding &lt;code&gt;ComponentUI&lt;/code&gt; of any
 * &lt;code&gt;JComponent&lt;/code&gt;s may also produce unexpected results,
 * such as the wrong colors showing up, and is generally not
 * encouraged.
 *
 */

package com.sun.java.swing.plaf.windows;

import java.awt.*;
import java.awt.image.*;
import java.security.AccessController;
import java.util.*;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.plaf.*;
import javax.swing.text.JTextComponent;

import sun.awt.image.SunWritableRaster;
import sun.awt.windows.ThemeReader;
import sun.security.action.GetPropertyAction;
import sun.swing.CachedPainter;

import static com.sun.java.swing.plaf.windows.TMSchema.*;


/**
 * Implements Windows XP Styles for the Windows Look and Feel.
 *
 * @author Leif Samuelsson
 */
<span class="nc bnc" id="L66" title="All 2 branches missed.">class XPStyle {</span>
    // Singleton instance of this class
    private static XPStyle xp;

    // Singleton instance of SkinPainter
<span class="nc" id="L71">    private static SkinPainter skinPainter = new SkinPainter();</span>

<span class="nc" id="L73">    private static Boolean themeActive = null;</span>

    private HashMap&lt;String, Border&gt; borderMap;
    private HashMap&lt;String, Color&gt;  colorMap;

    private boolean flatMenus;

    static {
<span class="nc" id="L81">        invalidateStyle();</span>
<span class="nc" id="L82">    }</span>

    /** Static method for clearing the hashmap and loading the
     * current XP style and theme
     */
    static synchronized void invalidateStyle() {
<span class="nc" id="L88">        xp = null;</span>
<span class="nc" id="L89">        themeActive = null;</span>
<span class="nc" id="L90">        skinPainter.flush();</span>
<span class="nc" id="L91">    }</span>

    /** Get the singleton instance of this class
     *
     * @return the singleton instance of this class or null if XP styles
     * are not active or if this is not Windows XP
     */
    static synchronized XPStyle getXP() {
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (themeActive == null) {</span>
<span class="nc" id="L100">            Toolkit toolkit = Toolkit.getDefaultToolkit();</span>
<span class="nc" id="L101">            themeActive =</span>
<span class="nc" id="L102">                (Boolean)toolkit.getDesktopProperty(&quot;win.xpstyle.themeActive&quot;);</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">            if (themeActive == null) {</span>
<span class="nc" id="L104">                themeActive = Boolean.FALSE;</span>
            }
<span class="nc bnc" id="L106" title="All 2 branches missed.">            if (themeActive.booleanValue()) {</span>
<span class="nc" id="L107">                GetPropertyAction propertyAction =</span>
                    new GetPropertyAction(&quot;swing.noxp&quot;);
<span class="nc bnc" id="L109" title="All 2 branches missed.">                if (AccessController.doPrivileged(propertyAction) == null &amp;&amp;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">                    ThemeReader.isThemed() &amp;&amp;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">                    !(UIManager.getLookAndFeel()</span>
                      instanceof WindowsClassicLookAndFeel)) {

<span class="nc" id="L114">                    xp = new XPStyle();</span>
                }
            }
        }
<span class="nc" id="L118">        return xp;</span>
    }

    static boolean isVista() {
<span class="nc" id="L122">        XPStyle xp = XPStyle.getXP();</span>
<span class="nc bnc" id="L123" title="All 4 branches missed.">        return (xp != null &amp;&amp; xp.isSkinDefined(null, Part.CP_DROPDOWNBUTTONRIGHT));</span>
    }

    /** Get a named &lt;code&gt;String&lt;/code&gt; value from the current style
     *
     * @param part a &lt;code&gt;Part&lt;/code&gt;
     * @param state a &lt;code&gt;String&lt;/code&gt;
     * @param attributeKey a &lt;code&gt;String&lt;/code&gt;
     * @return a &lt;code&gt;String&lt;/code&gt; or null if key is not found
     *    in the current style
     *
     * This is currently only used by WindowsInternalFrameTitlePane for painting
     * title foregound and can be removed when no longer needed
     */
    String getString(Component c, Part part, State state, Prop prop) {
<span class="nc" id="L138">        return getTypeEnumName(c, part, state, prop);</span>
    }

    TypeEnum getTypeEnum(Component c, Part part, State state, Prop prop) {
<span class="nc" id="L142">        int enumValue = ThemeReader.getEnum(part.getControlName(c), part.getValue(),</span>
<span class="nc" id="L143">                                            State.getValue(part, state),</span>
<span class="nc" id="L144">                                            prop.getValue());</span>
<span class="nc" id="L145">        return TypeEnum.getTypeEnum(prop, enumValue);</span>
    }

    private static String getTypeEnumName(Component c, Part part, State state, Prop prop) {
<span class="nc" id="L149">        int enumValue = ThemeReader.getEnum(part.getControlName(c), part.getValue(),</span>
<span class="nc" id="L150">                                            State.getValue(part, state),</span>
<span class="nc" id="L151">                                            prop.getValue());</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (enumValue == -1) {</span>
<span class="nc" id="L153">            return null;</span>
        }
<span class="nc" id="L155">        return TypeEnum.getTypeEnum(prop, enumValue).getName();</span>
    }




    /** Get a named &lt;code&gt;int&lt;/code&gt; value from the current style
     *
     * @param part a &lt;code&gt;Part&lt;/code&gt;
     * @return an &lt;code&gt;int&lt;/code&gt; or null if key is not found
     *    in the current style
     */
    int getInt(Component c, Part part, State state, Prop prop, int fallback) {
<span class="nc" id="L168">        return ThemeReader.getInt(part.getControlName(c), part.getValue(),</span>
<span class="nc" id="L169">                                  State.getValue(part, state),</span>
<span class="nc" id="L170">                                  prop.getValue());</span>
    }

    /** Get a named &lt;code&gt;Dimension&lt;/code&gt; value from the current style
     *
     * @param key a &lt;code&gt;String&lt;/code&gt;
     * @return a &lt;code&gt;Dimension&lt;/code&gt; or null if key is not found
     *    in the current style
     *
     * This is currently only used by WindowsProgressBarUI and the value
     * should probably be cached there instead of here.
     */
    Dimension getDimension(Component c, Part part, State state, Prop prop) {
<span class="nc" id="L183">        return ThemeReader.getPosition(part.getControlName(c), part.getValue(),</span>
<span class="nc" id="L184">                                       State.getValue(part, state),</span>
<span class="nc" id="L185">                                       prop.getValue());</span>
    }

    /** Get a named &lt;code&gt;Point&lt;/code&gt; (e.g. a location or an offset) value
     *  from the current style
     *
     * @param key a &lt;code&gt;String&lt;/code&gt;
     * @return a &lt;code&gt;Point&lt;/code&gt; or null if key is not found
     *    in the current style
     *
     * This is currently only used by WindowsInternalFrameTitlePane for painting
     * title foregound and can be removed when no longer needed
     */
    Point getPoint(Component c, Part part, State state, Prop prop) {
<span class="nc" id="L199">        Dimension d = ThemeReader.getPosition(part.getControlName(c), part.getValue(),</span>
<span class="nc" id="L200">                                              State.getValue(part, state),</span>
<span class="nc" id="L201">                                              prop.getValue());</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (d != null) {</span>
<span class="nc" id="L203">            return new Point(d.width, d.height);</span>
        } else {
<span class="nc" id="L205">            return null;</span>
        }
    }

    /** Get a named &lt;code&gt;Insets&lt;/code&gt; value from the current style
     *
     * @param key a &lt;code&gt;String&lt;/code&gt;
     * @return an &lt;code&gt;Insets&lt;/code&gt; object or null if key is not found
     *    in the current style
     *
     * This is currently only used to create borders and by
     * WindowsInternalFrameTitlePane for painting title foregound.
     * The return value is already cached in those places.
     */
    Insets getMargin(Component c, Part part, State state, Prop prop) {
<span class="nc" id="L220">        return ThemeReader.getThemeMargins(part.getControlName(c), part.getValue(),</span>
<span class="nc" id="L221">                                           State.getValue(part, state),</span>
<span class="nc" id="L222">                                           prop.getValue());</span>
    }


    /** Get a named &lt;code&gt;Color&lt;/code&gt; value from the current style
     *
     * @param part a &lt;code&gt;Part&lt;/code&gt;
     * @return a &lt;code&gt;Color&lt;/code&gt; or null if key is not found
     *    in the current style
     */
    synchronized Color getColor(Skin skin, Prop prop, Color fallback) {
<span class="nc" id="L233">        String key = skin.toString() + &quot;.&quot; + prop.name();</span>
<span class="nc" id="L234">        Part part = skin.part;</span>
<span class="nc" id="L235">        Color color = colorMap.get(key);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (color == null) {</span>
<span class="nc" id="L237">            color = ThemeReader.getColor(part.getControlName(null), part.getValue(),</span>
<span class="nc" id="L238">                                         State.getValue(part, skin.state),</span>
<span class="nc" id="L239">                                         prop.getValue());</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (color != null) {</span>
<span class="nc" id="L241">                color = new ColorUIResource(color);</span>
<span class="nc" id="L242">                colorMap.put(key, color);</span>
            }
        }
<span class="nc bnc" id="L245" title="All 2 branches missed.">        return (color != null) ? color : fallback;</span>
    }

    Color getColor(Component c, Part part, State state, Prop prop, Color fallback) {
<span class="nc" id="L249">        return getColor(new Skin(c, part, state), prop, fallback);</span>
    }



    /** Get a named &lt;code&gt;Border&lt;/code&gt; value from the current style
     *
     * @param part a &lt;code&gt;Part&lt;/code&gt;
     * @return a &lt;code&gt;Border&lt;/code&gt; or null if key is not found
     *    in the current style or if the style for the particular
     *    part is not defined as &quot;borderfill&quot;.
     */
    synchronized Border getBorder(Component c, Part part) {
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (part == Part.MENU) {</span>
            // Special case because XP has no skin for menus
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (flatMenus) {</span>
                // TODO: The classic border uses this color, but we should
                // create a new UI property called &quot;PopupMenu.borderColor&quot;
                // instead.
<span class="nc" id="L268">                return new XPFillBorder(UIManager.getColor(&quot;InternalFrame.borderShadow&quot;),</span>
                                        1);
            } else {
<span class="nc" id="L271">                return null;    // Will cause L&amp;F to use classic border</span>
            }
        }
<span class="nc" id="L274">        Skin skin = new Skin(c, part, null);</span>
<span class="nc" id="L275">        Border border = borderMap.get(skin.string);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (border == null) {</span>
<span class="nc" id="L277">            String bgType = getTypeEnumName(c, part, null, Prop.BGTYPE);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (&quot;borderfill&quot;.equalsIgnoreCase(bgType)) {</span>
<span class="nc" id="L279">                int thickness = getInt(c, part, null, Prop.BORDERSIZE, 1);</span>
<span class="nc" id="L280">                Color color = getColor(skin, Prop.BORDERCOLOR, Color.black);</span>
<span class="nc" id="L281">                border = new XPFillBorder(color, thickness);</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                if (part == Part.CP_COMBOBOX) {</span>
<span class="nc" id="L283">                    border = new XPStatefulFillBorder(color, thickness, part, Prop.BORDERCOLOR);</span>
                }
<span class="nc bnc" id="L285" title="All 2 branches missed.">            } else if (&quot;imagefile&quot;.equalsIgnoreCase(bgType)) {</span>
<span class="nc" id="L286">                Insets m = getMargin(c, part, null, Prop.SIZINGMARGINS);</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                if (m != null) {</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">                    if (getBoolean(c, part, null, Prop.BORDERONLY)) {</span>
<span class="nc" id="L289">                        border = new XPImageBorder(c, part);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                    } else if (part == Part.CP_COMBOBOX) {</span>
<span class="nc" id="L291">                        border = new EmptyBorder(1, 1, 1, 1);</span>
                    } else {
<span class="nc bnc" id="L293" title="All 2 branches missed.">                        if(part == Part.TP_BUTTON) {</span>
<span class="nc" id="L294">                            border = new XPEmptyBorder(new Insets(3,3,3,3));</span>
                        } else {
<span class="nc" id="L296">                            border = new XPEmptyBorder(m);</span>
                        }
                    }
                }
            }
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (border != null) {</span>
<span class="nc" id="L302">                borderMap.put(skin.string, border);</span>
            }
        }
<span class="nc" id="L305">        return border;</span>
    }

    private class XPFillBorder extends LineBorder implements UIResource {
<span class="nc" id="L309">        XPFillBorder(Color color, int thickness) {</span>
<span class="nc" id="L310">            super(color, thickness);</span>
<span class="nc" id="L311">        }</span>

        public Insets getBorderInsets(Component c, Insets insets)       {
<span class="nc" id="L314">            Insets margin = null;</span>
            //
            // Ideally we'd have an interface defined for classes which
            // support margins (to avoid this hackery), but we've
            // decided against it for simplicity
            //
<span class="nc bnc" id="L320" title="All 2 branches missed.">           if (c instanceof AbstractButton) {</span>
<span class="nc" id="L321">               margin = ((AbstractButton)c).getMargin();</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">           } else if (c instanceof JToolBar) {</span>
<span class="nc" id="L323">               margin = ((JToolBar)c).getMargin();</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">           } else if (c instanceof JTextComponent) {</span>
<span class="nc" id="L325">               margin = ((JTextComponent)c).getMargin();</span>
           }
<span class="nc bnc" id="L327" title="All 2 branches missed.">           insets.top    = (margin != null? margin.top : 0)    + thickness;</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">           insets.left   = (margin != null? margin.left : 0)   + thickness;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">           insets.bottom = (margin != null? margin.bottom : 0) + thickness;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">           insets.right =  (margin != null? margin.right : 0)  + thickness;</span>

<span class="nc" id="L332">           return insets;</span>
        }
    }

    private class XPStatefulFillBorder extends XPFillBorder {
        private final Part part;
        private final Prop prop;
<span class="nc" id="L339">        XPStatefulFillBorder(Color color, int thickness, Part part, Prop prop) {</span>
<span class="nc" id="L340">            super(color, thickness);</span>
<span class="nc" id="L341">            this.part = part;</span>
<span class="nc" id="L342">            this.prop = prop;</span>
<span class="nc" id="L343">        }</span>

        public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
<span class="nc" id="L346">            State state = State.NORMAL;</span>
            // special casing for comboboxes.
            // there may be more special cases in the future
<span class="nc bnc" id="L349" title="All 2 branches missed.">            if(c instanceof JComboBox) {</span>
<span class="nc" id="L350">                JComboBox cb = (JComboBox)c;</span>
                // note. in the future this should be replaced with a call
                // to BasicLookAndFeel.getUIOfType()
<span class="nc bnc" id="L353" title="All 2 branches missed.">                if(cb.getUI() instanceof WindowsComboBoxUI) {</span>
<span class="nc" id="L354">                    WindowsComboBoxUI wcb = (WindowsComboBoxUI)cb.getUI();</span>
<span class="nc" id="L355">                    state = wcb.getXPComboBoxState(cb);</span>
                }
            }
<span class="nc" id="L358">            lineColor = getColor(c, part, state, prop, Color.black);</span>
<span class="nc" id="L359">            super.paintBorder(c, g, x, y, width, height);</span>
<span class="nc" id="L360">        }</span>
    }

    private class XPImageBorder extends AbstractBorder implements UIResource {
        Skin skin;

<span class="nc" id="L366">        XPImageBorder(Component c, Part part) {</span>
<span class="nc" id="L367">            this.skin = getSkin(c, part);</span>
<span class="nc" id="L368">        }</span>

        public void paintBorder(Component c, Graphics g,
                                int x, int y, int width, int height) {
<span class="nc" id="L372">            skin.paintSkin(g, x, y, width, height, null);</span>
<span class="nc" id="L373">        }</span>

        public Insets getBorderInsets(Component c, Insets insets)       {
<span class="nc" id="L376">            Insets margin = null;</span>
<span class="nc" id="L377">            Insets borderInsets = skin.getContentMargin();</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">            if(borderInsets == null) {</span>
<span class="nc" id="L379">                borderInsets = new Insets(0, 0, 0, 0);</span>
            }
            //
            // Ideally we'd have an interface defined for classes which
            // support margins (to avoid this hackery), but we've
            // decided against it for simplicity
            //
<span class="nc bnc" id="L386" title="All 2 branches missed.">           if (c instanceof AbstractButton) {</span>
<span class="nc" id="L387">               margin = ((AbstractButton)c).getMargin();</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">           } else if (c instanceof JToolBar) {</span>
<span class="nc" id="L389">               margin = ((JToolBar)c).getMargin();</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">           } else if (c instanceof JTextComponent) {</span>
<span class="nc" id="L391">               margin = ((JTextComponent)c).getMargin();</span>
           }
<span class="nc bnc" id="L393" title="All 2 branches missed.">           insets.top    = (margin != null? margin.top : 0)    + borderInsets.top;</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">           insets.left   = (margin != null? margin.left : 0)   + borderInsets.left;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">           insets.bottom = (margin != null? margin.bottom : 0) + borderInsets.bottom;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">           insets.right  = (margin != null? margin.right : 0)  + borderInsets.right;</span>

<span class="nc" id="L398">           return insets;</span>
        }
    }

    private class XPEmptyBorder extends EmptyBorder implements UIResource {
<span class="nc" id="L403">        XPEmptyBorder(Insets m) {</span>
<span class="nc" id="L404">            super(m.top+2, m.left+2, m.bottom+2, m.right+2);</span>
<span class="nc" id="L405">        }</span>

        public Insets getBorderInsets(Component c, Insets insets)       {
<span class="nc" id="L408">            insets = super.getBorderInsets(c, insets);</span>

<span class="nc" id="L410">            Insets margin = null;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (c instanceof AbstractButton) {</span>
<span class="nc" id="L412">                Insets m = ((AbstractButton)c).getMargin();</span>
                // if this is a toolbar button then ignore getMargin()
                // and subtract the padding added by the constructor
<span class="nc bnc" id="L415" title="All 8 branches missed.">                if(c.getParent() instanceof JToolBar</span>
                   &amp;&amp; ! (c instanceof JRadioButton)
                   &amp;&amp; ! (c instanceof JCheckBox)
                   &amp;&amp; m instanceof InsetsUIResource) {
<span class="nc" id="L419">                    insets.top -= 2;</span>
<span class="nc" id="L420">                    insets.left -= 2;</span>
<span class="nc" id="L421">                    insets.bottom -= 2;</span>
<span class="nc" id="L422">                    insets.right -= 2;</span>
                } else {
<span class="nc" id="L424">                    margin = m;</span>
                }
<span class="nc bnc" id="L426" title="All 2 branches missed.">            } else if (c instanceof JToolBar) {</span>
<span class="nc" id="L427">                margin = ((JToolBar)c).getMargin();</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            } else if (c instanceof JTextComponent) {</span>
<span class="nc" id="L429">                margin = ((JTextComponent)c).getMargin();</span>
            }
<span class="nc bnc" id="L431" title="All 2 branches missed.">            if (margin != null) {</span>
<span class="nc" id="L432">                insets.top    = margin.top + 2;</span>
<span class="nc" id="L433">                insets.left   = margin.left + 2;</span>
<span class="nc" id="L434">                insets.bottom = margin.bottom + 2;</span>
<span class="nc" id="L435">                insets.right  = margin.right + 2;</span>
            }
<span class="nc" id="L437">            return insets;</span>
        }
    }
    boolean isSkinDefined(Component c, Part part) {
<span class="nc bnc" id="L441" title="All 2 branches missed.">        return (part.getValue() == 0)</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            || ThemeReader.isThemePartDefined(</span>
<span class="nc" id="L443">                   part.getControlName(c), part.getValue(), 0);</span>
    }


    /** Get a &lt;code&gt;Skin&lt;/code&gt; object from the current style
     * for a named part (component type)
     *
     * @param part a &lt;code&gt;Part&lt;/code&gt;
     * @return a &lt;code&gt;Skin&lt;/code&gt; object
     */
    synchronized Skin getSkin(Component c, Part part) {
<span class="nc bnc" id="L454" title="All 4 branches missed.">        assert isSkinDefined(c, part) : &quot;part &quot; + part + &quot; is not defined&quot;;</span>
<span class="nc" id="L455">        return new Skin(c, part, null);</span>
    }


    long getThemeTransitionDuration(Component c, Part part, State stateFrom,
                                    State stateTo, Prop prop) {
<span class="nc" id="L461">         return ThemeReader.getThemeTransitionDuration(part.getControlName(c),</span>
<span class="nc" id="L462">                                          part.getValue(),</span>
<span class="nc" id="L463">                                          State.getValue(part, stateFrom),</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                                          State.getValue(part, stateTo),</span>
<span class="nc" id="L465">                                          (prop != null) ? prop.getValue() : 0);</span>
    }


    /** A class which encapsulates attributes for a given part
     * (component type) and which provides methods for painting backgrounds
     * and glyphs
     */
    static class Skin {
        final Component component;
        final Part part;
        final State state;

        private final String string;
<span class="nc" id="L479">        private Dimension size = null;</span>

        Skin(Component component, Part part) {
<span class="nc" id="L482">            this(component, part, null);</span>
<span class="nc" id="L483">        }</span>

        Skin(Part part, State state) {
<span class="nc" id="L486">            this(null, part, state);</span>
<span class="nc" id="L487">        }</span>

<span class="nc" id="L489">        Skin(Component component, Part part, State state) {</span>
<span class="nc" id="L490">            this.component = component;</span>
<span class="nc" id="L491">            this.part  = part;</span>
<span class="nc" id="L492">            this.state = state;</span>

<span class="nc" id="L494">            String str = part.getControlName(component) +&quot;.&quot; + part.name();</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">            if (state != null) {</span>
<span class="nc" id="L496">                str += &quot;(&quot;+state.name()+&quot;)&quot;;</span>
            }
<span class="nc" id="L498">            string = str;</span>
<span class="nc" id="L499">        }</span>

        Insets getContentMargin() {
            /* idk: it seems margins are the same for all 'big enough'
             * bounding rectangles.
             */
<span class="nc" id="L505">            int boundingWidth = 100;</span>
<span class="nc" id="L506">            int boundingHeight = 100;</span>

<span class="nc" id="L508">            return ThemeReader.getThemeBackgroundContentMargins(</span>
<span class="nc" id="L509">                part.getControlName(null), part.getValue(),</span>
                0, boundingWidth, boundingHeight);
        }

        private int getWidth(State state) {
<span class="nc bnc" id="L514" title="All 2 branches missed.">            if (size == null) {</span>
<span class="nc" id="L515">                size = getPartSize(part, state);</span>
            }
<span class="nc" id="L517">            return size.width;</span>
        }

        int getWidth() {
<span class="nc bnc" id="L521" title="All 2 branches missed.">            return getWidth((state != null) ? state : State.NORMAL);</span>
        }

        private int getHeight(State state) {
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (size == null) {</span>
<span class="nc" id="L526">                size = getPartSize(part, state);</span>
            }
<span class="nc" id="L528">            return size.height;</span>
        }

        int getHeight() {
<span class="nc bnc" id="L532" title="All 2 branches missed.">            return getHeight((state != null) ? state : State.NORMAL);</span>
        }

        public String toString() {
<span class="nc" id="L536">            return string;</span>
        }

        public boolean equals(Object obj) {
<span class="nc bnc" id="L540" title="All 4 branches missed.">            return (obj instanceof Skin &amp;&amp; ((Skin)obj).string.equals(string));</span>
        }

        public int hashCode() {
<span class="nc" id="L544">            return string.hashCode();</span>
        }

        /** Paint a skin at x, y.
         *
         * @param g   the graphics context to use for painting
         * @param dx  the destination &lt;i&gt;x&lt;/i&gt; coordinate
         * @param dy  the destination &lt;i&gt;y&lt;/i&gt; coordinate
         * @param state which state to paint
         */
        void paintSkin(Graphics g, int dx, int dy, State state) {
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (state == null) {</span>
<span class="nc" id="L556">                state = this.state;</span>
            }
<span class="nc" id="L558">            paintSkin(g, dx, dy, getWidth(state), getHeight(state), state);</span>
<span class="nc" id="L559">        }</span>

        /** Paint a skin in an area defined by a rectangle.
         *
         * @param g the graphics context to use for painting
         * @param r     a &lt;code&gt;Rectangle&lt;/code&gt; defining the area to fill,
         *                     may cause the image to be stretched or tiled
         * @param state which state to paint
         */
        void paintSkin(Graphics g, Rectangle r, State state) {
<span class="nc" id="L569">            paintSkin(g, r.x, r.y, r.width, r.height, state);</span>
<span class="nc" id="L570">        }</span>

        /** Paint a skin at a defined position and size
         *  This method supports animation.
         *
         * @param g   the graphics context to use for painting
         * @param dx  the destination &lt;i&gt;x&lt;/i&gt; coordinate
         * @param dy  the destination &lt;i&gt;y&lt;/i&gt; coordinate
         * @param dw  the width of the area to fill, may cause
         *                  the image to be stretched or tiled
         * @param dh  the height of the area to fill, may cause
         *                  the image to be stretched or tiled
         * @param state which state to paint
         */
        void paintSkin(Graphics g, int dx, int dy, int dw, int dh, State state) {
<span class="nc bnc" id="L585" title="All 4 branches missed.">            if (ThemeReader.isGetThemeTransitionDurationDefined()</span>
                  &amp;&amp; component instanceof JComponent
<span class="nc bnc" id="L587" title="All 2 branches missed.">                  &amp;&amp; SwingUtilities.getAncestorOfClass(CellRendererPane.class,</span>
                                                       component) == null) {
<span class="nc" id="L589">                AnimationController.paintSkin((JComponent) component, this,</span>
                                              g, dx, dy, dw, dh, state);
            } else {
<span class="nc" id="L592">                paintSkinRaw(g, dx, dy, dw, dh, state);</span>
            }
<span class="nc" id="L594">        }</span>

        /** Paint a skin at a defined position and size. This method
         *  does not trigger animation. It is needed for the animation
         *  support.
         *
         * @param g   the graphics context to use for painting
         * @param dx  the destination &lt;i&gt;x&lt;/i&gt; coordinate.
         * @param dy  the destination &lt;i&gt;y&lt;/i&gt; coordinate.
         * @param dw  the width of the area to fill, may cause
         *                  the image to be stretched or tiled
         * @param dh  the height of the area to fill, may cause
         *                  the image to be stretched or tiled
         * @param state which state to paint
         */
        void paintSkinRaw(Graphics g, int dx, int dy, int dw, int dh, State state) {
<span class="nc" id="L610">            skinPainter.paint(null, g, dx, dy, dw, dh, this, state);</span>
<span class="nc" id="L611">        }</span>

        /** Paint a skin at a defined position and size
         *
         * @param g   the graphics context to use for painting
         * @param dx  the destination &lt;i&gt;x&lt;/i&gt; coordinate
         * @param dy  the destination &lt;i&gt;y&lt;/i&gt; coordinate
         * @param dw  the width of the area to fill, may cause
         *                  the image to be stretched or tiled
         * @param dh  the height of the area to fill, may cause
         *                  the image to be stretched or tiled
         * @param state which state to paint
         * @param borderFill should test if the component uses a border fill
                            and skip painting if it is
         */
        void paintSkin(Graphics g, int dx, int dy, int dw, int dh, State state,
                boolean borderFill) {
<span class="nc bnc" id="L628" title="All 4 branches missed.">            if(borderFill &amp;&amp; &quot;borderfill&quot;.equals(getTypeEnumName(component, part,</span>
                    state, Prop.BGTYPE))) {
<span class="nc" id="L630">                return;</span>
            }
<span class="nc" id="L632">            skinPainter.paint(null, g, dx, dy, dw, dh, this, state);</span>
<span class="nc" id="L633">        }</span>
    }

    private static class SkinPainter extends CachedPainter {
        SkinPainter() {
<span class="nc" id="L638">            super(30);</span>
<span class="nc" id="L639">            flush();</span>
<span class="nc" id="L640">        }</span>

        public void flush() {
<span class="nc" id="L643">            super.flush();</span>
<span class="nc" id="L644">        }</span>

        protected void paintToImage(Component c, Image image, Graphics g,
                                    int w, int h, Object[] args) {
<span class="nc" id="L648">            boolean accEnabled = false;</span>
<span class="nc" id="L649">            Skin skin = (Skin)args[0];</span>
<span class="nc" id="L650">            Part part = skin.part;</span>
<span class="nc" id="L651">            State state = (State)args[1];</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (state == null) {</span>
<span class="nc" id="L653">                state = skin.state;</span>
            }
<span class="nc bnc" id="L655" title="All 2 branches missed.">            if (c == null) {</span>
<span class="nc" id="L656">                c = skin.component;</span>
            }
<span class="nc" id="L658">            BufferedImage bi = (BufferedImage)image;</span>

<span class="nc" id="L660">            WritableRaster raster = bi.getRaster();</span>
<span class="nc" id="L661">            DataBufferInt dbi = (DataBufferInt)raster.getDataBuffer();</span>
            // Note that stealData() requires a markDirty() afterwards
            // since we modify the data in it.
<span class="nc" id="L664">            ThemeReader.paintBackground(SunWritableRaster.stealData(dbi, 0),</span>
<span class="nc" id="L665">                                        part.getControlName(c), part.getValue(),</span>
<span class="nc" id="L666">                                        State.getValue(part, state),</span>
                                        0, 0, w, h, w);
<span class="nc" id="L668">            SunWritableRaster.markDirty(dbi);</span>
<span class="nc" id="L669">        }</span>

        protected Image createImage(Component c, int w, int h,
                                    GraphicsConfiguration config, Object[] args) {
<span class="nc" id="L673">            return new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);</span>
        }
    }

    static class GlyphButton extends JButton {
        private Skin skin;

<span class="nc" id="L680">        public GlyphButton(Component parent, Part part) {</span>
<span class="nc" id="L681">            XPStyle xp = getXP();</span>
<span class="nc" id="L682">            skin = xp.getSkin(parent, part);</span>
<span class="nc" id="L683">            setBorder(null);</span>
<span class="nc" id="L684">            setContentAreaFilled(false);</span>
<span class="nc" id="L685">            setMinimumSize(new Dimension(5, 5));</span>
<span class="nc" id="L686">            setPreferredSize(new Dimension(16, 16));</span>
<span class="nc" id="L687">            setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));</span>
<span class="nc" id="L688">        }</span>

        public boolean isFocusTraversable() {
<span class="nc" id="L691">            return false;</span>
        }

        protected State getState() {
<span class="nc" id="L695">            State state = State.NORMAL;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">            if (!isEnabled()) {</span>
<span class="nc" id="L697">                state = State.DISABLED;</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">            } else if (getModel().isPressed()) {</span>
<span class="nc" id="L699">                state = State.PRESSED;</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">            } else if (getModel().isRollover()) {</span>
<span class="nc" id="L701">                state = State.HOT;</span>
            }
<span class="nc" id="L703">            return state;</span>
        }

        public void paintComponent(Graphics g) {
<span class="nc" id="L707">            Dimension d = getSize();</span>
<span class="nc" id="L708">            skin.paintSkin(g, 0, 0, d.width, d.height, getState());</span>
<span class="nc" id="L709">        }</span>

        public void setPart(Component parent, Part part) {
<span class="nc" id="L712">            XPStyle xp = getXP();</span>
<span class="nc" id="L713">            skin = xp.getSkin(parent, part);</span>
<span class="nc" id="L714">            revalidate();</span>
<span class="nc" id="L715">            repaint();</span>
<span class="nc" id="L716">        }</span>

        protected void paintBorder(Graphics g) {
<span class="nc" id="L719">        }</span>


    }

    // Private constructor
<span class="nc" id="L725">    private XPStyle() {</span>
<span class="nc" id="L726">        flatMenus = getSysBoolean(Prop.FLATMENUS);</span>

<span class="nc" id="L728">        colorMap  = new HashMap&lt;String, Color&gt;();</span>
<span class="nc" id="L729">        borderMap = new HashMap&lt;String, Border&gt;();</span>
        // Note: All further access to the maps must be synchronized
<span class="nc" id="L731">    }</span>


    private boolean getBoolean(Component c, Part part, State state, Prop prop) {
<span class="nc" id="L735">        return ThemeReader.getBoolean(part.getControlName(c), part.getValue(),</span>
<span class="nc" id="L736">                                      State.getValue(part, state),</span>
<span class="nc" id="L737">                                      prop.getValue());</span>
    }



    static Dimension getPartSize(Part part, State state) {
<span class="nc" id="L743">        return ThemeReader.getPartSize(part.getControlName(null), part.getValue(),</span>
<span class="nc" id="L744">                                       State.getValue(part, state));</span>
    }

    private static boolean getSysBoolean(Prop prop) {
        // We can use any widget name here, I guess.
<span class="nc" id="L749">        return ThemeReader.getSysBoolean(&quot;window&quot;, prop.getValue());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>