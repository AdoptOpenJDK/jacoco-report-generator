<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AnimationController.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.java.swing.plaf.windows</a> &gt; <span class="el_source">AnimationController.java</span></div><h1>AnimationController.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.java.swing.plaf.windows;

import java.security.AccessController;
import sun.security.action.GetBooleanAction;

import java.util.*;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;



import sun.swing.UIClientPropertyKey;
import com.sun.java.swing.plaf.windows.TMSchema.State;
import static com.sun.java.swing.plaf.windows.TMSchema.State.*;
import com.sun.java.swing.plaf.windows.TMSchema.Part;
import com.sun.java.swing.plaf.windows.TMSchema.Prop;
import com.sun.java.swing.plaf.windows.XPStyle.Skin;

import sun.awt.AppContext;

/**
 * A class to help mimic Vista theme animations.  The only kind of
 * animation it handles for now is 'transition' animation (this seems
 * to be the only animation which Vista theme can do). This is when
 * one picture fadein over another one in some period of time.
 * According to
 * https://connect.microsoft.com/feedback/ViewFeedback.aspx?FeedbackID=86852&amp;SiteID=4
 * The animations are all linear.
 *
 * This class has a number of responsibilities.
 * &lt;ul&gt;
 *   &lt;li&gt; It trigger rapaint for the UI components involved in the animation
 *   &lt;li&gt; It tracks the animation state for every UI component involved in the
 *        animation and paints {@code Skin} in new {@code State} over the
 *        {@code Skin} in last {@code State} using
 *        {@code AlphaComposite.SrcOver.derive(alpha)} where {code alpha}
 *        depends on the state of animation
 * &lt;/ul&gt;
 *
 * @author Igor Kushnirskiy
 */
class AnimationController implements ActionListener, PropertyChangeListener {

<span class="nc" id="L72">    private final static boolean VISTA_ANIMATION_DISABLED =</span>
<span class="nc" id="L73">        AccessController.doPrivileged(new GetBooleanAction(&quot;swing.disablevistaanimation&quot;));</span>


<span class="nc" id="L76">    private final static Object ANIMATION_CONTROLLER_KEY =</span>
        new StringBuilder(&quot;ANIMATION_CONTROLLER_KEY&quot;);

<span class="nc" id="L79">    private final Map&lt;JComponent, Map&lt;Part, AnimationState&gt;&gt; animationStateMap =</span>
            new WeakHashMap&lt;JComponent, Map&lt;Part, AnimationState&gt;&gt;();

    //this timer is used to cause repaint on animated components
    //30 repaints per second should give smooth animation affect
<span class="nc" id="L84">    private final javax.swing.Timer timer =</span>
        new javax.swing.Timer(1000/30, this);

    private static synchronized AnimationController getAnimationController() {
<span class="nc" id="L88">        AppContext appContext = AppContext.getAppContext();</span>
<span class="nc" id="L89">        Object obj = appContext.get(ANIMATION_CONTROLLER_KEY);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L91">            obj = new AnimationController();</span>
<span class="nc" id="L92">            appContext.put(ANIMATION_CONTROLLER_KEY, obj);</span>
        }
<span class="nc" id="L94">        return (AnimationController) obj;</span>
    }

<span class="nc" id="L97">    private AnimationController() {</span>
<span class="nc" id="L98">        timer.setRepeats(true);</span>
<span class="nc" id="L99">        timer.setCoalesce(true);</span>
        //we need to dispose the controller on l&amp;f change
<span class="nc" id="L101">        UIManager.addPropertyChangeListener(this);</span>
<span class="nc" id="L102">    }</span>

    private static void triggerAnimation(JComponent c,
                           Part part, State newState) {
<span class="nc bnc" id="L106" title="All 4 branches missed.">        if (c instanceof javax.swing.JTabbedPane</span>
            || part == Part.TP_BUTTON) {
            //idk: we can not handle tabs animation because
            //the same (component,part) is used to handle all the tabs
            //and we can not track the states
            //Vista theme might have transition duration for toolbar buttons
            //but native application does not seem to animate them
<span class="nc" id="L113">            return;</span>
        }
        AnimationController controller =
<span class="nc" id="L116">            AnimationController.getAnimationController();</span>
<span class="nc" id="L117">        State oldState = controller.getState(c, part);</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (oldState != newState) {</span>
<span class="nc" id="L119">            controller.putState(c, part, newState);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">            if (newState == State.DEFAULTED) {</span>
                // it seems for DEFAULTED button state Vista does animation from
                // HOT
<span class="nc" id="L123">                oldState = State.HOT;</span>
            }
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (oldState != null) {</span>
                long duration;
<span class="nc bnc" id="L127" title="All 2 branches missed.">                if (newState == State.DEFAULTED) {</span>
                    //Only button might have DEFAULTED state
                    //idk: do not know how to get the value from Vista
                    //one second seems plausible value
<span class="nc" id="L131">                    duration = 1000;</span>
                } else {
<span class="nc" id="L133">                     duration = XPStyle.getXP().getThemeTransitionDuration(</span>
                           c, part,
<span class="nc" id="L135">                           normalizeState(oldState),</span>
<span class="nc" id="L136">                           normalizeState(newState),</span>
                           Prop.TRANSITIONDURATIONS);
                }
<span class="nc" id="L139">                controller.startAnimation(c, part, oldState, newState, duration);</span>
            }
        }
<span class="nc" id="L142">    }</span>

    // for scrollbar up, down, left and right button pictures are
    // defined by states.  It seems that theme has duration defined
    // only for up button states thus we doing this translation here.
    private static State normalizeState(State state) {
        State rv;
<span class="nc bnc" id="L149" title="All 5 branches missed.">        switch (state) {</span>
        case DOWNPRESSED:
            /* falls through */
        case LEFTPRESSED:
            /* falls through */
        case RIGHTPRESSED:
<span class="nc" id="L155">            rv = UPPRESSED;</span>
<span class="nc" id="L156">            break;</span>

        case DOWNDISABLED:
            /* falls through */
        case LEFTDISABLED:
            /* falls through */
        case RIGHTDISABLED:
<span class="nc" id="L163">            rv = UPDISABLED;</span>
<span class="nc" id="L164">            break;</span>

        case DOWNHOT:
            /* falls through */
        case LEFTHOT:
            /* falls through */
        case RIGHTHOT:
<span class="nc" id="L171">            rv = UPHOT;</span>
<span class="nc" id="L172">            break;</span>

        case DOWNNORMAL:
            /* falls through */
        case LEFTNORMAL:
            /* falls through */
        case RIGHTNORMAL:
<span class="nc" id="L179">            rv = UPNORMAL;</span>
<span class="nc" id="L180">            break;</span>

        default :
<span class="nc" id="L183">            rv = state;</span>
            break;
        }
<span class="nc" id="L186">        return rv;</span>
    }

    private synchronized State getState(JComponent component, Part part) {
<span class="nc" id="L190">        State rv = null;</span>
<span class="nc" id="L191">        Object tmpObject =</span>
<span class="nc" id="L192">            component.getClientProperty(PartUIClientPropertyKey.getKey(part));</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (tmpObject instanceof State) {</span>
<span class="nc" id="L194">            rv = (State) tmpObject;</span>
        }
<span class="nc" id="L196">        return rv;</span>
    }

    private synchronized void putState(JComponent component, Part part,
                                       State state) {
<span class="nc" id="L201">        component.putClientProperty(PartUIClientPropertyKey.getKey(part),</span>
                                    state);
<span class="nc" id="L203">    }</span>

    private synchronized void startAnimation(JComponent component,
                                     Part part,
                                     State startState,
                                     State endState,
                                     long millis) {
<span class="nc" id="L210">        boolean isForwardAndReverse = false;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        if (endState == State.DEFAULTED) {</span>
<span class="nc" id="L212">            isForwardAndReverse = true;</span>
        }
<span class="nc" id="L214">        Map&lt;Part, AnimationState&gt; map = animationStateMap.get(component);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (millis &lt;= 0) {</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if (map != null) {</span>
<span class="nc" id="L217">                map.remove(part);</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                if (map.size() == 0) {</span>
<span class="nc" id="L219">                    animationStateMap.remove(component);</span>
                }
            }
<span class="nc" id="L222">            return;</span>
        }
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (map == null) {</span>
<span class="nc" id="L225">            map = new EnumMap&lt;Part, AnimationState&gt;(Part.class);</span>
<span class="nc" id="L226">            animationStateMap.put(component, map);</span>
        }
<span class="nc" id="L228">        map.put(part,</span>
                new AnimationState(startState, millis, isForwardAndReverse));
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (! timer.isRunning()) {</span>
<span class="nc" id="L231">            timer.start();</span>
        }
<span class="nc" id="L233">    }</span>

    static void paintSkin(JComponent component, Skin skin,
                      Graphics g, int dx, int dy, int dw, int dh, State state) {
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (VISTA_ANIMATION_DISABLED) {</span>
<span class="nc" id="L238">            skin.paintSkinRaw(g, dx, dy, dw, dh, state);</span>
<span class="nc" id="L239">            return;</span>
        }
<span class="nc" id="L241">        triggerAnimation(component, skin.part, state);</span>
<span class="nc" id="L242">        AnimationController controller = getAnimationController();</span>
<span class="nc" id="L243">        synchronized (controller) {</span>
<span class="nc" id="L244">            AnimationState animationState = null;</span>
<span class="nc" id="L245">            Map&lt;Part, AnimationState&gt; map =</span>
<span class="nc" id="L246">                controller.animationStateMap.get(component);</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">            if (map != null) {</span>
<span class="nc" id="L248">                animationState = map.get(skin.part);</span>
            }
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (animationState != null) {</span>
<span class="nc" id="L251">                animationState.paintSkin(skin, g, dx, dy, dw, dh, state);</span>
            } else {
<span class="nc" id="L253">                skin.paintSkinRaw(g, dx, dy, dw, dh, state);</span>
            }
<span class="nc" id="L255">        }</span>
<span class="nc" id="L256">    }</span>

    public synchronized void propertyChange(PropertyChangeEvent e) {
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (&quot;lookAndFeel&quot; == e.getPropertyName()</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            &amp;&amp; ! (e.getNewValue() instanceof WindowsLookAndFeel) ) {</span>
<span class="nc" id="L261">            dispose();</span>
        }
<span class="nc" id="L263">    }</span>

    public synchronized void actionPerformed(ActionEvent e) {
<span class="nc" id="L266">        java.util.List&lt;JComponent&gt; componentsToRemove = null;</span>
<span class="nc" id="L267">        java.util.List&lt;Part&gt; partsToRemove = null;</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        for (JComponent component : animationStateMap.keySet()) {</span>
<span class="nc" id="L269">            component.repaint();</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">            if (partsToRemove != null) {</span>
<span class="nc" id="L271">                partsToRemove.clear();</span>
            }
<span class="nc" id="L273">            Map&lt;Part, AnimationState&gt; map = animationStateMap.get(component);</span>
<span class="nc bnc" id="L274" title="All 4 branches missed.">            if (! component.isShowing()</span>
                  || map == null
<span class="nc bnc" id="L276" title="All 2 branches missed.">                  || map.size() == 0) {</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">                if (componentsToRemove == null) {</span>
<span class="nc" id="L278">                    componentsToRemove = new ArrayList&lt;JComponent&gt;();</span>
                }
<span class="nc" id="L280">                componentsToRemove.add(component);</span>
<span class="nc" id="L281">                continue;</span>
            }
<span class="nc bnc" id="L283" title="All 2 branches missed.">            for (Part part : map.keySet()) {</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                if (map.get(part).isDone()) {</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                    if (partsToRemove == null) {</span>
<span class="nc" id="L286">                        partsToRemove = new ArrayList&lt;Part&gt;();</span>
                    }
<span class="nc" id="L288">                    partsToRemove.add(part);</span>
                }
<span class="nc" id="L290">            }</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (partsToRemove != null) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                if (partsToRemove.size() == map.size()) {</span>
                    //animation is done for the component
<span class="nc bnc" id="L294" title="All 2 branches missed.">                    if (componentsToRemove == null) {</span>
<span class="nc" id="L295">                        componentsToRemove = new ArrayList&lt;JComponent&gt;();</span>
                    }
<span class="nc" id="L297">                    componentsToRemove.add(component);</span>
                } else {
<span class="nc bnc" id="L299" title="All 2 branches missed.">                    for (Part part : partsToRemove) {</span>
<span class="nc" id="L300">                        map.remove(part);</span>
<span class="nc" id="L301">                    }</span>
                }
            }
<span class="nc" id="L304">        }</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (componentsToRemove != null) {</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            for (JComponent component : componentsToRemove) {</span>
<span class="nc" id="L307">                animationStateMap.remove(component);</span>
<span class="nc" id="L308">            }</span>
        }
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (animationStateMap.size() == 0) {</span>
<span class="nc" id="L311">            timer.stop();</span>
        }
<span class="nc" id="L313">    }</span>

    private synchronized void dispose() {
<span class="nc" id="L316">        timer.stop();</span>
<span class="nc" id="L317">        UIManager.removePropertyChangeListener(this);</span>
<span class="nc" id="L318">        synchronized (AnimationController.class) {</span>
<span class="nc" id="L319">            AppContext.getAppContext()</span>
<span class="nc" id="L320">                .put(ANIMATION_CONTROLLER_KEY, null);</span>
<span class="nc" id="L321">        }</span>
<span class="nc" id="L322">    }</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">    private static class AnimationState {</span>
        private final State startState;

        //animation duration in nanoseconds
        private final long duration;

        //animatin start time in nanoseconds
        private long startTime;

        //direction the alpha value is changing
        //forward  - from 0 to 1
        //!forward - from 1 to 0
<span class="nc" id="L336">        private boolean isForward = true;</span>

        //if isForwardAndReverse the animation continually goes
        //forward and reverse. alpha value is changing from 0 to 1 then
        //from 1 to 0 and so forth
        private boolean isForwardAndReverse;

        private float progress;

        AnimationState(final State startState,
                       final long milliseconds,
<span class="nc" id="L347">                       boolean isForwardAndReverse) {</span>
<span class="nc bnc" id="L348" title="All 6 branches missed.">            assert startState != null &amp;&amp; milliseconds &gt; 0;</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">            assert SwingUtilities.isEventDispatchThread();</span>

<span class="nc" id="L351">            this.startState = startState;</span>
<span class="nc" id="L352">            this.duration = milliseconds * 1000000;</span>
<span class="nc" id="L353">            this.startTime = System.nanoTime();</span>
<span class="nc" id="L354">            this.isForwardAndReverse = isForwardAndReverse;</span>
<span class="nc" id="L355">            progress = 0f;</span>
<span class="nc" id="L356">        }</span>
        private void updateProgress() {
<span class="nc bnc" id="L358" title="All 4 branches missed.">            assert SwingUtilities.isEventDispatchThread();</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (isDone()) {</span>
<span class="nc" id="L361">                return;</span>
            }
<span class="nc" id="L363">            long currentTime = System.nanoTime();</span>

<span class="nc" id="L365">            progress = ((float) (currentTime - startTime))</span>
                / duration;
<span class="nc" id="L367">            progress = Math.max(progress, 0); //in case time was reset</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            if (progress &gt;= 1) {</span>
<span class="nc" id="L369">                progress = 1;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                if (isForwardAndReverse) {</span>
<span class="nc" id="L371">                    startTime = currentTime;</span>
<span class="nc" id="L372">                    progress = 0;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                    isForward = ! isForward;</span>
                }
            }
<span class="nc" id="L376">        }</span>
        void paintSkin(Skin skin, Graphics _g,
                       int dx, int dy, int dw, int dh, State state) {
<span class="nc bnc" id="L379" title="All 4 branches missed.">            assert SwingUtilities.isEventDispatchThread();</span>

<span class="nc" id="L381">            updateProgress();</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">            if (! isDone()) {</span>
<span class="nc" id="L383">                Graphics2D g = (Graphics2D) _g.create();</span>
<span class="nc" id="L384">                skin.paintSkinRaw(g, dx, dy, dw, dh, startState);</span>
                float alpha;
<span class="nc bnc" id="L386" title="All 2 branches missed.">                if (isForward) {</span>
<span class="nc" id="L387">                    alpha = progress;</span>
                } else {
<span class="nc" id="L389">                    alpha = 1 - progress;</span>
                }
<span class="nc" id="L391">                g.setComposite(AlphaComposite.SrcOver.derive(alpha));</span>
<span class="nc" id="L392">                skin.paintSkinRaw(g, dx, dy, dw, dh, state);</span>
<span class="nc" id="L393">                g.dispose();</span>
<span class="nc" id="L394">            } else {</span>
<span class="nc" id="L395">                skin.paintSkinRaw(_g, dx, dy, dw, dh, state);</span>
            }
<span class="nc" id="L397">        }</span>
        boolean isDone() {
<span class="nc bnc" id="L399" title="All 4 branches missed.">            assert SwingUtilities.isEventDispatchThread();</span>

<span class="nc bnc" id="L401" title="All 2 branches missed.">            return  progress &gt;= 1;</span>
        }
    }

    private static class PartUIClientPropertyKey
          implements UIClientPropertyKey {

<span class="nc" id="L408">        private static final Map&lt;Part, PartUIClientPropertyKey&gt; map =</span>
            new EnumMap&lt;Part, PartUIClientPropertyKey&gt;(Part.class);

        static synchronized PartUIClientPropertyKey getKey(Part part) {
<span class="nc" id="L412">            PartUIClientPropertyKey rv = map.get(part);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">            if (rv == null) {</span>
<span class="nc" id="L414">                rv = new PartUIClientPropertyKey(part);</span>
<span class="nc" id="L415">                map.put(part, rv);</span>
            }
<span class="nc" id="L417">            return rv;</span>
        }

        private final Part part;
<span class="nc" id="L421">        private PartUIClientPropertyKey(Part part) {</span>
<span class="nc" id="L422">            this.part  = part;</span>
<span class="nc" id="L423">        }</span>
        public String toString() {
<span class="nc" id="L425">            return part.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>