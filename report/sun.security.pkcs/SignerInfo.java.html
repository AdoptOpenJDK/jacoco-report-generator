<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SignerInfo.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.pkcs</a> &gt; <span class="el_source">SignerInfo.java</span></div><h1>SignerInfo.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.pkcs;

import java.io.OutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.CertPath;
import java.security.cert.X509Certificate;
import java.security.*;
import java.util.ArrayList;
import java.util.Arrays;

import sun.security.timestamp.TimestampToken;
import sun.security.util.*;
import sun.security.x509.AlgorithmId;
import sun.security.x509.X500Name;
import sun.security.x509.KeyUsageExtension;
import sun.misc.HexDumpEncoder;

/**
 * A SignerInfo, as defined in PKCS#7's signedData type.
 *
 * @author Benjamin Renaud
 */
public class SignerInfo implements DerEncoder {

    BigInteger version;
    X500Name issuerName;
    BigInteger certificateSerialNumber;
    AlgorithmId digestAlgorithmId;
    AlgorithmId digestEncryptionAlgorithmId;
    byte[] encryptedDigest;
    Timestamp timestamp;
<span class="pc" id="L60">    private boolean hasTimestamp = true;</span>
<span class="fc" id="L61">    private static final Debug debug = Debug.getInstance(&quot;jar&quot;);</span>

    PKCS9Attributes authenticatedAttributes;
    PKCS9Attributes unauthenticatedAttributes;

    public SignerInfo(X500Name  issuerName,
                      BigInteger serial,
                      AlgorithmId digestAlgorithmId,
                      AlgorithmId digestEncryptionAlgorithmId,
<span class="nc" id="L70">                      byte[] encryptedDigest) {</span>
<span class="nc" id="L71">        this.version = BigInteger.ONE;</span>
<span class="nc" id="L72">        this.issuerName = issuerName;</span>
<span class="nc" id="L73">        this.certificateSerialNumber = serial;</span>
<span class="nc" id="L74">        this.digestAlgorithmId = digestAlgorithmId;</span>
<span class="nc" id="L75">        this.digestEncryptionAlgorithmId = digestEncryptionAlgorithmId;</span>
<span class="nc" id="L76">        this.encryptedDigest = encryptedDigest;</span>
<span class="nc" id="L77">    }</span>

    public SignerInfo(X500Name  issuerName,
                      BigInteger serial,
                      AlgorithmId digestAlgorithmId,
                      PKCS9Attributes authenticatedAttributes,
                      AlgorithmId digestEncryptionAlgorithmId,
                      byte[] encryptedDigest,
<span class="nc" id="L85">                      PKCS9Attributes unauthenticatedAttributes) {</span>
<span class="nc" id="L86">        this.version = BigInteger.ONE;</span>
<span class="nc" id="L87">        this.issuerName = issuerName;</span>
<span class="nc" id="L88">        this.certificateSerialNumber = serial;</span>
<span class="nc" id="L89">        this.digestAlgorithmId = digestAlgorithmId;</span>
<span class="nc" id="L90">        this.authenticatedAttributes = authenticatedAttributes;</span>
<span class="nc" id="L91">        this.digestEncryptionAlgorithmId = digestEncryptionAlgorithmId;</span>
<span class="nc" id="L92">        this.encryptedDigest = encryptedDigest;</span>
<span class="nc" id="L93">        this.unauthenticatedAttributes = unauthenticatedAttributes;</span>
<span class="nc" id="L94">    }</span>

    /**
     * Parses a PKCS#7 signer info.
     */
    public SignerInfo(DerInputStream derin)
        throws IOException, ParsingException
    {
<span class="fc" id="L102">        this(derin, false);</span>
<span class="fc" id="L103">    }</span>

    /**
     * Parses a PKCS#7 signer info.
     *
     * &lt;p&gt;This constructor is used only for backwards compatibility with
     * PKCS#7 blocks that were generated using JDK1.1.x.
     *
     * @param derin the ASN.1 encoding of the signer info.
     * @param oldStyle flag indicating whether or not the given signer info
     * is encoded according to JDK1.1.x.
     */
    public SignerInfo(DerInputStream derin, boolean oldStyle)
        throws IOException, ParsingException
<span class="fc" id="L117">    {</span>
        // version
<span class="fc" id="L119">        version = derin.getBigInteger();</span>

        // issuerAndSerialNumber
<span class="fc" id="L122">        DerValue[] issuerAndSerialNumber = derin.getSequence(2);</span>
<span class="fc" id="L123">        byte[] issuerBytes = issuerAndSerialNumber[0].toByteArray();</span>
<span class="fc" id="L124">        issuerName = new X500Name(new DerValue(DerValue.tag_Sequence,</span>
                                               issuerBytes));
<span class="fc" id="L126">        certificateSerialNumber = issuerAndSerialNumber[1].getBigInteger();</span>

        // digestAlgorithmId
<span class="fc" id="L129">        DerValue tmp = derin.getDerValue();</span>

<span class="fc" id="L131">        digestAlgorithmId = AlgorithmId.parse(tmp);</span>

        // authenticatedAttributes
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (oldStyle) {</span>
            // In JDK1.1.x, the authenticatedAttributes are always present,
            // encoded as an empty Set (Set of length zero)
<span class="nc" id="L137">            derin.getSet(0);</span>
        } else {
            // check if set of auth attributes (implicit tag) is provided
            // (auth attributes are OPTIONAL)
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">            if ((byte)(derin.peekByte()) == (byte)0xA0) {</span>
<span class="nc" id="L142">                authenticatedAttributes = new PKCS9Attributes(derin);</span>
            }
        }

        // digestEncryptionAlgorithmId - little RSA naming scheme -
        // signature == encryption...
<span class="fc" id="L148">        tmp = derin.getDerValue();</span>

<span class="fc" id="L150">        digestEncryptionAlgorithmId = AlgorithmId.parse(tmp);</span>

        // encryptedDigest
<span class="fc" id="L153">        encryptedDigest = derin.getOctetString();</span>

        // unauthenticatedAttributes
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        if (oldStyle) {</span>
            // In JDK1.1.x, the unauthenticatedAttributes are always present,
            // encoded as an empty Set (Set of length zero)
<span class="nc" id="L159">            derin.getSet(0);</span>
        } else {
            // check if set of unauth attributes (implicit tag) is provided
            // (unauth attributes are OPTIONAL)
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">            if (derin.available() != 0</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">                &amp;&amp; (byte)(derin.peekByte()) == (byte)0xA1) {</span>
<span class="nc" id="L165">                unauthenticatedAttributes =</span>
                    new PKCS9Attributes(derin, true);// ignore unsupported attrs
            }
        }

        // all done
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        if (derin.available() != 0) {</span>
<span class="nc" id="L172">            throw new ParsingException(&quot;extra data at the end&quot;);</span>
        }
<span class="fc" id="L174">    }</span>

    public void encode(DerOutputStream out) throws IOException {

<span class="nc" id="L178">        derEncode(out);</span>
<span class="nc" id="L179">    }</span>

    /**
     * DER encode this object onto an output stream.
     * Implements the &lt;code&gt;DerEncoder&lt;/code&gt; interface.
     *
     * @param out
     * the output stream on which to write the DER encoding.
     *
     * @exception IOException on encoding error.
     */
    public void derEncode(OutputStream out) throws IOException {
<span class="nc" id="L191">        DerOutputStream seq = new DerOutputStream();</span>
<span class="nc" id="L192">        seq.putInteger(version);</span>
<span class="nc" id="L193">        DerOutputStream issuerAndSerialNumber = new DerOutputStream();</span>
<span class="nc" id="L194">        issuerName.encode(issuerAndSerialNumber);</span>
<span class="nc" id="L195">        issuerAndSerialNumber.putInteger(certificateSerialNumber);</span>
<span class="nc" id="L196">        seq.write(DerValue.tag_Sequence, issuerAndSerialNumber);</span>

<span class="nc" id="L198">        digestAlgorithmId.encode(seq);</span>

        // encode authenticated attributes if there are any
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (authenticatedAttributes != null)</span>
<span class="nc" id="L202">            authenticatedAttributes.encode((byte)0xA0, seq);</span>

<span class="nc" id="L204">        digestEncryptionAlgorithmId.encode(seq);</span>

<span class="nc" id="L206">        seq.putOctetString(encryptedDigest);</span>

        // encode unauthenticated attributes if there are any
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (unauthenticatedAttributes != null)</span>
<span class="nc" id="L210">            unauthenticatedAttributes.encode((byte)0xA1, seq);</span>

<span class="nc" id="L212">        DerOutputStream tmp = new DerOutputStream();</span>
<span class="nc" id="L213">        tmp.write(DerValue.tag_Sequence, seq);</span>

<span class="nc" id="L215">        out.write(tmp.toByteArray());</span>
<span class="nc" id="L216">    }</span>



    /*
     * Returns the (user) certificate pertaining to this SignerInfo.
     */
    public X509Certificate getCertificate(PKCS7 block)
        throws IOException
    {
<span class="fc" id="L226">        return block.getCertificate(certificateSerialNumber, issuerName);</span>
    }

    /*
     * Returns the certificate chain pertaining to this SignerInfo.
     */
    public ArrayList&lt;X509Certificate&gt; getCertificateChain(PKCS7 block)
        throws IOException
    {
        X509Certificate userCert;
<span class="fc" id="L236">        userCert = block.getCertificate(certificateSerialNumber, issuerName);</span>
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (userCert == null)</span>
<span class="nc" id="L238">            return null;</span>

<span class="fc" id="L240">        ArrayList&lt;X509Certificate&gt; certList = new ArrayList&lt;X509Certificate&gt;();</span>
<span class="fc" id="L241">        certList.add(userCert);</span>

<span class="fc" id="L243">        X509Certificate[] pkcsCerts = block.getCertificates();</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">        if (pkcsCerts == null</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">            || userCert.getSubjectDN().equals(userCert.getIssuerDN())) {</span>
<span class="fc" id="L246">            return certList;</span>
        }

<span class="fc" id="L249">        Principal issuer = userCert.getIssuerDN();</span>
<span class="fc" id="L250">        int start = 0;</span>
        while (true) {
<span class="fc" id="L252">            boolean match = false;</span>
<span class="fc" id="L253">            int i = start;</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">            while (i &lt; pkcsCerts.length) {</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">                if (issuer.equals(pkcsCerts[i].getSubjectDN())) {</span>
                    // next cert in chain found
<span class="fc" id="L257">                    certList.add(pkcsCerts[i]);</span>
                    // if selected cert is self-signed, we're done
                    // constructing the chain
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                    if (pkcsCerts[i].getSubjectDN().equals(</span>
<span class="fc" id="L261">                                            pkcsCerts[i].getIssuerDN())) {</span>
<span class="fc" id="L262">                        start = pkcsCerts.length;</span>
                    } else {
<span class="nc" id="L264">                        issuer = pkcsCerts[i].getIssuerDN();</span>
<span class="nc" id="L265">                        X509Certificate tmpCert = pkcsCerts[start];</span>
<span class="nc" id="L266">                        pkcsCerts[start] = pkcsCerts[i];</span>
<span class="nc" id="L267">                        pkcsCerts[i] = tmpCert;</span>
<span class="nc" id="L268">                        start++;</span>
                    }
<span class="fc" id="L270">                    match = true;</span>
<span class="fc" id="L271">                    break;</span>
                } else {
<span class="fc" id="L273">                    i++;</span>
                }
            }
<span class="fc bfc" id="L276" title="All 2 branches covered.">            if (!match)</span>
<span class="fc" id="L277">                break;</span>
<span class="fc" id="L278">        }</span>

<span class="fc" id="L280">        return certList;</span>
    }

    /* Returns null if verify fails, this signerInfo if
       verify succeeds. */
    SignerInfo verify(PKCS7 block, byte[] data)
    throws NoSuchAlgorithmException, SignatureException {

        try {

<span class="fc" id="L290">            ContentInfo content = block.getContentInfo();</span>
<span class="pc bpc" id="L291" title="1 of 2 branches missed.">            if (data == null) {</span>
<span class="nc" id="L292">                data = content.getContentBytes();</span>
            }

<span class="fc" id="L295">            String digestAlgname = getDigestAlgorithmId().getName();</span>

            byte[] dataSigned;

            // if there are authenticate attributes, get the message
            // digest and compare it with the digest of data
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">            if (authenticatedAttributes == null) {</span>
<span class="fc" id="L302">                dataSigned = data;</span>
            } else {

                // first, check content type
<span class="nc" id="L306">                ObjectIdentifier contentType = (ObjectIdentifier)</span>
<span class="nc" id="L307">                       authenticatedAttributes.getAttributeValue(</span>
                         PKCS9Attribute.CONTENT_TYPE_OID);
<span class="nc bnc" id="L309" title="All 2 branches missed.">                if (contentType == null ||</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                    !contentType.equals((Object)content.contentType))</span>
<span class="nc" id="L311">                    return null;  // contentType does not match, bad SignerInfo</span>

                // now, check message digest
<span class="nc" id="L314">                byte[] messageDigest = (byte[])</span>
<span class="nc" id="L315">                    authenticatedAttributes.getAttributeValue(</span>
                         PKCS9Attribute.MESSAGE_DIGEST_OID);

<span class="nc bnc" id="L318" title="All 2 branches missed.">                if (messageDigest == null) // fail if there is no message digest</span>
<span class="nc" id="L319">                    return null;</span>

<span class="nc" id="L321">                MessageDigest md = MessageDigest.getInstance(digestAlgname);</span>
<span class="nc" id="L322">                byte[] computedMessageDigest = md.digest(data);</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">                if (messageDigest.length != computedMessageDigest.length)</span>
<span class="nc" id="L325">                    return null;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">                for (int i = 0; i &lt; messageDigest.length; i++) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">                    if (messageDigest[i] != computedMessageDigest[i])</span>
<span class="nc" id="L328">                        return null;</span>
                }

                // message digest attribute matched
                // digest of original data

                // the data actually signed is the DER encoding of
                // the authenticated attributes (tagged with
                // the &quot;SET OF&quot; tag, not 0xA0).
<span class="nc" id="L337">                dataSigned = authenticatedAttributes.getDerEncoding();</span>
            }

            // put together digest algorithm and encryption algorithm
            // to form signing algorithm
<span class="fc" id="L342">            String encryptionAlgname =</span>
<span class="fc" id="L343">                getDigestEncryptionAlgorithmId().getName();</span>

            // Workaround: sometimes the encryptionAlgname is actually
            // a signature name
<span class="fc" id="L347">            String tmp = AlgorithmId.getEncAlgFromSigAlg(encryptionAlgname);</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">            if (tmp != null) encryptionAlgname = tmp;</span>
<span class="fc" id="L349">            String algname = AlgorithmId.makeSigAlg(</span>
                    digestAlgname, encryptionAlgname);

<span class="fc" id="L352">            Signature sig = Signature.getInstance(algname);</span>
<span class="fc" id="L353">            X509Certificate cert = getCertificate(block);</span>

<span class="pc bpc" id="L355" title="1 of 2 branches missed.">            if (cert == null) {</span>
<span class="nc" id="L356">                return null;</span>
            }
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">            if (cert.hasUnsupportedCriticalExtension()) {</span>
<span class="nc" id="L359">                throw new SignatureException(&quot;Certificate has unsupported &quot;</span>
                                             + &quot;critical extension(s)&quot;);
            }

            // Make sure that if the usage of the key in the certificate is
            // restricted, it can be used for digital signatures.
            // XXX We may want to check for additional extensions in the
            // future.
<span class="fc" id="L367">            boolean[] keyUsageBits = cert.getKeyUsage();</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">            if (keyUsageBits != null) {</span>
                KeyUsageExtension keyUsage;
                try {
                    // We don't care whether or not this extension was marked
                    // critical in the certificate.
                    // We're interested only in its value (i.e., the bits set)
                    // and treat the extension as critical.
<span class="fc" id="L375">                    keyUsage = new KeyUsageExtension(keyUsageBits);</span>
<span class="nc" id="L376">                } catch (IOException ioe) {</span>
<span class="nc" id="L377">                    throw new SignatureException(&quot;Failed to parse keyUsage &quot;</span>
                                                 + &quot;extension&quot;);
<span class="fc" id="L379">                }</span>

<span class="fc" id="L381">                boolean digSigAllowed = keyUsage.get(</span>
<span class="fc" id="L382">                        KeyUsageExtension.DIGITAL_SIGNATURE).booleanValue();</span>

<span class="fc" id="L384">                boolean nonRepuAllowed = keyUsage.get(</span>
<span class="fc" id="L385">                        KeyUsageExtension.NON_REPUDIATION).booleanValue();</span>

<span class="pc bpc" id="L387" title="3 of 4 branches missed.">                if (!digSigAllowed &amp;&amp; !nonRepuAllowed) {</span>
<span class="nc" id="L388">                    throw new SignatureException(&quot;Key usage restricted: &quot;</span>
                                                 + &quot;cannot be used for &quot;
                                                 + &quot;digital signatures&quot;);
                }
            }

<span class="fc" id="L394">            PublicKey key = cert.getPublicKey();</span>
<span class="fc" id="L395">            sig.initVerify(key);</span>

<span class="fc" id="L397">            sig.update(dataSigned);</span>

<span class="fc bfc" id="L399" title="All 2 branches covered.">            if (sig.verify(encryptedDigest)) {</span>
<span class="fc" id="L400">                return this;</span>
            }

<span class="nc" id="L403">        } catch (IOException e) {</span>
<span class="nc" id="L404">            throw new SignatureException(&quot;IO error verifying signature:\n&quot; +</span>
<span class="nc" id="L405">                                         e.getMessage());</span>

<span class="nc" id="L407">        } catch (InvalidKeyException e) {</span>
<span class="nc" id="L408">            throw new SignatureException(&quot;InvalidKey: &quot; + e.getMessage());</span>

<span class="fc" id="L410">        }</span>
<span class="fc" id="L411">        return null;</span>
    }

    /* Verify the content of the pkcs7 block. */
    SignerInfo verify(PKCS7 block)
    throws NoSuchAlgorithmException, SignatureException {
<span class="nc" id="L417">        return verify(block, null);</span>
    }


    public BigInteger getVersion() {
<span class="nc" id="L422">            return version;</span>
    }

    public X500Name getIssuerName() {
<span class="nc" id="L426">        return issuerName;</span>
    }

    public BigInteger getCertificateSerialNumber() {
<span class="nc" id="L430">        return certificateSerialNumber;</span>
    }

    public AlgorithmId getDigestAlgorithmId() {
<span class="fc" id="L434">        return digestAlgorithmId;</span>
    }

    public PKCS9Attributes getAuthenticatedAttributes() {
<span class="nc" id="L438">        return authenticatedAttributes;</span>
    }

    public AlgorithmId getDigestEncryptionAlgorithmId() {
<span class="fc" id="L442">        return digestEncryptionAlgorithmId;</span>
    }

    public byte[] getEncryptedDigest() {
<span class="nc" id="L446">        return encryptedDigest;</span>
    }

    public PKCS9Attributes getUnauthenticatedAttributes() {
<span class="nc" id="L450">        return unauthenticatedAttributes;</span>
    }

    /*
     * Extracts a timestamp from a PKCS7 SignerInfo.
     *
     * Examines the signer's unsigned attributes for a
     * &lt;tt&gt;signatureTimestampToken&lt;/tt&gt; attribute. If present,
     * then it is parsed to extract the date and time at which the
     * timestamp was generated.
     *
     * @param info A signer information element of a PKCS 7 block.
     *
     * @return A timestamp token or null if none is present.
     * @throws IOException if an error is encountered while parsing the
     *         PKCS7 data.
     * @throws NoSuchAlgorithmException if an error is encountered while
     *         verifying the PKCS7 object.
     * @throws SignatureException if an error is encountered while
     *         verifying the PKCS7 object.
     * @throws CertificateException if an error is encountered while generating
     *         the TSA's certpath.
     */
    public Timestamp getTimestamp()
        throws IOException, NoSuchAlgorithmException, SignatureException,
               CertificateException
    {
<span class="pc bpc" id="L477" title="2 of 4 branches missed.">        if (timestamp != null || !hasTimestamp)</span>
<span class="nc" id="L478">            return timestamp;</span>

<span class="pc bpc" id="L480" title="1 of 2 branches missed.">        if (unauthenticatedAttributes == null) {</span>
<span class="fc" id="L481">            hasTimestamp = false;</span>
<span class="fc" id="L482">            return null;</span>
        }
<span class="nc" id="L484">        PKCS9Attribute tsTokenAttr =</span>
<span class="nc" id="L485">            unauthenticatedAttributes.getAttribute(</span>
                PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID);
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (tsTokenAttr == null) {</span>
<span class="nc" id="L488">            hasTimestamp = false;</span>
<span class="nc" id="L489">            return null;</span>
        }

<span class="nc" id="L492">        PKCS7 tsToken = new PKCS7((byte[])tsTokenAttr.getValue());</span>
        // Extract the content (an encoded timestamp token info)
<span class="nc" id="L494">        byte[] encTsTokenInfo = tsToken.getContentInfo().getData();</span>
        // Extract the signer (the Timestamping Authority)
        // while verifying the content
<span class="nc" id="L497">        SignerInfo[] tsa = tsToken.verify(encTsTokenInfo);</span>
        // Expect only one signer
<span class="nc" id="L499">        ArrayList&lt;X509Certificate&gt; chain = tsa[0].getCertificateChain(tsToken);</span>
<span class="nc" id="L500">        CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
<span class="nc" id="L501">        CertPath tsaChain = cf.generateCertPath(chain);</span>
        // Create a timestamp token info object
<span class="nc" id="L503">        TimestampToken tsTokenInfo = new TimestampToken(encTsTokenInfo);</span>
        // Check that the signature timestamp applies to this signature
<span class="nc" id="L505">        verifyTimestamp(tsTokenInfo);</span>
        // Create a timestamp object
<span class="nc" id="L507">        timestamp = new Timestamp(tsTokenInfo.getDate(), tsaChain);</span>
<span class="nc" id="L508">        return timestamp;</span>
    }

    /*
     * Check that the signature timestamp applies to this signature.
     * Match the hash present in the signature timestamp token against the hash
     * of this signature.
     */
    private void verifyTimestamp(TimestampToken token)
        throws NoSuchAlgorithmException, SignatureException {

<span class="nc" id="L519">        MessageDigest md =</span>
<span class="nc" id="L520">            MessageDigest.getInstance(token.getHashAlgorithm().getName());</span>

<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (!Arrays.equals(token.getHashedMessage(),</span>
<span class="nc" id="L523">            md.digest(encryptedDigest))) {</span>

<span class="nc" id="L525">            throw new SignatureException(&quot;Signature timestamp (#&quot; +</span>
<span class="nc" id="L526">                token.getSerialNumber() + &quot;) generated on &quot; + token.getDate() +</span>
                &quot; is inapplicable&quot;);
        }

<span class="nc bnc" id="L530" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L531">            debug.println();</span>
<span class="nc" id="L532">            debug.println(&quot;Detected signature timestamp (#&quot; +</span>
<span class="nc" id="L533">                token.getSerialNumber() + &quot;) generated on &quot; + token.getDate());</span>
<span class="nc" id="L534">            debug.println();</span>
        }
<span class="nc" id="L536">    }</span>

    public String toString() {
<span class="nc" id="L539">        HexDumpEncoder hexDump = new HexDumpEncoder();</span>

<span class="nc" id="L541">        String out = &quot;&quot;;</span>

<span class="nc" id="L543">        out += &quot;Signer Info for (issuer): &quot; + issuerName + &quot;\n&quot;;</span>
<span class="nc" id="L544">        out += &quot;\tversion: &quot; + Debug.toHexString(version) + &quot;\n&quot;;</span>
<span class="nc" id="L545">        out += &quot;\tcertificateSerialNumber: &quot; +</span>
<span class="nc" id="L546">               Debug.toHexString(certificateSerialNumber) + &quot;\n&quot;;</span>
<span class="nc" id="L547">        out += &quot;\tdigestAlgorithmId: &quot; + digestAlgorithmId + &quot;\n&quot;;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">        if (authenticatedAttributes != null) {</span>
<span class="nc" id="L549">            out += &quot;\tauthenticatedAttributes: &quot; + authenticatedAttributes +</span>
                   &quot;\n&quot;;
        }
<span class="nc" id="L552">        out += &quot;\tdigestEncryptionAlgorithmId: &quot; + digestEncryptionAlgorithmId +</span>
            &quot;\n&quot;;

<span class="nc" id="L555">        out += &quot;\tencryptedDigest: &quot; + &quot;\n&quot; +</span>
<span class="nc" id="L556">            hexDump.encodeBuffer(encryptedDigest) + &quot;\n&quot;;</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">        if (unauthenticatedAttributes != null) {</span>
<span class="nc" id="L558">            out += &quot;\tunauthenticatedAttributes: &quot; +</span>
                   unauthenticatedAttributes + &quot;\n&quot;;
        }
<span class="nc" id="L561">        return out;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>