<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PKCS9Attribute.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.pkcs</a> &gt; <span class="el_source">PKCS9Attribute.java</span></div><h1>PKCS9Attribute.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.pkcs;

import java.io.IOException;
import java.io.OutputStream;
import java.security.cert.CertificateException;
import java.util.Locale;
import java.util.Date;
import java.util.Hashtable;
import sun.security.x509.CertificateExtensions;
import sun.security.util.Debug;
import sun.security.util.DerEncoder;
import sun.security.util.DerValue;
import sun.security.util.DerInputStream;
import sun.security.util.DerOutputStream;
import sun.security.util.ObjectIdentifier;
import sun.misc.HexDumpEncoder;

/**
 * Class supporting any PKCS9 attributes.
 * Supports DER decoding/encoding and access to attribute values.
 *
 * &lt;a name=&quot;classTable&quot;&gt;&lt;h3&gt;Type/Class Table&lt;/h3&gt;&lt;/a&gt;
 * The following table shows the correspondence between
 * PKCS9 attribute types and value component classes.
 * For types not listed here, its name is the OID
 * in string form, its value is a (single-valued)
 * byte array that is the SET's encoding.
 *
 * &lt;P&gt;
 * &lt;TABLE BORDER CELLPADDING=8 ALIGN=CENTER&gt;
 *
 * &lt;TR&gt;
 * &lt;TH&gt;Object Identifier&lt;/TH&gt;
 * &lt;TH&gt;Attribute Name&lt;/TH&gt;
 * &lt;TH&gt;Type&lt;/TH&gt;
 * &lt;TH&gt;Value Class&lt;/TH&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.1&lt;/TD&gt;
 * &lt;TD&gt;EmailAddress&lt;/TD&gt;
 * &lt;TD&gt;Multi-valued&lt;/TD&gt;
 * &lt;TD&gt;&lt;code&gt;String[]&lt;/code&gt;&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.2&lt;/TD&gt;
 * &lt;TD&gt;UnstructuredName&lt;/TD&gt;
 * &lt;TD&gt;Multi-valued&lt;/TD&gt;
 * &lt;TD&gt;&lt;code&gt;String[]&lt;/code&gt;&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.3&lt;/TD&gt;
 * &lt;TD&gt;ContentType&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;&lt;code&gt;ObjectIdentifier&lt;/code&gt;&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.4&lt;/TD&gt;
 * &lt;TD&gt;MessageDigest&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;&lt;code&gt;byte[]&lt;/code&gt;&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.5&lt;/TD&gt;
 * &lt;TD&gt;SigningTime&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.6&lt;/TD&gt;
 * &lt;TD&gt;Countersignature&lt;/TD&gt;
 * &lt;TD&gt;Multi-valued&lt;/TD&gt;
 * &lt;TD&gt;&lt;code&gt;SignerInfo[]&lt;/code&gt;&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.7&lt;/TD&gt;
 * &lt;TD&gt;ChallengePassword&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;&lt;code&gt;String&lt;/code&gt;&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.8&lt;/TD&gt;
 * &lt;TD&gt;UnstructuredAddress&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;&lt;code&gt;String&lt;/code&gt;&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.9&lt;/TD&gt;
 * &lt;TD&gt;ExtendedCertificateAttributes&lt;/TD&gt;
 * &lt;TD&gt;Multi-valued&lt;/TD&gt;
 * &lt;TD&gt;(not supported)&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.10&lt;/TD&gt;
 * &lt;TD&gt;IssuerAndSerialNumber&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;(not supported)&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.{11,12}&lt;/TD&gt;
 * &lt;TD&gt;RSA DSI proprietary&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;(not supported)&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.13&lt;/TD&gt;
 * &lt;TD&gt;S/MIME unused assignment&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;(not supported)&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.14&lt;/TD&gt;
 * &lt;TD&gt;ExtensionRequest&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;CertificateExtensions&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.15&lt;/TD&gt;
 * &lt;TD&gt;SMIMECapability&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;(not supported)&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.16.2.12&lt;/TD&gt;
 * &lt;TD&gt;SigningCertificate&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;SigningCertificateInfo&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;TR&gt;
 * &lt;TD&gt;1.2.840.113549.1.9.16.2.14&lt;/TD&gt;
 * &lt;TD&gt;SignatureTimestampToken&lt;/TD&gt;
 * &lt;TD&gt;Single-valued&lt;/TD&gt;
 * &lt;TD&gt;byte[]&lt;/TD&gt;
 * &lt;/TR&gt;
 *
 * &lt;/TABLE&gt;
 *
 * @author Douglas Hoover
 */
public class PKCS9Attribute implements DerEncoder {

    /* Are we debugging ? */
<span class="fc" id="L183">    private static final Debug debug = Debug.getInstance(&quot;jar&quot;);</span>

    /**
     * Array of attribute OIDs defined in PKCS9, by number.
     */
<span class="fc" id="L188">    static final ObjectIdentifier[] PKCS9_OIDS = new ObjectIdentifier[18];</span>

    private final static Class&lt;?&gt; BYTE_ARRAY_CLASS;

    static {   // static initializer for PKCS9_OIDS
<span class="fc bfc" id="L193" title="All 2 branches covered.">        for (int i = 1; i &lt; PKCS9_OIDS.length - 2; i++) {</span>
<span class="fc" id="L194">            PKCS9_OIDS[i] =</span>
<span class="fc" id="L195">                ObjectIdentifier.newInternal(new int[]{1,2,840,113549,1,9,i});</span>
        }
        // Initialize SigningCertificate and SignatureTimestampToken
        // separately (because their values are out of sequence)
<span class="fc" id="L199">        PKCS9_OIDS[PKCS9_OIDS.length - 2] =</span>
<span class="fc" id="L200">            ObjectIdentifier.newInternal(new int[]{1,2,840,113549,1,9,16,2,12});</span>
<span class="fc" id="L201">        PKCS9_OIDS[PKCS9_OIDS.length - 1] =</span>
<span class="fc" id="L202">            ObjectIdentifier.newInternal(new int[]{1,2,840,113549,1,9,16,2,14});</span>

        try {
<span class="fc" id="L205">            BYTE_ARRAY_CLASS = Class.forName(&quot;[B&quot;);</span>
<span class="nc" id="L206">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L207">            throw new ExceptionInInitializerError(e.toString());</span>
<span class="fc" id="L208">        }</span>
    }

    // first element [0] not used
<span class="fc" id="L212">    public static final ObjectIdentifier EMAIL_ADDRESS_OID = PKCS9_OIDS[1];</span>
<span class="fc" id="L213">    public static final ObjectIdentifier UNSTRUCTURED_NAME_OID = PKCS9_OIDS[2];</span>
<span class="fc" id="L214">    public static final ObjectIdentifier CONTENT_TYPE_OID = PKCS9_OIDS[3];</span>
<span class="fc" id="L215">    public static final ObjectIdentifier MESSAGE_DIGEST_OID = PKCS9_OIDS[4];</span>
<span class="fc" id="L216">    public static final ObjectIdentifier SIGNING_TIME_OID = PKCS9_OIDS[5];</span>
<span class="fc" id="L217">    public static final ObjectIdentifier COUNTERSIGNATURE_OID = PKCS9_OIDS[6];</span>
<span class="fc" id="L218">    public static final ObjectIdentifier CHALLENGE_PASSWORD_OID = PKCS9_OIDS[7];</span>
<span class="fc" id="L219">    public static final ObjectIdentifier UNSTRUCTURED_ADDRESS_OID = PKCS9_OIDS[8];</span>
<span class="fc" id="L220">    public static final ObjectIdentifier EXTENDED_CERTIFICATE_ATTRIBUTES_OID</span>
                                         = PKCS9_OIDS[9];
<span class="fc" id="L222">    public static final ObjectIdentifier ISSUER_SERIALNUMBER_OID = PKCS9_OIDS[10];</span>
    // [11], [12] are RSA DSI proprietary
    // [13] ==&gt; signingDescription, S/MIME, not used anymore
<span class="fc" id="L225">    public static final ObjectIdentifier EXTENSION_REQUEST_OID = PKCS9_OIDS[14];</span>
<span class="fc" id="L226">    public static final ObjectIdentifier SMIME_CAPABILITY_OID = PKCS9_OIDS[15];</span>
<span class="fc" id="L227">    public static final ObjectIdentifier SIGNING_CERTIFICATE_OID = PKCS9_OIDS[16];</span>
<span class="fc" id="L228">    public static final ObjectIdentifier SIGNATURE_TIMESTAMP_TOKEN_OID =</span>
                                PKCS9_OIDS[17];
    public static final String EMAIL_ADDRESS_STR = &quot;EmailAddress&quot;;
    public static final String UNSTRUCTURED_NAME_STR = &quot;UnstructuredName&quot;;
    public static final String CONTENT_TYPE_STR = &quot;ContentType&quot;;
    public static final String MESSAGE_DIGEST_STR = &quot;MessageDigest&quot;;
    public static final String SIGNING_TIME_STR = &quot;SigningTime&quot;;
    public static final String COUNTERSIGNATURE_STR = &quot;Countersignature&quot;;
    public static final String CHALLENGE_PASSWORD_STR = &quot;ChallengePassword&quot;;
    public static final String UNSTRUCTURED_ADDRESS_STR = &quot;UnstructuredAddress&quot;;
    public static final String EXTENDED_CERTIFICATE_ATTRIBUTES_STR =
                               &quot;ExtendedCertificateAttributes&quot;;
    public static final String ISSUER_SERIALNUMBER_STR = &quot;IssuerAndSerialNumber&quot;;
    // [11], [12] are RSA DSI proprietary
    private static final String RSA_PROPRIETARY_STR = &quot;RSAProprietary&quot;;
    // [13] ==&gt; signingDescription, S/MIME, not used anymore
    private static final String SMIME_SIGNING_DESC_STR = &quot;SMIMESigningDesc&quot;;
    public static final String EXTENSION_REQUEST_STR = &quot;ExtensionRequest&quot;;
    public static final String SMIME_CAPABILITY_STR = &quot;SMIMECapability&quot;;
    public static final String SIGNING_CERTIFICATE_STR = &quot;SigningCertificate&quot;;
    public static final String SIGNATURE_TIMESTAMP_TOKEN_STR =
                                &quot;SignatureTimestampToken&quot;;

    /**
     * Hashtable mapping names and variant names of supported
     * attributes to their OIDs. This table contains all name forms
     * that occur in PKCS9, in lower case.
     */
<span class="fc" id="L256">    private static final Hashtable&lt;String, ObjectIdentifier&gt; NAME_OID_TABLE =</span>
        new Hashtable&lt;String, ObjectIdentifier&gt;(18);

    static { // static initializer for PCKS9_NAMES
<span class="fc" id="L260">        NAME_OID_TABLE.put(&quot;emailaddress&quot;, PKCS9_OIDS[1]);</span>
<span class="fc" id="L261">        NAME_OID_TABLE.put(&quot;unstructuredname&quot;, PKCS9_OIDS[2]);</span>
<span class="fc" id="L262">        NAME_OID_TABLE.put(&quot;contenttype&quot;, PKCS9_OIDS[3]);</span>
<span class="fc" id="L263">        NAME_OID_TABLE.put(&quot;messagedigest&quot;, PKCS9_OIDS[4]);</span>
<span class="fc" id="L264">        NAME_OID_TABLE.put(&quot;signingtime&quot;, PKCS9_OIDS[5]);</span>
<span class="fc" id="L265">        NAME_OID_TABLE.put(&quot;countersignature&quot;, PKCS9_OIDS[6]);</span>
<span class="fc" id="L266">        NAME_OID_TABLE.put(&quot;challengepassword&quot;, PKCS9_OIDS[7]);</span>
<span class="fc" id="L267">        NAME_OID_TABLE.put(&quot;unstructuredaddress&quot;, PKCS9_OIDS[8]);</span>
<span class="fc" id="L268">        NAME_OID_TABLE.put(&quot;extendedcertificateattributes&quot;, PKCS9_OIDS[9]);</span>
<span class="fc" id="L269">        NAME_OID_TABLE.put(&quot;issuerandserialnumber&quot;, PKCS9_OIDS[10]);</span>
<span class="fc" id="L270">        NAME_OID_TABLE.put(&quot;rsaproprietary&quot;, PKCS9_OIDS[11]);</span>
<span class="fc" id="L271">        NAME_OID_TABLE.put(&quot;rsaproprietary&quot;, PKCS9_OIDS[12]);</span>
<span class="fc" id="L272">        NAME_OID_TABLE.put(&quot;signingdescription&quot;, PKCS9_OIDS[13]);</span>
<span class="fc" id="L273">        NAME_OID_TABLE.put(&quot;extensionrequest&quot;, PKCS9_OIDS[14]);</span>
<span class="fc" id="L274">        NAME_OID_TABLE.put(&quot;smimecapability&quot;, PKCS9_OIDS[15]);</span>
<span class="fc" id="L275">        NAME_OID_TABLE.put(&quot;signingcertificate&quot;, PKCS9_OIDS[16]);</span>
<span class="fc" id="L276">        NAME_OID_TABLE.put(&quot;signaturetimestamptoken&quot;, PKCS9_OIDS[17]);</span>
    };

    /**
     * Hashtable mapping attribute OIDs defined in PKCS9 to the
     * corresponding attribute value type.
     */
<span class="fc" id="L283">    private static final Hashtable&lt;ObjectIdentifier, String&gt; OID_NAME_TABLE =</span>
        new Hashtable&lt;ObjectIdentifier, String&gt;(16);
    static {
<span class="fc" id="L286">        OID_NAME_TABLE.put(PKCS9_OIDS[1], EMAIL_ADDRESS_STR);</span>
<span class="fc" id="L287">        OID_NAME_TABLE.put(PKCS9_OIDS[2], UNSTRUCTURED_NAME_STR);</span>
<span class="fc" id="L288">        OID_NAME_TABLE.put(PKCS9_OIDS[3], CONTENT_TYPE_STR);</span>
<span class="fc" id="L289">        OID_NAME_TABLE.put(PKCS9_OIDS[4], MESSAGE_DIGEST_STR);</span>
<span class="fc" id="L290">        OID_NAME_TABLE.put(PKCS9_OIDS[5], SIGNING_TIME_STR);</span>
<span class="fc" id="L291">        OID_NAME_TABLE.put(PKCS9_OIDS[6], COUNTERSIGNATURE_STR);</span>
<span class="fc" id="L292">        OID_NAME_TABLE.put(PKCS9_OIDS[7], CHALLENGE_PASSWORD_STR);</span>
<span class="fc" id="L293">        OID_NAME_TABLE.put(PKCS9_OIDS[8], UNSTRUCTURED_ADDRESS_STR);</span>
<span class="fc" id="L294">        OID_NAME_TABLE.put(PKCS9_OIDS[9], EXTENDED_CERTIFICATE_ATTRIBUTES_STR);</span>
<span class="fc" id="L295">        OID_NAME_TABLE.put(PKCS9_OIDS[10], ISSUER_SERIALNUMBER_STR);</span>
<span class="fc" id="L296">        OID_NAME_TABLE.put(PKCS9_OIDS[11], RSA_PROPRIETARY_STR);</span>
<span class="fc" id="L297">        OID_NAME_TABLE.put(PKCS9_OIDS[12], RSA_PROPRIETARY_STR);</span>
<span class="fc" id="L298">        OID_NAME_TABLE.put(PKCS9_OIDS[13], SMIME_SIGNING_DESC_STR);</span>
<span class="fc" id="L299">        OID_NAME_TABLE.put(PKCS9_OIDS[14], EXTENSION_REQUEST_STR);</span>
<span class="fc" id="L300">        OID_NAME_TABLE.put(PKCS9_OIDS[15], SMIME_CAPABILITY_STR);</span>
<span class="fc" id="L301">        OID_NAME_TABLE.put(PKCS9_OIDS[16], SIGNING_CERTIFICATE_STR);</span>
<span class="fc" id="L302">        OID_NAME_TABLE.put(PKCS9_OIDS[17], SIGNATURE_TIMESTAMP_TOKEN_STR);</span>
    }

    /**
     * Acceptable ASN.1 tags for DER encodings of values of PKCS9
     * attributes, by index in &lt;code&gt;PKCS9_OIDS&lt;/code&gt;.
     * Sets of acceptable tags are represented as arrays.
     */
<span class="fc" id="L310">    private static final Byte[][] PKCS9_VALUE_TAGS = {</span>
        null,
        {new Byte(DerValue.tag_IA5String)},   // EMailAddress
        {new Byte(DerValue.tag_IA5String),   // UnstructuredName
         new Byte(DerValue.tag_PrintableString)},
        {new Byte(DerValue.tag_ObjectId)},    // ContentType
        {new Byte(DerValue.tag_OctetString)}, // MessageDigest
        {new Byte(DerValue.tag_UtcTime)},     // SigningTime
        {new Byte(DerValue.tag_Sequence)},    // Countersignature
        {new Byte(DerValue.tag_PrintableString),
         new Byte(DerValue.tag_T61String)},   // ChallengePassword
        {new Byte(DerValue.tag_PrintableString),
         new Byte(DerValue.tag_T61String)},   // UnstructuredAddress
        {new Byte(DerValue.tag_SetOf)},       // ExtendedCertificateAttributes
        {new Byte(DerValue.tag_Sequence)},    // issuerAndSerialNumber
        null,
        null,
        null,
        {new Byte(DerValue.tag_Sequence)},    // extensionRequest
        {new Byte(DerValue.tag_Sequence)},    // SMIMECapability
        {new Byte(DerValue.tag_Sequence)},    // SigningCertificate
        {new Byte(DerValue.tag_Sequence)}     // SignatureTimestampToken
    };

<span class="fc" id="L334">    private static final Class&lt;?&gt;[] VALUE_CLASSES = new Class&lt;?&gt;[18];</span>

    static {
        try {
<span class="fc" id="L338">            Class&lt;?&gt; str = Class.forName(&quot;[Ljava.lang.String;&quot;);</span>

<span class="fc" id="L340">            VALUE_CLASSES[0] = null;  // not used</span>
<span class="fc" id="L341">            VALUE_CLASSES[1] = str;   // EMailAddress</span>
<span class="fc" id="L342">            VALUE_CLASSES[2] = str;   // UnstructuredName</span>
<span class="fc" id="L343">            VALUE_CLASSES[3] =        // ContentType</span>
<span class="fc" id="L344">                Class.forName(&quot;sun.security.util.ObjectIdentifier&quot;);</span>
<span class="fc" id="L345">            VALUE_CLASSES[4] = BYTE_ARRAY_CLASS; // MessageDigest (byte[])</span>
<span class="fc" id="L346">            VALUE_CLASSES[5] = Class.forName(&quot;java.util.Date&quot;); // SigningTime</span>
<span class="fc" id="L347">            VALUE_CLASSES[6] =        // Countersignature</span>
<span class="fc" id="L348">                Class.forName(&quot;[Lsun.security.pkcs.SignerInfo;&quot;);</span>
<span class="fc" id="L349">            VALUE_CLASSES[7] =        // ChallengePassword</span>
<span class="fc" id="L350">                Class.forName(&quot;java.lang.String&quot;);</span>
<span class="fc" id="L351">            VALUE_CLASSES[8] = str;   // UnstructuredAddress</span>
<span class="fc" id="L352">            VALUE_CLASSES[9] = null;  // ExtendedCertificateAttributes</span>
<span class="fc" id="L353">            VALUE_CLASSES[10] = null;  // IssuerAndSerialNumber</span>
<span class="fc" id="L354">            VALUE_CLASSES[11] = null;  // not used</span>
<span class="fc" id="L355">            VALUE_CLASSES[12] = null;  // not used</span>
<span class="fc" id="L356">            VALUE_CLASSES[13] = null;  // not used</span>
<span class="fc" id="L357">            VALUE_CLASSES[14] =        // ExtensionRequest</span>
<span class="fc" id="L358">                Class.forName(&quot;sun.security.x509.CertificateExtensions&quot;);</span>
<span class="fc" id="L359">            VALUE_CLASSES[15] = null;  // not supported yet</span>
<span class="fc" id="L360">            VALUE_CLASSES[16] = null;  // not supported yet</span>
<span class="fc" id="L361">            VALUE_CLASSES[17] = BYTE_ARRAY_CLASS;  // SignatureTimestampToken</span>
<span class="nc" id="L362">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L363">            throw new ExceptionInInitializerError(e.toString());</span>
<span class="fc" id="L364">        }</span>
    }

    /**
     * Array indicating which PKCS9 attributes are single-valued,
     * by index in &lt;code&gt;PKCS9_OIDS&lt;/code&gt;.
     */
<span class="fc" id="L371">    private static final boolean[] SINGLE_VALUED = {</span>
      false,
      false,   // EMailAddress
      false,   // UnstructuredName
      true,    // ContentType
      true,    // MessageDigest
      true,    // SigningTime
      false,   // Countersignature
      true,    // ChallengePassword
      false,   // UnstructuredAddress
      false,   // ExtendedCertificateAttributes
      true,    // IssuerAndSerialNumber - not supported yet
      false,   // not used
      false,   // not used
      false,   // not used
      true,    // ExtensionRequest
      true,    // SMIMECapability - not supported yet
      true,    // SigningCertificate
      true     // SignatureTimestampToken
    };

    /**
     * The OID of this attribute.
     */
    private ObjectIdentifier oid;

    /**
     * The index of the OID of this attribute in &lt;code&gt;PKCS9_OIDS&lt;/code&gt;,
     * or -1 if it's unknown.
     */
    private int index;

    /**
     * Value set of this attribute.  Its class is given by
     * &lt;code&gt;VALUE_CLASSES[index]&lt;/code&gt;. The SET itself
     * as byte[] if unknown.
     */
    private Object value;

    /**
     * Construct an attribute object from the attribute's OID and
     * value.  If the attribute is single-valued, provide only one
     * value.  If the attribute is multi-valued, provide an array
     * containing all the values.
     * Arrays of length zero are accepted, though probably useless.
     *
     * &lt;P&gt; The
     * &lt;a href=#classTable&gt;table&lt;/a&gt; gives the class that &lt;code&gt;value&lt;/code&gt;
     * must have for a given attribute.
     *
     * @exception IllegalArgumentException
     * if the &lt;code&gt;value&lt;/code&gt; has the wrong type.
     */
    public PKCS9Attribute(ObjectIdentifier oid, Object value)
<span class="nc" id="L425">    throws IllegalArgumentException {</span>
<span class="nc" id="L426">        init(oid, value);</span>
<span class="nc" id="L427">    }</span>

    /**
     * Construct an attribute object from the attribute's name and
     * value.  If the attribute is single-valued, provide only one
     * value.  If the attribute is multi-valued, provide an array
     * containing all the values.
     * Arrays of length zero are accepted, though probably useless.
     *
     * &lt;P&gt; The
     * &lt;a href=#classTable&gt;table&lt;/a&gt; gives the class that &lt;code&gt;value&lt;/code&gt;
     * must have for a given attribute. Reasonable variants of these
     * attributes are accepted; in particular, case does not matter.
     *
     * @exception IllegalArgumentException
     * if the &lt;code&gt;name&lt;/code&gt; is not recognized or the
     * &lt;code&gt;value&lt;/code&gt; has the wrong type.
     */
    public PKCS9Attribute(String name, Object value)
<span class="nc" id="L446">    throws IllegalArgumentException {</span>
<span class="nc" id="L447">        ObjectIdentifier oid = getOID(name);</span>

<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (oid == null)</span>
<span class="nc" id="L450">            throw new IllegalArgumentException(</span>
                       &quot;Unrecognized attribute name &quot; + name +
                       &quot; constructing PKCS9Attribute.&quot;);

<span class="nc" id="L454">        init(oid, value);</span>
<span class="nc" id="L455">    }</span>

    private void init(ObjectIdentifier oid, Object value)
        throws IllegalArgumentException {

<span class="nc" id="L460">        this.oid = oid;</span>
<span class="nc" id="L461">        index = indexOf(oid, PKCS9_OIDS, 1);</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        Class&lt;?&gt; clazz = index == -1 ? BYTE_ARRAY_CLASS: VALUE_CLASSES[index];</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (!clazz.isInstance(value)) {</span>
<span class="nc" id="L464">                throw new IllegalArgumentException(</span>
                           &quot;Wrong value class &quot; +
                           &quot; for attribute &quot; + oid +
                           &quot; constructing PKCS9Attribute; was &quot; +
<span class="nc" id="L468">                           value.getClass().toString() + &quot;, should be &quot; +</span>
<span class="nc" id="L469">                           clazz.toString());</span>
        }
<span class="nc" id="L471">        this.value = value;</span>
<span class="nc" id="L472">    }</span>


    /**
     * Construct a PKCS9Attribute from its encoding on an input
     * stream.
     *
     * @param val the DerValue representing the DER encoding of the attribute.
     * @exception IOException on parsing error.
     */
<span class="nc" id="L482">    public PKCS9Attribute(DerValue derVal) throws IOException {</span>

<span class="nc" id="L484">        DerInputStream derIn = new DerInputStream(derVal.toByteArray());</span>
<span class="nc" id="L485">        DerValue[] val =  derIn.getSequence(2);</span>

<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (derIn.available() != 0)</span>
<span class="nc" id="L488">            throw new IOException(&quot;Excess data parsing PKCS9Attribute&quot;);</span>

<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (val.length != 2)</span>
<span class="nc" id="L491">            throw new IOException(&quot;PKCS9Attribute doesn't have two components&quot;);</span>

        // get the oid
<span class="nc" id="L494">        oid = val[0].getOID();</span>
<span class="nc" id="L495">        byte[] content = val[1].toByteArray();</span>
<span class="nc" id="L496">        DerValue[] elems = new DerInputStream(content).getSet(1);</span>

<span class="nc" id="L498">        index = indexOf(oid, PKCS9_OIDS, 1);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (index == -1) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L501">                debug.println(&quot;Unsupported signer attribute: &quot; + oid);</span>
            }
<span class="nc" id="L503">            value = content;</span>
<span class="nc" id="L504">            return;</span>
        }

        // check single valued have only one value
<span class="nc bnc" id="L508" title="All 4 branches missed.">        if (SINGLE_VALUED[index] &amp;&amp; elems.length &gt; 1)</span>
<span class="nc" id="L509">            throwSingleValuedException();</span>

        // check for illegal element tags
        Byte tag;
<span class="nc bnc" id="L513" title="All 2 branches missed.">        for (int i=0; i &lt; elems.length; i++) {</span>
<span class="nc" id="L514">            tag = new Byte(elems[i].tag);</span>

<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (indexOf(tag, PKCS9_VALUE_TAGS[index], 0) == -1)</span>
<span class="nc" id="L517">                throwTagException(tag);</span>
        }

<span class="nc bnc" id="L520" title="All 15 branches missed.">        switch (index) {</span>
        case 1:     // email address
        case 2:     // unstructured name
        case 8:     // unstructured address
            { // open scope
<span class="nc" id="L525">                String[] values = new String[elems.length];</span>

<span class="nc bnc" id="L527" title="All 2 branches missed.">                for (int i=0; i &lt; elems.length; i++)</span>
<span class="nc" id="L528">                    values[i] = elems[i].getAsString();</span>
<span class="nc" id="L529">                value = values;</span>
            } // close scope
<span class="nc" id="L531">            break;</span>

        case 3:     // content type
<span class="nc" id="L534">            value = elems[0].getOID();</span>
<span class="nc" id="L535">            break;</span>

        case 4:     // message digest
<span class="nc" id="L538">            value = elems[0].getOctetString();</span>
<span class="nc" id="L539">            break;</span>

        case 5:     // signing time
<span class="nc" id="L542">            value = (new DerInputStream(elems[0].toByteArray())).getUTCTime();</span>
<span class="nc" id="L543">            break;</span>

        case 6:     // countersignature
            { // open scope
<span class="nc" id="L547">                SignerInfo[] values = new SignerInfo[elems.length];</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                for (int i=0; i &lt; elems.length; i++)</span>
<span class="nc" id="L549">                    values[i] =</span>
<span class="nc" id="L550">                        new SignerInfo(elems[i].toDerInputStream());</span>
<span class="nc" id="L551">                value = values;</span>
            } // close scope
<span class="nc" id="L553">            break;</span>

        case 7:     // challenge password
<span class="nc" id="L556">            value = elems[0].getAsString();</span>
<span class="nc" id="L557">            break;</span>

        case 9:     // extended-certificate attribute -- not supported
<span class="nc" id="L560">            throw new IOException(&quot;PKCS9 extended-certificate &quot; +</span>
                                  &quot;attribute not supported.&quot;);
            // break unnecessary
        case 10:    // issuerAndserialNumber attribute -- not supported
<span class="nc" id="L564">            throw new IOException(&quot;PKCS9 IssuerAndSerialNumber&quot; +</span>
                                  &quot;attribute not supported.&quot;);
            // break unnecessary
        case 11:    // RSA DSI proprietary
        case 12:    // RSA DSI proprietary
<span class="nc" id="L569">            throw new IOException(&quot;PKCS9 RSA DSI attributes&quot; +</span>
                                  &quot;11 and 12, not supported.&quot;);
            // break unnecessary
        case 13:    // S/MIME unused attribute
<span class="nc" id="L573">            throw new IOException(&quot;PKCS9 attribute #13 not supported.&quot;);</span>
            // break unnecessary

        case 14:     // ExtensionRequest
<span class="nc" id="L577">            value = new CertificateExtensions(</span>
<span class="nc" id="L578">                       new DerInputStream(elems[0].toByteArray()));</span>
<span class="nc" id="L579">            break;</span>

        case 15:     // SMIME-capability attribute -- not supported
<span class="nc" id="L582">            throw new IOException(&quot;PKCS9 SMIMECapability &quot; +</span>
                                  &quot;attribute not supported.&quot;);
            // break unnecessary
        case 16:     // SigningCertificate attribute
<span class="nc" id="L586">            value = new SigningCertificateInfo(elems[0].toByteArray());</span>
<span class="nc" id="L587">            break;</span>

        case 17:     // SignatureTimestampToken attribute
<span class="nc" id="L590">            value = elems[0].toByteArray();</span>
<span class="nc" id="L591">            break;</span>
        default: // can't happen
        }
<span class="nc" id="L594">    }</span>

    /**
     * Write the DER encoding of this attribute to an output stream.
     *
     * &lt;P&gt; N.B.: This method always encodes values of
     * ChallengePassword and UnstructuredAddress attributes as ASN.1
     * &lt;code&gt;PrintableString&lt;/code&gt;s, without checking whether they
     * should be encoded as &lt;code&gt;T61String&lt;/code&gt;s.
     */
    public void derEncode(OutputStream out) throws IOException {
<span class="nc" id="L605">        DerOutputStream temp = new DerOutputStream();</span>
<span class="nc" id="L606">        temp.putOID(oid);</span>
<span class="nc bnc" id="L607" title="All 17 branches missed.">        switch (index) {</span>
        case -1:    // Unknown
<span class="nc" id="L609">            temp.write((byte[])value);</span>
<span class="nc" id="L610">            break;</span>
        case 1:     // email address
        case 2:     // unstructured name
            { // open scope
<span class="nc" id="L614">                String[] values = (String[]) value;</span>
<span class="nc" id="L615">                DerOutputStream[] temps = new</span>
                    DerOutputStream[values.length];

<span class="nc bnc" id="L618" title="All 2 branches missed.">                for (int i=0; i &lt; values.length; i++) {</span>
<span class="nc" id="L619">                    temps[i] = new DerOutputStream();</span>
<span class="nc" id="L620">                    temps[i].putIA5String( values[i]);</span>
                }
<span class="nc" id="L622">                temp.putOrderedSetOf(DerValue.tag_Set, temps);</span>
            } // close scope
<span class="nc" id="L624">            break;</span>

        case 3:     // content type
            {
<span class="nc" id="L628">                DerOutputStream temp2 = new DerOutputStream();</span>
<span class="nc" id="L629">                temp2.putOID((ObjectIdentifier) value);</span>
<span class="nc" id="L630">                temp.write(DerValue.tag_Set, temp2.toByteArray());</span>
            }
<span class="nc" id="L632">            break;</span>

        case 4:     // message digest
            {
<span class="nc" id="L636">                DerOutputStream temp2 = new DerOutputStream();</span>
<span class="nc" id="L637">                temp2.putOctetString((byte[]) value);</span>
<span class="nc" id="L638">                temp.write(DerValue.tag_Set, temp2.toByteArray());</span>
            }
<span class="nc" id="L640">            break;</span>

        case 5:     // signing time
            {
<span class="nc" id="L644">                DerOutputStream temp2 = new DerOutputStream();</span>
<span class="nc" id="L645">                temp2.putUTCTime((Date) value);</span>
<span class="nc" id="L646">                temp.write(DerValue.tag_Set, temp2.toByteArray());</span>
            }
<span class="nc" id="L648">            break;</span>

        case 6:     // countersignature
<span class="nc" id="L651">            temp.putOrderedSetOf(DerValue.tag_Set, (DerEncoder[]) value);</span>
<span class="nc" id="L652">            break;</span>

        case 7:     // challenge password
            {
<span class="nc" id="L656">                DerOutputStream temp2 = new DerOutputStream();</span>
<span class="nc" id="L657">                temp2.putPrintableString((String) value);</span>
<span class="nc" id="L658">                temp.write(DerValue.tag_Set, temp2.toByteArray());</span>
            }
<span class="nc" id="L660">            break;</span>

        case 8:     // unstructured address
            { // open scope
<span class="nc" id="L664">                String[] values = (String[]) value;</span>
<span class="nc" id="L665">                DerOutputStream[] temps = new</span>
                    DerOutputStream[values.length];

<span class="nc bnc" id="L668" title="All 2 branches missed.">                for (int i=0; i &lt; values.length; i++) {</span>
<span class="nc" id="L669">                    temps[i] = new DerOutputStream();</span>
<span class="nc" id="L670">                    temps[i].putPrintableString(values[i]);</span>
                }
<span class="nc" id="L672">                temp.putOrderedSetOf(DerValue.tag_Set, temps);</span>
            } // close scope
<span class="nc" id="L674">            break;</span>

        case 9:     // extended-certificate attribute -- not supported
<span class="nc" id="L677">            throw new IOException(&quot;PKCS9 extended-certificate &quot; +</span>
                                  &quot;attribute not supported.&quot;);
            // break unnecessary
        case 10:    // issuerAndserialNumber attribute -- not supported
<span class="nc" id="L681">            throw new IOException(&quot;PKCS9 IssuerAndSerialNumber&quot; +</span>
                                  &quot;attribute not supported.&quot;);
            // break unnecessary
        case 11:    // RSA DSI proprietary
        case 12:    // RSA DSI proprietary
<span class="nc" id="L686">            throw new IOException(&quot;PKCS9 RSA DSI attributes&quot; +</span>
                                  &quot;11 and 12, not supported.&quot;);
            // break unnecessary
        case 13:    // S/MIME unused attribute
<span class="nc" id="L690">            throw new IOException(&quot;PKCS9 attribute #13 not supported.&quot;);</span>
            // break unnecessary

        case 14:     // ExtensionRequest
            {
<span class="nc" id="L695">                DerOutputStream temp2 = new DerOutputStream();</span>
<span class="nc" id="L696">                CertificateExtensions exts = (CertificateExtensions)value;</span>
                try {
<span class="nc" id="L698">                    exts.encode(temp2, true);</span>
<span class="nc" id="L699">                } catch (CertificateException ex) {</span>
<span class="nc" id="L700">                    throw new IOException(ex.toString());</span>
<span class="nc" id="L701">                }</span>
<span class="nc" id="L702">                temp.write(DerValue.tag_Set, temp2.toByteArray());</span>
            }
<span class="nc" id="L704">            break;</span>
        case 15:    // SMIMECapability
<span class="nc" id="L706">            throw new IOException(&quot;PKCS9 attribute #15 not supported.&quot;);</span>
            // break unnecessary

        case 16:    // SigningCertificate
<span class="nc" id="L710">            throw new IOException(</span>
                &quot;PKCS9 SigningCertificate attribute not supported.&quot;);
            // break unnecessary

        case 17:    // SignatureTimestampToken
<span class="nc" id="L715">            temp.write(DerValue.tag_Set, (byte[])value);</span>
<span class="nc" id="L716">            break;</span>

        default: // can't happen
        }

<span class="nc" id="L721">        DerOutputStream derOut = new DerOutputStream();</span>
<span class="nc" id="L722">        derOut.write(DerValue.tag_Sequence, temp.toByteArray());</span>

<span class="nc" id="L724">        out.write(derOut.toByteArray());</span>

<span class="nc" id="L726">    }</span>

    /**
     * Returns if the attribute is known. Unknown attributes can be created
     * from DER encoding with unknown OIDs.
     */
    public boolean isKnown() {
<span class="nc bnc" id="L733" title="All 2 branches missed.">        return index != -1;</span>
    }

    /**
     * Get the value of this attribute.  If the attribute is
     * single-valued, return just the one value.  If the attribute is
     * multi-valued, return an array containing all the values.
     * It is possible for this array to be of length 0.
     *
     * &lt;P&gt; The
     * &lt;a href=#classTable&gt;table&lt;/a&gt; gives the class of the value returned,
     * depending on the type of this attribute.
     */
    public Object getValue() {
<span class="nc" id="L747">        return value;</span>
    }

    /**
     * Show whether this attribute is single-valued.
     */
    public boolean isSingleValued() {
<span class="nc bnc" id="L754" title="All 4 branches missed.">        return index == -1 || SINGLE_VALUED[index];</span>
    }

    /**
     *  Return the OID of this attribute.
     */
    public ObjectIdentifier getOID() {
<span class="nc" id="L761">        return oid;</span>
    }

    /**
     *  Return the name of this attribute.
     */
    public String getName() {
<span class="nc bnc" id="L768" title="All 2 branches missed.">        return index == -1 ?</span>
<span class="nc" id="L769">                oid.toString() :</span>
<span class="nc" id="L770">                OID_NAME_TABLE.get(PKCS9_OIDS[index]);</span>
    }

    /**
     * Return the OID for a given attribute name or null if we don't recognize
     * the name.
     */
    public static ObjectIdentifier getOID(String name) {
<span class="nc" id="L778">        return NAME_OID_TABLE.get(name.toLowerCase(Locale.ENGLISH));</span>
    }

    /**
     * Return the attribute name for a given OID or null if we don't recognize
     * the oid.
     */
    public static String getName(ObjectIdentifier oid) {
<span class="nc" id="L786">        return OID_NAME_TABLE.get(oid);</span>
    }

    /**
     * Returns a string representation of this attribute.
     */
    public String toString() {
<span class="nc" id="L793">        StringBuffer buf = new StringBuffer(100);</span>

<span class="nc" id="L795">        buf.append(&quot;[&quot;);</span>

<span class="nc bnc" id="L797" title="All 2 branches missed.">        if (index == -1) {</span>
<span class="nc" id="L798">            buf.append(oid.toString());</span>
        } else {
<span class="nc" id="L800">            buf.append(OID_NAME_TABLE.get(PKCS9_OIDS[index]));</span>
        }
<span class="nc" id="L802">        buf.append(&quot;: &quot;);</span>

<span class="nc bnc" id="L804" title="All 4 branches missed.">        if (index == -1 || SINGLE_VALUED[index]) {</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">            if (value instanceof byte[]) { // special case for octet string</span>
<span class="nc" id="L806">                HexDumpEncoder hexDump = new HexDumpEncoder();</span>
<span class="nc" id="L807">                buf.append(hexDump.encodeBuffer((byte[]) value));</span>
<span class="nc" id="L808">            } else {</span>
<span class="nc" id="L809">                buf.append(value.toString());</span>
            }
<span class="nc" id="L811">            buf.append(&quot;]&quot;);</span>
<span class="nc" id="L812">            return buf.toString();</span>
        } else { // multi-valued
<span class="nc" id="L814">            boolean first = true;</span>
<span class="nc" id="L815">            Object[] values = (Object[]) value;</span>

<span class="nc bnc" id="L817" title="All 2 branches missed.">            for (int j=0; j &lt; values.length; j++) {</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                if (first)</span>
<span class="nc" id="L819">                    first = false;</span>
                else
<span class="nc" id="L821">                    buf.append(&quot;, &quot;);</span>

<span class="nc" id="L823">                buf.append(values[j].toString());</span>
            }
<span class="nc" id="L825">            return buf.toString();</span>
        }
    }

    /**
     * Beginning the search at &lt;code&gt;start&lt;/code&gt;, find the first
     * index &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;a[i] = obj&lt;/code&gt;.
     *
     * @return the index, if found, and -1 otherwise.
     */
    static int indexOf(Object obj, Object[] a, int start) {
<span class="nc bnc" id="L836" title="All 2 branches missed.">        for (int i=start; i &lt; a.length; i++) {</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">            if (obj.equals(a[i])) return i;</span>
        }
<span class="nc" id="L839">        return -1;</span>
    }

    /**
     * Throw an exception when there are multiple values for
     * a single-valued attribute.
     */
    private void throwSingleValuedException() throws IOException {
<span class="nc" id="L847">        throw new IOException(&quot;Single-value attribute &quot; +</span>
<span class="nc" id="L848">                              oid + &quot; (&quot; + getName() + &quot;)&quot; +</span>
                              &quot; has multiple values.&quot;);
    }

    /**
     * Throw an exception when the tag on a value encoding is
     * wrong for the attribute whose value it is. This method
     * will only be called for known tags.
     */
    private void throwTagException(Byte tag)
    throws IOException {
<span class="nc" id="L859">        Byte[] expectedTags = PKCS9_VALUE_TAGS[index];</span>
<span class="nc" id="L860">        StringBuffer msg = new StringBuffer(100);</span>
<span class="nc" id="L861">        msg.append(&quot;Value of attribute &quot;);</span>
<span class="nc" id="L862">        msg.append(oid.toString());</span>
<span class="nc" id="L863">        msg.append(&quot; (&quot;);</span>
<span class="nc" id="L864">        msg.append(getName());</span>
<span class="nc" id="L865">        msg.append(&quot;) has wrong tag: &quot;);</span>
<span class="nc" id="L866">        msg.append(tag.toString());</span>
<span class="nc" id="L867">        msg.append(&quot;.  Expected tags: &quot;);</span>

<span class="nc" id="L869">        msg.append(expectedTags[0].toString());</span>

<span class="nc bnc" id="L871" title="All 2 branches missed.">        for (int i = 1; i &lt; expectedTags.length; i++) {</span>
<span class="nc" id="L872">            msg.append(&quot;, &quot;);</span>
<span class="nc" id="L873">            msg.append(expectedTags[i].toString());</span>
        }
<span class="nc" id="L875">        msg.append(&quot;.&quot;);</span>
<span class="nc" id="L876">        throw new IOException(msg.toString());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>