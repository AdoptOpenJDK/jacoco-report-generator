<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PKCS7.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.pkcs</a> &gt; <span class="el_source">PKCS7.java</span></div><h1>PKCS7.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.pkcs;

import java.io.*;
import java.math.BigInteger;
import java.net.URI;
import java.util.*;
import java.security.cert.X509Certificate;
import java.security.cert.CertificateException;
import java.security.cert.X509CRL;
import java.security.cert.CRLException;
import java.security.cert.CertificateFactory;
import java.security.*;

import sun.security.timestamp.*;
import sun.security.util.*;
import sun.security.x509.AlgorithmId;
import sun.security.x509.X509CertImpl;
import sun.security.x509.X509CertInfo;
import sun.security.x509.X509CRLImpl;
import sun.security.x509.X500Name;

/**
 * PKCS7 as defined in RSA Laboratories PKCS7 Technical Note. Profile
 * Supports only &lt;tt&gt;SignedData&lt;/tt&gt; ContentInfo
 * type, where to the type of data signed is plain Data.
 * For signedData, &lt;tt&gt;crls&lt;/tt&gt;, &lt;tt&gt;attributes&lt;/tt&gt; and
 * PKCS#6 Extended Certificates are not supported.
 *
 * @author Benjamin Renaud
 */
public class PKCS7 {

    private ObjectIdentifier contentType;

    // the ASN.1 members for a signedData (and other) contentTypes
<span class="pc" id="L61">    private BigInteger version = null;</span>
<span class="pc" id="L62">    private AlgorithmId[] digestAlgorithmIds = null;</span>
<span class="pc" id="L63">    private ContentInfo contentInfo = null;</span>
<span class="pc" id="L64">    private X509Certificate[] certificates = null;</span>
<span class="pc" id="L65">    private X509CRL[] crls = null;</span>
<span class="pc" id="L66">    private SignerInfo[] signerInfos = null;</span>

<span class="pc" id="L68">    private boolean oldStyle = false; // Is this JDK1.1.x-style?</span>

    private Principal[] certIssuerNames;

    /*
     * Random number generator for creating nonce values
     * (Lazy initialization)
     */
<span class="nc" id="L76">    private static class SecureRandomHolder {</span>
        static final SecureRandom RANDOM;
        static {
<span class="nc" id="L79">            SecureRandom tmp = null;</span>
            try {
<span class="nc" id="L81">                tmp = SecureRandom.getInstance(&quot;SHA1PRNG&quot;);</span>
<span class="nc" id="L82">            } catch (NoSuchAlgorithmException e) {</span>
                // should not happen
<span class="nc" id="L84">            }</span>
<span class="nc" id="L85">            RANDOM = tmp;</span>
<span class="nc" id="L86">        }</span>
    }

    /*
     * Object identifier for the timestamping key purpose.
     */
    private static final String KP_TIMESTAMPING_OID = &quot;1.3.6.1.5.5.7.3.8&quot;;

    /*
     * Object identifier for extendedKeyUsage extension
     */
    private static final String EXTENDED_KEY_USAGE_OID = &quot;2.5.29.37&quot;;

    /**
     * Unmarshals a PKCS7 block from its encoded form, parsing the
     * encoded bytes from the InputStream.
     *
     * @param in an input stream holding at least one PKCS7 block.
     * @exception ParsingException on parsing errors.
     * @exception IOException on other errors.
     */
<span class="nc" id="L107">    public PKCS7(InputStream in) throws ParsingException, IOException {</span>
<span class="nc" id="L108">        DataInputStream dis = new DataInputStream(in);</span>
<span class="nc" id="L109">        byte[] data = new byte[dis.available()];</span>
<span class="nc" id="L110">        dis.readFully(data);</span>

<span class="nc" id="L112">        parse(new DerInputStream(data));</span>
<span class="nc" id="L113">    }</span>

    /**
     * Unmarshals a PKCS7 block from its encoded form, parsing the
     * encoded bytes from the DerInputStream.
     *
     * @param derin a DerInputStream holding at least one PKCS7 block.
     * @exception ParsingException on parsing errors.
     */
<span class="nc" id="L122">    public PKCS7(DerInputStream derin) throws ParsingException {</span>
<span class="nc" id="L123">        parse(derin);</span>
<span class="nc" id="L124">    }</span>

    /**
     * Unmarshals a PKCS7 block from its encoded form, parsing the
     * encoded bytes.
     *
     * @param bytes the encoded bytes.
     * @exception ParsingException on parsing errors.
     */
<span class="fc" id="L133">    public PKCS7(byte[] bytes) throws ParsingException {</span>
        try {
<span class="fc" id="L135">            DerInputStream derin = new DerInputStream(bytes);</span>
<span class="fc" id="L136">            parse(derin);</span>
<span class="fc" id="L137">        } catch (IOException ioe1) {</span>
<span class="fc" id="L138">            ParsingException pe = new ParsingException(</span>
                &quot;Unable to parse the encoded bytes&quot;);
<span class="fc" id="L140">            pe.initCause(ioe1);</span>
<span class="fc" id="L141">            throw pe;</span>
<span class="fc" id="L142">        }</span>
<span class="fc" id="L143">    }</span>

    /*
     * Parses a PKCS#7 block.
     */
    private void parse(DerInputStream derin)
        throws ParsingException
    {
        try {
<span class="fc" id="L152">            derin.mark(derin.available());</span>
            // try new (i.e., JDK1.2) style
<span class="fc" id="L154">            parse(derin, false);</span>
<span class="fc" id="L155">        } catch (IOException ioe) {</span>
            try {
<span class="nc" id="L157">                derin.reset();</span>
                // try old (i.e., JDK1.1.x) style
<span class="nc" id="L159">                parse(derin, true);</span>
<span class="nc" id="L160">                oldStyle = true;</span>
<span class="fc" id="L161">            } catch (IOException ioe1) {</span>
<span class="fc" id="L162">                ParsingException pe = new ParsingException(</span>
<span class="fc" id="L163">                    ioe1.getMessage());</span>
<span class="fc" id="L164">                pe.initCause(ioe);</span>
<span class="fc" id="L165">                pe.addSuppressed(ioe1);</span>
<span class="fc" id="L166">                throw pe;</span>
<span class="nc" id="L167">            }</span>
<span class="fc" id="L168">        }</span>
<span class="fc" id="L169">    }</span>

    /**
     * Parses a PKCS#7 block.
     *
     * @param derin the ASN.1 encoding of the PKCS#7 block.
     * @param oldStyle flag indicating whether or not the given PKCS#7 block
     * is encoded according to JDK1.1.x.
     */
    private void parse(DerInputStream derin, boolean oldStyle)
        throws IOException
    {
<span class="fc" id="L181">        contentInfo = new ContentInfo(derin, oldStyle);</span>
<span class="fc" id="L182">        contentType = contentInfo.contentType;</span>
<span class="fc" id="L183">        DerValue content = contentInfo.getContent();</span>

<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (contentType.equals((Object)ContentInfo.SIGNED_DATA_OID)) {</span>
<span class="fc" id="L186">            parseSignedData(content);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        } else if (contentType.equals((Object)ContentInfo.OLD_SIGNED_DATA_OID)) {</span>
            // This is for backwards compatibility with JDK 1.1.x
<span class="nc" id="L189">            parseOldSignedData(content);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        } else if (contentType.equals((Object)</span>
                       ContentInfo.NETSCAPE_CERT_SEQUENCE_OID)){
<span class="nc" id="L192">            parseNetscapeCertChain(content);</span>
        } else {
<span class="nc" id="L194">            throw new ParsingException(&quot;content type &quot; + contentType +</span>
                                       &quot; not supported.&quot;);
        }
<span class="fc" id="L197">    }</span>

    /**
     * Construct an initialized PKCS7 block.
     *
     * @param digestAlgorithmIds the message digest algorithm identifiers.
     * @param contentInfo the content information.
     * @param certificates an array of X.509 certificates.
     * @param crls an array of CRLs
     * @param signerInfos an array of signer information.
     */
    public PKCS7(AlgorithmId[] digestAlgorithmIds,
                 ContentInfo contentInfo,
                 X509Certificate[] certificates,
                 X509CRL[] crls,
<span class="nc" id="L212">                 SignerInfo[] signerInfos) {</span>

<span class="nc" id="L214">        version = BigInteger.ONE;</span>
<span class="nc" id="L215">        this.digestAlgorithmIds = digestAlgorithmIds;</span>
<span class="nc" id="L216">        this.contentInfo = contentInfo;</span>
<span class="nc" id="L217">        this.certificates = certificates;</span>
<span class="nc" id="L218">        this.crls = crls;</span>
<span class="nc" id="L219">        this.signerInfos = signerInfos;</span>
<span class="nc" id="L220">    }</span>

    public PKCS7(AlgorithmId[] digestAlgorithmIds,
                 ContentInfo contentInfo,
                 X509Certificate[] certificates,
                 SignerInfo[] signerInfos) {
<span class="nc" id="L226">        this(digestAlgorithmIds, contentInfo, certificates, null, signerInfos);</span>
<span class="nc" id="L227">    }</span>

    private void parseNetscapeCertChain(DerValue val)
    throws ParsingException, IOException {
<span class="nc" id="L231">        DerInputStream dis = new DerInputStream(val.toByteArray());</span>
<span class="nc" id="L232">        DerValue[] contents = dis.getSequence(2);</span>
<span class="nc" id="L233">        certificates = new X509Certificate[contents.length];</span>

<span class="nc" id="L235">        CertificateFactory certfac = null;</span>
        try {
<span class="nc" id="L237">            certfac = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
<span class="nc" id="L238">        } catch (CertificateException ce) {</span>
            // do nothing
<span class="nc" id="L240">        }</span>

<span class="nc bnc" id="L242" title="All 2 branches missed.">        for (int i=0; i &lt; contents.length; i++) {</span>
<span class="nc" id="L243">            ByteArrayInputStream bais = null;</span>
            try {
<span class="nc bnc" id="L245" title="All 2 branches missed.">                if (certfac == null)</span>
<span class="nc" id="L246">                    certificates[i] = new X509CertImpl(contents[i]);</span>
                else {
<span class="nc" id="L248">                    byte[] encoded = contents[i].toByteArray();</span>
<span class="nc" id="L249">                    bais = new ByteArrayInputStream(encoded);</span>
<span class="nc" id="L250">                    certificates[i] =</span>
<span class="nc" id="L251">                        (X509Certificate)certfac.generateCertificate(bais);</span>
<span class="nc" id="L252">                    bais.close();</span>
<span class="nc" id="L253">                    bais = null;</span>
                }
<span class="nc" id="L255">            } catch (CertificateException ce) {</span>
<span class="nc" id="L256">                ParsingException pe = new ParsingException(ce.getMessage());</span>
<span class="nc" id="L257">                pe.initCause(ce);</span>
<span class="nc" id="L258">                throw pe;</span>
<span class="nc" id="L259">            } catch (IOException ioe) {</span>
<span class="nc" id="L260">                ParsingException pe = new ParsingException(ioe.getMessage());</span>
<span class="nc" id="L261">                pe.initCause(ioe);</span>
<span class="nc" id="L262">                throw pe;</span>
            } finally {
<span class="nc bnc" id="L264" title="All 4 branches missed.">                if (bais != null)</span>
<span class="nc" id="L265">                    bais.close();</span>
            }
        }
<span class="nc" id="L268">    }</span>

    private void parseSignedData(DerValue val)
        throws ParsingException, IOException {

<span class="fc" id="L273">        DerInputStream dis = val.toDerInputStream();</span>

        // Version
<span class="fc" id="L276">        version = dis.getBigInteger();</span>

        // digestAlgorithmIds
<span class="fc" id="L279">        DerValue[] digestAlgorithmIdVals = dis.getSet(1);</span>
<span class="fc" id="L280">        int len = digestAlgorithmIdVals.length;</span>
<span class="fc" id="L281">        digestAlgorithmIds = new AlgorithmId[len];</span>
        try {
<span class="fc bfc" id="L283" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L284">                DerValue oid = digestAlgorithmIdVals[i];</span>
<span class="fc" id="L285">                digestAlgorithmIds[i] = AlgorithmId.parse(oid);</span>
            }

<span class="nc" id="L288">        } catch (IOException e) {</span>
<span class="nc" id="L289">            ParsingException pe =</span>
                new ParsingException(&quot;Error parsing digest AlgorithmId IDs: &quot; +
<span class="nc" id="L291">                                     e.getMessage());</span>
<span class="nc" id="L292">            pe.initCause(e);</span>
<span class="nc" id="L293">            throw pe;</span>
<span class="fc" id="L294">        }</span>
        // contentInfo
<span class="fc" id="L296">        contentInfo = new ContentInfo(dis);</span>

<span class="fc" id="L298">        CertificateFactory certfac = null;</span>
        try {
<span class="fc" id="L300">            certfac = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
<span class="nc" id="L301">        } catch (CertificateException ce) {</span>
            // do nothing
<span class="fc" id="L303">        }</span>

        /*
         * check if certificates (implicit tag) are provided
         * (certificates are OPTIONAL)
         */
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">        if ((byte)(dis.peekByte()) == (byte)0xA0) {</span>
<span class="fc" id="L310">            DerValue[] certVals = dis.getSet(2, true);</span>

<span class="fc" id="L312">            len = certVals.length;</span>
<span class="fc" id="L313">            certificates = new X509Certificate[len];</span>
<span class="fc" id="L314">            int count = 0;</span>

<span class="fc bfc" id="L316" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L317">                ByteArrayInputStream bais = null;</span>
                try {
<span class="fc" id="L319">                    byte tag = certVals[i].getTag();</span>
                    // We only parse the normal certificate. Other types of
                    // CertificateChoices ignored.
<span class="pc bpc" id="L322" title="1 of 2 branches missed.">                    if (tag == DerValue.tag_Sequence) {</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">                        if (certfac == null) {</span>
<span class="nc" id="L324">                            certificates[count] = new X509CertImpl(certVals[i]);</span>
                        } else {
<span class="fc" id="L326">                            byte[] encoded = certVals[i].toByteArray();</span>
<span class="fc" id="L327">                            bais = new ByteArrayInputStream(encoded);</span>
<span class="fc" id="L328">                            certificates[count] =</span>
<span class="fc" id="L329">                                (X509Certificate)certfac.generateCertificate(bais);</span>
<span class="fc" id="L330">                            bais.close();</span>
<span class="fc" id="L331">                            bais = null;</span>
                        }
<span class="fc" id="L333">                        count++;</span>
                    }
<span class="nc" id="L335">                } catch (CertificateException ce) {</span>
<span class="nc" id="L336">                    ParsingException pe = new ParsingException(ce.getMessage());</span>
<span class="nc" id="L337">                    pe.initCause(ce);</span>
<span class="nc" id="L338">                    throw pe;</span>
<span class="nc" id="L339">                } catch (IOException ioe) {</span>
<span class="nc" id="L340">                    ParsingException pe = new ParsingException(ioe.getMessage());</span>
<span class="nc" id="L341">                    pe.initCause(ioe);</span>
<span class="nc" id="L342">                    throw pe;</span>
                } finally {
<span class="pc bpc" id="L344" title="3 of 4 branches missed.">                    if (bais != null)</span>
<span class="nc" id="L345">                        bais.close();</span>
                }
            }
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">            if (count != len) {</span>
<span class="nc" id="L349">                certificates = Arrays.copyOf(certificates, count);</span>
            }
        }

        // check if crls (implicit tag) are provided (crls are OPTIONAL)
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if ((byte)(dis.peekByte()) == (byte)0xA1) {</span>
<span class="nc" id="L355">            DerValue[] crlVals = dis.getSet(1, true);</span>

<span class="nc" id="L357">            len = crlVals.length;</span>
<span class="nc" id="L358">            crls = new X509CRL[len];</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L361">                ByteArrayInputStream bais = null;</span>
                try {
<span class="nc bnc" id="L363" title="All 2 branches missed.">                    if (certfac == null)</span>
<span class="nc" id="L364">                        crls[i] = new X509CRLImpl(crlVals[i]);</span>
                    else {
<span class="nc" id="L366">                        byte[] encoded = crlVals[i].toByteArray();</span>
<span class="nc" id="L367">                        bais = new ByteArrayInputStream(encoded);</span>
<span class="nc" id="L368">                        crls[i] = (X509CRL) certfac.generateCRL(bais);</span>
<span class="nc" id="L369">                        bais.close();</span>
<span class="nc" id="L370">                        bais = null;</span>
                    }
<span class="nc" id="L372">                } catch (CRLException e) {</span>
<span class="nc" id="L373">                    ParsingException pe =</span>
<span class="nc" id="L374">                        new ParsingException(e.getMessage());</span>
<span class="nc" id="L375">                    pe.initCause(e);</span>
<span class="nc" id="L376">                    throw pe;</span>
                } finally {
<span class="nc bnc" id="L378" title="All 4 branches missed.">                    if (bais != null)</span>
<span class="nc" id="L379">                        bais.close();</span>
                }
            }
        }

        // signerInfos
<span class="fc" id="L385">        DerValue[] signerInfoVals = dis.getSet(1);</span>

<span class="fc" id="L387">        len = signerInfoVals.length;</span>
<span class="fc" id="L388">        signerInfos = new SignerInfo[len];</span>

<span class="fc bfc" id="L390" title="All 2 branches covered.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="fc" id="L391">            DerInputStream in = signerInfoVals[i].toDerInputStream();</span>
<span class="fc" id="L392">            signerInfos[i] = new SignerInfo(in);</span>
        }
<span class="fc" id="L394">    }</span>

    /*
     * Parses an old-style SignedData encoding (for backwards
     * compatibility with JDK1.1.x).
     */
    private void parseOldSignedData(DerValue val)
        throws ParsingException, IOException
    {
<span class="nc" id="L403">        DerInputStream dis = val.toDerInputStream();</span>

        // Version
<span class="nc" id="L406">        version = dis.getBigInteger();</span>

        // digestAlgorithmIds
<span class="nc" id="L409">        DerValue[] digestAlgorithmIdVals = dis.getSet(1);</span>
<span class="nc" id="L410">        int len = digestAlgorithmIdVals.length;</span>

<span class="nc" id="L412">        digestAlgorithmIds = new AlgorithmId[len];</span>
        try {
<span class="nc bnc" id="L414" title="All 2 branches missed.">            for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L415">                DerValue oid = digestAlgorithmIdVals[i];</span>
<span class="nc" id="L416">                digestAlgorithmIds[i] = AlgorithmId.parse(oid);</span>
            }
<span class="nc" id="L418">        } catch (IOException e) {</span>
<span class="nc" id="L419">            throw new ParsingException(&quot;Error parsing digest AlgorithmId IDs&quot;);</span>
<span class="nc" id="L420">        }</span>

        // contentInfo
<span class="nc" id="L423">        contentInfo = new ContentInfo(dis, true);</span>

        // certificates
<span class="nc" id="L426">        CertificateFactory certfac = null;</span>
        try {
<span class="nc" id="L428">            certfac = CertificateFactory.getInstance(&quot;X.509&quot;);</span>
<span class="nc" id="L429">        } catch (CertificateException ce) {</span>
            // do nothing
<span class="nc" id="L431">        }</span>
<span class="nc" id="L432">        DerValue[] certVals = dis.getSet(2);</span>
<span class="nc" id="L433">        len = certVals.length;</span>
<span class="nc" id="L434">        certificates = new X509Certificate[len];</span>

<span class="nc bnc" id="L436" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L437">            ByteArrayInputStream bais = null;</span>
            try {
<span class="nc bnc" id="L439" title="All 2 branches missed.">                if (certfac == null)</span>
<span class="nc" id="L440">                    certificates[i] = new X509CertImpl(certVals[i]);</span>
                else {
<span class="nc" id="L442">                    byte[] encoded = certVals[i].toByteArray();</span>
<span class="nc" id="L443">                    bais = new ByteArrayInputStream(encoded);</span>
<span class="nc" id="L444">                    certificates[i] =</span>
<span class="nc" id="L445">                        (X509Certificate)certfac.generateCertificate(bais);</span>
<span class="nc" id="L446">                    bais.close();</span>
<span class="nc" id="L447">                    bais = null;</span>
                }
<span class="nc" id="L449">            } catch (CertificateException ce) {</span>
<span class="nc" id="L450">                ParsingException pe = new ParsingException(ce.getMessage());</span>
<span class="nc" id="L451">                pe.initCause(ce);</span>
<span class="nc" id="L452">                throw pe;</span>
<span class="nc" id="L453">            } catch (IOException ioe) {</span>
<span class="nc" id="L454">                ParsingException pe = new ParsingException(ioe.getMessage());</span>
<span class="nc" id="L455">                pe.initCause(ioe);</span>
<span class="nc" id="L456">                throw pe;</span>
            } finally {
<span class="nc bnc" id="L458" title="All 4 branches missed.">                if (bais != null)</span>
<span class="nc" id="L459">                    bais.close();</span>
            }
        }

        // crls are ignored.
<span class="nc" id="L464">        dis.getSet(0);</span>

        // signerInfos
<span class="nc" id="L467">        DerValue[] signerInfoVals = dis.getSet(1);</span>
<span class="nc" id="L468">        len = signerInfoVals.length;</span>
<span class="nc" id="L469">        signerInfos = new SignerInfo[len];</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L471">            DerInputStream in = signerInfoVals[i].toDerInputStream();</span>
<span class="nc" id="L472">            signerInfos[i] = new SignerInfo(in, true);</span>
        }
<span class="nc" id="L474">    }</span>

    /**
     * Encodes the signed data to an output stream.
     *
     * @param out the output stream to write the encoded data to.
     * @exception IOException on encoding errors.
     */
    public void encodeSignedData(OutputStream out) throws IOException {
<span class="nc" id="L483">        DerOutputStream derout = new DerOutputStream();</span>
<span class="nc" id="L484">        encodeSignedData(derout);</span>
<span class="nc" id="L485">        out.write(derout.toByteArray());</span>
<span class="nc" id="L486">    }</span>

    /**
     * Encodes the signed data to a DerOutputStream.
     *
     * @param out the DerOutputStream to write the encoded data to.
     * @exception IOException on encoding errors.
     */
    public void encodeSignedData(DerOutputStream out)
        throws IOException
    {
<span class="nc" id="L497">        DerOutputStream signedData = new DerOutputStream();</span>

        // version
<span class="nc" id="L500">        signedData.putInteger(version);</span>

        // digestAlgorithmIds
<span class="nc" id="L503">        signedData.putOrderedSetOf(DerValue.tag_Set, digestAlgorithmIds);</span>

        // contentInfo
<span class="nc" id="L506">        contentInfo.encode(signedData);</span>

        // certificates (optional)
<span class="nc bnc" id="L509" title="All 4 branches missed.">        if (certificates != null &amp;&amp; certificates.length != 0) {</span>
            // cast to X509CertImpl[] since X509CertImpl implements DerEncoder
<span class="nc" id="L511">            X509CertImpl implCerts[] = new X509CertImpl[certificates.length];</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            for (int i = 0; i &lt; certificates.length; i++) {</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                if (certificates[i] instanceof X509CertImpl)</span>
<span class="nc" id="L514">                    implCerts[i] = (X509CertImpl) certificates[i];</span>
                else {
                    try {
<span class="nc" id="L517">                        byte[] encoded = certificates[i].getEncoded();</span>
<span class="nc" id="L518">                        implCerts[i] = new X509CertImpl(encoded);</span>
<span class="nc" id="L519">                    } catch (CertificateException ce) {</span>
<span class="nc" id="L520">                        throw new IOException(ce);</span>
<span class="nc" id="L521">                    }</span>
                }
            }

            // Add the certificate set (tagged with [0] IMPLICIT)
            // to the signed data
<span class="nc" id="L527">            signedData.putOrderedSetOf((byte)0xA0, implCerts);</span>
        }

        // CRLs (optional)
<span class="nc bnc" id="L531" title="All 4 branches missed.">        if (crls != null &amp;&amp; crls.length != 0) {</span>
            // cast to X509CRLImpl[] since X509CRLImpl implements DerEncoder
<span class="nc" id="L533">            Set&lt;X509CRLImpl&gt; implCRLs = new HashSet&lt;X509CRLImpl&gt;(crls.length);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">            for (X509CRL crl: crls) {</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">                if (crl instanceof X509CRLImpl)</span>
<span class="nc" id="L536">                    implCRLs.add((X509CRLImpl) crl);</span>
                else {
                    try {
<span class="nc" id="L539">                        byte[] encoded = crl.getEncoded();</span>
<span class="nc" id="L540">                        implCRLs.add(new X509CRLImpl(encoded));</span>
<span class="nc" id="L541">                    } catch (CRLException ce) {</span>
<span class="nc" id="L542">                        throw new IOException(ce);</span>
<span class="nc" id="L543">                    }</span>
                }
            }

            // Add the CRL set (tagged with [1] IMPLICIT)
            // to the signed data
<span class="nc" id="L549">            signedData.putOrderedSetOf((byte)0xA1,</span>
<span class="nc" id="L550">                    implCRLs.toArray(new X509CRLImpl[implCRLs.size()]));</span>
        }

        // signerInfos
<span class="nc" id="L554">        signedData.putOrderedSetOf(DerValue.tag_Set, signerInfos);</span>

        // making it a signed data block
<span class="nc" id="L557">        DerValue signedDataSeq = new DerValue(DerValue.tag_Sequence,</span>
<span class="nc" id="L558">                                              signedData.toByteArray());</span>

        // making it a content info sequence
<span class="nc" id="L561">        ContentInfo block = new ContentInfo(ContentInfo.SIGNED_DATA_OID,</span>
                                            signedDataSeq);

        // writing out the contentInfo sequence
<span class="nc" id="L565">        block.encode(out);</span>
<span class="nc" id="L566">    }</span>

    /**
     * This verifies a given SignerInfo.
     *
     * @param info the signer information.
     * @param bytes the DER encoded content information.
     *
     * @exception NoSuchAlgorithmException on unrecognized algorithms.
     * @exception SignatureException on signature handling errors.
     */
    public SignerInfo verify(SignerInfo info, byte[] bytes)
    throws NoSuchAlgorithmException, SignatureException {
<span class="fc" id="L579">        return info.verify(this, bytes);</span>
    }

    /**
     * Returns all signerInfos which self-verify.
     *
     * @param bytes the DER encoded content information.
     *
     * @exception NoSuchAlgorithmException on unrecognized algorithms.
     * @exception SignatureException on signature handling errors.
     */
    public SignerInfo[] verify(byte[] bytes)
    throws NoSuchAlgorithmException, SignatureException {

<span class="fc" id="L593">        Vector&lt;SignerInfo&gt; intResult = new Vector&lt;SignerInfo&gt;();</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">        for (int i = 0; i &lt; signerInfos.length; i++) {</span>

<span class="fc" id="L596">            SignerInfo signerInfo = verify(signerInfos[i], bytes);</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">            if (signerInfo != null) {</span>
<span class="fc" id="L598">                intResult.addElement(signerInfo);</span>
            }
        }
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (!intResult.isEmpty()) {</span>

<span class="fc" id="L603">            SignerInfo[] result = new SignerInfo[intResult.size()];</span>
<span class="fc" id="L604">            intResult.copyInto(result);</span>
<span class="fc" id="L605">            return result;</span>
        }
<span class="fc" id="L607">        return null;</span>
    }

    /**
     * Returns all signerInfos which self-verify.
     *
     * @exception NoSuchAlgorithmException on unrecognized algorithms.
     * @exception SignatureException on signature handling errors.
     */
    public SignerInfo[] verify()
    throws NoSuchAlgorithmException, SignatureException {
<span class="nc" id="L618">        return verify(null);</span>
    }

    /**
     * Returns the version number of this PKCS7 block.
     * @return the version or null if version is not specified
     *         for the content type.
     */
    public  BigInteger getVersion() {
<span class="nc" id="L627">        return version;</span>
    }

    /**
     * Returns the message digest algorithms specified in this PKCS7 block.
     * @return the array of Digest Algorithms or null if none are specified
     *         for the content type.
     */
    public AlgorithmId[] getDigestAlgorithmIds() {
<span class="nc" id="L636">        return  digestAlgorithmIds;</span>
    }

    /**
     * Returns the content information specified in this PKCS7 block.
     */
    public ContentInfo getContentInfo() {
<span class="fc" id="L643">        return contentInfo;</span>
    }

    /**
     * Returns the X.509 certificates listed in this PKCS7 block.
     * @return a clone of the array of X.509 certificates or null if
     *         none are specified for the content type.
     */
    public X509Certificate[] getCertificates() {
<span class="pc bpc" id="L652" title="1 of 2 branches missed.">        if (certificates != null)</span>
<span class="fc" id="L653">            return certificates.clone();</span>
        else
<span class="nc" id="L655">            return null;</span>
    }

    /**
     * Returns the X.509 crls listed in this PKCS7 block.
     * @return a clone of the array of X.509 crls or null if none
     *         are specified for the content type.
     */
    public X509CRL[] getCRLs() {
<span class="nc bnc" id="L664" title="All 2 branches missed.">        if (crls != null)</span>
<span class="nc" id="L665">            return crls.clone();</span>
        else
<span class="nc" id="L667">            return null;</span>
    }

    /**
     * Returns the signer's information specified in this PKCS7 block.
     * @return the array of Signer Infos or null if none are specified
     *         for the content type.
     */
    public SignerInfo[] getSignerInfos() {
<span class="nc" id="L676">        return signerInfos;</span>
    }

    /**
     * Returns the X.509 certificate listed in this PKCS7 block
     * which has a matching serial number and Issuer name, or
     * null if one is not found.
     *
     * @param serial the serial number of the certificate to retrieve.
     * @param issuerName the Distinguished Name of the Issuer.
     */
    public X509Certificate getCertificate(BigInteger serial, X500Name issuerName) {
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">        if (certificates != null) {</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">            if (certIssuerNames == null)</span>
<span class="fc" id="L690">                populateCertIssuerNames();</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">            for (int i = 0; i &lt; certificates.length; i++) {</span>
<span class="fc" id="L692">                X509Certificate cert = certificates[i];</span>
<span class="fc" id="L693">                BigInteger thisSerial = cert.getSerialNumber();</span>
<span class="pc bpc" id="L694" title="1 of 2 branches missed.">                if (serial.equals(thisSerial)</span>
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">                    &amp;&amp; issuerName.equals(certIssuerNames[i]))</span>
                {
<span class="fc" id="L697">                    return cert;</span>
                }
            }
        }
<span class="nc" id="L701">        return null;</span>
    }

    /**
     * Populate array of Issuer DNs from certificates and convert
     * each Principal to type X500Name if necessary.
     */
    private void populateCertIssuerNames() {
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">        if (certificates == null)</span>
<span class="nc" id="L710">            return;</span>

<span class="fc" id="L712">        certIssuerNames = new Principal[certificates.length];</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">        for (int i = 0; i &lt; certificates.length; i++) {</span>
<span class="fc" id="L714">            X509Certificate cert = certificates[i];</span>
<span class="fc" id="L715">            Principal certIssuerName = cert.getIssuerDN();</span>
<span class="pc bpc" id="L716" title="1 of 2 branches missed.">            if (!(certIssuerName instanceof X500Name)) {</span>
                // must extract the original encoded form of DN for
                // subsequent name comparison checks (converting to a
                // String and back to an encoded DN could cause the
                // types of String attribute values to be changed)
                try {
<span class="nc" id="L722">                    X509CertInfo tbsCert =</span>
<span class="nc" id="L723">                        new X509CertInfo(cert.getTBSCertificate());</span>
<span class="nc" id="L724">                    certIssuerName = (Principal)</span>
<span class="nc" id="L725">                        tbsCert.get(X509CertInfo.ISSUER + &quot;.&quot; +</span>
                                    X509CertInfo.DN_NAME);
<span class="nc" id="L727">                } catch (Exception e) {</span>
                    // error generating X500Name object from the cert's
                    // issuer DN, leave name as is.
<span class="nc" id="L730">                }</span>
            }
<span class="fc" id="L732">            certIssuerNames[i] = certIssuerName;</span>
        }
<span class="fc" id="L734">    }</span>

    /**
     * Returns the PKCS7 block in a printable string form.
     */
    public String toString() {
<span class="nc" id="L740">        String out = &quot;&quot;;</span>

<span class="nc" id="L742">        out += contentInfo + &quot;\n&quot;;</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (version != null)</span>
<span class="nc" id="L744">            out += &quot;PKCS7 :: version: &quot; + Debug.toHexString(version) + &quot;\n&quot;;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (digestAlgorithmIds != null) {</span>
<span class="nc" id="L746">            out += &quot;PKCS7 :: digest AlgorithmIds: \n&quot;;</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            for (int i = 0; i &lt; digestAlgorithmIds.length; i++)</span>
<span class="nc" id="L748">                out += &quot;\t&quot; + digestAlgorithmIds[i] + &quot;\n&quot;;</span>
        }
<span class="nc bnc" id="L750" title="All 2 branches missed.">        if (certificates != null) {</span>
<span class="nc" id="L751">            out += &quot;PKCS7 :: certificates: \n&quot;;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">            for (int i = 0; i &lt; certificates.length; i++)</span>
<span class="nc" id="L753">                out += &quot;\t&quot; + i + &quot;.   &quot; + certificates[i] + &quot;\n&quot;;</span>
        }
<span class="nc bnc" id="L755" title="All 2 branches missed.">        if (crls != null) {</span>
<span class="nc" id="L756">            out += &quot;PKCS7 :: crls: \n&quot;;</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            for (int i = 0; i &lt; crls.length; i++)</span>
<span class="nc" id="L758">                out += &quot;\t&quot; + i + &quot;.   &quot; + crls[i] + &quot;\n&quot;;</span>
        }
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if (signerInfos != null) {</span>
<span class="nc" id="L761">            out += &quot;PKCS7 :: signer infos: \n&quot;;</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">            for (int i = 0; i &lt; signerInfos.length; i++)</span>
<span class="nc" id="L763">                out += (&quot;\t&quot; + i + &quot;.  &quot; + signerInfos[i] + &quot;\n&quot;);</span>
        }
<span class="nc" id="L765">        return out;</span>
    }

    /**
     * Returns true if this is a JDK1.1.x-style PKCS#7 block, and false
     * otherwise.
     */
    public boolean isOldStyle() {
<span class="nc" id="L773">        return this.oldStyle;</span>
    }

    /**
     * Assembles a PKCS #7 signed data message that optionally includes a
     * signature timestamp.
     *
     * @param signature the signature bytes
     * @param signerChain the signer's X.509 certificate chain
     * @param content the content that is signed; specify null to not include
     *        it in the PKCS7 data
     * @param signatureAlgorithm the name of the signature algorithm
     * @param tsaURI the URI of the Timestamping Authority; or null if no
     *         timestamp is requested
     * @param tSAPolicyID the TSAPolicyID of the Timestamping Authority as a
     *         numerical object identifier; or null if we leave the TSA server
     *         to choose one. This argument is only used when tsaURI is provided
     * @return the bytes of the encoded PKCS #7 signed data message
     * @throws NoSuchAlgorithmException The exception is thrown if the signature
     *         algorithm is unrecognised.
     * @throws CertificateException The exception is thrown if an error occurs
     *         while processing the signer's certificate or the TSA's
     *         certificate.
     * @throws IOException The exception is thrown if an error occurs while
     *         generating the signature timestamp or while generating the signed
     *         data message.
     */
    public static byte[] generateSignedData(byte[] signature,
                                            X509Certificate[] signerChain,
                                            byte[] content,
                                            String signatureAlgorithm,
                                            URI tsaURI,
                                            String tSAPolicyID)
        throws CertificateException, IOException, NoSuchAlgorithmException
    {

        // Generate the timestamp token
<span class="nc" id="L810">        PKCS9Attributes unauthAttrs = null;</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">        if (tsaURI != null) {</span>
            // Timestamp the signature
<span class="nc" id="L813">            HttpTimestamper tsa = new HttpTimestamper(tsaURI);</span>
<span class="nc" id="L814">            byte[] tsToken = generateTimestampToken(tsa, tSAPolicyID, signature);</span>

            // Insert the timestamp token into the PKCS #7 signer info element
            // (as an unsigned attribute)
<span class="nc" id="L818">            unauthAttrs =</span>
                new PKCS9Attributes(new PKCS9Attribute[]{
                    new PKCS9Attribute(
                        PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_STR,
                        tsToken)});
        }

        // Create the SignerInfo
<span class="nc" id="L826">        X500Name issuerName =</span>
<span class="nc" id="L827">            X500Name.asX500Name(signerChain[0].getIssuerX500Principal());</span>
<span class="nc" id="L828">        BigInteger serialNumber = signerChain[0].getSerialNumber();</span>
<span class="nc" id="L829">        String encAlg = AlgorithmId.getEncAlgFromSigAlg(signatureAlgorithm);</span>
<span class="nc" id="L830">        String digAlg = AlgorithmId.getDigAlgFromSigAlg(signatureAlgorithm);</span>
<span class="nc" id="L831">        SignerInfo signerInfo = new SignerInfo(issuerName, serialNumber,</span>
<span class="nc" id="L832">                                               AlgorithmId.get(digAlg), null,</span>
<span class="nc" id="L833">                                               AlgorithmId.get(encAlg),</span>
                                               signature, unauthAttrs);

        // Create the PKCS #7 signed data message
<span class="nc" id="L837">        SignerInfo[] signerInfos = {signerInfo};</span>
<span class="nc" id="L838">        AlgorithmId[] algorithms = {signerInfo.getDigestAlgorithmId()};</span>
        // Include or exclude content
<span class="nc bnc" id="L840" title="All 2 branches missed.">        ContentInfo contentInfo = (content == null)</span>
            ? new ContentInfo(ContentInfo.DATA_OID, null)
            : new ContentInfo(content);
<span class="nc" id="L843">        PKCS7 pkcs7 = new PKCS7(algorithms, contentInfo,</span>
                                signerChain, signerInfos);
<span class="nc" id="L845">        ByteArrayOutputStream p7out = new ByteArrayOutputStream();</span>
<span class="nc" id="L846">        pkcs7.encodeSignedData(p7out);</span>

<span class="nc" id="L848">        return p7out.toByteArray();</span>
    }

    /**
     * Requests, processes and validates a timestamp token from a TSA using
     * common defaults. Uses the following defaults in the timestamp request:
     * SHA-1 for the hash algorithm, a 64-bit nonce, and request certificate
     * set to true.
     *
     * @param tsa the timestamping authority to use
     * @param tSAPolicyID the TSAPolicyID of the Timestamping Authority as a
     *         numerical object identifier; or null if we leave the TSA server
     *         to choose one
     * @param toBeTimestamped the token that is to be timestamped
     * @return the encoded timestamp token
     * @throws IOException The exception is thrown if an error occurs while
     *                     communicating with the TSA, or a non-null
     *                     TSAPolicyID is specified in the request but it
     *                     does not match the one in the reply
     * @throws CertificateException The exception is thrown if the TSA's
     *                     certificate is not permitted for timestamping.
     */
    private static byte[] generateTimestampToken(Timestamper tsa,
                                                 String tSAPolicyID,
                                                 byte[] toBeTimestamped)
        throws IOException, CertificateException
    {
        // Generate a timestamp
<span class="nc" id="L876">        MessageDigest messageDigest = null;</span>
<span class="nc" id="L877">        TSRequest tsQuery = null;</span>
        try {
            // SHA-1 is always used.
<span class="nc" id="L880">            messageDigest = MessageDigest.getInstance(&quot;SHA-1&quot;);</span>
<span class="nc" id="L881">            tsQuery = new TSRequest(tSAPolicyID, toBeTimestamped, messageDigest);</span>
<span class="nc" id="L882">        } catch (NoSuchAlgorithmException e) {</span>
            // ignore
<span class="nc" id="L884">        }</span>

        // Generate a nonce
<span class="nc" id="L887">        BigInteger nonce = null;</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">        if (SecureRandomHolder.RANDOM != null) {</span>
<span class="nc" id="L889">            nonce = new BigInteger(64, SecureRandomHolder.RANDOM);</span>
<span class="nc" id="L890">            tsQuery.setNonce(nonce);</span>
        }
<span class="nc" id="L892">        tsQuery.requestCertificate(true);</span>

<span class="nc" id="L894">        TSResponse tsReply = tsa.generateTimestamp(tsQuery);</span>
<span class="nc" id="L895">        int status = tsReply.getStatusCode();</span>
        // Handle TSP error
<span class="nc bnc" id="L897" title="All 4 branches missed.">        if (status != 0 &amp;&amp; status != 1) {</span>
<span class="nc" id="L898">            throw new IOException(&quot;Error generating timestamp: &quot; +</span>
<span class="nc" id="L899">                tsReply.getStatusCodeAsText() + &quot; &quot; +</span>
<span class="nc" id="L900">                tsReply.getFailureCodeAsText());</span>
        }

<span class="nc bnc" id="L903" title="All 2 branches missed.">        if (tSAPolicyID != null &amp;&amp;</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                !tSAPolicyID.equals(tsReply.getTimestampToken().getPolicyID())) {</span>
<span class="nc" id="L905">            throw new IOException(&quot;TSAPolicyID changed in &quot;</span>
                    + &quot;timestamp token&quot;);
        }
<span class="nc" id="L908">        PKCS7 tsToken = tsReply.getToken();</span>

<span class="nc" id="L910">        TimestampToken tst = tsReply.getTimestampToken();</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">        if (!tst.getHashAlgorithm().getName().equals(&quot;SHA-1&quot;)) {</span>
<span class="nc" id="L912">            throw new IOException(&quot;Digest algorithm not SHA-1 in &quot;</span>
                                  + &quot;timestamp token&quot;);
        }
<span class="nc bnc" id="L915" title="All 2 branches missed.">        if (!MessageDigest.isEqual(tst.getHashedMessage(),</span>
<span class="nc" id="L916">                                   tsQuery.getHashedMessage())) {</span>
<span class="nc" id="L917">            throw new IOException(&quot;Digest octets changed in timestamp token&quot;);</span>
        }

<span class="nc" id="L920">        BigInteger replyNonce = tst.getNonce();</span>
<span class="nc bnc" id="L921" title="All 4 branches missed.">        if (replyNonce == null &amp;&amp; nonce != null) {</span>
<span class="nc" id="L922">            throw new IOException(&quot;Nonce missing in timestamp token&quot;);</span>
        }
<span class="nc bnc" id="L924" title="All 4 branches missed.">        if (replyNonce != null &amp;&amp; !replyNonce.equals(nonce)) {</span>
<span class="nc" id="L925">            throw new IOException(&quot;Nonce changed in timestamp token&quot;);</span>
        }

        // Examine the TSA's certificate (if present)
<span class="nc bnc" id="L929" title="All 2 branches missed.">        for (SignerInfo si: tsToken.getSignerInfos()) {</span>
<span class="nc" id="L930">            X509Certificate cert = si.getCertificate(tsToken);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">            if (cert == null) {</span>
                // Error, we've already set tsRequestCertificate = true
<span class="nc" id="L933">                throw new CertificateException(</span>
                &quot;Certificate not included in timestamp token&quot;);
            } else {
<span class="nc bnc" id="L936" title="All 2 branches missed.">                if (!cert.getCriticalExtensionOIDs().contains(</span>
                        EXTENDED_KEY_USAGE_OID)) {
<span class="nc" id="L938">                    throw new CertificateException(</span>
                    &quot;Certificate is not valid for timestamping&quot;);
                }
<span class="nc" id="L941">                List&lt;String&gt; keyPurposes = cert.getExtendedKeyUsage();</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">                if (keyPurposes == null ||</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">                        !keyPurposes.contains(KP_TIMESTAMPING_OID)) {</span>
<span class="nc" id="L944">                    throw new CertificateException(</span>
                    &quot;Certificate is not valid for timestamping&quot;);
                }
            }
        }
<span class="nc" id="L949">        return tsReply.getEncodedToken();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>