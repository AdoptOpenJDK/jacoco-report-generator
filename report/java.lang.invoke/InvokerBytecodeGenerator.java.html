<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InvokerBytecodeGenerator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">InvokerBytecodeGenerator.java</span></div><h1>InvokerBytecodeGenerator.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.invoke;

import sun.invoke.util.VerifyAccess;
import java.lang.invoke.LambdaForm.Name;
import java.lang.invoke.MethodHandles.Lookup;

import sun.invoke.util.Wrapper;

import java.io.*;
import java.util.*;

import jdk.internal.org.objectweb.asm.*;

import java.lang.reflect.*;
import static java.lang.invoke.MethodHandleStatics.*;
import static java.lang.invoke.MethodHandleNatives.Constants.*;
import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
import sun.invoke.util.ValueConversions;
import sun.invoke.util.VerifyType;

/**
 * Code generation backend for LambdaForm.
 * &lt;p&gt;
 * @author John Rose, JSR 292 EG
 */
<span class="fc bfc" id="L51" title="All 2 branches covered.">class InvokerBytecodeGenerator {</span>
    /** Define class names for convenience. */
    private static final String MH      = &quot;java/lang/invoke/MethodHandle&quot;;
    private static final String BMH     = &quot;java/lang/invoke/BoundMethodHandle&quot;;
    private static final String LF      = &quot;java/lang/invoke/LambdaForm&quot;;
    private static final String LFN     = &quot;java/lang/invoke/LambdaForm$Name&quot;;
    private static final String CLS     = &quot;java/lang/Class&quot;;
    private static final String OBJ     = &quot;java/lang/Object&quot;;
    private static final String OBJARY  = &quot;[Ljava/lang/Object;&quot;;

    private static final String LF_SIG  = &quot;L&quot; + LF + &quot;;&quot;;
    private static final String LFN_SIG = &quot;L&quot; + LFN + &quot;;&quot;;
    private static final String LL_SIG  = &quot;(L&quot; + OBJ + &quot;;)L&quot; + OBJ + &quot;;&quot;;

    /** Name of its super class*/
    private static final String superName = LF;

    /** Name of new class */
    private final String className;

    /** Name of the source file (for stack trace printing). */
    private final String sourceFile;

    private final LambdaForm lambdaForm;
    private final String     invokerName;
    private final MethodType invokerType;
    private final int[] localsMap;

    /** ASM bytecode generation. */
    private ClassWriter cw;
    private MethodVisitor mv;

<span class="fc" id="L83">    private static final MemberName.Factory MEMBERNAME_FACTORY = MemberName.getFactory();</span>
<span class="fc" id="L84">    private static final Class&lt;?&gt; HOST_CLASS = LambdaForm.class;</span>

    private InvokerBytecodeGenerator(LambdaForm lambdaForm, int localsMapSize,
<span class="fc" id="L87">                                     String className, String invokerName, MethodType invokerType) {</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (invokerName.contains(&quot;.&quot;)) {</span>
<span class="fc" id="L89">            int p = invokerName.indexOf(&quot;.&quot;);</span>
<span class="fc" id="L90">            className = invokerName.substring(0, p);</span>
<span class="fc" id="L91">            invokerName = invokerName.substring(p+1);</span>
        }
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (DUMP_CLASS_FILES) {</span>
<span class="nc" id="L94">            className = makeDumpableClassName(className);</span>
        }
<span class="fc" id="L96">        this.className  = superName + &quot;$&quot; + className;</span>
<span class="fc" id="L97">        this.sourceFile = &quot;LambdaForm$&quot; + className;</span>
<span class="fc" id="L98">        this.lambdaForm = lambdaForm;</span>
<span class="fc" id="L99">        this.invokerName = invokerName;</span>
<span class="fc" id="L100">        this.invokerType = invokerType;</span>
<span class="fc" id="L101">        this.localsMap = new int[localsMapSize];</span>
<span class="fc" id="L102">    }</span>

    private InvokerBytecodeGenerator(String className, String invokerName, MethodType invokerType) {
<span class="fc" id="L105">        this(null, invokerType.parameterCount(),</span>
             className, invokerName, invokerType);
        // Create an array to map name indexes to locals indexes.
<span class="fc bfc" id="L108" title="All 2 branches covered.">        for (int i = 0; i &lt; localsMap.length; i++) {</span>
<span class="fc" id="L109">            localsMap[i] = invokerType.parameterSlotCount() - invokerType.parameterSlotDepth(i);</span>
        }
<span class="fc" id="L111">    }</span>

    private InvokerBytecodeGenerator(String className, LambdaForm form, MethodType invokerType) {
<span class="fc" id="L114">        this(form, form.names.length,</span>
             className, form.debugName, invokerType);
        // Create an array to map name indexes to locals indexes.
<span class="fc" id="L117">        Name[] names = form.names;</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">        for (int i = 0, index = 0; i &lt; localsMap.length; i++) {</span>
<span class="fc" id="L119">            localsMap[i] = index;</span>
<span class="fc" id="L120">            index += Wrapper.forBasicType(names[i].type).stackSlots();</span>
        }
<span class="fc" id="L122">    }</span>


    /** instance counters for dumped classes */
    private final static HashMap&lt;String,Integer&gt; DUMP_CLASS_FILES_COUNTERS;
    /** debugging flag for saving generated class files */
    private final static File DUMP_CLASS_FILES_DIR;

    static {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (DUMP_CLASS_FILES) {</span>
<span class="nc" id="L132">            DUMP_CLASS_FILES_COUNTERS = new HashMap&lt;&gt;();</span>
            try {
<span class="nc" id="L134">                File dumpDir = new File(&quot;DUMP_CLASS_FILES&quot;);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">                if (!dumpDir.exists()) {</span>
<span class="nc" id="L136">                    dumpDir.mkdirs();</span>
                }
<span class="nc" id="L138">                DUMP_CLASS_FILES_DIR = dumpDir;</span>
<span class="nc" id="L139">                System.out.println(&quot;Dumping class files to &quot;+DUMP_CLASS_FILES_DIR+&quot;/...&quot;);</span>
<span class="nc" id="L140">            } catch (Exception e) {</span>
<span class="nc" id="L141">                throw newInternalError(e);</span>
<span class="nc" id="L142">            }</span>
        } else {
<span class="fc" id="L144">            DUMP_CLASS_FILES_COUNTERS = null;</span>
<span class="fc" id="L145">            DUMP_CLASS_FILES_DIR = null;</span>
        }
    }

    static void maybeDump(final String className, final byte[] classFile) {
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">        if (DUMP_CLASS_FILES) {</span>
<span class="nc" id="L151">            System.out.println(&quot;dump: &quot; + className);</span>
<span class="nc" id="L152">            java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L153">            new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
                    try {
<span class="nc" id="L156">                        String dumpName = className;</span>
                        //dumpName = dumpName.replace('/', '-');
<span class="nc" id="L158">                        File dumpFile = new File(DUMP_CLASS_FILES_DIR, dumpName+&quot;.class&quot;);</span>
<span class="nc" id="L159">                        dumpFile.getParentFile().mkdirs();</span>
<span class="nc" id="L160">                        FileOutputStream file = new FileOutputStream(dumpFile);</span>
<span class="nc" id="L161">                        file.write(classFile);</span>
<span class="nc" id="L162">                        file.close();</span>
<span class="nc" id="L163">                        return null;</span>
<span class="nc" id="L164">                    } catch (IOException ex) {</span>
<span class="nc" id="L165">                        throw newInternalError(ex);</span>
                    }
                }
            });
        }

<span class="fc" id="L171">    }</span>

    private static String makeDumpableClassName(String className) {
        Integer ctr;
<span class="nc" id="L175">        synchronized (DUMP_CLASS_FILES_COUNTERS) {</span>
<span class="nc" id="L176">            ctr = DUMP_CLASS_FILES_COUNTERS.get(className);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (ctr == null)  ctr = 0;</span>
<span class="nc" id="L178">            DUMP_CLASS_FILES_COUNTERS.put(className, ctr+1);</span>
<span class="nc" id="L179">        }</span>
<span class="nc" id="L180">        String sfx = ctr.toString();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        while (sfx.length() &lt; 3)</span>
<span class="nc" id="L182">            sfx = &quot;0&quot;+sfx;</span>
<span class="nc" id="L183">        className += sfx;</span>
<span class="nc" id="L184">        return className;</span>
    }

    class CpPatch {
        final int index;
        final String placeholder;
        final Object value;
<span class="fc" id="L191">        CpPatch(int index, String placeholder, Object value) {</span>
<span class="fc" id="L192">            this.index = index;</span>
<span class="fc" id="L193">            this.placeholder = placeholder;</span>
<span class="fc" id="L194">            this.value = value;</span>
<span class="fc" id="L195">        }</span>
        public String toString() {
<span class="nc" id="L197">            return &quot;CpPatch/index=&quot;+index+&quot;,placeholder=&quot;+placeholder+&quot;,value=&quot;+value;</span>
        }
    }

<span class="fc" id="L201">    Map&lt;Object, CpPatch&gt; cpPatches = new HashMap&lt;&gt;();</span>

<span class="fc" id="L203">    int cph = 0;  // for counting constant placeholders</span>

    String constantPlaceholder(Object arg) {
<span class="fc" id="L206">        String cpPlaceholder = &quot;CONSTANT_PLACEHOLDER_&quot; + cph++;</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (DUMP_CLASS_FILES) cpPlaceholder += &quot; &lt;&lt;&quot; + arg.toString() + &quot;&gt;&gt;&quot;;  // debugging aid</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">        if (cpPatches.containsKey(cpPlaceholder)) {</span>
<span class="nc" id="L209">            throw new InternalError(&quot;observed CP placeholder twice: &quot; + cpPlaceholder);</span>
        }
        // insert placeholder in CP and remember the patch
<span class="fc" id="L212">        int index = cw.newConst((Object) cpPlaceholder);  // TODO check if aready in the constant pool</span>
<span class="fc" id="L213">        cpPatches.put(cpPlaceholder, new CpPatch(index, cpPlaceholder, arg));</span>
<span class="fc" id="L214">        return cpPlaceholder;</span>
    }

    Object[] cpPatches(byte[] classFile) {
<span class="fc" id="L218">        int size = getConstantPoolSize(classFile);</span>
<span class="fc" id="L219">        Object[] res = new Object[size];</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (CpPatch p : cpPatches.values()) {</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">            if (p.index &gt;= size)</span>
<span class="nc" id="L222">                throw new InternalError(&quot;in cpool[&quot;+size+&quot;]: &quot;+p+&quot;\n&quot;+Arrays.toString(Arrays.copyOf(classFile, 20)));</span>
<span class="fc" id="L223">            res[p.index] = p.value;</span>
<span class="fc" id="L224">        }</span>
<span class="fc" id="L225">        return res;</span>
    }

    /**
     * Extract the number of constant pool entries from a given class file.
     *
     * @param classFile the bytes of the class file in question.
     * @return the number of entries in the constant pool.
     */
    private static int getConstantPoolSize(byte[] classFile) {
        // The first few bytes:
        // u4 magic;
        // u2 minor_version;
        // u2 major_version;
        // u2 constant_pool_count;
<span class="fc" id="L240">        return ((classFile[8] &amp; 0xFF) &lt;&lt; 8) | (classFile[9] &amp; 0xFF);</span>
    }

    /**
     * Extract the MemberName of a newly-defined method.
     */
    private MemberName loadMethod(byte[] classFile) {
<span class="fc" id="L247">        Class&lt;?&gt; invokerClass = loadAndInitializeInvokerClass(classFile, cpPatches(classFile));</span>
<span class="fc" id="L248">        return resolveInvokerMember(invokerClass, invokerName, invokerType);</span>
    }

    /**
     * Define a given class as anonymous class in the runtime system.
     */
    private static Class&lt;?&gt; loadAndInitializeInvokerClass(byte[] classBytes, Object[] patches) {
<span class="fc" id="L255">        Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(HOST_CLASS, classBytes, patches);</span>
<span class="fc" id="L256">        UNSAFE.ensureClassInitialized(invokerClass);  // Make sure the class is initialized; VM might complain.</span>
<span class="fc" id="L257">        return invokerClass;</span>
    }

    private static MemberName resolveInvokerMember(Class&lt;?&gt; invokerClass, String name, MethodType type) {
<span class="fc" id="L261">        MemberName member = new MemberName(invokerClass, name, type, REF_invokeStatic);</span>
        //System.out.println(&quot;resolveInvokerMember =&gt; &quot;+member);
        //for (Method m : invokerClass.getDeclaredMethods())  System.out.println(&quot;  &quot;+m);
        try {
<span class="fc" id="L265">            member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);</span>
<span class="nc" id="L266">        } catch (ReflectiveOperationException e) {</span>
<span class="nc" id="L267">            throw newInternalError(e);</span>
<span class="fc" id="L268">        }</span>
        //System.out.println(&quot;resolveInvokerMember =&gt; &quot;+member);
<span class="fc" id="L270">        return member;</span>
    }

    /**
     * Set up class file generation.
     */
    private void classFilePrologue() {
<span class="fc" id="L277">        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>
<span class="fc" id="L278">        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, className, null, superName, null);</span>
<span class="fc" id="L279">        cw.visitSource(sourceFile, null);</span>

<span class="fc" id="L281">        String invokerDesc = invokerType.toMethodDescriptorString();</span>
<span class="fc" id="L282">        mv = cw.visitMethod(Opcodes.ACC_STATIC, invokerName, invokerDesc, null, null);</span>
<span class="fc" id="L283">    }</span>

    /**
     * Tear down class file generation.
     */
    private void classFileEpilogue() {
<span class="fc" id="L289">        mv.visitMaxs(0, 0);</span>
<span class="fc" id="L290">        mv.visitEnd();</span>
<span class="fc" id="L291">    }</span>

    /*
     * Low-level emit helpers.
     */
    private void emitConst(Object con) {
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (con == null) {</span>
<span class="nc" id="L298">            mv.visitInsn(Opcodes.ACONST_NULL);</span>
<span class="nc" id="L299">            return;</span>
        }
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (con instanceof Integer) {</span>
<span class="fc" id="L302">            emitIconstInsn((int) con);</span>
<span class="fc" id="L303">            return;</span>
        }
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (con instanceof Long) {</span>
<span class="nc" id="L306">            long x = (long) con;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">            if (x == (short) x) {</span>
<span class="nc" id="L308">                emitIconstInsn((int) x);</span>
<span class="nc" id="L309">                mv.visitInsn(Opcodes.I2L);</span>
<span class="nc" id="L310">                return;</span>
            }
        }
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (con instanceof Float) {</span>
<span class="nc" id="L314">            float x = (float) con;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (x == (short) x) {</span>
<span class="nc" id="L316">                emitIconstInsn((int) x);</span>
<span class="nc" id="L317">                mv.visitInsn(Opcodes.I2F);</span>
<span class="nc" id="L318">                return;</span>
            }
        }
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (con instanceof Double) {</span>
<span class="nc" id="L322">            double x = (double) con;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">            if (x == (short) x) {</span>
<span class="nc" id="L324">                emitIconstInsn((int) x);</span>
<span class="nc" id="L325">                mv.visitInsn(Opcodes.I2D);</span>
<span class="nc" id="L326">                return;</span>
            }
        }
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (con instanceof Boolean) {</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            emitIconstInsn((boolean) con ? 1 : 0);</span>
<span class="nc" id="L331">            return;</span>
        }
        // fall through:
<span class="nc" id="L334">        mv.visitLdcInsn(con);</span>
<span class="nc" id="L335">    }</span>

    private void emitIconstInsn(int i) {
        int opcode;
<span class="fc bfc" id="L339" title="All 7 branches covered.">        switch (i) {</span>
<span class="fc" id="L340">        case 0:  opcode = Opcodes.ICONST_0;  break;</span>
<span class="fc" id="L341">        case 1:  opcode = Opcodes.ICONST_1;  break;</span>
<span class="fc" id="L342">        case 2:  opcode = Opcodes.ICONST_2;  break;</span>
<span class="fc" id="L343">        case 3:  opcode = Opcodes.ICONST_3;  break;</span>
<span class="fc" id="L344">        case 4:  opcode = Opcodes.ICONST_4;  break;</span>
<span class="fc" id="L345">        case 5:  opcode = Opcodes.ICONST_5;  break;</span>
        default:
<span class="fc bfc" id="L347" title="All 2 branches covered.">            if (i == (byte) i) {</span>
<span class="fc" id="L348">                mv.visitIntInsn(Opcodes.BIPUSH, i &amp; 0xFF);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">            } else if (i == (short) i) {</span>
<span class="fc" id="L350">                mv.visitIntInsn(Opcodes.SIPUSH, (char) i);</span>
            } else {
<span class="nc" id="L352">                mv.visitLdcInsn(i);</span>
            }
<span class="fc" id="L354">            return;</span>
        }
<span class="fc" id="L356">        mv.visitInsn(opcode);</span>
<span class="fc" id="L357">    }</span>

    /*
     * NOTE: These load/store methods use the localsMap to find the correct index!
     */
    private void emitLoadInsn(char type, int index) {
        int opcode;
<span class="pc bpc" id="L364" title="1 of 6 branches missed.">        switch (type) {</span>
<span class="fc" id="L365">        case 'I':  opcode = Opcodes.ILOAD;  break;</span>
<span class="fc" id="L366">        case 'J':  opcode = Opcodes.LLOAD;  break;</span>
<span class="fc" id="L367">        case 'F':  opcode = Opcodes.FLOAD;  break;</span>
<span class="fc" id="L368">        case 'D':  opcode = Opcodes.DLOAD;  break;</span>
<span class="fc" id="L369">        case 'L':  opcode = Opcodes.ALOAD;  break;</span>
        default:
<span class="nc" id="L371">            throw new InternalError(&quot;unknown type: &quot; + type);</span>
        }
<span class="fc" id="L373">        mv.visitVarInsn(opcode, localsMap[index]);</span>
<span class="fc" id="L374">    }</span>
    private void emitAloadInsn(int index) {
<span class="fc" id="L376">        emitLoadInsn('L', index);</span>
<span class="fc" id="L377">    }</span>

    private void emitStoreInsn(char type, int index) {
        int opcode;
<span class="pc bpc" id="L381" title="1 of 6 branches missed.">        switch (type) {</span>
<span class="fc" id="L382">        case 'I':  opcode = Opcodes.ISTORE;  break;</span>
<span class="fc" id="L383">        case 'J':  opcode = Opcodes.LSTORE;  break;</span>
<span class="fc" id="L384">        case 'F':  opcode = Opcodes.FSTORE;  break;</span>
<span class="fc" id="L385">        case 'D':  opcode = Opcodes.DSTORE;  break;</span>
<span class="fc" id="L386">        case 'L':  opcode = Opcodes.ASTORE;  break;</span>
        default:
<span class="nc" id="L388">            throw new InternalError(&quot;unknown type: &quot; + type);</span>
        }
<span class="fc" id="L390">        mv.visitVarInsn(opcode, localsMap[index]);</span>
<span class="fc" id="L391">    }</span>
    private void emitAstoreInsn(int index) {
<span class="nc" id="L393">        emitStoreInsn('L', index);</span>
<span class="nc" id="L394">    }</span>

    /**
     * Emit a boxing call.
     *
     * @param type primitive type class to box.
     */
    private void emitBoxing(Class&lt;?&gt; type) {
<span class="fc" id="L402">        Wrapper wrapper = Wrapper.forPrimitiveType(type);</span>
<span class="fc" id="L403">        String owner = &quot;java/lang/&quot; + wrapper.wrapperType().getSimpleName();</span>
<span class="fc" id="L404">        String name  = &quot;valueOf&quot;;</span>
<span class="fc" id="L405">        String desc  = &quot;(&quot; + wrapper.basicTypeChar() + &quot;)L&quot; + owner + &quot;;&quot;;</span>
<span class="fc" id="L406">        mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, desc);</span>
<span class="fc" id="L407">    }</span>

    /**
     * Emit an unboxing call (plus preceding checkcast).
     *
     * @param type wrapper type class to unbox.
     */
    private void emitUnboxing(Class&lt;?&gt; type) {
<span class="fc" id="L415">        Wrapper wrapper = Wrapper.forWrapperType(type);</span>
<span class="fc" id="L416">        String owner = &quot;java/lang/&quot; + wrapper.wrapperType().getSimpleName();</span>
<span class="fc" id="L417">        String name  = wrapper.primitiveSimpleName() + &quot;Value&quot;;</span>
<span class="fc" id="L418">        String desc  = &quot;()&quot; + wrapper.basicTypeChar();</span>
<span class="fc" id="L419">        mv.visitTypeInsn(Opcodes.CHECKCAST, owner);</span>
<span class="fc" id="L420">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, desc);</span>
<span class="fc" id="L421">    }</span>

    /**
     * Emit an implicit conversion.
     *
     * @param ptype type of value present on stack
     * @param pclass type of value required on stack
     */
    private void emitImplicitConversion(char ptype, Class&lt;?&gt; pclass) {
<span class="pc bpc" id="L430" title="1 of 6 branches missed.">        switch (ptype) {</span>
        case 'L':
<span class="fc bfc" id="L432" title="All 2 branches covered.">            if (VerifyType.isNullConversion(Object.class, pclass))</span>
<span class="fc" id="L433">                return;</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">            if (isStaticallyNameable(pclass)) {</span>
<span class="fc" id="L435">                mv.visitTypeInsn(Opcodes.CHECKCAST, getInternalName(pclass));</span>
            } else {
<span class="fc" id="L437">                mv.visitLdcInsn(constantPlaceholder(pclass));</span>
<span class="fc" id="L438">                mv.visitTypeInsn(Opcodes.CHECKCAST, CLS);</span>
<span class="fc" id="L439">                mv.visitInsn(Opcodes.SWAP);</span>
<span class="fc" id="L440">                mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, &quot;cast&quot;, LL_SIG);</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">                if (pclass.isArray())</span>
<span class="nc" id="L442">                    mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);</span>
            }
<span class="fc" id="L444">            return;</span>
        case 'I':
<span class="fc bfc" id="L446" title="All 2 branches covered.">            if (!VerifyType.isNullConversion(int.class, pclass))</span>
<span class="fc" id="L447">                emitPrimCast(ptype, Wrapper.basicTypeChar(pclass));</span>
<span class="fc" id="L448">            return;</span>
        case 'J':
<span class="pc bpc" id="L450" title="1 of 4 branches missed.">            assert(pclass == long.class);</span>
<span class="fc" id="L451">            return;</span>
        case 'F':
<span class="pc bpc" id="L453" title="1 of 4 branches missed.">            assert(pclass == float.class);</span>
<span class="fc" id="L454">            return;</span>
        case 'D':
<span class="pc bpc" id="L456" title="1 of 4 branches missed.">            assert(pclass == double.class);</span>
<span class="fc" id="L457">            return;</span>
        }
<span class="nc" id="L459">        throw new InternalError(&quot;bad implicit conversion: tc=&quot;+ptype+&quot;: &quot;+pclass);</span>
    }

    /**
     * Emits an actual return instruction conforming to the given return type.
     */
    private void emitReturnInsn(Class&lt;?&gt; type) {
        int opcode;
<span class="pc bpc" id="L467" title="1 of 7 branches missed.">        switch (Wrapper.basicTypeChar(type)) {</span>
<span class="fc" id="L468">        case 'I':  opcode = Opcodes.IRETURN;  break;</span>
<span class="fc" id="L469">        case 'J':  opcode = Opcodes.LRETURN;  break;</span>
<span class="fc" id="L470">        case 'F':  opcode = Opcodes.FRETURN;  break;</span>
<span class="fc" id="L471">        case 'D':  opcode = Opcodes.DRETURN;  break;</span>
<span class="fc" id="L472">        case 'L':  opcode = Opcodes.ARETURN;  break;</span>
<span class="fc" id="L473">        case 'V':  opcode = Opcodes.RETURN;   break;</span>
        default:
<span class="nc" id="L475">            throw new InternalError(&quot;unknown return type: &quot; + type);</span>
        }
<span class="fc" id="L477">        mv.visitInsn(opcode);</span>
<span class="fc" id="L478">    }</span>

    private static String getInternalName(Class&lt;?&gt; c) {
<span class="pc bpc" id="L481" title="1 of 4 branches missed.">        assert(VerifyAccess.isTypeVisible(c, Object.class));</span>
<span class="fc" id="L482">        return c.getName().replace('.', '/');</span>
    }

    /**
     * Generate customized bytecode for a given LambdaForm.
     */
    static MemberName generateCustomizedCode(LambdaForm form, MethodType invokerType) {
<span class="fc" id="L489">        InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;MH&quot;, form, invokerType);</span>
<span class="fc" id="L490">        return g.loadMethod(g.generateCustomizedCodeBytes());</span>
    }

    /**
     * Generate an invoker method for the passed {@link LambdaForm}.
     */
    private byte[] generateCustomizedCodeBytes() {
<span class="fc" id="L497">        classFilePrologue();</span>

        // Suppress this method in backtraces displayed to the user.
<span class="fc" id="L500">        mv.visitAnnotation(&quot;Ljava/lang/invoke/LambdaForm$Hidden;&quot;, true);</span>

        // Mark this method as a compiled LambdaForm
<span class="fc" id="L503">        mv.visitAnnotation(&quot;Ljava/lang/invoke/LambdaForm$Compiled;&quot;, true);</span>

        // Force inlining of this invoker method.
<span class="fc" id="L506">        mv.visitAnnotation(&quot;Ljava/lang/invoke/ForceInline;&quot;, true);</span>

        // iterate over the form's names, generating bytecode instructions for each
        // start iterating at the first name following the arguments
<span class="fc bfc" id="L510" title="All 2 branches covered.">        for (int i = lambdaForm.arity; i &lt; lambdaForm.names.length; i++) {</span>
<span class="fc" id="L511">            Name name = lambdaForm.names[i];</span>
<span class="fc" id="L512">            MemberName member = name.function.member();</span>

<span class="pc bpc" id="L514" title="1 of 2 branches missed.">            if (isSelectAlternative(member)) {</span>
                // selectAlternative idiom
                // FIXME: make sure this idiom is really present!
<span class="nc" id="L517">                emitSelectAlternative(name, lambdaForm.names[i + 1]);</span>
<span class="nc" id="L518">                i++;  // skip MH.invokeBasic of the selectAlternative result</span>
<span class="fc bfc" id="L519" title="All 2 branches covered.">            } else if (isStaticallyInvocable(member)) {</span>
<span class="fc" id="L520">                emitStaticInvoke(member, name);</span>
            } else {
<span class="fc" id="L522">                emitInvoke(name);</span>
            }

            // store the result from evaluating to the target name in a local if required
            // (if this is the last value, i.e., the one that is going to be returned,
            // avoid store/load/return and just return)
<span class="fc bfc" id="L528" title="All 4 branches covered.">            if (i == lambdaForm.names.length - 1 &amp;&amp; i == lambdaForm.result) {</span>
                // return value - do nothing
<span class="fc bfc" id="L530" title="All 2 branches covered.">            } else if (name.type != 'V') {</span>
                // non-void: actually assign
<span class="fc" id="L532">                emitStoreInsn(name.type, name.index());</span>
            }
        }

        // return statement
<span class="fc" id="L537">        emitReturn();</span>

<span class="fc" id="L539">        classFileEpilogue();</span>
<span class="fc" id="L540">        bogusMethod(lambdaForm);</span>

<span class="fc" id="L542">        final byte[] classFile = cw.toByteArray();</span>
<span class="fc" id="L543">        maybeDump(className, classFile);</span>
<span class="fc" id="L544">        return classFile;</span>
    }

    /**
     * Emit an invoke for the given name.
     */
    void emitInvoke(Name name) {
        if (true) {
            // push receiver
<span class="fc" id="L553">            MethodHandle target = name.function.resolvedHandle;</span>
<span class="pc bpc" id="L554" title="1 of 4 branches missed.">            assert(target != null) : name.exprString();</span>
<span class="fc" id="L555">            mv.visitLdcInsn(constantPlaceholder(target));</span>
<span class="fc" id="L556">            mv.visitTypeInsn(Opcodes.CHECKCAST, MH);</span>
        } else {
            // load receiver
            emitAloadInsn(0);
            mv.visitTypeInsn(Opcodes.CHECKCAST, MH);
            mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, LF_SIG);
            mv.visitFieldInsn(Opcodes.GETFIELD, LF, &quot;names&quot;, LFN_SIG);
            // TODO more to come
        }

        // push arguments
<span class="fc bfc" id="L567" title="All 2 branches covered.">        for (int i = 0; i &lt; name.arguments.length; i++) {</span>
<span class="fc" id="L568">            emitPushArgument(name, i);</span>
        }

        // invocation
<span class="fc" id="L572">        MethodType type = name.function.methodType();</span>
<span class="fc" id="L573">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString());</span>
<span class="fc" id="L574">    }</span>

<span class="fc" id="L576">    static private Class&lt;?&gt;[] STATICALLY_INVOCABLE_PACKAGES = {</span>
        // Sample classes from each package we are willing to bind to statically:
        java.lang.Object.class,
        java.util.Arrays.class,
        sun.misc.Unsafe.class
        //MethodHandle.class already covered
    };

    static boolean isStaticallyInvocable(MemberName member) {
<span class="fc bfc" id="L585" title="All 2 branches covered.">        if (member == null)  return false;</span>
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        if (member.isConstructor())  return false;</span>
<span class="fc" id="L587">        Class&lt;?&gt; cls = member.getDeclaringClass();</span>
<span class="pc bpc" id="L588" title="2 of 4 branches missed.">        if (cls.isArray() || cls.isPrimitive())</span>
<span class="nc" id="L589">            return false;  // FIXME</span>
<span class="pc bpc" id="L590" title="2 of 4 branches missed.">        if (cls.isAnonymousClass() || cls.isLocalClass())</span>
<span class="nc" id="L591">            return false;  // inner class of some sort</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">        if (cls.getClassLoader() != MethodHandle.class.getClassLoader())</span>
<span class="fc" id="L593">            return false;  // not on BCP</span>
<span class="fc" id="L594">        MethodType mtype = member.getMethodOrFieldType();</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">        if (!isStaticallyNameable(mtype.returnType()))</span>
<span class="nc" id="L596">            return false;</span>
<span class="fc bfc" id="L597" title="All 2 branches covered.">        for (Class&lt;?&gt; ptype : mtype.parameterArray())</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">            if (!isStaticallyNameable(ptype))</span>
<span class="nc" id="L599">                return false;</span>
<span class="fc bfc" id="L600" title="All 4 branches covered.">        if (!member.isPrivate() &amp;&amp; VerifyAccess.isSamePackage(MethodHandle.class, cls))</span>
<span class="fc" id="L601">            return true;   // in java.lang.invoke package</span>
<span class="pc bpc" id="L602" title="1 of 4 branches missed.">        if (member.isPublic() &amp;&amp; isStaticallyNameable(cls))</span>
<span class="fc" id="L603">            return true;</span>
<span class="fc" id="L604">        return false;</span>
    }

    static boolean isStaticallyNameable(Class&lt;?&gt; cls) {
<span class="fc bfc" id="L608" title="All 2 branches covered.">        while (cls.isArray())</span>
<span class="fc" id="L609">            cls = cls.getComponentType();</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">        if (cls.isPrimitive())</span>
<span class="fc" id="L611">            return true;  // int[].class, for example</span>
        // could use VerifyAccess.isClassAccessible but the following is a safe approximation
<span class="fc bfc" id="L613" title="All 2 branches covered.">        if (cls.getClassLoader() != Object.class.getClassLoader())</span>
<span class="fc" id="L614">            return false;</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">        if (VerifyAccess.isSamePackage(MethodHandle.class, cls))</span>
<span class="fc" id="L616">            return true;</span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        if (!Modifier.isPublic(cls.getModifiers()))</span>
<span class="nc" id="L618">            return false;</span>
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">        for (Class&lt;?&gt; pkgcls : STATICALLY_INVOCABLE_PACKAGES) {</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">            if (VerifyAccess.isSamePackage(pkgcls, cls))</span>
<span class="fc" id="L621">                return true;</span>
        }
<span class="nc" id="L623">        return false;</span>
    }

    /**
     * Emit an invoke for the given name, using the MemberName directly.
     */
    void emitStaticInvoke(MemberName member, Name name) {
<span class="pc bpc" id="L630" title="1 of 4 branches missed.">        assert(member.equals(name.function.member()));</span>
<span class="fc" id="L631">        String cname = getInternalName(member.getDeclaringClass());</span>
<span class="fc" id="L632">        String mname = member.getName();</span>
        String mtype;
<span class="fc" id="L634">        byte refKind = member.getReferenceKind();</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">        if (refKind == REF_invokeSpecial) {</span>
            // in order to pass the verifier, we need to convert this to invokevirtual in all cases
<span class="pc bpc" id="L637" title="1 of 4 branches missed.">            assert(member.canBeStaticallyBound()) : member;</span>
<span class="fc" id="L638">            refKind = REF_invokeVirtual;</span>
        }

        // push arguments
<span class="fc bfc" id="L642" title="All 2 branches covered.">        for (int i = 0; i &lt; name.arguments.length; i++) {</span>
<span class="fc" id="L643">            emitPushArgument(name, i);</span>
        }

        // invocation
<span class="fc bfc" id="L647" title="All 2 branches covered.">        if (member.isMethod()) {</span>
<span class="fc" id="L648">            mtype = member.getMethodType().toMethodDescriptorString();</span>
<span class="fc" id="L649">            mv.visitMethodInsn(refKindOpcode(refKind), cname, mname, mtype,</span>
<span class="fc" id="L650">                               member.getDeclaringClass().isInterface());</span>
        } else {
<span class="fc" id="L652">            mtype = MethodType.toFieldDescriptorString(member.getFieldType());</span>
<span class="fc" id="L653">            mv.visitFieldInsn(refKindOpcode(refKind), cname, mname, mtype);</span>
        }
<span class="fc" id="L655">    }</span>
    int refKindOpcode(byte refKind) {
<span class="pc bpc" id="L657" title="6 of 9 branches missed.">        switch (refKind) {</span>
<span class="fc" id="L658">        case REF_invokeVirtual:      return Opcodes.INVOKEVIRTUAL;</span>
<span class="fc" id="L659">        case REF_invokeStatic:       return Opcodes.INVOKESTATIC;</span>
<span class="nc" id="L660">        case REF_invokeSpecial:      return Opcodes.INVOKESPECIAL;</span>
<span class="nc" id="L661">        case REF_invokeInterface:    return Opcodes.INVOKEINTERFACE;</span>
<span class="fc" id="L662">        case REF_getField:           return Opcodes.GETFIELD;</span>
<span class="nc" id="L663">        case REF_putField:           return Opcodes.PUTFIELD;</span>
<span class="nc" id="L664">        case REF_getStatic:          return Opcodes.GETSTATIC;</span>
<span class="nc" id="L665">        case REF_putStatic:          return Opcodes.PUTSTATIC;</span>
        }
<span class="nc" id="L667">        throw new InternalError(&quot;refKind=&quot;+refKind);</span>
    }

    /**
     * Check if MemberName is a call to MethodHandleImpl.selectAlternative.
     */
    private boolean isSelectAlternative(MemberName member) {
<span class="fc bfc" id="L674" title="All 2 branches covered.">        return member != null &amp;&amp;</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">               member.getDeclaringClass() == MethodHandleImpl.class &amp;&amp;</span>
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">               member.getName().equals(&quot;selectAlternative&quot;);</span>
    }

    /**
     * Emit bytecode for the selectAlternative idiom.
     *
     * The pattern looks like (Cf. MethodHandleImpl.makeGuardWithTest):
     * &lt;blockquote&gt;&lt;pre&gt;{@code
     *   Lambda(a0:L,a1:I)=&gt;{
     *     t2:I=foo.test(a1:I);
     *     t3:L=MethodHandleImpl.selectAlternative(t2:I,(MethodHandle(int)int),(MethodHandle(int)int));
     *     t4:I=MethodHandle.invokeBasic(t3:L,a1:I);t4:I}
     * }&lt;/pre&gt;&lt;/blockquote&gt;
     */
    private void emitSelectAlternative(Name selectAlternativeName, Name invokeBasicName) {
<span class="nc" id="L691">        MethodType type = selectAlternativeName.function.methodType();</span>

<span class="nc" id="L693">        Name receiver = (Name) invokeBasicName.arguments[0];</span>

<span class="nc" id="L695">        Label L_fallback = new Label();</span>
<span class="nc" id="L696">        Label L_done     = new Label();</span>

        // load test result
<span class="nc" id="L699">        emitPushArgument(selectAlternativeName, 0);</span>
<span class="nc" id="L700">        mv.visitInsn(Opcodes.ICONST_1);</span>

        // if_icmpne L_fallback
<span class="nc" id="L703">        mv.visitJumpInsn(Opcodes.IF_ICMPNE, L_fallback);</span>

        // invoke selectAlternativeName.arguments[1]
<span class="nc" id="L706">        MethodHandle target = (MethodHandle) selectAlternativeName.arguments[1];</span>
<span class="nc" id="L707">        emitPushArgument(selectAlternativeName, 1);  // get 2nd argument of selectAlternative</span>
<span class="nc" id="L708">        emitAstoreInsn(receiver.index());  // store the MH in the receiver slot</span>
<span class="nc" id="L709">        emitInvoke(invokeBasicName);</span>

        // goto L_done
<span class="nc" id="L712">        mv.visitJumpInsn(Opcodes.GOTO, L_done);</span>

        // L_fallback:
<span class="nc" id="L715">        mv.visitLabel(L_fallback);</span>

        // invoke selectAlternativeName.arguments[2]
<span class="nc" id="L718">        MethodHandle fallback = (MethodHandle) selectAlternativeName.arguments[2];</span>
<span class="nc" id="L719">        emitPushArgument(selectAlternativeName, 2);  // get 3rd argument of selectAlternative</span>
<span class="nc" id="L720">        emitAstoreInsn(receiver.index());  // store the MH in the receiver slot</span>
<span class="nc" id="L721">        emitInvoke(invokeBasicName);</span>

        // L_done:
<span class="nc" id="L724">        mv.visitLabel(L_done);</span>
<span class="nc" id="L725">    }</span>

    private void emitPushArgument(Name name, int paramIndex) {
<span class="fc" id="L728">        Object arg = name.arguments[paramIndex];</span>
<span class="fc" id="L729">        char ptype = name.function.parameterType(paramIndex);</span>
<span class="fc" id="L730">        MethodType mtype = name.function.methodType();</span>
<span class="fc bfc" id="L731" title="All 2 branches covered.">        if (arg instanceof Name) {</span>
<span class="fc" id="L732">            Name n = (Name) arg;</span>
<span class="fc" id="L733">            emitLoadInsn(n.type, n.index());</span>
<span class="fc" id="L734">            emitImplicitConversion(n.type, mtype.parameterType(paramIndex));</span>
<span class="pc bpc" id="L735" title="4 of 6 branches missed.">        } else if ((arg == null || arg instanceof String) &amp;&amp; ptype == 'L') {</span>
<span class="nc" id="L736">            emitConst(arg);</span>
        } else {
<span class="pc bpc" id="L738" title="1 of 4 branches missed.">            if (Wrapper.isWrapperType(arg.getClass()) &amp;&amp; ptype != 'L') {</span>
<span class="fc" id="L739">                emitConst(arg);</span>
            } else {
<span class="fc" id="L741">                mv.visitLdcInsn(constantPlaceholder(arg));</span>
<span class="fc" id="L742">                emitImplicitConversion('L', mtype.parameterType(paramIndex));</span>
            }
        }
<span class="fc" id="L745">    }</span>

    /**
     * Emits a return statement from a LF invoker. If required, the result type is cast to the correct return type.
     */
    private void emitReturn() {
        // return statement
<span class="fc bfc" id="L752" title="All 2 branches covered.">        if (lambdaForm.result == -1) {</span>
            // void
<span class="fc" id="L754">            mv.visitInsn(Opcodes.RETURN);</span>
        } else {
<span class="fc" id="L756">            LambdaForm.Name rn = lambdaForm.names[lambdaForm.result];</span>
<span class="fc" id="L757">            char rtype = Wrapper.basicTypeChar(invokerType.returnType());</span>

            // put return value on the stack if it is not already there
<span class="fc bfc" id="L760" title="All 2 branches covered.">            if (lambdaForm.result != lambdaForm.names.length - 1) {</span>
<span class="fc" id="L761">                emitLoadInsn(rn.type, lambdaForm.result);</span>
            }

            // potentially generate cast
            // rtype is the return type of the invoker - generated code must conform to this
            // rn.type is the type of the result Name in the LF
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">            if (rtype != rn.type) {</span>
                // need cast
<span class="nc bnc" id="L769" title="All 2 branches missed.">                if (rtype == 'L') {</span>
                    // possibly cast the primitive to the correct type for boxing
<span class="nc" id="L771">                    char boxedType = Wrapper.forWrapperType(invokerType.returnType()).basicTypeChar();</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">                    if (boxedType != rn.type) {</span>
<span class="nc" id="L773">                        emitPrimCast(rn.type, boxedType);</span>
                    }
                    // cast primitive to reference (&quot;boxing&quot;)
<span class="nc" id="L776">                    emitBoxing(invokerType.returnType());</span>
<span class="nc" id="L777">                } else {</span>
                    // to-primitive cast
<span class="nc bnc" id="L779" title="All 2 branches missed.">                    if (rn.type != 'L') {</span>
                        // prim-to-prim cast
<span class="nc" id="L781">                        emitPrimCast(rn.type, rtype);</span>
                    } else {
                        // ref-to-prim cast (&quot;unboxing&quot;)
<span class="nc" id="L784">                        throw new InternalError(&quot;no ref-to-prim (unboxing) casts supported right now&quot;);</span>
                    }
                }
            }

            // generate actual return statement
<span class="fc" id="L790">            emitReturnInsn(invokerType.returnType());</span>
        }
<span class="fc" id="L792">    }</span>

    /**
     * Emit a type conversion bytecode casting from &quot;from&quot; to &quot;to&quot;.
     */
    private void emitPrimCast(char from, char to) {
        // Here's how.
        // -   indicates forbidden
        // &lt;-&gt; indicates implicit
        //      to ----&gt; boolean  byte     short    char     int      long     float    double
        // from boolean    &lt;-&gt;        -        -        -        -        -        -        -
        //      byte        -       &lt;-&gt;       i2s      i2c      &lt;-&gt;      i2l      i2f      i2d
        //      short       -       i2b       &lt;-&gt;      i2c      &lt;-&gt;      i2l      i2f      i2d
        //      char        -       i2b       i2s      &lt;-&gt;      &lt;-&gt;      i2l      i2f      i2d
        //      int         -       i2b       i2s      i2c      &lt;-&gt;      i2l      i2f      i2d
        //      long        -     l2i,i2b   l2i,i2s  l2i,i2c    l2i      &lt;-&gt;      l2f      l2d
        //      float       -     f2i,i2b   f2i,i2s  f2i,i2c    f2i      f2l      &lt;-&gt;      f2d
        //      double      -     d2i,i2b   d2i,i2s  d2i,i2c    d2i      d2l      d2f      &lt;-&gt;
<span class="fc bfc" id="L810" title="All 2 branches covered.">        if (from == to) {</span>
            // no cast required, should be dead code anyway
<span class="fc" id="L812">            return;</span>
        }
<span class="fc" id="L814">        Wrapper wfrom = Wrapper.forBasicType(from);</span>
<span class="fc" id="L815">        Wrapper wto   = Wrapper.forBasicType(to);</span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">        if (wfrom.isSubwordOrInt()) {</span>
            // cast from {byte,short,char,int} to anything
<span class="fc" id="L818">            emitI2X(to);</span>
        } else {
            // cast from {long,float,double} to anything
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if (wto.isSubwordOrInt()) {</span>
                // cast to {byte,short,char,int}
<span class="nc" id="L823">                emitX2I(from);</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">                if (wto.bitWidth() &lt; 32) {</span>
                    // targets other than int require another conversion
<span class="nc" id="L826">                    emitI2X(to);</span>
                }
            } else {
                // cast to {long,float,double} - this is verbose
<span class="nc" id="L830">                boolean error = false;</span>
<span class="nc bnc" id="L831" title="All 4 branches missed.">                switch (from) {</span>
                case 'J':
<span class="nc bnc" id="L833" title="All 2 branches missed.">                         if (to == 'F') { mv.visitInsn(Opcodes.L2F); }</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">                    else if (to == 'D') { mv.visitInsn(Opcodes.L2D); }</span>
<span class="nc" id="L835">                    else error = true;</span>
<span class="nc" id="L836">                    break;</span>
                case 'F':
<span class="nc bnc" id="L838" title="All 2 branches missed.">                         if (to == 'J') { mv.visitInsn(Opcodes.F2L); }</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">                    else if (to == 'D') { mv.visitInsn(Opcodes.F2D); }</span>
<span class="nc" id="L840">                    else error = true;</span>
<span class="nc" id="L841">                    break;</span>
                case 'D':
<span class="nc bnc" id="L843" title="All 2 branches missed.">                         if (to == 'J') { mv.visitInsn(Opcodes.D2L); }</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">                    else if (to == 'F') { mv.visitInsn(Opcodes.D2F); }</span>
<span class="nc" id="L845">                    else error = true;</span>
<span class="nc" id="L846">                    break;</span>
                default:
<span class="nc" id="L848">                    error = true;</span>
                    break;
                }
<span class="nc bnc" id="L851" title="All 2 branches missed.">                if (error) {</span>
<span class="nc" id="L852">                    throw new IllegalStateException(&quot;unhandled prim cast: &quot; + from + &quot;2&quot; + to);</span>
                }
            }
        }
<span class="fc" id="L856">    }</span>

    private void emitI2X(char type) {
<span class="pc bpc" id="L859" title="4 of 9 branches missed.">        switch (type) {</span>
<span class="fc" id="L860">        case 'B':  mv.visitInsn(Opcodes.I2B);  break;</span>
<span class="fc" id="L861">        case 'S':  mv.visitInsn(Opcodes.I2S);  break;</span>
<span class="fc" id="L862">        case 'C':  mv.visitInsn(Opcodes.I2C);  break;</span>
<span class="fc" id="L863">        case 'I':  /* naught */                break;</span>
<span class="nc" id="L864">        case 'J':  mv.visitInsn(Opcodes.I2L);  break;</span>
<span class="nc" id="L865">        case 'F':  mv.visitInsn(Opcodes.I2F);  break;</span>
<span class="nc" id="L866">        case 'D':  mv.visitInsn(Opcodes.I2D);  break;</span>
        case 'Z':
            // For compatibility with ValueConversions and explicitCastArguments:
<span class="fc" id="L869">            mv.visitInsn(Opcodes.ICONST_1);</span>
<span class="fc" id="L870">            mv.visitInsn(Opcodes.IAND);</span>
<span class="fc" id="L871">            break;</span>
<span class="nc" id="L872">        default:   throw new InternalError(&quot;unknown type: &quot; + type);</span>
        }
<span class="fc" id="L874">    }</span>

    private void emitX2I(char type) {
<span class="nc bnc" id="L877" title="All 4 branches missed.">        switch (type) {</span>
<span class="nc" id="L878">        case 'J':  mv.visitInsn(Opcodes.L2I);  break;</span>
<span class="nc" id="L879">        case 'F':  mv.visitInsn(Opcodes.F2I);  break;</span>
<span class="nc" id="L880">        case 'D':  mv.visitInsn(Opcodes.D2I);  break;</span>
<span class="nc" id="L881">        default:   throw new InternalError(&quot;unknown type: &quot; + type);</span>
        }
<span class="nc" id="L883">    }</span>

    private static String basicTypeCharSignature(String prefix, MethodType type) {
<span class="fc" id="L886">        StringBuilder buf = new StringBuilder(prefix);</span>
<span class="fc bfc" id="L887" title="All 2 branches covered.">        for (Class&lt;?&gt; ptype : type.parameterList())</span>
<span class="fc" id="L888">            buf.append(Wrapper.forBasicType(ptype).basicTypeChar());</span>
<span class="fc" id="L889">        buf.append('_').append(Wrapper.forBasicType(type.returnType()).basicTypeChar());</span>
<span class="fc" id="L890">        return buf.toString();</span>
    }

    /**
     * Generate bytecode for a LambdaForm.vmentry which calls interpretWithArguments.
     */
    static MemberName generateLambdaFormInterpreterEntryPoint(String sig) {
<span class="pc bpc" id="L897" title="1 of 4 branches missed.">        assert(LambdaForm.isValidSignature(sig));</span>
        //System.out.println(&quot;generateExactInvoker &quot;+sig);
        // compute method type
        // first parameter and return type
<span class="fc" id="L901">        char tret = LambdaForm.signatureReturn(sig);</span>
<span class="fc" id="L902">        MethodType type = MethodType.methodType(LambdaForm.typeClass(tret), MethodHandle.class);</span>
        // other parameter types
<span class="fc" id="L904">        int arity = LambdaForm.signatureArity(sig);</span>
<span class="fc bfc" id="L905" title="All 2 branches covered.">        for (int i = 1; i &lt; arity; i++) {</span>
<span class="fc" id="L906">            type = type.appendParameterTypes(LambdaForm.typeClass(sig.charAt(i)));</span>
        }
<span class="fc" id="L908">        InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;LFI&quot;, &quot;interpret_&quot;+tret, type);</span>
<span class="fc" id="L909">        return g.loadMethod(g.generateLambdaFormInterpreterEntryPointBytes());</span>
    }

    private byte[] generateLambdaFormInterpreterEntryPointBytes() {
<span class="fc" id="L913">        classFilePrologue();</span>

        // Suppress this method in backtraces displayed to the user.
<span class="fc" id="L916">        mv.visitAnnotation(&quot;Ljava/lang/invoke/LambdaForm$Hidden;&quot;, true);</span>

        // Don't inline the interpreter entry.
<span class="fc" id="L919">        mv.visitAnnotation(&quot;Ljava/lang/invoke/DontInline;&quot;, true);</span>

        // create parameter array
<span class="fc" id="L922">        emitIconstInsn(invokerType.parameterCount());</span>
<span class="fc" id="L923">        mv.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/Object&quot;);</span>

        // fill parameter array
<span class="fc bfc" id="L926" title="All 2 branches covered.">        for (int i = 0; i &lt; invokerType.parameterCount(); i++) {</span>
<span class="fc" id="L927">            Class&lt;?&gt; ptype = invokerType.parameterType(i);</span>
<span class="fc" id="L928">            mv.visitInsn(Opcodes.DUP);</span>
<span class="fc" id="L929">            emitIconstInsn(i);</span>
<span class="fc" id="L930">            emitLoadInsn(Wrapper.basicTypeChar(ptype), i);</span>
            // box if primitive type
<span class="fc bfc" id="L932" title="All 2 branches covered.">            if (ptype.isPrimitive()) {</span>
<span class="fc" id="L933">                emitBoxing(ptype);</span>
            }
<span class="fc" id="L935">            mv.visitInsn(Opcodes.AASTORE);</span>
        }
        // invoke
<span class="fc" id="L938">        emitAloadInsn(0);</span>
<span class="fc" id="L939">        mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, &quot;Ljava/lang/invoke/LambdaForm;&quot;);</span>
<span class="fc" id="L940">        mv.visitInsn(Opcodes.SWAP);  // swap form and array; avoid local variable</span>
<span class="fc" id="L941">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, LF, &quot;interpretWithArguments&quot;, &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;);</span>

        // maybe unbox
<span class="fc" id="L944">        Class&lt;?&gt; rtype = invokerType.returnType();</span>
<span class="fc bfc" id="L945" title="All 4 branches covered.">        if (rtype.isPrimitive() &amp;&amp; rtype != void.class) {</span>
<span class="fc" id="L946">            emitUnboxing(Wrapper.asWrapperType(rtype));</span>
        }

        // return statement
<span class="fc" id="L950">        emitReturnInsn(rtype);</span>

<span class="fc" id="L952">        classFileEpilogue();</span>
<span class="fc" id="L953">        bogusMethod(invokerType);</span>

<span class="fc" id="L955">        final byte[] classFile = cw.toByteArray();</span>
<span class="fc" id="L956">        maybeDump(className, classFile);</span>
<span class="fc" id="L957">        return classFile;</span>
    }

    /**
     * Generate bytecode for a NamedFunction invoker.
     */
    static MemberName generateNamedFunctionInvoker(MethodTypeForm typeForm) {
<span class="fc" id="L964">        MethodType invokerType = LambdaForm.NamedFunction.INVOKER_METHOD_TYPE;</span>
<span class="fc" id="L965">        String invokerName = basicTypeCharSignature(&quot;invoke_&quot;, typeForm.erasedType());</span>
<span class="fc" id="L966">        InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;NFI&quot;, invokerName, invokerType);</span>
<span class="fc" id="L967">        return g.loadMethod(g.generateNamedFunctionInvokerImpl(typeForm));</span>
    }

<span class="fc" id="L970">    static int nfi = 0;</span>

    private byte[] generateNamedFunctionInvokerImpl(MethodTypeForm typeForm) {
<span class="fc" id="L973">        MethodType dstType = typeForm.erasedType();</span>
<span class="fc" id="L974">        classFilePrologue();</span>

        // Suppress this method in backtraces displayed to the user.
<span class="fc" id="L977">        mv.visitAnnotation(&quot;Ljava/lang/invoke/LambdaForm$Hidden;&quot;, true);</span>

        // Force inlining of this invoker method.
<span class="fc" id="L980">        mv.visitAnnotation(&quot;Ljava/lang/invoke/ForceInline;&quot;, true);</span>

        // Load receiver
<span class="fc" id="L983">        emitAloadInsn(0);</span>

        // Load arguments from array
<span class="fc bfc" id="L986" title="All 2 branches covered.">        for (int i = 0; i &lt; dstType.parameterCount(); i++) {</span>
<span class="fc" id="L987">            emitAloadInsn(1);</span>
<span class="fc" id="L988">            emitIconstInsn(i);</span>
<span class="fc" id="L989">            mv.visitInsn(Opcodes.AALOAD);</span>

            // Maybe unbox
<span class="fc" id="L992">            Class&lt;?&gt; dptype = dstType.parameterType(i);</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">            if (dptype.isPrimitive()) {</span>
<span class="fc" id="L994">                Class&lt;?&gt; sptype = dstType.basicType().wrap().parameterType(i);</span>
<span class="fc" id="L995">                Wrapper dstWrapper = Wrapper.forBasicType(dptype);</span>
<span class="fc bfc" id="L996" title="All 2 branches covered.">                Wrapper srcWrapper = dstWrapper.isSubwordOrInt() ? Wrapper.INT : dstWrapper;  // narrow subword from int</span>
<span class="fc" id="L997">                emitUnboxing(srcWrapper.wrapperType());</span>
<span class="fc" id="L998">                emitPrimCast(srcWrapper.basicTypeChar(), dstWrapper.basicTypeChar());</span>
            }
        }

        // Invoke
<span class="fc" id="L1003">        String targetDesc = dstType.basicType().toMethodDescriptorString();</span>
<span class="fc" id="L1004">        mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, targetDesc);</span>

        // Box primitive types
<span class="fc" id="L1007">        Class&lt;?&gt; rtype = dstType.returnType();</span>
<span class="fc bfc" id="L1008" title="All 4 branches covered.">        if (rtype != void.class &amp;&amp; rtype.isPrimitive()) {</span>
<span class="fc" id="L1009">            Wrapper srcWrapper = Wrapper.forBasicType(rtype);</span>
<span class="fc bfc" id="L1010" title="All 2 branches covered.">            Wrapper dstWrapper = srcWrapper.isSubwordOrInt() ? Wrapper.INT : srcWrapper;  // widen subword to int</span>
            // boolean casts not allowed
<span class="fc" id="L1012">            emitPrimCast(srcWrapper.basicTypeChar(), dstWrapper.basicTypeChar());</span>
<span class="fc" id="L1013">            emitBoxing(dstWrapper.primitiveType());</span>
        }

        // If the return type is void we return a null reference.
<span class="fc bfc" id="L1017" title="All 2 branches covered.">        if (rtype == void.class) {</span>
<span class="fc" id="L1018">            mv.visitInsn(Opcodes.ACONST_NULL);</span>
        }
<span class="fc" id="L1020">        emitReturnInsn(Object.class);  // NOTE: NamedFunction invokers always return a reference value.</span>

<span class="fc" id="L1022">        classFileEpilogue();</span>
<span class="fc" id="L1023">        bogusMethod(dstType);</span>

<span class="fc" id="L1025">        final byte[] classFile = cw.toByteArray();</span>
<span class="fc" id="L1026">        maybeDump(className, classFile);</span>
<span class="fc" id="L1027">        return classFile;</span>
    }

    /**
     * Emit a bogus method that just loads some string constants. This is to get the constants into the constant pool
     * for debugging purposes.
     */
    private void bogusMethod(Object... os) {
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">        if (DUMP_CLASS_FILES) {</span>
<span class="nc" id="L1036">            mv = cw.visitMethod(Opcodes.ACC_STATIC, &quot;dummy&quot;, &quot;()V&quot;, null, null);</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            for (Object o : os) {</span>
<span class="nc" id="L1038">                mv.visitLdcInsn(o.toString());</span>
<span class="nc" id="L1039">                mv.visitInsn(Opcodes.POP);</span>
            }
<span class="nc" id="L1041">            mv.visitInsn(Opcodes.RETURN);</span>
<span class="nc" id="L1042">            mv.visitMaxs(0, 0);</span>
<span class="nc" id="L1043">            mv.visitEnd();</span>
        }
<span class="fc" id="L1045">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>