<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DirectMethodHandle.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">DirectMethodHandle.java</span></div><h1>DirectMethodHandle.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.invoke;

import sun.misc.Unsafe;
import java.lang.reflect.Method;
import java.util.Arrays;
import sun.invoke.util.VerifyAccess;
import static java.lang.invoke.MethodHandleNatives.Constants.*;
import static java.lang.invoke.LambdaForm.*;
import static java.lang.invoke.MethodTypeForm.*;
import static java.lang.invoke.MethodHandleStatics.*;
import java.lang.ref.WeakReference;
import java.lang.reflect.Field;
import sun.invoke.util.ValueConversions;
import sun.invoke.util.VerifyType;
import sun.invoke.util.Wrapper;

/**
 * The flavor of method handle which implements a constant reference
 * to a class member.
 * @author jrose
 */
<span class="fc bfc" id="L47" title="All 2 branches covered.">class DirectMethodHandle extends MethodHandle {</span>
    final MemberName member;

    // Constructors and factory methods in this class *must* be package scoped or private.
    private DirectMethodHandle(MethodType mtype, LambdaForm form, MemberName member) {
<span class="fc" id="L52">        super(mtype, form);</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (!member.isResolved())  throw new InternalError();</span>

<span class="fc bfc" id="L55" title="All 2 branches covered.">        if (member.getDeclaringClass().isInterface() &amp;&amp;</span>
<span class="fc bfc" id="L56" title="All 4 branches covered.">                member.isMethod() &amp;&amp; !member.isAbstract()) {</span>
            // Check for corner case: invokeinterface of Object method
<span class="fc" id="L58">            MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());</span>
<span class="fc" id="L59">            m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);</span>
<span class="pc bpc" id="L60" title="3 of 4 branches missed.">            if (m != null &amp;&amp; m.isPublic()) {</span>
<span class="nc" id="L61">                member = m;</span>
            }
        }

<span class="fc" id="L65">        this.member = member;</span>
<span class="fc" id="L66">    }</span>

    // Factory methods:
    static DirectMethodHandle make(byte refKind, Class&lt;?&gt; receiver, MemberName member) {
<span class="fc" id="L70">        MethodType mtype = member.getMethodOrFieldType();</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">        if (!member.isStatic()) {</span>
<span class="pc bpc" id="L72" title="2 of 4 branches missed.">            if (!member.getDeclaringClass().isAssignableFrom(receiver) || member.isConstructor())</span>
<span class="nc" id="L73">                throw new InternalError(member.toString());</span>
<span class="fc" id="L74">            mtype = mtype.insertParameterTypes(0, receiver);</span>
        }
<span class="fc bfc" id="L76" title="All 2 branches covered.">        if (!member.isField()) {</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">            if (refKind == REF_invokeSpecial) {</span>
<span class="fc" id="L78">                member = member.asSpecial();</span>
<span class="fc" id="L79">                LambdaForm lform = preparedLambdaForm(member);</span>
<span class="fc" id="L80">                return new Special(mtype, lform, member);</span>
            } else {
<span class="fc" id="L82">                LambdaForm lform = preparedLambdaForm(member);</span>
<span class="fc" id="L83">                return new DirectMethodHandle(mtype, lform, member);</span>
            }
        } else {
<span class="fc" id="L86">            LambdaForm lform = preparedFieldLambdaForm(member);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            if (member.isStatic()) {</span>
<span class="fc" id="L88">                long offset = MethodHandleNatives.staticFieldOffset(member);</span>
<span class="fc" id="L89">                Object base = MethodHandleNatives.staticFieldBase(member);</span>
<span class="fc" id="L90">                return new StaticAccessor(mtype, lform, member, base, offset);</span>
            } else {
<span class="fc" id="L92">                long offset = MethodHandleNatives.objectFieldOffset(member);</span>
<span class="pc bpc" id="L93" title="1 of 4 branches missed.">                assert(offset == (int)offset);</span>
<span class="fc" id="L94">                return new Accessor(mtype, lform, member, (int)offset);</span>
            }
        }
    }
    static DirectMethodHandle make(Class&lt;?&gt; receiver, MemberName member) {
<span class="fc" id="L99">        byte refKind = member.getReferenceKind();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (refKind == REF_invokeSpecial)</span>
<span class="fc" id="L101">            refKind =  REF_invokeVirtual;</span>
<span class="fc" id="L102">        return make(refKind, receiver, member);</span>
    }
    static DirectMethodHandle make(MemberName member) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (member.isConstructor())</span>
<span class="fc" id="L106">            return makeAllocator(member);</span>
<span class="fc" id="L107">        return make(member.getDeclaringClass(), member);</span>
    }
    static DirectMethodHandle make(Method method) {
<span class="nc" id="L110">        return make(method.getDeclaringClass(), new MemberName(method));</span>
    }
    static DirectMethodHandle make(Field field) {
<span class="nc" id="L113">        return make(field.getDeclaringClass(), new MemberName(field));</span>
    }
    private static DirectMethodHandle makeAllocator(MemberName ctor) {
<span class="pc bpc" id="L116" title="2 of 6 branches missed.">        assert(ctor.isConstructor() &amp;&amp; ctor.getName().equals(&quot;&lt;init&gt;&quot;));</span>
<span class="fc" id="L117">        Class&lt;?&gt; instanceClass = ctor.getDeclaringClass();</span>
<span class="fc" id="L118">        ctor = ctor.asConstructor();</span>
<span class="pc bpc" id="L119" title="2 of 6 branches missed.">        assert(ctor.isConstructor() &amp;&amp; ctor.getReferenceKind() == REF_newInvokeSpecial) : ctor;</span>
<span class="fc" id="L120">        MethodType mtype = ctor.getMethodType().changeReturnType(instanceClass);</span>
<span class="fc" id="L121">        LambdaForm lform = preparedLambdaForm(ctor);</span>
<span class="fc" id="L122">        MemberName init = ctor.asSpecial();</span>
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">        assert(init.getMethodType().returnType() == void.class);</span>
<span class="fc" id="L124">        return new Constructor(mtype, lform, ctor, init, instanceClass);</span>
    }

    @Override
    MethodHandle copyWith(MethodType mt, LambdaForm lf) {
<span class="nc" id="L129">        return new DirectMethodHandle(mt, lf, member);</span>
    }

    @Override
    String internalProperties() {
<span class="nc" id="L134">        return &quot;/DMH=&quot;+member.toString();</span>
    }

    //// Implementation methods.
    @Override
    MethodHandle viewAsType(MethodType newType) {
<span class="fc" id="L140">        return new DirectMethodHandle(newType, form, member);</span>
    }
    @Override
    @ForceInline
    MemberName internalMemberName() {
<span class="fc" id="L145">        return member;</span>
    }

    @Override
    MethodHandle bindArgument(int pos, char basicType, Object value) {
        // If the member needs dispatching, do so.
<span class="fc bfc" id="L151" title="All 4 branches covered.">        if (pos == 0 &amp;&amp; basicType == 'L') {</span>
<span class="fc" id="L152">            DirectMethodHandle concrete = maybeRebind(value);</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">            if (concrete != null)</span>
<span class="nc" id="L154">                return concrete.bindReceiver(value);</span>
        }
<span class="fc" id="L156">        return super.bindArgument(pos, basicType, value);</span>
    }

    @Override
    MethodHandle bindReceiver(Object receiver) {
        // If the member needs dispatching, do so.
<span class="fc" id="L162">        DirectMethodHandle concrete = maybeRebind(receiver);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (concrete != null)</span>
<span class="fc" id="L164">            return concrete.bindReceiver(receiver);</span>
<span class="fc" id="L165">        return super.bindReceiver(receiver);</span>
    }

<span class="fc" id="L168">    private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();</span>

    private DirectMethodHandle maybeRebind(Object receiver) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">        if (receiver != null) {</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">            switch (member.getReferenceKind()) {</span>
            case REF_invokeInterface:
            case REF_invokeVirtual:
                // Pre-dispatch the member.
<span class="fc" id="L176">                Class&lt;?&gt; concreteClass = receiver.getClass();</span>
<span class="fc" id="L177">                MemberName concrete = new MemberName(concreteClass, member.getName(), member.getMethodType(), REF_invokeSpecial);</span>
<span class="fc" id="L178">                concrete = IMPL_NAMES.resolveOrNull(REF_invokeSpecial, concrete, concreteClass);</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">                if (concrete != null)</span>
<span class="fc" id="L180">                    return new DirectMethodHandle(type(), preparedLambdaForm(concrete), concrete);</span>
                break;
            }
        }
<span class="fc" id="L184">        return null;</span>
    }

    /**
     * Create a LF which can invoke the given method.
     * Cache and share this structure among all methods with
     * the same basicType and refKind.
     */
    private static LambdaForm preparedLambdaForm(MemberName m) {
<span class="pc bpc" id="L193" title="1 of 4 branches missed.">        assert(m.isInvocable()) : m;  // call preparedFieldLambdaForm instead</span>
<span class="fc" id="L194">        MethodType mtype = m.getInvocationType().basicType();</span>
<span class="pc bpc" id="L195" title="3 of 6 branches missed.">        assert(!m.isMethodHandleInvoke() || &quot;invokeBasic&quot;.equals(m.getName())) : m;</span>
        int which;
<span class="pc bpc" id="L197" title="1 of 6 branches missed.">        switch (m.getReferenceKind()) {</span>
<span class="fc" id="L198">        case REF_invokeVirtual:    which = LF_INVVIRTUAL;    break;</span>
<span class="fc" id="L199">        case REF_invokeStatic:     which = LF_INVSTATIC;     break;</span>
<span class="fc" id="L200">        case REF_invokeSpecial:    which = LF_INVSPECIAL;    break;</span>
<span class="fc" id="L201">        case REF_invokeInterface:  which = LF_INVINTERFACE;  break;</span>
<span class="fc" id="L202">        case REF_newInvokeSpecial: which = LF_NEWINVSPECIAL; break;</span>
<span class="nc" id="L203">        default:  throw new InternalError(m.toString());</span>
        }
<span class="fc bfc" id="L205" title="All 4 branches covered.">        if (which == LF_INVSTATIC &amp;&amp; shouldBeInitialized(m)) {</span>
            // precompute the barrier-free version:
<span class="fc" id="L207">            preparedLambdaForm(mtype, which);</span>
<span class="fc" id="L208">            which = LF_INVSTATIC_INIT;</span>
        }
<span class="fc" id="L210">        LambdaForm lform = preparedLambdaForm(mtype, which);</span>
<span class="fc" id="L211">        maybeCompile(lform, m);</span>
<span class="pc bfc" id="L212" title="All 2 branches covered.">        assert(lform.methodType().dropParameterTypes(0, 1)</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">                .equals(m.getInvocationType().basicType()))</span>
<span class="nc" id="L214">                : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());</span>
<span class="fc" id="L215">        return lform;</span>
    }

    private static LambdaForm preparedLambdaForm(MethodType mtype, int which) {
<span class="fc" id="L219">        LambdaForm lform = mtype.form().cachedLambdaForm(which);</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">        if (lform != null)  return lform;</span>
<span class="fc" id="L221">        lform = makePreparedLambdaForm(mtype, which);</span>
<span class="fc" id="L222">        return mtype.form().setCachedLambdaForm(which, lform);</span>
    }

    private static LambdaForm makePreparedLambdaForm(MethodType mtype, int which) {
<span class="fc bfc" id="L226" title="All 2 branches covered.">        boolean needsInit = (which == LF_INVSTATIC_INIT);</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        boolean doesAlloc = (which == LF_NEWINVSPECIAL);</span>
        String linkerName, lambdaName;
<span class="pc bpc" id="L229" title="1 of 7 branches missed.">        switch (which) {</span>
<span class="fc" id="L230">        case LF_INVVIRTUAL:    linkerName = &quot;linkToVirtual&quot;;    lambdaName = &quot;DMH.invokeVirtual&quot;;    break;</span>
<span class="fc" id="L231">        case LF_INVSTATIC:     linkerName = &quot;linkToStatic&quot;;     lambdaName = &quot;DMH.invokeStatic&quot;;     break;</span>
<span class="fc" id="L232">        case LF_INVSTATIC_INIT:linkerName = &quot;linkToStatic&quot;;     lambdaName = &quot;DMH.invokeStaticInit&quot;; break;</span>
<span class="fc" id="L233">        case LF_INVSPECIAL:    linkerName = &quot;linkToSpecial&quot;;    lambdaName = &quot;DMH.invokeSpecial&quot;;    break;</span>
<span class="fc" id="L234">        case LF_INVINTERFACE:  linkerName = &quot;linkToInterface&quot;;  lambdaName = &quot;DMH.invokeInterface&quot;;  break;</span>
<span class="fc" id="L235">        case LF_NEWINVSPECIAL: linkerName = &quot;linkToSpecial&quot;;    lambdaName = &quot;DMH.newInvokeSpecial&quot;; break;</span>
<span class="nc" id="L236">        default:  throw new InternalError(&quot;which=&quot;+which);</span>
        }
<span class="fc" id="L238">        MethodType mtypeWithArg = mtype.appendParameterTypes(MemberName.class);</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (doesAlloc)</span>
<span class="fc" id="L240">            mtypeWithArg = mtypeWithArg</span>
<span class="fc" id="L241">                    .insertParameterTypes(0, Object.class)  // insert newly allocated obj</span>
<span class="fc" id="L242">                    .changeReturnType(void.class);          // &lt;init&gt; returns void</span>
<span class="fc" id="L243">        MemberName linker = new MemberName(MethodHandle.class, linkerName, mtypeWithArg, REF_invokeStatic);</span>
        try {
<span class="fc" id="L245">            linker = IMPL_NAMES.resolveOrFail(REF_invokeStatic, linker, null, NoSuchMethodException.class);</span>
<span class="nc" id="L246">        } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L247">            throw newInternalError(ex);</span>
<span class="fc" id="L248">        }</span>
        final int DMH_THIS    = 0;
        final int ARG_BASE    = 1;
<span class="fc" id="L251">        final int ARG_LIMIT   = ARG_BASE + mtype.parameterCount();</span>
<span class="fc" id="L252">        int nameCursor = ARG_LIMIT;</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">        final int NEW_OBJ     = (doesAlloc ? nameCursor++ : -1);</span>
<span class="fc" id="L254">        final int GET_MEMBER  = nameCursor++;</span>
<span class="fc" id="L255">        final int LINKER_CALL = nameCursor++;</span>
<span class="fc" id="L256">        Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());</span>
<span class="pc bpc" id="L257" title="1 of 4 branches missed.">        assert(names.length == nameCursor);</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        if (doesAlloc) {</span>
            // names = { argx,y,z,... new C, init method }
<span class="fc" id="L260">            names[NEW_OBJ] = new Name(Lazy.NF_allocateInstance, names[DMH_THIS]);</span>
<span class="fc" id="L261">            names[GET_MEMBER] = new Name(Lazy.NF_constructorMethod, names[DMH_THIS]);</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">        } else if (needsInit) {</span>
<span class="fc" id="L263">            names[GET_MEMBER] = new Name(Lazy.NF_internalMemberNameEnsureInit, names[DMH_THIS]);</span>
        } else {
<span class="fc" id="L265">            names[GET_MEMBER] = new Name(Lazy.NF_internalMemberName, names[DMH_THIS]);</span>
        }
<span class="fc" id="L267">        Object[] outArgs = Arrays.copyOfRange(names, ARG_BASE, GET_MEMBER+1, Object[].class);</span>
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">        assert(outArgs[outArgs.length-1] == names[GET_MEMBER]);  // look, shifted args!</span>
<span class="fc" id="L269">        int result = LambdaForm.LAST_RESULT;</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (doesAlloc) {</span>
<span class="pc bpc" id="L271" title="1 of 4 branches missed.">            assert(outArgs[outArgs.length-2] == names[NEW_OBJ]);  // got to move this one</span>
<span class="fc" id="L272">            System.arraycopy(outArgs, 0, outArgs, 1, outArgs.length-2);</span>
<span class="fc" id="L273">            outArgs[0] = names[NEW_OBJ];</span>
<span class="fc" id="L274">            result = NEW_OBJ;</span>
        }
<span class="fc" id="L276">        names[LINKER_CALL] = new Name(linker, outArgs);</span>
<span class="fc" id="L277">        lambdaName += &quot;_&quot; + LambdaForm.basicTypeSignature(mtype);</span>
<span class="fc" id="L278">        LambdaForm lform = new LambdaForm(lambdaName, ARG_LIMIT, names, result);</span>
        // This is a tricky bit of code.  Don't send it through the LF interpreter.
<span class="fc" id="L280">        lform.compileToBytecode();</span>
<span class="fc" id="L281">        return lform;</span>
    }

    private static void maybeCompile(LambdaForm lform, MemberName m) {
<span class="fc bfc" id="L285" title="All 2 branches covered.">        if (VerifyAccess.isSamePackage(m.getDeclaringClass(), MethodHandle.class))</span>
            // Help along bootstrapping...
<span class="fc" id="L287">            lform.compileToBytecode();</span>
<span class="fc" id="L288">    }</span>

    /** Static wrapper for DirectMethodHandle.internalMemberName. */
    @ForceInline
    /*non-public*/ static Object internalMemberName(Object mh) {
<span class="fc" id="L293">        return ((DirectMethodHandle)mh).member;</span>
    }

    /** Static wrapper for DirectMethodHandle.internalMemberName.
     * This one also forces initialization.
     */
    /*non-public*/ static Object internalMemberNameEnsureInit(Object mh) {
<span class="fc" id="L300">        DirectMethodHandle dmh = (DirectMethodHandle)mh;</span>
<span class="fc" id="L301">        dmh.ensureInitialized();</span>
<span class="fc" id="L302">        return dmh.member;</span>
    }

    /*non-public*/ static
    boolean shouldBeInitialized(MemberName member) {
<span class="fc bfc" id="L307" title="All 2 branches covered.">        switch (member.getReferenceKind()) {</span>
        case REF_invokeStatic:
        case REF_getStatic:
        case REF_putStatic:
        case REF_newInvokeSpecial:
<span class="fc" id="L312">            break;</span>
        default:
            // No need to initialize the class on this kind of member.
<span class="fc" id="L315">            return false;</span>
        }
<span class="fc" id="L317">        Class&lt;?&gt; cls = member.getDeclaringClass();</span>
<span class="fc bfc" id="L318" title="All 6 branches covered.">        if (cls == ValueConversions.class ||</span>
            cls == MethodHandleImpl.class ||
            cls == Invokers.class) {
            // These guys have lots of &lt;clinit&gt; DMH creation but we know
            // the MHs will not be used until the system is booted.
<span class="fc" id="L323">            return false;</span>
        }
<span class="fc bfc" id="L325" title="All 2 branches covered.">        if (VerifyAccess.isSamePackage(MethodHandle.class, cls) ||</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">            VerifyAccess.isSamePackage(ValueConversions.class, cls)) {</span>
            // It is a system class.  It is probably in the process of
            // being initialized, but we will help it along just to be safe.
<span class="fc bfc" id="L329" title="All 2 branches covered.">            if (UNSAFE.shouldBeInitialized(cls)) {</span>
<span class="fc" id="L330">                UNSAFE.ensureClassInitialized(cls);</span>
            }
<span class="fc" id="L332">            return false;</span>
        }
<span class="fc" id="L334">        return UNSAFE.shouldBeInitialized(cls);</span>
    }

<span class="fc" id="L337">    private static class EnsureInitialized extends ClassValue&lt;WeakReference&lt;Thread&gt;&gt; {</span>
        @Override
        protected WeakReference&lt;Thread&gt; computeValue(Class&lt;?&gt; type) {
<span class="fc" id="L340">            UNSAFE.ensureClassInitialized(type);</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">            if (UNSAFE.shouldBeInitialized(type))</span>
                // If the previous call didn't block, this can happen.
                // We are executing inside &lt;clinit&gt;.
<span class="nc" id="L344">                return new WeakReference&lt;&gt;(Thread.currentThread());</span>
<span class="fc" id="L345">            return null;</span>
        }
<span class="fc" id="L347">        static final EnsureInitialized INSTANCE = new EnsureInitialized();</span>
    }

    private void ensureInitialized() {
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        if (checkInitialized(member)) {</span>
            // The coast is clear.  Delete the &lt;clinit&gt; barrier.
<span class="fc bfc" id="L353" title="All 2 branches covered.">            if (member.isField())</span>
<span class="fc" id="L354">                updateForm(preparedFieldLambdaForm(member));</span>
            else
<span class="fc" id="L356">                updateForm(preparedLambdaForm(member));</span>
        }
<span class="fc" id="L358">    }</span>
    private static boolean checkInitialized(MemberName member) {
<span class="fc" id="L360">        Class&lt;?&gt; defc = member.getDeclaringClass();</span>
<span class="fc" id="L361">        WeakReference&lt;Thread&gt; ref = EnsureInitialized.INSTANCE.get(defc);</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">        if (ref == null) {</span>
<span class="fc" id="L363">            return true;  // the final state</span>
        }
<span class="nc" id="L365">        Thread clinitThread = ref.get();</span>
        // Somebody may still be running defc.&lt;clinit&gt;.
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (clinitThread == Thread.currentThread()) {</span>
            // If anybody is running defc.&lt;clinit&gt;, it is this thread.
<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (UNSAFE.shouldBeInitialized(defc))</span>
                // Yes, we are running it; keep the barrier for now.
<span class="nc" id="L371">                return false;</span>
        } else {
            // We are in a random thread.  Block.
<span class="nc" id="L374">            UNSAFE.ensureClassInitialized(defc);</span>
        }
<span class="nc bnc" id="L376" title="All 4 branches missed.">        assert(!UNSAFE.shouldBeInitialized(defc));</span>
        // put it into the final state
<span class="nc" id="L378">        EnsureInitialized.INSTANCE.remove(defc);</span>
<span class="nc" id="L379">        return true;</span>
    }

    /*non-public*/ static void ensureInitialized(Object mh) {
<span class="fc" id="L383">        ((DirectMethodHandle)mh).ensureInitialized();</span>
<span class="fc" id="L384">    }</span>

    /** This subclass represents invokespecial instructions. */
    static class Special extends DirectMethodHandle {
        private Special(MethodType mtype, LambdaForm form, MemberName member) {
<span class="fc" id="L389">            super(mtype, form, member);</span>
<span class="fc" id="L390">        }</span>
        @Override
        boolean isInvokeSpecial() {
<span class="fc" id="L393">            return true;</span>
        }
        @Override
        MethodHandle viewAsType(MethodType newType) {
<span class="fc" id="L397">            return new Special(newType, form, member);</span>
        }
    }

    /** This subclass handles constructor references. */
<span class="fc bfc" id="L402" title="All 2 branches covered.">    static class Constructor extends DirectMethodHandle {</span>
        final MemberName initMethod;
        final Class&lt;?&gt;   instanceClass;

        private Constructor(MethodType mtype, LambdaForm form, MemberName constructor,
                            MemberName initMethod, Class&lt;?&gt; instanceClass) {
<span class="fc" id="L408">            super(mtype, form, constructor);</span>
<span class="fc" id="L409">            this.initMethod = initMethod;</span>
<span class="fc" id="L410">            this.instanceClass = instanceClass;</span>
<span class="pc bpc" id="L411" title="1 of 4 branches missed.">            assert(initMethod.isResolved());</span>
<span class="fc" id="L412">        }</span>
        @Override
        MethodHandle viewAsType(MethodType newType) {
<span class="nc" id="L415">            return new Constructor(newType, form, member, initMethod, instanceClass);</span>
        }
    }

    /*non-public*/ static Object constructorMethod(Object mh) {
<span class="fc" id="L420">        Constructor dmh = (Constructor)mh;</span>
<span class="fc" id="L421">        return dmh.initMethod;</span>
    }

    /*non-public*/ static Object allocateInstance(Object mh) throws InstantiationException {
<span class="fc" id="L425">        Constructor dmh = (Constructor)mh;</span>
<span class="fc" id="L426">        return UNSAFE.allocateInstance(dmh.instanceClass);</span>
    }

    /** This subclass handles non-static field references. */
    static class Accessor extends DirectMethodHandle {
        final Class&lt;?&gt; fieldType;
        final int      fieldOffset;
        private Accessor(MethodType mtype, LambdaForm form, MemberName member,
                         int fieldOffset) {
<span class="fc" id="L435">            super(mtype, form, member);</span>
<span class="fc" id="L436">            this.fieldType   = member.getFieldType();</span>
<span class="fc" id="L437">            this.fieldOffset = fieldOffset;</span>
<span class="fc" id="L438">        }</span>

        @Override Object checkCast(Object obj) {
<span class="fc" id="L441">            return fieldType.cast(obj);</span>
        }
        @Override
        MethodHandle viewAsType(MethodType newType) {
<span class="nc" id="L445">            return new Accessor(newType, form, member, fieldOffset);</span>
        }
    }

    @ForceInline
    /*non-public*/ static long fieldOffset(Object accessorObj) {
        // Note: We return a long because that is what Unsafe.getObject likes.
        // We store a plain int because it is more compact.
<span class="fc" id="L453">        return ((Accessor)accessorObj).fieldOffset;</span>
    }

    @ForceInline
    /*non-public*/ static Object checkBase(Object obj) {
        // Note that the object's class has already been verified,
        // since the parameter type of the Accessor method handle
        // is either member.getDeclaringClass or a subclass.
        // This was verified in DirectMethodHandle.make.
        // Therefore, the only remaining check is for null.
        // Since this check is *not* guaranteed by Unsafe.getInt
        // and its siblings, we need to make an explicit one here.
<span class="fc" id="L465">        obj.getClass();  // maybe throw NPE</span>
<span class="fc" id="L466">        return obj;</span>
    }

    /** This subclass handles static field references. */
    static class StaticAccessor extends DirectMethodHandle {
        final private Class&lt;?&gt; fieldType;
        final private Object   staticBase;
        final private long     staticOffset;

        private StaticAccessor(MethodType mtype, LambdaForm form, MemberName member,
                               Object staticBase, long staticOffset) {
<span class="fc" id="L477">            super(mtype, form, member);</span>
<span class="fc" id="L478">            this.fieldType    = member.getFieldType();</span>
<span class="fc" id="L479">            this.staticBase   = staticBase;</span>
<span class="fc" id="L480">            this.staticOffset = staticOffset;</span>
<span class="fc" id="L481">        }</span>

        @Override Object checkCast(Object obj) {
<span class="fc" id="L484">            return fieldType.cast(obj);</span>
        }
        @Override
        MethodHandle viewAsType(MethodType newType) {
<span class="nc" id="L488">            return new StaticAccessor(newType, form, member, staticBase, staticOffset);</span>
        }
    }

    @ForceInline
    /*non-public*/ static Object nullCheck(Object obj) {
<span class="nc" id="L494">        obj.getClass();</span>
<span class="nc" id="L495">        return obj;</span>
    }

    @ForceInline
    /*non-public*/ static Object staticBase(Object accessorObj) {
<span class="fc" id="L500">        return ((StaticAccessor)accessorObj).staticBase;</span>
    }

    @ForceInline
    /*non-public*/ static long staticOffset(Object accessorObj) {
<span class="fc" id="L505">        return ((StaticAccessor)accessorObj).staticOffset;</span>
    }

    @ForceInline
    /*non-public*/ static Object checkCast(Object mh, Object obj) {
<span class="fc" id="L510">        return ((DirectMethodHandle) mh).checkCast(obj);</span>
    }

    Object checkCast(Object obj) {
<span class="nc" id="L514">        return member.getReturnType().cast(obj);</span>
    }

    // Caching machinery for field accessors:
    private static byte
<span class="fc" id="L519">            AF_GETFIELD        = 0,</span>
<span class="fc" id="L520">            AF_PUTFIELD        = 1,</span>
<span class="fc" id="L521">            AF_GETSTATIC       = 2,</span>
<span class="fc" id="L522">            AF_PUTSTATIC       = 3,</span>
<span class="fc" id="L523">            AF_GETSTATIC_INIT  = 4,</span>
<span class="fc" id="L524">            AF_PUTSTATIC_INIT  = 5,</span>
<span class="fc" id="L525">            AF_LIMIT           = 6;</span>
    // Enumerate the different field kinds using Wrapper,
    // with an extra case added for checked references.
    private static int
<span class="fc" id="L529">            FT_LAST_WRAPPER    = Wrapper.values().length-1,</span>
<span class="fc" id="L530">            FT_UNCHECKED_REF   = Wrapper.OBJECT.ordinal(),</span>
<span class="fc" id="L531">            FT_CHECKED_REF     = FT_LAST_WRAPPER+1,</span>
<span class="fc" id="L532">            FT_LIMIT           = FT_LAST_WRAPPER+2;</span>
    private static int afIndex(byte formOp, boolean isVolatile, int ftypeKind) {
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">        return ((formOp * FT_LIMIT * 2)</span>
                + (isVolatile ? FT_LIMIT : 0)
                + ftypeKind);
    }
<span class="fc" id="L538">    private static final LambdaForm[] ACCESSOR_FORMS</span>
<span class="fc" id="L539">            = new LambdaForm[afIndex(AF_LIMIT, false, 0)];</span>
    private static int ftypeKind(Class&lt;?&gt; ftype) {
<span class="fc bfc" id="L541" title="All 2 branches covered.">        if (ftype.isPrimitive())</span>
<span class="fc" id="L542">            return Wrapper.forPrimitiveType(ftype).ordinal();</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        else if (VerifyType.isNullReferenceConversion(Object.class, ftype))</span>
<span class="fc" id="L544">            return FT_UNCHECKED_REF;</span>
        else
<span class="fc" id="L546">            return FT_CHECKED_REF;</span>
    }

    /**
     * Create a LF which can access the given field.
     * Cache and share this structure among all fields with
     * the same basicType and refKind.
     */
    private static LambdaForm preparedFieldLambdaForm(MemberName m) {
<span class="fc" id="L555">        Class&lt;?&gt; ftype = m.getFieldType();</span>
<span class="fc" id="L556">        boolean isVolatile = m.isVolatile();</span>
        byte formOp;
<span class="pc bpc" id="L558" title="1 of 5 branches missed.">        switch (m.getReferenceKind()) {</span>
<span class="fc" id="L559">        case REF_getField:      formOp = AF_GETFIELD;    break;</span>
<span class="fc" id="L560">        case REF_putField:      formOp = AF_PUTFIELD;    break;</span>
<span class="fc" id="L561">        case REF_getStatic:     formOp = AF_GETSTATIC;   break;</span>
<span class="fc" id="L562">        case REF_putStatic:     formOp = AF_PUTSTATIC;   break;</span>
<span class="nc" id="L563">        default:  throw new InternalError(m.toString());</span>
        }
<span class="fc bfc" id="L565" title="All 2 branches covered.">        if (shouldBeInitialized(m)) {</span>
            // precompute the barrier-free version:
<span class="fc" id="L567">            preparedFieldLambdaForm(formOp, isVolatile, ftype);</span>
<span class="pc bpc" id="L568" title="2 of 4 branches missed.">            assert((AF_GETSTATIC_INIT - AF_GETSTATIC) ==</span>
                   (AF_PUTSTATIC_INIT - AF_PUTSTATIC));
<span class="fc" id="L570">            formOp += (AF_GETSTATIC_INIT - AF_GETSTATIC);</span>
        }
<span class="fc" id="L572">        LambdaForm lform = preparedFieldLambdaForm(formOp, isVolatile, ftype);</span>
<span class="fc" id="L573">        maybeCompile(lform, m);</span>
<span class="pc bfc" id="L574" title="All 2 branches covered.">        assert(lform.methodType().dropParameterTypes(0, 1)</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">                .equals(m.getInvocationType().basicType()))</span>
<span class="nc" id="L576">                : Arrays.asList(m, m.getInvocationType().basicType(), lform, lform.methodType());</span>
<span class="fc" id="L577">        return lform;</span>
    }
    private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, Class&lt;?&gt; ftype) {
<span class="fc" id="L580">        int afIndex = afIndex(formOp, isVolatile, ftypeKind(ftype));</span>
<span class="fc" id="L581">        LambdaForm lform = ACCESSOR_FORMS[afIndex];</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">        if (lform != null)  return lform;</span>
<span class="fc" id="L583">        lform = makePreparedFieldLambdaForm(formOp, isVolatile, ftypeKind(ftype));</span>
<span class="fc" id="L584">        ACCESSOR_FORMS[afIndex] = lform;  // don't bother with a CAS</span>
<span class="fc" id="L585">        return lform;</span>
    }

    private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftypeKind) {
<span class="fc bfc" id="L589" title="All 2 branches covered.">        boolean isGetter  = (formOp &amp; 1) == (AF_GETFIELD &amp; 1);</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">        boolean isStatic  = (formOp &gt;= AF_GETSTATIC);</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">        boolean needsInit = (formOp &gt;= AF_GETSTATIC_INIT);</span>
<span class="fc bfc" id="L592" title="All 2 branches covered.">        boolean needsCast = (ftypeKind == FT_CHECKED_REF);</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">        Wrapper fw = (needsCast ? Wrapper.OBJECT : Wrapper.values()[ftypeKind]);</span>
<span class="fc" id="L594">        Class&lt;?&gt; ft = fw.primitiveType();</span>
<span class="pc bpc" id="L595" title="1 of 6 branches missed.">        assert(ftypeKind(needsCast ? String.class : ft) == ftypeKind);</span>
<span class="fc" id="L596">        String tname  = fw.primitiveSimpleName();</span>
<span class="fc" id="L597">        String ctname = Character.toUpperCase(tname.charAt(0)) + tname.substring(1);</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">        if (isVolatile)  ctname += &quot;Volatile&quot;;</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">        String getOrPut = (isGetter ? &quot;get&quot; : &quot;put&quot;);</span>
<span class="fc" id="L600">        String linkerName = (getOrPut + ctname);  // getObject, putIntVolatile, etc.</span>
        MethodType linkerType;
<span class="fc bfc" id="L602" title="All 2 branches covered.">        if (isGetter)</span>
<span class="fc" id="L603">            linkerType = MethodType.methodType(ft, Object.class, long.class);</span>
        else
<span class="fc" id="L605">            linkerType = MethodType.methodType(void.class, Object.class, long.class, ft);</span>
<span class="fc" id="L606">        MemberName linker = new MemberName(Unsafe.class, linkerName, linkerType, REF_invokeVirtual);</span>
        try {
<span class="fc" id="L608">            linker = IMPL_NAMES.resolveOrFail(REF_invokeVirtual, linker, null, NoSuchMethodException.class);</span>
<span class="nc" id="L609">        } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L610">            throw newInternalError(ex);</span>
<span class="fc" id="L611">        }</span>

        // What is the external type of the lambda form?
        MethodType mtype;
<span class="fc bfc" id="L615" title="All 2 branches covered.">        if (isGetter)</span>
<span class="fc" id="L616">            mtype = MethodType.methodType(ft);</span>
        else
<span class="fc" id="L618">            mtype = MethodType.methodType(void.class, ft);</span>
<span class="fc" id="L619">        mtype = mtype.basicType();  // erase short to int, etc.</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">        if (!isStatic)</span>
<span class="fc" id="L621">            mtype = mtype.insertParameterTypes(0, Object.class);</span>
        final int DMH_THIS  = 0;
        final int ARG_BASE  = 1;
<span class="fc" id="L624">        final int ARG_LIMIT = ARG_BASE + mtype.parameterCount();</span>
        // if this is for non-static access, the base pointer is stored at this index:
<span class="fc bfc" id="L626" title="All 2 branches covered.">        final int OBJ_BASE  = isStatic ? -1 : ARG_BASE;</span>
        // if this is for write access, the value to be written is stored at this index:
<span class="fc bfc" id="L628" title="All 2 branches covered.">        final int SET_VALUE  = isGetter ? -1 : ARG_LIMIT - 1;</span>
<span class="fc" id="L629">        int nameCursor = ARG_LIMIT;</span>
<span class="fc bfc" id="L630" title="All 2 branches covered.">        final int F_HOLDER  = (isStatic ? nameCursor++ : -1);  // static base if any</span>
<span class="fc" id="L631">        final int F_OFFSET  = nameCursor++;  // Either static offset or field offset.</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">        final int OBJ_CHECK = (OBJ_BASE &gt;= 0 ? nameCursor++ : -1);</span>
<span class="fc bfc" id="L633" title="All 2 branches covered.">        final int INIT_BAR  = (needsInit ? nameCursor++ : -1);</span>
<span class="fc bfc" id="L634" title="All 4 branches covered.">        final int PRE_CAST  = (needsCast &amp;&amp; !isGetter ? nameCursor++ : -1);</span>
<span class="fc" id="L635">        final int LINKER_CALL = nameCursor++;</span>
<span class="fc bfc" id="L636" title="All 4 branches covered.">        final int POST_CAST = (needsCast &amp;&amp; isGetter ? nameCursor++ : -1);</span>
<span class="fc" id="L637">        final int RESULT    = nameCursor-1;  // either the call or the cast</span>
<span class="fc" id="L638">        Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">        if (needsInit)</span>
<span class="fc" id="L640">            names[INIT_BAR] = new Name(Lazy.NF_ensureInitialized, names[DMH_THIS]);</span>
<span class="fc bfc" id="L641" title="All 4 branches covered.">        if (needsCast &amp;&amp; !isGetter)</span>
<span class="fc" id="L642">            names[PRE_CAST] = new Name(Lazy.NF_checkCast, names[DMH_THIS], names[SET_VALUE]);</span>
<span class="fc" id="L643">        Object[] outArgs = new Object[1 + linkerType.parameterCount()];</span>
<span class="pc bpc" id="L644" title="1 of 6 branches missed.">        assert(outArgs.length == (isGetter ? 3 : 4));</span>
<span class="fc" id="L645">        outArgs[0] = UNSAFE;</span>
<span class="fc bfc" id="L646" title="All 2 branches covered.">        if (isStatic) {</span>
<span class="fc" id="L647">            outArgs[1] = names[F_HOLDER]  = new Name(Lazy.NF_staticBase, names[DMH_THIS]);</span>
<span class="fc" id="L648">            outArgs[2] = names[F_OFFSET]  = new Name(Lazy.NF_staticOffset, names[DMH_THIS]);</span>
        } else {
<span class="fc" id="L650">            outArgs[1] = names[OBJ_CHECK] = new Name(Lazy.NF_checkBase, names[OBJ_BASE]);</span>
<span class="fc" id="L651">            outArgs[2] = names[F_OFFSET]  = new Name(Lazy.NF_fieldOffset, names[DMH_THIS]);</span>
        }
<span class="fc bfc" id="L653" title="All 2 branches covered.">        if (!isGetter) {</span>
<span class="fc bfc" id="L654" title="All 2 branches covered.">            outArgs[3] = (needsCast ? names[PRE_CAST] : names[SET_VALUE]);</span>
        }
<span class="pc bpc" id="L656" title="1 of 6 branches missed.">        for (Object a : outArgs)  assert(a != null);</span>
<span class="fc" id="L657">        names[LINKER_CALL] = new Name(linker, outArgs);</span>
<span class="fc bfc" id="L658" title="All 4 branches covered.">        if (needsCast &amp;&amp; isGetter)</span>
<span class="fc" id="L659">            names[POST_CAST] = new Name(Lazy.NF_checkCast, names[DMH_THIS], names[LINKER_CALL]);</span>
<span class="pc bpc" id="L660" title="1 of 6 branches missed.">        for (Name n : names)  assert(n != null);</span>
<span class="fc bfc" id="L661" title="All 2 branches covered.">        String fieldOrStatic = (isStatic ? &quot;Static&quot; : &quot;Field&quot;);</span>
<span class="fc" id="L662">        String lambdaName = (linkerName + fieldOrStatic);  // significant only for debugging</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">        if (needsCast)  lambdaName += &quot;Cast&quot;;</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">        if (needsInit)  lambdaName += &quot;Init&quot;;</span>
<span class="fc" id="L665">        return new LambdaForm(lambdaName, ARG_LIMIT, names, RESULT);</span>
    }

    /**
     * Pre-initialized NamedFunctions for bootstrapping purposes.
     * Factored in an inner class to delay initialization until first usage.
     */
<span class="pc bfc" id="L672" title="All 2 branches covered.">    private static class Lazy {</span>
        static final NamedFunction
                NF_internalMemberName,
                NF_internalMemberNameEnsureInit,
                NF_ensureInitialized,
                NF_fieldOffset,
                NF_checkBase,
                NF_staticBase,
                NF_staticOffset,
                NF_checkCast,
                NF_allocateInstance,
                NF_constructorMethod;
        static {
            try {
<span class="fc" id="L686">                NamedFunction nfs[] = {</span>
                        NF_internalMemberName = new NamedFunction(DirectMethodHandle.class
<span class="fc" id="L688">                                .getDeclaredMethod(&quot;internalMemberName&quot;, Object.class)),</span>
                        NF_internalMemberNameEnsureInit = new NamedFunction(DirectMethodHandle.class
<span class="fc" id="L690">                                .getDeclaredMethod(&quot;internalMemberNameEnsureInit&quot;, Object.class)),</span>
                        NF_ensureInitialized = new NamedFunction(DirectMethodHandle.class
<span class="fc" id="L692">                                .getDeclaredMethod(&quot;ensureInitialized&quot;, Object.class)),</span>
                        NF_fieldOffset = new NamedFunction(DirectMethodHandle.class
<span class="fc" id="L694">                                .getDeclaredMethod(&quot;fieldOffset&quot;, Object.class)),</span>
                        NF_checkBase = new NamedFunction(DirectMethodHandle.class
<span class="fc" id="L696">                                .getDeclaredMethod(&quot;checkBase&quot;, Object.class)),</span>
                        NF_staticBase = new NamedFunction(DirectMethodHandle.class
<span class="fc" id="L698">                                .getDeclaredMethod(&quot;staticBase&quot;, Object.class)),</span>
                        NF_staticOffset = new NamedFunction(DirectMethodHandle.class
<span class="fc" id="L700">                                .getDeclaredMethod(&quot;staticOffset&quot;, Object.class)),</span>
                        NF_checkCast = new NamedFunction(DirectMethodHandle.class
<span class="fc" id="L702">                                .getDeclaredMethod(&quot;checkCast&quot;, Object.class, Object.class)),</span>
                        NF_allocateInstance = new NamedFunction(DirectMethodHandle.class
<span class="fc" id="L704">                                .getDeclaredMethod(&quot;allocateInstance&quot;, Object.class)),</span>
                        NF_constructorMethod = new NamedFunction(DirectMethodHandle.class
<span class="fc" id="L706">                                .getDeclaredMethod(&quot;constructorMethod&quot;, Object.class))</span>
                };
<span class="fc bfc" id="L708" title="All 2 branches covered.">                for (NamedFunction nf : nfs) {</span>
                    // Each nf must be statically invocable or we get tied up in our bootstraps.
<span class="pc bpc" id="L710" title="1 of 4 branches missed.">                    assert(InvokerBytecodeGenerator.isStaticallyInvocable(nf.member)) : nf;</span>
<span class="fc" id="L711">                    nf.resolve();</span>
                }
<span class="nc" id="L713">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L714">                throw newInternalError(ex);</span>
<span class="fc" id="L715">            }</span>
<span class="fc" id="L716">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>