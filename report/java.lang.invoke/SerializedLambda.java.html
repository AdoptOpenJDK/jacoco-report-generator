<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SerializedLambda.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">SerializedLambda.java</span></div><h1>SerializedLambda.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.lang.invoke;

import java.io.Serializable;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.Objects;

/**
 * Serialized form of a lambda expression.  The properties of this class
 * represent the information that is present at the lambda factory site, including
 * static metafactory arguments such as the identity of the primary functional
 * interface method and the identity of the implementation method, as well as
 * dynamic metafactory arguments such as values captured from the lexical scope
 * at the time of lambda capture.
 *
 * &lt;p&gt;Implementors of serializable lambdas, such as compilers or language
 * runtime libraries, are expected to ensure that instances deserialize properly.
 * One means to do so is to ensure that the {@code writeReplace} method returns
 * an instance of {@code SerializedLambda}, rather than allowing default
 * serialization to proceed.
 *
 * &lt;p&gt;{@code SerializedLambda} has a {@code readResolve} method that looks for
 * a (possibly private) static method called
 * {@code $deserializeLambda$(SerializedLambda)} in the capturing class, invokes
 * that with itself as the first argument, and returns the result.  Lambda classes
 * implementing {@code $deserializeLambda$} are responsible for validating
 * that the properties of the {@code SerializedLambda} are consistent with a
 * lambda actually captured by that class.
 *
 * @see LambdaMetafactory
 */
public final class SerializedLambda implements Serializable {
    private static final long serialVersionUID = 8025925345765570181L;
    private final Class&lt;?&gt; capturingClass;
    private final String functionalInterfaceClass;
    private final String functionalInterfaceMethodName;
    private final String functionalInterfaceMethodSignature;
    private final String implClass;
    private final String implMethodName;
    private final String implMethodSignature;
    private final int implMethodKind;
    private final String instantiatedMethodType;
    private final Object[] capturedArgs;

    /**
     * Create a {@code SerializedLambda} from the low-level information present
     * at the lambda factory site.
     *
     * @param capturingClass The class in which the lambda expression appears
     * @param functionalInterfaceClass Name, in slash-delimited form, of static
     *                                 type of the returned lambda object
     * @param functionalInterfaceMethodName Name of the functional interface
     *                                      method for the present at the
     *                                      lambda factory site
     * @param functionalInterfaceMethodSignature Signature of the functional
     *                                           interface method present at
     *                                           the lambda factory site
     * @param implMethodKind Method handle kind for the implementation method
     * @param implClass Name, in slash-delimited form, for the class holding
     *                  the implementation method
     * @param implMethodName Name of the implementation method
     * @param implMethodSignature Signature of the implementation method
     * @param instantiatedMethodType The signature of the primary functional
     *                               interface method after type variables
     *                               are substituted with their instantiation
     *                               from the capture site
     * @param capturedArgs The dynamic arguments to the lambda factory site,
     *                     which represent variables captured by
     *                     the lambda
     */
    public SerializedLambda(Class&lt;?&gt; capturingClass,
                            String functionalInterfaceClass,
                            String functionalInterfaceMethodName,
                            String functionalInterfaceMethodSignature,
                            int implMethodKind,
                            String implClass,
                            String implMethodName,
                            String implMethodSignature,
                            String instantiatedMethodType,
<span class="fc" id="L106">                            Object[] capturedArgs) {</span>
<span class="fc" id="L107">        this.capturingClass = capturingClass;</span>
<span class="fc" id="L108">        this.functionalInterfaceClass = functionalInterfaceClass;</span>
<span class="fc" id="L109">        this.functionalInterfaceMethodName = functionalInterfaceMethodName;</span>
<span class="fc" id="L110">        this.functionalInterfaceMethodSignature = functionalInterfaceMethodSignature;</span>
<span class="fc" id="L111">        this.implMethodKind = implMethodKind;</span>
<span class="fc" id="L112">        this.implClass = implClass;</span>
<span class="fc" id="L113">        this.implMethodName = implMethodName;</span>
<span class="fc" id="L114">        this.implMethodSignature = implMethodSignature;</span>
<span class="fc" id="L115">        this.instantiatedMethodType = instantiatedMethodType;</span>
<span class="fc" id="L116">        this.capturedArgs = Objects.requireNonNull(capturedArgs).clone();</span>
<span class="fc" id="L117">    }</span>

    /**
     * Get the name of the class that captured this lambda.
     * @return the name of the class that captured this lambda
     */
    public String getCapturingClass() {
<span class="nc" id="L124">        return capturingClass.getName().replace('.', '/');</span>
    }

    /**
     * Get the name of the invoked type to which this
     * lambda has been converted
     * @return the name of the functional interface class to which
     * this lambda has been converted
     */
    public String getFunctionalInterfaceClass() {
<span class="fc" id="L134">        return functionalInterfaceClass;</span>
    }

    /**
     * Get the name of the primary method for the functional interface
     * to which this lambda has been converted.
     * @return the name of the primary methods of the functional interface
     */
    public String getFunctionalInterfaceMethodName() {
<span class="fc" id="L143">        return functionalInterfaceMethodName;</span>
    }

    /**
     * Get the signature of the primary method for the functional
     * interface to which this lambda has been converted.
     * @return the signature of the primary method of the functional
     * interface
     */
    public String getFunctionalInterfaceMethodSignature() {
<span class="fc" id="L153">        return functionalInterfaceMethodSignature;</span>
    }

    /**
     * Get the name of the class containing the implementation
     * method.
     * @return the name of the class containing the implementation
     * method
     */
    public String getImplClass() {
<span class="fc" id="L163">        return implClass;</span>
    }

    /**
     * Get the name of the implementation method.
     * @return the name of the implementation method
     */
    public String getImplMethodName() {
<span class="fc" id="L171">        return implMethodName;</span>
    }

    /**
     * Get the signature of the implementation method.
     * @return the signature of the implementation method
     */
    public String getImplMethodSignature() {
<span class="fc" id="L179">        return implMethodSignature;</span>
    }

    /**
     * Get the method handle kind (see {@link MethodHandleInfo}) of
     * the implementation method.
     * @return the method handle kind of the implementation method
     */
    public int getImplMethodKind() {
<span class="fc" id="L188">        return implMethodKind;</span>
    }

    /**
     * Get the signature of the primary functional interface method
     * after type variables are substituted with their instantiation
     * from the capture site.
     * @return the signature of the primary functional interface method
     * after type variable processing
     */
    public final String getInstantiatedMethodType() {
<span class="nc" id="L199">        return instantiatedMethodType;</span>
    }

    /**
     * Get the count of dynamic arguments to the lambda capture site.
     * @return the count of dynamic arguments to the lambda capture site
     */
    public int getCapturedArgCount() {
<span class="nc" id="L207">        return capturedArgs.length;</span>
    }

    /**
     * Get a dynamic argument to the lambda capture site.
     * @param i the argument to capture
     * @return a dynamic argument to the lambda capture site
     */
    public Object getCapturedArg(int i) {
<span class="fc" id="L216">        return capturedArgs[i];</span>
    }

    private Object readResolve() throws ReflectiveOperationException {
        try {
<span class="fc" id="L221">            Method deserialize = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Method&gt;() {</span>
                @Override
                public Method run() throws Exception {
<span class="fc" id="L224">                    Method m = capturingClass.getDeclaredMethod(&quot;$deserializeLambda$&quot;, SerializedLambda.class);</span>
<span class="fc" id="L225">                    m.setAccessible(true);</span>
<span class="fc" id="L226">                    return m;</span>
                }
            });

<span class="fc" id="L230">            return deserialize.invoke(null, this);</span>
        }
<span class="nc" id="L232">        catch (PrivilegedActionException e) {</span>
<span class="nc" id="L233">            Exception cause = e.getException();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            if (cause instanceof ReflectiveOperationException)</span>
<span class="nc" id="L235">                throw (ReflectiveOperationException) cause;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            else if (cause instanceof RuntimeException)</span>
<span class="nc" id="L237">                throw (RuntimeException) cause;</span>
            else
<span class="nc" id="L239">                throw new RuntimeException(&quot;Exception in SerializedLambda.readResolve&quot;, e);</span>
        }
    }

    @Override
    public String toString() {
<span class="nc" id="L245">        String implKind=MethodHandleInfo.referenceKindToString(implMethodKind);</span>
<span class="nc" id="L246">        return String.format(&quot;SerializedLambda[%s=%s, %s=%s.%s:%s, &quot; +</span>
                             &quot;%s=%s %s.%s:%s, %s=%s, %s=%d]&quot;,
                             &quot;capturingClass&quot;, capturingClass,
                             &quot;functionalInterfaceMethod&quot;, functionalInterfaceClass,
                               functionalInterfaceMethodName,
                               functionalInterfaceMethodSignature,
                             &quot;implementation&quot;,
                               implKind,
                               implClass, implMethodName, implMethodSignature,
                             &quot;instantiatedMethodType&quot;, instantiatedMethodType,
<span class="nc" id="L256">                             &quot;numCaptured&quot;, capturedArgs.length);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>