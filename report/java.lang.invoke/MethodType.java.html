<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MethodType.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">MethodType.java</span></div><h1>MethodType.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.invoke;

import sun.invoke.util.Wrapper;
import java.lang.ref.WeakReference;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ConcurrentHashMap;
import sun.invoke.util.BytecodeDescriptor;
import static java.lang.invoke.MethodHandleStatics.*;
import sun.invoke.util.VerifyType;

/**
 * A method type represents the arguments and return type accepted and
 * returned by a method handle, or the arguments and return type passed
 * and expected  by a method handle caller.  Method types must be properly
 * matched between a method handle and all its callers,
 * and the JVM's operations enforce this matching at, specifically
 * during calls to {@link MethodHandle#invokeExact MethodHandle.invokeExact}
 * and {@link MethodHandle#invoke MethodHandle.invoke}, and during execution
 * of {@code invokedynamic} instructions.
 * &lt;p&gt;
 * The structure is a return type accompanied by any number of parameter types.
 * The types (primitive, {@code void}, and reference) are represented by {@link Class} objects.
 * (For ease of exposition, we treat {@code void} as if it were a type.
 * In fact, it denotes the absence of a return type.)
 * &lt;p&gt;
 * All instances of {@code MethodType} are immutable.
 * Two instances are completely interchangeable if they compare equal.
 * Equality depends on pairwise correspondence of the return and parameter types and on nothing else.
 * &lt;p&gt;
 * This type can be created only by factory methods.
 * All factory methods may cache values, though caching is not guaranteed.
 * Some factory methods are static, while others are virtual methods which
 * modify precursor method types, e.g., by changing a selected parameter.
 * &lt;p&gt;
 * Factory methods which operate on groups of parameter types
 * are systematically presented in two versions, so that both Java arrays and
 * Java lists can be used to work with groups of parameter types.
 * The query methods {@code parameterArray} and {@code parameterList}
 * also provide a choice between arrays and lists.
 * &lt;p&gt;
 * {@code MethodType} objects are sometimes derived from bytecode instructions
 * such as {@code invokedynamic}, specifically from the type descriptor strings associated
 * with the instructions in a class file's constant pool.
 * &lt;p&gt;
 * Like classes and strings, method types can also be represented directly
 * in a class file's constant pool as constants.
 * A method type may be loaded by an {@code ldc} instruction which refers
 * to a suitable {@code CONSTANT_MethodType} constant pool entry.
 * The entry refers to a {@code CONSTANT_Utf8} spelling for the descriptor string.
 * (For full details on method type constants,
 * see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.)
 * &lt;p&gt;
 * When the JVM materializes a {@code MethodType} from a descriptor string,
 * all classes named in the descriptor must be accessible, and will be loaded.
 * (But the classes need not be initialized, as is the case with a {@code CONSTANT_Class}.)
 * This loading may occur at any time before the {@code MethodType} object is first derived.
 * @author John Rose, JSR 292 EG
 */
<span class="fc bfc" id="L90" title="All 2 branches covered.">public final</span>
class MethodType implements java.io.Serializable {
    private static final long serialVersionUID = 292L;  // {rtype, {ptype...}}

    // The rtype and ptypes fields define the structural identity of the method type:
    private final Class&lt;?&gt;   rtype;
    private final Class&lt;?&gt;[] ptypes;

    // The remaining fields are caches of various sorts:
    private @Stable MethodTypeForm form; // erased form, plus cached data about primitives
    private @Stable MethodType wrapAlt;  // alternative wrapped/unwrapped version
    private @Stable Invokers invokers;   // cache of handy higher-order adapters
    private @Stable String methodDescriptor;  // cache for toMethodDescriptorString

    /**
     * Check the given parameters for validity and store them into the final fields.
     */
<span class="fc" id="L107">    private MethodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes, boolean trusted) {</span>
<span class="fc" id="L108">        checkRtype(rtype);</span>
<span class="fc" id="L109">        checkPtypes(ptypes);</span>
<span class="fc" id="L110">        this.rtype = rtype;</span>
        // defensively copy the array passed in by the user
<span class="fc bfc" id="L112" title="All 2 branches covered.">        this.ptypes = trusted ? ptypes : Arrays.copyOf(ptypes, ptypes.length);</span>
<span class="fc" id="L113">    }</span>

    /**
     * Construct a temporary unchecked instance of MethodType for use only as a key to the intern table.
     * Does not check the given parameters for validity, and must be discarded after it is used as a searching key.
     * The parameters are reversed for this constructor, so that is is not accidentally used.
     */
<span class="fc" id="L120">    private MethodType(Class&lt;?&gt;[] ptypes, Class&lt;?&gt; rtype) {</span>
<span class="fc" id="L121">        this.rtype = rtype;</span>
<span class="fc" id="L122">        this.ptypes = ptypes;</span>
<span class="fc" id="L123">    }</span>

<span class="fc" id="L125">    /*trusted*/ MethodTypeForm form() { return form; }</span>
<span class="nc" id="L126">    /*trusted*/ Class&lt;?&gt; rtype() { return rtype; }</span>
<span class="fc" id="L127">    /*trusted*/ Class&lt;?&gt;[] ptypes() { return ptypes; }</span>

<span class="nc" id="L129">    void setForm(MethodTypeForm f) { form = f; }</span>

    /** This number, mandated by the JVM spec as 255,
     *  is the maximum number of &lt;em&gt;slots&lt;/em&gt;
     *  that any Java method can receive in its argument list.
     *  It limits both JVM signatures and method type objects.
     *  The longest possible invocation will look like
     *  {@code staticMethod(arg1, arg2, ..., arg255)} or
     *  {@code x.virtualMethod(arg1, arg2, ..., arg254)}.
     */
    /*non-public*/ static final int MAX_JVM_ARITY = 255;  // this is mandated by the JVM spec.

    /** This number is the maximum arity of a method handle, 254.
     *  It is derived from the absolute JVM-imposed arity by subtracting one,
     *  which is the slot occupied by the method handle itself at the
     *  beginning of the argument list used to invoke the method handle.
     *  The longest possible invocation will look like
     *  {@code mh.invoke(arg1, arg2, ..., arg254)}.
     */
    // Issue:  Should we allow MH.invokeWithArguments to go to the full 255?
    /*non-public*/ static final int MAX_MH_ARITY = MAX_JVM_ARITY-1;  // deduct one for mh receiver

    /** This number is the maximum arity of a method handle invoker, 253.
     *  It is derived from the absolute JVM-imposed arity by subtracting two,
     *  which are the slots occupied by invoke method handle, and the
     *  target method handle, which are both at the beginning of the argument
     *  list used to invoke the target method handle.
     *  The longest possible invocation will look like
     *  {@code invokermh.invoke(targetmh, arg1, arg2, ..., arg253)}.
     */
    /*non-public*/ static final int MAX_MH_INVOKER_ARITY = MAX_MH_ARITY-1;  // deduct one more for invoker

    private static void checkRtype(Class&lt;?&gt; rtype) {
<span class="fc" id="L162">        Objects.requireNonNull(rtype);</span>
<span class="fc" id="L163">    }</span>
    private static void checkPtype(Class&lt;?&gt; ptype) {
<span class="fc" id="L165">        Objects.requireNonNull(ptype);</span>
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        if (ptype == void.class)</span>
<span class="nc" id="L167">            throw newIllegalArgumentException(&quot;parameter type cannot be void&quot;);</span>
<span class="fc" id="L168">    }</span>
    /** Return number of extra slots (count of long/double args). */
    private static int checkPtypes(Class&lt;?&gt;[] ptypes) {
<span class="fc" id="L171">        int slots = 0;</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        for (Class&lt;?&gt; ptype : ptypes) {</span>
<span class="fc" id="L173">            checkPtype(ptype);</span>
<span class="fc bfc" id="L174" title="All 4 branches covered.">            if (ptype == double.class || ptype == long.class) {</span>
<span class="fc" id="L175">                slots++;</span>
            }
        }
<span class="fc" id="L178">        checkSlotCount(ptypes.length + slots);</span>
<span class="fc" id="L179">        return slots;</span>
    }
    static void checkSlotCount(int count) {
        assert((MAX_JVM_ARITY &amp; (MAX_JVM_ARITY+1)) == 0);
        // MAX_JVM_ARITY must be power of 2 minus 1 for following code trick to work:
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if ((count &amp; MAX_JVM_ARITY) != count)</span>
<span class="fc" id="L185">            throw newIllegalArgumentException(&quot;bad parameter count &quot;+count);</span>
<span class="fc" id="L186">    }</span>
    private static IndexOutOfBoundsException newIndexOutOfBoundsException(Object num) {
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (num instanceof Integer)  num = &quot;bad index: &quot;+num;</span>
<span class="nc" id="L189">        return new IndexOutOfBoundsException(num.toString());</span>
    }

<span class="fc" id="L192">    static final ConcurrentWeakInternSet&lt;MethodType&gt; internTable = new ConcurrentWeakInternSet&lt;&gt;();</span>

<span class="fc" id="L194">    static final Class&lt;?&gt;[] NO_PTYPES = {};</span>

    /**
     * Finds or creates an instance of the given method type.
     * @param rtype  the return type
     * @param ptypes the parameter types
     * @return a method type with the given components
     * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
     * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
     */
    public static
    MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {
<span class="fc" id="L206">        return makeImpl(rtype, ptypes, false);</span>
    }

    /**
     * Finds or creates a method type with the given components.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * @param rtype  the return type
     * @param ptypes the parameter types
     * @return a method type with the given components
     * @throws NullPointerException if {@code rtype} or {@code ptypes} or any element of {@code ptypes} is null
     * @throws IllegalArgumentException if any element of {@code ptypes} is {@code void.class}
     */
    public static
    MethodType methodType(Class&lt;?&gt; rtype, List&lt;Class&lt;?&gt;&gt; ptypes) {
<span class="fc" id="L220">        boolean notrust = false;  // random List impl. could return evil ptypes array</span>
<span class="fc" id="L221">        return makeImpl(rtype, listToArray(ptypes), notrust);</span>
    }

    private static Class&lt;?&gt;[] listToArray(List&lt;Class&lt;?&gt;&gt; ptypes) {
        // sanity check the size before the toArray call, since size might be huge
<span class="fc" id="L226">        checkSlotCount(ptypes.size());</span>
<span class="fc" id="L227">        return ptypes.toArray(NO_PTYPES);</span>
    }

    /**
     * Finds or creates a method type with the given components.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * The leading parameter type is prepended to the remaining array.
     * @param rtype  the return type
     * @param ptype0 the first parameter type
     * @param ptypes the remaining parameter types
     * @return a method type with the given components
     * @throws NullPointerException if {@code rtype} or {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is null
     * @throws IllegalArgumentException if {@code ptype0} or {@code ptypes} or any element of {@code ptypes} is {@code void.class}
     */
    public static
    MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0, Class&lt;?&gt;... ptypes) {
<span class="fc" id="L243">        Class&lt;?&gt;[] ptypes1 = new Class&lt;?&gt;[1+ptypes.length];</span>
<span class="fc" id="L244">        ptypes1[0] = ptype0;</span>
<span class="fc" id="L245">        System.arraycopy(ptypes, 0, ptypes1, 1, ptypes.length);</span>
<span class="fc" id="L246">        return makeImpl(rtype, ptypes1, true);</span>
    }

    /**
     * Finds or creates a method type with the given components.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * The resulting method has no parameter types.
     * @param rtype  the return type
     * @return a method type with the given return value
     * @throws NullPointerException if {@code rtype} is null
     */
    public static
    MethodType methodType(Class&lt;?&gt; rtype) {
<span class="fc" id="L259">        return makeImpl(rtype, NO_PTYPES, true);</span>
    }

    /**
     * Finds or creates a method type with the given components.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * The resulting method has the single given parameter type.
     * @param rtype  the return type
     * @param ptype0 the parameter type
     * @return a method type with the given return value and parameter type
     * @throws NullPointerException if {@code rtype} or {@code ptype0} is null
     * @throws IllegalArgumentException if {@code ptype0} is {@code void.class}
     */
    public static
    MethodType methodType(Class&lt;?&gt; rtype, Class&lt;?&gt; ptype0) {
<span class="fc" id="L274">        return makeImpl(rtype, new Class&lt;?&gt;[]{ ptype0 }, true);</span>
    }

    /**
     * Finds or creates a method type with the given components.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * The resulting method has the same parameter types as {@code ptypes},
     * and the specified return type.
     * @param rtype  the return type
     * @param ptypes the method type which supplies the parameter types
     * @return a method type with the given components
     * @throws NullPointerException if {@code rtype} or {@code ptypes} is null
     */
    public static
    MethodType methodType(Class&lt;?&gt; rtype, MethodType ptypes) {
<span class="nc" id="L289">        return makeImpl(rtype, ptypes.ptypes, true);</span>
    }

    /**
     * Sole factory method to find or create an interned method type.
     * @param rtype desired return type
     * @param ptypes desired parameter types
     * @param trusted whether the ptypes can be used without cloning
     * @return the unique method type of the desired structure
     */
    /*trusted*/ static
    MethodType makeImpl(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes, boolean trusted) {
<span class="fc" id="L301">        MethodType mt = internTable.get(new MethodType(ptypes, rtype));</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (mt != null)</span>
<span class="fc" id="L303">            return mt;</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (ptypes.length == 0) {</span>
<span class="fc" id="L305">            ptypes = NO_PTYPES; trusted = true;</span>
        }
<span class="fc" id="L307">        mt = new MethodType(rtype, ptypes, trusted);</span>
        // promote the object to the Real Thing, and reprobe
<span class="fc" id="L309">        mt.form = MethodTypeForm.findForm(mt);</span>
<span class="fc" id="L310">        return internTable.add(mt);</span>
    }
<span class="fc" id="L312">    private static final MethodType[] objectOnlyTypes = new MethodType[20];</span>

    /**
     * Finds or creates a method type whose components are {@code Object} with an optional trailing {@code Object[]} array.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * All parameters and the return type will be {@code Object},
     * except the final array parameter if any, which will be {@code Object[]}.
     * @param objectArgCount number of parameters (excluding the final array parameter if any)
     * @param finalArray whether there will be a trailing array parameter, of type {@code Object[]}
     * @return a generally applicable method type, for all calls of the given fixed argument count and a collected array of further arguments
     * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255 (or 254, if {@code finalArray} is true)
     * @see #genericMethodType(int)
     */
    public static
    MethodType genericMethodType(int objectArgCount, boolean finalArray) {
        MethodType mt;
<span class="fc" id="L328">        checkSlotCount(objectArgCount);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">        int ivarargs = (!finalArray ? 0 : 1);</span>
<span class="fc" id="L330">        int ootIndex = objectArgCount*2 + ivarargs;</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">        if (ootIndex &lt; objectOnlyTypes.length) {</span>
<span class="fc" id="L332">            mt = objectOnlyTypes[ootIndex];</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">            if (mt != null)  return mt;</span>
        }
<span class="fc" id="L335">        Class&lt;?&gt;[] ptypes = new Class&lt;?&gt;[objectArgCount + ivarargs];</span>
<span class="fc" id="L336">        Arrays.fill(ptypes, Object.class);</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">        if (ivarargs != 0)  ptypes[objectArgCount] = Object[].class;</span>
<span class="fc" id="L338">        mt = makeImpl(Object.class, ptypes, true);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">        if (ootIndex &lt; objectOnlyTypes.length) {</span>
<span class="fc" id="L340">            objectOnlyTypes[ootIndex] = mt;     // cache it here also!</span>
        }
<span class="fc" id="L342">        return mt;</span>
    }

    /**
     * Finds or creates a method type whose components are all {@code Object}.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * All parameters and the return type will be Object.
     * @param objectArgCount number of parameters
     * @return a generally applicable method type, for all calls of the given argument count
     * @throws IllegalArgumentException if {@code objectArgCount} is negative or greater than 255
     * @see #genericMethodType(int, boolean)
     */
    public static
    MethodType genericMethodType(int objectArgCount) {
<span class="fc" id="L356">        return genericMethodType(objectArgCount, false);</span>
    }

    /**
     * Finds or creates a method type with a single different parameter type.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * @param num    the index (zero-based) of the parameter type to change
     * @param nptype a new parameter type to replace the old one with
     * @return the same type, except with the selected parameter changed
     * @throws IndexOutOfBoundsException if {@code num} is not a valid index into {@code parameterArray()}
     * @throws IllegalArgumentException if {@code nptype} is {@code void.class}
     * @throws NullPointerException if {@code nptype} is null
     */
    public MethodType changeParameterType(int num, Class&lt;?&gt; nptype) {
<span class="fc bfc" id="L370" title="All 2 branches covered.">        if (parameterType(num) == nptype)  return this;</span>
<span class="fc" id="L371">        checkPtype(nptype);</span>
<span class="fc" id="L372">        Class&lt;?&gt;[] nptypes = ptypes.clone();</span>
<span class="fc" id="L373">        nptypes[num] = nptype;</span>
<span class="fc" id="L374">        return makeImpl(rtype, nptypes, true);</span>
    }

    /**
     * Finds or creates a method type with additional parameter types.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * @param num    the position (zero-based) of the inserted parameter type(s)
     * @param ptypesToInsert zero or more new parameter types to insert into the parameter list
     * @return the same type, except with the selected parameter(s) inserted
     * @throws IndexOutOfBoundsException if {@code num} is negative or greater than {@code parameterCount()}
     * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
     *                                  or if the resulting method type would have more than 255 parameter slots
     * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
     */
    public MethodType insertParameterTypes(int num, Class&lt;?&gt;... ptypesToInsert) {
<span class="fc" id="L389">        int len = ptypes.length;</span>
<span class="pc bpc" id="L390" title="2 of 4 branches missed.">        if (num &lt; 0 || num &gt; len)</span>
<span class="nc" id="L391">            throw newIndexOutOfBoundsException(num);</span>
<span class="fc" id="L392">        int ins = checkPtypes(ptypesToInsert);</span>
<span class="fc" id="L393">        checkSlotCount(parameterSlotCount() + ptypesToInsert.length + ins);</span>
<span class="fc" id="L394">        int ilen = ptypesToInsert.length;</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        if (ilen == 0)  return this;</span>
<span class="fc" id="L396">        Class&lt;?&gt;[] nptypes = Arrays.copyOfRange(ptypes, 0, len+ilen);</span>
<span class="fc" id="L397">        System.arraycopy(nptypes, num, nptypes, num+ilen, len-num);</span>
<span class="fc" id="L398">        System.arraycopy(ptypesToInsert, 0, nptypes, num, ilen);</span>
<span class="fc" id="L399">        return makeImpl(rtype, nptypes, true);</span>
    }

    /**
     * Finds or creates a method type with additional parameter types.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * @param ptypesToInsert zero or more new parameter types to insert after the end of the parameter list
     * @return the same type, except with the selected parameter(s) appended
     * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
     *                                  or if the resulting method type would have more than 255 parameter slots
     * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
     */
    public MethodType appendParameterTypes(Class&lt;?&gt;... ptypesToInsert) {
<span class="fc" id="L412">        return insertParameterTypes(parameterCount(), ptypesToInsert);</span>
    }

    /**
     * Finds or creates a method type with additional parameter types.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * @param num    the position (zero-based) of the inserted parameter type(s)
     * @param ptypesToInsert zero or more new parameter types to insert into the parameter list
     * @return the same type, except with the selected parameter(s) inserted
     * @throws IndexOutOfBoundsException if {@code num} is negative or greater than {@code parameterCount()}
     * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
     *                                  or if the resulting method type would have more than 255 parameter slots
     * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
     */
    public MethodType insertParameterTypes(int num, List&lt;Class&lt;?&gt;&gt; ptypesToInsert) {
<span class="fc" id="L427">        return insertParameterTypes(num, listToArray(ptypesToInsert));</span>
    }

    /**
     * Finds or creates a method type with additional parameter types.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * @param ptypesToInsert zero or more new parameter types to insert after the end of the parameter list
     * @return the same type, except with the selected parameter(s) appended
     * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
     *                                  or if the resulting method type would have more than 255 parameter slots
     * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
     */
    public MethodType appendParameterTypes(List&lt;Class&lt;?&gt;&gt; ptypesToInsert) {
<span class="nc" id="L440">        return insertParameterTypes(parameterCount(), ptypesToInsert);</span>
    }

     /**
     * Finds or creates a method type with modified parameter types.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * @param start  the position (zero-based) of the first replaced parameter type(s)
     * @param end    the position (zero-based) after the last replaced parameter type(s)
     * @param ptypesToInsert zero or more new parameter types to insert into the parameter list
     * @return the same type, except with the selected parameter(s) replaced
     * @throws IndexOutOfBoundsException if {@code start} is negative or greater than {@code parameterCount()}
     *                                  or if {@code end} is negative or greater than {@code parameterCount()}
     *                                  or if {@code start} is greater than {@code end}
     * @throws IllegalArgumentException if any element of {@code ptypesToInsert} is {@code void.class}
     *                                  or if the resulting method type would have more than 255 parameter slots
     * @throws NullPointerException if {@code ptypesToInsert} or any of its elements is null
     */
    /*non-public*/ MethodType replaceParameterTypes(int start, int end, Class&lt;?&gt;... ptypesToInsert) {
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if (start == end)</span>
<span class="fc" id="L459">            return insertParameterTypes(start, ptypesToInsert);</span>
<span class="fc" id="L460">        int len = ptypes.length;</span>
<span class="pc bpc" id="L461" title="3 of 6 branches missed.">        if (!(0 &lt;= start &amp;&amp; start &lt;= end &amp;&amp; end &lt;= len))</span>
<span class="nc" id="L462">            throw newIndexOutOfBoundsException(&quot;start=&quot;+start+&quot; end=&quot;+end);</span>
<span class="fc" id="L463">        int ilen = ptypesToInsert.length;</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (ilen == 0)</span>
<span class="nc" id="L465">            return dropParameterTypes(start, end);</span>
<span class="fc" id="L466">        return dropParameterTypes(start, end).insertParameterTypes(start, ptypesToInsert);</span>
    }

    /**
     * Finds or creates a method type with some parameter types omitted.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * @param start  the index (zero-based) of the first parameter type to remove
     * @param end    the index (greater than {@code start}) of the first parameter type after not to remove
     * @return the same type, except with the selected parameter(s) removed
     * @throws IndexOutOfBoundsException if {@code start} is negative or greater than {@code parameterCount()}
     *                                  or if {@code end} is negative or greater than {@code parameterCount()}
     *                                  or if {@code start} is greater than {@code end}
     */
    public MethodType dropParameterTypes(int start, int end) {
<span class="fc" id="L480">        int len = ptypes.length;</span>
<span class="pc bpc" id="L481" title="3 of 6 branches missed.">        if (!(0 &lt;= start &amp;&amp; start &lt;= end &amp;&amp; end &lt;= len))</span>
<span class="nc" id="L482">            throw newIndexOutOfBoundsException(&quot;start=&quot;+start+&quot; end=&quot;+end);</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (start == end)  return this;</span>
        Class&lt;?&gt;[] nptypes;
<span class="fc bfc" id="L485" title="All 2 branches covered.">        if (start == 0) {</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">            if (end == len) {</span>
                // drop all parameters
<span class="fc" id="L488">                nptypes = NO_PTYPES;</span>
            } else {
                // drop initial parameter(s)
<span class="fc" id="L491">                nptypes = Arrays.copyOfRange(ptypes, end, len);</span>
            }
        } else {
<span class="fc bfc" id="L494" title="All 2 branches covered.">            if (end == len) {</span>
                // drop trailing parameter(s)
<span class="fc" id="L496">                nptypes = Arrays.copyOfRange(ptypes, 0, start);</span>
            } else {
<span class="fc" id="L498">                int tail = len - end;</span>
<span class="fc" id="L499">                nptypes = Arrays.copyOfRange(ptypes, 0, start + tail);</span>
<span class="fc" id="L500">                System.arraycopy(ptypes, end, nptypes, start, tail);</span>
            }
        }
<span class="fc" id="L503">        return makeImpl(rtype, nptypes, true);</span>
    }

    /**
     * Finds or creates a method type with a different return type.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * @param nrtype a return parameter type to replace the old one with
     * @return the same type, except with the return type change
     * @throws NullPointerException if {@code nrtype} is null
     */
    public MethodType changeReturnType(Class&lt;?&gt; nrtype) {
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (returnType() == nrtype)  return this;</span>
<span class="fc" id="L515">        return makeImpl(nrtype, ptypes, true);</span>
    }

    /**
     * Reports if this type contains a primitive argument or return value.
     * The return type {@code void} counts as a primitive.
     * @return true if any of the types are primitives
     */
    public boolean hasPrimitives() {
<span class="fc" id="L524">        return form.hasPrimitives();</span>
    }

    /**
     * Reports if this type contains a wrapper argument or return value.
     * Wrappers are types which box primitive values, such as {@link Integer}.
     * The reference type {@code java.lang.Void} counts as a wrapper,
     * if it occurs as a return type.
     * @return true if any of the types are wrappers
     */
    public boolean hasWrappers() {
<span class="nc bnc" id="L535" title="All 2 branches missed.">        return unwrap() != this;</span>
    }

    /**
     * Erases all reference types to {@code Object}.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * All primitive types (including {@code void}) will remain unchanged.
     * @return a version of the original type with all reference types replaced
     */
    public MethodType erase() {
<span class="fc" id="L545">        return form.erasedType();</span>
    }

    /**
     * Erases all reference types to {@code Object}, and all subword types to {@code int}.
     * This is the reduced type polymorphism used by private methods
     * such as {@link MethodHandle#invokeBasic invokeBasic}.
     * @return a version of the original type with all reference and subword types replaced
     */
    /*non-public*/ MethodType basicType() {
<span class="fc" id="L555">        return form.basicType();</span>
    }

    /**
     * @return a version of the original type with MethodHandle prepended as the first argument
     */
    /*non-public*/ MethodType invokerType() {
<span class="fc" id="L562">        return insertParameterTypes(0, MethodHandle.class);</span>
    }

    /**
     * Converts all types, both reference and primitive, to {@code Object}.
     * Convenience method for {@link #genericMethodType(int) genericMethodType}.
     * The expression {@code type.wrap().erase()} produces the same value
     * as {@code type.generic()}.
     * @return a version of the original type with all types replaced
     */
    public MethodType generic() {
<span class="fc" id="L573">        return genericMethodType(parameterCount());</span>
    }

    /**
     * Converts all primitive types to their corresponding wrapper types.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * All reference types (including wrapper types) will remain unchanged.
     * A {@code void} return type is changed to the type {@code java.lang.Void}.
     * The expression {@code type.wrap().erase()} produces the same value
     * as {@code type.generic()}.
     * @return a version of the original type with all primitive types replaced
     */
    public MethodType wrap() {
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        return hasPrimitives() ? wrapWithPrims(this) : this;</span>
    }

    /**
     * Converts all wrapper types to their corresponding primitive types.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * All primitive types (including {@code void}) will remain unchanged.
     * A return type of {@code java.lang.Void} is changed to {@code void}.
     * @return a version of the original type with all wrapper types replaced
     */
    public MethodType unwrap() {
<span class="nc bnc" id="L597" title="All 2 branches missed.">        MethodType noprims = !hasPrimitives() ? this : wrapWithPrims(this);</span>
<span class="nc" id="L598">        return unwrapWithNoPrims(noprims);</span>
    }

    private static MethodType wrapWithPrims(MethodType pt) {
<span class="pc bpc" id="L602" title="1 of 4 branches missed.">        assert(pt.hasPrimitives());</span>
<span class="fc" id="L603">        MethodType wt = pt.wrapAlt;</span>
<span class="fc bfc" id="L604" title="All 2 branches covered.">        if (wt == null) {</span>
            // fill in lazily
<span class="fc" id="L606">            wt = MethodTypeForm.canonicalize(pt, MethodTypeForm.WRAP, MethodTypeForm.WRAP);</span>
<span class="pc bpc" id="L607" title="1 of 4 branches missed.">            assert(wt != null);</span>
<span class="fc" id="L608">            pt.wrapAlt = wt;</span>
        }
<span class="fc" id="L610">        return wt;</span>
    }

    private static MethodType unwrapWithNoPrims(MethodType wt) {
<span class="nc bnc" id="L614" title="All 4 branches missed.">        assert(!wt.hasPrimitives());</span>
<span class="nc" id="L615">        MethodType uwt = wt.wrapAlt;</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (uwt == null) {</span>
            // fill in lazily
<span class="nc" id="L618">            uwt = MethodTypeForm.canonicalize(wt, MethodTypeForm.UNWRAP, MethodTypeForm.UNWRAP);</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            if (uwt == null)</span>
<span class="nc" id="L620">                uwt = wt;    // type has no wrappers or prims at all</span>
<span class="nc" id="L621">            wt.wrapAlt = uwt;</span>
        }
<span class="nc" id="L623">        return uwt;</span>
    }

    /**
     * Returns the parameter type at the specified index, within this method type.
     * @param num the index (zero-based) of the desired parameter type
     * @return the selected parameter type
     * @throws IndexOutOfBoundsException if {@code num} is not a valid index into {@code parameterArray()}
     */
    public Class&lt;?&gt; parameterType(int num) {
<span class="fc" id="L633">        return ptypes[num];</span>
    }
    /**
     * Returns the number of parameter types in this method type.
     * @return the number of parameter types
     */
    public int parameterCount() {
<span class="fc" id="L640">        return ptypes.length;</span>
    }
    /**
     * Returns the return type of this method type.
     * @return the return type
     */
    public Class&lt;?&gt; returnType() {
<span class="fc" id="L647">        return rtype;</span>
    }

    /**
     * Presents the parameter types as a list (a convenience method).
     * The list will be immutable.
     * @return the parameter types (as an immutable list)
     */
    public List&lt;Class&lt;?&gt;&gt; parameterList() {
<span class="fc" id="L656">        return Collections.unmodifiableList(Arrays.asList(ptypes));</span>
    }

    /*non-public*/ Class&lt;?&gt; lastParameterType() {
<span class="nc" id="L660">        int len = ptypes.length;</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">        return len == 0 ? void.class : ptypes[len-1];</span>
    }

    /**
     * Presents the parameter types as an array (a convenience method).
     * Changes to the array will not result in changes to the type.
     * @return the parameter types (as a fresh copy if necessary)
     */
    public Class&lt;?&gt;[] parameterArray() {
<span class="fc" id="L670">        return ptypes.clone();</span>
    }

    /**
     * Compares the specified object with this type for equality.
     * That is, it returns &lt;tt&gt;true&lt;/tt&gt; if and only if the specified object
     * is also a method type with exactly the same parameters and return type.
     * @param x object to compare
     * @see Object#equals(Object)
     */
    @Override
    public boolean equals(Object x) {
<span class="pc bpc" id="L682" title="1 of 6 branches missed.">        return this == x || x instanceof MethodType &amp;&amp; equals((MethodType)x);</span>
    }

    private boolean equals(MethodType that) {
<span class="fc bfc" id="L686" title="All 2 branches covered.">        return this.rtype == that.rtype</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">            &amp;&amp; Arrays.equals(this.ptypes, that.ptypes);</span>
    }

    /**
     * Returns the hash code value for this method type.
     * It is defined to be the same as the hashcode of a List
     * whose elements are the return type followed by the
     * parameter types.
     * @return the hash code value for this method type
     * @see Object#hashCode()
     * @see #equals(Object)
     * @see List#hashCode()
     */
    @Override
    public int hashCode() {
<span class="fc" id="L702">      int hashCode = 31 + rtype.hashCode();</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">      for (Class&lt;?&gt; ptype : ptypes)</span>
<span class="fc" id="L704">          hashCode = 31*hashCode + ptype.hashCode();</span>
<span class="fc" id="L705">      return hashCode;</span>
    }

    /**
     * Returns a string representation of the method type,
     * of the form {@code &quot;(PT0,PT1...)RT&quot;}.
     * The string representation of a method type is a
     * parenthesis enclosed, comma separated list of type names,
     * followed immediately by the return type.
     * &lt;p&gt;
     * Each type is represented by its
     * {@link java.lang.Class#getSimpleName simple name}.
     */
    @Override
    public String toString() {
<span class="fc" id="L720">        StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L721">        sb.append(&quot;(&quot;);</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">        for (int i = 0; i &lt; ptypes.length; i++) {</span>
<span class="fc bfc" id="L723" title="All 2 branches covered.">            if (i &gt; 0)  sb.append(&quot;,&quot;);</span>
<span class="fc" id="L724">            sb.append(ptypes[i].getSimpleName());</span>
        }
<span class="fc" id="L726">        sb.append(&quot;)&quot;);</span>
<span class="fc" id="L727">        sb.append(rtype.getSimpleName());</span>
<span class="fc" id="L728">        return sb.toString();</span>
    }


    /*non-public*/
    boolean isViewableAs(MethodType newType) {
<span class="nc bnc" id="L734" title="All 2 branches missed.">        if (!VerifyType.isNullConversion(returnType(), newType.returnType()))</span>
<span class="nc" id="L735">            return false;</span>
<span class="nc" id="L736">        int argc = parameterCount();</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (argc != newType.parameterCount())</span>
<span class="nc" id="L738">            return false;</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">        for (int i = 0; i &lt; argc; i++) {</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">            if (!VerifyType.isNullConversion(newType.parameterType(i), parameterType(i)))</span>
<span class="nc" id="L741">                return false;</span>
        }
<span class="nc" id="L743">        return true;</span>
    }
    /*non-public*/
    boolean isCastableTo(MethodType newType) {
<span class="fc" id="L747">        int argc = parameterCount();</span>
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">        if (argc != newType.parameterCount())</span>
<span class="nc" id="L749">            return false;</span>
<span class="fc" id="L750">        return true;</span>
    }
    /*non-public*/
    boolean isConvertibleTo(MethodType newType) {
<span class="fc bfc" id="L754" title="All 2 branches covered.">        if (!canConvert(returnType(), newType.returnType()))</span>
<span class="fc" id="L755">            return false;</span>
<span class="fc" id="L756">        int argc = parameterCount();</span>
<span class="fc bfc" id="L757" title="All 2 branches covered.">        if (argc != newType.parameterCount())</span>
<span class="fc" id="L758">            return false;</span>
<span class="fc bfc" id="L759" title="All 2 branches covered.">        for (int i = 0; i &lt; argc; i++) {</span>
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">            if (!canConvert(newType.parameterType(i), parameterType(i)))</span>
<span class="nc" id="L761">                return false;</span>
        }
<span class="fc" id="L763">        return true;</span>
    }
    /*non-public*/
    static boolean canConvert(Class&lt;?&gt; src, Class&lt;?&gt; dst) {
        // short-circuit a few cases:
<span class="fc bfc" id="L768" title="All 4 branches covered.">        if (src == dst || dst == Object.class)  return true;</span>
        // the remainder of this logic is documented in MethodHandle.asType
<span class="fc bfc" id="L770" title="All 2 branches covered.">        if (src.isPrimitive()) {</span>
            // can force void to an explicit null, a la reflect.Method.invoke
            // can also force void to a primitive zero, by analogy
<span class="fc bfc" id="L773" title="All 2 branches covered.">            if (src == void.class)  return true;  //or !dst.isPrimitive()?</span>
<span class="fc" id="L774">            Wrapper sw = Wrapper.forPrimitiveType(src);</span>
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">            if (dst.isPrimitive()) {</span>
                // P-&gt;P must widen
<span class="fc" id="L777">                return Wrapper.forPrimitiveType(dst).isConvertibleFrom(sw);</span>
            } else {
                // P-&gt;R must box and widen
<span class="nc" id="L780">                return dst.isAssignableFrom(sw.wrapperType());</span>
            }
<span class="fc bfc" id="L782" title="All 2 branches covered.">        } else if (dst.isPrimitive()) {</span>
            // any value can be dropped
<span class="fc bfc" id="L784" title="All 2 branches covered.">            if (dst == void.class)  return true;</span>
<span class="fc" id="L785">            Wrapper dw = Wrapper.forPrimitiveType(dst);</span>
            // R-&gt;P must be able to unbox (from a dynamically chosen type) and widen
            // For example:
            //   Byte/Number/Comparable/Object -&gt; dw:Byte -&gt; byte.
            //   Character/Comparable/Object -&gt; dw:Character -&gt; char
            //   Boolean/Comparable/Object -&gt; dw:Boolean -&gt; boolean
            // This means that dw must be cast-compatible with src.
<span class="fc bfc" id="L792" title="All 2 branches covered.">            if (src.isAssignableFrom(dw.wrapperType())) {</span>
<span class="fc" id="L793">                return true;</span>
            }
            // The above does not work if the source reference is strongly typed
            // to a wrapper whose primitive must be widened.  For example:
            //   Byte -&gt; unbox:byte -&gt; short/int/long/float/double
            //   Character -&gt; unbox:char -&gt; int/long/float/double
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">            if (Wrapper.isWrapperType(src) &amp;&amp;</span>
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">                dw.isConvertibleFrom(Wrapper.forWrapperType(src))) {</span>
                // can unbox from src and then widen to dst
<span class="fc" id="L802">                return true;</span>
            }
            // We have already covered cases which arise due to runtime unboxing
            // of a reference type which covers several wrapper types:
            //   Object -&gt; cast:Integer -&gt; unbox:int -&gt; long/float/double
            //   Serializable -&gt; cast:Byte -&gt; unbox:byte -&gt; byte/short/int/long/float/double
            // An marginal case is Number -&gt; dw:Character -&gt; char, which would be OK if there were a
            // subclass of Number which wraps a value that can convert to char.
            // Since there is none, we don't need an extra check here to cover char or boolean.
<span class="nc" id="L811">            return false;</span>
        } else {
            // R-&gt;R always works, since null is always valid dynamically
<span class="fc" id="L814">            return true;</span>
        }
    }

    /// Queries which have to do with the bytecode architecture

    /** Reports the number of JVM stack slots required to invoke a method
     * of this type.  Note that (for historical reasons) the JVM requires
     * a second stack slot to pass long and double arguments.
     * So this method returns {@link #parameterCount() parameterCount} plus the
     * number of long and double parameters (if any).
     * &lt;p&gt;
     * This method is included for the benefit of applications that must
     * generate bytecodes that process method handles and invokedynamic.
     * @return the number of JVM stack slots for this type's parameters
     */
    /*non-public*/ int parameterSlotCount() {
<span class="fc" id="L831">        return form.parameterSlotCount();</span>
    }

    /*non-public*/ Invokers invokers() {
<span class="fc" id="L835">        Invokers inv = invokers;</span>
<span class="fc bfc" id="L836" title="All 2 branches covered.">        if (inv != null)  return inv;</span>
<span class="fc" id="L837">        invokers = inv = new Invokers(this);</span>
<span class="fc" id="L838">        return inv;</span>
    }

    /** Reports the number of JVM stack slots which carry all parameters including and after
     * the given position, which must be in the range of 0 to
     * {@code parameterCount} inclusive.  Successive parameters are
     * more shallowly stacked, and parameters are indexed in the bytecodes
     * according to their trailing edge.  Thus, to obtain the depth
     * in the outgoing call stack of parameter {@code N}, obtain
     * the {@code parameterSlotDepth} of its trailing edge
     * at position {@code N+1}.
     * &lt;p&gt;
     * Parameters of type {@code long} and {@code double} occupy
     * two stack slots (for historical reasons) and all others occupy one.
     * Therefore, the number returned is the number of arguments
     * &lt;em&gt;including&lt;/em&gt; and &lt;em&gt;after&lt;/em&gt; the given parameter,
     * &lt;em&gt;plus&lt;/em&gt; the number of long or double arguments
     * at or after after the argument for the given parameter.
     * &lt;p&gt;
     * This method is included for the benefit of applications that must
     * generate bytecodes that process method handles and invokedynamic.
     * @param num an index (zero-based, inclusive) within the parameter types
     * @return the index of the (shallowest) JVM stack slot transmitting the
     *         given parameter
     * @throws IllegalArgumentException if {@code num} is negative or greater than {@code parameterCount()}
     */
    /*non-public*/ int parameterSlotDepth(int num) {
<span class="pc bpc" id="L865" title="2 of 4 branches missed.">        if (num &lt; 0 || num &gt; ptypes.length)</span>
<span class="nc" id="L866">            parameterType(num);  // force a range check</span>
<span class="fc" id="L867">        return form.parameterToArgSlot(num-1);</span>
    }

    /** Reports the number of JVM stack slots required to receive a return value
     * from a method of this type.
     * If the {@link #returnType() return type} is void, it will be zero,
     * else if the return type is long or double, it will be two, else one.
     * &lt;p&gt;
     * This method is included for the benefit of applications that must
     * generate bytecodes that process method handles and invokedynamic.
     * @return the number of JVM stack slots (0, 1, or 2) for this type's return value
     * Will be removed for PFD.
     */
    /*non-public*/ int returnSlotCount() {
<span class="nc" id="L881">        return form.returnSlotCount();</span>
    }

    /**
     * Finds or creates an instance of a method type, given the spelling of its bytecode descriptor.
     * Convenience method for {@link #methodType(java.lang.Class, java.lang.Class[]) methodType}.
     * Any class or interface name embedded in the descriptor string
     * will be resolved by calling {@link ClassLoader#loadClass(java.lang.String)}
     * on the given loader (or if it is null, on the system class loader).
     * &lt;p&gt;
     * Note that it is possible to encounter method types which cannot be
     * constructed by this method, because their component types are
     * not all reachable from a common class loader.
     * &lt;p&gt;
     * This method is included for the benefit of applications that must
     * generate bytecodes that process method handles and {@code invokedynamic}.
     * @param descriptor a bytecode-level type descriptor string &quot;(T...)T&quot;
     * @param loader the class loader in which to look up the types
     * @return a method type matching the bytecode-level type descriptor
     * @throws NullPointerException if the string is null
     * @throws IllegalArgumentException if the string is not well-formed
     * @throws TypeNotPresentException if a named type cannot be found
     */
    public static MethodType fromMethodDescriptorString(String descriptor, ClassLoader loader)
        throws IllegalArgumentException, TypeNotPresentException
    {
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">        if (!descriptor.startsWith(&quot;(&quot;) ||  // also generates NPE if needed</span>
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">            descriptor.indexOf(')') &lt; 0 ||</span>
<span class="pc bpc" id="L909" title="1 of 2 branches missed.">            descriptor.indexOf('.') &gt;= 0)</span>
<span class="nc" id="L910">            throw new IllegalArgumentException(&quot;not a method descriptor: &quot;+descriptor);</span>
<span class="fc" id="L911">        List&lt;Class&lt;?&gt;&gt; types = BytecodeDescriptor.parseMethod(descriptor, loader);</span>
<span class="fc" id="L912">        Class&lt;?&gt; rtype = types.remove(types.size() - 1);</span>
<span class="fc" id="L913">        checkSlotCount(types.size());</span>
<span class="fc" id="L914">        Class&lt;?&gt;[] ptypes = listToArray(types);</span>
<span class="fc" id="L915">        return makeImpl(rtype, ptypes, true);</span>
    }

    /**
     * Produces a bytecode descriptor representation of the method type.
     * &lt;p&gt;
     * Note that this is not a strict inverse of {@link #fromMethodDescriptorString fromMethodDescriptorString}.
     * Two distinct classes which share a common name but have different class loaders
     * will appear identical when viewed within descriptor strings.
     * &lt;p&gt;
     * This method is included for the benefit of applications that must
     * generate bytecodes that process method handles and {@code invokedynamic}.
     * {@link #fromMethodDescriptorString(java.lang.String, java.lang.ClassLoader) fromMethodDescriptorString},
     * because the latter requires a suitable class loader argument.
     * @return the bytecode type descriptor representation
     */
    public String toMethodDescriptorString() {
<span class="fc" id="L932">        String desc = methodDescriptor;</span>
<span class="fc bfc" id="L933" title="All 2 branches covered.">        if (desc == null) {</span>
<span class="fc" id="L934">            desc = BytecodeDescriptor.unparse(this);</span>
<span class="fc" id="L935">            methodDescriptor = desc;</span>
        }
<span class="fc" id="L937">        return desc;</span>
    }

    /*non-public*/ static String toFieldDescriptorString(Class&lt;?&gt; cls) {
<span class="fc" id="L941">        return BytecodeDescriptor.unparse(cls);</span>
    }

    /// Serialization.

    /**
     * There are no serializable fields for {@code MethodType}.
     */
<span class="fc" id="L949">    private static final java.io.ObjectStreamField[] serialPersistentFields = { };</span>

    /**
     * Save the {@code MethodType} instance to a stream.
     *
     * @serialData
     * For portability, the serialized format does not refer to named fields.
     * Instead, the return type and parameter type arrays are written directly
     * from the {@code writeObject} method, using two calls to {@code s.writeObject}
     * as follows:
     * &lt;blockquote&gt;&lt;pre&gt;{@code
s.writeObject(this.returnType());
s.writeObject(this.parameterArray());
     * }&lt;/pre&gt;&lt;/blockquote&gt;
     * &lt;p&gt;
     * The deserialized field values are checked as if they were
     * provided to the factory method {@link #methodType(Class,Class[]) methodType}.
     * For example, null values, or {@code void} parameter types,
     * will lead to exceptions during deserialization.
     * @param s the stream to write the object to
     * @throws java.io.IOException if there is a problem writing the object
     */
    private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException {
<span class="nc" id="L972">        s.defaultWriteObject();  // requires serialPersistentFields to be an empty array</span>
<span class="nc" id="L973">        s.writeObject(returnType());</span>
<span class="nc" id="L974">        s.writeObject(parameterArray());</span>
<span class="nc" id="L975">    }</span>

    /**
     * Reconstitute the {@code MethodType} instance from a stream (that is,
     * deserialize it).
     * This instance is a scratch object with bogus final fields.
     * It provides the parameters to the factory method called by
     * {@link #readResolve readResolve}.
     * After that call it is discarded.
     * @param s the stream to read the object from
     * @throws java.io.IOException if there is a problem reading the object
     * @throws ClassNotFoundException if one of the component classes cannot be resolved
     * @see #MethodType()
     * @see #readResolve
     * @see #writeObject
     */
    private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException {
<span class="nc" id="L992">        s.defaultReadObject();  // requires serialPersistentFields to be an empty array</span>

<span class="nc" id="L994">        Class&lt;?&gt;   returnType     = (Class&lt;?&gt;)   s.readObject();</span>
<span class="nc" id="L995">        Class&lt;?&gt;[] parameterArray = (Class&lt;?&gt;[]) s.readObject();</span>

        // Probably this object will never escape, but let's check
        // the field values now, just to be sure.
<span class="nc" id="L999">        checkRtype(returnType);</span>
<span class="nc" id="L1000">        checkPtypes(parameterArray);</span>

<span class="nc" id="L1002">        parameterArray = parameterArray.clone();  // make sure it is unshared</span>
<span class="nc" id="L1003">        MethodType_init(returnType, parameterArray);</span>
<span class="nc" id="L1004">    }</span>

    /**
     * For serialization only.
     * Sets the final fields to null, pending {@code Unsafe.putObject}.
     */
<span class="nc" id="L1010">    private MethodType() {</span>
<span class="nc" id="L1011">        this.rtype = null;</span>
<span class="nc" id="L1012">        this.ptypes = null;</span>
<span class="nc" id="L1013">    }</span>
    private void MethodType_init(Class&lt;?&gt; rtype, Class&lt;?&gt;[] ptypes) {
        // In order to communicate these values to readResolve, we must
        // store them into the implementation-specific final fields.
<span class="nc" id="L1017">        checkRtype(rtype);</span>
<span class="nc" id="L1018">        checkPtypes(ptypes);</span>
<span class="nc" id="L1019">        UNSAFE.putObject(this, rtypeOffset, rtype);</span>
<span class="nc" id="L1020">        UNSAFE.putObject(this, ptypesOffset, ptypes);</span>
<span class="nc" id="L1021">    }</span>

    // Support for resetting final fields while deserializing
    private static final long rtypeOffset, ptypesOffset;
    static {
        try {
<span class="fc" id="L1027">            rtypeOffset = UNSAFE.objectFieldOffset</span>
<span class="fc" id="L1028">                (MethodType.class.getDeclaredField(&quot;rtype&quot;));</span>
<span class="fc" id="L1029">            ptypesOffset = UNSAFE.objectFieldOffset</span>
<span class="fc" id="L1030">                (MethodType.class.getDeclaredField(&quot;ptypes&quot;));</span>
<span class="nc" id="L1031">        } catch (Exception ex) {</span>
<span class="nc" id="L1032">            throw new Error(ex);</span>
<span class="fc" id="L1033">        }</span>
<span class="fc" id="L1034">    }</span>

    /**
     * Resolves and initializes a {@code MethodType} object
     * after serialization.
     * @return the fully initialized {@code MethodType} object
     */
    private Object readResolve() {
        // Do not use a trusted path for deserialization:
        //return makeImpl(rtype, ptypes, true);
        // Verify all operands, and make sure ptypes is unshared:
<span class="nc" id="L1045">        return methodType(rtype, ptypes);</span>
    }

    /**
     * Simple implementation of weak concurrent intern set.
     *
     * @param &lt;T&gt; interned type
     */
    private static class ConcurrentWeakInternSet&lt;T&gt; {

        private final ConcurrentMap&lt;WeakEntry&lt;T&gt;, WeakEntry&lt;T&gt;&gt; map;
        private final ReferenceQueue&lt;T&gt; stale;

<span class="fc" id="L1058">        public ConcurrentWeakInternSet() {</span>
<span class="fc" id="L1059">            this.map = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L1060">            this.stale = new ReferenceQueue&lt;&gt;();</span>
<span class="fc" id="L1061">        }</span>

        /**
         * Get the existing interned element.
         * This method returns null if no element is interned.
         *
         * @param elem element to look up
         * @return the interned element
         */
        public T get(T elem) {
<span class="pc bpc" id="L1071" title="1 of 2 branches missed.">            if (elem == null) throw new NullPointerException();</span>
<span class="fc" id="L1072">            expungeStaleElements();</span>

<span class="fc" id="L1074">            WeakEntry&lt;T&gt; value = map.get(new WeakEntry&lt;&gt;(elem));</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">            if (value != null) {</span>
<span class="fc" id="L1076">                T res = value.get();</span>
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">                if (res != null) {</span>
<span class="fc" id="L1078">                    return res;</span>
                }
            }
<span class="fc" id="L1081">            return null;</span>
        }

        /**
         * Interns the element.
         * Always returns non-null element, matching the one in the intern set.
         * Under the race against another add(), it can return &lt;i&gt;different&lt;/i&gt;
         * element, if another thread beats us to interning it.
         *
         * @param elem element to add
         * @return element that was actually added
         */
        public T add(T elem) {
<span class="pc bpc" id="L1094" title="1 of 2 branches missed.">            if (elem == null) throw new NullPointerException();</span>

            // Playing double race here, and so spinloop is required.
            // First race is with two concurrent updaters.
            // Second race is with GC purging weak ref under our feet.
            // Hopefully, we almost always end up with a single pass.
            T interned;
<span class="fc" id="L1101">            WeakEntry&lt;T&gt; e = new WeakEntry&lt;&gt;(elem, stale);</span>
            do {
<span class="fc" id="L1103">                expungeStaleElements();</span>
<span class="fc" id="L1104">                WeakEntry&lt;T&gt; exist = map.putIfAbsent(e, e);</span>
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">                interned = (exist == null) ? elem : exist.get();</span>
<span class="pc bpc" id="L1106" title="1 of 2 branches missed.">            } while (interned == null);</span>
<span class="fc" id="L1107">            return interned;</span>
        }

        private void expungeStaleElements() {
            Reference&lt;? extends T&gt; reference;
<span class="fc bfc" id="L1112" title="All 2 branches covered.">            while ((reference = stale.poll()) != null) {</span>
<span class="fc" id="L1113">                map.remove(reference);</span>
            }
<span class="fc" id="L1115">        }</span>

        private static class WeakEntry&lt;T&gt; extends WeakReference&lt;T&gt; {

            public final int hashcode;

            public WeakEntry(T key, ReferenceQueue&lt;T&gt; queue) {
<span class="fc" id="L1122">                super(key, queue);</span>
<span class="fc" id="L1123">                hashcode = key.hashCode();</span>
<span class="fc" id="L1124">            }</span>

            public WeakEntry(T key) {
<span class="fc" id="L1127">                super(key);</span>
<span class="fc" id="L1128">                hashcode = key.hashCode();</span>
<span class="fc" id="L1129">            }</span>

            @Override
            public boolean equals(Object obj) {
<span class="pc bpc" id="L1133" title="1 of 2 branches missed.">                if (obj instanceof WeakEntry) {</span>
<span class="fc" id="L1134">                    Object that = ((WeakEntry) obj).get();</span>
<span class="fc" id="L1135">                    Object mine = get();</span>
<span class="pc bpc" id="L1136" title="2 of 6 branches missed.">                    return (that == null || mine == null) ? (this == obj) : mine.equals(that);</span>
                }
<span class="nc" id="L1138">                return false;</span>
            }

            @Override
            public int hashCode() {
<span class="fc" id="L1143">                return hashcode;</span>
            }

        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>