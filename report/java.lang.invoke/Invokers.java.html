<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Invokers.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">Invokers.java</span></div><h1>Invokers.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.invoke;

import java.util.Arrays;
import sun.invoke.empty.Empty;
import static java.lang.invoke.MethodHandleStatics.*;
import static java.lang.invoke.MethodHandleNatives.Constants.*;
import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;
import static java.lang.invoke.LambdaForm.*;

/**
 * Construction and caching of often-used invokers.
 * @author jrose
 */
<span class="fc bfc" id="L39" title="All 2 branches covered.">class Invokers {</span>
    // exact type (sans leading taget MH) for the outgoing call
    private final MethodType targetType;

    // FIXME: Get rid of the invokers that are not useful.

    // exact invoker for the outgoing call
    private /*lazy*/ MethodHandle exactInvoker;
    private /*lazy*/ MethodHandle basicInvoker;  // invokeBasic (unchecked exact)

    // erased (partially untyped but with primitives) invoker for the outgoing call
    // FIXME: get rid of
    private /*lazy*/ MethodHandle erasedInvoker;
    // FIXME: get rid of
    /*lazy*/ MethodHandle erasedInvokerWithDrops;  // for InvokeGeneric

    // general invoker for the outgoing call
    private /*lazy*/ MethodHandle generalInvoker;

    // general invoker for the outgoing call, uses varargs
    private /*lazy*/ MethodHandle varargsInvoker;

    // general invoker for the outgoing call; accepts a trailing Object[]
    private final /*lazy*/ MethodHandle[] spreadInvokers;

    // invoker for an unbound callsite
    private /*lazy*/ MethodHandle uninitializedCallSite;

    /** Compute and cache information common to all collecting adapters
     *  that implement members of the erasure-family of the given erased type.
     */
<span class="fc" id="L70">    /*non-public*/ Invokers(MethodType targetType) {</span>
<span class="fc" id="L71">        this.targetType = targetType;</span>
<span class="fc" id="L72">        this.spreadInvokers = new MethodHandle[targetType.parameterCount()+1];</span>
<span class="fc" id="L73">    }</span>

    /*non-public*/ MethodHandle exactInvoker() {
<span class="fc" id="L76">        MethodHandle invoker = exactInvoker;</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (invoker != null)  return invoker;</span>
<span class="fc" id="L78">        invoker = makeExactOrGeneralInvoker(true);</span>
<span class="fc" id="L79">        exactInvoker = invoker;</span>
<span class="fc" id="L80">        return invoker;</span>
    }

    /*non-public*/ MethodHandle generalInvoker() {
<span class="fc" id="L84">        MethodHandle invoker = generalInvoker;</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (invoker != null)  return invoker;</span>
<span class="fc" id="L86">        invoker = makeExactOrGeneralInvoker(false);</span>
<span class="fc" id="L87">        generalInvoker = invoker;</span>
<span class="fc" id="L88">        return invoker;</span>
    }

    private MethodHandle makeExactOrGeneralInvoker(boolean isExact) {
<span class="fc" id="L92">        MethodType mtype = targetType;</span>
<span class="fc" id="L93">        MethodType invokerType = mtype.invokerType();</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        int which = (isExact ? MethodTypeForm.LF_EX_INVOKER : MethodTypeForm.LF_GEN_INVOKER);</span>
<span class="fc" id="L95">        LambdaForm lform = invokeHandleForm(mtype, false, which);</span>
<span class="fc" id="L96">        MethodHandle invoker = BoundMethodHandle.bindSingle(invokerType, lform, mtype);</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        String whichName = (isExact ? &quot;invokeExact&quot; : &quot;invoke&quot;);</span>
<span class="fc" id="L98">        invoker = invoker.withInternalMemberName(MemberName.makeMethodHandleInvoke(whichName, mtype));</span>
<span class="pc bpc" id="L99" title="1 of 4 branches missed.">        assert(checkInvoker(invoker));</span>
<span class="fc" id="L100">        maybeCompileToBytecode(invoker);</span>
<span class="fc" id="L101">        return invoker;</span>
    }

    /** If the target type seems to be common enough, eagerly compile the invoker to bytecodes. */
    private void maybeCompileToBytecode(MethodHandle invoker) {
        final int EAGER_COMPILE_ARITY_LIMIT = 10;
<span class="fc bfc" id="L107" title="All 2 branches covered.">        if (targetType == targetType.erase() &amp;&amp;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">            targetType.parameterCount() &lt; EAGER_COMPILE_ARITY_LIMIT) {</span>
<span class="fc" id="L109">            invoker.form.compileToBytecode();</span>
        }
<span class="fc" id="L111">    }</span>

    /*non-public*/ MethodHandle basicInvoker() {
<span class="fc" id="L114">        MethodHandle invoker = basicInvoker;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (invoker != null)  return invoker;</span>
<span class="fc" id="L116">        MethodType basicType = targetType.basicType();</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (basicType != targetType) {</span>
            // double cache; not used significantly
<span class="nc" id="L119">            return basicInvoker = basicType.invokers().basicInvoker();</span>
        }
<span class="fc" id="L121">        MemberName method = invokeBasicMethod(basicType);</span>
<span class="fc" id="L122">        invoker = DirectMethodHandle.make(method);</span>
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">        assert(checkInvoker(invoker));</span>
<span class="fc" id="L124">        basicInvoker = invoker;</span>
<span class="fc" id="L125">        return invoker;</span>
    }

    // This next one is called from LambdaForm.NamedFunction.&lt;init&gt;.
    /*non-public*/ static MemberName invokeBasicMethod(MethodType basicType) {
<span class="pc bpc" id="L130" title="1 of 4 branches missed.">        assert(basicType == basicType.basicType());</span>
        try {
            //Lookup.findVirtual(MethodHandle.class, name, type);
<span class="fc" id="L133">            return IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, MethodHandle.class, &quot;invokeBasic&quot;, basicType);</span>
<span class="nc" id="L134">        } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L135">            throw newInternalError(&quot;JVM cannot find invoker for &quot;+basicType, ex);</span>
        }
    }

    private boolean checkInvoker(MethodHandle invoker) {
<span class="pc bpc" id="L140" title="2 of 4 branches missed.">        assert(targetType.invokerType().equals(invoker.type()))</span>
<span class="nc" id="L141">                : java.util.Arrays.asList(targetType, targetType.invokerType(), invoker);</span>
<span class="pc bpc" id="L142" title="2 of 4 branches missed.">        assert(invoker.internalMemberName() == null ||</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">               invoker.internalMemberName().getMethodType().equals(targetType));</span>
<span class="pc bpc" id="L144" title="2 of 4 branches missed.">        assert(!invoker.isVarargsCollector());</span>
<span class="fc" id="L145">        return true;</span>
    }

    // FIXME: get rid of
    /*non-public*/ MethodHandle erasedInvoker() {
<span class="nc" id="L150">        MethodHandle xinvoker = exactInvoker();</span>
<span class="nc" id="L151">        MethodHandle invoker = erasedInvoker;</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (invoker != null)  return invoker;</span>
<span class="nc" id="L153">        MethodType erasedType = targetType.erase();</span>
<span class="nc" id="L154">        invoker = xinvoker.asType(erasedType.invokerType());</span>
<span class="nc" id="L155">        erasedInvoker = invoker;</span>
<span class="nc" id="L156">        return invoker;</span>
    }

    /*non-public*/ MethodHandle spreadInvoker(int leadingArgCount) {
<span class="fc" id="L160">        MethodHandle vaInvoker = spreadInvokers[leadingArgCount];</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        if (vaInvoker != null)  return vaInvoker;</span>
<span class="fc" id="L162">        int spreadArgCount = targetType.parameterCount() - leadingArgCount;</span>
<span class="fc" id="L163">        MethodType spreadInvokerType = targetType</span>
<span class="fc" id="L164">            .replaceParameterTypes(leadingArgCount, targetType.parameterCount(), Object[].class);</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (targetType.parameterSlotCount() &lt;= MethodType.MAX_MH_INVOKER_ARITY) {</span>
            // Factor sinvoker.invoke(mh, a) into ginvoker.asSpreader().invoke(mh, a)
            // where ginvoker.invoke(mh, a*) =&gt; mh.invoke(a*).
<span class="fc" id="L168">            MethodHandle genInvoker = generalInvoker();</span>
<span class="fc" id="L169">            vaInvoker = genInvoker.asSpreader(Object[].class, spreadArgCount);</span>
<span class="fc" id="L170">        } else {</span>
            // Cannot build a general invoker here of type ginvoker.invoke(mh, a*[254]).
            // Instead, factor sinvoker.invoke(mh, a) into ainvoker.invoke(filter(mh), a)
            // where filter(mh) == mh.asSpreader(Object[], spreadArgCount)
<span class="fc" id="L174">            MethodHandle arrayInvoker = MethodHandles.exactInvoker(spreadInvokerType);</span>
            MethodHandle makeSpreader;
            try {
<span class="fc" id="L177">                makeSpreader = IMPL_LOOKUP</span>
<span class="fc" id="L178">                    .findVirtual(MethodHandle.class, &quot;asSpreader&quot;,</span>
<span class="fc" id="L179">                        MethodType.methodType(MethodHandle.class, Class.class, int.class));</span>
<span class="nc" id="L180">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L181">                throw newInternalError(ex);</span>
<span class="fc" id="L182">            }</span>
<span class="fc" id="L183">            makeSpreader = MethodHandles.insertArguments(makeSpreader, 1, Object[].class, spreadArgCount);</span>
<span class="fc" id="L184">            vaInvoker = MethodHandles.filterArgument(arrayInvoker, 0, makeSpreader);</span>
        }
<span class="pc bpc" id="L186" title="2 of 4 branches missed.">        assert(vaInvoker.type().equals(spreadInvokerType.invokerType()));</span>
<span class="fc" id="L187">        maybeCompileToBytecode(vaInvoker);</span>
<span class="fc" id="L188">        spreadInvokers[leadingArgCount] = vaInvoker;</span>
<span class="fc" id="L189">        return vaInvoker;</span>
    }

    /*non-public*/ MethodHandle varargsInvoker() {
<span class="fc" id="L193">        MethodHandle vaInvoker = varargsInvoker;</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (vaInvoker != null)  return vaInvoker;</span>
<span class="fc" id="L195">        vaInvoker = spreadInvoker(0).asType(MethodType.genericMethodType(0, true).invokerType());</span>
<span class="fc" id="L196">        varargsInvoker = vaInvoker;</span>
<span class="fc" id="L197">        return vaInvoker;</span>
    }

<span class="fc" id="L200">    private static MethodHandle THROW_UCS = null;</span>

    /*non-public*/ MethodHandle uninitializedCallSite() {
<span class="fc" id="L203">        MethodHandle invoker = uninitializedCallSite;</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (invoker != null)  return invoker;</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">        if (targetType.parameterCount() &gt; 0) {</span>
<span class="fc" id="L206">            MethodType type0 = targetType.dropParameterTypes(0, targetType.parameterCount());</span>
<span class="fc" id="L207">            Invokers invokers0 = type0.invokers();</span>
<span class="fc" id="L208">            invoker = MethodHandles.dropArguments(invokers0.uninitializedCallSite(),</span>
<span class="fc" id="L209">                                                  0, targetType.parameterList());</span>
<span class="pc bpc" id="L210" title="1 of 4 branches missed.">            assert(invoker.type().equals(targetType));</span>
<span class="fc" id="L211">            uninitializedCallSite = invoker;</span>
<span class="fc" id="L212">            return invoker;</span>
        }
<span class="fc" id="L214">        invoker = THROW_UCS;</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">        if (invoker == null) {</span>
            try {
<span class="fc" id="L217">                THROW_UCS = invoker = IMPL_LOOKUP</span>
<span class="fc" id="L218">                    .findStatic(CallSite.class, &quot;uninitializedCallSite&quot;,</span>
<span class="fc" id="L219">                                MethodType.methodType(Empty.class));</span>
<span class="nc" id="L220">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L221">                throw newInternalError(ex);</span>
<span class="fc" id="L222">            }</span>
        }
<span class="fc" id="L224">        invoker = MethodHandles.explicitCastArguments(invoker, MethodType.methodType(targetType.returnType()));</span>
<span class="fc" id="L225">        invoker = invoker.dropArguments(targetType, 0, targetType.parameterCount());</span>
<span class="pc bpc" id="L226" title="1 of 4 branches missed.">        assert(invoker.type().equals(targetType));</span>
<span class="fc" id="L227">        uninitializedCallSite = invoker;</span>
<span class="fc" id="L228">        return invoker;</span>
    }

    public String toString() {
<span class="nc" id="L232">        return &quot;Invokers&quot;+targetType;</span>
    }

    static MemberName methodHandleInvokeLinkerMethod(String name,
                                                     MethodType mtype,
                                                     Object[] appendixResult) {
        int which;
<span class="pc bpc" id="L239" title="4 of 10 branches missed.">        switch (name) {</span>
<span class="fc" id="L240">        case &quot;invokeExact&quot;:  which = MethodTypeForm.LF_EX_LINKER; break;</span>
<span class="fc" id="L241">        case &quot;invoke&quot;:       which = MethodTypeForm.LF_GEN_LINKER; break;</span>
<span class="nc" id="L242">        default:             throw new InternalError(&quot;not invoker: &quot;+name);</span>
        }
        LambdaForm lform;
<span class="fc bfc" id="L245" title="All 2 branches covered.">        if (mtype.parameterSlotCount() &lt;= MethodType.MAX_MH_ARITY - MH_LINKER_ARG_APPENDED) {</span>
<span class="fc" id="L246">            lform = invokeHandleForm(mtype, false, which);</span>
<span class="fc" id="L247">            appendixResult[0] = mtype;</span>
        } else {
<span class="fc" id="L249">            lform = invokeHandleForm(mtype, true, which);</span>
        }
<span class="fc" id="L251">        return lform.vmentry;</span>
    }

    // argument count to account for trailing &quot;appendix value&quot; (typically the mtype)
    private static final int MH_LINKER_ARG_APPENDED = 1;

    /** Returns an adapter for invokeExact or generic invoke, as a MH or constant pool linker.
     * If !customized, caller is responsible for supplying, during adapter execution,
     * a copy of the exact mtype.  This is because the adapter might be generalized to
     * a basic type.
     * @param mtype the caller's method type (either basic or full-custom)
     * @param customized whether to use a trailing appendix argument (to carry the mtype)
     * @param which bit-encoded 0x01 whether it is a CP adapter (&quot;linker&quot;) or MHs.invoker value (&quot;invoker&quot;);
     *                          0x02 whether it is for invokeExact or generic invoke
     */
    private static LambdaForm invokeHandleForm(MethodType mtype, boolean customized, int which) {
        boolean isCached;
<span class="fc bfc" id="L268" title="All 2 branches covered.">        if (!customized) {</span>
<span class="fc" id="L269">            mtype = mtype.basicType();  // normalize Z to I, String to Object, etc.</span>
<span class="fc" id="L270">            isCached = true;</span>
        } else {
<span class="fc" id="L272">            isCached = false;  // maybe cache if mtype == mtype.basicType()</span>
        }
        boolean isLinker, isGeneric;
        String debugName;
<span class="pc bpc" id="L276" title="1 of 5 branches missed.">        switch (which) {</span>
<span class="fc" id="L277">        case MethodTypeForm.LF_EX_LINKER:   isLinker = true;  isGeneric = false; debugName = &quot;invokeExact_MT&quot;; break;</span>
<span class="fc" id="L278">        case MethodTypeForm.LF_EX_INVOKER:  isLinker = false; isGeneric = false; debugName = &quot;exactInvoker&quot;; break;</span>
<span class="fc" id="L279">        case MethodTypeForm.LF_GEN_LINKER:  isLinker = true;  isGeneric = true;  debugName = &quot;invoke_MT&quot;; break;</span>
<span class="fc" id="L280">        case MethodTypeForm.LF_GEN_INVOKER: isLinker = false; isGeneric = true;  debugName = &quot;invoker&quot;; break;</span>
<span class="nc" id="L281">        default: throw new InternalError();</span>
        }
        LambdaForm lform;
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (isCached) {</span>
<span class="fc" id="L285">            lform = mtype.form().cachedLambdaForm(which);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">            if (lform != null)  return lform;</span>
        }
        // exactInvokerForm (Object,Object)Object
        //   link with java.lang.invoke.MethodHandle.invokeBasic(MethodHandle,Object,Object)Object/invokeSpecial
        final int THIS_MH      = 0;
<span class="fc bfc" id="L291" title="All 2 branches covered.">        final int CALL_MH      = THIS_MH + (isLinker ? 0 : 1);</span>
<span class="fc" id="L292">        final int ARG_BASE     = CALL_MH + 1;</span>
<span class="fc" id="L293">        final int OUTARG_LIMIT = ARG_BASE + mtype.parameterCount();</span>
<span class="fc bfc" id="L294" title="All 4 branches covered.">        final int INARG_LIMIT  = OUTARG_LIMIT + (isLinker &amp;&amp; !customized ? 1 : 0);</span>
<span class="fc" id="L295">        int nameCursor = OUTARG_LIMIT;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">        final int MTYPE_ARG    = customized ? -1 : nameCursor++;  // might be last in-argument</span>
<span class="fc" id="L297">        final int CHECK_TYPE   = nameCursor++;</span>
<span class="fc" id="L298">        final int LINKER_CALL  = nameCursor++;</span>
<span class="fc" id="L299">        MethodType invokerFormType = mtype.invokerType();</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (isLinker) {</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">            if (!customized)</span>
<span class="fc" id="L302">                invokerFormType = invokerFormType.appendParameterTypes(MemberName.class);</span>
        } else {
<span class="fc" id="L304">            invokerFormType = invokerFormType.invokerType();</span>
        }
<span class="fc" id="L306">        Name[] names = arguments(nameCursor - INARG_LIMIT, invokerFormType);</span>
<span class="pc bpc" id="L307" title="1 of 4 branches missed.">        assert(names.length == nameCursor)</span>
<span class="nc" id="L308">                : Arrays.asList(mtype, customized, which, nameCursor, names.length);</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if (MTYPE_ARG &gt;= INARG_LIMIT) {</span>
<span class="pc bpc" id="L310" title="1 of 4 branches missed.">            assert(names[MTYPE_ARG] == null);</span>
<span class="fc" id="L311">            NamedFunction getter = BoundMethodHandle.getSpeciesData(&quot;L&quot;).getterFunction(0);</span>
<span class="fc" id="L312">            names[MTYPE_ARG] = new Name(getter, names[THIS_MH]);</span>
            // else if isLinker, then MTYPE is passed in from the caller (e.g., the JVM)
        }

        // Make the final call.  If isGeneric, then prepend the result of type checking.
<span class="fc" id="L317">        MethodType outCallType = mtype.basicType();</span>
<span class="fc" id="L318">        Object[] outArgs = Arrays.copyOfRange(names, CALL_MH, OUTARG_LIMIT, Object[].class);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        Object mtypeArg = (customized ? mtype : names[MTYPE_ARG]);</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (!isGeneric) {</span>
<span class="fc" id="L321">            names[CHECK_TYPE] = new Name(NF_checkExactType, names[CALL_MH], mtypeArg);</span>
            // mh.invokeExact(a*):R =&gt; checkExactType(mh, TYPEOF(a*:R)); mh.invokeBasic(a*)
        } else {
<span class="fc" id="L324">            names[CHECK_TYPE] = new Name(NF_checkGenericType, names[CALL_MH], mtypeArg);</span>
            // mh.invokeGeneric(a*):R =&gt; checkGenericType(mh, TYPEOF(a*:R)).invokeBasic(a*)
<span class="fc" id="L326">            outArgs[0] = names[CHECK_TYPE];</span>
        }
<span class="fc" id="L328">        names[LINKER_CALL] = new Name(outCallType, outArgs);</span>
<span class="fc" id="L329">        lform = new LambdaForm(debugName, INARG_LIMIT, names);</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (isLinker)</span>
<span class="fc" id="L331">            lform.compileToBytecode();  // JVM needs a real methodOop</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if (isCached)</span>
<span class="fc" id="L333">            lform = mtype.form().setCachedLambdaForm(which, lform);</span>
<span class="fc" id="L334">        return lform;</span>
    }

    /*non-public*/ static
    WrongMethodTypeException newWrongMethodTypeException(MethodType actual, MethodType expected) {
        // FIXME: merge with JVM logic for throwing WMTE
<span class="nc" id="L340">        return new WrongMethodTypeException(&quot;expected &quot;+expected+&quot; but found &quot;+actual);</span>
    }

    /** Static definition of MethodHandle.invokeExact checking code. */
    /*non-public*/ static
    @ForceInline
    void checkExactType(Object mhObj, Object expectedObj) {
<span class="fc" id="L347">        MethodHandle mh = (MethodHandle) mhObj;</span>
<span class="fc" id="L348">        MethodType expected = (MethodType) expectedObj;</span>
<span class="fc" id="L349">        MethodType actual = mh.type();</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        if (actual != expected)</span>
<span class="nc" id="L351">            throw newWrongMethodTypeException(expected, actual);</span>
<span class="fc" id="L352">    }</span>

    /** Static definition of MethodHandle.invokeGeneric checking code.
     * Directly returns the type-adjusted MH to invoke, as follows:
     * {@code (R)MH.invoke(a*) =&gt; MH.asType(TYPEOF(a*:R)).invokeBasic(a*)}
     */
    /*non-public*/ static
    @ForceInline
    Object checkGenericType(Object mhObj, Object expectedObj) {
<span class="fc" id="L361">        MethodHandle mh = (MethodHandle) mhObj;</span>
<span class="fc" id="L362">        MethodType expected = (MethodType) expectedObj;</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (mh.type() == expected)  return mh;</span>
<span class="fc" id="L364">        MethodHandle atc = mh.asTypeCache;</span>
<span class="fc bfc" id="L365" title="All 4 branches covered.">        if (atc != null &amp;&amp; atc.type() == expected)  return atc;</span>
<span class="fc" id="L366">        return mh.asType(expected);</span>
        /* Maybe add more paths here.  Possible optimizations:
         * for (R)MH.invoke(a*),
         * let MT0 = TYPEOF(a*:R), MT1 = MH.type
         *
         * if MT0==MT1 or MT1 can be safely called by MT0
         *  =&gt; MH.invokeBasic(a*)
         * if MT1 can be safely called by MT0[R := Object]
         *  =&gt; MH.invokeBasic(a*) &amp; checkcast(R)
         * if MT1 can be safely called by MT0[* := Object]
         *  =&gt; checkcast(A)* &amp; MH.invokeBasic(a*) &amp; checkcast(R)
         * if a big adapter BA can be pulled out of (MT0,MT1)
         *  =&gt; BA.invokeBasic(MT0,MH,a*)
         * if a local adapter LA can cached on static CS0 = new GICS(MT0)
         *  =&gt; CS0.LA.invokeBasic(MH,a*)
         * else
         *  =&gt; MH.asType(MT0).invokeBasic(A*)
         */
    }

    static MemberName linkToCallSiteMethod(MethodType mtype) {
<span class="fc" id="L387">        LambdaForm lform = callSiteForm(mtype, false);</span>
<span class="fc" id="L388">        return lform.vmentry;</span>
    }

    static MemberName linkToTargetMethod(MethodType mtype) {
<span class="fc" id="L392">        LambdaForm lform = callSiteForm(mtype, true);</span>
<span class="fc" id="L393">        return lform.vmentry;</span>
    }

    // skipCallSite is true if we are optimizing a ConstantCallSite
    private static LambdaForm callSiteForm(MethodType mtype, boolean skipCallSite) {
<span class="fc" id="L398">        mtype = mtype.basicType();  // normalize Z to I, String to Object, etc.</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">        final int which = (skipCallSite ? MethodTypeForm.LF_MH_LINKER : MethodTypeForm.LF_CS_LINKER);</span>
<span class="fc" id="L400">        LambdaForm lform = mtype.form().cachedLambdaForm(which);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (lform != null)  return lform;</span>
        // exactInvokerForm (Object,Object)Object
        //   link with java.lang.invoke.MethodHandle.invokeBasic(MethodHandle,Object,Object)Object/invokeSpecial
        final int ARG_BASE     = 0;
<span class="fc" id="L405">        final int OUTARG_LIMIT = ARG_BASE + mtype.parameterCount();</span>
<span class="fc" id="L406">        final int INARG_LIMIT  = OUTARG_LIMIT + 1;</span>
<span class="fc" id="L407">        int nameCursor = OUTARG_LIMIT;</span>
<span class="fc" id="L408">        final int APPENDIX_ARG = nameCursor++;  // the last in-argument</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">        final int CSITE_ARG    = skipCallSite ? -1 : APPENDIX_ARG;</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        final int CALL_MH      = skipCallSite ? APPENDIX_ARG : nameCursor++;  // result of getTarget</span>
<span class="fc" id="L411">        final int LINKER_CALL  = nameCursor++;</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        MethodType invokerFormType = mtype.appendParameterTypes(skipCallSite ? MethodHandle.class : CallSite.class);</span>
<span class="fc" id="L413">        Name[] names = arguments(nameCursor - INARG_LIMIT, invokerFormType);</span>
<span class="pc bpc" id="L414" title="1 of 4 branches missed.">        assert(names.length == nameCursor);</span>
<span class="pc bpc" id="L415" title="1 of 4 branches missed.">        assert(names[APPENDIX_ARG] != null);</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">        if (!skipCallSite)</span>
<span class="fc" id="L417">            names[CALL_MH] = new Name(NF_getCallSiteTarget, names[CSITE_ARG]);</span>
        // (site.)invokedynamic(a*):R =&gt; mh = site.getTarget(); mh.invokeBasic(a*)
        final int PREPEND_MH = 0, PREPEND_COUNT = 1;
<span class="fc" id="L420">        Object[] outArgs = Arrays.copyOfRange(names, ARG_BASE, OUTARG_LIMIT + PREPEND_COUNT, Object[].class);</span>
        // prepend MH argument:
<span class="fc" id="L422">        System.arraycopy(outArgs, 0, outArgs, PREPEND_COUNT, outArgs.length - PREPEND_COUNT);</span>
<span class="fc" id="L423">        outArgs[PREPEND_MH] = names[CALL_MH];</span>
<span class="fc" id="L424">        names[LINKER_CALL] = new Name(mtype, outArgs);</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        lform = new LambdaForm((skipCallSite ? &quot;linkToTargetMethod&quot; : &quot;linkToCallSite&quot;), INARG_LIMIT, names);</span>
<span class="fc" id="L426">        lform.compileToBytecode();  // JVM needs a real methodOop</span>
<span class="fc" id="L427">        lform = mtype.form().setCachedLambdaForm(which, lform);</span>
<span class="fc" id="L428">        return lform;</span>
    }

    /** Static definition of MethodHandle.invokeGeneric checking code. */
    /*non-public*/ static
    @ForceInline
    Object getCallSiteTarget(Object site) {
<span class="fc" id="L435">        return ((CallSite)site).getTarget();</span>
    }

    // Local constant functions:
    private static final NamedFunction NF_checkExactType;
    private static final NamedFunction NF_checkGenericType;
    private static final NamedFunction NF_asType;
    private static final NamedFunction NF_getCallSiteTarget;
    static {
        try {
<span class="fc" id="L445">            NF_checkExactType = new NamedFunction(Invokers.class</span>
<span class="fc" id="L446">                    .getDeclaredMethod(&quot;checkExactType&quot;, Object.class, Object.class));</span>
<span class="fc" id="L447">            NF_checkGenericType = new NamedFunction(Invokers.class</span>
<span class="fc" id="L448">                    .getDeclaredMethod(&quot;checkGenericType&quot;, Object.class, Object.class));</span>
<span class="fc" id="L449">            NF_asType = new NamedFunction(MethodHandle.class</span>
<span class="fc" id="L450">                    .getDeclaredMethod(&quot;asType&quot;, MethodType.class));</span>
<span class="fc" id="L451">            NF_getCallSiteTarget = new NamedFunction(Invokers.class</span>
<span class="fc" id="L452">                    .getDeclaredMethod(&quot;getCallSiteTarget&quot;, Object.class));</span>
<span class="fc" id="L453">            NF_checkExactType.resolve();</span>
<span class="fc" id="L454">            NF_checkGenericType.resolve();</span>
<span class="fc" id="L455">            NF_getCallSiteTarget.resolve();</span>
            // bound
<span class="nc" id="L457">        } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L458">            throw newInternalError(ex);</span>
<span class="fc" id="L459">        }</span>
<span class="fc" id="L460">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>