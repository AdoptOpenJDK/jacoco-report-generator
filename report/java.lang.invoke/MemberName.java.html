<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MemberName.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">MemberName.java</span></div><h1>MemberName.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.invoke;

import sun.invoke.util.BytecodeDescriptor;
import sun.invoke.util.VerifyAccess;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Member;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import static java.lang.invoke.MethodHandleNatives.Constants.*;
import static java.lang.invoke.MethodHandleStatics.*;
import java.util.Objects;

/**
 * A {@code MemberName} is a compact symbolic datum which fully characterizes
 * a method or field reference.
 * A member name refers to a field, method, constructor, or member type.
 * Every member name has a simple name (a string) and a type (either a Class or MethodType).
 * A member name may also have a non-null declaring class, or it may be simply
 * a naked name/type pair.
 * A member name may also have non-zero modifier flags.
 * Finally, a member name may be either resolved or unresolved.
 * If it is resolved, the existence of the named
 * &lt;p&gt;
 * Whether resolved or not, a member name provides no access rights or
 * invocation capability to its possessor.  It is merely a compact
 * representation of all symbolic information necessary to link to
 * and properly use the named member.
 * &lt;p&gt;
 * When resolved, a member name's internal implementation may include references to JVM metadata.
 * This representation is stateless and only decriptive.
 * It provides no private information and no capability to use the member.
 * &lt;p&gt;
 * By contrast, a {@linkplain java.lang.reflect.Method} contains fuller information
 * about the internals of a method (except its bytecodes) and also
 * allows invocation.  A MemberName is much lighter than a Method,
 * since it contains about 7 fields to the 16 of Method (plus its sub-arrays),
 * and those seven fields omit much of the information in Method.
 * @author jrose
 */
<span class="fc bfc" id="L72" title="All 2 branches covered.">/*non-public*/ final class MemberName implements Member, Cloneable {</span>
    private Class&lt;?&gt; clazz;       // class in which the method is defined
    private String   name;        // may be null if not yet materialized
    private Object   type;        // may be null if not yet materialized
    private int      flags;       // modifier bits; see reflect.Modifier
    //@Injected JVM_Method* vmtarget;
    //@Injected int         vmindex;
    private Object   resolution;  // if null, this guy is resolved

    /** Return the declaring class of this member.
     *  In the case of a bare name and type, the declaring class will be null.
     */
    public Class&lt;?&gt; getDeclaringClass() {
<span class="fc" id="L85">        return clazz;</span>
    }

    /** Utility method producing the class loader of the declaring class. */
    public ClassLoader getClassLoader() {
<span class="fc" id="L90">        return clazz.getClassLoader();</span>
    }

    /** Return the simple name of this member.
     *  For a type, it is the same as {@link Class#getSimpleName}.
     *  For a method or field, it is the simple name of the member.
     *  For a constructor, it is always {@code &quot;&amp;lt;init&amp;gt;&quot;}.
     */
    public String getName() {
<span class="pc bpc" id="L99" title="1 of 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L100">            expandFromVM();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">            if (name == null) {</span>
<span class="nc" id="L102">                return null;</span>
            }
        }
<span class="fc" id="L105">        return name;</span>
    }

    public MethodType getMethodOrFieldType() {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (isInvocable())</span>
<span class="fc" id="L110">            return getMethodType();</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (isGetter())</span>
<span class="fc" id="L112">            return MethodType.methodType(getFieldType());</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">        if (isSetter())</span>
<span class="fc" id="L114">            return MethodType.methodType(void.class, getFieldType());</span>
<span class="nc" id="L115">        throw new InternalError(&quot;not a method or field: &quot;+this);</span>
    }

    /** Return the declared type of this member, which
     *  must be a method or constructor.
     */
    public MethodType getMethodType() {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (type == null) {</span>
<span class="fc" id="L123">            expandFromVM();</span>
<span class="pc bpc" id="L124" title="1 of 2 branches missed.">            if (type == null) {</span>
<span class="nc" id="L125">                return null;</span>
            }
        }
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">        if (!isInvocable()) {</span>
<span class="nc" id="L129">            throw newIllegalArgumentException(&quot;not invocable, no method type&quot;);</span>
        }

        {
            // Get a snapshot of type which doesn't get changed by racing threads.
<span class="fc" id="L134">            final Object type = this.type;</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">            if (type instanceof MethodType) {</span>
<span class="fc" id="L136">                return (MethodType) type;</span>
            }
        }

        // type is not a MethodType yet.  Convert it thread-safely.
<span class="fc" id="L141">        synchronized (this) {</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">            if (type instanceof String) {</span>
<span class="fc" id="L143">                String sig = (String) type;</span>
<span class="fc" id="L144">                MethodType res = MethodType.fromMethodDescriptorString(sig, getClassLoader());</span>
<span class="fc" id="L145">                type = res;</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">            } else if (type instanceof Object[]) {</span>
<span class="fc" id="L147">                Object[] typeInfo = (Object[]) type;</span>
<span class="fc" id="L148">                Class&lt;?&gt;[] ptypes = (Class&lt;?&gt;[]) typeInfo[1];</span>
<span class="fc" id="L149">                Class&lt;?&gt; rtype = (Class&lt;?&gt;) typeInfo[0];</span>
<span class="fc" id="L150">                MethodType res = MethodType.methodType(rtype, ptypes);</span>
<span class="fc" id="L151">                type = res;</span>
            }
            // Make sure type is a MethodType for racing threads.
<span class="pc bpc" id="L154" title="1 of 4 branches missed.">            assert type instanceof MethodType : &quot;bad method type &quot; + type;</span>
<span class="pc" id="L155">        }</span>
<span class="fc" id="L156">        return (MethodType) type;</span>
    }

    /** Return the actual type under which this method or constructor must be invoked.
     *  For non-static methods or constructors, this is the type with a leading parameter,
     *  a reference to declaring class.  For static methods, it is the same as the declared type.
     */
    public MethodType getInvocationType() {
<span class="fc" id="L164">        MethodType itype = getMethodOrFieldType();</span>
<span class="pc bpc" id="L165" title="1 of 4 branches missed.">        if (isConstructor() &amp;&amp; getReferenceKind() == REF_newInvokeSpecial)</span>
<span class="fc" id="L166">            return itype.changeReturnType(clazz);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (!isStatic())</span>
<span class="fc" id="L168">            return itype.insertParameterTypes(0, clazz);</span>
<span class="fc" id="L169">        return itype;</span>
    }

    /** Utility method producing the parameter types of the method type. */
    public Class&lt;?&gt;[] getParameterTypes() {
<span class="nc" id="L174">        return getMethodType().parameterArray();</span>
    }

    /** Utility method producing the return type of the method type. */
    public Class&lt;?&gt; getReturnType() {
<span class="nc" id="L179">        return getMethodType().returnType();</span>
    }

    /** Return the declared type of this member, which
     *  must be a field or type.
     *  If it is a type member, that type itself is returned.
     */
    public Class&lt;?&gt; getFieldType() {
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L188">            expandFromVM();</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (type == null) {</span>
<span class="nc" id="L190">                return null;</span>
            }
        }
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (isInvocable()) {</span>
<span class="nc" id="L194">            throw newIllegalArgumentException(&quot;not a field or nested class, no simple type&quot;);</span>
        }

        {
            // Get a snapshot of type which doesn't get changed by racing threads.
<span class="fc" id="L199">            final Object type = this.type;</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            if (type instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L201">                return (Class&lt;?&gt;) type;</span>
            }
        }

        // type is not a Class yet.  Convert it thread-safely.
<span class="nc" id="L206">        synchronized (this) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (type instanceof String) {</span>
<span class="nc" id="L208">                String sig = (String) type;</span>
<span class="nc" id="L209">                MethodType mtype = MethodType.fromMethodDescriptorString(&quot;()&quot;+sig, getClassLoader());</span>
<span class="nc" id="L210">                Class&lt;?&gt; res = mtype.returnType();</span>
<span class="nc" id="L211">                type = res;</span>
            }
            // Make sure type is a Class for racing threads.
<span class="nc bnc" id="L214" title="All 4 branches missed.">            assert type instanceof Class&lt;?&gt; : &quot;bad field type &quot; + type;</span>
<span class="nc" id="L215">        }</span>
<span class="nc" id="L216">        return (Class&lt;?&gt;) type;</span>
    }

    /** Utility method to produce either the method type or field type of this member. */
    public Object getType() {
<span class="fc bfc" id="L221" title="All 2 branches covered.">        return (isInvocable() ? getMethodType() : getFieldType());</span>
    }

    /** Utility method to produce the signature of this member,
     *  used within the class file format to describe its type.
     */
    public String getSignature() {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L229">            expandFromVM();</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">            if (type == null) {</span>
<span class="nc" id="L231">                return null;</span>
            }
        }
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (isInvocable())</span>
<span class="nc" id="L235">            return BytecodeDescriptor.unparse(getMethodType());</span>
        else
<span class="nc" id="L237">            return BytecodeDescriptor.unparse(getFieldType());</span>
    }

    /** Return the modifier flags of this member.
     *  @see java.lang.reflect.Modifier
     */
    public int getModifiers() {
<span class="fc" id="L244">        return (flags &amp; RECOGNIZED_MODIFIERS);</span>
    }

    /** Return the reference kind of this member, or zero if none.
     */
    public byte getReferenceKind() {
<span class="fc" id="L250">        return (byte) ((flags &gt;&gt;&gt; MN_REFERENCE_KIND_SHIFT) &amp; MN_REFERENCE_KIND_MASK);</span>
    }
    private boolean referenceKindIsConsistent() {
<span class="fc" id="L253">        byte refKind = getReferenceKind();</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (refKind == REF_NONE)  return isType();</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">        if (isField()) {</span>
<span class="pc bpc" id="L256" title="2 of 4 branches missed.">            assert(staticIsConsistent());</span>
<span class="pc bpc" id="L257" title="2 of 4 branches missed.">            assert(MethodHandleNatives.refKindIsField(refKind));</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        } else if (isConstructor()) {</span>
<span class="pc bpc" id="L259" title="3 of 6 branches missed.">            assert(refKind == REF_newInvokeSpecial || refKind == REF_invokeSpecial);</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        } else if (isMethod()) {</span>
<span class="pc bpc" id="L261" title="2 of 4 branches missed.">            assert(staticIsConsistent());</span>
<span class="pc bpc" id="L262" title="2 of 4 branches missed.">            assert(MethodHandleNatives.refKindIsMethod(refKind));</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">            if (clazz.isInterface())</span>
<span class="pc bpc" id="L264" title="8 of 10 branches missed.">                assert(refKind == REF_invokeInterface ||</span>
                       refKind == REF_invokeStatic    ||
                       refKind == REF_invokeSpecial   ||
<span class="nc bnc" id="L267" title="All 2 branches missed.">                       refKind == REF_invokeVirtual &amp;&amp; isObjectPublicMethod());</span>
        } else {
<span class="nc bnc" id="L269" title="All 2 branches missed.">            assert(false);</span>
        }
<span class="fc" id="L271">        return true;</span>
    }
    private boolean isObjectPublicMethod() {
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (clazz == Object.class)  return true;</span>
<span class="nc" id="L275">        MethodType mtype = getMethodType();</span>
<span class="nc bnc" id="L276" title="All 6 branches missed.">        if (name.equals(&quot;toString&quot;) &amp;&amp; mtype.returnType() == String.class &amp;&amp; mtype.parameterCount() == 0)</span>
<span class="nc" id="L277">            return true;</span>
<span class="nc bnc" id="L278" title="All 6 branches missed.">        if (name.equals(&quot;hashCode&quot;) &amp;&amp; mtype.returnType() == int.class &amp;&amp; mtype.parameterCount() == 0)</span>
<span class="nc" id="L279">            return true;</span>
<span class="nc bnc" id="L280" title="All 8 branches missed.">        if (name.equals(&quot;equals&quot;) &amp;&amp; mtype.returnType() == boolean.class &amp;&amp; mtype.parameterCount() == 1 &amp;&amp; mtype.parameterType(0) == Object.class)</span>
<span class="nc" id="L281">            return true;</span>
<span class="nc" id="L282">        return false;</span>
    }
    /*non-public*/ boolean referenceKindIsConsistentWith(int originalRefKind) {
<span class="fc" id="L285">        int refKind = getReferenceKind();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (refKind == originalRefKind)  return true;</span>
<span class="pc bpc" id="L287" title="2 of 3 branches missed.">        switch (originalRefKind) {</span>
        case REF_invokeInterface:
            // Looking up an interface method, can get (e.g.) Object.hashCode
<span class="nc bnc" id="L290" title="All 6 branches missed.">            assert(refKind == REF_invokeVirtual ||</span>
                   refKind == REF_invokeSpecial) : this;
<span class="nc" id="L292">            return true;</span>
        case REF_invokeVirtual:
        case REF_newInvokeSpecial:
            // Looked up a virtual, can get (e.g.) final String.hashCode.
<span class="pc bpc" id="L296" title="2 of 4 branches missed.">            assert(refKind == REF_invokeSpecial) : this;</span>
<span class="fc" id="L297">            return true;</span>
        }
<span class="nc bnc" id="L299" title="All 2 branches missed.">        assert(false) : this+&quot; != &quot;+MethodHandleNatives.refKindName((byte)originalRefKind);</span>
<span class="nc" id="L300">        return true;</span>
    }
    private boolean staticIsConsistent() {
<span class="fc" id="L303">        byte refKind = getReferenceKind();</span>
<span class="pc bpc" id="L304" title="3 of 4 branches missed.">        return MethodHandleNatives.refKindIsStatic(refKind) == isStatic() || getModifiers() == 0;</span>
    }
    private boolean vminfoIsConsistent() {
<span class="fc" id="L307">        byte refKind = getReferenceKind();</span>
<span class="pc bpc" id="L308" title="2 of 4 branches missed.">        assert(isResolved());  // else don't call</span>
<span class="fc" id="L309">        Object vminfo = MethodHandleNatives.getMemberVMInfo(this);</span>
<span class="pc bpc" id="L310" title="2 of 4 branches missed.">        assert(vminfo instanceof Object[]);</span>
<span class="fc" id="L311">        long vmindex = (Long) ((Object[])vminfo)[0];</span>
<span class="fc" id="L312">        Object vmtarget = ((Object[])vminfo)[1];</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (MethodHandleNatives.refKindIsField(refKind)) {</span>
<span class="pc bpc" id="L314" title="2 of 4 branches missed.">            assert(vmindex &gt;= 0) : vmindex + &quot;:&quot; + this;</span>
<span class="pc bpc" id="L315" title="2 of 4 branches missed.">            assert(vmtarget instanceof Class);</span>
        } else {
<span class="fc bfc" id="L317" title="All 2 branches covered.">            if (MethodHandleNatives.refKindDoesDispatch(refKind))</span>
<span class="pc bpc" id="L318" title="2 of 4 branches missed.">                assert(vmindex &gt;= 0) : vmindex + &quot;:&quot; + this;</span>
            else
<span class="pc bpc" id="L320" title="2 of 4 branches missed.">                assert(vmindex &lt; 0) : vmindex;</span>
<span class="pc bpc" id="L321" title="2 of 4 branches missed.">            assert(vmtarget instanceof MemberName) : vmtarget + &quot; in &quot; + this;</span>
        }
<span class="fc" id="L323">        return true;</span>
    }

    private MemberName changeReferenceKind(byte refKind, byte oldKind) {
<span class="pc bpc" id="L327" title="1 of 4 branches missed.">        assert(getReferenceKind() == oldKind);</span>
<span class="pc bpc" id="L328" title="1 of 4 branches missed.">        assert(MethodHandleNatives.refKindIsValid(refKind));</span>
<span class="fc" id="L329">        flags += (((int)refKind - oldKind) &lt;&lt; MN_REFERENCE_KIND_SHIFT);</span>
//        if (isConstructor() &amp;&amp; refKind != REF_newInvokeSpecial)
//            flags += (IS_METHOD - IS_CONSTRUCTOR);
//        else if (refKind == REF_newInvokeSpecial &amp;&amp; isMethod())
//            flags += (IS_CONSTRUCTOR - IS_METHOD);
<span class="fc" id="L334">        return this;</span>
    }

    private boolean testFlags(int mask, int value) {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        return (flags &amp; mask) == value;</span>
    }
    private boolean testAllFlags(int mask) {
<span class="fc" id="L341">        return testFlags(mask, mask);</span>
    }
    private boolean testAnyFlags(int mask) {
<span class="fc bfc" id="L344" title="All 2 branches covered.">        return !testFlags(mask, 0);</span>
    }

    /** Utility method to query if this member is a method handle invocation (invoke or invokeExact). */
    public boolean isMethodHandleInvoke() {
        final int bits = MH_INVOKE_MODS;
        final int negs = Modifier.STATIC;
<span class="fc bfc" id="L351" title="All 4 branches covered.">        if (testFlags(bits | negs, bits) &amp;&amp;</span>
            clazz == MethodHandle.class) {
<span class="fc" id="L353">            return isMethodHandleInvokeName(name);</span>
        }
<span class="fc" id="L355">        return false;</span>
    }
    public static boolean isMethodHandleInvokeName(String name) {
<span class="fc bfc" id="L358" title="All 4 branches covered.">        return name.equals(&quot;invoke&quot;) || name.equals(&quot;invokeExact&quot;);</span>
    }
    private static final int MH_INVOKE_MODS = Modifier.NATIVE | Modifier.FINAL | Modifier.PUBLIC;

    /** Utility method to query the modifier flags of this member. */
    public boolean isStatic() {
<span class="fc" id="L364">        return Modifier.isStatic(flags);</span>
    }
    /** Utility method to query the modifier flags of this member. */
    public boolean isPublic() {
<span class="fc" id="L368">        return Modifier.isPublic(flags);</span>
    }
    /** Utility method to query the modifier flags of this member. */
    public boolean isPrivate() {
<span class="fc" id="L372">        return Modifier.isPrivate(flags);</span>
    }
    /** Utility method to query the modifier flags of this member. */
    public boolean isProtected() {
<span class="fc" id="L376">        return Modifier.isProtected(flags);</span>
    }
    /** Utility method to query the modifier flags of this member. */
    public boolean isFinal() {
<span class="nc" id="L380">        return Modifier.isFinal(flags);</span>
    }
    /** Utility method to query whether this member or its defining class is final. */
    public boolean canBeStaticallyBound() {
<span class="fc" id="L384">        return Modifier.isFinal(flags | clazz.getModifiers());</span>
    }
    /** Utility method to query the modifier flags of this member. */
    public boolean isVolatile() {
<span class="fc" id="L388">        return Modifier.isVolatile(flags);</span>
    }
    /** Utility method to query the modifier flags of this member. */
    public boolean isAbstract() {
<span class="fc" id="L392">        return Modifier.isAbstract(flags);</span>
    }
    /** Utility method to query the modifier flags of this member. */
    public boolean isNative() {
<span class="nc" id="L396">        return Modifier.isNative(flags);</span>
    }
    // let the rest (native, volatile, transient, etc.) be tested via Modifier.isJDK

    // unofficial modifier flags, used by HotSpot:
    static final int BRIDGE    = 0x00000040;
    static final int VARARGS   = 0x00000080;
    static final int SYNTHETIC = 0x00001000;
    static final int ANNOTATION= 0x00002000;
    static final int ENUM      = 0x00004000;
    /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
    public boolean isBridge() {
<span class="nc" id="L408">        return testAllFlags(IS_METHOD | BRIDGE);</span>
    }
    /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
    public boolean isVarargs() {
<span class="pc bpc" id="L412" title="1 of 4 branches missed.">        return testAllFlags(VARARGS) &amp;&amp; isInvocable();</span>
    }
    /** Utility method to query the modifier flags of this member; returns false if the member is not a method. */
    public boolean isSynthetic() {
<span class="nc" id="L416">        return testAllFlags(SYNTHETIC);</span>
    }

    static final String CONSTRUCTOR_NAME = &quot;&lt;init&gt;&quot;;  // the ever-popular

    // modifiers exported by the JVM:
    static final int RECOGNIZED_MODIFIERS = 0xFFFF;

    // private flags, not part of RECOGNIZED_MODIFIERS:
    static final int
            IS_METHOD        = MN_IS_METHOD,        // method (not constructor)
            IS_CONSTRUCTOR   = MN_IS_CONSTRUCTOR,   // constructor
            IS_FIELD         = MN_IS_FIELD,         // field
            IS_TYPE          = MN_IS_TYPE,          // nested type
            CALLER_SENSITIVE = MN_CALLER_SENSITIVE; // @CallerSensitive annotation detected

    static final int ALL_ACCESS = Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED;
    static final int ALL_KINDS = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE;
    static final int IS_INVOCABLE = IS_METHOD | IS_CONSTRUCTOR;
    static final int IS_FIELD_OR_METHOD = IS_METHOD | IS_FIELD;
    static final int SEARCH_ALL_SUPERS = MN_SEARCH_SUPERCLASSES | MN_SEARCH_INTERFACES;

    /** Utility method to query whether this member is a method or constructor. */
    public boolean isInvocable() {
<span class="fc" id="L440">        return testAnyFlags(IS_INVOCABLE);</span>
    }
    /** Utility method to query whether this member is a method, constructor, or field. */
    public boolean isFieldOrMethod() {
<span class="nc" id="L444">        return testAnyFlags(IS_FIELD_OR_METHOD);</span>
    }
    /** Query whether this member is a method. */
    public boolean isMethod() {
<span class="fc" id="L448">        return testAllFlags(IS_METHOD);</span>
    }
    /** Query whether this member is a constructor. */
    public boolean isConstructor() {
<span class="fc" id="L452">        return testAllFlags(IS_CONSTRUCTOR);</span>
    }
    /** Query whether this member is a field. */
    public boolean isField() {
<span class="fc" id="L456">        return testAllFlags(IS_FIELD);</span>
    }
    /** Query whether this member is a type. */
    public boolean isType() {
<span class="fc" id="L460">        return testAllFlags(IS_TYPE);</span>
    }
    /** Utility method to query whether this member is neither public, private, nor protected. */
    public boolean isPackage() {
<span class="fc bfc" id="L464" title="All 2 branches covered.">        return !testAnyFlags(ALL_ACCESS);</span>
    }
    /** Query whether this member has a CallerSensitive annotation. */
    public boolean isCallerSensitive() {
<span class="fc" id="L468">        return testAllFlags(CALLER_SENSITIVE);</span>
    }

    /** Utility method to query whether this member is accessible from a given lookup class. */
    public boolean isAccessibleFrom(Class&lt;?&gt; lookupClass) {
<span class="nc" id="L473">        return VerifyAccess.isMemberAccessible(this.getDeclaringClass(), this.getDeclaringClass(), flags,</span>
                                               lookupClass, ALL_ACCESS|MethodHandles.Lookup.PACKAGE);
    }

    /** Initialize a query.   It is not resolved. */
    private void init(Class&lt;?&gt; defClass, String name, Object type, int flags) {
        // defining class is allowed to be null (for a naked name/type pair)
        //name.toString();  // null check
        //type.equals(type);  // null check
        // fill in fields:
<span class="fc" id="L483">        this.clazz = defClass;</span>
<span class="fc" id="L484">        this.name = name;</span>
<span class="fc" id="L485">        this.type = type;</span>
<span class="fc" id="L486">        this.flags = flags;</span>
<span class="pc bpc" id="L487" title="1 of 4 branches missed.">        assert(testAnyFlags(ALL_KINDS));</span>
<span class="pc bpc" id="L488" title="1 of 4 branches missed.">        assert(this.resolution == null);  // nobody should have touched this yet</span>
        //assert(referenceKindIsConsistent());  // do this after resolution
<span class="fc" id="L490">    }</span>

    /**
     * Calls down to the VM to fill in the fields.  This method is
     * synchronized to avoid racing calls.
     */
    private void expandFromVM() {
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">        if (type != null) {</span>
<span class="nc" id="L498">            return;</span>
        }
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">        if (!isResolved()) {</span>
<span class="nc" id="L501">            return;</span>
        }
<span class="fc" id="L503">        MethodHandleNatives.expand(this);</span>
<span class="fc" id="L504">    }</span>

    // Capturing information from the Core Reflection API:
    private static int flagsMods(int flags, int mods, byte refKind) {
<span class="pc bpc" id="L508" title="1 of 4 branches missed.">        assert((flags &amp; RECOGNIZED_MODIFIERS) == 0);</span>
<span class="pc bpc" id="L509" title="1 of 4 branches missed.">        assert((mods &amp; ~RECOGNIZED_MODIFIERS) == 0);</span>
<span class="pc bpc" id="L510" title="1 of 4 branches missed.">        assert((refKind &amp; ~MN_REFERENCE_KIND_MASK) == 0);</span>
<span class="fc" id="L511">        return flags | mods | (refKind &lt;&lt; MN_REFERENCE_KIND_SHIFT);</span>
    }
    /** Create a name for the given reflected method.  The resulting name will be in a resolved state. */
    public MemberName(Method m) {
<span class="fc" id="L515">        this(m, false);</span>
<span class="fc" id="L516">    }</span>
    @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)
<span class="fc" id="L518">    public MemberName(Method m, boolean wantSpecial) {</span>
<span class="fc" id="L519">        m.getClass();  // NPE check</span>
        // fill in vmtarget, vmindex while we have m in hand:
<span class="fc" id="L521">        MethodHandleNatives.init(this, m);</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">        if (clazz == null) {  // MHN.init failed</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">            if (m.getDeclaringClass() == MethodHandle.class &amp;&amp;</span>
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">                isMethodHandleInvokeName(m.getName())) {</span>
                // The JVM did not reify this signature-polymorphic instance.
                // Need a special case here.
                // See comments on MethodHandleNatives.linkMethod.
<span class="fc" id="L528">                MethodType type = MethodType.methodType(m.getReturnType(), m.getParameterTypes());</span>
<span class="fc" id="L529">                int flags = flagsMods(IS_METHOD, m.getModifiers(), REF_invokeVirtual);</span>
<span class="fc" id="L530">                init(MethodHandle.class, m.getName(), type, flags);</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">                if (isMethodHandleInvoke())</span>
<span class="fc" id="L532">                    return;</span>
            }
<span class="nc" id="L534">            throw new LinkageError(m.toString());</span>
        }
<span class="pc bpc" id="L536" title="2 of 6 branches missed.">        assert(isResolved() &amp;&amp; this.clazz != null);</span>
<span class="fc" id="L537">        this.name = m.getName();</span>
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">        if (this.type == null)</span>
<span class="fc" id="L539">            this.type = new Object[] { m.getReturnType(), m.getParameterTypes() };</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">        if (wantSpecial) {</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">            if (isAbstract())</span>
<span class="nc" id="L542">                throw new AbstractMethodError(this.toString());</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">            if (getReferenceKind() == REF_invokeVirtual)</span>
<span class="fc" id="L544">                changeReferenceKind(REF_invokeSpecial, REF_invokeVirtual);</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">            else if (getReferenceKind() == REF_invokeInterface)</span>
                // invokeSpecial on a default method
<span class="nc" id="L547">                changeReferenceKind(REF_invokeSpecial, REF_invokeInterface);</span>
        }
<span class="fc" id="L549">    }</span>
    public MemberName asSpecial() {
<span class="pc bpc" id="L551" title="3 of 5 branches missed.">        switch (getReferenceKind()) {</span>
<span class="fc" id="L552">        case REF_invokeSpecial:     return this;</span>
<span class="nc" id="L553">        case REF_invokeVirtual:     return clone().changeReferenceKind(REF_invokeSpecial, REF_invokeVirtual);</span>
<span class="nc" id="L554">        case REF_invokeInterface:   return clone().changeReferenceKind(REF_invokeSpecial, REF_invokeInterface);</span>
<span class="fc" id="L555">        case REF_newInvokeSpecial:  return clone().changeReferenceKind(REF_invokeSpecial, REF_newInvokeSpecial);</span>
        }
<span class="nc" id="L557">        throw new IllegalArgumentException(this.toString());</span>
    }
    /** If this MN is not REF_newInvokeSpecial, return a clone with that ref. kind.
     *  In that case it must already be REF_invokeSpecial.
     */
    public MemberName asConstructor() {
<span class="pc bpc" id="L563" title="2 of 3 branches missed.">        switch (getReferenceKind()) {</span>
<span class="fc" id="L564">        case REF_invokeSpecial:     return clone().changeReferenceKind(REF_newInvokeSpecial, REF_invokeSpecial);</span>
<span class="nc" id="L565">        case REF_newInvokeSpecial:  return this;</span>
        }
<span class="nc" id="L567">        throw new IllegalArgumentException(this.toString());</span>
    }
    /** If this MN is a REF_invokeSpecial, return a clone with the &quot;normal&quot; kind
     *  REF_invokeVirtual; also switch either to REF_invokeInterface if clazz.isInterface.
     *  The end result is to get a fully virtualized version of the MN.
     *  (Note that resolving in the JVM will sometimes devirtualize, changing
     *  REF_invokeVirtual of a final to REF_invokeSpecial, and REF_invokeInterface
     *  in some corner cases to either of the previous two; this transform
     *  undoes that change under the assumption that it occurred.)
     */
    public MemberName asNormalOriginal() {
<span class="fc bfc" id="L578" title="All 2 branches covered.">        byte normalVirtual = clazz.isInterface() ? REF_invokeInterface : REF_invokeVirtual;</span>
<span class="fc" id="L579">        byte refKind = getReferenceKind();</span>
<span class="fc" id="L580">        byte newRefKind = refKind;</span>
<span class="fc" id="L581">        MemberName result = this;</span>
<span class="fc bfc" id="L582" title="All 2 branches covered.">        switch (refKind) {</span>
        case REF_invokeInterface:
        case REF_invokeVirtual:
        case REF_invokeSpecial:
<span class="fc" id="L586">            newRefKind = normalVirtual;</span>
            break;
        }
<span class="fc bfc" id="L589" title="All 2 branches covered.">        if (newRefKind == refKind)</span>
<span class="fc" id="L590">            return this;</span>
<span class="fc" id="L591">        result = clone().changeReferenceKind(newRefKind, refKind);</span>
<span class="pc bpc" id="L592" title="1 of 4 branches missed.">        assert(this.referenceKindIsConsistentWith(result.getReferenceKind()));</span>
<span class="fc" id="L593">        return result;</span>
    }
    /** Create a name for the given reflected constructor.  The resulting name will be in a resolved state. */
    @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)
<span class="fc" id="L597">    public MemberName(Constructor&lt;?&gt; ctor) {</span>
<span class="fc" id="L598">        ctor.getClass();  // NPE check</span>
        // fill in vmtarget, vmindex while we have ctor in hand:
<span class="fc" id="L600">        MethodHandleNatives.init(this, ctor);</span>
<span class="pc bpc" id="L601" title="2 of 6 branches missed.">        assert(isResolved() &amp;&amp; this.clazz != null);</span>
<span class="fc" id="L602">        this.name = CONSTRUCTOR_NAME;</span>
<span class="pc bpc" id="L603" title="1 of 2 branches missed.">        if (this.type == null)</span>
<span class="fc" id="L604">            this.type = new Object[] { void.class, ctor.getParameterTypes() };</span>
<span class="fc" id="L605">    }</span>
    /** Create a name for the given reflected field.  The resulting name will be in a resolved state.
     */
    public MemberName(Field fld) {
<span class="nc" id="L609">        this(fld, false);</span>
<span class="nc" id="L610">    }</span>
    @SuppressWarnings(&quot;LeakingThisInConstructor&quot;)
<span class="fc" id="L612">    public MemberName(Field fld, boolean makeSetter) {</span>
<span class="fc" id="L613">        fld.getClass();  // NPE check</span>
        // fill in vmtarget, vmindex while we have fld in hand:
<span class="fc" id="L615">        MethodHandleNatives.init(this, fld);</span>
<span class="pc bpc" id="L616" title="2 of 6 branches missed.">        assert(isResolved() &amp;&amp; this.clazz != null);</span>
<span class="fc" id="L617">        this.name = fld.getName();</span>
<span class="fc" id="L618">        this.type = fld.getType();</span>
        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));
<span class="fc" id="L620">        byte refKind = this.getReferenceKind();</span>
<span class="pc bpc" id="L621" title="1 of 6 branches missed.">        assert(refKind == (isStatic() ? REF_getStatic : REF_getField));</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">        if (makeSetter) {</span>
<span class="fc" id="L623">            changeReferenceKind((byte)(refKind + (REF_putStatic - REF_getStatic)), refKind);</span>
        }
<span class="fc" id="L625">    }</span>
    public boolean isGetter() {
<span class="fc" id="L627">        return MethodHandleNatives.refKindIsGetter(getReferenceKind());</span>
    }
    public boolean isSetter() {
<span class="fc" id="L630">        return MethodHandleNatives.refKindIsSetter(getReferenceKind());</span>
    }
    public MemberName asSetter() {
<span class="nc" id="L633">        byte refKind = getReferenceKind();</span>
<span class="nc bnc" id="L634" title="All 4 branches missed.">        assert(MethodHandleNatives.refKindIsGetter(refKind));</span>
        assert((REF_putStatic - REF_getStatic) == (REF_putField - REF_getField));
<span class="nc" id="L636">        byte setterRefKind = (byte)(refKind + (REF_putField - REF_getField));</span>
<span class="nc" id="L637">        return clone().changeReferenceKind(setterRefKind, refKind);</span>
    }
    /** Create a name for the given class.  The resulting name will be in a resolved state. */
<span class="fc" id="L640">    public MemberName(Class&lt;?&gt; type) {</span>
<span class="fc" id="L641">        init(type.getDeclaringClass(), type.getSimpleName(), type,</span>
<span class="fc" id="L642">                flagsMods(IS_TYPE, type.getModifiers(), REF_NONE));</span>
<span class="fc" id="L643">        initResolved(true);</span>
<span class="fc" id="L644">    }</span>

    /**
     * Create a name for a signature-polymorphic invoker.
     * This is a placeholder for a signature-polymorphic instance
     * (of MH.invokeExact, etc.) that the JVM does not reify.
     * See comments on {@link MethodHandleNatives#linkMethod}.
     */
    static MemberName makeMethodHandleInvoke(String name, MethodType type) {
<span class="fc" id="L653">        return makeMethodHandleInvoke(name, type, MH_INVOKE_MODS | SYNTHETIC);</span>
    }
    static MemberName makeMethodHandleInvoke(String name, MethodType type, int mods) {
<span class="fc" id="L656">        MemberName mem = new MemberName(MethodHandle.class, name, type, REF_invokeVirtual);</span>
<span class="fc" id="L657">        mem.flags |= mods;  // it's not resolved, but add these modifiers anyway</span>
<span class="pc bpc" id="L658" title="1 of 4 branches missed.">        assert(mem.isMethodHandleInvoke()) : mem;</span>
<span class="fc" id="L659">        return mem;</span>
    }

    // bare-bones constructor; the JVM will fill it in
<span class="fc" id="L663">    MemberName() { }</span>

    // locally useful cloner
    @Override protected MemberName clone() {
        try {
<span class="fc" id="L668">            return (MemberName) super.clone();</span>
<span class="nc" id="L669">        } catch (CloneNotSupportedException ex) {</span>
<span class="nc" id="L670">            throw newInternalError(ex);</span>
        }
     }

    /** Get the definition of this member name.
     *  This may be in a super-class of the declaring class of this member.
     */
    public MemberName getDefinition() {
<span class="nc bnc" id="L678" title="All 2 branches missed.">        if (!isResolved())  throw new IllegalStateException(&quot;must be resolved: &quot;+this);</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (isType())  return this;</span>
<span class="nc" id="L680">        MemberName res = this.clone();</span>
<span class="nc" id="L681">        res.clazz = null;</span>
<span class="nc" id="L682">        res.type = null;</span>
<span class="nc" id="L683">        res.name = null;</span>
<span class="nc" id="L684">        res.resolution = res;</span>
<span class="nc" id="L685">        res.expandFromVM();</span>
<span class="nc bnc" id="L686" title="All 4 branches missed.">        assert(res.getName().equals(this.getName()));</span>
<span class="nc" id="L687">        return res;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L692">        return Objects.hash(clazz, getReferenceKind(), name, getType());</span>
    }
    @Override
    public boolean equals(Object that) {
<span class="pc bpc" id="L696" title="2 of 4 branches missed.">        return (that instanceof MemberName &amp;&amp; this.equals((MemberName)that));</span>
    }

    /** Decide if two member names have exactly the same symbolic content.
     *  Does not take into account any actual class members, so even if
     *  two member names resolve to the same actual member, they may
     *  be distinct references.
     */
    public boolean equals(MemberName that) {
<span class="fc bfc" id="L705" title="All 2 branches covered.">        if (this == that)  return true;</span>
<span class="fc bfc" id="L706" title="All 2 branches covered.">        if (that == null)  return false;</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">        return this.clazz == that.clazz</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">                &amp;&amp; this.getReferenceKind() == that.getReferenceKind()</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">                &amp;&amp; Objects.equals(this.name, that.name)</span>
<span class="pc bpc" id="L710" title="1 of 2 branches missed.">                &amp;&amp; Objects.equals(this.getType(), that.getType());</span>
    }

    // Construction from symbolic parts, for queries:
    /** Create a field or type name from the given components:
     *  Declaring class, name, type, reference kind.
     *  The declaring class may be supplied as null if this is to be a bare name and type.
     *  The resulting name will in an unresolved state.
     */
<span class="fc" id="L719">    public MemberName(Class&lt;?&gt; defClass, String name, Class&lt;?&gt; type, byte refKind) {</span>
<span class="fc" id="L720">        init(defClass, name, type, flagsMods(IS_FIELD, 0, refKind));</span>
<span class="fc" id="L721">        initResolved(false);</span>
<span class="fc" id="L722">    }</span>
    /** Create a field or type name from the given components:  Declaring class, name, type.
     *  The declaring class may be supplied as null if this is to be a bare name and type.
     *  The modifier flags default to zero.
     *  The resulting name will in an unresolved state.
     */
    public MemberName(Class&lt;?&gt; defClass, String name, Class&lt;?&gt; type, Void unused) {
<span class="nc" id="L729">        this(defClass, name, type, REF_NONE);</span>
<span class="nc" id="L730">        initResolved(false);</span>
<span class="nc" id="L731">    }</span>
    /** Create a method or constructor name from the given components:  Declaring class, name, type, modifiers.
     *  It will be a constructor if and only if the name is {@code &quot;&amp;lt;init&amp;gt;&quot;}.
     *  The declaring class may be supplied as null if this is to be a bare name and type.
     *  The last argument is optional, a boolean which requests REF_invokeSpecial.
     *  The resulting name will in an unresolved state.
     */
<span class="fc" id="L738">    public MemberName(Class&lt;?&gt; defClass, String name, MethodType type, byte refKind) {</span>
<span class="pc bpc" id="L739" title="1 of 4 branches missed.">        int initFlags = (name != null &amp;&amp; name.equals(CONSTRUCTOR_NAME) ? IS_CONSTRUCTOR : IS_METHOD);</span>
<span class="fc" id="L740">        init(defClass, name, type, flagsMods(initFlags, 0, refKind));</span>
<span class="fc" id="L741">        initResolved(false);</span>
<span class="fc" id="L742">    }</span>
    /** Create a method, constructor, or field name from the given components:
     *  Reference kind, declaring class, name, type.
     */
<span class="fc" id="L746">    public MemberName(byte refKind, Class&lt;?&gt; defClass, String name, Object type) {</span>
        int kindFlags;
<span class="pc bpc" id="L748" title="1 of 2 branches missed.">        if (MethodHandleNatives.refKindIsField(refKind)) {</span>
<span class="nc" id="L749">            kindFlags = IS_FIELD;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">            if (!(type instanceof Class))</span>
<span class="nc" id="L751">                throw newIllegalArgumentException(&quot;not a field type&quot;);</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">        } else if (MethodHandleNatives.refKindIsMethod(refKind)) {</span>
<span class="fc" id="L753">            kindFlags = IS_METHOD;</span>
<span class="pc bpc" id="L754" title="1 of 2 branches missed.">            if (!(type instanceof MethodType))</span>
<span class="nc" id="L755">                throw newIllegalArgumentException(&quot;not a method type&quot;);</span>
<span class="pc bpc" id="L756" title="1 of 2 branches missed.">        } else if (refKind == REF_newInvokeSpecial) {</span>
<span class="fc" id="L757">            kindFlags = IS_CONSTRUCTOR;</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">            if (!(type instanceof MethodType) ||</span>
<span class="pc bpc" id="L759" title="1 of 2 branches missed.">                !CONSTRUCTOR_NAME.equals(name))</span>
<span class="nc" id="L760">                throw newIllegalArgumentException(&quot;not a constructor type or name&quot;);</span>
        } else {
<span class="nc" id="L762">            throw newIllegalArgumentException(&quot;bad reference kind &quot;+refKind);</span>
        }
<span class="fc" id="L764">        init(defClass, name, type, flagsMods(kindFlags, 0, refKind));</span>
<span class="fc" id="L765">        initResolved(false);</span>
<span class="fc" id="L766">    }</span>
    /** Query whether this member name is resolved to a non-static, non-final method.
     */
    public boolean hasReceiverTypeDispatch() {
<span class="nc" id="L770">        return MethodHandleNatives.refKindDoesDispatch(getReferenceKind());</span>
    }

    /** Query whether this member name is resolved.
     *  A resolved member name is one for which the JVM has found
     *  a method, constructor, field, or type binding corresponding exactly to the name.
     *  (Document?)
     */
    public boolean isResolved() {
<span class="fc bfc" id="L779" title="All 2 branches covered.">        return resolution == null;</span>
    }

    private void initResolved(boolean isResolved) {
<span class="pc bpc" id="L783" title="1 of 4 branches missed.">        assert(this.resolution == null);  // not initialized yet!</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">        if (!isResolved)</span>
<span class="fc" id="L785">            this.resolution = this;</span>
<span class="pc bpc" id="L786" title="1 of 4 branches missed.">        assert(isResolved() == isResolved);</span>
<span class="fc" id="L787">    }</span>

    void checkForTypeAlias() {
<span class="fc bfc" id="L790" title="All 2 branches covered.">        if (isInvocable()) {</span>
            MethodType type;
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">            if (this.type instanceof MethodType)</span>
<span class="fc" id="L793">                type = (MethodType) this.type;</span>
            else
<span class="nc" id="L795">                this.type = type = getMethodType();</span>
<span class="fc bfc" id="L796" title="All 2 branches covered.">            if (type.erase() == type)  return;</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">            if (VerifyAccess.isTypeVisible(type, clazz))  return;</span>
<span class="nc" id="L798">            throw new LinkageError(&quot;bad method type alias: &quot;+type+&quot; not visible from &quot;+clazz);</span>
        } else {
            Class&lt;?&gt; type;
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">            if (this.type instanceof Class&lt;?&gt;)</span>
<span class="fc" id="L802">                type = (Class&lt;?&gt;) this.type;</span>
            else
<span class="nc" id="L804">                this.type = type = getFieldType();</span>
<span class="pc bpc" id="L805" title="1 of 2 branches missed.">            if (VerifyAccess.isTypeVisible(type, clazz))  return;</span>
<span class="nc" id="L806">            throw new LinkageError(&quot;bad field type alias: &quot;+type+&quot; not visible from &quot;+clazz);</span>
        }
    }


    /** Produce a string form of this member name.
     *  For types, it is simply the type's own string (as reported by {@code toString}).
     *  For fields, it is {@code &quot;DeclaringClass.name/type&quot;}.
     *  For methods and constructors, it is {@code &quot;DeclaringClass.name(ptype...)rtype&quot;}.
     *  If the declaring class is null, the prefix {@code &quot;DeclaringClass.&quot;} is omitted.
     *  If the member is unresolved, a prefix {@code &quot;*.&quot;} is prepended.
     */
    @SuppressWarnings(&quot;LocalVariableHidesMemberVariable&quot;)
    @Override
    public String toString() {
<span class="fc bfc" id="L821" title="All 2 branches covered.">        if (isType())</span>
<span class="fc" id="L822">            return type.toString();  // class java.lang.String</span>
        // else it is a field, method, or constructor
<span class="fc" id="L824">        StringBuilder buf = new StringBuilder();</span>
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">        if (getDeclaringClass() != null) {</span>
<span class="fc" id="L826">            buf.append(getName(clazz));</span>
<span class="fc" id="L827">            buf.append('.');</span>
        }
<span class="fc" id="L829">        String name = getName();</span>
<span class="pc bpc" id="L830" title="1 of 2 branches missed.">        buf.append(name == null ? &quot;*&quot; : name);</span>
<span class="fc" id="L831">        Object type = getType();</span>
<span class="fc bfc" id="L832" title="All 2 branches covered.">        if (!isInvocable()) {</span>
<span class="fc" id="L833">            buf.append('/');</span>
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">            buf.append(type == null ? &quot;*&quot; : getName(type));</span>
        } else {
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">            buf.append(type == null ? &quot;(*)*&quot; : getName(type));</span>
        }
<span class="fc" id="L838">        byte refKind = getReferenceKind();</span>
<span class="pc bpc" id="L839" title="1 of 2 branches missed.">        if (refKind != REF_NONE) {</span>
<span class="fc" id="L840">            buf.append('/');</span>
<span class="fc" id="L841">            buf.append(MethodHandleNatives.refKindName(refKind));</span>
        }
        //buf.append(&quot;#&quot;).append(System.identityHashCode(this));
<span class="fc" id="L844">        return buf.toString();</span>
    }
    private static String getName(Object obj) {
<span class="fc bfc" id="L847" title="All 2 branches covered.">        if (obj instanceof Class&lt;?&gt;)</span>
<span class="fc" id="L848">            return ((Class&lt;?&gt;)obj).getName();</span>
<span class="fc" id="L849">        return String.valueOf(obj);</span>
    }

    public IllegalAccessException makeAccessException(String message, Object from) {
<span class="fc" id="L853">        message = message + &quot;: &quot;+ toString();</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">        if (from != null)  message += &quot;, from &quot; + from;</span>
<span class="fc" id="L855">        return new IllegalAccessException(message);</span>
    }
    private String message() {
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">        if (isResolved())</span>
<span class="nc" id="L859">            return &quot;no access&quot;;</span>
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">        else if (isConstructor())</span>
<span class="nc" id="L861">            return &quot;no such constructor&quot;;</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">        else if (isMethod())</span>
<span class="fc" id="L863">            return &quot;no such method&quot;;</span>
        else
<span class="fc" id="L865">            return &quot;no such field&quot;;</span>
    }
    public ReflectiveOperationException makeAccessException() {
<span class="fc" id="L868">        String message = message() + &quot;: &quot;+ toString();</span>
        ReflectiveOperationException ex;
<span class="pc bpc" id="L870" title="1 of 6 branches missed.">        if (isResolved() || !(resolution instanceof NoSuchMethodError ||</span>
                              resolution instanceof NoSuchFieldError))
<span class="fc" id="L872">            ex = new IllegalAccessException(message);</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">        else if (isConstructor())</span>
<span class="nc" id="L874">            ex = new NoSuchMethodException(message);</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">        else if (isMethod())</span>
<span class="fc" id="L876">            ex = new NoSuchMethodException(message);</span>
        else
<span class="fc" id="L878">            ex = new NoSuchFieldException(message);</span>
<span class="pc bpc" id="L879" title="1 of 2 branches missed.">        if (resolution instanceof Throwable)</span>
<span class="fc" id="L880">            ex.initCause((Throwable) resolution);</span>
<span class="fc" id="L881">        return ex;</span>
    }

    /** Actually making a query requires an access check. */
    /*non-public*/ static Factory getFactory() {
<span class="fc" id="L886">        return Factory.INSTANCE;</span>
    }
    /** A factory type for resolving member names with the help of the VM.
     *  TBD: Define access-safe public constructors for this factory.
     */
<span class="fc bfc" id="L891" title="All 2 branches covered.">    /*non-public*/ static class Factory {</span>
<span class="fc" id="L892">        private Factory() { } // singleton pattern</span>
<span class="fc" id="L893">        static Factory INSTANCE = new Factory();</span>

<span class="fc" id="L895">        private static int ALLOWED_FLAGS = ALL_KINDS;</span>

        /// Queries
        List&lt;MemberName&gt; getMembers(Class&lt;?&gt; defc,
                String matchName, Object matchType,
                int matchFlags, Class&lt;?&gt; lookupClass) {
<span class="fc" id="L901">            matchFlags &amp;= ALLOWED_FLAGS;</span>
<span class="fc" id="L902">            String matchSig = null;</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">            if (matchType != null) {</span>
<span class="nc" id="L904">                matchSig = BytecodeDescriptor.unparse(matchType);</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">                if (matchSig.startsWith(&quot;(&quot;))</span>
<span class="nc" id="L906">                    matchFlags &amp;= ~(ALL_KINDS &amp; ~IS_INVOCABLE);</span>
                else
<span class="nc" id="L908">                    matchFlags &amp;= ~(ALL_KINDS &amp; ~IS_FIELD);</span>
            }
            final int BUF_MAX = 0x2000;
<span class="pc bpc" id="L911" title="3 of 4 branches missed.">            int len1 = matchName == null ? 10 : matchType == null ? 4 : 1;</span>
<span class="fc" id="L912">            MemberName[] buf = newMemberBuffer(len1);</span>
<span class="fc" id="L913">            int totalCount = 0;</span>
<span class="fc" id="L914">            ArrayList&lt;MemberName[]&gt; bufs = null;</span>
<span class="fc" id="L915">            int bufCount = 0;</span>
            for (;;) {
<span class="fc" id="L917">                bufCount = MethodHandleNatives.getMembers(defc,</span>
                        matchName, matchSig, matchFlags,
                        lookupClass,
                        totalCount, buf);
<span class="fc bfc" id="L921" title="All 2 branches covered.">                if (bufCount &lt;= buf.length) {</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">                    if (bufCount &lt; 0)  bufCount = 0;</span>
<span class="fc" id="L923">                    totalCount += bufCount;</span>
<span class="fc" id="L924">                    break;</span>
                }
                // JVM returned to us with an intentional overflow!
<span class="fc" id="L927">                totalCount += buf.length;</span>
<span class="fc" id="L928">                int excess = bufCount - buf.length;</span>
<span class="pc bpc" id="L929" title="1 of 2 branches missed.">                if (bufs == null)  bufs = new ArrayList&lt;&gt;(1);</span>
<span class="fc" id="L930">                bufs.add(buf);</span>
<span class="fc" id="L931">                int len2 = buf.length;</span>
<span class="fc" id="L932">                len2 = Math.max(len2, excess);</span>
<span class="fc" id="L933">                len2 = Math.max(len2, totalCount / 4);</span>
<span class="fc" id="L934">                buf = newMemberBuffer(Math.min(BUF_MAX, len2));</span>
<span class="fc" id="L935">            }</span>
<span class="fc" id="L936">            ArrayList&lt;MemberName&gt; result = new ArrayList&lt;&gt;(totalCount);</span>
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">            if (bufs != null) {</span>
<span class="fc bfc" id="L938" title="All 2 branches covered.">                for (MemberName[] buf0 : bufs) {</span>
<span class="fc" id="L939">                    Collections.addAll(result, buf0);</span>
<span class="fc" id="L940">                }</span>
            }
<span class="fc" id="L942">            result.addAll(Arrays.asList(buf).subList(0, bufCount));</span>
            // Signature matching is not the same as type matching, since
            // one signature might correspond to several types.
            // So if matchType is a Class or MethodType, refilter the results.
<span class="pc bpc" id="L946" title="3 of 4 branches missed.">            if (matchType != null &amp;&amp; matchType != matchSig) {</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">                for (Iterator&lt;MemberName&gt; it = result.iterator(); it.hasNext();) {</span>
<span class="nc" id="L948">                    MemberName m = it.next();</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                    if (!matchType.equals(m.getType()))</span>
<span class="nc" id="L950">                        it.remove();</span>
<span class="nc" id="L951">                }</span>
            }
<span class="fc" id="L953">            return result;</span>
        }
        /** Produce a resolved version of the given member.
         *  Super types are searched (for inherited members) if {@code searchSupers} is true.
         *  Access checking is performed on behalf of the given {@code lookupClass}.
         *  If lookup fails or access is not permitted, null is returned.
         *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
         */
        private MemberName resolve(byte refKind, MemberName ref, Class&lt;?&gt; lookupClass) {
<span class="fc" id="L962">            MemberName m = ref.clone();  // JVM will side-effect the ref</span>
<span class="pc bpc" id="L963" title="1 of 4 branches missed.">            assert(refKind == m.getReferenceKind());</span>
            try {
<span class="fc" id="L965">                m = MethodHandleNatives.resolve(m, lookupClass);</span>
<span class="fc" id="L966">                m.checkForTypeAlias();</span>
<span class="fc" id="L967">                m.resolution = null;</span>
<span class="fc" id="L968">            } catch (LinkageError ex) {</span>
                // JVM reports that the &quot;bytecode behavior&quot; would get an error
<span class="pc bpc" id="L970" title="1 of 4 branches missed.">                assert(!m.isResolved());</span>
<span class="fc" id="L971">                m.resolution = ex;</span>
<span class="fc" id="L972">                return m;</span>
<span class="fc" id="L973">            }</span>
<span class="pc bpc" id="L974" title="1 of 4 branches missed.">            assert(m.referenceKindIsConsistent());</span>
<span class="fc" id="L975">            m.initResolved(true);</span>
<span class="pc bpc" id="L976" title="1 of 4 branches missed.">            assert(m.vminfoIsConsistent());</span>
<span class="fc" id="L977">            return m;</span>
        }
        /** Produce a resolved version of the given member.
         *  Super types are searched (for inherited members) if {@code searchSupers} is true.
         *  Access checking is performed on behalf of the given {@code lookupClass}.
         *  If lookup fails or access is not permitted, a {@linkplain ReflectiveOperationException} is thrown.
         *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
         */
        public
        &lt;NoSuchMemberException extends ReflectiveOperationException&gt;
        MemberName resolveOrFail(byte refKind, MemberName m, Class&lt;?&gt; lookupClass,
                                 Class&lt;NoSuchMemberException&gt; nsmClass)
                throws IllegalAccessException, NoSuchMemberException {
<span class="fc" id="L990">            MemberName result = resolve(refKind, m, lookupClass);</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">            if (result.isResolved())</span>
<span class="fc" id="L992">                return result;</span>
<span class="fc" id="L993">            ReflectiveOperationException ex = result.makeAccessException();</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">            if (ex instanceof IllegalAccessException)  throw (IllegalAccessException) ex;</span>
<span class="fc" id="L995">            throw nsmClass.cast(ex);</span>
        }
        /** Produce a resolved version of the given member.
         *  Super types are searched (for inherited members) if {@code searchSupers} is true.
         *  Access checking is performed on behalf of the given {@code lookupClass}.
         *  If lookup fails or access is not permitted, return null.
         *  Otherwise a fresh copy of the given member is returned, with modifier bits filled in.
         */
        public
        MemberName resolveOrNull(byte refKind, MemberName m, Class&lt;?&gt; lookupClass) {
<span class="fc" id="L1005">            MemberName result = resolve(refKind, m, lookupClass);</span>
<span class="fc bfc" id="L1006" title="All 2 branches covered.">            if (result.isResolved())</span>
<span class="fc" id="L1007">                return result;</span>
<span class="fc" id="L1008">            return null;</span>
        }
        /** Return a list of all methods defined by the given class.
         *  Super types are searched (for inherited members) if {@code searchSupers} is true.
         *  Access checking is performed on behalf of the given {@code lookupClass}.
         *  Inaccessible members are not added to the last.
         */
        public List&lt;MemberName&gt; getMethods(Class&lt;?&gt; defc, boolean searchSupers,
                Class&lt;?&gt; lookupClass) {
<span class="nc" id="L1017">            return getMethods(defc, searchSupers, null, null, lookupClass);</span>
        }
        /** Return a list of matching methods defined by the given class.
         *  Super types are searched (for inherited members) if {@code searchSupers} is true.
         *  Returned methods will match the name (if not null) and the type (if not null).
         *  Access checking is performed on behalf of the given {@code lookupClass}.
         *  Inaccessible members are not added to the last.
         */
        public List&lt;MemberName&gt; getMethods(Class&lt;?&gt; defc, boolean searchSupers,
                String name, MethodType type, Class&lt;?&gt; lookupClass) {
<span class="pc bpc" id="L1027" title="1 of 2 branches missed.">            int matchFlags = IS_METHOD | (searchSupers ? SEARCH_ALL_SUPERS : 0);</span>
<span class="fc" id="L1028">            return getMembers(defc, name, type, matchFlags, lookupClass);</span>
        }
        /** Return a list of all constructors defined by the given class.
         *  Access checking is performed on behalf of the given {@code lookupClass}.
         *  Inaccessible members are not added to the last.
         */
        public List&lt;MemberName&gt; getConstructors(Class&lt;?&gt; defc, Class&lt;?&gt; lookupClass) {
<span class="nc" id="L1035">            return getMembers(defc, null, null, IS_CONSTRUCTOR, lookupClass);</span>
        }
        /** Return a list of all fields defined by the given class.
         *  Super types are searched (for inherited members) if {@code searchSupers} is true.
         *  Access checking is performed on behalf of the given {@code lookupClass}.
         *  Inaccessible members are not added to the last.
         */
        public List&lt;MemberName&gt; getFields(Class&lt;?&gt; defc, boolean searchSupers,
                Class&lt;?&gt; lookupClass) {
<span class="nc" id="L1044">            return getFields(defc, searchSupers, null, null, lookupClass);</span>
        }
        /** Return a list of all fields defined by the given class.
         *  Super types are searched (for inherited members) if {@code searchSupers} is true.
         *  Returned fields will match the name (if not null) and the type (if not null).
         *  Access checking is performed on behalf of the given {@code lookupClass}.
         *  Inaccessible members are not added to the last.
         */
        public List&lt;MemberName&gt; getFields(Class&lt;?&gt; defc, boolean searchSupers,
                String name, Class&lt;?&gt; type, Class&lt;?&gt; lookupClass) {
<span class="nc bnc" id="L1054" title="All 2 branches missed.">            int matchFlags = IS_FIELD | (searchSupers ? SEARCH_ALL_SUPERS : 0);</span>
<span class="nc" id="L1055">            return getMembers(defc, name, type, matchFlags, lookupClass);</span>
        }
        /** Return a list of all nested types defined by the given class.
         *  Super types are searched (for inherited members) if {@code searchSupers} is true.
         *  Access checking is performed on behalf of the given {@code lookupClass}.
         *  Inaccessible members are not added to the last.
         */
        public List&lt;MemberName&gt; getNestedTypes(Class&lt;?&gt; defc, boolean searchSupers,
                Class&lt;?&gt; lookupClass) {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">            int matchFlags = IS_TYPE | (searchSupers ? SEARCH_ALL_SUPERS : 0);</span>
<span class="nc" id="L1065">            return getMembers(defc, null, null, matchFlags, lookupClass);</span>
        }
        private static MemberName[] newMemberBuffer(int length) {
<span class="fc" id="L1068">            MemberName[] buf = new MemberName[length];</span>
            // fill the buffer with dummy structs for the JVM to fill in
<span class="fc bfc" id="L1070" title="All 2 branches covered.">            for (int i = 0; i &lt; length; i++)</span>
<span class="fc" id="L1071">                buf[i] = new MemberName();</span>
<span class="fc" id="L1072">            return buf;</span>
        }
    }

//    static {
//        System.out.println(&quot;Hello world!  My methods are:&quot;);
//        System.out.println(Factory.INSTANCE.getMethods(MemberName.class, true, null));
//    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>