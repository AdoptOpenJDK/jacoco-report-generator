<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MethodHandleImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">MethodHandleImpl.java</span></div><h1>MethodHandleImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.invoke;

import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import sun.invoke.empty.Empty;
import sun.invoke.util.ValueConversions;
import sun.invoke.util.VerifyType;
import sun.invoke.util.Wrapper;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;
import static java.lang.invoke.LambdaForm.*;
import static java.lang.invoke.MethodHandleStatics.*;
import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;

/**
 * Trusted implementation code for MethodHandle.
 * @author jrose
 */
<span class="pc bfc" id="L47" title="All 2 branches covered.">/*non-public*/ abstract class MethodHandleImpl {</span>
    /// Factory methods to create method handles:

    static void initStatics() {
        // Trigger selected static initializations.
<span class="fc" id="L52">        MemberName.Factory.INSTANCE.getClass();</span>
<span class="fc" id="L53">    }</span>

    static MethodHandle makeArrayElementAccessor(Class&lt;?&gt; arrayClass, boolean isSetter) {
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">        if (!arrayClass.isArray())</span>
<span class="nc" id="L57">            throw newIllegalArgumentException(&quot;not an array: &quot;+arrayClass);</span>
<span class="fc" id="L58">        MethodHandle accessor = ArrayAccessor.getAccessor(arrayClass, isSetter);</span>
<span class="fc" id="L59">        MethodType srcType = accessor.type().erase();</span>
<span class="fc" id="L60">        MethodType lambdaType = srcType.invokerType();</span>
<span class="fc" id="L61">        Name[] names = arguments(1, lambdaType);</span>
<span class="fc" id="L62">        Name[] args  = Arrays.copyOfRange(names, 1, 1 + srcType.parameterCount());</span>
<span class="fc" id="L63">        names[names.length - 1] = new Name(accessor.asType(srcType), (Object[]) args);</span>
<span class="fc" id="L64">        LambdaForm form = new LambdaForm(&quot;getElement&quot;, lambdaType.parameterCount(), names);</span>
<span class="fc" id="L65">        MethodHandle mh = SimpleMethodHandle.make(srcType, form);</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">        if (ArrayAccessor.needCast(arrayClass)) {</span>
<span class="fc" id="L67">            mh = mh.bindTo(arrayClass);</span>
        }
<span class="fc" id="L69">        mh = mh.asType(ArrayAccessor.correctType(arrayClass, isSetter));</span>
<span class="fc" id="L70">        return mh;</span>
    }

<span class="nc" id="L73">    static final class ArrayAccessor {</span>
        /// Support for array element access
<span class="fc" id="L75">        static final HashMap&lt;Class&lt;?&gt;, MethodHandle&gt; GETTER_CACHE = new HashMap&lt;&gt;();  // TODO use it</span>
<span class="fc" id="L76">        static final HashMap&lt;Class&lt;?&gt;, MethodHandle&gt; SETTER_CACHE = new HashMap&lt;&gt;();  // TODO use it</span>

<span class="fc" id="L78">        static int     getElementI(int[]     a, int i)            { return              a[i]; }</span>
<span class="fc" id="L79">        static long    getElementJ(long[]    a, int i)            { return              a[i]; }</span>
<span class="fc" id="L80">        static float   getElementF(float[]   a, int i)            { return              a[i]; }</span>
<span class="fc" id="L81">        static double  getElementD(double[]  a, int i)            { return              a[i]; }</span>
<span class="fc" id="L82">        static boolean getElementZ(boolean[] a, int i)            { return              a[i]; }</span>
<span class="fc" id="L83">        static byte    getElementB(byte[]    a, int i)            { return              a[i]; }</span>
<span class="fc" id="L84">        static short   getElementS(short[]   a, int i)            { return              a[i]; }</span>
<span class="fc" id="L85">        static char    getElementC(char[]    a, int i)            { return              a[i]; }</span>
<span class="fc" id="L86">        static Object  getElementL(Object[]  a, int i)            { return              a[i]; }</span>

<span class="fc" id="L88">        static void    setElementI(int[]     a, int i, int     x) {              a[i] = x; }</span>
<span class="fc" id="L89">        static void    setElementJ(long[]    a, int i, long    x) {              a[i] = x; }</span>
<span class="fc" id="L90">        static void    setElementF(float[]   a, int i, float   x) {              a[i] = x; }</span>
<span class="fc" id="L91">        static void    setElementD(double[]  a, int i, double  x) {              a[i] = x; }</span>
<span class="fc" id="L92">        static void    setElementZ(boolean[] a, int i, boolean x) {              a[i] = x; }</span>
<span class="fc" id="L93">        static void    setElementB(byte[]    a, int i, byte    x) {              a[i] = x; }</span>
<span class="fc" id="L94">        static void    setElementS(short[]   a, int i, short   x) {              a[i] = x; }</span>
<span class="fc" id="L95">        static void    setElementC(char[]    a, int i, char    x) {              a[i] = x; }</span>
<span class="fc" id="L96">        static void    setElementL(Object[]  a, int i, Object  x) {              a[i] = x; }</span>

<span class="fc" id="L98">        static Object  getElementL(Class&lt;?&gt; arrayClass, Object[] a, int i)           { arrayClass.cast(a); return a[i]; }</span>
<span class="fc" id="L99">        static void    setElementL(Class&lt;?&gt; arrayClass, Object[] a, int i, Object x) { arrayClass.cast(a); a[i] = x; }</span>

        // Weakly typed wrappers of Object[] accessors:
<span class="nc" id="L102">        static Object  getElementL(Object    a, int i)            { return getElementL((Object[])a, i); }</span>
<span class="nc" id="L103">        static void    setElementL(Object    a, int i, Object  x) {        setElementL((Object[]) a, i, x); }</span>
<span class="nc" id="L104">        static Object  getElementL(Object   arrayClass, Object a, int i)             { return getElementL((Class&lt;?&gt;) arrayClass, (Object[])a, i); }</span>
<span class="nc" id="L105">        static void    setElementL(Object   arrayClass, Object a, int i, Object x)   {        setElementL((Class&lt;?&gt;) arrayClass, (Object[])a, i, x); }</span>

        static boolean needCast(Class&lt;?&gt; arrayClass) {
<span class="fc" id="L108">            Class&lt;?&gt; elemClass = arrayClass.getComponentType();</span>
<span class="fc bfc" id="L109" title="All 4 branches covered.">            return !elemClass.isPrimitive() &amp;&amp; elemClass != Object.class;</span>
        }
        static String name(Class&lt;?&gt; arrayClass, boolean isSetter) {
<span class="fc" id="L112">            Class&lt;?&gt; elemClass = arrayClass.getComponentType();</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            if (elemClass == null)  throw new IllegalArgumentException();</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            return (!isSetter ? &quot;getElement&quot; : &quot;setElement&quot;) + Wrapper.basicTypeChar(elemClass);</span>
        }
        static final boolean USE_WEAKLY_TYPED_ARRAY_ACCESSORS = false;  // FIXME: decide
        static MethodType type(Class&lt;?&gt; arrayClass, boolean isSetter) {
<span class="fc" id="L118">            Class&lt;?&gt; elemClass = arrayClass.getComponentType();</span>
<span class="fc" id="L119">            Class&lt;?&gt; arrayArgClass = arrayClass;</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">            if (!elemClass.isPrimitive()) {</span>
<span class="fc" id="L121">                arrayArgClass = Object[].class;</span>
                if (USE_WEAKLY_TYPED_ARRAY_ACCESSORS)
                    arrayArgClass = Object.class;
            }
<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (!needCast(arrayClass)) {</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">                return !isSetter ?</span>
<span class="fc" id="L127">                    MethodType.methodType(elemClass,  arrayArgClass, int.class) :</span>
<span class="fc" id="L128">                    MethodType.methodType(void.class, arrayArgClass, int.class, elemClass);</span>
            } else {
<span class="fc" id="L130">                Class&lt;?&gt; classArgClass = Class.class;</span>
                if (USE_WEAKLY_TYPED_ARRAY_ACCESSORS)
                    classArgClass = Object.class;
<span class="fc bfc" id="L133" title="All 2 branches covered.">                return !isSetter ?</span>
<span class="fc" id="L134">                    MethodType.methodType(Object.class, classArgClass, arrayArgClass, int.class) :</span>
<span class="fc" id="L135">                    MethodType.methodType(void.class,   classArgClass, arrayArgClass, int.class, Object.class);</span>
            }
        }
        static MethodType correctType(Class&lt;?&gt; arrayClass, boolean isSetter) {
<span class="fc" id="L139">            Class&lt;?&gt; elemClass = arrayClass.getComponentType();</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            return !isSetter ?</span>
<span class="fc" id="L141">                    MethodType.methodType(elemClass,  arrayClass, int.class) :</span>
<span class="fc" id="L142">                    MethodType.methodType(void.class, arrayClass, int.class, elemClass);</span>
        }
        static MethodHandle getAccessor(Class&lt;?&gt; arrayClass, boolean isSetter) {
<span class="fc" id="L145">            String     name = name(arrayClass, isSetter);</span>
<span class="fc" id="L146">            MethodType type = type(arrayClass, isSetter);</span>
            try {
<span class="fc" id="L148">                return IMPL_LOOKUP.findStatic(ArrayAccessor.class, name, type);</span>
<span class="nc" id="L149">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L150">                throw uncaughtException(ex);</span>
            }
        }
    }

    /**
     * Create a JVM-level adapter method handle to conform the given method
     * handle to the similar newType, using only pairwise argument conversions.
     * For each argument, convert incoming argument to the exact type needed.
     * The argument conversions allowed are casting, boxing and unboxing,
     * integral widening or narrowing, and floating point widening or narrowing.
     * @param srcType required call type
     * @param target original method handle
     * @param level which strength of conversion is allowed
     * @return an adapter to the original handle with the desired new type,
     *          or the original target if the types are already identical
     *          or null if the adaptation cannot be made
     */
    static MethodHandle makePairwiseConvert(MethodHandle target, MethodType srcType, int level) {
<span class="pc bpc" id="L169" title="2 of 6 branches missed.">        assert(level &gt;= 0 &amp;&amp; level &lt;= 2);</span>
<span class="fc" id="L170">        MethodType dstType = target.type();</span>
<span class="pc bpc" id="L171" title="1 of 4 branches missed.">        assert(dstType.parameterCount() == target.type().parameterCount());</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (srcType == dstType)</span>
<span class="fc" id="L173">            return target;</span>

        // Calculate extra arguments (temporaries) required in the names array.
        // FIXME: Use an ArrayList&lt;Name&gt;.  Some arguments require more than one conversion step.
<span class="fc" id="L177">        final int INARG_COUNT = srcType.parameterCount();</span>
<span class="fc" id="L178">        int conversions = 0;</span>
<span class="fc" id="L179">        boolean[] needConv = new boolean[1+INARG_COUNT];</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        for (int i = 0; i &lt;= INARG_COUNT; i++) {</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">            Class&lt;?&gt; src = (i == INARG_COUNT) ? dstType.returnType() : srcType.parameterType(i);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            Class&lt;?&gt; dst = (i == INARG_COUNT) ? srcType.returnType() : dstType.parameterType(i);</span>
<span class="fc bfc" id="L183" title="All 4 branches covered.">            if (!VerifyType.isNullConversion(src, dst) ||</span>
<span class="fc bfc" id="L184" title="All 4 branches covered.">                level &lt;= 1 &amp;&amp; dst.isInterface() &amp;&amp; !dst.isAssignableFrom(src)) {</span>
<span class="fc" id="L185">                needConv[i] = true;</span>
<span class="fc" id="L186">                conversions++;</span>
            }
        }
<span class="fc" id="L189">        boolean retConv = needConv[INARG_COUNT];</span>

        final int IN_MH         = 0;
        final int INARG_BASE    = 1;
<span class="fc" id="L193">        final int INARG_LIMIT   = INARG_BASE + INARG_COUNT;</span>
<span class="fc" id="L194">        final int NAME_LIMIT    = INARG_LIMIT + conversions + 1;</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">        final int RETURN_CONV   = (!retConv ? -1         : NAME_LIMIT - 1);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        final int OUT_CALL      = (!retConv ? NAME_LIMIT : RETURN_CONV) - 1;</span>

        // Now build a LambdaForm.
<span class="fc" id="L199">        MethodType lambdaType = srcType.basicType().invokerType();</span>
<span class="fc" id="L200">        Name[] names = arguments(NAME_LIMIT - INARG_LIMIT, lambdaType);</span>

        // Collect the arguments to the outgoing call, maybe with conversions:
        final int OUTARG_BASE = 0;  // target MH is Name.function, name Name.arguments[0]
<span class="fc" id="L204">        Object[] outArgs = new Object[OUTARG_BASE + INARG_COUNT];</span>

<span class="fc" id="L206">        int nameCursor = INARG_LIMIT;</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        for (int i = 0; i &lt; INARG_COUNT; i++) {</span>
<span class="fc" id="L208">            Class&lt;?&gt; src = srcType.parameterType(i);</span>
<span class="fc" id="L209">            Class&lt;?&gt; dst = dstType.parameterType(i);</span>

<span class="fc bfc" id="L211" title="All 2 branches covered.">            if (!needConv[i]) {</span>
                // do nothing: difference is trivial
<span class="fc" id="L213">                outArgs[OUTARG_BASE + i] = names[INARG_BASE + i];</span>
<span class="fc" id="L214">                continue;</span>
            }

            // Tricky case analysis follows.
<span class="fc" id="L218">            MethodHandle fn = null;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (src.isPrimitive()) {</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                if (dst.isPrimitive()) {</span>
<span class="fc" id="L221">                    fn = ValueConversions.convertPrimitive(src, dst);</span>
                } else {
<span class="fc" id="L223">                    Wrapper w = Wrapper.forPrimitiveType(src);</span>
<span class="fc" id="L224">                    MethodHandle boxMethod = ValueConversions.box(w);</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">                    if (dst == w.wrapperType())</span>
<span class="nc" id="L226">                        fn = boxMethod;</span>
                    else
<span class="fc" id="L228">                        fn = boxMethod.asType(MethodType.methodType(dst, src));</span>
<span class="fc" id="L229">                }</span>
            } else {
<span class="fc bfc" id="L231" title="All 2 branches covered.">                if (dst.isPrimitive()) {</span>
                    // Caller has boxed a primitive.  Unbox it for the target.
<span class="fc" id="L233">                    Wrapper w = Wrapper.forPrimitiveType(dst);</span>
<span class="pc bpc" id="L234" title="1 of 4 branches missed.">                    if (level == 0 || VerifyType.isNullConversion(src, w.wrapperType())) {</span>
<span class="fc" id="L235">                        fn = ValueConversions.unbox(dst);</span>
<span class="pc bpc" id="L236" title="1 of 4 branches missed.">                    } else if (src == Object.class || !Wrapper.isWrapperType(src)) {</span>
                        // Examples:  Object-&gt;int, Number-&gt;int, Comparable-&gt;int; Byte-&gt;int, Character-&gt;int
                        // must include additional conversions
                        // src must be examined at runtime, to detect Byte, Character, etc.
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">                        MethodHandle unboxMethod = (level == 1</span>
<span class="pc" id="L241">                                                    ? ValueConversions.unbox(dst)</span>
<span class="pc" id="L242">                                                    : ValueConversions.unboxCast(dst));</span>
<span class="fc" id="L243">                        fn = unboxMethod;</span>
<span class="fc" id="L244">                    } else {</span>
                        // Example: Byte-&gt;int
                        // Do this by reformulating the problem to Byte-&gt;byte.
<span class="fc" id="L247">                        Class&lt;?&gt; srcPrim = Wrapper.forWrapperType(src).primitiveType();</span>
<span class="fc" id="L248">                        MethodHandle unbox = ValueConversions.unbox(srcPrim);</span>
                        // Compose the two conversions.  FIXME:  should make two Names for this job
<span class="fc" id="L250">                        fn = unbox.asType(MethodType.methodType(dst, src));</span>
                    }
<span class="fc" id="L252">                } else {</span>
                    // Simple reference conversion.
                    // Note:  Do not check for a class hierarchy relation
                    // between src and dst.  In all cases a 'null' argument
                    // will pass the cast conversion.
<span class="fc" id="L257">                    fn = ValueConversions.cast(dst);</span>
                }
            }
<span class="fc" id="L260">            Name conv = new Name(fn, names[INARG_BASE + i]);</span>
<span class="pc bpc" id="L261" title="1 of 4 branches missed.">            assert(names[nameCursor] == null);</span>
<span class="fc" id="L262">            names[nameCursor++] = conv;</span>
<span class="pc bpc" id="L263" title="1 of 4 branches missed.">            assert(outArgs[OUTARG_BASE + i] == null);</span>
<span class="fc" id="L264">            outArgs[OUTARG_BASE + i] = conv;</span>
        }

        // Build argument array for the call.
<span class="pc bpc" id="L268" title="1 of 4 branches missed.">        assert(nameCursor == OUT_CALL);</span>
<span class="fc" id="L269">        names[OUT_CALL] = new Name(target, outArgs);</span>

<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (RETURN_CONV &lt; 0) {</span>
<span class="pc bpc" id="L272" title="1 of 4 branches missed.">            assert(OUT_CALL == names.length-1);</span>
        } else {
<span class="fc" id="L274">            Class&lt;?&gt; needReturn = srcType.returnType();</span>
<span class="fc" id="L275">            Class&lt;?&gt; haveReturn = dstType.returnType();</span>
            MethodHandle fn;
<span class="fc" id="L277">            Object[] arg = { names[OUT_CALL] };</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">            if (haveReturn == void.class) {</span>
                // synthesize a zero value for the given void
<span class="fc" id="L280">                Object zero = Wrapper.forBasicType(needReturn).zero();</span>
<span class="fc" id="L281">                fn = MethodHandles.constant(needReturn, zero);</span>
<span class="fc" id="L282">                arg = new Object[0];  // don't pass names[OUT_CALL] to conversion</span>
<span class="fc" id="L283">            } else {</span>
<span class="fc" id="L284">                MethodHandle identity = MethodHandles.identity(needReturn);</span>
<span class="fc" id="L285">                MethodType needConversion = identity.type().changeParameterType(0, haveReturn);</span>
<span class="fc" id="L286">                fn = makePairwiseConvert(identity, needConversion, level);</span>
            }
<span class="pc bpc" id="L288" title="1 of 4 branches missed.">            assert(names[RETURN_CONV] == null);</span>
<span class="fc" id="L289">            names[RETURN_CONV] = new Name(fn, arg);</span>
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">            assert(RETURN_CONV == names.length-1);</span>
        }

<span class="fc" id="L293">        LambdaForm form = new LambdaForm(&quot;convert&quot;, lambdaType.parameterCount(), names);</span>
<span class="fc" id="L294">        return SimpleMethodHandle.make(srcType, form);</span>
    }

    static MethodHandle makeReferenceIdentity(Class&lt;?&gt; refType) {
<span class="fc" id="L298">        MethodType lambdaType = MethodType.genericMethodType(1).invokerType();</span>
<span class="fc" id="L299">        Name[] names = arguments(1, lambdaType);</span>
<span class="fc" id="L300">        names[names.length - 1] = new Name(ValueConversions.identity(), names[1]);</span>
<span class="fc" id="L301">        LambdaForm form = new LambdaForm(&quot;identity&quot;, lambdaType.parameterCount(), names);</span>
<span class="fc" id="L302">        return SimpleMethodHandle.make(MethodType.methodType(refType, refType), form);</span>
    }

    static MethodHandle makeVarargsCollector(MethodHandle target, Class&lt;?&gt; arrayType) {
<span class="fc" id="L306">        MethodType type = target.type();</span>
<span class="fc" id="L307">        int last = type.parameterCount() - 1;</span>
<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (type.parameterType(last) != arrayType)</span>
<span class="nc" id="L309">            target = target.asType(type.changeParameterType(last, arrayType));</span>
<span class="fc" id="L310">        target = target.asFixedArity();  // make sure this attribute is turned off</span>
<span class="fc" id="L311">        return new AsVarargsCollector(target, target.type(), arrayType);</span>
    }

<span class="fc bfc" id="L314" title="All 2 branches covered.">    static class AsVarargsCollector extends MethodHandle {</span>
        private final MethodHandle target;
        private final Class&lt;?&gt; arrayType;
        private /*@Stable*/ MethodHandle asCollectorCache;

        AsVarargsCollector(MethodHandle target, MethodType type, Class&lt;?&gt; arrayType) {
<span class="fc" id="L320">            super(type, reinvokerForm(target));</span>
<span class="fc" id="L321">            this.target = target;</span>
<span class="fc" id="L322">            this.arrayType = arrayType;</span>
<span class="fc" id="L323">            this.asCollectorCache = target.asCollector(arrayType, 0);</span>
<span class="fc" id="L324">        }</span>

<span class="fc" id="L326">        @Override MethodHandle reinvokerTarget() { return target; }</span>

        @Override
        public boolean isVarargsCollector() {
<span class="fc" id="L330">            return true;</span>
        }

        @Override
        public MethodHandle asFixedArity() {
<span class="fc" id="L335">            return target;</span>
        }

        @Override
        public MethodHandle asTypeUncached(MethodType newType) {
<span class="fc" id="L340">            MethodType type = this.type();</span>
<span class="fc" id="L341">            int collectArg = type.parameterCount() - 1;</span>
<span class="fc" id="L342">            int newArity = newType.parameterCount();</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">            if (newArity == collectArg+1 &amp;&amp;</span>
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">                type.parameterType(collectArg).isAssignableFrom(newType.parameterType(collectArg))) {</span>
                // if arity and trailing parameter are compatible, do normal thing
<span class="nc" id="L346">                return asTypeCache = asFixedArity().asType(newType);</span>
            }
            // check cache
<span class="fc" id="L349">            MethodHandle acc = asCollectorCache;</span>
<span class="pc bpc" id="L350" title="1 of 4 branches missed.">            if (acc != null &amp;&amp; acc.type().parameterCount() == newArity)</span>
<span class="fc" id="L351">                return asTypeCache = acc.asType(newType);</span>
            // build and cache a collector
<span class="fc" id="L353">            int arrayLength = newArity - collectArg;</span>
            MethodHandle collector;
            try {
<span class="fc" id="L356">                collector = asFixedArity().asCollector(arrayType, arrayLength);</span>
<span class="pc bpc" id="L357" title="2 of 4 branches missed.">                assert(collector.type().parameterCount() == newArity) : &quot;newArity=&quot;+newArity+&quot; but collector=&quot;+collector;</span>
<span class="fc" id="L358">            } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L359">                throw new WrongMethodTypeException(&quot;cannot build collector&quot;, ex);</span>
<span class="fc" id="L360">            }</span>
<span class="fc" id="L361">            asCollectorCache = collector;</span>
<span class="fc" id="L362">            return asTypeCache = collector.asType(newType);</span>
        }

        @Override
        MethodHandle setVarargs(MemberName member) {
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (member.isVarargs())  return this;</span>
<span class="nc" id="L368">            return asFixedArity();</span>
        }

        @Override
        MethodHandle viewAsType(MethodType newType) {
<span class="nc bnc" id="L373" title="All 2 branches missed.">            if (newType.lastParameterType() != type().lastParameterType())</span>
<span class="nc" id="L374">                throw new InternalError();</span>
<span class="nc" id="L375">            MethodHandle newTarget = asFixedArity().viewAsType(newType);</span>
            // put back the varargs bit:
<span class="nc" id="L377">            return new AsVarargsCollector(newTarget, newType, arrayType);</span>
        }

        @Override
        MemberName internalMemberName() {
<span class="fc" id="L382">            return asFixedArity().internalMemberName();</span>
        }
        @Override
        Class&lt;?&gt; internalCallerClass() {
<span class="nc" id="L386">            return asFixedArity().internalCallerClass();</span>
        }

        /*non-public*/
        @Override
        boolean isInvokeSpecial() {
<span class="nc" id="L392">            return asFixedArity().isInvokeSpecial();</span>
        }


        @Override
        MethodHandle bindArgument(int pos, char basicType, Object value) {
<span class="fc" id="L398">            return asFixedArity().bindArgument(pos, basicType, value);</span>
        }

        @Override
        MethodHandle bindReceiver(Object receiver) {
<span class="fc" id="L403">            return asFixedArity().bindReceiver(receiver);</span>
        }

        @Override
        MethodHandle dropArguments(MethodType srcType, int pos, int drops) {
<span class="nc" id="L408">            return asFixedArity().dropArguments(srcType, pos, drops);</span>
        }

        @Override
        MethodHandle permuteArguments(MethodType newType, int[] reorder) {
<span class="nc" id="L413">            return asFixedArity().permuteArguments(newType, reorder);</span>
        }
    }

    /** Factory method:  Spread selected argument. */
    static MethodHandle makeSpreadArguments(MethodHandle target,
                                            Class&lt;?&gt; spreadArgType, int spreadArgPos, int spreadArgCount) {
<span class="fc" id="L420">        MethodType targetType = target.type();</span>

<span class="fc bfc" id="L422" title="All 2 branches covered.">        for (int i = 0; i &lt; spreadArgCount; i++) {</span>
<span class="fc" id="L423">            Class&lt;?&gt; arg = VerifyType.spreadArgElementType(spreadArgType, i);</span>
<span class="pc bpc" id="L424" title="1 of 2 branches missed.">            if (arg == null)  arg = Object.class;</span>
<span class="fc" id="L425">            targetType = targetType.changeParameterType(spreadArgPos + i, arg);</span>
        }
<span class="fc" id="L427">        target = target.asType(targetType);</span>

<span class="fc" id="L429">        MethodType srcType = targetType</span>
<span class="fc" id="L430">                .replaceParameterTypes(spreadArgPos, spreadArgPos + spreadArgCount, spreadArgType);</span>
        // Now build a LambdaForm.
<span class="fc" id="L432">        MethodType lambdaType = srcType.invokerType();</span>
<span class="fc" id="L433">        Name[] names = arguments(spreadArgCount + 2, lambdaType);</span>
<span class="fc" id="L434">        int nameCursor = lambdaType.parameterCount();</span>
<span class="fc" id="L435">        int[] indexes = new int[targetType.parameterCount()];</span>

<span class="fc bfc" id="L437" title="All 2 branches covered.">        for (int i = 0, argIndex = 1; i &lt; targetType.parameterCount() + 1; i++, argIndex++) {</span>
<span class="fc" id="L438">            Class&lt;?&gt; src = lambdaType.parameterType(i);</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">            if (i == spreadArgPos) {</span>
                // Spread the array.
<span class="fc" id="L441">                MethodHandle aload = MethodHandles.arrayElementGetter(spreadArgType);</span>
<span class="fc" id="L442">                Name array = names[argIndex];</span>
<span class="fc" id="L443">                names[nameCursor++] = new Name(Lazy.NF_checkSpreadArgument, array, spreadArgCount);</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">                for (int j = 0; j &lt; spreadArgCount; i++, j++) {</span>
<span class="fc" id="L445">                    indexes[i] = nameCursor;</span>
<span class="fc" id="L446">                    names[nameCursor++] = new Name(aload, array, j);</span>
                }
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">            } else if (i &lt; indexes.length) {</span>
<span class="fc" id="L449">                indexes[i] = argIndex;</span>
            }
        }
<span class="pc bpc" id="L452" title="2 of 4 branches missed.">        assert(nameCursor == names.length-1);  // leave room for the final call</span>

        // Build argument array for the call.
<span class="fc" id="L455">        Name[] targetArgs = new Name[targetType.parameterCount()];</span>
<span class="fc bfc" id="L456" title="All 2 branches covered.">        for (int i = 0; i &lt; targetType.parameterCount(); i++) {</span>
<span class="fc" id="L457">            int idx = indexes[i];</span>
<span class="fc" id="L458">            targetArgs[i] = names[idx];</span>
        }
<span class="fc" id="L460">        names[names.length - 1] = new Name(target, (Object[]) targetArgs);</span>

<span class="fc" id="L462">        LambdaForm form = new LambdaForm(&quot;spread&quot;, lambdaType.parameterCount(), names);</span>
<span class="fc" id="L463">        return SimpleMethodHandle.make(srcType, form);</span>
    }

    static void checkSpreadArgument(Object av, int n) {
<span class="fc bfc" id="L467" title="All 2 branches covered.">        if (av == null) {</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">            if (n == 0)  return;</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">        } else if (av instanceof Object[]) {</span>
<span class="fc" id="L470">            int len = ((Object[])av).length;</span>
<span class="pc bpc" id="L471" title="1 of 2 branches missed.">            if (len == n)  return;</span>
<span class="nc" id="L472">        } else {</span>
<span class="fc" id="L473">            int len = java.lang.reflect.Array.getLength(av);</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            if (len == n)  return;</span>
        }
        // fall through to error:
<span class="nc" id="L477">        throw newIllegalArgumentException(&quot;array is not of length &quot;+n);</span>
    }

    /**
     * Pre-initialized NamedFunctions for bootstrapping purposes.
     * Factored in an inner class to delay initialization until first usage.
     */
<span class="nc" id="L484">    private static class Lazy {</span>
        static final NamedFunction NF_checkSpreadArgument;
        static {
            try {
<span class="fc" id="L488">                NF_checkSpreadArgument = new NamedFunction(MethodHandleImpl.class</span>
<span class="fc" id="L489">                        .getDeclaredMethod(&quot;checkSpreadArgument&quot;, Object.class, int.class));</span>
<span class="fc" id="L490">                NF_checkSpreadArgument.resolve();</span>
<span class="nc" id="L491">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L492">                throw newInternalError(ex);</span>
<span class="fc" id="L493">            }</span>
<span class="fc" id="L494">        }</span>
    }

    /** Factory method:  Collect or filter selected argument(s). */
    static MethodHandle makeCollectArguments(MethodHandle target,
                MethodHandle collector, int collectArgPos, boolean retainOriginalArgs) {
<span class="fc" id="L500">        MethodType targetType = target.type();          // (a..., c, [b...])=&gt;r</span>
<span class="fc" id="L501">        MethodType collectorType = collector.type();    // (b...)=&gt;c</span>
<span class="fc" id="L502">        int collectArgCount = collectorType.parameterCount();</span>
<span class="fc" id="L503">        Class&lt;?&gt; collectValType = collectorType.returnType();</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">        int collectValCount = (collectValType == void.class ? 0 : 1);</span>
<span class="fc" id="L505">        MethodType srcType = targetType                 // (a..., [b...])=&gt;r</span>
<span class="fc" id="L506">                .dropParameterTypes(collectArgPos, collectArgPos+collectValCount);</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">        if (!retainOriginalArgs) {                      // (a..., b...)=&gt;r</span>
<span class="fc" id="L508">            srcType = srcType.insertParameterTypes(collectArgPos, collectorType.parameterList());</span>
        }
        // in  arglist: [0: ...keep1 | cpos: collect...  | cpos+cacount: keep2... ]
        // out arglist: [0: ...keep1 | cpos: collectVal? | cpos+cvcount: keep2... ]
        // out(retain): [0: ...keep1 | cpos: cV? coll... | cpos+cvc+cac: keep2... ]

        // Now build a LambdaForm.
<span class="fc" id="L515">        MethodType lambdaType = srcType.invokerType();</span>
<span class="fc" id="L516">        Name[] names = arguments(2, lambdaType);</span>
<span class="fc" id="L517">        final int collectNamePos = names.length - 2;</span>
<span class="fc" id="L518">        final int targetNamePos  = names.length - 1;</span>

<span class="fc" id="L520">        Name[] collectorArgs = Arrays.copyOfRange(names, 1 + collectArgPos, 1 + collectArgPos + collectArgCount);</span>
<span class="fc" id="L521">        names[collectNamePos] = new Name(collector, (Object[]) collectorArgs);</span>

        // Build argument array for the target.
        // Incoming LF args to copy are: [ (mh) headArgs collectArgs tailArgs ].
        // Output argument array is [ headArgs (collectVal)? (collectArgs)? tailArgs ].
<span class="fc" id="L526">        Name[] targetArgs = new Name[targetType.parameterCount()];</span>
<span class="fc" id="L527">        int inputArgPos  = 1;  // incoming LF args to copy to target</span>
<span class="fc" id="L528">        int targetArgPos = 0;  // fill pointer for targetArgs</span>
<span class="fc" id="L529">        int chunk = collectArgPos;  // |headArgs|</span>
<span class="fc" id="L530">        System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);</span>
<span class="fc" id="L531">        inputArgPos  += chunk;</span>
<span class="fc" id="L532">        targetArgPos += chunk;</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">        if (collectValType != void.class) {</span>
<span class="fc" id="L534">            targetArgs[targetArgPos++] = names[collectNamePos];</span>
        }
<span class="fc" id="L536">        chunk = collectArgCount;</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">        if (retainOriginalArgs) {</span>
<span class="fc" id="L538">            System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);</span>
<span class="fc" id="L539">            targetArgPos += chunk;   // optionally pass on the collected chunk</span>
        }
<span class="fc" id="L541">        inputArgPos += chunk;</span>
<span class="fc" id="L542">        chunk = targetArgs.length - targetArgPos;  // all the rest</span>
<span class="fc" id="L543">        System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);</span>
<span class="pc bpc" id="L544" title="1 of 4 branches missed.">        assert(inputArgPos + chunk == collectNamePos);  // use of rest of input args also</span>
<span class="fc" id="L545">        names[targetNamePos] = new Name(target, (Object[]) targetArgs);</span>

<span class="fc" id="L547">        LambdaForm form = new LambdaForm(&quot;collect&quot;, lambdaType.parameterCount(), names);</span>
<span class="fc" id="L548">        return SimpleMethodHandle.make(srcType, form);</span>
    }

    static
    MethodHandle selectAlternative(boolean testResult, MethodHandle target, MethodHandle fallback) {
<span class="fc bfc" id="L553" title="All 2 branches covered.">        return testResult ? target : fallback;</span>
    }

    static MethodHandle SELECT_ALTERNATIVE;
    static MethodHandle selectAlternative() {
<span class="fc bfc" id="L558" title="All 2 branches covered.">        if (SELECT_ALTERNATIVE != null)  return SELECT_ALTERNATIVE;</span>
        try {
<span class="fc" id="L560">            SELECT_ALTERNATIVE</span>
<span class="fc" id="L561">            = IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;selectAlternative&quot;,</span>
<span class="fc" id="L562">                    MethodType.methodType(MethodHandle.class, boolean.class, MethodHandle.class, MethodHandle.class));</span>
<span class="nc" id="L563">        } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L564">            throw new RuntimeException(ex);</span>
<span class="fc" id="L565">        }</span>
<span class="fc" id="L566">        return SELECT_ALTERNATIVE;</span>
    }

    static
    MethodHandle makeGuardWithTest(MethodHandle test,
                                   MethodHandle target,
                                   MethodHandle fallback) {
<span class="fc" id="L573">        MethodType basicType = target.type().basicType();</span>
<span class="fc" id="L574">        MethodHandle invokeBasic = MethodHandles.basicInvoker(basicType);</span>
<span class="fc" id="L575">        int arity = basicType.parameterCount();</span>
<span class="fc" id="L576">        int extraNames = 3;</span>
<span class="fc" id="L577">        MethodType lambdaType = basicType.invokerType();</span>
<span class="fc" id="L578">        Name[] names = arguments(extraNames, lambdaType);</span>

<span class="fc" id="L580">        Object[] testArgs   = Arrays.copyOfRange(names, 1, 1 + arity, Object[].class);</span>
<span class="fc" id="L581">        Object[] targetArgs = Arrays.copyOfRange(names, 0, 1 + arity, Object[].class);</span>

        // call test
<span class="fc" id="L584">        names[arity + 1] = new Name(test, testArgs);</span>

        // call selectAlternative
<span class="fc" id="L587">        Object[] selectArgs = { names[arity + 1], target, fallback };</span>
<span class="fc" id="L588">        names[arity + 2] = new Name(MethodHandleImpl.selectAlternative(), selectArgs);</span>
<span class="fc" id="L589">        targetArgs[0] = names[arity + 2];</span>

        // call target or fallback
<span class="fc" id="L592">        names[arity + 3] = new Name(new NamedFunction(invokeBasic), targetArgs);</span>

<span class="fc" id="L594">        LambdaForm form = new LambdaForm(&quot;guard&quot;, lambdaType.parameterCount(), names);</span>
<span class="fc" id="L595">        return SimpleMethodHandle.make(target.type(), form);</span>
    }

<span class="pc bpc" id="L598" title="1 of 2 branches missed.">    private static class GuardWithCatch {</span>
        private final MethodHandle target;
        private final Class&lt;? extends Throwable&gt; exType;
        private final MethodHandle catcher;
        // FIXME: Build the control flow out of foldArguments.
<span class="fc" id="L603">        GuardWithCatch(MethodHandle target, Class&lt;? extends Throwable&gt; exType, MethodHandle catcher) {</span>
<span class="fc" id="L604">            this.target = target;</span>
<span class="fc" id="L605">            this.exType = exType;</span>
<span class="fc" id="L606">            this.catcher = catcher;</span>
<span class="fc" id="L607">        }</span>
        @LambdaForm.Hidden
        private Object invoke_V(Object... av) throws Throwable {
            try {
<span class="fc" id="L611">                return target.invokeExact(av);</span>
<span class="fc" id="L612">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L613" title="All 2 branches covered.">                if (!exType.isInstance(t))  throw t;</span>
<span class="fc" id="L614">                return catcher.invokeExact(t, av);</span>
            }
        }
        @LambdaForm.Hidden
        private Object invoke_L0() throws Throwable {
            try {
<span class="fc" id="L620">                return target.invokeExact();</span>
<span class="fc" id="L621">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">                if (!exType.isInstance(t))  throw t;</span>
<span class="fc" id="L623">                return catcher.invokeExact(t);</span>
            }
        }
        @LambdaForm.Hidden
        private Object invoke_L1(Object a0) throws Throwable {
            try {
<span class="fc" id="L629">                return target.invokeExact(a0);</span>
<span class="fc" id="L630">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L631" title="All 2 branches covered.">                if (!exType.isInstance(t))  throw t;</span>
<span class="fc" id="L632">                return catcher.invokeExact(t, a0);</span>
            }
        }
        @LambdaForm.Hidden
        private Object invoke_L2(Object a0, Object a1) throws Throwable {
            try {
<span class="fc" id="L638">                return target.invokeExact(a0, a1);</span>
<span class="fc" id="L639">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L640" title="All 2 branches covered.">                if (!exType.isInstance(t))  throw t;</span>
<span class="fc" id="L641">                return catcher.invokeExact(t, a0, a1);</span>
            }
        }
        @LambdaForm.Hidden
        private Object invoke_L3(Object a0, Object a1, Object a2) throws Throwable {
            try {
<span class="fc" id="L647">                return target.invokeExact(a0, a1, a2);</span>
<span class="fc" id="L648">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">                if (!exType.isInstance(t))  throw t;</span>
<span class="fc" id="L650">                return catcher.invokeExact(t, a0, a1, a2);</span>
            }
        }
        @LambdaForm.Hidden
        private Object invoke_L4(Object a0, Object a1, Object a2, Object a3) throws Throwable {
            try {
<span class="fc" id="L656">                return target.invokeExact(a0, a1, a2, a3);</span>
<span class="fc" id="L657">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L658" title="All 2 branches covered.">                if (!exType.isInstance(t))  throw t;</span>
<span class="fc" id="L659">                return catcher.invokeExact(t, a0, a1, a2, a3);</span>
            }
        }
        @LambdaForm.Hidden
        private Object invoke_L5(Object a0, Object a1, Object a2, Object a3, Object a4) throws Throwable {
            try {
<span class="fc" id="L665">                return target.invokeExact(a0, a1, a2, a3, a4);</span>
<span class="fc" id="L666">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">                if (!exType.isInstance(t))  throw t;</span>
<span class="fc" id="L668">                return catcher.invokeExact(t, a0, a1, a2, a3, a4);</span>
            }
        }
        @LambdaForm.Hidden
        private Object invoke_L6(Object a0, Object a1, Object a2, Object a3, Object a4, Object a5) throws Throwable {
            try {
<span class="fc" id="L674">                return target.invokeExact(a0, a1, a2, a3, a4, a5);</span>
<span class="fc" id="L675">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">                if (!exType.isInstance(t))  throw t;</span>
<span class="fc" id="L677">                return catcher.invokeExact(t, a0, a1, a2, a3, a4, a5);</span>
            }
        }
        @LambdaForm.Hidden
        private Object invoke_L7(Object a0, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6) throws Throwable {
            try {
<span class="fc" id="L683">                return target.invokeExact(a0, a1, a2, a3, a4, a5, a6);</span>
<span class="fc" id="L684">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">                if (!exType.isInstance(t))  throw t;</span>
<span class="fc" id="L686">                return catcher.invokeExact(t, a0, a1, a2, a3, a4, a5, a6);</span>
            }
        }
        @LambdaForm.Hidden
        private Object invoke_L8(Object a0, Object a1, Object a2, Object a3, Object a4, Object a5, Object a6, Object a7) throws Throwable {
            try {
<span class="fc" id="L692">                return target.invokeExact(a0, a1, a2, a3, a4, a5, a6, a7);</span>
<span class="fc" id="L693">            } catch (Throwable t) {</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">                if (!exType.isInstance(t))  throw t;</span>
<span class="fc" id="L695">                return catcher.invokeExact(t, a0, a1, a2, a3, a4, a5, a6, a7);</span>
            }
        }
        static MethodHandle[] makeInvokes() {
<span class="fc" id="L699">            ArrayList&lt;MethodHandle&gt; invokes = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L700">            MethodHandles.Lookup lookup = IMPL_LOOKUP;</span>
            for (;;) {
<span class="fc" id="L702">                int nargs = invokes.size();</span>
<span class="fc" id="L703">                String name = &quot;invoke_L&quot;+nargs;</span>
<span class="fc" id="L704">                MethodHandle invoke = null;</span>
                try {
<span class="fc" id="L706">                    invoke = lookup.findVirtual(GuardWithCatch.class, name, MethodType.genericMethodType(nargs));</span>
<span class="fc" id="L707">                } catch (ReflectiveOperationException ex) {</span>
<span class="fc" id="L708">                }</span>
<span class="fc bfc" id="L709" title="All 2 branches covered.">                if (invoke == null)  break;</span>
<span class="fc" id="L710">                invokes.add(invoke);</span>
<span class="fc" id="L711">            }</span>
<span class="pc bpc" id="L712" title="2 of 4 branches missed.">            assert(invokes.size() == 9);  // current number of methods</span>
<span class="fc" id="L713">            return invokes.toArray(new MethodHandle[0]);</span>
        };
<span class="fc" id="L715">        static final MethodHandle[] INVOKES = makeInvokes();</span>
        // For testing use this:
        //static final MethodHandle[] INVOKES = Arrays.copyOf(makeInvokes(), 2);
        static final MethodHandle VARARGS_INVOKE;
        static {
            try {
<span class="fc" id="L721">                VARARGS_INVOKE = IMPL_LOOKUP.findVirtual(GuardWithCatch.class, &quot;invoke_V&quot;, MethodType.genericMethodType(0, true));</span>
<span class="nc" id="L722">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L723">                throw uncaughtException(ex);</span>
<span class="fc" id="L724">            }</span>
<span class="fc" id="L725">        }</span>
    }


    static
    MethodHandle makeGuardWithCatch(MethodHandle target,
                                    Class&lt;? extends Throwable&gt; exType,
                                    MethodHandle catcher) {
<span class="fc" id="L733">        MethodType type = target.type();</span>
<span class="fc" id="L734">        MethodType ctype = catcher.type();</span>
<span class="fc" id="L735">        int nargs = type.parameterCount();</span>
<span class="fc bfc" id="L736" title="All 2 branches covered.">        if (nargs &lt; GuardWithCatch.INVOKES.length) {</span>
<span class="fc" id="L737">            MethodType gtype = type.generic();</span>
<span class="fc" id="L738">            MethodType gcatchType = gtype.insertParameterTypes(0, Throwable.class);</span>
            // Note: convertArguments(...2) avoids interface casts present in convertArguments(...0)
<span class="fc" id="L740">            MethodHandle gtarget = makePairwiseConvert(target, gtype, 2);</span>
<span class="fc" id="L741">            MethodHandle gcatcher = makePairwiseConvert(catcher, gcatchType, 2);</span>
<span class="fc" id="L742">            GuardWithCatch gguard = new GuardWithCatch(gtarget, exType, gcatcher);</span>
<span class="pc bpc" id="L743" title="2 of 4 branches missed.">            if (gtarget == null || gcatcher == null)  throw new InternalError();</span>
<span class="fc" id="L744">            MethodHandle ginvoker = GuardWithCatch.INVOKES[nargs].bindReceiver(gguard);</span>
<span class="fc" id="L745">            return makePairwiseConvert(ginvoker, type, 2);</span>
        } else {
<span class="fc" id="L747">            target = target.asType(type.changeReturnType(Object.class));</span>
<span class="fc" id="L748">            MethodHandle gtarget = makeSpreadArguments(target, Object[].class, 0, nargs);</span>
<span class="fc" id="L749">            MethodType catcherType = ctype.changeParameterType(0, Throwable.class)</span>
<span class="fc" id="L750">                                          .changeReturnType(Object.class);</span>
<span class="fc" id="L751">            catcher = catcher.asType(catcherType);</span>
<span class="fc" id="L752">            MethodHandle gcatcher = makeSpreadArguments(catcher, Object[].class, 1, nargs);</span>
<span class="fc" id="L753">            GuardWithCatch gguard = new GuardWithCatch(gtarget, exType, gcatcher);</span>
<span class="pc bpc" id="L754" title="2 of 4 branches missed.">            if (gtarget == null || gcatcher == null)  throw new InternalError();</span>
<span class="fc" id="L755">            MethodHandle ginvoker = GuardWithCatch.VARARGS_INVOKE.bindReceiver(gguard);</span>
<span class="fc" id="L756">            MethodHandle gcollect = makeCollectArguments(ginvoker, ValueConversions.varargsArray(nargs), 0, false);</span>
<span class="fc" id="L757">            return makePairwiseConvert(gcollect, type, 2);</span>
        }
    }

    static
    MethodHandle throwException(MethodType type) {
<span class="pc bpc" id="L763" title="2 of 4 branches missed.">        assert(Throwable.class.isAssignableFrom(type.parameterType(0)));</span>
<span class="fc" id="L764">        int arity = type.parameterCount();</span>
<span class="fc bfc" id="L765" title="All 2 branches covered.">        if (arity &gt; 1) {</span>
<span class="fc" id="L766">            return throwException(type.dropParameterTypes(1, arity)).dropArguments(type, 1, arity-1);</span>
        }
<span class="fc" id="L768">        return makePairwiseConvert(throwException(), type, 2);</span>
    }

    static MethodHandle THROW_EXCEPTION;
    static MethodHandle throwException() {
<span class="fc" id="L773">        MethodHandle mh = THROW_EXCEPTION;</span>
<span class="fc bfc" id="L774" title="All 2 branches covered.">        if (mh != null)  return mh;</span>
        try {
<span class="fc" id="L776">            mh</span>
<span class="fc" id="L777">            = IMPL_LOOKUP.findStatic(MethodHandleImpl.class, &quot;throwException&quot;,</span>
<span class="fc" id="L778">                    MethodType.methodType(Empty.class, Throwable.class));</span>
<span class="nc" id="L779">        } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L780">            throw new RuntimeException(ex);</span>
<span class="fc" id="L781">        }</span>
<span class="fc" id="L782">        THROW_EXCEPTION = mh;</span>
<span class="fc" id="L783">        return mh;</span>
    }
<span class="fc" id="L785">    static &lt;T extends Throwable&gt; Empty throwException(T t) throws T { throw t; }</span>

<span class="fc" id="L787">    static MethodHandle[] FAKE_METHOD_HANDLE_INVOKE = new MethodHandle[2];</span>
    static MethodHandle fakeMethodHandleInvoke(MemberName method) {
        int idx;
<span class="pc bpc" id="L790" title="2 of 4 branches missed.">        assert(method.isMethodHandleInvoke());</span>
<span class="pc bpc" id="L791" title="4 of 10 branches missed.">        switch (method.getName()) {</span>
<span class="fc" id="L792">        case &quot;invoke&quot;:       idx = 0; break;</span>
<span class="fc" id="L793">        case &quot;invokeExact&quot;:  idx = 1; break;</span>
<span class="nc" id="L794">        default:             throw new InternalError(method.getName());</span>
        }
<span class="fc" id="L796">        MethodHandle mh = FAKE_METHOD_HANDLE_INVOKE[idx];</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">        if (mh != null)  return mh;</span>
<span class="fc" id="L798">        MethodType type = MethodType.methodType(Object.class, UnsupportedOperationException.class,</span>
                                                MethodHandle.class, Object[].class);
<span class="fc" id="L800">        mh = throwException(type);</span>
<span class="fc" id="L801">        mh = mh.bindTo(new UnsupportedOperationException(&quot;cannot reflectively invoke MethodHandle&quot;));</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">        if (!method.getInvocationType().equals(mh.type()))</span>
<span class="nc" id="L803">            throw new InternalError(method.toString());</span>
<span class="fc" id="L804">        mh = mh.withInternalMemberName(method);</span>
<span class="fc" id="L805">        mh = mh.asVarargsCollector(Object[].class);</span>
<span class="pc bpc" id="L806" title="2 of 4 branches missed.">        assert(method.isVarargs());</span>
<span class="fc" id="L807">        FAKE_METHOD_HANDLE_INVOKE[idx] = mh;</span>
<span class="fc" id="L808">        return mh;</span>
    }

    /**
     * Create an alias for the method handle which, when called,
     * appears to be called from the same class loader and protection domain
     * as hostClass.
     * This is an expensive no-op unless the method which is called
     * is sensitive to its caller.  A small number of system methods
     * are in this category, including Class.forName and Method.invoke.
     */
    static
    MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
<span class="nc" id="L821">        return BindCaller.bindCaller(mh, hostClass);</span>
    }

    // Put the whole mess into its own nested class.
    // That way we can lazily load the code and set up the constants.
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">    private static class BindCaller {</span>
        static
        MethodHandle bindCaller(MethodHandle mh, Class&lt;?&gt; hostClass) {
            // Do not use this function to inject calls into system classes.
<span class="nc bnc" id="L830" title="All 2 branches missed.">            if (hostClass == null</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">                ||    (hostClass.isArray() ||</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">                       hostClass.isPrimitive() ||</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">                       hostClass.getName().startsWith(&quot;java.&quot;) ||</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">                       hostClass.getName().startsWith(&quot;sun.&quot;))) {</span>
<span class="nc" id="L835">                throw new InternalError();  // does not happen, and should not anyway</span>
            }
            // For simplicity, convert mh to a varargs-like method.
<span class="nc" id="L838">            MethodHandle vamh = prepareForInvoker(mh);</span>
            // Cache the result of makeInjectedInvoker once per argument class.
<span class="nc" id="L840">            MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);</span>
<span class="nc" id="L841">            return restoreToType(bccInvoker.bindTo(vamh), mh.type(), mh.internalMemberName(), hostClass);</span>
        }

        private static MethodHandle makeInjectedInvoker(Class&lt;?&gt; hostClass) {
<span class="nc" id="L845">            Class&lt;?&gt; bcc = UNSAFE.defineAnonymousClass(hostClass, T_BYTES, null);</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">            if (hostClass.getClassLoader() != bcc.getClassLoader())</span>
<span class="nc" id="L847">                throw new InternalError(hostClass.getName()+&quot; (CL)&quot;);</span>
            try {
<span class="nc bnc" id="L849" title="All 2 branches missed.">                if (hostClass.getProtectionDomain() != bcc.getProtectionDomain())</span>
<span class="nc" id="L850">                    throw new InternalError(hostClass.getName()+&quot; (PD)&quot;);</span>
<span class="nc" id="L851">            } catch (SecurityException ex) {</span>
                // Self-check was blocked by security manager.  This is OK.
                // In fact the whole try body could be turned into an assertion.
<span class="nc" id="L854">            }</span>
            try {
<span class="nc" id="L856">                MethodHandle init = IMPL_LOOKUP.findStatic(bcc, &quot;init&quot;, MethodType.methodType(void.class));</span>
<span class="nc" id="L857">                init.invokeExact();  // force initialization of the class</span>
<span class="nc" id="L858">            } catch (Throwable ex) {</span>
<span class="nc" id="L859">                throw uncaughtException(ex);</span>
<span class="nc" id="L860">            }</span>
            MethodHandle bccInvoker;
            try {
<span class="nc" id="L863">                MethodType invokerMT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);</span>
<span class="nc" id="L864">                bccInvoker = IMPL_LOOKUP.findStatic(bcc, &quot;invoke_V&quot;, invokerMT);</span>
<span class="nc" id="L865">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L866">                throw uncaughtException(ex);</span>
<span class="nc" id="L867">            }</span>
            // Test the invoker, to ensure that it really injects into the right place.
            try {
<span class="nc" id="L870">                MethodHandle vamh = prepareForInvoker(MH_checkCallerClass);</span>
<span class="nc" id="L871">                Object ok = bccInvoker.invokeExact(vamh, new Object[]{hostClass, bcc});</span>
<span class="nc" id="L872">            } catch (Throwable ex) {</span>
<span class="nc" id="L873">                throw new InternalError(ex);</span>
<span class="nc" id="L874">            }</span>
<span class="nc" id="L875">            return bccInvoker;</span>
        }
<span class="fc" id="L877">        private static ClassValue&lt;MethodHandle&gt; CV_makeInjectedInvoker = new ClassValue&lt;MethodHandle&gt;() {</span>
            @Override protected MethodHandle computeValue(Class&lt;?&gt; hostClass) {
<span class="nc" id="L879">                return makeInjectedInvoker(hostClass);</span>
            }
        };

        // Adapt mh so that it can be called directly from an injected invoker:
        private static MethodHandle prepareForInvoker(MethodHandle mh) {
<span class="nc" id="L885">            mh = mh.asFixedArity();</span>
<span class="nc" id="L886">            MethodType mt = mh.type();</span>
<span class="nc" id="L887">            int arity = mt.parameterCount();</span>
<span class="nc" id="L888">            MethodHandle vamh = mh.asType(mt.generic());</span>
<span class="nc" id="L889">            vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames</span>
<span class="nc" id="L890">            vamh = vamh.asSpreader(Object[].class, arity);</span>
<span class="nc" id="L891">            vamh.internalForm().compileToBytecode();  // eliminate LFI stack frames</span>
<span class="nc" id="L892">            return vamh;</span>
        }

        // Undo the adapter effect of prepareForInvoker:
        private static MethodHandle restoreToType(MethodHandle vamh, MethodType type,
                                                  MemberName member,
                                                  Class&lt;?&gt; hostClass) {
<span class="nc" id="L899">            MethodHandle mh = vamh.asCollector(Object[].class, type.parameterCount());</span>
<span class="nc" id="L900">            mh = mh.asType(type);</span>
<span class="nc" id="L901">            mh = new WrappedMember(mh, type, member, hostClass);</span>
<span class="nc" id="L902">            return mh;</span>
        }

        private static final MethodHandle MH_checkCallerClass;
        static {
<span class="fc" id="L907">            final Class&lt;?&gt; THIS_CLASS = BindCaller.class;</span>
<span class="pc bpc" id="L908" title="2 of 4 branches missed.">            assert(checkCallerClass(THIS_CLASS, THIS_CLASS));</span>
            try {
<span class="fc" id="L910">                MH_checkCallerClass = IMPL_LOOKUP</span>
<span class="fc" id="L911">                    .findStatic(THIS_CLASS, &quot;checkCallerClass&quot;,</span>
<span class="fc" id="L912">                                MethodType.methodType(boolean.class, Class.class, Class.class));</span>
<span class="pc bpc" id="L913" title="2 of 4 branches missed.">                assert((boolean) MH_checkCallerClass.invokeExact(THIS_CLASS, THIS_CLASS));</span>
<span class="nc" id="L914">            } catch (Throwable ex) {</span>
<span class="nc" id="L915">                throw new InternalError(ex);</span>
<span class="nc" id="L916">            }</span>
        }

        @CallerSensitive
        private static boolean checkCallerClass(Class&lt;?&gt; expected, Class&lt;?&gt; expected2) {
            // This method is called via MH_checkCallerClass and so it's
            // correct to ask for the immediate caller here.
<span class="fc" id="L923">            Class&lt;?&gt; actual = Reflection.getCallerClass();</span>
<span class="pc bpc" id="L924" title="3 of 4 branches missed.">            if (actual != expected &amp;&amp; actual != expected2)</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                throw new InternalError(&quot;found &quot;+actual.getName()+&quot;, expected &quot;+expected.getName()</span>
<span class="nc" id="L926">                                        +(expected == expected2 ? &quot;&quot; : &quot;, or else &quot;+expected2.getName()));</span>
<span class="fc" id="L927">            return true;</span>
        }

        private static final byte[] T_BYTES;
        static {
<span class="nc" id="L932">            final Object[] values = {null};</span>
<span class="pc" id="L933">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                    public Void run() {
                        try {
<span class="nc" id="L936">                            Class&lt;T&gt; tClass = T.class;</span>
<span class="nc" id="L937">                            String tName = tClass.getName();</span>
<span class="nc" id="L938">                            String tResource = tName.substring(tName.lastIndexOf('.')+1)+&quot;.class&quot;;</span>
<span class="nc" id="L939">                            java.net.URLConnection uconn = tClass.getResource(tResource).openConnection();</span>
<span class="nc" id="L940">                            int len = uconn.getContentLength();</span>
<span class="nc" id="L941">                            byte[] bytes = new byte[len];</span>
<span class="nc" id="L942">                            try (java.io.InputStream str = uconn.getInputStream()) {</span>
<span class="nc" id="L943">                                int nr = str.read(bytes);</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">                                if (nr != len)  throw new java.io.IOException(tResource);</span>
<span class="nc bnc" id="L945" title="All 8 branches missed.">                            }</span>
<span class="nc" id="L946">                            values[0] = bytes;</span>
<span class="nc" id="L947">                        } catch (java.io.IOException ex) {</span>
<span class="nc" id="L948">                            throw new InternalError(ex);</span>
<span class="nc" id="L949">                        }</span>
<span class="nc" id="L950">                        return null;</span>
                    }
                });
<span class="nc" id="L953">            T_BYTES = (byte[]) values[0];</span>
<span class="nc" id="L954">        }</span>

        // The following class is used as a template for Unsafe.defineAnonymousClass:
<span class="nc" id="L957">        private static class T {</span>
<span class="nc" id="L958">            static void init() { }  // side effect: initializes this class</span>
            static Object invoke_V(MethodHandle vamh, Object[] args) throws Throwable {
<span class="nc" id="L960">                return vamh.invokeExact(args);</span>
            }
        }
    }


    /** This subclass allows a wrapped method handle to be re-associated with an arbitrary member name. */
<span class="nc" id="L967">    static class WrappedMember extends MethodHandle {</span>
        private final MethodHandle target;
        private final MemberName member;
        private final Class&lt;?&gt; callerClass;

        private WrappedMember(MethodHandle target, MethodType type, MemberName member, Class&lt;?&gt; callerClass) {
<span class="fc" id="L973">            super(type, reinvokerForm(target));</span>
<span class="fc" id="L974">            this.target = target;</span>
<span class="fc" id="L975">            this.member = member;</span>
<span class="fc" id="L976">            this.callerClass = callerClass;</span>
<span class="fc" id="L977">        }</span>

        @Override
        MethodHandle reinvokerTarget() {
<span class="fc" id="L981">            return target;</span>
        }
        @Override
        public MethodHandle asTypeUncached(MethodType newType) {
            // This MH is an alias for target, except for the MemberName
            // Drop the MemberName if there is any conversion.
<span class="fc" id="L987">            return asTypeCache = target.asType(newType);</span>
        }
        @Override
        MemberName internalMemberName() {
<span class="fc" id="L991">            return member;</span>
        }
        @Override
        Class&lt;?&gt; internalCallerClass() {
<span class="nc" id="L995">            return callerClass;</span>
        }
        @Override
        boolean isInvokeSpecial() {
<span class="nc" id="L999">            return target.isInvokeSpecial();</span>
        }
        @Override
        MethodHandle viewAsType(MethodType newType) {
<span class="nc" id="L1003">            return new WrappedMember(target, newType, member, callerClass);</span>
        }
    }

    static MethodHandle makeWrappedMember(MethodHandle target, MemberName member) {
<span class="pc bpc" id="L1008" title="1 of 2 branches missed.">        if (member.equals(target.internalMemberName()))</span>
<span class="nc" id="L1009">            return target;</span>
<span class="fc" id="L1010">        return new WrappedMember(target, target.type(), member, null);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>