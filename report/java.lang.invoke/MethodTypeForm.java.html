<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MethodTypeForm.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">MethodTypeForm.java</span></div><h1>MethodTypeForm.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.invoke;

import sun.invoke.util.Wrapper;
import static java.lang.invoke.MethodHandleStatics.*;
import static java.lang.invoke.MethodHandleNatives.Constants.*;
 import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;

/**
 * Shared information for a group of method types, which differ
 * only by reference types, and therefore share a common erasure
 * and wrapping.
 * &lt;p&gt;
 * For an empirical discussion of the structure of method types,
 * see &lt;a href=&quot;http://groups.google.com/group/jvm-languages/browse_thread/thread/ac9308ae74da9b7e/&quot;&gt;
 * the thread &quot;Avoiding Boxing&quot; on jvm-languages&lt;/a&gt;.
 * There are approximately 2000 distinct erased method types in the JDK.
 * There are a little over 10 times that number of unerased types.
 * No more than half of these are likely to be loaded at once.
 * @author John Rose
 */
<span class="fc bfc" id="L46" title="All 2 branches covered.">final class MethodTypeForm {</span>
    final int[] argToSlotTable, slotToArgTable;
    final long argCounts;               // packed slot &amp; value counts
    final long primCounts;              // packed prim &amp; double counts
    final int vmslots;                  // total number of parameter slots
    final MethodType erasedType;        // the canonical erasure
    final MethodType basicType;         // the canonical erasure, with primitives simplified

    // Cached adapter information:
    @Stable String typeString;           // argument type signature characters
    @Stable MethodHandle genericInvoker; // JVM hook for inexact invoke
    @Stable MethodHandle basicInvoker;   // cached instance of MH.invokeBasic
    @Stable MethodHandle namedFunctionInvoker; // cached helper for LF.NamedFunction

    // Cached lambda form information, for basic types only:
    final @Stable LambdaForm[] lambdaForms;
    // Indexes into lambdaForms:
    static final int
            LF_INVVIRTUAL     =  0,  // DMH invokeVirtual
            LF_INVSTATIC      =  1,
            LF_INVSPECIAL     =  2,
            LF_NEWINVSPECIAL  =  3,
            LF_INVINTERFACE   =  4,
            LF_INVSTATIC_INIT =  5,  // DMH invokeStatic with &lt;clinit&gt; barrier
            LF_INTERPRET      =  6,  // LF interpreter
            LF_COUNTER        =  7,  // CMH wrapper
            LF_REINVOKE       =  8,  // other wrapper
            LF_EX_LINKER      =  9,  // invokeExact_MT
            LF_EX_INVOKER     = 10,  // invokeExact MH
            LF_GEN_LINKER     = 11,
            LF_GEN_INVOKER    = 12,
            LF_CS_LINKER      = 13,  // linkToCallSite_CS
            LF_MH_LINKER      = 14,  // linkToCallSite_MH
            LF_LIMIT          = 15;

    public MethodType erasedType() {
<span class="fc" id="L82">        return erasedType;</span>
    }

    public MethodType basicType() {
<span class="fc" id="L86">        return basicType;</span>
    }

    public LambdaForm cachedLambdaForm(int which) {
<span class="fc" id="L90">        return lambdaForms[which];</span>
    }

    public LambdaForm setCachedLambdaForm(int which, LambdaForm form) {
        // Should we perform some sort of CAS, to avoid racy duplication?
<span class="fc" id="L95">        return lambdaForms[which] = form;</span>
    }

    public MethodHandle basicInvoker() {
<span class="pc bpc" id="L99" title="1 of 4 branches missed.">        assert(erasedType == basicType) : &quot;erasedType: &quot; + erasedType + &quot; != basicType: &quot; + basicType;  // primitives must be flattened also</span>
<span class="fc" id="L100">        MethodHandle invoker = basicInvoker;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        if (invoker != null)  return invoker;</span>
<span class="fc" id="L102">        invoker = DirectMethodHandle.make(invokeBasicMethod(basicType));</span>
<span class="fc" id="L103">        basicInvoker = invoker;</span>
<span class="fc" id="L104">        return invoker;</span>
    }

    // This next one is called from LambdaForm.NamedFunction.&lt;init&gt;.
    /*non-public*/ static MemberName invokeBasicMethod(MethodType basicType) {
<span class="pc bpc" id="L109" title="1 of 4 branches missed.">        assert(basicType == basicType.basicType());</span>
        try {
            // Do approximately the same as this public API call:
            //   Lookup.findVirtual(MethodHandle.class, name, type);
            // But bypass access and corner case checks, since we know exactly what we need.
<span class="fc" id="L114">            return IMPL_LOOKUP.resolveOrFail(REF_invokeVirtual, MethodHandle.class, &quot;invokeBasic&quot;, basicType);</span>
<span class="nc" id="L115">         } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L116">            throw newInternalError(&quot;JVM cannot find invoker for &quot;+basicType, ex);</span>
        }
    }

    /**
     * Build an MTF for a given type, which must have all references erased to Object.
     * This MTF will stand for that type and all un-erased variations.
     * Eagerly compute some basic properties of the type, common to all variations.
     */
<span class="fc" id="L125">    protected MethodTypeForm(MethodType erasedType) {</span>
<span class="fc" id="L126">        this.erasedType = erasedType;</span>

<span class="fc" id="L128">        Class&lt;?&gt;[] ptypes = erasedType.ptypes();</span>
<span class="fc" id="L129">        int ptypeCount = ptypes.length;</span>
<span class="fc" id="L130">        int pslotCount = ptypeCount;            // temp. estimate</span>
<span class="fc" id="L131">        int rtypeCount = 1;                     // temp. estimate</span>
<span class="fc" id="L132">        int rslotCount = 1;                     // temp. estimate</span>

<span class="fc" id="L134">        int[] argToSlotTab = null, slotToArgTab = null;</span>

        // Walk the argument types, looking for primitives.
<span class="fc" id="L137">        int pac = 0, lac = 0, prc = 0, lrc = 0;</span>
<span class="fc" id="L138">        Class&lt;?&gt;[] epts = ptypes;</span>
<span class="fc" id="L139">        Class&lt;?&gt;[] bpts = epts;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        for (int i = 0; i &lt; epts.length; i++) {</span>
<span class="fc" id="L141">            Class&lt;?&gt; pt = epts[i];</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">            if (pt != Object.class) {</span>
<span class="fc" id="L143">                ++pac;</span>
<span class="fc" id="L144">                Wrapper w = Wrapper.forPrimitiveType(pt);</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                if (w.isDoubleWord())  ++lac;</span>
<span class="fc bfc" id="L146" title="All 4 branches covered.">                if (w.isSubwordOrInt() &amp;&amp; pt != int.class) {</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">                    if (bpts == epts)</span>
<span class="fc" id="L148">                        bpts = bpts.clone();</span>
<span class="fc" id="L149">                    bpts[i] = int.class;</span>
                }
            }
        }
<span class="fc" id="L153">        pslotCount += lac;                  // #slots = #args + #longs</span>
<span class="fc" id="L154">        Class&lt;?&gt; rt = erasedType.returnType();</span>
<span class="fc" id="L155">        Class&lt;?&gt; bt = rt;</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">        if (rt != Object.class) {</span>
<span class="fc" id="L157">            ++prc;          // even void.class counts as a prim here</span>
<span class="fc" id="L158">            Wrapper w = Wrapper.forPrimitiveType(rt);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (w.isDoubleWord())  ++lrc;</span>
<span class="fc bfc" id="L160" title="All 4 branches covered.">            if (w.isSubwordOrInt() &amp;&amp; rt != int.class)</span>
<span class="fc" id="L161">                bt = int.class;</span>
            // adjust #slots, #args
<span class="fc bfc" id="L163" title="All 2 branches covered.">            if (rt == void.class)</span>
<span class="fc" id="L164">                rtypeCount = rslotCount = 0;</span>
            else
<span class="fc" id="L166">                rslotCount += lrc;</span>
        }
<span class="fc bfc" id="L168" title="All 4 branches covered.">        if (epts == bpts &amp;&amp; bt == rt) {</span>
<span class="fc" id="L169">            this.basicType = erasedType;</span>
        } else {
<span class="fc" id="L171">            this.basicType = MethodType.makeImpl(bt, bpts, true);</span>
        }
<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (lac != 0) {</span>
<span class="fc" id="L174">            int slot = ptypeCount + lac;</span>
<span class="fc" id="L175">            slotToArgTab = new int[slot+1];</span>
<span class="fc" id="L176">            argToSlotTab = new int[1+ptypeCount];</span>
<span class="fc" id="L177">            argToSlotTab[0] = slot;  // argument &quot;-1&quot; is past end of slots</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">            for (int i = 0; i &lt; epts.length; i++) {</span>
<span class="fc" id="L179">                Class&lt;?&gt; pt = epts[i];</span>
<span class="fc" id="L180">                Wrapper w = Wrapper.forBasicType(pt);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">                if (w.isDoubleWord())  --slot;</span>
<span class="fc" id="L182">                --slot;</span>
<span class="fc" id="L183">                slotToArgTab[slot] = i+1; // &quot;+1&quot; see argSlotToParameter note</span>
<span class="fc" id="L184">                argToSlotTab[1+i]  = slot;</span>
            }
<span class="pc bpc" id="L186" title="1 of 4 branches missed.">            assert(slot == 0);  // filled the table</span>
        }
<span class="fc" id="L188">        this.primCounts = pack(lrc, prc, lac, pac);</span>
<span class="fc" id="L189">        this.argCounts = pack(rslotCount, rtypeCount, pslotCount, ptypeCount);</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (slotToArgTab == null) {</span>
<span class="fc" id="L191">            int slot = ptypeCount; // first arg is deepest in stack</span>
<span class="fc" id="L192">            slotToArgTab = new int[slot+1];</span>
<span class="fc" id="L193">            argToSlotTab = new int[1+ptypeCount];</span>
<span class="fc" id="L194">            argToSlotTab[0] = slot;  // argument &quot;-1&quot; is past end of slots</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            for (int i = 0; i &lt; ptypeCount; i++) {</span>
<span class="fc" id="L196">                --slot;</span>
<span class="fc" id="L197">                slotToArgTab[slot] = i+1; // &quot;+1&quot; see argSlotToParameter note</span>
<span class="fc" id="L198">                argToSlotTab[1+i]  = slot;</span>
            }
        }
<span class="fc" id="L201">        this.argToSlotTable = argToSlotTab;</span>
<span class="fc" id="L202">        this.slotToArgTable = slotToArgTab;</span>

<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        if (pslotCount &gt;= 256)  throw newIllegalArgumentException(&quot;too many arguments&quot;);</span>

        // send a few bits down to the JVM:
<span class="fc" id="L207">        this.vmslots = parameterSlotCount();</span>

<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (basicType == erasedType) {</span>
<span class="fc" id="L210">            lambdaForms = new LambdaForm[LF_LIMIT];</span>
        } else {
<span class="fc" id="L212">            lambdaForms = null;  // could be basicType.form().lambdaForms;</span>
        }
<span class="fc" id="L214">    }</span>

    private static long pack(int a, int b, int c, int d) {
<span class="pc bpc" id="L217" title="1 of 4 branches missed.">        assert(((a|b|c|d) &amp; ~0xFFFF) == 0);</span>
<span class="fc" id="L218">        long hw = ((a &lt;&lt; 16) | b), lw = ((c &lt;&lt; 16) | d);</span>
<span class="fc" id="L219">        return (hw &lt;&lt; 32) | lw;</span>
    }
    private static char unpack(long packed, int word) { // word==0 =&gt; return a, ==3 =&gt; return d
<span class="pc bpc" id="L222" title="1 of 4 branches missed.">        assert(word &lt;= 3);</span>
<span class="fc" id="L223">        return (char)(packed &gt;&gt; ((3-word) * 16));</span>
    }

    public int parameterCount() {                      // # outgoing values
<span class="nc" id="L227">        return unpack(argCounts, 3);</span>
    }
    public int parameterSlotCount() {                  // # outgoing interpreter slots
<span class="fc" id="L230">        return unpack(argCounts, 2);</span>
    }
    public int returnCount() {                         // = 0 (V), or 1
<span class="nc" id="L233">        return unpack(argCounts, 1);</span>
    }
    public int returnSlotCount() {                     // = 0 (V), 2 (J/D), or 1
<span class="nc" id="L236">        return unpack(argCounts, 0);</span>
    }
    public int primitiveParameterCount() {
<span class="nc" id="L239">        return unpack(primCounts, 3);</span>
    }
    public int longPrimitiveParameterCount() {
<span class="nc" id="L242">        return unpack(primCounts, 2);</span>
    }
    public int primitiveReturnCount() {                // = 0 (obj), or 1
<span class="nc" id="L245">        return unpack(primCounts, 1);</span>
    }
    public int longPrimitiveReturnCount() {            // = 1 (J/D), or 0
<span class="nc" id="L248">        return unpack(primCounts, 0);</span>
    }
    public boolean hasPrimitives() {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        return primCounts != 0;</span>
    }
    public boolean hasNonVoidPrimitives() {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (primCounts == 0)  return false;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (primitiveParameterCount() != 0)  return true;</span>
<span class="nc bnc" id="L256" title="All 4 branches missed.">        return (primitiveReturnCount() != 0 &amp;&amp; returnCount() != 0);</span>
    }
    public boolean hasLongPrimitives() {
<span class="nc bnc" id="L259" title="All 2 branches missed.">        return (longPrimitiveParameterCount() | longPrimitiveReturnCount()) != 0;</span>
    }
    public int parameterToArgSlot(int i) {
<span class="fc" id="L262">        return argToSlotTable[1+i];</span>
    }
    public int argSlotToParameter(int argSlot) {
        // Note:  Empty slots are represented by zero in this table.
        // Valid arguments slots contain incremented entries, so as to be non-zero.
        // We return -1 the caller to mean an empty slot.
<span class="nc" id="L268">        return slotToArgTable[argSlot] - 1;</span>
    }

    static MethodTypeForm findForm(MethodType mt) {
<span class="fc" id="L272">        MethodType erased = canonicalize(mt, ERASE, ERASE);</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">        if (erased == null) {</span>
            // It is already erased.  Make a new MethodTypeForm.
<span class="fc" id="L275">            return new MethodTypeForm(mt);</span>
        } else {
            // Share the MethodTypeForm with the erased version.
<span class="fc" id="L278">            return erased.form();</span>
        }
    }

    /** Codes for {@link #canonicalize(java.lang.Class, int)}.
     * ERASE means change every reference to {@code Object}.
     * WRAP means convert primitives (including {@code void} to their
     * corresponding wrapper types.  UNWRAP means the reverse of WRAP.
     * INTS means convert all non-void primitive types to int or long,
     * according to size.  LONGS means convert all non-void primitives
     * to long, regardless of size.  RAW_RETURN means convert a type
     * (assumed to be a return type) to int if it is smaller than an int,
     * or if it is void.
     */
    public static final int NO_CHANGE = 0, ERASE = 1, WRAP = 2, UNWRAP = 3, INTS = 4, LONGS = 5, RAW_RETURN = 6;

    /** Canonicalize the types in the given method type.
     * If any types change, intern the new type, and return it.
     * Otherwise return null.
     */
    public static MethodType canonicalize(MethodType mt, int howRet, int howArgs) {
<span class="fc" id="L299">        Class&lt;?&gt;[] ptypes = mt.ptypes();</span>
<span class="fc" id="L300">        Class&lt;?&gt;[] ptc = MethodTypeForm.canonicalizes(ptypes, howArgs);</span>
<span class="fc" id="L301">        Class&lt;?&gt; rtype = mt.returnType();</span>
<span class="fc" id="L302">        Class&lt;?&gt; rtc = MethodTypeForm.canonicalize(rtype, howRet);</span>
<span class="fc bfc" id="L303" title="All 4 branches covered.">        if (ptc == null &amp;&amp; rtc == null) {</span>
            // It is already canonical.
<span class="fc" id="L305">            return null;</span>
        }
        // Find the erased version of the method type:
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (rtc == null)  rtc = rtype;</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">        if (ptc == null)  ptc = ptypes;</span>
<span class="fc" id="L310">        return MethodType.makeImpl(rtc, ptc, true);</span>
    }

    /** Canonicalize the given return or param type.
     *  Return null if the type is already canonicalized.
     */
    static Class&lt;?&gt; canonicalize(Class&lt;?&gt; t, int how) {
        Class&lt;?&gt; ct;
<span class="fc bfc" id="L318" title="All 2 branches covered.">        if (t == Object.class) {</span>
            // no change, ever
<span class="fc bfc" id="L320" title="All 2 branches covered.">        } else if (!t.isPrimitive()) {</span>
<span class="pc bpc" id="L321" title="2 of 3 branches missed.">            switch (how) {</span>
                case UNWRAP:
<span class="nc" id="L323">                    ct = Wrapper.asPrimitiveType(t);</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">                    if (ct != t)  return ct;</span>
                    break;
                case RAW_RETURN:
                case ERASE:
<span class="pc" id="L328">                    return Object.class;</span>
            }
<span class="fc bfc" id="L330" title="All 2 branches covered.">        } else if (t == void.class) {</span>
            // no change, usually
<span class="pc bpc" id="L332" title="1 of 3 branches missed.">            switch (how) {</span>
                case RAW_RETURN:
<span class="nc" id="L334">                    return int.class;</span>
                case WRAP:
<span class="fc" id="L336">                    return Void.class;</span>
            }
        } else {
            // non-void primitive
<span class="pc bpc" id="L340" title="3 of 5 branches missed.">            switch (how) {</span>
                case WRAP:
<span class="fc" id="L342">                    return Wrapper.asWrapperType(t);</span>
                case INTS:
<span class="nc bnc" id="L344" title="All 4 branches missed.">                    if (t == int.class || t == long.class)</span>
<span class="nc" id="L345">                        return null;  // no change</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">                    if (t == double.class)</span>
<span class="nc" id="L347">                        return long.class;</span>
<span class="nc" id="L348">                    return int.class;</span>
                case LONGS:
<span class="nc bnc" id="L350" title="All 2 branches missed.">                    if (t == long.class)</span>
<span class="nc" id="L351">                        return null;  // no change</span>
<span class="nc" id="L352">                    return long.class;</span>
                case RAW_RETURN:
<span class="nc bnc" id="L354" title="All 8 branches missed.">                    if (t == int.class || t == long.class ||</span>
                        t == float.class || t == double.class)
<span class="nc" id="L356">                        return null;  // no change</span>
                    // everything else returns as an int
<span class="nc" id="L358">                    return int.class;</span>
            }
        }
        // no change; return null to signify
<span class="fc" id="L362">        return null;</span>
    }

    /** Canonicalize each param type in the given array.
     *  Return null if all types are already canonicalized.
     */
    static Class&lt;?&gt;[] canonicalizes(Class&lt;?&gt;[] ts, int how) {
<span class="fc" id="L369">        Class&lt;?&gt;[] cs = null;</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">        for (int imax = ts.length, i = 0; i &lt; imax; i++) {</span>
<span class="fc" id="L371">            Class&lt;?&gt; c = canonicalize(ts[i], how);</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">            if (c == void.class)</span>
<span class="nc" id="L373">                c = null;  // a Void parameter was unwrapped to void; ignore</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">            if (c != null) {</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">                if (cs == null)</span>
<span class="fc" id="L376">                    cs = ts.clone();</span>
<span class="fc" id="L377">                cs[i] = c;</span>
            }
        }
<span class="fc" id="L380">        return cs;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L385">        return &quot;Form&quot;+erasedType;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>