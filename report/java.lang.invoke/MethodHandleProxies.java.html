<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MethodHandleProxies.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">MethodHandleProxies.java</span></div><h1>MethodHandleProxies.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.invoke;

import java.lang.reflect.*;
import java.security.AccessController;
import java.security.PrivilegedAction;
import sun.invoke.WrapperInstance;
import java.util.ArrayList;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;
import sun.reflect.misc.ReflectUtil;

/**
 * This class consists exclusively of static methods that help adapt
 * method handles to other JVM types, such as interfaces.
 */
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">public class MethodHandleProxies {</span>

<span class="nc" id="L43">    private MethodHandleProxies() { }  // do not instantiate</span>

    /**
     * Produces an instance of the given single-method interface which redirects
     * its calls to the given method handle.
     * &lt;p&gt;
     * A single-method interface is an interface which declares a uniquely named method.
     * When determining the uniquely named method of a single-method interface,
     * the public {@code Object} methods ({@code toString}, {@code equals}, {@code hashCode})
     * are disregarded.  For example, {@link java.util.Comparator} is a single-method interface,
     * even though it re-declares the {@code Object.equals} method.
     * &lt;p&gt;
     * The interface must be public.  No additional access checks are performed.
     * &lt;p&gt;
     * The resulting instance of the required type will respond to
     * invocation of the type's uniquely named method by calling
     * the given target on the incoming arguments,
     * and returning or throwing whatever the target
     * returns or throws.  The invocation will be as if by
     * {@code target.invoke}.
     * The target's type will be checked before the
     * instance is created, as if by a call to {@code asType},
     * which may result in a {@code WrongMethodTypeException}.
     * &lt;p&gt;
     * The uniquely named method is allowed to be multiply declared,
     * with distinct type descriptors.  (E.g., it can be overloaded,
     * or can possess bridge methods.)  All such declarations are
     * connected directly to the target method handle.
     * Argument and return types are adjusted by {@code asType}
     * for each individual declaration.
     * &lt;p&gt;
     * The wrapper instance will implement the requested interface
     * and its super-types, but no other single-method interfaces.
     * This means that the instance will not unexpectedly
     * pass an {@code instanceof} test for any unrequested type.
     * &lt;p style=&quot;font-size:smaller;&quot;&gt;
     * &lt;em&gt;Implementation Note:&lt;/em&gt;
     * Therefore, each instance must implement a unique single-method interface.
     * Implementations may not bundle together
     * multiple single-method interfaces onto single implementation classes
     * in the style of {@link java.awt.AWTEventMulticaster}.
     * &lt;p&gt;
     * The method handle may throw an &lt;em&gt;undeclared exception&lt;/em&gt;,
     * which means any checked exception (or other checked throwable)
     * not declared by the requested type's single abstract method.
     * If this happens, the throwable will be wrapped in an instance of
     * {@link java.lang.reflect.UndeclaredThrowableException UndeclaredThrowableException}
     * and thrown in that wrapped form.
     * &lt;p&gt;
     * Like {@link java.lang.Integer#valueOf Integer.valueOf},
     * {@code asInterfaceInstance} is a factory method whose results are defined
     * by their behavior.
     * It is not guaranteed to return a new instance for every call.
     * &lt;p&gt;
     * Because of the possibility of {@linkplain java.lang.reflect.Method#isBridge bridge methods}
     * and other corner cases, the interface may also have several abstract methods
     * with the same name but having distinct descriptors (types of returns and parameters).
     * In this case, all the methods are bound in common to the one given target.
     * The type check and effective {@code asType} conversion is applied to each
     * method type descriptor, and all abstract methods are bound to the target in common.
     * Beyond this type check, no further checks are made to determine that the
     * abstract methods are related in any way.
     * &lt;p&gt;
     * Future versions of this API may accept additional types,
     * such as abstract classes with single abstract methods.
     * Future versions of this API may also equip wrapper instances
     * with one or more additional public &quot;marker&quot; interfaces.
     * &lt;p&gt;
     * If a security manager is installed, this method is caller sensitive.
     * During any invocation of the target method handle via the returned wrapper,
     * the original creator of the wrapper (the caller) will be visible
     * to context checks requested by the security manager.
     *
     * @param &lt;T&gt; the desired type of the wrapper, a single-method interface
     * @param intfc a class object representing {@code T}
     * @param target the method handle to invoke from the wrapper
     * @return a correctly-typed wrapper for the given target
     * @throws NullPointerException if either argument is null
     * @throws IllegalArgumentException if the {@code intfc} is not a
     *         valid argument to this method
     * @throws WrongMethodTypeException if the target cannot
     *         be converted to the type required by the requested interface
     */
    // Other notes to implementors:
    // &lt;p&gt;
    // No stable mapping is promised between the single-method interface and
    // the implementation class C.  Over time, several implementation
    // classes might be used for the same type.
    // &lt;p&gt;
    // If the implementation is able
    // to prove that a wrapper of the required type
    // has already been created for a given
    // method handle, or for another method handle with the
    // same behavior, the implementation may return that wrapper in place of
    // a new wrapper.
    // &lt;p&gt;
    // This method is designed to apply to common use cases
    // where a single method handle must interoperate with
    // an interface that implements a function-like
    // API.  Additional variations, such as single-abstract-method classes with
    // private constructors, or interfaces with multiple but related
    // entry points, must be covered by hand-written or automatically
    // generated adapter classes.
    //
    @CallerSensitive
    public static
    &lt;T&gt; T asInterfaceInstance(final Class&lt;T&gt; intfc, final MethodHandle target) {
<span class="fc bfc" id="L150" title="All 4 branches covered.">        if (!intfc.isInterface() || !Modifier.isPublic(intfc.getModifiers()))</span>
<span class="fc" id="L151">            throw new IllegalArgumentException(&quot;not a public interface: &quot;+intfc.getName());</span>
        final MethodHandle mh;
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">        if (System.getSecurityManager() != null) {</span>
<span class="nc" id="L154">            final Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            final ClassLoader ccl = caller != null ? caller.getClassLoader() : null;</span>
<span class="nc" id="L156">            ReflectUtil.checkProxyPackageAccess(ccl, intfc);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">            mh = ccl != null ? bindCaller(target, caller) : target;</span>
<span class="nc" id="L158">        } else {</span>
<span class="fc" id="L159">            mh = target;</span>
        }
<span class="fc" id="L161">        ClassLoader proxyLoader = intfc.getClassLoader();</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (proxyLoader == null) {</span>
<span class="fc" id="L163">            ClassLoader cl = Thread.currentThread().getContextClassLoader(); // avoid use of BCP</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            proxyLoader = cl != null ? cl : ClassLoader.getSystemClassLoader();</span>
        }
<span class="fc" id="L166">        final Method[] methods = getSingleNameMethods(intfc);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (methods == null)</span>
<span class="fc" id="L168">            throw new IllegalArgumentException(&quot;not a single-method interface: &quot;+intfc.getName());</span>
<span class="fc" id="L169">        final MethodHandle[] vaTargets = new MethodHandle[methods.length];</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="fc" id="L171">            Method sm = methods[i];</span>
<span class="fc" id="L172">            MethodType smMT = MethodType.methodType(sm.getReturnType(), sm.getParameterTypes());</span>
<span class="fc" id="L173">            MethodHandle checkTarget = mh.asType(smMT);  // make throw WMT</span>
<span class="fc" id="L174">            checkTarget = checkTarget.asType(checkTarget.type().changeReturnType(Object.class));</span>
<span class="fc" id="L175">            vaTargets[i] = checkTarget.asSpreader(Object[].class, smMT.parameterCount());</span>
        }
<span class="fc" id="L177">        final InvocationHandler ih = new InvocationHandler() {</span>
                private Object getArg(String name) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">                    if ((Object)name == &quot;getWrapperInstanceTarget&quot;)  return target;</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                    if ((Object)name == &quot;getWrapperInstanceType&quot;)    return intfc;</span>
<span class="nc" id="L181">                    throw new AssertionError();</span>
                }
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
<span class="fc bfc" id="L184" title="All 2 branches covered.">                    for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">                        if (method.equals(methods[i]))</span>
<span class="fc" id="L186">                            return vaTargets[i].invokeExact(args);</span>
                    }
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                    if (method.getDeclaringClass() == WrapperInstance.class)</span>
<span class="nc" id="L189">                        return getArg(method.getName());</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">                    if (isObjectMethod(method))</span>
<span class="fc" id="L191">                        return callObjectMethod(proxy, method, args);</span>
<span class="nc" id="L192">                    throw new InternalError(&quot;bad proxy method: &quot;+method);</span>
                }
            };

        final Object proxy;
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (System.getSecurityManager() != null) {</span>
            // sun.invoke.WrapperInstance is a restricted interface not accessible
            // by any non-null class loader.
<span class="nc" id="L200">            final ClassLoader loader = proxyLoader;</span>
<span class="nc" id="L201">            proxy = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() {</span>
                public Object run() {
<span class="nc" id="L203">                    return Proxy.newProxyInstance(</span>
                            loader,
                            new Class&lt;?&gt;[]{ intfc, WrapperInstance.class },
                            ih);
                }
            });
<span class="nc" id="L209">        } else {</span>
<span class="fc" id="L210">            proxy = Proxy.newProxyInstance(proxyLoader,</span>
                                           new Class&lt;?&gt;[]{ intfc, WrapperInstance.class },
                                           ih);
        }
<span class="fc" id="L214">        return intfc.cast(proxy);</span>
    }

    private static MethodHandle bindCaller(MethodHandle target, Class&lt;?&gt; hostClass) {
<span class="nc" id="L218">        MethodHandle cbmh = MethodHandleImpl.bindCaller(target, hostClass);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (target.isVarargsCollector()) {</span>
<span class="nc" id="L220">            MethodType type = cbmh.type();</span>
<span class="nc" id="L221">            int arity = type.parameterCount();</span>
<span class="nc" id="L222">            return cbmh.asVarargsCollector(type.parameterType(arity-1));</span>
        }
<span class="nc" id="L224">        return cbmh;</span>
    }

    /**
     * Determines if the given object was produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
     * @param x any reference
     * @return true if the reference is not null and points to an object produced by {@code asInterfaceInstance}
     */
    public static
    boolean isWrapperInstance(Object x) {
<span class="nc" id="L234">        return x instanceof WrapperInstance;</span>
    }

    private static WrapperInstance asWrapperInstance(Object x) {
        try {
<span class="nc bnc" id="L239" title="All 2 branches missed.">            if (x != null)</span>
<span class="nc" id="L240">                return (WrapperInstance) x;</span>
<span class="nc" id="L241">        } catch (ClassCastException ex) {</span>
<span class="nc" id="L242">        }</span>
<span class="nc" id="L243">        throw new IllegalArgumentException(&quot;not a wrapper instance&quot;);</span>
    }

    /**
     * Produces or recovers a target method handle which is behaviorally
     * equivalent to the unique method of this wrapper instance.
     * The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
     * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
     * @param x any reference
     * @return a method handle implementing the unique method
     * @throws IllegalArgumentException if the reference x is not to a wrapper instance
     */
    public static
    MethodHandle wrapperInstanceTarget(Object x) {
<span class="nc" id="L257">        return asWrapperInstance(x).getWrapperInstanceTarget();</span>
    }

    /**
     * Recovers the unique single-method interface type for which this wrapper instance was created.
     * The object {@code x} must have been produced by a call to {@link #asInterfaceInstance asInterfaceInstance}.
     * This requirement may be tested via {@link #isWrapperInstance isWrapperInstance}.
     * @param x any reference
     * @return the single-method interface type for which the wrapper was created
     * @throws IllegalArgumentException if the reference x is not to a wrapper instance
     */
    public static
    Class&lt;?&gt; wrapperInstanceType(Object x) {
<span class="nc" id="L270">        return asWrapperInstance(x).getWrapperInstanceType();</span>
    }

    private static
    boolean isObjectMethod(Method m) {
<span class="pc bpc" id="L275" title="3 of 14 branches missed.">        switch (m.getName()) {</span>
        case &quot;toString&quot;:
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">            return (m.getReturnType() == String.class</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">                    &amp;&amp; m.getParameterTypes().length == 0);</span>
        case &quot;hashCode&quot;:
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">            return (m.getReturnType() == int.class</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">                    &amp;&amp; m.getParameterTypes().length == 0);</span>
        case &quot;equals&quot;:
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">            return (m.getReturnType() == boolean.class</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                    &amp;&amp; m.getParameterTypes().length == 1</span>
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">                    &amp;&amp; m.getParameterTypes()[0] == Object.class);</span>
        }
<span class="fc" id="L287">        return false;</span>
    }

    private static
    Object callObjectMethod(Object self, Method m, Object[] args) {
<span class="pc bpc" id="L292" title="2 of 4 branches missed.">        assert(isObjectMethod(m)) : m;</span>
<span class="pc bpc" id="L293" title="5 of 14 branches missed.">        switch (m.getName()) {</span>
        case &quot;toString&quot;:
<span class="fc" id="L295">            return self.getClass().getName() + &quot;@&quot; + Integer.toHexString(self.hashCode());</span>
        case &quot;hashCode&quot;:
<span class="fc" id="L297">            return System.identityHashCode(self);</span>
        case &quot;equals&quot;:
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">            return (self == args[0]);</span>
        }
<span class="nc" id="L301">        return null;</span>
    }

    private static
    Method[] getSingleNameMethods(Class&lt;?&gt; intfc) {
<span class="fc" id="L306">        ArrayList&lt;Method&gt; methods = new ArrayList&lt;Method&gt;();</span>
<span class="fc" id="L307">        String uniqueName = null;</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        for (Method m : intfc.getMethods()) {</span>
<span class="fc bfc" id="L309" title="All 2 branches covered.">            if (isObjectMethod(m))  continue;</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            if (!Modifier.isAbstract(m.getModifiers()))  continue;</span>
<span class="fc" id="L311">            String mname = m.getName();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">            if (uniqueName == null)</span>
<span class="fc" id="L313">                uniqueName = mname;</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">            else if (!uniqueName.equals(mname))</span>
<span class="fc" id="L315">                return null;  // too many abstract methods</span>
<span class="fc" id="L316">            methods.add(m);</span>
        }
<span class="fc bfc" id="L318" title="All 2 branches covered.">        if (uniqueName == null)  return null;</span>
<span class="fc" id="L319">        return methods.toArray(new Method[methods.size()]);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>