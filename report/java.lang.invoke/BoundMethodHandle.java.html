<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BoundMethodHandle.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">BoundMethodHandle.java</span></div><h1>BoundMethodHandle.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.invoke;

import static jdk.internal.org.objectweb.asm.Opcodes.*;
import static java.lang.invoke.LambdaForm.basicTypes;
import static java.lang.invoke.MethodHandleNatives.Constants.REF_invokeStatic;
import static java.lang.invoke.MethodHandleStatics.*;

import java.lang.invoke.LambdaForm.Name;
import java.lang.invoke.LambdaForm.NamedFunction;
import java.lang.invoke.MethodHandles.Lookup;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.HashMap;

import sun.invoke.util.ValueConversions;
import sun.invoke.util.Wrapper;

import jdk.internal.org.objectweb.asm.ClassWriter;
import jdk.internal.org.objectweb.asm.MethodVisitor;
import jdk.internal.org.objectweb.asm.Type;

/**
 * The flavor of method handle which emulates an invoke instruction
 * on a predetermined argument.  The JVM dispatches to the correct method
 * when the handle is created, not when it is invoked.
 *
 * All bound arguments are encapsulated in dedicated species.
 */
/* non-public */ abstract class BoundMethodHandle extends MethodHandle {

    /* non-public */ BoundMethodHandle(MethodType type, LambdaForm form) {
<span class="fc" id="L57">        super(type, form);</span>
<span class="fc" id="L58">    }</span>

    //
    // BMH API and internals
    //

    static MethodHandle bindSingle(MethodType type, LambdaForm form, char xtype, Object x) {
        // for some type signatures, there exist pre-defined concrete BMH classes
        try {
<span class="pc bpc" id="L67" title="4 of 6 branches missed.">            switch (xtype) {</span>
            case 'L':
<span class="fc" id="L69">                if (true)  return bindSingle(type, form, x);  // Use known fast path.</span>
                return (BoundMethodHandle) SpeciesData.EMPTY.extendWithType('L').constructor[0].invokeBasic(type, form, x);
            case 'I':
<span class="fc" id="L72">                return (BoundMethodHandle) SpeciesData.EMPTY.extendWithType('I').constructor[0].invokeBasic(type, form, ValueConversions.widenSubword(x));</span>
            case 'J':
<span class="nc" id="L74">                return (BoundMethodHandle) SpeciesData.EMPTY.extendWithType('J').constructor[0].invokeBasic(type, form, (long) x);</span>
            case 'F':
<span class="nc" id="L76">                return (BoundMethodHandle) SpeciesData.EMPTY.extendWithType('F').constructor[0].invokeBasic(type, form, (float) x);</span>
            case 'D':
<span class="nc" id="L78">                return (BoundMethodHandle) SpeciesData.EMPTY.extendWithType('D').constructor[0].invokeBasic(type, form, (double) x);</span>
<span class="nc" id="L79">            default : throw new InternalError(&quot;unexpected xtype: &quot; + xtype);</span>
            }
<span class="nc" id="L81">        } catch (Throwable t) {</span>
<span class="nc" id="L82">            throw newInternalError(t);</span>
        }
    }

    static MethodHandle bindSingle(MethodType type, LambdaForm form, Object x) {
<span class="fc" id="L87">            return new Species_L(type, form, x);</span>
    }

    MethodHandle cloneExtend(MethodType type, LambdaForm form, char xtype, Object x) {
        try {
<span class="pc bpc" id="L92" title="1 of 6 branches missed.">            switch (xtype) {</span>
<span class="fc" id="L93">            case 'L': return cloneExtendL(type, form, x);</span>
<span class="fc" id="L94">            case 'I': return cloneExtendI(type, form, ValueConversions.widenSubword(x));</span>
<span class="fc" id="L95">            case 'J': return cloneExtendJ(type, form, (long) x);</span>
<span class="fc" id="L96">            case 'F': return cloneExtendF(type, form, (float) x);</span>
<span class="fc" id="L97">            case 'D': return cloneExtendD(type, form, (double) x);</span>
            }
<span class="nc" id="L99">        } catch (Throwable t) {</span>
<span class="nc" id="L100">            throw newInternalError(t);</span>
<span class="nc" id="L101">        }</span>
<span class="nc" id="L102">        throw new InternalError(&quot;unexpected type: &quot; + xtype);</span>
    }

    @Override
    MethodHandle bindArgument(int pos, char basicType, Object value) {
<span class="fc" id="L107">        MethodType type = type().dropParameterTypes(pos, pos+1);</span>
<span class="fc" id="L108">        LambdaForm form = internalForm().bind(1+pos, speciesData());</span>
<span class="fc" id="L109">        return cloneExtend(type, form, basicType, value);</span>
    }

    @Override
    MethodHandle dropArguments(MethodType srcType, int pos, int drops) {
<span class="fc" id="L114">        LambdaForm form = internalForm().addArguments(pos, srcType.parameterList().subList(pos, pos+drops));</span>
        try {
<span class="fc" id="L116">             return clone(srcType, form);</span>
<span class="nc" id="L117">         } catch (Throwable t) {</span>
<span class="nc" id="L118">             throw newInternalError(t);</span>
         }
    }

    @Override
    MethodHandle permuteArguments(MethodType newType, int[] reorder) {
        try {
<span class="fc" id="L125">             return clone(newType, form.permuteArguments(1, reorder, basicTypes(newType.parameterList())));</span>
<span class="nc" id="L126">         } catch (Throwable t) {</span>
<span class="nc" id="L127">             throw newInternalError(t);</span>
         }
    }

    static final String EXTENSION_TYPES = &quot;LIJFD&quot;;
    static final byte INDEX_L = 0, INDEX_I = 1, INDEX_J = 2, INDEX_F = 3, INDEX_D = 4;
    static byte extensionIndex(char type) {
<span class="fc" id="L134">        int i = EXTENSION_TYPES.indexOf(type);</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (i &lt; 0)  throw new InternalError();</span>
<span class="fc" id="L136">        return (byte) i;</span>
    }

    /**
     * Return the {@link SpeciesData} instance representing this BMH species. All subclasses must provide a
     * static field containing this value, and they must accordingly implement this method.
     */
    protected abstract SpeciesData speciesData();

    @Override
    final Object internalProperties() {
<span class="nc" id="L147">        return &quot;/BMH=&quot;+internalValues();</span>
    }

    @Override
    final Object internalValues() {
<span class="nc" id="L152">        Object[] boundValues = new Object[speciesData().fieldCount()];</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        for (int i = 0; i &lt; boundValues.length; ++i) {</span>
<span class="nc" id="L154">            boundValues[i] = arg(i);</span>
        }
<span class="nc" id="L156">        return Arrays.asList(boundValues);</span>
    }

    public final Object arg(int i) {
        try {
<span class="nc bnc" id="L161" title="All 6 branches missed.">            switch (speciesData().fieldType(i)) {</span>
<span class="nc" id="L162">            case 'L': return argL(i);</span>
<span class="nc" id="L163">            case 'I': return argI(i);</span>
<span class="nc" id="L164">            case 'F': return argF(i);</span>
<span class="nc" id="L165">            case 'D': return argD(i);</span>
<span class="nc" id="L166">            case 'J': return argJ(i);</span>
            }
<span class="nc" id="L168">        } catch (Throwable ex) {</span>
<span class="nc" id="L169">            throw newInternalError(ex);</span>
<span class="nc" id="L170">        }</span>
<span class="nc" id="L171">        throw new InternalError(&quot;unexpected type: &quot; + speciesData().types+&quot;.&quot;+i);</span>
    }
<span class="nc" id="L173">    public final Object argL(int i) throws Throwable { return          speciesData().getters[i].invokeBasic(this); }</span>
<span class="nc" id="L174">    public final int    argI(int i) throws Throwable { return (int)    speciesData().getters[i].invokeBasic(this); }</span>
<span class="nc" id="L175">    public final float  argF(int i) throws Throwable { return (float)  speciesData().getters[i].invokeBasic(this); }</span>
<span class="nc" id="L176">    public final double argD(int i) throws Throwable { return (double) speciesData().getters[i].invokeBasic(this); }</span>
<span class="nc" id="L177">    public final long   argJ(int i) throws Throwable { return (long)   speciesData().getters[i].invokeBasic(this); }</span>

    //
    // cloning API
    //

    public abstract BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable;
    public abstract BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable;
    public abstract BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int    narg) throws Throwable;
    public abstract BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long   narg) throws Throwable;
    public abstract BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float  narg) throws Throwable;
    public abstract BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable;

    // The following is a grossly irregular hack:
    @Override MethodHandle reinvokerTarget() {
        try {
<span class="nc" id="L193">            return (MethodHandle) argL(0);</span>
<span class="nc" id="L194">        } catch (Throwable ex) {</span>
<span class="nc" id="L195">            throw newInternalError(ex);</span>
        }
    }

    //
    // concrete BMH classes required to close bootstrap loops
    //

    private  // make it private to force users to access the enclosing class first
    static final class Species_L extends BoundMethodHandle {
        final Object argL0;
        public Species_L(MethodType mt, LambdaForm lf, Object argL0) {
<span class="fc" id="L207">            super(mt, lf);</span>
<span class="fc" id="L208">            this.argL0 = argL0;</span>
<span class="fc" id="L209">        }</span>
        // The following is a grossly irregular hack:
<span class="fc" id="L211">        @Override MethodHandle reinvokerTarget() { return (MethodHandle) argL0; }</span>
        @Override
        public SpeciesData speciesData() {
<span class="fc" id="L214">            return SPECIES_DATA;</span>
        }
<span class="fc" id="L216">        public static final SpeciesData SPECIES_DATA = SpeciesData.getForClass(&quot;L&quot;, Species_L.class);</span>
        @Override
        public final BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable {
<span class="fc" id="L219">            return new Species_L(mt, lf, argL0);</span>
        }
        @Override
        public final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable {
<span class="fc" id="L223">            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_L).constructor[0].invokeBasic(mt, lf, argL0, narg);</span>
        }
        @Override
        public final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) throws Throwable {
<span class="fc" id="L227">            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_I).constructor[0].invokeBasic(mt, lf, argL0, narg);</span>
        }
        @Override
        public final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) throws Throwable {
<span class="fc" id="L231">            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_J).constructor[0].invokeBasic(mt, lf, argL0, narg);</span>
        }
        @Override
        public final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) throws Throwable {
<span class="fc" id="L235">            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_F).constructor[0].invokeBasic(mt, lf, argL0, narg);</span>
        }
        @Override
        public final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable {
<span class="fc" id="L239">            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_D).constructor[0].invokeBasic(mt, lf, argL0, narg);</span>
        }
    }

/*
    static final class Species_LL extends BoundMethodHandle {
        final Object argL0;
        final Object argL1;
        public Species_LL(MethodType mt, LambdaForm lf, Object argL0, Object argL1) {
            super(mt, lf);
            this.argL0 = argL0;
            this.argL1 = argL1;
        }
        @Override
        public SpeciesData speciesData() {
            return SPECIES_DATA;
        }
        public static final SpeciesData SPECIES_DATA = SpeciesData.getForClass(&quot;LL&quot;, Species_LL.class);
        @Override
        public final BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable {
            return new Species_LL(mt, lf, argL0, argL1);
        }
        @Override
        public final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable {
            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_L).constructor[0].invokeBasic(mt, lf, argL0, argL1, narg);
        }
        @Override
        public final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) throws Throwable {
            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_I).constructor[0].invokeBasic(mt, lf, argL0, argL1, narg);
        }
        @Override
        public final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) throws Throwable {
            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_J).constructor[0].invokeBasic(mt, lf, argL0, argL1, narg);
        }
        @Override
        public final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) throws Throwable {
            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_F).constructor[0].invokeBasic(mt, lf, argL0, argL1, narg);
        }
        @Override
        public final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable {
            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_D).constructor[0].invokeBasic(mt, lf, argL0, argL1, narg);
        }
    }

    static final class Species_JL extends BoundMethodHandle {
        final long argJ0;
        final Object argL1;
        public Species_JL(MethodType mt, LambdaForm lf, long argJ0, Object argL1) {
            super(mt, lf);
            this.argJ0 = argJ0;
            this.argL1 = argL1;
        }
        @Override
        public SpeciesData speciesData() {
            return SPECIES_DATA;
        }
        public static final SpeciesData SPECIES_DATA = SpeciesData.getForClass(&quot;JL&quot;, Species_JL.class);
        @Override public final long   argJ0() { return argJ0; }
        @Override public final Object argL1() { return argL1; }
        @Override
        public final BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable {
            return new Species_JL(mt, lf, argJ0, argL1);
        }
        @Override
        public final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable {
            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_L).constructor[0].invokeBasic(mt, lf, argJ0, argL1, narg);
        }
        @Override
        public final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) throws Throwable {
            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_I).constructor[0].invokeBasic(mt, lf, argJ0, argL1, narg);
        }
        @Override
        public final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) throws Throwable {
            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_J).constructor[0].invokeBasic(mt, lf, argJ0, argL1, narg);
        }
        @Override
        public final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) throws Throwable {
            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_F).constructor[0].invokeBasic(mt, lf, argJ0, argL1, narg);
        }
        @Override
        public final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable {
            return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_D).constructor[0].invokeBasic(mt, lf, argJ0, argL1, narg);
        }
    }
*/

    //
    // BMH species meta-data
    //

    /**
     * Meta-data wrapper for concrete BMH classes.
     */
<span class="fc bfc" id="L332" title="All 2 branches covered.">    static class SpeciesData {</span>
        final String                             types;
        final Class&lt;? extends BoundMethodHandle&gt; clazz;
        // Bootstrapping requires circular relations MH -&gt; BMH -&gt; SpeciesData -&gt; MH
        // Therefore, we need a non-final link in the chain.  Use array elements.
        final MethodHandle[]                     constructor;
        final MethodHandle[]                     getters;
        final SpeciesData[]                      extensions;

        public int fieldCount() {
<span class="fc" id="L342">            return types.length();</span>
        }
        public char fieldType(int i) {
<span class="nc" id="L345">            return types.charAt(i);</span>
        }

        public String toString() {
<span class="nc bnc" id="L349" title="All 2 branches missed.">            return &quot;SpeciesData[&quot;+(isPlaceholder() ? &quot;&lt;placeholder&gt;&quot; : clazz.getSimpleName())+&quot;:&quot;+types+&quot;]&quot;;</span>
        }

        /**
         * Return a {@link LambdaForm.Name} containing a {@link LambdaForm.NamedFunction} that
         * represents a MH bound to a generic invoker, which in turn forwards to the corresponding
         * getter.
         */
        Name getterName(Name mhName, int i) {
<span class="fc" id="L358">            MethodHandle mh = getters[i];</span>
<span class="pc bpc" id="L359" title="1 of 4 branches missed.">            assert(mh != null) : this+&quot;.&quot;+i;</span>
<span class="fc" id="L360">            return new Name(mh, mhName);</span>
        }

        NamedFunction getterFunction(int i) {
<span class="fc" id="L364">            return new NamedFunction(getters[i]);</span>
        }

<span class="fc" id="L367">        static final SpeciesData EMPTY = new SpeciesData(&quot;&quot;, BoundMethodHandle.class);</span>

<span class="fc" id="L369">        private SpeciesData(String types, Class&lt;? extends BoundMethodHandle&gt; clazz) {</span>
<span class="fc" id="L370">            this.types = types;</span>
<span class="fc" id="L371">            this.clazz = clazz;</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">            if (!INIT_DONE) {</span>
<span class="fc" id="L373">                this.constructor = new MethodHandle[1];</span>
<span class="fc" id="L374">                this.getters = new MethodHandle[types.length()];</span>
            } else {
<span class="fc" id="L376">                this.constructor = Factory.makeCtors(clazz, types, null);</span>
<span class="fc" id="L377">                this.getters = Factory.makeGetters(clazz, types, null);</span>
            }
<span class="fc" id="L379">            this.extensions = new SpeciesData[EXTENSION_TYPES.length()];</span>
<span class="fc" id="L380">        }</span>

        private void initForBootstrap() {
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">            assert(!INIT_DONE);</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">            if (constructor[0] == null) {</span>
<span class="fc" id="L385">                Factory.makeCtors(clazz, types, this.constructor);</span>
<span class="fc" id="L386">                Factory.makeGetters(clazz, types, this.getters);</span>
            }
<span class="fc" id="L388">        }</span>

<span class="fc" id="L390">        private SpeciesData(String types) {</span>
            // Placeholder only.
<span class="fc" id="L392">            this.types = types;</span>
<span class="fc" id="L393">            this.clazz = null;</span>
<span class="fc" id="L394">            this.constructor = null;</span>
<span class="fc" id="L395">            this.getters = null;</span>
<span class="fc" id="L396">            this.extensions = null;</span>
<span class="fc" id="L397">        }</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        private boolean isPlaceholder() { return clazz == null; }</span>

<span class="fc" id="L400">        private static final HashMap&lt;String, SpeciesData&gt; CACHE = new HashMap&lt;&gt;();</span>
<span class="fc" id="L401">        static { CACHE.put(&quot;&quot;, EMPTY); }  // make bootstrap predictable</span>
        private static final boolean INIT_DONE;  // set after &lt;clinit&gt; finishes...

        SpeciesData extendWithType(char type) {
<span class="fc" id="L405">            int i = extensionIndex(type);</span>
<span class="fc" id="L406">            SpeciesData d = extensions[i];</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">            if (d != null)  return d;</span>
<span class="fc" id="L408">            extensions[i] = d = get(types+type);</span>
<span class="fc" id="L409">            return d;</span>
        }

        SpeciesData extendWithIndex(byte index) {
<span class="fc" id="L413">            SpeciesData d = extensions[index];</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            if (d != null)  return d;</span>
<span class="nc" id="L415">            extensions[index] = d = get(types+EXTENSION_TYPES.charAt(index));</span>
<span class="nc" id="L416">            return d;</span>
        }

        private static SpeciesData get(String types) {
            // Acquire cache lock for query.
<span class="fc" id="L421">            SpeciesData d = lookupCache(types);</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">            if (!d.isPlaceholder())</span>
<span class="fc" id="L423">                return d;</span>
<span class="fc" id="L424">            synchronized (d) {</span>
                // Use synch. on the placeholder to prevent multiple instantiation of one species.
                // Creating this class forces a recursive call to getForClass.
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">                if (lookupCache(types).isPlaceholder())</span>
<span class="fc" id="L428">                    Factory.generateConcreteBMHClass(types);</span>
<span class="pc" id="L429">            }</span>
            // Reacquire cache lock.
<span class="fc" id="L431">            d = lookupCache(types);</span>
            // Class loading must have upgraded the cache.
<span class="pc bpc" id="L433" title="2 of 6 branches missed.">            assert(d != null &amp;&amp; !d.isPlaceholder());</span>
<span class="fc" id="L434">            return d;</span>
        }
        static SpeciesData getForClass(String types, Class&lt;? extends BoundMethodHandle&gt; clazz) {
            // clazz is a new class which is initializing its SPECIES_DATA field
<span class="fc" id="L438">            return updateCache(types, new SpeciesData(types, clazz));</span>
        }
        private static synchronized SpeciesData lookupCache(String types) {
<span class="fc" id="L441">            SpeciesData d = CACHE.get(types);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            if (d != null)  return d;</span>
<span class="fc" id="L443">            d = new SpeciesData(types);</span>
<span class="pc bpc" id="L444" title="1 of 4 branches missed.">            assert(d.isPlaceholder());</span>
<span class="fc" id="L445">            CACHE.put(types, d);</span>
<span class="fc" id="L446">            return d;</span>
        }
        private static synchronized SpeciesData updateCache(String types, SpeciesData d) {
            SpeciesData d2;
<span class="pc bpc" id="L450" title="1 of 6 branches missed.">            assert((d2 = CACHE.get(types)) == null || d2.isPlaceholder());</span>
<span class="pc bpc" id="L451" title="1 of 4 branches missed.">            assert(!d.isPlaceholder());</span>
<span class="fc" id="L452">            CACHE.put(types, d);</span>
<span class="fc" id="L453">            return d;</span>
        }

        static {
            // pre-fill the BMH speciesdata cache with BMH's inner classes
<span class="fc" id="L458">            final Class&lt;BoundMethodHandle&gt; rootCls = BoundMethodHandle.class;</span>
<span class="fc" id="L459">            SpeciesData d0 = BoundMethodHandle.SPECIES_DATA;  // trigger class init</span>
<span class="pc bpc" id="L460" title="1 of 6 branches missed.">            assert(d0 == null || d0 == lookupCache(&quot;&quot;)) : d0;</span>
            try {
<span class="fc bfc" id="L462" title="All 2 branches covered.">                for (Class&lt;?&gt; c : rootCls.getDeclaredClasses()) {</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">                    if (rootCls.isAssignableFrom(c)) {</span>
<span class="fc" id="L464">                        final Class&lt;? extends BoundMethodHandle&gt; cbmh = c.asSubclass(BoundMethodHandle.class);</span>
<span class="fc" id="L465">                        SpeciesData d = Factory.speciesDataFromConcreteBMHClass(cbmh);</span>
<span class="pc bpc" id="L466" title="1 of 4 branches missed.">                        assert(d != null) : cbmh.getName();</span>
<span class="pc bpc" id="L467" title="1 of 4 branches missed.">                        assert(d.clazz == cbmh);</span>
<span class="pc bpc" id="L468" title="1 of 4 branches missed.">                        assert(d == lookupCache(d.types));</span>
                    }
                }
<span class="nc" id="L471">            } catch (Throwable e) {</span>
<span class="nc" id="L472">                throw newInternalError(e);</span>
<span class="fc" id="L473">            }</span>

<span class="fc bfc" id="L475" title="All 2 branches covered.">            for (SpeciesData d : CACHE.values()) {</span>
<span class="fc" id="L476">                d.initForBootstrap();</span>
<span class="fc" id="L477">            }</span>
            // Note:  Do not simplify this, because INIT_DONE must not be
            // a compile-time constant during bootstrapping.
<span class="fc" id="L480">            INIT_DONE = Boolean.TRUE;</span>
<span class="fc" id="L481">        }</span>
    }

    static SpeciesData getSpeciesData(String types) {
<span class="fc" id="L485">        return SpeciesData.get(types);</span>
    }

    /**
     * Generation of concrete BMH classes.
     *
     * A concrete BMH species is fit for binding a number of values adhering to a
     * given type pattern. Reference types are erased.
     *
     * BMH species are cached by type pattern.
     *
     * A BMH species has a number of fields with the concrete (possibly erased) types of
     * bound values. Setters are provided as an API in BMH. Getters are exposed as MHs,
     * which can be included as names in lambda forms.
     */
<span class="pc bfc" id="L500" title="All 2 branches covered.">    static class Factory {</span>

        static final String JLO_SIG  = &quot;Ljava/lang/Object;&quot;;
        static final String JLS_SIG  = &quot;Ljava/lang/String;&quot;;
        static final String JLC_SIG  = &quot;Ljava/lang/Class;&quot;;
        static final String MH       = &quot;java/lang/invoke/MethodHandle&quot;;
        static final String MH_SIG   = &quot;L&quot;+MH+&quot;;&quot;;
        static final String BMH      = &quot;java/lang/invoke/BoundMethodHandle&quot;;
        static final String BMH_SIG  = &quot;L&quot;+BMH+&quot;;&quot;;
        static final String SPECIES_DATA     = &quot;java/lang/invoke/BoundMethodHandle$SpeciesData&quot;;
        static final String SPECIES_DATA_SIG = &quot;L&quot;+SPECIES_DATA+&quot;;&quot;;

        static final String SPECIES_PREFIX_NAME = &quot;Species_&quot;;
        static final String SPECIES_PREFIX_PATH = BMH + &quot;$&quot; + SPECIES_PREFIX_NAME;

        static final String BMHSPECIES_DATA_EWI_SIG = &quot;(B)&quot; + SPECIES_DATA_SIG;
        static final String BMHSPECIES_DATA_GFC_SIG = &quot;(&quot; + JLS_SIG + JLC_SIG + &quot;)&quot; + SPECIES_DATA_SIG;
        static final String MYSPECIES_DATA_SIG = &quot;()&quot; + SPECIES_DATA_SIG;
        static final String VOID_SIG   = &quot;()V&quot;;

        static final String SIG_INCIPIT = &quot;(Ljava/lang/invoke/MethodType;Ljava/lang/invoke/LambdaForm;&quot;;

<span class="fc" id="L522">        static final Class&lt;?&gt;[] TYPES = new Class&lt;?&gt;[] { Object.class, int.class, long.class, float.class, double.class };</span>

<span class="fc" id="L524">        static final String[] E_THROWABLE = new String[] { &quot;java/lang/Throwable&quot; };</span>

        /**
         * Generate a concrete subclass of BMH for a given combination of bound types.
         *
         * A concrete BMH species adheres to the following schema:
         *
         * &lt;pre&gt;
         * class Species_[[types]] extends BoundMethodHandle {
         *     [[fields]]
         *     final SpeciesData speciesData() { return SpeciesData.get(&quot;[[types]]&quot;); }
         * }
         * &lt;/pre&gt;
         *
         * The {@code [[types]]} signature is precisely the string that is passed to this
         * method.
         *
         * The {@code [[fields]]} section consists of one field definition per character in
         * the type signature, adhering to the naming schema described in the definition of
         * {@link #makeFieldName}.
         *
         * For example, a concrete BMH species for two reference and one integral bound values
         * would have the following shape:
         *
         * &lt;pre&gt;
         * class BoundMethodHandle { ... private static
         * final class Species_LLI extends BoundMethodHandle {
         *     final Object argL0;
         *     final Object argL1;
         *     final int argI2;
         *     public Species_LLI(MethodType mt, LambdaForm lf, Object argL0, Object argL1, int argI2) {
         *         super(mt, lf);
         *         this.argL0 = argL0;
         *         this.argL1 = argL1;
         *         this.argI2 = argI2;
         *     }
         *     public final SpeciesData speciesData() { return SPECIES_DATA; }
         *     public static final SpeciesData SPECIES_DATA = SpeciesData.getForClass(&quot;LLI&quot;, Species_LLI.class);
         *     public final BoundMethodHandle clone(MethodType mt, LambdaForm lf) {
         *         return SPECIES_DATA.constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2);
         *     }
         *     public final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) {
         *         return SPECIES_DATA.extendWithIndex(INDEX_L).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
         *     }
         *     public final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) {
         *         return SPECIES_DATA.extendWithIndex(INDEX_I).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
         *     }
         *     public final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) {
         *         return SPECIES_DATA.extendWithIndex(INDEX_J).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
         *     }
         *     public final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) {
         *         return SPECIES_DATA.extendWithIndex(INDEX_F).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
         *     }
         *     public final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) {
         *         return SPECIES_DATA.extendWithIndex(INDEX_D).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
         *     }
         * }
         * &lt;/pre&gt;
         *
         * @param types the type signature, wherein reference types are erased to 'L'
         * @return the generated concrete BMH class
         */
        static Class&lt;? extends BoundMethodHandle&gt; generateConcreteBMHClass(String types) {
<span class="fc" id="L587">            final ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>

<span class="fc" id="L589">            final String className  = SPECIES_PREFIX_PATH + types;</span>
<span class="fc" id="L590">            final String sourceFile = SPECIES_PREFIX_NAME + types;</span>
<span class="fc" id="L591">            cw.visit(V1_6, ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, BMH, null);</span>
<span class="fc" id="L592">            cw.visitSource(sourceFile, null);</span>

            // emit static types and SPECIES_DATA fields
<span class="fc" id="L595">            cw.visitField(ACC_PUBLIC + ACC_STATIC, &quot;SPECIES_DATA&quot;, SPECIES_DATA_SIG, null, null).visitEnd();</span>

            // emit bound argument fields
<span class="fc bfc" id="L598" title="All 2 branches covered.">            for (int i = 0; i &lt; types.length(); ++i) {</span>
<span class="fc" id="L599">                final char t = types.charAt(i);</span>
<span class="fc" id="L600">                final String fieldName = makeFieldName(types, i);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">                final String fieldDesc = t == 'L' ? JLO_SIG : String.valueOf(t);</span>
<span class="fc" id="L602">                cw.visitField(ACC_FINAL, fieldName, fieldDesc, null, null).visitEnd();</span>
            }

            MethodVisitor mv;

            // emit constructor
<span class="fc" id="L608">            mv = cw.visitMethod(ACC_PUBLIC, &quot;&lt;init&gt;&quot;, makeSignature(types, true), null, null);</span>
<span class="fc" id="L609">            mv.visitCode();</span>
<span class="fc" id="L610">            mv.visitVarInsn(ALOAD, 0);</span>
<span class="fc" id="L611">            mv.visitVarInsn(ALOAD, 1);</span>
<span class="fc" id="L612">            mv.visitVarInsn(ALOAD, 2);</span>

<span class="fc" id="L614">            mv.visitMethodInsn(INVOKESPECIAL, BMH, &quot;&lt;init&gt;&quot;, makeSignature(&quot;&quot;, true));</span>

<span class="fc bfc" id="L616" title="All 2 branches covered.">            for (int i = 0, j = 0; i &lt; types.length(); ++i, ++j) {</span>
                // i counts the arguments, j counts corresponding argument slots
<span class="fc" id="L618">                char t = types.charAt(i);</span>
<span class="fc" id="L619">                mv.visitVarInsn(ALOAD, 0);</span>
<span class="fc" id="L620">                mv.visitVarInsn(typeLoadOp(t), j + 3); // parameters start at 3</span>
<span class="fc" id="L621">                mv.visitFieldInsn(PUTFIELD, className, makeFieldName(types, i), typeSig(t));</span>
<span class="fc bfc" id="L622" title="All 4 branches covered.">                if (t == 'J' || t == 'D') {</span>
<span class="fc" id="L623">                    ++j; // adjust argument register access</span>
                }
            }

<span class="fc" id="L627">            mv.visitInsn(RETURN);</span>
<span class="fc" id="L628">            mv.visitMaxs(0, 0);</span>
<span class="fc" id="L629">            mv.visitEnd();</span>

            // emit implementation of reinvokerTarget()
<span class="fc" id="L632">            mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, &quot;reinvokerTarget&quot;, &quot;()&quot; + MH_SIG, null, null);</span>
<span class="fc" id="L633">            mv.visitCode();</span>
<span class="fc" id="L634">            mv.visitVarInsn(ALOAD, 0);</span>
<span class="fc" id="L635">            mv.visitFieldInsn(GETFIELD, className, &quot;argL0&quot;, JLO_SIG);</span>
<span class="fc" id="L636">            mv.visitTypeInsn(CHECKCAST, MH);</span>
<span class="fc" id="L637">            mv.visitInsn(ARETURN);</span>
<span class="fc" id="L638">            mv.visitMaxs(0, 0);</span>
<span class="fc" id="L639">            mv.visitEnd();</span>

            // emit implementation of speciesData()
<span class="fc" id="L642">            mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, &quot;speciesData&quot;, MYSPECIES_DATA_SIG, null, null);</span>
<span class="fc" id="L643">            mv.visitCode();</span>
<span class="fc" id="L644">            mv.visitFieldInsn(GETSTATIC, className, &quot;SPECIES_DATA&quot;, SPECIES_DATA_SIG);</span>
<span class="fc" id="L645">            mv.visitInsn(ARETURN);</span>
<span class="fc" id="L646">            mv.visitMaxs(0, 0);</span>
<span class="fc" id="L647">            mv.visitEnd();</span>

            // emit clone()
<span class="fc" id="L650">            mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, &quot;clone&quot;, makeSignature(&quot;&quot;, false), null, E_THROWABLE);</span>
<span class="fc" id="L651">            mv.visitCode();</span>
            // return speciesData().constructor[0].invokeBasic(mt, lf, argL0, ...)
            // obtain constructor
<span class="fc" id="L654">            mv.visitVarInsn(ALOAD, 0);</span>
<span class="fc" id="L655">            mv.visitFieldInsn(GETSTATIC, className, &quot;SPECIES_DATA&quot;, SPECIES_DATA_SIG);</span>
<span class="fc" id="L656">            mv.visitFieldInsn(GETFIELD, SPECIES_DATA, &quot;constructor&quot;, &quot;[&quot; + MH_SIG);</span>
<span class="fc" id="L657">            mv.visitInsn(ICONST_0);</span>
<span class="fc" id="L658">            mv.visitInsn(AALOAD);</span>
            // load mt, lf
<span class="fc" id="L660">            mv.visitVarInsn(ALOAD, 1);</span>
<span class="fc" id="L661">            mv.visitVarInsn(ALOAD, 2);</span>
            // put fields on the stack
<span class="fc" id="L663">            emitPushFields(types, className, mv);</span>
            // finally, invoke the constructor and return
<span class="fc" id="L665">            mv.visitMethodInsn(INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, makeSignature(types, false));</span>
<span class="fc" id="L666">            mv.visitInsn(ARETURN);</span>
<span class="fc" id="L667">            mv.visitMaxs(0, 0);</span>
<span class="fc" id="L668">            mv.visitEnd();</span>

            // for each type, emit cloneExtendT()
<span class="fc bfc" id="L671" title="All 2 branches covered.">            for (Class&lt;?&gt; c : TYPES) {</span>
<span class="fc" id="L672">                char t = Wrapper.basicTypeChar(c);</span>
<span class="fc" id="L673">                mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, &quot;cloneExtend&quot; + t, makeSignature(String.valueOf(t), false), null, E_THROWABLE);</span>
<span class="fc" id="L674">                mv.visitCode();</span>
                // return SPECIES_DATA.extendWithIndex(extensionIndex(t)).constructor[0].invokeBasic(mt, lf, argL0, ..., narg)
                // obtain constructor
<span class="fc" id="L677">                mv.visitFieldInsn(GETSTATIC, className, &quot;SPECIES_DATA&quot;, SPECIES_DATA_SIG);</span>
<span class="fc" id="L678">                int iconstInsn = ICONST_0 + extensionIndex(t);</span>
<span class="pc bpc" id="L679" title="1 of 4 branches missed.">                assert(iconstInsn &lt;= ICONST_5);</span>
<span class="fc" id="L680">                mv.visitInsn(iconstInsn);</span>
<span class="fc" id="L681">                mv.visitMethodInsn(INVOKEVIRTUAL, SPECIES_DATA, &quot;extendWithIndex&quot;, BMHSPECIES_DATA_EWI_SIG);</span>
<span class="fc" id="L682">                mv.visitFieldInsn(GETFIELD, SPECIES_DATA, &quot;constructor&quot;, &quot;[&quot; + MH_SIG);</span>
<span class="fc" id="L683">                mv.visitInsn(ICONST_0);</span>
<span class="fc" id="L684">                mv.visitInsn(AALOAD);</span>
                // load mt, lf
<span class="fc" id="L686">                mv.visitVarInsn(ALOAD, 1);</span>
<span class="fc" id="L687">                mv.visitVarInsn(ALOAD, 2);</span>
                // put fields on the stack
<span class="fc" id="L689">                emitPushFields(types, className, mv);</span>
                // put narg on stack
<span class="fc" id="L691">                mv.visitVarInsn(typeLoadOp(t), 3);</span>
                // finally, invoke the constructor and return
<span class="fc" id="L693">                mv.visitMethodInsn(INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, makeSignature(types + t, false));</span>
<span class="fc" id="L694">                mv.visitInsn(ARETURN);</span>
<span class="fc" id="L695">                mv.visitMaxs(0, 0);</span>
<span class="fc" id="L696">                mv.visitEnd();</span>
            }

            // emit class initializer
<span class="fc" id="L700">            mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, &quot;&lt;clinit&gt;&quot;, VOID_SIG, null, null);</span>
<span class="fc" id="L701">            mv.visitCode();</span>
<span class="fc" id="L702">            mv.visitLdcInsn(types);</span>
<span class="fc" id="L703">            mv.visitLdcInsn(Type.getObjectType(className));</span>
<span class="fc" id="L704">            mv.visitMethodInsn(INVOKESTATIC, SPECIES_DATA, &quot;getForClass&quot;, BMHSPECIES_DATA_GFC_SIG);</span>
<span class="fc" id="L705">            mv.visitFieldInsn(PUTSTATIC, className, &quot;SPECIES_DATA&quot;, SPECIES_DATA_SIG);</span>
<span class="fc" id="L706">            mv.visitInsn(RETURN);</span>
<span class="fc" id="L707">            mv.visitMaxs(0, 0);</span>
<span class="fc" id="L708">            mv.visitEnd();</span>

<span class="fc" id="L710">            cw.visitEnd();</span>

            // load class
<span class="fc" id="L713">            final byte[] classFile = cw.toByteArray();</span>
<span class="fc" id="L714">            InvokerBytecodeGenerator.maybeDump(className, classFile);</span>
<span class="fc" id="L715">            Class&lt;? extends BoundMethodHandle&gt; bmhClass =</span>
                //UNSAFE.defineAnonymousClass(BoundMethodHandle.class, classFile, null).asSubclass(BoundMethodHandle.class);
<span class="fc" id="L717">                UNSAFE.defineClass(className, classFile, 0, classFile.length,</span>
<span class="fc" id="L718">                                   BoundMethodHandle.class.getClassLoader(), null)</span>
<span class="fc" id="L719">                    .asSubclass(BoundMethodHandle.class);</span>
<span class="fc" id="L720">            UNSAFE.ensureClassInitialized(bmhClass);</span>

<span class="fc" id="L722">            return bmhClass;</span>
        }

        private static int typeLoadOp(char t) {
<span class="pc bpc" id="L726" title="1 of 6 branches missed.">            switch (t) {</span>
<span class="fc" id="L727">            case 'L': return ALOAD;</span>
<span class="fc" id="L728">            case 'I': return ILOAD;</span>
<span class="fc" id="L729">            case 'J': return LLOAD;</span>
<span class="fc" id="L730">            case 'F': return FLOAD;</span>
<span class="fc" id="L731">            case 'D': return DLOAD;</span>
<span class="nc" id="L732">            default : throw new InternalError(&quot;unrecognized type &quot; + t);</span>
            }
        }

        private static void emitPushFields(String types, String className, MethodVisitor mv) {
<span class="fc bfc" id="L737" title="All 2 branches covered.">            for (int i = 0; i &lt; types.length(); ++i) {</span>
<span class="fc" id="L738">                char tc = types.charAt(i);</span>
<span class="fc" id="L739">                mv.visitVarInsn(ALOAD, 0);</span>
<span class="fc" id="L740">                mv.visitFieldInsn(GETFIELD, className, makeFieldName(types, i), typeSig(tc));</span>
            }
<span class="fc" id="L742">        }</span>

        static String typeSig(char t) {
<span class="fc bfc" id="L745" title="All 2 branches covered.">            return t == 'L' ? JLO_SIG : String.valueOf(t);</span>
        }

        //
        // Getter MH generation.
        //

        private static MethodHandle makeGetter(Class&lt;?&gt; cbmhClass, String types, int index) {
<span class="fc" id="L753">            String fieldName = makeFieldName(types, index);</span>
<span class="fc" id="L754">            Class&lt;?&gt; fieldType = Wrapper.forBasicType(types.charAt(index)).primitiveType();</span>
            try {
<span class="fc" id="L756">                return LOOKUP.findGetter(cbmhClass, fieldName, fieldType);</span>
<span class="nc" id="L757">            } catch (NoSuchFieldException | IllegalAccessException e) {</span>
<span class="nc" id="L758">                throw newInternalError(e);</span>
            }
        }

        static MethodHandle[] makeGetters(Class&lt;?&gt; cbmhClass, String types, MethodHandle[] mhs) {
<span class="fc bfc" id="L763" title="All 2 branches covered.">            if (mhs == null)  mhs = new MethodHandle[types.length()];</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">            for (int i = 0; i &lt; mhs.length; ++i) {</span>
<span class="fc" id="L765">                mhs[i] = makeGetter(cbmhClass, types, i);</span>
<span class="pc bpc" id="L766" title="1 of 4 branches missed.">                assert(mhs[i].internalMemberName().getDeclaringClass() == cbmhClass);</span>
            }
<span class="fc" id="L768">            return mhs;</span>
        }

        static MethodHandle[] makeCtors(Class&lt;? extends BoundMethodHandle&gt; cbmh, String types, MethodHandle mhs[]) {
<span class="fc bfc" id="L772" title="All 2 branches covered.">            if (mhs == null)  mhs = new MethodHandle[1];</span>
<span class="fc" id="L773">            mhs[0] = makeCbmhCtor(cbmh, types);</span>
<span class="fc" id="L774">            return mhs;</span>
        }

        //
        // Auxiliary methods.
        //

        static SpeciesData speciesDataFromConcreteBMHClass(Class&lt;? extends BoundMethodHandle&gt; cbmh) {
            try {
<span class="fc" id="L783">                Field F_SPECIES_DATA = cbmh.getDeclaredField(&quot;SPECIES_DATA&quot;);</span>
<span class="fc" id="L784">                return (SpeciesData) F_SPECIES_DATA.get(null);</span>
<span class="nc" id="L785">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L786">                throw newInternalError(ex);</span>
            }
        }

        /**
         * Field names in concrete BMHs adhere to this pattern:
         * arg + type + index
         * where type is a single character (L, I, J, F, D).
         */
        private static String makeFieldName(String types, int index) {
<span class="pc bpc" id="L796" title="2 of 6 branches missed.">            assert index &gt;= 0 &amp;&amp; index &lt; types.length();</span>
<span class="fc" id="L797">            return &quot;arg&quot; + types.charAt(index) + index;</span>
        }

        private static String makeSignature(String types, boolean ctor) {
<span class="fc" id="L801">            StringBuilder buf = new StringBuilder(SIG_INCIPIT);</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">            for (char c : types.toCharArray()) {</span>
<span class="fc" id="L803">                buf.append(typeSig(c));</span>
            }
<span class="fc bfc" id="L805" title="All 2 branches covered.">            return buf.append(')').append(ctor ? &quot;V&quot; : BMH_SIG).toString();</span>
        }

        static MethodHandle makeCbmhCtor(Class&lt;? extends BoundMethodHandle&gt; cbmh, String types) {
            try {
<span class="fc" id="L810">                return linkConstructor(LOOKUP.findConstructor(cbmh, MethodType.fromMethodDescriptorString(makeSignature(types, true), null)));</span>
<span class="nc" id="L811">            } catch (NoSuchMethodException | IllegalAccessException | IllegalArgumentException | TypeNotPresentException e) {</span>
<span class="nc" id="L812">                throw newInternalError(e);</span>
            }
        }

        /**
         * Wrap a constructor call in a {@link LambdaForm}.
         *
         * If constructors ({@code &lt;init&gt;} methods) are called in LFs, problems might arise if the LFs
         * are turned into bytecode, because the call to the allocator is routed through an MH, and the
         * verifier cannot find a {@code NEW} instruction preceding the {@code INVOKESPECIAL} to
         * {@code &lt;init&gt;}. To avoid this, we add an indirection by invoking {@code &lt;init&gt;} through
         * {@link MethodHandle#linkToSpecial}.
         *
         * The last {@link LambdaForm.Name Name} in the argument's form is expected to be the {@code void}
         * result of the {@code &lt;init&gt;} invocation. This entry is replaced.
         */
        private static MethodHandle linkConstructor(MethodHandle cmh) {
<span class="fc" id="L829">            final LambdaForm lf = cmh.form;</span>
<span class="fc" id="L830">            final int initNameIndex = lf.names.length - 1;</span>
<span class="fc" id="L831">            final Name initName = lf.names[initNameIndex];</span>
<span class="fc" id="L832">            final MemberName ctorMN = initName.function.member;</span>
<span class="fc" id="L833">            final MethodType ctorMT = ctorMN.getInvocationType();</span>

            // obtain function member (call target)
            // linker method type replaces initial parameter (BMH species) with BMH to avoid naming a species (anonymous class!)
<span class="fc" id="L837">            final MethodType linkerMT = ctorMT.changeParameterType(0, BoundMethodHandle.class).appendParameterTypes(MemberName.class);</span>
<span class="fc" id="L838">            MemberName linkerMN = new MemberName(MethodHandle.class, &quot;linkToSpecial&quot;, linkerMT, REF_invokeStatic);</span>
            try {
<span class="fc" id="L840">                linkerMN = MemberName.getFactory().resolveOrFail(REF_invokeStatic, linkerMN, null, NoSuchMethodException.class);</span>
<span class="pc bpc" id="L841" title="1 of 4 branches missed.">                assert(linkerMN.isStatic());</span>
<span class="nc" id="L842">            } catch (ReflectiveOperationException ex) {</span>
<span class="nc" id="L843">                throw newInternalError(ex);</span>
<span class="fc" id="L844">            }</span>
            // extend arguments array
<span class="fc" id="L846">            Object[] newArgs = Arrays.copyOf(initName.arguments, initName.arguments.length + 1);</span>
<span class="fc" id="L847">            newArgs[newArgs.length - 1] = ctorMN;</span>
            // replace function
<span class="fc" id="L849">            final NamedFunction nf = new NamedFunction(linkerMN);</span>
<span class="fc" id="L850">            final Name linkedCtor = new Name(nf, newArgs);</span>
<span class="fc" id="L851">            linkedCtor.initIndex(initNameIndex);</span>
<span class="fc" id="L852">            lf.names[initNameIndex] = linkedCtor;</span>
<span class="fc" id="L853">            return cmh;</span>
        }

    }

<span class="fc" id="L858">    private static final Lookup LOOKUP = Lookup.IMPL_LOOKUP;</span>

    /**
     * All subclasses must provide such a value describing their type signature.
     */
<span class="fc" id="L863">    static final SpeciesData SPECIES_DATA = SpeciesData.EMPTY;</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>