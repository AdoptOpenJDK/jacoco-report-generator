<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CallSite.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang.invoke</a> &gt; <span class="el_source">CallSite.java</span></div><h1>CallSite.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang.invoke;

import sun.invoke.empty.Empty;
import static java.lang.invoke.MethodHandleStatics.*;
import static java.lang.invoke.MethodHandles.Lookup.IMPL_LOOKUP;

/**
 * A {@code CallSite} is a holder for a variable {@link MethodHandle},
 * which is called its {@code target}.
 * An {@code invokedynamic} instruction linked to a {@code CallSite} delegates
 * all calls to the site's current target.
 * A {@code CallSite} may be associated with several {@code invokedynamic}
 * instructions, or it may be &quot;free floating&quot;, associated with none.
 * In any case, it may be invoked through an associated method handle
 * called its {@linkplain #dynamicInvoker dynamic invoker}.
 * &lt;p&gt;
 * {@code CallSite} is an abstract class which does not allow
 * direct subclassing by users.  It has three immediate,
 * concrete subclasses that may be either instantiated or subclassed.
 * &lt;ul&gt;
 * &lt;li&gt;If a mutable target is not required, an {@code invokedynamic} instruction
 * may be permanently bound by means of a {@linkplain ConstantCallSite constant call site}.
 * &lt;li&gt;If a mutable target is required which has volatile variable semantics,
 * because updates to the target must be immediately and reliably witnessed by other threads,
 * a {@linkplain VolatileCallSite volatile call site} may be used.
 * &lt;li&gt;Otherwise, if a mutable target is required,
 * a {@linkplain MutableCallSite mutable call site} may be used.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * A non-constant call site may be &lt;em&gt;relinked&lt;/em&gt; by changing its target.
 * The new target must have the same {@linkplain MethodHandle#type() type}
 * as the previous target.
 * Thus, though a call site can be relinked to a series of
 * successive targets, it cannot change its type.
 * &lt;p&gt;
 * Here is a sample use of call sites and bootstrap methods which links every
 * dynamic call site to print its arguments:
&lt;blockquote&gt;&lt;pre&gt;{@code
static void test() throws Throwable {
    // THE FOLLOWING LINE IS PSEUDOCODE FOR A JVM INSTRUCTION
    InvokeDynamic[#bootstrapDynamic].baz(&quot;baz arg&quot;, 2, 3.14);
}
private static void printArgs(Object... args) {
  System.out.println(java.util.Arrays.deepToString(args));
}
private static final MethodHandle printArgs;
static {
  MethodHandles.Lookup lookup = MethodHandles.lookup();
  Class thisClass = lookup.lookupClass();  // (who am I?)
  printArgs = lookup.findStatic(thisClass,
      &quot;printArgs&quot;, MethodType.methodType(void.class, Object[].class));
}
private static CallSite bootstrapDynamic(MethodHandles.Lookup caller, String name, MethodType type) {
  // ignore caller and name, but match the type:
  return new ConstantCallSite(printArgs.asType(type));
}
}&lt;/pre&gt;&lt;/blockquote&gt;
 * @author John Rose, JSR 292 EG
 */
abstract
public class CallSite {
<span class="fc" id="L87">    static { MethodHandleImpl.initStatics(); }</span>

    // The actual payload of this call site:
    /*package-private*/
    MethodHandle target;    // Note: This field is known to the JVM.  Do not change.

    /**
     * Make a blank call site object with the given method type.
     * An initial target method is supplied which will throw
     * an {@link IllegalStateException} if called.
     * &lt;p&gt;
     * Before this {@code CallSite} object is returned from a bootstrap method,
     * it is usually provided with a more useful target method,
     * via a call to {@link CallSite#setTarget(MethodHandle) setTarget}.
     * @throws NullPointerException if the proposed type is null
     */
    /*package-private*/
<span class="fc" id="L104">    CallSite(MethodType type) {</span>
<span class="fc" id="L105">        target = type.invokers().uninitializedCallSite();</span>
<span class="fc" id="L106">    }</span>

    /**
     * Make a call site object equipped with an initial target method handle.
     * @param target the method handle which will be the initial target of the call site
     * @throws NullPointerException if the proposed target is null
     */
    /*package-private*/
<span class="fc" id="L114">    CallSite(MethodHandle target) {</span>
<span class="fc" id="L115">        target.type();  // null check</span>
<span class="fc" id="L116">        this.target = target;</span>
<span class="fc" id="L117">    }</span>

    /**
     * Make a call site object equipped with an initial target method handle.
     * @param targetType the desired type of the call site
     * @param createTargetHook a hook which will bind the call site to the target method handle
     * @throws WrongMethodTypeException if the hook cannot be invoked on the required arguments,
     *         or if the target returned by the hook is not of the given {@code targetType}
     * @throws NullPointerException if the hook returns a null value
     * @throws ClassCastException if the hook returns something other than a {@code MethodHandle}
     * @throws Throwable anything else thrown by the hook function
     */
    /*package-private*/
    CallSite(MethodType targetType, MethodHandle createTargetHook) throws Throwable {
<span class="fc" id="L131">        this(targetType);</span>
<span class="fc" id="L132">        ConstantCallSite selfCCS = (ConstantCallSite) this;</span>
<span class="fc" id="L133">        MethodHandle boundTarget = (MethodHandle) createTargetHook.invokeWithArguments(selfCCS);</span>
<span class="fc" id="L134">        checkTargetChange(this.target, boundTarget);</span>
<span class="fc" id="L135">        this.target = boundTarget;</span>
<span class="fc" id="L136">    }</span>

    /**
     * Returns the type of this call site's target.
     * Although targets may change, any call site's type is permanent, and can never change to an unequal type.
     * The {@code setTarget} method enforces this invariant by refusing any new target that does
     * not have the previous target's type.
     * @return the type of the current target, which is also the type of any future target
     */
    public MethodType type() {
        // warning:  do not call getTarget here, because CCS.getTarget can throw IllegalStateException
<span class="fc" id="L147">        return target.type();</span>
    }

    /**
     * Returns the target method of the call site, according to the
     * behavior defined by this call site's specific class.
     * The immediate subclasses of {@code CallSite} document the
     * class-specific behaviors of this method.
     *
     * @return the current linkage state of the call site, its target method handle
     * @see ConstantCallSite
     * @see VolatileCallSite
     * @see #setTarget
     * @see ConstantCallSite#getTarget
     * @see MutableCallSite#getTarget
     * @see VolatileCallSite#getTarget
     */
    public abstract MethodHandle getTarget();

    /**
     * Updates the target method of this call site, according to the
     * behavior defined by this call site's specific class.
     * The immediate subclasses of {@code CallSite} document the
     * class-specific behaviors of this method.
     * &lt;p&gt;
     * The type of the new target must be {@linkplain MethodType#equals equal to}
     * the type of the old target.
     *
     * @param newTarget the new target
     * @throws NullPointerException if the proposed new target is null
     * @throws WrongMethodTypeException if the proposed new target
     *         has a method type that differs from the previous target
     * @see CallSite#getTarget
     * @see ConstantCallSite#setTarget
     * @see MutableCallSite#setTarget
     * @see VolatileCallSite#setTarget
     */
    public abstract void setTarget(MethodHandle newTarget);

    void checkTargetChange(MethodHandle oldTarget, MethodHandle newTarget) {
<span class="fc" id="L187">        MethodType oldType = oldTarget.type();</span>
<span class="fc" id="L188">        MethodType newType = newTarget.type();  // null check!</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (!newType.equals(oldType))</span>
<span class="nc" id="L190">            throw wrongTargetType(newTarget, oldType);</span>
<span class="fc" id="L191">    }</span>

    private static WrongMethodTypeException wrongTargetType(MethodHandle target, MethodType type) {
<span class="nc" id="L194">        return new WrongMethodTypeException(String.valueOf(target)+&quot; should be of type &quot;+type);</span>
    }

    /**
     * Produces a method handle equivalent to an invokedynamic instruction
     * which has been linked to this call site.
     * &lt;p&gt;
     * This method is equivalent to the following code:
     * &lt;blockquote&gt;&lt;pre&gt;{@code
     * MethodHandle getTarget, invoker, result;
     * getTarget = MethodHandles.publicLookup().bind(this, &quot;getTarget&quot;, MethodType.methodType(MethodHandle.class));
     * invoker = MethodHandles.exactInvoker(this.type());
     * result = MethodHandles.foldArguments(invoker, getTarget)
     * }&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return a method handle which always invokes this call site's current target
     */
    public abstract MethodHandle dynamicInvoker();

    /*non-public*/ MethodHandle makeDynamicInvoker() {
<span class="fc" id="L214">        MethodHandle getTarget = GET_TARGET.bindReceiver(this);</span>
<span class="fc" id="L215">        MethodHandle invoker = MethodHandles.exactInvoker(this.type());</span>
<span class="fc" id="L216">        return MethodHandles.foldArguments(invoker, getTarget);</span>
    }

    private static final MethodHandle GET_TARGET;
    static {
        try {
<span class="fc" id="L222">            GET_TARGET = IMPL_LOOKUP.</span>
<span class="fc" id="L223">                findVirtual(CallSite.class, &quot;getTarget&quot;, MethodType.methodType(MethodHandle.class));</span>
<span class="nc" id="L224">        } catch (ReflectiveOperationException e) {</span>
<span class="nc" id="L225">            throw newInternalError(e);</span>
<span class="fc" id="L226">        }</span>
    }

    /** This guy is rolled into the default target if a MethodType is supplied to the constructor. */
    /*package-private*/
    static Empty uninitializedCallSite() {
<span class="fc" id="L232">        throw new IllegalStateException(&quot;uninitialized call site&quot;);</span>
    }

    // unsafe stuff:
    private static final long TARGET_OFFSET;
    static {
        try {
<span class="fc" id="L239">            TARGET_OFFSET = UNSAFE.objectFieldOffset(CallSite.class.getDeclaredField(&quot;target&quot;));</span>
<span class="pc" id="L240">        } catch (Exception ex) { throw new Error(ex); }</span>
<span class="fc" id="L241">    }</span>

    /*package-private*/
    void setTargetNormal(MethodHandle newTarget) {
<span class="fc" id="L245">        MethodHandleNatives.setCallSiteTargetNormal(this, newTarget);</span>
<span class="fc" id="L246">    }</span>
    /*package-private*/
    MethodHandle getTargetVolatile() {
<span class="fc" id="L249">        return (MethodHandle) UNSAFE.getObjectVolatile(this, TARGET_OFFSET);</span>
    }
    /*package-private*/
    void setTargetVolatile(MethodHandle newTarget) {
<span class="fc" id="L253">        MethodHandleNatives.setCallSiteTargetVolatile(this, newTarget);</span>
<span class="fc" id="L254">    }</span>

    // this implements the upcall from the JVM, MethodHandleNatives.makeDynamicCallSite:
    static CallSite makeSite(MethodHandle bootstrapMethod,
                             // Callee information:
                             String name, MethodType type,
                             // Extra arguments for BSM, if any:
                             Object info,
                             // Caller information:
                             Class&lt;?&gt; callerClass) {
<span class="fc" id="L264">        MethodHandles.Lookup caller = IMPL_LOOKUP.in(callerClass);</span>
        CallSite site;
        try {
            Object binding;
<span class="fc" id="L268">            info = maybeReBox(info);</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">            if (info == null) {</span>
<span class="fc" id="L270">                binding = bootstrapMethod.invoke(caller, name, type);</span>
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">            } else if (!info.getClass().isArray()) {</span>
<span class="nc" id="L272">                binding = bootstrapMethod.invoke(caller, name, type, info);</span>
            } else {
<span class="fc" id="L274">                Object[] argv = (Object[]) info;</span>
<span class="fc" id="L275">                maybeReBoxElements(argv);</span>
<span class="pc bpc" id="L276" title="4 of 8 branches missed.">                switch (argv.length) {</span>
                case 0:
<span class="nc" id="L278">                    binding = bootstrapMethod.invoke(caller, name, type);</span>
<span class="nc" id="L279">                    break;</span>
                case 1:
<span class="fc" id="L281">                    binding = bootstrapMethod.invoke(caller, name, type,</span>
                                                     argv[0]);
<span class="fc" id="L283">                    break;</span>
                case 2:
<span class="nc" id="L285">                    binding = bootstrapMethod.invoke(caller, name, type,</span>
                                                     argv[0], argv[1]);
<span class="nc" id="L287">                    break;</span>
                case 3:
<span class="fc" id="L289">                    binding = bootstrapMethod.invoke(caller, name, type,</span>
                                                     argv[0], argv[1], argv[2]);
<span class="fc" id="L291">                    break;</span>
                case 4:
<span class="nc" id="L293">                    binding = bootstrapMethod.invoke(caller, name, type,</span>
                                                     argv[0], argv[1], argv[2], argv[3]);
<span class="nc" id="L295">                    break;</span>
                case 5:
<span class="fc" id="L297">                    binding = bootstrapMethod.invoke(caller, name, type,</span>
                                                     argv[0], argv[1], argv[2], argv[3], argv[4]);
<span class="fc" id="L299">                    break;</span>
                case 6:
<span class="fc" id="L301">                    binding = bootstrapMethod.invoke(caller, name, type,</span>
                                                     argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);
<span class="fc" id="L303">                    break;</span>
                default:
                    final int NON_SPREAD_ARG_COUNT = 3;  // (caller, name, type)
<span class="nc bnc" id="L306" title="All 2 branches missed.">                    if (NON_SPREAD_ARG_COUNT + argv.length &gt; MethodType.MAX_MH_ARITY)</span>
<span class="nc" id="L307">                        throw new BootstrapMethodError(&quot;too many bootstrap method arguments&quot;);</span>
<span class="nc" id="L308">                    MethodType bsmType = bootstrapMethod.type();</span>
<span class="nc" id="L309">                    MethodType invocationType = MethodType.genericMethodType(NON_SPREAD_ARG_COUNT + argv.length);</span>
<span class="nc" id="L310">                    MethodHandle typedBSM = bootstrapMethod.asType(invocationType);</span>
<span class="nc" id="L311">                    MethodHandle spreader = invocationType.invokers().spreadInvoker(NON_SPREAD_ARG_COUNT);</span>
<span class="nc" id="L312">                    binding = spreader.invokeExact(typedBSM, (Object)caller, (Object)name, (Object)type, argv);</span>
                }
            }
            //System.out.println(&quot;BSM for &quot;+name+type+&quot; =&gt; &quot;+binding);
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">            if (binding instanceof CallSite) {</span>
<span class="fc" id="L317">                site = (CallSite) binding;</span>
            }  else {
<span class="nc" id="L319">                throw new ClassCastException(&quot;bootstrap method failed to produce a CallSite&quot;);</span>
            }
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">            if (!site.getTarget().type().equals(type))</span>
<span class="nc" id="L322">                throw new WrongMethodTypeException(&quot;wrong type: &quot;+site.getTarget());</span>
<span class="nc" id="L323">        } catch (Throwable ex) {</span>
            BootstrapMethodError bex;
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (ex instanceof BootstrapMethodError)</span>
<span class="nc" id="L326">                bex = (BootstrapMethodError) ex;</span>
            else
<span class="nc" id="L328">                bex = new BootstrapMethodError(&quot;call site initialization exception&quot;, ex);</span>
<span class="nc" id="L329">            throw bex;</span>
<span class="fc" id="L330">        }</span>
<span class="fc" id="L331">        return site;</span>
    }

    private static Object maybeReBox(Object x) {
<span class="fc bfc" id="L335" title="All 2 branches covered.">        if (x instanceof Integer) {</span>
<span class="fc" id="L336">            int xi = (int) x;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">            if (xi == (byte) xi)</span>
<span class="fc" id="L338">                x = xi;  // must rebox; see JLS 5.1.7</span>
        }
<span class="fc" id="L340">        return x;</span>
    }
    private static void maybeReBoxElements(Object[] xa) {
<span class="fc bfc" id="L343" title="All 2 branches covered.">        for (int i = 0; i &lt; xa.length; i++) {</span>
<span class="fc" id="L344">            xa[i] = maybeReBox(xa[i]);</span>
        }
<span class="fc" id="L346">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>