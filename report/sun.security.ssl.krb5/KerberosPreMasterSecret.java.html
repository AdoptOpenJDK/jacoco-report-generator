<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KerberosPreMasterSecret.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.ssl.krb5</a> &gt; <span class="el_source">KerberosPreMasterSecret.java</span></div><h1>KerberosPreMasterSecret.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.ssl.krb5;

import java.io.*;
import java.security.*;
import java.util.Arrays;

import javax.net.ssl.*;

import sun.security.krb5.EncryptionKey;
import sun.security.krb5.EncryptedData;
import sun.security.krb5.KrbException;
import sun.security.krb5.internal.crypto.KeyUsage;

import sun.security.ssl.Debug;
import sun.security.ssl.HandshakeInStream;
import sun.security.ssl.HandshakeMessage;
import sun.security.ssl.ProtocolVersion;

/**
 * This is the Kerberos premaster secret in the Kerberos client key
 * exchange message (CLIENT --&gt; SERVER); it holds the
 * Kerberos-encrypted pre-master secret. The secret is encrypted using the
 * Kerberos session key.  The padding and size of the resulting message
 * depends on the session key type, but the pre-master secret is
 * always exactly 48 bytes.
 *
 */
final class KerberosPreMasterSecret {

    private ProtocolVersion protocolVersion; // preMaster [0,1]
    private byte preMaster[];           // 48 bytes
    private byte encrypted[];

    /**
     * Constructor used by client to generate premaster secret.
     *
     * Client randomly creates a pre-master secret and encrypts it
     * using the Kerberos session key; only the server can decrypt
     * it, using the session key available in the service ticket.
     *
     * @param protocolVersion used to set preMaster[0,1]
     * @param generator random number generator for generating premaster secret
     * @param sessionKey Kerberos session key for encrypting premaster secret
     */
    KerberosPreMasterSecret(ProtocolVersion protocolVersion,
<span class="nc" id="L71">        SecureRandom generator, EncryptionKey sessionKey) throws IOException {</span>

<span class="nc bnc" id="L73" title="All 2 branches missed.">        if (sessionKey.getEType() ==</span>
            EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD) {
<span class="nc" id="L75">            throw new IOException(</span>
               &quot;session keys with des3-cbc-hmac-sha1-kd encryption type &quot; +
               &quot;are not supported for TLS Kerberos cipher suites&quot;);
        }

<span class="nc" id="L80">        this.protocolVersion = protocolVersion;</span>
<span class="nc" id="L81">        preMaster = generatePreMaster(generator, protocolVersion);</span>

        // Encrypt premaster secret
        try {
<span class="nc" id="L85">            EncryptedData eData = new EncryptedData(sessionKey, preMaster,</span>
                KeyUsage.KU_UNKNOWN);
<span class="nc" id="L87">            encrypted = eData.getBytes();  // not ASN.1 encoded.</span>

<span class="nc" id="L89">        } catch (KrbException e) {</span>
<span class="nc" id="L90">            throw (SSLKeyException)new SSLKeyException</span>
<span class="nc" id="L91">                (&quot;Kerberos premaster secret error&quot;).initCause(e);</span>
<span class="nc" id="L92">        }</span>
<span class="nc" id="L93">    }</span>

    /*
     * Constructor used by server to decrypt encrypted premaster secret.
     * The protocol version in preMaster[0,1] must match either currentVersion
     * or clientVersion, otherwise, the premaster secret is set to
     * a random one to foil possible attack.
     *
     * @param currentVersion version of protocol being used
     * @param clientVersion version requested by client
     * @param generator random number generator used to generate
     *        bogus premaster secret if premaster secret verification fails
     * @param input input stream from which to read the encrypted
     *        premaster secret
     * @param sessionKey Kerberos session key to be used for decryption
     */
    KerberosPreMasterSecret(ProtocolVersion currentVersion,
        ProtocolVersion clientVersion,
        SecureRandom generator, HandshakeInStream input,
<span class="nc" id="L112">        EncryptionKey sessionKey) throws IOException {</span>

         // Extract encrypted premaster secret from message
<span class="nc" id="L115">         encrypted = input.getBytes16();</span>

<span class="nc bnc" id="L117" title="All 4 branches missed.">         if (HandshakeMessage.debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            if (encrypted != null) {</span>
<span class="nc" id="L119">                Debug.println(System.out,</span>
                     &quot;encrypted premaster secret&quot;, encrypted);
            }
         }

<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (sessionKey.getEType() ==</span>
            EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD) {
<span class="nc" id="L126">            throw new IOException(</span>
               &quot;session keys with des3-cbc-hmac-sha1-kd encryption type &quot; +
               &quot;are not supported for TLS Kerberos cipher suites&quot;);
        }

        // Decrypt premaster secret
        try {
<span class="nc" id="L133">            EncryptedData data = new EncryptedData(sessionKey.getEType(),</span>
                        null /* optional kvno */, encrypted);

<span class="nc" id="L136">            byte[] temp = data.decrypt(sessionKey, KeyUsage.KU_UNKNOWN);</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">            if (HandshakeMessage.debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">                 if (encrypted != null) {</span>
<span class="nc" id="L139">                     Debug.println(System.out,</span>
                         &quot;decrypted premaster secret&quot;, temp);
                 }
            }

            // Remove padding bytes after decryption. Only DES and DES3 have
            // paddings and we don't support DES3 in TLS (see above)

<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (temp.length == 52 &amp;&amp;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">                    data.getEType() == EncryptedData.ETYPE_DES_CBC_CRC) {</span>
                // For des-cbc-crc, 4 paddings. Value can be 0x04 or 0x00.
<span class="nc bnc" id="L150" title="All 2 branches missed.">                if (paddingByteIs(temp, 52, (byte)4) ||</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">                        paddingByteIs(temp, 52, (byte)0)) {</span>
<span class="nc" id="L152">                    temp = Arrays.copyOf(temp, 48);</span>
                }
<span class="nc bnc" id="L154" title="All 2 branches missed.">            } else if (temp.length == 56 &amp;&amp;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                    data.getEType() == EncryptedData.ETYPE_DES_CBC_MD5) {</span>
                // For des-cbc-md5, 8 paddings with 0x08, or no padding
<span class="nc bnc" id="L157" title="All 2 branches missed.">                if (paddingByteIs(temp, 56, (byte)8)) {</span>
<span class="nc" id="L158">                    temp = Arrays.copyOf(temp, 48);</span>
                }
            }

<span class="nc" id="L162">            preMaster = temp;</span>

<span class="nc" id="L164">            protocolVersion = ProtocolVersion.valueOf(preMaster[0],</span>
                 preMaster[1]);
<span class="nc bnc" id="L166" title="All 4 branches missed.">            if (HandshakeMessage.debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L167">                 System.out.println(&quot;Kerberos PreMasterSecret version: &quot;</span>
                        + protocolVersion);
            }
<span class="nc" id="L170">        } catch (Exception e) {</span>
            // catch exception &amp; process below
<span class="nc" id="L172">            preMaster = null;</span>
<span class="nc" id="L173">            protocolVersion = currentVersion;</span>
<span class="nc" id="L174">        }</span>

        // check if the premaster secret version is ok
        // the specification says that it must be the maximum version supported
        // by the client from its ClientHello message. However, many
        // old implementations send the negotiated version, so accept both
        // for SSL v3.0 and TLS v1.0.
        // NOTE that we may be comparing two unsupported version numbers in
        // the second case, which is why we cannot use object references
        // equality in this special case
<span class="nc bnc" id="L184" title="All 2 branches missed.">        boolean versionMismatch = (protocolVersion.v != clientVersion.v);</span>

        /*
         * we never checked the client_version in server side
         * for TLS v1.0 and SSL v3.0. For compatibility, we
         * maintain this behavior.
         */
<span class="nc bnc" id="L191" title="All 4 branches missed.">        if (versionMismatch &amp;&amp; (clientVersion.v &lt;= 0x0301)) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">            versionMismatch = (protocolVersion.v != currentVersion.v);</span>
        }

        /*
         * Bogus decrypted ClientKeyExchange? If so, conjure a
         * a random preMaster secret that will fail later during
         * Finished message processing. This is a countermeasure against
         * the &quot;interactive RSA PKCS#1 encryption envelop attack&quot; reported
         * in June 1998. Preserving the executation path will
         * mitigate timing attacks and force consistent error handling
         * that will prevent an attacking client from differentiating
         * different kinds of decrypted ClientKeyExchange bogosities.
         */
<span class="nc bnc" id="L205" title="All 6 branches missed.">         if ((preMaster == null) || (preMaster.length != 48)</span>
                || versionMismatch) {
<span class="nc bnc" id="L207" title="All 4 branches missed.">            if (HandshakeMessage.debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L208">                System.out.println(&quot;Kerberos PreMasterSecret error, &quot;</span>
                                   + &quot;generating random secret&quot;);
<span class="nc bnc" id="L210" title="All 2 branches missed.">                if (preMaster != null) {</span>
<span class="nc" id="L211">                    Debug.println(System.out, &quot;Invalid secret&quot;, preMaster);</span>
                }
            }

            /*
             * Randomize the preMaster secret with the
             * ClientHello.client_version, as will produce invalid master
             * secret to prevent the attacks.
             */
<span class="nc" id="L220">            preMaster = generatePreMaster(generator, clientVersion);</span>
<span class="nc" id="L221">            protocolVersion = clientVersion;</span>
        }
<span class="nc" id="L223">    }</span>

    /**
     * Checks if all paddings of data are b
     * @param data the block with padding
     * @param len length of data, &gt;= 48
     * @param b expected padding byte
     */
    private static boolean paddingByteIs(byte[] data, int len, byte b) {
<span class="nc bnc" id="L232" title="All 2 branches missed.">        for (int i=48; i&lt;len; i++) {</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (data[i] != b) return false;</span>
        }
<span class="nc" id="L235">        return true;</span>
    }

    /*
     * Used by server to generate premaster secret in case of
     * problem decoding ticket.
     *
     * @param protocolVersion used for preMaster[0,1]
     * @param generator random number generator to use for generating secret.
     */
    KerberosPreMasterSecret(ProtocolVersion protocolVersion,
<span class="nc" id="L246">        SecureRandom generator) {</span>

<span class="nc" id="L248">        this.protocolVersion = protocolVersion;</span>
<span class="nc" id="L249">        preMaster = generatePreMaster(generator, protocolVersion);</span>
<span class="nc" id="L250">    }</span>

    private static byte[] generatePreMaster(SecureRandom rand,
        ProtocolVersion ver) {

<span class="nc" id="L255">        byte[] pm = new byte[48];</span>
<span class="nc" id="L256">        rand.nextBytes(pm);</span>
<span class="nc" id="L257">        pm[0] = ver.major;</span>
<span class="nc" id="L258">        pm[1] = ver.minor;</span>

<span class="nc" id="L260">        return pm;</span>
    }

    // Clone not needed; internal use only
    byte[] getUnencrypted() {
<span class="nc" id="L265">        return preMaster;</span>
    }

    // Clone not needed; internal use only
    byte[] getEncrypted() {
<span class="nc" id="L270">        return encrypted;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>