<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DnsClient.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.dns</a> &gt; <span class="el_source">DnsClient.java</span></div><h1>DnsClient.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jndi.dns;

import java.io.IOException;
import java.net.DatagramSocket;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.net.Socket;
import javax.naming.*;

import java.util.Collections;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;

// Some of this code began life as part of sun.javaos.net.DnsClient
// originally by sritchie@eng 1/96.  It was first hacked up for JNDI
// use by caveh@eng 6/97.


/**
 * The DnsClient class performs DNS client operations in support of DnsContext.
 *
 */

public class DnsClient {

    // DNS packet header field offsets
    private static final int IDENT_OFFSET = 0;
    private static final int FLAGS_OFFSET = 2;
    private static final int NUMQ_OFFSET  = 4;
    private static final int NUMANS_OFFSET = 6;
    private static final int NUMAUTH_OFFSET = 8;
    private static final int NUMADD_OFFSET = 10;
    private static final int DNS_HDR_SIZE = 12;

    // DNS response codes
    private static final int NO_ERROR       = 0;
    private static final int FORMAT_ERROR   = 1;
    private static final int SERVER_FAILURE = 2;
    private static final int NAME_ERROR     = 3;
    private static final int NOT_IMPL       = 4;
    private static final int REFUSED        = 5;

<span class="fc" id="L70">    private static final String[] rcodeDescription = {</span>
        &quot;No error&quot;,
        &quot;DNS format error&quot;,
        &quot;DNS server failure&quot;,
        &quot;DNS name not found&quot;,
        &quot;DNS operation not supported&quot;,
        &quot;DNS service refused&quot;
    };

    private static final int DEFAULT_PORT = 53;
    private InetAddress[] servers;
    private int[] serverPorts;
    private int timeout;                // initial timeout on UDP queries in ms
    private int retries;                // number of UDP retries

    private DatagramSocket udpSocket;

    // Requests sent
    private Set&lt;Integer&gt; reqs;

    // Responses received
    private Map&lt;Integer, byte[]&gt; resps;

    //-------------------------------------------------------------------------

    /*
     * Each server is of the form &quot;server[:port]&quot;.  IPv6 literal host names
     * include delimiting brackets.
     * &quot;timeout&quot; is the initial timeout interval (in ms) for UDP queries,
     * and &quot;retries&quot; gives the number of retries per server.
     */
    public DnsClient(String[] servers, int timeout, int retries)
<span class="fc" id="L102">            throws NamingException {</span>
<span class="fc" id="L103">        this.timeout = timeout;</span>
<span class="fc" id="L104">        this.retries = retries;</span>
        try {
<span class="fc" id="L106">            udpSocket = new DatagramSocket();</span>
<span class="nc" id="L107">        } catch (java.net.SocketException e) {</span>
<span class="nc" id="L108">            NamingException ne = new ConfigurationException();</span>
<span class="nc" id="L109">            ne.setRootCause(e);</span>
<span class="nc" id="L110">            throw ne;</span>
<span class="fc" id="L111">        }</span>

<span class="fc" id="L113">        this.servers = new InetAddress[servers.length];</span>
<span class="fc" id="L114">        serverPorts = new int[servers.length];</span>

<span class="fc bfc" id="L116" title="All 2 branches covered.">        for (int i = 0; i &lt; servers.length; i++) {</span>

            // Is optional port given?
<span class="fc" id="L119">            int colon = servers[i].indexOf(':',</span>
<span class="fc" id="L120">                                           servers[i].indexOf(']') + 1);</span>

<span class="pc bpc" id="L122" title="1 of 2 branches missed.">            serverPorts[i] = (colon &lt; 0)</span>
                ? DEFAULT_PORT
<span class="pc" id="L124">                : Integer.parseInt(servers[i].substring(colon + 1));</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">            String server = (colon &lt; 0)</span>
                ? servers[i]
<span class="pc" id="L127">                : servers[i].substring(0, colon);</span>
            try {
<span class="fc" id="L129">                this.servers[i] = InetAddress.getByName(server);</span>
<span class="nc" id="L130">            } catch (java.net.UnknownHostException e) {</span>
<span class="nc" id="L131">                NamingException ne = new ConfigurationException(</span>
                        &quot;Unknown DNS server: &quot; + server);
<span class="nc" id="L133">                ne.setRootCause(e);</span>
<span class="nc" id="L134">                throw ne;</span>
<span class="fc" id="L135">            }</span>
        }
<span class="fc" id="L137">        reqs = Collections.synchronizedSet(new HashSet&lt;Integer&gt;());</span>
<span class="fc" id="L138">        resps = Collections.synchronizedMap(new HashMap&lt;Integer, byte[]&gt;());</span>
<span class="fc" id="L139">    }</span>

    protected void finalize() {
<span class="fc" id="L142">        close();</span>
<span class="fc" id="L143">    }</span>

    // A lock to access the request and response queues in tandem.
<span class="fc" id="L146">    private Object queuesLock = new Object();</span>

    public void close() {
<span class="fc" id="L149">        udpSocket.close();</span>
<span class="fc" id="L150">        synchronized (queuesLock) {</span>
<span class="fc" id="L151">            reqs.clear();</span>
<span class="fc" id="L152">            resps.clear();</span>
<span class="pc" id="L153">        }</span>
<span class="fc" id="L154">    }</span>


<span class="fc" id="L157">    private int ident = 0;              // used to set the msg ID field</span>
<span class="fc" id="L158">    private Object identLock = new Object();</span>

    /*
     * If recursion is true, recursion is requested on the query.
     * If auth is true, only authoritative responses are accepted; other
     * responses throw NameNotFoundException.
     */
    ResourceRecords query(DnsName fqdn, int qclass, int qtype,
                          boolean recursion, boolean auth)
            throws NamingException {

        int xid;
<span class="fc" id="L170">        synchronized (identLock) {</span>
<span class="fc" id="L171">            ident = 0xFFFF &amp; (ident + 1);</span>
<span class="fc" id="L172">            xid = ident;</span>
<span class="pc" id="L173">        }</span>

        // enqueue the outstanding request
<span class="fc" id="L176">        reqs.add(xid);</span>

<span class="fc" id="L178">        Packet pkt = makeQueryPacket(fqdn, xid, qclass, qtype, recursion);</span>

<span class="fc" id="L180">        Exception caughtException = null;</span>
<span class="fc" id="L181">        boolean[] doNotRetry = new boolean[servers.length];</span>

        //
        // The UDP retry strategy is to try the 1st server, and then
        // each server in order. If no answer, double the timeout
        // and try each server again.
        //
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">        for (int retry = 0; retry &lt; retries; retry++) {</span>

            // Try each name server.
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            for (int i = 0; i &lt; servers.length; i++) {</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                if (doNotRetry[i]) {</span>
<span class="nc" id="L193">                    continue;</span>
                }

                // send the request packet and wait for a response.
                try {
                    if (debug) {
                        dprint(&quot;SEND ID (&quot; + (retry + 1) + &quot;): &quot; + xid);
                    }

<span class="nc" id="L202">                    byte[] msg = null;</span>
<span class="nc" id="L203">                    msg = doUdpQuery(pkt, servers[i], serverPorts[i],</span>
                                        retry, xid);
                    //
                    // If the matching response is not got within the
                    // given timeout, check if the response was enqueued
                    // by some other thread, if not proceed with the next
                    // server or retry.
                    //
<span class="nc bnc" id="L211" title="All 2 branches missed.">                    if (msg == null) {</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">                        if (resps.size() &gt; 0) {</span>
<span class="nc" id="L213">                            msg = lookupResponse(xid);</span>
                        }
<span class="nc bnc" id="L215" title="All 2 branches missed.">                        if (msg == null) { // try next server or retry</span>
<span class="nc" id="L216">                            continue;</span>
                        }
                    }
<span class="nc" id="L219">                    Header hdr = new Header(msg, msg.length);</span>

<span class="nc bnc" id="L221" title="All 4 branches missed.">                    if (auth &amp;&amp; !hdr.authoritative) {</span>
<span class="nc" id="L222">                        caughtException = new NameNotFoundException(</span>
                                &quot;DNS response not authoritative&quot;);
<span class="nc" id="L224">                        doNotRetry[i] = true;</span>
<span class="nc" id="L225">                        continue;</span>
                    }
<span class="nc bnc" id="L227" title="All 2 branches missed.">                    if (hdr.truncated) {    // message is truncated -- try TCP</span>

                        // Try each server, starting with the one that just
                        // provided the truncated message.
<span class="nc bnc" id="L231" title="All 2 branches missed.">                        for (int j = 0; j &lt; servers.length; j++) {</span>
<span class="nc" id="L232">                            int ij = (i + j) % servers.length;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                            if (doNotRetry[ij]) {</span>
<span class="nc" id="L234">                                continue;</span>
                            }
                            try {
<span class="nc" id="L237">                                Tcp tcp =</span>
                                    new Tcp(servers[ij], serverPorts[ij]);
                                byte[] msg2;
                                try {
<span class="nc" id="L241">                                    msg2 = doTcpQuery(tcp, pkt);</span>
                                } finally {
<span class="nc" id="L243">                                    tcp.close();</span>
<span class="nc" id="L244">                                }</span>
<span class="nc" id="L245">                                Header hdr2 = new Header(msg2, msg2.length);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">                                if (hdr2.query) {</span>
<span class="nc" id="L247">                                    throw new CommunicationException(</span>
                                        &quot;DNS error: expecting response&quot;);
                                }
<span class="nc" id="L250">                                checkResponseCode(hdr2);</span>

<span class="nc bnc" id="L252" title="All 4 branches missed.">                                if (!auth || hdr2.authoritative) {</span>
                                    // Got a valid response
<span class="nc" id="L254">                                    hdr = hdr2;</span>
<span class="nc" id="L255">                                    msg = msg2;</span>
<span class="nc" id="L256">                                    break;</span>
                                } else {
<span class="nc" id="L258">                                    doNotRetry[ij] = true;</span>
                                }
<span class="nc" id="L260">                            } catch (Exception e) {</span>
                                // Try next server, or use UDP response
<span class="nc" id="L262">                            }</span>
                        } // servers
                    }
<span class="nc" id="L265">                    return new ResourceRecords(msg, msg.length, hdr, false);</span>

<span class="nc" id="L267">                } catch (IOException e) {</span>
                    if (debug) {
                        dprint(&quot;Caught IOException:&quot; + e);
                    }
<span class="nc bnc" id="L271" title="All 2 branches missed.">                    if (caughtException == null) {</span>
<span class="nc" id="L272">                        caughtException = e;</span>
                    }
                    // Use reflection to allow pre-1.4 compilation.
                    // This won't be needed much longer.
<span class="nc bnc" id="L276" title="All 2 branches missed.">                    if (e.getClass().getName().equals(</span>
                            &quot;java.net.PortUnreachableException&quot;)) {
<span class="nc" id="L278">                        doNotRetry[i] = true;</span>
                    }
<span class="fc" id="L280">                } catch (NameNotFoundException e) {</span>
<span class="fc" id="L281">                    throw e;</span>
<span class="nc" id="L282">                } catch (CommunicationException e) {</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">                    if (caughtException == null) {</span>
<span class="nc" id="L284">                        caughtException = e;</span>
                    }
<span class="nc" id="L286">                } catch (NamingException e) {</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">                    if (caughtException == null) {</span>
<span class="nc" id="L288">                        caughtException = e;</span>
                    }
<span class="nc" id="L290">                    doNotRetry[i] = true;</span>
<span class="nc" id="L291">                }</span>
            } // servers
        } // retries

<span class="nc" id="L295">        reqs.remove(xid);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (caughtException instanceof NamingException) {</span>
<span class="nc" id="L297">            throw (NamingException) caughtException;</span>
        }
        // A network timeout or other error occurred.
<span class="nc" id="L300">        NamingException ne = new CommunicationException(&quot;DNS error&quot;);</span>
<span class="nc" id="L301">        ne.setRootCause(caughtException);</span>
<span class="nc" id="L302">        throw ne;</span>
    }

    ResourceRecords queryZone(DnsName zone, int qclass, boolean recursion)
            throws NamingException {

        int xid;
<span class="nc" id="L309">        synchronized (identLock) {</span>
<span class="nc" id="L310">            ident = 0xFFFF &amp; (ident + 1);</span>
<span class="nc" id="L311">            xid = ident;</span>
<span class="nc" id="L312">        }</span>
<span class="nc" id="L313">        Packet pkt = makeQueryPacket(zone, xid, qclass,</span>
                                     ResourceRecord.QTYPE_AXFR, recursion);
<span class="nc" id="L315">        Exception caughtException = null;</span>

        // Try each name server.
<span class="nc bnc" id="L318" title="All 2 branches missed.">        for (int i = 0; i &lt; servers.length; i++) {</span>
            try {
<span class="nc" id="L320">                Tcp tcp = new Tcp(servers[i], serverPorts[i]);</span>
                byte[] msg;
                try {
<span class="nc" id="L323">                    msg = doTcpQuery(tcp, pkt);</span>
<span class="nc" id="L324">                    Header hdr = new Header(msg, msg.length);</span>
                    // Check only rcode as per
                    // draft-ietf-dnsext-axfr-clarify-04
<span class="nc" id="L327">                    checkResponseCode(hdr);</span>
<span class="nc" id="L328">                    ResourceRecords rrs =</span>
                        new ResourceRecords(msg, msg.length, hdr, true);
<span class="nc bnc" id="L330" title="All 2 branches missed.">                    if (rrs.getFirstAnsType() != ResourceRecord.TYPE_SOA) {</span>
<span class="nc" id="L331">                        throw new CommunicationException(</span>
                                &quot;DNS error: zone xfer doesn't begin with SOA&quot;);
                    }

<span class="nc bnc" id="L335" title="All 2 branches missed.">                    if (rrs.answer.size() == 1 ||</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">                            rrs.getLastAnsType() != ResourceRecord.TYPE_SOA) {</span>
                        // The response is split into multiple DNS messages.
                        do {
<span class="nc" id="L339">                            msg = continueTcpQuery(tcp);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                            if (msg == null) {</span>
<span class="nc" id="L341">                                throw new CommunicationException(</span>
                                        &quot;DNS error: incomplete zone transfer&quot;);
                            }
<span class="nc" id="L344">                            hdr = new Header(msg, msg.length);</span>
<span class="nc" id="L345">                            checkResponseCode(hdr);</span>
<span class="nc" id="L346">                            rrs.add(msg, msg.length, hdr);</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">                        } while (rrs.getLastAnsType() !=</span>
                                 ResourceRecord.TYPE_SOA);
                    }

                    // Delete the duplicate SOA record.
<span class="nc" id="L352">                    rrs.answer.removeElementAt(rrs.answer.size() - 1);</span>
<span class="nc" id="L353">                    return rrs;</span>

                } finally {
<span class="nc" id="L356">                    tcp.close();</span>
                }

<span class="nc" id="L359">            } catch (IOException e) {</span>
<span class="nc" id="L360">                caughtException = e;</span>
<span class="nc" id="L361">            } catch (NameNotFoundException e) {</span>
<span class="nc" id="L362">                throw e;</span>
<span class="nc" id="L363">            } catch (NamingException e) {</span>
<span class="nc" id="L364">                caughtException = e;</span>
<span class="nc" id="L365">            }</span>
        }
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (caughtException instanceof NamingException) {</span>
<span class="nc" id="L368">            throw (NamingException) caughtException;</span>
        }
<span class="nc" id="L370">        NamingException ne = new CommunicationException(</span>
                &quot;DNS error during zone transfer&quot;);
<span class="nc" id="L372">        ne.setRootCause(caughtException);</span>
<span class="nc" id="L373">        throw ne;</span>
    }


    /**
     * Tries to retreive an UDP packet matching the given xid
     * received within the timeout.
     * If a packet with different xid is received, the received packet
     * is enqueued with the corresponding xid in 'resps'.
     */
    private byte[] doUdpQuery(Packet pkt, InetAddress server,
                                     int port, int retry, int xid)
            throws IOException, NamingException {

<span class="fc" id="L387">        int minTimeout = 50; // msec after which there are no retries.</span>

<span class="fc" id="L389">        synchronized (udpSocket) {</span>
<span class="fc" id="L390">            DatagramPacket opkt = new DatagramPacket(</span>
<span class="fc" id="L391">                    pkt.getData(), pkt.length(), server, port);</span>
<span class="fc" id="L392">            DatagramPacket ipkt = new DatagramPacket(new byte[8000], 8000);</span>
<span class="fc" id="L393">            udpSocket.connect(server, port);</span>
<span class="fc" id="L394">            int pktTimeout = (timeout * (1 &lt;&lt; retry));</span>
            try {
<span class="fc" id="L396">                udpSocket.send(opkt);</span>

                // timeout remaining after successive 'receive()'
<span class="fc" id="L399">                int timeoutLeft = pktTimeout;</span>
<span class="fc" id="L400">                int cnt = 0;</span>
                do {
                    if (debug) {
                       cnt++;
                        dprint(&quot;Trying RECEIVE(&quot; +
                                cnt + &quot;) retry(&quot; + (retry + 1) +
                                &quot;) for:&quot; + xid  + &quot;    sock-timeout:&quot; +
                                timeoutLeft + &quot; ms.&quot;);
                    }
<span class="nc" id="L409">                    udpSocket.setSoTimeout(timeoutLeft);</span>
<span class="nc" id="L410">                    long start = System.currentTimeMillis();</span>
<span class="nc" id="L411">                    udpSocket.receive(ipkt);</span>
<span class="nc" id="L412">                    long end = System.currentTimeMillis();</span>

<span class="nc" id="L414">                    byte[] data = new byte[ipkt.getLength()];</span>
<span class="nc" id="L415">                    data = ipkt.getData();</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">                    if (isMatchResponse(data, xid)) {</span>
<span class="nc" id="L417">                        return data;</span>
                    }
<span class="nc" id="L419">                    timeoutLeft = pktTimeout - ((int) (end - start));</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                } while (timeoutLeft &gt; minTimeout);</span>

            } finally {
<span class="pc" id="L423">                udpSocket.disconnect();</span>
<span class="nc" id="L424">            }</span>
<span class="nc" id="L425">            return null; // no matching packet received within the timeout</span>
<span class="fc" id="L426">        }</span>
    }

    /*
     * Sends a TCP query, and returns the first DNS message in the response.
     */
    private byte[] doTcpQuery(Tcp tcp, Packet pkt) throws IOException {

<span class="nc" id="L434">        int len = pkt.length();</span>
        // Send 2-byte message length, then send message.
<span class="nc" id="L436">        tcp.out.write(len &gt;&gt; 8);</span>
<span class="nc" id="L437">        tcp.out.write(len);</span>
<span class="nc" id="L438">        tcp.out.write(pkt.getData(), 0, len);</span>
<span class="nc" id="L439">        tcp.out.flush();</span>

<span class="nc" id="L441">        byte[] msg = continueTcpQuery(tcp);</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        if (msg == null) {</span>
<span class="nc" id="L443">            throw new IOException(&quot;DNS error: no response&quot;);</span>
        }
<span class="nc" id="L445">        return msg;</span>
    }

    /*
     * Returns the next DNS message from the TCP socket, or null on EOF.
     */
    private byte[] continueTcpQuery(Tcp tcp) throws IOException {

<span class="nc" id="L453">        int lenHi = tcp.in.read();      // high-order byte of response length</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (lenHi == -1) {</span>
<span class="nc" id="L455">            return null;        // EOF</span>
        }
<span class="nc" id="L457">        int lenLo = tcp.in.read();      // low-order byte of response length</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (lenLo == -1) {</span>
<span class="nc" id="L459">            throw new IOException(&quot;Corrupted DNS response: bad length&quot;);</span>
        }
<span class="nc" id="L461">        int len = (lenHi &lt;&lt; 8) | lenLo;</span>
<span class="nc" id="L462">        byte[] msg = new byte[len];</span>
<span class="nc" id="L463">        int pos = 0;                    // next unfilled position in msg</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">        while (len &gt; 0) {</span>
<span class="nc" id="L465">            int n = tcp.in.read(msg, pos, len);</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            if (n == -1) {</span>
<span class="nc" id="L467">                throw new IOException(</span>
                        &quot;Corrupted DNS response: too little data&quot;);
            }
<span class="nc" id="L470">            len -= n;</span>
<span class="nc" id="L471">            pos += n;</span>
<span class="nc" id="L472">        }</span>
<span class="nc" id="L473">        return msg;</span>
    }

    private Packet makeQueryPacket(DnsName fqdn, int xid,
                                   int qclass, int qtype, boolean recursion) {
<span class="fc" id="L478">        int qnameLen = fqdn.getOctets();</span>
<span class="fc" id="L479">        int pktLen = DNS_HDR_SIZE + qnameLen + 4;</span>
<span class="fc" id="L480">        Packet pkt = new Packet(pktLen);</span>

<span class="pc bpc" id="L482" title="1 of 2 branches missed.">        short flags = recursion ? Header.RD_BIT : 0;</span>

<span class="fc" id="L484">        pkt.putShort(xid, IDENT_OFFSET);</span>
<span class="fc" id="L485">        pkt.putShort(flags, FLAGS_OFFSET);</span>
<span class="fc" id="L486">        pkt.putShort(1, NUMQ_OFFSET);</span>
<span class="fc" id="L487">        pkt.putShort(0, NUMANS_OFFSET);</span>
<span class="fc" id="L488">        pkt.putInt(0, NUMAUTH_OFFSET);</span>

<span class="fc" id="L490">        makeQueryName(fqdn, pkt, DNS_HDR_SIZE);</span>
<span class="fc" id="L491">        pkt.putShort(qtype, DNS_HDR_SIZE + qnameLen);</span>
<span class="fc" id="L492">        pkt.putShort(qclass, DNS_HDR_SIZE + qnameLen + 2);</span>

<span class="fc" id="L494">        return pkt;</span>
    }

    // Builds a query name in pkt according to the RFC spec.
    private void makeQueryName(DnsName fqdn, Packet pkt, int off) {

        // Loop through labels, least-significant first.
<span class="fc bfc" id="L501" title="All 2 branches covered.">        for (int i = fqdn.size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L502">            String label = fqdn.get(i);</span>
<span class="fc" id="L503">            int len = label.length();</span>

<span class="fc" id="L505">            pkt.putByte(len, off++);</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">            for (int j = 0; j &lt; len; j++) {</span>
<span class="fc" id="L507">                pkt.putByte(label.charAt(j), off++);</span>
            }
        }
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">        if (!fqdn.hasRootLabel()) {</span>
<span class="nc" id="L511">            pkt.putByte(0, off);</span>
        }
<span class="fc" id="L513">    }</span>

    //-------------------------------------------------------------------------

    private byte[] lookupResponse(Integer xid) throws NamingException {
        //
        // Check the queued responses: some other thread in between
        // received the response for this request.
        //
        if (debug) {
            dprint(&quot;LOOKUP for: &quot; + xid +
                &quot;\tResponse Q:&quot; + resps);
        }
        byte[] pkt;
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if ((pkt = resps.get(xid)) != null) {</span>
<span class="nc" id="L528">            checkResponseCode(new Header(pkt, pkt.length));</span>
<span class="nc" id="L529">            synchronized (queuesLock) {</span>
<span class="nc" id="L530">                resps.remove(xid);</span>
<span class="nc" id="L531">                reqs.remove(xid);</span>
<span class="nc" id="L532">            }</span>

            if (debug) {
                dprint(&quot;FOUND (&quot; + Thread.currentThread() +
                    &quot;) for:&quot; + xid);
            }
        }
<span class="nc" id="L539">        return pkt;</span>
    }

    /*
     * Checks the header of an incoming DNS response.
     * Returns true if it matches the given xid and throws a naming
     * exception, if appropriate, based on the response code.
     */
    private boolean isMatchResponse(byte[] pkt, int xid)
                throws NamingException {

<span class="nc" id="L550">        Header hdr = new Header(pkt, pkt.length);</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">        if (hdr.query) {</span>
<span class="nc" id="L552">            throw new CommunicationException(&quot;DNS error: expecting response&quot;);</span>
        }

<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (!reqs.contains(xid)) { // already received, ignore the response</span>
<span class="nc" id="L556">            return false;</span>
        }

        // common case- the request sent matches the subsequent response read
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (hdr.xid == xid) {</span>
            if (debug) {
                dprint(&quot;XID MATCH:&quot; + xid);
            }

<span class="nc" id="L565">            checkResponseCode(hdr);</span>
            // remove the response for the xid if received by some other thread.
<span class="nc" id="L567">            synchronized (queuesLock) {</span>
<span class="nc" id="L568">                resps.remove(xid);</span>
<span class="nc" id="L569">                reqs.remove(xid);</span>
<span class="nc" id="L570">            }</span>
<span class="nc" id="L571">            return true;</span>
        }

        //
        // xid mis-match: enqueue the response, it may belong to some other
        // thread that has not yet had a chance to read its response.
        // enqueue only the first response, responses for retries are ignored.
        //
<span class="nc" id="L579">        synchronized (queuesLock) {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">            if (reqs.contains(hdr.xid)) { // enqueue only the first response</span>
<span class="nc" id="L581">                resps.put(hdr.xid, pkt);</span>
            }
<span class="nc" id="L583">        }</span>

        if (debug) {
            dprint(&quot;NO-MATCH SEND ID:&quot; +
                                xid + &quot; RECVD ID:&quot; + hdr.xid +
                                &quot;    Response Q:&quot; + resps +
                                &quot;    Reqs size:&quot; + reqs.size());
        }
<span class="nc" id="L591">        return false;</span>
    }

    /*
     * Throws an exception if appropriate for the response code of a
     * given header.
     */
    private void checkResponseCode(Header hdr) throws NamingException {

<span class="fc" id="L600">        int rcode = hdr.rcode;</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">        if (rcode == NO_ERROR) {</span>
<span class="nc" id="L602">            return;</span>
        }
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">        String msg = (rcode &lt; rcodeDescription.length)</span>
            ? rcodeDescription[rcode]
            : &quot;DNS error&quot;;
<span class="fc" id="L607">        msg += &quot; [response code &quot; + rcode + &quot;]&quot;;</span>

<span class="pc bpc" id="L609" title="3 of 4 branches missed.">        switch (rcode) {</span>
        case SERVER_FAILURE:
<span class="nc" id="L611">            throw new ServiceUnavailableException(msg);</span>
        case NAME_ERROR:
<span class="fc" id="L613">            throw new NameNotFoundException(msg);</span>
        case NOT_IMPL:
        case REFUSED:
<span class="nc" id="L616">            throw new OperationNotSupportedException(msg);</span>
        case FORMAT_ERROR:
        default:
<span class="nc" id="L619">            throw new NamingException(msg);</span>
        }
    }

    //-------------------------------------------------------------------------

    private static final boolean debug = false;

    private static void dprint(String mess) {
        if (debug) {
            System.err.println(&quot;DNS: &quot; + mess);
        }
<span class="nc" id="L631">    }</span>

}

class Tcp {

    private Socket sock;
    java.io.InputStream in;
    java.io.OutputStream out;

<span class="nc" id="L641">    Tcp(InetAddress server, int port) throws IOException {</span>
<span class="nc" id="L642">        sock = new Socket(server, port);</span>
<span class="nc" id="L643">        sock.setTcpNoDelay(true);</span>
<span class="nc" id="L644">        out = new java.io.BufferedOutputStream(sock.getOutputStream());</span>
<span class="nc" id="L645">        in = new java.io.BufferedInputStream(sock.getInputStream());</span>
<span class="nc" id="L646">    }</span>

    void close() throws IOException {
<span class="nc" id="L649">        sock.close();</span>
<span class="nc" id="L650">    }</span>
}

/*
 * javaos emulation -cj
 */
class Packet {
        byte buf[];

<span class="fc" id="L659">        Packet(int len) {</span>
<span class="fc" id="L660">                buf = new byte[len];</span>
<span class="fc" id="L661">        }</span>

<span class="nc" id="L663">        Packet(byte data[], int len) {</span>
<span class="nc" id="L664">                buf = new byte[len];</span>
<span class="nc" id="L665">                System.arraycopy(data, 0, buf, 0, len);</span>
<span class="nc" id="L666">        }</span>

        void putInt(int x, int off) {
<span class="fc" id="L669">                buf[off + 0] = (byte)(x &gt;&gt; 24);</span>
<span class="fc" id="L670">                buf[off + 1] = (byte)(x &gt;&gt; 16);</span>
<span class="fc" id="L671">                buf[off + 2] = (byte)(x &gt;&gt; 8);</span>
<span class="fc" id="L672">                buf[off + 3] = (byte)x;</span>
<span class="fc" id="L673">        }</span>

        void putShort(int x, int off) {
<span class="fc" id="L676">                buf[off + 0] = (byte)(x &gt;&gt; 8);</span>
<span class="fc" id="L677">                buf[off + 1] = (byte)x;</span>
<span class="fc" id="L678">        }</span>

        void putByte(int x, int off) {
<span class="fc" id="L681">                buf[off] = (byte)x;</span>
<span class="fc" id="L682">        }</span>

        void putBytes(byte src[], int src_offset, int dst_offset, int len) {
<span class="nc" id="L685">                System.arraycopy(src, src_offset, buf, dst_offset, len);</span>
<span class="nc" id="L686">        }</span>

        int length() {
<span class="fc" id="L689">                return buf.length;</span>
        }

        byte[] getData() {
<span class="fc" id="L693">                return buf;</span>
        }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>