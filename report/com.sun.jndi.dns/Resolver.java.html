<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Resolver.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.dns</a> &gt; <span class="el_source">Resolver.java</span></div><h1>Resolver.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jndi.dns;


import javax.naming.*;


/**
 * The Resolver class performs DNS client operations in support of DnsContext.
 *
 * &lt;p&gt; Every DnsName instance passed to or returned from a method of
 * this class should be fully-qualified and contain a root label (an
 * empty component at position 0).
 *
 * @author Scott Seligman
 */

class Resolver {

    private DnsClient dnsClient;
    private int timeout;                // initial timeout on UDP queries in ms
    private int retries;                // number of UDP retries


    /*
     * Constructs a new Resolver given its servers and timeout parameters.
     * Each server is of the form &quot;server[:port]&quot;.
     * IPv6 literal host names include delimiting brackets.
     * There must be at least one server.
     * &quot;timeout&quot; is the initial timeout interval (in ms) for UDP queries,
     * and &quot;retries&quot; gives the number of retries per server.
     */
    Resolver(String[] servers, int timeout, int retries)
<span class="fc" id="L58">            throws NamingException {</span>
<span class="fc" id="L59">        this.timeout = timeout;</span>
<span class="fc" id="L60">        this.retries = retries;</span>
<span class="fc" id="L61">        dnsClient = new DnsClient(servers, timeout, retries);</span>
<span class="fc" id="L62">    }</span>

    public void close() {
<span class="fc" id="L65">        dnsClient.close();</span>
<span class="fc" id="L66">        dnsClient = null;</span>
<span class="fc" id="L67">    }</span>


    /*
     * Queries resource records of a particular class and type for a
     * given domain name.
     * Useful values of rrclass are ResourceRecord.[Q]CLASS_xxx.
     * Useful values of rrtype are ResourceRecord.[Q]TYPE_xxx.
     * If recursion is true, recursion is requested on the query.
     * If auth is true, only authoritative responses are accepted.
     */
    ResourceRecords query(DnsName fqdn, int rrclass, int rrtype,
                          boolean recursion, boolean auth)
            throws NamingException {
<span class="nc" id="L81">        return dnsClient.query(fqdn, rrclass, rrtype, recursion, auth);</span>
    }

    /*
     * Queries all resource records of a zone given its domain name and class.
     * If recursion is true, recursion is requested on the query to find
     * the name server (and also on the zone transfer, but it won't matter).
     */
    ResourceRecords queryZone(DnsName zone, int rrclass, boolean recursion)
            throws NamingException {

<span class="nc" id="L92">        DnsClient cl =</span>
<span class="nc" id="L93">            new DnsClient(findNameServers(zone, recursion), timeout, retries);</span>
        try {
<span class="nc" id="L95">            return cl.queryZone(zone, rrclass, recursion);</span>
        } finally {
<span class="nc" id="L97">            cl.close();</span>
        }
    }

    /*
     * Finds the zone of a given domain name.  The method is to look
     * for the first SOA record on the path from the given domain to
     * the root.  This search may be partially bypassed if the zone's
     * SOA record is received in the authority section of a response.
     * If recursion is true, recursion is requested on any queries.
     */
    DnsName findZoneName(DnsName fqdn, int rrclass, boolean recursion)
            throws NamingException {

<span class="nc" id="L111">        fqdn = (DnsName) fqdn.clone();</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">        while (fqdn.size() &gt; 1) {       // while below root</span>
<span class="nc" id="L113">            ResourceRecords rrs = null;</span>
            try {
<span class="nc" id="L115">                rrs = query(fqdn, rrclass, ResourceRecord.TYPE_SOA,</span>
                            recursion, false);
<span class="nc" id="L117">            } catch (NameNotFoundException e) {</span>
<span class="nc" id="L118">                throw e;</span>
<span class="nc" id="L119">            } catch (NamingException e) {</span>
                // Ignore error and keep searching up the tree.
<span class="nc" id="L121">            }</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            if (rrs != null) {</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                if (rrs.answer.size() &gt; 0) {    // found zone's SOA</span>
<span class="nc" id="L124">                    return fqdn;</span>
                }
                // Look for an SOA record giving the zone's top node.
<span class="nc bnc" id="L127" title="All 2 branches missed.">                for (int i = 0; i &lt; rrs.authority.size(); i++) {</span>
<span class="nc" id="L128">                    ResourceRecord rr = rrs.authority.elementAt(i);</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">                    if (rr.getType() == ResourceRecord.TYPE_SOA) {</span>
<span class="nc" id="L130">                        DnsName zone = rr.getName();</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                        if (fqdn.endsWith(zone)) {</span>
<span class="nc" id="L132">                            return zone;</span>
                        }
                    }
                }
            }
<span class="nc" id="L137">            fqdn.remove(fqdn.size() - 1);       // one step rootward</span>
<span class="nc" id="L138">        }</span>
<span class="nc" id="L139">        return fqdn;                    // no SOA found below root, so</span>
                                        // return root
    }

    /*
     * Finds a zone's SOA record.  Returns null if no SOA is found (in
     * which case &quot;zone&quot; is not actually a zone).
     * If recursion is true, recursion is requested on the query.
     */
     ResourceRecord findSoa(DnsName zone, int rrclass, boolean recursion)
            throws NamingException {

<span class="nc" id="L151">        ResourceRecords rrs = query(zone, rrclass, ResourceRecord.TYPE_SOA,</span>
                                    recursion, false);
<span class="nc bnc" id="L153" title="All 2 branches missed.">        for (int i = 0; i &lt; rrs.answer.size(); i++) {</span>
<span class="nc" id="L154">            ResourceRecord rr = rrs.answer.elementAt(i);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (rr.getType() == ResourceRecord.TYPE_SOA) {</span>
<span class="nc" id="L156">                return rr;</span>
            }
        }
<span class="nc" id="L159">        return null;</span>
    }

    /*
     * Finds the name servers of a zone.  &lt;tt&gt;zone&lt;/tt&gt; is a fully-qualified
     * domain name at the top of a zone.
     * If recursion is true, recursion is requested on the query.
     */
    private String[] findNameServers(DnsName zone, boolean recursion)
            throws NamingException {

        // %%% As an optimization, could look in authority section of
        // findZoneName() response first.
<span class="nc" id="L172">        ResourceRecords rrs =</span>
<span class="nc" id="L173">            query(zone, ResourceRecord.CLASS_INTERNET, ResourceRecord.TYPE_NS,</span>
                  recursion, false);
<span class="nc" id="L175">        String[] ns = new String[rrs.answer.size()];</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        for (int i = 0; i &lt; ns.length; i++) {</span>
<span class="nc" id="L177">            ResourceRecord rr = rrs.answer.elementAt(i);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            if (rr.getType() != ResourceRecord.TYPE_NS) {</span>
<span class="nc" id="L179">                throw new CommunicationException(&quot;Corrupted DNS message&quot;);</span>
            }
<span class="nc" id="L181">            ns[i] = (String) rr.getRdata();</span>

            // Server name will be passed to InetAddress.getByName(), which
            // may not be able to handle a trailing dot.
            // assert ns[i].endsWith(&quot;.&quot;);
<span class="nc" id="L186">            ns[i] = ns[i].substring(0, ns[i].length() - 1);</span>
        }
<span class="nc" id="L188">        return ns;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>