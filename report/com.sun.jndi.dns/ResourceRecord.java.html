<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ResourceRecord.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.dns</a> &gt; <span class="el_source">ResourceRecord.java</span></div><h1>ResourceRecord.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jndi.dns;

import javax.naming.InvalidNameException;


/**
 * The ResourceRecord class represents a DNS resource record.
 * The string format is based on the master file representation in
 * RFC 1035.
 *
 * @author Scott Seligman
 */


public class ResourceRecord {

    /*
     * Resource record type codes
     */
    static final int TYPE_A     =  1;
    static final int TYPE_NS    =  2;
    static final int TYPE_CNAME =  5;
    static final int TYPE_SOA   =  6;
    static final int TYPE_PTR   = 12;
    static final int TYPE_HINFO = 13;
    static final int TYPE_MX    = 15;
    static final int TYPE_TXT   = 16;
    static final int TYPE_AAAA  = 28;
    static final int TYPE_SRV   = 33;
    static final int TYPE_NAPTR = 35;
    static final int QTYPE_AXFR = 252;          // zone transfer
    static final int QTYPE_STAR = 255;          // query type &quot;*&quot;

    /*
     * Mapping from resource record type codes to type name strings.
     */
<span class="fc" id="L62">    static final String rrTypeNames[] = {</span>
        null, &quot;A&quot;, &quot;NS&quot;, null, null,
        &quot;CNAME&quot;, &quot;SOA&quot;, null, null, null,
        null, null, &quot;PTR&quot;, &quot;HINFO&quot;, null,
        &quot;MX&quot;, &quot;TXT&quot;, null, null, null,
        null, null, null, null, null,
        null, null, null, &quot;AAAA&quot;, null,
        null, null, null, &quot;SRV&quot;, null,
        &quot;NAPTR&quot;
    };

    /*
     * Resource record class codes
     */
    static final int CLASS_INTERNET = 1;
    static final int CLASS_HESIOD   = 2;
    static final int QCLASS_STAR    = 255;      // query class &quot;*&quot;

    /*
     * Mapping from resource record type codes to class name strings.
     */
<span class="fc" id="L83">    static final String rrClassNames[] = {</span>
        null, &quot;IN&quot;, null, null, &quot;HS&quot;
    };


    byte[] msg;                 // DNS message
    int msgLen;                 // msg size (in octets)
    boolean qSection;           // true if this RR is part of question section
                                // and therefore has no ttl or rdata
    int offset;                 // offset of RR w/in msg
    int rrlen;                  // number of octets in encoded RR
    DnsName name;               // name field of RR, including root label
    int rrtype;                 // type field of RR
    String rrtypeName;          // name of of rrtype
    int rrclass;                // class field of RR
    String rrclassName;         // name of rrclass
<span class="nc" id="L99">    int ttl = 0;                // ttl field of RR</span>
<span class="nc" id="L100">    int rdlen = 0;              // number of octets of rdata</span>
<span class="nc" id="L101">    Object rdata = null;        // rdata -- most are String, unknown are byte[]</span>


    /*
     * Constructs a new ResourceRecord.  The encoded data of the DNS
     * message is contained in msg; data for this RR begins at msg[offset].
     * If qSection is true this RR is part of a question section.  It's
     * not a true resource record in that case, but is treated as if it
     * were a shortened one (with no ttl or rdata).  If decodeRdata is
     * false, the rdata is not decoded (and getRdata() will return null)
     * unless this is an SOA record.
     *
     * @throws InvalidNameException if a decoded domain name isn't valid.
     * @throws ArrayIndexOutOfBoundsException given certain other corrupt data.
     */
    ResourceRecord(byte[] msg, int msgLen, int offset,
                   boolean qSection, boolean decodeRdata)
<span class="nc" id="L118">            throws InvalidNameException {</span>

<span class="nc" id="L120">        this.msg = msg;</span>
<span class="nc" id="L121">        this.msgLen = msgLen;</span>
<span class="nc" id="L122">        this.offset = offset;</span>
<span class="nc" id="L123">        this.qSection = qSection;</span>
<span class="nc" id="L124">        decode(decodeRdata);</span>
<span class="nc" id="L125">    }</span>

    public String toString() {
<span class="nc" id="L128">        String text = name + &quot; &quot; + rrclassName + &quot; &quot; + rrtypeName;</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (!qSection) {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            text += &quot; &quot; + ttl + &quot; &quot; +</span>
                ((rdata != null) ? rdata : &quot;[n/a]&quot;);
        }
<span class="nc" id="L133">        return text;</span>
    }

    /*
     * Returns the name field of this RR, including the root label.
     */
    public DnsName getName() {
<span class="nc" id="L140">        return name;</span>
    }

    /*
     * Returns the number of octets in the encoded RR.
     */
    public int size() {
<span class="nc" id="L147">        return rrlen;</span>
    }

    public int getType() {
<span class="nc" id="L151">        return rrtype;</span>
    }

    public int getRrclass() {
<span class="nc" id="L155">        return rrclass;</span>
    }

    public Object getRdata() {
<span class="nc" id="L159">        return rdata;</span>
    }


    public static String getTypeName(int rrtype) {
<span class="nc" id="L164">        return valueToName(rrtype, rrTypeNames);</span>
    }

    public static int getType(String typeName) {
<span class="fc" id="L168">        return nameToValue(typeName, rrTypeNames);</span>
    }

    public static String getRrclassName(int rrclass) {
<span class="nc" id="L172">        return valueToName(rrclass, rrClassNames);</span>
    }

    public static int getRrclass(String className) {
<span class="nc" id="L176">        return nameToValue(className, rrClassNames);</span>
    }

    private static String valueToName(int val, String[] names) {
<span class="nc" id="L180">        String name = null;</span>
<span class="nc bnc" id="L181" title="All 4 branches missed.">        if ((val &gt; 0) &amp;&amp; (val &lt; names.length)) {</span>
<span class="nc" id="L182">            name = names[val];</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">        } else if (val == QTYPE_STAR) {         // QTYPE_STAR == QCLASS_STAR</span>
<span class="nc" id="L184">            name = &quot;*&quot;;</span>
        }
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L187">            name = Integer.toString(val);</span>
        }
<span class="nc" id="L189">        return name;</span>
    }

    private static int nameToValue(String name, String[] names) {
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (name.equals(&quot;&quot;)) {</span>
<span class="nc" id="L194">            return -1;                          // invalid name</span>
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        } else if (name.equals(&quot;*&quot;)) {</span>
<span class="nc" id="L196">            return QTYPE_STAR;                  // QTYPE_STAR == QCLASS_STAR</span>
        }
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (Character.isDigit(name.charAt(0))) {</span>
            try {
<span class="nc" id="L200">                return Integer.parseInt(name);</span>
<span class="nc" id="L201">            } catch (NumberFormatException e) {</span>
            }
        }
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        for (int i = 1; i &lt; names.length; i++) {</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">            if ((names[i] != null) &amp;&amp;</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">                    name.equalsIgnoreCase(names[i])) {</span>
<span class="fc" id="L207">                return i;</span>
            }
        }
<span class="nc" id="L210">        return -1;                              // unknown name</span>
    }

    /*
     * Compares two SOA record serial numbers using 32-bit serial number
     * arithmetic as defined in RFC 1982.  Serial numbers are unsigned
     * 32-bit quantities.  Returns a negative, zero, or positive value
     * as the first serial number is less than, equal to, or greater
     * than the second.  If the serial numbers are not comparable the
     * result is undefined.  Note that the relation is not transitive.
     */
    public static int compareSerialNumbers(long s1, long s2) {
<span class="nc" id="L222">        long diff = s2 - s1;</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (diff == 0) {</span>
<span class="nc" id="L224">            return 0;</span>
<span class="nc bnc" id="L225" title="All 8 branches missed.">        } else if ((diff &gt; 0 &amp;&amp;  diff &lt;= 0x7FFFFFFF) ||</span>
                   (diff &lt; 0 &amp;&amp; -diff &gt;  0x7FFFFFFF)) {
<span class="nc" id="L227">            return -1;</span>
        } else {
<span class="nc" id="L229">            return 1;</span>
        }
    }


    /*
     * Decodes the binary format of the RR.
     * May throw ArrayIndexOutOfBoundsException given corrupt data.
     */
    private void decode(boolean decodeRdata) throws InvalidNameException {
<span class="nc" id="L239">        int pos = offset;       // index of next unread octet</span>

<span class="nc" id="L241">        name = new DnsName();                           // NAME</span>
<span class="nc" id="L242">        pos = decodeName(pos, name);</span>

<span class="nc" id="L244">        rrtype = getUShort(pos);                        // TYPE</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        rrtypeName = (rrtype &lt; rrTypeNames.length)</span>
            ? rrTypeNames[rrtype]
            : null;
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (rrtypeName == null) {</span>
<span class="nc" id="L249">            rrtypeName = Integer.toString(rrtype);</span>
        }
<span class="nc" id="L251">        pos += 2;</span>

<span class="nc" id="L253">        rrclass = getUShort(pos);                       // CLASS</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        rrclassName = (rrclass &lt; rrClassNames.length)</span>
            ? rrClassNames[rrclass]
            : null;
<span class="nc bnc" id="L257" title="All 2 branches missed.">        if (rrclassName == null) {</span>
<span class="nc" id="L258">            rrclassName = Integer.toString(rrclass);</span>
        }
<span class="nc" id="L260">        pos += 2;</span>

<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (!qSection) {</span>
<span class="nc" id="L263">            ttl = getInt(pos);                          // TTL</span>
<span class="nc" id="L264">            pos += 4;</span>

<span class="nc" id="L266">            rdlen = getUShort(pos);                     // RDLENGTH</span>
<span class="nc" id="L267">            pos += 2;</span>

<span class="nc bnc" id="L269" title="All 4 branches missed.">            rdata = (decodeRdata ||                     // RDATA</span>
                     (rrtype == TYPE_SOA))
<span class="nc" id="L271">                ? decodeRdata(pos)</span>
                : null;
<span class="nc bnc" id="L273" title="All 2 branches missed.">            if (rdata instanceof DnsName) {</span>
<span class="nc" id="L274">                rdata = rdata.toString();</span>
            }
<span class="nc" id="L276">            pos += rdlen;</span>
        }

<span class="nc" id="L279">        rrlen = pos - offset;</span>

<span class="nc" id="L281">        msg = null;     // free up for GC</span>
<span class="nc" id="L282">    }</span>

    /*
     * Returns the 1-byte unsigned value at msg[pos].
     */
    private int getUByte(int pos) {
<span class="nc" id="L288">        return (msg[pos] &amp; 0xFF);</span>
    }

    /*
     * Returns the 2-byte unsigned value at msg[pos].  The high
     * order byte comes first.
     */
    private int getUShort(int pos) {
<span class="nc" id="L296">        return (((msg[pos] &amp; 0xFF) &lt;&lt; 8) |</span>
                (msg[pos + 1] &amp; 0xFF));
    }

    /*
     * Returns the 4-byte signed value at msg[pos].  The high
     * order byte comes first.
     */
    private int getInt(int pos) {
<span class="nc" id="L305">        return ((getUShort(pos) &lt;&lt; 16) | getUShort(pos + 2));</span>
    }

    /*
     * Returns the 4-byte unsigned value at msg[pos].  The high
     * order byte comes first.
     */
    private long getUInt(int pos) {
<span class="nc" id="L313">        return (getInt(pos) &amp; 0xffffffffL);</span>
    }

    /*
     * Returns the name encoded at msg[pos], including the root label.
     */
    private DnsName decodeName(int pos) throws InvalidNameException {
<span class="nc" id="L320">        DnsName n = new DnsName();</span>
<span class="nc" id="L321">        decodeName(pos, n);</span>
<span class="nc" id="L322">        return n;</span>
    }

    /*
     * Prepends to &quot;n&quot; the domain name encoded at msg[pos], including the root
     * label.  Returns the index into &quot;msg&quot; following the name.
     */
    private int decodeName(int pos, DnsName n) throws InvalidNameException {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (msg[pos] == 0) {                            // end of name</span>
<span class="nc" id="L331">            n.add(0, &quot;&quot;);</span>
<span class="nc" id="L332">            return (pos + 1);</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        } else if ((msg[pos] &amp; 0xC0) != 0) {            // name compression</span>
<span class="nc" id="L334">            decodeName(getUShort(pos) &amp; 0x3FFF, n);</span>
<span class="nc" id="L335">            return (pos + 2);</span>
        } else {                                        // append a label
<span class="nc" id="L337">            int len = msg[pos++];</span>
            try {
<span class="nc" id="L339">                n.add(0, new String(msg, pos, len, &quot;ISO-8859-1&quot;));</span>
<span class="nc" id="L340">            } catch (java.io.UnsupportedEncodingException e) {</span>
                // assert false : &quot;ISO-Latin-1 charset unavailable&quot;;
<span class="nc" id="L342">            }</span>
<span class="nc" id="L343">            return decodeName(pos + len, n);</span>
        }
    }

    /*
     * Returns the rdata encoded at msg[pos].  The format is dependent
     * on the rrtype and rrclass values, which have already been set.
     * The length of the encoded data is rdlen, which has already been
     * set.
     * The rdata of records with unknown type/class combinations is
     * returned in a newly-allocated byte array.
     */
    private Object decodeRdata(int pos) throws InvalidNameException {
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (rrclass == CLASS_INTERNET) {</span>
<span class="nc bnc" id="L357" title="All 10 branches missed.">            switch (rrtype) {</span>
            case TYPE_A:
<span class="nc" id="L359">                return decodeA(pos);</span>
            case TYPE_AAAA:
<span class="nc" id="L361">                return decodeAAAA(pos);</span>
            case TYPE_CNAME:
            case TYPE_NS:
            case TYPE_PTR:
<span class="nc" id="L365">                return decodeName(pos);</span>
            case TYPE_MX:
<span class="nc" id="L367">                return decodeMx(pos);</span>
            case TYPE_SOA:
<span class="nc" id="L369">                return decodeSoa(pos);</span>
            case TYPE_SRV:
<span class="nc" id="L371">                return decodeSrv(pos);</span>
            case TYPE_NAPTR:
<span class="nc" id="L373">                return decodeNaptr(pos);</span>
            case TYPE_TXT:
<span class="nc" id="L375">                return decodeTxt(pos);</span>
            case TYPE_HINFO:
<span class="nc" id="L377">                return decodeHinfo(pos);</span>
            }
        }
        // Unknown RR type/class
<span class="nc" id="L381">        byte[] rd = new byte[rdlen];</span>
<span class="nc" id="L382">        System.arraycopy(msg, pos, rd, 0, rdlen);</span>
<span class="nc" id="L383">        return rd;</span>
    }

    /*
     * Returns the rdata of an MX record that is encoded at msg[pos].
     */
    private String decodeMx(int pos) throws InvalidNameException {
<span class="nc" id="L390">        int preference = getUShort(pos);</span>
<span class="nc" id="L391">        pos += 2;</span>
<span class="nc" id="L392">        DnsName name = decodeName(pos);</span>
<span class="nc" id="L393">        return (preference + &quot; &quot; + name);</span>
    }

    /*
     * Returns the rdata of an SOA record that is encoded at msg[pos].
     */
    private String decodeSoa(int pos) throws InvalidNameException {
<span class="nc" id="L400">        DnsName mname = new DnsName();</span>
<span class="nc" id="L401">        pos = decodeName(pos, mname);</span>
<span class="nc" id="L402">        DnsName rname = new DnsName();</span>
<span class="nc" id="L403">        pos = decodeName(pos, rname);</span>

<span class="nc" id="L405">        long serial = getUInt(pos);</span>
<span class="nc" id="L406">        pos += 4;</span>
<span class="nc" id="L407">        long refresh = getUInt(pos);</span>
<span class="nc" id="L408">        pos += 4;</span>
<span class="nc" id="L409">        long retry = getUInt(pos);</span>
<span class="nc" id="L410">        pos += 4;</span>
<span class="nc" id="L411">        long expire = getUInt(pos);</span>
<span class="nc" id="L412">        pos += 4;</span>
<span class="nc" id="L413">        long minimum = getUInt(pos);    // now used as negative TTL</span>
<span class="nc" id="L414">        pos += 4;</span>

<span class="nc" id="L416">        return (mname + &quot; &quot; + rname + &quot; &quot; + serial + &quot; &quot; +</span>
                refresh + &quot; &quot; + retry + &quot; &quot; + expire + &quot; &quot; + minimum);
    }

    /*
     * Returns the rdata of an SRV record that is encoded at msg[pos].
     * See RFC 2782.
     */
    private String decodeSrv(int pos) throws InvalidNameException {
<span class="nc" id="L425">        int priority = getUShort(pos);</span>
<span class="nc" id="L426">        pos += 2;</span>
<span class="nc" id="L427">        int weight =   getUShort(pos);</span>
<span class="nc" id="L428">        pos += 2;</span>
<span class="nc" id="L429">        int port =     getUShort(pos);</span>
<span class="nc" id="L430">        pos += 2;</span>
<span class="nc" id="L431">        DnsName target = decodeName(pos);</span>
<span class="nc" id="L432">        return (priority + &quot; &quot; + weight + &quot; &quot; + port + &quot; &quot; + target);</span>
    }

    /*
     * Returns the rdata of an NAPTR record that is encoded at msg[pos].
     * See RFC 2915.
     */
    private String decodeNaptr(int pos) throws InvalidNameException {
<span class="nc" id="L440">        int order = getUShort(pos);</span>
<span class="nc" id="L441">        pos += 2;</span>
<span class="nc" id="L442">        int preference = getUShort(pos);</span>
<span class="nc" id="L443">        pos += 2;</span>
<span class="nc" id="L444">        StringBuffer flags = new StringBuffer();</span>
<span class="nc" id="L445">        pos += decodeCharString(pos, flags);</span>
<span class="nc" id="L446">        StringBuffer services = new StringBuffer();</span>
<span class="nc" id="L447">        pos += decodeCharString(pos, services);</span>
<span class="nc" id="L448">        StringBuffer regexp = new StringBuffer(rdlen);</span>
<span class="nc" id="L449">        pos += decodeCharString(pos, regexp);</span>
<span class="nc" id="L450">        DnsName replacement = decodeName(pos);</span>

<span class="nc" id="L452">        return (order + &quot; &quot; + preference + &quot; &quot; + flags + &quot; &quot; +</span>
                services + &quot; &quot; + regexp + &quot; &quot; + replacement);
    }

    /*
     * Returns the rdata of a TXT record that is encoded at msg[pos].
     * The rdata consists of one or more &lt;character-string&gt;s.
     */
    private String decodeTxt(int pos) {
<span class="nc" id="L461">        StringBuffer buf = new StringBuffer(rdlen);</span>
<span class="nc" id="L462">        int end = pos + rdlen;</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">        while (pos &lt; end) {</span>
<span class="nc" id="L464">            pos += decodeCharString(pos, buf);</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            if (pos &lt; end) {</span>
<span class="nc" id="L466">                buf.append(' ');</span>
            }
        }
<span class="nc" id="L469">        return buf.toString();</span>
    }

    /*
     * Returns the rdata of an HINFO record that is encoded at msg[pos].
     * The rdata consists of two &lt;character-string&gt;s.
     */
    private String decodeHinfo(int pos) {
<span class="nc" id="L477">        StringBuffer buf = new StringBuffer(rdlen);</span>
<span class="nc" id="L478">        pos += decodeCharString(pos, buf);</span>
<span class="nc" id="L479">        buf.append(' ');</span>
<span class="nc" id="L480">        pos += decodeCharString(pos, buf);</span>
<span class="nc" id="L481">        return buf.toString();</span>
    }

    /*
     * Decodes the &lt;character-string&gt; at msg[pos] and adds it to buf.
     * If the string contains one of the meta-characters ' ', '\\', or
     * '&quot;', then the result is quoted and any embedded '\\' or '&quot;'
     * chars are escaped with '\\'.  Empty strings are also quoted.
     * Returns the size of the encoded string, including the initial
     * length octet.
     */
    private int decodeCharString(int pos, StringBuffer buf) {
<span class="nc" id="L493">        int start = buf.length();       // starting index of this string</span>
<span class="nc" id="L494">        int len = getUByte(pos++);      // encoded string length</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">        boolean quoted = (len == 0);    // quote string if empty</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L497">            int c = getUByte(pos++);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">            quoted |= (c == ' ');</span>
<span class="nc bnc" id="L499" title="All 4 branches missed.">            if ((c == '\\') || (c == '&quot;')) {</span>
<span class="nc" id="L500">                quoted = true;</span>
<span class="nc" id="L501">                buf.append('\\');</span>
            }
<span class="nc" id="L503">            buf.append((char) c);</span>
        }
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (quoted) {</span>
<span class="nc" id="L506">            buf.insert(start, '&quot;');</span>
<span class="nc" id="L507">            buf.append('&quot;');</span>
        }
<span class="nc" id="L509">        return (len + 1);       // size includes initial octet</span>
    }

    /*
     * Returns the rdata of an A record, in dotted-decimal format,
     * that is encoded at msg[pos].
     */
    private String decodeA(int pos) {
<span class="nc" id="L517">        return ((msg[pos] &amp; 0xff) + &quot;.&quot; +</span>
                (msg[pos + 1] &amp; 0xff) + &quot;.&quot; +
                (msg[pos + 2] &amp; 0xff) + &quot;.&quot; +
                (msg[pos + 3] &amp; 0xff));
    }

    /*
     * Returns the rdata of an AAAA record, in colon-separated format,
     * that is encoded at msg[pos].  For example:  4321:0:1:2:3:4:567:89ab.
     * See RFCs 1886 and 2373.
     */
    private String decodeAAAA(int pos) {
<span class="nc" id="L529">        int[] addr6 = new int[8];  // the unsigned 16-bit words of the address</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="nc" id="L531">            addr6[i] = getUShort(pos);</span>
<span class="nc" id="L532">            pos += 2;</span>
        }

        // Find longest sequence of two or more zeros, to compress them.
<span class="nc" id="L536">        int curBase = -1;</span>
<span class="nc" id="L537">        int curLen = 0;</span>
<span class="nc" id="L538">        int bestBase = -1;</span>
<span class="nc" id="L539">        int bestLen = 0;</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">            if (addr6[i] == 0) {</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">                if (curBase == -1) {    // new sequence</span>
<span class="nc" id="L543">                    curBase = i;</span>
<span class="nc" id="L544">                    curLen = 1;</span>
                } else {                // extend sequence
<span class="nc" id="L546">                    ++curLen;</span>
<span class="nc bnc" id="L547" title="All 4 branches missed.">                    if ((curLen &gt;= 2) &amp;&amp; (curLen &gt; bestLen)) {</span>
<span class="nc" id="L548">                        bestBase = curBase;</span>
<span class="nc" id="L549">                        bestLen = curLen;</span>
                    }
                }
            } else {                    // not in sequence
<span class="nc" id="L553">                curBase = -1;</span>
            }
        }

        // If addr begins with at least 6 zeros and is not :: or ::1,
        // or with 5 zeros followed by 0xffff, use the text format for
        // IPv4-compatible or IPv4-mapped addresses.
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (bestBase == 0) {</span>
<span class="nc bnc" id="L561" title="All 6 branches missed.">            if ((bestLen == 6) ||</span>
                    ((bestLen == 7) &amp;&amp; (addr6[7] &gt; 1))) {
<span class="nc" id="L563">                return (&quot;::&quot; + decodeA(pos - 4));</span>
<span class="nc bnc" id="L564" title="All 4 branches missed.">            } else if ((bestLen == 5) &amp;&amp; (addr6[5] == 0xffff)) {</span>
<span class="nc" id="L565">                return (&quot;::ffff:&quot; + decodeA(pos - 4));</span>
            }
        }

        // If bestBase != -1, compress zeros in [bestBase, bestBase+bestLen)
<span class="nc bnc" id="L570" title="All 2 branches missed.">        boolean compress = (bestBase != -1);</span>

<span class="nc" id="L572">        StringBuffer buf = new StringBuffer(40);</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">        if (bestBase == 0) {</span>
<span class="nc" id="L574">            buf.append(':');</span>
        }
<span class="nc bnc" id="L576" title="All 2 branches missed.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="nc bnc" id="L577" title="All 6 branches missed.">            if (!compress || (i &lt; bestBase) || (i &gt;= bestBase + bestLen)) {</span>
<span class="nc" id="L578">                buf.append(Integer.toHexString(addr6[i]));</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">                if (i &lt; 7) {</span>
<span class="nc" id="L580">                    buf.append(':');</span>
                }
<span class="nc bnc" id="L582" title="All 4 branches missed.">            } else if (compress &amp;&amp; (i == bestBase)) {  // first compressed zero</span>
<span class="nc" id="L583">                buf.append(':');</span>
            }
        }

<span class="nc" id="L587">        return buf.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>