<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DnsName.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jndi.dns</a> &gt; <span class="el_source">DnsName.java</span></div><h1>DnsName.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jndi.dns;


import java.util.ArrayList;
import java.util.Comparator;
import java.util.Enumeration;

import javax.naming.*;


/**
 * &lt;tt&gt;DnsName&lt;/tt&gt; implements compound names for DNS as specified by
 * RFCs 1034 and 1035, and as updated and clarified by RFCs 1123 and 2181.
 *
 * &lt;p&gt; The labels in a domain name correspond to JNDI atomic names.
 * Each label must be less than 64 octets in length, and only the
 * optional root label at the end of the name may be 0 octets long.
 * The sum of the lengths of all labels in a name, plus the number of
 * non-root labels plus 1, must be less than 256.  The textual
 * representation of a domain name consists of the labels, escaped as
 * needed, dot-separated, and ordered right-to-left.
 *
 * &lt;p&gt; A label consists of a sequence of octets, each of which may
 * have any value from 0 to 255.
 *
 * &lt;p&gt; &lt;em&gt;Host names&lt;/em&gt; are a subset of domain names.
 * Their labels contain only ASCII letters, digits, and hyphens, and
 * none may begin or end with a hyphen.  While names not conforming to
 * these rules may be valid domain names, they will not be usable by a
 * number of DNS applications, and should in most cases be avoided.
 *
 * &lt;p&gt; DNS does not specify an encoding (such as UTF-8) to use for
 * octets with non-ASCII values.  As of this writing there is some
 * work going on in this area, but it is not yet finalized.
 * &lt;tt&gt;DnsName&lt;/tt&gt; currently converts any non-ASCII octets into
 * characters using ISO-LATIN-1 encoding, in effect taking the
 * value of each octet and storing it directly into the low-order byte
 * of a Java character and &lt;i&gt;vice versa&lt;/i&gt;.  As a consequence, no
 * character in a DNS name will ever have a non-zero high-order byte.
 * When the work on internationalizing domain names has stabilized
 * (see for example &lt;i&gt;draft-ietf-idn-idna-10.txt&lt;/i&gt;), &lt;tt&gt;DnsName&lt;/tt&gt;
 * may be updated to conform to that work.
 *
 * &lt;p&gt; Backslash (&lt;tt&gt;\&lt;/tt&gt;) is used as the escape character in the
 * textual representation of a domain name.  The character sequence
 * `&lt;tt&gt;\DDD&lt;/tt&gt;', where &lt;tt&gt;DDD&lt;/tt&gt; is a 3-digit decimal number
 * (with leading zeros if needed), represents the octet whose value
 * is &lt;tt&gt;DDD&lt;/tt&gt;.  The character sequence `&lt;tt&gt;\C&lt;/tt&gt;', where
 * &lt;tt&gt;C&lt;/tt&gt; is a character other than &lt;tt&gt;'0'&lt;/tt&gt; through
 * &lt;tt&gt;'9'&lt;/tt&gt;, represents the octet whose value is that of
 * &lt;tt&gt;C&lt;/tt&gt; (again using ISO-LATIN-1 encoding); this is particularly
 * useful for escaping &lt;tt&gt;'.'&lt;/tt&gt; or backslash itself.  Backslash is
 * otherwise not allowed in a domain name.  Note that escape characters
 * are interpreted when a name is parsed.  So, for example, the character
 * sequences `&lt;tt&gt;S&lt;/tt&gt;', `&lt;tt&gt;\S&lt;/tt&gt;', and `&lt;tt&gt;\083&lt;/tt&gt;' each
 * represent the same one-octet name.  The &lt;tt&gt;toString()&lt;/tt&gt; method
 * does not generally insert escape sequences except where necessary.
 * If, however, the &lt;tt&gt;DnsName&lt;/tt&gt; was constructed using unneeded
 * escapes, those escapes may appear in the &lt;tt&gt;toString&lt;/tt&gt; result.
 *
 * &lt;p&gt; Atomic names passed as parameters to methods of
 * &lt;tt&gt;DnsName&lt;/tt&gt;, and those returned by them, are unescaped.  So,
 * for example, &lt;tt&gt;(new&amp;nbsp;DnsName()).add(&quot;a.b&quot;)&lt;/tt&gt; creates an
 * object representing the one-label domain name &lt;tt&gt;a\.b&lt;/tt&gt;, and
 * calling &lt;tt&gt;get(0)&lt;/tt&gt; on this object returns &lt;tt&gt;&quot;a.b&quot;&lt;/tt&gt;.
 *
 * &lt;p&gt; While DNS names are case-preserving, comparisons between them
 * are case-insensitive.  When comparing names containing non-ASCII
 * octets, &lt;tt&gt;DnsName&lt;/tt&gt; uses case-insensitive comparison
 * between pairs of ASCII values, and exact binary comparison
 * otherwise.

 * &lt;p&gt; A &lt;tt&gt;DnsName&lt;/tt&gt; instance is not synchronized against
 * concurrent access by multiple threads.
 *
 * @author Scott Seligman
 */


public final class DnsName implements Name {

    // If non-null, the domain name represented by this DnsName.
<span class="pc" id="L108">    private String domain = &quot;&quot;;</span>

    // The labels of this domain name, as a list of strings.  Index 0
    // corresponds to the leftmost (least significant) label:  note that
    // this is the reverse of the ordering used by the Name interface.
<span class="pc" id="L113">    private ArrayList&lt;String&gt; labels = new ArrayList&lt;&gt;();</span>

    // The number of octets needed to carry this domain name in a DNS
    // packet.  Equal to the sum of the lengths of each label, plus the
    // number of non-root labels, plus 1.  Must remain less than 256.
<span class="pc" id="L118">    private short octets = 1;</span>


    /**
     * Constructs a &lt;tt&gt;DnsName&lt;/tt&gt; representing the empty domain name.
     */
<span class="nc" id="L124">    public DnsName() {</span>
<span class="nc" id="L125">    }</span>

    /**
     * Constructs a &lt;tt&gt;DnsName&lt;/tt&gt; representing a given domain name.
     *
     * @param   name    the domain name to parse
     * @throws InvalidNameException if &lt;tt&gt;name&lt;/tt&gt; does not conform
     *          to DNS syntax.
     */
<span class="fc" id="L134">    public DnsName(String name) throws InvalidNameException {</span>
<span class="fc" id="L135">        parse(name);</span>
<span class="fc" id="L136">    }</span>

    /*
     * Returns a new DnsName with its name components initialized to
     * the components of &quot;n&quot; in the range [beg,end).  Indexing is as
     * for the Name interface, with 0 being the most significant.
     */
<span class="nc" id="L143">    private DnsName(DnsName n, int beg, int end) {</span>
        // Compute indexes into &quot;labels&quot;, which has least-significant label
        // at index 0 (opposite to the convention used for &quot;beg&quot; and &quot;end&quot;).
<span class="nc" id="L146">        int b = n.size() - end;</span>
<span class="nc" id="L147">        int e = n.size() - beg;</span>
<span class="nc" id="L148">        labels.addAll(n.labels.subList(b, e));</span>

<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (size() == n.size()) {</span>
<span class="nc" id="L151">            domain = n.domain;</span>
<span class="nc" id="L152">            octets = n.octets;</span>
        } else {
<span class="nc bnc" id="L154" title="All 2 branches missed.">            for (String label: labels) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                if (label.length() &gt; 0) {</span>
<span class="nc" id="L156">                    octets += (short) (label.length() + 1);</span>
                }
<span class="nc" id="L158">            }</span>
        }
<span class="nc" id="L160">    }</span>


    public String toString() {
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (domain == null) {</span>
<span class="nc" id="L165">            StringBuilder buf = new StringBuilder();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">            for (String label: labels) {</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">                if (buf.length() &gt; 0 || label.length() == 0) {</span>
<span class="nc" id="L168">                    buf.append('.');</span>
                }
<span class="nc" id="L170">                escape(buf, label);</span>
<span class="nc" id="L171">            }</span>
<span class="nc" id="L172">            domain = buf.toString();</span>
        }
<span class="nc" id="L174">        return domain;</span>
    }

    /**
     * Does this domain name follow &lt;em&gt;host name&lt;/em&gt; syntax?
     */
    public boolean isHostName() {
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (String label: labels) {</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">            if (!isHostNameLabel(label)) {</span>
<span class="nc" id="L183">                return false;</span>
            }
<span class="nc" id="L185">        }</span>
<span class="nc" id="L186">        return true;</span>
    }

    public short getOctets() {
<span class="fc" id="L190">        return octets;</span>
    }

    public int size() {
<span class="fc" id="L194">        return labels.size();</span>
    }

    public boolean isEmpty() {
<span class="fc bfc" id="L198" title="All 2 branches covered.">        return (size() == 0);</span>
    }

    public int hashCode() {
<span class="nc" id="L202">        int h = 0;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">        for (int i = 0; i &lt; size(); i++) {</span>
<span class="nc" id="L204">            h = 31 * h + getKey(i).hashCode();</span>
        }
<span class="nc" id="L206">        return h;</span>
    }

    public boolean equals(Object obj) {
<span class="nc bnc" id="L210" title="All 4 branches missed.">        if (!(obj instanceof Name) || (obj instanceof CompositeName)) {</span>
<span class="nc" id="L211">            return false;</span>
        }
<span class="nc" id="L213">        Name n = (Name) obj;</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">        return ((size() == n.size()) &amp;&amp;         // shortcut:  do sizes differ?</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                (compareTo(obj) == 0));</span>
    }

    public int compareTo(Object obj) {
<span class="nc" id="L219">        Name n = (Name) obj;</span>
<span class="nc" id="L220">        return compareRange(0, size(), n);      // never 0 if sizes differ</span>
    }

    public boolean startsWith(Name n) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        return ((size() &gt;= n.size()) &amp;&amp;</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                (compareRange(0, n.size(), n) == 0));</span>
    }

    public boolean endsWith(Name n) {
<span class="nc bnc" id="L229" title="All 2 branches missed.">        return ((size() &gt;= n.size()) &amp;&amp;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                (compareRange(size() - n.size(), size(), n) == 0));</span>
    }

    public String get(int pos) {
<span class="pc bpc" id="L234" title="2 of 4 branches missed.">        if (pos &lt; 0 || pos &gt;= size()) {</span>
<span class="nc" id="L235">            throw new ArrayIndexOutOfBoundsException();</span>
        }
<span class="fc" id="L237">        int i = size() - pos - 1;       // index of &quot;pos&quot; component in &quot;labels&quot;</span>
<span class="fc" id="L238">        return labels.get(i);</span>
    }

    public Enumeration&lt;String&gt; getAll() {
<span class="nc" id="L242">        return new Enumeration&lt;String&gt;() {</span>
<span class="nc" id="L243">            int pos = 0;</span>
            public boolean hasMoreElements() {
<span class="nc bnc" id="L245" title="All 2 branches missed.">                return (pos &lt; size());</span>
            }
            public String nextElement() {
<span class="nc bnc" id="L248" title="All 2 branches missed.">                if (pos &lt; size()) {</span>
<span class="nc" id="L249">                    return get(pos++);</span>
                }
<span class="nc" id="L251">                throw new java.util.NoSuchElementException();</span>
            }
        };
    }

    public Name getPrefix(int pos) {
<span class="nc" id="L257">        return new DnsName(this, 0, pos);</span>
    }

    public Name getSuffix(int pos) {
<span class="nc" id="L261">        return new DnsName(this, pos, size());</span>
    }

    public Object clone() {
<span class="nc" id="L265">        return new DnsName(this, 0, size());</span>
    }

    public Object remove(int pos) {
<span class="nc bnc" id="L269" title="All 4 branches missed.">        if (pos &lt; 0 || pos &gt;= size()) {</span>
<span class="nc" id="L270">            throw new ArrayIndexOutOfBoundsException();</span>
        }
<span class="nc" id="L272">        int i = size() - pos - 1;     // index of element to remove in &quot;labels&quot;</span>
<span class="nc" id="L273">        String label = labels.remove(i);</span>
<span class="nc" id="L274">        int len = label.length();</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (len &gt; 0) {</span>
<span class="nc" id="L276">            octets -= (short) (len + 1);</span>
        }
<span class="nc" id="L278">        domain = null;          // invalidate &quot;domain&quot;</span>
<span class="nc" id="L279">        return label;</span>
    }

    public Name add(String comp) throws InvalidNameException {
<span class="nc" id="L283">        return add(size(), comp);</span>
    }

    public Name add(int pos, String comp) throws InvalidNameException {
<span class="pc bpc" id="L287" title="2 of 4 branches missed.">        if (pos &lt; 0 || pos &gt; size()) {</span>
<span class="nc" id="L288">            throw new ArrayIndexOutOfBoundsException();</span>
        }
        // Check for empty labels:  may have only one, and only at end.
<span class="fc" id="L291">        int len = comp.length();</span>
<span class="pc bpc" id="L292" title="4 of 6 branches missed.">        if ((pos &gt; 0 &amp;&amp; len == 0) ||</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">            (pos == 0 &amp;&amp; hasRootLabel())) {</span>
<span class="nc" id="L294">                throw new InvalidNameException(</span>
                        &quot;Empty label must be the last label in a domain name&quot;);
        }
        // Check total name length.
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (len &gt; 0) {</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">            if (octets + len + 1 &gt;= 256) {</span>
<span class="nc" id="L300">                throw new InvalidNameException(&quot;Name too long&quot;);</span>
            }
<span class="fc" id="L302">            octets += (short) (len + 1);</span>
        }

<span class="fc" id="L305">        int i = size() - pos;   // index for insertion into &quot;labels&quot;</span>
<span class="fc" id="L306">        verifyLabel(comp);</span>
<span class="fc" id="L307">        labels.add(i, comp);</span>

<span class="fc" id="L309">        domain = null;          // invalidate &quot;domain&quot;</span>
<span class="fc" id="L310">        return this;</span>
    }

    public Name addAll(Name suffix) throws InvalidNameException {
<span class="nc" id="L314">        return addAll(size(), suffix);</span>
    }

    public Name addAll(int pos, Name n) throws InvalidNameException {
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">        if (n instanceof DnsName) {</span>
            // &quot;n&quot; is a DnsName so we can insert it as a whole, rather than
            // verifying and inserting it component-by-component.
            // More code, but less work.
<span class="fc" id="L322">            DnsName dn = (DnsName) n;</span>

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">            if (dn.isEmpty()) {</span>
<span class="nc" id="L325">                return this;</span>
            }
            // Check for empty labels:  may have only one, and only at end.
<span class="pc bpc" id="L328" title="4 of 6 branches missed.">            if ((pos &gt; 0 &amp;&amp; dn.hasRootLabel()) ||</span>
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">                (pos == 0 &amp;&amp; hasRootLabel())) {</span>
<span class="nc" id="L330">                    throw new InvalidNameException(</span>
                        &quot;Empty label must be the last label in a domain name&quot;);
            }

<span class="fc" id="L334">            short newOctets = (short) (octets + dn.octets - 1);</span>
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">            if (newOctets &gt; 255) {</span>
<span class="nc" id="L336">                throw new InvalidNameException(&quot;Name too long&quot;);</span>
            }
<span class="fc" id="L338">            octets = newOctets;</span>
<span class="fc" id="L339">            int i = size() - pos;       // index for insertion into &quot;labels&quot;</span>
<span class="fc" id="L340">            labels.addAll(i, dn.labels);</span>

            // Preserve &quot;domain&quot; if we're appending or prepending,
            // otherwise invalidate it.
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            if (isEmpty()) {</span>
<span class="nc" id="L345">                domain = dn.domain;</span>
<span class="pc bpc" id="L346" title="2 of 4 branches missed.">            } else if (domain == null || dn.domain == null) {</span>
<span class="nc" id="L347">                domain = null;</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">            } else if (pos == 0) {</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">                domain += (dn.domain.equals(&quot;.&quot;) ? &quot;&quot; : &quot;.&quot;) + dn.domain;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">            } else if (pos == size()) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                domain = dn.domain + (domain.equals(&quot;.&quot;) ? &quot;&quot; : &quot;.&quot;) + domain;</span>
            } else {
<span class="nc" id="L353">                domain = null;</span>
            }

<span class="pc bnc" id="L356" title="All 2 branches missed.">        } else if (n instanceof CompositeName) {</span>
<span class="nc" id="L357">            n = (DnsName) n;            // force ClassCastException</span>

        } else {                // &quot;n&quot; is a compound name, but not a DnsName.
            // Add labels least-significant first:  sometimes more efficient.
<span class="nc bnc" id="L361" title="All 2 branches missed.">            for (int i = n.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L362">                add(pos, n.get(i));</span>
            }
        }
<span class="fc" id="L365">        return this;</span>
    }


    boolean hasRootLabel() {
<span class="fc bfc" id="L370" title="All 2 branches covered.">        return (!isEmpty() &amp;&amp;</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">                get(0).equals(&quot;&quot;));</span>
    }

    /*
     * Helper method for public comparison methods.  Lexicographically
     * compares components of this name in the range [beg,end) with
     * all components of &quot;n&quot;.  Indexing is as for the Name interface,
     * with 0 being the most significant.  Returns negative, zero, or
     * positive as these name components are less than, equal to, or
     * greater than those of &quot;n&quot;.
     */
    private int compareRange(int beg, int end, Name n) {
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (n instanceof CompositeName) {</span>
<span class="nc" id="L384">            n = (DnsName) n;                    // force ClassCastException</span>
        }
        // Loop through labels, starting with most significant.
<span class="nc" id="L387">        int minSize = Math.min(end - beg, n.size());</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        for (int i = 0; i &lt; minSize; i++) {</span>
<span class="nc" id="L389">            String label1 = get(i + beg);</span>
<span class="nc" id="L390">            String label2 = n.get(i);</span>

<span class="nc" id="L392">            int j = size() - (i + beg) - 1;     // index of label1 in &quot;labels&quot;</span>
            // assert (label1 == labels.get(j));

<span class="nc" id="L395">            int c = compareLabels(label1, label2);</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (c != 0) {</span>
<span class="nc" id="L397">                return c;</span>
            }
        }
<span class="nc" id="L400">        return ((end - beg) - n.size());        // longer range wins</span>
    }

    /*
     * Returns a key suitable for hashing the label at index i.
     * Indexing is as for the Name interface, with 0 being the most
     * significant.
     */
    String getKey(int i) {
<span class="nc" id="L409">        return keyForLabel(get(i));</span>
    }


    /*
     * Parses a domain name, setting the values of instance vars accordingly.
     */
    private void parse(String name) throws InvalidNameException {

<span class="fc" id="L418">        StringBuffer label = new StringBuffer();        // label being parsed</span>

<span class="fc bfc" id="L420" title="All 2 branches covered.">        for (int i = 0; i &lt; name.length(); i++) {</span>
<span class="fc" id="L421">            char c = name.charAt(i);</span>

<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            if (c == '\\') {                    // found an escape sequence</span>
<span class="nc" id="L424">                c = getEscapedOctet(name, i++);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">                if (isDigit(name.charAt(i))) {  // sequence is \DDD</span>
<span class="nc" id="L426">                    i += 2;                     // consume remaining digits</span>
                }
<span class="nc" id="L428">                label.append(c);</span>

<span class="fc bfc" id="L430" title="All 2 branches covered.">            } else if (c != '.') {              // an unescaped octet</span>
<span class="fc" id="L431">                label.append(c);</span>

            } else {                            // found '.' separator
<span class="fc" id="L434">                add(0, label.toString());       // check syntax, then add label</span>
                                                //   to end of name
<span class="fc" id="L436">                label.delete(0, i);             // clear buffer for next label</span>
            }
        }

        // If name is neither &quot;.&quot; nor &quot;&quot;, the octets (zero or more)
        // from the rightmost dot onward are now added as the final
        // label of the name.  Those two are special cases in that for
        // all other domain names, the number of labels is one greater
        // than the number of dot separators.
<span class="pc bpc" id="L445" title="1 of 4 branches missed.">        if (!name.equals(&quot;&quot;) &amp;&amp; !name.equals(&quot;.&quot;)) {</span>
<span class="fc" id="L446">            add(0, label.toString());</span>
        }

<span class="fc" id="L449">        domain = name;          // do this last, since add() sets it to null</span>
<span class="fc" id="L450">    }</span>

    /*
     * Returns (as a char) the octet indicated by the escape sequence
     * at a given position within a domain name.
     * @throws InvalidNameException if a valid escape sequence is not found.
     */
    private static char getEscapedOctet(String name, int pos)
                                                throws InvalidNameException {
        try {
            // assert (name.charAt(pos) == '\\');
<span class="nc" id="L461">            char c1 = name.charAt(++pos);</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">            if (isDigit(c1)) {          // sequence is `\DDD'</span>
<span class="nc" id="L463">                char c2 = name.charAt(++pos);</span>
<span class="nc" id="L464">                char c3 = name.charAt(++pos);</span>
<span class="nc bnc" id="L465" title="All 4 branches missed.">                if (isDigit(c2) &amp;&amp; isDigit(c3)) {</span>
<span class="nc" id="L466">                    return (char)</span>
                        ((c1 - '0') * 100 + (c2 - '0') * 10 + (c3 - '0'));
                } else {
<span class="nc" id="L469">                    throw new InvalidNameException(</span>
                            &quot;Invalid escape sequence in &quot; + name);
                }
            } else {                    // sequence is `\C'
<span class="nc" id="L473">                return c1;</span>
            }
<span class="nc" id="L475">        } catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L476">            throw new InvalidNameException(</span>
                    &quot;Invalid escape sequence in &quot; + name);
        }
    }

    /*
     * Checks that this label is valid.
     * @throws InvalidNameException if label is not valid.
     */
    private static void verifyLabel(String label) throws InvalidNameException {
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        if (label.length() &gt; 63) {</span>
<span class="nc" id="L487">            throw new InvalidNameException(</span>
                    &quot;Label exceeds 63 octets: &quot; + label);
        }
        // Check for two-byte characters.
<span class="fc bfc" id="L491" title="All 2 branches covered.">        for (int i = 0; i &lt; label.length(); i++) {</span>
<span class="fc" id="L492">            char c = label.charAt(i);</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">            if ((c &amp; 0xFF00) != 0) {</span>
<span class="nc" id="L494">                throw new InvalidNameException(</span>
                        &quot;Label has two-byte char: &quot; + label);
            }
        }
<span class="fc" id="L498">    }</span>

    /*
     * Does this label conform to host name syntax?
     */
    private static boolean isHostNameLabel(String label) {
<span class="nc bnc" id="L504" title="All 2 branches missed.">        for (int i = 0; i &lt; label.length(); i++) {</span>
<span class="nc" id="L505">            char c = label.charAt(i);</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">            if (!isHostNameChar(c)) {</span>
<span class="nc" id="L507">                return false;</span>
            }
        }
<span class="nc bnc" id="L510" title="All 4 branches missed.">        return !(label.startsWith(&quot;-&quot;) || label.endsWith(&quot;-&quot;));</span>
    }

    private static boolean isHostNameChar(char c) {
<span class="nc bnc" id="L514" title="All 14 branches missed.">        return (c == '-' ||</span>
                c &gt;= 'a' &amp;&amp; c &lt;= 'z' ||
                c &gt;= 'A' &amp;&amp; c &lt;= 'Z' ||
                c &gt;= '0' &amp;&amp; c &lt;= '9');
    }

    private static boolean isDigit(char c) {
<span class="nc bnc" id="L521" title="All 4 branches missed.">        return (c &gt;= '0' &amp;&amp; c &lt;= '9');</span>
    }

    /*
     * Append a label to buf, escaping as needed.
     */
    private static void escape(StringBuilder buf, String label) {
<span class="nc bnc" id="L528" title="All 2 branches missed.">        for (int i = 0; i &lt; label.length(); i++) {</span>
<span class="nc" id="L529">            char c = label.charAt(i);</span>
<span class="nc bnc" id="L530" title="All 4 branches missed.">            if (c == '.' || c == '\\') {</span>
<span class="nc" id="L531">                buf.append('\\');</span>
            }
<span class="nc" id="L533">            buf.append(c);</span>
        }
<span class="nc" id="L535">    }</span>

    /*
     * Compares two labels, ignoring case for ASCII values.
     * Returns negative, zero, or positive as the first label
     * is less than, equal to, or greater than the second.
     * See keyForLabel().
     */
    private static int compareLabels(String label1, String label2) {
<span class="nc" id="L544">        int min = Math.min(label1.length(), label2.length());</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">        for (int i = 0; i &lt; min; i++) {</span>
<span class="nc" id="L546">            char c1 = label1.charAt(i);</span>
<span class="nc" id="L547">            char c2 = label2.charAt(i);</span>
<span class="nc bnc" id="L548" title="All 4 branches missed.">            if (c1 &gt;= 'A' &amp;&amp; c1 &lt;= 'Z') {</span>
<span class="nc" id="L549">                c1 += 'a' - 'A';                        // to lower case</span>
            }
<span class="nc bnc" id="L551" title="All 4 branches missed.">            if (c2 &gt;= 'A' &amp;&amp; c2 &lt;= 'Z') {</span>
<span class="nc" id="L552">                c2 += 'a' - 'A';                        // to lower case</span>
            }
<span class="nc bnc" id="L554" title="All 2 branches missed.">            if (c1 != c2) {</span>
<span class="nc" id="L555">                return (c1 - c2);</span>
            }
        }
<span class="nc" id="L558">        return (label1.length() - label2.length());     // the longer one wins</span>
    }

    /*
     * Returns a key suitable for hashing a label.  Two labels map to
     * the same key iff they are equal, taking possible case-folding
     * into account.  See compareLabels().
     */
    private static String keyForLabel(String label) {
<span class="nc" id="L567">        StringBuffer buf = new StringBuffer(label.length());</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">        for (int i = 0; i &lt; label.length(); i++) {</span>
<span class="nc" id="L569">            char c = label.charAt(i);</span>
<span class="nc bnc" id="L570" title="All 4 branches missed.">            if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {</span>
<span class="nc" id="L571">                c += 'a' - 'A';                         // to lower case</span>
            }
<span class="nc" id="L573">            buf.append(c);</span>
        }
<span class="nc" id="L575">        return buf.toString();</span>
    }


    /**
     * Serializes only the domain name string, for compactness and to avoid
     * any implementation dependency.
     *
     * @serialdata      The domain name string.
     */
    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
<span class="nc" id="L587">        s.writeObject(toString());</span>
<span class="nc" id="L588">    }</span>

    private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        try {
<span class="nc" id="L593">            parse((String) s.readObject());</span>
<span class="nc" id="L594">        } catch (InvalidNameException e) {</span>
            // shouldn't happen
<span class="nc" id="L596">            throw new java.io.StreamCorruptedException(</span>
                    &quot;Invalid name: &quot; + domain);
<span class="nc" id="L598">        }</span>
<span class="nc" id="L599">    }</span>

    private static final long serialVersionUID = 7040187611324710271L;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>