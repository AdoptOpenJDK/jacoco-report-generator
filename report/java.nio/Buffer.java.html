<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Buffer.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.nio</a> &gt; <span class="el_source">Buffer.java</span></div><h1>Buffer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.nio;

import java.util.Spliterator;

/**
 * A container for data of a specific primitive type.
 *
 * &lt;p&gt; A buffer is a linear, finite sequence of elements of a specific
 * primitive type.  Aside from its content, the essential properties of a
 * buffer are its capacity, limit, and position: &lt;/p&gt;
 *
 * &lt;blockquote&gt;
 *
 *   &lt;p&gt; A buffer's &lt;i&gt;capacity&lt;/i&gt; is the number of elements it contains.  The
 *   capacity of a buffer is never negative and never changes.  &lt;/p&gt;
 *
 *   &lt;p&gt; A buffer's &lt;i&gt;limit&lt;/i&gt; is the index of the first element that should
 *   not be read or written.  A buffer's limit is never negative and is never
 *   greater than its capacity.  &lt;/p&gt;
 *
 *   &lt;p&gt; A buffer's &lt;i&gt;position&lt;/i&gt; is the index of the next element to be
 *   read or written.  A buffer's position is never negative and is never
 *   greater than its limit.  &lt;/p&gt;
 *
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt; There is one subclass of this class for each non-boolean primitive type.
 *
 *
 * &lt;h2&gt; Transferring data &lt;/h2&gt;
 *
 * &lt;p&gt; Each subclass of this class defines two categories of &lt;i&gt;get&lt;/i&gt; and
 * &lt;i&gt;put&lt;/i&gt; operations: &lt;/p&gt;
 *
 * &lt;blockquote&gt;
 *
 *   &lt;p&gt; &lt;i&gt;Relative&lt;/i&gt; operations read or write one or more elements starting
 *   at the current position and then increment the position by the number of
 *   elements transferred.  If the requested transfer exceeds the limit then a
 *   relative &lt;i&gt;get&lt;/i&gt; operation throws a {@link BufferUnderflowException}
 *   and a relative &lt;i&gt;put&lt;/i&gt; operation throws a {@link
 *   BufferOverflowException}; in either case, no data is transferred.  &lt;/p&gt;
 *
 *   &lt;p&gt; &lt;i&gt;Absolute&lt;/i&gt; operations take an explicit element index and do not
 *   affect the position.  Absolute &lt;i&gt;get&lt;/i&gt; and &lt;i&gt;put&lt;/i&gt; operations throw
 *   an {@link IndexOutOfBoundsException} if the index argument exceeds the
 *   limit.  &lt;/p&gt;
 *
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt; Data may also, of course, be transferred in to or out of a buffer by the
 * I/O operations of an appropriate channel, which are always relative to the
 * current position.
 *
 *
 * &lt;h2&gt; Marking and resetting &lt;/h2&gt;
 *
 * &lt;p&gt; A buffer's &lt;i&gt;mark&lt;/i&gt; is the index to which its position will be reset
 * when the {@link #reset reset} method is invoked.  The mark is not always
 * defined, but when it is defined it is never negative and is never greater
 * than the position.  If the mark is defined then it is discarded when the
 * position or the limit is adjusted to a value smaller than the mark.  If the
 * mark is not defined then invoking the {@link #reset reset} method causes an
 * {@link InvalidMarkException} to be thrown.
 *
 *
 * &lt;h2&gt; Invariants &lt;/h2&gt;
 *
 * &lt;p&gt; The following invariant holds for the mark, position, limit, and
 * capacity values:
 *
 * &lt;blockquote&gt;
 *     &lt;tt&gt;0&lt;/tt&gt; &lt;tt&gt;&amp;lt;=&lt;/tt&gt;
 *     &lt;i&gt;mark&lt;/i&gt; &lt;tt&gt;&amp;lt;=&lt;/tt&gt;
 *     &lt;i&gt;position&lt;/i&gt; &lt;tt&gt;&amp;lt;=&lt;/tt&gt;
 *     &lt;i&gt;limit&lt;/i&gt; &lt;tt&gt;&amp;lt;=&lt;/tt&gt;
 *     &lt;i&gt;capacity&lt;/i&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt; A newly-created buffer always has a position of zero and a mark that is
 * undefined.  The initial limit may be zero, or it may be some other value
 * that depends upon the type of the buffer and the manner in which it is
 * constructed.  Each element of a newly-allocated buffer is initialized
 * to zero.
 *
 *
 * &lt;h2&gt; Clearing, flipping, and rewinding &lt;/h2&gt;
 *
 * &lt;p&gt; In addition to methods for accessing the position, limit, and capacity
 * values and for marking and resetting, this class also defines the following
 * operations upon buffers:
 *
 * &lt;ul&gt;
 *
 *   &lt;li&gt;&lt;p&gt; {@link #clear} makes a buffer ready for a new sequence of
 *   channel-read or relative &lt;i&gt;put&lt;/i&gt; operations: It sets the limit to the
 *   capacity and the position to zero.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; {@link #flip} makes a buffer ready for a new sequence of
 *   channel-write or relative &lt;i&gt;get&lt;/i&gt; operations: It sets the limit to the
 *   current position and then sets the position to zero.  &lt;/p&gt;&lt;/li&gt;
 *
 *   &lt;li&gt;&lt;p&gt; {@link #rewind} makes a buffer ready for re-reading the data that
 *   it already contains: It leaves the limit unchanged and sets the position
 *   to zero.  &lt;/p&gt;&lt;/li&gt;
 *
 * &lt;/ul&gt;
 *
 *
 * &lt;h2&gt; Read-only buffers &lt;/h2&gt;
 *
 * &lt;p&gt; Every buffer is readable, but not every buffer is writable.  The
 * mutation methods of each buffer class are specified as &lt;i&gt;optional
 * operations&lt;/i&gt; that will throw a {@link ReadOnlyBufferException} when
 * invoked upon a read-only buffer.  A read-only buffer does not allow its
 * content to be changed, but its mark, position, and limit values are mutable.
 * Whether or not a buffer is read-only may be determined by invoking its
 * {@link #isReadOnly isReadOnly} method.
 *
 *
 * &lt;h2&gt; Thread safety &lt;/h2&gt;
 *
 * &lt;p&gt; Buffers are not safe for use by multiple concurrent threads.  If a
 * buffer is to be used by more than one thread then access to the buffer
 * should be controlled by appropriate synchronization.
 *
 *
 * &lt;h2&gt; Invocation chaining &lt;/h2&gt;
 *
 * &lt;p&gt; Methods in this class that do not otherwise have a value to return are
 * specified to return the buffer upon which they are invoked.  This allows
 * method invocations to be chained; for example, the sequence of statements
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * b.flip();
 * b.position(23);
 * b.limit(42);&lt;/pre&gt;&lt;/blockquote&gt;
 *
 * can be replaced by the single, more compact statement
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 * b.flip().position(23).limit(42);&lt;/pre&gt;&lt;/blockquote&gt;
 *
 *
 * @author Mark Reinhold
 * @author JSR-51 Expert Group
 * @since 1.4
 */

public abstract class Buffer {

    /**
     * The characteristics of Spliterators that traverse and split elements
     * maintained in Buffers.
     */
    static final int SPLITERATOR_CHARACTERISTICS =
        Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED;

    // Invariants: mark &lt;= position &lt;= limit &lt;= capacity
<span class="fc" id="L185">    private int mark = -1;</span>
<span class="fc" id="L186">    private int position = 0;</span>
    private int limit;
    private int capacity;

    // Used only by direct buffers
    // NOTE: hoisted here for speed in JNI GetDirectBufferAddress
    long address;

    // Creates a new buffer with the given mark, position, limit, and capacity,
    // after checking invariants.
    //
<span class="fc" id="L197">    Buffer(int mark, int pos, int lim, int cap) {       // package-private</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (cap &lt; 0)</span>
<span class="fc" id="L199">            throw new IllegalArgumentException(&quot;Negative capacity: &quot; + cap);</span>
<span class="fc" id="L200">        this.capacity = cap;</span>
<span class="fc" id="L201">        limit(lim);</span>
<span class="fc" id="L202">        position(pos);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (mark &gt;= 0) {</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            if (mark &gt; pos)</span>
<span class="nc" id="L205">                throw new IllegalArgumentException(&quot;mark &gt; position: (&quot;</span>
                                                   + mark + &quot; &gt; &quot; + pos + &quot;)&quot;);
<span class="fc" id="L207">            this.mark = mark;</span>
        }
<span class="fc" id="L209">    }</span>

    /**
     * Returns this buffer's capacity.
     *
     * @return  The capacity of this buffer
     */
    public final int capacity() {
<span class="fc" id="L217">        return capacity;</span>
    }

    /**
     * Returns this buffer's position.
     *
     * @return  The position of this buffer
     */
    public final int position() {
<span class="fc" id="L226">        return position;</span>
    }

    /**
     * Sets this buffer's position.  If the mark is defined and larger than the
     * new position then it is discarded.
     *
     * @param  newPosition
     *         The new position value; must be non-negative
     *         and no larger than the current limit
     *
     * @return  This buffer
     *
     * @throws  IllegalArgumentException
     *          If the preconditions on &lt;tt&gt;newPosition&lt;/tt&gt; do not hold
     */
    public final Buffer position(int newPosition) {
<span class="fc bfc" id="L243" title="All 4 branches covered.">        if ((newPosition &gt; limit) || (newPosition &lt; 0))</span>
<span class="fc" id="L244">            throw new IllegalArgumentException();</span>
<span class="fc" id="L245">        position = newPosition;</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">        if (mark &gt; position) mark = -1;</span>
<span class="fc" id="L247">        return this;</span>
    }

    /**
     * Returns this buffer's limit.
     *
     * @return  The limit of this buffer
     */
    public final int limit() {
<span class="fc" id="L256">        return limit;</span>
    }

    /**
     * Sets this buffer's limit.  If the position is larger than the new limit
     * then it is set to the new limit.  If the mark is defined and larger than
     * the new limit then it is discarded.
     *
     * @param  newLimit
     *         The new limit value; must be non-negative
     *         and no larger than this buffer's capacity
     *
     * @return  This buffer
     *
     * @throws  IllegalArgumentException
     *          If the preconditions on &lt;tt&gt;newLimit&lt;/tt&gt; do not hold
     */
    public final Buffer limit(int newLimit) {
<span class="fc bfc" id="L274" title="All 4 branches covered.">        if ((newLimit &gt; capacity) || (newLimit &lt; 0))</span>
<span class="fc" id="L275">            throw new IllegalArgumentException();</span>
<span class="fc" id="L276">        limit = newLimit;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (position &gt; limit) position = limit;</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if (mark &gt; limit) mark = -1;</span>
<span class="fc" id="L279">        return this;</span>
    }

    /**
     * Sets this buffer's mark at its position.
     *
     * @return  This buffer
     */
    public final Buffer mark() {
<span class="fc" id="L288">        mark = position;</span>
<span class="fc" id="L289">        return this;</span>
    }

    /**
     * Resets this buffer's position to the previously-marked position.
     *
     * &lt;p&gt; Invoking this method neither changes nor discards the mark's
     * value. &lt;/p&gt;
     *
     * @return  This buffer
     *
     * @throws  InvalidMarkException
     *          If the mark has not been set
     */
    public final Buffer reset() {
<span class="fc" id="L304">        int m = mark;</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        if (m &lt; 0)</span>
<span class="fc" id="L306">            throw new InvalidMarkException();</span>
<span class="fc" id="L307">        position = m;</span>
<span class="fc" id="L308">        return this;</span>
    }

    /**
     * Clears this buffer.  The position is set to zero, the limit is set to
     * the capacity, and the mark is discarded.
     *
     * &lt;p&gt; Invoke this method before using a sequence of channel-read or
     * &lt;i&gt;put&lt;/i&gt; operations to fill this buffer.  For example:
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * buf.clear();     // Prepare buffer for reading
     * in.read(buf);    // Read data&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt; This method does not actually erase the data in the buffer, but it
     * is named as if it did because it will most often be used in situations
     * in which that might as well be the case. &lt;/p&gt;
     *
     * @return  This buffer
     */
    public final Buffer clear() {
<span class="fc" id="L329">        position = 0;</span>
<span class="fc" id="L330">        limit = capacity;</span>
<span class="fc" id="L331">        mark = -1;</span>
<span class="fc" id="L332">        return this;</span>
    }

    /**
     * Flips this buffer.  The limit is set to the current position and then
     * the position is set to zero.  If the mark is defined then it is
     * discarded.
     *
     * &lt;p&gt; After a sequence of channel-read or &lt;i&gt;put&lt;/i&gt; operations, invoke
     * this method to prepare for a sequence of channel-write or relative
     * &lt;i&gt;get&lt;/i&gt; operations.  For example:
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * buf.put(magic);    // Prepend header
     * in.read(buf);      // Read data into rest of buffer
     * buf.flip();        // Flip buffer
     * out.write(buf);    // Write header + data to channel&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt; This method is often used in conjunction with the {@link
     * java.nio.ByteBuffer#compact compact} method when transferring data from
     * one place to another.  &lt;/p&gt;
     *
     * @return  This buffer
     */
    public final Buffer flip() {
<span class="fc" id="L357">        limit = position;</span>
<span class="fc" id="L358">        position = 0;</span>
<span class="fc" id="L359">        mark = -1;</span>
<span class="fc" id="L360">        return this;</span>
    }

    /**
     * Rewinds this buffer.  The position is set to zero and the mark is
     * discarded.
     *
     * &lt;p&gt; Invoke this method before a sequence of channel-write or &lt;i&gt;get&lt;/i&gt;
     * operations, assuming that the limit has already been set
     * appropriately.  For example:
     *
     * &lt;blockquote&gt;&lt;pre&gt;
     * out.write(buf);    // Write remaining data
     * buf.rewind();      // Rewind buffer
     * buf.get(array);    // Copy data into array&lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return  This buffer
     */
    public final Buffer rewind() {
<span class="fc" id="L379">        position = 0;</span>
<span class="fc" id="L380">        mark = -1;</span>
<span class="fc" id="L381">        return this;</span>
    }

    /**
     * Returns the number of elements between the current position and the
     * limit.
     *
     * @return  The number of elements remaining in this buffer
     */
    public final int remaining() {
<span class="fc" id="L391">        return limit - position;</span>
    }

    /**
     * Tells whether there are any elements between the current position and
     * the limit.
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, there is at least one element
     *          remaining in this buffer
     */
    public final boolean hasRemaining() {
<span class="fc bfc" id="L402" title="All 2 branches covered.">        return position &lt; limit;</span>
    }

    /**
     * Tells whether or not this buffer is read-only.
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, this buffer is read-only
     */
    public abstract boolean isReadOnly();

    /**
     * Tells whether or not this buffer is backed by an accessible
     * array.
     *
     * &lt;p&gt; If this method returns &lt;tt&gt;true&lt;/tt&gt; then the {@link #array() array}
     * and {@link #arrayOffset() arrayOffset} methods may safely be invoked.
     * &lt;/p&gt;
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, this buffer
     *          is backed by an array and is not read-only
     *
     * @since 1.6
     */
    public abstract boolean hasArray();

    /**
     * Returns the array that backs this
     * buffer&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.
     *
     * &lt;p&gt; This method is intended to allow array-backed buffers to be
     * passed to native code more efficiently. Concrete subclasses
     * provide more strongly-typed return values for this method.
     *
     * &lt;p&gt; Modifications to this buffer's content will cause the returned
     * array's content to be modified, and vice versa.
     *
     * &lt;p&gt; Invoke the {@link #hasArray hasArray} method before invoking this
     * method in order to ensure that this buffer has an accessible backing
     * array.  &lt;/p&gt;
     *
     * @return  The array that backs this buffer
     *
     * @throws  ReadOnlyBufferException
     *          If this buffer is backed by an array but is read-only
     *
     * @throws  UnsupportedOperationException
     *          If this buffer is not backed by an accessible array
     *
     * @since 1.6
     */
    public abstract Object array();

    /**
     * Returns the offset within this buffer's backing array of the first
     * element of the buffer&amp;nbsp;&amp;nbsp;&lt;i&gt;(optional operation)&lt;/i&gt;.
     *
     * &lt;p&gt; If this buffer is backed by an array then buffer position &lt;i&gt;p&lt;/i&gt;
     * corresponds to array index &lt;i&gt;p&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;tt&gt;arrayOffset()&lt;/tt&gt;.
     *
     * &lt;p&gt; Invoke the {@link #hasArray hasArray} method before invoking this
     * method in order to ensure that this buffer has an accessible backing
     * array.  &lt;/p&gt;
     *
     * @return  The offset within this buffer's array
     *          of the first element of the buffer
     *
     * @throws  ReadOnlyBufferException
     *          If this buffer is backed by an array but is read-only
     *
     * @throws  UnsupportedOperationException
     *          If this buffer is not backed by an accessible array
     *
     * @since 1.6
     */
    public abstract int arrayOffset();

    /**
     * Tells whether or not this buffer is
     * &lt;a href=&quot;ByteBuffer.html#direct&quot;&gt;&lt;i&gt;direct&lt;/i&gt;&lt;/a&gt;.
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if, and only if, this buffer is direct
     *
     * @since 1.6
     */
    public abstract boolean isDirect();


    // -- Package-private methods for bounds checking, etc. --

    /**
     * Checks the current position against the limit, throwing a {@link
     * BufferUnderflowException} if it is not smaller than the limit, and then
     * increments the position.
     *
     * @return  The current position value, before it is incremented
     */
    final int nextGetIndex() {                          // package-private
<span class="fc bfc" id="L499" title="All 2 branches covered.">        if (position &gt;= limit)</span>
<span class="fc" id="L500">            throw new BufferUnderflowException();</span>
<span class="fc" id="L501">        return position++;</span>
    }

    final int nextGetIndex(int nb) {                    // package-private
<span class="fc bfc" id="L505" title="All 2 branches covered.">        if (limit - position &lt; nb)</span>
<span class="fc" id="L506">            throw new BufferUnderflowException();</span>
<span class="fc" id="L507">        int p = position;</span>
<span class="fc" id="L508">        position += nb;</span>
<span class="fc" id="L509">        return p;</span>
    }

    /**
     * Checks the current position against the limit, throwing a {@link
     * BufferOverflowException} if it is not smaller than the limit, and then
     * increments the position.
     *
     * @return  The current position value, before it is incremented
     */
    final int nextPutIndex() {                          // package-private
<span class="fc bfc" id="L520" title="All 2 branches covered.">        if (position &gt;= limit)</span>
<span class="fc" id="L521">            throw new BufferOverflowException();</span>
<span class="fc" id="L522">        return position++;</span>
    }

    final int nextPutIndex(int nb) {                    // package-private
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">        if (limit - position &lt; nb)</span>
<span class="nc" id="L527">            throw new BufferOverflowException();</span>
<span class="fc" id="L528">        int p = position;</span>
<span class="fc" id="L529">        position += nb;</span>
<span class="fc" id="L530">        return p;</span>
    }

    /**
     * Checks the given index against the limit, throwing an {@link
     * IndexOutOfBoundsException} if it is not smaller than the limit
     * or is smaller than zero.
     */
    final int checkIndex(int i) {                       // package-private
<span class="fc bfc" id="L539" title="All 4 branches covered.">        if ((i &lt; 0) || (i &gt;= limit))</span>
<span class="fc" id="L540">            throw new IndexOutOfBoundsException();</span>
<span class="fc" id="L541">        return i;</span>
    }

    final int checkIndex(int i, int nb) {               // package-private
<span class="fc bfc" id="L545" title="All 4 branches covered.">        if ((i &lt; 0) || (nb &gt; limit - i))</span>
<span class="fc" id="L546">            throw new IndexOutOfBoundsException();</span>
<span class="fc" id="L547">        return i;</span>
    }

    final int markValue() {                             // package-private
<span class="fc" id="L551">        return mark;</span>
    }

    final void truncate() {                             // package-private
<span class="nc" id="L555">        mark = -1;</span>
<span class="nc" id="L556">        position = 0;</span>
<span class="nc" id="L557">        limit = 0;</span>
<span class="nc" id="L558">        capacity = 0;</span>
<span class="nc" id="L559">    }</span>

    final void discardMark() {                          // package-private
<span class="fc" id="L562">        mark = -1;</span>
<span class="fc" id="L563">    }</span>

    static void checkBounds(int off, int len, int size) { // package-private
<span class="pc bpc" id="L566" title="1 of 2 branches missed.">        if ((off | len | (off + len) | (size - (off + len))) &lt; 0)</span>
<span class="nc" id="L567">            throw new IndexOutOfBoundsException();</span>
<span class="fc" id="L568">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>