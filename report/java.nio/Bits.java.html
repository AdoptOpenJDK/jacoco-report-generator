<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Bits.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.nio</a> &gt; <span class="el_source">Bits.java</span></div><h1>Bits.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.nio;

import java.security.AccessController;
import sun.misc.Unsafe;
import sun.misc.VM;

/**
 * Access to bits, native and otherwise.
 */

<span class="fc bfc" id="L36" title="All 2 branches covered.">class Bits {                            // package-private</span>

<span class="nc" id="L38">    private Bits() { }</span>


    // -- Swapping --

    static short swap(short x) {
<span class="fc" id="L44">        return Short.reverseBytes(x);</span>
    }

    static char swap(char x) {
<span class="fc" id="L48">        return Character.reverseBytes(x);</span>
    }

    static int swap(int x) {
<span class="fc" id="L52">        return Integer.reverseBytes(x);</span>
    }

    static long swap(long x) {
<span class="fc" id="L56">        return Long.reverseBytes(x);</span>
    }


    // -- get/put char --

    static private char makeChar(byte b1, byte b0) {
<span class="fc" id="L63">        return (char)((b1 &lt;&lt; 8) | (b0 &amp; 0xff));</span>
    }

    static char getCharL(ByteBuffer bb, int bi) {
<span class="fc" id="L67">        return makeChar(bb._get(bi + 1),</span>
<span class="fc" id="L68">                        bb._get(bi    ));</span>
    }

    static char getCharL(long a) {
<span class="nc" id="L72">        return makeChar(_get(a + 1),</span>
<span class="nc" id="L73">                        _get(a    ));</span>
    }

    static char getCharB(ByteBuffer bb, int bi) {
<span class="fc" id="L77">        return makeChar(bb._get(bi    ),</span>
<span class="fc" id="L78">                        bb._get(bi + 1));</span>
    }

    static char getCharB(long a) {
<span class="nc" id="L82">        return makeChar(_get(a    ),</span>
<span class="nc" id="L83">                        _get(a + 1));</span>
    }

    static char getChar(ByteBuffer bb, int bi, boolean bigEndian) {
<span class="fc bfc" id="L87" title="All 2 branches covered.">        return bigEndian ? getCharB(bb, bi) : getCharL(bb, bi);</span>
    }

    static char getChar(long a, boolean bigEndian) {
<span class="nc bnc" id="L91" title="All 2 branches missed.">        return bigEndian ? getCharB(a) : getCharL(a);</span>
    }

<span class="fc" id="L94">    private static byte char1(char x) { return (byte)(x &gt;&gt; 8); }</span>
<span class="fc" id="L95">    private static byte char0(char x) { return (byte)(x     ); }</span>

    static void putCharL(ByteBuffer bb, int bi, char x) {
<span class="fc" id="L98">        bb._put(bi    , char0(x));</span>
<span class="fc" id="L99">        bb._put(bi + 1, char1(x));</span>
<span class="fc" id="L100">    }</span>

    static void putCharL(long a, char x) {
<span class="nc" id="L103">        _put(a    , char0(x));</span>
<span class="nc" id="L104">        _put(a + 1, char1(x));</span>
<span class="nc" id="L105">    }</span>

    static void putCharB(ByteBuffer bb, int bi, char x) {
<span class="fc" id="L108">        bb._put(bi    , char1(x));</span>
<span class="fc" id="L109">        bb._put(bi + 1, char0(x));</span>
<span class="fc" id="L110">    }</span>

    static void putCharB(long a, char x) {
<span class="nc" id="L113">        _put(a    , char1(x));</span>
<span class="nc" id="L114">        _put(a + 1, char0(x));</span>
<span class="nc" id="L115">    }</span>

    static void putChar(ByteBuffer bb, int bi, char x, boolean bigEndian) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (bigEndian)</span>
<span class="fc" id="L119">            putCharB(bb, bi, x);</span>
        else
<span class="fc" id="L121">            putCharL(bb, bi, x);</span>
<span class="fc" id="L122">    }</span>

    static void putChar(long a, char x, boolean bigEndian) {
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (bigEndian)</span>
<span class="nc" id="L126">            putCharB(a, x);</span>
        else
<span class="nc" id="L128">            putCharL(a, x);</span>
<span class="nc" id="L129">    }</span>


    // -- get/put short --

    static private short makeShort(byte b1, byte b0) {
<span class="fc" id="L135">        return (short)((b1 &lt;&lt; 8) | (b0 &amp; 0xff));</span>
    }

    static short getShortL(ByteBuffer bb, int bi) {
<span class="fc" id="L139">        return makeShort(bb._get(bi + 1),</span>
<span class="fc" id="L140">                         bb._get(bi    ));</span>
    }

    static short getShortL(long a) {
<span class="nc" id="L144">        return makeShort(_get(a + 1),</span>
<span class="nc" id="L145">                         _get(a    ));</span>
    }

    static short getShortB(ByteBuffer bb, int bi) {
<span class="fc" id="L149">        return makeShort(bb._get(bi    ),</span>
<span class="fc" id="L150">                         bb._get(bi + 1));</span>
    }

    static short getShortB(long a) {
<span class="nc" id="L154">        return makeShort(_get(a    ),</span>
<span class="nc" id="L155">                         _get(a + 1));</span>
    }

    static short getShort(ByteBuffer bb, int bi, boolean bigEndian) {
<span class="fc bfc" id="L159" title="All 2 branches covered.">        return bigEndian ? getShortB(bb, bi) : getShortL(bb, bi);</span>
    }

    static short getShort(long a, boolean bigEndian) {
<span class="nc bnc" id="L163" title="All 2 branches missed.">        return bigEndian ? getShortB(a) : getShortL(a);</span>
    }

<span class="fc" id="L166">    private static byte short1(short x) { return (byte)(x &gt;&gt; 8); }</span>
<span class="fc" id="L167">    private static byte short0(short x) { return (byte)(x     ); }</span>

    static void putShortL(ByteBuffer bb, int bi, short x) {
<span class="fc" id="L170">        bb._put(bi    , short0(x));</span>
<span class="fc" id="L171">        bb._put(bi + 1, short1(x));</span>
<span class="fc" id="L172">    }</span>

    static void putShortL(long a, short x) {
<span class="nc" id="L175">        _put(a    , short0(x));</span>
<span class="nc" id="L176">        _put(a + 1, short1(x));</span>
<span class="nc" id="L177">    }</span>

    static void putShortB(ByteBuffer bb, int bi, short x) {
<span class="fc" id="L180">        bb._put(bi    , short1(x));</span>
<span class="fc" id="L181">        bb._put(bi + 1, short0(x));</span>
<span class="fc" id="L182">    }</span>

    static void putShortB(long a, short x) {
<span class="nc" id="L185">        _put(a    , short1(x));</span>
<span class="nc" id="L186">        _put(a + 1, short0(x));</span>
<span class="nc" id="L187">    }</span>

    static void putShort(ByteBuffer bb, int bi, short x, boolean bigEndian) {
<span class="fc bfc" id="L190" title="All 2 branches covered.">        if (bigEndian)</span>
<span class="fc" id="L191">            putShortB(bb, bi, x);</span>
        else
<span class="fc" id="L193">            putShortL(bb, bi, x);</span>
<span class="fc" id="L194">    }</span>

    static void putShort(long a, short x, boolean bigEndian) {
<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (bigEndian)</span>
<span class="nc" id="L198">            putShortB(a, x);</span>
        else
<span class="nc" id="L200">            putShortL(a, x);</span>
<span class="nc" id="L201">    }</span>


    // -- get/put int --

    static private int makeInt(byte b3, byte b2, byte b1, byte b0) {
<span class="fc" id="L207">        return (((b3       ) &lt;&lt; 24) |</span>
                ((b2 &amp; 0xff) &lt;&lt; 16) |
                ((b1 &amp; 0xff) &lt;&lt;  8) |
                ((b0 &amp; 0xff)      ));
    }

    static int getIntL(ByteBuffer bb, int bi) {
<span class="fc" id="L214">        return makeInt(bb._get(bi + 3),</span>
<span class="fc" id="L215">                       bb._get(bi + 2),</span>
<span class="fc" id="L216">                       bb._get(bi + 1),</span>
<span class="fc" id="L217">                       bb._get(bi    ));</span>
    }

    static int getIntL(long a) {
<span class="nc" id="L221">        return makeInt(_get(a + 3),</span>
<span class="nc" id="L222">                       _get(a + 2),</span>
<span class="nc" id="L223">                       _get(a + 1),</span>
<span class="nc" id="L224">                       _get(a    ));</span>
    }

    static int getIntB(ByteBuffer bb, int bi) {
<span class="fc" id="L228">        return makeInt(bb._get(bi    ),</span>
<span class="fc" id="L229">                       bb._get(bi + 1),</span>
<span class="fc" id="L230">                       bb._get(bi + 2),</span>
<span class="fc" id="L231">                       bb._get(bi + 3));</span>
    }

    static int getIntB(long a) {
<span class="nc" id="L235">        return makeInt(_get(a    ),</span>
<span class="nc" id="L236">                       _get(a + 1),</span>
<span class="nc" id="L237">                       _get(a + 2),</span>
<span class="nc" id="L238">                       _get(a + 3));</span>
    }

    static int getInt(ByteBuffer bb, int bi, boolean bigEndian) {
<span class="fc bfc" id="L242" title="All 2 branches covered.">        return bigEndian ? getIntB(bb, bi) : getIntL(bb, bi) ;</span>
    }

    static int getInt(long a, boolean bigEndian) {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        return bigEndian ? getIntB(a) : getIntL(a) ;</span>
    }

<span class="fc" id="L249">    private static byte int3(int x) { return (byte)(x &gt;&gt; 24); }</span>
<span class="fc" id="L250">    private static byte int2(int x) { return (byte)(x &gt;&gt; 16); }</span>
<span class="fc" id="L251">    private static byte int1(int x) { return (byte)(x &gt;&gt;  8); }</span>
<span class="fc" id="L252">    private static byte int0(int x) { return (byte)(x      ); }</span>

    static void putIntL(ByteBuffer bb, int bi, int x) {
<span class="fc" id="L255">        bb._put(bi + 3, int3(x));</span>
<span class="fc" id="L256">        bb._put(bi + 2, int2(x));</span>
<span class="fc" id="L257">        bb._put(bi + 1, int1(x));</span>
<span class="fc" id="L258">        bb._put(bi    , int0(x));</span>
<span class="fc" id="L259">    }</span>

    static void putIntL(long a, int x) {
<span class="nc" id="L262">        _put(a + 3, int3(x));</span>
<span class="nc" id="L263">        _put(a + 2, int2(x));</span>
<span class="nc" id="L264">        _put(a + 1, int1(x));</span>
<span class="nc" id="L265">        _put(a    , int0(x));</span>
<span class="nc" id="L266">    }</span>

    static void putIntB(ByteBuffer bb, int bi, int x) {
<span class="fc" id="L269">        bb._put(bi    , int3(x));</span>
<span class="fc" id="L270">        bb._put(bi + 1, int2(x));</span>
<span class="fc" id="L271">        bb._put(bi + 2, int1(x));</span>
<span class="fc" id="L272">        bb._put(bi + 3, int0(x));</span>
<span class="fc" id="L273">    }</span>

    static void putIntB(long a, int x) {
<span class="nc" id="L276">        _put(a    , int3(x));</span>
<span class="nc" id="L277">        _put(a + 1, int2(x));</span>
<span class="nc" id="L278">        _put(a + 2, int1(x));</span>
<span class="nc" id="L279">        _put(a + 3, int0(x));</span>
<span class="nc" id="L280">    }</span>

    static void putInt(ByteBuffer bb, int bi, int x, boolean bigEndian) {
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (bigEndian)</span>
<span class="fc" id="L284">            putIntB(bb, bi, x);</span>
        else
<span class="fc" id="L286">            putIntL(bb, bi, x);</span>
<span class="fc" id="L287">    }</span>

    static void putInt(long a, int x, boolean bigEndian) {
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (bigEndian)</span>
<span class="nc" id="L291">            putIntB(a, x);</span>
        else
<span class="nc" id="L293">            putIntL(a, x);</span>
<span class="nc" id="L294">    }</span>


    // -- get/put long --

    static private long makeLong(byte b7, byte b6, byte b5, byte b4,
                                 byte b3, byte b2, byte b1, byte b0)
    {
<span class="fc" id="L302">        return ((((long)b7       ) &lt;&lt; 56) |</span>
                (((long)b6 &amp; 0xff) &lt;&lt; 48) |
                (((long)b5 &amp; 0xff) &lt;&lt; 40) |
                (((long)b4 &amp; 0xff) &lt;&lt; 32) |
                (((long)b3 &amp; 0xff) &lt;&lt; 24) |
                (((long)b2 &amp; 0xff) &lt;&lt; 16) |
                (((long)b1 &amp; 0xff) &lt;&lt;  8) |
                (((long)b0 &amp; 0xff)      ));
    }

    static long getLongL(ByteBuffer bb, int bi) {
<span class="fc" id="L313">        return makeLong(bb._get(bi + 7),</span>
<span class="fc" id="L314">                        bb._get(bi + 6),</span>
<span class="fc" id="L315">                        bb._get(bi + 5),</span>
<span class="fc" id="L316">                        bb._get(bi + 4),</span>
<span class="fc" id="L317">                        bb._get(bi + 3),</span>
<span class="fc" id="L318">                        bb._get(bi + 2),</span>
<span class="fc" id="L319">                        bb._get(bi + 1),</span>
<span class="fc" id="L320">                        bb._get(bi    ));</span>
    }

    static long getLongL(long a) {
<span class="nc" id="L324">        return makeLong(_get(a + 7),</span>
<span class="nc" id="L325">                        _get(a + 6),</span>
<span class="nc" id="L326">                        _get(a + 5),</span>
<span class="nc" id="L327">                        _get(a + 4),</span>
<span class="nc" id="L328">                        _get(a + 3),</span>
<span class="nc" id="L329">                        _get(a + 2),</span>
<span class="nc" id="L330">                        _get(a + 1),</span>
<span class="nc" id="L331">                        _get(a    ));</span>
    }

    static long getLongB(ByteBuffer bb, int bi) {
<span class="fc" id="L335">        return makeLong(bb._get(bi    ),</span>
<span class="fc" id="L336">                        bb._get(bi + 1),</span>
<span class="fc" id="L337">                        bb._get(bi + 2),</span>
<span class="fc" id="L338">                        bb._get(bi + 3),</span>
<span class="fc" id="L339">                        bb._get(bi + 4),</span>
<span class="fc" id="L340">                        bb._get(bi + 5),</span>
<span class="fc" id="L341">                        bb._get(bi + 6),</span>
<span class="fc" id="L342">                        bb._get(bi + 7));</span>
    }

    static long getLongB(long a) {
<span class="nc" id="L346">        return makeLong(_get(a    ),</span>
<span class="nc" id="L347">                        _get(a + 1),</span>
<span class="nc" id="L348">                        _get(a + 2),</span>
<span class="nc" id="L349">                        _get(a + 3),</span>
<span class="nc" id="L350">                        _get(a + 4),</span>
<span class="nc" id="L351">                        _get(a + 5),</span>
<span class="nc" id="L352">                        _get(a + 6),</span>
<span class="nc" id="L353">                        _get(a + 7));</span>
    }

    static long getLong(ByteBuffer bb, int bi, boolean bigEndian) {
<span class="fc bfc" id="L357" title="All 2 branches covered.">        return bigEndian ? getLongB(bb, bi) : getLongL(bb, bi);</span>
    }

    static long getLong(long a, boolean bigEndian) {
<span class="nc bnc" id="L361" title="All 2 branches missed.">        return bigEndian ? getLongB(a) : getLongL(a);</span>
    }

<span class="fc" id="L364">    private static byte long7(long x) { return (byte)(x &gt;&gt; 56); }</span>
<span class="fc" id="L365">    private static byte long6(long x) { return (byte)(x &gt;&gt; 48); }</span>
<span class="fc" id="L366">    private static byte long5(long x) { return (byte)(x &gt;&gt; 40); }</span>
<span class="fc" id="L367">    private static byte long4(long x) { return (byte)(x &gt;&gt; 32); }</span>
<span class="fc" id="L368">    private static byte long3(long x) { return (byte)(x &gt;&gt; 24); }</span>
<span class="fc" id="L369">    private static byte long2(long x) { return (byte)(x &gt;&gt; 16); }</span>
<span class="fc" id="L370">    private static byte long1(long x) { return (byte)(x &gt;&gt;  8); }</span>
<span class="fc" id="L371">    private static byte long0(long x) { return (byte)(x      ); }</span>

    static void putLongL(ByteBuffer bb, int bi, long x) {
<span class="fc" id="L374">        bb._put(bi + 7, long7(x));</span>
<span class="fc" id="L375">        bb._put(bi + 6, long6(x));</span>
<span class="fc" id="L376">        bb._put(bi + 5, long5(x));</span>
<span class="fc" id="L377">        bb._put(bi + 4, long4(x));</span>
<span class="fc" id="L378">        bb._put(bi + 3, long3(x));</span>
<span class="fc" id="L379">        bb._put(bi + 2, long2(x));</span>
<span class="fc" id="L380">        bb._put(bi + 1, long1(x));</span>
<span class="fc" id="L381">        bb._put(bi    , long0(x));</span>
<span class="fc" id="L382">    }</span>

    static void putLongL(long a, long x) {
<span class="nc" id="L385">        _put(a + 7, long7(x));</span>
<span class="nc" id="L386">        _put(a + 6, long6(x));</span>
<span class="nc" id="L387">        _put(a + 5, long5(x));</span>
<span class="nc" id="L388">        _put(a + 4, long4(x));</span>
<span class="nc" id="L389">        _put(a + 3, long3(x));</span>
<span class="nc" id="L390">        _put(a + 2, long2(x));</span>
<span class="nc" id="L391">        _put(a + 1, long1(x));</span>
<span class="nc" id="L392">        _put(a    , long0(x));</span>
<span class="nc" id="L393">    }</span>

    static void putLongB(ByteBuffer bb, int bi, long x) {
<span class="fc" id="L396">        bb._put(bi    , long7(x));</span>
<span class="fc" id="L397">        bb._put(bi + 1, long6(x));</span>
<span class="fc" id="L398">        bb._put(bi + 2, long5(x));</span>
<span class="fc" id="L399">        bb._put(bi + 3, long4(x));</span>
<span class="fc" id="L400">        bb._put(bi + 4, long3(x));</span>
<span class="fc" id="L401">        bb._put(bi + 5, long2(x));</span>
<span class="fc" id="L402">        bb._put(bi + 6, long1(x));</span>
<span class="fc" id="L403">        bb._put(bi + 7, long0(x));</span>
<span class="fc" id="L404">    }</span>

    static void putLongB(long a, long x) {
<span class="nc" id="L407">        _put(a    , long7(x));</span>
<span class="nc" id="L408">        _put(a + 1, long6(x));</span>
<span class="nc" id="L409">        _put(a + 2, long5(x));</span>
<span class="nc" id="L410">        _put(a + 3, long4(x));</span>
<span class="nc" id="L411">        _put(a + 4, long3(x));</span>
<span class="nc" id="L412">        _put(a + 5, long2(x));</span>
<span class="nc" id="L413">        _put(a + 6, long1(x));</span>
<span class="nc" id="L414">        _put(a + 7, long0(x));</span>
<span class="nc" id="L415">    }</span>

    static void putLong(ByteBuffer bb, int bi, long x, boolean bigEndian) {
<span class="fc bfc" id="L418" title="All 2 branches covered.">        if (bigEndian)</span>
<span class="fc" id="L419">            putLongB(bb, bi, x);</span>
        else
<span class="fc" id="L421">            putLongL(bb, bi, x);</span>
<span class="fc" id="L422">    }</span>

    static void putLong(long a, long x, boolean bigEndian) {
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (bigEndian)</span>
<span class="nc" id="L426">            putLongB(a, x);</span>
        else
<span class="nc" id="L428">            putLongL(a, x);</span>
<span class="nc" id="L429">    }</span>


    // -- get/put float --

    static float getFloatL(ByteBuffer bb, int bi) {
<span class="fc" id="L435">        return Float.intBitsToFloat(getIntL(bb, bi));</span>
    }

    static float getFloatL(long a) {
<span class="nc" id="L439">        return Float.intBitsToFloat(getIntL(a));</span>
    }

    static float getFloatB(ByteBuffer bb, int bi) {
<span class="fc" id="L443">        return Float.intBitsToFloat(getIntB(bb, bi));</span>
    }

    static float getFloatB(long a) {
<span class="nc" id="L447">        return Float.intBitsToFloat(getIntB(a));</span>
    }

    static float getFloat(ByteBuffer bb, int bi, boolean bigEndian) {
<span class="fc bfc" id="L451" title="All 2 branches covered.">        return bigEndian ? getFloatB(bb, bi) : getFloatL(bb, bi);</span>
    }

    static float getFloat(long a, boolean bigEndian) {
<span class="nc bnc" id="L455" title="All 2 branches missed.">        return bigEndian ? getFloatB(a) : getFloatL(a);</span>
    }

    static void putFloatL(ByteBuffer bb, int bi, float x) {
<span class="fc" id="L459">        putIntL(bb, bi, Float.floatToRawIntBits(x));</span>
<span class="fc" id="L460">    }</span>

    static void putFloatL(long a, float x) {
<span class="nc" id="L463">        putIntL(a, Float.floatToRawIntBits(x));</span>
<span class="nc" id="L464">    }</span>

    static void putFloatB(ByteBuffer bb, int bi, float x) {
<span class="fc" id="L467">        putIntB(bb, bi, Float.floatToRawIntBits(x));</span>
<span class="fc" id="L468">    }</span>

    static void putFloatB(long a, float x) {
<span class="nc" id="L471">        putIntB(a, Float.floatToRawIntBits(x));</span>
<span class="nc" id="L472">    }</span>

    static void putFloat(ByteBuffer bb, int bi, float x, boolean bigEndian) {
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (bigEndian)</span>
<span class="fc" id="L476">            putFloatB(bb, bi, x);</span>
        else
<span class="fc" id="L478">            putFloatL(bb, bi, x);</span>
<span class="fc" id="L479">    }</span>

    static void putFloat(long a, float x, boolean bigEndian) {
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (bigEndian)</span>
<span class="nc" id="L483">            putFloatB(a, x);</span>
        else
<span class="nc" id="L485">            putFloatL(a, x);</span>
<span class="nc" id="L486">    }</span>


    // -- get/put double --

    static double getDoubleL(ByteBuffer bb, int bi) {
<span class="fc" id="L492">        return Double.longBitsToDouble(getLongL(bb, bi));</span>
    }

    static double getDoubleL(long a) {
<span class="nc" id="L496">        return Double.longBitsToDouble(getLongL(a));</span>
    }

    static double getDoubleB(ByteBuffer bb, int bi) {
<span class="fc" id="L500">        return Double.longBitsToDouble(getLongB(bb, bi));</span>
    }

    static double getDoubleB(long a) {
<span class="nc" id="L504">        return Double.longBitsToDouble(getLongB(a));</span>
    }

    static double getDouble(ByteBuffer bb, int bi, boolean bigEndian) {
<span class="fc bfc" id="L508" title="All 2 branches covered.">        return bigEndian ? getDoubleB(bb, bi) : getDoubleL(bb, bi);</span>
    }

    static double getDouble(long a, boolean bigEndian) {
<span class="nc bnc" id="L512" title="All 2 branches missed.">        return bigEndian ? getDoubleB(a) : getDoubleL(a);</span>
    }

    static void putDoubleL(ByteBuffer bb, int bi, double x) {
<span class="fc" id="L516">        putLongL(bb, bi, Double.doubleToRawLongBits(x));</span>
<span class="fc" id="L517">    }</span>

    static void putDoubleL(long a, double x) {
<span class="nc" id="L520">        putLongL(a, Double.doubleToRawLongBits(x));</span>
<span class="nc" id="L521">    }</span>

    static void putDoubleB(ByteBuffer bb, int bi, double x) {
<span class="fc" id="L524">        putLongB(bb, bi, Double.doubleToRawLongBits(x));</span>
<span class="fc" id="L525">    }</span>

    static void putDoubleB(long a, double x) {
<span class="nc" id="L528">        putLongB(a, Double.doubleToRawLongBits(x));</span>
<span class="nc" id="L529">    }</span>

    static void putDouble(ByteBuffer bb, int bi, double x, boolean bigEndian) {
<span class="fc bfc" id="L532" title="All 2 branches covered.">        if (bigEndian)</span>
<span class="fc" id="L533">            putDoubleB(bb, bi, x);</span>
        else
<span class="fc" id="L535">            putDoubleL(bb, bi, x);</span>
<span class="fc" id="L536">    }</span>

    static void putDouble(long a, double x, boolean bigEndian) {
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (bigEndian)</span>
<span class="nc" id="L540">            putDoubleB(a, x);</span>
        else
<span class="nc" id="L542">            putDoubleL(a, x);</span>
<span class="nc" id="L543">    }</span>


    // -- Unsafe access --

<span class="fc" id="L548">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span>

    private static byte _get(long a) {
<span class="nc" id="L551">        return unsafe.getByte(a);</span>
    }

    private static void _put(long a, byte b) {
<span class="nc" id="L555">        unsafe.putByte(a, b);</span>
<span class="nc" id="L556">    }</span>

    static Unsafe unsafe() {
<span class="fc" id="L559">        return unsafe;</span>
    }


    // -- Processor and memory-system properties --

    private static final ByteOrder byteOrder;

    static ByteOrder byteOrder() {
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">        if (byteOrder == null)</span>
<span class="nc" id="L569">            throw new Error(&quot;Unknown byte order&quot;);</span>
<span class="fc" id="L570">        return byteOrder;</span>
    }

    static {
<span class="fc" id="L574">        long a = unsafe.allocateMemory(8);</span>
        try {
<span class="fc" id="L576">            unsafe.putLong(a, 0x0102030405060708L);</span>
<span class="fc" id="L577">            byte b = unsafe.getByte(a);</span>
<span class="pc bpc" id="L578" title="2 of 3 branches missed.">            switch (b) {</span>
<span class="nc" id="L579">            case 0x01: byteOrder = ByteOrder.BIG_ENDIAN;     break;</span>
<span class="fc" id="L580">            case 0x08: byteOrder = ByteOrder.LITTLE_ENDIAN;  break;</span>
            default:
<span class="nc bnc" id="L582" title="All 2 branches missed.">                assert false;</span>
<span class="nc" id="L583">                byteOrder = null;</span>
            }
        } finally {
<span class="pc" id="L586">            unsafe.freeMemory(a);</span>
<span class="fc" id="L587">        }</span>
    }


<span class="fc" id="L591">    private static int pageSize = -1;</span>

    static int pageSize() {
<span class="fc bfc" id="L594" title="All 2 branches covered.">        if (pageSize == -1)</span>
<span class="fc" id="L595">            pageSize = unsafe().pageSize();</span>
<span class="fc" id="L596">        return pageSize;</span>
    }

    static int pageCount(long size) {
<span class="fc" id="L600">        return (int)(size + (long)pageSize() - 1L) / pageSize();</span>
    }

    private static boolean unaligned;
<span class="fc" id="L604">    private static boolean unalignedKnown = false;</span>

    static boolean unaligned() {
<span class="fc bfc" id="L607" title="All 2 branches covered.">        if (unalignedKnown)</span>
<span class="fc" id="L608">            return unaligned;</span>
<span class="fc" id="L609">        String arch = AccessController.doPrivileged(</span>
            new sun.security.action.GetPropertyAction(&quot;os.arch&quot;));
<span class="pc bpc" id="L611" title="2 of 4 branches missed.">        unaligned = arch.equals(&quot;i386&quot;) || arch.equals(&quot;x86&quot;)</span>
<span class="pc bpc" id="L612" title="3 of 4 branches missed.">            || arch.equals(&quot;amd64&quot;) || arch.equals(&quot;x86_64&quot;);</span>
<span class="fc" id="L613">        unalignedKnown = true;</span>
<span class="fc" id="L614">        return unaligned;</span>
    }


    // -- Direct memory management --

    // A user-settable upper limit on the maximum amount of allocatable
    // direct buffer memory.  This value may be changed during VM
    // initialization if it is launched with &quot;-XX:MaxDirectMemorySize=&lt;size&gt;&quot;.
<span class="fc" id="L623">    private static volatile long maxMemory = VM.maxDirectMemory();</span>
    private static volatile long reservedMemory;
    private static volatile long totalCapacity;
    private static volatile long count;
<span class="fc" id="L627">    private static boolean memoryLimitSet = false;</span>

    // These methods should be called whenever direct memory is allocated or
    // freed.  They allow the user to control the amount of direct memory
    // which a process may access.  All sizes are specified in bytes.
    static void reserveMemory(long size, int cap) {
<span class="fc" id="L633">        synchronized (Bits.class) {</span>
<span class="pc bpc" id="L634" title="1 of 4 branches missed.">            if (!memoryLimitSet &amp;&amp; VM.isBooted()) {</span>
<span class="fc" id="L635">                maxMemory = VM.maxDirectMemory();</span>
<span class="fc" id="L636">                memoryLimitSet = true;</span>
            }
            // -XX:MaxDirectMemorySize limits the total capacity rather than the
            // actual memory usage, which will differ when buffers are page
            // aligned.
<span class="fc bfc" id="L641" title="All 2 branches covered.">            if (cap &lt;= maxMemory - totalCapacity) {</span>
<span class="fc" id="L642">                reservedMemory += size;</span>
<span class="fc" id="L643">                totalCapacity += cap;</span>
<span class="fc" id="L644">                count++;</span>
<span class="fc" id="L645">                return;</span>
            }
<span class="pc" id="L647">        }</span>

<span class="fc" id="L649">        System.gc();</span>
        try {
<span class="fc" id="L651">            Thread.sleep(100);</span>
<span class="nc" id="L652">        } catch (InterruptedException x) {</span>
            // Restore interrupt status
<span class="nc" id="L654">            Thread.currentThread().interrupt();</span>
<span class="fc" id="L655">        }</span>
<span class="fc" id="L656">        synchronized (Bits.class) {</span>
<span class="fc bfc" id="L657" title="All 2 branches covered.">            if (totalCapacity + cap &gt; maxMemory)</span>
<span class="fc" id="L658">                throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);</span>
<span class="fc" id="L659">            reservedMemory += size;</span>
<span class="fc" id="L660">            totalCapacity += cap;</span>
<span class="fc" id="L661">            count++;</span>
<span class="fc" id="L662">        }</span>

<span class="fc" id="L664">    }</span>

    static synchronized void unreserveMemory(long size, int cap) {
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">        if (reservedMemory &gt; 0) {</span>
<span class="fc" id="L668">            reservedMemory -= size;</span>
<span class="fc" id="L669">            totalCapacity -= cap;</span>
<span class="fc" id="L670">            count--;</span>
<span class="pc bpc" id="L671" title="1 of 4 branches missed.">            assert (reservedMemory &gt; -1);</span>
        }
<span class="fc" id="L673">    }</span>

    // -- Monitoring of direct buffer usage --

    static {
        // setup access to this package in SharedSecrets
<span class="fc" id="L679">        sun.misc.SharedSecrets.setJavaNioAccess(</span>
<span class="fc" id="L680">            new sun.misc.JavaNioAccess() {</span>
                @Override
                public sun.misc.JavaNioAccess.BufferPool getDirectBufferPool() {
<span class="fc" id="L683">                    return new sun.misc.JavaNioAccess.BufferPool() {</span>
                        @Override
                        public String getName() {
<span class="fc" id="L686">                            return &quot;direct&quot;;</span>
                        }
                        @Override
                        public long getCount() {
<span class="fc" id="L690">                            return Bits.count;</span>
                        }
                        @Override
                        public long getTotalCapacity() {
<span class="fc" id="L694">                            return Bits.totalCapacity;</span>
                        }
                        @Override
                        public long getMemoryUsed() {
<span class="fc" id="L698">                            return Bits.reservedMemory;</span>
                        }
                    };
                }
                @Override
                public ByteBuffer newDirectByteBuffer(long addr, int cap, Object ob) {
<span class="nc" id="L704">                    return new DirectByteBuffer(addr, cap, ob);</span>
                }
                @Override
                public void truncate(Buffer buf) {
<span class="nc" id="L708">                    buf.truncate();</span>
<span class="nc" id="L709">                }</span>
        });
<span class="fc" id="L711">    }</span>

    // -- Bulk get/put acceleration --

    // These numbers represent the point at which we have empirically
    // determined that the average cost of a JNI call exceeds the expense
    // of an element by element copy.  These numbers may change over time.
    static final int JNI_COPY_TO_ARRAY_THRESHOLD   = 6;
    static final int JNI_COPY_FROM_ARRAY_THRESHOLD = 6;

    // This number limits the number of bytes to copy per call to Unsafe's
    // copyMemory method. A limit is imposed to allow for safepoint polling
    // during a large copy
    static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;

    // These methods do no bounds checking.  Verification that the copy will not
    // result in memory corruption should be done prior to invocation.
    // All positions and lengths are specified in bytes.

    /**
     * Copy from given source array to destination address.
     *
     * @param   src
     *          source array
     * @param   srcBaseOffset
     *          offset of first element of storage in source array
     * @param   srcPos
     *          offset within source array of the first element to read
     * @param   dstAddr
     *          destination address
     * @param   length
     *          number of bytes to copy
     */
    static void copyFromArray(Object src, long srcBaseOffset, long srcPos,
                              long dstAddr, long length)
    {
<span class="fc" id="L747">        long offset = srcBaseOffset + srcPos;</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">        while (length &gt; 0) {</span>
<span class="pc bpc" id="L749" title="1 of 2 branches missed.">            long size = (length &gt; UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : length;</span>
<span class="fc" id="L750">            unsafe.copyMemory(src, offset, null, dstAddr, size);</span>
<span class="fc" id="L751">            length -= size;</span>
<span class="fc" id="L752">            offset += size;</span>
<span class="fc" id="L753">            dstAddr += size;</span>
<span class="fc" id="L754">        }</span>
<span class="fc" id="L755">    }</span>

    /**
     * Copy from source address into given destination array.
     *
     * @param   srcAddr
     *          source address
     * @param   dst
     *          destination array
     * @param   dstBaseOffset
     *          offset of first element of storage in destination array
     * @param   dstPos
     *          offset within destination array of the first element to write
     * @param   length
     *          number of bytes to copy
     */
    static void copyToArray(long srcAddr, Object dst, long dstBaseOffset, long dstPos,
                            long length)
    {
<span class="fc" id="L774">        long offset = dstBaseOffset + dstPos;</span>
<span class="fc bfc" id="L775" title="All 2 branches covered.">        while (length &gt; 0) {</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">            long size = (length &gt; UNSAFE_COPY_THRESHOLD) ? UNSAFE_COPY_THRESHOLD : length;</span>
<span class="fc" id="L777">            unsafe.copyMemory(null, srcAddr, dst, offset, size);</span>
<span class="fc" id="L778">            length -= size;</span>
<span class="fc" id="L779">            srcAddr += size;</span>
<span class="fc" id="L780">            offset += size;</span>
<span class="fc" id="L781">        }</span>
<span class="fc" id="L782">    }</span>

    static void copyFromCharArray(Object src, long srcPos, long dstAddr,
                                  long length)
    {
<span class="fc" id="L787">        copyFromShortArray(src, srcPos, dstAddr, length);</span>
<span class="fc" id="L788">    }</span>

    static void copyToCharArray(long srcAddr, Object dst, long dstPos,
                                long length)
    {
<span class="fc" id="L793">        copyToShortArray(srcAddr, dst, dstPos, length);</span>
<span class="fc" id="L794">    }</span>

    static native void copyFromShortArray(Object src, long srcPos, long dstAddr,
                                          long length);
    static native void copyToShortArray(long srcAddr, Object dst, long dstPos,
                                        long length);

    static native void copyFromIntArray(Object src, long srcPos, long dstAddr,
                                        long length);
    static native void copyToIntArray(long srcAddr, Object dst, long dstPos,
                                      long length);

    static native void copyFromLongArray(Object src, long srcPos, long dstAddr,
                                         long length);
    static native void copyToLongArray(long srcAddr, Object dst, long dstPos,
                                       long length);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>