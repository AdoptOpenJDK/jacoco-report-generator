<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MappedByteBuffer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.nio</a> &gt; <span class="el_source">MappedByteBuffer.java</span></div><h1>MappedByteBuffer.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.nio;

import java.io.FileDescriptor;
import sun.misc.Unsafe;


/**
 * A direct byte buffer whose content is a memory-mapped region of a file.
 *
 * &lt;p&gt; Mapped byte buffers are created via the {@link
 * java.nio.channels.FileChannel#map FileChannel.map} method.  This class
 * extends the {@link ByteBuffer} class with operations that are specific to
 * memory-mapped file regions.
 *
 * &lt;p&gt; A mapped byte buffer and the file mapping that it represents remain
 * valid until the buffer itself is garbage-collected.
 *
 * &lt;p&gt; The content of a mapped byte buffer can change at any time, for example
 * if the content of the corresponding region of the mapped file is changed by
 * this program or another.  Whether or not such changes occur, and when they
 * occur, is operating-system dependent and therefore unspecified.
 *
 * &lt;a name=&quot;inaccess&quot;&gt;&lt;/a&gt;&lt;p&gt; All or part of a mapped byte buffer may become
 * inaccessible at any time, for example if the mapped file is truncated.  An
 * attempt to access an inaccessible region of a mapped byte buffer will not
 * change the buffer's content and will cause an unspecified exception to be
 * thrown either at the time of the access or at some later time.  It is
 * therefore strongly recommended that appropriate precautions be taken to
 * avoid the manipulation of a mapped file by this program, or by a
 * concurrently running program, except to read or write the file's content.
 *
 * &lt;p&gt; Mapped byte buffers otherwise behave no differently than ordinary direct
 * byte buffers. &lt;/p&gt;
 *
 *
 * @author Mark Reinhold
 * @author JSR-51 Expert Group
 * @since 1.4
 */

public abstract class MappedByteBuffer
    extends ByteBuffer
{

    // This is a little bit backwards: By rights MappedByteBuffer should be a
    // subclass of DirectByteBuffer, but to keep the spec clear and simple, and
    // for optimization purposes, it's easier to do it the other way around.
    // This works because DirectByteBuffer is a package-private class.

    // For mapped buffers, a FileDescriptor that may be used for mapping
    // operations if valid; null if the buffer is not mapped.
    private final FileDescriptor fd;

    // This should only be invoked by the DirectByteBuffer constructors
    //
    MappedByteBuffer(int mark, int pos, int lim, int cap, // package-private
                     FileDescriptor fd)
    {
<span class="fc" id="L84">        super(mark, pos, lim, cap);</span>
<span class="fc" id="L85">        this.fd = fd;</span>
<span class="fc" id="L86">    }</span>

    MappedByteBuffer(int mark, int pos, int lim, int cap) { // package-private
<span class="fc" id="L89">        super(mark, pos, lim, cap);</span>
<span class="fc" id="L90">        this.fd = null;</span>
<span class="fc" id="L91">    }</span>

    private void checkMapped() {
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        if (fd == null)</span>
            // Can only happen if a luser explicitly casts a direct byte buffer
<span class="nc" id="L96">            throw new UnsupportedOperationException();</span>
<span class="fc" id="L97">    }</span>

    // Returns the distance (in bytes) of the buffer from the page aligned address
    // of the mapping. Computed each time to avoid storing in every direct buffer.
    private long mappingOffset() {
<span class="fc" id="L102">        int ps = Bits.pageSize();</span>
<span class="fc" id="L103">        long offset = address % ps;</span>
<span class="pc bpc" id="L104" title="1 of 2 branches missed.">        return (offset &gt;= 0) ? offset : (ps + offset);</span>
    }

    private long mappingAddress(long mappingOffset) {
<span class="fc" id="L108">        return address - mappingOffset;</span>
    }

    private long mappingLength(long mappingOffset) {
<span class="fc" id="L112">        return (long)capacity() + mappingOffset;</span>
    }

    /**
     * Tells whether or not this buffer's content is resident in physical
     * memory.
     *
     * &lt;p&gt; A return value of &lt;tt&gt;true&lt;/tt&gt; implies that it is highly likely
     * that all of the data in this buffer is resident in physical memory and
     * may therefore be accessed without incurring any virtual-memory page
     * faults or I/O operations.  A return value of &lt;tt&gt;false&lt;/tt&gt; does not
     * necessarily imply that the buffer's content is not resident in physical
     * memory.
     *
     * &lt;p&gt; The returned value is a hint, rather than a guarantee, because the
     * underlying operating system may have paged out some of the buffer's data
     * by the time that an invocation of this method returns.  &lt;/p&gt;
     *
     * @return  &lt;tt&gt;true&lt;/tt&gt; if it is likely that this buffer's content
     *          is resident in physical memory
     */
    public final boolean isLoaded() {
<span class="fc" id="L134">        checkMapped();</span>
<span class="pc bpc" id="L135" title="1 of 4 branches missed.">        if ((address == 0) || (capacity() == 0))</span>
<span class="fc" id="L136">            return true;</span>
<span class="fc" id="L137">        long offset = mappingOffset();</span>
<span class="fc" id="L138">        long length = mappingLength(offset);</span>
<span class="fc" id="L139">        return isLoaded0(mappingAddress(offset), length, Bits.pageCount(length));</span>
    }

    // not used, but a potential target for a store, see load() for details.
    private static byte unused;

    /**
     * Loads this buffer's content into physical memory.
     *
     * &lt;p&gt; This method makes a best effort to ensure that, when it returns,
     * this buffer's content is resident in physical memory.  Invoking this
     * method may cause some number of page faults and I/O operations to
     * occur. &lt;/p&gt;
     *
     * @return  This buffer
     */
    public final MappedByteBuffer load() {
<span class="fc" id="L156">        checkMapped();</span>
<span class="pc bpc" id="L157" title="1 of 4 branches missed.">        if ((address == 0) || (capacity() == 0))</span>
<span class="fc" id="L158">            return this;</span>
<span class="fc" id="L159">        long offset = mappingOffset();</span>
<span class="fc" id="L160">        long length = mappingLength(offset);</span>
<span class="fc" id="L161">        load0(mappingAddress(offset), length);</span>

        // Read a byte from each page to bring it into memory. A checksum
        // is computed as we go along to prevent the compiler from otherwise
        // considering the loop as dead code.
<span class="fc" id="L166">        Unsafe unsafe = Unsafe.getUnsafe();</span>
<span class="fc" id="L167">        int ps = Bits.pageSize();</span>
<span class="fc" id="L168">        int count = Bits.pageCount(length);</span>
<span class="fc" id="L169">        long a = mappingAddress(offset);</span>
<span class="fc" id="L170">        byte x = 0;</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (int i=0; i&lt;count; i++) {</span>
<span class="fc" id="L172">            x ^= unsafe.getByte(a);</span>
<span class="fc" id="L173">            a += ps;</span>
        }
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">        if (unused != 0)</span>
<span class="nc" id="L176">            unused = x;</span>

<span class="fc" id="L178">        return this;</span>
    }

    /**
     * Forces any changes made to this buffer's content to be written to the
     * storage device containing the mapped file.
     *
     * &lt;p&gt; If the file mapped into this buffer resides on a local storage
     * device then when this method returns it is guaranteed that all changes
     * made to the buffer since it was created, or since this method was last
     * invoked, will have been written to that device.
     *
     * &lt;p&gt; If the file does not reside on a local device then no such guarantee
     * is made.
     *
     * &lt;p&gt; If this buffer was not mapped in read/write mode ({@link
     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then invoking this
     * method has no effect. &lt;/p&gt;
     *
     * @return  This buffer
     */
    public final MappedByteBuffer force() {
<span class="fc" id="L200">        checkMapped();</span>
<span class="pc bpc" id="L201" title="1 of 4 branches missed.">        if ((address != 0) &amp;&amp; (capacity() != 0)) {</span>
<span class="fc" id="L202">            long offset = mappingOffset();</span>
<span class="fc" id="L203">            force0(fd, mappingAddress(offset), mappingLength(offset));</span>
        }
<span class="fc" id="L205">        return this;</span>
    }

    private native boolean isLoaded0(long address, long length, int pageCount);
    private native void load0(long address, long length);
    private native void force0(FileDescriptor fd, long address, long length);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>