<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DefaultTreeCellEditor.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.tree</a> &gt; <span class="el_source">DefaultTreeCellEditor.java</span></div><h1>DefaultTreeCellEditor.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.tree;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.plaf.FontUIResource;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.io.*;
import java.util.EventObject;
import java.util.Vector;

/**
 * A &lt;code&gt;TreeCellEditor&lt;/code&gt;. You need to supply an
 * instance of &lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt;
 * so that the icons can be obtained. You can optionally supply
 * a &lt;code&gt;TreeCellEditor&lt;/code&gt; that will be layed out according
 * to the icon in the &lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt;.
 * If you do not supply a &lt;code&gt;TreeCellEditor&lt;/code&gt;,
 * a &lt;code&gt;TextField&lt;/code&gt; will be used. Editing is started
 * on a triple mouse click, or after a click, pause, click and
 * a delay of 1200 milliseconds.
 *&lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see javax.swing.JTree
 *
 * @author Scott Violet
 */
public class DefaultTreeCellEditor implements ActionListener, TreeCellEditor,
            TreeSelectionListener {
    /** Editor handling the editing. */
    protected TreeCellEditor               realEditor;

    /** Renderer, used to get border and offsets from. */
    protected DefaultTreeCellRenderer      renderer;

    /** Editing container, will contain the &lt;code&gt;editorComponent&lt;/code&gt;. */
    protected Container                    editingContainer;

    /**
     * Component used in editing, obtained from the
     * &lt;code&gt;editingContainer&lt;/code&gt;.
     */
    transient protected Component          editingComponent;

    /**
     * As of Java 2 platform v1.4 this field should no longer be used. If
     * you wish to provide similar behavior you should directly override
     * &lt;code&gt;isCellEditable&lt;/code&gt;.
     */
    protected boolean                      canEdit;

    /**
     * Used in editing. Indicates x position to place
     * &lt;code&gt;editingComponent&lt;/code&gt;.
     */
    protected transient int                offset;

    /** &lt;code&gt;JTree&lt;/code&gt; instance listening too. */
    protected transient JTree              tree;

    /** Last path that was selected. */
    protected transient TreePath           lastPath;

    /** Used before starting the editing session. */
    protected transient Timer              timer;

    /**
     * Row that was last passed into
     * &lt;code&gt;getTreeCellEditorComponent&lt;/code&gt;.
     */
    protected transient int                lastRow;

    /** True if the border selection color should be drawn. */
    protected Color                        borderSelectionColor;

    /** Icon to use when editing. */
    protected transient Icon               editingIcon;

    /**
     * Font to paint with, &lt;code&gt;null&lt;/code&gt; indicates
     * font of renderer is to be used.
     */
    protected Font                         font;


    /**
     * Constructs a &lt;code&gt;DefaultTreeCellEditor&lt;/code&gt;
     * object for a JTree using the specified renderer and
     * a default editor. (Use this constructor for normal editing.)
     *
     * @param tree      a &lt;code&gt;JTree&lt;/code&gt; object
     * @param renderer  a &lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt; object
     */
    public DefaultTreeCellEditor(JTree tree,
                                 DefaultTreeCellRenderer renderer) {
<span class="nc" id="L131">        this(tree, renderer, null);</span>
<span class="nc" id="L132">    }</span>

    /**
     * Constructs a &lt;code&gt;DefaultTreeCellEditor&lt;/code&gt;
     * object for a &lt;code&gt;JTree&lt;/code&gt; using the
     * specified renderer and the specified editor. (Use this constructor
     * for specialized editing.)
     *
     * @param tree      a &lt;code&gt;JTree&lt;/code&gt; object
     * @param renderer  a &lt;code&gt;DefaultTreeCellRenderer&lt;/code&gt; object
     * @param editor    a &lt;code&gt;TreeCellEditor&lt;/code&gt; object
     */
    public DefaultTreeCellEditor(JTree tree, DefaultTreeCellRenderer renderer,
<span class="nc" id="L145">                                 TreeCellEditor editor) {</span>
<span class="nc" id="L146">        this.renderer = renderer;</span>
<span class="nc" id="L147">        realEditor = editor;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if(realEditor == null)</span>
<span class="nc" id="L149">            realEditor = createTreeCellEditor();</span>
<span class="nc" id="L150">        editingContainer = createContainer();</span>
<span class="nc" id="L151">        setTree(tree);</span>
<span class="nc" id="L152">        setBorderSelectionColor(UIManager.getColor</span>
<span class="nc" id="L153">                                (&quot;Tree.editorBorderSelectionColor&quot;));</span>
<span class="nc" id="L154">    }</span>

    /**
      * Sets the color to use for the border.
      * @param newColor the new border color
      */
    public void setBorderSelectionColor(Color newColor) {
<span class="nc" id="L161">        borderSelectionColor = newColor;</span>
<span class="nc" id="L162">    }</span>

    /**
      * Returns the color the border is drawn.
      * @return the border selection color
      */
    public Color getBorderSelectionColor() {
<span class="nc" id="L169">        return borderSelectionColor;</span>
    }

    /**
     * Sets the font to edit with. &lt;code&gt;null&lt;/code&gt; indicates
     * the renderers font should be used. This will NOT
     * override any font you have set in the editor
     * the receiver was instantiated with. If &lt;code&gt;null&lt;/code&gt;
     * for an editor was passed in a default editor will be
     * created that will pick up this font.
     *
     * @param font  the editing &lt;code&gt;Font&lt;/code&gt;
     * @see #getFont
     */
    public void setFont(Font font) {
<span class="nc" id="L184">        this.font = font;</span>
<span class="nc" id="L185">    }</span>

    /**
     * Gets the font used for editing.
     *
     * @return the editing &lt;code&gt;Font&lt;/code&gt;
     * @see #setFont
     */
    public Font getFont() {
<span class="nc" id="L194">        return font;</span>
    }

    //
    // TreeCellEditor
    //

    /**
     * Configures the editor.  Passed onto the &lt;code&gt;realEditor&lt;/code&gt;.
     */
    public Component getTreeCellEditorComponent(JTree tree, Object value,
                                                boolean isSelected,
                                                boolean expanded,
                                                boolean leaf, int row) {
<span class="nc" id="L208">        setTree(tree);</span>
<span class="nc" id="L209">        lastRow = row;</span>
<span class="nc" id="L210">        determineOffset(tree, value, isSelected, expanded, leaf, row);</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">        if (editingComponent != null) {</span>
<span class="nc" id="L213">            editingContainer.remove(editingComponent);</span>
        }
<span class="nc" id="L215">        editingComponent = realEditor.getTreeCellEditorComponent(tree, value,</span>
                                        isSelected, expanded,leaf, row);


        // this is kept for backwards compatibility but isn't really needed
        // with the current BasicTreeUI implementation.
<span class="nc" id="L221">        TreePath        newPath = tree.getPathForRow(row);</span>

<span class="nc bnc" id="L223" title="All 4 branches missed.">        canEdit = (lastPath != null &amp;&amp; newPath != null &amp;&amp;</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">                   lastPath.equals(newPath));</span>

<span class="nc" id="L226">        Font            font = getFont();</span>

<span class="nc bnc" id="L228" title="All 2 branches missed.">        if(font == null) {</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">            if(renderer != null)</span>
<span class="nc" id="L230">                font = renderer.getFont();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">            if(font == null)</span>
<span class="nc" id="L232">                font = tree.getFont();</span>
        }
<span class="nc" id="L234">        editingContainer.setFont(font);</span>
<span class="nc" id="L235">        prepareForEditing();</span>
<span class="nc" id="L236">        return editingContainer;</span>
    }

    /**
     * Returns the value currently being edited.
     * @return the value currently being edited
     */
    public Object getCellEditorValue() {
<span class="nc" id="L244">        return realEditor.getCellEditorValue();</span>
    }

    /**
     * If the &lt;code&gt;realEditor&lt;/code&gt; returns true to this
     * message, &lt;code&gt;prepareForEditing&lt;/code&gt;
     * is messaged and true is returned.
     */
    public boolean isCellEditable(EventObject event) {
<span class="nc" id="L253">        boolean            retValue = false;</span>
<span class="nc" id="L254">        boolean            editable = false;</span>

<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (event != null) {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            if (event.getSource() instanceof JTree) {</span>
<span class="nc" id="L258">                setTree((JTree)event.getSource());</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">                if (event instanceof MouseEvent) {</span>
<span class="nc" id="L260">                    TreePath path = tree.getPathForLocation(</span>
<span class="nc" id="L261">                                         ((MouseEvent)event).getX(),</span>
<span class="nc" id="L262">                                         ((MouseEvent)event).getY());</span>
<span class="nc bnc" id="L263" title="All 4 branches missed.">                    editable = (lastPath != null &amp;&amp; path != null &amp;&amp;</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                               lastPath.equals(path));</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">                    if (path!=null) {</span>
<span class="nc" id="L266">                        lastRow = tree.getRowForPath(path);</span>
<span class="nc" id="L267">                        Object value = path.getLastPathComponent();</span>
<span class="nc" id="L268">                        boolean isSelected = tree.isRowSelected(lastRow);</span>
<span class="nc" id="L269">                        boolean expanded = tree.isExpanded(path);</span>
<span class="nc" id="L270">                        TreeModel treeModel = tree.getModel();</span>
<span class="nc" id="L271">                        boolean leaf = treeModel.isLeaf(value);</span>
<span class="nc" id="L272">                        determineOffset(tree, value, isSelected,</span>
                                        expanded, leaf, lastRow);
                    }
                }
            }
        }
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if(!realEditor.isCellEditable(event))</span>
<span class="nc" id="L279">            return false;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if(canEditImmediately(event))</span>
<span class="nc" id="L281">            retValue = true;</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">        else if(editable &amp;&amp; shouldStartEditingTimer(event)) {</span>
<span class="nc" id="L283">            startEditingTimer();</span>
        }
<span class="nc bnc" id="L285" title="All 4 branches missed.">        else if(timer != null &amp;&amp; timer.isRunning())</span>
<span class="nc" id="L286">            timer.stop();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if(retValue)</span>
<span class="nc" id="L288">            prepareForEditing();</span>
<span class="nc" id="L289">        return retValue;</span>
    }

    /**
     * Messages the &lt;code&gt;realEditor&lt;/code&gt; for the return value.
     */
    public boolean shouldSelectCell(EventObject event) {
<span class="nc" id="L296">        return realEditor.shouldSelectCell(event);</span>
    }

    /**
     * If the &lt;code&gt;realEditor&lt;/code&gt; will allow editing to stop,
     * the &lt;code&gt;realEditor&lt;/code&gt; is removed and true is returned,
     * otherwise false is returned.
     */
    public boolean stopCellEditing() {
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if(realEditor.stopCellEditing()) {</span>
<span class="nc" id="L306">            cleanupAfterEditing();</span>
<span class="nc" id="L307">            return true;</span>
        }
<span class="nc" id="L309">        return false;</span>
    }

    /**
     * Messages &lt;code&gt;cancelCellEditing&lt;/code&gt; to the
     * &lt;code&gt;realEditor&lt;/code&gt; and removes it from this instance.
     */
    public void cancelCellEditing() {
<span class="nc" id="L317">        realEditor.cancelCellEditing();</span>
<span class="nc" id="L318">        cleanupAfterEditing();</span>
<span class="nc" id="L319">    }</span>

    /**
     * Adds the &lt;code&gt;CellEditorListener&lt;/code&gt;.
     * @param l the listener to be added
     */
    public void addCellEditorListener(CellEditorListener l) {
<span class="nc" id="L326">        realEditor.addCellEditorListener(l);</span>
<span class="nc" id="L327">    }</span>

    /**
      * Removes the previously added &lt;code&gt;CellEditorListener&lt;/code&gt;.
      * @param l the listener to be removed
      */
    public void removeCellEditorListener(CellEditorListener l) {
<span class="nc" id="L334">        realEditor.removeCellEditorListener(l);</span>
<span class="nc" id="L335">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;CellEditorListener&lt;/code&gt;s added
     * to this DefaultTreeCellEditor with addCellEditorListener().
     *
     * @return all of the &lt;code&gt;CellEditorListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public CellEditorListener[] getCellEditorListeners() {
<span class="nc" id="L346">        return ((DefaultCellEditor)realEditor).getCellEditorListeners();</span>
    }

    //
    // TreeSelectionListener
    //

    /**
     * Resets &lt;code&gt;lastPath&lt;/code&gt;.
     */
    public void valueChanged(TreeSelectionEvent e) {
<span class="nc bnc" id="L357" title="All 2 branches missed.">        if(tree != null) {</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if(tree.getSelectionCount() == 1)</span>
<span class="nc" id="L359">                lastPath = tree.getSelectionPath();</span>
            else
<span class="nc" id="L361">                lastPath = null;</span>
        }
<span class="nc bnc" id="L363" title="All 2 branches missed.">        if(timer != null) {</span>
<span class="nc" id="L364">            timer.stop();</span>
        }
<span class="nc" id="L366">    }</span>

    //
    // ActionListener (for Timer).
    //

    /**
     * Messaged when the timer fires, this will start the editing
     * session.
     */
    public void actionPerformed(ActionEvent e) {
<span class="nc bnc" id="L377" title="All 4 branches missed.">        if(tree != null &amp;&amp; lastPath != null) {</span>
<span class="nc" id="L378">            tree.startEditingAtPath(lastPath);</span>
        }
<span class="nc" id="L380">    }</span>

    //
    // Local methods
    //

    /**
     * Sets the tree currently editing for. This is needed to add
     * a selection listener.
     * @param newTree the new tree to be edited
     */
    protected void setTree(JTree newTree) {
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if(tree != newTree) {</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            if(tree != null)</span>
<span class="nc" id="L394">                tree.removeTreeSelectionListener(this);</span>
<span class="nc" id="L395">            tree = newTree;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if(tree != null)</span>
<span class="nc" id="L397">                tree.addTreeSelectionListener(this);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            if(timer != null) {</span>
<span class="nc" id="L399">                timer.stop();</span>
            }
        }
<span class="nc" id="L402">    }</span>

    /**
     * Returns true if &lt;code&gt;event&lt;/code&gt; is a &lt;code&gt;MouseEvent&lt;/code&gt;
     * and the click count is 1.
     * @param event  the event being studied
     */
    protected boolean shouldStartEditingTimer(EventObject event) {
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if((event instanceof MouseEvent) &amp;&amp;</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            SwingUtilities.isLeftMouseButton((MouseEvent)event)) {</span>
<span class="nc" id="L412">            MouseEvent        me = (MouseEvent)event;</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">            return (me.getClickCount() == 1 &amp;&amp;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">                    inHitRegion(me.getX(), me.getY()));</span>
        }
<span class="nc" id="L417">        return false;</span>
    }

    /**
     * Starts the editing timer.
     */
    protected void startEditingTimer() {
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if(timer == null) {</span>
<span class="nc" id="L425">            timer = new Timer(1200, this);</span>
<span class="nc" id="L426">            timer.setRepeats(false);</span>
        }
<span class="nc" id="L428">        timer.start();</span>
<span class="nc" id="L429">    }</span>

    /**
     * Returns true if &lt;code&gt;event&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * or it is a &lt;code&gt;MouseEvent&lt;/code&gt; with a click count &amp;gt; 2
     * and &lt;code&gt;inHitRegion&lt;/code&gt; returns true.
     * @param event the event being studied
     */
    protected boolean canEditImmediately(EventObject event) {
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if((event instanceof MouseEvent) &amp;&amp;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">           SwingUtilities.isLeftMouseButton((MouseEvent)event)) {</span>
<span class="nc" id="L440">            MouseEvent       me = (MouseEvent)event;</span>

<span class="nc bnc" id="L442" title="All 2 branches missed.">            return ((me.getClickCount() &gt; 2) &amp;&amp;</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">                    inHitRegion(me.getX(), me.getY()));</span>
        }
<span class="nc bnc" id="L445" title="All 2 branches missed.">        return (event == null);</span>
    }

    /**
     * Returns true if the passed in location is a valid mouse location
     * to start editing from. This is implemented to return false if
     * &lt;code&gt;x&lt;/code&gt; is &amp;lt;= the width of the icon and icon gap displayed
     * by the renderer. In other words this returns true if the user
     * clicks over the text part displayed by the renderer, and false
     * otherwise.
     * @param x the x-coordinate of the point
     * @param y the y-coordinate of the point
     * @return true if the passed in location is a valid mouse location
     */
    protected boolean inHitRegion(int x, int y) {
<span class="nc bnc" id="L460" title="All 4 branches missed.">        if(lastRow != -1 &amp;&amp; tree != null) {</span>
<span class="nc" id="L461">            Rectangle bounds = tree.getRowBounds(lastRow);</span>
<span class="nc" id="L462">            ComponentOrientation treeOrientation = tree.getComponentOrientation();</span>

<span class="nc bnc" id="L464" title="All 2 branches missed.">            if ( treeOrientation.isLeftToRight() ) {</span>
<span class="nc bnc" id="L465" title="All 6 branches missed.">                if (bounds != null &amp;&amp; x &lt;= (bounds.x + offset) &amp;&amp;</span>
                    offset &lt; (bounds.width - 5)) {
<span class="nc" id="L467">                    return false;</span>
                }
<span class="nc bnc" id="L469" title="All 8 branches missed.">            } else if ( bounds != null &amp;&amp;</span>
                        ( x &gt;= (bounds.x+bounds.width-offset+5) ||
                          x &lt;= (bounds.x + 5) ) &amp;&amp;
                        offset &lt; (bounds.width - 5) ) {
<span class="nc" id="L473">                return false;</span>
            }
        }
<span class="nc" id="L476">        return true;</span>
    }

    protected void determineOffset(JTree tree, Object value,
                                   boolean isSelected, boolean expanded,
                                   boolean leaf, int row) {
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if(renderer != null) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">            if(leaf)</span>
<span class="nc" id="L484">                editingIcon = renderer.getLeafIcon();</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            else if(expanded)</span>
<span class="nc" id="L486">                editingIcon = renderer.getOpenIcon();</span>
            else
<span class="nc" id="L488">                editingIcon = renderer.getClosedIcon();</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">            if(editingIcon != null)</span>
<span class="nc" id="L490">                offset = renderer.getIconTextGap() +</span>
<span class="nc" id="L491">                         editingIcon.getIconWidth();</span>
            else
<span class="nc" id="L493">                offset = renderer.getIconTextGap();</span>
        }
        else {
<span class="nc" id="L496">            editingIcon = null;</span>
<span class="nc" id="L497">            offset = 0;</span>
        }
<span class="nc" id="L499">    }</span>

    /**
     * Invoked just before editing is to start. Will add the
     * &lt;code&gt;editingComponent&lt;/code&gt; to the
     * &lt;code&gt;editingContainer&lt;/code&gt;.
     */
    protected void prepareForEditing() {
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (editingComponent != null) {</span>
<span class="nc" id="L508">            editingContainer.add(editingComponent);</span>
        }
<span class="nc" id="L510">    }</span>

    /**
     * Creates the container to manage placement of
     * &lt;code&gt;editingComponent&lt;/code&gt;.
     */
    protected Container createContainer() {
<span class="nc" id="L517">        return new EditorContainer();</span>
    }

    /**
     * This is invoked if a &lt;code&gt;TreeCellEditor&lt;/code&gt;
     * is not supplied in the constructor.
     * It returns a &lt;code&gt;TextField&lt;/code&gt; editor.
     * @return a new &lt;code&gt;TextField&lt;/code&gt; editor
     */
    protected TreeCellEditor createTreeCellEditor() {
<span class="nc" id="L527">        Border              aBorder = UIManager.getBorder(&quot;Tree.editorBorder&quot;);</span>
<span class="nc" id="L528">        DefaultCellEditor   editor = new DefaultCellEditor</span>
<span class="nc" id="L529">            (new DefaultTextField(aBorder)) {</span>
            public boolean shouldSelectCell(EventObject event) {
<span class="nc" id="L531">                boolean retValue = super.shouldSelectCell(event);</span>
<span class="nc" id="L532">                return retValue;</span>
            }
        };

        // One click to edit.
<span class="nc" id="L537">        editor.setClickCountToStart(1);</span>
<span class="nc" id="L538">        return editor;</span>
    }

    /**
     * Cleans up any state after editing has completed. Removes the
     * &lt;code&gt;editingComponent&lt;/code&gt; the &lt;code&gt;editingContainer&lt;/code&gt;.
     */
    private void cleanupAfterEditing() {
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (editingComponent != null) {</span>
<span class="nc" id="L547">            editingContainer.remove(editingComponent);</span>
        }
<span class="nc" id="L549">        editingComponent = null;</span>
<span class="nc" id="L550">    }</span>

    // Serialization support.
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L554">        Vector&lt;Object&gt; values = new Vector&lt;Object&gt;();</span>

<span class="nc" id="L556">        s.defaultWriteObject();</span>
        // Save the realEditor, if its Serializable.
<span class="nc bnc" id="L558" title="All 4 branches missed.">        if(realEditor != null &amp;&amp; realEditor instanceof Serializable) {</span>
<span class="nc" id="L559">            values.addElement(&quot;realEditor&quot;);</span>
<span class="nc" id="L560">            values.addElement(realEditor);</span>
        }
<span class="nc" id="L562">        s.writeObject(values);</span>
<span class="nc" id="L563">    }</span>

    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
<span class="nc" id="L567">        s.defaultReadObject();</span>

<span class="nc" id="L569">        Vector          values = (Vector)s.readObject();</span>
<span class="nc" id="L570">        int             indexCounter = 0;</span>
<span class="nc" id="L571">        int             maxCounter = values.size();</span>

<span class="nc bnc" id="L573" title="All 2 branches missed.">        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">           equals(&quot;realEditor&quot;)) {</span>
<span class="nc" id="L575">            realEditor = (TreeCellEditor)values.elementAt(++indexCounter);</span>
<span class="nc" id="L576">            indexCounter++;</span>
        }
<span class="nc" id="L578">    }</span>


    /**
     * &lt;code&gt;TextField&lt;/code&gt; used when no editor is supplied.
     * This textfield locks into the border it is constructed with.
     * It also prefers its parents font over its font. And if the
     * renderer is not &lt;code&gt;null&lt;/code&gt; and no font
     * has been specified the preferred height is that of the renderer.
     */
    public class DefaultTextField extends JTextField {
        /** Border to use. */
        protected Border         border;

        /**
         * Constructs a
         * &lt;code&gt;DefaultTreeCellEditor.DefaultTextField&lt;/code&gt; object.
         *
         * @param border  a &lt;code&gt;Border&lt;/code&gt; object
         * @since 1.4
         */
<span class="nc" id="L599">        public DefaultTextField(Border border) {</span>
<span class="nc" id="L600">            setBorder(border);</span>
<span class="nc" id="L601">        }</span>

        /**
         * Sets the border of this component.&lt;p&gt;
         * This is a bound property.
         *
         * @param border the border to be rendered for this component
         * @see Border
         * @see CompoundBorder
         * @beaninfo
         *        bound: true
         *    preferred: true
         *    attribute: visualUpdate true
         *  description: The component's border.
         */
        public void setBorder(Border border) {
<span class="nc" id="L617">            super.setBorder(border);</span>
<span class="nc" id="L618">            this.border = border;</span>
<span class="nc" id="L619">        }</span>

        /**
         * Overrides &lt;code&gt;JComponent.getBorder&lt;/code&gt; to
         * returns the current border.
         */
        public Border getBorder() {
<span class="nc" id="L626">            return border;</span>
        }

        // implements java.awt.MenuContainer
        public Font getFont() {
<span class="nc" id="L631">            Font     font = super.getFont();</span>

            // Prefer the parent containers font if our font is a
            // FontUIResource
<span class="nc bnc" id="L635" title="All 2 branches missed.">            if(font instanceof FontUIResource) {</span>
<span class="nc" id="L636">                Container     parent = getParent();</span>

<span class="nc bnc" id="L638" title="All 4 branches missed.">                if(parent != null &amp;&amp; parent.getFont() != null)</span>
<span class="nc" id="L639">                    font = parent.getFont();</span>
            }
<span class="nc" id="L641">            return font;</span>
        }

        /**
         * Overrides &lt;code&gt;JTextField.getPreferredSize&lt;/code&gt; to
         * return the preferred size based on current font, if set,
         * or else use renderer's font.
         * @return a &lt;code&gt;Dimension&lt;/code&gt; object containing
         *   the preferred size
         */
        public Dimension getPreferredSize() {
<span class="nc" id="L652">            Dimension      size = super.getPreferredSize();</span>

            // If not font has been set, prefer the renderers height.
<span class="nc bnc" id="L655" title="All 2 branches missed.">            if(renderer != null &amp;&amp;</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">               DefaultTreeCellEditor.this.getFont() == null) {</span>
<span class="nc" id="L657">                Dimension     rSize = renderer.getPreferredSize();</span>

<span class="nc" id="L659">                size.height = rSize.height;</span>
            }
<span class="nc" id="L661">            return size;</span>
        }
    }


    /**
     * Container responsible for placing the &lt;code&gt;editingComponent&lt;/code&gt;.
     */
    public class EditorContainer extends Container {
        /**
         * Constructs an &lt;code&gt;EditorContainer&lt;/code&gt; object.
         */
<span class="nc" id="L673">        public EditorContainer() {</span>
<span class="nc" id="L674">            setLayout(null);</span>
<span class="nc" id="L675">        }</span>

        // This should not be used. It will be removed when new API is
        // allowed.
        public void EditorContainer() {
<span class="nc" id="L680">            setLayout(null);</span>
<span class="nc" id="L681">        }</span>

        /**
         * Overrides &lt;code&gt;Container.paint&lt;/code&gt; to paint the node's
         * icon and use the selection color for the background.
         */
        public void paint(Graphics g) {
<span class="nc" id="L688">            int width = getWidth();</span>
<span class="nc" id="L689">            int height = getHeight();</span>

            // Then the icon.
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if(editingIcon != null) {</span>
<span class="nc" id="L693">                int yLoc = calculateIconY(editingIcon);</span>

<span class="nc bnc" id="L695" title="All 2 branches missed.">                if (getComponentOrientation().isLeftToRight()) {</span>
<span class="nc" id="L696">                    editingIcon.paintIcon(this, g, 0, yLoc);</span>
                } else {
<span class="nc" id="L698">                    editingIcon.paintIcon(</span>
<span class="nc" id="L699">                            this, g, width - editingIcon.getIconWidth(),</span>
                            yLoc);
                }
            }

            // Border selection color
<span class="nc" id="L705">            Color       background = getBorderSelectionColor();</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">            if(background != null) {</span>
<span class="nc" id="L707">                g.setColor(background);</span>
<span class="nc" id="L708">                g.drawRect(0, 0, width - 1, height - 1);</span>
            }
<span class="nc" id="L710">            super.paint(g);</span>
<span class="nc" id="L711">        }</span>

        /**
         * Lays out this &lt;code&gt;Container&lt;/code&gt;.  If editing,
         * the editor will be placed at
         * &lt;code&gt;offset&lt;/code&gt; in the x direction and 0 for y.
         */
        public void doLayout() {
<span class="nc bnc" id="L719" title="All 2 branches missed.">            if(editingComponent != null) {</span>
<span class="nc" id="L720">                int width = getWidth();</span>
<span class="nc" id="L721">                int height = getHeight();</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">                if (getComponentOrientation().isLeftToRight()) {</span>
<span class="nc" id="L723">                    editingComponent.setBounds(</span>
                            offset, 0, width - offset, height);
                } else {
<span class="nc" id="L726">                    editingComponent.setBounds(</span>
                        0, 0, width - offset, height);
                }
            }
<span class="nc" id="L730">        }</span>

        /**
         * Calculate the y location for the icon.
         */
        private int calculateIconY(Icon icon) {
            // To make sure the icon position matches that of the
            // renderer, use the same algorithm as JLabel
            // (SwingUtilities.layoutCompoundLabel).
<span class="nc" id="L739">            int iconHeight = icon.getIconHeight();</span>
<span class="nc" id="L740">            int textHeight = editingComponent.getFontMetrics(</span>
<span class="nc" id="L741">                editingComponent.getFont()).getHeight();</span>
<span class="nc" id="L742">            int textY = iconHeight / 2 - textHeight / 2;</span>
<span class="nc" id="L743">            int totalY = Math.min(0, textY);</span>
<span class="nc" id="L744">            int totalHeight = Math.max(iconHeight, textY + textHeight) -</span>
                totalY;
<span class="nc" id="L746">            return getHeight() / 2 - (totalY + (totalHeight / 2));</span>
        }

        /**
         * Returns the preferred size for the &lt;code&gt;Container&lt;/code&gt;.
         * This will be at least preferred size of the editor plus
         * &lt;code&gt;offset&lt;/code&gt;.
         * @return a &lt;code&gt;Dimension&lt;/code&gt; containing the preferred
         *   size for the &lt;code&gt;Container&lt;/code&gt;; if
         *   &lt;code&gt;editingComponent&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; the
         *   &lt;code&gt;Dimension&lt;/code&gt; returned is 0, 0
         */
        public Dimension getPreferredSize() {
<span class="nc bnc" id="L759" title="All 2 branches missed.">            if(editingComponent != null) {</span>
<span class="nc" id="L760">                Dimension         pSize = editingComponent.getPreferredSize();</span>

<span class="nc" id="L762">                pSize.width += offset + 5;</span>

<span class="nc bnc" id="L764" title="All 2 branches missed.">                Dimension         rSize = (renderer != null) ?</span>
<span class="nc" id="L765">                                          renderer.getPreferredSize() : null;</span>

<span class="nc bnc" id="L767" title="All 2 branches missed.">                if(rSize != null)</span>
<span class="nc" id="L768">                    pSize.height = Math.max(pSize.height, rSize.height);</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                if(editingIcon != null)</span>
<span class="nc" id="L770">                    pSize.height = Math.max(pSize.height,</span>
<span class="nc" id="L771">                                            editingIcon.getIconHeight());</span>

                // Make sure width is at least 100.
<span class="nc" id="L774">                pSize.width = Math.max(pSize.width, 100);</span>
<span class="nc" id="L775">                return pSize;</span>
            }
<span class="nc" id="L777">            return new Dimension(0, 0);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>