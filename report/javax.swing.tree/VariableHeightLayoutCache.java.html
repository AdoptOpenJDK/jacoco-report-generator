<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VariableHeightLayoutCache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.tree</a> &gt; <span class="el_source">VariableHeightLayoutCache.java</span></div><h1>VariableHeightLayoutCache.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.tree;

import javax.swing.event.TreeModelEvent;
import java.awt.Rectangle;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.NoSuchElementException;
import java.util.Stack;
import java.util.Vector;

import sun.swing.SwingUtilities2;

/**
 * NOTE: This will become more open in a future release.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author Rob Davis
 * @author Ray Ryan
 * @author Scott Violet
 */

public class VariableHeightLayoutCache extends AbstractLayoutCache {
    /**
     * The array of nodes that are currently visible, in the order they
     * are displayed.
     */
    private Vector&lt;Object&gt; visibleNodes;

    /**
     * This is set to true if one of the entries has an invalid size.
     */
    private boolean           updateNodeSizes;

    /**
     * The root node of the internal cache of nodes that have been shown.
     * If the treeModel is vending a network rather than a true tree,
     * there may be one cached node for each path to a modeled node.
     */
    private TreeStateNode     root;

    /**
     * Used in getting sizes for nodes to avoid creating a new Rectangle
     * every time a size is needed.
     */
    private Rectangle         boundsBuffer;

    /**
     * Maps from &lt;code&gt;TreePath&lt;/code&gt; to a &lt;code&gt;TreeStateNode&lt;/code&gt;.
     */
    private Hashtable&lt;TreePath, TreeStateNode&gt; treePathMapping;

    /**
     * A stack of stacks.
     */
    private Stack&lt;Stack&lt;TreePath&gt;&gt; tempStacks;


    public VariableHeightLayoutCache() {
<span class="nc" id="L92">        super();</span>
<span class="nc" id="L93">        tempStacks = new Stack&lt;Stack&lt;TreePath&gt;&gt;();</span>
<span class="nc" id="L94">        visibleNodes = new Vector&lt;Object&gt;();</span>
<span class="nc" id="L95">        boundsBuffer = new Rectangle();</span>
<span class="nc" id="L96">        treePathMapping = new Hashtable&lt;TreePath, TreeStateNode&gt;();</span>
<span class="nc" id="L97">    }</span>

    /**
     * Sets the &lt;code&gt;TreeModel&lt;/code&gt; that will provide the data.
     *
     * @param newModel the &lt;code&gt;TreeModel&lt;/code&gt; that is to provide the data
     * @beaninfo
     *        bound: true
     *  description: The TreeModel that will provide the data.
     */
    public void setModel(TreeModel newModel) {
<span class="nc" id="L108">        super.setModel(newModel);</span>
<span class="nc" id="L109">        rebuild(false);</span>
<span class="nc" id="L110">    }</span>

    /**
     * Determines whether or not the root node from
     * the &lt;code&gt;TreeModel&lt;/code&gt; is visible.
     *
     * @param rootVisible true if the root node of the tree is to be displayed
     * @see #rootVisible
     * @beaninfo
     *        bound: true
     *  description: Whether or not the root node
     *               from the TreeModel is visible.
     */
    public void setRootVisible(boolean rootVisible) {
<span class="nc bnc" id="L124" title="All 4 branches missed.">        if(isRootVisible() != rootVisible &amp;&amp; root != null) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if(rootVisible) {</span>
<span class="nc" id="L126">                root.updatePreferredSize(0);</span>
<span class="nc" id="L127">                visibleNodes.insertElementAt(root, 0);</span>
            }
<span class="nc bnc" id="L129" title="All 2 branches missed.">            else if(visibleNodes.size() &gt; 0) {</span>
<span class="nc" id="L130">                visibleNodes.removeElementAt(0);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                if(treeSelectionModel != null)</span>
<span class="nc" id="L132">                    treeSelectionModel.removeSelectionPath</span>
<span class="nc" id="L133">                        (root.getTreePath());</span>
            }
<span class="nc bnc" id="L135" title="All 2 branches missed.">            if(treeSelectionModel != null)</span>
<span class="nc" id="L136">                treeSelectionModel.resetRowSelection();</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">            if(getRowCount() &gt; 0)</span>
<span class="nc" id="L138">                getNode(0).setYOrigin(0);</span>
<span class="nc" id="L139">            updateYLocationsFrom(0);</span>
<span class="nc" id="L140">            visibleNodesChanged();</span>
        }
<span class="nc" id="L142">        super.setRootVisible(rootVisible);</span>
<span class="nc" id="L143">    }</span>

    /**
     * Sets the height of each cell.  If the specified value
     * is less than or equal to zero the current cell renderer is
     * queried for each row's height.
     *
     * @param rowHeight the height of each cell, in pixels
     * @beaninfo
     *        bound: true
     *  description: The height of each cell.
     */
    public void setRowHeight(int rowHeight) {
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if(rowHeight != getRowHeight()) {</span>
<span class="nc" id="L157">            super.setRowHeight(rowHeight);</span>
<span class="nc" id="L158">            invalidateSizes();</span>
<span class="nc" id="L159">            this.visibleNodesChanged();</span>
        }
<span class="nc" id="L161">    }</span>

    /**
     * Sets the renderer that is responsible for drawing nodes in the tree.
     * @param nd the renderer
     */
    public void setNodeDimensions(NodeDimensions nd) {
<span class="nc" id="L168">        super.setNodeDimensions(nd);</span>
<span class="nc" id="L169">        invalidateSizes();</span>
<span class="nc" id="L170">        visibleNodesChanged();</span>
<span class="nc" id="L171">    }</span>

    /**
     * Marks the path &lt;code&gt;path&lt;/code&gt; expanded state to
     * &lt;code&gt;isExpanded&lt;/code&gt;.
     * @param path the &lt;code&gt;TreePath&lt;/code&gt; of interest
     * @param isExpanded true if the path should be expanded, otherwise false
     */
    public void setExpandedState(TreePath path, boolean isExpanded) {
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if(path != null) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">            if(isExpanded)</span>
<span class="nc" id="L182">                ensurePathIsExpanded(path, true);</span>
            else {
<span class="nc" id="L184">                TreeStateNode        node = getNodeForPath(path, false, true);</span>

<span class="nc bnc" id="L186" title="All 2 branches missed.">                if(node != null) {</span>
<span class="nc" id="L187">                    node.makeVisible();</span>
<span class="nc" id="L188">                    node.collapse();</span>
                }
            }
        }
<span class="nc" id="L192">    }</span>

    /**
     * Returns true if the path is expanded, and visible.
     * @return true if the path is expanded and visible, otherwise false
     */
    public boolean getExpandedState(TreePath path) {
<span class="nc" id="L199">        TreeStateNode       node = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L201" title="All 6 branches missed.">        return (node != null) ? (node.isVisible() &amp;&amp; node.isExpanded()) :</span>
                                 false;
    }

    /**
      * Returns the &lt;code&gt;Rectangle&lt;/code&gt; enclosing the label portion
      * into which the item identified by &lt;code&gt;path&lt;/code&gt; will be drawn.
      *
      * @param path  the path to be drawn
      * @param placeIn the bounds of the enclosing rectangle
      * @return the bounds of the enclosing rectangle or &lt;code&gt;null&lt;/code&gt;
      *    if the node could not be ascertained
      */
    public Rectangle getBounds(TreePath path, Rectangle placeIn) {
<span class="nc" id="L215">        TreeStateNode       node = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">        if(node != null) {</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            if(updateNodeSizes)</span>
<span class="nc" id="L219">                updateNodeSizes(false);</span>
<span class="nc" id="L220">            return node.getNodeBounds(placeIn);</span>
        }
<span class="nc" id="L222">        return null;</span>
    }

    /**
      * Returns the path for &lt;code&gt;row&lt;/code&gt;.  If &lt;code&gt;row&lt;/code&gt;
      * is not visible, &lt;code&gt;null&lt;/code&gt; is returned.
      *
      * @param row the location of interest
      * @return the path for &lt;code&gt;row&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;
      * if &lt;code&gt;row&lt;/code&gt; is not visible
      */
    public TreePath getPathForRow(int row) {
<span class="nc bnc" id="L234" title="All 4 branches missed.">        if(row &gt;= 0 &amp;&amp; row &lt; getRowCount()) {</span>
<span class="nc" id="L235">            return getNode(row).getTreePath();</span>
        }
<span class="nc" id="L237">        return null;</span>
    }

    /**
      * Returns the row where the last item identified in path is visible.
      * Will return -1 if any of the elements in path are not
      * currently visible.
      *
      * @param path the &lt;code&gt;TreePath&lt;/code&gt; of interest
      * @return the row where the last item in path is visible
      */
    public int getRowForPath(TreePath path) {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if(path == null)</span>
<span class="nc" id="L250">            return -1;</span>

<span class="nc" id="L252">        TreeStateNode    visNode = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L254" title="All 2 branches missed.">        if(visNode != null)</span>
<span class="nc" id="L255">            return visNode.getRow();</span>
<span class="nc" id="L256">        return -1;</span>
    }

    /**
     * Returns the number of visible rows.
     * @return the number of visible rows
     */
    public int getRowCount() {
<span class="nc" id="L264">        return visibleNodes.size();</span>
    }

    /**
     * Instructs the &lt;code&gt;LayoutCache&lt;/code&gt; that the bounds for
     * &lt;code&gt;path&lt;/code&gt; are invalid, and need to be updated.
     *
     * @param path the &lt;code&gt;TreePath&lt;/code&gt; which is now invalid
     */
    public void invalidatePathBounds(TreePath path) {
<span class="nc" id="L274">        TreeStateNode       node = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">        if(node != null) {</span>
<span class="nc" id="L277">            node.markSizeInvalid();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if(node.isVisible())</span>
<span class="nc" id="L279">                updateYLocationsFrom(node.getRow());</span>
        }
<span class="nc" id="L281">    }</span>

    /**
     * Returns the preferred height.
     * @return the preferred height
     */
    public int getPreferredHeight() {
        // Get the height
<span class="nc" id="L289">        int           rowCount = getRowCount();</span>

<span class="nc bnc" id="L291" title="All 2 branches missed.">        if(rowCount &gt; 0) {</span>
<span class="nc" id="L292">            TreeStateNode  node = getNode(rowCount - 1);</span>

<span class="nc" id="L294">            return node.getYOrigin() + node.getPreferredHeight();</span>
        }
<span class="nc" id="L296">        return 0;</span>
    }

    /**
     * Returns the preferred width and height for the region in
     * &lt;code&gt;visibleRegion&lt;/code&gt;.
     *
     * @param bounds  the region being queried
     */
    public int getPreferredWidth(Rectangle bounds) {
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if(updateNodeSizes)</span>
<span class="nc" id="L307">            updateNodeSizes(false);</span>

<span class="nc" id="L309">        return getMaxNodeWidth();</span>
    }

    /**
      * Returns the path to the node that is closest to x,y.  If
      * there is nothing currently visible this will return &lt;code&gt;null&lt;/code&gt;,
      * otherwise it will always return a valid path.
      * If you need to test if the
      * returned object is exactly at x, y you should get the bounds for
      * the returned path and test x, y against that.
      *
      * @param x  the x-coordinate
      * @param y  the y-coordinate
      * @return the path to the node that is closest to x, y
      */
    public TreePath getPathClosestTo(int x, int y) {
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if(getRowCount() == 0)</span>
<span class="nc" id="L326">            return null;</span>

<span class="nc bnc" id="L328" title="All 2 branches missed.">        if(updateNodeSizes)</span>
<span class="nc" id="L329">            updateNodeSizes(false);</span>

<span class="nc" id="L331">        int                row = getRowContainingYLocation(y);</span>

<span class="nc" id="L333">        return getNode(row).getTreePath();</span>
    }

    /**
     * Returns an &lt;code&gt;Enumerator&lt;/code&gt; that increments over the visible paths
     * starting at the passed in location. The ordering of the enumeration
     * is based on how the paths are displayed.
     *
     * @param path the location in the &lt;code&gt;TreePath&lt;/code&gt; to start
     * @return an &lt;code&gt;Enumerator&lt;/code&gt; that increments over the visible
     *     paths
     */
    public Enumeration&lt;TreePath&gt; getVisiblePathsFrom(TreePath path) {
<span class="nc" id="L346">        TreeStateNode       node = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L348" title="All 2 branches missed.">        if(node != null) {</span>
<span class="nc" id="L349">            return new VisibleTreeStateNodeEnumeration(node);</span>
        }
<span class="nc" id="L351">        return null;</span>
    }

    /**
     * Returns the number of visible children for &lt;code&gt;path&lt;/code&gt;.
     * @return the number of visible children for &lt;code&gt;path&lt;/code&gt;
     */
    public int getVisibleChildCount(TreePath path) {
<span class="nc" id="L359">        TreeStateNode         node = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L361" title="All 2 branches missed.">        return (node != null) ? node.getVisibleChildCount() : 0;</span>
    }

    /**
     * Informs the &lt;code&gt;TreeState&lt;/code&gt; that it needs to recalculate
     * all the sizes it is referencing.
     */
    public void invalidateSizes() {
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if(root != null)</span>
<span class="nc" id="L370">            root.deepMarkSizeInvalid();</span>
<span class="nc bnc" id="L371" title="All 4 branches missed.">        if(!isFixedRowHeight() &amp;&amp; visibleNodes.size() &gt; 0) {</span>
<span class="nc" id="L372">            updateNodeSizes(true);</span>
        }
<span class="nc" id="L374">    }</span>

    /**
      * Returns true if the value identified by &lt;code&gt;path&lt;/code&gt; is
      * currently expanded.
      * @return true if the value identified by &lt;code&gt;path&lt;/code&gt; is
      *    currently expanded
      */
    public boolean isExpanded(TreePath path) {
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if(path != null) {</span>
<span class="nc" id="L384">            TreeStateNode     lastNode = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L386" title="All 4 branches missed.">            return (lastNode != null &amp;&amp; lastNode.isExpanded());</span>
        }
<span class="nc" id="L388">        return false;</span>
    }

    //
    // TreeModelListener methods
    //

    /**
     * Invoked after a node (or a set of siblings) has changed in some
     * way. The node(s) have not changed locations in the tree or
     * altered their children arrays, but other attributes have
     * changed and may affect presentation. Example: the name of a
     * file has changed, but it is in the same location in the file
     * system.
     *
     * &lt;p&gt;&lt;code&gt;e.path&lt;/code&gt; returns the path the parent of the
     * changed node(s).
     *
     * &lt;p&gt;&lt;code&gt;e.childIndices&lt;/code&gt; returns the index(es) of the
     * changed node(s).
     *
     * @param e the &lt;code&gt;TreeModelEvent&lt;/code&gt; of interest
     */
    public void treeNodesChanged(TreeModelEvent e) {
<span class="nc bnc" id="L412" title="All 2 branches missed.">        if(e != null) {</span>
            int               changedIndexs[];
            TreeStateNode     changedNode;

<span class="nc" id="L416">            changedIndexs = e.getChildIndices();</span>
<span class="nc" id="L417">            changedNode = getNodeForPath(SwingUtilities2.getTreePath(e, getModel()), false, false);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">            if(changedNode != null) {</span>
<span class="nc" id="L419">                Object            changedValue = changedNode.getValue();</span>

                /* Update the size of the changed node, as well as all the
                   child indexs that are passed in. */
<span class="nc" id="L423">                changedNode.updatePreferredSize();</span>
<span class="nc bnc" id="L424" title="All 4 branches missed.">                if(changedNode.hasBeenExpanded() &amp;&amp; changedIndexs != null) {</span>
                    int                counter;
                    TreeStateNode      changedChildNode;

<span class="nc bnc" id="L428" title="All 2 branches missed.">                    for(counter = 0; counter &lt; changedIndexs.length;</span>
<span class="nc" id="L429">                        counter++) {</span>
<span class="nc" id="L430">                        changedChildNode = (TreeStateNode)changedNode</span>
<span class="nc" id="L431">                                    .getChildAt(changedIndexs[counter]);</span>
                        /* Reset the user object. */
<span class="nc" id="L433">                        changedChildNode.setUserObject</span>
<span class="nc" id="L434">                                    (treeModel.getChild(changedValue,</span>
                                                     changedIndexs[counter]));
<span class="nc" id="L436">                        changedChildNode.updatePreferredSize();</span>
                    }
<span class="nc" id="L438">                }</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">                else if (changedNode == root) {</span>
                    // Null indicies for root indicates it changed.
<span class="nc" id="L441">                    changedNode.updatePreferredSize();</span>
                }
<span class="nc bnc" id="L443" title="All 2 branches missed.">                if(!isFixedRowHeight()) {</span>
<span class="nc" id="L444">                    int          aRow = changedNode.getRow();</span>

<span class="nc bnc" id="L446" title="All 2 branches missed.">                    if(aRow != -1)</span>
<span class="nc" id="L447">                        this.updateYLocationsFrom(aRow);</span>
                }
<span class="nc" id="L449">                this.visibleNodesChanged();</span>
            }
        }
<span class="nc" id="L452">    }</span>


    /**
     * Invoked after nodes have been inserted into the tree.
     *
     * &lt;p&gt;&lt;code&gt;e.path&lt;/code&gt; returns the parent of the new nodes.
     * &lt;p&gt;&lt;code&gt;e.childIndices&lt;/code&gt; returns the indices of the new nodes in
     * ascending order.
     *
     * @param e the &lt;code&gt;TreeModelEvent&lt;/code&gt; of interest
     */
    public void treeNodesInserted(TreeModelEvent e) {
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if(e != null) {</span>
            int               changedIndexs[];
            TreeStateNode     changedParentNode;

<span class="nc" id="L469">            changedIndexs = e.getChildIndices();</span>
<span class="nc" id="L470">            changedParentNode = getNodeForPath(SwingUtilities2.getTreePath(e, getModel()), false, false);</span>
            /* Only need to update the children if the node has been
               expanded once. */
            // PENDING(scott): make sure childIndexs is sorted!
<span class="nc bnc" id="L474" title="All 6 branches missed.">            if(changedParentNode != null &amp;&amp; changedIndexs != null &amp;&amp;</span>
               changedIndexs.length &gt; 0) {
<span class="nc bnc" id="L476" title="All 2 branches missed.">                if(changedParentNode.hasBeenExpanded()) {</span>
                    boolean            makeVisible;
                    int                counter;
                    Object             changedParent;
                    TreeStateNode      newNode;
<span class="nc" id="L481">                    int                oldChildCount = changedParentNode.</span>
<span class="nc" id="L482">                                          getChildCount();</span>

<span class="nc" id="L484">                    changedParent = changedParentNode.getValue();</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">                    makeVisible = ((changedParentNode == root &amp;&amp;</span>
                                    !rootVisible) ||
<span class="nc bnc" id="L487" title="All 2 branches missed.">                                   (changedParentNode.getRow() != -1 &amp;&amp;</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">                                    changedParentNode.isExpanded()));</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                    for(counter = 0;counter &lt; changedIndexs.length;counter++)</span>
                    {
<span class="nc" id="L491">                        newNode = this.createNodeAt(changedParentNode,</span>
                                                    changedIndexs[counter]);
                    }
<span class="nc bnc" id="L494" title="All 2 branches missed.">                    if(oldChildCount == 0) {</span>
                        // Update the size of the parent.
<span class="nc" id="L496">                        changedParentNode.updatePreferredSize();</span>
                    }
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    if(treeSelectionModel != null)</span>
<span class="nc" id="L499">                        treeSelectionModel.resetRowSelection();</span>
                    /* Update the y origins from the index of the parent
                       to the end of the visible rows. */
<span class="nc bnc" id="L502" title="All 6 branches missed.">                    if(!isFixedRowHeight() &amp;&amp; (makeVisible ||</span>
                                               (oldChildCount == 0 &amp;&amp;
<span class="nc bnc" id="L504" title="All 2 branches missed.">                                        changedParentNode.isVisible()))) {</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                        if(changedParentNode == root)</span>
<span class="nc" id="L506">                            this.updateYLocationsFrom(0);</span>
                        else
<span class="nc" id="L508">                            this.updateYLocationsFrom(changedParentNode.</span>
<span class="nc" id="L509">                                                      getRow());</span>
<span class="nc" id="L510">                        this.visibleNodesChanged();</span>
                    }
<span class="nc bnc" id="L512" title="All 2 branches missed.">                    else if(makeVisible)</span>
<span class="nc" id="L513">                        this.visibleNodesChanged();</span>
<span class="nc" id="L514">                }</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                else if(treeModel.getChildCount(changedParentNode.getValue())</span>
                        - changedIndexs.length == 0) {
<span class="nc" id="L517">                    changedParentNode.updatePreferredSize();</span>
<span class="nc bnc" id="L518" title="All 4 branches missed.">                    if(!isFixedRowHeight() &amp;&amp; changedParentNode.isVisible())</span>
<span class="nc" id="L519">                        updateYLocationsFrom(changedParentNode.getRow());</span>
                }
            }
        }
<span class="nc" id="L523">    }</span>

    /**
     * Invoked after nodes have been removed from the tree.  Note that
     * if a subtree is removed from the tree, this method may only be
     * invoked once for the root of the removed subtree, not once for
     * each individual set of siblings removed.
     *
     * &lt;p&gt;&lt;code&gt;e.path&lt;/code&gt; returns the former parent of the deleted nodes.
     *
     * &lt;p&gt;&lt;code&gt;e.childIndices&lt;/code&gt; returns the indices the nodes had
     * before they were deleted in ascending order.
     *
     * @param e the &lt;code&gt;TreeModelEvent&lt;/code&gt; of interest
     */
    public void treeNodesRemoved(TreeModelEvent e) {
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if(e != null) {</span>
            int               changedIndexs[];
            TreeStateNode     changedParentNode;

<span class="nc" id="L543">            changedIndexs = e.getChildIndices();</span>
<span class="nc" id="L544">            changedParentNode = getNodeForPath(SwingUtilities2.getTreePath(e, getModel()), false, false);</span>
            // PENDING(scott): make sure that changedIndexs are sorted in
            // ascending order.
<span class="nc bnc" id="L547" title="All 6 branches missed.">            if(changedParentNode != null &amp;&amp; changedIndexs != null &amp;&amp;</span>
               changedIndexs.length &gt; 0) {
<span class="nc bnc" id="L549" title="All 2 branches missed.">                if(changedParentNode.hasBeenExpanded()) {</span>
                    boolean            makeInvisible;
                    int                counter;
                    int                removedRow;
                    TreeStateNode      removedNode;

<span class="nc bnc" id="L555" title="All 4 branches missed.">                    makeInvisible = ((changedParentNode == root &amp;&amp;</span>
                                      !rootVisible) ||
<span class="nc bnc" id="L557" title="All 2 branches missed.">                                     (changedParentNode.getRow() != -1 &amp;&amp;</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">                                      changedParentNode.isExpanded()));</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                    for(counter = changedIndexs.length - 1;counter &gt;= 0;</span>
<span class="nc" id="L560">                        counter--) {</span>
<span class="nc" id="L561">                        removedNode = (TreeStateNode)changedParentNode.</span>
<span class="nc" id="L562">                                getChildAt(changedIndexs[counter]);</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                        if(removedNode.isExpanded()) {</span>
<span class="nc" id="L564">                            removedNode.collapse(false);</span>
                        }

                        /* Let the selection model now. */
<span class="nc bnc" id="L568" title="All 2 branches missed.">                        if(makeInvisible) {</span>
<span class="nc" id="L569">                            removedRow = removedNode.getRow();</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                            if(removedRow != -1) {</span>
<span class="nc" id="L571">                                visibleNodes.removeElementAt(removedRow);</span>
                            }
                        }
<span class="nc" id="L574">                        changedParentNode.remove(changedIndexs[counter]);</span>
                    }
<span class="nc bnc" id="L576" title="All 2 branches missed.">                    if(changedParentNode.getChildCount() == 0) {</span>
                        // Update the size of the parent.
<span class="nc" id="L578">                        changedParentNode.updatePreferredSize();</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">                        if (changedParentNode.isExpanded() &amp;&amp;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">                                   changedParentNode.isLeaf()) {</span>
                            // Node has become a leaf, collapse it.
<span class="nc" id="L582">                            changedParentNode.collapse(false);</span>
                        }
                    }
<span class="nc bnc" id="L585" title="All 2 branches missed.">                    if(treeSelectionModel != null)</span>
<span class="nc" id="L586">                        treeSelectionModel.resetRowSelection();</span>
                    /* Update the y origins from the index of the parent
                       to the end of the visible rows. */
<span class="nc bnc" id="L589" title="All 4 branches missed.">                    if(!isFixedRowHeight() &amp;&amp; (makeInvisible ||</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">                               (changedParentNode.getChildCount() == 0 &amp;&amp;</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">                                changedParentNode.isVisible()))) {</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">                        if(changedParentNode == root) {</span>
                            /* It is possible for first row to have been
                               removed if the root isn't visible, in which
                               case ylocations will be off! */
<span class="nc bnc" id="L596" title="All 2 branches missed.">                            if(getRowCount() &gt; 0)</span>
<span class="nc" id="L597">                                getNode(0).setYOrigin(0);</span>
<span class="nc" id="L598">                            updateYLocationsFrom(0);</span>
                        }
                        else
<span class="nc" id="L601">                            updateYLocationsFrom(changedParentNode.getRow());</span>
<span class="nc" id="L602">                        this.visibleNodesChanged();</span>
                    }
<span class="nc bnc" id="L604" title="All 2 branches missed.">                    else if(makeInvisible)</span>
<span class="nc" id="L605">                        this.visibleNodesChanged();</span>
<span class="nc" id="L606">                }</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">                else if(treeModel.getChildCount(changedParentNode.getValue())</span>
                        == 0) {
<span class="nc" id="L609">                    changedParentNode.updatePreferredSize();</span>
<span class="nc bnc" id="L610" title="All 4 branches missed.">                    if(!isFixedRowHeight() &amp;&amp; changedParentNode.isVisible())</span>
<span class="nc" id="L611">                        this.updateYLocationsFrom(changedParentNode.getRow());</span>
                }
            }
        }
<span class="nc" id="L615">    }</span>

    /**
     * Invoked after the tree has drastically changed structure from a
     * given node down.  If the path returned by &lt;code&gt;e.getPath&lt;/code&gt;
     * is of length one and the first element does not identify the
     * current root node the first element should become the new root
     * of the tree.
     *
     * &lt;p&gt;&lt;code&gt;e.path&lt;/code&gt; holds the path to the node.
     * &lt;p&gt;&lt;code&gt;e.childIndices&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @param e the &lt;code&gt;TreeModelEvent&lt;/code&gt; of interest
     */
    public void treeStructureChanged(TreeModelEvent e) {
<span class="nc bnc" id="L630" title="All 2 branches missed.">        if(e != null)</span>
        {
<span class="nc" id="L632">            TreePath          changedPath = SwingUtilities2.getTreePath(e, getModel());</span>
            TreeStateNode     changedNode;

<span class="nc" id="L635">            changedNode = getNodeForPath(changedPath, false, false);</span>

            // Check if root has changed, either to a null root, or
            // to an entirely new root.
<span class="nc bnc" id="L639" title="All 8 branches missed.">            if(changedNode == root ||</span>
               (changedNode == null &amp;&amp;
                ((changedPath == null &amp;&amp; treeModel != null &amp;&amp;
<span class="nc bnc" id="L642" title="All 4 branches missed.">                  treeModel.getRoot() == null) ||</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                 (changedPath != null &amp;&amp; changedPath.getPathCount() == 1)))) {</span>
<span class="nc" id="L644">                rebuild(true);</span>
            }
<span class="nc bnc" id="L646" title="All 2 branches missed.">            else if(changedNode != null) {</span>
                int                              nodeIndex, oldRow;
                TreeStateNode                    newNode, parent;
                boolean                          wasExpanded, wasVisible;
                int                              newIndex;

<span class="nc" id="L652">                wasExpanded = changedNode.isExpanded();</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                wasVisible = (changedNode.getRow() != -1);</span>
                /* Remove the current node and recreate a new one. */
<span class="nc" id="L655">                parent = (TreeStateNode)changedNode.getParent();</span>
<span class="nc" id="L656">                nodeIndex = parent.getIndex(changedNode);</span>
<span class="nc bnc" id="L657" title="All 4 branches missed.">                if(wasVisible &amp;&amp; wasExpanded) {</span>
<span class="nc" id="L658">                    changedNode.collapse(false);</span>
                }
<span class="nc bnc" id="L660" title="All 2 branches missed.">                if(wasVisible)</span>
<span class="nc" id="L661">                    visibleNodes.removeElement(changedNode);</span>
<span class="nc" id="L662">                changedNode.removeFromParent();</span>
<span class="nc" id="L663">                createNodeAt(parent, nodeIndex);</span>
<span class="nc" id="L664">                newNode = (TreeStateNode)parent.getChildAt(nodeIndex);</span>
<span class="nc bnc" id="L665" title="All 4 branches missed.">                if(wasVisible &amp;&amp; wasExpanded)</span>
<span class="nc" id="L666">                    newNode.expand(false);</span>
<span class="nc" id="L667">                newIndex = newNode.getRow();</span>
<span class="nc bnc" id="L668" title="All 4 branches missed.">                if(!isFixedRowHeight() &amp;&amp; wasVisible) {</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">                    if(newIndex == 0)</span>
<span class="nc" id="L670">                        updateYLocationsFrom(newIndex);</span>
                    else
<span class="nc" id="L672">                        updateYLocationsFrom(newIndex - 1);</span>
<span class="nc" id="L673">                    this.visibleNodesChanged();</span>
                }
<span class="nc bnc" id="L675" title="All 2 branches missed.">                else if(wasVisible)</span>
<span class="nc" id="L676">                    this.visibleNodesChanged();</span>
            }
        }
<span class="nc" id="L679">    }</span>


    //
    // Local methods
    //

    private void visibleNodesChanged() {
<span class="nc" id="L687">    }</span>

    /**
     * Adds a mapping for node.
     */
    private void addMapping(TreeStateNode node) {
<span class="nc" id="L693">        treePathMapping.put(node.getTreePath(), node);</span>
<span class="nc" id="L694">    }</span>

    /**
     * Removes the mapping for a previously added node.
     */
    private void removeMapping(TreeStateNode node) {
<span class="nc" id="L700">        treePathMapping.remove(node.getTreePath());</span>
<span class="nc" id="L701">    }</span>

    /**
     * Returns the node previously added for &lt;code&gt;path&lt;/code&gt;. This may
     * return null, if you to create a node use getNodeForPath.
     */
    private TreeStateNode getMapping(TreePath path) {
<span class="nc" id="L708">        return treePathMapping.get(path);</span>
    }

    /**
     * Retursn the bounds for row, &lt;code&gt;row&lt;/code&gt; by reference in
     * &lt;code&gt;placeIn&lt;/code&gt;. If &lt;code&gt;placeIn&lt;/code&gt; is null a new
     * Rectangle will be created and returned.
     */
    private Rectangle getBounds(int row, Rectangle placeIn) {
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if(updateNodeSizes)</span>
<span class="nc" id="L718">            updateNodeSizes(false);</span>

<span class="nc bnc" id="L720" title="All 4 branches missed.">        if(row &gt;= 0 &amp;&amp; row &lt; getRowCount()) {</span>
<span class="nc" id="L721">            return getNode(row).getNodeBounds(placeIn);</span>
        }
<span class="nc" id="L723">        return null;</span>
    }

    /**
     * Completely rebuild the tree, all expanded state, and node caches are
     * removed. All nodes are collapsed, except the root.
     */
    private void rebuild(boolean clearSelection) {
        Object rootObject;

<span class="nc" id="L733">        treePathMapping.clear();</span>
<span class="nc bnc" id="L734" title="All 4 branches missed.">        if(treeModel != null &amp;&amp; (rootObject = treeModel.getRoot()) != null) {</span>
<span class="nc" id="L735">            root = createNodeForValue(rootObject);</span>
<span class="nc" id="L736">            root.path = new TreePath(rootObject);</span>
<span class="nc" id="L737">            addMapping(root);</span>
<span class="nc" id="L738">            root.updatePreferredSize(0);</span>
<span class="nc" id="L739">            visibleNodes.removeAllElements();</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">            if (isRootVisible())</span>
<span class="nc" id="L741">                visibleNodes.addElement(root);</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if(!root.isExpanded())</span>
<span class="nc" id="L743">                root.expand();</span>
            else {
<span class="nc" id="L745">                Enumeration cursor = root.children();</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">                while(cursor.hasMoreElements()) {</span>
<span class="nc" id="L747">                    visibleNodes.addElement(cursor.nextElement());</span>
                }
<span class="nc bnc" id="L749" title="All 2 branches missed.">                if(!isFixedRowHeight())</span>
<span class="nc" id="L750">                    updateYLocationsFrom(0);</span>
<span class="nc" id="L751">            }</span>
        }
        else {
<span class="nc" id="L754">            visibleNodes.removeAllElements();</span>
<span class="nc" id="L755">            root = null;</span>
        }
<span class="nc bnc" id="L757" title="All 4 branches missed.">        if(clearSelection &amp;&amp; treeSelectionModel != null) {</span>
<span class="nc" id="L758">            treeSelectionModel.clearSelection();</span>
        }
<span class="nc" id="L760">        this.visibleNodesChanged();</span>
<span class="nc" id="L761">    }</span>

    /**
      * Creates a new node to represent the node at &lt;I&gt;childIndex&lt;/I&gt; in
      * &lt;I&gt;parent&lt;/I&gt;s children.  This should be called if the node doesn't
      * already exist and &lt;I&gt;parent&lt;/I&gt; has been expanded at least once.
      * The newly created node will be made visible if &lt;I&gt;parent&lt;/I&gt; is
      * currently expanded.  This does not update the position of any
      * cells, nor update the selection if it needs to be.  If succesful
      * in creating the new TreeStateNode, it is returned, otherwise
      * null is returned.
      */
    private TreeStateNode createNodeAt(TreeStateNode parent,
                                         int childIndex) {
        boolean                isParentRoot;
        Object                 newValue;
        TreeStateNode          newChildNode;

<span class="nc" id="L779">        newValue = treeModel.getChild(parent.getValue(), childIndex);</span>
<span class="nc" id="L780">        newChildNode = createNodeForValue(newValue);</span>
<span class="nc" id="L781">        parent.insert(newChildNode, childIndex);</span>
<span class="nc" id="L782">        newChildNode.updatePreferredSize(-1);</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">        isParentRoot = (parent == root);</span>
<span class="nc bnc" id="L784" title="All 4 branches missed.">        if(newChildNode != null &amp;&amp; parent.isExpanded() &amp;&amp;</span>
<span class="nc bnc" id="L785" title="All 4 branches missed.">           (parent.getRow() != -1 || isParentRoot)) {</span>
            int                 newRow;

            /* Find the new row to insert this newly visible node at. */
<span class="nc bnc" id="L789" title="All 2 branches missed.">            if(childIndex == 0) {</span>
<span class="nc bnc" id="L790" title="All 4 branches missed.">                if(isParentRoot &amp;&amp; !isRootVisible())</span>
<span class="nc" id="L791">                    newRow = 0;</span>
                else
<span class="nc" id="L793">                    newRow = parent.getRow() + 1;</span>
            }
<span class="nc bnc" id="L795" title="All 2 branches missed.">            else if(childIndex == parent.getChildCount())</span>
<span class="nc" id="L796">                newRow = parent.getLastVisibleNode().getRow() + 1;</span>
            else {
                TreeStateNode          previousNode;

<span class="nc" id="L800">                previousNode = (TreeStateNode)parent.</span>
<span class="nc" id="L801">                    getChildAt(childIndex - 1);</span>
<span class="nc" id="L802">                newRow = previousNode.getLastVisibleNode().getRow() + 1;</span>
            }
<span class="nc" id="L804">            visibleNodes.insertElementAt(newChildNode, newRow);</span>
        }
<span class="nc" id="L806">        return newChildNode;</span>
    }

    /**
      * Returns the TreeStateNode identified by path.  This mirrors
      * the behavior of getNodeForPath, but tries to take advantage of
      * path if it is an instance of AbstractTreePath.
      */
    private TreeStateNode getNodeForPath(TreePath path,
                                           boolean onlyIfVisible,
                                           boolean shouldCreate) {
<span class="nc bnc" id="L817" title="All 2 branches missed.">        if(path != null) {</span>
            TreeStateNode      node;

<span class="nc" id="L820">            node = getMapping(path);</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if(node != null) {</span>
<span class="nc bnc" id="L822" title="All 4 branches missed.">                if(onlyIfVisible &amp;&amp; !node.isVisible())</span>
<span class="nc" id="L823">                    return null;</span>
<span class="nc" id="L824">                return node;</span>
            }

            // Check all the parent paths, until a match is found.
            Stack&lt;TreePath&gt; paths;

<span class="nc bnc" id="L830" title="All 2 branches missed.">            if(tempStacks.size() == 0) {</span>
<span class="nc" id="L831">                paths = new Stack&lt;TreePath&gt;();</span>
            }
            else {
<span class="nc" id="L834">                paths = tempStacks.pop();</span>
            }

            try {
<span class="nc" id="L838">                paths.push(path);</span>
<span class="nc" id="L839">                path = path.getParentPath();</span>
<span class="nc" id="L840">                node = null;</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">                while(path != null) {</span>
<span class="nc" id="L842">                    node = getMapping(path);</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">                    if(node != null) {</span>
                        // Found a match, create entries for all paths in
                        // paths.
<span class="nc bnc" id="L846" title="All 4 branches missed.">                        while(node != null &amp;&amp; paths.size() &gt; 0) {</span>
<span class="nc" id="L847">                            path = paths.pop();</span>
<span class="nc" id="L848">                            node.getLoadedChildren(shouldCreate);</span>

<span class="nc" id="L850">                            int            childIndex = treeModel.</span>
<span class="nc" id="L851">                                      getIndexOfChild(node.getUserObject(),</span>
<span class="nc" id="L852">                                                  path.getLastPathComponent());</span>

<span class="nc bnc" id="L854" title="All 2 branches missed.">                            if(childIndex == -1 ||</span>
<span class="nc bnc" id="L855" title="All 4 branches missed.">                               childIndex &gt;= node.getChildCount() ||</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                               (onlyIfVisible &amp;&amp; !node.isVisible())) {</span>
<span class="nc" id="L857">                                node = null;</span>
                            }
                            else
<span class="nc" id="L860">                                node = (TreeStateNode)node.getChildAt</span>
<span class="nc" id="L861">                                               (childIndex);</span>
<span class="nc" id="L862">                        }</span>
<span class="nc" id="L863">                        return node;</span>
                    }
<span class="nc" id="L865">                    paths.push(path);</span>
<span class="nc" id="L866">                    path = path.getParentPath();</span>
                }
            }
            finally {
<span class="nc" id="L870">                paths.removeAllElements();</span>
<span class="nc" id="L871">                tempStacks.push(paths);</span>
<span class="nc" id="L872">            }</span>
            // If we get here it means they share a different root!
            // We could throw an exception...
        }
<span class="nc" id="L876">        return null;</span>
    }

    /**
      * Updates the y locations of all of the visible nodes after
      * location.
      */
    private void updateYLocationsFrom(int location) {
<span class="nc bnc" id="L884" title="All 4 branches missed.">        if(location &gt;= 0 &amp;&amp; location &lt; getRowCount()) {</span>
            int                    counter, maxCounter, newYOrigin;
            TreeStateNode          aNode;

<span class="nc" id="L888">            aNode = getNode(location);</span>
<span class="nc" id="L889">            newYOrigin = aNode.getYOrigin() + aNode.getPreferredHeight();</span>
<span class="nc" id="L890">            for(counter = location + 1, maxCounter = visibleNodes.size();</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">                counter &lt; maxCounter;counter++) {</span>
<span class="nc" id="L892">                aNode = (TreeStateNode)visibleNodes.</span>
<span class="nc" id="L893">                    elementAt(counter);</span>
<span class="nc" id="L894">                aNode.setYOrigin(newYOrigin);</span>
<span class="nc" id="L895">                newYOrigin += aNode.getPreferredHeight();</span>
            }
        }
<span class="nc" id="L898">    }</span>

    /**
      * Resets the y origin of all the visible nodes as well as messaging
      * all the visible nodes to updatePreferredSize().  You should not
      * normally have to call this.  Expanding and contracting the nodes
      * automaticly adjusts the locations.
      * updateAll determines if updatePreferredSize() is call on all nodes
      * or just those that don't have a valid size.
      */
    private void updateNodeSizes(boolean updateAll) {
        int                      aY, counter, maxCounter;
        TreeStateNode            node;

<span class="nc" id="L912">        updateNodeSizes = false;</span>
<span class="nc" id="L913">        for(aY = counter = 0, maxCounter = visibleNodes.size();</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">            counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L915">            node = (TreeStateNode)visibleNodes.elementAt(counter);</span>
<span class="nc" id="L916">            node.setYOrigin(aY);</span>
<span class="nc bnc" id="L917" title="All 4 branches missed.">            if(updateAll || !node.hasValidSize())</span>
<span class="nc" id="L918">                node.updatePreferredSize(counter);</span>
<span class="nc" id="L919">            aY += node.getPreferredHeight();</span>
        }
<span class="nc" id="L921">    }</span>

    /**
      * Returns the index of the row containing location.  If there
      * are no rows, -1 is returned.  If location is beyond the last
      * row index, the last row index is returned.
      */
    private int getRowContainingYLocation(int location) {
<span class="nc bnc" id="L929" title="All 2 branches missed.">        if(isFixedRowHeight()) {</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">            if(getRowCount() == 0)</span>
<span class="nc" id="L931">                return -1;</span>
<span class="nc" id="L932">            return Math.max(0, Math.min(getRowCount() - 1,</span>
<span class="nc" id="L933">                                        location / getRowHeight()));</span>
        }

        int                    max, maxY, mid, min, minY;
        TreeStateNode          node;

<span class="nc bnc" id="L939" title="All 2 branches missed.">        if((max = getRowCount()) &lt;= 0)</span>
<span class="nc" id="L940">            return -1;</span>
<span class="nc" id="L941">        mid = min = 0;</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">        while(min &lt; max) {</span>
<span class="nc" id="L943">            mid = (max - min) / 2 + min;</span>
<span class="nc" id="L944">            node = (TreeStateNode)visibleNodes.elementAt(mid);</span>
<span class="nc" id="L945">            minY = node.getYOrigin();</span>
<span class="nc" id="L946">            maxY = minY + node.getPreferredHeight();</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">            if(location &lt; minY) {</span>
<span class="nc" id="L948">                max = mid - 1;</span>
            }
<span class="nc bnc" id="L950" title="All 2 branches missed.">            else if(location &gt;= maxY) {</span>
<span class="nc" id="L951">                min = mid + 1;</span>
            }
            else
                break;
        }
<span class="nc bnc" id="L956" title="All 2 branches missed.">        if(min == max) {</span>
<span class="nc" id="L957">            mid = min;</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">            if(mid &gt;= getRowCount())</span>
<span class="nc" id="L959">                mid = getRowCount() - 1;</span>
        }
<span class="nc" id="L961">        return mid;</span>
    }

    /**
     * Ensures that all the path components in path are expanded, accept
     * for the last component which will only be expanded if expandLast
     * is true.
     * Returns true if succesful in finding the path.
     */
    private void ensurePathIsExpanded(TreePath aPath, boolean expandLast) {
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if(aPath != null) {</span>
            // Make sure the last entry isn't a leaf.
<span class="nc bnc" id="L973" title="All 2 branches missed.">            if(treeModel.isLeaf(aPath.getLastPathComponent())) {</span>
<span class="nc" id="L974">                aPath = aPath.getParentPath();</span>
<span class="nc" id="L975">                expandLast = true;</span>
            }
<span class="nc bnc" id="L977" title="All 2 branches missed.">            if(aPath != null) {</span>
<span class="nc" id="L978">                TreeStateNode     lastNode = getNodeForPath(aPath, false,</span>
                                                            true);

<span class="nc bnc" id="L981" title="All 2 branches missed.">                if(lastNode != null) {</span>
<span class="nc" id="L982">                    lastNode.makeVisible();</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">                    if(expandLast)</span>
<span class="nc" id="L984">                        lastNode.expand();</span>
                }
            }
        }
<span class="nc" id="L988">    }</span>

    /**
     * Returns the AbstractTreeUI.VisibleNode displayed at the given row
     */
    private TreeStateNode getNode(int row) {
<span class="nc" id="L994">        return (TreeStateNode)visibleNodes.elementAt(row);</span>
    }

    /**
      * Returns the maximum node width.
      */
    private int getMaxNodeWidth() {
<span class="nc" id="L1001">        int                     maxWidth = 0;</span>
        int                     nodeWidth;
        int                     counter;
        TreeStateNode           node;

<span class="nc bnc" id="L1006" title="All 2 branches missed.">        for(counter = getRowCount() - 1;counter &gt;= 0;counter--) {</span>
<span class="nc" id="L1007">            node = this.getNode(counter);</span>
<span class="nc" id="L1008">            nodeWidth = node.getPreferredWidth() + node.getXOrigin();</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            if(nodeWidth &gt; maxWidth)</span>
<span class="nc" id="L1010">                maxWidth = nodeWidth;</span>
        }
<span class="nc" id="L1012">        return maxWidth;</span>
    }

    /**
      * Responsible for creating a TreeStateNode that will be used
      * to track display information about value.
      */
    private TreeStateNode createNodeForValue(Object value) {
<span class="nc" id="L1020">        return new TreeStateNode(value);</span>
    }


    /**
     * TreeStateNode is used to keep track of each of
     * the nodes that have been expanded. This will also cache the preferred
     * size of the value it represents.
     */
    private class TreeStateNode extends DefaultMutableTreeNode {
        /** Preferred size needed to draw the user object. */
        protected int             preferredWidth;
        protected int             preferredHeight;

        /** X location that the user object will be drawn at. */
        protected int             xOrigin;

        /** Y location that the user object will be drawn at. */
        protected int             yOrigin;

        /** Is this node currently expanded? */
        protected boolean         expanded;

        /** Has this node been expanded at least once? */
        protected boolean         hasBeenExpanded;

        /** Path of this node. */
        protected TreePath        path;


<span class="nc" id="L1050">        public TreeStateNode(Object value) {</span>
<span class="nc" id="L1051">            super(value);</span>
<span class="nc" id="L1052">        }</span>

        //
        // Overriden DefaultMutableTreeNode methods
        //

        /**
         * Messaged when this node is added somewhere, resets the path
         * and adds a mapping from path to this node.
         */
        public void setParent(MutableTreeNode parent) {
<span class="nc" id="L1063">            super.setParent(parent);</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">            if(parent != null) {</span>
<span class="nc" id="L1065">                path = ((TreeStateNode)parent).getTreePath().</span>
<span class="nc" id="L1066">                                       pathByAddingChild(getUserObject());</span>
<span class="nc" id="L1067">                addMapping(this);</span>
            }
<span class="nc" id="L1069">        }</span>

        /**
         * Messaged when this node is removed from its parent, this messages
         * &lt;code&gt;removedFromMapping&lt;/code&gt; to remove all the children.
         */
        public void remove(int childIndex) {
<span class="nc" id="L1076">            TreeStateNode     node = (TreeStateNode)getChildAt(childIndex);</span>

<span class="nc" id="L1078">            node.removeFromMapping();</span>
<span class="nc" id="L1079">            super.remove(childIndex);</span>
<span class="nc" id="L1080">        }</span>

        /**
         * Messaged to set the user object. This resets the path.
         */
        public void setUserObject(Object o) {
<span class="nc" id="L1086">            super.setUserObject(o);</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">            if(path != null) {</span>
<span class="nc" id="L1088">                TreeStateNode      parent = (TreeStateNode)getParent();</span>

<span class="nc bnc" id="L1090" title="All 2 branches missed.">                if(parent != null)</span>
<span class="nc" id="L1091">                    resetChildrenPaths(parent.getTreePath());</span>
                else
<span class="nc" id="L1093">                    resetChildrenPaths(null);</span>
            }
<span class="nc" id="L1095">        }</span>

        /**
         * Returns the children of the receiver.
         * If the receiver is not currently expanded, this will return an
         * empty enumeration.
         */
        public Enumeration children() {
<span class="nc bnc" id="L1103" title="All 2 branches missed.">            if (!this.isExpanded()) {</span>
<span class="nc" id="L1104">                return DefaultMutableTreeNode.EMPTY_ENUMERATION;</span>
            } else {
<span class="nc" id="L1106">                return super.children();</span>
            }
        }

        /**
         * Returns true if the receiver is a leaf.
         */
        public boolean isLeaf() {
<span class="nc" id="L1114">            return getModel().isLeaf(this.getValue());</span>
        }

        //
        // VariableHeightLayoutCache
        //

        /**
         * Returns the location and size of this node.
         */
        public Rectangle getNodeBounds(Rectangle placeIn) {
<span class="nc bnc" id="L1125" title="All 2 branches missed.">            if(placeIn == null)</span>
<span class="nc" id="L1126">                placeIn = new Rectangle(getXOrigin(), getYOrigin(),</span>
<span class="nc" id="L1127">                                        getPreferredWidth(),</span>
<span class="nc" id="L1128">                                        getPreferredHeight());</span>
            else {
<span class="nc" id="L1130">                placeIn.x = getXOrigin();</span>
<span class="nc" id="L1131">                placeIn.y = getYOrigin();</span>
<span class="nc" id="L1132">                placeIn.width = getPreferredWidth();</span>
<span class="nc" id="L1133">                placeIn.height = getPreferredHeight();</span>
            }
<span class="nc" id="L1135">            return placeIn;</span>
        }

        /**
         * @return x location to draw node at.
         */
        public int getXOrigin() {
<span class="nc bnc" id="L1142" title="All 2 branches missed.">            if(!hasValidSize())</span>
<span class="nc" id="L1143">                updatePreferredSize(getRow());</span>
<span class="nc" id="L1144">            return xOrigin;</span>
        }

        /**
         * Returns the y origin the user object will be drawn at.
         */
        public int getYOrigin() {
<span class="nc bnc" id="L1151" title="All 2 branches missed.">            if(isFixedRowHeight()) {</span>
<span class="nc" id="L1152">                int      aRow = getRow();</span>

<span class="nc bnc" id="L1154" title="All 2 branches missed.">                if(aRow == -1)</span>
<span class="nc" id="L1155">                    return -1;</span>
<span class="nc" id="L1156">                return getRowHeight() * aRow;</span>
            }
<span class="nc" id="L1158">            return yOrigin;</span>
        }

        /**
         * Returns the preferred height of the receiver.
         */
        public int getPreferredHeight() {
<span class="nc bnc" id="L1165" title="All 2 branches missed.">            if(isFixedRowHeight())</span>
<span class="nc" id="L1166">                return getRowHeight();</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">            else if(!hasValidSize())</span>
<span class="nc" id="L1168">                updatePreferredSize(getRow());</span>
<span class="nc" id="L1169">            return preferredHeight;</span>
        }

        /**
         * Returns the preferred width of the receiver.
         */
        public int getPreferredWidth() {
<span class="nc bnc" id="L1176" title="All 2 branches missed.">            if(!hasValidSize())</span>
<span class="nc" id="L1177">                updatePreferredSize(getRow());</span>
<span class="nc" id="L1178">            return preferredWidth;</span>
        }

        /**
         * Returns true if this node has a valid size.
         */
        public boolean hasValidSize() {
<span class="nc bnc" id="L1185" title="All 2 branches missed.">            return (preferredHeight != 0);</span>
        }

        /**
         * Returns the row of the receiver.
         */
        public int getRow() {
<span class="nc" id="L1192">            return visibleNodes.indexOf(this);</span>
        }

        /**
         * Returns true if this node has been expanded at least once.
         */
        public boolean hasBeenExpanded() {
<span class="nc" id="L1199">            return hasBeenExpanded;</span>
        }

        /**
         * Returns true if the receiver has been expanded.
         */
        public boolean isExpanded() {
<span class="nc" id="L1206">            return expanded;</span>
        }

        /**
         * Returns the last visible node that is a child of this
         * instance.
         */
        public TreeStateNode getLastVisibleNode() {
<span class="nc" id="L1214">            TreeStateNode                node = this;</span>

<span class="nc bnc" id="L1216" title="All 4 branches missed.">            while(node.isExpanded() &amp;&amp; node.getChildCount() &gt; 0)</span>
<span class="nc" id="L1217">                node = (TreeStateNode)node.getLastChild();</span>
<span class="nc" id="L1218">            return node;</span>
        }

        /**
         * Returns true if the receiver is currently visible.
         */
        public boolean isVisible() {
<span class="nc bnc" id="L1225" title="All 2 branches missed.">            if(this == root)</span>
<span class="nc" id="L1226">                return true;</span>

<span class="nc" id="L1228">            TreeStateNode        parent = (TreeStateNode)getParent();</span>

<span class="nc bnc" id="L1230" title="All 4 branches missed.">            return (parent != null &amp;&amp; parent.isExpanded() &amp;&amp;</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">                    parent.isVisible());</span>
        }

        /**
         * Returns the number of children this will have. If the children
         * have not yet been loaded, this messages the model.
         */
        public int getModelChildCount() {
<span class="nc bnc" id="L1239" title="All 2 branches missed.">            if(hasBeenExpanded)</span>
<span class="nc" id="L1240">                return super.getChildCount();</span>
<span class="nc" id="L1241">            return getModel().getChildCount(getValue());</span>
        }

        /**
         * Returns the number of visible children, that is the number of
         * children that are expanded, or leafs.
         */
        public int getVisibleChildCount() {
<span class="nc" id="L1249">            int               childCount = 0;</span>

<span class="nc bnc" id="L1251" title="All 2 branches missed.">            if(isExpanded()) {</span>
<span class="nc" id="L1252">                int         maxCounter = getChildCount();</span>

<span class="nc" id="L1254">                childCount += maxCounter;</span>
<span class="nc bnc" id="L1255" title="All 2 branches missed.">                for(int counter = 0; counter &lt; maxCounter; counter++)</span>
<span class="nc" id="L1256">                    childCount += ((TreeStateNode)getChildAt(counter)).</span>
<span class="nc" id="L1257">                                    getVisibleChildCount();</span>
            }
<span class="nc" id="L1259">            return childCount;</span>
        }

        /**
         * Toggles the receiver between expanded and collapsed.
         */
        public void toggleExpanded() {
<span class="nc bnc" id="L1266" title="All 2 branches missed.">            if (isExpanded()) {</span>
<span class="nc" id="L1267">                collapse();</span>
            } else {
<span class="nc" id="L1269">                expand();</span>
            }
<span class="nc" id="L1271">        }</span>

        /**
         * Makes the receiver visible, but invoking
         * &lt;code&gt;expandParentAndReceiver&lt;/code&gt; on the superclass.
         */
        public void makeVisible() {
<span class="nc" id="L1278">            TreeStateNode       parent = (TreeStateNode)getParent();</span>

<span class="nc bnc" id="L1280" title="All 2 branches missed.">            if(parent != null)</span>
<span class="nc" id="L1281">                parent.expandParentAndReceiver();</span>
<span class="nc" id="L1282">        }</span>

        /**
         * Expands the receiver.
         */
        public void expand() {
<span class="nc" id="L1288">            expand(true);</span>
<span class="nc" id="L1289">        }</span>

        /**
         * Collapses the receiver.
         */
        public void collapse() {
<span class="nc" id="L1295">            collapse(true);</span>
<span class="nc" id="L1296">        }</span>

        /**
         * Returns the value the receiver is representing. This is a cover
         * for getUserObject.
         */
        public Object getValue() {
<span class="nc" id="L1303">            return getUserObject();</span>
        }

        /**
         * Returns a TreePath instance for this node.
         */
        public TreePath getTreePath() {
<span class="nc" id="L1310">            return path;</span>
        }

        //
        // Local methods
        //

        /**
         * Recreates the receivers path, and all its children's paths.
         */
        protected void resetChildrenPaths(TreePath parentPath) {
<span class="nc" id="L1321">            removeMapping(this);</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">            if(parentPath == null)</span>
<span class="nc" id="L1323">                path = new TreePath(getUserObject());</span>
            else
<span class="nc" id="L1325">                path = parentPath.pathByAddingChild(getUserObject());</span>
<span class="nc" id="L1326">            addMapping(this);</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">            for(int counter = getChildCount() - 1; counter &gt;= 0; counter--)</span>
<span class="nc" id="L1328">                ((TreeStateNode)getChildAt(counter)).resetChildrenPaths(path);</span>
<span class="nc" id="L1329">        }</span>

        /**
         * Sets y origin the user object will be drawn at to
         * &lt;I&gt;newYOrigin&lt;/I&gt;.
         */
        protected void setYOrigin(int newYOrigin) {
<span class="nc" id="L1336">            yOrigin = newYOrigin;</span>
<span class="nc" id="L1337">        }</span>

        /**
         * Shifts the y origin by &lt;code&gt;offset&lt;/code&gt;.
         */
        protected void shiftYOriginBy(int offset) {
<span class="nc" id="L1343">            yOrigin += offset;</span>
<span class="nc" id="L1344">        }</span>

        /**
         * Updates the receivers preferredSize by invoking
         * &lt;code&gt;updatePreferredSize&lt;/code&gt; with an argument of -1.
         */
        protected void updatePreferredSize() {
<span class="nc" id="L1351">            updatePreferredSize(getRow());</span>
<span class="nc" id="L1352">        }</span>

        /**
         * Updates the preferred size by asking the current renderer
         * for the Dimension needed to draw the user object this
         * instance represents.
         */
        protected void updatePreferredSize(int index) {
<span class="nc" id="L1360">            Rectangle       bounds = getNodeDimensions(this.getUserObject(),</span>
<span class="nc" id="L1361">                                                       index, getLevel(),</span>
<span class="nc" id="L1362">                                                       isExpanded(),</span>
<span class="nc" id="L1363">                                                       boundsBuffer);</span>

<span class="nc bnc" id="L1365" title="All 2 branches missed.">            if(bounds == null) {</span>
<span class="nc" id="L1366">                xOrigin = 0;</span>
<span class="nc" id="L1367">                preferredWidth = preferredHeight = 0;</span>
<span class="nc" id="L1368">                updateNodeSizes = true;</span>
            }
<span class="nc bnc" id="L1370" title="All 2 branches missed.">            else if(bounds.height == 0) {</span>
<span class="nc" id="L1371">                xOrigin = 0;</span>
<span class="nc" id="L1372">                preferredWidth = preferredHeight = 0;</span>
<span class="nc" id="L1373">                updateNodeSizes = true;</span>
            }
            else {
<span class="nc" id="L1376">                xOrigin = bounds.x;</span>
<span class="nc" id="L1377">                preferredWidth = bounds.width;</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">                if(isFixedRowHeight())</span>
<span class="nc" id="L1379">                    preferredHeight = getRowHeight();</span>
                else
<span class="nc" id="L1381">                    preferredHeight = bounds.height;</span>
            }
<span class="nc" id="L1383">        }</span>

        /**
         * Marks the receivers size as invalid. Next time the size, location
         * is asked for it will be obtained.
         */
        protected void markSizeInvalid() {
<span class="nc" id="L1390">            preferredHeight = 0;</span>
<span class="nc" id="L1391">        }</span>

        /**
         * Marks the receivers size, and all its descendants sizes, as invalid.
         */
        protected void deepMarkSizeInvalid() {
<span class="nc" id="L1397">            markSizeInvalid();</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">            for(int counter = getChildCount() - 1; counter &gt;= 0; counter--)</span>
<span class="nc" id="L1399">                ((TreeStateNode)getChildAt(counter)).deepMarkSizeInvalid();</span>
<span class="nc" id="L1400">        }</span>

        /**
         * Returns the children of the receiver. If the children haven't
         * been loaded from the model and
         * &lt;code&gt;createIfNeeded&lt;/code&gt; is true, the children are first
         * loaded.
         */
        protected Enumeration getLoadedChildren(boolean createIfNeeded) {
<span class="nc bnc" id="L1409" title="All 4 branches missed.">            if(!createIfNeeded || hasBeenExpanded)</span>
<span class="nc" id="L1410">                return super.children();</span>

            TreeStateNode   newNode;
<span class="nc" id="L1413">            Object          realNode = getValue();</span>
<span class="nc" id="L1414">            TreeModel       treeModel = getModel();</span>
<span class="nc" id="L1415">            int             count = treeModel.getChildCount(realNode);</span>

<span class="nc" id="L1417">            hasBeenExpanded = true;</span>

<span class="nc" id="L1419">            int    childRow = getRow();</span>

<span class="nc bnc" id="L1421" title="All 2 branches missed.">            if(childRow == -1) {</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">                for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1423">                    newNode = createNodeForValue</span>
<span class="nc" id="L1424">                        (treeModel.getChild(realNode, i));</span>
<span class="nc" id="L1425">                    this.add(newNode);</span>
<span class="nc" id="L1426">                    newNode.updatePreferredSize(-1);</span>
                }
            }
            else {
<span class="nc" id="L1430">                childRow++;</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">                for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1432">                    newNode = createNodeForValue</span>
<span class="nc" id="L1433">                        (treeModel.getChild(realNode, i));</span>
<span class="nc" id="L1434">                    this.add(newNode);</span>
<span class="nc" id="L1435">                    newNode.updatePreferredSize(childRow++);</span>
                }
            }
<span class="nc" id="L1438">            return super.children();</span>
        }

        /**
         * Messaged from expand and collapse. This is meant for subclassers
         * that may wish to do something interesting with this.
         */
        protected void didAdjustTree() {
<span class="nc" id="L1446">        }</span>

        /**
         * Invokes &lt;code&gt;expandParentAndReceiver&lt;/code&gt; on the parent,
         * and expands the receiver.
         */
        protected void expandParentAndReceiver() {
<span class="nc" id="L1453">            TreeStateNode       parent = (TreeStateNode)getParent();</span>

<span class="nc bnc" id="L1455" title="All 2 branches missed.">            if(parent != null)</span>
<span class="nc" id="L1456">                parent.expandParentAndReceiver();</span>
<span class="nc" id="L1457">            expand();</span>
<span class="nc" id="L1458">        }</span>

        /**
         * Expands this node in the tree.  This will load the children
         * from the treeModel if this node has not previously been
         * expanded.  If &lt;I&gt;adjustTree&lt;/I&gt; is true the tree and selection
         * are updated accordingly.
         */
        protected void expand(boolean adjustTree) {
<span class="nc bnc" id="L1467" title="All 4 branches missed.">            if (!isExpanded() &amp;&amp; !isLeaf()) {</span>
<span class="nc" id="L1468">                boolean         isFixed = isFixedRowHeight();</span>
<span class="nc" id="L1469">                int             startHeight = getPreferredHeight();</span>
<span class="nc" id="L1470">                int             originalRow = getRow();</span>

<span class="nc" id="L1472">                expanded = true;</span>
<span class="nc" id="L1473">                updatePreferredSize(originalRow);</span>

<span class="nc bnc" id="L1475" title="All 2 branches missed.">                if (!hasBeenExpanded) {</span>
                    TreeStateNode  newNode;
<span class="nc" id="L1477">                    Object         realNode = getValue();</span>
<span class="nc" id="L1478">                    TreeModel      treeModel = getModel();</span>
<span class="nc" id="L1479">                    int            count = treeModel.getChildCount(realNode);</span>

<span class="nc" id="L1481">                    hasBeenExpanded = true;</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">                    if(originalRow == -1) {</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">                        for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1484">                            newNode = createNodeForValue(treeModel.getChild</span>
<span class="nc" id="L1485">                                                            (realNode, i));</span>
<span class="nc" id="L1486">                            this.add(newNode);</span>
<span class="nc" id="L1487">                            newNode.updatePreferredSize(-1);</span>
                        }
                    }
                    else {
<span class="nc" id="L1491">                        int offset = originalRow + 1;</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">                        for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L1493">                            newNode = createNodeForValue(treeModel.getChild</span>
<span class="nc" id="L1494">                                                       (realNode, i));</span>
<span class="nc" id="L1495">                            this.add(newNode);</span>
<span class="nc" id="L1496">                            newNode.updatePreferredSize(offset);</span>
                        }
                    }
                }

<span class="nc" id="L1501">                int i = originalRow;</span>
<span class="nc" id="L1502">                Enumeration cursor = preorderEnumeration();</span>
<span class="nc" id="L1503">                cursor.nextElement(); // don't add me, I'm already in</span>

                int newYOrigin;

<span class="nc bnc" id="L1507" title="All 2 branches missed.">                if(isFixed)</span>
<span class="nc" id="L1508">                    newYOrigin = 0;</span>
<span class="nc bnc" id="L1509" title="All 4 branches missed.">                else if(this == root &amp;&amp; !isRootVisible())</span>
<span class="nc" id="L1510">                    newYOrigin = 0;</span>
                else
<span class="nc" id="L1512">                    newYOrigin = getYOrigin() + this.getPreferredHeight();</span>
                TreeStateNode   aNode;
<span class="nc bnc" id="L1514" title="All 2 branches missed.">                if(!isFixed) {</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">                    while (cursor.hasMoreElements()) {</span>
<span class="nc" id="L1516">                        aNode = (TreeStateNode)cursor.nextElement();</span>
<span class="nc bnc" id="L1517" title="All 4 branches missed.">                        if(!updateNodeSizes &amp;&amp; !aNode.hasValidSize())</span>
<span class="nc" id="L1518">                            aNode.updatePreferredSize(i + 1);</span>
<span class="nc" id="L1519">                        aNode.setYOrigin(newYOrigin);</span>
<span class="nc" id="L1520">                        newYOrigin += aNode.getPreferredHeight();</span>
<span class="nc" id="L1521">                        visibleNodes.insertElementAt(aNode, ++i);</span>
                    }
                }
                else {
<span class="nc bnc" id="L1525" title="All 2 branches missed.">                    while (cursor.hasMoreElements()) {</span>
<span class="nc" id="L1526">                        aNode = (TreeStateNode)cursor.nextElement();</span>
<span class="nc" id="L1527">                        visibleNodes.insertElementAt(aNode, ++i);</span>
                    }
                }

<span class="nc bnc" id="L1531" title="All 4 branches missed.">                if(adjustTree &amp;&amp; (originalRow != i ||</span>
<span class="nc bnc" id="L1532" title="All 2 branches missed.">                                  getPreferredHeight() != startHeight)) {</span>
                    // Adjust the Y origin of any nodes following this row.
<span class="nc bnc" id="L1534" title="All 4 branches missed.">                    if(!isFixed &amp;&amp; ++i &lt; getRowCount()) {</span>
                        int              counter;
<span class="nc" id="L1536">                        int              heightDiff = newYOrigin -</span>
<span class="nc" id="L1537">                            (getYOrigin() + getPreferredHeight()) +</span>
<span class="nc" id="L1538">                            (getPreferredHeight() - startHeight);</span>

<span class="nc bnc" id="L1540" title="All 2 branches missed.">                        for(counter = visibleNodes.size() - 1;counter &gt;= i;</span>
<span class="nc" id="L1541">                            counter--)</span>
<span class="nc" id="L1542">                            ((TreeStateNode)visibleNodes.elementAt(counter)).</span>
<span class="nc" id="L1543">                                shiftYOriginBy(heightDiff);</span>
                    }
<span class="nc" id="L1545">                    didAdjustTree();</span>
<span class="nc" id="L1546">                    visibleNodesChanged();</span>
                }

                // Update the rows in the selection
<span class="nc bnc" id="L1550" title="All 2 branches missed.">                if(treeSelectionModel != null) {</span>
<span class="nc" id="L1551">                    treeSelectionModel.resetRowSelection();</span>
                }
            }
<span class="nc" id="L1554">        }</span>

        /**
         * Collapses this node in the tree.  If &lt;I&gt;adjustTree&lt;/I&gt; is
         * true the tree and selection are updated accordingly.
         */
        protected void collapse(boolean adjustTree) {
<span class="nc bnc" id="L1561" title="All 2 branches missed.">            if (isExpanded()) {</span>
<span class="nc" id="L1562">                Enumeration cursor = preorderEnumeration();</span>
<span class="nc" id="L1563">                cursor.nextElement(); // don't remove me, I'm still visible</span>
<span class="nc" id="L1564">                int rowsDeleted = 0;</span>
<span class="nc" id="L1565">                boolean isFixed = isFixedRowHeight();</span>
                int lastYEnd;
<span class="nc bnc" id="L1567" title="All 2 branches missed.">                if(isFixed)</span>
<span class="nc" id="L1568">                    lastYEnd = 0;</span>
                else
<span class="nc" id="L1570">                    lastYEnd = getPreferredHeight() + getYOrigin();</span>
<span class="nc" id="L1571">                int startHeight = getPreferredHeight();</span>
<span class="nc" id="L1572">                int startYEnd = lastYEnd;</span>
<span class="nc" id="L1573">                int myRow = getRow();</span>

<span class="nc bnc" id="L1575" title="All 2 branches missed.">                if(!isFixed) {</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">                    while(cursor.hasMoreElements()) {</span>
<span class="nc" id="L1577">                        TreeStateNode node = (TreeStateNode)cursor.</span>
<span class="nc" id="L1578">                            nextElement();</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">                        if (node.isVisible()) {</span>
<span class="nc" id="L1580">                            rowsDeleted++;</span>
                            //visibleNodes.removeElement(node);
<span class="nc" id="L1582">                            lastYEnd = node.getYOrigin() +</span>
<span class="nc" id="L1583">                                node.getPreferredHeight();</span>
                        }
<span class="nc" id="L1585">                    }</span>
                }
                else {
<span class="nc bnc" id="L1588" title="All 2 branches missed.">                    while(cursor.hasMoreElements()) {</span>
<span class="nc" id="L1589">                        TreeStateNode node = (TreeStateNode)cursor.</span>
<span class="nc" id="L1590">                            nextElement();</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">                        if (node.isVisible()) {</span>
<span class="nc" id="L1592">                            rowsDeleted++;</span>
                            //visibleNodes.removeElement(node);
                        }
<span class="nc" id="L1595">                    }</span>
                }

                // Clean up the visible nodes.
<span class="nc bnc" id="L1599" title="All 2 branches missed.">                for (int counter = rowsDeleted + myRow; counter &gt; myRow;</span>
<span class="nc" id="L1600">                     counter--) {</span>
<span class="nc" id="L1601">                    visibleNodes.removeElementAt(counter);</span>
                }

<span class="nc" id="L1604">                expanded = false;</span>

<span class="nc bnc" id="L1606" title="All 2 branches missed.">                if(myRow == -1)</span>
<span class="nc" id="L1607">                    markSizeInvalid();</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">                else if (adjustTree)</span>
<span class="nc" id="L1609">                    updatePreferredSize(myRow);</span>

<span class="nc bnc" id="L1611" title="All 6 branches missed.">                if(myRow != -1 &amp;&amp; adjustTree &amp;&amp;</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">                   (rowsDeleted &gt; 0 || startHeight != getPreferredHeight())) {</span>
                    // Adjust the Y origin of any rows following this one.
<span class="nc" id="L1614">                    startYEnd += (getPreferredHeight() - startHeight);</span>
<span class="nc bnc" id="L1615" title="All 6 branches missed.">                    if(!isFixed &amp;&amp; (myRow + 1) &lt; getRowCount() &amp;&amp;</span>
                       startYEnd != lastYEnd) {
                        int                 counter, maxCounter, shiftAmount;

<span class="nc" id="L1619">                        shiftAmount = startYEnd - lastYEnd;</span>
<span class="nc" id="L1620">                        for(counter = myRow + 1, maxCounter =</span>
<span class="nc" id="L1621">                                visibleNodes.size();</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">                            counter &lt; maxCounter;counter++)</span>
<span class="nc" id="L1623">                            ((TreeStateNode)visibleNodes.elementAt(counter))</span>
<span class="nc" id="L1624">                                .shiftYOriginBy(shiftAmount);</span>
                    }
<span class="nc" id="L1626">                    didAdjustTree();</span>
<span class="nc" id="L1627">                    visibleNodesChanged();</span>
                }
<span class="nc bnc" id="L1629" title="All 6 branches missed.">                if(treeSelectionModel != null &amp;&amp; rowsDeleted &gt; 0 &amp;&amp;</span>
                   myRow != -1) {
<span class="nc" id="L1631">                    treeSelectionModel.resetRowSelection();</span>
                }
            }
<span class="nc" id="L1634">        }</span>

        /**
         * Removes the receiver, and all its children, from the mapping
         * table.
         */
        protected void removeFromMapping() {
<span class="nc bnc" id="L1641" title="All 2 branches missed.">            if(path != null) {</span>
<span class="nc" id="L1642">                removeMapping(this);</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">                for(int counter = getChildCount() - 1; counter &gt;= 0; counter--)</span>
<span class="nc" id="L1644">                    ((TreeStateNode)getChildAt(counter)).removeFromMapping();</span>
            }
<span class="nc" id="L1646">        }</span>
    } // End of VariableHeightLayoutCache.TreeStateNode


    /**
     * An enumerator to iterate through visible nodes.
     */
    private class VisibleTreeStateNodeEnumeration implements
                     Enumeration&lt;TreePath&gt; {
        /** Parent thats children are being enumerated. */
        protected TreeStateNode       parent;
        /** Index of next child. An index of -1 signifies parent should be
         * visibled next. */
        protected int                 nextIndex;
        /** Number of children in parent. */
        protected int                 childCount;

        protected VisibleTreeStateNodeEnumeration(TreeStateNode node) {
<span class="nc" id="L1664">            this(node, -1);</span>
<span class="nc" id="L1665">        }</span>

        protected VisibleTreeStateNodeEnumeration(TreeStateNode parent,
<span class="nc" id="L1668">                                                  int startIndex) {</span>
<span class="nc" id="L1669">            this.parent = parent;</span>
<span class="nc" id="L1670">            this.nextIndex = startIndex;</span>
<span class="nc" id="L1671">            this.childCount = this.parent.getChildCount();</span>
<span class="nc" id="L1672">        }</span>

        /**
         * @return true if more visible nodes.
         */
        public boolean hasMoreElements() {
<span class="nc bnc" id="L1678" title="All 2 branches missed.">            return (parent != null);</span>
        }

        /**
         * @return next visible TreePath.
         */
        public TreePath nextElement() {
<span class="nc bnc" id="L1685" title="All 2 branches missed.">            if(!hasMoreElements())</span>
<span class="nc" id="L1686">                throw new NoSuchElementException(&quot;No more visible paths&quot;);</span>

            TreePath                retObject;

<span class="nc bnc" id="L1690" title="All 2 branches missed.">            if(nextIndex == -1) {</span>
<span class="nc" id="L1691">                retObject = parent.getTreePath();</span>
            }
            else {
<span class="nc" id="L1694">                TreeStateNode   node = (TreeStateNode)parent.</span>
<span class="nc" id="L1695">                                        getChildAt(nextIndex);</span>

<span class="nc" id="L1697">                retObject = node.getTreePath();</span>
            }
<span class="nc" id="L1699">            updateNextObject();</span>
<span class="nc" id="L1700">            return retObject;</span>
        }

        /**
         * Determines the next object by invoking &lt;code&gt;updateNextIndex&lt;/code&gt;
         * and if not succesful &lt;code&gt;findNextValidParent&lt;/code&gt;.
         */
        protected void updateNextObject() {
<span class="nc bnc" id="L1708" title="All 2 branches missed.">            if(!updateNextIndex()) {</span>
<span class="nc" id="L1709">                findNextValidParent();</span>
            }
<span class="nc" id="L1711">        }</span>

        /**
         * Finds the next valid parent, this should be called when nextIndex
         * is beyond the number of children of the current parent.
         */
        protected boolean findNextValidParent() {
<span class="nc bnc" id="L1718" title="All 2 branches missed.">            if(parent == root) {</span>
                // mark as invalid!
<span class="nc" id="L1720">                parent = null;</span>
<span class="nc" id="L1721">                return false;</span>
            }
<span class="nc bnc" id="L1723" title="All 2 branches missed.">            while(parent != null) {</span>
<span class="nc" id="L1724">                TreeStateNode      newParent = (TreeStateNode)parent.</span>
<span class="nc" id="L1725">                                                  getParent();</span>

<span class="nc bnc" id="L1727" title="All 2 branches missed.">                if(newParent != null) {</span>
<span class="nc" id="L1728">                    nextIndex = newParent.getIndex(parent);</span>
<span class="nc" id="L1729">                    parent = newParent;</span>
<span class="nc" id="L1730">                    childCount = parent.getChildCount();</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                    if(updateNextIndex())</span>
<span class="nc" id="L1732">                        return true;</span>
                }
                else
<span class="nc" id="L1735">                    parent = null;</span>
<span class="nc" id="L1736">            }</span>
<span class="nc" id="L1737">            return false;</span>
        }

        /**
         * Updates &lt;code&gt;nextIndex&lt;/code&gt; returning false if it is beyond
         * the number of children of parent.
         */
        protected boolean updateNextIndex() {
            // nextIndex == -1 identifies receiver, make sure is expanded
            // before descend.
<span class="nc bnc" id="L1747" title="All 4 branches missed.">            if(nextIndex == -1 &amp;&amp; !parent.isExpanded())</span>
<span class="nc" id="L1748">                return false;</span>

            // Check that it can have kids
<span class="nc bnc" id="L1751" title="All 2 branches missed.">            if(childCount == 0)</span>
<span class="nc" id="L1752">                return false;</span>
            // Make sure next index not beyond child count.
<span class="nc bnc" id="L1754" title="All 2 branches missed.">            else if(++nextIndex &gt;= childCount)</span>
<span class="nc" id="L1755">                return false;</span>

<span class="nc" id="L1757">            TreeStateNode       child = (TreeStateNode)parent.</span>
<span class="nc" id="L1758">                                        getChildAt(nextIndex);</span>

<span class="nc bnc" id="L1760" title="All 4 branches missed.">            if(child != null &amp;&amp; child.isExpanded()) {</span>
<span class="nc" id="L1761">                parent = child;</span>
<span class="nc" id="L1762">                nextIndex = -1;</span>
<span class="nc" id="L1763">                childCount = child.getChildCount();</span>
            }
<span class="nc" id="L1765">            return true;</span>
        }
    } // VariableHeightLayoutCache.VisibleTreeStateNodeEnumeration
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>