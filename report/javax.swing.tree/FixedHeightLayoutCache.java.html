<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FixedHeightLayoutCache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.tree</a> &gt; <span class="el_source">FixedHeightLayoutCache.java</span></div><h1>FixedHeightLayoutCache.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.tree;

import javax.swing.event.TreeModelEvent;
import java.awt.Rectangle;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.NoSuchElementException;
import java.util.Stack;

import sun.swing.SwingUtilities2;

/**
 * NOTE: This will become more open in a future release.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author Scott Violet
 */

public class FixedHeightLayoutCache extends AbstractLayoutCache {
    /** Root node. */
    private FHTreeStateNode    root;

    /** Number of rows currently visible. */
    private int                rowCount;

    /**
     * Used in getting sizes for nodes to avoid creating a new Rectangle
     * every time a size is needed.
     */
    private Rectangle          boundsBuffer;

    /**
     * Maps from TreePath to a FHTreeStateNode.
     */
    private Hashtable&lt;TreePath, FHTreeStateNode&gt; treePathMapping;

    /**
     * Used for getting path/row information.
     */
    private SearchInfo         info;

    private Stack&lt;Stack&lt;TreePath&gt;&gt; tempStacks;


    public FixedHeightLayoutCache() {
<span class="nc" id="L79">        super();</span>
<span class="nc" id="L80">        tempStacks = new Stack&lt;Stack&lt;TreePath&gt;&gt;();</span>
<span class="nc" id="L81">        boundsBuffer = new Rectangle();</span>
<span class="nc" id="L82">        treePathMapping = new Hashtable&lt;TreePath, FHTreeStateNode&gt;();</span>
<span class="nc" id="L83">        info = new SearchInfo();</span>
<span class="nc" id="L84">        setRowHeight(1);</span>
<span class="nc" id="L85">    }</span>

    /**
     * Sets the TreeModel that will provide the data.
     *
     * @param newModel the TreeModel that is to provide the data
     */
    public void setModel(TreeModel newModel) {
<span class="nc" id="L93">        super.setModel(newModel);</span>
<span class="nc" id="L94">        rebuild(false);</span>
<span class="nc" id="L95">    }</span>

    /**
     * Determines whether or not the root node from
     * the TreeModel is visible.
     *
     * @param rootVisible true if the root node of the tree is to be displayed
     * @see #rootVisible
     */
    public void setRootVisible(boolean rootVisible) {
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if(isRootVisible() != rootVisible) {</span>
<span class="nc" id="L106">            super.setRootVisible(rootVisible);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if(root != null) {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">                if(rootVisible) {</span>
<span class="nc" id="L109">                    rowCount++;</span>
<span class="nc" id="L110">                    root.adjustRowBy(1);</span>
                }
                else {
<span class="nc" id="L113">                    rowCount--;</span>
<span class="nc" id="L114">                    root.adjustRowBy(-1);</span>
                }
<span class="nc" id="L116">                visibleNodesChanged();</span>
            }
        }
<span class="nc" id="L119">    }</span>

    /**
     * Sets the height of each cell. If rowHeight is less than or equal to
     * 0 this will throw an IllegalArgumentException.
     *
     * @param rowHeight the height of each cell, in pixels
     */
    public void setRowHeight(int rowHeight) {
<span class="nc bnc" id="L128" title="All 2 branches missed.">        if(rowHeight &lt;= 0)</span>
<span class="nc" id="L129">            throw new IllegalArgumentException(&quot;FixedHeightLayoutCache only supports row heights greater than 0&quot;);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if(getRowHeight() != rowHeight) {</span>
<span class="nc" id="L131">            super.setRowHeight(rowHeight);</span>
<span class="nc" id="L132">            visibleNodesChanged();</span>
        }
<span class="nc" id="L134">    }</span>

    /**
     * Returns the number of visible rows.
     */
    public int getRowCount() {
<span class="nc" id="L140">        return rowCount;</span>
    }

    /**
     * Does nothing, FixedHeightLayoutCache doesn't cache width, and that
     * is all that could change.
     */
    public void invalidatePathBounds(TreePath path) {
<span class="nc" id="L148">    }</span>


    /**
     * Informs the TreeState that it needs to recalculate all the sizes
     * it is referencing.
     */
    public void invalidateSizes() {
        // Nothing to do here, rowHeight still same, which is all
        // this is interested in, visible region may have changed though.
<span class="nc" id="L158">        visibleNodesChanged();</span>
<span class="nc" id="L159">    }</span>

    /**
      * Returns true if the value identified by row is currently expanded.
      */
    public boolean isExpanded(TreePath path) {
<span class="nc bnc" id="L165" title="All 2 branches missed.">        if(path != null) {</span>
<span class="nc" id="L166">            FHTreeStateNode     lastNode = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L168" title="All 4 branches missed.">            return (lastNode != null &amp;&amp; lastNode.isExpanded());</span>
        }
<span class="nc" id="L170">        return false;</span>
    }

    /**
     * Returns a rectangle giving the bounds needed to draw path.
     *
     * @param path     a TreePath specifying a node
     * @param placeIn  a Rectangle object giving the available space
     * @return a Rectangle object specifying the space to be used
     */
    public Rectangle getBounds(TreePath path, Rectangle placeIn) {
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if(path == null)</span>
<span class="nc" id="L182">            return null;</span>

<span class="nc" id="L184">        FHTreeStateNode      node = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L186" title="All 2 branches missed.">        if(node != null)</span>
<span class="nc" id="L187">            return getBounds(node, -1, placeIn);</span>

        // node hasn't been created yet.
<span class="nc" id="L190">        TreePath       parentPath = path.getParentPath();</span>

<span class="nc" id="L192">        node = getNodeForPath(parentPath, true, false);</span>
<span class="nc bnc" id="L193" title="All 4 branches missed.">        if (node != null &amp;&amp; node.isExpanded()) {</span>
<span class="nc" id="L194">            int              childIndex = treeModel.getIndexOfChild</span>
<span class="nc" id="L195">                                 (parentPath.getLastPathComponent(),</span>
<span class="nc" id="L196">                                  path.getLastPathComponent());</span>

<span class="nc bnc" id="L198" title="All 2 branches missed.">            if(childIndex != -1)</span>
<span class="nc" id="L199">                return getBounds(node, childIndex, placeIn);</span>
        }
<span class="nc" id="L201">        return null;</span>
    }

    /**
      * Returns the path for passed in row.  If row is not visible
      * null is returned.
      */
    public TreePath getPathForRow(int row) {
<span class="nc bnc" id="L209" title="All 4 branches missed.">        if(row &gt;= 0 &amp;&amp; row &lt; getRowCount()) {</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            if(root.getPathForRow(row, getRowCount(), info)) {</span>
<span class="nc" id="L211">                return info.getPath();</span>
            }
        }
<span class="nc" id="L214">        return null;</span>
    }

    /**
      * Returns the row that the last item identified in path is visible
      * at.  Will return -1 if any of the elements in path are not
      * currently visible.
      */
    public int getRowForPath(TreePath path) {
<span class="nc bnc" id="L223" title="All 4 branches missed.">        if(path == null || root == null)</span>
<span class="nc" id="L224">            return -1;</span>

<span class="nc" id="L226">        FHTreeStateNode         node = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L228" title="All 2 branches missed.">        if(node != null)</span>
<span class="nc" id="L229">            return node.getRow();</span>

<span class="nc" id="L231">        TreePath       parentPath = path.getParentPath();</span>

<span class="nc" id="L233">        node = getNodeForPath(parentPath, true, false);</span>
<span class="nc bnc" id="L234" title="All 4 branches missed.">        if(node != null &amp;&amp; node.isExpanded()) {</span>
<span class="nc" id="L235">            return node.getRowToModelIndex(treeModel.getIndexOfChild</span>
<span class="nc" id="L236">                                           (parentPath.getLastPathComponent(),</span>
<span class="nc" id="L237">                                            path.getLastPathComponent()));</span>
        }
<span class="nc" id="L239">        return -1;</span>
    }

    /**
      * Returns the path to the node that is closest to x,y.  If
      * there is nothing currently visible this will return null, otherwise
      * it'll always return a valid path.  If you need to test if the
      * returned object is exactly at x, y you should get the bounds for
      * the returned path and test x, y against that.
      */
    public TreePath getPathClosestTo(int x, int y) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if(getRowCount() == 0)</span>
<span class="nc" id="L251">            return null;</span>

<span class="nc" id="L253">        int                row = getRowContainingYLocation(y);</span>

<span class="nc" id="L255">        return getPathForRow(row);</span>
    }

    /**
     * Returns the number of visible children for row.
     */
    public int getVisibleChildCount(TreePath path) {
<span class="nc" id="L262">        FHTreeStateNode         node = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">        if(node == null)</span>
<span class="nc" id="L265">            return 0;</span>
<span class="nc" id="L266">        return node.getTotalChildCount();</span>
    }

    /**
     * Returns an Enumerator that increments over the visible paths
     * starting at the passed in location. The ordering of the enumeration
     * is based on how the paths are displayed.
     */
    public Enumeration&lt;TreePath&gt; getVisiblePathsFrom(TreePath path) {
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if(path == null)</span>
<span class="nc" id="L276">            return null;</span>

<span class="nc" id="L278">        FHTreeStateNode         node = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L280" title="All 2 branches missed.">        if(node != null) {</span>
<span class="nc" id="L281">            return new VisibleFHTreeStateNodeEnumeration(node);</span>
        }
<span class="nc" id="L283">        TreePath            parentPath = path.getParentPath();</span>

<span class="nc" id="L285">        node = getNodeForPath(parentPath, true, false);</span>
<span class="nc bnc" id="L286" title="All 4 branches missed.">        if(node != null &amp;&amp; node.isExpanded()) {</span>
<span class="nc" id="L287">            return new VisibleFHTreeStateNodeEnumeration(node,</span>
<span class="nc" id="L288">                  treeModel.getIndexOfChild(parentPath.getLastPathComponent(),</span>
<span class="nc" id="L289">                                            path.getLastPathComponent()));</span>
        }
<span class="nc" id="L291">        return null;</span>
    }

    /**
     * Marks the path &lt;code&gt;path&lt;/code&gt; expanded state to
     * &lt;code&gt;isExpanded&lt;/code&gt;.
     */
    public void setExpandedState(TreePath path, boolean isExpanded) {
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if(isExpanded)</span>
<span class="nc" id="L300">            ensurePathIsExpanded(path, true);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        else if(path != null) {</span>
<span class="nc" id="L302">            TreePath              parentPath = path.getParentPath();</span>

            // YECK! Make the parent expanded.
<span class="nc bnc" id="L305" title="All 2 branches missed.">            if(parentPath != null) {</span>
<span class="nc" id="L306">                FHTreeStateNode     parentNode = getNodeForPath(parentPath,</span>
                                                                false, true);
<span class="nc bnc" id="L308" title="All 2 branches missed.">                if(parentNode != null)</span>
<span class="nc" id="L309">                    parentNode.makeVisible();</span>
            }
            // And collapse the child.
<span class="nc" id="L312">            FHTreeStateNode         childNode = getNodeForPath(path, true,</span>
                                                               false);

<span class="nc bnc" id="L315" title="All 2 branches missed.">            if(childNode != null)</span>
<span class="nc" id="L316">                childNode.collapse(true);</span>
        }
<span class="nc" id="L318">    }</span>

    /**
     * Returns true if the path is expanded, and visible.
     */
    public boolean getExpandedState(TreePath path) {
<span class="nc" id="L324">        FHTreeStateNode       node = getNodeForPath(path, true, false);</span>

<span class="nc bnc" id="L326" title="All 6 branches missed.">        return (node != null) ? (node.isVisible() &amp;&amp; node.isExpanded()) :</span>
                                 false;
    }

    //
    // TreeModelListener methods
    //

    /**
     * &lt;p&gt;Invoked after a node (or a set of siblings) has changed in some
     * way. The node(s) have not changed locations in the tree or
     * altered their children arrays, but other attributes have
     * changed and may affect presentation. Example: the name of a
     * file has changed, but it is in the same location in the file
     * system.&lt;/p&gt;
     *
     * &lt;p&gt;e.path() returns the path the parent of the changed node(s).&lt;/p&gt;
     *
     * &lt;p&gt;e.childIndices() returns the index(es) of the changed node(s).&lt;/p&gt;
     */
    public void treeNodesChanged(TreeModelEvent e) {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if(e != null) {</span>
            int                 changedIndexs[];
<span class="nc" id="L349">            FHTreeStateNode     changedParent = getNodeForPath</span>
<span class="nc" id="L350">                                  (SwingUtilities2.getTreePath(e, getModel()), false, false);</span>
            int                 maxCounter;

<span class="nc" id="L353">            changedIndexs = e.getChildIndices();</span>
            /* Only need to update the children if the node has been
               expanded once. */
            // PENDING(scott): make sure childIndexs is sorted!
<span class="nc bnc" id="L357" title="All 2 branches missed.">            if (changedParent != null) {</span>
<span class="nc bnc" id="L358" title="All 4 branches missed.">                if (changedIndexs != null &amp;&amp;</span>
                    (maxCounter = changedIndexs.length) &gt; 0) {
<span class="nc" id="L360">                    Object       parentValue = changedParent.getUserObject();</span>

<span class="nc bnc" id="L362" title="All 2 branches missed.">                    for(int counter = 0; counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L363">                        FHTreeStateNode    child = changedParent.</span>
<span class="nc" id="L364">                                 getChildAtModelIndex(changedIndexs[counter]);</span>

<span class="nc bnc" id="L366" title="All 2 branches missed.">                        if(child != null) {</span>
<span class="nc" id="L367">                            child.setUserObject(treeModel.getChild(parentValue,</span>
                                                     changedIndexs[counter]));
                        }
                    }
<span class="nc bnc" id="L371" title="All 4 branches missed.">                    if(changedParent.isVisible() &amp;&amp; changedParent.isExpanded())</span>
<span class="nc" id="L372">                        visibleNodesChanged();</span>
<span class="nc" id="L373">                }</span>
                // Null for root indicates it changed.
<span class="nc bnc" id="L375" title="All 4 branches missed.">                else if (changedParent == root &amp;&amp; changedParent.isVisible() &amp;&amp;</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                         changedParent.isExpanded()) {</span>
<span class="nc" id="L377">                    visibleNodesChanged();</span>
                }
            }
        }
<span class="nc" id="L381">    }</span>

    /**
     * &lt;p&gt;Invoked after nodes have been inserted into the tree.&lt;/p&gt;
     *
     * &lt;p&gt;e.path() returns the parent of the new nodes
     * &lt;p&gt;e.childIndices() returns the indices of the new nodes in
     * ascending order.
     */
    public void treeNodesInserted(TreeModelEvent e) {
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if(e != null) {</span>
            int                 changedIndexs[];
<span class="nc" id="L393">            FHTreeStateNode     changedParent = getNodeForPath</span>
<span class="nc" id="L394">                                  (SwingUtilities2.getTreePath(e, getModel()), false, false);</span>
            int                 maxCounter;

<span class="nc" id="L397">            changedIndexs = e.getChildIndices();</span>
            /* Only need to update the children if the node has been
               expanded once. */
            // PENDING(scott): make sure childIndexs is sorted!
<span class="nc bnc" id="L401" title="All 6 branches missed.">            if(changedParent != null &amp;&amp; changedIndexs != null &amp;&amp;</span>
               (maxCounter = changedIndexs.length) &gt; 0) {
<span class="nc" id="L403">                boolean          isVisible =</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                    (changedParent.isVisible() &amp;&amp;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                     changedParent.isExpanded());</span>

<span class="nc bnc" id="L407" title="All 2 branches missed.">                for(int counter = 0; counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L408">                    changedParent.childInsertedAtModelIndex</span>
<span class="nc" id="L409">                        (changedIndexs[counter], isVisible);</span>
                }
<span class="nc bnc" id="L411" title="All 4 branches missed.">                if(isVisible &amp;&amp; treeSelectionModel != null)</span>
<span class="nc" id="L412">                    treeSelectionModel.resetRowSelection();</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if(changedParent.isVisible())</span>
<span class="nc" id="L414">                    this.visibleNodesChanged();</span>
            }
        }
<span class="nc" id="L417">    }</span>

    /**
     * &lt;p&gt;Invoked after nodes have been removed from the tree.  Note that
     * if a subtree is removed from the tree, this method may only be
     * invoked once for the root of the removed subtree, not once for
     * each individual set of siblings removed.&lt;/p&gt;
     *
     * &lt;p&gt;e.path() returns the former parent of the deleted nodes.&lt;/p&gt;
     *
     * &lt;p&gt;e.childIndices() returns the indices the nodes had before they were deleted in ascending order.&lt;/p&gt;
     */
    public void treeNodesRemoved(TreeModelEvent e) {
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if(e != null) {</span>
            int                  changedIndexs[];
            int                  maxCounter;
<span class="nc" id="L433">            TreePath             parentPath = SwingUtilities2.getTreePath(e, getModel());</span>
<span class="nc" id="L434">            FHTreeStateNode      changedParentNode = getNodeForPath</span>
<span class="nc" id="L435">                                       (parentPath, false, false);</span>

<span class="nc" id="L437">            changedIndexs = e.getChildIndices();</span>
            // PENDING(scott): make sure that changedIndexs are sorted in
            // ascending order.
<span class="nc bnc" id="L440" title="All 6 branches missed.">            if(changedParentNode != null &amp;&amp; changedIndexs != null &amp;&amp;</span>
               (maxCounter = changedIndexs.length) &gt; 0) {
<span class="nc" id="L442">                Object[]           children = e.getChildren();</span>
<span class="nc" id="L443">                boolean            isVisible =</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                    (changedParentNode.isVisible() &amp;&amp;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">                     changedParentNode.isExpanded());</span>

<span class="nc bnc" id="L447" title="All 2 branches missed.">                for(int counter = maxCounter - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L448">                    changedParentNode.removeChildAtModelIndex</span>
<span class="nc" id="L449">                                     (changedIndexs[counter], isVisible);</span>
                }
<span class="nc bnc" id="L451" title="All 2 branches missed.">                if(isVisible) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                    if(treeSelectionModel != null)</span>
<span class="nc" id="L453">                        treeSelectionModel.resetRowSelection();</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">                    if (treeModel.getChildCount(changedParentNode.</span>
<span class="nc" id="L455">                                                getUserObject()) == 0 &amp;&amp;</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                                  changedParentNode.isLeaf()) {</span>
                        // Node has become a leaf, collapse it.
<span class="nc" id="L458">                        changedParentNode.collapse(false);</span>
                    }
<span class="nc" id="L460">                    visibleNodesChanged();</span>
                }
<span class="nc bnc" id="L462" title="All 2 branches missed.">                else if(changedParentNode.isVisible())</span>
<span class="nc" id="L463">                    visibleNodesChanged();</span>
            }
        }
<span class="nc" id="L466">    }</span>

    /**
     * &lt;p&gt;Invoked after the tree has drastically changed structure from a
     * given node down.  If the path returned by e.getPath() is of length
     * one and the first element does not identify the current root node
     * the first element should become the new root of the tree.&lt;p&gt;
     *
     * &lt;p&gt;e.path() holds the path to the node.&lt;/p&gt;
     * &lt;p&gt;e.childIndices() returns null.&lt;/p&gt;
     */
    public void treeStructureChanged(TreeModelEvent e) {
<span class="nc bnc" id="L478" title="All 2 branches missed.">        if(e != null) {</span>
<span class="nc" id="L479">            TreePath          changedPath = SwingUtilities2.getTreePath(e, getModel());</span>
<span class="nc" id="L480">            FHTreeStateNode   changedNode = getNodeForPath</span>
<span class="nc" id="L481">                                                (changedPath, false, false);</span>

            // Check if root has changed, either to a null root, or
            // to an entirely new root.
<span class="nc bnc" id="L485" title="All 8 branches missed.">            if (changedNode == root ||</span>
                (changedNode == null &amp;&amp;
                 ((changedPath == null &amp;&amp; treeModel != null &amp;&amp;
<span class="nc bnc" id="L488" title="All 4 branches missed.">                   treeModel.getRoot() == null) ||</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                  (changedPath != null &amp;&amp; changedPath.getPathCount() &lt;= 1)))) {</span>
<span class="nc" id="L490">                rebuild(true);</span>
            }
<span class="nc bnc" id="L492" title="All 2 branches missed.">            else if(changedNode != null) {</span>
                boolean             wasExpanded, wasVisible;
<span class="nc" id="L494">                FHTreeStateNode     parent = (FHTreeStateNode)</span>
<span class="nc" id="L495">                                              changedNode.getParent();</span>

<span class="nc" id="L497">                wasExpanded = changedNode.isExpanded();</span>
<span class="nc" id="L498">                wasVisible = changedNode.isVisible();</span>

<span class="nc" id="L500">                int index = parent.getIndex(changedNode);</span>
<span class="nc" id="L501">                changedNode.collapse(false);</span>
<span class="nc" id="L502">                parent.remove(index);</span>

<span class="nc bnc" id="L504" title="All 4 branches missed.">                if(wasVisible &amp;&amp; wasExpanded) {</span>
<span class="nc" id="L505">                    int row = changedNode.getRow();</span>
<span class="nc" id="L506">                    parent.resetChildrenRowsFrom(row, index,</span>
<span class="nc" id="L507">                                                 changedNode.getChildIndex());</span>
<span class="nc" id="L508">                    changedNode = getNodeForPath(changedPath, false, true);</span>
<span class="nc" id="L509">                    changedNode.expand();</span>
                }
<span class="nc bnc" id="L511" title="All 6 branches missed.">                if(treeSelectionModel != null &amp;&amp; wasVisible &amp;&amp; wasExpanded)</span>
<span class="nc" id="L512">                    treeSelectionModel.resetRowSelection();</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                if(wasVisible)</span>
<span class="nc" id="L514">                    this.visibleNodesChanged();</span>
            }
        }
<span class="nc" id="L517">    }</span>


    //
    // Local methods
    //

    private void visibleNodesChanged() {
<span class="nc" id="L525">    }</span>

    /**
     * Returns the bounds for the given node. If &lt;code&gt;childIndex&lt;/code&gt;
     * is -1, the bounds of &lt;code&gt;parent&lt;/code&gt; are returned, otherwise
     * the bounds of the node at &lt;code&gt;childIndex&lt;/code&gt; are returned.
     */
    private Rectangle getBounds(FHTreeStateNode parent, int childIndex,
                                  Rectangle placeIn) {
        boolean              expanded;
        int                  level;
        int                  row;
        Object               value;

<span class="nc bnc" id="L539" title="All 2 branches missed.">        if(childIndex == -1) {</span>
            // Getting bounds for parent
<span class="nc" id="L541">            row = parent.getRow();</span>
<span class="nc" id="L542">            value = parent.getUserObject();</span>
<span class="nc" id="L543">            expanded = parent.isExpanded();</span>
<span class="nc" id="L544">            level = parent.getLevel();</span>
        }
        else {
<span class="nc" id="L547">            row = parent.getRowToModelIndex(childIndex);</span>
<span class="nc" id="L548">            value = treeModel.getChild(parent.getUserObject(), childIndex);</span>
<span class="nc" id="L549">            expanded = false;</span>
<span class="nc" id="L550">            level = parent.getLevel() + 1;</span>
        }

<span class="nc" id="L553">        Rectangle      bounds = getNodeDimensions(value, row, level,</span>
                                                  expanded, boundsBuffer);
        // No node dimensions, bail.
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if(bounds == null)</span>
<span class="nc" id="L557">            return null;</span>

<span class="nc bnc" id="L559" title="All 2 branches missed.">        if(placeIn == null)</span>
<span class="nc" id="L560">            placeIn = new Rectangle();</span>

<span class="nc" id="L562">        placeIn.x = bounds.x;</span>
<span class="nc" id="L563">        placeIn.height = getRowHeight();</span>
<span class="nc" id="L564">        placeIn.y = row * placeIn.height;</span>
<span class="nc" id="L565">        placeIn.width = bounds.width;</span>
<span class="nc" id="L566">        return placeIn;</span>
    }

    /**
     * Adjust the large row count of the AbstractTreeUI the receiver was
     * created with.
     */
    private void adjustRowCountBy(int changeAmount) {
<span class="nc" id="L574">        rowCount += changeAmount;</span>
<span class="nc" id="L575">    }</span>

    /**
     * Adds a mapping for node.
     */
    private void addMapping(FHTreeStateNode node) {
<span class="nc" id="L581">        treePathMapping.put(node.getTreePath(), node);</span>
<span class="nc" id="L582">    }</span>

    /**
     * Removes the mapping for a previously added node.
     */
    private void removeMapping(FHTreeStateNode node) {
<span class="nc" id="L588">        treePathMapping.remove(node.getTreePath());</span>
<span class="nc" id="L589">    }</span>

    /**
     * Returns the node previously added for &lt;code&gt;path&lt;/code&gt;. This may
     * return null, if you to create a node use getNodeForPath.
     */
    private FHTreeStateNode getMapping(TreePath path) {
<span class="nc" id="L596">        return treePathMapping.get(path);</span>
    }

    /**
     * Sent to completely rebuild the visible tree. All nodes are collapsed.
     */
    private void rebuild(boolean clearSelection) {
        Object            rootUO;

<span class="nc" id="L605">        treePathMapping.clear();</span>
<span class="nc bnc" id="L606" title="All 4 branches missed.">        if(treeModel != null &amp;&amp; (rootUO = treeModel.getRoot()) != null) {</span>
<span class="nc" id="L607">            root = createNodeForValue(rootUO, 0);</span>
<span class="nc" id="L608">            root.path = new TreePath(rootUO);</span>
<span class="nc" id="L609">            addMapping(root);</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if(isRootVisible()) {</span>
<span class="nc" id="L611">                rowCount = 1;</span>
<span class="nc" id="L612">                root.row = 0;</span>
            }
            else {
<span class="nc" id="L615">                rowCount = 0;</span>
<span class="nc" id="L616">                root.row = -1;</span>
            }
<span class="nc" id="L618">            root.expand();</span>
        }
        else {
<span class="nc" id="L621">            root = null;</span>
<span class="nc" id="L622">            rowCount = 0;</span>
        }
<span class="nc bnc" id="L624" title="All 4 branches missed.">        if(clearSelection &amp;&amp; treeSelectionModel != null) {</span>
<span class="nc" id="L625">            treeSelectionModel.clearSelection();</span>
        }
<span class="nc" id="L627">        this.visibleNodesChanged();</span>
<span class="nc" id="L628">    }</span>

    /**
      * Returns the index of the row containing location.  If there
      * are no rows, -1 is returned.  If location is beyond the last
      * row index, the last row index is returned.
      */
    private int getRowContainingYLocation(int location) {
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if(getRowCount() == 0)</span>
<span class="nc" id="L637">            return -1;</span>
<span class="nc" id="L638">        return Math.max(0, Math.min(getRowCount() - 1,</span>
<span class="nc" id="L639">                                    location / getRowHeight()));</span>
    }

    /**
     * Ensures that all the path components in path are expanded, accept
     * for the last component which will only be expanded if expandLast
     * is true.
     * Returns true if succesful in finding the path.
     */
    private boolean ensurePathIsExpanded(TreePath aPath,
                                           boolean expandLast) {
<span class="nc bnc" id="L650" title="All 2 branches missed.">        if(aPath != null) {</span>
            // Make sure the last entry isn't a leaf.
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if(treeModel.isLeaf(aPath.getLastPathComponent())) {</span>
<span class="nc" id="L653">                aPath = aPath.getParentPath();</span>
<span class="nc" id="L654">                expandLast = true;</span>
            }
<span class="nc bnc" id="L656" title="All 2 branches missed.">            if(aPath != null) {</span>
<span class="nc" id="L657">                FHTreeStateNode     lastNode = getNodeForPath(aPath, false,</span>
                                                              true);

<span class="nc bnc" id="L660" title="All 2 branches missed.">                if(lastNode != null) {</span>
<span class="nc" id="L661">                    lastNode.makeVisible();</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">                    if(expandLast)</span>
<span class="nc" id="L663">                        lastNode.expand();</span>
<span class="nc" id="L664">                    return true;</span>
                }
            }
        }
<span class="nc" id="L668">        return false;</span>
    }

    /**
     * Creates and returns an instance of FHTreeStateNode.
     */
    private FHTreeStateNode createNodeForValue(Object value,int childIndex) {
<span class="nc" id="L675">        return new FHTreeStateNode(value, childIndex, -1);</span>
    }

    /**
     * Messages getTreeNodeForPage(path, onlyIfVisible, shouldCreate,
     * path.length) as long as path is non-null and the length is &gt; 0.
     * Otherwise returns null.
     */
    private FHTreeStateNode getNodeForPath(TreePath path,
                                             boolean onlyIfVisible,
                                             boolean shouldCreate) {
<span class="nc bnc" id="L686" title="All 2 branches missed.">        if(path != null) {</span>
            FHTreeStateNode      node;

<span class="nc" id="L689">            node = getMapping(path);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if(node != null) {</span>
<span class="nc bnc" id="L691" title="All 4 branches missed.">                if(onlyIfVisible &amp;&amp; !node.isVisible())</span>
<span class="nc" id="L692">                    return null;</span>
<span class="nc" id="L693">                return node;</span>
            }
<span class="nc bnc" id="L695" title="All 2 branches missed.">            if(onlyIfVisible)</span>
<span class="nc" id="L696">                return null;</span>

            // Check all the parent paths, until a match is found.
            Stack&lt;TreePath&gt; paths;

<span class="nc bnc" id="L701" title="All 2 branches missed.">            if(tempStacks.size() == 0) {</span>
<span class="nc" id="L702">                paths = new Stack&lt;TreePath&gt;();</span>
            }
            else {
<span class="nc" id="L705">                paths = tempStacks.pop();</span>
            }

            try {
<span class="nc" id="L709">                paths.push(path);</span>
<span class="nc" id="L710">                path = path.getParentPath();</span>
<span class="nc" id="L711">                node = null;</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">                while(path != null) {</span>
<span class="nc" id="L713">                    node = getMapping(path);</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                    if(node != null) {</span>
                        // Found a match, create entries for all paths in
                        // paths.
<span class="nc bnc" id="L717" title="All 4 branches missed.">                        while(node != null &amp;&amp; paths.size() &gt; 0) {</span>
<span class="nc" id="L718">                            path = paths.pop();</span>
<span class="nc" id="L719">                            node = node.createChildFor(path.</span>
<span class="nc" id="L720">                                                       getLastPathComponent());</span>
                        }
<span class="nc" id="L722">                        return node;</span>
                    }
<span class="nc" id="L724">                    paths.push(path);</span>
<span class="nc" id="L725">                    path = path.getParentPath();</span>
                }
            }
            finally {
<span class="nc" id="L729">                paths.removeAllElements();</span>
<span class="nc" id="L730">                tempStacks.push(paths);</span>
<span class="nc" id="L731">            }</span>
            // If we get here it means they share a different root!
<span class="nc" id="L733">            return null;</span>
        }
<span class="nc" id="L735">        return null;</span>
    }

    /**
     * FHTreeStateNode is used to track what has been expanded.
     * FHTreeStateNode differs from VariableHeightTreeState.TreeStateNode
     * in that it is highly model intensive. That is almost all queries to a
     * FHTreeStateNode result in the TreeModel being queried. And it
     * obviously does not support variable sized row heights.
     */
    private class FHTreeStateNode extends DefaultMutableTreeNode {
        /** Is this node expanded? */
        protected boolean         isExpanded;

        /** Index of this node from the model. */
        protected int             childIndex;

        /** Child count of the receiver. */
        protected int             childCount;

        /** Row of the receiver. This is only valid if the row is expanded.
         */
        protected int             row;

        /** Path of this node. */
        protected TreePath        path;


<span class="nc" id="L763">        public FHTreeStateNode(Object userObject, int childIndex, int row) {</span>
<span class="nc" id="L764">            super(userObject);</span>
<span class="nc" id="L765">            this.childIndex = childIndex;</span>
<span class="nc" id="L766">            this.row = row;</span>
<span class="nc" id="L767">        }</span>

        //
        // Overriden DefaultMutableTreeNode methods
        //

        /**
         * Messaged when this node is added somewhere, resets the path
         * and adds a mapping from path to this node.
         */
        public void setParent(MutableTreeNode parent) {
<span class="nc" id="L778">            super.setParent(parent);</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">            if(parent != null) {</span>
<span class="nc" id="L780">                path = ((FHTreeStateNode)parent).getTreePath().</span>
<span class="nc" id="L781">                            pathByAddingChild(getUserObject());</span>
<span class="nc" id="L782">                addMapping(this);</span>
            }
<span class="nc" id="L784">        }</span>

        /**
         * Messaged when this node is removed from its parent, this messages
         * &lt;code&gt;removedFromMapping&lt;/code&gt; to remove all the children.
         */
        public void remove(int childIndex) {
<span class="nc" id="L791">            FHTreeStateNode     node = (FHTreeStateNode)getChildAt(childIndex);</span>

<span class="nc" id="L793">            node.removeFromMapping();</span>
<span class="nc" id="L794">            super.remove(childIndex);</span>
<span class="nc" id="L795">        }</span>

        /**
         * Messaged to set the user object. This resets the path.
         */
        public void setUserObject(Object o) {
<span class="nc" id="L801">            super.setUserObject(o);</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if(path != null) {</span>
<span class="nc" id="L803">                FHTreeStateNode      parent = (FHTreeStateNode)getParent();</span>

<span class="nc bnc" id="L805" title="All 2 branches missed.">                if(parent != null)</span>
<span class="nc" id="L806">                    resetChildrenPaths(parent.getTreePath());</span>
                else
<span class="nc" id="L808">                    resetChildrenPaths(null);</span>
            }
<span class="nc" id="L810">        }</span>

        //
        //

        /**
         * Returns the index of the receiver in the model.
         */
        public int getChildIndex() {
<span class="nc" id="L819">            return childIndex;</span>
        }

        /**
         * Returns the &lt;code&gt;TreePath&lt;/code&gt; of the receiver.
         */
        public TreePath getTreePath() {
<span class="nc" id="L826">            return path;</span>
        }

        /**
         * Returns the child for the passed in model index, this will
         * return &lt;code&gt;null&lt;/code&gt; if the child for &lt;code&gt;index&lt;/code&gt;
         * has not yet been created (expanded).
         */
        public FHTreeStateNode getChildAtModelIndex(int index) {
            // PENDING: Make this a binary search!
<span class="nc bnc" id="L836" title="All 2 branches missed.">            for(int counter = getChildCount() - 1; counter &gt;= 0; counter--)</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">                if(((FHTreeStateNode)getChildAt(counter)).childIndex == index)</span>
<span class="nc" id="L838">                    return (FHTreeStateNode)getChildAt(counter);</span>
<span class="nc" id="L839">            return null;</span>
        }

        /**
         * Returns true if this node is visible. This is determined by
         * asking all the parents if they are expanded.
         */
        public boolean isVisible() {
<span class="nc" id="L847">            FHTreeStateNode         parent = (FHTreeStateNode)getParent();</span>

<span class="nc bnc" id="L849" title="All 2 branches missed.">            if(parent == null)</span>
<span class="nc" id="L850">                return true;</span>
<span class="nc bnc" id="L851" title="All 4 branches missed.">            return (parent.isExpanded() &amp;&amp; parent.isVisible());</span>
        }

        /**
         * Returns the row of the receiver.
         */
        public int getRow() {
<span class="nc" id="L858">            return row;</span>
        }

        /**
         * Returns the row of the child with a model index of
         * &lt;code&gt;index&lt;/code&gt;.
         */
        public int getRowToModelIndex(int index) {
            FHTreeStateNode      child;
<span class="nc" id="L867">            int                  lastRow = getRow() + 1;</span>
<span class="nc" id="L868">            int                  retValue = lastRow;</span>

            // This too could be a binary search!
<span class="nc" id="L871">            for(int counter = 0, maxCounter = getChildCount();</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">                counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L873">                child = (FHTreeStateNode)getChildAt(counter);</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">                if(child.childIndex &gt;= index) {</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                    if(child.childIndex == index)</span>
<span class="nc" id="L876">                        return child.row;</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">                    if(counter == 0)</span>
<span class="nc" id="L878">                        return getRow() + 1 + index;</span>
<span class="nc" id="L879">                    return child.row - (child.childIndex - index);</span>
                }
            }
            // YECK!
<span class="nc" id="L883">            return getRow() + 1 + getTotalChildCount() -</span>
                             (childCount - index);
        }

        /**
         * Returns the number of children in the receiver by descending all
         * expanded nodes and messaging them with getTotalChildCount.
         */
        public int getTotalChildCount() {
<span class="nc bnc" id="L892" title="All 2 branches missed.">            if(isExpanded()) {</span>
<span class="nc" id="L893">                FHTreeStateNode      parent = (FHTreeStateNode)getParent();</span>
                int                  pIndex;

<span class="nc bnc" id="L896" title="All 2 branches missed.">                if(parent != null &amp;&amp; (pIndex = parent.getIndex(this)) + 1 &lt;</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">                   parent.getChildCount()) {</span>
                    // This node has a created sibling, to calc total
                    // child count directly from that!
<span class="nc" id="L900">                    FHTreeStateNode  nextSibling = (FHTreeStateNode)parent.</span>
<span class="nc" id="L901">                                           getChildAt(pIndex + 1);</span>

<span class="nc" id="L903">                    return nextSibling.row - row -</span>
                           (nextSibling.childIndex - childIndex);
                }
                else {
<span class="nc" id="L907">                    int retCount = childCount;</span>

<span class="nc bnc" id="L909" title="All 2 branches missed.">                    for(int counter = getChildCount() - 1; counter &gt;= 0;</span>
<span class="nc" id="L910">                        counter--) {</span>
<span class="nc" id="L911">                        retCount += ((FHTreeStateNode)getChildAt(counter))</span>
<span class="nc" id="L912">                                                  .getTotalChildCount();</span>
                    }
<span class="nc" id="L914">                    return retCount;</span>
                }
            }
<span class="nc" id="L917">            return 0;</span>
        }

        /**
         * Returns true if this node is expanded.
         */
        public boolean isExpanded() {
<span class="nc" id="L924">            return isExpanded;</span>
        }

        /**
         * The highest visible nodes have a depth of 0.
         */
        public int getVisibleLevel() {
<span class="nc bnc" id="L931" title="All 2 branches missed.">            if (isRootVisible()) {</span>
<span class="nc" id="L932">                return getLevel();</span>
            } else {
<span class="nc" id="L934">                return getLevel() - 1;</span>
            }
        }

        /**
         * Recreates the receivers path, and all its children's paths.
         */
        protected void resetChildrenPaths(TreePath parentPath) {
<span class="nc" id="L942">            removeMapping(this);</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if(parentPath == null)</span>
<span class="nc" id="L944">                path = new TreePath(getUserObject());</span>
            else
<span class="nc" id="L946">                path = parentPath.pathByAddingChild(getUserObject());</span>
<span class="nc" id="L947">            addMapping(this);</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">            for(int counter = getChildCount() - 1; counter &gt;= 0; counter--)</span>
<span class="nc" id="L949">                ((FHTreeStateNode)getChildAt(counter)).</span>
<span class="nc" id="L950">                               resetChildrenPaths(path);</span>
<span class="nc" id="L951">        }</span>

        /**
         * Removes the receiver, and all its children, from the mapping
         * table.
         */
        protected void removeFromMapping() {
<span class="nc bnc" id="L958" title="All 2 branches missed.">            if(path != null) {</span>
<span class="nc" id="L959">                removeMapping(this);</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">                for(int counter = getChildCount() - 1; counter &gt;= 0; counter--)</span>
<span class="nc" id="L961">                    ((FHTreeStateNode)getChildAt(counter)).removeFromMapping();</span>
            }
<span class="nc" id="L963">        }</span>

        /**
         * Creates a new node to represent &lt;code&gt;userObject&lt;/code&gt;.
         * This does NOT check to ensure there isn't already a child node
         * to manage &lt;code&gt;userObject&lt;/code&gt;.
         */
        protected FHTreeStateNode createChildFor(Object userObject) {
<span class="nc" id="L971">            int      newChildIndex = treeModel.getIndexOfChild</span>
<span class="nc" id="L972">                                     (getUserObject(), userObject);</span>

<span class="nc bnc" id="L974" title="All 2 branches missed.">            if(newChildIndex &lt; 0)</span>
<span class="nc" id="L975">                return null;</span>

            FHTreeStateNode     aNode;
<span class="nc" id="L978">            FHTreeStateNode     child = createNodeForValue(userObject,</span>
                                                           newChildIndex);
            int                 childRow;

<span class="nc bnc" id="L982" title="All 2 branches missed.">            if(isVisible()) {</span>
<span class="nc" id="L983">                childRow = getRowToModelIndex(newChildIndex);</span>
            }
            else {
<span class="nc" id="L986">                childRow = -1;</span>
            }
<span class="nc" id="L988">            child.row = childRow;</span>
<span class="nc" id="L989">            for(int counter = 0, maxCounter = getChildCount();</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">                counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L991">                aNode = (FHTreeStateNode)getChildAt(counter);</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">                if(aNode.childIndex &gt; newChildIndex) {</span>
<span class="nc" id="L993">                    insert(child, counter);</span>
<span class="nc" id="L994">                    return child;</span>
                }
            }
<span class="nc" id="L997">            add(child);</span>
<span class="nc" id="L998">            return child;</span>
        }

        /**
         * Adjusts the receiver, and all its children rows by
         * &lt;code&gt;amount&lt;/code&gt;.
         */
        protected void adjustRowBy(int amount) {
<span class="nc" id="L1006">            row += amount;</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            if(isExpanded) {</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                for(int counter = getChildCount() - 1; counter &gt;= 0;</span>
<span class="nc" id="L1009">                    counter--)</span>
<span class="nc" id="L1010">                    ((FHTreeStateNode)getChildAt(counter)).adjustRowBy(amount);</span>
            }
<span class="nc" id="L1012">        }</span>

        /**
         * Adjusts this node, its child, and its parent starting at
         * an index of &lt;code&gt;index&lt;/code&gt; index is the index of the child
         * to start adjusting from, which is not necessarily the model
         * index.
         */
        protected void adjustRowBy(int amount, int startIndex) {
            // Could check isVisible, but probably isn't worth it.
<span class="nc bnc" id="L1022" title="All 2 branches missed.">            if(isExpanded) {</span>
                // children following startIndex.
<span class="nc bnc" id="L1024" title="All 2 branches missed.">                for(int counter = getChildCount() - 1; counter &gt;= startIndex;</span>
<span class="nc" id="L1025">                    counter--)</span>
<span class="nc" id="L1026">                    ((FHTreeStateNode)getChildAt(counter)).adjustRowBy(amount);</span>
            }
            // Parent
<span class="nc" id="L1029">            FHTreeStateNode        parent = (FHTreeStateNode)getParent();</span>

<span class="nc bnc" id="L1031" title="All 2 branches missed.">            if(parent != null) {</span>
<span class="nc" id="L1032">                parent.adjustRowBy(amount, parent.getIndex(this) + 1);</span>
            }
<span class="nc" id="L1034">        }</span>

        /**
         * Messaged when the node has expanded. This updates all of
         * the receivers children rows, as well as the total row count.
         */
        protected void didExpand() {
<span class="nc" id="L1041">            int               nextRow = setRowAndChildren(row);</span>
<span class="nc" id="L1042">            FHTreeStateNode   parent = (FHTreeStateNode)getParent();</span>
<span class="nc" id="L1043">            int               childRowCount = nextRow - row - 1;</span>

<span class="nc bnc" id="L1045" title="All 2 branches missed.">            if(parent != null) {</span>
<span class="nc" id="L1046">                parent.adjustRowBy(childRowCount, parent.getIndex(this) + 1);</span>
            }
<span class="nc" id="L1048">            adjustRowCountBy(childRowCount);</span>
<span class="nc" id="L1049">        }</span>

        /**
         * Sets the receivers row to &lt;code&gt;nextRow&lt;/code&gt; and recursively
         * updates all the children of the receivers rows. The index the
         * next row is to be placed as is returned.
         */
        protected int setRowAndChildren(int nextRow) {
<span class="nc" id="L1057">            row = nextRow;</span>

<span class="nc bnc" id="L1059" title="All 2 branches missed.">            if(!isExpanded())</span>
<span class="nc" id="L1060">                return row + 1;</span>

<span class="nc" id="L1062">            int              lastRow = row + 1;</span>
<span class="nc" id="L1063">            int              lastModelIndex = 0;</span>
            FHTreeStateNode  child;
<span class="nc" id="L1065">            int              maxCounter = getChildCount();</span>

<span class="nc bnc" id="L1067" title="All 2 branches missed.">            for(int counter = 0; counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L1068">                child = (FHTreeStateNode)getChildAt(counter);</span>
<span class="nc" id="L1069">                lastRow += (child.childIndex - lastModelIndex);</span>
<span class="nc" id="L1070">                lastModelIndex = child.childIndex + 1;</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">                if(child.isExpanded) {</span>
<span class="nc" id="L1072">                    lastRow = child.setRowAndChildren(lastRow);</span>
                }
                else {
<span class="nc" id="L1075">                    child.row = lastRow++;</span>
                }
            }
<span class="nc" id="L1078">            return lastRow + childCount - lastModelIndex;</span>
        }

        /**
         * Resets the receivers children's rows. Starting with the child
         * at &lt;code&gt;childIndex&lt;/code&gt; (and &lt;code&gt;modelIndex&lt;/code&gt;) to
         * &lt;code&gt;newRow&lt;/code&gt;. This uses &lt;code&gt;setRowAndChildren&lt;/code&gt;
         * to recursively descend children, and uses
         * &lt;code&gt;resetRowSelection&lt;/code&gt; to ascend parents.
         */
        // This can be rather expensive, but is needed for the collapse
        // case this is resulting from a remove (although I could fix
        // that by having instances of FHTreeStateNode hold a ref to
        // the number of children). I prefer this though, making determing
        // the row of a particular node fast is very nice!
        protected void resetChildrenRowsFrom(int newRow, int childIndex,
                                            int modelIndex) {
<span class="nc" id="L1095">            int              lastRow = newRow;</span>
<span class="nc" id="L1096">            int              lastModelIndex = modelIndex;</span>
            FHTreeStateNode  node;
<span class="nc" id="L1098">            int              maxCounter = getChildCount();</span>

<span class="nc bnc" id="L1100" title="All 2 branches missed.">            for(int counter = childIndex; counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L1101">                node = (FHTreeStateNode)getChildAt(counter);</span>
<span class="nc" id="L1102">                lastRow += (node.childIndex - lastModelIndex);</span>
<span class="nc" id="L1103">                lastModelIndex = node.childIndex + 1;</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                if(node.isExpanded) {</span>
<span class="nc" id="L1105">                    lastRow = node.setRowAndChildren(lastRow);</span>
                }
                else {
<span class="nc" id="L1108">                    node.row = lastRow++;</span>
                }
            }
<span class="nc" id="L1111">            lastRow += childCount - lastModelIndex;</span>
<span class="nc" id="L1112">            node = (FHTreeStateNode)getParent();</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">            if(node != null) {</span>
<span class="nc" id="L1114">                node.resetChildrenRowsFrom(lastRow, node.getIndex(this) + 1,</span>
                                           this.childIndex + 1);
            }
            else { // This is the root, reset total ROWCOUNT!
<span class="nc" id="L1118">                rowCount = lastRow;</span>
            }
<span class="nc" id="L1120">        }</span>

        /**
         * Makes the receiver visible, but invoking
         * &lt;code&gt;expandParentAndReceiver&lt;/code&gt; on the superclass.
         */
        protected void makeVisible() {
<span class="nc" id="L1127">            FHTreeStateNode       parent = (FHTreeStateNode)getParent();</span>

<span class="nc bnc" id="L1129" title="All 2 branches missed.">            if(parent != null)</span>
<span class="nc" id="L1130">                parent.expandParentAndReceiver();</span>
<span class="nc" id="L1131">        }</span>

        /**
         * Invokes &lt;code&gt;expandParentAndReceiver&lt;/code&gt; on the parent,
         * and expands the receiver.
         */
        protected void expandParentAndReceiver() {
<span class="nc" id="L1138">            FHTreeStateNode       parent = (FHTreeStateNode)getParent();</span>

<span class="nc bnc" id="L1140" title="All 2 branches missed.">            if(parent != null)</span>
<span class="nc" id="L1141">                parent.expandParentAndReceiver();</span>
<span class="nc" id="L1142">            expand();</span>
<span class="nc" id="L1143">        }</span>

        /**
         * Expands the receiver.
         */
        protected void expand() {
<span class="nc bnc" id="L1149" title="All 4 branches missed.">            if(!isExpanded &amp;&amp; !isLeaf()) {</span>
<span class="nc" id="L1150">                boolean            visible = isVisible();</span>

<span class="nc" id="L1152">                isExpanded = true;</span>
<span class="nc" id="L1153">                childCount = treeModel.getChildCount(getUserObject());</span>

<span class="nc bnc" id="L1155" title="All 2 branches missed.">                if(visible) {</span>
<span class="nc" id="L1156">                    didExpand();</span>
                }

                // Update the selection model.
<span class="nc bnc" id="L1160" title="All 4 branches missed.">                if(visible &amp;&amp; treeSelectionModel != null) {</span>
<span class="nc" id="L1161">                    treeSelectionModel.resetRowSelection();</span>
                }
            }
<span class="nc" id="L1164">        }</span>

        /**
         * Collapses the receiver. If &lt;code&gt;adjustRows&lt;/code&gt; is true,
         * the rows of nodes after the receiver are adjusted.
         */
        protected void collapse(boolean adjustRows) {
<span class="nc bnc" id="L1171" title="All 2 branches missed.">            if(isExpanded) {</span>
<span class="nc bnc" id="L1172" title="All 4 branches missed.">                if(isVisible() &amp;&amp; adjustRows) {</span>
<span class="nc" id="L1173">                    int              childCount = getTotalChildCount();</span>

<span class="nc" id="L1175">                    isExpanded = false;</span>
<span class="nc" id="L1176">                    adjustRowCountBy(-childCount);</span>
                    // We can do this because adjustRowBy won't descend
                    // the children.
<span class="nc" id="L1179">                    adjustRowBy(-childCount, 0);</span>
<span class="nc" id="L1180">                }</span>
                else
<span class="nc" id="L1182">                    isExpanded = false;</span>

<span class="nc bnc" id="L1184" title="All 6 branches missed.">                if(adjustRows &amp;&amp; isVisible() &amp;&amp; treeSelectionModel != null)</span>
<span class="nc" id="L1185">                    treeSelectionModel.resetRowSelection();</span>
            }
<span class="nc" id="L1187">        }</span>

        /**
         * Returns true if the receiver is a leaf.
         */
        public boolean isLeaf() {
<span class="nc" id="L1193">            TreeModel model = getModel();</span>

<span class="nc bnc" id="L1195" title="All 2 branches missed.">            return (model != null) ? model.isLeaf(this.getUserObject()) :</span>
                   true;
        }

        /**
         * Adds newChild to this nodes children at the appropriate location.
         * The location is determined from the childIndex of newChild.
         */
        protected void addNode(FHTreeStateNode newChild) {
<span class="nc" id="L1204">            boolean         added = false;</span>
<span class="nc" id="L1205">            int             childIndex = newChild.getChildIndex();</span>

<span class="nc" id="L1207">            for(int counter = 0, maxCounter = getChildCount();</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                counter &lt; maxCounter; counter++) {</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">                if(((FHTreeStateNode)getChildAt(counter)).getChildIndex() &gt;</span>
                   childIndex) {
<span class="nc" id="L1211">                    added = true;</span>
<span class="nc" id="L1212">                    insert(newChild, counter);</span>
<span class="nc" id="L1213">                    counter = maxCounter;</span>
                }
            }
<span class="nc bnc" id="L1216" title="All 2 branches missed.">            if(!added)</span>
<span class="nc" id="L1217">                add(newChild);</span>
<span class="nc" id="L1218">        }</span>

        /**
         * Removes the child at &lt;code&gt;modelIndex&lt;/code&gt;.
         * &lt;code&gt;isChildVisible&lt;/code&gt; should be true if the receiver
         * is visible and expanded.
         */
        protected void removeChildAtModelIndex(int modelIndex,
                                               boolean isChildVisible) {
<span class="nc" id="L1227">            FHTreeStateNode     childNode = getChildAtModelIndex(modelIndex);</span>

<span class="nc bnc" id="L1229" title="All 2 branches missed.">            if(childNode != null) {</span>
<span class="nc" id="L1230">                int          row = childNode.getRow();</span>
<span class="nc" id="L1231">                int          index = getIndex(childNode);</span>

<span class="nc" id="L1233">                childNode.collapse(false);</span>
<span class="nc" id="L1234">                remove(index);</span>
<span class="nc" id="L1235">                adjustChildIndexs(index, -1);</span>
<span class="nc" id="L1236">                childCount--;</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">                if(isChildVisible) {</span>
                    // Adjust the rows.
<span class="nc" id="L1239">                    resetChildrenRowsFrom(row, index, modelIndex);</span>
                }
<span class="nc" id="L1241">            }</span>
            else {
<span class="nc" id="L1243">                int                  maxCounter = getChildCount();</span>
                FHTreeStateNode      aChild;

<span class="nc bnc" id="L1246" title="All 2 branches missed.">                for(int counter = 0; counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L1247">                    aChild = (FHTreeStateNode)getChildAt(counter);</span>
<span class="nc bnc" id="L1248" title="All 2 branches missed.">                    if(aChild.childIndex &gt;= modelIndex) {</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                        if(isChildVisible) {</span>
<span class="nc" id="L1250">                            adjustRowBy(-1, counter);</span>
<span class="nc" id="L1251">                            adjustRowCountBy(-1);</span>
                        }
                        // Since matched and children are always sorted by
                        // index, no need to continue testing with the
                        // above.
<span class="nc bnc" id="L1256" title="All 2 branches missed.">                        for(; counter &lt; maxCounter; counter++)</span>
<span class="nc" id="L1257">                            ((FHTreeStateNode)getChildAt(counter)).</span>
                                              childIndex--;
<span class="nc" id="L1259">                        childCount--;</span>
<span class="nc" id="L1260">                        return;</span>
                    }
                }
                // No children to adjust, but it was a child, so we still need
                // to adjust nodes after this one.
<span class="nc bnc" id="L1265" title="All 2 branches missed.">                if(isChildVisible) {</span>
<span class="nc" id="L1266">                    adjustRowBy(-1, maxCounter);</span>
<span class="nc" id="L1267">                    adjustRowCountBy(-1);</span>
                }
<span class="nc" id="L1269">                childCount--;</span>
            }
<span class="nc" id="L1271">        }</span>

        /**
         * Adjusts the child indexs of the receivers children by
         * &lt;code&gt;amount&lt;/code&gt;, starting at &lt;code&gt;index&lt;/code&gt;.
         */
        protected void adjustChildIndexs(int index, int amount) {
<span class="nc" id="L1278">            for(int counter = index, maxCounter = getChildCount();</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">                counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L1280">                ((FHTreeStateNode)getChildAt(counter)).childIndex += amount;</span>
            }
<span class="nc" id="L1282">        }</span>

        /**
         * Messaged when a child has been inserted at index. For all the
         * children that have a childIndex &gt;= index their index is incremented
         * by one.
         */
        protected void childInsertedAtModelIndex(int index,
                                               boolean isExpandedAndVisible) {
            FHTreeStateNode                aChild;
<span class="nc" id="L1292">            int                            maxCounter = getChildCount();</span>

<span class="nc bnc" id="L1294" title="All 2 branches missed.">            for(int counter = 0; counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L1295">                aChild = (FHTreeStateNode)getChildAt(counter);</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">                if(aChild.childIndex &gt;= index) {</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                    if(isExpandedAndVisible) {</span>
<span class="nc" id="L1298">                        adjustRowBy(1, counter);</span>
<span class="nc" id="L1299">                        adjustRowCountBy(1);</span>
                    }
                    /* Since matched and children are always sorted by
                       index, no need to continue testing with the above. */
<span class="nc bnc" id="L1303" title="All 2 branches missed.">                    for(; counter &lt; maxCounter; counter++)</span>
<span class="nc" id="L1304">                        ((FHTreeStateNode)getChildAt(counter)).childIndex++;</span>
<span class="nc" id="L1305">                    childCount++;</span>
<span class="nc" id="L1306">                    return;</span>
                }
            }
            // No children to adjust, but it was a child, so we still need
            // to adjust nodes after this one.
<span class="nc bnc" id="L1311" title="All 2 branches missed.">            if(isExpandedAndVisible) {</span>
<span class="nc" id="L1312">                adjustRowBy(1, maxCounter);</span>
<span class="nc" id="L1313">                adjustRowCountBy(1);</span>
            }
<span class="nc" id="L1315">            childCount++;</span>
<span class="nc" id="L1316">        }</span>

        /**
         * Returns true if there is a row for &lt;code&gt;row&lt;/code&gt;.
         * &lt;code&gt;nextRow&lt;/code&gt; gives the bounds of the receiver.
         * Information about the found row is returned in &lt;code&gt;info&lt;/code&gt;.
         * This should be invoked on root with &lt;code&gt;nextRow&lt;/code&gt; set
         * to &lt;code&gt;getRowCount&lt;/code&gt;().
         */
        protected boolean getPathForRow(int row, int nextRow,
                                        SearchInfo info) {
<span class="nc bnc" id="L1327" title="All 2 branches missed.">            if(this.row == row) {</span>
<span class="nc" id="L1328">                info.node = this;</span>
<span class="nc" id="L1329">                info.isNodeParentNode = false;</span>
<span class="nc" id="L1330">                info.childIndex = childIndex;</span>
<span class="nc" id="L1331">                return true;</span>
            }

            FHTreeStateNode            child;
<span class="nc" id="L1335">            FHTreeStateNode            lastChild = null;</span>

<span class="nc" id="L1337">            for(int counter = 0, maxCounter = getChildCount();</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">                counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L1339">                child = (FHTreeStateNode)getChildAt(counter);</span>
<span class="nc bnc" id="L1340" title="All 2 branches missed.">                if(child.row &gt; row) {</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">                    if(counter == 0) {</span>
                        // No node exists for it, and is first.
<span class="nc" id="L1343">                        info.node = this;</span>
<span class="nc" id="L1344">                        info.isNodeParentNode = true;</span>
<span class="nc" id="L1345">                        info.childIndex = row - this.row - 1;</span>
<span class="nc" id="L1346">                        return true;</span>
                    }
                    else {
                        // May have been in last child's bounds.
<span class="nc" id="L1350">                        int          lastChildEndRow = 1 + child.row -</span>
                                     (child.childIndex - lastChild.childIndex);

<span class="nc bnc" id="L1353" title="All 2 branches missed.">                        if(row &lt; lastChildEndRow) {</span>
<span class="nc" id="L1354">                            return lastChild.getPathForRow(row,</span>
                                                       lastChildEndRow, info);
                        }
                        // Between last child and child, but not in last child
<span class="nc" id="L1358">                        info.node = this;</span>
<span class="nc" id="L1359">                        info.isNodeParentNode = true;</span>
<span class="nc" id="L1360">                        info.childIndex = row - lastChildEndRow +</span>
                                                lastChild.childIndex + 1;
<span class="nc" id="L1362">                        return true;</span>
                    }
                }
<span class="nc" id="L1365">                lastChild = child;</span>
            }

            // Not in children, but we should have it, offset from
            // nextRow.
<span class="nc bnc" id="L1370" title="All 2 branches missed.">            if(lastChild != null) {</span>
<span class="nc" id="L1371">                int        lastChildEndRow = nextRow -</span>
                                  (childCount - lastChild.childIndex) + 1;

<span class="nc bnc" id="L1374" title="All 2 branches missed.">                if(row &lt; lastChildEndRow) {</span>
<span class="nc" id="L1375">                    return lastChild.getPathForRow(row, lastChildEndRow, info);</span>
                }
                // Between last child and child, but not in last child
<span class="nc" id="L1378">                info.node = this;</span>
<span class="nc" id="L1379">                info.isNodeParentNode = true;</span>
<span class="nc" id="L1380">                info.childIndex = row - lastChildEndRow +</span>
                                             lastChild.childIndex + 1;
<span class="nc" id="L1382">                return true;</span>
            }
            else {
                // No children.
<span class="nc" id="L1386">                int         retChildIndex = row - this.row - 1;</span>

<span class="nc bnc" id="L1388" title="All 2 branches missed.">                if(retChildIndex &gt;= childCount) {</span>
<span class="nc" id="L1389">                    return false;</span>
                }
<span class="nc" id="L1391">                info.node = this;</span>
<span class="nc" id="L1392">                info.isNodeParentNode = true;</span>
<span class="nc" id="L1393">                info.childIndex = retChildIndex;</span>
<span class="nc" id="L1394">                return true;</span>
            }
        }

        /**
         * Asks all the children of the receiver for their totalChildCount
         * and returns this value (plus stopIndex).
         */
        protected int getCountTo(int stopIndex) {
            FHTreeStateNode    aChild;
<span class="nc" id="L1404">            int                retCount = stopIndex + 1;</span>

<span class="nc" id="L1406">            for(int counter = 0, maxCounter = getChildCount();</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">                counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L1408">                aChild = (FHTreeStateNode)getChildAt(counter);</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">                if(aChild.childIndex &gt;= stopIndex)</span>
<span class="nc" id="L1410">                    counter = maxCounter;</span>
                else
<span class="nc" id="L1412">                    retCount += aChild.getTotalChildCount();</span>
            }
<span class="nc bnc" id="L1414" title="All 2 branches missed.">            if(parent != null)</span>
<span class="nc" id="L1415">                return retCount + ((FHTreeStateNode)getParent())</span>
<span class="nc" id="L1416">                                   .getCountTo(childIndex);</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">            if(!isRootVisible())</span>
<span class="nc" id="L1418">                return (retCount - 1);</span>
<span class="nc" id="L1419">            return retCount;</span>
        }

        /**
         * Returns the number of children that are expanded to
         * &lt;code&gt;stopIndex&lt;/code&gt;. This does not include the number
         * of children that the child at &lt;code&gt;stopIndex&lt;/code&gt; might
         * have.
         */
        protected int getNumExpandedChildrenTo(int stopIndex) {
            FHTreeStateNode    aChild;
<span class="nc" id="L1430">            int                retCount = stopIndex;</span>

<span class="nc" id="L1432">            for(int counter = 0, maxCounter = getChildCount();</span>
<span class="nc bnc" id="L1433" title="All 2 branches missed.">                counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L1434">                aChild = (FHTreeStateNode)getChildAt(counter);</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">                if(aChild.childIndex &gt;= stopIndex)</span>
<span class="nc" id="L1436">                    return retCount;</span>
                else {
<span class="nc" id="L1438">                    retCount += aChild.getTotalChildCount();</span>
                }
            }
<span class="nc" id="L1441">            return retCount;</span>
        }

        /**
         * Messaged when this node either expands or collapses.
         */
        protected void didAdjustTree() {
<span class="nc" id="L1448">        }</span>

    } // FixedHeightLayoutCache.FHTreeStateNode


    /**
     * Used as a placeholder when getting the path in FHTreeStateNodes.
     */
<span class="nc" id="L1456">    private class SearchInfo {</span>
        protected FHTreeStateNode   node;
        protected boolean           isNodeParentNode;
        protected int               childIndex;

        protected TreePath getPath() {
<span class="nc bnc" id="L1462" title="All 2 branches missed.">            if(node == null)</span>
<span class="nc" id="L1463">                return null;</span>

<span class="nc bnc" id="L1465" title="All 2 branches missed.">            if(isNodeParentNode)</span>
<span class="nc" id="L1466">                return node.getTreePath().pathByAddingChild(treeModel.getChild</span>
<span class="nc" id="L1467">                                            (node.getUserObject(),</span>
                                             childIndex));
<span class="nc" id="L1469">            return node.path;</span>
        }
    } // FixedHeightLayoutCache.SearchInfo


    /**
     * An enumerator to iterate through visible nodes.
     */
    // This is very similar to
    // VariableHeightTreeState.VisibleTreeStateNodeEnumeration
    private class VisibleFHTreeStateNodeEnumeration
        implements Enumeration&lt;TreePath&gt;
    {
        /** Parent thats children are being enumerated. */
        protected FHTreeStateNode     parent;
        /** Index of next child. An index of -1 signifies parent should be
         * visibled next. */
        protected int                 nextIndex;
        /** Number of children in parent. */
        protected int                 childCount;

        protected VisibleFHTreeStateNodeEnumeration(FHTreeStateNode node) {
<span class="nc" id="L1491">            this(node, -1);</span>
<span class="nc" id="L1492">        }</span>

        protected VisibleFHTreeStateNodeEnumeration(FHTreeStateNode parent,
<span class="nc" id="L1495">                                                    int startIndex) {</span>
<span class="nc" id="L1496">            this.parent = parent;</span>
<span class="nc" id="L1497">            this.nextIndex = startIndex;</span>
<span class="nc" id="L1498">            this.childCount = treeModel.getChildCount(this.parent.</span>
<span class="nc" id="L1499">                                                      getUserObject());</span>
<span class="nc" id="L1500">        }</span>

        /**
         * @return true if more visible nodes.
         */
        public boolean hasMoreElements() {
<span class="nc bnc" id="L1506" title="All 2 branches missed.">            return (parent != null);</span>
        }

        /**
         * @return next visible TreePath.
         */
        public TreePath nextElement() {
<span class="nc bnc" id="L1513" title="All 2 branches missed.">            if(!hasMoreElements())</span>
<span class="nc" id="L1514">                throw new NoSuchElementException(&quot;No more visible paths&quot;);</span>

            TreePath                retObject;

<span class="nc bnc" id="L1518" title="All 2 branches missed.">            if(nextIndex == -1)</span>
<span class="nc" id="L1519">                retObject = parent.getTreePath();</span>
            else {
<span class="nc" id="L1521">                FHTreeStateNode  node = parent.getChildAtModelIndex(nextIndex);</span>

<span class="nc bnc" id="L1523" title="All 2 branches missed.">                if(node == null)</span>
<span class="nc" id="L1524">                    retObject = parent.getTreePath().pathByAddingChild</span>
<span class="nc" id="L1525">                                  (treeModel.getChild(parent.getUserObject(),</span>
                                                      nextIndex));
                else
<span class="nc" id="L1528">                    retObject = node.getTreePath();</span>
            }
<span class="nc" id="L1530">            updateNextObject();</span>
<span class="nc" id="L1531">            return retObject;</span>
        }

        /**
         * Determines the next object by invoking &lt;code&gt;updateNextIndex&lt;/code&gt;
         * and if not succesful &lt;code&gt;findNextValidParent&lt;/code&gt;.
         */
        protected void updateNextObject() {
<span class="nc bnc" id="L1539" title="All 2 branches missed.">            if(!updateNextIndex()) {</span>
<span class="nc" id="L1540">                findNextValidParent();</span>
            }
<span class="nc" id="L1542">        }</span>

        /**
         * Finds the next valid parent, this should be called when nextIndex
         * is beyond the number of children of the current parent.
         */
        protected boolean findNextValidParent() {
<span class="nc bnc" id="L1549" title="All 2 branches missed.">            if(parent == root) {</span>
                // mark as invalid!
<span class="nc" id="L1551">                parent = null;</span>
<span class="nc" id="L1552">                return false;</span>
            }
<span class="nc bnc" id="L1554" title="All 2 branches missed.">            while(parent != null) {</span>
<span class="nc" id="L1555">                FHTreeStateNode      newParent = (FHTreeStateNode)parent.</span>
<span class="nc" id="L1556">                                                  getParent();</span>

<span class="nc bnc" id="L1558" title="All 2 branches missed.">                if(newParent != null) {</span>
<span class="nc" id="L1559">                    nextIndex = parent.childIndex;</span>
<span class="nc" id="L1560">                    parent = newParent;</span>
<span class="nc" id="L1561">                    childCount = treeModel.getChildCount</span>
<span class="nc" id="L1562">                                            (parent.getUserObject());</span>
<span class="nc bnc" id="L1563" title="All 2 branches missed.">                    if(updateNextIndex())</span>
<span class="nc" id="L1564">                        return true;</span>
                }
                else
<span class="nc" id="L1567">                    parent = null;</span>
<span class="nc" id="L1568">            }</span>
<span class="nc" id="L1569">            return false;</span>
        }

        /**
         * Updates &lt;code&gt;nextIndex&lt;/code&gt; returning false if it is beyond
         * the number of children of parent.
         */
        protected boolean updateNextIndex() {
            // nextIndex == -1 identifies receiver, make sure is expanded
            // before descend.
<span class="nc bnc" id="L1579" title="All 4 branches missed.">            if(nextIndex == -1 &amp;&amp; !parent.isExpanded()) {</span>
<span class="nc" id="L1580">                return false;</span>
            }

            // Check that it can have kids
<span class="nc bnc" id="L1584" title="All 2 branches missed.">            if(childCount == 0) {</span>
<span class="nc" id="L1585">                return false;</span>
            }
            // Make sure next index not beyond child count.
<span class="nc bnc" id="L1588" title="All 2 branches missed.">            else if(++nextIndex &gt;= childCount) {</span>
<span class="nc" id="L1589">                return false;</span>
            }

<span class="nc" id="L1592">            FHTreeStateNode    child = parent.getChildAtModelIndex(nextIndex);</span>

<span class="nc bnc" id="L1594" title="All 4 branches missed.">            if(child != null &amp;&amp; child.isExpanded()) {</span>
<span class="nc" id="L1595">                parent = child;</span>
<span class="nc" id="L1596">                nextIndex = -1;</span>
<span class="nc" id="L1597">                childCount = treeModel.getChildCount(child.getUserObject());</span>
            }
<span class="nc" id="L1599">            return true;</span>
        }
    } // FixedHeightLayoutCache.VisibleFHTreeStateNodeEnumeration
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>