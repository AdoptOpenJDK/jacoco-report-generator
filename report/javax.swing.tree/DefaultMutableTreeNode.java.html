<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultMutableTreeNode.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.tree</a> &gt; <span class="el_source">DefaultMutableTreeNode.java</span></div><h1>DefaultMutableTreeNode.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.tree;
   // ISSUE: this class depends on nothing in AWT -- move to java.util?

import java.beans.Transient;
import java.io.*;
import java.util.*;


/**
 * A &lt;code&gt;DefaultMutableTreeNode&lt;/code&gt; is a general-purpose node in a tree data
 * structure.
 * For examples of using default mutable tree nodes, see
 * &lt;a
 href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;How to Use Trees&lt;/a&gt;
 * in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 *
 * &lt;p&gt;
 *
 * A tree node may have at most one parent and 0 or more children.
 * &lt;code&gt;DefaultMutableTreeNode&lt;/code&gt; provides operations for examining and modifying a
 * node's parent and children and also operations for examining the tree that
 * the node is a part of.  A node's tree is the set of all nodes that can be
 * reached by starting at the node and following all the possible links to
 * parents and children.  A node with no parent is the root of its tree; a
 * node with no children is a leaf.  A tree may consist of many subtrees,
 * each node acting as the root for its own subtree.
 * &lt;p&gt;
 * This class provides enumerations for efficiently traversing a tree or
 * subtree in various orders or for following the path between two nodes.
 * A &lt;code&gt;DefaultMutableTreeNode&lt;/code&gt; may also hold a reference to a user object, the
 * use of which is left to the user.  Asking a &lt;code&gt;DefaultMutableTreeNode&lt;/code&gt; for its
 * string representation with &lt;code&gt;toString()&lt;/code&gt; returns the string
 * representation of its user object.
 * &lt;p&gt;
 * &lt;b&gt;This is not a thread safe class.&lt;/b&gt;If you intend to use
 * a DefaultMutableTreeNode (or a tree of TreeNodes) in more than one thread, you
 * need to do your own synchronizing. A good convention to adopt is
 * synchronizing on the root node of a tree.
 * &lt;p&gt;
 * While DefaultMutableTreeNode implements the MutableTreeNode interface and
 * will allow you to add in any implementation of MutableTreeNode not all
 * of the methods in DefaultMutableTreeNode will be applicable to all
 * MutableTreeNodes implementations. Especially with some of the enumerations
 * that are provided, using some of these methods assumes the
 * DefaultMutableTreeNode contains only DefaultMutableNode instances. All
 * of the TreeNode/MutableTreeNode methods will behave as defined no
 * matter what implementations are added.
 *
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see MutableTreeNode
 *
 * @author Rob Davis
 */
public class DefaultMutableTreeNode implements Cloneable,
       MutableTreeNode, Serializable
{
    private static final long serialVersionUID = -4298474751201349152L;

    /**
     * An enumeration that is always empty. This is used when an enumeration
     * of a leaf node's children is requested.
     */
<span class="nc" id="L97">    static public final Enumeration&lt;TreeNode&gt; EMPTY_ENUMERATION</span>
<span class="nc" id="L98">        = Collections.emptyEnumeration();</span>

    /** this node's parent, or null if this node has no parent */
    protected MutableTreeNode   parent;

    /** array of children, may be null if this node has no children */
    protected Vector children;

    /** optional user object */
    transient protected Object  userObject;

    /** true if the node is able to have children */
    protected boolean           allowsChildren;


    /**
     * Creates a tree node that has no parent and no children, but which
     * allows children.
     */
    public DefaultMutableTreeNode() {
<span class="nc" id="L118">        this(null);</span>
<span class="nc" id="L119">    }</span>

    /**
     * Creates a tree node with no parent, no children, but which allows
     * children, and initializes it with the specified user object.
     *
     * @param userObject an Object provided by the user that constitutes
     *                   the node's data
     */
    public DefaultMutableTreeNode(Object userObject) {
<span class="nc" id="L129">        this(userObject, true);</span>
<span class="nc" id="L130">    }</span>

    /**
     * Creates a tree node with no parent, no children, initialized with
     * the specified user object, and that allows children only if
     * specified.
     *
     * @param userObject an Object provided by the user that constitutes
     *        the node's data
     * @param allowsChildren if true, the node is allowed to have child
     *        nodes -- otherwise, it is always a leaf node
     */
    public DefaultMutableTreeNode(Object userObject, boolean allowsChildren) {
<span class="nc" id="L143">        super();</span>
<span class="nc" id="L144">        parent = null;</span>
<span class="nc" id="L145">        this.allowsChildren = allowsChildren;</span>
<span class="nc" id="L146">        this.userObject = userObject;</span>
<span class="nc" id="L147">    }</span>


    //
    //  Primitives
    //

    /**
     * Removes &lt;code&gt;newChild&lt;/code&gt; from its present parent (if it has a
     * parent), sets the child's parent to this node, and then adds the child
     * to this node's child array at index &lt;code&gt;childIndex&lt;/code&gt;.
     * &lt;code&gt;newChild&lt;/code&gt; must not be null and must not be an ancestor of
     * this node.
     *
     * @param   newChild        the MutableTreeNode to insert under this node
     * @param   childIndex      the index in this node's child array
     *                          where this node is to be inserted
     * @exception       ArrayIndexOutOfBoundsException  if
     *                          &lt;code&gt;childIndex&lt;/code&gt; is out of bounds
     * @exception       IllegalArgumentException        if
     *                          &lt;code&gt;newChild&lt;/code&gt; is null or is an
     *                          ancestor of this node
     * @exception       IllegalStateException   if this node does not allow
     *                                          children
     * @see     #isNodeDescendant
     */
    public void insert(MutableTreeNode newChild, int childIndex) {
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (!allowsChildren) {</span>
<span class="nc" id="L175">            throw new IllegalStateException(&quot;node does not allow children&quot;);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        } else if (newChild == null) {</span>
<span class="nc" id="L177">            throw new IllegalArgumentException(&quot;new child is null&quot;);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        } else if (isNodeAncestor(newChild)) {</span>
<span class="nc" id="L179">            throw new IllegalArgumentException(&quot;new child is an ancestor&quot;);</span>
        }

<span class="nc" id="L182">            MutableTreeNode oldParent = (MutableTreeNode)newChild.getParent();</span>

<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (oldParent != null) {</span>
<span class="nc" id="L185">                oldParent.remove(newChild);</span>
            }
<span class="nc" id="L187">            newChild.setParent(this);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (children == null) {</span>
<span class="nc" id="L189">                children = new Vector();</span>
            }
<span class="nc" id="L191">            children.insertElementAt(newChild, childIndex);</span>
<span class="nc" id="L192">    }</span>

    /**
     * Removes the child at the specified index from this node's children
     * and sets that node's parent to null. The child node to remove
     * must be a &lt;code&gt;MutableTreeNode&lt;/code&gt;.
     *
     * @param   childIndex      the index in this node's child array
     *                          of the child to remove
     * @exception       ArrayIndexOutOfBoundsException  if
     *                          &lt;code&gt;childIndex&lt;/code&gt; is out of bounds
     */
    public void remove(int childIndex) {
<span class="nc" id="L205">        MutableTreeNode child = (MutableTreeNode)getChildAt(childIndex);</span>
<span class="nc" id="L206">        children.removeElementAt(childIndex);</span>
<span class="nc" id="L207">        child.setParent(null);</span>
<span class="nc" id="L208">    }</span>

    /**
     * Sets this node's parent to &lt;code&gt;newParent&lt;/code&gt; but does not
     * change the parent's child array.  This method is called from
     * &lt;code&gt;insert()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt; to
     * reassign a child's parent, it should not be messaged from anywhere
     * else.
     *
     * @param   newParent       this node's new parent
     */
    @Transient
    public void setParent(MutableTreeNode newParent) {
<span class="nc" id="L221">        parent = newParent;</span>
<span class="nc" id="L222">    }</span>

    /**
     * Returns this node's parent or null if this node has no parent.
     *
     * @return  this node's parent TreeNode, or null if this node has no parent
     */
    public TreeNode getParent() {
<span class="nc" id="L230">        return parent;</span>
    }

    /**
     * Returns the child at the specified index in this node's child array.
     *
     * @param   index   an index into this node's child array
     * @exception       ArrayIndexOutOfBoundsException  if &lt;code&gt;index&lt;/code&gt;
     *                                          is out of bounds
     * @return  the TreeNode in this node's child array at  the specified index
     */
    public TreeNode getChildAt(int index) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (children == null) {</span>
<span class="nc" id="L243">            throw new ArrayIndexOutOfBoundsException(&quot;node has no children&quot;);</span>
        }
<span class="nc" id="L245">        return (TreeNode)children.elementAt(index);</span>
    }

    /**
     * Returns the number of children of this node.
     *
     * @return  an int giving the number of children of this node
     */
    public int getChildCount() {
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (children == null) {</span>
<span class="nc" id="L255">            return 0;</span>
        } else {
<span class="nc" id="L257">            return children.size();</span>
        }
    }

    /**
     * Returns the index of the specified child in this node's child array.
     * If the specified node is not a child of this node, returns
     * &lt;code&gt;-1&lt;/code&gt;.  This method performs a linear search and is O(n)
     * where n is the number of children.
     *
     * @param   aChild  the TreeNode to search for among this node's children
     * @exception       IllegalArgumentException        if &lt;code&gt;aChild&lt;/code&gt;
     *                                                  is null
     * @return  an int giving the index of the node in this node's child
     *          array, or &lt;code&gt;-1&lt;/code&gt; if the specified node is a not
     *          a child of this node
     */
    public int getIndex(TreeNode aChild) {
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (aChild == null) {</span>
<span class="nc" id="L276">            throw new IllegalArgumentException(&quot;argument is null&quot;);</span>
        }

<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (!isNodeChild(aChild)) {</span>
<span class="nc" id="L280">            return -1;</span>
        }
<span class="nc" id="L282">        return children.indexOf(aChild);        // linear search</span>
    }

    /**
     * Creates and returns a forward-order enumeration of this node's
     * children.  Modifying this node's child array invalidates any child
     * enumerations created before the modification.
     *
     * @return  an Enumeration of this node's children
     */
    public Enumeration children() {
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (children == null) {</span>
<span class="nc" id="L294">            return EMPTY_ENUMERATION;</span>
        } else {
<span class="nc" id="L296">            return children.elements();</span>
        }
    }

    /**
     * Determines whether or not this node is allowed to have children.
     * If &lt;code&gt;allows&lt;/code&gt; is false, all of this node's children are
     * removed.
     * &lt;p&gt;
     * Note: By default, a node allows children.
     *
     * @param   allows  true if this node is allowed to have children
     */
    public void setAllowsChildren(boolean allows) {
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (allows != allowsChildren) {</span>
<span class="nc" id="L311">            allowsChildren = allows;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            if (!allowsChildren) {</span>
<span class="nc" id="L313">                removeAllChildren();</span>
            }
        }
<span class="nc" id="L316">    }</span>

    /**
     * Returns true if this node is allowed to have children.
     *
     * @return  true if this node allows children, else false
     */
    public boolean getAllowsChildren() {
<span class="nc" id="L324">        return allowsChildren;</span>
    }

    /**
     * Sets the user object for this node to &lt;code&gt;userObject&lt;/code&gt;.
     *
     * @param   userObject      the Object that constitutes this node's
     *                          user-specified data
     * @see     #getUserObject
     * @see     #toString
     */
    public void setUserObject(Object userObject) {
<span class="nc" id="L336">        this.userObject = userObject;</span>
<span class="nc" id="L337">    }</span>

    /**
     * Returns this node's user object.
     *
     * @return  the Object stored at this node by the user
     * @see     #setUserObject
     * @see     #toString
     */
    public Object getUserObject() {
<span class="nc" id="L347">        return userObject;</span>
    }


    //
    //  Derived methods
    //

    /**
     * Removes the subtree rooted at this node from the tree, giving this
     * node a null parent.  Does nothing if this node is the root of its
     * tree.
     */
    public void removeFromParent() {
<span class="nc" id="L361">        MutableTreeNode parent = (MutableTreeNode)getParent();</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L363">            parent.remove(this);</span>
        }
<span class="nc" id="L365">    }</span>

    /**
     * Removes &lt;code&gt;aChild&lt;/code&gt; from this node's child array, giving it a
     * null parent.
     *
     * @param   aChild  a child of this node to remove
     * @exception       IllegalArgumentException        if &lt;code&gt;aChild&lt;/code&gt;
     *                                  is null or is not a child of this node
     */
    public void remove(MutableTreeNode aChild) {
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (aChild == null) {</span>
<span class="nc" id="L377">            throw new IllegalArgumentException(&quot;argument is null&quot;);</span>
        }

<span class="nc bnc" id="L380" title="All 2 branches missed.">        if (!isNodeChild(aChild)) {</span>
<span class="nc" id="L381">            throw new IllegalArgumentException(&quot;argument is not a child&quot;);</span>
        }
<span class="nc" id="L383">        remove(getIndex(aChild));       // linear search</span>
<span class="nc" id="L384">    }</span>

    /**
     * Removes all of this node's children, setting their parents to null.
     * If this node has no children, this method does nothing.
     */
    public void removeAllChildren() {
<span class="nc bnc" id="L391" title="All 2 branches missed.">        for (int i = getChildCount()-1; i &gt;= 0; i--) {</span>
<span class="nc" id="L392">            remove(i);</span>
        }
<span class="nc" id="L394">    }</span>

    /**
     * Removes &lt;code&gt;newChild&lt;/code&gt; from its parent and makes it a child of
     * this node by adding it to the end of this node's child array.
     *
     * @see             #insert
     * @param   newChild        node to add as a child of this node
     * @exception       IllegalArgumentException    if &lt;code&gt;newChild&lt;/code&gt;
     *                                          is null
     * @exception       IllegalStateException   if this node does not allow
     *                                          children
     */
    public void add(MutableTreeNode newChild) {
<span class="nc bnc" id="L408" title="All 4 branches missed.">        if(newChild != null &amp;&amp; newChild.getParent() == this)</span>
<span class="nc" id="L409">            insert(newChild, getChildCount() - 1);</span>
        else
<span class="nc" id="L411">            insert(newChild, getChildCount());</span>
<span class="nc" id="L412">    }</span>



    //
    //  Tree Queries
    //

    /**
     * Returns true if &lt;code&gt;anotherNode&lt;/code&gt; is an ancestor of this node
     * -- if it is this node, this node's parent, or an ancestor of this
     * node's parent.  (Note that a node is considered an ancestor of itself.)
     * If &lt;code&gt;anotherNode&lt;/code&gt; is null, this method returns false.  This
     * operation is at worst O(h) where h is the distance from the root to
     * this node.
     *
     * @see             #isNodeDescendant
     * @see             #getSharedAncestor
     * @param   anotherNode     node to test as an ancestor of this node
     * @return  true if this node is a descendant of &lt;code&gt;anotherNode&lt;/code&gt;
     */
    public boolean isNodeAncestor(TreeNode anotherNode) {
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (anotherNode == null) {</span>
<span class="nc" id="L435">            return false;</span>
        }

<span class="nc" id="L438">        TreeNode ancestor = this;</span>

        do {
<span class="nc bnc" id="L441" title="All 2 branches missed.">            if (ancestor == anotherNode) {</span>
<span class="nc" id="L442">                return true;</span>
            }
<span class="nc bnc" id="L444" title="All 2 branches missed.">        } while((ancestor = ancestor.getParent()) != null);</span>

<span class="nc" id="L446">        return false;</span>
    }

    /**
     * Returns true if &lt;code&gt;anotherNode&lt;/code&gt; is a descendant of this node
     * -- if it is this node, one of this node's children, or a descendant of
     * one of this node's children.  Note that a node is considered a
     * descendant of itself.  If &lt;code&gt;anotherNode&lt;/code&gt; is null, returns
     * false.  This operation is at worst O(h) where h is the distance from the
     * root to &lt;code&gt;anotherNode&lt;/code&gt;.
     *
     * @see     #isNodeAncestor
     * @see     #getSharedAncestor
     * @param   anotherNode     node to test as descendant of this node
     * @return  true if this node is an ancestor of &lt;code&gt;anotherNode&lt;/code&gt;
     */
    public boolean isNodeDescendant(DefaultMutableTreeNode anotherNode) {
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (anotherNode == null)</span>
<span class="nc" id="L464">            return false;</span>

<span class="nc" id="L466">        return anotherNode.isNodeAncestor(this);</span>
    }

    /**
     * Returns the nearest common ancestor to this node and &lt;code&gt;aNode&lt;/code&gt;.
     * Returns null, if no such ancestor exists -- if this node and
     * &lt;code&gt;aNode&lt;/code&gt; are in different trees or if &lt;code&gt;aNode&lt;/code&gt; is
     * null.  A node is considered an ancestor of itself.
     *
     * @see     #isNodeAncestor
     * @see     #isNodeDescendant
     * @param   aNode   node to find common ancestor with
     * @return  nearest ancestor common to this node and &lt;code&gt;aNode&lt;/code&gt;,
     *          or null if none
     */
    public TreeNode getSharedAncestor(DefaultMutableTreeNode aNode) {
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (aNode == this) {</span>
<span class="nc" id="L483">            return this;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">        } else if (aNode == null) {</span>
<span class="nc" id="L485">            return null;</span>
        }

        int             level1, level2, diff;
        TreeNode        node1, node2;

<span class="nc" id="L491">        level1 = getLevel();</span>
<span class="nc" id="L492">        level2 = aNode.getLevel();</span>

<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (level2 &gt; level1) {</span>
<span class="nc" id="L495">            diff = level2 - level1;</span>
<span class="nc" id="L496">            node1 = aNode;</span>
<span class="nc" id="L497">            node2 = this;</span>
        } else {
<span class="nc" id="L499">            diff = level1 - level2;</span>
<span class="nc" id="L500">            node1 = this;</span>
<span class="nc" id="L501">            node2 = aNode;</span>
        }

        // Go up the tree until the nodes are at the same level
<span class="nc bnc" id="L505" title="All 2 branches missed.">        while (diff &gt; 0) {</span>
<span class="nc" id="L506">            node1 = node1.getParent();</span>
<span class="nc" id="L507">            diff--;</span>
        }

        // Move up the tree until we find a common ancestor.  Since we know
        // that both nodes are at the same level, we won't cross paths
        // unknowingly (if there is a common ancestor, both nodes hit it in
        // the same iteration).

        do {
<span class="nc bnc" id="L516" title="All 2 branches missed.">            if (node1 == node2) {</span>
<span class="nc" id="L517">                return node1;</span>
            }
<span class="nc" id="L519">            node1 = node1.getParent();</span>
<span class="nc" id="L520">            node2 = node2.getParent();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        } while (node1 != null);// only need to check one -- they're at the</span>
        // same level so if one is null, the other is

<span class="nc bnc" id="L524" title="All 4 branches missed.">        if (node1 != null || node2 != null) {</span>
<span class="nc" id="L525">            throw new Error (&quot;nodes should be null&quot;);</span>
        }

<span class="nc" id="L528">        return null;</span>
    }


    /**
     * Returns true if and only if &lt;code&gt;aNode&lt;/code&gt; is in the same tree
     * as this node.  Returns false if &lt;code&gt;aNode&lt;/code&gt; is null.
     *
     * @see     #getSharedAncestor
     * @see     #getRoot
     * @return  true if &lt;code&gt;aNode&lt;/code&gt; is in the same tree as this node;
     *          false if &lt;code&gt;aNode&lt;/code&gt; is null
     */
    public boolean isNodeRelated(DefaultMutableTreeNode aNode) {
<span class="nc bnc" id="L542" title="All 4 branches missed.">        return (aNode != null) &amp;&amp; (getRoot() == aNode.getRoot());</span>
    }


    /**
     * Returns the depth of the tree rooted at this node -- the longest
     * distance from this node to a leaf.  If this node has no children,
     * returns 0.  This operation is much more expensive than
     * &lt;code&gt;getLevel()&lt;/code&gt; because it must effectively traverse the entire
     * tree rooted at this node.
     *
     * @see     #getLevel
     * @return  the depth of the tree whose root is this node
     */
    public int getDepth() {
<span class="nc" id="L557">        Object  last = null;</span>
<span class="nc" id="L558">        Enumeration     enum_ = breadthFirstEnumeration();</span>

<span class="nc bnc" id="L560" title="All 2 branches missed.">        while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L561">            last = enum_.nextElement();</span>
        }

<span class="nc bnc" id="L564" title="All 2 branches missed.">        if (last == null) {</span>
<span class="nc" id="L565">            throw new Error (&quot;nodes should be null&quot;);</span>
        }

<span class="nc" id="L568">        return ((DefaultMutableTreeNode)last).getLevel() - getLevel();</span>
    }



    /**
     * Returns the number of levels above this node -- the distance from
     * the root to this node.  If this node is the root, returns 0.
     *
     * @see     #getDepth
     * @return  the number of levels above this node
     */
    public int getLevel() {
        TreeNode ancestor;
<span class="nc" id="L582">        int levels = 0;</span>

<span class="nc" id="L584">        ancestor = this;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        while((ancestor = ancestor.getParent()) != null){</span>
<span class="nc" id="L586">            levels++;</span>
        }

<span class="nc" id="L589">        return levels;</span>
    }


    /**
      * Returns the path from the root, to get to this node.  The last
      * element in the path is this node.
      *
      * @return an array of TreeNode objects giving the path, where the
      *         first element in the path is the root and the last
      *         element is this node.
      */
    public TreeNode[] getPath() {
<span class="nc" id="L602">        return getPathToRoot(this, 0);</span>
    }

    /**
     * Builds the parents of node up to and including the root node,
     * where the original node is the last element in the returned array.
     * The length of the returned array gives the node's depth in the
     * tree.
     *
     * @param aNode  the TreeNode to get the path for
     * @param depth  an int giving the number of steps already taken towards
     *        the root (on recursive calls), used to size the returned array
     * @return an array of TreeNodes giving the path from the root to the
     *         specified node
     */
    protected TreeNode[] getPathToRoot(TreeNode aNode, int depth) {
        TreeNode[]              retNodes;

        /* Check for null, in case someone passed in a null node, or
           they passed in an element that isn't rooted at root. */
<span class="nc bnc" id="L622" title="All 2 branches missed.">        if(aNode == null) {</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">            if(depth == 0)</span>
<span class="nc" id="L624">                return null;</span>
            else
<span class="nc" id="L626">                retNodes = new TreeNode[depth];</span>
        }
        else {
<span class="nc" id="L629">            depth++;</span>
<span class="nc" id="L630">            retNodes = getPathToRoot(aNode.getParent(), depth);</span>
<span class="nc" id="L631">            retNodes[retNodes.length - depth] = aNode;</span>
        }
<span class="nc" id="L633">        return retNodes;</span>
    }

    /**
      * Returns the user object path, from the root, to get to this node.
      * If some of the TreeNodes in the path have null user objects, the
      * returned path will contain nulls.
      */
    public Object[] getUserObjectPath() {
<span class="nc" id="L642">        TreeNode[]          realPath = getPath();</span>
<span class="nc" id="L643">        Object[]            retPath = new Object[realPath.length];</span>

<span class="nc bnc" id="L645" title="All 2 branches missed.">        for(int counter = 0; counter &lt; realPath.length; counter++)</span>
<span class="nc" id="L646">            retPath[counter] = ((DefaultMutableTreeNode)realPath[counter])</span>
<span class="nc" id="L647">                               .getUserObject();</span>
<span class="nc" id="L648">        return retPath;</span>
    }

    /**
     * Returns the root of the tree that contains this node.  The root is
     * the ancestor with a null parent.
     *
     * @see     #isNodeAncestor
     * @return  the root of the tree that contains this node
     */
    public TreeNode getRoot() {
<span class="nc" id="L659">        TreeNode ancestor = this;</span>
        TreeNode previous;

        do {
<span class="nc" id="L663">            previous = ancestor;</span>
<span class="nc" id="L664">            ancestor = ancestor.getParent();</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">        } while (ancestor != null);</span>

<span class="nc" id="L667">        return previous;</span>
    }


    /**
     * Returns true if this node is the root of the tree.  The root is
     * the only node in the tree with a null parent; every tree has exactly
     * one root.
     *
     * @return  true if this node is the root of its tree
     */
    public boolean isRoot() {
<span class="nc bnc" id="L679" title="All 2 branches missed.">        return getParent() == null;</span>
    }


    /**
     * Returns the node that follows this node in a preorder traversal of this
     * node's tree.  Returns null if this node is the last node of the
     * traversal.  This is an inefficient way to traverse the entire tree; use
     * an enumeration, instead.
     *
     * @see     #preorderEnumeration
     * @return  the node that follows this node in a preorder traversal, or
     *          null if this node is last
     */
    public DefaultMutableTreeNode getNextNode() {
<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (getChildCount() == 0) {</span>
            // No children, so look for nextSibling
<span class="nc" id="L696">            DefaultMutableTreeNode nextSibling = getNextSibling();</span>

<span class="nc bnc" id="L698" title="All 2 branches missed.">            if (nextSibling == null) {</span>
<span class="nc" id="L699">                DefaultMutableTreeNode aNode = (DefaultMutableTreeNode)getParent();</span>

                do {
<span class="nc bnc" id="L702" title="All 2 branches missed.">                    if (aNode == null) {</span>
<span class="nc" id="L703">                        return null;</span>
                    }

<span class="nc" id="L706">                    nextSibling = aNode.getNextSibling();</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">                    if (nextSibling != null) {</span>
<span class="nc" id="L708">                        return nextSibling;</span>
                    }

<span class="nc" id="L711">                    aNode = (DefaultMutableTreeNode)aNode.getParent();</span>
<span class="nc" id="L712">                } while(true);</span>
            } else {
<span class="nc" id="L714">                return nextSibling;</span>
            }
        } else {
<span class="nc" id="L717">            return (DefaultMutableTreeNode)getChildAt(0);</span>
        }
    }


    /**
     * Returns the node that precedes this node in a preorder traversal of
     * this node's tree.  Returns &lt;code&gt;null&lt;/code&gt; if this node is the
     * first node of the traversal -- the root of the tree.
     * This is an inefficient way to
     * traverse the entire tree; use an enumeration, instead.
     *
     * @see     #preorderEnumeration
     * @return  the node that precedes this node in a preorder traversal, or
     *          null if this node is the first
     */
    public DefaultMutableTreeNode getPreviousNode() {
        DefaultMutableTreeNode previousSibling;
<span class="nc" id="L735">        DefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();</span>

<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (myParent == null) {</span>
<span class="nc" id="L738">            return null;</span>
        }

<span class="nc" id="L741">        previousSibling = getPreviousSibling();</span>

<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (previousSibling != null) {</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (previousSibling.getChildCount() == 0)</span>
<span class="nc" id="L745">                return previousSibling;</span>
            else
<span class="nc" id="L747">                return previousSibling.getLastLeaf();</span>
        } else {
<span class="nc" id="L749">            return myParent;</span>
        }
    }

    /**
     * Creates and returns an enumeration that traverses the subtree rooted at
     * this node in preorder.  The first node returned by the enumeration's
     * &lt;code&gt;nextElement()&lt;/code&gt; method is this node.&lt;P&gt;
     *
     * Modifying the tree by inserting, removing, or moving a node invalidates
     * any enumerations created before the modification.
     *
     * @see     #postorderEnumeration
     * @return  an enumeration for traversing the tree in preorder
     */
    public Enumeration preorderEnumeration() {
<span class="nc" id="L765">        return new PreorderEnumeration(this);</span>
    }

    /**
     * Creates and returns an enumeration that traverses the subtree rooted at
     * this node in postorder.  The first node returned by the enumeration's
     * &lt;code&gt;nextElement()&lt;/code&gt; method is the leftmost leaf.  This is the
     * same as a depth-first traversal.&lt;P&gt;
     *
     * Modifying the tree by inserting, removing, or moving a node invalidates
     * any enumerations created before the modification.
     *
     * @see     #depthFirstEnumeration
     * @see     #preorderEnumeration
     * @return  an enumeration for traversing the tree in postorder
     */
    public Enumeration postorderEnumeration() {
<span class="nc" id="L782">        return new PostorderEnumeration(this);</span>
    }

    /**
     * Creates and returns an enumeration that traverses the subtree rooted at
     * this node in breadth-first order.  The first node returned by the
     * enumeration's &lt;code&gt;nextElement()&lt;/code&gt; method is this node.&lt;P&gt;
     *
     * Modifying the tree by inserting, removing, or moving a node invalidates
     * any enumerations created before the modification.
     *
     * @see     #depthFirstEnumeration
     * @return  an enumeration for traversing the tree in breadth-first order
     */
    public Enumeration breadthFirstEnumeration() {
<span class="nc" id="L797">        return new BreadthFirstEnumeration(this);</span>
    }

    /**
     * Creates and returns an enumeration that traverses the subtree rooted at
     * this node in depth-first order.  The first node returned by the
     * enumeration's &lt;code&gt;nextElement()&lt;/code&gt; method is the leftmost leaf.
     * This is the same as a postorder traversal.&lt;P&gt;
     *
     * Modifying the tree by inserting, removing, or moving a node invalidates
     * any enumerations created before the modification.
     *
     * @see     #breadthFirstEnumeration
     * @see     #postorderEnumeration
     * @return  an enumeration for traversing the tree in depth-first order
     */
    public Enumeration depthFirstEnumeration() {
<span class="nc" id="L814">        return postorderEnumeration();</span>
    }

    /**
     * Creates and returns an enumeration that follows the path from
     * &lt;code&gt;ancestor&lt;/code&gt; to this node.  The enumeration's
     * &lt;code&gt;nextElement()&lt;/code&gt; method first returns &lt;code&gt;ancestor&lt;/code&gt;,
     * then the child of &lt;code&gt;ancestor&lt;/code&gt; that is an ancestor of this
     * node, and so on, and finally returns this node.  Creation of the
     * enumeration is O(m) where m is the number of nodes between this node
     * and &lt;code&gt;ancestor&lt;/code&gt;, inclusive.  Each &lt;code&gt;nextElement()&lt;/code&gt;
     * message is O(1).&lt;P&gt;
     *
     * Modifying the tree by inserting, removing, or moving a node invalidates
     * any enumerations created before the modification.
     *
     * @see             #isNodeAncestor
     * @see             #isNodeDescendant
     * @exception       IllegalArgumentException if &lt;code&gt;ancestor&lt;/code&gt; is
     *                                          not an ancestor of this node
     * @return  an enumeration for following the path from an ancestor of
     *          this node to this one
     */
    public Enumeration pathFromAncestorEnumeration(TreeNode ancestor) {
<span class="nc" id="L838">        return new PathBetweenNodesEnumeration(ancestor, this);</span>
    }


    //
    //  Child Queries
    //

    /**
     * Returns true if &lt;code&gt;aNode&lt;/code&gt; is a child of this node.  If
     * &lt;code&gt;aNode&lt;/code&gt; is null, this method returns false.
     *
     * @return  true if &lt;code&gt;aNode&lt;/code&gt; is a child of this node; false if
     *                  &lt;code&gt;aNode&lt;/code&gt; is null
     */
    public boolean isNodeChild(TreeNode aNode) {
        boolean retval;

<span class="nc bnc" id="L856" title="All 2 branches missed.">        if (aNode == null) {</span>
<span class="nc" id="L857">            retval = false;</span>
        } else {
<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (getChildCount() == 0) {</span>
<span class="nc" id="L860">                retval = false;</span>
            } else {
<span class="nc bnc" id="L862" title="All 2 branches missed.">                retval = (aNode.getParent() == this);</span>
            }
        }

<span class="nc" id="L866">        return retval;</span>
    }


    /**
     * Returns this node's first child.  If this node has no children,
     * throws NoSuchElementException.
     *
     * @return  the first child of this node
     * @exception       NoSuchElementException  if this node has no children
     */
    public TreeNode getFirstChild() {
<span class="nc bnc" id="L878" title="All 2 branches missed.">        if (getChildCount() == 0) {</span>
<span class="nc" id="L879">            throw new NoSuchElementException(&quot;node has no children&quot;);</span>
        }
<span class="nc" id="L881">        return getChildAt(0);</span>
    }


    /**
     * Returns this node's last child.  If this node has no children,
     * throws NoSuchElementException.
     *
     * @return  the last child of this node
     * @exception       NoSuchElementException  if this node has no children
     */
    public TreeNode getLastChild() {
<span class="nc bnc" id="L893" title="All 2 branches missed.">        if (getChildCount() == 0) {</span>
<span class="nc" id="L894">            throw new NoSuchElementException(&quot;node has no children&quot;);</span>
        }
<span class="nc" id="L896">        return getChildAt(getChildCount()-1);</span>
    }


    /**
     * Returns the child in this node's child array that immediately
     * follows &lt;code&gt;aChild&lt;/code&gt;, which must be a child of this node.  If
     * &lt;code&gt;aChild&lt;/code&gt; is the last child, returns null.  This method
     * performs a linear search of this node's children for
     * &lt;code&gt;aChild&lt;/code&gt; and is O(n) where n is the number of children; to
     * traverse the entire array of children, use an enumeration instead.
     *
     * @see             #children
     * @exception       IllegalArgumentException if &lt;code&gt;aChild&lt;/code&gt; is
     *                                  null or is not a child of this node
     * @return  the child of this node that immediately follows
     *          &lt;code&gt;aChild&lt;/code&gt;
     */
    public TreeNode getChildAfter(TreeNode aChild) {
<span class="nc bnc" id="L915" title="All 2 branches missed.">        if (aChild == null) {</span>
<span class="nc" id="L916">            throw new IllegalArgumentException(&quot;argument is null&quot;);</span>
        }

<span class="nc" id="L919">        int index = getIndex(aChild);           // linear search</span>

<span class="nc bnc" id="L921" title="All 2 branches missed.">        if (index == -1) {</span>
<span class="nc" id="L922">            throw new IllegalArgumentException(&quot;node is not a child&quot;);</span>
        }

<span class="nc bnc" id="L925" title="All 2 branches missed.">        if (index &lt; getChildCount() - 1) {</span>
<span class="nc" id="L926">            return getChildAt(index + 1);</span>
        } else {
<span class="nc" id="L928">            return null;</span>
        }
    }


    /**
     * Returns the child in this node's child array that immediately
     * precedes &lt;code&gt;aChild&lt;/code&gt;, which must be a child of this node.  If
     * &lt;code&gt;aChild&lt;/code&gt; is the first child, returns null.  This method
     * performs a linear search of this node's children for &lt;code&gt;aChild&lt;/code&gt;
     * and is O(n) where n is the number of children.
     *
     * @exception       IllegalArgumentException if &lt;code&gt;aChild&lt;/code&gt; is null
     *                                          or is not a child of this node
     * @return  the child of this node that immediately precedes
     *          &lt;code&gt;aChild&lt;/code&gt;
     */
    public TreeNode getChildBefore(TreeNode aChild) {
<span class="nc bnc" id="L946" title="All 2 branches missed.">        if (aChild == null) {</span>
<span class="nc" id="L947">            throw new IllegalArgumentException(&quot;argument is null&quot;);</span>
        }

<span class="nc" id="L950">        int index = getIndex(aChild);           // linear search</span>

<span class="nc bnc" id="L952" title="All 2 branches missed.">        if (index == -1) {</span>
<span class="nc" id="L953">            throw new IllegalArgumentException(&quot;argument is not a child&quot;);</span>
        }

<span class="nc bnc" id="L956" title="All 2 branches missed.">        if (index &gt; 0) {</span>
<span class="nc" id="L957">            return getChildAt(index - 1);</span>
        } else {
<span class="nc" id="L959">            return null;</span>
        }
    }


    //
    //  Sibling Queries
    //


    /**
     * Returns true if &lt;code&gt;anotherNode&lt;/code&gt; is a sibling of (has the
     * same parent as) this node.  A node is its own sibling.  If
     * &lt;code&gt;anotherNode&lt;/code&gt; is null, returns false.
     *
     * @param   anotherNode     node to test as sibling of this node
     * @return  true if &lt;code&gt;anotherNode&lt;/code&gt; is a sibling of this node
     */
    public boolean isNodeSibling(TreeNode anotherNode) {
        boolean retval;

<span class="nc bnc" id="L980" title="All 2 branches missed.">        if (anotherNode == null) {</span>
<span class="nc" id="L981">            retval = false;</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">        } else if (anotherNode == this) {</span>
<span class="nc" id="L983">            retval = true;</span>
        } else {
<span class="nc" id="L985">            TreeNode  myParent = getParent();</span>
<span class="nc bnc" id="L986" title="All 4 branches missed.">            retval = (myParent != null &amp;&amp; myParent == anotherNode.getParent());</span>

<span class="nc bnc" id="L988" title="All 2 branches missed.">            if (retval &amp;&amp; !((DefaultMutableTreeNode)getParent())</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">                           .isNodeChild(anotherNode)) {</span>
<span class="nc" id="L990">                throw new Error(&quot;sibling has different parent&quot;);</span>
            }
        }

<span class="nc" id="L994">        return retval;</span>
    }


    /**
     * Returns the number of siblings of this node.  A node is its own sibling
     * (if it has no parent or no siblings, this method returns
     * &lt;code&gt;1&lt;/code&gt;).
     *
     * @return  the number of siblings of this node
     */
    public int getSiblingCount() {
<span class="nc" id="L1006">        TreeNode myParent = getParent();</span>

<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (myParent == null) {</span>
<span class="nc" id="L1009">            return 1;</span>
        } else {
<span class="nc" id="L1011">            return myParent.getChildCount();</span>
        }
    }


    /**
     * Returns the next sibling of this node in the parent's children array.
     * Returns null if this node has no parent or is the parent's last child.
     * This method performs a linear search that is O(n) where n is the number
     * of children; to traverse the entire array, use the parent's child
     * enumeration instead.
     *
     * @see     #children
     * @return  the sibling of this node that immediately follows this node
     */
    public DefaultMutableTreeNode getNextSibling() {
        DefaultMutableTreeNode retval;

<span class="nc" id="L1029">        DefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();</span>

<span class="nc bnc" id="L1031" title="All 2 branches missed.">        if (myParent == null) {</span>
<span class="nc" id="L1032">            retval = null;</span>
        } else {
<span class="nc" id="L1034">            retval = (DefaultMutableTreeNode)myParent.getChildAfter(this);      // linear search</span>
        }

<span class="nc bnc" id="L1037" title="All 4 branches missed.">        if (retval != null &amp;&amp; !isNodeSibling(retval)) {</span>
<span class="nc" id="L1038">            throw new Error(&quot;child of parent is not a sibling&quot;);</span>
        }

<span class="nc" id="L1041">        return retval;</span>
    }


    /**
     * Returns the previous sibling of this node in the parent's children
     * array.  Returns null if this node has no parent or is the parent's
     * first child.  This method performs a linear search that is O(n) where n
     * is the number of children.
     *
     * @return  the sibling of this node that immediately precedes this node
     */
    public DefaultMutableTreeNode getPreviousSibling() {
        DefaultMutableTreeNode retval;

<span class="nc" id="L1056">        DefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();</span>

<span class="nc bnc" id="L1058" title="All 2 branches missed.">        if (myParent == null) {</span>
<span class="nc" id="L1059">            retval = null;</span>
        } else {
<span class="nc" id="L1061">            retval = (DefaultMutableTreeNode)myParent.getChildBefore(this);     // linear search</span>
        }

<span class="nc bnc" id="L1064" title="All 4 branches missed.">        if (retval != null &amp;&amp; !isNodeSibling(retval)) {</span>
<span class="nc" id="L1065">            throw new Error(&quot;child of parent is not a sibling&quot;);</span>
        }

<span class="nc" id="L1068">        return retval;</span>
    }



    //
    //  Leaf Queries
    //

    /**
     * Returns true if this node has no children.  To distinguish between
     * nodes that have no children and nodes that &lt;i&gt;cannot&lt;/i&gt; have
     * children (e.g. to distinguish files from empty directories), use this
     * method in conjunction with &lt;code&gt;getAllowsChildren&lt;/code&gt;
     *
     * @see     #getAllowsChildren
     * @return  true if this node has no children
     */
    public boolean isLeaf() {
<span class="nc bnc" id="L1087" title="All 2 branches missed.">        return (getChildCount() == 0);</span>
    }


    /**
     * Finds and returns the first leaf that is a descendant of this node --
     * either this node or its first child's first leaf.
     * Returns this node if it is a leaf.
     *
     * @see     #isLeaf
     * @see     #isNodeDescendant
     * @return  the first leaf in the subtree rooted at this node
     */
    public DefaultMutableTreeNode getFirstLeaf() {
<span class="nc" id="L1101">        DefaultMutableTreeNode node = this;</span>

<span class="nc bnc" id="L1103" title="All 2 branches missed.">        while (!node.isLeaf()) {</span>
<span class="nc" id="L1104">            node = (DefaultMutableTreeNode)node.getFirstChild();</span>
        }

<span class="nc" id="L1107">        return node;</span>
    }


    /**
     * Finds and returns the last leaf that is a descendant of this node --
     * either this node or its last child's last leaf.
     * Returns this node if it is a leaf.
     *
     * @see     #isLeaf
     * @see     #isNodeDescendant
     * @return  the last leaf in the subtree rooted at this node
     */
    public DefaultMutableTreeNode getLastLeaf() {
<span class="nc" id="L1121">        DefaultMutableTreeNode node = this;</span>

<span class="nc bnc" id="L1123" title="All 2 branches missed.">        while (!node.isLeaf()) {</span>
<span class="nc" id="L1124">            node = (DefaultMutableTreeNode)node.getLastChild();</span>
        }

<span class="nc" id="L1127">        return node;</span>
    }


    /**
     * Returns the leaf after this node or null if this node is the
     * last leaf in the tree.
     * &lt;p&gt;
     * In this implementation of the &lt;code&gt;MutableNode&lt;/code&gt; interface,
     * this operation is very inefficient. In order to determine the
     * next node, this method first performs a linear search in the
     * parent's child-list in order to find the current node.
     * &lt;p&gt;
     * That implementation makes the operation suitable for short
     * traversals from a known position. But to traverse all of the
     * leaves in the tree, you should use &lt;code&gt;depthFirstEnumeration&lt;/code&gt;
     * to enumerate the nodes in the tree and use &lt;code&gt;isLeaf&lt;/code&gt;
     * on each node to determine which are leaves.
     *
     * @see     #depthFirstEnumeration
     * @see     #isLeaf
     * @return  returns the next leaf past this node
     */
    public DefaultMutableTreeNode getNextLeaf() {
        DefaultMutableTreeNode nextSibling;
<span class="nc" id="L1152">        DefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();</span>

<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (myParent == null)</span>
<span class="nc" id="L1155">            return null;</span>

<span class="nc" id="L1157">        nextSibling = getNextSibling(); // linear search</span>

<span class="nc bnc" id="L1159" title="All 2 branches missed.">        if (nextSibling != null)</span>
<span class="nc" id="L1160">            return nextSibling.getFirstLeaf();</span>

<span class="nc" id="L1162">        return myParent.getNextLeaf();  // tail recursion</span>
    }


    /**
     * Returns the leaf before this node or null if this node is the
     * first leaf in the tree.
     * &lt;p&gt;
     * In this implementation of the &lt;code&gt;MutableNode&lt;/code&gt; interface,
     * this operation is very inefficient. In order to determine the
     * previous node, this method first performs a linear search in the
     * parent's child-list in order to find the current node.
     * &lt;p&gt;
     * That implementation makes the operation suitable for short
     * traversals from a known position. But to traverse all of the
     * leaves in the tree, you should use &lt;code&gt;depthFirstEnumeration&lt;/code&gt;
     * to enumerate the nodes in the tree and use &lt;code&gt;isLeaf&lt;/code&gt;
     * on each node to determine which are leaves.
     *
     * @see             #depthFirstEnumeration
     * @see             #isLeaf
     * @return  returns the leaf before this node
     */
    public DefaultMutableTreeNode getPreviousLeaf() {
        DefaultMutableTreeNode previousSibling;
<span class="nc" id="L1187">        DefaultMutableTreeNode myParent = (DefaultMutableTreeNode)getParent();</span>

<span class="nc bnc" id="L1189" title="All 2 branches missed.">        if (myParent == null)</span>
<span class="nc" id="L1190">            return null;</span>

<span class="nc" id="L1192">        previousSibling = getPreviousSibling(); // linear search</span>

<span class="nc bnc" id="L1194" title="All 2 branches missed.">        if (previousSibling != null)</span>
<span class="nc" id="L1195">            return previousSibling.getLastLeaf();</span>

<span class="nc" id="L1197">        return myParent.getPreviousLeaf();              // tail recursion</span>
    }


    /**
     * Returns the total number of leaves that are descendants of this node.
     * If this node is a leaf, returns &lt;code&gt;1&lt;/code&gt;.  This method is O(n)
     * where n is the number of descendants of this node.
     *
     * @see     #isNodeAncestor
     * @return  the number of leaves beneath this node
     */
    public int getLeafCount() {
<span class="nc" id="L1210">        int count = 0;</span>

        TreeNode node;
<span class="nc" id="L1213">        Enumeration enum_ = breadthFirstEnumeration(); // order matters not</span>

<span class="nc bnc" id="L1215" title="All 2 branches missed.">        while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L1216">            node = (TreeNode)enum_.nextElement();</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">            if (node.isLeaf()) {</span>
<span class="nc" id="L1218">                count++;</span>
            }
        }

<span class="nc bnc" id="L1222" title="All 2 branches missed.">        if (count &lt; 1) {</span>
<span class="nc" id="L1223">            throw new Error(&quot;tree has zero leaves&quot;);</span>
        }

<span class="nc" id="L1226">        return count;</span>
    }


    //
    //  Overrides
    //

    /**
     * Returns the result of sending &lt;code&gt;toString()&lt;/code&gt; to this node's
     * user object, or the empty string if the node has no user object.
     *
     * @see     #getUserObject
     */
    public String toString() {
<span class="nc bnc" id="L1241" title="All 2 branches missed.">        if (userObject == null) {</span>
<span class="nc" id="L1242">            return &quot;&quot;;</span>
        } else {
<span class="nc" id="L1244">            return userObject.toString();</span>
        }
    }

    /**
     * Overridden to make clone public.  Returns a shallow copy of this node;
     * the new node has no parent or children and has a reference to the same
     * user object, if any.
     *
     * @return  a copy of this node
     */
    public Object clone() {
        DefaultMutableTreeNode newNode;

        try {
<span class="nc" id="L1259">            newNode = (DefaultMutableTreeNode)super.clone();</span>

            // shallow copy -- the new node has no parent or children
<span class="nc" id="L1262">            newNode.children = null;</span>
<span class="nc" id="L1263">            newNode.parent = null;</span>

<span class="nc" id="L1265">        } catch (CloneNotSupportedException e) {</span>
            // Won't happen because we implement Cloneable
<span class="nc" id="L1267">            throw new Error(e.toString());</span>
<span class="nc" id="L1268">        }</span>

<span class="nc" id="L1270">        return newNode;</span>
    }


    // Serialization support.
    private void writeObject(ObjectOutputStream s) throws IOException {
        Object[]             tValues;

<span class="nc" id="L1278">        s.defaultWriteObject();</span>
        // Save the userObject, if its Serializable.
<span class="nc bnc" id="L1280" title="All 4 branches missed.">        if(userObject != null &amp;&amp; userObject instanceof Serializable) {</span>
<span class="nc" id="L1281">            tValues = new Object[2];</span>
<span class="nc" id="L1282">            tValues[0] = &quot;userObject&quot;;</span>
<span class="nc" id="L1283">            tValues[1] = userObject;</span>
        }
        else
<span class="nc" id="L1286">            tValues = new Object[0];</span>
<span class="nc" id="L1287">        s.writeObject(tValues);</span>
<span class="nc" id="L1288">    }</span>

    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
        Object[]      tValues;

<span class="nc" id="L1294">        s.defaultReadObject();</span>

<span class="nc" id="L1296">        tValues = (Object[])s.readObject();</span>

<span class="nc bnc" id="L1298" title="All 4 branches missed.">        if(tValues.length &gt; 0 &amp;&amp; tValues[0].equals(&quot;userObject&quot;))</span>
<span class="nc" id="L1299">            userObject = tValues[1];</span>
<span class="nc" id="L1300">    }</span>

    private final class PreorderEnumeration implements Enumeration&lt;TreeNode&gt; {
<span class="nc" id="L1303">        private final Stack&lt;Enumeration&gt; stack = new Stack&lt;Enumeration&gt;();</span>

<span class="nc" id="L1305">        public PreorderEnumeration(TreeNode rootNode) {</span>
<span class="nc" id="L1306">            super();</span>
<span class="nc" id="L1307">            Vector&lt;TreeNode&gt; v = new Vector&lt;TreeNode&gt;(1);</span>
<span class="nc" id="L1308">            v.addElement(rootNode);     // PENDING: don't really need a vector</span>
<span class="nc" id="L1309">            stack.push(v.elements());</span>
<span class="nc" id="L1310">        }</span>

        public boolean hasMoreElements() {
<span class="nc bnc" id="L1313" title="All 4 branches missed.">            return (!stack.empty() &amp;&amp; stack.peek().hasMoreElements());</span>
        }

        public TreeNode nextElement() {
<span class="nc" id="L1317">            Enumeration enumer = stack.peek();</span>
<span class="nc" id="L1318">            TreeNode    node = (TreeNode)enumer.nextElement();</span>
<span class="nc" id="L1319">            Enumeration children = node.children();</span>

<span class="nc bnc" id="L1321" title="All 2 branches missed.">            if (!enumer.hasMoreElements()) {</span>
<span class="nc" id="L1322">                stack.pop();</span>
            }
<span class="nc bnc" id="L1324" title="All 2 branches missed.">            if (children.hasMoreElements()) {</span>
<span class="nc" id="L1325">                stack.push(children);</span>
            }
<span class="nc" id="L1327">            return node;</span>
        }

    }  // End of class PreorderEnumeration



    final class PostorderEnumeration implements Enumeration&lt;TreeNode&gt; {
        protected TreeNode root;
        protected Enumeration&lt;TreeNode&gt; children;
        protected Enumeration&lt;TreeNode&gt; subtree;

<span class="nc" id="L1339">        public PostorderEnumeration(TreeNode rootNode) {</span>
<span class="nc" id="L1340">            super();</span>
<span class="nc" id="L1341">            root = rootNode;</span>
<span class="nc" id="L1342">            children = root.children();</span>
<span class="nc" id="L1343">            subtree = EMPTY_ENUMERATION;</span>
<span class="nc" id="L1344">        }</span>

        public boolean hasMoreElements() {
<span class="nc bnc" id="L1347" title="All 2 branches missed.">            return root != null;</span>
        }

        public TreeNode nextElement() {
            TreeNode retval;

<span class="nc bnc" id="L1353" title="All 2 branches missed.">            if (subtree.hasMoreElements()) {</span>
<span class="nc" id="L1354">                retval = subtree.nextElement();</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">            } else if (children.hasMoreElements()) {</span>
<span class="nc" id="L1356">                subtree = new PostorderEnumeration(children.nextElement());</span>
<span class="nc" id="L1357">                retval = subtree.nextElement();</span>
            } else {
<span class="nc" id="L1359">                retval = root;</span>
<span class="nc" id="L1360">                root = null;</span>
            }

<span class="nc" id="L1363">            return retval;</span>
        }

    }  // End of class PostorderEnumeration



    final class BreadthFirstEnumeration implements Enumeration&lt;TreeNode&gt; {
        protected Queue queue;

<span class="nc" id="L1373">        public BreadthFirstEnumeration(TreeNode rootNode) {</span>
<span class="nc" id="L1374">            super();</span>
<span class="nc" id="L1375">            Vector&lt;TreeNode&gt; v = new Vector&lt;TreeNode&gt;(1);</span>
<span class="nc" id="L1376">            v.addElement(rootNode);     // PENDING: don't really need a vector</span>
<span class="nc" id="L1377">            queue = new Queue();</span>
<span class="nc" id="L1378">            queue.enqueue(v.elements());</span>
<span class="nc" id="L1379">        }</span>

        public boolean hasMoreElements() {
<span class="nc bnc" id="L1382" title="All 2 branches missed.">            return (!queue.isEmpty() &amp;&amp;</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">                    ((Enumeration)queue.firstObject()).hasMoreElements());</span>
        }

        public TreeNode nextElement() {
<span class="nc" id="L1387">            Enumeration enumer = (Enumeration)queue.firstObject();</span>
<span class="nc" id="L1388">            TreeNode    node = (TreeNode)enumer.nextElement();</span>
<span class="nc" id="L1389">            Enumeration children = node.children();</span>

<span class="nc bnc" id="L1391" title="All 2 branches missed.">            if (!enumer.hasMoreElements()) {</span>
<span class="nc" id="L1392">                queue.dequeue();</span>
            }
<span class="nc bnc" id="L1394" title="All 2 branches missed.">            if (children.hasMoreElements()) {</span>
<span class="nc" id="L1395">                queue.enqueue(children);</span>
            }
<span class="nc" id="L1397">            return node;</span>
        }


        // A simple queue with a linked list data structure.
<span class="nc" id="L1402">        final class Queue {</span>
            QNode head; // null if empty
            QNode tail;

<span class="nc" id="L1406">            final class QNode {</span>
                public Object   object;
                public QNode    next;   // null if end
<span class="nc" id="L1409">                public QNode(Object object, QNode next) {</span>
<span class="nc" id="L1410">                    this.object = object;</span>
<span class="nc" id="L1411">                    this.next = next;</span>
<span class="nc" id="L1412">                }</span>
            }

            public void enqueue(Object anObject) {
<span class="nc bnc" id="L1416" title="All 2 branches missed.">                if (head == null) {</span>
<span class="nc" id="L1417">                    head = tail = new QNode(anObject, null);</span>
                } else {
<span class="nc" id="L1419">                    tail.next = new QNode(anObject, null);</span>
<span class="nc" id="L1420">                    tail = tail.next;</span>
                }
<span class="nc" id="L1422">            }</span>

            public Object dequeue() {
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                if (head == null) {</span>
<span class="nc" id="L1426">                    throw new NoSuchElementException(&quot;No more elements&quot;);</span>
                }

<span class="nc" id="L1429">                Object retval = head.object;</span>
<span class="nc" id="L1430">                QNode oldHead = head;</span>
<span class="nc" id="L1431">                head = head.next;</span>
<span class="nc bnc" id="L1432" title="All 2 branches missed.">                if (head == null) {</span>
<span class="nc" id="L1433">                    tail = null;</span>
                } else {
<span class="nc" id="L1435">                    oldHead.next = null;</span>
                }
<span class="nc" id="L1437">                return retval;</span>
            }

            public Object firstObject() {
<span class="nc bnc" id="L1441" title="All 2 branches missed.">                if (head == null) {</span>
<span class="nc" id="L1442">                    throw new NoSuchElementException(&quot;No more elements&quot;);</span>
                }

<span class="nc" id="L1445">                return head.object;</span>
            }

            public boolean isEmpty() {
<span class="nc bnc" id="L1449" title="All 2 branches missed.">                return head == null;</span>
            }

        } // End of class Queue

    }  // End of class BreadthFirstEnumeration



    final class PathBetweenNodesEnumeration implements Enumeration&lt;TreeNode&gt; {
        protected Stack&lt;TreeNode&gt; stack;

        public PathBetweenNodesEnumeration(TreeNode ancestor,
                                           TreeNode descendant)
<span class="nc" id="L1463">        {</span>
<span class="nc" id="L1464">            super();</span>

<span class="nc bnc" id="L1466" title="All 4 branches missed.">            if (ancestor == null || descendant == null) {</span>
<span class="nc" id="L1467">                throw new IllegalArgumentException(&quot;argument is null&quot;);</span>
            }

            TreeNode current;

<span class="nc" id="L1472">            stack = new Stack&lt;TreeNode&gt;();</span>
<span class="nc" id="L1473">            stack.push(descendant);</span>

<span class="nc" id="L1475">            current = descendant;</span>
<span class="nc bnc" id="L1476" title="All 2 branches missed.">            while (current != ancestor) {</span>
<span class="nc" id="L1477">                current = current.getParent();</span>
<span class="nc bnc" id="L1478" title="All 4 branches missed.">                if (current == null &amp;&amp; descendant != ancestor) {</span>
<span class="nc" id="L1479">                    throw new IllegalArgumentException(&quot;node &quot; + ancestor +</span>
                                &quot; is not an ancestor of &quot; + descendant);
                }
<span class="nc" id="L1482">                stack.push(current);</span>
            }
<span class="nc" id="L1484">        }</span>

        public boolean hasMoreElements() {
<span class="nc bnc" id="L1487" title="All 2 branches missed.">            return stack.size() &gt; 0;</span>
        }

        public TreeNode nextElement() {
            try {
<span class="nc" id="L1492">                return stack.pop();</span>
<span class="nc" id="L1493">            } catch (EmptyStackException e) {</span>
<span class="nc" id="L1494">                throw new NoSuchElementException(&quot;No more elements&quot;);</span>
            }
        }

    } // End of class PathBetweenNodesEnumeration



} // End of class DefaultMutableTreeNode
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>