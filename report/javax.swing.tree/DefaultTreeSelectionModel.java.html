<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultTreeSelectionModel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.tree</a> &gt; <span class="el_source">DefaultTreeSelectionModel.java</span></div><h1>DefaultTreeSelectionModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.tree;

import java.beans.PropertyChangeListener;
import java.io.*;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Enumeration;
import java.util.EventListener;
import java.util.Hashtable;
import java.util.List;
import java.util.Vector;
import javax.swing.event.*;
import javax.swing.DefaultListSelectionModel;

/**
 * Default implementation of TreeSelectionModel.  Listeners are notified
 * whenever
 * the paths in the selection change, not the rows. In order
 * to be able to track row changes you may wish to become a listener
 * for expansion events on the tree and test for changes from there.
 * &lt;p&gt;resetRowSelection is called from any of the methods that update
 * the selected paths. If you subclass any of these methods to
 * filter what is allowed to be selected, be sure and message
 * &lt;code&gt;resetRowSelection&lt;/code&gt; if you do not message super.
 *
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see javax.swing.JTree
 *
 * @author Scott Violet
 */
@SuppressWarnings(&quot;serial&quot;)
public class DefaultTreeSelectionModel implements Cloneable, Serializable, TreeSelectionModel
{
    /** Property name for selectionMode. */
    public static final String          SELECTION_MODE_PROPERTY = &quot;selectionMode&quot;;

    /** Used to messaged registered listeners. */
    protected SwingPropertyChangeSupport     changeSupport;

    /** Paths that are currently selected.  Will be null if nothing is
      * currently selected. */
    protected TreePath[]                selection;

    /** Event listener list. */
<span class="nc" id="L78">    protected EventListenerList   listenerList = new EventListenerList();</span>

    /** Provides a row for a given path. */
    transient protected RowMapper               rowMapper;

    /** Handles maintaining the list selection model. The RowMapper is used
     * to map from a TreePath to a row, and the value is then placed here. */
    protected DefaultListSelectionModel     listSelectionModel;

    /** Mode for the selection, will be either SINGLE_TREE_SELECTION,
     * CONTIGUOUS_TREE_SELECTION or DISCONTIGUOUS_TREE_SELECTION.
     */
    protected int                           selectionMode;

    /** Last path that was added. */
    protected TreePath                      leadPath;
    /** Index of the lead path in selection. */
    protected int                           leadIndex;
    /** Lead row. */
    protected int                           leadRow;

    /** Used to make sure the paths are unique, will contain all the paths
     * in &lt;code&gt;selection&lt;/code&gt;.
     */
    private Hashtable&lt;TreePath, Boolean&gt;    uniquePaths;
    private Hashtable&lt;TreePath, Boolean&gt;    lastPaths;
    private TreePath[]                      tempPaths;


    /**
     * Creates a new instance of DefaultTreeSelectionModel that is
     * empty, with a selection mode of DISCONTIGUOUS_TREE_SELECTION.
     */
<span class="nc" id="L111">    public DefaultTreeSelectionModel() {</span>
<span class="nc" id="L112">        listSelectionModel = new DefaultListSelectionModel();</span>
<span class="nc" id="L113">        selectionMode = DISCONTIGUOUS_TREE_SELECTION;</span>
<span class="nc" id="L114">        leadIndex = leadRow = -1;</span>
<span class="nc" id="L115">        uniquePaths = new Hashtable&lt;TreePath, Boolean&gt;();</span>
<span class="nc" id="L116">        lastPaths = new Hashtable&lt;TreePath, Boolean&gt;();</span>
<span class="nc" id="L117">        tempPaths = new TreePath[1];</span>
<span class="nc" id="L118">    }</span>

    /**
     * Sets the RowMapper instance. This instance is used to determine
     * the row for a particular TreePath.
     */
    public void setRowMapper(RowMapper newMapper) {
<span class="nc" id="L125">        rowMapper = newMapper;</span>
<span class="nc" id="L126">        resetRowSelection();</span>
<span class="nc" id="L127">    }</span>

    /**
     * Returns the RowMapper instance that is able to map a TreePath to a
     * row.
     */
    public RowMapper getRowMapper() {
<span class="nc" id="L134">        return rowMapper;</span>
    }

    /**
     * Sets the selection model, which must be one of SINGLE_TREE_SELECTION,
     * CONTIGUOUS_TREE_SELECTION or DISCONTIGUOUS_TREE_SELECTION. If mode
     * is not one of the defined value,
     * &lt;code&gt;DISCONTIGUOUS_TREE_SELECTION&lt;/code&gt; is assumed.
     * &lt;p&gt;This may change the selection if the current selection is not valid
     * for the new mode. For example, if three TreePaths are
     * selected when the mode is changed to &lt;code&gt;SINGLE_TREE_SELECTION&lt;/code&gt;,
     * only one TreePath will remain selected. It is up to the particular
     * implementation to decide what TreePath remains selected.
     * &lt;p&gt;
     * Setting the mode to something other than the defined types will
     * result in the mode becoming &lt;code&gt;DISCONTIGUOUS_TREE_SELECTION&lt;/code&gt;.
     */
    public void setSelectionMode(int mode) {
<span class="nc" id="L152">        int            oldMode = selectionMode;</span>

<span class="nc" id="L154">        selectionMode = mode;</span>
<span class="nc bnc" id="L155" title="All 6 branches missed.">        if(selectionMode != TreeSelectionModel.SINGLE_TREE_SELECTION &amp;&amp;</span>
           selectionMode != TreeSelectionModel.CONTIGUOUS_TREE_SELECTION &amp;&amp;
           selectionMode != TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION)
<span class="nc" id="L158">            selectionMode = TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION;</span>
<span class="nc bnc" id="L159" title="All 4 branches missed.">        if(oldMode != selectionMode &amp;&amp; changeSupport != null)</span>
<span class="nc" id="L160">            changeSupport.firePropertyChange(SELECTION_MODE_PROPERTY,</span>
<span class="nc" id="L161">                                             Integer.valueOf(oldMode),</span>
<span class="nc" id="L162">                                             Integer.valueOf(selectionMode));</span>
<span class="nc" id="L163">    }</span>

    /**
     * Returns the selection mode, one of &lt;code&gt;SINGLE_TREE_SELECTION&lt;/code&gt;,
     * &lt;code&gt;DISCONTIGUOUS_TREE_SELECTION&lt;/code&gt; or
     * &lt;code&gt;CONTIGUOUS_TREE_SELECTION&lt;/code&gt;.
     */
    public int getSelectionMode() {
<span class="nc" id="L171">        return selectionMode;</span>
    }

    /**
      * Sets the selection to path. If this represents a change, then
      * the TreeSelectionListeners are notified. If &lt;code&gt;path&lt;/code&gt; is
      * null, this has the same effect as invoking &lt;code&gt;clearSelection&lt;/code&gt;.
      *
      * @param path new path to select
      */
    public void setSelectionPath(TreePath path) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if(path == null)</span>
<span class="nc" id="L183">            setSelectionPaths(null);</span>
        else {
<span class="nc" id="L185">            TreePath[]          newPaths = new TreePath[1];</span>

<span class="nc" id="L187">            newPaths[0] = path;</span>
<span class="nc" id="L188">            setSelectionPaths(newPaths);</span>
        }
<span class="nc" id="L190">    }</span>

    /**
     * Sets the selection. Whether the supplied paths are taken as the
     * new selection depends upon the selection mode. If the supplied
     * array is {@code null}, or empty, the selection is cleared. If
     * the selection mode is {@code SINGLE_TREE_SELECTION}, only the
     * first path in {@code pPaths} is used. If the selection
     * mode is {@code CONTIGUOUS_TREE_SELECTION} and the supplied paths
     * are not contiguous, then only the first path in {@code pPaths} is
     * used. If the selection mode is
     * {@code DISCONTIGUOUS_TREE_SELECTION}, then all paths are used.
     * &lt;p&gt;
     * All {@code null} paths in {@code pPaths} are ignored.
     * &lt;p&gt;
     * If this represents a change, all registered {@code
     * TreeSelectionListener}s are notified.
     * &lt;p&gt;
     * The lead path is set to the last unique path.
     * &lt;p&gt;
     * The paths returned from {@code getSelectionPaths} are in the same
     * order as those supplied to this method.
     *
     * @param pPaths the new selection
     */
    public void setSelectionPaths(TreePath[] pPaths) {
        int            newCount, newCounter, oldCount, oldCounter;
<span class="nc" id="L217">        TreePath[]     paths = pPaths;</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">        if(paths == null)</span>
<span class="nc" id="L220">            newCount = 0;</span>
        else
<span class="nc" id="L222">            newCount = paths.length;</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if(selection == null)</span>
<span class="nc" id="L224">            oldCount = 0;</span>
        else
<span class="nc" id="L226">            oldCount = selection.length;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if((newCount + oldCount) != 0) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            if(selectionMode == TreeSelectionModel.SINGLE_TREE_SELECTION) {</span>
                /* If single selection and more than one path, only allow
                   first. */
<span class="nc bnc" id="L231" title="All 2 branches missed.">                if(newCount &gt; 1) {</span>
<span class="nc" id="L232">                    paths = new TreePath[1];</span>
<span class="nc" id="L233">                    paths[0] = pPaths[0];</span>
<span class="nc" id="L234">                    newCount = 1;</span>
                }
            }
<span class="nc bnc" id="L237" title="All 2 branches missed.">            else if(selectionMode ==</span>
                    TreeSelectionModel.CONTIGUOUS_TREE_SELECTION) {
                /* If contiguous selection and paths aren't contiguous,
                   only select the first path item. */
<span class="nc bnc" id="L241" title="All 4 branches missed.">                if(newCount &gt; 0 &amp;&amp; !arePathsContiguous(paths)) {</span>
<span class="nc" id="L242">                    paths = new TreePath[1];</span>
<span class="nc" id="L243">                    paths[0] = pPaths[0];</span>
<span class="nc" id="L244">                    newCount = 1;</span>
                }
            }

<span class="nc" id="L248">            TreePath         beginLeadPath = leadPath;</span>
<span class="nc" id="L249">            Vector&lt;PathPlaceHolder&gt; cPaths = new Vector&lt;PathPlaceHolder&gt;(newCount + oldCount);</span>
<span class="nc" id="L250">            List&lt;TreePath&gt; newSelectionAsList =</span>
                    new ArrayList&lt;TreePath&gt;(newCount);

<span class="nc" id="L253">            lastPaths.clear();</span>
<span class="nc" id="L254">            leadPath = null;</span>
            /* Find the paths that are new. */
<span class="nc bnc" id="L256" title="All 2 branches missed.">            for(newCounter = 0; newCounter &lt; newCount; newCounter++) {</span>
<span class="nc" id="L257">                TreePath path = paths[newCounter];</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">                if (path != null &amp;&amp; lastPaths.get(path) == null) {</span>
<span class="nc" id="L259">                    lastPaths.put(path, Boolean.TRUE);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                    if (uniquePaths.get(path) == null) {</span>
<span class="nc" id="L261">                        cPaths.addElement(new PathPlaceHolder(path, true));</span>
                    }
<span class="nc" id="L263">                    leadPath = path;</span>
<span class="nc" id="L264">                    newSelectionAsList.add(path);</span>
                }
            }

<span class="nc" id="L268">            TreePath[] newSelection = newSelectionAsList.toArray(</span>
<span class="nc" id="L269">                    new TreePath[newSelectionAsList.size()]);</span>

            /* Get the paths that were selected but no longer selected. */
<span class="nc bnc" id="L272" title="All 2 branches missed.">            for(oldCounter = 0; oldCounter &lt; oldCount; oldCounter++)</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">                if(selection[oldCounter] != null &amp;&amp;</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">                    lastPaths.get(selection[oldCounter]) == null)</span>
<span class="nc" id="L275">                    cPaths.addElement(new PathPlaceHolder</span>
                                      (selection[oldCounter], false));

<span class="nc" id="L278">            selection = newSelection;</span>

<span class="nc" id="L280">            Hashtable&lt;TreePath, Boolean&gt;  tempHT = uniquePaths;</span>

<span class="nc" id="L282">            uniquePaths = lastPaths;</span>
<span class="nc" id="L283">            lastPaths = tempHT;</span>
<span class="nc" id="L284">            lastPaths.clear();</span>

            // No reason to do this now, but will still call it.
<span class="nc" id="L287">            insureUniqueness();</span>

<span class="nc" id="L289">            updateLeadIndex();</span>

<span class="nc" id="L291">            resetRowSelection();</span>
            /* Notify of the change. */
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if(cPaths.size() &gt; 0)</span>
<span class="nc" id="L294">                notifyPathChange(cPaths, beginLeadPath);</span>
        }
<span class="nc" id="L296">    }</span>

    /**
      * Adds path to the current selection. If path is not currently
      * in the selection the TreeSelectionListeners are notified. This has
      * no effect if &lt;code&gt;path&lt;/code&gt; is null.
      *
      * @param path the new path to add to the current selection
      */
    public void addSelectionPath(TreePath path) {
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if(path != null) {</span>
<span class="nc" id="L307">            TreePath[]            toAdd = new TreePath[1];</span>

<span class="nc" id="L309">            toAdd[0] = path;</span>
<span class="nc" id="L310">            addSelectionPaths(toAdd);</span>
        }
<span class="nc" id="L312">    }</span>

    /**
      * Adds paths to the current selection. If any of the paths in
      * paths are not currently in the selection the TreeSelectionListeners
      * are notified. This has
      * no effect if &lt;code&gt;paths&lt;/code&gt; is null.
      * &lt;p&gt;The lead path is set to the last element in &lt;code&gt;paths&lt;/code&gt;.
      * &lt;p&gt;If the selection mode is &lt;code&gt;CONTIGUOUS_TREE_SELECTION&lt;/code&gt;,
      * and adding the new paths would make the selection discontiguous.
      * Then two things can result: if the TreePaths in &lt;code&gt;paths&lt;/code&gt;
      * are contiguous, then the selection becomes these TreePaths,
      * otherwise the TreePaths aren't contiguous and the selection becomes
      * the first TreePath in &lt;code&gt;paths&lt;/code&gt;.
      *
      * @param paths the new path to add to the current selection
      */
    public void addSelectionPaths(TreePath[] paths) {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        int       newPathLength = ((paths == null) ? 0 : paths.length);</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">        if(newPathLength &gt; 0) {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if(selectionMode == TreeSelectionModel.SINGLE_TREE_SELECTION) {</span>
<span class="nc" id="L334">                setSelectionPaths(paths);</span>
            }
<span class="nc bnc" id="L336" title="All 2 branches missed.">            else if(selectionMode == TreeSelectionModel.</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">                    CONTIGUOUS_TREE_SELECTION &amp;&amp; !canPathsBeAdded(paths)) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                if(arePathsContiguous(paths)) {</span>
<span class="nc" id="L339">                    setSelectionPaths(paths);</span>
                }
                else {
<span class="nc" id="L342">                    TreePath[]          newPaths = new TreePath[1];</span>

<span class="nc" id="L344">                    newPaths[0] = paths[0];</span>
<span class="nc" id="L345">                    setSelectionPaths(newPaths);</span>
<span class="nc" id="L346">                }</span>
            }
            else {
                int               counter, validCount;
                int               oldCount;
<span class="nc" id="L351">                TreePath          beginLeadPath = leadPath;</span>
<span class="nc" id="L352">                Vector&lt;PathPlaceHolder&gt;  cPaths = null;</span>

<span class="nc bnc" id="L354" title="All 2 branches missed.">                if(selection == null)</span>
<span class="nc" id="L355">                    oldCount = 0;</span>
                else
<span class="nc" id="L357">                    oldCount = selection.length;</span>
                /* Determine the paths that aren't currently in the
                   selection. */
<span class="nc" id="L360">                lastPaths.clear();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">                for(counter = 0, validCount = 0; counter &lt; newPathLength;</span>
<span class="nc" id="L362">                    counter++) {</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">                    if(paths[counter] != null) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">                        if (uniquePaths.get(paths[counter]) == null) {</span>
<span class="nc" id="L365">                            validCount++;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                            if(cPaths == null)</span>
<span class="nc" id="L367">                                cPaths = new Vector&lt;PathPlaceHolder&gt;();</span>
<span class="nc" id="L368">                            cPaths.addElement(new PathPlaceHolder</span>
                                              (paths[counter], true));
<span class="nc" id="L370">                            uniquePaths.put(paths[counter], Boolean.TRUE);</span>
<span class="nc" id="L371">                            lastPaths.put(paths[counter], Boolean.TRUE);</span>
                        }
<span class="nc" id="L373">                        leadPath = paths[counter];</span>
                    }
                }

<span class="nc bnc" id="L377" title="All 2 branches missed.">                if(leadPath == null) {</span>
<span class="nc" id="L378">                    leadPath = beginLeadPath;</span>
                }

<span class="nc bnc" id="L381" title="All 2 branches missed.">                if(validCount &gt; 0) {</span>
<span class="nc" id="L382">                    TreePath         newSelection[] = new TreePath[oldCount +</span>
                                                                  validCount];

                    /* And build the new selection. */
<span class="nc bnc" id="L386" title="All 2 branches missed.">                    if(oldCount &gt; 0)</span>
<span class="nc" id="L387">                        System.arraycopy(selection, 0, newSelection, 0,</span>
                                         oldCount);
<span class="nc bnc" id="L389" title="All 2 branches missed.">                    if(validCount != paths.length) {</span>
                        /* Some of the paths in paths are already in
                           the selection. */
<span class="nc" id="L392">                        Enumeration&lt;TreePath&gt; newPaths = lastPaths.keys();</span>

<span class="nc" id="L394">                        counter = oldCount;</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                        while (newPaths.hasMoreElements()) {</span>
<span class="nc" id="L396">                            newSelection[counter++] = newPaths.nextElement();</span>
                        }
<span class="nc" id="L398">                    }</span>
                    else {
<span class="nc" id="L400">                        System.arraycopy(paths, 0, newSelection, oldCount,</span>
                                         validCount);
                    }

<span class="nc" id="L404">                    selection = newSelection;</span>

<span class="nc" id="L406">                    insureUniqueness();</span>

<span class="nc" id="L408">                    updateLeadIndex();</span>

<span class="nc" id="L410">                    resetRowSelection();</span>

<span class="nc" id="L412">                    notifyPathChange(cPaths, beginLeadPath);</span>
<span class="nc" id="L413">                }</span>
                else
<span class="nc" id="L415">                    leadPath = beginLeadPath;</span>
<span class="nc" id="L416">                lastPaths.clear();</span>
            }
        }
<span class="nc" id="L419">    }</span>

    /**
      * Removes path from the selection. If path is in the selection
      * The TreeSelectionListeners are notified. This has no effect if
      * &lt;code&gt;path&lt;/code&gt; is null.
      *
      * @param path the path to remove from the selection
      */
    public void removeSelectionPath(TreePath path) {
<span class="nc bnc" id="L429" title="All 2 branches missed.">        if(path != null) {</span>
<span class="nc" id="L430">            TreePath[]             rPath = new TreePath[1];</span>

<span class="nc" id="L432">            rPath[0] = path;</span>
<span class="nc" id="L433">            removeSelectionPaths(rPath);</span>
        }
<span class="nc" id="L435">    }</span>

    /**
      * Removes paths from the selection.  If any of the paths in paths
      * are in the selection the TreeSelectionListeners are notified.
      * This has no effect if &lt;code&gt;paths&lt;/code&gt; is null.
      *
      * @param paths the paths to remove from the selection
      */
    public void removeSelectionPaths(TreePath[] paths) {
<span class="nc bnc" id="L445" title="All 6 branches missed.">        if (paths != null &amp;&amp; selection != null &amp;&amp; paths.length &gt; 0) {</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if(!canPathsBeRemoved(paths)) {</span>
                /* Could probably do something more interesting here! */
<span class="nc" id="L448">                clearSelection();</span>
            }
            else {
<span class="nc" id="L451">                Vector&lt;PathPlaceHolder&gt; pathsToRemove = null;</span>

                /* Find the paths that can be removed. */
<span class="nc bnc" id="L454" title="All 2 branches missed.">                for (int removeCounter = paths.length - 1; removeCounter &gt;= 0;</span>
<span class="nc" id="L455">                     removeCounter--) {</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                    if(paths[removeCounter] != null) {</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                        if (uniquePaths.get(paths[removeCounter]) != null) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                            if(pathsToRemove == null)</span>
<span class="nc" id="L459">                                pathsToRemove = new Vector&lt;PathPlaceHolder&gt;(paths.length);</span>
<span class="nc" id="L460">                            uniquePaths.remove(paths[removeCounter]);</span>
<span class="nc" id="L461">                            pathsToRemove.addElement(new PathPlaceHolder</span>
                                         (paths[removeCounter], false));
                        }
                    }
                }
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if(pathsToRemove != null) {</span>
<span class="nc" id="L467">                    int         removeCount = pathsToRemove.size();</span>
<span class="nc" id="L468">                    TreePath    beginLeadPath = leadPath;</span>

<span class="nc bnc" id="L470" title="All 2 branches missed.">                    if(removeCount == selection.length) {</span>
<span class="nc" id="L471">                        selection = null;</span>
                    }
                    else {
<span class="nc" id="L474">                        Enumeration&lt;TreePath&gt; pEnum = uniquePaths.keys();</span>
<span class="nc" id="L475">                        int                  validCount = 0;</span>

<span class="nc" id="L477">                        selection = new TreePath[selection.length -</span>
                                                removeCount];
<span class="nc bnc" id="L479" title="All 2 branches missed.">                        while (pEnum.hasMoreElements()) {</span>
<span class="nc" id="L480">                            selection[validCount++] = pEnum.nextElement();</span>
                        }
                    }
<span class="nc bnc" id="L483" title="All 2 branches missed.">                    if (leadPath != null &amp;&amp;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                        uniquePaths.get(leadPath) == null) {</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">                        if (selection != null) {</span>
<span class="nc" id="L486">                            leadPath = selection[selection.length - 1];</span>
                        }
                        else {
<span class="nc" id="L489">                            leadPath = null;</span>
                        }
                    }
<span class="nc bnc" id="L492" title="All 2 branches missed.">                    else if (selection != null) {</span>
<span class="nc" id="L493">                        leadPath = selection[selection.length - 1];</span>
                    }
                    else {
<span class="nc" id="L496">                        leadPath = null;</span>
                    }
<span class="nc" id="L498">                    updateLeadIndex();</span>

<span class="nc" id="L500">                    resetRowSelection();</span>

<span class="nc" id="L502">                    notifyPathChange(pathsToRemove, beginLeadPath);</span>
                }
            }
        }
<span class="nc" id="L506">    }</span>

    /**
      * Returns the first path in the selection. This is useful if there
      * if only one item currently selected.
      */
    public TreePath getSelectionPath() {
<span class="nc bnc" id="L513" title="All 4 branches missed.">        if (selection != null &amp;&amp; selection.length &gt; 0) {</span>
<span class="nc" id="L514">            return selection[0];</span>
        }
<span class="nc" id="L516">        return null;</span>
    }

    /**
      * Returns the selection.
      *
      * @return the selection
      */
    public TreePath[] getSelectionPaths() {
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if(selection != null) {</span>
<span class="nc" id="L526">            int                 pathSize = selection.length;</span>
<span class="nc" id="L527">            TreePath[]          result = new TreePath[pathSize];</span>

<span class="nc" id="L529">            System.arraycopy(selection, 0, result, 0, pathSize);</span>
<span class="nc" id="L530">            return result;</span>
        }
<span class="nc" id="L532">        return new TreePath[0];</span>
    }

    /**
     * Returns the number of paths that are selected.
     */
    public int getSelectionCount() {
<span class="nc bnc" id="L539" title="All 2 branches missed.">        return (selection == null) ? 0 : selection.length;</span>
    }

    /**
      * Returns true if the path, &lt;code&gt;path&lt;/code&gt;,
      * is in the current selection.
      */
    public boolean isPathSelected(TreePath path) {
<span class="nc bnc" id="L547" title="All 4 branches missed.">        return (path != null) ? (uniquePaths.get(path) != null) : false;</span>
    }

    /**
      * Returns true if the selection is currently empty.
      */
    public boolean isSelectionEmpty() {
<span class="nc bnc" id="L554" title="All 4 branches missed.">        return (selection == null || selection.length == 0);</span>
    }

    /**
      * Empties the current selection.  If this represents a change in the
      * current selection, the selection listeners are notified.
      */
    public void clearSelection() {
<span class="nc bnc" id="L562" title="All 4 branches missed.">        if (selection != null &amp;&amp; selection.length &gt; 0) {</span>
<span class="nc" id="L563">            int                    selSize = selection.length;</span>
<span class="nc" id="L564">            boolean[]              newness = new boolean[selSize];</span>

<span class="nc bnc" id="L566" title="All 2 branches missed.">            for(int counter = 0; counter &lt; selSize; counter++)</span>
<span class="nc" id="L567">                newness[counter] = false;</span>

<span class="nc" id="L569">            TreeSelectionEvent     event = new TreeSelectionEvent</span>
                (this, selection, newness, leadPath, null);

<span class="nc" id="L572">            leadPath = null;</span>
<span class="nc" id="L573">            leadIndex = leadRow = -1;</span>
<span class="nc" id="L574">            uniquePaths.clear();</span>
<span class="nc" id="L575">            selection = null;</span>
<span class="nc" id="L576">            resetRowSelection();</span>
<span class="nc" id="L577">            fireValueChanged(event);</span>
        }
<span class="nc" id="L579">    }</span>

    /**
      * Adds x to the list of listeners that are notified each time the
      * set of selected TreePaths changes.
      *
      * @param x the new listener to be added
      */
    public void addTreeSelectionListener(TreeSelectionListener x) {
<span class="nc" id="L588">        listenerList.add(TreeSelectionListener.class, x);</span>
<span class="nc" id="L589">    }</span>

    /**
      * Removes x from the list of listeners that are notified each time
      * the set of selected TreePaths changes.
      *
      * @param x the listener to remove
      */
    public void removeTreeSelectionListener(TreeSelectionListener x) {
<span class="nc" id="L598">        listenerList.remove(TreeSelectionListener.class, x);</span>
<span class="nc" id="L599">    }</span>

    /**
     * Returns an array of all the tree selection listeners
     * registered on this model.
     *
     * @return all of this model's &lt;code&gt;TreeSelectionListener&lt;/code&gt;s
     *         or an empty
     *         array if no tree selection listeners are currently registered
     *
     * @see #addTreeSelectionListener
     * @see #removeTreeSelectionListener
     *
     * @since 1.4
     */
    public TreeSelectionListener[] getTreeSelectionListeners() {
<span class="nc" id="L615">        return listenerList.getListeners(TreeSelectionListener.class);</span>
    }

    /**
     * Notifies all listeners that are registered for
     * tree selection events on this object.
     * @see #addTreeSelectionListener
     * @see EventListenerList
     */
    protected void fireValueChanged(TreeSelectionEvent e) {
        // Guaranteed to return a non-null array
<span class="nc" id="L626">        Object[] listeners = listenerList.getListenerList();</span>
        // TreeSelectionEvent e = null;
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L630" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (listeners[i]==TreeSelectionListener.class) {</span>
                // Lazily create the event:
                // if (e == null)
                // e = new ListSelectionEvent(this, firstIndex, lastIndex);
<span class="nc" id="L635">                ((TreeSelectionListener)listeners[i+1]).valueChanged(e);</span>
            }
        }
<span class="nc" id="L638">    }</span>

    /**
     * Returns an array of all the objects currently registered
     * as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this model.
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
     * &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
     *
     * &lt;p&gt;
     *
     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
     * with a class literal,
     * such as
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a
     * &lt;code&gt;DefaultTreeSelectionModel&lt;/code&gt; &lt;code&gt;m&lt;/code&gt;
     * for its tree selection listeners with the following code:
     *
     * &lt;pre&gt;TreeSelectionListener[] tsls = (TreeSelectionListener[])(m.getListeners(TreeSelectionListener.class));&lt;/pre&gt;
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s on this component,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
     *          doesn't specify a class or interface that implements
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     *
     * @see #getTreeSelectionListeners
     * @see #getPropertyChangeListeners
     *
     * @since 1.3
     */
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L678">        return listenerList.getListeners(listenerType);</span>
    }

    /**
     * Returns the selection in terms of rows. There is not
     * necessarily a one-to-one mapping between the {@code TreePath}s
     * returned from {@code getSelectionPaths} and this method. In
     * particular, if a {@code TreePath} is not viewable (the {@code
     * RowMapper} returns {@code -1} for the row corresponding to the
     * {@code TreePath}), then the corresponding row is not included
     * in the returned array. For example, if the selection consists
     * of two paths, {@code A} and {@code B}, with {@code A} at row
     * {@code 10}, and {@code B} not currently viewable, then this method
     * returns an array with the single entry {@code 10}.
     *
     * @return the selection in terms of rows
     */
    public int[] getSelectionRows() {
        // This is currently rather expensive.  Needs
        // to be better support from ListSelectionModel to speed this up.
<span class="nc bnc" id="L698" title="All 6 branches missed.">        if (rowMapper != null &amp;&amp; selection != null &amp;&amp; selection.length &gt; 0) {</span>
<span class="nc" id="L699">            int[]      rows = rowMapper.getRowsForPaths(selection);</span>

<span class="nc bnc" id="L701" title="All 2 branches missed.">            if (rows != null) {</span>
<span class="nc" id="L702">                int       invisCount = 0;</span>

<span class="nc bnc" id="L704" title="All 2 branches missed.">                for (int counter = rows.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">                    if (rows[counter] == -1) {</span>
<span class="nc" id="L706">                        invisCount++;</span>
                    }
                }
<span class="nc bnc" id="L709" title="All 2 branches missed.">                if (invisCount &gt; 0) {</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">                    if (invisCount == rows.length) {</span>
<span class="nc" id="L711">                        rows = null;</span>
                    }
                    else {
<span class="nc" id="L714">                        int[]    tempRows = new int[rows.length - invisCount];</span>

<span class="nc" id="L716">                        for (int counter = rows.length - 1, visCounter = 0;</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">                             counter &gt;= 0; counter--) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">                            if (rows[counter] != -1) {</span>
<span class="nc" id="L719">                                tempRows[visCounter++] = rows[counter];</span>
                            }
                        }
<span class="nc" id="L722">                        rows = tempRows;</span>
                    }
                }
            }
<span class="nc" id="L726">            return rows;</span>
        }
<span class="nc" id="L728">        return new int[0];</span>
    }

    /**
     * Returns the smallest value obtained from the RowMapper for the
     * current set of selected TreePaths. If nothing is selected,
     * or there is no RowMapper, this will return -1.
      */
    public int getMinSelectionRow() {
<span class="nc" id="L737">        return listSelectionModel.getMinSelectionIndex();</span>
    }

    /**
     * Returns the largest value obtained from the RowMapper for the
     * current set of selected TreePaths. If nothing is selected,
     * or there is no RowMapper, this will return -1.
      */
    public int getMaxSelectionRow() {
<span class="nc" id="L746">        return listSelectionModel.getMaxSelectionIndex();</span>
    }

    /**
      * Returns true if the row identified by &lt;code&gt;row&lt;/code&gt; is selected.
      */
    public boolean isRowSelected(int row) {
<span class="nc" id="L753">        return listSelectionModel.isSelectedIndex(row);</span>
    }

    /**
     * Updates this object's mapping from TreePath to rows. This should
     * be invoked when the mapping from TreePaths to integers has changed
     * (for example, a node has been expanded).
     * &lt;p&gt;You do not normally have to call this, JTree and its associated
     * Listeners will invoke this for you. If you are implementing your own
     * View class, then you will have to invoke this.
     * &lt;p&gt;This will invoke &lt;code&gt;insureRowContinuity&lt;/code&gt; to make sure
     * the currently selected TreePaths are still valid based on the
     * selection mode.
     */
    public void resetRowSelection() {
<span class="nc" id="L768">        listSelectionModel.clearSelection();</span>
<span class="nc bnc" id="L769" title="All 4 branches missed.">        if(selection != null &amp;&amp; rowMapper != null) {</span>
            int               aRow;
<span class="nc" id="L771">            int               validCount = 0;</span>
<span class="nc" id="L772">            int[]             rows = rowMapper.getRowsForPaths(selection);</span>

<span class="nc" id="L774">            for(int counter = 0, maxCounter = selection.length;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">                counter &lt; maxCounter; counter++) {</span>
<span class="nc" id="L776">                aRow = rows[counter];</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                if(aRow != -1) {</span>
<span class="nc" id="L778">                    listSelectionModel.addSelectionInterval(aRow, aRow);</span>
                }
            }
<span class="nc bnc" id="L781" title="All 4 branches missed.">            if(leadIndex != -1 &amp;&amp; rows != null) {</span>
<span class="nc" id="L782">                leadRow = rows[leadIndex];</span>
            }
<span class="nc bnc" id="L784" title="All 2 branches missed.">            else if (leadPath != null) {</span>
                // Lead selection path doesn't have to be in the selection.
<span class="nc" id="L786">                tempPaths[0] = leadPath;</span>
<span class="nc" id="L787">                rows = rowMapper.getRowsForPaths(tempPaths);</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">                leadRow = (rows != null) ? rows[0] : -1;</span>
            }
            else {
<span class="nc" id="L791">                leadRow = -1;</span>
            }
<span class="nc" id="L793">            insureRowContinuity();</span>

<span class="nc" id="L795">        }</span>
        else
<span class="nc" id="L797">            leadRow = -1;</span>
<span class="nc" id="L798">    }</span>

    /**
     * Returns the lead selection index. That is the last index that was
     * added.
     */
    public int getLeadSelectionRow() {
<span class="nc" id="L805">        return leadRow;</span>
    }

    /**
     * Returns the last path that was added. This may differ from the
     * leadSelectionPath property maintained by the JTree.
     */
    public TreePath getLeadSelectionPath() {
<span class="nc" id="L813">        return leadPath;</span>
    }

    /**
     * Adds a PropertyChangeListener to the listener list.
     * The listener is registered for all properties.
     * &lt;p&gt;
     * A PropertyChangeEvent will get fired when the selection mode
     * changes.
     *
     * @param listener  the PropertyChangeListener to be added
     */
    public synchronized void addPropertyChangeListener(
                                PropertyChangeListener listener) {
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (changeSupport == null) {</span>
<span class="nc" id="L828">            changeSupport = new SwingPropertyChangeSupport(this);</span>
        }
<span class="nc" id="L830">        changeSupport.addPropertyChangeListener(listener);</span>
<span class="nc" id="L831">    }</span>

    /**
     * Removes a PropertyChangeListener from the listener list.
     * This removes a PropertyChangeListener that was registered
     * for all properties.
     *
     * @param listener  the PropertyChangeListener to be removed
     */

    public synchronized void removePropertyChangeListener(
                                PropertyChangeListener listener) {
<span class="nc bnc" id="L843" title="All 2 branches missed.">        if (changeSupport == null) {</span>
<span class="nc" id="L844">            return;</span>
        }
<span class="nc" id="L846">        changeSupport.removePropertyChangeListener(listener);</span>
<span class="nc" id="L847">    }</span>

    /**
     * Returns an array of all the property change listeners
     * registered on this &lt;code&gt;DefaultTreeSelectionModel&lt;/code&gt;.
     *
     * @return all of this model's &lt;code&gt;PropertyChangeListener&lt;/code&gt;s
     *         or an empty
     *         array if no property change listeners are currently registered
     *
     * @see #addPropertyChangeListener
     * @see #removePropertyChangeListener
     *
     * @since 1.4
     */
    public PropertyChangeListener[] getPropertyChangeListeners() {
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (changeSupport == null) {</span>
<span class="nc" id="L864">            return new PropertyChangeListener[0];</span>
        }
<span class="nc" id="L866">        return changeSupport.getPropertyChangeListeners();</span>
    }

    /**
     * Makes sure the currently selected &lt;code&gt;TreePath&lt;/code&gt;s are valid
     * for the current selection mode.
     * If the selection mode is &lt;code&gt;CONTIGUOUS_TREE_SELECTION&lt;/code&gt;
     * and a &lt;code&gt;RowMapper&lt;/code&gt; exists, this will make sure all
     * the rows are contiguous, that is, when sorted all the rows are
     * in order with no gaps.
     * If the selection isn't contiguous, the selection is
     * reset to contain the first set, when sorted, of contiguous rows.
     * &lt;p&gt;
     * If the selection mode is &lt;code&gt;SINGLE_TREE_SELECTION&lt;/code&gt; and
     * more than one TreePath is selected, the selection is reset to
     * contain the first path currently selected.
     */
    protected void insureRowContinuity() {
<span class="nc bnc" id="L884" title="All 6 branches missed.">        if(selectionMode == TreeSelectionModel.CONTIGUOUS_TREE_SELECTION &amp;&amp;</span>
           selection != null &amp;&amp; rowMapper != null) {
<span class="nc" id="L886">            DefaultListSelectionModel lModel = listSelectionModel;</span>
<span class="nc" id="L887">            int                       min = lModel.getMinSelectionIndex();</span>

<span class="nc bnc" id="L889" title="All 2 branches missed.">            if(min != -1) {</span>
<span class="nc" id="L890">                for(int counter = min,</span>
<span class="nc" id="L891">                        maxCounter = lModel.getMaxSelectionIndex();</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">                        counter &lt;= maxCounter; counter++) {</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">                    if(!lModel.isSelectedIndex(counter)) {</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">                        if(counter == min) {</span>
<span class="nc" id="L895">                            clearSelection();</span>
                        }
                        else {
<span class="nc" id="L898">                            TreePath[] newSel = new TreePath[counter - min];</span>
<span class="nc" id="L899">                            int selectionIndex[] = rowMapper.getRowsForPaths(selection);</span>
                            // find the actual selection pathes corresponded to the
                            // rows of the new selection
<span class="nc bnc" id="L902" title="All 2 branches missed.">                            for (int i = 0; i &lt; selectionIndex.length; i++) {</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">                                if (selectionIndex[i]&lt;counter) {</span>
<span class="nc" id="L904">                                    newSel[selectionIndex[i]-min] = selection[i];</span>
                                }
                            }
<span class="nc" id="L907">                            setSelectionPaths(newSel);</span>
<span class="nc" id="L908">                            break;</span>
                        }
                    }
                }
            }
<span class="nc" id="L913">        }</span>
<span class="nc bnc" id="L914" title="All 6 branches missed.">        else if(selectionMode == TreeSelectionModel.SINGLE_TREE_SELECTION &amp;&amp;</span>
                selection != null &amp;&amp; selection.length &gt; 1) {
<span class="nc" id="L916">            setSelectionPath(selection[0]);</span>
        }
<span class="nc" id="L918">    }</span>

    /**
     * Returns true if the paths are contiguous,
     * or this object has no RowMapper.
     */
    protected boolean arePathsContiguous(TreePath[] paths) {
<span class="nc bnc" id="L925" title="All 4 branches missed.">        if(rowMapper == null || paths.length &lt; 2)</span>
<span class="nc" id="L926">            return true;</span>
        else {
<span class="nc" id="L928">            BitSet                             bitSet = new BitSet(32);</span>
            int                                anIndex, counter, min;
<span class="nc" id="L930">            int                                pathCount = paths.length;</span>
<span class="nc" id="L931">            int                                validCount = 0;</span>
<span class="nc" id="L932">            TreePath[]                         tempPath = new TreePath[1];</span>

<span class="nc" id="L934">            tempPath[0] = paths[0];</span>
<span class="nc" id="L935">            min = rowMapper.getRowsForPaths(tempPath)[0];</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">            for(counter = 0; counter &lt; pathCount; counter++) {</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">                if(paths[counter] != null) {</span>
<span class="nc" id="L938">                    tempPath[0] = paths[counter];</span>
<span class="nc" id="L939">                    int[] rows = rowMapper.getRowsForPaths(tempPath);</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">                    if (rows == null) {</span>
<span class="nc" id="L941">                        return false;</span>
                    }
<span class="nc" id="L943">                    anIndex = rows[0];</span>
<span class="nc bnc" id="L944" title="All 6 branches missed.">                    if(anIndex == -1 || anIndex &lt; (min - pathCount) ||</span>
                       anIndex &gt; (min + pathCount))
<span class="nc" id="L946">                        return false;</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">                    if(anIndex &lt; min)</span>
<span class="nc" id="L948">                        min = anIndex;</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                    if(!bitSet.get(anIndex)) {</span>
<span class="nc" id="L950">                        bitSet.set(anIndex);</span>
<span class="nc" id="L951">                        validCount++;</span>
                    }
                }
            }
<span class="nc" id="L955">            int          maxCounter = validCount + min;</span>

<span class="nc bnc" id="L957" title="All 2 branches missed.">            for(counter = min; counter &lt; maxCounter; counter++)</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">                if(!bitSet.get(counter))</span>
<span class="nc" id="L959">                    return false;</span>
        }
<span class="nc" id="L961">        return true;</span>
    }

    /**
     * Used to test if a particular set of &lt;code&gt;TreePath&lt;/code&gt;s can
     * be added. This will return true if &lt;code&gt;paths&lt;/code&gt; is null (or
     * empty), or this object has no RowMapper, or nothing is currently selected,
     * or the selection mode is &lt;code&gt;DISCONTIGUOUS_TREE_SELECTION&lt;/code&gt;, or
     * adding the paths to the current selection still results in a
     * contiguous set of &lt;code&gt;TreePath&lt;/code&gt;s.
     */
    protected boolean canPathsBeAdded(TreePath[] paths) {
<span class="nc bnc" id="L973" title="All 10 branches missed.">        if(paths == null || paths.length == 0 || rowMapper == null ||</span>
           selection == null || selectionMode ==
           TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION)
<span class="nc" id="L976">            return true;</span>
        else {
<span class="nc" id="L978">            BitSet                       bitSet = new BitSet();</span>
<span class="nc" id="L979">            DefaultListSelectionModel    lModel = listSelectionModel;</span>
            int                          anIndex;
            int                          counter;
<span class="nc" id="L982">            int                          min = lModel.getMinSelectionIndex();</span>
<span class="nc" id="L983">            int                          max = lModel.getMaxSelectionIndex();</span>
<span class="nc" id="L984">            TreePath[]                   tempPath = new TreePath[1];</span>

<span class="nc bnc" id="L986" title="All 2 branches missed.">            if(min != -1) {</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">                for(counter = min; counter &lt;= max; counter++) {</span>
<span class="nc bnc" id="L988" title="All 2 branches missed.">                    if(lModel.isSelectedIndex(counter))</span>
<span class="nc" id="L989">                        bitSet.set(counter);</span>
                }
            }
            else {
<span class="nc" id="L993">                tempPath[0] = paths[0];</span>
<span class="nc" id="L994">                min = max = rowMapper.getRowsForPaths(tempPath)[0];</span>
            }
<span class="nc bnc" id="L996" title="All 2 branches missed.">            for(counter = paths.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">                if(paths[counter] != null) {</span>
<span class="nc" id="L998">                    tempPath[0] = paths[counter];</span>
<span class="nc" id="L999">                    int[]   rows = rowMapper.getRowsForPaths(tempPath);</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">                    if (rows == null) {</span>
<span class="nc" id="L1001">                        return false;</span>
                    }
<span class="nc" id="L1003">                    anIndex = rows[0];</span>
<span class="nc" id="L1004">                    min = Math.min(anIndex, min);</span>
<span class="nc" id="L1005">                    max = Math.max(anIndex, max);</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                    if(anIndex == -1)</span>
<span class="nc" id="L1007">                        return false;</span>
<span class="nc" id="L1008">                    bitSet.set(anIndex);</span>
                }
            }
<span class="nc bnc" id="L1011" title="All 2 branches missed.">            for(counter = min; counter &lt;= max; counter++)</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                if(!bitSet.get(counter))</span>
<span class="nc" id="L1013">                    return false;</span>
        }
<span class="nc" id="L1015">        return true;</span>
    }

    /**
     * Returns true if the paths can be removed without breaking the
     * continuity of the model.
     * This is rather expensive.
     */
    protected boolean canPathsBeRemoved(TreePath[] paths) {
<span class="nc bnc" id="L1024" title="All 6 branches missed.">        if(rowMapper == null || selection == null ||</span>
           selectionMode == TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION)
<span class="nc" id="L1026">            return true;</span>
        else {
<span class="nc" id="L1028">            BitSet               bitSet = new BitSet();</span>
            int                  counter;
<span class="nc" id="L1030">            int                  pathCount = paths.length;</span>
            int                  anIndex;
<span class="nc" id="L1032">            int                  min = -1;</span>
<span class="nc" id="L1033">            int                  validCount = 0;</span>
<span class="nc" id="L1034">            TreePath[]           tempPath = new TreePath[1];</span>
            int[]                rows;

            /* Determine the rows for the removed entries. */
<span class="nc" id="L1038">            lastPaths.clear();</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            for (counter = 0; counter &lt; pathCount; counter++) {</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">                if (paths[counter] != null) {</span>
<span class="nc" id="L1041">                    lastPaths.put(paths[counter], Boolean.TRUE);</span>
                }
            }
<span class="nc bnc" id="L1044" title="All 2 branches missed.">            for(counter = selection.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                if(lastPaths.get(selection[counter]) == null) {</span>
<span class="nc" id="L1046">                    tempPath[0] = selection[counter];</span>
<span class="nc" id="L1047">                    rows = rowMapper.getRowsForPaths(tempPath);</span>
<span class="nc bnc" id="L1048" title="All 6 branches missed.">                    if(rows != null &amp;&amp; rows[0] != -1 &amp;&amp; !bitSet.get(rows[0])) {</span>
<span class="nc" id="L1049">                        validCount++;</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                        if(min == -1)</span>
<span class="nc" id="L1051">                            min = rows[0];</span>
                        else
<span class="nc" id="L1053">                            min = Math.min(min, rows[0]);</span>
<span class="nc" id="L1054">                        bitSet.set(rows[0]);</span>
                    }
                }
            }
<span class="nc" id="L1058">            lastPaths.clear();</span>
            /* Make sure they are contiguous. */
<span class="nc bnc" id="L1060" title="All 2 branches missed.">            if(validCount &gt; 1) {</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">                for(counter = min + validCount - 1; counter &gt;= min;</span>
<span class="nc" id="L1062">                    counter--)</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">                    if(!bitSet.get(counter))</span>
<span class="nc" id="L1064">                        return false;</span>
            }
        }
<span class="nc" id="L1067">        return true;</span>
    }

    /**
     * Notifies listeners of a change in path. changePaths should contain
     * instances of PathPlaceHolder.
     *
     * @deprecated As of JDK version 1.7
     */
    @Deprecated
    protected void notifyPathChange(Vector&lt;?&gt; changedPaths,
                                    TreePath oldLeadSelection) {
<span class="nc" id="L1079">        int                    cPathCount = changedPaths.size();</span>
<span class="nc" id="L1080">        boolean[]              newness = new boolean[cPathCount];</span>
<span class="nc" id="L1081">        TreePath[]            paths = new TreePath[cPathCount];</span>
        PathPlaceHolder        placeholder;

<span class="nc bnc" id="L1084" title="All 2 branches missed.">        for(int counter = 0; counter &lt; cPathCount; counter++) {</span>
<span class="nc" id="L1085">            placeholder = (PathPlaceHolder) changedPaths.elementAt(counter);</span>
<span class="nc" id="L1086">            newness[counter] = placeholder.isNew;</span>
<span class="nc" id="L1087">            paths[counter] = placeholder.path;</span>
        }

<span class="nc" id="L1090">        TreeSelectionEvent     event = new TreeSelectionEvent</span>
                          (this, paths, newness, oldLeadSelection, leadPath);

<span class="nc" id="L1093">        fireValueChanged(event);</span>
<span class="nc" id="L1094">    }</span>

    /**
     * Updates the leadIndex instance variable.
     */
    protected void updateLeadIndex() {
<span class="nc bnc" id="L1100" title="All 2 branches missed.">        if(leadPath != null) {</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">            if(selection == null) {</span>
<span class="nc" id="L1102">                leadPath = null;</span>
<span class="nc" id="L1103">                leadIndex = leadRow = -1;</span>
            }
            else {
<span class="nc" id="L1106">                leadRow = leadIndex = -1;</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">                for(int counter = selection.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L1108">                    counter--) {</span>
                    // Can use == here since we know leadPath came from
                    // selection
<span class="nc bnc" id="L1111" title="All 2 branches missed.">                    if(selection[counter] == leadPath) {</span>
<span class="nc" id="L1112">                        leadIndex = counter;</span>
<span class="nc" id="L1113">                        break;</span>
                    }
                }
            }
        }
        else {
<span class="nc" id="L1119">            leadIndex = -1;</span>
        }
<span class="nc" id="L1121">    }</span>

    /**
     * This method is obsolete and its implementation is now a noop.  It's
     * still called by setSelectionPaths and addSelectionPaths, but only
     * for backwards compatibility.
     */
    protected void insureUniqueness() {
<span class="nc" id="L1129">    }</span>


    /**
     * Returns a string that displays and identifies this
     * object's properties.
     *
     * @return a String representation of this object
     */
    public String toString() {
<span class="nc" id="L1139">        int                selCount = getSelectionCount();</span>
<span class="nc" id="L1140">        StringBuffer       retBuffer = new StringBuffer();</span>
        int[]              rows;

<span class="nc bnc" id="L1143" title="All 2 branches missed.">        if(rowMapper != null)</span>
<span class="nc" id="L1144">            rows = rowMapper.getRowsForPaths(selection);</span>
        else
<span class="nc" id="L1146">            rows = null;</span>
<span class="nc" id="L1147">        retBuffer.append(getClass().getName() + &quot; &quot; + hashCode() + &quot; [ &quot;);</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">        for(int counter = 0; counter &lt; selCount; counter++) {</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">            if(rows != null)</span>
<span class="nc" id="L1150">                retBuffer.append(selection[counter].toString() + &quot;@&quot; +</span>
<span class="nc" id="L1151">                                 Integer.toString(rows[counter])+ &quot; &quot;);</span>
            else
<span class="nc" id="L1153">                retBuffer.append(selection[counter].toString() + &quot; &quot;);</span>
        }
<span class="nc" id="L1155">        retBuffer.append(&quot;]&quot;);</span>
<span class="nc" id="L1156">        return retBuffer.toString();</span>
    }

    /**
     * Returns a clone of this object with the same selection.
     * This method does not duplicate
     * selection listeners and property listeners.
     *
     * @exception CloneNotSupportedException never thrown by instances of
     *                                       this class
     */
    public Object clone() throws CloneNotSupportedException {
<span class="nc" id="L1168">        DefaultTreeSelectionModel        clone = (DefaultTreeSelectionModel)</span>
<span class="nc" id="L1169">                            super.clone();</span>

<span class="nc" id="L1171">        clone.changeSupport = null;</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">        if(selection != null) {</span>
<span class="nc" id="L1173">            int              selLength = selection.length;</span>

<span class="nc" id="L1175">            clone.selection = new TreePath[selLength];</span>
<span class="nc" id="L1176">            System.arraycopy(selection, 0, clone.selection, 0, selLength);</span>
        }
<span class="nc" id="L1178">        clone.listenerList = new EventListenerList();</span>
<span class="nc" id="L1179">        clone.listSelectionModel = (DefaultListSelectionModel)</span>
<span class="nc" id="L1180">            listSelectionModel.clone();</span>
<span class="nc" id="L1181">        clone.uniquePaths = new Hashtable&lt;TreePath, Boolean&gt;();</span>
<span class="nc" id="L1182">        clone.lastPaths = new Hashtable&lt;TreePath, Boolean&gt;();</span>
<span class="nc" id="L1183">        clone.tempPaths = new TreePath[1];</span>
<span class="nc" id="L1184">        return clone;</span>
    }

    // Serialization support.
    private void writeObject(ObjectOutputStream s) throws IOException {
        Object[]             tValues;

<span class="nc" id="L1191">        s.defaultWriteObject();</span>
        // Save the rowMapper, if it implements Serializable
<span class="nc bnc" id="L1193" title="All 4 branches missed.">        if(rowMapper != null &amp;&amp; rowMapper instanceof Serializable) {</span>
<span class="nc" id="L1194">            tValues = new Object[2];</span>
<span class="nc" id="L1195">            tValues[0] = &quot;rowMapper&quot;;</span>
<span class="nc" id="L1196">            tValues[1] = rowMapper;</span>
        }
        else
<span class="nc" id="L1199">            tValues = new Object[0];</span>
<span class="nc" id="L1200">        s.writeObject(tValues);</span>
<span class="nc" id="L1201">    }</span>


    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
        Object[]      tValues;

<span class="nc" id="L1208">        s.defaultReadObject();</span>

<span class="nc" id="L1210">        tValues = (Object[])s.readObject();</span>

<span class="nc bnc" id="L1212" title="All 4 branches missed.">        if(tValues.length &gt; 0 &amp;&amp; tValues[0].equals(&quot;rowMapper&quot;))</span>
<span class="nc" id="L1213">            rowMapper = (RowMapper)tValues[1];</span>
<span class="nc" id="L1214">    }</span>
}

/**
 * Holds a path and whether or not it is new.
 */
class PathPlaceHolder {
    protected boolean             isNew;
    protected TreePath           path;

<span class="nc" id="L1224">    PathPlaceHolder(TreePath path, boolean isNew) {</span>
<span class="nc" id="L1225">        this.path = path;</span>
<span class="nc" id="L1226">        this.isNew = isNew;</span>
<span class="nc" id="L1227">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>