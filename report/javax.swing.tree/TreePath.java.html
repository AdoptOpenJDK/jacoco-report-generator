<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TreePath.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.tree</a> &gt; <span class="el_source">TreePath.java</span></div><h1>TreePath.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.tree;

import java.io.*;
import java.beans.ConstructorProperties;

/**
 * {@code TreePath} represents an array of objects that uniquely
 * identify the path to a node in a tree. The elements of the array
 * are ordered with the root as the first element of the array. For
 * example, a file on the file system is uniquely identified based on
 * the array of parent directories and the name of the file. The path
 * {@code /tmp/foo/bar} could be represented by a {@code TreePath} as
 * {@code new TreePath(new Object[] {&quot;tmp&quot;, &quot;foo&quot;, &quot;bar&quot;})}.
 * &lt;p&gt;
 * {@code TreePath} is used extensively by {@code JTree} and related classes.
 * For example, {@code JTree} represents the selection as an array of
 * {@code TreePath}s. When used with {@code JTree}, the elements of the
 * path are the objects returned from the {@code TreeModel}. When {@code JTree}
 * is paired with {@code DefaultTreeModel}, the elements of the
 * path are {@code TreeNode}s. The following example illustrates extracting
 * the user object from the selection of a {@code JTree}:
 * &lt;pre&gt;
 *   DefaultMutableTreeNode root = ...;
 *   DefaultTreeModel model = new DefaultTreeModel(root);
 *   JTree tree = new JTree(model);
 *   ...
 *   TreePath selectedPath = tree.getSelectionPath();
 *   DefaultMutableTreeNode selectedNode =
 *       ((DefaultMutableTreeNode)selectedPath.getLastPathComponent()).
 *       getUserObject();
 * &lt;/pre&gt;
 * Subclasses typically need override only {@code
 * getLastPathComponent}, and {@code getParentPath}. As {@code JTree}
 * internally creates {@code TreePath}s at various points, it's
 * generally not useful to subclass {@code TreePath} and use with
 * {@code JTree}.
 * &lt;p&gt;
 * While {@code TreePath} is serializable, a {@code
 * NotSerializableException} is thrown if any elements of the path are
 * not serializable.
 * &lt;p&gt;
 * For further information and examples of using tree paths,
 * see &lt;a
 href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;How to Use Trees&lt;/a&gt;
 * in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author Scott Violet
 * @author Philip Milne
 */
public class TreePath extends Object implements Serializable {
    /** Path representing the parent, null if lastPathComponent represents
     * the root. */
    private TreePath           parentPath;
    /** Last path component. */
    private Object lastPathComponent;

    /**
     * Creates a {@code TreePath} from an array. The array uniquely
     * identifies the path to a node.
     *
     * @param path an array of objects representing the path to a node
     * @throws IllegalArgumentException if {@code path} is {@code null},
     *         empty, or contains a {@code null} value
     */
    @ConstructorProperties({&quot;path&quot;})
<span class="nc" id="L100">    public TreePath(Object[] path) {</span>
<span class="nc bnc" id="L101" title="All 4 branches missed.">        if(path == null || path.length == 0)</span>
<span class="nc" id="L102">            throw new IllegalArgumentException(&quot;path in TreePath must be non null and not empty.&quot;);</span>
<span class="nc" id="L103">        lastPathComponent = path[path.length - 1];</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (lastPathComponent == null) {</span>
<span class="nc" id="L105">            throw new IllegalArgumentException(</span>
                &quot;Last path component must be non-null&quot;);
        }
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if(path.length &gt; 1)</span>
<span class="nc" id="L109">            parentPath = new TreePath(path, path.length - 1);</span>
<span class="nc" id="L110">    }</span>

    /**
     * Creates a {@code TreePath} containing a single element. This is
     * used to construct a {@code TreePath} identifying the root.
     *
     * @param lastPathComponent the root
     * @see #TreePath(Object[])
     * @throws IllegalArgumentException if {@code lastPathComponent} is
     *         {@code null}
     */
<span class="nc" id="L121">    public TreePath(Object lastPathComponent) {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if(lastPathComponent == null)</span>
<span class="nc" id="L123">            throw new IllegalArgumentException(&quot;path in TreePath must be non null.&quot;);</span>
<span class="nc" id="L124">        this.lastPathComponent = lastPathComponent;</span>
<span class="nc" id="L125">        parentPath = null;</span>
<span class="nc" id="L126">    }</span>

    /**
     * Creates a {@code TreePath} with the specified parent and element.
     *
     * @param parent the path to the parent, or {@code null} to indicate
     *        the root
     * @param lastPathComponent the last path element
     * @throws IllegalArgumentException if {@code lastPathComponent} is
     *         {@code null}
     */
<span class="nc" id="L137">    protected TreePath(TreePath parent, Object lastPathComponent) {</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if(lastPathComponent == null)</span>
<span class="nc" id="L139">            throw new IllegalArgumentException(&quot;path in TreePath must be non null.&quot;);</span>
<span class="nc" id="L140">        parentPath = parent;</span>
<span class="nc" id="L141">        this.lastPathComponent = lastPathComponent;</span>
<span class="nc" id="L142">    }</span>

    /**
     * Creates a {@code TreePath} from an array. The returned
     * {@code TreePath} represents the elements of the array from
     * {@code 0} to {@code length - 1}.
     * &lt;p&gt;
     * This constructor is used internally, and generally not useful outside
     * of subclasses.
     *
     * @param path the array to create the {@code TreePath} from
     * @param length identifies the number of elements in {@code path} to
     *        create the {@code TreePath} from
     * @throws NullPointerException if {@code path} is {@code null}
     * @throws ArrayIndexOutOfBoundsException if {@code length - 1} is
     *         outside the range of the array
     * @throws IllegalArgumentException if any of the elements from
     *         {@code 0} to {@code length - 1} are {@code null}
     */
<span class="nc" id="L161">    protected TreePath(Object[] path, int length) {</span>
<span class="nc" id="L162">        lastPathComponent = path[length - 1];</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (lastPathComponent == null) {</span>
<span class="nc" id="L164">            throw new IllegalArgumentException(</span>
                &quot;Path elements must be non-null&quot;);
        }
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if(length &gt; 1)</span>
<span class="nc" id="L168">            parentPath = new TreePath(path, length - 1);</span>
<span class="nc" id="L169">    }</span>

    /**
     * Creates an empty {@code TreePath}.  This is provided for
     * subclasses that represent paths in a different
     * manner. Subclasses that use this constructor must override
     * {@code getLastPathComponent}, and {@code getParentPath}.
     */
<span class="nc" id="L177">    protected TreePath() {</span>
<span class="nc" id="L178">    }</span>

    /**
     * Returns an ordered array of the elements of this {@code TreePath}.
     * The first element is the root.
     *
     * @return an array of the elements in this {@code TreePath}
     */
    public Object[] getPath() {
<span class="nc" id="L187">        int            i = getPathCount();</span>
<span class="nc" id="L188">        Object[]       result = new Object[i--];</span>

<span class="nc bnc" id="L190" title="All 2 branches missed.">        for(TreePath path = this; path != null; path = path.getParentPath()) {</span>
<span class="nc" id="L191">            result[i--] = path.getLastPathComponent();</span>
        }
<span class="nc" id="L193">        return result;</span>
    }

    /**
     * Returns the last element of this path.
     *
     * @return the last element in the path
     */
    public Object getLastPathComponent() {
<span class="nc" id="L202">        return lastPathComponent;</span>
    }

    /**
     * Returns the number of elements in the path.
     *
     * @return the number of elements in the path
     */
    public int getPathCount() {
<span class="nc" id="L211">        int        result = 0;</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">        for(TreePath path = this; path != null; path = path.getParentPath()) {</span>
<span class="nc" id="L213">            result++;</span>
        }
<span class="nc" id="L215">        return result;</span>
    }

    /**
     * Returns the path element at the specified index.
     *
     * @param index the index of the element requested
     * @return the element at the specified index
     * @throws IllegalArgumentException if the index is outside the
     *         range of this path
     */
    public Object getPathComponent(int index) {
<span class="nc" id="L227">        int          pathLength = getPathCount();</span>

<span class="nc bnc" id="L229" title="All 4 branches missed.">        if(index &lt; 0 || index &gt;= pathLength)</span>
<span class="nc" id="L230">            throw new IllegalArgumentException(&quot;Index &quot; + index +</span>
                                           &quot; is out of the specified range&quot;);

<span class="nc" id="L233">        TreePath         path = this;</span>

<span class="nc bnc" id="L235" title="All 2 branches missed.">        for(int i = pathLength-1; i != index; i--) {</span>
<span class="nc" id="L236">            path = path.getParentPath();</span>
        }
<span class="nc" id="L238">        return path.getLastPathComponent();</span>
    }

    /**
     * Compares this {@code TreePath} to the specified object. This returns
     * {@code true} if {@code o} is a {@code TreePath} with the exact
     * same elements (as determined by using {@code equals} on each
     * element of the path).
     *
     * @param o the object to compare
     */
    public boolean equals(Object o) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        if(o == this)</span>
<span class="nc" id="L251">            return true;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if(o instanceof TreePath) {</span>
<span class="nc" id="L253">            TreePath            oTreePath = (TreePath)o;</span>

<span class="nc bnc" id="L255" title="All 2 branches missed.">            if(getPathCount() != oTreePath.getPathCount())</span>
<span class="nc" id="L256">                return false;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            for(TreePath path = this; path != null;</span>
<span class="nc" id="L258">                    path = path.getParentPath()) {</span>
<span class="nc" id="L259">                if (!(path.getLastPathComponent().equals</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">                      (oTreePath.getLastPathComponent()))) {</span>
<span class="nc" id="L261">                    return false;</span>
                }
<span class="nc" id="L263">                oTreePath = oTreePath.getParentPath();</span>
            }
<span class="nc" id="L265">            return true;</span>
        }
<span class="nc" id="L267">        return false;</span>
    }

    /**
     * Returns the hash code of this {@code TreePath}. The hash code of a
     * {@code TreePath} is the hash code of the last element in the path.
     *
     * @return the hashCode for the object
     */
    public int hashCode() {
<span class="nc" id="L277">        return getLastPathComponent().hashCode();</span>
    }

    /**
     * Returns true if &lt;code&gt;aTreePath&lt;/code&gt; is a
     * descendant of this
     * {@code TreePath}. A {@code TreePath} {@code P1} is a descendant of a
     * {@code TreePath} {@code P2}
     * if {@code P1} contains all of the elements that make up
     * {@code P2's} path.
     * For example, if this object has the path {@code [a, b]},
     * and &lt;code&gt;aTreePath&lt;/code&gt; has the path {@code [a, b, c]},
     * then &lt;code&gt;aTreePath&lt;/code&gt; is a descendant of this object.
     * However, if &lt;code&gt;aTreePath&lt;/code&gt; has the path {@code [a]},
     * then it is not a descendant of this object.  By this definition
     * a {@code TreePath} is always considered a descendant of itself.
     * That is, &lt;code&gt;aTreePath.isDescendant(aTreePath)&lt;/code&gt; returns
     * {@code true}.
     *
     * @param aTreePath the {@code TreePath} to check
     * @return true if &lt;code&gt;aTreePath&lt;/code&gt; is a descendant of this path
     */
    public boolean isDescendant(TreePath aTreePath) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if(aTreePath == this)</span>
<span class="nc" id="L301">            return true;</span>

<span class="nc bnc" id="L303" title="All 2 branches missed.">        if(aTreePath != null) {</span>
<span class="nc" id="L304">            int                 pathLength = getPathCount();</span>
<span class="nc" id="L305">            int                 oPathLength = aTreePath.getPathCount();</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">            if(oPathLength &lt; pathLength)</span>
                // Can't be a descendant, has fewer components in the path.
<span class="nc" id="L309">                return false;</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">            while(oPathLength-- &gt; pathLength)</span>
<span class="nc" id="L311">                aTreePath = aTreePath.getParentPath();</span>
<span class="nc" id="L312">            return equals(aTreePath);</span>
        }
<span class="nc" id="L314">        return false;</span>
    }

    /**
     * Returns a new path containing all the elements of this path
     * plus &lt;code&gt;child&lt;/code&gt;. &lt;code&gt;child&lt;/code&gt; is the last element
     * of the newly created {@code TreePath}.
     *
     * @param child the path element to add
     * @throws NullPointerException if {@code child} is {@code null}
     */
    public TreePath pathByAddingChild(Object child) {
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if(child == null)</span>
<span class="nc" id="L327">            throw new NullPointerException(&quot;Null child not allowed&quot;);</span>

<span class="nc" id="L329">        return new TreePath(this, child);</span>
    }

    /**
     * Returns the {@code TreePath} of the parent. A return value of
     * {@code null} indicates this is the root node.
     *
     * @return the parent path
     */
    public TreePath getParentPath() {
<span class="nc" id="L339">        return parentPath;</span>
    }

    /**
     * Returns a string that displays and identifies this
     * object's properties.
     *
     * @return a String representation of this object
     */
    public String toString() {
<span class="nc" id="L349">        StringBuffer tempSpot = new StringBuffer(&quot;[&quot;);</span>

<span class="nc bnc" id="L351" title="All 2 branches missed.">        for(int counter = 0, maxCounter = getPathCount();counter &lt; maxCounter;</span>
<span class="nc" id="L352">            counter++) {</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if(counter &gt; 0)</span>
<span class="nc" id="L354">                tempSpot.append(&quot;, &quot;);</span>
<span class="nc" id="L355">            tempSpot.append(getPathComponent(counter));</span>
        }
<span class="nc" id="L357">        tempSpot.append(&quot;]&quot;);</span>
<span class="nc" id="L358">        return tempSpot.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>