<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DefaultTreeModel.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.tree</a> &gt; <span class="el_source">DefaultTreeModel.java</span></div><h1>DefaultTreeModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.tree;

import java.util.*;
import java.beans.ConstructorProperties;
import java.io.*;
import javax.swing.event.*;

/**
 * A simple tree data model that uses TreeNodes.
 * For further information and examples that use DefaultTreeModel,
 * see &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tree.html&quot;&gt;How to Use Trees&lt;/a&gt;
 * in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author Rob Davis
 * @author Ray Ryan
 * @author Scott Violet
 */
public class DefaultTreeModel implements Serializable, TreeModel {
    /** Root of the tree. */
    protected TreeNode root;
    /** Listeners. */
<span class="nc" id="L56">    protected EventListenerList listenerList = new EventListenerList();</span>
    /**
      * Determines how the &lt;code&gt;isLeaf&lt;/code&gt; method figures
      * out if a node is a leaf node. If true, a node is a leaf
      * node if it does not allow children. (If it allows
      * children, it is not a leaf node, even if no children
      * are present.) That lets you distinguish between &lt;i&gt;folder&lt;/i&gt;
      * nodes and &lt;i&gt;file&lt;/i&gt; nodes in a file system, for example.
      * &lt;p&gt;
      * If this value is false, then any node which has no
      * children is a leaf node, and any node may acquire
      * children.
      *
      * @see TreeNode#getAllowsChildren
      * @see TreeModel#isLeaf
      * @see #setAsksAllowsChildren
      */
    protected boolean asksAllowsChildren;


    /**
      * Creates a tree in which any node can have children.
      *
      * @param root a TreeNode object that is the root of the tree
      * @see #DefaultTreeModel(TreeNode, boolean)
      */
     @ConstructorProperties({&quot;root&quot;})
     public DefaultTreeModel(TreeNode root) {
<span class="nc" id="L84">        this(root, false);</span>
<span class="nc" id="L85">    }</span>

    /**
      * Creates a tree specifying whether any node can have children,
      * or whether only certain nodes can have children.
      *
      * @param root a TreeNode object that is the root of the tree
      * @param asksAllowsChildren a boolean, false if any node can
      *        have children, true if each node is asked to see if
      *        it can have children
      * @see #asksAllowsChildren
      */
    public DefaultTreeModel(TreeNode root, boolean asksAllowsChildren) {
<span class="nc" id="L98">        super();</span>
<span class="nc" id="L99">        this.root = root;</span>
<span class="nc" id="L100">        this.asksAllowsChildren = asksAllowsChildren;</span>
<span class="nc" id="L101">    }</span>

    /**
      * Sets whether or not to test leafness by asking getAllowsChildren()
      * or isLeaf() to the TreeNodes.  If newvalue is true, getAllowsChildren()
      * is messaged, otherwise isLeaf() is messaged.
      */
    public void setAsksAllowsChildren(boolean newValue) {
<span class="nc" id="L109">        asksAllowsChildren = newValue;</span>
<span class="nc" id="L110">    }</span>

    /**
      * Tells how leaf nodes are determined.
      *
      * @return true if only nodes which do not allow children are
      *         leaf nodes, false if nodes which have no children
      *         (even if allowed) are leaf nodes
      * @see #asksAllowsChildren
      */
    public boolean asksAllowsChildren() {
<span class="nc" id="L121">        return asksAllowsChildren;</span>
    }

    /**
     * Sets the root to &lt;code&gt;root&lt;/code&gt;. A null &lt;code&gt;root&lt;/code&gt; implies
     * the tree is to display nothing, and is legal.
     */
    public void setRoot(TreeNode root) {
<span class="nc" id="L129">        Object oldRoot = this.root;</span>
<span class="nc" id="L130">        this.root = root;</span>
<span class="nc bnc" id="L131" title="All 4 branches missed.">        if (root == null &amp;&amp; oldRoot != null) {</span>
<span class="nc" id="L132">            fireTreeStructureChanged(this, null);</span>
        }
        else {
<span class="nc" id="L135">            nodeStructureChanged(root);</span>
        }
<span class="nc" id="L137">    }</span>

    /**
     * Returns the root of the tree.  Returns null only if the tree has
     * no nodes.
     *
     * @return  the root of the tree
     */
    public Object getRoot() {
<span class="nc" id="L146">        return root;</span>
    }

    /**
     * Returns the index of child in parent.
     * If either the parent or child is &lt;code&gt;null&lt;/code&gt;, returns -1.
     * @param parent a note in the tree, obtained from this data source
     * @param child the node we are interested in
     * @return the index of the child in the parent, or -1
     *    if either the parent or the child is &lt;code&gt;null&lt;/code&gt;
     */
    public int getIndexOfChild(Object parent, Object child) {
<span class="nc bnc" id="L158" title="All 4 branches missed.">        if(parent == null || child == null)</span>
<span class="nc" id="L159">            return -1;</span>
<span class="nc" id="L160">        return ((TreeNode)parent).getIndex((TreeNode)child);</span>
    }

    /**
     * Returns the child of &lt;I&gt;parent&lt;/I&gt; at index &lt;I&gt;index&lt;/I&gt; in the parent's
     * child array.  &lt;I&gt;parent&lt;/I&gt; must be a node previously obtained from
     * this data source. This should not return null if &lt;i&gt;index&lt;/i&gt;
     * is a valid index for &lt;i&gt;parent&lt;/i&gt; (that is &lt;i&gt;index&lt;/i&gt; &amp;gt;= 0 &amp;amp;&amp;amp;
     * &lt;i&gt;index&lt;/i&gt; &amp;lt; getChildCount(&lt;i&gt;parent&lt;/i&gt;)).
     *
     * @param   parent  a node in the tree, obtained from this data source
     * @return  the child of &lt;I&gt;parent&lt;/I&gt; at index &lt;I&gt;index&lt;/I&gt;
     */
    public Object getChild(Object parent, int index) {
<span class="nc" id="L174">        return ((TreeNode)parent).getChildAt(index);</span>
    }

    /**
     * Returns the number of children of &lt;I&gt;parent&lt;/I&gt;.  Returns 0 if the node
     * is a leaf or if it has no children.  &lt;I&gt;parent&lt;/I&gt; must be a node
     * previously obtained from this data source.
     *
     * @param   parent  a node in the tree, obtained from this data source
     * @return  the number of children of the node &lt;I&gt;parent&lt;/I&gt;
     */
    public int getChildCount(Object parent) {
<span class="nc" id="L186">        return ((TreeNode)parent).getChildCount();</span>
    }

    /**
     * Returns whether the specified node is a leaf node.
     * The way the test is performed depends on the
     * &lt;code&gt;askAllowsChildren&lt;/code&gt; setting.
     *
     * @param node the node to check
     * @return true if the node is a leaf node
     *
     * @see #asksAllowsChildren
     * @see TreeModel#isLeaf
     */
    public boolean isLeaf(Object node) {
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if(asksAllowsChildren)</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            return !((TreeNode)node).getAllowsChildren();</span>
<span class="nc" id="L203">        return ((TreeNode)node).isLeaf();</span>
    }

    /**
     * Invoke this method if you've modified the {@code TreeNode}s upon which
     * this model depends. The model will notify all of its listeners that the
     * model has changed.
     */
    public void reload() {
<span class="nc" id="L212">        reload(root);</span>
<span class="nc" id="L213">    }</span>

    /**
      * This sets the user object of the TreeNode identified by path
      * and posts a node changed.  If you use custom user objects in
      * the TreeModel you're going to need to subclass this and
      * set the user object of the changed node to something meaningful.
      */
    public void valueForPathChanged(TreePath path, Object newValue) {
<span class="nc" id="L222">        MutableTreeNode   aNode = (MutableTreeNode)path.getLastPathComponent();</span>

<span class="nc" id="L224">        aNode.setUserObject(newValue);</span>
<span class="nc" id="L225">        nodeChanged(aNode);</span>
<span class="nc" id="L226">    }</span>

    /**
     * Invoked this to insert newChild at location index in parents children.
     * This will then message nodesWereInserted to create the appropriate
     * event. This is the preferred way to add children as it will create
     * the appropriate event.
     */
    public void insertNodeInto(MutableTreeNode newChild,
                               MutableTreeNode parent, int index){
<span class="nc" id="L236">        parent.insert(newChild, index);</span>

<span class="nc" id="L238">        int[]           newIndexs = new int[1];</span>

<span class="nc" id="L240">        newIndexs[0] = index;</span>
<span class="nc" id="L241">        nodesWereInserted(parent, newIndexs);</span>
<span class="nc" id="L242">    }</span>

    /**
     * Message this to remove node from its parent. This will message
     * nodesWereRemoved to create the appropriate event. This is the
     * preferred way to remove a node as it handles the event creation
     * for you.
     */
    public void removeNodeFromParent(MutableTreeNode node) {
<span class="nc" id="L251">        MutableTreeNode         parent = (MutableTreeNode)node.getParent();</span>

<span class="nc bnc" id="L253" title="All 2 branches missed.">        if(parent == null)</span>
<span class="nc" id="L254">            throw new IllegalArgumentException(&quot;node does not have a parent.&quot;);</span>

<span class="nc" id="L256">        int[]            childIndex = new int[1];</span>
<span class="nc" id="L257">        Object[]         removedArray = new Object[1];</span>

<span class="nc" id="L259">        childIndex[0] = parent.getIndex(node);</span>
<span class="nc" id="L260">        parent.remove(childIndex[0]);</span>
<span class="nc" id="L261">        removedArray[0] = node;</span>
<span class="nc" id="L262">        nodesWereRemoved(parent, childIndex, removedArray);</span>
<span class="nc" id="L263">    }</span>

    /**
      * Invoke this method after you've changed how node is to be
      * represented in the tree.
      */
    public void nodeChanged(TreeNode node) {
<span class="nc bnc" id="L270" title="All 4 branches missed.">        if(listenerList != null &amp;&amp; node != null) {</span>
<span class="nc" id="L271">            TreeNode         parent = node.getParent();</span>

<span class="nc bnc" id="L273" title="All 2 branches missed.">            if(parent != null) {</span>
<span class="nc" id="L274">                int        anIndex = parent.getIndex(node);</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">                if(anIndex != -1) {</span>
<span class="nc" id="L276">                    int[]        cIndexs = new int[1];</span>

<span class="nc" id="L278">                    cIndexs[0] = anIndex;</span>
<span class="nc" id="L279">                    nodesChanged(parent, cIndexs);</span>
                }
<span class="nc" id="L281">            }</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            else if (node == getRoot()) {</span>
<span class="nc" id="L283">                nodesChanged(node, null);</span>
            }
        }
<span class="nc" id="L286">    }</span>

    /**
     * Invoke this method if you've modified the {@code TreeNode}s upon which
     * this model depends. The model will notify all of its listeners that the
     * model has changed below the given node.
     *
     * @param node the node below which the model has changed
     */
    public void reload(TreeNode node) {
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if(node != null) {</span>
<span class="nc" id="L297">            fireTreeStructureChanged(this, getPathToRoot(node), null, null);</span>
        }
<span class="nc" id="L299">    }</span>

    /**
      * Invoke this method after you've inserted some TreeNodes into
      * node.  childIndices should be the index of the new elements and
      * must be sorted in ascending order.
      */
    public void nodesWereInserted(TreeNode node, int[] childIndices) {
<span class="nc bnc" id="L307" title="All 8 branches missed.">        if(listenerList != null &amp;&amp; node != null &amp;&amp; childIndices != null</span>
           &amp;&amp; childIndices.length &gt; 0) {
<span class="nc" id="L309">            int               cCount = childIndices.length;</span>
<span class="nc" id="L310">            Object[]          newChildren = new Object[cCount];</span>

<span class="nc bnc" id="L312" title="All 2 branches missed.">            for(int counter = 0; counter &lt; cCount; counter++)</span>
<span class="nc" id="L313">                newChildren[counter] = node.getChildAt(childIndices[counter]);</span>
<span class="nc" id="L314">            fireTreeNodesInserted(this, getPathToRoot(node), childIndices,</span>
                                  newChildren);
        }
<span class="nc" id="L317">    }</span>

    /**
      * Invoke this method after you've removed some TreeNodes from
      * node.  childIndices should be the index of the removed elements and
      * must be sorted in ascending order. And removedChildren should be
      * the array of the children objects that were removed.
      */
    public void nodesWereRemoved(TreeNode node, int[] childIndices,
                                 Object[] removedChildren) {
<span class="nc bnc" id="L327" title="All 4 branches missed.">        if(node != null &amp;&amp; childIndices != null) {</span>
<span class="nc" id="L328">            fireTreeNodesRemoved(this, getPathToRoot(node), childIndices,</span>
                                 removedChildren);
        }
<span class="nc" id="L331">    }</span>

    /**
      * Invoke this method after you've changed how the children identified by
      * childIndicies are to be represented in the tree.
      */
    public void nodesChanged(TreeNode node, int[] childIndices) {
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if(node != null) {</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">            if (childIndices != null) {</span>
<span class="nc" id="L340">                int            cCount = childIndices.length;</span>

<span class="nc bnc" id="L342" title="All 2 branches missed.">                if(cCount &gt; 0) {</span>
<span class="nc" id="L343">                    Object[]       cChildren = new Object[cCount];</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">                    for(int counter = 0; counter &lt; cCount; counter++)</span>
<span class="nc" id="L346">                        cChildren[counter] = node.getChildAt</span>
<span class="nc" id="L347">                            (childIndices[counter]);</span>
<span class="nc" id="L348">                    fireTreeNodesChanged(this, getPathToRoot(node),</span>
                                         childIndices, cChildren);
                }
<span class="nc" id="L351">            }</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            else if (node == getRoot()) {</span>
<span class="nc" id="L353">                fireTreeNodesChanged(this, getPathToRoot(node), null, null);</span>
            }
        }
<span class="nc" id="L356">    }</span>

    /**
      * Invoke this method if you've totally changed the children of
      * node and its children's children...  This will post a
      * treeStructureChanged event.
      */
    public void nodeStructureChanged(TreeNode node) {
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if(node != null) {</span>
<span class="nc" id="L365">           fireTreeStructureChanged(this, getPathToRoot(node), null, null);</span>
        }
<span class="nc" id="L367">    }</span>

    /**
     * Builds the parents of node up to and including the root node,
     * where the original node is the last element in the returned array.
     * The length of the returned array gives the node's depth in the
     * tree.
     *
     * @param aNode the TreeNode to get the path for
     */
    public TreeNode[] getPathToRoot(TreeNode aNode) {
<span class="nc" id="L378">        return getPathToRoot(aNode, 0);</span>
    }

    /**
     * Builds the parents of node up to and including the root node,
     * where the original node is the last element in the returned array.
     * The length of the returned array gives the node's depth in the
     * tree.
     *
     * @param aNode  the TreeNode to get the path for
     * @param depth  an int giving the number of steps already taken towards
     *        the root (on recursive calls), used to size the returned array
     * @return an array of TreeNodes giving the path from the root to the
     *         specified node
     */
    protected TreeNode[] getPathToRoot(TreeNode aNode, int depth) {
        TreeNode[]              retNodes;
        // This method recurses, traversing towards the root in order
        // size the array. On the way back, it fills in the nodes,
        // starting from the root and working back to the original node.

        /* Check for null, in case someone passed in a null node, or
           they passed in an element that isn't rooted at root. */
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if(aNode == null) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            if(depth == 0)</span>
<span class="nc" id="L403">                return null;</span>
            else
<span class="nc" id="L405">                retNodes = new TreeNode[depth];</span>
        }
        else {
<span class="nc" id="L408">            depth++;</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if(aNode == root)</span>
<span class="nc" id="L410">                retNodes = new TreeNode[depth];</span>
            else
<span class="nc" id="L412">                retNodes = getPathToRoot(aNode.getParent(), depth);</span>
<span class="nc" id="L413">            retNodes[retNodes.length - depth] = aNode;</span>
        }
<span class="nc" id="L415">        return retNodes;</span>
    }

    //
    //  Events
    //

    /**
     * Adds a listener for the TreeModelEvent posted after the tree changes.
     *
     * @see     #removeTreeModelListener
     * @param   l       the listener to add
     */
    public void addTreeModelListener(TreeModelListener l) {
<span class="nc" id="L429">        listenerList.add(TreeModelListener.class, l);</span>
<span class="nc" id="L430">    }</span>

    /**
     * Removes a listener previously added with &lt;B&gt;addTreeModelListener()&lt;/B&gt;.
     *
     * @see     #addTreeModelListener
     * @param   l       the listener to remove
     */
    public void removeTreeModelListener(TreeModelListener l) {
<span class="nc" id="L439">        listenerList.remove(TreeModelListener.class, l);</span>
<span class="nc" id="L440">    }</span>

    /**
     * Returns an array of all the tree model listeners
     * registered on this model.
     *
     * @return all of this model's &lt;code&gt;TreeModelListener&lt;/code&gt;s
     *         or an empty
     *         array if no tree model listeners are currently registered
     *
     * @see #addTreeModelListener
     * @see #removeTreeModelListener
     *
     * @since 1.4
     */
    public TreeModelListener[] getTreeModelListeners() {
<span class="nc" id="L456">        return listenerList.getListeners(TreeModelListener.class);</span>
    }

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param source the source of the {@code TreeModelEvent};
     *               typically {@code this}
     * @param path the path to the parent of the nodes that changed; use
     *             {@code null} to identify the root has changed
     * @param childIndices the indices of the changed elements
     * @param children the changed elements
     */
    protected void fireTreeNodesChanged(Object source, Object[] path,
                                        int[] childIndices,
                                        Object[] children) {
        // Guaranteed to return a non-null array
<span class="nc" id="L476">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L477">        TreeModelEvent e = null;</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L480" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (listeners[i]==TreeModelListener.class) {</span>
                // Lazily create the event:
<span class="nc bnc" id="L483" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L484">                    e = new TreeModelEvent(source, path,</span>
                                           childIndices, children);
<span class="nc" id="L486">                ((TreeModelListener)listeners[i+1]).treeNodesChanged(e);</span>
            }
        }
<span class="nc" id="L489">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param source the source of the {@code TreeModelEvent};
     *               typically {@code this}
     * @param path the path to the parent the nodes were added to
     * @param childIndices the indices of the new elements
     * @param children the new elements
     */
    protected void fireTreeNodesInserted(Object source, Object[] path,
                                        int[] childIndices,
                                        Object[] children) {
        // Guaranteed to return a non-null array
<span class="nc" id="L507">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L508">        TreeModelEvent e = null;</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L511" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (listeners[i]==TreeModelListener.class) {</span>
                // Lazily create the event:
<span class="nc bnc" id="L514" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L515">                    e = new TreeModelEvent(source, path,</span>
                                           childIndices, children);
<span class="nc" id="L517">                ((TreeModelListener)listeners[i+1]).treeNodesInserted(e);</span>
            }
        }
<span class="nc" id="L520">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param source the source of the {@code TreeModelEvent};
     *               typically {@code this}
     * @param path the path to the parent the nodes were removed from
     * @param childIndices the indices of the removed elements
     * @param children the removed elements
     */
    protected void fireTreeNodesRemoved(Object source, Object[] path,
                                        int[] childIndices,
                                        Object[] children) {
        // Guaranteed to return a non-null array
<span class="nc" id="L538">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L539">        TreeModelEvent e = null;</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L542" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">            if (listeners[i]==TreeModelListener.class) {</span>
                // Lazily create the event:
<span class="nc bnc" id="L545" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L546">                    e = new TreeModelEvent(source, path,</span>
                                           childIndices, children);
<span class="nc" id="L548">                ((TreeModelListener)listeners[i+1]).treeNodesRemoved(e);</span>
            }
        }
<span class="nc" id="L551">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param source the source of the {@code TreeModelEvent};
     *               typically {@code this}
     * @param path the path to the parent of the structure that has changed;
     *             use {@code null} to identify the root has changed
     * @param childIndices the indices of the affected elements
     * @param children the affected elements
     */
    protected void fireTreeStructureChanged(Object source, Object[] path,
                                        int[] childIndices,
                                        Object[] children) {
        // Guaranteed to return a non-null array
<span class="nc" id="L570">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L571">        TreeModelEvent e = null;</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L574" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (listeners[i]==TreeModelListener.class) {</span>
                // Lazily create the event:
<span class="nc bnc" id="L577" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L578">                    e = new TreeModelEvent(source, path,</span>
                                           childIndices, children);
<span class="nc" id="L580">                ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);</span>
            }
        }
<span class="nc" id="L583">    }</span>

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created using the parameters passed into
     * the fire method.
     *
     * @param source the source of the {@code TreeModelEvent};
     *               typically {@code this}
     * @param path the path to the parent of the structure that has changed;
     *             use {@code null} to identify the root has changed
     */
    private void fireTreeStructureChanged(Object source, TreePath path) {
        // Guaranteed to return a non-null array
<span class="nc" id="L598">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L599">        TreeModelEvent e = null;</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L602" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">            if (listeners[i]==TreeModelListener.class) {</span>
                // Lazily create the event:
<span class="nc bnc" id="L605" title="All 2 branches missed.">                if (e == null)</span>
<span class="nc" id="L606">                    e = new TreeModelEvent(source, path);</span>
<span class="nc" id="L607">                ((TreeModelListener)listeners[i+1]).treeStructureChanged(e);</span>
            }
        }
<span class="nc" id="L610">    }</span>

    /**
     * Returns an array of all the objects currently registered
     * as &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this model.
     * &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
     * &lt;code&gt;add&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt; method.
     *
     * &lt;p&gt;
     *
     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
     * with a class literal,
     * such as
     * &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a
     * &lt;code&gt;DefaultTreeModel&lt;/code&gt; &lt;code&gt;m&lt;/code&gt;
     * for its tree model listeners with the following code:
     *
     * &lt;pre&gt;TreeModelListener[] tmls = (TreeModelListener[])(m.getListeners(TreeModelListener.class));&lt;/pre&gt;
     *
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;JDK&lt;/em&gt;Listener&lt;/code&gt;s on this component,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
     *          doesn't specify a class or interface that implements
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     *
     * @see #getTreeModelListeners
     *
     * @since 1.3
     */
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
<span class="nc" id="L649">        return listenerList.getListeners(listenerType);</span>
    }

    // Serialization support.
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L654">        Vector&lt;Object&gt; values = new Vector&lt;Object&gt;();</span>

<span class="nc" id="L656">        s.defaultWriteObject();</span>
        // Save the root, if its Serializable.
<span class="nc bnc" id="L658" title="All 4 branches missed.">        if(root != null &amp;&amp; root instanceof Serializable) {</span>
<span class="nc" id="L659">            values.addElement(&quot;root&quot;);</span>
<span class="nc" id="L660">            values.addElement(root);</span>
        }
<span class="nc" id="L662">        s.writeObject(values);</span>
<span class="nc" id="L663">    }</span>

    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException {
<span class="nc" id="L667">        s.defaultReadObject();</span>

<span class="nc" id="L669">        Vector          values = (Vector)s.readObject();</span>
<span class="nc" id="L670">        int             indexCounter = 0;</span>
<span class="nc" id="L671">        int             maxCounter = values.size();</span>

<span class="nc bnc" id="L673" title="All 2 branches missed.">        if(indexCounter &lt; maxCounter &amp;&amp; values.elementAt(indexCounter).</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">           equals(&quot;root&quot;)) {</span>
<span class="nc" id="L675">            root = (TreeNode)values.elementAt(++indexCounter);</span>
<span class="nc" id="L676">            indexCounter++;</span>
        }
<span class="nc" id="L678">    }</span>


} // End of class DefaultTreeModel
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>