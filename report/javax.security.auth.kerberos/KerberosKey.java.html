<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KerberosKey.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.security.auth.kerberos</a> &gt; <span class="el_source">KerberosKey.java</span></div><h1>KerberosKey.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.security.auth.kerberos;

import java.util.Arrays;
import javax.crypto.SecretKey;
import javax.security.auth.Destroyable;
import javax.security.auth.DestroyFailedException;

/**
 * This class encapsulates a long term secret key for a Kerberos
 * principal.&lt;p&gt;
 *
 * All Kerberos JAAS login modules that obtain a principal's password and
 * generate the secret key from it should use this class.
 * Sometimes, such as when authenticating a server in
 * the absence of user-to-user authentication, the login module will store
 * an instance of this class in the private credential set of a
 * {@link javax.security.auth.Subject Subject} during the commit phase of the
 * authentication process.&lt;p&gt;
 *
 * A Kerberos service using a keytab to read secret keys should use
 * the {@link KeyTab} class, where latest keys can be read when needed.&lt;p&gt;
 *
 * It might be necessary for the application to be granted a
 * {@link javax.security.auth.PrivateCredentialPermission
 * PrivateCredentialPermission} if it needs to access the KerberosKey
 * instance from a Subject. This permission is not needed when the
 * application depends on the default JGSS Kerberos mechanism to access the
 * KerberosKey. In that case, however, the application will need an
 * appropriate
 * {@link javax.security.auth.kerberos.ServicePermission ServicePermission}.
 *
 * @author Mayank Upadhyay
 * @since 1.4
 */
public class KerberosKey implements SecretKey, Destroyable {

    private static final long serialVersionUID = -4625402278148246993L;

   /**
     * The principal that this secret key belongs to.
     *
     * @serial
     */
    private KerberosPrincipal principal;

   /**
     * the version number of this secret key
     *
     * @serial
     */
    private int versionNum;

   /**
    * {@code KeyImpl} is serialized by writing out the ASN1 Encoded bytes
    * of the encryption key.
    * The ASN1 encoding is defined in RFC4120 and as  follows:
    * &lt;pre&gt;
    * EncryptionKey   ::= SEQUENCE {
    *           keytype   [0] Int32 -- actually encryption type --,
    *           keyvalue  [1] OCTET STRING
    * }
    * &lt;/pre&gt;
    *
    * @serial
    */

    private KeyImpl key;
<span class="pc" id="L93">    private transient boolean destroyed = false;</span>

    /**
     * Constructs a KerberosKey from the given bytes when the key type and
     * key version number are known. This can be used when reading the secret
     * key information from a Kerberos &quot;keytab&quot;.
     *
     * @param principal the principal that this secret key belongs to
     * @param keyBytes the raw bytes for the secret key
     * @param keyType the key type for the secret key as defined by the
     * Kerberos protocol specification.
     * @param versionNum the version number of this secret key
     */
    public KerberosKey(KerberosPrincipal principal,
                       byte[] keyBytes,
                       int keyType,
<span class="fc" id="L109">                       int versionNum) {</span>
<span class="fc" id="L110">        this.principal = principal;</span>
<span class="fc" id="L111">        this.versionNum = versionNum;</span>
<span class="fc" id="L112">        key = new KeyImpl(keyBytes, keyType);</span>
<span class="fc" id="L113">    }</span>

    /**
     * Constructs a KerberosKey from a principal's password.
     *
     * @param principal the principal that this password belongs to
     * @param password the password that should be used to compute the key
     * @param algorithm the name for the algorithm that this key will be
     * used for. This parameter may be null in which case the default
     * algorithm &quot;DES&quot; will be assumed.
     * @throws IllegalArgumentException if the name of the
     * algorithm passed is unsupported.
     */
    public KerberosKey(KerberosPrincipal principal,
                       char[] password,
<span class="nc" id="L128">                       String algorithm) {</span>

<span class="nc" id="L130">        this.principal = principal;</span>
        // Pass principal in for salt
<span class="nc" id="L132">        key = new KeyImpl(principal, password, algorithm);</span>
<span class="nc" id="L133">    }</span>

    /**
     * Returns the principal that this key belongs to.
     *
     * @return the principal this key belongs to.
     */
    public final KerberosPrincipal getPrincipal() {
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (destroyed)</span>
<span class="nc" id="L142">            throw new IllegalStateException(&quot;This key is no longer valid&quot;);</span>
<span class="fc" id="L143">        return principal;</span>
    }

    /**
     * Returns the key version number.
     *
     * @return the key version number.
     */
    public final int getVersionNumber() {
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (destroyed)</span>
<span class="nc" id="L153">            throw new IllegalStateException(&quot;This key is no longer valid&quot;);</span>
<span class="fc" id="L154">        return versionNum;</span>
    }

    /**
     * Returns the key type for this long-term key.
     *
     * @return the key type.
     */
    public final int getKeyType() {
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (destroyed)</span>
<span class="nc" id="L164">            throw new IllegalStateException(&quot;This key is no longer valid&quot;);</span>
<span class="fc" id="L165">        return key.getKeyType();</span>
    }

    /*
     * Methods from java.security.Key
     */

    /**
     * Returns the standard algorithm name for this key. For
     * example, &quot;DES&quot; would indicate that this key is a DES key.
     * See Appendix A in the &lt;a href=
     * &quot;../../../../../technotes/guides/security/crypto/CryptoSpec.html#AppA&quot;&gt;
     * Java Cryptography Architecture API Specification &amp;amp; Reference
     * &lt;/a&gt;
     * for information about standard algorithm names.
     *
     * @return the name of the algorithm associated with this key.
     */
    public final String getAlgorithm() {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (destroyed)</span>
<span class="nc" id="L185">            throw new IllegalStateException(&quot;This key is no longer valid&quot;);</span>
<span class="nc" id="L186">        return key.getAlgorithm();</span>
    }

    /**
     * Returns the name of the encoding format for this secret key.
     *
     * @return the String &quot;RAW&quot;
     */
    public final String getFormat() {
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (destroyed)</span>
<span class="nc" id="L196">            throw new IllegalStateException(&quot;This key is no longer valid&quot;);</span>
<span class="nc" id="L197">        return key.getFormat();</span>
    }

    /**
     * Returns the key material of this secret key.
     *
     * @return the key material
     */
    public final byte[] getEncoded() {
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">        if (destroyed)</span>
<span class="nc" id="L207">            throw new IllegalStateException(&quot;This key is no longer valid&quot;);</span>
<span class="fc" id="L208">        return key.getEncoded();</span>
    }

    /**
     * Destroys this key. A call to any of its other methods after this
     * will cause an  IllegalStateException to be thrown.
     *
     * @throws DestroyFailedException if some error occurs while destorying
     * this key.
     */
    public void destroy() throws DestroyFailedException {
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">        if (!destroyed) {</span>
<span class="fc" id="L220">            key.destroy();</span>
<span class="fc" id="L221">            principal = null;</span>
<span class="fc" id="L222">            destroyed = true;</span>
        }
<span class="fc" id="L224">    }</span>


    /** Determines if this key has been destroyed.*/
    public boolean isDestroyed() {
<span class="fc" id="L229">        return destroyed;</span>
    }

    public String toString() {
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (destroyed) {</span>
<span class="nc" id="L234">            return &quot;Destroyed Principal&quot;;</span>
        }
<span class="nc" id="L236">        return &quot;Kerberos Principal &quot; + principal.toString() +</span>
                &quot;Key Version &quot; + versionNum +
<span class="nc" id="L238">                &quot;key &quot;  + key.toString();</span>
    }

    /**
     * Returns a hashcode for this KerberosKey.
     *
     * @return a hashCode() for the {@code KerberosKey}
     * @since 1.6
     */
    public int hashCode() {
<span class="fc" id="L248">        int result = 17;</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (isDestroyed()) {</span>
<span class="fc" id="L250">            return result;</span>
        }
<span class="fc" id="L252">        result = 37 * result + Arrays.hashCode(getEncoded());</span>
<span class="fc" id="L253">        result = 37 * result + getKeyType();</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (principal != null) {</span>
<span class="fc" id="L255">            result = 37 * result + principal.hashCode();</span>
        }
<span class="fc" id="L257">        return result * 37 + versionNum;</span>
    }

    /**
     * Compares the specified Object with this KerberosKey for equality.
     * Returns true if the given object is also a
     * {@code KerberosKey} and the two
     * {@code KerberosKey} instances are equivalent.
     *
     * @param other the Object to compare to
     * @return true if the specified object is equal to this KerberosKey,
     * false otherwise. NOTE: Returns false if either of the KerberosKey
     * objects has been destroyed.
     * @since 1.6
     */
    public boolean equals(Object other) {

<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (other == this)</span>
<span class="fc" id="L275">            return true;</span>

<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (! (other instanceof KerberosKey)) {</span>
<span class="fc" id="L278">            return false;</span>
        }

<span class="fc" id="L281">        KerberosKey otherKey = ((KerberosKey) other);</span>
<span class="fc bfc" id="L282" title="All 4 branches covered.">        if (isDestroyed() || otherKey.isDestroyed()) {</span>
<span class="fc" id="L283">            return false;</span>
        }

<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (versionNum != otherKey.getVersionNumber() ||</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">                getKeyType() != otherKey.getKeyType() ||</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">                !Arrays.equals(getEncoded(), otherKey.getEncoded())) {</span>
<span class="fc" id="L289">            return false;</span>
        }

<span class="fc bfc" id="L292" title="All 2 branches covered.">        if (principal == null) {</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">            if (otherKey.getPrincipal() != null) {</span>
<span class="nc" id="L294">                return false;</span>
            }
        } else {
<span class="fc bfc" id="L297" title="All 2 branches covered.">            if (!principal.equals(otherKey.getPrincipal())) {</span>
<span class="fc" id="L298">                return false;</span>
            }
        }

<span class="fc" id="L302">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>