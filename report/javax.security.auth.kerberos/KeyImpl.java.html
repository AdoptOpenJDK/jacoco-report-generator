<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>KeyImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.security.auth.kerberos</a> &gt; <span class="el_source">KeyImpl.java</span></div><h1>KeyImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.security.auth.kerberos;

import java.io.*;
import java.util.Arrays;
import javax.crypto.SecretKey;
import javax.security.auth.Destroyable;
import javax.security.auth.DestroyFailedException;
import sun.misc.HexDumpEncoder;
import sun.security.krb5.Asn1Exception;
import sun.security.krb5.PrincipalName;
import sun.security.krb5.EncryptionKey;
import sun.security.krb5.EncryptedData;
import sun.security.krb5.KrbException;
import sun.security.krb5.KrbCryptoException;
import sun.security.util.DerValue;

/**
 * This class encapsulates a Kerberos encryption key. It is not associated
 * with a principal and may represent an ephemeral session key.
 *
 * @author Mayank Upadhyay
 * @since 1.4
 *
 * @serial include
 */
class KeyImpl implements SecretKey, Destroyable, Serializable {

    private static final long serialVersionUID = -7889313790214321193L;

    private transient byte[] keyBytes;
    private transient int keyType;
<span class="pc" id="L57">    private transient volatile boolean destroyed = false;</span>


    /**
     * Constructs a KeyImpl from the given bytes.
     *
     * @param keyBytes the raw bytes for the secret key
     * @param keyType the key type for the secret key as defined by the
     * Kerberos protocol specification.
     */
    public KeyImpl(byte[] keyBytes,
<span class="fc" id="L68">                       int keyType) {</span>
<span class="fc" id="L69">        this.keyBytes = keyBytes.clone();</span>
<span class="fc" id="L70">        this.keyType = keyType;</span>
<span class="fc" id="L71">    }</span>

    /**
     * Constructs a KeyImpl from a password.
     *
     * @param principal the principal from which to derive the salt
     * @param password the password that should be used to compute the
     * key.
     * @param algorithm the name for the algorithm that this key wil be
     * used for. This parameter may be null in which case &quot;DES&quot; will be
     * assumed.
     */
    public KeyImpl(KerberosPrincipal principal,
                   char[] password,
<span class="nc" id="L85">                   String algorithm) {</span>

        try {
<span class="nc" id="L88">            PrincipalName princ = new PrincipalName(principal.getName());</span>
<span class="nc" id="L89">            EncryptionKey key =</span>
<span class="nc" id="L90">                new EncryptionKey(password, princ.getSalt(), algorithm);</span>
<span class="nc" id="L91">            this.keyBytes = key.getBytes();</span>
<span class="nc" id="L92">            this.keyType = key.getEType();</span>
<span class="nc" id="L93">        } catch (KrbException e) {</span>
<span class="nc" id="L94">            throw new IllegalArgumentException(e.getMessage());</span>
<span class="nc" id="L95">        }</span>
<span class="nc" id="L96">    }</span>

    /**
     * Returns the keyType for this key as defined in the Kerberos Spec.
     */
    public final int getKeyType() {
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">        if (destroyed)</span>
<span class="nc" id="L103">            throw new IllegalStateException(&quot;This key is no longer valid&quot;);</span>
<span class="fc" id="L104">        return keyType;</span>
    }

    /*
     * Methods from java.security.Key
     */

    public final String getAlgorithm() {
<span class="nc" id="L112">        return getAlgorithmName(keyType);</span>
    }

    private String getAlgorithmName(int eType) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (destroyed)</span>
<span class="nc" id="L117">            throw new IllegalStateException(&quot;This key is no longer valid&quot;);</span>

<span class="nc bnc" id="L119" title="All 7 branches missed.">        switch (eType) {</span>
        case EncryptedData.ETYPE_DES_CBC_CRC:
        case EncryptedData.ETYPE_DES_CBC_MD5:
<span class="nc" id="L122">            return &quot;DES&quot;;</span>

        case EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD:
<span class="nc" id="L125">            return &quot;DESede&quot;;</span>

        case EncryptedData.ETYPE_ARCFOUR_HMAC:
<span class="nc" id="L128">            return &quot;ArcFourHmac&quot;;</span>

        case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96:
<span class="nc" id="L131">            return &quot;AES128&quot;;</span>

        case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96:
<span class="nc" id="L134">            return &quot;AES256&quot;;</span>

        case EncryptedData.ETYPE_NULL:
<span class="nc" id="L137">            return &quot;NULL&quot;;</span>

        default:
<span class="nc" id="L140">            throw new IllegalArgumentException(</span>
                &quot;Unsupported encryption type: &quot; + eType);
        }
    }

    public final String getFormat() {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (destroyed)</span>
<span class="nc" id="L147">            throw new IllegalStateException(&quot;This key is no longer valid&quot;);</span>
<span class="nc" id="L148">        return &quot;RAW&quot;;</span>
    }

    public final byte[] getEncoded() {
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">        if (destroyed)</span>
<span class="nc" id="L153">            throw new IllegalStateException(&quot;This key is no longer valid&quot;);</span>
<span class="fc" id="L154">        return keyBytes.clone();</span>
    }

    public void destroy() throws DestroyFailedException {
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        if (!destroyed) {</span>
<span class="fc" id="L159">            destroyed = true;</span>
<span class="fc" id="L160">            Arrays.fill(keyBytes, (byte) 0);</span>
        }
<span class="fc" id="L162">    }</span>

    public boolean isDestroyed() {
<span class="fc" id="L165">        return destroyed;</span>
    }

    /**
     * @serialData this {@code KeyImpl} is serialized by
     * writing out the ASN1 Encoded bytes of the encryption key.
     * The ASN1 encoding is defined in RFC4120 and as  follows:
     * EncryptionKey   ::= SEQUENCE {
     *          keytype    [0] Int32 -- actually encryption type --,
     *          keyvalue   [1] OCTET STRING
     * }
     */
    private void writeObject(ObjectOutputStream ois)
                throws IOException {
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (destroyed) {</span>
<span class="nc" id="L180">           throw new IOException(&quot;This key is no longer valid&quot;);</span>
        }

        try {
<span class="nc" id="L184">           ois.writeObject((new EncryptionKey(keyType, keyBytes)).asn1Encode());</span>
<span class="nc" id="L185">        } catch (Asn1Exception ae) {</span>
<span class="nc" id="L186">           throw new IOException(ae.getMessage());</span>
<span class="nc" id="L187">        }</span>
<span class="nc" id="L188">    }</span>

    private void readObject(ObjectInputStream ois)
                throws IOException, ClassNotFoundException {
        try {
<span class="nc" id="L193">            EncryptionKey encKey = new EncryptionKey(new</span>
<span class="nc" id="L194">                                     DerValue((byte[])ois.readObject()));</span>
<span class="nc" id="L195">            keyType = encKey.getEType();</span>
<span class="nc" id="L196">            keyBytes = encKey.getBytes();</span>
<span class="nc" id="L197">        } catch (Asn1Exception ae) {</span>
<span class="nc" id="L198">            throw new IOException(ae.getMessage());</span>
<span class="nc" id="L199">        }</span>
<span class="nc" id="L200">    }</span>

    public String toString() {
<span class="nc" id="L203">        HexDumpEncoder hd = new HexDumpEncoder();</span>
<span class="nc bnc" id="L204" title="All 4 branches missed.">        return &quot;EncryptionKey: keyType=&quot; + keyType</span>
                          + &quot; keyBytes (hex dump)=&quot;
                          + (keyBytes == null || keyBytes.length == 0 ?
                             &quot; Empty Key&quot; :
<span class="nc" id="L208">                             '\n' + hd.encodeBuffer(keyBytes)</span>
                          + '\n');


    }

    public int hashCode() {
<span class="fc" id="L215">        int result = 17;</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if(isDestroyed()) {</span>
<span class="nc" id="L217">            return result;</span>
        }
<span class="fc" id="L219">        result = 37 * result + Arrays.hashCode(keyBytes);</span>
<span class="fc" id="L220">        return 37 * result + keyType;</span>
    }

    public boolean equals(Object other) {

<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if (other == this)</span>
<span class="nc" id="L226">            return true;</span>

<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (! (other instanceof KeyImpl)) {</span>
<span class="nc" id="L229">            return false;</span>
        }

<span class="fc" id="L232">        KeyImpl otherKey = ((KeyImpl) other);</span>
<span class="pc bpc" id="L233" title="2 of 4 branches missed.">        if (isDestroyed() || otherKey.isDestroyed()) {</span>
<span class="nc" id="L234">            return false;</span>
        }

<span class="fc bfc" id="L237" title="All 2 branches covered.">        if(keyType != otherKey.getKeyType() ||</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">                !Arrays.equals(keyBytes, otherKey.getEncoded())) {</span>
<span class="fc" id="L239">            return false;</span>
        }

<span class="fc" id="L242">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>