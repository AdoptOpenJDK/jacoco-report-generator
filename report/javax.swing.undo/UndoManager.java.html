<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>UndoManager.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing.undo</a> &gt; <span class="el_source">UndoManager.java</span></div><h1>UndoManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing.undo;

import javax.swing.event.*;
import javax.swing.UIManager;
import java.util.*;

/**
 * {@code UndoManager} manages a list of {@code UndoableEdits},
 * providing a way to undo or redo the appropriate edits.  There are
 * two ways to add edits to an &lt;code&gt;UndoManager&lt;/code&gt;.  Add the edit
 * directly using the &lt;code&gt;addEdit&lt;/code&gt; method, or add the
 * &lt;code&gt;UndoManager&lt;/code&gt; to a bean that supports
 * &lt;code&gt;UndoableEditListener&lt;/code&gt;.  The following examples creates
 * an &lt;code&gt;UndoManager&lt;/code&gt; and adds it as an
 * &lt;code&gt;UndoableEditListener&lt;/code&gt; to a &lt;code&gt;JTextField&lt;/code&gt;:
 * &lt;pre&gt;
 *   UndoManager undoManager = new UndoManager();
 *   JTextField tf = ...;
 *   tf.getDocument().addUndoableEditListener(undoManager);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * &lt;code&gt;UndoManager&lt;/code&gt; maintains an ordered list of edits and the
 * index of the next edit in that list. The index of the next edit is
 * either the size of the current list of edits, or if
 * &lt;code&gt;undo&lt;/code&gt; has been invoked it corresponds to the index
 * of the last significant edit that was undone. When
 * &lt;code&gt;undo&lt;/code&gt; is invoked all edits from the index of the next
 * edit to the last significant edit are undone, in reverse order.
 * For example, consider an &lt;code&gt;UndoManager&lt;/code&gt; consisting of the
 * following edits: &lt;b&gt;A&lt;/b&gt; &lt;i&gt;b&lt;/i&gt; &lt;i&gt;c&lt;/i&gt; &lt;b&gt;D&lt;/b&gt;.  Edits with a
 * upper-case letter in bold are significant, those in lower-case
 * and italicized are insignificant.
 * &lt;p&gt;
 * &lt;a name=&quot;figure1&quot;&gt;&lt;/a&gt;
 * &lt;table border=0 summary=&quot;&quot;&gt;
 * &lt;tr&gt;&lt;td&gt;
 *     &lt;img src=&quot;doc-files/UndoManager-1.gif&quot; alt=&quot;&quot;&gt;
 * &lt;tr&gt;&lt;td align=center&gt;Figure 1
 * &lt;/table&gt;
 * &lt;p&gt;
 * As shown in &lt;a href=&quot;#figure1&quot;&gt;figure 1&lt;/a&gt;, if &lt;b&gt;D&lt;/b&gt; was just added, the
 * index of the next edit will be 4. Invoking &lt;code&gt;undo&lt;/code&gt;
 * results in invoking &lt;code&gt;undo&lt;/code&gt; on &lt;b&gt;D&lt;/b&gt; and setting the
 * index of the next edit to 3 (edit &lt;i&gt;c&lt;/i&gt;), as shown in the following
 * figure.
 * &lt;p&gt;
 * &lt;a name=&quot;figure2&quot;&gt;&lt;/a&gt;
 * &lt;table border=0 summary=&quot;&quot;&gt;
 * &lt;tr&gt;&lt;td&gt;
 *     &lt;img src=&quot;doc-files/UndoManager-2.gif&quot; alt=&quot;&quot;&gt;
 * &lt;tr&gt;&lt;td align=center&gt;Figure 2
 * &lt;/table&gt;
 * &lt;p&gt;
 * The last significant edit is &lt;b&gt;A&lt;/b&gt;, so that invoking
 * &lt;code&gt;undo&lt;/code&gt; again invokes &lt;code&gt;undo&lt;/code&gt; on &lt;i&gt;c&lt;/i&gt;,
 * &lt;i&gt;b&lt;/i&gt;, and &lt;b&gt;A&lt;/b&gt;, in that order, setting the index of the
 * next edit to 0, as shown in the following figure.
 * &lt;p&gt;
 * &lt;a name=&quot;figure3&quot;&gt;&lt;/a&gt;
 * &lt;table border=0 summary=&quot;&quot;&gt;
 * &lt;tr&gt;&lt;td&gt;
 *     &lt;img src=&quot;doc-files/UndoManager-3.gif&quot; alt=&quot;&quot;&gt;
 * &lt;tr&gt;&lt;td align=center&gt;Figure 3
 * &lt;/table&gt;
 * &lt;p&gt;
 * Invoking &lt;code&gt;redo&lt;/code&gt; results in invoking &lt;code&gt;redo&lt;/code&gt; on
 * all edits between the index of the next edit and the next
 * significant edit (or the end of the list).  Continuing with the previous
 * example if &lt;code&gt;redo&lt;/code&gt; were invoked, &lt;code&gt;redo&lt;/code&gt; would in
 * turn be invoked on &lt;b&gt;A&lt;/b&gt;, &lt;i&gt;b&lt;/i&gt; and &lt;i&gt;c&lt;/i&gt;.  In addition
 * the index of the next edit is set to 3 (as shown in &lt;a
 * href=&quot;#figure2&quot;&gt;figure 2&lt;/a&gt;).
 * &lt;p&gt;
 * Adding an edit to an &lt;code&gt;UndoManager&lt;/code&gt; results in
 * removing all edits from the index of the next edit to the end of
 * the list.  Continuing with the previous example, if a new edit,
 * &lt;i&gt;e&lt;/i&gt;, is added the edit &lt;b&gt;D&lt;/b&gt; is removed from the list
 * (after having &lt;code&gt;die&lt;/code&gt; invoked on it).  If &lt;i&gt;c&lt;/i&gt; is not
 * incorporated by the next edit
 * (&lt;code&gt;&lt;i&gt;c&lt;/i&gt;.addEdit(&lt;i&gt;e&lt;/i&gt;)&lt;/code&gt; returns true), or replaced
 * by it (&lt;code&gt;&lt;i&gt;e&lt;/i&gt;.replaceEdit(&lt;i&gt;c&lt;/i&gt;)&lt;/code&gt; returns true),
 * the new edit is added after &lt;i&gt;c&lt;/i&gt;, as shown in the following
 * figure.
 * &lt;p&gt;
 * &lt;a name=&quot;figure4&quot;&gt;&lt;/a&gt;
 * &lt;table border=0 summary=&quot;&quot;&gt;
 * &lt;tr&gt;&lt;td&gt;
 *     &lt;img src=&quot;doc-files/UndoManager-4.gif&quot; alt=&quot;&quot;&gt;
 * &lt;tr&gt;&lt;td align=center&gt;Figure 4
 * &lt;/table&gt;
 * &lt;p&gt;
 * Once &lt;code&gt;end&lt;/code&gt; has been invoked on an &lt;code&gt;UndoManager&lt;/code&gt;
 * the superclass behavior is used for all &lt;code&gt;UndoableEdit&lt;/code&gt;
 * methods.  Refer to &lt;code&gt;CompoundEdit&lt;/code&gt; for more details on its
 * behavior.
 * &lt;p&gt;
 * Unlike the rest of Swing, this class is thread safe.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author Ray Ryan
 */
public class UndoManager extends CompoundEdit implements UndoableEditListener {
    int indexOfNextAdd;
    int limit;

    /**
     * Creates a new &lt;code&gt;UndoManager&lt;/code&gt;.
     */
    public UndoManager() {
<span class="nc" id="L143">        super();</span>
<span class="nc" id="L144">        indexOfNextAdd = 0;</span>
<span class="nc" id="L145">        limit = 100;</span>
<span class="nc" id="L146">        edits.ensureCapacity(limit);</span>
<span class="nc" id="L147">    }</span>

    /**
     * Returns the maximum number of edits this {@code UndoManager}
     * holds. A value less than 0 indicates the number of edits is not
     * limited.
     *
     * @return the maximum number of edits this {@code UndoManager} holds
     * @see #addEdit
     * @see #setLimit
     */
    public synchronized int getLimit() {
<span class="nc" id="L159">        return limit;</span>
    }

    /**
     * Empties the undo manager sending each edit a &lt;code&gt;die&lt;/code&gt; message
     * in the process.
     *
     * @see AbstractUndoableEdit#die
     */
    public synchronized void discardAllEdits() {
<span class="nc bnc" id="L169" title="All 2 branches missed.">        for (UndoableEdit e : edits) {</span>
<span class="nc" id="L170">            e.die();</span>
<span class="nc" id="L171">        }</span>
<span class="nc" id="L172">        edits = new Vector&lt;UndoableEdit&gt;();</span>
<span class="nc" id="L173">        indexOfNextAdd = 0;</span>
        // PENDING(rjrjr) when vector grows a removeRange() method
        // (expected in JDK 1.2), trimEdits() will be nice and
        // efficient, and this method can call that instead.
<span class="nc" id="L177">    }</span>

    /**
     * Reduces the number of queued edits to a range of size limit,
     * centered on the index of the next edit.
     */
    protected void trimForLimit() {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (limit &gt;= 0) {</span>
<span class="nc" id="L185">            int size = edits.size();</span>
//          System.out.print(&quot;limit: &quot; + limit +
//                           &quot; size: &quot; + size +
//                           &quot; indexOfNextAdd: &quot; + indexOfNextAdd +
//                           &quot;\n&quot;);

<span class="nc bnc" id="L191" title="All 2 branches missed.">            if (size &gt; limit) {</span>
<span class="nc" id="L192">                int halfLimit = limit/2;</span>
<span class="nc" id="L193">                int keepFrom = indexOfNextAdd - 1 - halfLimit;</span>
<span class="nc" id="L194">                int keepTo   = indexOfNextAdd - 1 + halfLimit;</span>

                // These are ints we're playing with, so dividing by two
                // rounds down for odd numbers, so make sure the limit was
                // honored properly. Note that the keep range is
                // inclusive.

<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (keepTo - keepFrom + 1 &gt; limit) {</span>
<span class="nc" id="L202">                    keepFrom++;</span>
                }

                // The keep range is centered on indexOfNextAdd,
                // but odds are good that the actual edits Vector
                // isn't. Move the keep range to keep it legal.

<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (keepFrom &lt; 0) {</span>
<span class="nc" id="L210">                    keepTo -= keepFrom;</span>
<span class="nc" id="L211">                    keepFrom = 0;</span>
                }
<span class="nc bnc" id="L213" title="All 2 branches missed.">                if (keepTo &gt;= size) {</span>
<span class="nc" id="L214">                    int delta = size - keepTo - 1;</span>
<span class="nc" id="L215">                    keepTo += delta;</span>
<span class="nc" id="L216">                    keepFrom += delta;</span>
                }

//              System.out.println(&quot;Keeping &quot; + keepFrom + &quot; &quot; + keepTo);
<span class="nc" id="L220">                trimEdits(keepTo+1, size-1);</span>
<span class="nc" id="L221">                trimEdits(0, keepFrom-1);</span>
            }
        }
<span class="nc" id="L224">    }</span>

    /**
     * Removes edits in the specified range.
     * All edits in the given range (inclusive, and in reverse order)
     * will have &lt;code&gt;die&lt;/code&gt; invoked on them and are removed from
     * the list of edits. This has no effect if
     * &lt;code&gt;from&lt;/code&gt; &amp;gt; &lt;code&gt;to&lt;/code&gt;.
     *
     * @param from the minimum index to remove
     * @param to the maximum index to remove
     */
    protected void trimEdits(int from, int to) {
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (from &lt;= to) {</span>
//          System.out.println(&quot;Trimming &quot; + from + &quot; &quot; + to + &quot; with index &quot; +
//                           indexOfNextAdd);
<span class="nc bnc" id="L240" title="All 2 branches missed.">            for (int i = to; from &lt;= i; i--) {</span>
<span class="nc" id="L241">                UndoableEdit e = edits.elementAt(i);</span>
//              System.out.println(&quot;JUM: Discarding &quot; +
//                                 e.getUndoPresentationName());
<span class="nc" id="L244">                e.die();</span>
                // PENDING(rjrjr) when Vector supports range deletion (JDK
                // 1.2) , we can optimize the next line considerably.
<span class="nc" id="L247">                edits.removeElementAt(i);</span>
            }

<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (indexOfNextAdd &gt; to) {</span>
//              System.out.print(&quot;...right...&quot;);
<span class="nc" id="L252">                indexOfNextAdd -= to-from+1;</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            } else if (indexOfNextAdd &gt;= from) {</span>
//              System.out.println(&quot;...mid...&quot;);
<span class="nc" id="L255">                indexOfNextAdd = from;</span>
            }

//          System.out.println(&quot;new index &quot; + indexOfNextAdd);
        }
<span class="nc" id="L260">    }</span>

    /**
     * Sets the maximum number of edits this &lt;code&gt;UndoManager&lt;/code&gt;
     * holds. A value less than 0 indicates the number of edits is not
     * limited. If edits need to be discarded to shrink the limit,
     * &lt;code&gt;die&lt;/code&gt; will be invoked on them in the reverse
     * order they were added.  The default is 100.
     *
     * @param l the new limit
     * @throws RuntimeException if this {@code UndoManager} is not in progress
     *                          ({@code end} has been invoked)
     * @see #isInProgress
     * @see #end
     * @see #addEdit
     * @see #getLimit
     */
    public synchronized void setLimit(int l) {
<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (!inProgress) throw new RuntimeException(&quot;Attempt to call UndoManager.setLimit() after UndoManager.end() has been called&quot;);</span>
<span class="nc" id="L279">        limit = l;</span>
<span class="nc" id="L280">        trimForLimit();</span>
<span class="nc" id="L281">    }</span>


    /**
     * Returns the the next significant edit to be undone if &lt;code&gt;undo&lt;/code&gt;
     * is invoked. This returns &lt;code&gt;null&lt;/code&gt; if there are no edits
     * to be undone.
     *
     * @return the next significant edit to be undone
     */
    protected UndoableEdit editToBeUndone() {
<span class="nc" id="L292">        int i = indexOfNextAdd;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        while (i &gt; 0) {</span>
<span class="nc" id="L294">            UndoableEdit edit = edits.elementAt(--i);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (edit.isSignificant()) {</span>
<span class="nc" id="L296">                return edit;</span>
            }
<span class="nc" id="L298">        }</span>

<span class="nc" id="L300">        return null;</span>
    }

    /**
     * Returns the the next significant edit to be redone if &lt;code&gt;redo&lt;/code&gt;
     * is invoked. This returns &lt;code&gt;null&lt;/code&gt; if there are no edits
     * to be redone.
     *
     * @return the next significant edit to be redone
     */
    protected UndoableEdit editToBeRedone() {
<span class="nc" id="L311">        int count = edits.size();</span>
<span class="nc" id="L312">        int i = indexOfNextAdd;</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">        while (i &lt; count) {</span>
<span class="nc" id="L315">            UndoableEdit edit = edits.elementAt(i++);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (edit.isSignificant()) {</span>
<span class="nc" id="L317">                return edit;</span>
            }
<span class="nc" id="L319">        }</span>

<span class="nc" id="L321">        return null;</span>
    }

    /**
     * Undoes all changes from the index of the next edit to
     * &lt;code&gt;edit&lt;/code&gt;, updating the index of the next edit appropriately.
     *
     * @throws CannotUndoException if one of the edits throws
     *         &lt;code&gt;CannotUndoException&lt;/code&gt;
     */
    protected void undoTo(UndoableEdit edit) throws CannotUndoException {
<span class="nc" id="L332">        boolean done = false;</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        while (!done) {</span>
<span class="nc" id="L334">            UndoableEdit next = edits.elementAt(--indexOfNextAdd);</span>
<span class="nc" id="L335">            next.undo();</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            done = next == edit;</span>
<span class="nc" id="L337">        }</span>
<span class="nc" id="L338">    }</span>

    /**
     * Redoes all changes from the index of the next edit to
     * &lt;code&gt;edit&lt;/code&gt;, updating the index of the next edit appropriately.
     *
     * @throws CannotRedoException if one of the edits throws
     *         &lt;code&gt;CannotRedoException&lt;/code&gt;
     */
    protected void redoTo(UndoableEdit edit) throws CannotRedoException {
<span class="nc" id="L348">        boolean done = false;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        while (!done) {</span>
<span class="nc" id="L350">            UndoableEdit next = edits.elementAt(indexOfNextAdd++);</span>
<span class="nc" id="L351">            next.redo();</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            done = next == edit;</span>
<span class="nc" id="L353">        }</span>
<span class="nc" id="L354">    }</span>

    /**
     * Convenience method that invokes one of &lt;code&gt;undo&lt;/code&gt; or
     * &lt;code&gt;redo&lt;/code&gt;. If any edits have been undone (the index of
     * the next edit is less than the length of the edits list) this
     * invokes &lt;code&gt;redo&lt;/code&gt;, otherwise it invokes &lt;code&gt;undo&lt;/code&gt;.
     *
     * @see #canUndoOrRedo
     * @see #getUndoOrRedoPresentationName
     * @throws CannotUndoException if one of the edits throws
     *         &lt;code&gt;CannotUndoException&lt;/code&gt;
     * @throws CannotRedoException if one of the edits throws
     *         &lt;code&gt;CannotRedoException&lt;/code&gt;
     */
    public synchronized void undoOrRedo() throws CannotRedoException,
        CannotUndoException {
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (indexOfNextAdd == edits.size()) {</span>
<span class="nc" id="L372">            undo();</span>
        } else {
<span class="nc" id="L374">            redo();</span>
        }
<span class="nc" id="L376">    }</span>

    /**
     * Returns true if it is possible to invoke &lt;code&gt;undo&lt;/code&gt; or
     * &lt;code&gt;redo&lt;/code&gt;.
     *
     * @return true if invoking &lt;code&gt;canUndoOrRedo&lt;/code&gt; is valid
     * @see #undoOrRedo
     */
    public synchronized boolean canUndoOrRedo() {
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (indexOfNextAdd == edits.size()) {</span>
<span class="nc" id="L387">            return canUndo();</span>
        } else {
<span class="nc" id="L389">            return canRedo();</span>
        }
    }

    /**
     * Undoes the appropriate edits.  If &lt;code&gt;end&lt;/code&gt; has been
     * invoked this calls through to the superclass, otherwise
     * this invokes &lt;code&gt;undo&lt;/code&gt; on all edits between the
     * index of the next edit and the last significant edit, updating
     * the index of the next edit appropriately.
     *
     * @throws CannotUndoException if one of the edits throws
     *         &lt;code&gt;CannotUndoException&lt;/code&gt; or there are no edits
     *         to be undone
     * @see CompoundEdit#end
     * @see #canUndo
     * @see #editToBeUndone
     */
    public synchronized void undo() throws CannotUndoException {
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (inProgress) {</span>
<span class="nc" id="L409">            UndoableEdit edit = editToBeUndone();</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (edit == null) {</span>
<span class="nc" id="L411">                throw new CannotUndoException();</span>
            }
<span class="nc" id="L413">            undoTo(edit);</span>
<span class="nc" id="L414">        } else {</span>
<span class="nc" id="L415">            super.undo();</span>
        }
<span class="nc" id="L417">    }</span>

    /**
     * Returns true if edits may be undone.  If &lt;code&gt;end&lt;/code&gt; has
     * been invoked, this returns the value from super.  Otherwise
     * this returns true if there are any edits to be undone
     * (&lt;code&gt;editToBeUndone&lt;/code&gt; returns non-&lt;code&gt;null&lt;/code&gt;).
     *
     * @return true if there are edits to be undone
     * @see CompoundEdit#canUndo
     * @see #editToBeUndone
     */
    public synchronized boolean canUndo() {
<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (inProgress) {</span>
<span class="nc" id="L431">            UndoableEdit edit = editToBeUndone();</span>
<span class="nc bnc" id="L432" title="All 4 branches missed.">            return edit != null &amp;&amp; edit.canUndo();</span>
        } else {
<span class="nc" id="L434">            return super.canUndo();</span>
        }
    }

    /**
     * Redoes the appropriate edits.  If &lt;code&gt;end&lt;/code&gt; has been
     * invoked this calls through to the superclass.  Otherwise
     * this invokes &lt;code&gt;redo&lt;/code&gt; on all edits between the
     * index of the next edit and the next significant edit, updating
     * the index of the next edit appropriately.
     *
     * @throws CannotRedoException if one of the edits throws
     *         &lt;code&gt;CannotRedoException&lt;/code&gt; or there are no edits
     *         to be redone
     * @see CompoundEdit#end
     * @see #canRedo
     * @see #editToBeRedone
     */
    public synchronized void redo() throws CannotRedoException {
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (inProgress) {</span>
<span class="nc" id="L454">            UndoableEdit edit = editToBeRedone();</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (edit == null) {</span>
<span class="nc" id="L456">                throw new CannotRedoException();</span>
            }
<span class="nc" id="L458">            redoTo(edit);</span>
<span class="nc" id="L459">        } else {</span>
<span class="nc" id="L460">            super.redo();</span>
        }
<span class="nc" id="L462">    }</span>

    /**
     * Returns true if edits may be redone.  If &lt;code&gt;end&lt;/code&gt; has
     * been invoked, this returns the value from super.  Otherwise,
     * this returns true if there are any edits to be redone
     * (&lt;code&gt;editToBeRedone&lt;/code&gt; returns non-&lt;code&gt;null&lt;/code&gt;).
     *
     * @return true if there are edits to be redone
     * @see CompoundEdit#canRedo
     * @see #editToBeRedone
     */
    public synchronized boolean canRedo() {
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (inProgress) {</span>
<span class="nc" id="L476">            UndoableEdit edit = editToBeRedone();</span>
<span class="nc bnc" id="L477" title="All 4 branches missed.">            return edit != null &amp;&amp; edit.canRedo();</span>
        } else {
<span class="nc" id="L479">            return super.canRedo();</span>
        }
    }

    /**
     * Adds an &lt;code&gt;UndoableEdit&lt;/code&gt; to this
     * &lt;code&gt;UndoManager&lt;/code&gt;, if it's possible.  This removes all
     * edits from the index of the next edit to the end of the edits
     * list.  If &lt;code&gt;end&lt;/code&gt; has been invoked the edit is not added
     * and &lt;code&gt;false&lt;/code&gt; is returned.  If &lt;code&gt;end&lt;/code&gt; hasn't
     * been invoked this returns &lt;code&gt;true&lt;/code&gt;.
     *
     * @param anEdit the edit to be added
     * @return true if &lt;code&gt;anEdit&lt;/code&gt; can be incorporated into this
     *              edit
     * @see CompoundEdit#end
     * @see CompoundEdit#addEdit
     */
    public synchronized boolean addEdit(UndoableEdit anEdit) {
        boolean retVal;

        // Trim from the indexOfNextAdd to the end, as we'll
        // never reach these edits once the new one is added.
<span class="nc" id="L502">        trimEdits(indexOfNextAdd, edits.size()-1);</span>

<span class="nc" id="L504">        retVal = super.addEdit(anEdit);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (inProgress) {</span>
<span class="nc" id="L506">          retVal = true;</span>
        }

        // Maybe super added this edit, maybe it didn't (perhaps
        // an in progress compound edit took it instead. Or perhaps
        // this UndoManager is no longer in progress). So make sure
        // the indexOfNextAdd is pointed at the right place.
<span class="nc" id="L513">        indexOfNextAdd = edits.size();</span>

        // Enforce the limit
<span class="nc" id="L516">        trimForLimit();</span>

<span class="nc" id="L518">        return retVal;</span>
    }


    /**
     * Turns this &lt;code&gt;UndoManager&lt;/code&gt; into a normal
     * &lt;code&gt;CompoundEdit&lt;/code&gt;.  This removes all edits that have
     * been undone.
     *
     * @see CompoundEdit#end
     */
    public synchronized void end() {
<span class="nc" id="L530">        super.end();</span>
<span class="nc" id="L531">        this.trimEdits(indexOfNextAdd, edits.size()-1);</span>
<span class="nc" id="L532">    }</span>

    /**
     * Convenience method that returns either
     * &lt;code&gt;getUndoPresentationName&lt;/code&gt; or
     * &lt;code&gt;getRedoPresentationName&lt;/code&gt;.  If the index of the next
     * edit equals the size of the edits list,
     * &lt;code&gt;getUndoPresentationName&lt;/code&gt; is returned, otherwise
     * &lt;code&gt;getRedoPresentationName&lt;/code&gt; is returned.
     *
     * @return undo or redo name
     */
    public synchronized String getUndoOrRedoPresentationName() {
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (indexOfNextAdd == edits.size()) {</span>
<span class="nc" id="L546">            return getUndoPresentationName();</span>
        } else {
<span class="nc" id="L548">            return getRedoPresentationName();</span>
        }
    }

    /**
     * Returns a description of the undoable form of this edit.
     * If &lt;code&gt;end&lt;/code&gt; has been invoked this calls into super.
     * Otherwise if there are edits to be undone, this returns
     * the value from the next significant edit that will be undone.
     * If there are no edits to be undone and &lt;code&gt;end&lt;/code&gt; has not
     * been invoked this returns the value from the &lt;code&gt;UIManager&lt;/code&gt;
     * property &quot;AbstractUndoableEdit.undoText&quot;.
     *
     * @return a description of the undoable form of this edit
     * @see     #undo
     * @see     CompoundEdit#getUndoPresentationName
     */
    public synchronized String getUndoPresentationName() {
<span class="nc bnc" id="L566" title="All 2 branches missed.">        if (inProgress) {</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">            if (canUndo()) {</span>
<span class="nc" id="L568">                return editToBeUndone().getUndoPresentationName();</span>
            } else {
<span class="nc" id="L570">                return UIManager.getString(&quot;AbstractUndoableEdit.undoText&quot;);</span>
            }
        } else {
<span class="nc" id="L573">            return super.getUndoPresentationName();</span>
        }
    }

    /**
     * Returns a description of the redoable form of this edit.
     * If &lt;code&gt;end&lt;/code&gt; has been invoked this calls into super.
     * Otherwise if there are edits to be redone, this returns
     * the value from the next significant edit that will be redone.
     * If there are no edits to be redone and &lt;code&gt;end&lt;/code&gt; has not
     * been invoked this returns the value from the &lt;code&gt;UIManager&lt;/code&gt;
     * property &quot;AbstractUndoableEdit.redoText&quot;.
     *
     * @return a description of the redoable form of this edit
     * @see     #redo
     * @see     CompoundEdit#getRedoPresentationName
     */
    public synchronized String getRedoPresentationName() {
<span class="nc bnc" id="L591" title="All 2 branches missed.">        if (inProgress) {</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (canRedo()) {</span>
<span class="nc" id="L593">                return editToBeRedone().getRedoPresentationName();</span>
            } else {
<span class="nc" id="L595">                return UIManager.getString(&quot;AbstractUndoableEdit.redoText&quot;);</span>
            }
        } else {
<span class="nc" id="L598">            return super.getRedoPresentationName();</span>
        }
    }

    /**
     * An &lt;code&gt;UndoableEditListener&lt;/code&gt; method. This invokes
     * &lt;code&gt;addEdit&lt;/code&gt; with &lt;code&gt;e.getEdit()&lt;/code&gt;.
     *
     * @param e the &lt;code&gt;UndoableEditEvent&lt;/code&gt; the
     *        &lt;code&gt;UndoableEditEvent&lt;/code&gt; will be added from
     * @see #addEdit
     */
    public void undoableEditHappened(UndoableEditEvent e) {
<span class="nc" id="L611">        addEdit(e.getEdit());</span>
<span class="nc" id="L612">    }</span>

    /**
     * Returns a string that displays and identifies this
     * object's properties.
     *
     * @return a String representation of this object
     */
    public String toString() {
<span class="nc" id="L621">        return super.toString() + &quot; limit: &quot; + limit +</span>
            &quot; indexOfNextAdd: &quot; + indexOfNextAdd;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>