<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">jdk.internal.util.xml.impl</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package jdk.internal.util.xml.impl;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.util.HashMap;
import java.util.Map;
import jdk.internal.org.xml.sax.InputSource;
import jdk.internal.org.xml.sax.SAXException;

/**
 * XML non-validating parser engine.
 */
public abstract class Parser {

    public final static String FAULT = &quot;&quot;;
    protected final static int BUFFSIZE_READER = 512;
    protected final static int BUFFSIZE_PARSER = 128;
    /**
     * The end of stream character.
     */
    public final static char EOS = 0xffff;
    private Pair mNoNS; // there is no namespace
    private Pair mXml;  // the xml namespace
    private Map&lt;String, Input&gt; mEnt;  // the entities look up table
    private Map&lt;String, Input&gt; mPEnt; // the parmeter entities look up table
    protected boolean mIsSAlone;     // xml decl standalone flag
    protected boolean mIsSAloneSet;  // standalone is explicitely set
    protected boolean mIsNSAware;    // if true - namespace aware mode
    protected int mPh;  // current phase of document processing
    protected final static int PH_BEFORE_DOC = -1;  // before parsing
    protected final static int PH_DOC_START = 0;   // document start
    protected final static int PH_MISC_DTD = 1;   // misc before DTD
    protected final static int PH_DTD = 2;   // DTD
    protected final static int PH_DTD_MISC = 3;   // misc after DTD
    protected final static int PH_DOCELM = 4;   // document's element
    protected final static int PH_DOCELM_MISC = 5;   // misc after element
    protected final static int PH_AFTER_DOC = 6;   // after parsing
    protected int mEvt;  // current event type
    protected final static int EV_NULL = 0;   // unknown
    protected final static int EV_ELM = 1;   // empty element
    protected final static int EV_ELMS = 2;   // start element
    protected final static int EV_ELME = 3;   // end element
    protected final static int EV_TEXT = 4;   // textual content
    protected final static int EV_WSPC = 5;   // white space content
    protected final static int EV_PI = 6;   // processing instruction
    protected final static int EV_CDAT = 7;   // character data
    protected final static int EV_COMM = 8;   // comment
    protected final static int EV_DTD = 9;   // document type definition
    protected final static int EV_ENT = 10;  // skipped entity
    private char mESt; // built-in entity recognizer state
    // mESt values:
    //   0x100   : the initial state
    //   &gt; 0x100 : unrecognized name
    //   &lt; 0x100 : replacement character
    protected char[] mBuff;       // parser buffer
    protected int mBuffIdx;    // index of the last char
    protected Pair mPref;       // stack of prefixes
    protected Pair mElm;        // stack of elements
    // mAttL.chars - element qname
    // mAttL.next  - next element
    // mAttL.list  - list of attributes defined on this element
    // mAttL.list.chars - attribute qname
    // mAttL.list.id    - a char representing attribute's type see below
    // mAttL.list.next  - next attribute defined on the element
    // mAttL.list.list  - devault value structure or null
    // mAttL.list.list.chars - &quot;name='value' &quot; chars array for Input
    //
    // Attribute type character values:
    // 'i' - &quot;ID&quot;
    // 'r' - &quot;IDREF&quot;
    // 'R' - &quot;IDREFS&quot;
    // 'n' - &quot;ENTITY&quot;
    // 'N' - &quot;ENTITIES&quot;
    // 't' - &quot;NMTOKEN&quot;
    // 'T' - &quot;NMTOKENS&quot;
    // 'u' - enumeration type
    // 'o' - &quot;NOTATION&quot;
    // 'c' - &quot;CDATA&quot;
    // see also: bkeyword() and atype()
    //
    protected Pair mAttL;       // list of defined attrs by element name
    protected Input mDoc;        // document entity
    protected Input mInp;        // stack of entities
    private char[] mChars;      // reading buffer
    private int mChLen;      // current capacity
    private int mChIdx;      // index to the next char
    protected Attrs mAttrs;      // attributes of the curr. element
    private String[] mItems;      // attributes array of the curr. element
    private char mAttrIdx;    // attributes counter/index
    private String mUnent;  // unresolved entity name
    private Pair mDltd;   // deleted objects for reuse
    /**
     * Default prefixes
     */
    private final static char NONS[];
    private final static char XML[];
    private final static char XMLNS[];

    static {
<span class="fc" id="L128">        NONS = new char[1];</span>
<span class="fc" id="L129">        NONS[0] = (char) 0;</span>

<span class="fc" id="L131">        XML = new char[4];</span>
<span class="fc" id="L132">        XML[0] = (char) 4;</span>
<span class="fc" id="L133">        XML[1] = 'x';</span>
<span class="fc" id="L134">        XML[2] = 'm';</span>
<span class="fc" id="L135">        XML[3] = 'l';</span>

<span class="fc" id="L137">        XMLNS = new char[6];</span>
<span class="fc" id="L138">        XMLNS[0] = (char) 6;</span>
<span class="fc" id="L139">        XMLNS[1] = 'x';</span>
<span class="fc" id="L140">        XMLNS[2] = 'm';</span>
<span class="fc" id="L141">        XMLNS[3] = 'l';</span>
<span class="fc" id="L142">        XMLNS[4] = 'n';</span>
<span class="fc" id="L143">        XMLNS[5] = 's';</span>
    }
    /**
     * ASCII character type array.
     *
     * This array maps an ASCII (7 bit) character to the character type.&lt;br /&gt;
     * Possible character type values are:&lt;br /&gt; - ' ' for any kind of white
     * space character;&lt;br /&gt; - 'a' for any lower case alphabetical character
     * value;&lt;br /&gt; - 'A' for any upper case alphabetical character value;&lt;br /&gt;
     * - 'd' for any decimal digit character value;&lt;br /&gt; - 'z' for any
     * character less then ' ' except '\t', '\n', '\r';&lt;br /&gt; An ASCII (7 bit)
     * character which does not fall in any category listed above is mapped to
     * it self.
     */
    private static final byte asctyp[];
    /**
     * NMTOKEN character type array.
     *
     * This array maps an ASCII (7 bit) character to the character type.&lt;br /&gt;
     * Possible character type values are:&lt;br /&gt; - 0 for underscore ('_') or any
     * lower and upper case alphabetical character value;&lt;br /&gt; - 1 for colon
     * (':') character;&lt;br /&gt; - 2 for dash ('-') and dot ('.') or any decimal
     * digit character value;&lt;br /&gt; - 3 for any kind of white space character&lt;br
     * /&gt; An ASCII (7 bit) character which does not fall in any category listed
     * above is mapped to 0xff.
     */
    private static final byte nmttyp[];

    /**
     * Static constructor.
     *
     * Sets up the ASCII character type array which is used by
     * {@link #asctyp asctyp} method and NMTOKEN character type array.
     */
    static {
<span class="fc" id="L178">        short i = 0;</span>

<span class="fc" id="L180">        asctyp = new byte[0x80];</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        while (i &lt; ' ') {</span>
<span class="fc" id="L182">            asctyp[i++] = (byte) 'z';</span>
        }
<span class="fc" id="L184">        asctyp['\t'] = (byte) ' ';</span>
<span class="fc" id="L185">        asctyp['\r'] = (byte) ' ';</span>
<span class="fc" id="L186">        asctyp['\n'] = (byte) ' ';</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">        while (i &lt; '0') {</span>
<span class="fc" id="L188">            asctyp[i] = (byte) i++;</span>
        }
<span class="fc bfc" id="L190" title="All 2 branches covered.">        while (i &lt;= '9') {</span>
<span class="fc" id="L191">            asctyp[i++] = (byte) 'd';</span>
        }
<span class="fc bfc" id="L193" title="All 2 branches covered.">        while (i &lt; 'A') {</span>
<span class="fc" id="L194">            asctyp[i] = (byte) i++;</span>
        }
<span class="fc bfc" id="L196" title="All 2 branches covered.">        while (i &lt;= 'Z') {</span>
<span class="fc" id="L197">            asctyp[i++] = (byte) 'A';</span>
        }
<span class="fc bfc" id="L199" title="All 2 branches covered.">        while (i &lt; 'a') {</span>
<span class="fc" id="L200">            asctyp[i] = (byte) i++;</span>
        }
<span class="fc bfc" id="L202" title="All 2 branches covered.">        while (i &lt;= 'z') {</span>
<span class="fc" id="L203">            asctyp[i++] = (byte) 'a';</span>
        }
<span class="fc bfc" id="L205" title="All 2 branches covered.">        while (i &lt; 0x80) {</span>
<span class="fc" id="L206">            asctyp[i] = (byte) i++;</span>
        }

<span class="fc" id="L209">        nmttyp = new byte[0x80];</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">        for (i = 0; i &lt; '0'; i++) {</span>
<span class="fc" id="L211">            nmttyp[i] = (byte) 0xff;</span>
        }
<span class="fc bfc" id="L213" title="All 2 branches covered.">        while (i &lt;= '9') {</span>
<span class="fc" id="L214">            nmttyp[i++] = (byte) 2;  // digits</span>
        }
<span class="fc bfc" id="L216" title="All 2 branches covered.">        while (i &lt; 'A') {</span>
<span class="fc" id="L217">            nmttyp[i++] = (byte) 0xff;</span>
        }
        // skiped upper case alphabetical character are already 0
<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (i = '['; i &lt; 'a'; i++) {</span>
<span class="fc" id="L221">            nmttyp[i] = (byte) 0xff;</span>
        }
        // skiped lower case alphabetical character are already 0
<span class="fc bfc" id="L224" title="All 2 branches covered.">        for (i = '{'; i &lt; 0x80; i++) {</span>
<span class="fc" id="L225">            nmttyp[i] = (byte) 0xff;</span>
        }
<span class="fc" id="L227">        nmttyp['_'] = 0;</span>
<span class="fc" id="L228">        nmttyp[':'] = 1;</span>
<span class="fc" id="L229">        nmttyp['.'] = 2;</span>
<span class="fc" id="L230">        nmttyp['-'] = 2;</span>
<span class="fc" id="L231">        nmttyp[' '] = 3;</span>
<span class="fc" id="L232">        nmttyp['\t'] = 3;</span>
<span class="fc" id="L233">        nmttyp['\r'] = 3;</span>
<span class="fc" id="L234">        nmttyp['\n'] = 3;</span>
<span class="fc" id="L235">    }</span>

    /**
     * Constructor.
     */
<span class="fc" id="L240">    protected Parser() {</span>
<span class="fc" id="L241">        mPh = PH_BEFORE_DOC;  // before parsing</span>

        //              Initialize the parser
<span class="fc" id="L244">        mBuff = new char[BUFFSIZE_PARSER];</span>
<span class="fc" id="L245">        mAttrs = new Attrs();</span>

        //              Default namespace
<span class="fc" id="L248">        mPref = pair(mPref);</span>
<span class="fc" id="L249">        mPref.name = &quot;&quot;;</span>
<span class="fc" id="L250">        mPref.value = &quot;&quot;;</span>
<span class="fc" id="L251">        mPref.chars = NONS;</span>
<span class="fc" id="L252">        mNoNS = mPref;  // no namespace</span>
        //              XML namespace
<span class="fc" id="L254">        mPref = pair(mPref);</span>
<span class="fc" id="L255">        mPref.name = &quot;xml&quot;;</span>
<span class="fc" id="L256">        mPref.value = &quot;http://www.w3.org/XML/1998/namespace&quot;;</span>
<span class="fc" id="L257">        mPref.chars = XML;</span>
<span class="fc" id="L258">        mXml = mPref;  // XML namespace</span>
<span class="fc" id="L259">    }</span>

    /**
     * Initializes parser's internals. Note, current input has to be set before
     * this method is called.
     */
    protected void init() {
<span class="fc" id="L266">        mUnent = null;</span>
<span class="fc" id="L267">        mElm = null;</span>
<span class="fc" id="L268">        mPref = mXml;</span>
<span class="fc" id="L269">        mAttL = null;</span>
<span class="fc" id="L270">        mPEnt = new HashMap&lt;&gt;();</span>
<span class="fc" id="L271">        mEnt = new HashMap&lt;&gt;();</span>
<span class="fc" id="L272">        mDoc = mInp;          // current input is document entity</span>
<span class="fc" id="L273">        mChars = mInp.chars;    // use document entity buffer</span>
<span class="fc" id="L274">        mPh = PH_DOC_START;  // the begining of the document</span>
<span class="fc" id="L275">    }</span>

    /**
     * Cleans up parser internal resources.
     */
    protected void cleanup() {
        //              Default attributes
<span class="fc bfc" id="L282" title="All 2 branches covered.">        while (mAttL != null) {</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">            while (mAttL.list != null) {</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                if (mAttL.list.list != null) {</span>
<span class="fc" id="L285">                    del(mAttL.list.list);</span>
                }
<span class="fc" id="L287">                mAttL.list = del(mAttL.list);</span>
            }
<span class="fc" id="L289">            mAttL = del(mAttL);</span>
        }
        //              Element stack
<span class="fc bfc" id="L292" title="All 2 branches covered.">        while (mElm != null) {</span>
<span class="fc" id="L293">            mElm = del(mElm);</span>
        }
        //              Namespace prefixes
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        while (mPref != mXml) {</span>
<span class="nc" id="L297">            mPref = del(mPref);</span>
        }
        //              Inputs
<span class="fc bfc" id="L300" title="All 2 branches covered.">        while (mInp != null) {</span>
<span class="fc" id="L301">            pop();</span>
        }
        //              Document reader
<span class="pc bpc" id="L304" title="2 of 4 branches missed.">        if ((mDoc != null) &amp;&amp; (mDoc.src != null)) {</span>
            try {
<span class="nc" id="L306">                mDoc.src.close();</span>
<span class="nc" id="L307">            } catch (IOException ioe) {</span>
<span class="nc" id="L308">            }</span>
        }
<span class="fc" id="L310">        mPEnt = null;</span>
<span class="fc" id="L311">        mEnt = null;</span>
<span class="fc" id="L312">        mDoc = null;</span>
<span class="fc" id="L313">        mPh = PH_AFTER_DOC;  // before documnet processing</span>
<span class="fc" id="L314">    }</span>

    /**
     * Processes a portion of document. This method returns one of EV_*
     * constants as an identifier of the portion of document have been read.
     *
     * @return Identifier of processed document portion.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    protected int step() throws Exception {
<span class="fc" id="L326">        mEvt = EV_NULL;</span>
<span class="fc" id="L327">        int st = 0;</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">        while (mEvt == EV_NULL) {</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">            char ch = (mChIdx &lt; mChLen) ? mChars[mChIdx++] : getch();</span>
<span class="pc bpc" id="L330" title="1 of 4 branches missed.">            switch (st) {</span>
                case 0:     // all sorts of markup (dispetcher)
<span class="fc bfc" id="L332" title="All 2 branches covered.">                    if (ch != '&lt;') {</span>
<span class="fc" id="L333">                        bkch();</span>
<span class="fc" id="L334">                        mBuffIdx = -1;  // clean parser buffer</span>
<span class="fc" id="L335">                        st = 1;</span>
<span class="fc" id="L336">                        break;</span>
                    }
<span class="fc bfc" id="L338" title="All 4 branches covered.">                    switch (getch()) {</span>
                        case '/':  // the end of the element content
<span class="fc" id="L340">                            mEvt = EV_ELME;</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">                            if (mElm == null) {</span>
<span class="nc" id="L342">                                panic(FAULT);</span>
                            }
                            //          Check element's open/close tags balance
<span class="fc" id="L345">                            mBuffIdx = -1;  // clean parser buffer</span>
<span class="fc" id="L346">                            bname(mIsNSAware);</span>
<span class="fc" id="L347">                            char[] chars = mElm.chars;</span>
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">                            if (chars.length == (mBuffIdx + 1)) {</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">                                for (char i = 1; i &lt;= mBuffIdx; i += 1) {</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">                                    if (chars[i] != mBuff[i]) {</span>
<span class="nc" id="L351">                                        panic(FAULT);</span>
                                    }
                                }
                            } else {
<span class="nc" id="L355">                                panic(FAULT);</span>
                            }
                            //          Skip white spaces before '&gt;'
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">                            if (wsskip() != '&gt;') {</span>
<span class="nc" id="L359">                                panic(FAULT);</span>
                            }
<span class="fc" id="L361">                            getch();  // read '&gt;'</span>
<span class="fc" id="L362">                            break;</span>

                        case '!':  // a comment or a CDATA
<span class="fc" id="L365">                            ch = getch();</span>
<span class="fc" id="L366">                            bkch();</span>
<span class="fc bfc" id="L367" title="All 3 branches covered.">                            switch (ch) {</span>
                                case '-':  // must be a comment
<span class="fc" id="L369">                                    mEvt = EV_COMM;</span>
<span class="fc" id="L370">                                    comm();</span>
<span class="fc" id="L371">                                    break;</span>

                                case '[':  // must be a CDATA section
<span class="fc" id="L374">                                    mEvt = EV_CDAT;</span>
<span class="fc" id="L375">                                    cdat();</span>
<span class="fc" id="L376">                                    break;</span>

                                default:   // must be 'DOCTYPE'
<span class="fc" id="L379">                                    mEvt = EV_DTD;</span>
<span class="fc" id="L380">                                    dtd();</span>
<span class="fc" id="L381">                                    break;</span>
                            }
                            break;

                        case '?':  // processing instruction
<span class="fc" id="L386">                            mEvt = EV_PI;</span>
<span class="fc" id="L387">                            pi();</span>
<span class="fc" id="L388">                            break;</span>

                        default:  // must be the first char of an xml name
<span class="fc" id="L391">                            bkch();</span>
                            //          Read an element name and put it on top of the
                            //          element stack
<span class="fc" id="L394">                            mElm = pair(mElm);  // add new element to the stack</span>
<span class="fc" id="L395">                            mElm.chars = qname(mIsNSAware);</span>
<span class="fc" id="L396">                            mElm.name = mElm.local();</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">                            mElm.id = (mElm.next != null) ? mElm.next.id : 0;  // flags</span>
<span class="fc" id="L398">                            mElm.num = 0;     // namespace counter</span>
                            //          Find the list of defined attributs of the current
                            //          element
<span class="fc" id="L401">                            Pair elm = find(mAttL, mElm.chars);</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">                            mElm.list = (elm != null) ? elm.list : null;</span>
                            //          Read attributes till the end of the element tag
<span class="fc" id="L404">                            mAttrIdx = 0;</span>
<span class="fc" id="L405">                            Pair att = pair(null);</span>
<span class="fc" id="L406">                            att.num = 0;  // clear attribute's flags</span>
<span class="fc" id="L407">                            attr(att);     // get all attributes inc. defaults</span>
<span class="fc" id="L408">                            del(att);</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">                            mElm.value = (mIsNSAware) ? rslv(mElm.chars) : null;</span>
                            //          Skip white spaces before '&gt;'
<span class="pc bpc" id="L411" title="2 of 3 branches missed.">                            switch (wsskip()) {</span>
                                case '&gt;':
<span class="fc" id="L413">                                    getch();  // read '&gt;'</span>
<span class="fc" id="L414">                                    mEvt = EV_ELMS;</span>
<span class="fc" id="L415">                                    break;</span>

                                case '/':
<span class="nc" id="L418">                                    getch();  // read '/'</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                                    if (getch() != '&gt;') // read '&gt;'</span>
                                    {
<span class="nc" id="L421">                                        panic(FAULT);</span>
                                    }
<span class="nc" id="L423">                                    mEvt = EV_ELM;</span>
<span class="nc" id="L424">                                    break;</span>

                                default:
<span class="nc" id="L427">                                    panic(FAULT);</span>
                            }
                            break;
                    }
<span class="fc" id="L431">                    break;</span>

                case 1:     // read white space
<span class="fc bfc" id="L434" title="All 4 branches covered.">                    switch (ch) {</span>
                        case ' ':
                        case '\t':
                        case '\n':
<span class="fc" id="L438">                            bappend(ch);</span>
<span class="fc" id="L439">                            break;</span>

                        case '\r':              // EOL processing [#2.11]
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">                            if (getch() != '\n') {</span>
<span class="nc" id="L443">                                bkch();</span>
                            }
<span class="fc" id="L445">                            bappend('\n');</span>
<span class="fc" id="L446">                            break;</span>

                        case '&lt;':
<span class="fc" id="L449">                            mEvt = EV_WSPC;</span>
<span class="fc" id="L450">                            bkch();</span>
<span class="fc" id="L451">                            bflash_ws();</span>
<span class="fc" id="L452">                            break;</span>

                        default:
<span class="fc" id="L455">                            bkch();</span>
<span class="fc" id="L456">                            st = 2;</span>
<span class="fc" id="L457">                            break;</span>
                    }
                    break;

                case 2:     // read the text content of the element
<span class="pc bpc" id="L462" title="2 of 5 branches missed.">                    switch (ch) {</span>
                        case '&amp;':
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">                            if (mUnent == null) {</span>
                                //              There was no unresolved entity on previous step.
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">                                if ((mUnent = ent('x')) != null) {</span>
<span class="nc" id="L467">                                    mEvt = EV_TEXT;</span>
<span class="nc" id="L468">                                    bkch();      // move back to ';' after entity name</span>
<span class="nc" id="L469">                                    setch('&amp;');  // parser must be back on next step</span>
<span class="nc" id="L470">                                    bflash();</span>
                                }
                            } else {
                                //              There was unresolved entity on previous step.
<span class="nc" id="L474">                                mEvt = EV_ENT;</span>
<span class="nc" id="L475">                                skippedEnt(mUnent);</span>
<span class="nc" id="L476">                                mUnent = null;</span>
                            }
<span class="nc" id="L478">                            break;</span>

                        case '&lt;':
<span class="fc" id="L481">                            mEvt = EV_TEXT;</span>
<span class="fc" id="L482">                            bkch();</span>
<span class="fc" id="L483">                            bflash();</span>
<span class="fc" id="L484">                            break;</span>

                        case '\r':  // EOL processing [#2.11]
<span class="nc bnc" id="L487" title="All 2 branches missed.">                            if (getch() != '\n') {</span>
<span class="nc" id="L488">                                bkch();</span>
                            }
<span class="nc" id="L490">                            bappend('\n');</span>
<span class="nc" id="L491">                            break;</span>

                        case EOS:
<span class="nc" id="L494">                            panic(FAULT);</span>

                        default:
<span class="fc" id="L497">                            bappend(ch);</span>
<span class="fc" id="L498">                            break;</span>
                    }
                    break;

                default:
<span class="nc" id="L503">                    panic(FAULT);</span>
            }
<span class="fc" id="L505">        }</span>

<span class="fc" id="L507">        return mEvt;</span>
    }

    /**
     * Parses the document type declaration.
     *
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private void dtd() throws Exception {
        char ch;
<span class="fc" id="L518">        String str = null;</span>
<span class="fc" id="L519">        String name = null;</span>
<span class="fc" id="L520">        Pair psid = null;</span>
        // read 'DOCTYPE'
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        if (&quot;DOCTYPE&quot;.equals(name(false)) != true) {</span>
<span class="nc" id="L523">            panic(FAULT);</span>
        }
<span class="fc" id="L525">        mPh = PH_DTD;  // DTD</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">        for (short st = 0; st &gt;= 0;) {</span>
<span class="fc" id="L527">            ch = getch();</span>
<span class="pc bpc" id="L528" title="1 of 5 branches missed.">            switch (st) {</span>
                case 0:     // read the document type name
<span class="fc bfc" id="L530" title="All 2 branches covered.">                    if (chtyp(ch) != ' ') {</span>
<span class="fc" id="L531">                        bkch();</span>
<span class="fc" id="L532">                        name = name(mIsNSAware);</span>
<span class="fc" id="L533">                        wsskip();</span>
<span class="fc" id="L534">                        st = 1;  // read 'PUPLIC' or 'SYSTEM'</span>
                    }
                    break;

                case 1:     // read 'PUPLIC' or 'SYSTEM'
<span class="pc bpc" id="L539" title="2 of 4 branches missed.">                    switch (chtyp(ch)) {</span>
                        case 'A':
<span class="fc" id="L541">                            bkch();</span>
<span class="fc" id="L542">                            psid = pubsys(' ');</span>
<span class="fc" id="L543">                            st = 2;  // skip spaces before internal subset</span>
<span class="fc" id="L544">                            docType(name, psid.name, psid.value);</span>
<span class="fc" id="L545">                            break;</span>

                        case '[':
<span class="fc" id="L548">                            bkch();</span>
<span class="fc" id="L549">                            st = 2;    // skip spaces before internal subset</span>
<span class="fc" id="L550">                            docType(name, null, null);</span>
<span class="fc" id="L551">                            break;</span>

                        case '&gt;':
<span class="nc" id="L554">                            bkch();</span>
<span class="nc" id="L555">                            st = 3;    // skip spaces after internal subset</span>
<span class="nc" id="L556">                            docType(name, null, null);</span>
<span class="nc" id="L557">                            break;</span>

                        default:
<span class="nc" id="L560">                            panic(FAULT);</span>
                    }
<span class="nc" id="L562">                    break;</span>

                case 2:     // skip spaces before internal subset
<span class="pc bpc" id="L565" title="1 of 4 branches missed.">                    switch (chtyp(ch)) {</span>
                        case '[':
                            //          Process internal subset
<span class="fc" id="L568">                            dtdsub();</span>
<span class="fc" id="L569">                            st = 3;  // skip spaces after internal subset</span>
<span class="fc" id="L570">                            break;</span>

                        case '&gt;':
                            //          There is no internal subset
<span class="fc" id="L574">                            bkch();</span>
<span class="fc" id="L575">                            st = 3;  // skip spaces after internal subset</span>
<span class="fc" id="L576">                            break;</span>

                        case ' ':
                            // skip white spaces
<span class="fc" id="L580">                            break;</span>

                        default:
<span class="nc" id="L583">                            panic(FAULT);</span>
                    }
<span class="nc" id="L585">                    break;</span>

                case 3:     // skip spaces after internal subset
<span class="pc bpc" id="L588" title="2 of 3 branches missed.">                    switch (chtyp(ch)) {</span>
                        case '&gt;':
<span class="fc bfc" id="L590" title="All 2 branches covered.">                            if (psid != null) {</span>
                                //              Report the DTD external subset
<span class="fc" id="L592">                                InputSource is = resolveEnt(name, psid.name, psid.value);</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">                                if (is != null) {</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">                                    if (mIsSAlone == false) {</span>
                                        //              Set the end of DTD external subset char
<span class="fc" id="L596">                                        bkch();</span>
<span class="fc" id="L597">                                        setch(']');</span>
                                        //              Set the DTD external subset InputSource
<span class="fc" id="L599">                                        push(new Input(BUFFSIZE_READER));</span>
<span class="fc" id="L600">                                        setinp(is);</span>
<span class="fc" id="L601">                                        mInp.pubid = psid.name;</span>
<span class="fc" id="L602">                                        mInp.sysid = psid.value;</span>
                                        //              Parse the DTD external subset
<span class="fc" id="L604">                                        dtdsub();</span>
                                    } else {
                                        //              Unresolved DTD external subset
<span class="nc" id="L607">                                        skippedEnt(&quot;[dtd]&quot;);</span>
                                        //              Release reader and stream
<span class="nc bnc" id="L609" title="All 2 branches missed.">                                        if (is.getCharacterStream() != null) {</span>
                                            try {
<span class="nc" id="L611">                                                is.getCharacterStream().close();</span>
<span class="nc" id="L612">                                            } catch (IOException ioe) {</span>
<span class="nc" id="L613">                                            }</span>
                                        }
<span class="nc bnc" id="L615" title="All 2 branches missed.">                                        if (is.getByteStream() != null) {</span>
                                            try {
<span class="nc" id="L617">                                                is.getByteStream().close();</span>
<span class="nc" id="L618">                                            } catch (IOException ioe) {</span>
<span class="nc" id="L619">                                            }</span>
                                        }
                                    }
                                } else {
                                    //          Unresolved DTD external subset
<span class="nc" id="L624">                                    skippedEnt(&quot;[dtd]&quot;);</span>
                                }
<span class="fc" id="L626">                                del(psid);</span>
                            }
<span class="fc" id="L628">                            st = -1;  // end of DTD</span>
<span class="fc" id="L629">                            break;</span>

                        case ' ':
                            // skip white spaces
<span class="nc" id="L633">                            break;</span>

                        default:
<span class="nc" id="L636">                            panic(FAULT);</span>
                    }
<span class="nc" id="L638">                    break;</span>

                default:
<span class="nc" id="L641">                    panic(FAULT);</span>
            }
        }
<span class="fc" id="L644">    }</span>

    /**
     * Parses the document type declaration subset.
     *
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private void dtdsub() throws Exception {
        char ch;
<span class="fc bfc" id="L654" title="All 2 branches covered.">        for (short st = 0; st &gt;= 0;) {</span>
<span class="fc" id="L655">            ch = getch();</span>
<span class="pc bpc" id="L656" title="1 of 3 branches missed.">            switch (st) {</span>
                case 0:     // skip white spaces before a declaration
<span class="pc bpc" id="L658" title="3 of 6 branches missed.">                    switch (chtyp(ch)) {</span>
                        case '&lt;':
<span class="fc" id="L660">                            ch = getch();</span>
<span class="pc bpc" id="L661" title="2 of 3 branches missed.">                            switch (ch) {</span>
                                case '?':
<span class="nc" id="L663">                                    pi();</span>
<span class="nc" id="L664">                                    break;</span>

                                case '!':
<span class="fc" id="L667">                                    ch = getch();</span>
<span class="fc" id="L668">                                    bkch();</span>
<span class="fc bfc" id="L669" title="All 2 branches covered.">                                    if (ch == '-') {</span>
<span class="fc" id="L670">                                        comm();</span>
<span class="fc" id="L671">                                        break;</span>
                                    }
                                    //          A markup or an entity declaration
<span class="fc" id="L674">                                    bntok();</span>
<span class="pc bpc" id="L675" title="2 of 5 branches missed.">                                    switch (bkeyword()) {</span>
                                        case 'n':
<span class="fc" id="L677">                                            dtdent();</span>
<span class="fc" id="L678">                                            break;</span>

                                        case 'a':
<span class="fc" id="L681">                                            dtdattl();    // parse attributes declaration</span>
<span class="fc" id="L682">                                            break;</span>

                                        case 'e':
<span class="fc" id="L685">                                            dtdelm();     // parse element declaration</span>
<span class="fc" id="L686">                                            break;</span>

                                        case 'o':
<span class="nc" id="L689">                                            dtdnot();     // parse notation declaration</span>
<span class="nc" id="L690">                                            break;</span>

                                        default:
<span class="nc" id="L693">                                            panic(FAULT); // unsupported markup declaration</span>
                                            break;
                                    }
<span class="fc" id="L696">                                    st = 1;  // read the end of declaration</span>
<span class="fc" id="L697">                                    break;</span>

                                default:
<span class="nc" id="L700">                                    panic(FAULT);</span>
<span class="nc" id="L701">                                    break;</span>
                            }
                            break;

                        case '%':
                            //          A parameter entity reference
<span class="nc" id="L707">                            pent(' ');</span>
<span class="nc" id="L708">                            break;</span>

                        case ']':
                            //          End of DTD subset
<span class="fc" id="L712">                            st = -1;</span>
<span class="fc" id="L713">                            break;</span>

                        case ' ':
                            //          Skip white spaces
<span class="fc" id="L717">                            break;</span>

                        case 'Z':
                            //          End of stream
<span class="nc bnc" id="L721" title="All 2 branches missed.">                            if (getch() != ']') {</span>
<span class="nc" id="L722">                                panic(FAULT);</span>
                            }
<span class="nc" id="L724">                            st = -1;</span>
<span class="nc" id="L725">                            break;</span>

                        default:
<span class="nc" id="L728">                            panic(FAULT);</span>
                    }
<span class="nc" id="L730">                    break;</span>

                case 1:     // read the end of declaration
<span class="pc bpc" id="L733" title="2 of 3 branches missed.">                    switch (ch) {</span>
                        case '&gt;':   // there is no notation
<span class="fc" id="L735">                            st = 0; // skip white spaces before a declaration</span>
<span class="fc" id="L736">                            break;</span>

                        case ' ':
                        case '\n':
                        case '\r':
                        case '\t':
                            //          Skip white spaces
<span class="nc" id="L743">                            break;</span>

                        default:
<span class="nc" id="L746">                            panic(FAULT);</span>
<span class="nc" id="L747">                            break;</span>
                    }
                    break;

                default:
<span class="nc" id="L752">                    panic(FAULT);</span>
            }
        }
<span class="fc" id="L755">    }</span>

    /**
     * Parses an entity declaration. This method fills the general (
     * &lt;code&gt;mEnt&lt;/code&gt;) and parameter
     * (
     * &lt;code&gt;mPEnt&lt;/code&gt;) entity look up table.
     *
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void dtdent() throws Exception {
<span class="fc" id="L768">        String str = null;</span>
<span class="fc" id="L769">        char[] val = null;</span>
<span class="fc" id="L770">        Input inp = null;</span>
<span class="fc" id="L771">        Pair ids = null;</span>
        char ch;
<span class="fc bfc" id="L773" title="All 2 branches covered.">        for (short st = 0; st &gt;= 0;) {</span>
<span class="fc" id="L774">            ch = getch();</span>
<span class="pc bpc" id="L775" title="1 of 3 branches missed.">            switch (st) {</span>
                case 0:     // skip white spaces before entity name
<span class="pc bpc" id="L777" title="1 of 3 branches missed.">                    switch (chtyp(ch)) {</span>
                        case ' ':
                            //          Skip white spaces
<span class="fc" id="L780">                            break;</span>

                        case '%':
                            //          Parameter entity or parameter entity declaration.
<span class="nc" id="L784">                            ch = getch();</span>
<span class="nc" id="L785">                            bkch();</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">                            if (chtyp(ch) == ' ') {</span>
                                //              Parameter entity declaration.
<span class="nc" id="L788">                                wsskip();</span>
<span class="nc" id="L789">                                str = name(false);</span>
<span class="nc bnc" id="L790" title="All 3 branches missed.">                                switch (chtyp(wsskip())) {</span>
                                    case 'A':
                                        //              Read the external identifier
<span class="nc" id="L793">                                        ids = pubsys(' ');</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">                                        if (wsskip() == '&gt;') {</span>
                                            //          External parsed entity
<span class="nc bnc" id="L796" title="All 2 branches missed.">                                            if (mPEnt.containsKey(str) == false) {      // [#4.2]</span>
<span class="nc" id="L797">                                                inp = new Input();</span>
<span class="nc" id="L798">                                                inp.pubid = ids.name;</span>
<span class="nc" id="L799">                                                inp.sysid = ids.value;</span>
<span class="nc" id="L800">                                                mPEnt.put(str, inp);</span>
                                            }
                                        } else {
<span class="nc" id="L803">                                            panic(FAULT);</span>
                                        }
<span class="nc" id="L805">                                        del(ids);</span>
<span class="nc" id="L806">                                        st = -1;  // the end of declaration</span>
<span class="nc" id="L807">                                        break;</span>

                                    case '\&quot;':
                                    case '\'':
                                        //              Read the parameter entity value
<span class="nc" id="L812">                                        bqstr('d');</span>
                                        //              Create the parameter entity value
<span class="nc" id="L814">                                        val = new char[mBuffIdx + 1];</span>
<span class="nc" id="L815">                                        System.arraycopy(mBuff, 1, val, 1, val.length - 1);</span>
                                        //              Add surrounding spaces [#4.4.8]
<span class="nc" id="L817">                                        val[0] = ' ';</span>
                                        //              Add the entity to the entity look up table
<span class="nc bnc" id="L819" title="All 2 branches missed.">                                        if (mPEnt.containsKey(str) == false) {  // [#4.2]</span>
<span class="nc" id="L820">                                            inp = new Input(val);</span>
<span class="nc" id="L821">                                            inp.pubid = mInp.pubid;</span>
<span class="nc" id="L822">                                            inp.sysid = mInp.sysid;</span>
<span class="nc" id="L823">                                            inp.xmlenc = mInp.xmlenc;</span>
<span class="nc" id="L824">                                            inp.xmlver = mInp.xmlver;</span>
<span class="nc" id="L825">                                            mPEnt.put(str, inp);</span>
                                        }
<span class="nc" id="L827">                                        st = -1;  // the end of declaration</span>
<span class="nc" id="L828">                                        break;</span>

                                    default:
<span class="nc" id="L831">                                        panic(FAULT);</span>
<span class="nc" id="L832">                                        break;</span>
                                }
                            } else {
                                //              Parameter entity reference.
<span class="nc" id="L836">                                pent(' ');</span>
                            }
<span class="nc" id="L838">                            break;</span>

                        default:
<span class="fc" id="L841">                            bkch();</span>
<span class="fc" id="L842">                            str = name(false);</span>
<span class="fc" id="L843">                            st = 1;  // read entity declaration value</span>
<span class="fc" id="L844">                            break;</span>
                    }
                    break;

                case 1:     // read entity declaration value
<span class="pc bpc" id="L849" title="2 of 4 branches missed.">                    switch (chtyp(ch)) {</span>
                        case '\&quot;':  // internal entity
                        case '\'':
<span class="fc" id="L852">                            bkch();</span>
<span class="fc" id="L853">                            bqstr('d');  // read a string into the buffer</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">                            if (mEnt.get(str) == null) {</span>
                                //              Create general entity value
<span class="fc" id="L856">                                val = new char[mBuffIdx];</span>
<span class="fc" id="L857">                                System.arraycopy(mBuff, 1, val, 0, val.length);</span>
                                //              Add the entity to the entity look up table
<span class="pc bpc" id="L859" title="1 of 2 branches missed.">                                if (mEnt.containsKey(str) == false) {   // [#4.2]</span>
<span class="fc" id="L860">                                    inp = new Input(val);</span>
<span class="fc" id="L861">                                    inp.pubid = mInp.pubid;</span>
<span class="fc" id="L862">                                    inp.sysid = mInp.sysid;</span>
<span class="fc" id="L863">                                    inp.xmlenc = mInp.xmlenc;</span>
<span class="fc" id="L864">                                    inp.xmlver = mInp.xmlver;</span>
<span class="fc" id="L865">                                    mEnt.put(str, inp);</span>
                                }
                            }
<span class="fc" id="L868">                            st = -1;  // the end of declaration</span>
<span class="fc" id="L869">                            break;</span>

                        case 'A':  // external entity
<span class="nc" id="L872">                            bkch();</span>
<span class="nc" id="L873">                            ids = pubsys(' ');</span>
<span class="nc bnc" id="L874" title="All 3 branches missed.">                            switch (wsskip()) {</span>
                                case '&gt;':  // external parsed entity
<span class="nc bnc" id="L876" title="All 2 branches missed.">                                    if (mEnt.containsKey(str) == false) {  // [#4.2]</span>
<span class="nc" id="L877">                                        inp = new Input();</span>
<span class="nc" id="L878">                                        inp.pubid = ids.name;</span>
<span class="nc" id="L879">                                        inp.sysid = ids.value;</span>
<span class="nc" id="L880">                                        mEnt.put(str, inp);</span>
                                    }
                                    break;

                                case 'N':  // external general unparsed entity
<span class="nc bnc" id="L885" title="All 2 branches missed.">                                    if (&quot;NDATA&quot;.equals(name(false)) == true) {</span>
<span class="nc" id="L886">                                        wsskip();</span>
<span class="nc" id="L887">                                        unparsedEntDecl(str, ids.name, ids.value, name(false));</span>
<span class="nc" id="L888">                                        break;</span>
                                    }
                                default:
<span class="nc" id="L891">                                    panic(FAULT);</span>
                                    break;
                            }
<span class="nc" id="L894">                            del(ids);</span>
<span class="nc" id="L895">                            st = -1;  // the end of declaration</span>
<span class="nc" id="L896">                            break;</span>

                        case ' ':
                            //          Skip white spaces
<span class="fc" id="L900">                            break;</span>

                        default:
<span class="nc" id="L903">                            panic(FAULT);</span>
<span class="nc" id="L904">                            break;</span>
                    }
                    break;

                default:
<span class="nc" id="L909">                    panic(FAULT);</span>
            }
        }
<span class="fc" id="L912">    }</span>

    /**
     * Parses an element declaration.
     *
     * This method parses the declaration up to the closing angle bracket.
     *
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void dtdelm() throws Exception {
        //              This is stub implementation which skips an element
        //              declaration.
<span class="fc" id="L926">        wsskip();</span>
<span class="fc" id="L927">        name(mIsNSAware);</span>

        char ch;
        while (true) {
<span class="fc" id="L931">            ch = getch();</span>
<span class="pc bpc" id="L932" title="1 of 3 branches missed.">            switch (ch) {</span>
                case '&gt;':
<span class="fc" id="L934">                    bkch();</span>
<span class="fc" id="L935">                    return;</span>

                case EOS:
<span class="nc" id="L938">                    panic(FAULT);</span>

                default:
<span class="fc" id="L941">                    break;</span>
            }
        }
    }

    /**
     * Parses an attribute list declaration.
     *
     * This method parses the declaration up to the closing angle bracket.
     *
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private void dtdattl() throws Exception {
<span class="fc" id="L955">        char elmqn[] = null;</span>
<span class="fc" id="L956">        Pair elm = null;</span>
        char ch;
<span class="pc bpc" id="L958" title="1 of 2 branches missed.">        for (short st = 0; st &gt;= 0;) {</span>
<span class="fc" id="L959">            ch = getch();</span>
<span class="pc bpc" id="L960" title="1 of 3 branches missed.">            switch (st) {</span>
                case 0:     // read the element name
<span class="pc bpc" id="L962" title="2 of 4 branches missed.">                    switch (chtyp(ch)) {</span>
                        case 'a':
                        case 'A':
                        case '_':
                        case 'X':
                        case ':':
<span class="fc" id="L968">                            bkch();</span>
                            //          Get the element from the list or add a new one.
<span class="fc" id="L970">                            elmqn = qname(mIsNSAware);</span>
<span class="fc" id="L971">                            elm = find(mAttL, elmqn);</span>
<span class="pc bpc" id="L972" title="1 of 2 branches missed.">                            if (elm == null) {</span>
<span class="fc" id="L973">                                elm = pair(mAttL);</span>
<span class="fc" id="L974">                                elm.chars = elmqn;</span>
<span class="fc" id="L975">                                mAttL = elm;</span>
                            }
<span class="fc" id="L977">                            st = 1;  // read an attribute declaration</span>
<span class="fc" id="L978">                            break;</span>

                        case ' ':
<span class="fc" id="L981">                            break;</span>

                        case '%':
<span class="nc" id="L984">                            pent(' ');</span>
<span class="nc" id="L985">                            break;</span>

                        default:
<span class="nc" id="L988">                            panic(FAULT);</span>
<span class="nc" id="L989">                            break;</span>
                    }
                    break;

                case 1:     // read an attribute declaration
<span class="pc bpc" id="L994" title="2 of 4 branches missed.">                    switch (chtyp(ch)) {</span>
                        case 'a':
                        case 'A':
                        case '_':
                        case 'X':
                        case ':':
<span class="fc" id="L1000">                            bkch();</span>
<span class="fc" id="L1001">                            dtdatt(elm);</span>
<span class="pc bpc" id="L1002" title="1 of 2 branches missed.">                            if (wsskip() == '&gt;') {</span>
<span class="fc" id="L1003">                                return;</span>
                            }
                            break;

                        case ' ':
<span class="fc" id="L1008">                            break;</span>

                        case '%':
<span class="nc" id="L1011">                            pent(' ');</span>
<span class="nc" id="L1012">                            break;</span>

                        default:
<span class="nc" id="L1015">                            panic(FAULT);</span>
<span class="nc" id="L1016">                            break;</span>
                    }
                    break;

                default:
<span class="nc" id="L1021">                    panic(FAULT);</span>
<span class="nc" id="L1022">                    break;</span>
            }
        }
<span class="nc" id="L1025">    }</span>

    /**
     * Parses an attribute declaration.
     *
     * The attribute uses the following fields of Pair object: chars - characters
     * of qualified name id - the type identifier of the attribute list - a pair
     * which holds the default value (chars field)
     *
     * @param elm An object which represents all defined attributes on an
     * element.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void dtdatt(Pair elm) throws Exception {
<span class="fc" id="L1041">        char attqn[] = null;</span>
<span class="fc" id="L1042">        Pair att = null;</span>
        char ch;
<span class="fc bfc" id="L1044" title="All 2 branches covered.">        for (short st = 0; st &gt;= 0;) {</span>
<span class="fc" id="L1045">            ch = getch();</span>
<span class="pc bpc" id="L1046" title="3 of 7 branches missed.">            switch (st) {</span>
                case 0:     // the attribute name
<span class="pc bpc" id="L1048" title="3 of 4 branches missed.">                    switch (chtyp(ch)) {</span>
                        case 'a':
                        case 'A':
                        case '_':
                        case 'X':
                        case ':':
<span class="fc" id="L1054">                            bkch();</span>
                            //          Get the attribute from the list or add a new one.
<span class="fc" id="L1056">                            attqn = qname(mIsNSAware);</span>
<span class="fc" id="L1057">                            att = find(elm.list, attqn);</span>
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">                            if (att == null) {</span>
                                //              New attribute declaration
<span class="fc" id="L1060">                                att = pair(elm.list);</span>
<span class="fc" id="L1061">                                att.chars = attqn;</span>
<span class="fc" id="L1062">                                elm.list = att;</span>
                            } else {
                                //              Do not override the attribute declaration [#3.3]
<span class="nc" id="L1065">                                att = pair(null);</span>
<span class="nc" id="L1066">                                att.chars = attqn;</span>
<span class="nc" id="L1067">                                att.id = 'c';</span>
                            }
<span class="fc" id="L1069">                            wsskip();</span>
<span class="fc" id="L1070">                            st = 1;</span>
<span class="fc" id="L1071">                            break;</span>

                        case '%':
<span class="nc" id="L1074">                            pent(' ');</span>
<span class="nc" id="L1075">                            break;</span>

                        case ' ':
<span class="nc" id="L1078">                            break;</span>

                        default:
<span class="nc" id="L1081">                            panic(FAULT);</span>
<span class="nc" id="L1082">                            break;</span>
                    }
                    break;

                case 1:     // the attribute type
<span class="pc bpc" id="L1087" title="3 of 4 branches missed.">                    switch (chtyp(ch)) {</span>
                        case '(':
<span class="nc" id="L1089">                            att.id = 'u';  // enumeration type</span>
<span class="nc" id="L1090">                            st = 2;        // read the first element of the list</span>
<span class="nc" id="L1091">                            break;</span>

                        case '%':
<span class="nc" id="L1094">                            pent(' ');</span>
<span class="nc" id="L1095">                            break;</span>

                        case ' ':
<span class="nc" id="L1098">                            break;</span>

                        default:
<span class="fc" id="L1101">                            bkch();</span>
<span class="fc" id="L1102">                            bntok();  // read type id</span>
<span class="fc" id="L1103">                            att.id = bkeyword();</span>
<span class="pc bpc" id="L1104" title="2 of 3 branches missed.">                            switch (att.id) {</span>
                                case 'o':   // NOTATION
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                                    if (wsskip() != '(') {</span>
<span class="nc" id="L1107">                                        panic(FAULT);</span>
                                    }
<span class="nc" id="L1109">                                    ch = getch();</span>
<span class="nc" id="L1110">                                    st = 2;  // read the first element of the list</span>
<span class="nc" id="L1111">                                    break;</span>

                                case 'i':     // ID
                                case 'r':     // IDREF
                                case 'R':     // IDREFS
                                case 'n':     // ENTITY
                                case 'N':     // ENTITIES
                                case 't':     // NMTOKEN
                                case 'T':     // NMTOKENS
                                case 'c':     // CDATA
<span class="fc" id="L1121">                                    wsskip();</span>
<span class="fc" id="L1122">                                    st = 4;  // read default declaration</span>
<span class="fc" id="L1123">                                    break;</span>

                                default:
<span class="nc" id="L1126">                                    panic(FAULT);</span>
<span class="nc" id="L1127">                                    break;</span>
                            }
                            break;
                    }
                    break;

                case 2:     // read the first element of the list
<span class="nc bnc" id="L1134" title="All 4 branches missed.">                    switch (chtyp(ch)) {</span>
                        case 'a':
                        case 'A':
                        case 'd':
                        case '.':
                        case ':':
                        case '-':
                        case '_':
                        case 'X':
<span class="nc" id="L1143">                            bkch();</span>
<span class="nc bnc" id="L1144" title="All 3 branches missed.">                            switch (att.id) {</span>
                                case 'u':  // enumeration type
<span class="nc" id="L1146">                                    bntok();</span>
<span class="nc" id="L1147">                                    break;</span>

                                case 'o':  // NOTATION
<span class="nc" id="L1150">                                    mBuffIdx = -1;</span>
<span class="nc" id="L1151">                                    bname(false);</span>
<span class="nc" id="L1152">                                    break;</span>

                                default:
<span class="nc" id="L1155">                                    panic(FAULT);</span>
                                    break;
                            }
<span class="nc" id="L1158">                            wsskip();</span>
<span class="nc" id="L1159">                            st = 3;  // read next element of the list</span>
<span class="nc" id="L1160">                            break;</span>

                        case '%':
<span class="nc" id="L1163">                            pent(' ');</span>
<span class="nc" id="L1164">                            break;</span>

                        case ' ':
<span class="nc" id="L1167">                            break;</span>

                        default:
<span class="nc" id="L1170">                            panic(FAULT);</span>
<span class="nc" id="L1171">                            break;</span>
                    }
                    break;

                case 3:     // read next element of the list
<span class="nc bnc" id="L1176" title="All 4 branches missed.">                    switch (ch) {</span>
                        case ')':
<span class="nc" id="L1178">                            wsskip();</span>
<span class="nc" id="L1179">                            st = 4;  // read default declaration</span>
<span class="nc" id="L1180">                            break;</span>

                        case '|':
<span class="nc" id="L1183">                            wsskip();</span>
<span class="nc bnc" id="L1184" title="All 3 branches missed.">                            switch (att.id) {</span>
                                case 'u':  // enumeration type
<span class="nc" id="L1186">                                    bntok();</span>
<span class="nc" id="L1187">                                    break;</span>

                                case 'o':  // NOTATION
<span class="nc" id="L1190">                                    mBuffIdx = -1;</span>
<span class="nc" id="L1191">                                    bname(false);</span>
<span class="nc" id="L1192">                                    break;</span>

                                default:
<span class="nc" id="L1195">                                    panic(FAULT);</span>
                                    break;
                            }
<span class="nc" id="L1198">                            wsskip();</span>
<span class="nc" id="L1199">                            break;</span>

                        case '%':
<span class="nc" id="L1202">                            pent(' ');</span>
<span class="nc" id="L1203">                            break;</span>

                        default:
<span class="nc" id="L1206">                            panic(FAULT);</span>
<span class="nc" id="L1207">                            break;</span>
                    }
                    break;

                case 4:     // read default declaration
<span class="pc bpc" id="L1212" title="4 of 5 branches missed.">                    switch (ch) {</span>
                        case '#':
<span class="fc" id="L1214">                            bntok();</span>
<span class="pc bpc" id="L1215" title="1 of 3 branches missed.">                            switch (bkeyword()) {</span>
                                case 'F':  // FIXED
<span class="pc bpc" id="L1217" title="2 of 3 branches missed.">                                    switch (wsskip()) {</span>
                                        case '\&quot;':
                                        case '\'':
<span class="fc" id="L1220">                                            st = 5;  // read the default value</span>
<span class="fc" id="L1221">                                            break;</span>

                                        case EOS:
<span class="nc" id="L1224">                                            panic(FAULT);</span>

                                        default:
<span class="nc" id="L1227">                                            st = -1;</span>
<span class="nc" id="L1228">                                            break;</span>
                                    }
                                    break;

                                case 'Q':  // REQUIRED
                                case 'I':  // IMPLIED
<span class="fc" id="L1234">                                    st = -1;</span>
<span class="fc" id="L1235">                                    break;</span>

                                default:
<span class="nc" id="L1238">                                    panic(FAULT);</span>
<span class="nc" id="L1239">                                    break;</span>
                            }
                            break;

                        case '\&quot;':
                        case '\'':
<span class="nc" id="L1245">                            bkch();</span>
<span class="nc" id="L1246">                            st = 5;  // read the default value</span>
<span class="nc" id="L1247">                            break;</span>

                        case ' ':
                        case '\n':
                        case '\r':
                        case '\t':
<span class="nc" id="L1253">                            break;</span>

                        case '%':
<span class="nc" id="L1256">                            pent(' ');</span>
<span class="nc" id="L1257">                            break;</span>

                        default:
<span class="nc" id="L1260">                            bkch();</span>
<span class="nc" id="L1261">                            st = -1;</span>
<span class="nc" id="L1262">                            break;</span>
                    }
                    break;

                case 5:     // read the default value
<span class="pc bpc" id="L1267" title="1 of 2 branches missed.">                    switch (ch) {</span>
                        case '\&quot;':
                        case '\'':
<span class="fc" id="L1270">                            bkch();</span>
<span class="fc" id="L1271">                            bqstr('d');  // the value in the mBuff now</span>
<span class="fc" id="L1272">                            att.list = pair(null);</span>
                            //          Create a string like &quot;attqname='value' &quot;
<span class="fc" id="L1274">                            att.list.chars = new char[att.chars.length + mBuffIdx + 3];</span>
<span class="fc" id="L1275">                            System.arraycopy(</span>
                                    att.chars, 1, att.list.chars, 0, att.chars.length - 1);
<span class="fc" id="L1277">                            att.list.chars[att.chars.length - 1] = '=';</span>
<span class="fc" id="L1278">                            att.list.chars[att.chars.length] = ch;</span>
<span class="fc" id="L1279">                            System.arraycopy(</span>
                                    mBuff, 1, att.list.chars, att.chars.length + 1, mBuffIdx);
<span class="fc" id="L1281">                            att.list.chars[att.chars.length + mBuffIdx + 1] = ch;</span>
<span class="fc" id="L1282">                            att.list.chars[att.chars.length + mBuffIdx + 2] = ' ';</span>
<span class="fc" id="L1283">                            st = -1;</span>
<span class="fc" id="L1284">                            break;</span>

                        default:
<span class="nc" id="L1287">                            panic(FAULT);</span>
<span class="nc" id="L1288">                            break;</span>
                    }
                    break;

                default:
<span class="nc" id="L1293">                    panic(FAULT);</span>
<span class="nc" id="L1294">                    break;</span>
            }
        }
<span class="fc" id="L1297">    }</span>

    /**
     * Parses a notation declaration.
     *
     * This method parses the declaration up to the closing angle bracket.
     *
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private void dtdnot() throws Exception {
<span class="nc" id="L1308">        wsskip();</span>
<span class="nc" id="L1309">        String name = name(false);</span>
<span class="nc" id="L1310">        wsskip();</span>
<span class="nc" id="L1311">        Pair ids = pubsys('N');</span>
<span class="nc" id="L1312">        notDecl(name, ids.name, ids.value);</span>
<span class="nc" id="L1313">        del(ids);</span>
<span class="nc" id="L1314">    }</span>

    /**
     * Parses an attribute.
     *
     * This recursive method is responsible for prefix addition
     * (
     * &lt;code&gt;mPref&lt;/code&gt;) on the way down. The element's start tag end triggers
     * the return process. The method then on it's way back resolves prefixes
     * and accumulates attributes.
     *
     * &lt;p&gt;&lt;code&gt;att.num&lt;/code&gt; carries attribute flags where: 0x1 - attribute is
     * declared in DTD (attribute decalration had been read); 0x2 - attribute's
     * default value is used.&lt;/p&gt;
     *
     * @param att An object which reprecents current attribute.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void attr(Pair att) throws Exception {
<span class="pc bpc" id="L1335" title="1 of 3 branches missed.">        switch (wsskip()) {</span>
            case '/':
            case '&gt;':
<span class="fc bfc" id="L1338" title="All 2 branches covered.">                if ((att.num &amp; 0x2) == 0) {  // all attributes have been read</span>
<span class="fc" id="L1339">                    att.num |= 0x2;  // set default attribute flag</span>
<span class="fc" id="L1340">                    Input inp = mInp;</span>
                    //          Go through all attributes defined on current element.
<span class="fc bfc" id="L1342" title="All 2 branches covered.">                    for (Pair def = mElm.list; def != null; def = def.next) {</span>
<span class="fc bfc" id="L1343" title="All 2 branches covered.">                        if (def.list == null) // no default value</span>
                        {
<span class="fc" id="L1345">                            continue;</span>
                        }
                        //              Go through all attributes defined on current
                        //              element and add defaults.
<span class="fc" id="L1349">                        Pair act = find(att.next, def.chars);</span>
<span class="pc bpc" id="L1350" title="1 of 2 branches missed.">                        if (act == null) {</span>
<span class="fc" id="L1351">                            push(new Input(def.list.chars));</span>
                        }
                    }
<span class="fc bfc" id="L1354" title="All 2 branches covered.">                    if (mInp != inp) {  // defaults have been added</span>
<span class="fc" id="L1355">                        attr(att);</span>
<span class="fc" id="L1356">                        return;</span>
                    }
                }
                //              Ensure the attribute string array capacity
<span class="fc" id="L1360">                mAttrs.setLength(mAttrIdx);</span>
<span class="fc" id="L1361">                mItems = mAttrs.mItems;</span>
<span class="fc" id="L1362">                return;</span>

            case EOS:
<span class="nc" id="L1365">                panic(FAULT);</span>

            default:
                //              Read the attribute name and value
<span class="fc" id="L1369">                att.chars = qname(mIsNSAware);</span>
<span class="fc" id="L1370">                att.name = att.local();</span>
<span class="fc" id="L1371">                String type = atype(att);  // sets attribute's type on att.id</span>
<span class="fc" id="L1372">                wsskip();</span>
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">                if (getch() != '=') {</span>
<span class="nc" id="L1374">                    panic(FAULT);</span>
                }
<span class="fc" id="L1376">                bqstr((char) att.id);   // read the value with normalization.</span>
<span class="fc" id="L1377">                String val = new String(mBuff, 1, mBuffIdx);</span>
<span class="fc" id="L1378">                Pair next = pair(att);</span>
<span class="fc" id="L1379">                next.num = (att.num &amp; ~0x1);  // inherit attribute flags</span>
                //              Put a namespace declaration on top of the prefix stack
<span class="pc bpc" id="L1381" title="3 of 4 branches missed.">                if ((mIsNSAware == false) || (isdecl(att, val) == false)) {</span>
                    //          An ordinary attribute
<span class="fc" id="L1383">                    mAttrIdx++;</span>
<span class="fc" id="L1384">                    attr(next);     // recursive call to parse the next attribute</span>
<span class="fc" id="L1385">                    mAttrIdx--;</span>
                    //          Add the attribute to the attributes string array
<span class="fc" id="L1387">                    char idx = (char) (mAttrIdx &lt;&lt; 3);</span>
<span class="fc" id="L1388">                    mItems[idx + 1] = att.qname();  // attr qname</span>
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">                    mItems[idx + 2] = (mIsNSAware) ? att.name : &quot;&quot;; // attr local name</span>
<span class="fc" id="L1390">                    mItems[idx + 3] = val;          // attr value</span>
<span class="fc" id="L1391">                    mItems[idx + 4] = type;         // attr type</span>
<span class="fc bfc" id="L1392" title="All 3 branches covered.">                    switch (att.num &amp; 0x3) {</span>
                        case 0x0:
<span class="fc" id="L1394">                            mItems[idx + 5] = null;</span>
<span class="fc" id="L1395">                            break;</span>

                        case 0x1:  // declared attribute
<span class="fc" id="L1398">                            mItems[idx + 5] = &quot;d&quot;;</span>
<span class="fc" id="L1399">                            break;</span>

                        default:  // 0x2, 0x3 - default attribute always declared
<span class="fc" id="L1402">                            mItems[idx + 5] = &quot;D&quot;;</span>
                            break;
                    }
                    //          Resolve the prefix if any and report the attribute
                    //          NOTE: The attribute does not accept the default namespace.
<span class="pc bpc" id="L1407" title="1 of 2 branches missed.">                    mItems[idx + 0] = (att.chars[0] != 0) ? rslv(att.chars) : &quot;&quot;;</span>
<span class="fc" id="L1408">                } else {</span>
                    //          A namespace declaration. mPref.name contains prefix and
                    //          mPref.value contains namespace URI set by isdecl method.
                    //          Report a start of the new mapping
<span class="nc" id="L1412">                    newPrefix();</span>
                    //          Recursive call to parse the next attribute
<span class="nc" id="L1414">                    attr(next);</span>
                    //          NOTE: The namespace declaration is not reported.
                }
<span class="fc" id="L1417">                del(next);</span>
                break;
        }
<span class="fc" id="L1420">    }</span>

    /**
     * Retrieves attribute type.
     *
     * This method sets the type of normalization in the attribute
     * &lt;code&gt;id&lt;/code&gt; field and returns the name of attribute type.
     *
     * @param att An object which represents current attribute.
     * @return The name of the attribute type.
     * @exception Exception is parser specific exception form panic method.
     */
    private String atype(Pair att)
            throws Exception {
        Pair attr;

        // CDATA-type normalization by default [#3.3.3]
<span class="fc" id="L1437">        att.id = 'c';</span>
<span class="fc bfc" id="L1438" title="All 4 branches covered.">        if (mElm.list == null || (attr = find(mElm.list, att.chars)) == null) {</span>
<span class="fc" id="L1439">            return &quot;CDATA&quot;;</span>
        }

<span class="fc" id="L1442">        att.num |= 0x1;  // attribute is declared</span>

        // Non-CDATA normalization except when the attribute type is CDATA.
<span class="fc" id="L1445">        att.id = 'i';</span>
<span class="pc bpc" id="L1446" title="10 of 11 branches missed.">        switch (attr.id) {</span>
            case 'i':
<span class="nc" id="L1448">                return &quot;ID&quot;;</span>

            case 'r':
<span class="nc" id="L1451">                return &quot;IDREF&quot;;</span>

            case 'R':
<span class="nc" id="L1454">                return &quot;IDREFS&quot;;</span>

            case 'n':
<span class="nc" id="L1457">                return &quot;ENTITY&quot;;</span>

            case 'N':
<span class="nc" id="L1460">                return &quot;ENTITIES&quot;;</span>

            case 't':
<span class="nc" id="L1463">                return &quot;NMTOKEN&quot;;</span>

            case 'T':
<span class="nc" id="L1466">                return &quot;NMTOKENS&quot;;</span>

            case 'u':
<span class="nc" id="L1469">                return &quot;NMTOKEN&quot;;</span>

            case 'o':
<span class="nc" id="L1472">                return &quot;NOTATION&quot;;</span>

            case 'c':
<span class="fc" id="L1475">                att.id = 'c';</span>
<span class="fc" id="L1476">                return &quot;CDATA&quot;;</span>

            default:
<span class="nc" id="L1479">                panic(FAULT);</span>
        }
<span class="nc" id="L1481">        return null;</span>
    }

    /**
     * Parses a comment.
     *
     * The &amp;apos;&amp;lt;!&amp;apos; part is read in dispatcher so the method starts
     * with first &amp;apos;-&amp;apos; after &amp;apos;&amp;lt;!&amp;apos;.
     *
     * @exception Exception is parser specific exception form panic method.
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void comm() throws Exception {
<span class="pc bpc" id="L1494" title="1 of 2 branches missed.">        if (mPh == PH_DOC_START) {</span>
<span class="nc" id="L1495">            mPh = PH_MISC_DTD;  // misc before DTD</span>
        }               // '&lt;!' has been already read by dispetcher.
        char ch;
<span class="fc" id="L1498">        mBuffIdx = -1;</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">        for (short st = 0; st &gt;= 0;) {</span>
<span class="fc bfc" id="L1500" title="All 2 branches covered.">            ch = (mChIdx &lt; mChLen) ? mChars[mChIdx++] : getch();</span>
<span class="pc bpc" id="L1501" title="1 of 2 branches missed.">            if (ch == EOS) {</span>
<span class="nc" id="L1502">                panic(FAULT);</span>
            }
<span class="pc bpc" id="L1504" title="1 of 6 branches missed.">            switch (st) {</span>
                case 0:     // first '-' of the comment open
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">                    if (ch == '-') {</span>
<span class="fc" id="L1507">                        st = 1;</span>
                    } else {
<span class="nc" id="L1509">                        panic(FAULT);</span>
                    }
<span class="nc" id="L1511">                    break;</span>

                case 1:     // secind '-' of the comment open
<span class="pc bpc" id="L1514" title="1 of 2 branches missed.">                    if (ch == '-') {</span>
<span class="fc" id="L1515">                        st = 2;</span>
                    } else {
<span class="nc" id="L1517">                        panic(FAULT);</span>
                    }
<span class="nc" id="L1519">                    break;</span>

                case 2:     // skip the comment body
<span class="fc bfc" id="L1522" title="All 2 branches covered.">                    switch (ch) {</span>
                        case '-':
<span class="fc" id="L1524">                            st = 3;</span>
<span class="fc" id="L1525">                            break;</span>

                        default:
<span class="fc" id="L1528">                            bappend(ch);</span>
<span class="fc" id="L1529">                            break;</span>
                    }
                    break;

                case 3:     // second '-' of the comment close
<span class="fc bfc" id="L1534" title="All 2 branches covered.">                    switch (ch) {</span>
                        case '-':
<span class="fc" id="L1536">                            st = 4;</span>
<span class="fc" id="L1537">                            break;</span>

                        default:
<span class="fc" id="L1540">                            bappend('-');</span>
<span class="fc" id="L1541">                            bappend(ch);</span>
<span class="fc" id="L1542">                            st = 2;</span>
<span class="fc" id="L1543">                            break;</span>
                    }
                    break;

                case 4:     // '&gt;' of the comment close
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">                    if (ch == '&gt;') {</span>
<span class="fc" id="L1549">                        comm(mBuff, mBuffIdx + 1);</span>
<span class="fc" id="L1550">                        st = -1;</span>
<span class="fc" id="L1551">                        break;</span>
                    }
                // else - panic [#2.5 compatibility note]

                default:
<span class="nc" id="L1556">                    panic(FAULT);</span>
            }
        }
<span class="fc" id="L1559">    }</span>

    /**
     * Parses a processing instruction.
     *
     * The &amp;apos;&amp;lt;?&amp;apos; is read in dispatcher so the method starts with
     * first character of PI target name after &amp;apos;&amp;lt;?&amp;apos;.
     *
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private void pi() throws Exception {
        // '&lt;?' has been already read by dispetcher.
        char ch;
<span class="fc" id="L1573">        String str = null;</span>
<span class="fc" id="L1574">        mBuffIdx = -1;</span>
<span class="fc bfc" id="L1575" title="All 2 branches covered.">        for (short st = 0; st &gt;= 0;) {</span>
<span class="fc" id="L1576">            ch = getch();</span>
<span class="pc bpc" id="L1577" title="1 of 2 branches missed.">            if (ch == EOS) {</span>
<span class="nc" id="L1578">                panic(FAULT);</span>
            }
<span class="pc bpc" id="L1580" title="1 of 4 branches missed.">            switch (st) {</span>
                case 0:     // read the PI target name
<span class="pc bpc" id="L1582" title="1 of 2 branches missed.">                    switch (chtyp(ch)) {</span>
                        case 'a':
                        case 'A':
                        case '_':
                        case ':':
                        case 'X':
<span class="fc" id="L1588">                            bkch();</span>
<span class="fc" id="L1589">                            str = name(false);</span>
                            //          PI target name may not be empty string [#2.6]
                            //          PI target name 'XML' is reserved [#2.6]
<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">                            if ((str.length() == 0)</span>
<span class="pc bpc" id="L1593" title="1 of 2 branches missed.">                                    || (mXml.name.equals(str.toLowerCase()) == true)) {</span>
<span class="nc" id="L1594">                                panic(FAULT);</span>
                            }
                            //          This is processing instruction
<span class="pc bpc" id="L1597" title="1 of 2 branches missed.">                            if (mPh == PH_DOC_START) // the begining of the document</span>
                            {
<span class="nc" id="L1599">                                mPh = PH_MISC_DTD;    // misc before DTD</span>
                            }
<span class="fc" id="L1601">                            wsskip();  // skip spaces after the PI target name</span>
<span class="fc" id="L1602">                            st = 1;    // accumulate the PI body</span>
<span class="fc" id="L1603">                            mBuffIdx = -1;</span>
<span class="fc" id="L1604">                            break;</span>

                        default:
<span class="nc" id="L1607">                            panic(FAULT);</span>
                    }
<span class="nc" id="L1609">                    break;</span>

                case 1:     // accumulate the PI body
<span class="fc bfc" id="L1612" title="All 2 branches covered.">                    switch (ch) {</span>
                        case '?':
<span class="fc" id="L1614">                            st = 2;  // end of the PI body</span>
<span class="fc" id="L1615">                            break;</span>

                        default:
<span class="fc" id="L1618">                            bappend(ch);</span>
<span class="fc" id="L1619">                            break;</span>
                    }
                    break;

                case 2:     // end of the PI body
<span class="pc bpc" id="L1624" title="2 of 3 branches missed.">                    switch (ch) {</span>
                        case '&gt;':
                            //          PI has been read.
<span class="fc" id="L1627">                            pi(str, new String(mBuff, 0, mBuffIdx + 1));</span>
<span class="fc" id="L1628">                            st = -1;</span>
<span class="fc" id="L1629">                            break;</span>

                        case '?':
<span class="nc" id="L1632">                            bappend('?');</span>
<span class="nc" id="L1633">                            break;</span>

                        default:
<span class="nc" id="L1636">                            bappend('?');</span>
<span class="nc" id="L1637">                            bappend(ch);</span>
<span class="nc" id="L1638">                            st = 1;  // accumulate the PI body</span>
<span class="nc" id="L1639">                            break;</span>
                    }
                    break;

                default:
<span class="nc" id="L1644">                    panic(FAULT);</span>
            }
        }
<span class="fc" id="L1647">    }</span>

    /**
     * Parses a character data.
     *
     * The &amp;apos;&amp;lt;!&amp;apos; part is read in dispatcher so the method starts
     * with first &amp;apos;[&amp;apos; after &amp;apos;&amp;lt;!&amp;apos;.
     *
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private void cdat()
            throws Exception {
        // '&lt;!' has been already read by dispetcher.
        char ch;
<span class="fc" id="L1662">        mBuffIdx = -1;</span>
<span class="fc bfc" id="L1663" title="All 2 branches covered.">        for (short st = 0; st &gt;= 0;) {</span>
<span class="fc" id="L1664">            ch = getch();</span>
<span class="pc bpc" id="L1665" title="1 of 7 branches missed.">            switch (st) {</span>
                case 0:     // the first '[' of the CDATA open
<span class="pc bpc" id="L1667" title="1 of 2 branches missed.">                    if (ch == '[') {</span>
<span class="fc" id="L1668">                        st = 1;</span>
                    } else {
<span class="nc" id="L1670">                        panic(FAULT);</span>
                    }
<span class="nc" id="L1672">                    break;</span>

                case 1:     // read &quot;CDATA&quot;
<span class="fc bfc" id="L1675" title="All 2 branches covered.">                    if (chtyp(ch) == 'A') {</span>
<span class="fc" id="L1676">                        bappend(ch);</span>
                    } else {
<span class="pc bpc" id="L1678" title="1 of 2 branches missed.">                        if (&quot;CDATA&quot;.equals(</span>
                                new String(mBuff, 0, mBuffIdx + 1)) != true) {
<span class="nc" id="L1680">                            panic(FAULT);</span>
                        }
<span class="fc" id="L1682">                        bkch();</span>
<span class="fc" id="L1683">                        st = 2;</span>
                    }
<span class="fc" id="L1685">                    break;</span>

                case 2:     // the second '[' of the CDATA open
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">                    if (ch != '[') {</span>
<span class="nc" id="L1689">                        panic(FAULT);</span>
                    }
<span class="fc" id="L1691">                    mBuffIdx = -1;</span>
<span class="fc" id="L1692">                    st = 3;</span>
<span class="fc" id="L1693">                    break;</span>

                case 3:     // read data before the first ']'
<span class="fc bfc" id="L1696" title="All 2 branches covered.">                    if (ch != ']') {</span>
<span class="fc" id="L1697">                        bappend(ch);</span>
                    } else {
<span class="fc" id="L1699">                        st = 4;</span>
                    }
<span class="fc" id="L1701">                    break;</span>

                case 4:     // read the second ']' or continue to read the data
<span class="pc bpc" id="L1704" title="1 of 2 branches missed.">                    if (ch != ']') {</span>
<span class="nc" id="L1705">                        bappend(']');</span>
<span class="nc" id="L1706">                        bappend(ch);</span>
<span class="nc" id="L1707">                        st = 3;</span>
                    } else {
<span class="fc" id="L1709">                        st = 5;</span>
                    }
<span class="fc" id="L1711">                    break;</span>

                case 5:     // read '&gt;' or continue to read the data
<span class="pc bpc" id="L1714" title="2 of 3 branches missed.">                    switch (ch) {</span>
                        case ']':
<span class="nc" id="L1716">                            bappend(']');</span>
<span class="nc" id="L1717">                            break;</span>

                        case '&gt;':
<span class="fc" id="L1720">                            bflash();</span>
<span class="fc" id="L1721">                            st = -1;</span>
<span class="fc" id="L1722">                            break;</span>

                        default:
<span class="nc" id="L1725">                            bappend(']');</span>
<span class="nc" id="L1726">                            bappend(']');</span>
<span class="nc" id="L1727">                            bappend(ch);</span>
<span class="nc" id="L1728">                            st = 3;</span>
<span class="nc" id="L1729">                            break;</span>
                    }
                    break;

                default:
<span class="nc" id="L1734">                    panic(FAULT);</span>
            }
        }
<span class="fc" id="L1737">    }</span>

    /**
     * Reads a xml name.
     *
     * The xml name must conform &quot;Namespaces in XML&quot; specification. Therefore
     * the ':' character is not allowed in the name. This method should be used
     * for PI and entity names which may not have a namespace according to the
     * specification mentioned above.
     *
     * @param ns The true value turns namespace conformance on.
     * @return The name has been read.
     * @exception Exception When incorrect character appear in the name.
     * @exception IOException
     */
    protected String name(boolean ns)
            throws Exception {
<span class="fc" id="L1754">        mBuffIdx = -1;</span>
<span class="fc" id="L1755">        bname(ns);</span>
<span class="fc" id="L1756">        return new String(mBuff, 1, mBuffIdx);</span>
    }

    /**
     * Reads a qualified xml name.
     *
     * The characters of a qualified name is an array of characters. The first
     * (chars[0]) character is the index of the colon character which separates
     * the prefix from the local name. If the index is zero, the name does not
     * contain separator or the parser works in the namespace unaware mode. The
     * length of qualified name is the length of the array minus one.
     *
     * @param ns The true value turns namespace conformance on.
     * @return The characters of a qualified name.
     * @exception Exception When incorrect character appear in the name.
     * @exception IOException
     */
    protected char[] qname(boolean ns)
            throws Exception {
<span class="fc" id="L1775">        mBuffIdx = -1;</span>
<span class="fc" id="L1776">        bname(ns);</span>
<span class="fc" id="L1777">        char chars[] = new char[mBuffIdx + 1];</span>
<span class="fc" id="L1778">        System.arraycopy(mBuff, 0, chars, 0, mBuffIdx + 1);</span>
<span class="fc" id="L1779">        return chars;</span>
    }

    /**
     * Reads the public or/and system identifiers.
     *
     * @param inp The input object.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private void pubsys(Input inp)
            throws Exception {
<span class="nc" id="L1791">        Pair pair = pubsys(' ');</span>
<span class="nc" id="L1792">        inp.pubid = pair.name;</span>
<span class="nc" id="L1793">        inp.sysid = pair.value;</span>
<span class="nc" id="L1794">        del(pair);</span>
<span class="nc" id="L1795">    }</span>

    /**
     * Reads the public or/and system identifiers.
     *
     * @param flag The 'N' allows public id be without system id.
     * @return The public or/and system identifiers pair.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private Pair pubsys(char flag) throws Exception {
<span class="fc" id="L1807">        Pair ids = pair(null);</span>
<span class="fc" id="L1808">        String str = name(false);</span>
<span class="pc bpc" id="L1809" title="1 of 2 branches missed.">        if (&quot;PUBLIC&quot;.equals(str) == true) {</span>
<span class="nc" id="L1810">            bqstr('i');  // non-CDATA normalization [#4.2.2]</span>
<span class="nc" id="L1811">            ids.name = new String(mBuff, 1, mBuffIdx);</span>
<span class="nc bnc" id="L1812" title="All 3 branches missed.">            switch (wsskip()) {</span>
                case '\&quot;':
                case '\'':
<span class="nc" id="L1815">                    bqstr(' ');</span>
<span class="nc" id="L1816">                    ids.value = new String(mBuff, 1, mBuffIdx);</span>
<span class="nc" id="L1817">                    break;</span>

                case EOS:
<span class="nc" id="L1820">                    panic(FAULT);</span>

                default:
<span class="nc bnc" id="L1823" title="All 2 branches missed.">                    if (flag != 'N') // [#4.7]</span>
                    {
<span class="nc" id="L1825">                        panic(FAULT);</span>
                    }
<span class="nc" id="L1827">                    ids.value = null;</span>
                    break;
            }
<span class="nc" id="L1830">            return ids;</span>
<span class="pc bpc" id="L1831" title="1 of 2 branches missed.">        } else if (&quot;SYSTEM&quot;.equals(str) == true) {</span>
<span class="fc" id="L1832">            ids.name = null;</span>
<span class="fc" id="L1833">            bqstr(' ');</span>
<span class="fc" id="L1834">            ids.value = new String(mBuff, 1, mBuffIdx);</span>
<span class="fc" id="L1835">            return ids;</span>
        }
<span class="nc" id="L1837">        panic(FAULT);</span>
<span class="nc" id="L1838">        return null;</span>
    }

    /**
     * Reads an attribute value.
     *
     * The grammar which this method can read is:&lt;br /&gt;
     * &lt;code&gt;eqstr := S &amp;quot;=&amp;quot; qstr&lt;/code&gt;&lt;br /&gt;
     * &lt;code&gt;qstr  := S (&amp;quot;'&amp;quot; string &amp;quot;'&amp;quot;) |
     *  ('&amp;quot;' string '&amp;quot;')&lt;/code&gt;&lt;br /&gt; This method resolves entities
     * inside a string unless the parser parses DTD.
     *
     * @param flag The '=' character forces the method to accept the '='
     * character before quoted string and read the following string as not an
     * attribute ('-'), 'c' - CDATA, 'i' - non CDATA, ' ' - no normalization;
     * '-' - not an attribute value; 'd' - in DTD context.
     * @return The content of the quoted strign as a string.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    protected String eqstr(char flag) throws Exception {
<span class="pc bpc" id="L1859" title="1 of 2 branches missed.">        if (flag == '=') {</span>
<span class="fc" id="L1860">            wsskip();</span>
<span class="pc bpc" id="L1861" title="1 of 2 branches missed.">            if (getch() != '=') {</span>
<span class="nc" id="L1862">                panic(FAULT);</span>
            }
        }
<span class="pc bpc" id="L1865" title="1 of 2 branches missed.">        bqstr((flag == '=') ? '-' : flag);</span>
<span class="fc" id="L1866">        return new String(mBuff, 1, mBuffIdx);</span>
    }

    /**
     * Resoves an entity.
     *
     * This method resolves built-in and character entity references. It is also
     * reports external entities to the application.
     *
     * @param flag The 'x' character forces the method to report a skipped
     * entity; 'i' character - indicates non-CDATA normalization.
     * @return Name of unresolved entity or &lt;code&gt;null&lt;/code&gt; if entity had been
     * resolved successfully.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private String ent(char flag) throws Exception {
        char ch;
<span class="fc" id="L1885">        int idx = mBuffIdx + 1;</span>
<span class="fc" id="L1886">        Input inp = null;</span>
<span class="fc" id="L1887">        String str = null;</span>
<span class="fc" id="L1888">        mESt = 0x100;  // reset the built-in entity recognizer</span>
<span class="fc" id="L1889">        bappend('&amp;');</span>
<span class="fc bfc" id="L1890" title="All 2 branches covered.">        for (short st = 0; st &gt;= 0;) {</span>
<span class="pc bpc" id="L1891" title="1 of 2 branches missed.">            ch = (mChIdx &lt; mChLen) ? mChars[mChIdx++] : getch();</span>
<span class="pc bpc" id="L1892" title="3 of 4 branches missed.">            switch (st) {</span>
                case 0:     // the first character of the entity name
                case 1:     // read built-in entity name
<span class="pc bpc" id="L1895" title="4 of 6 branches missed.">                    switch (chtyp(ch)) {</span>
                        case 'd':
                        case '.':
                        case '-':
<span class="nc bnc" id="L1899" title="All 2 branches missed.">                            if (st != 1) {</span>
<span class="nc" id="L1900">                                panic(FAULT);</span>
                            }
                        case 'a':
                        case 'A':
                        case '_':
                        case 'X':
<span class="fc" id="L1906">                            bappend(ch);</span>
<span class="fc" id="L1907">                            eappend(ch);</span>
<span class="fc" id="L1908">                            st = 1;</span>
<span class="fc" id="L1909">                            break;</span>

                        case ':':
<span class="nc bnc" id="L1912" title="All 2 branches missed.">                            if (mIsNSAware != false) {</span>
<span class="nc" id="L1913">                                panic(FAULT);</span>
                            }
<span class="nc" id="L1915">                            bappend(ch);</span>
<span class="nc" id="L1916">                            eappend(ch);</span>
<span class="nc" id="L1917">                            st = 1;</span>
<span class="nc" id="L1918">                            break;</span>

                        case ';':
<span class="fc bfc" id="L1921" title="All 2 branches covered.">                            if (mESt &lt; 0x100) {</span>
                                //              The entity is a built-in entity
<span class="fc" id="L1923">                                mBuffIdx = idx - 1;</span>
<span class="fc" id="L1924">                                bappend(mESt);</span>
<span class="fc" id="L1925">                                st = -1;</span>
<span class="fc" id="L1926">                                break;</span>
<span class="pc bpc" id="L1927" title="1 of 2 branches missed.">                            } else if (mPh == PH_DTD) {</span>
                                //              In DTD entity declaration has to resolve character
                                //              entities and include &quot;as is&quot; others. [#4.4.7]
<span class="nc" id="L1930">                                bappend(';');</span>
<span class="nc" id="L1931">                                st = -1;</span>
<span class="nc" id="L1932">                                break;</span>
                            }
                            //          Convert an entity name to a string
<span class="fc" id="L1935">                            str = new String(mBuff, idx + 1, mBuffIdx - idx);</span>
<span class="fc" id="L1936">                            inp = mEnt.get(str);</span>
                            //          Restore the buffer offset
<span class="fc" id="L1938">                            mBuffIdx = idx - 1;</span>
<span class="pc bpc" id="L1939" title="1 of 2 branches missed.">                            if (inp != null) {</span>
<span class="pc bpc" id="L1940" title="1 of 2 branches missed.">                                if (inp.chars == null) {</span>
                                    //          External entity
<span class="nc" id="L1942">                                    InputSource is = resolveEnt(str, inp.pubid, inp.sysid);</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">                                    if (is != null) {</span>
<span class="nc" id="L1944">                                        push(new Input(BUFFSIZE_READER));</span>
<span class="nc" id="L1945">                                        setinp(is);</span>
<span class="nc" id="L1946">                                        mInp.pubid = inp.pubid;</span>
<span class="nc" id="L1947">                                        mInp.sysid = inp.sysid;</span>
<span class="nc" id="L1948">                                        str = null;  // the entity is resolved</span>
                                    } else {
                                        //              Unresolved external entity
<span class="nc bnc" id="L1951" title="All 2 branches missed.">                                        if (flag != 'x') {</span>
<span class="nc" id="L1952">                                            panic(FAULT);  // unknown entity within marckup</span>
                                        }                                                               //              str is name of unresolved entity
                                    }
<span class="nc" id="L1955">                                } else {</span>
                                    //          Internal entity
<span class="fc" id="L1957">                                    push(inp);</span>
<span class="fc" id="L1958">                                    str = null;  // the entity is resolved</span>
                                }
                            } else {
                                //              Unknown or general unparsed entity
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                                if (flag != 'x') {</span>
<span class="nc" id="L1963">                                    panic(FAULT);  // unknown entity within marckup</span>
                                }                                               //              str is name of unresolved entity
                            }
<span class="fc" id="L1966">                            st = -1;</span>
<span class="fc" id="L1967">                            break;</span>

                        case '#':
<span class="nc bnc" id="L1970" title="All 2 branches missed.">                            if (st != 0) {</span>
<span class="nc" id="L1971">                                panic(FAULT);</span>
                            }
<span class="nc" id="L1973">                            st = 2;</span>
<span class="nc" id="L1974">                            break;</span>

                        default:
<span class="nc" id="L1977">                            panic(FAULT);</span>
                    }
<span class="nc" id="L1979">                    break;</span>

                case 2:     // read character entity
<span class="nc bnc" id="L1982" title="All 4 branches missed.">                    switch (chtyp(ch)) {</span>
                        case 'd':
<span class="nc" id="L1984">                            bappend(ch);</span>
<span class="nc" id="L1985">                            break;</span>

                        case ';':
                            //          Convert the character entity to a character
                            try {
<span class="nc" id="L1990">                                int i = Integer.parseInt(</span>
                                        new String(mBuff, idx + 1, mBuffIdx - idx), 10);
<span class="nc bnc" id="L1992" title="All 2 branches missed.">                                if (i &gt;= 0xffff) {</span>
<span class="nc" id="L1993">                                    panic(FAULT);</span>
                                }
<span class="nc" id="L1995">                                ch = (char) i;</span>
<span class="nc" id="L1996">                            } catch (NumberFormatException nfe) {</span>
<span class="nc" id="L1997">                                panic(FAULT);</span>
<span class="nc" id="L1998">                            }</span>
                            //          Restore the buffer offset
<span class="nc" id="L2000">                            mBuffIdx = idx - 1;</span>
<span class="nc bnc" id="L2001" title="All 4 branches missed.">                            if (ch == ' ' || mInp.next != null) {</span>
<span class="nc" id="L2002">                                bappend(ch, flag);</span>
                            } else {
<span class="nc" id="L2004">                                bappend(ch);</span>
                            }
<span class="nc" id="L2006">                            st = -1;</span>
<span class="nc" id="L2007">                            break;</span>

                        case 'a':
                            //          If the entity buffer is empty and ch == 'x'
<span class="nc bnc" id="L2011" title="All 4 branches missed.">                            if ((mBuffIdx == idx) &amp;&amp; (ch == 'x')) {</span>
<span class="nc" id="L2012">                                st = 3;</span>
<span class="nc" id="L2013">                                break;</span>
                            }
                        default:
<span class="nc" id="L2016">                            panic(FAULT);</span>
                    }
<span class="nc" id="L2018">                    break;</span>

                case 3:     // read hex character entity
<span class="nc bnc" id="L2021" title="All 3 branches missed.">                    switch (chtyp(ch)) {</span>
                        case 'A':
                        case 'a':
                        case 'd':
<span class="nc" id="L2025">                            bappend(ch);</span>
<span class="nc" id="L2026">                            break;</span>

                        case ';':
                            //          Convert the character entity to a character
                            try {
<span class="nc" id="L2031">                                int i = Integer.parseInt(</span>
                                        new String(mBuff, idx + 1, mBuffIdx - idx), 16);
<span class="nc bnc" id="L2033" title="All 2 branches missed.">                                if (i &gt;= 0xffff) {</span>
<span class="nc" id="L2034">                                    panic(FAULT);</span>
                                }
<span class="nc" id="L2036">                                ch = (char) i;</span>
<span class="nc" id="L2037">                            } catch (NumberFormatException nfe) {</span>
<span class="nc" id="L2038">                                panic(FAULT);</span>
<span class="nc" id="L2039">                            }</span>
                            //          Restore the buffer offset
<span class="nc" id="L2041">                            mBuffIdx = idx - 1;</span>
<span class="nc bnc" id="L2042" title="All 4 branches missed.">                            if (ch == ' ' || mInp.next != null) {</span>
<span class="nc" id="L2043">                                bappend(ch, flag);</span>
                            } else {
<span class="nc" id="L2045">                                bappend(ch);</span>
                            }
<span class="nc" id="L2047">                            st = -1;</span>
<span class="nc" id="L2048">                            break;</span>

                        default:
<span class="nc" id="L2051">                            panic(FAULT);</span>
                    }
<span class="nc" id="L2053">                    break;</span>

                default:
<span class="nc" id="L2056">                    panic(FAULT);</span>
            }
        }

<span class="fc" id="L2060">        return str;</span>
    }

    /**
     * Resoves a parameter entity.
     *
     * This method resolves a parameter entity references. It is also reports
     * external entities to the application.
     *
     * @param flag The '-' instruct the method to do not set up surrounding
     * spaces [#4.4.8].
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void pent(char flag) throws Exception {
        char ch;
<span class="nc" id="L2077">        int idx = mBuffIdx + 1;</span>
<span class="nc" id="L2078">        Input inp = null;</span>
<span class="nc" id="L2079">        String str = null;</span>
<span class="nc" id="L2080">        bappend('%');</span>
<span class="nc bnc" id="L2081" title="All 2 branches missed.">        if (mPh != PH_DTD) // the DTD internal subset</span>
        {
<span class="nc" id="L2083">            return;         // Not Recognized [#4.4.1]</span>
        }               //              Read entity name
<span class="nc" id="L2085">        bname(false);</span>
<span class="nc" id="L2086">        str = new String(mBuff, idx + 2, mBuffIdx - idx - 1);</span>
<span class="nc bnc" id="L2087" title="All 2 branches missed.">        if (getch() != ';') {</span>
<span class="nc" id="L2088">            panic(FAULT);</span>
        }
<span class="nc" id="L2090">        inp = mPEnt.get(str);</span>
        //              Restore the buffer offset
<span class="nc" id="L2092">        mBuffIdx = idx - 1;</span>
<span class="nc bnc" id="L2093" title="All 2 branches missed.">        if (inp != null) {</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">            if (inp.chars == null) {</span>
                //              External parameter entity
<span class="nc" id="L2096">                InputSource is = resolveEnt(str, inp.pubid, inp.sysid);</span>
<span class="nc bnc" id="L2097" title="All 2 branches missed.">                if (is != null) {</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">                    if (flag != '-') {</span>
<span class="nc" id="L2099">                        bappend(' ');  // tail space</span>
                    }
<span class="nc" id="L2101">                    push(new Input(BUFFSIZE_READER));</span>
                    // BUG: there is no leading space! [#4.4.8]
<span class="nc" id="L2103">                    setinp(is);</span>
<span class="nc" id="L2104">                    mInp.pubid = inp.pubid;</span>
<span class="nc" id="L2105">                    mInp.sysid = inp.sysid;</span>
                } else {
                    //          Unresolved external parameter entity
<span class="nc" id="L2108">                    skippedEnt(&quot;%&quot; + str);</span>
                }
<span class="nc" id="L2110">            } else {</span>
                //              Internal parameter entity
<span class="nc bnc" id="L2112" title="All 2 branches missed.">                if (flag == '-') {</span>
                    //          No surrounding spaces
<span class="nc" id="L2114">                    inp.chIdx = 1;</span>
                } else {
                    //          Insert surrounding spaces
<span class="nc" id="L2117">                    bappend(' ');  // tail space</span>
<span class="nc" id="L2118">                    inp.chIdx = 0;</span>
                }
<span class="nc" id="L2120">                push(inp);</span>
            }
        } else {
            //          Unknown parameter entity
<span class="nc" id="L2124">            skippedEnt(&quot;%&quot; + str);</span>
        }
<span class="nc" id="L2126">    }</span>

    /**
     * Recognizes and handles a namespace declaration.
     *
     * This method identifies a type of namespace declaration if any and puts
     * new mapping on top of prefix stack.
     *
     * @param name The attribute qualified name (&lt;code&gt;name.value&lt;/code&gt; is a
     * &lt;code&gt;String&lt;/code&gt; object which represents the attribute prefix).
     * @param value The attribute value.
     * @return &lt;code&gt;true&lt;/code&gt; if a namespace declaration is recognized.
     */
    private boolean isdecl(Pair name, String value) {
<span class="nc bnc" id="L2140" title="All 2 branches missed.">        if (name.chars[0] == 0) {</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">            if (&quot;xmlns&quot;.equals(name.name) == true) {</span>
                //              New default namespace declaration
<span class="nc" id="L2143">                mPref = pair(mPref);</span>
<span class="nc" id="L2144">                mPref.list = mElm;  // prefix owner element</span>
<span class="nc" id="L2145">                mPref.value = value;</span>
<span class="nc" id="L2146">                mPref.name = &quot;&quot;;</span>
<span class="nc" id="L2147">                mPref.chars = NONS;</span>
<span class="nc" id="L2148">                mElm.num++;  // namespace counter</span>
<span class="nc" id="L2149">                return true;</span>
            }
        } else {
<span class="nc bnc" id="L2152" title="All 2 branches missed.">            if (name.eqpref(XMLNS) == true) {</span>
                //              New prefix declaration
<span class="nc" id="L2154">                int len = name.name.length();</span>
<span class="nc" id="L2155">                mPref = pair(mPref);</span>
<span class="nc" id="L2156">                mPref.list = mElm;  // prefix owner element</span>
<span class="nc" id="L2157">                mPref.value = value;</span>
<span class="nc" id="L2158">                mPref.name = name.name;</span>
<span class="nc" id="L2159">                mPref.chars = new char[len + 1];</span>
<span class="nc" id="L2160">                mPref.chars[0] = (char) (len + 1);</span>
<span class="nc" id="L2161">                name.name.getChars(0, len, mPref.chars, 1);</span>
<span class="nc" id="L2162">                mElm.num++;  // namespace counter</span>
<span class="nc" id="L2163">                return true;</span>
            }
        }
<span class="nc" id="L2166">        return false;</span>
    }

    /**
     * Resolves a prefix.
     *
     * @return The namespace assigned to the prefix.
     * @exception Exception When mapping for specified prefix is not found.
     */
    private String rslv(char[] qname)
            throws Exception {
<span class="nc bnc" id="L2177" title="All 2 branches missed.">        for (Pair pref = mPref; pref != null; pref = pref.next) {</span>
<span class="nc bnc" id="L2178" title="All 2 branches missed.">            if (pref.eqpref(qname) == true) {</span>
<span class="nc" id="L2179">                return pref.value;</span>
            }
        }
<span class="nc bnc" id="L2182" title="All 2 branches missed.">        if (qname[0] == 1) {  // QNames like ':local'</span>
<span class="nc bnc" id="L2183" title="All 2 branches missed.">            for (Pair pref = mPref; pref != null; pref = pref.next) {</span>
<span class="nc bnc" id="L2184" title="All 2 branches missed.">                if (pref.chars[0] == 0) {</span>
<span class="nc" id="L2185">                    return pref.value;</span>
                }
            }
        }
<span class="nc" id="L2189">        panic(FAULT);</span>
<span class="nc" id="L2190">        return null;</span>
    }

    /**
     * Skips xml white space characters.
     *
     * This method skips white space characters (' ', '\t', '\n', '\r') and
     * looks ahead not white space character.
     *
     * @return The first not white space look ahead character.
     * @exception IOException
     */
    protected char wsskip()
            throws IOException {
        char ch;
        while (true) {
            //          Read next character
<span class="fc bfc" id="L2207" title="All 2 branches covered.">            ch = (mChIdx &lt; mChLen) ? mChars[mChIdx++] : getch();</span>
<span class="fc bfc" id="L2208" title="All 2 branches covered.">            if (ch &lt; 0x80) {</span>
<span class="fc bfc" id="L2209" title="All 2 branches covered.">                if (nmttyp[ch] != 3) // [ \t\n\r]</span>
                {
<span class="fc" id="L2211">                    break;</span>
                }
            } else {
                break;
            }
        }
<span class="fc" id="L2217">        mChIdx--;  // bkch();</span>
<span class="fc" id="L2218">        return ch;</span>
    }

    /**
     * Reports document type.
     *
     * @param name The name of the entity.
     * @param pubid The public identifier of the entity or &lt;code&gt;null&lt;/code&gt;.
     * @param sysid The system identifier of the entity or &lt;code&gt;null&lt;/code&gt;.
     */
    protected abstract void docType(String name, String pubid, String sysid)
            throws SAXException;

    /**
     * Reports a comment.
     *
     * @param text The comment text starting from first charcater.
     * @param length The number of characters in comment.
     */
    protected abstract void comm(char[] text, int length);

    /**
     * Reports a processing instruction.
     *
     * @param target The processing instruction target name.
     * @param body The processing instruction body text.
     */
    protected abstract void pi(String target, String body)
            throws Exception;

    /**
     * Reports new namespace prefix. The Namespace prefix (
     * &lt;code&gt;mPref.name&lt;/code&gt;) being declared and the Namespace URI (
     * &lt;code&gt;mPref.value&lt;/code&gt;) the prefix is mapped to. An empty string is
     * used for the default element namespace, which has no prefix.
     */
    protected abstract void newPrefix()
            throws Exception;

    /**
     * Reports skipped entity name.
     *
     * @param name The entity name.
     */
    protected abstract void skippedEnt(String name)
            throws Exception;

    /**
     * Returns an
     * &lt;code&gt;InputSource&lt;/code&gt; for specified entity or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @param name The name of the entity.
     * @param pubid The public identifier of the entity.
     * @param sysid The system identifier of the entity.
     */
    protected abstract InputSource resolveEnt(
            String name, String pubid, String sysid)
            throws Exception;

    /**
     * Reports notation declaration.
     *
     * @param name The notation's name.
     * @param pubid The notation's public identifier, or null if none was given.
     * @param sysid The notation's system identifier, or null if none was given.
     */
    protected abstract void notDecl(String name, String pubid, String sysid)
            throws Exception;

    /**
     * Reports unparsed entity name.
     *
     * @param name The unparsed entity's name.
     * @param pubid The entity's public identifier, or null if none was given.
     * @param sysid The entity's system identifier.
     * @param notation The name of the associated notation.
     */
    protected abstract void unparsedEntDecl(
            String name, String pubid, String sysid, String notation)
            throws Exception;

    /**
     * Notifies the handler about fatal parsing error.
     *
     * @param msg The problem description message.
     */
    protected abstract void panic(String msg)
            throws Exception;

    /**
     * Reads a qualified xml name.
     *
     * This is low level routine which leaves a qName in the buffer. The
     * characters of a qualified name is an array of characters. The first
     * (chars[0]) character is the index of the colon character which separates
     * the prefix from the local name. If the index is zero, the name does not
     * contain separator or the parser works in the namespace unaware mode. The
     * length of qualified name is the length of the array minus one.
     *
     * @param ns The true value turns namespace conformance on.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private void bname(boolean ns)
            throws Exception {
        char ch;
        char type;
<span class="fc" id="L2326">        mBuffIdx++;  // allocate a char for colon offset</span>
<span class="fc" id="L2327">        int bqname = mBuffIdx;</span>
<span class="fc" id="L2328">        int bcolon = bqname;</span>
<span class="fc" id="L2329">        int bchidx = bqname + 1;</span>
<span class="fc" id="L2330">        int bstart = bchidx;</span>
<span class="fc" id="L2331">        int cstart = mChIdx;</span>
<span class="pc bpc" id="L2332" title="1 of 2 branches missed.">        short st = (short) ((ns == true) ? 0 : 2);</span>
        while (true) {
            //          Read next character
<span class="fc bfc" id="L2335" title="All 2 branches covered.">            if (mChIdx &gt;= mChLen) {</span>
<span class="fc" id="L2336">                bcopy(cstart, bstart);</span>
<span class="fc" id="L2337">                getch();</span>
<span class="fc" id="L2338">                mChIdx--;  // bkch();</span>
<span class="fc" id="L2339">                cstart = mChIdx;</span>
<span class="fc" id="L2340">                bstart = bchidx;</span>
            }
<span class="fc" id="L2342">            ch = mChars[mChIdx++];</span>
<span class="fc" id="L2343">            type = (char) 0;  // [X]</span>
<span class="pc bpc" id="L2344" title="1 of 2 branches missed.">            if (ch &lt; 0x80) {</span>
<span class="fc" id="L2345">                type = (char) nmttyp[ch];</span>
<span class="nc bnc" id="L2346" title="All 2 branches missed.">            } else if (ch == EOS) {</span>
<span class="nc" id="L2347">                panic(FAULT);</span>
            }
            //          Parse QName
<span class="pc bpc" id="L2350" title="1 of 3 branches missed.">            switch (st) {</span>
                case 0:     // read the first char of the prefix
                case 2:     // read the first char of the suffix
<span class="pc bpc" id="L2353" title="2 of 3 branches missed.">                    switch (type) {</span>
                        case 0:  // [aA_X]
<span class="fc" id="L2355">                            bchidx++;  // append char to the buffer</span>
<span class="fc" id="L2356">                            st++;      // (st == 0)? 1: 3;</span>
<span class="fc" id="L2357">                            break;</span>

                        case 1:  // [:]
<span class="nc" id="L2360">                            mChIdx--;  // bkch();</span>
<span class="nc" id="L2361">                            st++;      // (st == 0)? 1: 3;</span>
<span class="nc" id="L2362">                            break;</span>

                        default:
<span class="nc" id="L2365">                            panic(FAULT);</span>
                    }
<span class="nc" id="L2367">                    break;</span>

                case 1:     // read the prefix
                case 3:     // read the suffix
<span class="fc bfc" id="L2371" title="All 3 branches covered.">                    switch (type) {</span>
                        case 0:  // [aA_X]
                        case 2:  // [.-d]
<span class="fc" id="L2374">                            bchidx++;  // append char to the buffer</span>
<span class="fc" id="L2375">                            break;</span>

                        case 1:  // [:]
<span class="fc" id="L2378">                            bchidx++;  // append char to the buffer</span>
<span class="pc bpc" id="L2379" title="1 of 2 branches missed.">                            if (ns == true) {</span>
<span class="nc bnc" id="L2380" title="All 2 branches missed.">                                if (bcolon != bqname) {</span>
<span class="nc" id="L2381">                                    panic(FAULT);  // it must be only one colon</span>
                                }
<span class="nc" id="L2383">                                bcolon = bchidx - 1;</span>
<span class="nc bnc" id="L2384" title="All 2 branches missed.">                                if (st == 1) {</span>
<span class="nc" id="L2385">                                    st = 2;</span>
                                }
                            }
                            break;

                        default:
<span class="fc" id="L2391">                            mChIdx--;  // bkch();</span>
<span class="fc" id="L2392">                            bcopy(cstart, bstart);</span>
<span class="fc" id="L2393">                            mBuff[bqname] = (char) (bcolon - bqname);</span>
<span class="fc" id="L2394">                            return;</span>
                    }
                    break;

                default:
<span class="nc" id="L2399">                    panic(FAULT);</span>
            }
        }
    }

    /**
     * Reads a nmtoken.
     *
     * This is low level routine which leaves a nmtoken in the buffer.
     *
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void bntok() throws Exception {
        char ch;
<span class="fc" id="L2415">        mBuffIdx = -1;</span>
<span class="fc" id="L2416">        bappend((char) 0);  // default offset to the colon char</span>
        while (true) {
<span class="fc" id="L2418">            ch = getch();</span>
<span class="pc bpc" id="L2419" title="1 of 3 branches missed.">            switch (chtyp(ch)) {</span>
                case 'a':
                case 'A':
                case 'd':
                case '.':
                case ':':
                case '-':
                case '_':
                case 'X':
<span class="fc" id="L2428">                    bappend(ch);</span>
<span class="fc" id="L2429">                    break;</span>

                case 'Z':
<span class="nc" id="L2432">                    panic(FAULT);</span>

                default:
<span class="fc" id="L2435">                    bkch();</span>
<span class="fc" id="L2436">                    return;</span>
            }
        }
    }

    /**
     * Recognizes a keyword.
     *
     * This is low level routine which recognizes one of keywords in the buffer.
     * Keyword Id ID - i IDREF - r IDREFS - R ENTITY - n ENTITIES - N NMTOKEN -
     * t NMTOKENS - T ELEMENT - e ATTLIST - a NOTATION - o CDATA - c REQUIRED -
     * Q IMPLIED - I FIXED - F
     *
     * @return an id of a keyword or '?'.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private char bkeyword()
            throws Exception {
<span class="fc" id="L2455">        String str = new String(mBuff, 1, mBuffIdx);</span>
<span class="pc bpc" id="L2456" title="2 of 6 branches missed.">        switch (str.length()) {</span>
            case 2:  // ID
<span class="nc bnc" id="L2458" title="All 2 branches missed.">                return (&quot;ID&quot;.equals(str) == true) ? 'i' : '?';</span>

            case 5:  // IDREF, CDATA, FIXED
<span class="pc bpc" id="L2461" title="2 of 4 branches missed.">                switch (mBuff[1]) {</span>
                    case 'I':
<span class="nc bnc" id="L2463" title="All 2 branches missed.">                        return (&quot;IDREF&quot;.equals(str) == true) ? 'r' : '?';</span>
                    case 'C':
<span class="pc bpc" id="L2465" title="1 of 2 branches missed.">                        return (&quot;CDATA&quot;.equals(str) == true) ? 'c' : '?';</span>
                    case 'F':
<span class="pc bpc" id="L2467" title="1 of 2 branches missed.">                        return (&quot;FIXED&quot;.equals(str) == true) ? 'F' : '?';</span>
                    default:
<span class="nc" id="L2469">                        break;</span>
                }
                break;

            case 6:  // IDREFS, ENTITY
<span class="pc bpc" id="L2474" title="2 of 3 branches missed.">                switch (mBuff[1]) {</span>
                    case 'I':
<span class="nc bnc" id="L2476" title="All 2 branches missed.">                        return (&quot;IDREFS&quot;.equals(str) == true) ? 'R' : '?';</span>
                    case 'E':
<span class="pc bpc" id="L2478" title="1 of 2 branches missed.">                        return (&quot;ENTITY&quot;.equals(str) == true) ? 'n' : '?';</span>
                    default:
<span class="nc" id="L2480">                        break;</span>
                }
                break;

            case 7:  // NMTOKEN, IMPLIED, ATTLIST, ELEMENT
<span class="pc bpc" id="L2485" title="3 of 5 branches missed.">                switch (mBuff[1]) {</span>
                    case 'I':
<span class="nc bnc" id="L2487" title="All 2 branches missed.">                        return (&quot;IMPLIED&quot;.equals(str) == true) ? 'I' : '?';</span>
                    case 'N':
<span class="nc bnc" id="L2489" title="All 2 branches missed.">                        return (&quot;NMTOKEN&quot;.equals(str) == true) ? 't' : '?';</span>
                    case 'A':
<span class="pc bpc" id="L2491" title="1 of 2 branches missed.">                        return (&quot;ATTLIST&quot;.equals(str) == true) ? 'a' : '?';</span>
                    case 'E':
<span class="pc bpc" id="L2493" title="1 of 2 branches missed.">                        return (&quot;ELEMENT&quot;.equals(str) == true) ? 'e' : '?';</span>
                    default:
<span class="nc" id="L2495">                        break;</span>
                }
                break;

            case 8:  // ENTITIES, NMTOKENS, NOTATION, REQUIRED
<span class="pc bpc" id="L2500" title="4 of 5 branches missed.">                switch (mBuff[2]) {</span>
                    case 'N':
<span class="nc bnc" id="L2502" title="All 2 branches missed.">                        return (&quot;ENTITIES&quot;.equals(str) == true) ? 'N' : '?';</span>
                    case 'M':
<span class="nc bnc" id="L2504" title="All 2 branches missed.">                        return (&quot;NMTOKENS&quot;.equals(str) == true) ? 'T' : '?';</span>
                    case 'O':
<span class="nc bnc" id="L2506" title="All 2 branches missed.">                        return (&quot;NOTATION&quot;.equals(str) == true) ? 'o' : '?';</span>
                    case 'E':
<span class="pc bpc" id="L2508" title="1 of 2 branches missed.">                        return (&quot;REQUIRED&quot;.equals(str) == true) ? 'Q' : '?';</span>
                    default:
<span class="nc" id="L2510">                        break;</span>
                }
                break;

            default:
                break;
        }
<span class="nc" id="L2517">        return '?';</span>
    }

    /**
     * Reads a single or double quotted string in to the buffer.
     *
     * This method resolves entities inside a string unless the parser parses
     * DTD.
     *
     * @param flag 'c' - CDATA, 'i' - non CDATA, ' ' - no normalization; '-' -
     * not an attribute value; 'd' - in DTD context.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void bqstr(char flag) throws Exception {
<span class="fc" id="L2533">        Input inp = mInp;  // remember the original input</span>
<span class="fc" id="L2534">        mBuffIdx = -1;</span>
<span class="fc" id="L2535">        bappend((char) 0);  // default offset to the colon char</span>
        char ch;
<span class="fc bfc" id="L2537" title="All 2 branches covered.">        for (short st = 0; st &gt;= 0;) {</span>
<span class="pc bpc" id="L2538" title="1 of 2 branches missed.">            ch = (mChIdx &lt; mChLen) ? mChars[mChIdx++] : getch();</span>
<span class="pc bpc" id="L2539" title="1 of 3 branches missed.">            switch (st) {</span>
                case 0:     // read a single or double quote
<span class="pc bpc" id="L2541" title="1 of 4 branches missed.">                    switch (ch) {</span>
                        case ' ':
                        case '\n':
                        case '\r':
                        case '\t':
<span class="fc" id="L2546">                            break;</span>

                        case '\'':
<span class="fc" id="L2549">                            st = 2;  // read a single quoted string</span>
<span class="fc" id="L2550">                            break;</span>

                        case '\&quot;':
<span class="fc" id="L2553">                            st = 3;  // read a double quoted string</span>
<span class="fc" id="L2554">                            break;</span>

                        default:
<span class="nc" id="L2557">                            panic(FAULT);</span>
<span class="nc" id="L2558">                            break;</span>
                    }
                    break;

                case 2:     // read a single quoted string
                case 3:     // read a double quoted string
<span class="pc bpc" id="L2564" title="5 of 8 branches missed.">                    switch (ch) {</span>
                        case '\'':
<span class="pc bpc" id="L2566" title="2 of 4 branches missed.">                            if ((st == 2) &amp;&amp; (mInp == inp)) {</span>
<span class="fc" id="L2567">                                st = -1;</span>
                            } else {
<span class="nc" id="L2569">                                bappend(ch);</span>
                            }
<span class="nc" id="L2571">                            break;</span>

                        case '\&quot;':
<span class="pc bpc" id="L2574" title="2 of 4 branches missed.">                            if ((st == 3) &amp;&amp; (mInp == inp)) {</span>
<span class="fc" id="L2575">                                st = -1;</span>
                            } else {
<span class="nc" id="L2577">                                bappend(ch);</span>
                            }
<span class="nc" id="L2579">                            break;</span>

                        case '&amp;':
<span class="nc bnc" id="L2582" title="All 2 branches missed.">                            if (flag != 'd') {</span>
<span class="nc" id="L2583">                                ent(flag);</span>
                            } else {
<span class="nc" id="L2585">                                bappend(ch);</span>
                            }
<span class="nc" id="L2587">                            break;</span>

                        case '%':
<span class="nc bnc" id="L2590" title="All 2 branches missed.">                            if (flag == 'd') {</span>
<span class="nc" id="L2591">                                pent('-');</span>
                            } else {
<span class="nc" id="L2593">                                bappend(ch);</span>
                            }
<span class="nc" id="L2595">                            break;</span>

                        case '&lt;':
<span class="nc bnc" id="L2598" title="All 4 branches missed.">                            if ((flag == '-') || (flag == 'd')) {</span>
<span class="nc" id="L2599">                                bappend(ch);</span>
                            } else {
<span class="nc" id="L2601">                                panic(FAULT);</span>
                            }
<span class="nc" id="L2603">                            break;</span>

                        case EOS:               // EOS before single/double quote
<span class="nc" id="L2606">                            panic(FAULT);</span>

                        case '\r':     // EOL processing [#2.11 &amp; #3.3.3]
<span class="nc bnc" id="L2609" title="All 4 branches missed.">                            if (flag != ' ' &amp;&amp; mInp.next == null) {</span>
<span class="nc bnc" id="L2610" title="All 2 branches missed.">                                if (getch() != '\n') {</span>
<span class="nc" id="L2611">                                    bkch();</span>
                                }
<span class="nc" id="L2613">                                ch = '\n';</span>
                            }
                        default:
<span class="fc" id="L2616">                            bappend(ch, flag);</span>
<span class="fc" id="L2617">                            break;</span>
                    }
                    break;

                default:
<span class="nc" id="L2622">                    panic(FAULT);</span>
            }
        }
        //              There is maximum one space at the end of the string in
        //              i-mode (non CDATA normalization) and it has to be removed.
<span class="pc bpc" id="L2627" title="3 of 4 branches missed.">        if ((flag == 'i') &amp;&amp; (mBuff[mBuffIdx] == ' ')) {</span>
<span class="nc" id="L2628">            mBuffIdx -= 1;</span>
        }
<span class="fc" id="L2630">    }</span>

    /**
     * Reports characters and empties the parser's buffer. This method is called
     * only if parser is going to return control to the main loop. This means
     * that this method may use parser buffer to report white space without
     * copeing characters to temporary buffer.
     */
    protected abstract void bflash()
            throws Exception;

    /**
     * Reports white space characters and empties the parser's buffer. This
     * method is called only if parser is going to return control to the main
     * loop. This means that this method may use parser buffer to report white
     * space without copeing characters to temporary buffer.
     */
    protected abstract void bflash_ws()
            throws Exception;

    /**
     * Appends a character to parser's buffer with normalization.
     *
     * @param ch The character to append to the buffer.
     * @param mode The normalization mode.
     */
    private void bappend(char ch, char mode) {
        //              This implements attribute value normalization as
        //              described in the XML specification [#3.3.3].
<span class="pc bpc" id="L2659" title="1 of 3 branches missed.">        switch (mode) {</span>
            case 'i':  // non CDATA normalization
<span class="nc bnc" id="L2661" title="All 2 branches missed.">                switch (ch) {</span>
                    case ' ':
                    case '\n':
                    case '\r':
                    case '\t':
<span class="nc bnc" id="L2666" title="All 4 branches missed.">                        if ((mBuffIdx &gt; 0) &amp;&amp; (mBuff[mBuffIdx] != ' ')) {</span>
<span class="nc" id="L2667">                            bappend(' ');</span>
                        }
<span class="nc" id="L2669">                        return;</span>

                    default:
<span class="nc" id="L2672">                        break;</span>
                }
                break;

            case 'c':  // CDATA normalization
<span class="pc bpc" id="L2677" title="1 of 2 branches missed.">                switch (ch) {</span>
                    case '\n':
                    case '\r':
                    case '\t':
<span class="nc" id="L2681">                        ch = ' ';</span>
<span class="nc" id="L2682">                        break;</span>

                    default:
<span class="fc" id="L2685">                        break;</span>
                }
                break;

            default:  // no normalization
                break;
        }
<span class="fc" id="L2692">        mBuffIdx++;</span>
<span class="pc bpc" id="L2693" title="1 of 2 branches missed.">        if (mBuffIdx &lt; mBuff.length) {</span>
<span class="fc" id="L2694">            mBuff[mBuffIdx] = ch;</span>
        } else {
<span class="nc" id="L2696">            mBuffIdx--;</span>
<span class="nc" id="L2697">            bappend(ch);</span>
        }
<span class="fc" id="L2699">    }</span>

    /**
     * Appends a character to parser's buffer.
     *
     * @param ch The character to append to the buffer.
     */
    private void bappend(char ch) {
        try {
<span class="fc" id="L2708">            mBuff[++mBuffIdx] = ch;</span>
<span class="fc" id="L2709">        } catch (Exception exp) {</span>
            //          Double the buffer size
<span class="fc" id="L2711">            char buff[] = new char[mBuff.length &lt;&lt; 1];</span>
<span class="fc" id="L2712">            System.arraycopy(mBuff, 0, buff, 0, mBuff.length);</span>
<span class="fc" id="L2713">            mBuff = buff;</span>
<span class="fc" id="L2714">            mBuff[mBuffIdx] = ch;</span>
<span class="fc" id="L2715">        }</span>
<span class="fc" id="L2716">    }</span>

    /**
     * Appends (mChIdx - cidx) characters from character buffer (mChars) to
     * parser's buffer (mBuff).
     *
     * @param cidx The character buffer (mChars) start index.
     * @param bidx The parser buffer (mBuff) start index.
     */
    private void bcopy(int cidx, int bidx) {
<span class="fc" id="L2726">        int length = mChIdx - cidx;</span>
<span class="pc bpc" id="L2727" title="1 of 2 branches missed.">        if ((bidx + length + 1) &gt;= mBuff.length) {</span>
            //          Expand the buffer
<span class="nc" id="L2729">            char buff[] = new char[mBuff.length + length];</span>
<span class="nc" id="L2730">            System.arraycopy(mBuff, 0, buff, 0, mBuff.length);</span>
<span class="nc" id="L2731">            mBuff = buff;</span>
        }
<span class="fc" id="L2733">        System.arraycopy(mChars, cidx, mBuff, bidx, length);</span>
<span class="fc" id="L2734">        mBuffIdx += length;</span>
<span class="fc" id="L2735">    }</span>

    /**
     * Recognizes the built-in entities &lt;i&gt;lt&lt;/i&gt;, &lt;i&gt;gt&lt;/i&gt;, &lt;i&gt;amp&lt;/i&gt;,
     * &lt;i&gt;apos&lt;/i&gt;, &lt;i&gt;quot&lt;/i&gt;. The initial state is 0x100. Any state belowe
     * 0x100 is a built-in entity replacement character.
     *
     * @param ch the next character of an entity name.
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void eappend(char ch) {
<span class="pc bpc" id="L2746" title="8 of 12 branches missed.">        switch (mESt) {</span>
            case 0x100:  // &quot;l&quot; or &quot;g&quot; or &quot;a&quot; or &quot;q&quot;
<span class="pc bpc" id="L2748" title="2 of 5 branches missed.">                switch (ch) {</span>
                    case 'l':
<span class="fc" id="L2750">                        mESt = 0x101;</span>
<span class="fc" id="L2751">                        break;</span>
                    case 'g':
<span class="fc" id="L2753">                        mESt = 0x102;</span>
<span class="fc" id="L2754">                        break;</span>
                    case 'a':
<span class="nc" id="L2756">                        mESt = 0x103;</span>
<span class="nc" id="L2757">                        break;</span>
                    case 'q':
<span class="nc" id="L2759">                        mESt = 0x107;</span>
<span class="nc" id="L2760">                        break;</span>
                    default:
<span class="fc" id="L2762">                        mESt = 0x200;</span>
<span class="fc" id="L2763">                        break;</span>
                }
                break;

            case 0x101:  // &quot;lt&quot;
<span class="pc bpc" id="L2768" title="1 of 2 branches missed.">                mESt = (ch == 't') ? '&lt;' : (char) 0x200;</span>
<span class="fc" id="L2769">                break;</span>

            case 0x102:  // &quot;gt&quot;
<span class="pc bpc" id="L2772" title="1 of 2 branches missed.">                mESt = (ch == 't') ? '&gt;' : (char) 0x200;</span>
<span class="fc" id="L2773">                break;</span>

            case 0x103:  // &quot;am&quot; or &quot;ap&quot;
<span class="nc bnc" id="L2776" title="All 3 branches missed.">                switch (ch) {</span>
                    case 'm':
<span class="nc" id="L2778">                        mESt = 0x104;</span>
<span class="nc" id="L2779">                        break;</span>
                    case 'p':
<span class="nc" id="L2781">                        mESt = 0x105;</span>
<span class="nc" id="L2782">                        break;</span>
                    default:
<span class="nc" id="L2784">                        mESt = 0x200;</span>
<span class="nc" id="L2785">                        break;</span>
                }
                break;

            case 0x104:  // &quot;amp&quot;
<span class="nc bnc" id="L2790" title="All 2 branches missed.">                mESt = (ch == 'p') ? '&amp;' : (char) 0x200;</span>
<span class="nc" id="L2791">                break;</span>

            case 0x105:  // &quot;apo&quot;
<span class="nc bnc" id="L2794" title="All 2 branches missed.">                mESt = (ch == 'o') ? (char) 0x106 : (char) 0x200;</span>
<span class="nc" id="L2795">                break;</span>

            case 0x106:  // &quot;apos&quot;
<span class="nc bnc" id="L2798" title="All 2 branches missed.">                mESt = (ch == 's') ? '\'' : (char) 0x200;</span>
<span class="nc" id="L2799">                break;</span>

            case 0x107:  // &quot;qu&quot;
<span class="nc bnc" id="L2802" title="All 2 branches missed.">                mESt = (ch == 'u') ? (char) 0x108 : (char) 0x200;</span>
<span class="nc" id="L2803">                break;</span>

            case 0x108:  // &quot;quo&quot;
<span class="nc bnc" id="L2806" title="All 2 branches missed.">                mESt = (ch == 'o') ? (char) 0x109 : (char) 0x200;</span>
<span class="nc" id="L2807">                break;</span>

            case 0x109:  // &quot;quot&quot;
<span class="nc bnc" id="L2810" title="All 2 branches missed.">                mESt = (ch == 't') ? '\&quot;' : (char) 0x200;</span>
<span class="nc" id="L2811">                break;</span>

            case '&lt;':   // &quot;lt&quot;
            case '&gt;':   // &quot;gt&quot;
            case '&amp;':   // &quot;amp&quot;
            case '\'':  // &quot;apos&quot;
            case '\&quot;':  // &quot;quot&quot;
<span class="nc" id="L2818">                mESt = 0x200;</span>
            default:
                break;
        }
<span class="fc" id="L2822">    }</span>

    /**
     * Sets up a new input source on the top of the input stack. Note, the first
     * byte returned by the entity's byte stream has to be the first byte in the
     * entity. However, the parser does not expect the byte order mask in both
     * cases when encoding is provided by the input source.
     *
     * @param is A new input source to set up.
     * @exception IOException If any IO errors occur.
     * @exception Exception is parser specific exception form panic method.
     */
    protected void setinp(InputSource is)
            throws Exception {
<span class="fc" id="L2836">        Reader reader = null;</span>
<span class="fc" id="L2837">        mChIdx = 0;</span>
<span class="fc" id="L2838">        mChLen = 0;</span>
<span class="fc" id="L2839">        mChars = mInp.chars;</span>
<span class="fc" id="L2840">        mInp.src = null;</span>
<span class="fc bfc" id="L2841" title="All 2 branches covered.">        if (mPh &lt; PH_DOC_START) {</span>
<span class="fc" id="L2842">            mIsSAlone = false;  // default [#2.9]</span>
        }
<span class="fc" id="L2844">        mIsSAloneSet = false;</span>
<span class="fc bfc" id="L2845" title="All 2 branches covered.">        if (is.getCharacterStream() != null) {</span>
            //          Ignore encoding in the xml text decl.
<span class="fc" id="L2847">            reader = is.getCharacterStream();</span>
<span class="fc" id="L2848">            xml(reader);</span>
<span class="pc bpc" id="L2849" title="1 of 2 branches missed.">        } else if (is.getByteStream() != null) {</span>
            String expenc;
<span class="pc bpc" id="L2851" title="1 of 2 branches missed.">            if (is.getEncoding() != null) {</span>
                //              Ignore encoding in the xml text decl.
<span class="nc" id="L2853">                expenc = is.getEncoding().toUpperCase();</span>
<span class="nc bnc" id="L2854" title="All 2 branches missed.">                if (expenc.equals(&quot;UTF-16&quot;)) {</span>
<span class="nc" id="L2855">                    reader = bom(is.getByteStream(), 'U');  // UTF-16 [#4.3.3]</span>
                } else {
<span class="nc" id="L2857">                    reader = enc(expenc, is.getByteStream());</span>
                }
<span class="nc" id="L2859">                xml(reader);</span>
            } else {
                //              Get encoding from BOM or the xml text decl.
<span class="fc" id="L2862">                reader = bom(is.getByteStream(), ' ');</span>
<span class="fc bfc" id="L2863" title="All 2 branches covered.">                if (reader == null) {</span>
                    //          Encoding is defined by the xml text decl.
<span class="fc" id="L2865">                    reader = enc(&quot;UTF-8&quot;, is.getByteStream());</span>
<span class="fc" id="L2866">                    expenc = xml(reader);</span>
<span class="pc bpc" id="L2867" title="1 of 2 branches missed.">                    if (expenc.startsWith(&quot;UTF-16&quot;)) {</span>
<span class="nc" id="L2868">                        panic(FAULT);  // UTF-16 must have BOM [#4.3.3]</span>
                    }
<span class="fc" id="L2870">                    reader = enc(expenc, is.getByteStream());</span>
                } else {
                    //          Encoding is defined by the BOM.
<span class="fc" id="L2873">                    xml(reader);</span>
                }
            }
        } else {
            //          There is no support for public/system identifiers.
<span class="nc" id="L2878">            panic(FAULT);</span>
        }
<span class="fc" id="L2880">        mInp.src = reader;</span>
<span class="fc" id="L2881">        mInp.pubid = is.getPublicId();</span>
<span class="fc" id="L2882">        mInp.sysid = is.getSystemId();</span>
<span class="fc" id="L2883">    }</span>

    /**
     * Determines the entity encoding.
     *
     * This method gets encoding from Byte Order Mask [#4.3.3] if any. Note, the
     * first byte returned by the entity's byte stream has to be the first byte
     * in the entity. Also, there is no support for UCS-4.
     *
     * @param is A byte stream of the entity.
     * @param hint An encoding hint, character U means UTF-16.
     * @return a reader constructed from the BOM or UTF-8 by default.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private Reader bom(InputStream is, char hint)
            throws Exception {
<span class="fc" id="L2900">        int val = is.read();</span>
<span class="pc bpc" id="L2901" title="3 of 5 branches missed.">        switch (val) {</span>
            case 0xef:     // UTF-8
<span class="nc bnc" id="L2903" title="All 2 branches missed.">                if (hint == 'U') // must be UTF-16</span>
                {
<span class="nc" id="L2905">                    panic(FAULT);</span>
                }
<span class="nc bnc" id="L2907" title="All 2 branches missed.">                if (is.read() != 0xbb) {</span>
<span class="nc" id="L2908">                    panic(FAULT);</span>
                }
<span class="nc bnc" id="L2910" title="All 2 branches missed.">                if (is.read() != 0xbf) {</span>
<span class="nc" id="L2911">                    panic(FAULT);</span>
                }
<span class="nc" id="L2913">                return new ReaderUTF8(is);</span>

            case 0xfe:     // UTF-16, big-endian
<span class="pc bpc" id="L2916" title="1 of 2 branches missed.">                if (is.read() != 0xff) {</span>
<span class="nc" id="L2917">                    panic(FAULT);</span>
                }
<span class="fc" id="L2919">                return new ReaderUTF16(is, 'b');</span>

            case 0xff:     // UTF-16, little-endian
<span class="nc bnc" id="L2922" title="All 2 branches missed.">                if (is.read() != 0xfe) {</span>
<span class="nc" id="L2923">                    panic(FAULT);</span>
                }
<span class="nc" id="L2925">                return new ReaderUTF16(is, 'l');</span>

            case -1:
<span class="nc" id="L2928">                mChars[mChIdx++] = EOS;</span>
<span class="nc" id="L2929">                return new ReaderUTF8(is);</span>

            default:
<span class="pc bpc" id="L2932" title="1 of 2 branches missed.">                if (hint == 'U') // must be UTF-16</span>
                {
<span class="nc" id="L2934">                    panic(FAULT);</span>
                }
                //              Read the rest of UTF-8 character
<span class="pc bpc" id="L2937" title="3 of 4 branches missed.">                switch (val &amp; 0xf0) {</span>
                    case 0xc0:
                    case 0xd0:
<span class="nc" id="L2940">                        mChars[mChIdx++] = (char) (((val &amp; 0x1f) &lt;&lt; 6) | (is.read() &amp; 0x3f));</span>
<span class="nc" id="L2941">                        break;</span>

                    case 0xe0:
<span class="nc" id="L2944">                        mChars[mChIdx++] = (char) (((val &amp; 0x0f) &lt;&lt; 12)</span>
<span class="nc" id="L2945">                                | ((is.read() &amp; 0x3f) &lt;&lt; 6) | (is.read() &amp; 0x3f));</span>
<span class="nc" id="L2946">                        break;</span>

                    case 0xf0:  // UCS-4 character
<span class="nc" id="L2949">                        throw new UnsupportedEncodingException();</span>

                    default:
<span class="fc" id="L2952">                        mChars[mChIdx++] = (char) val;</span>
                        break;
                }
<span class="fc" id="L2955">                return null;</span>
        }
    }

    /**
     * Parses the xml text declaration.
     *
     * This method gets encoding from the xml text declaration [#4.3.1] if any.
     * The method assumes the buffer (mChars) is big enough to accommodate whole
     * xml text declaration.
     *
     * @param reader is entity reader.
     * @return The xml text declaration encoding or default UTF-8 encoding.
     * @exception Exception is parser specific exception form panic method.
     * @exception IOException
     */
    private String xml(Reader reader)
            throws Exception {
<span class="fc" id="L2973">        String str = null;</span>
<span class="fc" id="L2974">        String enc = &quot;UTF-8&quot;;</span>
        char ch;
        int val;
        short st;
        //              Read the xml text declaration into the buffer
<span class="fc bfc" id="L2979" title="All 2 branches covered.">        if (mChIdx != 0) {</span>
            //          The bom method have read ONE char into the buffer.
<span class="pc bpc" id="L2981" title="1 of 2 branches missed.">            st = (short) ((mChars[0] == '&lt;') ? 1 : -1);</span>
        } else {
<span class="fc" id="L2983">            st = 0;</span>
        }
<span class="pc bpc" id="L2985" title="1 of 4 branches missed.">        while (st &gt;= 0 &amp;&amp; mChIdx &lt; mChars.length) {</span>
<span class="pc bpc" id="L2986" title="1 of 2 branches missed.">            ch = ((val = reader.read()) &gt;= 0) ? (char) val : EOS;</span>
<span class="fc" id="L2987">            mChars[mChIdx++] = ch;</span>
<span class="pc bpc" id="L2988" title="1 of 9 branches missed.">            switch (st) {</span>
                case 0:     // read '&lt;' of xml declaration
<span class="pc bpc" id="L2990" title="2 of 3 branches missed.">                    switch (ch) {</span>
                        case '&lt;':
<span class="fc" id="L2992">                            st = 1;</span>
<span class="fc" id="L2993">                            break;</span>

                        case 0xfeff:    // the byte order mask
<span class="nc bnc" id="L2996" title="All 2 branches missed.">                            ch = ((val = reader.read()) &gt;= 0) ? (char) val : EOS;</span>
<span class="nc" id="L2997">                            mChars[mChIdx - 1] = ch;</span>
<span class="nc bnc" id="L2998" title="All 2 branches missed.">                            st = (short) ((ch == '&lt;') ? 1 : -1);</span>
<span class="nc" id="L2999">                            break;</span>

                        default:
<span class="nc" id="L3002">                            st = -1;</span>
<span class="nc" id="L3003">                            break;</span>
                    }
                    break;

                case 1:     // read '?' of xml declaration [#4.3.1]
<span class="pc bpc" id="L3008" title="1 of 2 branches missed.">                    st = (short) ((ch == '?') ? 2 : -1);</span>
<span class="fc" id="L3009">                    break;</span>

                case 2:     // read 'x' of xml declaration [#4.3.1]
<span class="pc bpc" id="L3012" title="1 of 2 branches missed.">                    st = (short) ((ch == 'x') ? 3 : -1);</span>
<span class="fc" id="L3013">                    break;</span>

                case 3:     // read 'm' of xml declaration [#4.3.1]
<span class="pc bpc" id="L3016" title="1 of 2 branches missed.">                    st = (short) ((ch == 'm') ? 4 : -1);</span>
<span class="fc" id="L3017">                    break;</span>

                case 4:     // read 'l' of xml declaration [#4.3.1]
<span class="pc bpc" id="L3020" title="1 of 2 branches missed.">                    st = (short) ((ch == 'l') ? 5 : -1);</span>
<span class="fc" id="L3021">                    break;</span>

                case 5:     // read white space after 'xml'
<span class="pc bpc" id="L3024" title="1 of 2 branches missed.">                    switch (ch) {</span>
                        case ' ':
                        case '\t':
                        case '\r':
                        case '\n':
<span class="fc" id="L3029">                            st = 6;</span>
<span class="fc" id="L3030">                            break;</span>

                        default:
<span class="nc" id="L3033">                            st = -1;</span>
<span class="nc" id="L3034">                            break;</span>
                    }
                    break;

                case 6:     // read content of xml declaration
<span class="pc bpc" id="L3039" title="1 of 3 branches missed.">                    switch (ch) {</span>
                        case '?':
<span class="fc" id="L3041">                            st = 7;</span>
<span class="fc" id="L3042">                            break;</span>

                        case EOS:
<span class="nc" id="L3045">                            st = -2;</span>
<span class="nc" id="L3046">                            break;</span>

                        default:
<span class="fc" id="L3049">                            break;</span>
                    }
                    break;

                case 7:     // read '&gt;' after '?' of xml declaration
<span class="pc bpc" id="L3054" title="1 of 2 branches missed.">                    switch (ch) {</span>
                        case '&gt;':
                        case EOS:
<span class="fc" id="L3057">                            st = -2;</span>
<span class="fc" id="L3058">                            break;</span>

                        default:
<span class="nc" id="L3061">                            st = 6;</span>
<span class="nc" id="L3062">                            break;</span>
                    }
                    break;

                default:
<span class="nc" id="L3067">                    panic(FAULT);</span>
<span class="nc" id="L3068">                    break;</span>
            }
        }
<span class="fc" id="L3071">        mChLen = mChIdx;</span>
<span class="fc" id="L3072">        mChIdx = 0;</span>
        //              If there is no xml text declaration, the encoding is default.
<span class="pc bpc" id="L3074" title="1 of 2 branches missed.">        if (st == -1) {</span>
<span class="nc" id="L3075">            return enc;</span>
        }
<span class="fc" id="L3077">        mChIdx = 5;  // the first white space after &quot;&lt;?xml&quot;</span>
        //              Parse the xml text declaration
<span class="fc bfc" id="L3079" title="All 2 branches covered.">        for (st = 0; st &gt;= 0;) {</span>
<span class="fc" id="L3080">            ch = getch();</span>
<span class="pc bpc" id="L3081" title="1 of 4 branches missed.">            switch (st) {</span>
                case 0:     // skip spaces after the xml declaration name
<span class="fc bfc" id="L3083" title="All 2 branches covered.">                    if (chtyp(ch) != ' ') {</span>
<span class="fc" id="L3084">                        bkch();</span>
<span class="fc" id="L3085">                        st = 1;</span>
                    }
                    break;

                case 1:     // read xml declaration version
                case 2:     // read xml declaration encoding or standalone
                case 3:     // read xml declaration standalone
<span class="pc bpc" id="L3092" title="1 of 4 branches missed.">                    switch (chtyp(ch)) {</span>
                        case 'a':
                        case 'A':
                        case '_':
<span class="fc" id="L3096">                            bkch();</span>
<span class="fc" id="L3097">                            str = name(false).toLowerCase();</span>
<span class="fc bfc" id="L3098" title="All 2 branches covered.">                            if (&quot;version&quot;.equals(str) == true) {</span>
<span class="pc bpc" id="L3099" title="1 of 2 branches missed.">                                if (st != 1) {</span>
<span class="nc" id="L3100">                                    panic(FAULT);</span>
                                }
<span class="pc bpc" id="L3102" title="1 of 2 branches missed.">                                if (&quot;1.0&quot;.equals(eqstr('=')) != true) {</span>
<span class="nc" id="L3103">                                    panic(FAULT);</span>
                                }
<span class="fc" id="L3105">                                mInp.xmlver = 0x0100;</span>
<span class="fc" id="L3106">                                st = 2;</span>
<span class="fc bfc" id="L3107" title="All 2 branches covered.">                            } else if (&quot;encoding&quot;.equals(str) == true) {</span>
<span class="pc bpc" id="L3108" title="1 of 2 branches missed.">                                if (st != 2) {</span>
<span class="nc" id="L3109">                                    panic(FAULT);</span>
                                }
<span class="fc" id="L3111">                                mInp.xmlenc = eqstr('=').toUpperCase();</span>
<span class="fc" id="L3112">                                enc = mInp.xmlenc;</span>
<span class="fc" id="L3113">                                st = 3;</span>
<span class="pc bpc" id="L3114" title="1 of 2 branches missed.">                            } else if (&quot;standalone&quot;.equals(str) == true) {</span>
<span class="pc bpc" id="L3115" title="2 of 4 branches missed.">                                if ((st == 1) || (mPh &gt;= PH_DOC_START)) // [#4.3.1]</span>
                                {
<span class="nc" id="L3117">                                    panic(FAULT);</span>
                                }
<span class="fc" id="L3119">                                str = eqstr('=').toLowerCase();</span>
                                //              Check the 'standalone' value and use it [#5.1]
<span class="pc bpc" id="L3121" title="1 of 2 branches missed.">                                if (str.equals(&quot;yes&quot;) == true) {</span>
<span class="nc" id="L3122">                                    mIsSAlone = true;</span>
<span class="pc bpc" id="L3123" title="1 of 2 branches missed.">                                } else if (str.equals(&quot;no&quot;) == true) {</span>
<span class="fc" id="L3124">                                    mIsSAlone = false;</span>
                                } else {
<span class="nc" id="L3126">                                    panic(FAULT);</span>
                                }
<span class="fc" id="L3128">                                mIsSAloneSet = true;</span>
<span class="fc" id="L3129">                                st = 4;</span>
                            } else {
<span class="nc" id="L3131">                                panic(FAULT);</span>
                            }
<span class="nc" id="L3133">                            break;</span>

                        case ' ':
<span class="fc" id="L3136">                            break;</span>

                        case '?':
<span class="pc bpc" id="L3139" title="1 of 2 branches missed.">                            if (st == 1) {</span>
<span class="nc" id="L3140">                                panic(FAULT);</span>
                            }
<span class="fc" id="L3142">                            bkch();</span>
<span class="fc" id="L3143">                            st = 4;</span>
<span class="fc" id="L3144">                            break;</span>

                        default:
<span class="nc" id="L3147">                            panic(FAULT);</span>
                    }
<span class="nc" id="L3149">                    break;</span>

                case 4:     // end of xml declaration
<span class="pc bpc" id="L3152" title="2 of 3 branches missed.">                    switch (chtyp(ch)) {</span>
                        case '?':
<span class="pc bpc" id="L3154" title="1 of 2 branches missed.">                            if (getch() != '&gt;') {</span>
<span class="nc" id="L3155">                                panic(FAULT);</span>
                            }
<span class="fc bfc" id="L3157" title="All 2 branches covered.">                            if (mPh &lt;= PH_DOC_START) {</span>
<span class="fc" id="L3158">                                mPh = PH_MISC_DTD;  // misc before DTD</span>
                            }
<span class="fc" id="L3160">                            st = -1;</span>
<span class="fc" id="L3161">                            break;</span>

                        case ' ':
<span class="nc" id="L3164">                            break;</span>

                        default:
<span class="nc" id="L3167">                            panic(FAULT);</span>
                    }
<span class="nc" id="L3169">                    break;</span>

                default:
<span class="nc" id="L3172">                    panic(FAULT);</span>
            }
        }
<span class="fc" id="L3175">        return enc;</span>
    }

    /**
     * Sets up the document reader.
     *
     * @param name an encoding name.
     * @param is the document byte input stream.
     * @return a reader constructed from encoding name and input stream.
     * @exception UnsupportedEncodingException
     */
    private Reader enc(String name, InputStream is)
            throws UnsupportedEncodingException {
        //              DO NOT CLOSE current reader if any!
<span class="fc bfc" id="L3189" title="All 2 branches covered.">        if (name.equals(&quot;UTF-8&quot;)) {</span>
<span class="fc" id="L3190">            return new ReaderUTF8(is);</span>
<span class="pc bpc" id="L3191" title="1 of 2 branches missed.">        } else if (name.equals(&quot;UTF-16LE&quot;)) {</span>
<span class="nc" id="L3192">            return new ReaderUTF16(is, 'l');</span>
<span class="pc bpc" id="L3193" title="1 of 2 branches missed.">        } else if (name.equals(&quot;UTF-16BE&quot;)) {</span>
<span class="nc" id="L3194">            return new ReaderUTF16(is, 'b');</span>
        } else {
<span class="fc" id="L3196">            return new InputStreamReader(is, name);</span>
        }
    }

    /**
     * Sets up current input on the top of the input stack.
     *
     * @param inp A new input to set up.
     */
    protected void push(Input inp) {
<span class="fc" id="L3206">        mInp.chLen = mChLen;</span>
<span class="fc" id="L3207">        mInp.chIdx = mChIdx;</span>
<span class="fc" id="L3208">        inp.next = mInp;</span>
<span class="fc" id="L3209">        mInp = inp;</span>
<span class="fc" id="L3210">        mChars = inp.chars;</span>
<span class="fc" id="L3211">        mChLen = inp.chLen;</span>
<span class="fc" id="L3212">        mChIdx = inp.chIdx;</span>
<span class="fc" id="L3213">    }</span>

    /**
     * Restores previous input on the top of the input stack.
     */
    protected void pop() {
<span class="fc bfc" id="L3219" title="All 2 branches covered.">        if (mInp.src != null) {</span>
            try {
<span class="fc" id="L3221">                mInp.src.close();</span>
<span class="nc" id="L3222">            } catch (IOException ioe) {</span>
<span class="fc" id="L3223">            }</span>
<span class="fc" id="L3224">            mInp.src = null;</span>
        }
<span class="fc" id="L3226">        mInp = mInp.next;</span>
<span class="fc bfc" id="L3227" title="All 2 branches covered.">        if (mInp != null) {</span>
<span class="fc" id="L3228">            mChars = mInp.chars;</span>
<span class="fc" id="L3229">            mChLen = mInp.chLen;</span>
<span class="fc" id="L3230">            mChIdx = mInp.chIdx;</span>
        } else {
<span class="fc" id="L3232">            mChars = null;</span>
<span class="fc" id="L3233">            mChLen = 0;</span>
<span class="fc" id="L3234">            mChIdx = 0;</span>
        }
<span class="fc" id="L3236">    }</span>

    /**
     * Maps a character to it's type.
     *
     * Possible character type values are:&lt;br /&gt; - ' ' for any kind of white
     * space character;&lt;br /&gt; - 'a' for any lower case alphabetical character
     * value;&lt;br /&gt; - 'A' for any upper case alphabetical character value;&lt;br /&gt;
     * - 'd' for any decimal digit character value;&lt;br /&gt; - 'z' for any
     * character less then ' ' except '\t', '\n', '\r';&lt;br /&gt; - 'X' for any not
     * ASCII character;&lt;br /&gt; - 'Z' for EOS character.&lt;br /&gt; An ASCII (7 bit)
     * character which does not fall in any category listed above is mapped to
     * it self.
     *
     * @param ch The character to map.
     * @return The type of character.
     */
    protected char chtyp(char ch) {
<span class="pc bpc" id="L3254" title="1 of 2 branches missed.">        if (ch &lt; 0x80) {</span>
<span class="fc" id="L3255">            return (char) asctyp[ch];</span>
        }
<span class="nc bnc" id="L3257" title="All 2 branches missed.">        return (ch != EOS) ? 'X' : 'Z';</span>
    }

    /**
     * Retrives the next character in the document.
     *
     * @return The next character in the document.
     */
    protected char getch()
            throws IOException {
<span class="fc bfc" id="L3267" title="All 2 branches covered.">        if (mChIdx &gt;= mChLen) {</span>
<span class="fc bfc" id="L3268" title="All 2 branches covered.">            if (mInp.src == null) {</span>
<span class="fc" id="L3269">                pop();  // remove internal entity</span>
<span class="fc" id="L3270">                return getch();</span>
            }
            //          Read new portion of the document characters
<span class="fc" id="L3273">            int Num = mInp.src.read(mChars, 0, mChars.length);</span>
<span class="fc bfc" id="L3274" title="All 2 branches covered.">            if (Num &lt; 0) {</span>
<span class="fc bfc" id="L3275" title="All 2 branches covered.">                if (mInp != mDoc) {</span>
<span class="fc" id="L3276">                    pop();  // restore the previous input</span>
<span class="fc" id="L3277">                    return getch();</span>
                } else {
<span class="fc" id="L3279">                    mChars[0] = EOS;</span>
<span class="fc" id="L3280">                    mChLen = 1;</span>
                }
            } else {
<span class="fc" id="L3283">                mChLen = Num;</span>
            }
<span class="fc" id="L3285">            mChIdx = 0;</span>
        }
<span class="fc" id="L3287">        return mChars[mChIdx++];</span>
    }

    /**
     * Puts back the last read character.
     *
     * This method &lt;strong&gt;MUST NOT&lt;/strong&gt; be called more then once after each
     * call of {@link #getch getch} method.
     */
    protected void bkch()
            throws Exception {
<span class="pc bpc" id="L3298" title="1 of 2 branches missed.">        if (mChIdx &lt;= 0) {</span>
<span class="nc" id="L3299">            panic(FAULT);</span>
        }
<span class="fc" id="L3301">        mChIdx--;</span>
<span class="fc" id="L3302">    }</span>

    /**
     * Sets the current character.
     *
     * @param ch The character to set.
     */
    protected void setch(char ch) {
<span class="fc" id="L3310">        mChars[mChIdx] = ch;</span>
<span class="fc" id="L3311">    }</span>

    /**
     * Finds a pair in the pair chain by a qualified name.
     *
     * @param chain The first element of the chain of pairs.
     * @param qname The qualified name.
     * @return A pair with the specified qualified name or null.
     */
    protected Pair find(Pair chain, char[] qname) {
<span class="fc bfc" id="L3321" title="All 2 branches covered.">        for (Pair pair = chain; pair != null; pair = pair.next) {</span>
<span class="fc bfc" id="L3322" title="All 2 branches covered.">            if (pair.eqname(qname) == true) {</span>
<span class="fc" id="L3323">                return pair;</span>
            }
        }
<span class="fc" id="L3326">        return null;</span>
    }

    /**
     * Provedes an instance of a pair.
     *
     * @param next The reference to a next pair.
     * @return An instance of a pair.
     */
    protected Pair pair(Pair next) {
        Pair pair;

<span class="fc bfc" id="L3338" title="All 2 branches covered.">        if (mDltd != null) {</span>
<span class="fc" id="L3339">            pair = mDltd;</span>
<span class="fc" id="L3340">            mDltd = pair.next;</span>
        } else {
<span class="fc" id="L3342">            pair = new Pair();</span>
        }
<span class="fc" id="L3344">        pair.next = next;</span>

<span class="fc" id="L3346">        return pair;</span>
    }

    /**
     * Deletes an instance of a pair.
     *
     * @param pair The pair to delete.
     * @return A reference to the next pair in a chain.
     */
    protected Pair del(Pair pair) {
<span class="fc" id="L3356">        Pair next = pair.next;</span>

<span class="fc" id="L3358">        pair.name = null;</span>
<span class="fc" id="L3359">        pair.value = null;</span>
<span class="fc" id="L3360">        pair.chars = null;</span>
<span class="fc" id="L3361">        pair.list = null;</span>
<span class="fc" id="L3362">        pair.next = mDltd;</span>
<span class="fc" id="L3363">        mDltd = pair;</span>

<span class="fc" id="L3365">        return next;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>