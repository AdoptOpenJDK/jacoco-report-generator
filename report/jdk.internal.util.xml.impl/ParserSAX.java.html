<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ParserSAX.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">jdk.internal.util.xml.impl</a> &gt; <span class="el_source">ParserSAX.java</span></div><h1>ParserSAX.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package jdk.internal.util.xml.impl;

import java.io.IOException;
import java.io.InputStream;
import jdk.internal.org.xml.sax.ContentHandler;
import jdk.internal.org.xml.sax.DTDHandler;
import jdk.internal.org.xml.sax.EntityResolver;
import jdk.internal.org.xml.sax.ErrorHandler;
import jdk.internal.org.xml.sax.InputSource;
import jdk.internal.org.xml.sax.Locator;
import jdk.internal.org.xml.sax.SAXException;
import jdk.internal.org.xml.sax.SAXParseException;
import jdk.internal.org.xml.sax.XMLReader;
import jdk.internal.org.xml.sax.helpers.DefaultHandler;

/**
 * XML non-validating push parser.
 *
 * This non-validating parser conforms to &lt;a href=&quot;http://www.w3.org/TR/REC-xml&quot;
 * &gt;Extensible Markup Language (XML) 1.0&lt;/a&gt; and &lt;a
 * href=&quot;http://www.w3.org/TR/REC-xml-names&quot; &gt;&quot;Namespaces in XML&quot;&lt;/a&gt;
 * specifications. The API supported by the parser are &lt;a
 * href=&quot;http://java.sun.com/aboutJava/communityprocess/final/jsr030/index.html&quot;&gt;CLDC
 * 1.0&lt;/a&gt; and &lt;a href=&quot;http://www.jcp.org/en/jsr/detail?id=280&quot;&gt;JSR-280&lt;/a&gt;, a
 * JavaME subset of &lt;a href=&quot;http://java.sun.com/xml/jaxp/index.html&quot;&gt;JAXP&lt;/a&gt;
 * and &lt;a href=&quot;http://www.saxproject.org/&quot;&gt;SAX2&lt;/a&gt;.
 *
 * @see org.xml.sax.XMLReader
 */

final class ParserSAX
    extends Parser implements XMLReader, Locator
{
    public final static String FEATURE_NS =
            &quot;http://xml.org/sax/features/namespaces&quot;;
    public final static String FEATURE_PREF =
            &quot;http://xml.org/sax/features/namespace-prefixes&quot;;
    //          SAX feature flags
    private boolean mFNamespaces;
    private boolean mFPrefixes;
    //          SAX handlers
    private DefaultHandler mHand;      // the default handler
    private ContentHandler mHandCont;  // the content handler
    private DTDHandler mHandDtd;   // the DTD handler
    private ErrorHandler mHandErr;   // the error handler
    private EntityResolver mHandEnt;   // the entity resolver

    /**
     * Constructor.
     */
    public ParserSAX() {
<span class="fc" id="L77">        super();</span>

        //              SAX feature defaut values
<span class="fc" id="L80">        mFNamespaces = true;</span>
<span class="fc" id="L81">        mFPrefixes = false;</span>

        //              Default handler which will be used in case the application
        //              do not set one of handlers.
<span class="fc" id="L85">        mHand = new DefaultHandler();</span>
<span class="fc" id="L86">        mHandCont = mHand;</span>
<span class="fc" id="L87">        mHandDtd = mHand;</span>
<span class="fc" id="L88">        mHandErr = mHand;</span>
<span class="fc" id="L89">        mHandEnt = mHand;</span>
<span class="fc" id="L90">    }</span>

    /**
     * Return the current content handler.
     *
     * @return The current content handler, or null if none has been registered.
     * @see #setContentHandler
     */
    public ContentHandler getContentHandler() {
<span class="nc bnc" id="L99" title="All 2 branches missed.">        return (mHandCont != mHand) ? mHandCont : null;</span>
    }

    /**
     * Allow an application to register a content event handler.
     *
     * &lt;p&gt;If the application does not register a content handler, all content
     * events reported by the SAX parser will be silently ignored.&lt;/p&gt;
     *
     * &lt;p&gt;Applications may register a new or different handler in the middle of
     * a parse, and the SAX parser must begin using the new handler
     * immediately.&lt;/p&gt;
     *
     * @param handler The content handler.
     * @exception java.lang.NullPointerException If the handler argument is
     * null.
     * @see #getContentHandler
     */
    public void setContentHandler(ContentHandler handler) {
<span class="nc bnc" id="L118" title="All 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L119">            throw new NullPointerException();</span>
        }
<span class="nc" id="L121">        mHandCont = handler;</span>
<span class="nc" id="L122">    }</span>

    /**
     * Return the current DTD handler.
     *
     * @return The current DTD handler, or null if none has been registered.
     * @see #setDTDHandler
     */
    public DTDHandler getDTDHandler() {
<span class="nc bnc" id="L131" title="All 2 branches missed.">        return (mHandDtd != mHand) ? mHandDtd : null;</span>
    }

    /**
     * Allow an application to register a DTD event handler.
     *
     * &lt;p&gt;If the application does not register a DTD handler, all DTD events
     * reported by the SAX parser will be silently ignored.&lt;/p&gt;
     *
     * &lt;p&gt;Applications may register a new or different handler in the middle of
     * a parse, and the SAX parser must begin using the new handler
     * immediately.&lt;/p&gt;
     *
     * @param handler The DTD handler.
     * @exception java.lang.NullPointerException If the handler argument is
     * null.
     * @see #getDTDHandler
     */
    public void setDTDHandler(DTDHandler handler) {
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L151">            throw new NullPointerException();</span>
        }
<span class="nc" id="L153">        mHandDtd = handler;</span>
<span class="nc" id="L154">    }</span>

    /**
     * Return the current error handler.
     *
     * @return The current error handler, or null if none has been registered.
     * @see #setErrorHandler
     */
    public ErrorHandler getErrorHandler() {
<span class="nc bnc" id="L163" title="All 2 branches missed.">        return (mHandErr != mHand) ? mHandErr : null;</span>
    }

    /**
     * Allow an application to register an error event handler.
     *
     * &lt;p&gt;If the application does not register an error handler, all error
     * events reported by the SAX parser will be silently ignored; however,
     * normal processing may not continue. It is highly recommended that all SAX
     * applications implement an error handler to avoid unexpected bugs.&lt;/p&gt;
     *
     * &lt;p&gt;Applications may register a new or different handler in the middle of
     * a parse, and the SAX parser must begin using the new handler
     * immediately.&lt;/p&gt;
     *
     * @param handler The error handler.
     * @exception java.lang.NullPointerException If the handler argument is
     * null.
     * @see #getErrorHandler
     */
    public void setErrorHandler(ErrorHandler handler) {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (handler == null) {</span>
<span class="nc" id="L185">            throw new NullPointerException();</span>
        }
<span class="nc" id="L187">        mHandErr = handler;</span>
<span class="nc" id="L188">    }</span>

    /**
     * Return the current entity resolver.
     *
     * @return The current entity resolver, or null if none has been registered.
     * @see #setEntityResolver
     */
    public EntityResolver getEntityResolver() {
<span class="nc bnc" id="L197" title="All 2 branches missed.">        return (mHandEnt != mHand) ? mHandEnt : null;</span>
    }

    /**
     * Allow an application to register an entity resolver.
     *
     * &lt;p&gt;If the application does not register an entity resolver, the XMLReader
     * will perform its own default resolution.&lt;/p&gt;
     *
     * &lt;p&gt;Applications may register a new or different resolver in the middle of
     * a parse, and the SAX parser must begin using the new resolver
     * immediately.&lt;/p&gt;
     *
     * @param resolver The entity resolver.
     * @exception java.lang.NullPointerException If the resolver argument is
     * null.
     * @see #getEntityResolver
     */
    public void setEntityResolver(EntityResolver resolver) {
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (resolver == null) {</span>
<span class="nc" id="L217">            throw new NullPointerException();</span>
        }
<span class="nc" id="L219">        mHandEnt = resolver;</span>
<span class="nc" id="L220">    }</span>

    /**
     * Return the public identifier for the current document event.
     *
     * &lt;p&gt;The return value is the public identifier of the document entity or of
     * the external parsed entity in which the markup triggering the event
     * appears.&lt;/p&gt;
     *
     * @return A string containing the public identifier, or null if none is
     * available.
     *
     * @see #getSystemId
     */
    public String getPublicId() {
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        return (mInp != null) ? mInp.pubid : null;</span>
    }

    /**
     * Return the system identifier for the current document event.
     *
     * &lt;p&gt;The return value is the system identifier of the document entity or of
     * the external parsed entity in which the markup triggering the event
     * appears.&lt;/p&gt;
     *
     * &lt;p&gt;If the system identifier is a URL, the parser must resolve it fully
     * before passing it to the application.&lt;/p&gt;
     *
     * @return A string containing the system identifier, or null if none is
     * available.
     *
     * @see #getPublicId
     */
    public String getSystemId() {
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        return (mInp != null) ? mInp.sysid : null;</span>
    }

    /**
     * Return the line number where the current document event ends.
     *
     * @return Always returns -1 indicating the line number is not available.
     *
     * @see #getColumnNumber
     */
    public int getLineNumber() {
<span class="fc" id="L265">        return -1;</span>
    }

    /**
     * Return the column number where the current document event ends.
     *
     * @return Always returns -1 indicating the column number is not available.
     *
     * @see #getLineNumber
     */
    public int getColumnNumber() {
<span class="fc" id="L276">        return -1;</span>
    }

    /**
     * Parse an XML document from a system identifier (URI).
     *
     * &lt;p&gt;This method is a shortcut for the common case of reading a document
     * from a system identifier. It is the exact equivalent of the
     * following:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * parse(new InputSource(systemId));
     * &lt;/pre&gt;
     *
     * &lt;p&gt;If the system identifier is a URL, it must be fully resolved by the
     * application before it is passed to the parser.&lt;/p&gt;
     *
     * @param systemId The system identifier (URI).
     * @exception org.xml.sax.SAXException Any SAX exception, possibly wrapping
     * another exception.
     * @exception java.io.IOException An IO exception from the parser, possibly
     * from a byte stream or character stream supplied by the application.
     * @see #parse(org.xml.sax.InputSource)
     */
    public void parse(String systemId) throws IOException, SAXException {
<span class="nc" id="L301">        parse(new InputSource(systemId));</span>
<span class="nc" id="L302">    }</span>

    /**
     * Parse an XML document.
     *
     * &lt;p&gt;The application can use this method to instruct the XML reader to
     * begin parsing an XML document from any valid input source (a character
     * stream, a byte stream, or a URI).&lt;/p&gt;
     *
     * &lt;p&gt;Applications may not invoke this method while a parse is in progress
     * (they should create a new XMLReader instead for each nested XML
     * document). Once a parse is complete, an application may reuse the same
     * XMLReader object, possibly with a different input source.&lt;/p&gt;
     *
     * &lt;p&gt;During the parse, the XMLReader will provide information about the XML
     * document through the registered event handlers.&lt;/p&gt;
     *
     * &lt;p&gt;This method is synchronous: it will not return until parsing has
     * ended. If a client application wants to terminate parsing early, it
     * should throw an exception.&lt;/p&gt;
     *
     * @param is The input source for the top-level of the XML document.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly wrapping
     * another exception.
     * @exception java.io.IOException An IO exception from the parser, possibly
     * from a byte stream or character stream supplied by the application.
     * @see org.xml.sax.InputSource
     * @see #parse(java.lang.String)
     * @see #setEntityResolver
     * @see #setDTDHandler
     * @see #setContentHandler
     * @see #setErrorHandler
     */
    public void parse(InputSource is) throws IOException, SAXException {
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (is == null) {</span>
<span class="nc" id="L337">            throw new IllegalArgumentException(&quot;&quot;);</span>
        }
        //              Set up the document
<span class="nc" id="L340">        mInp = new Input(BUFFSIZE_READER);</span>
<span class="nc" id="L341">        mPh = PH_BEFORE_DOC;  // before parsing</span>
        try {
<span class="nc" id="L343">            setinp(is);</span>
<span class="nc" id="L344">        } catch (SAXException saxe) {</span>
<span class="nc" id="L345">            throw saxe;</span>
<span class="nc" id="L346">        } catch (IOException ioe) {</span>
<span class="nc" id="L347">            throw ioe;</span>
<span class="nc" id="L348">        } catch (RuntimeException rte) {</span>
<span class="nc" id="L349">            throw rte;</span>
<span class="nc" id="L350">        } catch (Exception e) {</span>
<span class="nc" id="L351">            panic(e.toString());</span>
<span class="nc" id="L352">        }</span>
<span class="nc" id="L353">        parse();</span>
<span class="nc" id="L354">    }</span>

    /**
     * Parse the content of the given {@link java.io.InputStream} instance as
     * XML using the specified {@link org.xml.sax.helpers.DefaultHandler}.
     *
     * @param src InputStream containing the content to be parsed.
     * @param handler The SAX DefaultHandler to use.
     * @exception IOException If any IO errors occur.
     * @exception IllegalArgumentException If the given InputStream or handler
     * is null.
     * @exception SAXException If the underlying parser throws a SAXException
     * while parsing.
     * @see org.xml.sax.helpers.DefaultHandler
     */
    public void parse(InputStream src, DefaultHandler handler)
            throws SAXException, IOException {
<span class="pc bpc" id="L371" title="2 of 4 branches missed.">        if ((src == null) || (handler == null)) {</span>
<span class="nc" id="L372">            throw new IllegalArgumentException(&quot;&quot;);</span>
        }
<span class="fc" id="L374">        parse(new InputSource(src), handler);</span>
<span class="fc" id="L375">    }</span>

    /**
     * Parse the content given {@link org.xml.sax.InputSource} as XML using the
     * specified {@link org.xml.sax.helpers.DefaultHandler}.
     *
     * @param is The InputSource containing the content to be parsed.
     * @param handler The SAX DefaultHandler to use.
     * @exception IOException If any IO errors occur.
     * @exception IllegalArgumentException If the InputSource or handler is
     * null.
     * @exception SAXException If the underlying parser throws a SAXException
     * while parsing.
     * @see org.xml.sax.helpers.DefaultHandler
     */
    public void parse(InputSource is, DefaultHandler handler)
        throws SAXException, IOException
    {
<span class="pc bpc" id="L393" title="2 of 4 branches missed.">        if ((is == null) || (handler == null)) {</span>
<span class="nc" id="L394">            throw new IllegalArgumentException(&quot;&quot;);</span>
        }
        //              Set up the handler
<span class="fc" id="L397">        mHandCont = handler;</span>
<span class="fc" id="L398">        mHandDtd = handler;</span>
<span class="fc" id="L399">        mHandErr = handler;</span>
<span class="fc" id="L400">        mHandEnt = handler;</span>
        //              Set up the document
<span class="fc" id="L402">        mInp = new Input(BUFFSIZE_READER);</span>
<span class="fc" id="L403">        mPh = PH_BEFORE_DOC;  // before parsing</span>
        try {
<span class="fc" id="L405">            setinp(is);</span>
<span class="fc" id="L406">        } catch (SAXException | IOException | RuntimeException saxe) {</span>
<span class="fc" id="L407">            throw saxe;</span>
<span class="nc" id="L408">        } catch (Exception e) {</span>
<span class="nc" id="L409">            panic(e.toString());</span>
<span class="fc" id="L410">        }</span>
<span class="fc" id="L411">        parse();</span>
<span class="fc" id="L412">    }</span>

    /**
     * Parse the XML document content using specified handlers and an input
     * source.
     *
     * @exception IOException If any IO errors occur.
     * @exception SAXException If the underlying parser throws a SAXException
     * while parsing.
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    private void parse() throws SAXException, IOException {
<span class="fc" id="L424">        init();</span>
        try {
<span class="fc" id="L426">            mHandCont.setDocumentLocator(this);</span>
<span class="fc" id="L427">            mHandCont.startDocument();</span>

<span class="pc bpc" id="L429" title="1 of 2 branches missed.">            if (mPh != PH_MISC_DTD) {</span>
<span class="fc" id="L430">                mPh = PH_MISC_DTD;  // misc before DTD</span>
            }
<span class="fc" id="L432">            int evt = EV_NULL;</span>
            //          XML document prolog
            do {
<span class="fc" id="L435">                wsskip();</span>
<span class="pc bpc" id="L436" title="1 of 4 branches missed.">                switch (evt = step()) {</span>
                    case EV_ELM:
                    case EV_ELMS:
<span class="fc" id="L439">                        mPh = PH_DOCELM;</span>
<span class="fc" id="L440">                        break;</span>

                    case EV_COMM:
                    case EV_PI:
<span class="fc" id="L444">                        break;</span>

                    case EV_DTD:
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">                        if (mPh &gt;= PH_DTD_MISC) {</span>
<span class="nc" id="L448">                            panic(FAULT);</span>
                        }
<span class="fc" id="L450">                        mPh = PH_DTD_MISC;  // misc after DTD</span>
<span class="fc" id="L451">                        break;</span>

                    default:
<span class="nc" id="L454">                        panic(FAULT);</span>
                }
<span class="fc bfc" id="L456" title="All 2 branches covered.">            } while (mPh &lt; PH_DOCELM);  // misc before DTD</span>
            //          XML document starting with document's element
            do {
<span class="pc bpc" id="L459" title="1 of 4 branches missed.">                switch (evt) {</span>
                    case EV_ELM:
                    case EV_ELMS:
                        //              Report the element
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">                        if (mIsNSAware == true) {</span>
<span class="nc" id="L464">                            mHandCont.startElement(</span>
                                    mElm.value,
                                    mElm.name,
                                    &quot;&quot;,
                                    mAttrs);
                        } else {
<span class="fc" id="L470">                            mHandCont.startElement(</span>
                                    &quot;&quot;,
                                    &quot;&quot;,
                                    mElm.name,
                                    mAttrs);
                        }
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">                        if (evt == EV_ELMS) {</span>
<span class="fc" id="L477">                            evt = step();</span>
<span class="fc" id="L478">                            break;</span>
                        }

                    case EV_ELME:
                        //              Report the end of element
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">                        if (mIsNSAware == true) {</span>
<span class="nc" id="L484">                            mHandCont.endElement(mElm.value, mElm.name, &quot;&quot;);</span>
                        } else {
<span class="fc" id="L486">                            mHandCont.endElement(&quot;&quot;, &quot;&quot;, mElm.name);</span>
                        }
                        //              Restore the top of the prefix stack
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                        while (mPref.list == mElm) {</span>
<span class="nc" id="L490">                            mHandCont.endPrefixMapping(mPref.name);</span>
<span class="nc" id="L491">                            mPref = del(mPref);</span>
                        }
                        //              Remove the top element tag
<span class="fc" id="L494">                        mElm = del(mElm);</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">                        if (mElm == null) {</span>
<span class="fc" id="L496">                            mPh = PH_DOCELM_MISC;</span>
                        } else {
<span class="fc" id="L498">                            evt = step();</span>
                        }
<span class="fc" id="L500">                        break;</span>

                    case EV_TEXT:
                    case EV_WSPC:
                    case EV_CDAT:
                    case EV_COMM:
                    case EV_PI:
                    case EV_ENT:
<span class="fc" id="L508">                        evt = step();</span>
<span class="fc" id="L509">                        break;</span>

                    default:
<span class="nc" id="L512">                        panic(FAULT);</span>
                }
<span class="fc bfc" id="L514" title="All 2 branches covered.">            } while (mPh == PH_DOCELM);</span>
            //          Misc after document's element
            do {
<span class="pc bpc" id="L517" title="1 of 2 branches missed.">                if (wsskip() == EOS) {</span>
<span class="fc" id="L518">                    break;</span>
                }

<span class="nc bnc" id="L521" title="All 2 branches missed.">                switch (step()) {</span>
                    case EV_COMM:
                    case EV_PI:
<span class="nc" id="L524">                        break;</span>

                    default:
<span class="nc" id="L527">                        panic(FAULT);</span>
                }
<span class="nc bnc" id="L529" title="All 2 branches missed.">            } while (mPh == PH_DOCELM_MISC);</span>
<span class="fc" id="L530">            mPh = PH_AFTER_DOC;  // parsing is completed</span>

<span class="fc" id="L532">        } catch (SAXException saxe) {</span>
<span class="fc" id="L533">            throw saxe;</span>
<span class="nc" id="L534">        } catch (IOException ioe) {</span>
<span class="nc" id="L535">            throw ioe;</span>
<span class="nc" id="L536">        } catch (RuntimeException rte) {</span>
<span class="nc" id="L537">            throw rte;</span>
<span class="nc" id="L538">        } catch (Exception e) {</span>
<span class="nc" id="L539">            panic(e.toString());</span>
        } finally {
<span class="pc" id="L541">            mHandCont.endDocument();</span>
<span class="pc" id="L542">            cleanup();</span>
<span class="pc" id="L543">        }</span>
<span class="fc" id="L544">    }</span>

    /**
     * Reports document type.
     *
     * @param name The name of the entity.
     * @param pubid The public identifier of the entity or &lt;code&gt;null&lt;/code&gt;.
     * @param sysid The system identifier of the entity or &lt;code&gt;null&lt;/code&gt;.
     */
    protected void docType(String name, String pubid, String sysid) throws SAXException {
<span class="fc" id="L554">        mHandDtd.notationDecl(name, pubid, sysid);</span>
<span class="fc" id="L555">    }</span>

    /**
     * Reports a comment.
     *
     * @param text The comment text starting from first charcater.
     * @param length The number of characters in comment.
     */
    protected void comm(char[] text, int length) {
<span class="fc" id="L564">    }</span>

    /**
     * Reports a processing instruction.
     *
     * @param target The processing instruction target name.
     * @param body The processing instruction body text.
     */
    protected void pi(String target, String body) throws SAXException {
<span class="fc" id="L573">        mHandCont.processingInstruction(target, body);</span>
<span class="fc" id="L574">    }</span>

    /**
     * Reports new namespace prefix. The Namespace prefix (
     * &lt;code&gt;mPref.name&lt;/code&gt;) being declared and the Namespace URI (
     * &lt;code&gt;mPref.value&lt;/code&gt;) the prefix is mapped to. An empty string is
     * used for the default element namespace, which has no prefix.
     */
    protected void newPrefix() throws SAXException {
<span class="nc" id="L583">        mHandCont.startPrefixMapping(mPref.name, mPref.value);</span>
<span class="nc" id="L584">    }</span>

    /**
     * Reports skipped entity name.
     *
     * @param name The entity name.
     */
    protected void skippedEnt(String name) throws SAXException {
<span class="nc" id="L592">        mHandCont.skippedEntity(name);</span>
<span class="nc" id="L593">    }</span>

    /**
     * Returns an
     * &lt;code&gt;InputSource&lt;/code&gt; for specified entity or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @param name The name of the entity.
     * @param pubid The public identifier of the entity.
     * @param sysid The system identifier of the entity.
     */
    protected InputSource resolveEnt(String name, String pubid, String sysid)
        throws SAXException, IOException
    {
<span class="fc" id="L607">        return mHandEnt.resolveEntity(pubid, sysid);</span>
    }

    /**
     * Reports notation declaration.
     *
     * @param name The notation's name.
     * @param pubid The notation's public identifier, or null if none was given.
     * @param sysid The notation's system identifier, or null if none was given.
     */
    protected void notDecl(String name, String pubid, String sysid)
        throws SAXException
    {
<span class="nc" id="L620">        mHandDtd.notationDecl(name, pubid, sysid);</span>
<span class="nc" id="L621">    }</span>

    /**
     * Reports unparsed entity name.
     *
     * @param name The unparsed entity's name.
     * @param pubid The entity's public identifier, or null if none was given.
     * @param sysid The entity's system identifier.
     * @param notation The name of the associated notation.
     */
    protected void unparsedEntDecl(String name, String pubid, String sysid, String notation)
        throws SAXException
    {
<span class="nc" id="L634">        mHandDtd.unparsedEntityDecl(name, pubid, sysid, notation);</span>
<span class="nc" id="L635">    }</span>

    /**
     * Notifies the handler about fatal parsing error.
     *
     * @param msg The problem description message.
     */
    protected void panic(String msg) throws SAXException {
<span class="nc" id="L643">        SAXParseException spe = new SAXParseException(msg, this);</span>
<span class="nc" id="L644">        mHandErr.fatalError(spe);</span>
<span class="nc" id="L645">        throw spe;  // [#1.2] fatal error definition</span>
    }

    /**
     * Reports characters and empties the parser's buffer. This method is called
     * only if parser is going to return control to the main loop. This means
     * that this method may use parser buffer to report white space without
     * copeing characters to temporary buffer.
     */
    protected void bflash() throws SAXException {
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">        if (mBuffIdx &gt;= 0) {</span>
            //          Textual data has been read
<span class="fc" id="L657">            mHandCont.characters(mBuff, 0, (mBuffIdx + 1));</span>
<span class="fc" id="L658">            mBuffIdx = -1;</span>
        }
<span class="fc" id="L660">    }</span>

    /**
     * Reports white space characters and empties the parser's buffer. This
     * method is called only if parser is going to return control to the main
     * loop. This means that this method may use parser buffer to report white
     * space without copeing characters to temporary buffer.
     */
    protected void bflash_ws() throws SAXException {
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">        if (mBuffIdx &gt;= 0) {</span>
            // BUG: With additional info from DTD and xml:space attr [#2.10]
            // the following call can be supported:
            // mHandCont.ignorableWhitespace(mBuff, 0, (mBuffIdx + 1));

            //          Textual data has been read
<span class="fc" id="L675">            mHandCont.characters(mBuff, 0, (mBuffIdx + 1));</span>
<span class="fc" id="L676">            mBuffIdx = -1;</span>
        }
<span class="fc" id="L678">    }</span>

    public boolean getFeature(String name) {
<span class="nc" id="L681">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    public void setFeature(String name, boolean value) {
<span class="nc" id="L685">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    public Object getProperty(String name) {
<span class="nc" id="L689">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    public void setProperty(String name, Object value) {
<span class="nc" id="L693">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>