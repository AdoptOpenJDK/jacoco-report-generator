<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ThreadGroup.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang</a> &gt; <span class="el_source">ThreadGroup.java</span></div><h1>ThreadGroup.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang;

import java.io.PrintStream;
import java.util.Arrays;
import sun.misc.VM;

/**
 * A thread group represents a set of threads. In addition, a thread
 * group can also include other thread groups. The thread groups form
 * a tree in which every thread group except the initial thread group
 * has a parent.
 * &lt;p&gt;
 * A thread is allowed to access information about its own thread
 * group, but not to access information about its thread group's
 * parent thread group or any other thread groups.
 *
 * @author  unascribed
 * @since   JDK1.0
 */
/* The locking strategy for this code is to try to lock only one level of the
 * tree wherever possible, but otherwise to lock from the bottom up.
 * That is, from child thread groups to parents.
 * This has the advantage of limiting the number of locks that need to be held
 * and in particular avoids having to grab the lock for the root thread group,
 * (or a global lock) which would be a source of contention on a
 * multi-processor system with many thread groups.
 * This policy often leads to taking a snapshot of the state of a thread group
 * and working off of that snapshot, rather than holding the thread group locked
 * while we work on the children.
 */
public
class ThreadGroup implements Thread.UncaughtExceptionHandler {
    private final ThreadGroup parent;
    String name;
    int maxPriority;
    boolean destroyed;
    boolean daemon;
    boolean vmAllowSuspension;

<span class="fc" id="L65">    int nUnstartedThreads = 0;</span>
    int nthreads;
    Thread threads[];

    int ngroups;
    ThreadGroup groups[];

    /**
     * Creates an empty Thread group that is not in any Thread group.
     * This method is used to create the system Thread group.
     */
<span class="fc" id="L76">    private ThreadGroup() {     // called from C code</span>
<span class="fc" id="L77">        this.name = &quot;system&quot;;</span>
<span class="fc" id="L78">        this.maxPriority = Thread.MAX_PRIORITY;</span>
<span class="fc" id="L79">        this.parent = null;</span>
<span class="fc" id="L80">    }</span>

    /**
     * Constructs a new thread group. The parent of this new group is
     * the thread group of the currently running thread.
     * &lt;p&gt;
     * The &lt;code&gt;checkAccess&lt;/code&gt; method of the parent thread group is
     * called with no arguments; this may result in a security exception.
     *
     * @param   name   the name of the new thread group.
     * @exception  SecurityException  if the current thread cannot create a
     *               thread in the specified thread group.
     * @see     java.lang.ThreadGroup#checkAccess()
     * @since   JDK1.0
     */
    public ThreadGroup(String name) {
<span class="fc" id="L96">        this(Thread.currentThread().getThreadGroup(), name);</span>
<span class="fc" id="L97">    }</span>

    /**
     * Creates a new thread group. The parent of this new group is the
     * specified thread group.
     * &lt;p&gt;
     * The &lt;code&gt;checkAccess&lt;/code&gt; method of the parent thread group is
     * called with no arguments; this may result in a security exception.
     *
     * @param     parent   the parent thread group.
     * @param     name     the name of the new thread group.
     * @exception  NullPointerException  if the thread group argument is
     *               &lt;code&gt;null&lt;/code&gt;.
     * @exception  SecurityException  if the current thread cannot create a
     *               thread in the specified thread group.
     * @see     java.lang.SecurityException
     * @see     java.lang.ThreadGroup#checkAccess()
     * @since   JDK1.0
     */
    public ThreadGroup(ThreadGroup parent, String name) {
<span class="fc" id="L117">        this(checkParentAccess(parent), parent, name);</span>
<span class="fc" id="L118">    }</span>

<span class="fc" id="L120">    private ThreadGroup(Void unused, ThreadGroup parent, String name) {</span>
<span class="fc" id="L121">        this.name = name;</span>
<span class="fc" id="L122">        this.maxPriority = parent.maxPriority;</span>
<span class="fc" id="L123">        this.daemon = parent.daemon;</span>
<span class="fc" id="L124">        this.vmAllowSuspension = parent.vmAllowSuspension;</span>
<span class="fc" id="L125">        this.parent = parent;</span>
<span class="fc" id="L126">        parent.add(this);</span>
<span class="fc" id="L127">    }</span>

    /*
     * @throws  NullPointerException  if the parent argument is {@code null}
     * @throws  SecurityException     if the current thread cannot create a
     *                                thread in the specified thread group.
     */
    private static Void checkParentAccess(ThreadGroup parent) {
<span class="fc" id="L135">        parent.checkAccess();</span>
<span class="fc" id="L136">        return null;</span>
    }

    /**
     * Returns the name of this thread group.
     *
     * @return  the name of this thread group.
     * @since   JDK1.0
     */
    public final String getName() {
<span class="fc" id="L146">        return name;</span>
    }

    /**
     * Returns the parent of this thread group.
     * &lt;p&gt;
     * First, if the parent is not &lt;code&gt;null&lt;/code&gt;, the
     * &lt;code&gt;checkAccess&lt;/code&gt; method of the parent thread group is
     * called with no arguments; this may result in a security exception.
     *
     * @return  the parent of this thread group. The top-level thread group
     *          is the only thread group whose parent is &lt;code&gt;null&lt;/code&gt;.
     * @exception  SecurityException  if the current thread cannot modify
     *               this thread group.
     * @see        java.lang.ThreadGroup#checkAccess()
     * @see        java.lang.SecurityException
     * @see        java.lang.RuntimePermission
     * @since   JDK1.0
     */
    public final ThreadGroup getParent() {
<span class="fc bfc" id="L166" title="All 2 branches covered.">        if (parent != null)</span>
<span class="fc" id="L167">            parent.checkAccess();</span>
<span class="fc" id="L168">        return parent;</span>
    }

    /**
     * Returns the maximum priority of this thread group. Threads that are
     * part of this group cannot have a higher priority than the maximum
     * priority.
     *
     * @return  the maximum priority that a thread in this thread group
     *          can have.
     * @see     #setMaxPriority
     * @since   JDK1.0
     */
    public final int getMaxPriority() {
<span class="fc" id="L182">        return maxPriority;</span>
    }

    /**
     * Tests if this thread group is a daemon thread group. A
     * daemon thread group is automatically destroyed when its last
     * thread is stopped or its last thread group is destroyed.
     *
     * @return  &lt;code&gt;true&lt;/code&gt; if this thread group is a daemon thread group;
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since   JDK1.0
     */
    public final boolean isDaemon() {
<span class="nc" id="L195">        return daemon;</span>
    }

    /**
     * Tests if this thread group has been destroyed.
     *
     * @return  true if this object is destroyed
     * @since   JDK1.1
     */
    public synchronized boolean isDestroyed() {
<span class="fc" id="L205">        return destroyed;</span>
    }

    /**
     * Changes the daemon status of this thread group.
     * &lt;p&gt;
     * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is
     * called with no arguments; this may result in a security exception.
     * &lt;p&gt;
     * A daemon thread group is automatically destroyed when its last
     * thread is stopped or its last thread group is destroyed.
     *
     * @param      daemon   if &lt;code&gt;true&lt;/code&gt;, marks this thread group as
     *                      a daemon thread group; otherwise, marks this
     *                      thread group as normal.
     * @exception  SecurityException  if the current thread cannot modify
     *               this thread group.
     * @see        java.lang.SecurityException
     * @see        java.lang.ThreadGroup#checkAccess()
     * @since      JDK1.0
     */
    public final void setDaemon(boolean daemon) {
<span class="fc" id="L227">        checkAccess();</span>
<span class="fc" id="L228">        this.daemon = daemon;</span>
<span class="fc" id="L229">    }</span>

    /**
     * Sets the maximum priority of the group. Threads in the thread
     * group that already have a higher priority are not affected.
     * &lt;p&gt;
     * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is
     * called with no arguments; this may result in a security exception.
     * &lt;p&gt;
     * If the &lt;code&gt;pri&lt;/code&gt; argument is less than
     * {@link Thread#MIN_PRIORITY} or greater than
     * {@link Thread#MAX_PRIORITY}, the maximum priority of the group
     * remains unchanged.
     * &lt;p&gt;
     * Otherwise, the priority of this ThreadGroup object is set to the
     * smaller of the specified &lt;code&gt;pri&lt;/code&gt; and the maximum permitted
     * priority of the parent of this thread group. (If this thread group
     * is the system thread group, which has no parent, then its maximum
     * priority is simply set to &lt;code&gt;pri&lt;/code&gt;.) Then this method is
     * called recursively, with &lt;code&gt;pri&lt;/code&gt; as its argument, for
     * every thread group that belongs to this thread group.
     *
     * @param      pri   the new priority of the thread group.
     * @exception  SecurityException  if the current thread cannot modify
     *               this thread group.
     * @see        #getMaxPriority
     * @see        java.lang.SecurityException
     * @see        java.lang.ThreadGroup#checkAccess()
     * @since      JDK1.0
     */
    public final void setMaxPriority(int pri) {
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
<span class="nc" id="L262">        synchronized (this) {</span>
<span class="nc" id="L263">            checkAccess();</span>
<span class="nc bnc" id="L264" title="All 4 branches missed.">            if (pri &lt; Thread.MIN_PRIORITY || pri &gt; Thread.MAX_PRIORITY) {</span>
<span class="nc" id="L265">                return;</span>
            }
<span class="nc bnc" id="L267" title="All 2 branches missed.">            maxPriority = (parent != null) ? Math.min(pri, parent.maxPriority) : pri;</span>
<span class="nc" id="L268">            ngroupsSnapshot = ngroups;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (groups != null) {</span>
<span class="nc" id="L270">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span>
            } else {
<span class="nc" id="L272">                groupsSnapshot = null;</span>
            }
<span class="nc" id="L274">        }</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">        for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {</span>
<span class="nc" id="L276">            groupsSnapshot[i].setMaxPriority(pri);</span>
        }
<span class="nc" id="L278">    }</span>

    /**
     * Tests if this thread group is either the thread group
     * argument or one of its ancestor thread groups.
     *
     * @param   g   a thread group.
     * @return  &lt;code&gt;true&lt;/code&gt; if this thread group is the thread group
     *          argument or one of its ancestor thread groups;
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since   JDK1.0
     */
    public final boolean parentOf(ThreadGroup g) {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        for (; g != null ; g = g.parent) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (g == this) {</span>
<span class="nc" id="L293">                return true;</span>
            }
        }
<span class="nc" id="L296">        return false;</span>
    }

    /**
     * Determines if the currently running thread has permission to
     * modify this thread group.
     * &lt;p&gt;
     * If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method
     * is called with this thread group as its argument. This may result
     * in throwing a &lt;code&gt;SecurityException&lt;/code&gt;.
     *
     * @exception  SecurityException  if the current thread is not allowed to
     *               access this thread group.
     * @see        java.lang.SecurityManager#checkAccess(java.lang.ThreadGroup)
     * @since      JDK1.0
     */
    public final void checkAccess() {
<span class="fc" id="L313">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (security != null) {</span>
<span class="fc" id="L315">            security.checkAccess(this);</span>
        }
<span class="fc" id="L317">    }</span>

    /**
     * Returns an estimate of the number of active threads in this thread
     * group and its subgroups. Recursively iterates over all subgroups in
     * this thread group.
     *
     * &lt;p&gt; The value returned is only an estimate because the number of
     * threads may change dynamically while this method traverses internal
     * data structures, and might be affected by the presence of certain
     * system threads. This method is intended primarily for debugging
     * and monitoring purposes.
     *
     * @return  an estimate of the number of active threads in this thread
     *          group and in any other thread group that has this thread
     *          group as an ancestor
     *
     * @since   JDK1.0
     */
    public int activeCount() {
        int result;
        // Snapshot sub-group data so we don't hold this lock
        // while our children are computing.
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
<span class="fc" id="L342">        synchronized (this) {</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L344">                return 0;</span>
            }
<span class="fc" id="L346">            result = nthreads;</span>
<span class="fc" id="L347">            ngroupsSnapshot = ngroups;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">            if (groups != null) {</span>
<span class="fc" id="L349">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span>
            } else {
<span class="fc" id="L351">                groupsSnapshot = null;</span>
            }
<span class="pc" id="L353">        }</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">        for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {</span>
<span class="fc" id="L355">            result += groupsSnapshot[i].activeCount();</span>
        }
<span class="fc" id="L357">        return result;</span>
    }

    /**
     * Copies into the specified array every active thread in this
     * thread group and its subgroups.
     *
     * &lt;p&gt; An invocation of this method behaves in exactly the same
     * way as the invocation
     *
     * &lt;blockquote&gt;
     * {@linkplain #enumerate(Thread[], boolean) enumerate}{@code (list, true)}
     * &lt;/blockquote&gt;
     *
     * @param  list
     *         an array into which to put the list of threads
     *
     * @return  the number of threads put into the array
     *
     * @throws  SecurityException
     *          if {@linkplain #checkAccess checkAccess} determines that
     *          the current thread cannot access this thread group
     *
     * @since   JDK1.0
     */
    public int enumerate(Thread list[]) {
<span class="fc" id="L383">        checkAccess();</span>
<span class="fc" id="L384">        return enumerate(list, 0, true);</span>
    }

    /**
     * Copies into the specified array every active thread in this
     * thread group. If {@code recurse} is {@code true},
     * this method recursively enumerates all subgroups of this
     * thread group and references to every active thread in these
     * subgroups are also included. If the array is too short to
     * hold all the threads, the extra threads are silently ignored.
     *
     * &lt;p&gt; An application might use the {@linkplain #activeCount activeCount}
     * method to get an estimate of how big the array should be, however
     * &lt;i&gt;if the array is too short to hold all the threads, the extra threads
     * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active
     * thread in this thread group, the caller should verify that the returned
     * int value is strictly less than the length of {@code list}.
     *
     * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
     * that the method only be used for debugging and monitoring purposes.
     *
     * @param  list
     *         an array into which to put the list of threads
     *
     * @param  recurse
     *         if {@code true}, recursively enumerate all subgroups of this
     *         thread group
     *
     * @return  the number of threads put into the array
     *
     * @throws  SecurityException
     *          if {@linkplain #checkAccess checkAccess} determines that
     *          the current thread cannot access this thread group
     *
     * @since   JDK1.0
     */
    public int enumerate(Thread list[], boolean recurse) {
<span class="nc" id="L421">        checkAccess();</span>
<span class="nc" id="L422">        return enumerate(list, 0, recurse);</span>
    }

    private int enumerate(Thread list[], int n, boolean recurse) {
<span class="fc" id="L426">        int ngroupsSnapshot = 0;</span>
<span class="fc" id="L427">        ThreadGroup[] groupsSnapshot = null;</span>
<span class="fc" id="L428">        synchronized (this) {</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L430">                return 0;</span>
            }
<span class="fc" id="L432">            int nt = nthreads;</span>
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">            if (nt &gt; list.length - n) {</span>
<span class="nc" id="L434">                nt = list.length - n;</span>
            }
<span class="fc bfc" id="L436" title="All 2 branches covered.">            for (int i = 0; i &lt; nt; i++) {</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">                if (threads[i].isAlive()) {</span>
<span class="fc" id="L438">                    list[n++] = threads[i];</span>
                }
            }
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">            if (recurse) {</span>
<span class="fc" id="L442">                ngroupsSnapshot = ngroups;</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">                if (groups != null) {</span>
<span class="fc" id="L444">                    groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span>
                } else {
<span class="fc" id="L446">                    groupsSnapshot = null;</span>
                }
            }
<span class="pc" id="L449">        }</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (recurse) {</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">            for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {</span>
<span class="fc" id="L452">                n = groupsSnapshot[i].enumerate(list, n, true);</span>
            }
        }
<span class="fc" id="L455">        return n;</span>
    }

    /**
     * Returns an estimate of the number of active groups in this
     * thread group and its subgroups. Recursively iterates over
     * all subgroups in this thread group.
     *
     * &lt;p&gt; The value returned is only an estimate because the number of
     * thread groups may change dynamically while this method traverses
     * internal data structures. This method is intended primarily for
     * debugging and monitoring purposes.
     *
     * @return  the number of active thread groups with this thread group as
     *          an ancestor
     *
     * @since   JDK1.0
     */
    public int activeGroupCount() {
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
<span class="nc" id="L476">        synchronized (this) {</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L478">                return 0;</span>
            }
<span class="nc" id="L480">            ngroupsSnapshot = ngroups;</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">            if (groups != null) {</span>
<span class="nc" id="L482">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span>
            } else {
<span class="nc" id="L484">                groupsSnapshot = null;</span>
            }
<span class="nc" id="L486">        }</span>
<span class="nc" id="L487">        int n = ngroupsSnapshot;</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">        for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {</span>
<span class="nc" id="L489">            n += groupsSnapshot[i].activeGroupCount();</span>
        }
<span class="nc" id="L491">        return n;</span>
    }

    /**
     * Copies into the specified array references to every active
     * subgroup in this thread group and its subgroups.
     *
     * &lt;p&gt; An invocation of this method behaves in exactly the same
     * way as the invocation
     *
     * &lt;blockquote&gt;
     * {@linkplain #enumerate(ThreadGroup[], boolean) enumerate}{@code (list, true)}
     * &lt;/blockquote&gt;
     *
     * @param  list
     *         an array into which to put the list of thread groups
     *
     * @return  the number of thread groups put into the array
     *
     * @throws  SecurityException
     *          if {@linkplain #checkAccess checkAccess} determines that
     *          the current thread cannot access this thread group
     *
     * @since   JDK1.0
     */
    public int enumerate(ThreadGroup list[]) {
<span class="nc" id="L517">        checkAccess();</span>
<span class="nc" id="L518">        return enumerate(list, 0, true);</span>
    }

    /**
     * Copies into the specified array references to every active
     * subgroup in this thread group. If {@code recurse} is
     * {@code true}, this method recursively enumerates all subgroups of this
     * thread group and references to every active thread group in these
     * subgroups are also included.
     *
     * &lt;p&gt; An application might use the
     * {@linkplain #activeGroupCount activeGroupCount} method to
     * get an estimate of how big the array should be, however &lt;i&gt;if the
     * array is too short to hold all the thread groups, the extra thread
     * groups are silently ignored.&lt;/i&gt;  If it is critical to obtain every
     * active subgroup in this thread group, the caller should verify that
     * the returned int value is strictly less than the length of
     * {@code list}.
     *
     * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
     * that the method only be used for debugging and monitoring purposes.
     *
     * @param  list
     *         an array into which to put the list of thread groups
     *
     * @param  recurse
     *         if {@code true}, recursively enumerate all subgroups
     *
     * @return  the number of thread groups put into the array
     *
     * @throws  SecurityException
     *          if {@linkplain #checkAccess checkAccess} determines that
     *          the current thread cannot access this thread group
     *
     * @since   JDK1.0
     */
    public int enumerate(ThreadGroup list[], boolean recurse) {
<span class="nc" id="L555">        checkAccess();</span>
<span class="nc" id="L556">        return enumerate(list, 0, recurse);</span>
    }

    private int enumerate(ThreadGroup list[], int n, boolean recurse) {
<span class="nc" id="L560">        int ngroupsSnapshot = 0;</span>
<span class="nc" id="L561">        ThreadGroup[] groupsSnapshot = null;</span>
<span class="nc" id="L562">        synchronized (this) {</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L564">                return 0;</span>
            }
<span class="nc" id="L566">            int ng = ngroups;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">            if (ng &gt; list.length - n) {</span>
<span class="nc" id="L568">                ng = list.length - n;</span>
            }
<span class="nc bnc" id="L570" title="All 2 branches missed.">            if (ng &gt; 0) {</span>
<span class="nc" id="L571">                System.arraycopy(groups, 0, list, n, ng);</span>
<span class="nc" id="L572">                n += ng;</span>
            }
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if (recurse) {</span>
<span class="nc" id="L575">                ngroupsSnapshot = ngroups;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">                if (groups != null) {</span>
<span class="nc" id="L577">                    groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span>
                } else {
<span class="nc" id="L579">                    groupsSnapshot = null;</span>
                }
            }
<span class="nc" id="L582">        }</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (recurse) {</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {</span>
<span class="nc" id="L585">                n = groupsSnapshot[i].enumerate(list, n, true);</span>
            }
        }
<span class="nc" id="L588">        return n;</span>
    }

    /**
     * Stops all threads in this thread group.
     * &lt;p&gt;
     * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is
     * called with no arguments; this may result in a security exception.
     * &lt;p&gt;
     * This method then calls the &lt;code&gt;stop&lt;/code&gt; method on all the
     * threads in this thread group and in all of its subgroups.
     *
     * @exception  SecurityException  if the current thread is not allowed
     *               to access this thread group or any of the threads in
     *               the thread group.
     * @see        java.lang.SecurityException
     * @see        java.lang.Thread#stop()
     * @see        java.lang.ThreadGroup#checkAccess()
     * @since      JDK1.0
     * @deprecated    This method is inherently unsafe.  See
     *     {@link Thread#stop} for details.
     */
    @Deprecated
    public final void stop() {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (stopOrSuspend(false))</span>
<span class="nc" id="L613">            Thread.currentThread().stop();</span>
<span class="nc" id="L614">    }</span>

    /**
     * Interrupts all threads in this thread group.
     * &lt;p&gt;
     * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is
     * called with no arguments; this may result in a security exception.
     * &lt;p&gt;
     * This method then calls the &lt;code&gt;interrupt&lt;/code&gt; method on all the
     * threads in this thread group and in all of its subgroups.
     *
     * @exception  SecurityException  if the current thread is not allowed
     *               to access this thread group or any of the threads in
     *               the thread group.
     * @see        java.lang.Thread#interrupt()
     * @see        java.lang.SecurityException
     * @see        java.lang.ThreadGroup#checkAccess()
     * @since      1.2
     */
    public final void interrupt() {
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
<span class="nc" id="L636">        synchronized (this) {</span>
<span class="nc" id="L637">            checkAccess();</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">            for (int i = 0 ; i &lt; nthreads ; i++) {</span>
<span class="nc" id="L639">                threads[i].interrupt();</span>
            }
<span class="nc" id="L641">            ngroupsSnapshot = ngroups;</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (groups != null) {</span>
<span class="nc" id="L643">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span>
            } else {
<span class="nc" id="L645">                groupsSnapshot = null;</span>
            }
<span class="nc" id="L647">        }</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">        for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {</span>
<span class="nc" id="L649">            groupsSnapshot[i].interrupt();</span>
        }
<span class="nc" id="L651">    }</span>

    /**
     * Suspends all threads in this thread group.
     * &lt;p&gt;
     * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is
     * called with no arguments; this may result in a security exception.
     * &lt;p&gt;
     * This method then calls the &lt;code&gt;suspend&lt;/code&gt; method on all the
     * threads in this thread group and in all of its subgroups.
     *
     * @exception  SecurityException  if the current thread is not allowed
     *               to access this thread group or any of the threads in
     *               the thread group.
     * @see        java.lang.Thread#suspend()
     * @see        java.lang.SecurityException
     * @see        java.lang.ThreadGroup#checkAccess()
     * @since      JDK1.0
     * @deprecated    This method is inherently deadlock-prone.  See
     *     {@link Thread#suspend} for details.
     */
    @Deprecated
    @SuppressWarnings(&quot;deprecation&quot;)
    public final void suspend() {
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">        if (stopOrSuspend(true))</span>
<span class="fc" id="L676">            Thread.currentThread().suspend();</span>
<span class="fc" id="L677">    }</span>

    /**
     * Helper method: recursively stops or suspends (as directed by the
     * boolean argument) all of the threads in this thread group and its
     * subgroups, except the current thread.  This method returns true
     * if (and only if) the current thread is found to be in this thread
     * group or one of its subgroups.
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    private boolean stopOrSuspend(boolean suspend) {
<span class="fc" id="L688">        boolean suicide = false;</span>
<span class="fc" id="L689">        Thread us = Thread.currentThread();</span>
        int ngroupsSnapshot;
<span class="fc" id="L691">        ThreadGroup[] groupsSnapshot = null;</span>
<span class="fc" id="L692">        synchronized (this) {</span>
<span class="fc" id="L693">            checkAccess();</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">            for (int i = 0 ; i &lt; nthreads ; i++) {</span>
<span class="fc bfc" id="L695" title="All 2 branches covered.">                if (threads[i]==us)</span>
<span class="fc" id="L696">                    suicide = true;</span>
<span class="pc bpc" id="L697" title="1 of 2 branches missed.">                else if (suspend)</span>
<span class="fc" id="L698">                    threads[i].suspend();</span>
                else
<span class="nc" id="L700">                    threads[i].stop();</span>
            }

<span class="fc" id="L703">            ngroupsSnapshot = ngroups;</span>
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">            if (groups != null) {</span>
<span class="nc" id="L705">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span>
            }
<span class="pc" id="L707">        }</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">        for (int i = 0 ; i &lt; ngroupsSnapshot ; i++)</span>
<span class="nc bnc" id="L709" title="All 4 branches missed.">            suicide = groupsSnapshot[i].stopOrSuspend(suspend) || suicide;</span>

<span class="fc" id="L711">        return suicide;</span>
    }

    /**
     * Resumes all threads in this thread group.
     * &lt;p&gt;
     * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is
     * called with no arguments; this may result in a security exception.
     * &lt;p&gt;
     * This method then calls the &lt;code&gt;resume&lt;/code&gt; method on all the
     * threads in this thread group and in all of its sub groups.
     *
     * @exception  SecurityException  if the current thread is not allowed to
     *               access this thread group or any of the threads in the
     *               thread group.
     * @see        java.lang.SecurityException
     * @see        java.lang.Thread#resume()
     * @see        java.lang.ThreadGroup#checkAccess()
     * @since      JDK1.0
     * @deprecated    This method is used solely in conjunction with
     *      &lt;tt&gt;Thread.suspend&lt;/tt&gt; and &lt;tt&gt;ThreadGroup.suspend&lt;/tt&gt;,
     *       both of which have been deprecated, as they are inherently
     *       deadlock-prone.  See {@link Thread#suspend} for details.
     */
    @Deprecated
    @SuppressWarnings(&quot;deprecation&quot;)
    public final void resume() {
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
<span class="nc" id="L740">        synchronized (this) {</span>
<span class="nc" id="L741">            checkAccess();</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            for (int i = 0 ; i &lt; nthreads ; i++) {</span>
<span class="nc" id="L743">                threads[i].resume();</span>
            }
<span class="nc" id="L745">            ngroupsSnapshot = ngroups;</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">            if (groups != null) {</span>
<span class="nc" id="L747">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span>
            } else {
<span class="nc" id="L749">                groupsSnapshot = null;</span>
            }
<span class="nc" id="L751">        }</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">        for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {</span>
<span class="nc" id="L753">            groupsSnapshot[i].resume();</span>
        }
<span class="nc" id="L755">    }</span>

    /**
     * Destroys this thread group and all of its subgroups. This thread
     * group must be empty, indicating that all threads that had been in
     * this thread group have since stopped.
     * &lt;p&gt;
     * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread group is
     * called with no arguments; this may result in a security exception.
     *
     * @exception  IllegalThreadStateException  if the thread group is not
     *               empty or if the thread group has already been destroyed.
     * @exception  SecurityException  if the current thread cannot modify this
     *               thread group.
     * @see        java.lang.ThreadGroup#checkAccess()
     * @since      JDK1.0
     */
    public final void destroy() {
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
<span class="fc" id="L775">        synchronized (this) {</span>
<span class="fc" id="L776">            checkAccess();</span>
<span class="pc bpc" id="L777" title="2 of 4 branches missed.">            if (destroyed || (nthreads &gt; 0)) {</span>
<span class="nc" id="L778">                throw new IllegalThreadStateException();</span>
            }
<span class="fc" id="L780">            ngroupsSnapshot = ngroups;</span>
<span class="pc bpc" id="L781" title="1 of 2 branches missed.">            if (groups != null) {</span>
<span class="nc" id="L782">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span>
            } else {
<span class="fc" id="L784">                groupsSnapshot = null;</span>
            }
<span class="pc bpc" id="L786" title="1 of 2 branches missed.">            if (parent != null) {</span>
<span class="fc" id="L787">                destroyed = true;</span>
<span class="fc" id="L788">                ngroups = 0;</span>
<span class="fc" id="L789">                groups = null;</span>
<span class="fc" id="L790">                nthreads = 0;</span>
<span class="fc" id="L791">                threads = null;</span>
            }
<span class="pc" id="L793">        }</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">        for (int i = 0 ; i &lt; ngroupsSnapshot ; i += 1) {</span>
<span class="nc" id="L795">            groupsSnapshot[i].destroy();</span>
        }
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">        if (parent != null) {</span>
<span class="fc" id="L798">            parent.remove(this);</span>
        }
<span class="fc" id="L800">    }</span>

    /**
     * Adds the specified Thread group to this group.
     * @param g the specified Thread group to be added
     * @exception IllegalThreadStateException If the Thread group has been destroyed.
     */
    private final void add(ThreadGroup g){
<span class="fc" id="L808">        synchronized (this) {</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L810">                throw new IllegalThreadStateException();</span>
            }
<span class="fc bfc" id="L812" title="All 2 branches covered.">            if (groups == null) {</span>
<span class="fc" id="L813">                groups = new ThreadGroup[4];</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">            } else if (ngroups == groups.length) {</span>
<span class="fc" id="L815">                groups = Arrays.copyOf(groups, ngroups * 2);</span>
            }
<span class="fc" id="L817">            groups[ngroups] = g;</span>

            // This is done last so it doesn't matter in case the
            // thread is killed
<span class="fc" id="L821">            ngroups++;</span>
<span class="pc" id="L822">        }</span>
<span class="fc" id="L823">    }</span>

    /**
     * Removes the specified Thread group from this group.
     * @param g the Thread group to be removed
     * @return if this Thread has already been destroyed.
     */
    private void remove(ThreadGroup g) {
<span class="fc" id="L831">        synchronized (this) {</span>
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L833">                return;</span>
            }
<span class="pc bpc" id="L835" title="1 of 2 branches missed.">            for (int i = 0 ; i &lt; ngroups ; i++) {</span>
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">                if (groups[i] == g) {</span>
<span class="fc" id="L837">                    ngroups -= 1;</span>
<span class="fc" id="L838">                    System.arraycopy(groups, i + 1, groups, i, ngroups - i);</span>
                    // Zap dangling reference to the dead group so that
                    // the garbage collector will collect it.
<span class="fc" id="L841">                    groups[ngroups] = null;</span>
<span class="fc" id="L842">                    break;</span>
                }
            }
<span class="fc bfc" id="L845" title="All 2 branches covered.">            if (nthreads == 0) {</span>
<span class="fc" id="L846">                notifyAll();</span>
            }
<span class="pc bpc" id="L848" title="4 of 8 branches missed.">            if (daemon &amp;&amp; (nthreads == 0) &amp;&amp;</span>
                (nUnstartedThreads == 0) &amp;&amp; (ngroups == 0))
            {
<span class="nc" id="L851">                destroy();</span>
            }
<span class="pc" id="L853">        }</span>
<span class="fc" id="L854">    }</span>


    /**
     * Increments the count of unstarted threads in the thread group.
     * Unstarted threads are not added to the thread group so that they
     * can be collected if they are never started, but they must be
     * counted so that daemon thread groups with unstarted threads in
     * them are not destroyed.
     */
    void addUnstarted() {
<span class="fc" id="L865">        synchronized(this) {</span>
<span class="fc bfc" id="L866" title="All 2 branches covered.">            if (destroyed) {</span>
<span class="fc" id="L867">                throw new IllegalThreadStateException();</span>
            }
<span class="fc" id="L869">            nUnstartedThreads++;</span>
<span class="fc" id="L870">        }</span>
<span class="fc" id="L871">    }</span>

    /**
     * Adds the specified thread to this thread group.
     *
     * &lt;p&gt; Note: This method is called from both library code
     * and the Virtual Machine. It is called from VM to add
     * certain system threads to the system thread group.
     *
     * @param  t
     *         the Thread to be added
     *
     * @throws  IllegalThreadStateException
     *          if the Thread group has been destroyed
     */
    void add(Thread t) {
<span class="fc" id="L887">        synchronized (this) {</span>
<span class="pc bpc" id="L888" title="1 of 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L889">                throw new IllegalThreadStateException();</span>
            }
<span class="fc bfc" id="L891" title="All 2 branches covered.">            if (threads == null) {</span>
<span class="fc" id="L892">                threads = new Thread[4];</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">            } else if (nthreads == threads.length) {</span>
<span class="fc" id="L894">                threads = Arrays.copyOf(threads, nthreads * 2);</span>
            }
<span class="fc" id="L896">            threads[nthreads] = t;</span>

            // This is done last so it doesn't matter in case the
            // thread is killed
<span class="fc" id="L900">            nthreads++;</span>

            // The thread is now a fully fledged member of the group, even
            // though it may, or may not, have been started yet. It will prevent
            // the group from being destroyed so the unstarted Threads count is
            // decremented.
<span class="fc" id="L906">            nUnstartedThreads--;</span>
<span class="pc" id="L907">        }</span>
<span class="fc" id="L908">    }</span>

    /**
     * Notifies the group that the thread {@code t} has failed
     * an attempt to start.
     *
     * &lt;p&gt; The state of this thread group is rolled back as if the
     * attempt to start the thread has never occurred. The thread is again
     * considered an unstarted member of the thread group, and a subsequent
     * attempt to start the thread is permitted.
     *
     * @param  t
     *         the Thread whose start method was invoked
     */
    void threadStartFailed(Thread t) {
<span class="nc" id="L923">        synchronized(this) {</span>
<span class="nc" id="L924">            remove(t);</span>
<span class="nc" id="L925">            nUnstartedThreads++;</span>
<span class="nc" id="L926">        }</span>
<span class="nc" id="L927">    }</span>

    /**
     * Notifies the group that the thread {@code t} has terminated.
     *
     * &lt;p&gt; Destroy the group if all of the following conditions are
     * true: this is a daemon thread group; there are no more alive
     * or unstarted threads in the group; there are no subgroups in
     * this thread group.
     *
     * @param  t
     *         the Thread that has terminated
     */
    void threadTerminated(Thread t) {
<span class="fc" id="L941">        synchronized (this) {</span>
<span class="fc" id="L942">            remove(t);</span>

<span class="fc bfc" id="L944" title="All 2 branches covered.">            if (nthreads == 0) {</span>
<span class="fc" id="L945">                notifyAll();</span>
            }
<span class="pc bpc" id="L947" title="3 of 8 branches missed.">            if (daemon &amp;&amp; (nthreads == 0) &amp;&amp;</span>
                (nUnstartedThreads == 0) &amp;&amp; (ngroups == 0))
            {
<span class="fc" id="L950">                destroy();</span>
            }
<span class="pc" id="L952">        }</span>
<span class="fc" id="L953">    }</span>

    /**
     * Removes the specified Thread from this group. Invoking this method
     * on a thread group that has been destroyed has no effect.
     *
     * @param  t
     *         the Thread to be removed
     */
    private void remove(Thread t) {
<span class="fc" id="L963">        synchronized (this) {</span>
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">            if (destroyed) {</span>
<span class="nc" id="L965">                return;</span>
            }
<span class="pc bpc" id="L967" title="1 of 2 branches missed.">            for (int i = 0 ; i &lt; nthreads ; i++) {</span>
<span class="fc bfc" id="L968" title="All 2 branches covered.">                if (threads[i] == t) {</span>
<span class="fc" id="L969">                    System.arraycopy(threads, i + 1, threads, i, --nthreads - i);</span>
                    // Zap dangling reference to the dead thread so that
                    // the garbage collector will collect it.
<span class="fc" id="L972">                    threads[nthreads] = null;</span>
<span class="fc" id="L973">                    break;</span>
                }
            }
<span class="pc" id="L976">        }</span>
<span class="fc" id="L977">    }</span>

    /**
     * Prints information about this thread group to the standard
     * output. This method is useful only for debugging.
     *
     * @since   JDK1.0
     */
    public void list() {
<span class="nc" id="L986">        list(System.out, 0);</span>
<span class="nc" id="L987">    }</span>
    void list(PrintStream out, int indent) {
        int ngroupsSnapshot;
        ThreadGroup[] groupsSnapshot;
<span class="nc" id="L991">        synchronized (this) {</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">            for (int j = 0 ; j &lt; indent ; j++) {</span>
<span class="nc" id="L993">                out.print(&quot; &quot;);</span>
            }
<span class="nc" id="L995">            out.println(this);</span>
<span class="nc" id="L996">            indent += 4;</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">            for (int i = 0 ; i &lt; nthreads ; i++) {</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">                for (int j = 0 ; j &lt; indent ; j++) {</span>
<span class="nc" id="L999">                    out.print(&quot; &quot;);</span>
                }
<span class="nc" id="L1001">                out.println(threads[i]);</span>
            }
<span class="nc" id="L1003">            ngroupsSnapshot = ngroups;</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">            if (groups != null) {</span>
<span class="nc" id="L1005">                groupsSnapshot = Arrays.copyOf(groups, ngroupsSnapshot);</span>
            } else {
<span class="nc" id="L1007">                groupsSnapshot = null;</span>
            }
<span class="nc" id="L1009">        }</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        for (int i = 0 ; i &lt; ngroupsSnapshot ; i++) {</span>
<span class="nc" id="L1011">            groupsSnapshot[i].list(out, indent);</span>
        }
<span class="nc" id="L1013">    }</span>

    /**
     * Called by the Java Virtual Machine when a thread in this
     * thread group stops because of an uncaught exception, and the thread
     * does not have a specific {@link Thread.UncaughtExceptionHandler}
     * installed.
     * &lt;p&gt;
     * The &lt;code&gt;uncaughtException&lt;/code&gt; method of
     * &lt;code&gt;ThreadGroup&lt;/code&gt; does the following:
     * &lt;ul&gt;
     * &lt;li&gt;If this thread group has a parent thread group, the
     *     &lt;code&gt;uncaughtException&lt;/code&gt; method of that parent is called
     *     with the same two arguments.
     * &lt;li&gt;Otherwise, this method checks to see if there is a
     *     {@linkplain Thread#getDefaultUncaughtExceptionHandler default
     *     uncaught exception handler} installed, and if so, its
     *     &lt;code&gt;uncaughtException&lt;/code&gt; method is called with the same
     *     two arguments.
     * &lt;li&gt;Otherwise, this method determines if the &lt;code&gt;Throwable&lt;/code&gt;
     *     argument is an instance of {@link ThreadDeath}. If so, nothing
     *     special is done. Otherwise, a message containing the
     *     thread's name, as returned from the thread's {@link
     *     Thread#getName getName} method, and a stack backtrace,
     *     using the &lt;code&gt;Throwable&lt;/code&gt;'s {@link
     *     Throwable#printStackTrace printStackTrace} method, is
     *     printed to the {@linkplain System#err standard error stream}.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * Applications can override this method in subclasses of
     * &lt;code&gt;ThreadGroup&lt;/code&gt; to provide alternative handling of
     * uncaught exceptions.
     *
     * @param   t   the thread that is about to exit.
     * @param   e   the uncaught exception.
     * @since   JDK1.0
     */
    public void uncaughtException(Thread t, Throwable e) {
<span class="fc bfc" id="L1051" title="All 2 branches covered.">        if (parent != null) {</span>
<span class="fc" id="L1052">            parent.uncaughtException(t, e);</span>
        } else {
            Thread.UncaughtExceptionHandler ueh =
<span class="fc" id="L1055">                Thread.getDefaultUncaughtExceptionHandler();</span>
<span class="fc bfc" id="L1056" title="All 2 branches covered.">            if (ueh != null) {</span>
<span class="fc" id="L1057">                ueh.uncaughtException(t, e);</span>
<span class="pc bpc" id="L1058" title="1 of 2 branches missed.">            } else if (!(e instanceof ThreadDeath)) {</span>
<span class="fc" id="L1059">                System.err.print(&quot;Exception in thread \&quot;&quot;</span>
<span class="fc" id="L1060">                                 + t.getName() + &quot;\&quot; &quot;);</span>
<span class="fc" id="L1061">                e.printStackTrace(System.err);</span>
            }
        }
<span class="fc" id="L1064">    }</span>

    /**
     * Used by VM to control lowmem implicit suspension.
     *
     * @param b boolean to allow or disallow suspension
     * @return true on success
     * @since   JDK1.1
     * @deprecated The definition of this call depends on {@link #suspend},
     *             which is deprecated.  Further, the behavior of this call
     *             was never specified.
     */
    @Deprecated
    public boolean allowThreadSuspension(boolean b) {
<span class="nc" id="L1078">        this.vmAllowSuspension = b;</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">        if (!b) {</span>
<span class="nc" id="L1080">            VM.unsuspendSomeThreads();</span>
        }
<span class="nc" id="L1082">        return true;</span>
    }

    /**
     * Returns a string representation of this Thread group.
     *
     * @return  a string representation of this thread group.
     * @since   JDK1.0
     */
    public String toString() {
<span class="nc" id="L1092">        return getClass().getName() + &quot;[name=&quot; + getName() + &quot;,maxpri=&quot; + maxPriority + &quot;]&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>