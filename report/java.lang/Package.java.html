<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Package.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang</a> &gt; <span class="el_source">Package.java</span></div><h1>Package.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang;

import java.lang.reflect.AnnotatedElement;
import java.io.InputStream;
import java.util.Enumeration;

import java.util.StringTokenizer;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URL;
import java.net.MalformedURLException;
import java.security.AccessController;
import java.security.PrivilegedAction;

import java.util.jar.JarInputStream;
import java.util.jar.Manifest;
import java.util.jar.Attributes;
import java.util.jar.Attributes.Name;
import java.util.jar.JarException;
import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;

import sun.net.www.ParseUtil;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;

import java.lang.annotation.Annotation;

/**
 * {@code Package} objects contain version information
 * about the implementation and specification of a Java package.
 * This versioning information is retrieved and made available
 * by the {@link ClassLoader} instance that
 * loaded the class(es).  Typically, it is stored in the manifest that is
 * distributed with the classes.
 *
 * &lt;p&gt;The set of classes that make up the package may implement a
 * particular specification and if so the specification title, version number,
 * and vendor strings identify that specification.
 * An application can ask if the package is
 * compatible with a particular version, see the {@link
 * #isCompatibleWith isCompatibleWith}
 * method for details.
 *
 * &lt;p&gt;Specification version numbers use a syntax that consists of nonnegative
 * decimal integers separated by periods &quot;.&quot;, for example &quot;2.0&quot; or
 * &quot;1.2.3.4.5.6.7&quot;.  This allows an extensible number to be used to represent
 * major, minor, micro, etc. versions.  The version specification is described
 * by the following formal grammar:
 * &lt;blockquote&gt;
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;i&gt;SpecificationVersion:&lt;/i&gt;
 * &lt;dd&gt;&lt;i&gt;Digits RefinedVersion&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;

 * &lt;dt&gt;&lt;i&gt;RefinedVersion:&lt;/i&gt;
 * &lt;dd&gt;{@code .} &lt;i&gt;Digits&lt;/i&gt;
 * &lt;dd&gt;{@code .} &lt;i&gt;Digits RefinedVersion&lt;/i&gt;
 *
 * &lt;dt&gt;&lt;i&gt;Digits:&lt;/i&gt;
 * &lt;dd&gt;&lt;i&gt;Digit&lt;/i&gt;
 * &lt;dd&gt;&lt;i&gt;Digits&lt;/i&gt;
 *
 * &lt;dt&gt;&lt;i&gt;Digit:&lt;/i&gt;
 * &lt;dd&gt;any character for which {@link Character#isDigit} returns {@code true},
 * e.g. 0, 1, 2, ...
 * &lt;/dl&gt;
 * &lt;/blockquote&gt;
 *
 * &lt;p&gt;The implementation title, version, and vendor strings identify an
 * implementation and are made available conveniently to enable accurate
 * reporting of the packages involved when a problem occurs. The contents
 * all three implementation strings are vendor specific. The
 * implementation version strings have no specified syntax and should
 * only be compared for equality with desired version identifiers.
 *
 * &lt;p&gt;Within each {@code ClassLoader} instance all classes from the same
 * java package have the same Package object.  The static methods allow a package
 * to be found by name or the set of all packages known to the current class
 * loader to be found.
 *
 * @see ClassLoader#definePackage
 */
public class Package implements java.lang.reflect.AnnotatedElement {
    /**
     * Return the name of this package.
     *
     * @return  The fully-qualified name of this package as defined in section 6.5.3 of
     *          &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
     *          for example, {@code java.lang}
     */
    public String getName() {
<span class="fc" id="L120">        return pkgName;</span>
    }


    /**
     * Return the title of the specification that this package implements.
     * @return the specification title, null is returned if it is not known.
     */
    public String getSpecificationTitle() {
<span class="nc" id="L129">        return specTitle;</span>
    }

    /**
     * Returns the version number of the specification
     * that this package implements.
     * This version string must be a sequence of nonnegative decimal
     * integers separated by &quot;.&quot;'s and may have leading zeros.
     * When version strings are compared the most significant
     * numbers are compared.
     * @return the specification version, null is returned if it is not known.
     */
    public String getSpecificationVersion() {
<span class="nc" id="L142">        return specVersion;</span>
    }

    /**
     * Return the name of the organization, vendor,
     * or company that owns and maintains the specification
     * of the classes that implement this package.
     * @return the specification vendor, null is returned if it is not known.
     */
    public String getSpecificationVendor() {
<span class="nc" id="L152">        return specVendor;</span>
    }

    /**
     * Return the title of this package.
     * @return the title of the implementation, null is returned if it is not known.
     */
    public String getImplementationTitle() {
<span class="nc" id="L160">        return implTitle;</span>
    }

    /**
     * Return the version of this implementation. It consists of any string
     * assigned by the vendor of this implementation and does
     * not have any particular syntax specified or expected by the Java
     * runtime. It may be compared for equality with other
     * package version strings used for this implementation
     * by this vendor for this package.
     * @return the version of the implementation, null is returned if it is not known.
     */
    public String getImplementationVersion() {
<span class="nc" id="L173">        return implVersion;</span>
    }

    /**
     * Returns the name of the organization,
     * vendor or company that provided this implementation.
     * @return the vendor that implemented this package..
     */
    public String getImplementationVendor() {
<span class="nc" id="L182">        return implVendor;</span>
    }

    /**
     * Returns true if this package is sealed.
     *
     * @return true if the package is sealed, false otherwise
     */
    public boolean isSealed() {
<span class="fc bfc" id="L191" title="All 2 branches covered.">        return sealBase != null;</span>
    }

    /**
     * Returns true if this package is sealed with respect to the specified
     * code source url.
     *
     * @param url the code source url
     * @return true if this package is sealed with respect to url
     */
    public boolean isSealed(URL url) {
<span class="fc" id="L202">        return url.equals(sealBase);</span>
    }

    /**
     * Compare this package's specification version with a
     * desired version. It returns true if
     * this packages specification version number is greater than or equal
     * to the desired version number. &lt;p&gt;
     *
     * Version numbers are compared by sequentially comparing corresponding
     * components of the desired and specification strings.
     * Each component is converted as a decimal integer and the values
     * compared.
     * If the specification value is greater than the desired
     * value true is returned. If the value is less false is returned.
     * If the values are equal the period is skipped and the next pair of
     * components is compared.
     *
     * @param desired the version string of the desired version.
     * @return true if this package's version number is greater
     *          than or equal to the desired version number
     *
     * @exception NumberFormatException if the desired or current version
     *          is not of the correct dotted form.
     */
    public boolean isCompatibleWith(String desired)
        throws NumberFormatException
    {
<span class="nc bnc" id="L230" title="All 4 branches missed.">        if (specVersion == null || specVersion.length() &lt; 1) {</span>
<span class="nc" id="L231">            throw new NumberFormatException(&quot;Empty version string&quot;);</span>
        }

<span class="nc" id="L234">        String [] sa = specVersion.split(&quot;\\.&quot;, -1);</span>
<span class="nc" id="L235">        int [] si = new int[sa.length];</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        for (int i = 0; i &lt; sa.length; i++) {</span>
<span class="nc" id="L237">            si[i] = Integer.parseInt(sa[i]);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            if (si[i] &lt; 0)</span>
<span class="nc" id="L239">                throw NumberFormatException.forInputString(&quot;&quot; + si[i]);</span>
        }

<span class="nc" id="L242">        String [] da = desired.split(&quot;\\.&quot;, -1);</span>
<span class="nc" id="L243">        int [] di = new int[da.length];</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        for (int i = 0; i &lt; da.length; i++) {</span>
<span class="nc" id="L245">            di[i] = Integer.parseInt(da[i]);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if (di[i] &lt; 0)</span>
<span class="nc" id="L247">                throw NumberFormatException.forInputString(&quot;&quot; + di[i]);</span>
        }

<span class="nc" id="L250">        int len = Math.max(di.length, si.length);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">            int d = (i &lt; di.length ? di[i] : 0);</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            int s = (i &lt; si.length ? si[i] : 0);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (s &lt; d)</span>
<span class="nc" id="L255">                return false;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">            if (s &gt; d)</span>
<span class="nc" id="L257">                return true;</span>
        }
<span class="nc" id="L259">        return true;</span>
    }

    /**
     * Find a package by name in the callers {@code ClassLoader} instance.
     * The callers {@code ClassLoader} instance is used to find the package
     * instance corresponding to the named class. If the callers
     * {@code ClassLoader} instance is null then the set of packages loaded
     * by the system {@code ClassLoader} instance is searched to find the
     * named package. &lt;p&gt;
     *
     * Packages have attributes for versions and specifications only if the class
     * loader created the package instance with the appropriate attributes. Typically,
     * those attributes are defined in the manifests that accompany the classes.
     *
     * @param name a package name, for example, java.lang.
     * @return the package of the requested name. It may be null if no package
     *          information is available from the archive or codebase.
     */
    @CallerSensitive
    public static Package getPackage(String name) {
<span class="fc" id="L280">        ClassLoader l = ClassLoader.getClassLoader(Reflection.getCallerClass());</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if (l != null) {</span>
<span class="fc" id="L282">            return l.getPackage(name);</span>
        } else {
<span class="nc" id="L284">            return getSystemPackage(name);</span>
        }
    }

    /**
     * Get all the packages currently known for the caller's {@code ClassLoader}
     * instance.  Those packages correspond to classes loaded via or accessible by
     * name to that {@code ClassLoader} instance.  If the caller's
     * {@code ClassLoader} instance is the bootstrap {@code ClassLoader}
     * instance, which may be represented by {@code null} in some implementations,
     * only packages corresponding to classes loaded by the bootstrap
     * {@code ClassLoader} instance will be returned.
     *
     * @return a new array of packages known to the callers {@code ClassLoader}
     * instance.  An zero length array is returned if none are known.
     */
    @CallerSensitive
    public static Package[] getPackages() {
<span class="nc" id="L302">        ClassLoader l = ClassLoader.getClassLoader(Reflection.getCallerClass());</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (l != null) {</span>
<span class="nc" id="L304">            return l.getPackages();</span>
        } else {
<span class="nc" id="L306">            return getSystemPackages();</span>
        }
    }

    /**
     * Get the package for the specified class.
     * The class's class loader is used to find the package instance
     * corresponding to the specified class. If the class loader
     * is the bootstrap class loader, which may be represented by
     * {@code null} in some implementations, then the set of packages
     * loaded by the bootstrap class loader is searched to find the package.
     * &lt;p&gt;
     * Packages have attributes for versions and specifications only
     * if the class loader created the package
     * instance with the appropriate attributes. Typically those
     * attributes are defined in the manifests that accompany
     * the classes.
     *
     * @param c the class to get the package of.
     * @return the package of the class. It may be null if no package
     *          information is available from the archive or codebase.  */
    static Package getPackage(Class&lt;?&gt; c) {
<span class="fc" id="L328">        String name = c.getName();</span>
<span class="fc" id="L329">        int i = name.lastIndexOf('.');</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (i != -1) {</span>
<span class="fc" id="L331">            name = name.substring(0, i);</span>
<span class="fc" id="L332">            ClassLoader cl = c.getClassLoader();</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">            if (cl != null) {</span>
<span class="fc" id="L334">                return cl.getPackage(name);</span>
            } else {
<span class="fc" id="L336">                return getSystemPackage(name);</span>
            }
        } else {
<span class="fc" id="L339">            return null;</span>
        }
    }

    /**
     * Return the hash code computed from the package name.
     * @return the hash code computed from the package name.
     */
    public int hashCode(){
<span class="fc" id="L348">        return pkgName.hashCode();</span>
    }

    /**
     * Returns the string representation of this Package.
     * Its value is the string &quot;package &quot; and the package name.
     * If the package title is defined it is appended.
     * If the package version is defined it is appended.
     * @return the string representation of the package.
     */
    public String toString() {
<span class="nc" id="L359">        String spec = specTitle;</span>
<span class="nc" id="L360">        String ver =  specVersion;</span>
<span class="nc bnc" id="L361" title="All 4 branches missed.">        if (spec != null &amp;&amp; spec.length() &gt; 0)</span>
<span class="nc" id="L362">            spec = &quot;, &quot; + spec;</span>
        else
<span class="nc" id="L364">            spec = &quot;&quot;;</span>
<span class="nc bnc" id="L365" title="All 4 branches missed.">        if (ver != null &amp;&amp; ver.length() &gt; 0)</span>
<span class="nc" id="L366">            ver = &quot;, version &quot; + ver;</span>
        else
<span class="nc" id="L368">            ver = &quot;&quot;;</span>
<span class="nc" id="L369">        return &quot;package &quot; + pkgName + spec + ver;</span>
    }

    private Class&lt;?&gt; getPackageInfo() {
<span class="fc bfc" id="L373" title="All 2 branches covered.">        if (packageInfo == null) {</span>
            try {
<span class="fc" id="L375">                packageInfo = Class.forName(pkgName + &quot;.package-info&quot;, false, loader);</span>
<span class="fc" id="L376">            } catch (ClassNotFoundException ex) {</span>
                // store a proxy for the package info that has no annotations
<span class="nc" id="L378">                class PackageInfoProxy {}</span>
<span class="fc" id="L379">                packageInfo = PackageInfoProxy.class;</span>
<span class="fc" id="L380">            }</span>
        }
<span class="fc" id="L382">        return packageInfo;</span>
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     * @since 1.5
     */
    public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
<span class="fc" id="L390">        return getPackageInfo().getAnnotation(annotationClass);</span>
    }

    /**
     * {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     * @since 1.5
     */
    @Override
    public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
<span class="nc" id="L400">        return AnnotatedElement.super.isAnnotationPresent(annotationClass);</span>
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    public  &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
<span class="fc" id="L409">        return getPackageInfo().getAnnotationsByType(annotationClass);</span>
    }

    /**
     * @since 1.5
     */
    public Annotation[] getAnnotations() {
<span class="fc" id="L416">        return getPackageInfo().getAnnotations();</span>
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
<span class="nc" id="L425">        return getPackageInfo().getDeclaredAnnotation(annotationClass);</span>
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
<span class="nc" id="L434">        return getPackageInfo().getDeclaredAnnotationsByType(annotationClass);</span>
    }

    /**
     * @since 1.5
     */
    public Annotation[] getDeclaredAnnotations()  {
<span class="nc" id="L441">        return getPackageInfo().getDeclaredAnnotations();</span>
    }

    /**
     * Construct a package instance with the specified version
     * information.
     * @param name the name of the package
     * @param spectitle the title of the specification
     * @param specversion the version of the specification
     * @param specvendor the organization that maintains the specification
     * @param impltitle the title of the implementation
     * @param implversion the version of the implementation
     * @param implvendor the organization that maintains the implementation
     */
    Package(String name,
            String spectitle, String specversion, String specvendor,
            String impltitle, String implversion, String implvendor,
            URL sealbase, ClassLoader loader)
<span class="fc" id="L459">    {</span>
<span class="fc" id="L460">        pkgName = name;</span>
<span class="fc" id="L461">        implTitle = impltitle;</span>
<span class="fc" id="L462">        implVersion = implversion;</span>
<span class="fc" id="L463">        implVendor = implvendor;</span>
<span class="fc" id="L464">        specTitle = spectitle;</span>
<span class="fc" id="L465">        specVersion = specversion;</span>
<span class="fc" id="L466">        specVendor = specvendor;</span>
<span class="fc" id="L467">        sealBase = sealbase;</span>
<span class="fc" id="L468">        this.loader = loader;</span>
<span class="fc" id="L469">    }</span>

    /*
     * Construct a package using the attributes from the specified manifest.
     *
     * @param name the package name
     * @param man the optional manifest for the package
     * @param url the optional code source url for the package
     */
<span class="fc" id="L478">    private Package(String name, Manifest man, URL url, ClassLoader loader) {</span>
<span class="fc" id="L479">        String path = name.replace('.', '/').concat(&quot;/&quot;);</span>
<span class="fc" id="L480">        String sealed = null;</span>
<span class="fc" id="L481">        String specTitle= null;</span>
<span class="fc" id="L482">        String specVersion= null;</span>
<span class="fc" id="L483">        String specVendor= null;</span>
<span class="fc" id="L484">        String implTitle= null;</span>
<span class="fc" id="L485">        String implVersion= null;</span>
<span class="fc" id="L486">        String implVendor= null;</span>
<span class="fc" id="L487">        URL sealBase= null;</span>
<span class="fc" id="L488">        Attributes attr = man.getAttributes(path);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">        if (attr != null) {</span>
<span class="nc" id="L490">            specTitle   = attr.getValue(Name.SPECIFICATION_TITLE);</span>
<span class="nc" id="L491">            specVersion = attr.getValue(Name.SPECIFICATION_VERSION);</span>
<span class="nc" id="L492">            specVendor  = attr.getValue(Name.SPECIFICATION_VENDOR);</span>
<span class="nc" id="L493">            implTitle   = attr.getValue(Name.IMPLEMENTATION_TITLE);</span>
<span class="nc" id="L494">            implVersion = attr.getValue(Name.IMPLEMENTATION_VERSION);</span>
<span class="nc" id="L495">            implVendor  = attr.getValue(Name.IMPLEMENTATION_VENDOR);</span>
<span class="nc" id="L496">            sealed      = attr.getValue(Name.SEALED);</span>
        }
<span class="fc" id="L498">        attr = man.getMainAttributes();</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        if (attr != null) {</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">            if (specTitle == null) {</span>
<span class="fc" id="L501">                specTitle = attr.getValue(Name.SPECIFICATION_TITLE);</span>
            }
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">            if (specVersion == null) {</span>
<span class="fc" id="L504">                specVersion = attr.getValue(Name.SPECIFICATION_VERSION);</span>
            }
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">            if (specVendor == null) {</span>
<span class="fc" id="L507">                specVendor = attr.getValue(Name.SPECIFICATION_VENDOR);</span>
            }
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">            if (implTitle == null) {</span>
<span class="fc" id="L510">                implTitle = attr.getValue(Name.IMPLEMENTATION_TITLE);</span>
            }
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">            if (implVersion == null) {</span>
<span class="fc" id="L513">                implVersion = attr.getValue(Name.IMPLEMENTATION_VERSION);</span>
            }
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">            if (implVendor == null) {</span>
<span class="fc" id="L516">                implVendor = attr.getValue(Name.IMPLEMENTATION_VENDOR);</span>
            }
<span class="pc bpc" id="L518" title="1 of 2 branches missed.">            if (sealed == null) {</span>
<span class="fc" id="L519">                sealed = attr.getValue(Name.SEALED);</span>
            }
        }
<span class="pc bpc" id="L522" title="1 of 2 branches missed.">        if (&quot;true&quot;.equalsIgnoreCase(sealed)) {</span>
<span class="nc" id="L523">            sealBase = url;</span>
        }
<span class="fc" id="L525">        pkgName = name;</span>
<span class="fc" id="L526">        this.specTitle = specTitle;</span>
<span class="fc" id="L527">        this.specVersion = specVersion;</span>
<span class="fc" id="L528">        this.specVendor = specVendor;</span>
<span class="fc" id="L529">        this.implTitle = implTitle;</span>
<span class="fc" id="L530">        this.implVersion = implVersion;</span>
<span class="fc" id="L531">        this.implVendor = implVendor;</span>
<span class="fc" id="L532">        this.sealBase = sealBase;</span>
<span class="fc" id="L533">        this.loader = loader;</span>
<span class="fc" id="L534">    }</span>

    /*
     * Returns the loaded system package for the specified name.
     */
    static Package getSystemPackage(String name) {
<span class="fc" id="L540">        synchronized (pkgs) {</span>
<span class="fc" id="L541">            Package pkg = pkgs.get(name);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">            if (pkg == null) {</span>
<span class="fc" id="L543">                name = name.replace('.', '/').concat(&quot;/&quot;);</span>
<span class="fc" id="L544">                String fn = getSystemPackage0(name);</span>
<span class="fc bfc" id="L545" title="All 2 branches covered.">                if (fn != null) {</span>
<span class="fc" id="L546">                    pkg = defineSystemPackage(name, fn);</span>
                }
            }
<span class="fc" id="L549">            return pkg;</span>
<span class="nc" id="L550">        }</span>
    }

    /*
     * Return an array of loaded system packages.
     */
    static Package[] getSystemPackages() {
        // First, update the system package map with new package names
<span class="fc" id="L558">        String[] names = getSystemPackages0();</span>
<span class="fc" id="L559">        synchronized (pkgs) {</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">            for (int i = 0; i &lt; names.length; i++) {</span>
<span class="fc" id="L561">                defineSystemPackage(names[i], getSystemPackage0(names[i]));</span>
            }
<span class="fc" id="L563">            return pkgs.values().toArray(new Package[pkgs.size()]);</span>
<span class="nc" id="L564">        }</span>
    }

    private static Package defineSystemPackage(final String iname,
                                               final String fn)
    {
<span class="fc" id="L570">        return AccessController.doPrivileged(new PrivilegedAction&lt;Package&gt;() {</span>
            public Package run() {
<span class="fc" id="L572">                String name = iname;</span>
                // Get the cached code source url for the file name
<span class="fc" id="L574">                URL url = urls.get(fn);</span>
<span class="fc bfc" id="L575" title="All 2 branches covered.">                if (url == null) {</span>
                    // URL not found, so create one
<span class="fc" id="L577">                    File file = new File(fn);</span>
                    try {
<span class="fc" id="L579">                        url = ParseUtil.fileToEncodedURL(file);</span>
<span class="nc" id="L580">                    } catch (MalformedURLException e) {</span>
<span class="fc" id="L581">                    }</span>
<span class="pc bpc" id="L582" title="1 of 2 branches missed.">                    if (url != null) {</span>
<span class="fc" id="L583">                        urls.put(fn, url);</span>
                        // If loading a JAR file, then also cache the manifest
<span class="fc bfc" id="L585" title="All 2 branches covered.">                        if (file.isFile()) {</span>
<span class="fc" id="L586">                            mans.put(fn, loadManifest(fn));</span>
                        }
                    }
                }
                // Convert to &quot;.&quot;-separated package name
<span class="fc" id="L591">                name = name.substring(0, name.length() - 1).replace('/', '.');</span>
                Package pkg;
<span class="fc" id="L593">                Manifest man = mans.get(fn);</span>
<span class="fc bfc" id="L594" title="All 2 branches covered.">                if (man != null) {</span>
<span class="fc" id="L595">                    pkg = new Package(name, man, url, null);</span>
                } else {
<span class="fc" id="L597">                    pkg = new Package(name, null, null, null,</span>
                                      null, null, null, null, null);
                }
<span class="fc" id="L600">                pkgs.put(name, pkg);</span>
<span class="fc" id="L601">                return pkg;</span>
            }
        });
    }

    /*
     * Returns the Manifest for the specified JAR file name.
     */
    private static Manifest loadManifest(String fn) {
<span class="pc" id="L610">        try (FileInputStream fis = new FileInputStream(fn);</span>
<span class="fc" id="L611">             JarInputStream jis = new JarInputStream(fis, false))</span>
        {
<span class="fc" id="L613">            return jis.getManifest();</span>
<span class="pc bpc" id="L614" title="12 of 16 branches missed.">        } catch (IOException e) {</span>
<span class="nc" id="L615">            return null;</span>
        }
    }

    // The map of loaded system packages
<span class="fc" id="L620">    private static Map&lt;String, Package&gt; pkgs = new HashMap&lt;&gt;(31);</span>

    // Maps each directory or zip file name to its corresponding url
<span class="fc" id="L623">    private static Map&lt;String, URL&gt; urls = new HashMap&lt;&gt;(10);</span>

    // Maps each code source url for a jar file to its manifest
<span class="fc" id="L626">    private static Map&lt;String, Manifest&gt; mans = new HashMap&lt;&gt;(10);</span>

    private static native String getSystemPackage0(String name);
    private static native String[] getSystemPackages0();

    /*
     * Private storage for the package name and attributes.
     */
    private final String pkgName;
    private final String specTitle;
    private final String specVersion;
    private final String specVendor;
    private final String implTitle;
    private final String implVersion;
    private final String implVendor;
    private final URL sealBase;
    private transient final ClassLoader loader;
    private transient Class&lt;?&gt; packageInfo;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>