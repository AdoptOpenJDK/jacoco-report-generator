<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Class.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang</a> &gt; <span class="el_source">Class.java</span></div><h1>Class.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang;

import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.GenericDeclaration;
import java.lang.reflect.Member;
import java.lang.reflect.Field;
import java.lang.reflect.Executable;
import java.lang.reflect.Method;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.AnnotatedType;
import java.lang.ref.SoftReference;
import java.io.InputStream;
import java.io.ObjectStreamField;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Set;
import java.util.Map;
import java.util.HashMap;
import java.util.Objects;
import sun.misc.Unsafe;
import sun.reflect.CallerSensitive;
import sun.reflect.ConstantPool;
import sun.reflect.Reflection;
import sun.reflect.ReflectionFactory;
import sun.reflect.generics.factory.CoreReflectionFactory;
import sun.reflect.generics.factory.GenericsFactory;
import sun.reflect.generics.repository.ClassRepository;
import sun.reflect.generics.repository.MethodRepository;
import sun.reflect.generics.repository.ConstructorRepository;
import sun.reflect.generics.scope.ClassScope;
import sun.security.util.SecurityConstants;
import java.lang.annotation.Annotation;
import java.lang.reflect.Proxy;
import sun.reflect.annotation.*;
import sun.reflect.misc.ReflectUtil;

/**
 * Instances of the class {@code Class} represent classes and
 * interfaces in a running Java application.  An enum is a kind of
 * class and an annotation is a kind of interface.  Every array also
 * belongs to a class that is reflected as a {@code Class} object
 * that is shared by all arrays with the same element type and number
 * of dimensions.  The primitive Java types ({@code boolean},
 * {@code byte}, {@code char}, {@code short},
 * {@code int}, {@code long}, {@code float}, and
 * {@code double}), and the keyword {@code void} are also
 * represented as {@code Class} objects.
 *
 * &lt;p&gt; {@code Class} has no public constructor. Instead {@code Class}
 * objects are constructed automatically by the Java Virtual Machine as classes
 * are loaded and by calls to the {@code defineClass} method in the class
 * loader.
 *
 * &lt;p&gt; The following example uses a {@code Class} object to print the
 * class name of an object:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *     void printClassName(Object obj) {
 *         System.out.println(&quot;The class of &quot; + obj +
 *                            &quot; is &quot; + obj.getClass().getName());
 *     }
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; It is also possible to get the {@code Class} object for a named
 * type (or for void) using a class literal.  See Section 15.8.2 of
 * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 * For example:
 *
 * &lt;blockquote&gt;
 *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}
 * &lt;/blockquote&gt;
 *
 * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 * object.  For example, the type of {@code String.class} is {@code
 * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 * unknown.
 *
 * @author  unascribed
 * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 * @since   JDK1.0
 */
public final class Class&lt;T&gt; implements java.io.Serializable,
                              GenericDeclaration,
                              Type,
                              AnnotatedElement {
    private static final int ANNOTATION= 0x00002000;
    private static final int ENUM      = 0x00004000;
    private static final int SYNTHETIC = 0x00001000;

    private static native void registerNatives();
    static {
<span class="nc" id="L129">        registerNatives();</span>
    }

    /*
     * Constructor. Only the Java Virtual Machine creates Class
     * objects.
     */
<span class="nc" id="L136">    private Class() {}</span>


    /**
     * Converts the object to a string. The string representation is the
     * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
     * fully qualified name of the class in the format returned by
     * {@code getName}.  If this {@code Class} object represents a
     * primitive type, this method returns the name of the primitive type.  If
     * this {@code Class} object represents void this method returns
     * &quot;void&quot;.
     *
     * @return a string representation of this class object.
     */
    public String toString() {
<span class="nc bnc" id="L151" title="All 4 branches missed.">        return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))</span>
<span class="nc" id="L152">            + getName();</span>
    }

    /**
     * Returns a string describing this {@code Class}, including
     * information about modifiers and type parameters.
     *
     * The string is formatted as a list of type modifiers, if any,
     * followed by the kind of type (empty string for primitive types
     * and {@code class}, {@code enum}, {@code interface}, or
     * &lt;code&gt;&amp;#64;&lt;/code&gt;{@code interface}, as appropriate), followed
     * by the type's name, followed by an angle-bracketed
     * comma-separated list of the type's type parameters, if any.
     *
     * A space is used to separate modifiers from one another and to
     * separate any modifiers from the kind of type. The modifiers
     * occur in canonical order. If there are no type parameters, the
     * type parameter list is elided.
     *
     * &lt;p&gt;Note that since information about the runtime representation
     * of a type is being generated, modifiers not present on the
     * originating source code or illegal on the originating source
     * code may be present.
     *
     * @return a string describing this {@code Class}, including
     * information about modifiers and type parameters
     *
     * @since 1.8
     */
    public String toGenericString() {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (isPrimitive()) {</span>
<span class="nc" id="L183">            return toString();</span>
        } else {
<span class="nc" id="L185">            StringBuilder sb = new StringBuilder();</span>

            // Class modifiers are a superset of interface modifiers
<span class="nc" id="L188">            int modifiers = getModifiers() &amp; Modifier.classModifiers();</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (modifiers != 0) {</span>
<span class="nc" id="L190">                sb.append(Modifier.toString(modifiers));</span>
<span class="nc" id="L191">                sb.append(' ');</span>
            }

<span class="nc bnc" id="L194" title="All 2 branches missed.">            if (isAnnotation()) {</span>
<span class="nc" id="L195">                sb.append('@');</span>
            }
<span class="nc bnc" id="L197" title="All 2 branches missed.">            if (isInterface()) { // Note: all annotation types are interfaces</span>
<span class="nc" id="L198">                sb.append(&quot;interface&quot;);</span>
            } else {
<span class="nc bnc" id="L200" title="All 2 branches missed.">                if (isEnum())</span>
<span class="nc" id="L201">                    sb.append(&quot;enum&quot;);</span>
                else
<span class="nc" id="L203">                    sb.append(&quot;class&quot;);</span>
            }
<span class="nc" id="L205">            sb.append(' ');</span>
<span class="nc" id="L206">            sb.append(getName());</span>

<span class="nc" id="L208">            TypeVariable&lt;?&gt;[] typeparms = getTypeParameters();</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            if (typeparms.length &gt; 0) {</span>
<span class="nc" id="L210">                boolean first = true;</span>
<span class="nc" id="L211">                sb.append('&lt;');</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">                for(TypeVariable&lt;?&gt; typeparm: typeparms) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">                    if (!first)</span>
<span class="nc" id="L214">                        sb.append(',');</span>
<span class="nc" id="L215">                    sb.append(typeparm.getTypeName());</span>
<span class="nc" id="L216">                    first = false;</span>
                }
<span class="nc" id="L218">                sb.append('&gt;');</span>
            }

<span class="nc" id="L221">            return sb.toString();</span>
        }
    }

    /**
     * Returns the {@code Class} object associated with the class or
     * interface with the given string name.  Invoking this method is
     * equivalent to:
     *
     * &lt;blockquote&gt;
     *  {@code Class.forName(className, true, currentLoader)}
     * &lt;/blockquote&gt;
     *
     * where {@code currentLoader} denotes the defining class loader of
     * the current class.
     *
     * &lt;p&gt; For example, the following code fragment returns the
     * runtime {@code Class} descriptor for the class named
     * {@code java.lang.Thread}:
     *
     * &lt;blockquote&gt;
     *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
     * &lt;/blockquote&gt;
     * &lt;p&gt;
     * A call to {@code forName(&quot;X&quot;)} causes the class named
     * {@code X} to be initialized.
     *
     * @param      className   the fully qualified name of the desired class.
     * @return     the {@code Class} object for the class with the
     *             specified name.
     * @exception LinkageError if the linkage fails
     * @exception ExceptionInInitializerError if the initialization provoked
     *            by this method fails
     * @exception ClassNotFoundException if the class cannot be located
     */
    @CallerSensitive
    public static Class&lt;?&gt; forName(String className)
                throws ClassNotFoundException {
<span class="nc" id="L259">        return forName0(className, true,</span>
<span class="nc" id="L260">                        ClassLoader.getClassLoader(Reflection.getCallerClass()));</span>
    }


    /**
     * Returns the {@code Class} object associated with the class or
     * interface with the given string name, using the given class loader.
     * Given the fully qualified name for a class or interface (in the same
     * format returned by {@code getName}) this method attempts to
     * locate, load, and link the class or interface.  The specified class
     * loader is used to load the class or interface.  If the parameter
     * {@code loader} is null, the class is loaded through the bootstrap
     * class loader.  The class is initialized only if the
     * {@code initialize} parameter is {@code true} and if it has
     * not been initialized earlier.
     *
     * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
     * will be made to locate a user-defined class in the unnamed package whose
     * name is {@code name}. Therefore, this method cannot be used to
     * obtain any of the {@code Class} objects representing primitive
     * types or void.
     *
     * &lt;p&gt; If {@code name} denotes an array class, the component type of
     * the array class is loaded but not initialized.
     *
     * &lt;p&gt; For example, in an instance method the expression:
     *
     * &lt;blockquote&gt;
     *  {@code Class.forName(&quot;Foo&quot;)}
     * &lt;/blockquote&gt;
     *
     * is equivalent to:
     *
     * &lt;blockquote&gt;
     *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
     * &lt;/blockquote&gt;
     *
     * Note that this method throws errors related to loading, linking or
     * initializing as specified in Sections 12.2, 12.3 and 12.4 of &lt;em&gt;The
     * Java Language Specification&lt;/em&gt;.
     * Note that this method does not check whether the requested class
     * is accessible to its caller.
     *
     * &lt;p&gt; If the {@code loader} is {@code null}, and a security
     * manager is present, and the caller's class loader is not null, then this
     * method calls the security manager's {@code checkPermission} method
     * with a {@code RuntimePermission(&quot;getClassLoader&quot;)} permission to
     * ensure it's ok to access the bootstrap class loader.
     *
     * @param name       fully qualified name of the desired class
     * @param initialize if {@code true} the class will be initialized.
     *                   See Section 12.4 of &lt;em&gt;The Java Language Specification&lt;/em&gt;.
     * @param loader     class loader from which the class must be loaded
     * @return           class object representing the desired class
     *
     * @exception LinkageError if the linkage fails
     * @exception ExceptionInInitializerError if the initialization provoked
     *            by this method fails
     * @exception ClassNotFoundException if the class cannot be located by
     *            the specified class loader
     *
     * @see       java.lang.Class#forName(String)
     * @see       java.lang.ClassLoader
     * @since     1.2
     */
    @CallerSensitive
    public static Class&lt;?&gt; forName(String name, boolean initialize,
                                   ClassLoader loader)
        throws ClassNotFoundException
    {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (sun.misc.VM.isSystemDomainLoader(loader)) {</span>
<span class="nc" id="L331">            SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (sm != null) {</span>
<span class="nc" id="L333">                ClassLoader ccl = ClassLoader.getClassLoader(Reflection.getCallerClass());</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">                if (!sun.misc.VM.isSystemDomainLoader(ccl)) {</span>
<span class="nc" id="L335">                    sm.checkPermission(</span>
                        SecurityConstants.GET_CLASSLOADER_PERMISSION);
                }
            }
        }
<span class="nc" id="L340">        return forName0(name, initialize, loader);</span>
    }

    /** Called after security checks have been made. */
    private static native Class&lt;?&gt; forName0(String name, boolean initialize,
                                            ClassLoader loader)
        throws ClassNotFoundException;

    /**
     * Creates a new instance of the class represented by this {@code Class}
     * object.  The class is instantiated as if by a {@code new}
     * expression with an empty argument list.  The class is initialized if it
     * has not already been initialized.
     *
     * &lt;p&gt;Note that this method propagates any exception thrown by the
     * nullary constructor, including a checked exception.  Use of
     * this method effectively bypasses the compile-time exception
     * checking that would otherwise be performed by the compiler.
     * The {@link
     * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
     * Constructor.newInstance} method avoids this problem by wrapping
     * any exception thrown by the constructor in a (checked) {@link
     * java.lang.reflect.InvocationTargetException}.
     *
     * @return  a newly allocated instance of the class represented by this
     *          object.
     * @throws  IllegalAccessException  if the class or its nullary
     *          constructor is not accessible.
     * @throws  InstantiationException
     *          if this {@code Class} represents an abstract class,
     *          an interface, an array class, a primitive type, or void;
     *          or if the class has no nullary constructor;
     *          or if the instantiation fails for some other reason.
     * @throws  ExceptionInInitializerError if the initialization
     *          provoked by this method fails.
     * @throws  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *          the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class.
     */
    @CallerSensitive
    public T newInstance()
        throws InstantiationException, IllegalAccessException
    {
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (System.getSecurityManager() != null) {</span>
<span class="nc" id="L388">            checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);</span>
        }

        // NOTE: the following code may not be strictly correct under
        // the current Java memory model.

        // Constructor lookup
<span class="nc bnc" id="L395" title="All 2 branches missed.">        if (cachedConstructor == null) {</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (this == Class.class) {</span>
<span class="nc" id="L397">                throw new IllegalAccessException(</span>
                    &quot;Can not call newInstance() on the Class for java.lang.Class&quot;
                );
            }
            try {
<span class="nc" id="L402">                Class&lt;?&gt;[] empty = {};</span>
<span class="nc" id="L403">                final Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED);</span>
                // Disable accessibility checks on the constructor
                // since we have to do the security check here anyway
                // (the stack depth is wrong for the Constructor's
                // security check to work)
<span class="nc" id="L408">                java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L409">                    new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                        public Void run() {
<span class="fc" id="L411">                                c.setAccessible(true);</span>
<span class="fc" id="L412">                                return null;</span>
                            }
                        });
<span class="nc" id="L415">                cachedConstructor = c;</span>
<span class="nc" id="L416">            } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L417">                throw (InstantiationException)</span>
<span class="nc" id="L418">                    new InstantiationException(getName()).initCause(e);</span>
<span class="nc" id="L419">            }</span>
        }
<span class="nc" id="L421">        Constructor&lt;T&gt; tmpConstructor = cachedConstructor;</span>
        // Security check (same as in java.lang.reflect.Constructor)
<span class="nc" id="L423">        int modifiers = tmpConstructor.getModifiers();</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (!Reflection.quickCheckMemberAccess(this, modifiers)) {</span>
<span class="nc" id="L425">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">            if (newInstanceCallerCache != caller) {</span>
<span class="nc" id="L427">                Reflection.ensureMemberAccess(caller, this, null, modifiers);</span>
<span class="nc" id="L428">                newInstanceCallerCache = caller;</span>
            }
        }
        // Run constructor
        try {
<span class="nc" id="L433">            return tmpConstructor.newInstance((Object[])null);</span>
<span class="nc" id="L434">        } catch (InvocationTargetException e) {</span>
<span class="nc" id="L435">            Unsafe.getUnsafe().throwException(e.getTargetException());</span>
            // Not reached
<span class="nc" id="L437">            return null;</span>
        }
    }
    private volatile transient Constructor&lt;T&gt; cachedConstructor;
    private volatile transient Class&lt;?&gt;       newInstanceCallerCache;


    /**
     * Determines if the specified {@code Object} is assignment-compatible
     * with the object represented by this {@code Class}.  This method is
     * the dynamic equivalent of the Java language {@code instanceof}
     * operator. The method returns {@code true} if the specified
     * {@code Object} argument is non-null and can be cast to the
     * reference type represented by this {@code Class} object without
     * raising a {@code ClassCastException.} It returns {@code false}
     * otherwise.
     *
     * &lt;p&gt; Specifically, if this {@code Class} object represents a
     * declared class, this method returns {@code true} if the specified
     * {@code Object} argument is an instance of the represented class (or
     * of any of its subclasses); it returns {@code false} otherwise. If
     * this {@code Class} object represents an array class, this method
     * returns {@code true} if the specified {@code Object} argument
     * can be converted to an object of the array class by an identity
     * conversion or by a widening reference conversion; it returns
     * {@code false} otherwise. If this {@code Class} object
     * represents an interface, this method returns {@code true} if the
     * class or any superclass of the specified {@code Object} argument
     * implements this interface; it returns {@code false} otherwise. If
     * this {@code Class} object represents a primitive type, this method
     * returns {@code false}.
     *
     * @param   obj the object to check
     * @return  true if {@code obj} is an instance of this class
     *
     * @since JDK1.1
     */
    public native boolean isInstance(Object obj);


    /**
     * Determines if the class or interface represented by this
     * {@code Class} object is either the same as, or is a superclass or
     * superinterface of, the class or interface represented by the specified
     * {@code Class} parameter. It returns {@code true} if so;
     * otherwise it returns {@code false}. If this {@code Class}
     * object represents a primitive type, this method returns
     * {@code true} if the specified {@code Class} parameter is
     * exactly this {@code Class} object; otherwise it returns
     * {@code false}.
     *
     * &lt;p&gt; Specifically, this method tests whether the type represented by the
     * specified {@code Class} parameter can be converted to the type
     * represented by this {@code Class} object via an identity conversion
     * or via a widening reference conversion. See &lt;em&gt;The Java Language
     * Specification&lt;/em&gt;, sections 5.1.1 and 5.1.4 , for details.
     *
     * @param cls the {@code Class} object to be checked
     * @return the {@code boolean} value indicating whether objects of the
     * type {@code cls} can be assigned to objects of this class
     * @exception NullPointerException if the specified Class parameter is
     *            null.
     * @since JDK1.1
     */
    public native boolean isAssignableFrom(Class&lt;?&gt; cls);


    /**
     * Determines if the specified {@code Class} object represents an
     * interface type.
     *
     * @return  {@code true} if this object represents an interface;
     *          {@code false} otherwise.
     */
    public native boolean isInterface();


    /**
     * Determines if this {@code Class} object represents an array class.
     *
     * @return  {@code true} if this object represents an array class;
     *          {@code false} otherwise.
     * @since   JDK1.1
     */
    public native boolean isArray();


    /**
     * Determines if the specified {@code Class} object represents a
     * primitive type.
     *
     * &lt;p&gt; There are nine predefined {@code Class} objects to represent
     * the eight primitive types and void.  These are created by the Java
     * Virtual Machine, and have the same names as the primitive types that
     * they represent, namely {@code boolean}, {@code byte},
     * {@code char}, {@code short}, {@code int},
     * {@code long}, {@code float}, and {@code double}.
     *
     * &lt;p&gt; These objects may only be accessed via the following public static
     * final variables, and are the only {@code Class} objects for which
     * this method returns {@code true}.
     *
     * @return true if and only if this class represents a primitive type
     *
     * @see     java.lang.Boolean#TYPE
     * @see     java.lang.Character#TYPE
     * @see     java.lang.Byte#TYPE
     * @see     java.lang.Short#TYPE
     * @see     java.lang.Integer#TYPE
     * @see     java.lang.Long#TYPE
     * @see     java.lang.Float#TYPE
     * @see     java.lang.Double#TYPE
     * @see     java.lang.Void#TYPE
     * @since JDK1.1
     */
    public native boolean isPrimitive();

    /**
     * Returns true if this {@code Class} object represents an annotation
     * type.  Note that if this method returns true, {@link #isInterface()}
     * would also return true, as all annotation types are also interfaces.
     *
     * @return {@code true} if this class object represents an annotation
     *      type; {@code false} otherwise
     * @since 1.5
     */
    public boolean isAnnotation() {
<span class="nc bnc" id="L564" title="All 2 branches missed.">        return (getModifiers() &amp; ANNOTATION) != 0;</span>
    }

    /**
     * Returns {@code true} if this class is a synthetic class;
     * returns {@code false} otherwise.
     * @return {@code true} if and only if this class is a synthetic class as
     *         defined by the Java Language Specification.
     * @jls 13.1 The Form of a Binary
     * @since 1.5
     */
    public boolean isSynthetic() {
<span class="nc bnc" id="L576" title="All 2 branches missed.">        return (getModifiers() &amp; SYNTHETIC) != 0;</span>
    }

    /**
     * Returns the  name of the entity (class, interface, array class,
     * primitive type, or void) represented by this {@code Class} object,
     * as a {@code String}.
     *
     * &lt;p&gt; If this class object represents a reference type that is not an
     * array type then the binary name of the class is returned, as specified
     * by
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
     *
     * &lt;p&gt; If this class object represents a primitive type or void, then the
     * name returned is a {@code String} equal to the Java language
     * keyword corresponding to the primitive type or void.
     *
     * &lt;p&gt; If this class object represents a class of arrays, then the internal
     * form of the name consists of the name of the element type preceded by
     * one or more '{@code [}' characters representing the depth of the array
     * nesting.  The encoding of element type names is as follows:
     *
     * &lt;blockquote&gt;&lt;table summary=&quot;Element types and encodings&quot;&gt;
     * &lt;tr&gt;&lt;th&gt; Element Type &lt;th&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;th&gt; Encoding
     * &lt;tr&gt;&lt;td&gt; boolean      &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; Z
     * &lt;tr&gt;&lt;td&gt; byte         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; B
     * &lt;tr&gt;&lt;td&gt; char         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; C
     * &lt;tr&gt;&lt;td&gt; class or interface
     *                       &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; L&lt;i&gt;classname&lt;/i&gt;;
     * &lt;tr&gt;&lt;td&gt; double       &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; D
     * &lt;tr&gt;&lt;td&gt; float        &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; F
     * &lt;tr&gt;&lt;td&gt; int          &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; I
     * &lt;tr&gt;&lt;td&gt; long         &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; J
     * &lt;tr&gt;&lt;td&gt; short        &lt;td&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;td align=center&gt; S
     * &lt;/table&gt;&lt;/blockquote&gt;
     *
     * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
     * the class specified above.
     *
     * &lt;p&gt; Examples:
     * &lt;blockquote&gt;&lt;pre&gt;
     * String.class.getName()
     *     returns &quot;java.lang.String&quot;
     * byte.class.getName()
     *     returns &quot;byte&quot;
     * (new Object[3]).getClass().getName()
     *     returns &quot;[Ljava.lang.Object;&quot;
     * (new int[3][4][5][6][7][8][9]).getClass().getName()
     *     returns &quot;[[[[[[[I&quot;
     * &lt;/pre&gt;&lt;/blockquote&gt;
     *
     * @return  the name of the class or interface
     *          represented by this object.
     */
    public String getName() {
<span class="nc" id="L631">        String name = this.name;</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (name == null)</span>
<span class="nc" id="L633">            this.name = name = getName0();</span>
<span class="nc" id="L634">        return name;</span>
    }

    // cache the name to reduce the number of calls into the VM
    private transient String name;
    private native String getName0();

    /**
     * Returns the class loader for the class.  Some implementations may use
     * null to represent the bootstrap class loader. This method will return
     * null in such implementations if this class was loaded by the bootstrap
     * class loader.
     *
     * &lt;p&gt; If a security manager is present, and the caller's class loader is
     * not null and the caller's class loader is not the same as or an ancestor of
     * the class loader for the class whose class loader is requested, then
     * this method calls the security manager's {@code checkPermission}
     * method with a {@code RuntimePermission(&quot;getClassLoader&quot;)}
     * permission to ensure it's ok to access the class loader for the class.
     *
     * &lt;p&gt;If this object
     * represents a primitive type or void, null is returned.
     *
     * @return  the class loader that loaded the class or interface
     *          represented by this object.
     * @throws SecurityException
     *    if a security manager exists and its
     *    {@code checkPermission} method denies
     *    access to the class loader for the class.
     * @see java.lang.ClassLoader
     * @see SecurityManager#checkPermission
     * @see java.lang.RuntimePermission
     */
    @CallerSensitive
    public ClassLoader getClassLoader() {
<span class="nc" id="L669">        ClassLoader cl = getClassLoader0();</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">        if (cl == null)</span>
<span class="nc" id="L671">            return null;</span>
<span class="nc" id="L672">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L674">            ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());</span>
        }
<span class="nc" id="L676">        return cl;</span>
    }

    // Package-private to allow ClassLoader access
    native ClassLoader getClassLoader0();


    /**
     * Returns an array of {@code TypeVariable} objects that represent the
     * type variables declared by the generic declaration represented by this
     * {@code GenericDeclaration} object, in declaration order.  Returns an
     * array of length 0 if the underlying generic declaration declares no type
     * variables.
     *
     * @return an array of {@code TypeVariable} objects that represent
     *     the type variables declared by this generic declaration
     * @throws java.lang.reflect.GenericSignatureFormatError if the generic
     *     signature of this generic declaration does not conform to
     *     the format specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     * @since 1.5
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
<span class="nc" id="L700">        ClassRepository info = getGenericInfo();</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">        if (info != null)</span>
<span class="nc" id="L702">            return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();</span>
        else
<span class="nc" id="L704">            return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];</span>
    }


    /**
     * Returns the {@code Class} representing the superclass of the entity
     * (class, interface, primitive type or void) represented by this
     * {@code Class}.  If this {@code Class} represents either the
     * {@code Object} class, an interface, a primitive type, or void, then
     * null is returned.  If this object represents an array class then the
     * {@code Class} object representing the {@code Object} class is
     * returned.
     *
     * @return the superclass of the class represented by this object.
     */
    public native Class&lt;? super T&gt; getSuperclass();


    /**
     * Returns the {@code Type} representing the direct superclass of
     * the entity (class, interface, primitive type or void) represented by
     * this {@code Class}.
     *
     * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
     * object returned must accurately reflect the actual type
     * parameters used in the source code. The parameterized type
     * representing the superclass is created if it had not been
     * created before. See the declaration of {@link
     * java.lang.reflect.ParameterizedType ParameterizedType} for the
     * semantics of the creation process for parameterized types.  If
     * this {@code Class} represents either the {@code Object}
     * class, an interface, a primitive type, or void, then null is
     * returned.  If this object represents an array class then the
     * {@code Class} object representing the {@code Object} class is
     * returned.
     *
     * @throws java.lang.reflect.GenericSignatureFormatError if the generic
     *     class signature does not conform to the format specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     * @throws TypeNotPresentException if the generic superclass
     *     refers to a non-existent type declaration
     * @throws java.lang.reflect.MalformedParameterizedTypeException if the
     *     generic superclass refers to a parameterized type that cannot be
     *     instantiated  for any reason
     * @return the superclass of the class represented by this object
     * @since 1.5
     */
    public Type getGenericSuperclass() {
<span class="nc" id="L752">        ClassRepository info = getGenericInfo();</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (info == null) {</span>
<span class="nc" id="L754">            return getSuperclass();</span>
        }

        // Historical irregularity:
        // Generic signature marks interfaces with superclass = Object
        // but this API returns null for interfaces
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if (isInterface()) {</span>
<span class="nc" id="L761">            return null;</span>
        }

<span class="nc" id="L764">        return info.getSuperclass();</span>
    }

    /**
     * Gets the package for this class.  The class loader of this class is used
     * to find the package.  If the class was loaded by the bootstrap class
     * loader the set of packages loaded from CLASSPATH is searched to find the
     * package of the class. Null is returned if no package object was created
     * by the class loader of this class.
     *
     * &lt;p&gt; Packages have attributes for versions and specifications only if the
     * information was defined in the manifests that accompany the classes, and
     * if the class loader created the package instance with the attributes
     * from the manifest.
     *
     * @return the package of the class, or null if no package
     *         information is available from the archive or codebase.
     */
    public Package getPackage() {
<span class="nc" id="L783">        return Package.getPackage(this);</span>
    }


    /**
     * Determines the interfaces implemented by the class or interface
     * represented by this object.
     *
     * &lt;p&gt; If this object represents a class, the return value is an array
     * containing objects representing all interfaces implemented by the
     * class. The order of the interface objects in the array corresponds to
     * the order of the interface names in the {@code implements} clause
     * of the declaration of the class represented by this object. For
     * example, given the declaration:
     * &lt;blockquote&gt;
     * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
     * &lt;/blockquote&gt;
     * suppose the value of {@code s} is an instance of
     * {@code Shimmer}; the value of the expression:
     * &lt;blockquote&gt;
     * {@code s.getClass().getInterfaces()[0]}
     * &lt;/blockquote&gt;
     * is the {@code Class} object that represents interface
     * {@code FloorWax}; and the value of:
     * &lt;blockquote&gt;
     * {@code s.getClass().getInterfaces()[1]}
     * &lt;/blockquote&gt;
     * is the {@code Class} object that represents interface
     * {@code DessertTopping}.
     *
     * &lt;p&gt; If this object represents an interface, the array contains objects
     * representing all interfaces extended by the interface. The order of the
     * interface objects in the array corresponds to the order of the interface
     * names in the {@code extends} clause of the declaration of the
     * interface represented by this object.
     *
     * &lt;p&gt; If this object represents a class or interface that implements no
     * interfaces, the method returns an array of length 0.
     *
     * &lt;p&gt; If this object represents a primitive type or void, the method
     * returns an array of length 0.
     *
     * &lt;p&gt; If this {@code Class} object represents an array type, the
     * interfaces {@code Cloneable} and {@code java.io.Serializable} are
     * returned in that order.
     *
     * @return an array of interfaces implemented by this class.
     */
    public Class&lt;?&gt;[] getInterfaces() {
<span class="nc" id="L832">        ReflectionData&lt;T&gt; rd = reflectionData();</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (rd == null) {</span>
            // no cloning required
<span class="nc" id="L835">            return getInterfaces0();</span>
        } else {
<span class="nc" id="L837">            Class&lt;?&gt;[] interfaces = rd.interfaces;</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">            if (interfaces == null) {</span>
<span class="nc" id="L839">                interfaces = getInterfaces0();</span>
<span class="nc" id="L840">                rd.interfaces = interfaces;</span>
            }
            // defensively copy before handing over to user code
<span class="nc" id="L843">            return interfaces.clone();</span>
        }
    }

    private native Class&lt;?&gt;[] getInterfaces0();

    /**
     * Returns the {@code Type}s representing the interfaces
     * directly implemented by the class or interface represented by
     * this object.
     *
     * &lt;p&gt;If a superinterface is a parameterized type, the
     * {@code Type} object returned for it must accurately reflect
     * the actual type parameters used in the source code. The
     * parameterized type representing each superinterface is created
     * if it had not been created before. See the declaration of
     * {@link java.lang.reflect.ParameterizedType ParameterizedType}
     * for the semantics of the creation process for parameterized
     * types.
     *
     * &lt;p&gt; If this object represents a class, the return value is an
     * array containing objects representing all interfaces
     * implemented by the class. The order of the interface objects in
     * the array corresponds to the order of the interface names in
     * the {@code implements} clause of the declaration of the class
     * represented by this object.  In the case of an array class, the
     * interfaces {@code Cloneable} and {@code Serializable} are
     * returned in that order.
     *
     * &lt;p&gt;If this object represents an interface, the array contains
     * objects representing all interfaces directly extended by the
     * interface.  The order of the interface objects in the array
     * corresponds to the order of the interface names in the
     * {@code extends} clause of the declaration of the interface
     * represented by this object.
     *
     * &lt;p&gt;If this object represents a class or interface that
     * implements no interfaces, the method returns an array of length
     * 0.
     *
     * &lt;p&gt;If this object represents a primitive type or void, the
     * method returns an array of length 0.
     *
     * @throws java.lang.reflect.GenericSignatureFormatError
     *     if the generic class signature does not conform to the format
     *     specified in
     *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
     * @throws TypeNotPresentException if any of the generic
     *     superinterfaces refers to a non-existent type declaration
     * @throws java.lang.reflect.MalformedParameterizedTypeException
     *     if any of the generic superinterfaces refer to a parameterized
     *     type that cannot be instantiated for any reason
     * @return an array of interfaces implemented by this class
     * @since 1.5
     */
    public Type[] getGenericInterfaces() {
<span class="nc" id="L899">        ClassRepository info = getGenericInfo();</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">        return (info == null) ?  getInterfaces() : info.getSuperInterfaces();</span>
    }


    /**
     * Returns the {@code Class} representing the component type of an
     * array.  If this class does not represent an array class this method
     * returns null.
     *
     * @return the {@code Class} representing the component type of this
     * class if this class is an array
     * @see     java.lang.reflect.Array
     * @since JDK1.1
     */
    public native Class&lt;?&gt; getComponentType();


    /**
     * Returns the Java language modifiers for this class or interface, encoded
     * in an integer. The modifiers consist of the Java Virtual Machine's
     * constants for {@code public}, {@code protected},
     * {@code private}, {@code final}, {@code static},
     * {@code abstract} and {@code interface}; they should be decoded
     * using the methods of class {@code Modifier}.
     *
     * &lt;p&gt; If the underlying class is an array class, then its
     * {@code public}, {@code private} and {@code protected}
     * modifiers are the same as those of its component type.  If this
     * {@code Class} represents a primitive type or void, its
     * {@code public} modifier is always {@code true}, and its
     * {@code protected} and {@code private} modifiers are always
     * {@code false}. If this object represents an array class, a
     * primitive type or void, then its {@code final} modifier is always
     * {@code true} and its interface modifier is always
     * {@code false}. The values of its other modifiers are not determined
     * by this specification.
     *
     * &lt;p&gt; The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine
     * Specification&lt;/em&gt;, table 4.1.
     *
     * @return the {@code int} representing the modifiers for this class
     * @see     java.lang.reflect.Modifier
     * @since JDK1.1
     */
    public native int getModifiers();


    /**
     * Gets the signers of this class.
     *
     * @return  the signers of this class, or null if there are no signers.  In
     *          particular, this method returns null if this object represents
     *          a primitive type or void.
     * @since   JDK1.1
     */
    public native Object[] getSigners();


    /**
     * Set the signers of this class.
     */
    native void setSigners(Object[] signers);


    /**
     * If this {@code Class} object represents a local or anonymous
     * class within a method, returns a {@link
     * java.lang.reflect.Method Method} object representing the
     * immediately enclosing method of the underlying class. Returns
     * {@code null} otherwise.
     *
     * In particular, this method returns {@code null} if the underlying
     * class is a local or anonymous class immediately enclosed by a type
     * declaration, instance initializer or static initializer.
     *
     * @return the immediately enclosing method of the underlying class, if
     *     that class is a local or anonymous class; otherwise {@code null}.
     *
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *         following conditions is met:
     *
     *         &lt;ul&gt;
     *
     *         &lt;li&gt; the caller's class loader is not the same as the
     *         class loader of the enclosing class and invocation of
     *         {@link SecurityManager#checkPermission
     *         s.checkPermission} method with
     *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *         denies access to the methods within the enclosing class
     *
     *         &lt;li&gt; the caller's class loader is not the same as or an
     *         ancestor of the class loader for the enclosing class and
     *         invocation of {@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of the enclosing class
     *
     *         &lt;/ul&gt;
     * @since 1.5
     */
    @CallerSensitive
    public Method getEnclosingMethod() throws SecurityException {
<span class="nc" id="L1002">        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();</span>

<span class="nc bnc" id="L1004" title="All 2 branches missed.">        if (enclosingInfo == null)</span>
<span class="nc" id="L1005">            return null;</span>
        else {
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            if (!enclosingInfo.isMethod())</span>
<span class="nc" id="L1008">                return null;</span>

<span class="nc" id="L1010">            MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),</span>
<span class="nc" id="L1011">                                                              getFactory());</span>
<span class="nc" id="L1012">            Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());</span>
<span class="nc" id="L1013">            Type []    parameterTypes   = typeInfo.getParameterTypes();</span>
<span class="nc" id="L1014">            Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];</span>

            // Convert Types to Classes; returned types *should*
            // be class objects since the methodDescriptor's used
            // don't have generics information
<span class="nc bnc" id="L1019" title="All 2 branches missed.">            for(int i = 0; i &lt; parameterClasses.length; i++)</span>
<span class="nc" id="L1020">                parameterClasses[i] = toClass(parameterTypes[i]);</span>

            // Perform access check
<span class="nc" id="L1023">            Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();</span>
<span class="nc" id="L1024">            enclosingCandidate.checkMemberAccess(Member.DECLARED,</span>
<span class="nc" id="L1025">                                                 Reflection.getCallerClass(), true);</span>
            /*
             * Loop over all declared methods; match method name,
             * number of and type of parameters, *and* return
             * type.  Matching return type is also necessary
             * because of covariant returns, etc.
             */
<span class="nc bnc" id="L1032" title="All 2 branches missed.">            for(Method m: enclosingCandidate.getDeclaredMethods()) {</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">                if (m.getName().equals(enclosingInfo.getName()) ) {</span>
<span class="nc" id="L1034">                    Class&lt;?&gt;[] candidateParamClasses = m.getParameterTypes();</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">                    if (candidateParamClasses.length == parameterClasses.length) {</span>
<span class="nc" id="L1036">                        boolean matches = true;</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">                        for(int i = 0; i &lt; candidateParamClasses.length; i++) {</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">                            if (!candidateParamClasses[i].equals(parameterClasses[i])) {</span>
<span class="nc" id="L1039">                                matches = false;</span>
<span class="nc" id="L1040">                                break;</span>
                            }
                        }

<span class="nc bnc" id="L1044" title="All 2 branches missed.">                        if (matches) { // finally, check return type</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                            if (m.getReturnType().equals(returnType) )</span>
<span class="nc" id="L1046">                                return m;</span>
                        }
                    }
                }
            }

<span class="nc" id="L1052">            throw new InternalError(&quot;Enclosing method not found&quot;);</span>
        }
    }

    private native Object[] getEnclosingMethod0();

    private EnclosingMethodInfo getEnclosingMethodInfo() {
<span class="nc" id="L1059">        Object[] enclosingInfo = getEnclosingMethod0();</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">        if (enclosingInfo == null)</span>
<span class="nc" id="L1061">            return null;</span>
        else {
<span class="nc" id="L1063">            return new EnclosingMethodInfo(enclosingInfo);</span>
        }
    }

<span class="pc bpc" id="L1067" title="1 of 2 branches missed.">    private final static class EnclosingMethodInfo {</span>
        private Class&lt;?&gt; enclosingClass;
        private String name;
        private String descriptor;

<span class="fc" id="L1072">        private EnclosingMethodInfo(Object[] enclosingInfo) {</span>
<span class="pc bpc" id="L1073" title="1 of 2 branches missed.">            if (enclosingInfo.length != 3)</span>
<span class="nc" id="L1074">                throw new InternalError(&quot;Malformed enclosing method information&quot;);</span>
            try {
                // The array is expected to have three elements:

                // the immediately enclosing class
<span class="fc" id="L1079">                enclosingClass = (Class&lt;?&gt;) enclosingInfo[0];</span>
<span class="pc bpc" id="L1080" title="2 of 4 branches missed.">                assert(enclosingClass != null);</span>

                // the immediately enclosing method or constructor's
                // name (can be null).
<span class="fc" id="L1084">                name            = (String)   enclosingInfo[1];</span>

                // the immediately enclosing method or constructor's
                // descriptor (null iff name is).
<span class="fc" id="L1088">                descriptor      = (String)   enclosingInfo[2];</span>
<span class="pc bpc" id="L1089" title="3 of 8 branches missed.">                assert((name != null &amp;&amp; descriptor != null) || name == descriptor);</span>
<span class="nc" id="L1090">            } catch (ClassCastException cce) {</span>
<span class="nc" id="L1091">                throw new InternalError(&quot;Invalid type in enclosing method information&quot;, cce);</span>
<span class="fc" id="L1092">            }</span>
<span class="fc" id="L1093">        }</span>

        boolean isPartial() {
<span class="pc bpc" id="L1096" title="2 of 6 branches missed.">            return enclosingClass == null || name == null || descriptor == null;</span>
        }

<span class="fc bfc" id="L1099" title="All 4 branches covered.">        boolean isConstructor() { return !isPartial() &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name); }</span>

<span class="pc bpc" id="L1101" title="1 of 6 branches missed.">        boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name); }</span>

<span class="fc" id="L1103">        Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }</span>

<span class="fc" id="L1105">        String getName() { return name; }</span>

<span class="fc" id="L1107">        String getDescriptor() { return descriptor; }</span>

    }

    private static Class&lt;?&gt; toClass(Type o) {
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        if (o instanceof GenericArrayType)</span>
<span class="nc" id="L1113">            return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),</span>
                                     0)
<span class="nc" id="L1115">                .getClass();</span>
<span class="nc" id="L1116">        return (Class&lt;?&gt;)o;</span>
     }

    /**
     * If this {@code Class} object represents a local or anonymous
     * class within a constructor, returns a {@link
     * java.lang.reflect.Constructor Constructor} object representing
     * the immediately enclosing constructor of the underlying
     * class. Returns {@code null} otherwise.  In particular, this
     * method returns {@code null} if the underlying class is a local
     * or anonymous class immediately enclosed by a type declaration,
     * instance initializer or static initializer.
     *
     * @return the immediately enclosing constructor of the underlying class, if
     *     that class is a local or anonymous class; otherwise {@code null}.
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *         following conditions is met:
     *
     *         &lt;ul&gt;
     *
     *         &lt;li&gt; the caller's class loader is not the same as the
     *         class loader of the enclosing class and invocation of
     *         {@link SecurityManager#checkPermission
     *         s.checkPermission} method with
     *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *         denies access to the constructors within the enclosing class
     *
     *         &lt;li&gt; the caller's class loader is not the same as or an
     *         ancestor of the class loader for the enclosing class and
     *         invocation of {@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of the enclosing class
     *
     *         &lt;/ul&gt;
     * @since 1.5
     */
    @CallerSensitive
    public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {
<span class="nc" id="L1155">        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();</span>

<span class="nc bnc" id="L1157" title="All 2 branches missed.">        if (enclosingInfo == null)</span>
<span class="nc" id="L1158">            return null;</span>
        else {
<span class="nc bnc" id="L1160" title="All 2 branches missed.">            if (!enclosingInfo.isConstructor())</span>
<span class="nc" id="L1161">                return null;</span>

<span class="nc" id="L1163">            ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),</span>
<span class="nc" id="L1164">                                                                        getFactory());</span>
<span class="nc" id="L1165">            Type []    parameterTypes   = typeInfo.getParameterTypes();</span>
<span class="nc" id="L1166">            Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];</span>

            // Convert Types to Classes; returned types *should*
            // be class objects since the methodDescriptor's used
            // don't have generics information
<span class="nc bnc" id="L1171" title="All 2 branches missed.">            for(int i = 0; i &lt; parameterClasses.length; i++)</span>
<span class="nc" id="L1172">                parameterClasses[i] = toClass(parameterTypes[i]);</span>

            // Perform access check
<span class="nc" id="L1175">            Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();</span>
<span class="nc" id="L1176">            enclosingCandidate.checkMemberAccess(Member.DECLARED,</span>
<span class="nc" id="L1177">                                                 Reflection.getCallerClass(), true);</span>
            /*
             * Loop over all declared constructors; match number
             * of and type of parameters.
             */
<span class="nc bnc" id="L1182" title="All 2 branches missed.">            for(Constructor&lt;?&gt; c: enclosingCandidate.getDeclaredConstructors()) {</span>
<span class="nc" id="L1183">                Class&lt;?&gt;[] candidateParamClasses = c.getParameterTypes();</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">                if (candidateParamClasses.length == parameterClasses.length) {</span>
<span class="nc" id="L1185">                    boolean matches = true;</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">                    for(int i = 0; i &lt; candidateParamClasses.length; i++) {</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">                        if (!candidateParamClasses[i].equals(parameterClasses[i])) {</span>
<span class="nc" id="L1188">                            matches = false;</span>
<span class="nc" id="L1189">                            break;</span>
                        }
                    }

<span class="nc bnc" id="L1193" title="All 2 branches missed.">                    if (matches)</span>
<span class="nc" id="L1194">                        return c;</span>
                }
            }

<span class="nc" id="L1198">            throw new InternalError(&quot;Enclosing constructor not found&quot;);</span>
        }
    }


    /**
     * If the class or interface represented by this {@code Class} object
     * is a member of another class, returns the {@code Class} object
     * representing the class in which it was declared.  This method returns
     * null if this class or interface is not a member of any other class.  If
     * this {@code Class} object represents an array class, a primitive
     * type, or void,then this method returns null.
     *
     * @return the declaring class for this class
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller's
     *         class loader is not the same as or an ancestor of the class
     *         loader for the declaring class and invocation of {@link
     *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
     *         denies access to the package of the declaring class
     * @since JDK1.1
     */
    @CallerSensitive
    public Class&lt;?&gt; getDeclaringClass() throws SecurityException {
<span class="nc" id="L1222">        final Class&lt;?&gt; candidate = getDeclaringClass0();</span>

<span class="nc bnc" id="L1224" title="All 2 branches missed.">        if (candidate != null)</span>
<span class="nc" id="L1225">            candidate.checkPackageAccess(</span>
<span class="nc" id="L1226">                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);</span>
<span class="nc" id="L1227">        return candidate;</span>
    }

    private native Class&lt;?&gt; getDeclaringClass0();


    /**
     * Returns the immediately enclosing class of the underlying
     * class.  If the underlying class is a top level class this
     * method returns {@code null}.
     * @return the immediately enclosing class of the underlying class
     * @exception  SecurityException
     *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller's
     *             class loader is not the same as or an ancestor of the class
     *             loader for the enclosing class and invocation of {@link
     *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
     *             denies access to the package of the enclosing class
     * @since 1.5
     */
    @CallerSensitive
    public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
        // There are five kinds of classes (or interfaces):
        // a) Top level classes
        // b) Nested classes (static member classes)
        // c) Inner classes (non-static member classes)
        // d) Local classes (named classes declared within a method)
        // e) Anonymous classes


        // JVM Spec 4.8.6: A class must have an EnclosingMethod
        // attribute if and only if it is a local class or an
        // anonymous class.
<span class="nc" id="L1259">        EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();</span>
        Class&lt;?&gt; enclosingCandidate;

<span class="nc bnc" id="L1262" title="All 2 branches missed.">        if (enclosingInfo == null) {</span>
            // This is a top level or a nested class or an inner class (a, b, or c)
<span class="nc" id="L1264">            enclosingCandidate = getDeclaringClass();</span>
        } else {
<span class="nc" id="L1266">            Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();</span>
            // This is a local class or an anonymous class (d or e)
<span class="nc bnc" id="L1268" title="All 4 branches missed.">            if (enclosingClass == this || enclosingClass == null)</span>
<span class="nc" id="L1269">                throw new InternalError(&quot;Malformed enclosing method information&quot;);</span>
            else
<span class="nc" id="L1271">                enclosingCandidate = enclosingClass;</span>
        }

<span class="nc bnc" id="L1274" title="All 2 branches missed.">        if (enclosingCandidate != null)</span>
<span class="nc" id="L1275">            enclosingCandidate.checkPackageAccess(</span>
<span class="nc" id="L1276">                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);</span>
<span class="nc" id="L1277">        return enclosingCandidate;</span>
    }

    /**
     * Returns the simple name of the underlying class as given in the
     * source code. Returns an empty string if the underlying class is
     * anonymous.
     *
     * &lt;p&gt;The simple name of an array is the simple name of the
     * component type with &quot;[]&quot; appended.  In particular the simple
     * name of an array whose component type is anonymous is &quot;[]&quot;.
     *
     * @return the simple name of the underlying class
     * @since 1.5
     */
    public String getSimpleName() {
<span class="nc bnc" id="L1293" title="All 2 branches missed.">        if (isArray())</span>
<span class="nc" id="L1294">            return getComponentType().getSimpleName()+&quot;[]&quot;;</span>

<span class="nc" id="L1296">        String simpleName = getSimpleBinaryName();</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">        if (simpleName == null) { // top level class</span>
<span class="nc" id="L1298">            simpleName = getName();</span>
<span class="nc" id="L1299">            return simpleName.substring(simpleName.lastIndexOf(&quot;.&quot;)+1); // strip the package name</span>
        }
        // According to JLS3 &quot;Binary Compatibility&quot; (13.1) the binary
        // name of non-package classes (not top level) is the binary
        // name of the immediately enclosing class followed by a '$' followed by:
        // (for nested and inner classes): the simple name.
        // (for local classes): 1 or more digits followed by the simple name.
        // (for anonymous classes): 1 or more digits.

        // Since getSimpleBinaryName() will strip the binary name of
        // the immediatly enclosing class, we are now looking at a
        // string that matches the regular expression &quot;\$[0-9]*&quot;
        // followed by a simple name (considering the simple of an
        // anonymous class to be the empty string).

        // Remove leading &quot;\$[0-9]*&quot; from the name
<span class="nc" id="L1315">        int length = simpleName.length();</span>
<span class="nc bnc" id="L1316" title="All 4 branches missed.">        if (length &lt; 1 || simpleName.charAt(0) != '$')</span>
<span class="nc" id="L1317">            throw new InternalError(&quot;Malformed class name&quot;);</span>
<span class="nc" id="L1318">        int index = 1;</span>
<span class="nc bnc" id="L1319" title="All 4 branches missed.">        while (index &lt; length &amp;&amp; isAsciiDigit(simpleName.charAt(index)))</span>
<span class="nc" id="L1320">            index++;</span>
        // Eventually, this is the empty string iff this is an anonymous class
<span class="nc" id="L1322">        return simpleName.substring(index);</span>
    }

    /**
     * Return an informative string for the name of this type.
     *
     * @return an informative string for the name of this type
     * @since 1.8
     */
    public String getTypeName() {
<span class="nc bnc" id="L1332" title="All 2 branches missed.">        if (isArray()) {</span>
            try {
<span class="nc" id="L1334">                Class&lt;?&gt; cl = this;</span>
<span class="nc" id="L1335">                int dimensions = 0;</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">                while (cl.isArray()) {</span>
<span class="nc" id="L1337">                    dimensions++;</span>
<span class="nc" id="L1338">                    cl = cl.getComponentType();</span>
                }
<span class="nc" id="L1340">                StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1341">                sb.append(cl.getName());</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">                for (int i = 0; i &lt; dimensions; i++) {</span>
<span class="nc" id="L1343">                    sb.append(&quot;[]&quot;);</span>
                }
<span class="nc" id="L1345">                return sb.toString();</span>
<span class="nc" id="L1346">            } catch (Throwable e) { /*FALLTHRU*/ }</span>
        }
<span class="nc" id="L1348">        return getName();</span>
    }

    /**
     * Character.isDigit answers {@code true} to some non-ascii
     * digits.  This one does not.
     */
    private static boolean isAsciiDigit(char c) {
<span class="nc bnc" id="L1356" title="All 4 branches missed.">        return '0' &lt;= c &amp;&amp; c &lt;= '9';</span>
    }

    /**
     * Returns the canonical name of the underlying class as
     * defined by the Java Language Specification.  Returns null if
     * the underlying class does not have a canonical name (i.e., if
     * it is a local or anonymous class or an array whose component
     * type does not have a canonical name).
     * @return the canonical name of the underlying class if it exists, and
     * {@code null} otherwise.
     * @since 1.5
     */
    public String getCanonicalName() {
<span class="nc bnc" id="L1370" title="All 2 branches missed.">        if (isArray()) {</span>
<span class="nc" id="L1371">            String canonicalName = getComponentType().getCanonicalName();</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">            if (canonicalName != null)</span>
<span class="nc" id="L1373">                return canonicalName + &quot;[]&quot;;</span>
            else
<span class="nc" id="L1375">                return null;</span>
        }
<span class="nc bnc" id="L1377" title="All 2 branches missed.">        if (isLocalOrAnonymousClass())</span>
<span class="nc" id="L1378">            return null;</span>
<span class="nc" id="L1379">        Class&lt;?&gt; enclosingClass = getEnclosingClass();</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        if (enclosingClass == null) { // top level class</span>
<span class="nc" id="L1381">            return getName();</span>
        } else {
<span class="nc" id="L1383">            String enclosingName = enclosingClass.getCanonicalName();</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">            if (enclosingName == null)</span>
<span class="nc" id="L1385">                return null;</span>
<span class="nc" id="L1386">            return enclosingName + &quot;.&quot; + getSimpleName();</span>
        }
    }

    /**
     * Returns {@code true} if and only if the underlying class
     * is an anonymous class.
     *
     * @return {@code true} if and only if this class is an anonymous class.
     * @since 1.5
     */
    public boolean isAnonymousClass() {
<span class="nc" id="L1398">        return &quot;&quot;.equals(getSimpleName());</span>
    }

    /**
     * Returns {@code true} if and only if the underlying class
     * is a local class.
     *
     * @return {@code true} if and only if this class is a local class.
     * @since 1.5
     */
    public boolean isLocalClass() {
<span class="nc bnc" id="L1409" title="All 4 branches missed.">        return isLocalOrAnonymousClass() &amp;&amp; !isAnonymousClass();</span>
    }

    /**
     * Returns {@code true} if and only if the underlying class
     * is a member class.
     *
     * @return {@code true} if and only if this class is a member class.
     * @since 1.5
     */
    public boolean isMemberClass() {
<span class="nc bnc" id="L1420" title="All 4 branches missed.">        return getSimpleBinaryName() != null &amp;&amp; !isLocalOrAnonymousClass();</span>
    }

    /**
     * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
     * the binary name without the leading enclosing class name.
     * Returns {@code null} if the underlying class is a top level
     * class.
     */
    private String getSimpleBinaryName() {
<span class="nc" id="L1430">        Class&lt;?&gt; enclosingClass = getEnclosingClass();</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">        if (enclosingClass == null) // top level class</span>
<span class="nc" id="L1432">            return null;</span>
        // Otherwise, strip the enclosing class' name
        try {
<span class="nc" id="L1435">            return getName().substring(enclosingClass.getName().length());</span>
<span class="nc" id="L1436">        } catch (IndexOutOfBoundsException ex) {</span>
<span class="nc" id="L1437">            throw new InternalError(&quot;Malformed class name&quot;, ex);</span>
        }
    }

    /**
     * Returns {@code true} if this is a local class or an anonymous
     * class.  Returns {@code false} otherwise.
     */
    private boolean isLocalOrAnonymousClass() {
        // JVM Spec 4.8.6: A class must have an EnclosingMethod
        // attribute if and only if it is a local class or an
        // anonymous class.
<span class="nc bnc" id="L1449" title="All 2 branches missed.">        return getEnclosingMethodInfo() != null;</span>
    }

    /**
     * Returns an array containing {@code Class} objects representing all
     * the public classes and interfaces that are members of the class
     * represented by this {@code Class} object.  This includes public
     * class and interface members inherited from superclasses and public class
     * and interface members declared by the class.  This method returns an
     * array of length 0 if this {@code Class} object has no public member
     * classes or interfaces.  This method also returns an array of length 0 if
     * this {@code Class} object represents a primitive type, an array
     * class, or void.
     *
     * @return the array of {@code Class} objects representing the public
     *         members of this class
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @since JDK1.1
     */
    @CallerSensitive
    public Class&lt;?&gt;[] getClasses() {
<span class="nc" id="L1477">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), false);</span>

        // Privileged so this implementation can look at DECLARED classes,
        // something the caller might not have privilege to do.  The code here
        // is allowed to look at DECLARED classes because (1) it does not hand
        // out anything other than public members and (2) public member access
        // has already been ok'd by the SecurityManager.

<span class="nc" id="L1485">        return java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L1486">            new java.security.PrivilegedAction&lt;Class&lt;?&gt;[]&gt;() {</span>
                public Class&lt;?&gt;[] run() {
<span class="fc" id="L1488">                    List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L1489">                    Class&lt;?&gt; currentClass = Class.this;</span>
<span class="fc bfc" id="L1490" title="All 2 branches covered.">                    while (currentClass != null) {</span>
<span class="fc" id="L1491">                        Class&lt;?&gt;[] members = currentClass.getDeclaredClasses();</span>
<span class="fc bfc" id="L1492" title="All 2 branches covered.">                        for (int i = 0; i &lt; members.length; i++) {</span>
<span class="fc bfc" id="L1493" title="All 2 branches covered.">                            if (Modifier.isPublic(members[i].getModifiers())) {</span>
<span class="fc" id="L1494">                                list.add(members[i]);</span>
                            }
                        }
<span class="fc" id="L1497">                        currentClass = currentClass.getSuperclass();</span>
<span class="fc" id="L1498">                    }</span>
<span class="fc" id="L1499">                    return list.toArray(new Class&lt;?&gt;[0]);</span>
                }
            });
    }


    /**
     * Returns an array containing {@code Field} objects reflecting all
     * the accessible public fields of the class or interface represented by
     * this {@code Class} object.
     *
     * &lt;p&gt; If this {@code Class} object represents a class or interface with no
     * no accessible public fields, then this method returns an array of length
     * 0.
     *
     * &lt;p&gt; If this {@code Class} object represents a class, then this method
     * returns the public fields of the class and of all its superclasses.
     *
     * &lt;p&gt; If this {@code Class} object represents an interface, then this
     * method returns the fields of the interface and of all its
     * superinterfaces.
     *
     * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
     * type, or void, then this method returns an array of length 0.
     *
     * &lt;p&gt; The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * @return the array of {@code Field} objects representing the
     *         public fields
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @since JDK1.1
     * @jls 8.2 Class Members
     * @jls 8.3 Field Declarations
     */
    @CallerSensitive
    public Field[] getFields() throws SecurityException {
<span class="nc" id="L1543">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L1544">        return copyFields(privateGetPublicFields(null));</span>
    }


    /**
     * Returns an array containing {@code Method} objects reflecting all the
     * public methods of the class or interface represented by this {@code
     * Class} object, including those declared by the class or interface and
     * those inherited from superclasses and superinterfaces.
     *
     * &lt;p&gt; If this {@code Class} object represents a type that has multiple
     * public methods with the same name and parameter types, but different
     * return types, then the returned array has a {@code Method} object for
     * each such method.
     *
     * &lt;p&gt; If this {@code Class} object represents a type with a class
     * initialization method {@code &lt;clinit&gt;}, then the returned array does
     * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
     *
     * &lt;p&gt; If this {@code Class} object represents an array type, then the
     * returned array has a {@code Method} object for each of the public
     * methods inherited by the array type from {@code Object}. It does not
     * contain a {@code Method} object for {@code clone()}.
     *
     * &lt;p&gt; If this {@code Class} object represents a class or interface with no
     * public methods, then the returned array has length 0.
     *
     * &lt;p&gt; If this {@code Class} object represents a primitive type or void,
     * then the returned array has length 0.
     *
     * &lt;p&gt; Static methods declared in superinterfaces of the class or interface
     * represented by this {@code Class} object are not considered members of
     * the class or interface.
     *
     * &lt;p&gt; The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * @return the array of {@code Method} objects representing the
     *         public methods of this class
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @jls 8.2 Class Members
     * @jls 8.4 Method Declarations
     * @since JDK1.1
     */
    @CallerSensitive
    public Method[] getMethods() throws SecurityException {
<span class="nc" id="L1597">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L1598">        return copyMethods(privateGetPublicMethods());</span>
    }


    /**
     * Returns an array containing {@code Constructor} objects reflecting
     * all the public constructors of the class represented by this
     * {@code Class} object.  An array of length 0 is returned if the
     * class has no public constructors, or if the class is an array class, or
     * if the class reflects a primitive type or void.
     *
     * Note that while this method returns an array of {@code
     * Constructor&lt;T&gt;} objects (that is an array of constructors from
     * this class), the return type of this method is {@code
     * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
     * might be expected.  This less informative return type is
     * necessary since after being returned from this method, the
     * array could be modified to hold {@code Constructor} objects for
     * different classes, which would violate the type guarantees of
     * {@code Constructor&lt;T&gt;[]}.
     *
     * @return the array of {@code Constructor} objects representing the
     *         public constructors of this class
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @since JDK1.1
     */
    @CallerSensitive
    public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
<span class="nc" id="L1633">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L1634">        return copyConstructors(privateGetDeclaredConstructors(true));</span>
    }


    /**
     * Returns a {@code Field} object that reflects the specified public member
     * field of the class or interface represented by this {@code Class}
     * object. The {@code name} parameter is a {@code String} specifying the
     * simple name of the desired field.
     *
     * &lt;p&gt; The field to be reflected is determined by the algorithm that
     * follows.  Let C be the class or interface represented by this object:
     *
     * &lt;OL&gt;
     * &lt;LI&gt; If C declares a public field with the name specified, that is the
     *      field to be reflected.&lt;/LI&gt;
     * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
     *      recursively to each direct superinterface of C. The direct
     *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
     * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
     *      superclass S, then this algorithm is invoked recursively upon S.
     *      If C has no superclass, then a {@code NoSuchFieldException}
     *      is thrown.&lt;/LI&gt;
     * &lt;/OL&gt;
     *
     * &lt;p&gt; If this {@code Class} object represents an array type, then this
     * method does not find the {@code length} field of the array type.
     *
     * @param name the field name
     * @return the {@code Field} object of this class specified by
     *         {@code name}
     * @throws NoSuchFieldException if a field with the specified name is
     *         not found.
     * @throws NullPointerException if {@code name} is {@code null}
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @since JDK1.1
     * @jls 8.2 Class Members
     * @jls 8.3 Field Declarations
     */
    @CallerSensitive
    public Field getField(String name)
        throws NoSuchFieldException, SecurityException {
<span class="nc" id="L1683">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L1684">        Field field = getField0(name);</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L1686">            throw new NoSuchFieldException(name);</span>
        }
<span class="nc" id="L1688">        return field;</span>
    }


    /**
     * Returns a {@code Method} object that reflects the specified public
     * member method of the class or interface represented by this
     * {@code Class} object. The {@code name} parameter is a
     * {@code String} specifying the simple name of the desired method. The
     * {@code parameterTypes} parameter is an array of {@code Class}
     * objects that identify the method's formal parameter types, in declared
     * order. If {@code parameterTypes} is {@code null}, it is
     * treated as if it were an empty array.
     *
     * &lt;p&gt; If the {@code name} is &quot;{@code &lt;init&gt;};&quot;or &quot;{@code &lt;clinit&gt;}&quot; a
     * {@code NoSuchMethodException} is raised. Otherwise, the method to
     * be reflected is determined by the algorithm that follows.  Let C be the
     * class represented by this object:
     * &lt;OL&gt;
     * &lt;LI&gt; C is searched for any &lt;I&gt;matching methods&lt;/I&gt;. If no matching
     *      method is found, the algorithm of step 1 is invoked recursively on
     *      the superclass of C.&lt;/LI&gt;
     * &lt;LI&gt; If no method was found in step 1 above, the superinterfaces of C
     *      are searched for a matching method. If any such method is found, it
     *      is reflected.&lt;/LI&gt;
     * &lt;/OL&gt;
     *
     * To find a matching method in a class C:&amp;nbsp; If C declares exactly one
     * public method with the specified name and exactly the same formal
     * parameter types, that is the method reflected. If more than one such
     * method is found in C, and one of these methods has a return type that is
     * more specific than any of the others, that method is reflected;
     * otherwise one of the methods is chosen arbitrarily.
     *
     * &lt;p&gt;Note that there may be more than one matching method in a
     * class because while the Java language forbids a class to
     * declare multiple methods with the same signature but different
     * return types, the Java virtual machine does not.  This
     * increased flexibility in the virtual machine can be used to
     * implement various language features.  For example, covariant
     * returns can be implemented with {@linkplain
     * java.lang.reflect.Method#isBridge bridge methods}; the bridge
     * method and the method being overridden would have the same
     * signature but different return types.
     *
     * &lt;p&gt; If this {@code Class} object represents an array type, then this
     * method does not find the {@code clone()} method.
     *
     * &lt;p&gt; Static methods declared in superinterfaces of the class or interface
     * represented by this {@code Class} object are not considered members of
     * the class or interface.
     *
     * @param name the name of the method
     * @param parameterTypes the list of parameters
     * @return the {@code Method} object that matches the specified
     *         {@code name} and {@code parameterTypes}
     * @throws NoSuchMethodException if a matching method is not found
     *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
     * @throws NullPointerException if {@code name} is {@code null}
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @jls 8.2 Class Members
     * @jls 8.4 Method Declarations
     * @since JDK1.1
     */
    @CallerSensitive
    public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
        throws NoSuchMethodException, SecurityException {
<span class="nc" id="L1762">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L1763">        Method method = getMethod0(name, parameterTypes, true);</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">        if (method == null) {</span>
<span class="nc" id="L1765">            throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes));</span>
        }
<span class="nc" id="L1767">        return method;</span>
    }


    /**
     * Returns a {@code Constructor} object that reflects the specified
     * public constructor of the class represented by this {@code Class}
     * object. The {@code parameterTypes} parameter is an array of
     * {@code Class} objects that identify the constructor's formal
     * parameter types, in declared order.
     *
     * If this {@code Class} object represents an inner class
     * declared in a non-static context, the formal parameter types
     * include the explicit enclosing instance as the first parameter.
     *
     * &lt;p&gt; The constructor to reflect is the public constructor of the class
     * represented by this {@code Class} object whose formal parameter
     * types match those specified by {@code parameterTypes}.
     *
     * @param parameterTypes the parameter array
     * @return the {@code Constructor} object of the public constructor that
     *         matches the specified {@code parameterTypes}
     * @throws NoSuchMethodException if a matching method is not found.
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
     *         the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class.
     *
     * @since JDK1.1
     */
    @CallerSensitive
    public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
        throws NoSuchMethodException, SecurityException {
<span class="nc" id="L1803">        checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L1804">        return getConstructor0(parameterTypes, Member.PUBLIC);</span>
    }


    /**
     * Returns an array of {@code Class} objects reflecting all the
     * classes and interfaces declared as members of the class represented by
     * this {@code Class} object. This includes public, protected, default
     * (package) access, and private classes and interfaces declared by the
     * class, but excludes inherited classes and interfaces.  This method
     * returns an array of length 0 if the class declares no classes or
     * interfaces as members, or if this {@code Class} object represents a
     * primitive type, an array class, or void.
     *
     * @return the array of {@code Class} objects representing all the
     *         declared members of this class
     * @throws SecurityException
     *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *         following conditions is met:
     *
     *         &lt;ul&gt;
     *
     *         &lt;li&gt; the caller's class loader is not the same as the
     *         class loader of this class and invocation of
     *         {@link SecurityManager#checkPermission
     *         s.checkPermission} method with
     *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *         denies access to the declared classes within this class
     *
     *         &lt;li&gt; the caller's class loader is not the same as or an
     *         ancestor of the class loader for the current class and
     *         invocation of {@link SecurityManager#checkPackageAccess
     *         s.checkPackageAccess()} denies access to the package
     *         of this class
     *
     *         &lt;/ul&gt;
     *
     * @since JDK1.1
     */
    @CallerSensitive
    public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
<span class="nc" id="L1845">        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), false);</span>
<span class="nc" id="L1846">        return getDeclaredClasses0();</span>
    }


    /**
     * Returns an array of {@code Field} objects reflecting all the fields
     * declared by the class or interface represented by this
     * {@code Class} object. This includes public, protected, default
     * (package) access, and private fields, but excludes inherited fields.
     *
     * &lt;p&gt; If this {@code Class} object represents a class or interface with no
     * declared fields, then this method returns an array of length 0.
     *
     * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
     * type, or void, then this method returns an array of length 0.
     *
     * &lt;p&gt; The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * @return  the array of {@code Field} objects representing all the
     *          declared fields of this class
     * @throws  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared fields within this class
     *
     *          &lt;li&gt; the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * @since JDK1.1
     * @jls 8.2 Class Members
     * @jls 8.3 Field Declarations
     */
    @CallerSensitive
    public Field[] getDeclaredFields() throws SecurityException {
<span class="nc" id="L1894">        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L1895">        return copyFields(privateGetDeclaredFields(false));</span>
    }


    /**
     *
     * Returns an array containing {@code Method} objects reflecting all the
     * declared methods of the class or interface represented by this {@code
     * Class} object, including public, protected, default (package)
     * access, and private methods, but excluding inherited methods.
     *
     * &lt;p&gt; If this {@code Class} object represents a type that has multiple
     * declared methods with the same name and parameter types, but different
     * return types, then the returned array has a {@code Method} object for
     * each such method.
     *
     * &lt;p&gt; If this {@code Class} object represents a type that has a class
     * initialization method {@code &lt;clinit&gt;}, then the returned array does
     * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
     *
     * &lt;p&gt; If this {@code Class} object represents a class or interface with no
     * declared methods, then the returned array has length 0.
     *
     * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
     * type, or void, then the returned array has length 0.
     *
     * &lt;p&gt; The elements in the returned array are not sorted and are not in any
     * particular order.
     *
     * @return  the array of {@code Method} objects representing all the
     *          declared methods of this class
     * @throws  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared methods within this class
     *
     *          &lt;li&gt; the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * @jls 8.2 Class Members
     * @jls 8.4 Method Declarations
     * @since JDK1.1
     */
    @CallerSensitive
    public Method[] getDeclaredMethods() throws SecurityException {
<span class="nc" id="L1953">        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L1954">        return copyMethods(privateGetDeclaredMethods(false));</span>
    }


    /**
     * Returns an array of {@code Constructor} objects reflecting all the
     * constructors declared by the class represented by this
     * {@code Class} object. These are public, protected, default
     * (package) access, and private constructors.  The elements in the array
     * returned are not sorted and are not in any particular order.  If the
     * class has a default constructor, it is included in the returned array.
     * This method returns an array of length 0 if this {@code Class}
     * object represents an interface, a primitive type, an array class, or
     * void.
     *
     * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section 8.2.
     *
     * @return  the array of {@code Constructor} objects representing all the
     *          declared constructors of this class
     * @throws  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared constructors within this class
     *
     *          &lt;li&gt; the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * @since JDK1.1
     */
    @CallerSensitive
    public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
<span class="nc" id="L1998">        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L1999">        return copyConstructors(privateGetDeclaredConstructors(false));</span>
    }


    /**
     * Returns a {@code Field} object that reflects the specified declared
     * field of the class or interface represented by this {@code Class}
     * object. The {@code name} parameter is a {@code String} that specifies
     * the simple name of the desired field.
     *
     * &lt;p&gt; If this {@code Class} object represents an array type, then this
     * method does not find the {@code length} field of the array type.
     *
     * @param name the name of the field
     * @return  the {@code Field} object for the specified field in this
     *          class
     * @throws  NoSuchFieldException if a field with the specified name is
     *          not found.
     * @throws  NullPointerException if {@code name} is {@code null}
     * @throws  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared field
     *
     *          &lt;li&gt; the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * @since JDK1.1
     * @jls 8.2 Class Members
     * @jls 8.3 Field Declarations
     */
    @CallerSensitive
    public Field getDeclaredField(String name)
        throws NoSuchFieldException, SecurityException {
<span class="nc" id="L2046">        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L2047">        Field field = searchFields(privateGetDeclaredFields(false), name);</span>
<span class="nc bnc" id="L2048" title="All 2 branches missed.">        if (field == null) {</span>
<span class="nc" id="L2049">            throw new NoSuchFieldException(name);</span>
        }
<span class="nc" id="L2051">        return field;</span>
    }


    /**
     * Returns a {@code Method} object that reflects the specified
     * declared method of the class or interface represented by this
     * {@code Class} object. The {@code name} parameter is a
     * {@code String} that specifies the simple name of the desired
     * method, and the {@code parameterTypes} parameter is an array of
     * {@code Class} objects that identify the method's formal parameter
     * types, in declared order.  If more than one method with the same
     * parameter types is declared in a class, and one of these methods has a
     * return type that is more specific than any of the others, that method is
     * returned; otherwise one of the methods is chosen arbitrarily.  If the
     * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}
     * is raised.
     *
     * &lt;p&gt; If this {@code Class} object represents an array type, then this
     * method does not find the {@code clone()} method.
     *
     * @param name the name of the method
     * @param parameterTypes the parameter array
     * @return  the {@code Method} object for the method of this class
     *          matching the specified name and parameters
     * @throws  NoSuchMethodException if a matching method is not found.
     * @throws  NullPointerException if {@code name} is {@code null}
     * @throws  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared method
     *
     *          &lt;li&gt; the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * @jls 8.2 Class Members
     * @jls 8.4 Method Declarations
     * @since JDK1.1
     */
    @CallerSensitive
    public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
        throws NoSuchMethodException, SecurityException {
<span class="nc" id="L2106">        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L2107">        Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">        if (method == null) {</span>
<span class="nc" id="L2109">            throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes));</span>
        }
<span class="nc" id="L2111">        return method;</span>
    }


    /**
     * Returns a {@code Constructor} object that reflects the specified
     * constructor of the class or interface represented by this
     * {@code Class} object.  The {@code parameterTypes} parameter is
     * an array of {@code Class} objects that identify the constructor's
     * formal parameter types, in declared order.
     *
     * If this {@code Class} object represents an inner class
     * declared in a non-static context, the formal parameter types
     * include the explicit enclosing instance as the first parameter.
     *
     * @param parameterTypes the parameter array
     * @return  The {@code Constructor} object for the constructor with the
     *          specified parameter list
     * @throws  NoSuchMethodException if a matching method is not found.
     * @throws  SecurityException
     *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
     *          following conditions is met:
     *
     *          &lt;ul&gt;
     *
     *          &lt;li&gt; the caller's class loader is not the same as the
     *          class loader of this class and invocation of
     *          {@link SecurityManager#checkPermission
     *          s.checkPermission} method with
     *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
     *          denies access to the declared constructor
     *
     *          &lt;li&gt; the caller's class loader is not the same as or an
     *          ancestor of the class loader for the current class and
     *          invocation of {@link SecurityManager#checkPackageAccess
     *          s.checkPackageAccess()} denies access to the package
     *          of this class
     *
     *          &lt;/ul&gt;
     *
     * @since JDK1.1
     */
    @CallerSensitive
    public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
        throws NoSuchMethodException, SecurityException {
<span class="nc" id="L2156">        checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);</span>
<span class="nc" id="L2157">        return getConstructor0(parameterTypes, Member.DECLARED);</span>
    }

    /**
     * Finds a resource with a given name.  The rules for searching resources
     * associated with a given class are implemented by the defining
     * {@linkplain ClassLoader class loader} of the class.  This method
     * delegates to this object's class loader.  If this object was loaded by
     * the bootstrap class loader, the method delegates to {@link
     * ClassLoader#getSystemResourceAsStream}.
     *
     * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
     * given resource name using this algorithm:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt; If the {@code name} begins with a {@code '/'}
     * (&lt;tt&gt;'&amp;#92;u002f'&lt;/tt&gt;), then the absolute name of the resource is the
     * portion of the {@code name} following the {@code '/'}.
     *
     * &lt;li&gt; Otherwise, the absolute name is of the following form:
     *
     * &lt;blockquote&gt;
     *   {@code modified_package_name/name}
     * &lt;/blockquote&gt;
     *
     * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
     * object with {@code '/'} substituted for {@code '.'}
     * (&lt;tt&gt;'&amp;#92;u002e'&lt;/tt&gt;).
     *
     * &lt;/ul&gt;
     *
     * @param  name name of the desired resource
     * @return      A {@link java.io.InputStream} object or {@code null} if
     *              no resource with this name is found
     * @throws  NullPointerException If {@code name} is {@code null}
     * @since  JDK1.1
     */
     public InputStream getResourceAsStream(String name) {
<span class="nc" id="L2196">        name = resolveName(name);</span>
<span class="nc" id="L2197">        ClassLoader cl = getClassLoader0();</span>
<span class="nc bnc" id="L2198" title="All 2 branches missed.">        if (cl==null) {</span>
            // A system class.
<span class="nc" id="L2200">            return ClassLoader.getSystemResourceAsStream(name);</span>
        }
<span class="nc" id="L2202">        return cl.getResourceAsStream(name);</span>
    }

    /**
     * Finds a resource with a given name.  The rules for searching resources
     * associated with a given class are implemented by the defining
     * {@linkplain ClassLoader class loader} of the class.  This method
     * delegates to this object's class loader.  If this object was loaded by
     * the bootstrap class loader, the method delegates to {@link
     * ClassLoader#getSystemResource}.
     *
     * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
     * given resource name using this algorithm:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt; If the {@code name} begins with a {@code '/'}
     * (&lt;tt&gt;'&amp;#92;u002f'&lt;/tt&gt;), then the absolute name of the resource is the
     * portion of the {@code name} following the {@code '/'}.
     *
     * &lt;li&gt; Otherwise, the absolute name is of the following form:
     *
     * &lt;blockquote&gt;
     *   {@code modified_package_name/name}
     * &lt;/blockquote&gt;
     *
     * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
     * object with {@code '/'} substituted for {@code '.'}
     * (&lt;tt&gt;'&amp;#92;u002e'&lt;/tt&gt;).
     *
     * &lt;/ul&gt;
     *
     * @param  name name of the desired resource
     * @return      A  {@link java.net.URL} object or {@code null} if no
     *              resource with this name is found
     * @since  JDK1.1
     */
    public java.net.URL getResource(String name) {
<span class="nc" id="L2240">        name = resolveName(name);</span>
<span class="nc" id="L2241">        ClassLoader cl = getClassLoader0();</span>
<span class="nc bnc" id="L2242" title="All 2 branches missed.">        if (cl==null) {</span>
            // A system class.
<span class="nc" id="L2244">            return ClassLoader.getSystemResource(name);</span>
        }
<span class="nc" id="L2246">        return cl.getResource(name);</span>
    }



    /** protection domain returned when the internal domain is null */
    private static java.security.ProtectionDomain allPermDomain;


    /**
     * Returns the {@code ProtectionDomain} of this class.  If there is a
     * security manager installed, this method first calls the security
     * manager's {@code checkPermission} method with a
     * {@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
     * ensure it's ok to get the
     * {@code ProtectionDomain}.
     *
     * @return the ProtectionDomain of this class
     *
     * @throws SecurityException
     *        if a security manager exists and its
     *        {@code checkPermission} method doesn't allow
     *        getting the ProtectionDomain.
     *
     * @see java.security.ProtectionDomain
     * @see SecurityManager#checkPermission
     * @see java.lang.RuntimePermission
     * @since 1.2
     */
    public java.security.ProtectionDomain getProtectionDomain() {
<span class="nc" id="L2276">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L2277" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L2278">            sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);</span>
        }
<span class="nc" id="L2280">        java.security.ProtectionDomain pd = getProtectionDomain0();</span>
<span class="nc bnc" id="L2281" title="All 2 branches missed.">        if (pd == null) {</span>
<span class="nc bnc" id="L2282" title="All 2 branches missed.">            if (allPermDomain == null) {</span>
<span class="nc" id="L2283">                java.security.Permissions perms =</span>
                    new java.security.Permissions();
<span class="nc" id="L2285">                perms.add(SecurityConstants.ALL_PERMISSION);</span>
<span class="nc" id="L2286">                allPermDomain =</span>
                    new java.security.ProtectionDomain(null, perms);
            }
<span class="nc" id="L2289">            pd = allPermDomain;</span>
        }
<span class="nc" id="L2291">        return pd;</span>
    }


    /**
     * Returns the ProtectionDomain of this class.
     */
    private native java.security.ProtectionDomain getProtectionDomain0();

    /*
     * Return the Virtual Machine's Class object for the named
     * primitive type.
     */
    static native Class&lt;?&gt; getPrimitiveClass(String name);

    /*
     * Check if client is allowed to access members.  If access is denied,
     * throw a SecurityException.
     *
     * This method also enforces package access.
     *
     * &lt;p&gt; Default policy: allow all clients access with normal Java access
     * control.
     */
    private void checkMemberAccess(int which, Class&lt;?&gt; caller, boolean checkProxyInterfaces) {
<span class="nc" id="L2316">        final SecurityManager s = System.getSecurityManager();</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">        if (s != null) {</span>
            /* Default policy allows access to all {@link Member#PUBLIC} members,
             * as well as access to classes that have the same class loader as the caller.
             * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
             * permission.
             */
<span class="nc" id="L2323">            final ClassLoader ccl = ClassLoader.getClassLoader(caller);</span>
<span class="nc" id="L2324">            final ClassLoader cl = getClassLoader0();</span>
<span class="nc bnc" id="L2325" title="All 2 branches missed.">            if (which != Member.PUBLIC) {</span>
<span class="nc bnc" id="L2326" title="All 2 branches missed.">                if (ccl != cl) {</span>
<span class="nc" id="L2327">                    s.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);</span>
                }
            }
<span class="nc" id="L2330">            this.checkPackageAccess(ccl, checkProxyInterfaces);</span>
        }
<span class="nc" id="L2332">    }</span>

    /*
     * Checks if a client loaded in ClassLoader ccl is allowed to access this
     * class under the current package access policy. If access is denied,
     * throw a SecurityException.
     */
    private void checkPackageAccess(final ClassLoader ccl, boolean checkProxyInterfaces) {
<span class="nc" id="L2340">        final SecurityManager s = System.getSecurityManager();</span>
<span class="nc bnc" id="L2341" title="All 2 branches missed.">        if (s != null) {</span>
<span class="nc" id="L2342">            final ClassLoader cl = getClassLoader0();</span>

<span class="nc bnc" id="L2344" title="All 2 branches missed.">            if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {</span>
<span class="nc" id="L2345">                String name = this.getName();</span>
<span class="nc" id="L2346">                int i = name.lastIndexOf('.');</span>
<span class="nc bnc" id="L2347" title="All 2 branches missed.">                if (i != -1) {</span>
                    // skip the package access check on a proxy class in default proxy package
<span class="nc" id="L2349">                    String pkg = name.substring(0, i);</span>
<span class="nc bnc" id="L2350" title="All 4 branches missed.">                    if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {</span>
<span class="nc" id="L2351">                        s.checkPackageAccess(pkg);</span>
                    }
                }
            }
            // check package access on the proxy interfaces
<span class="nc bnc" id="L2356" title="All 4 branches missed.">            if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {</span>
<span class="nc" id="L2357">                ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());</span>
            }
        }
<span class="nc" id="L2360">    }</span>

    /**
     * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
     * if name is absolute
     */
    private String resolveName(String name) {
<span class="nc bnc" id="L2367" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L2368">            return name;</span>
        }
<span class="nc bnc" id="L2370" title="All 2 branches missed.">        if (!name.startsWith(&quot;/&quot;)) {</span>
<span class="nc" id="L2371">            Class&lt;?&gt; c = this;</span>
<span class="nc bnc" id="L2372" title="All 2 branches missed.">            while (c.isArray()) {</span>
<span class="nc" id="L2373">                c = c.getComponentType();</span>
            }
<span class="nc" id="L2375">            String baseName = c.getName();</span>
<span class="nc" id="L2376">            int index = baseName.lastIndexOf('.');</span>
<span class="nc bnc" id="L2377" title="All 2 branches missed.">            if (index != -1) {</span>
<span class="nc" id="L2378">                name = baseName.substring(0, index).replace('.', '/')</span>
                    +&quot;/&quot;+name;
            }
<span class="nc" id="L2381">        } else {</span>
<span class="nc" id="L2382">            name = name.substring(1);</span>
        }
<span class="nc" id="L2384">        return name;</span>
    }

    /**
     * Atomic operations support.
     */
<span class="nc" id="L2390">    private static class Atomic {</span>
        // initialize Unsafe machinery here, since we need to call Class.class instance method
        // and have to avoid calling it in the static initializer of the Class class...
<span class="fc" id="L2393">        private static final Unsafe unsafe = Unsafe.getUnsafe();</span>
        // offset of Class.reflectionData instance field
        private static final long reflectionDataOffset;
        // offset of Class.annotationType instance field
        private static final long annotationTypeOffset;
        // offset of Class.annotationData instance field
        private static final long annotationDataOffset;

        static {
<span class="fc" id="L2402">            Field[] fields = Class.class.getDeclaredFields0(false); // bypass caches</span>
<span class="fc" id="L2403">            reflectionDataOffset = objectFieldOffset(fields, &quot;reflectionData&quot;);</span>
<span class="fc" id="L2404">            annotationTypeOffset = objectFieldOffset(fields, &quot;annotationType&quot;);</span>
<span class="fc" id="L2405">            annotationDataOffset = objectFieldOffset(fields, &quot;annotationData&quot;);</span>
<span class="fc" id="L2406">        }</span>

        private static long objectFieldOffset(Field[] fields, String fieldName) {
<span class="fc" id="L2409">            Field field = searchFields(fields, fieldName);</span>
<span class="pc bpc" id="L2410" title="1 of 2 branches missed.">            if (field == null) {</span>
<span class="nc" id="L2411">                throw new Error(&quot;No &quot; + fieldName + &quot; field found in java.lang.Class&quot;);</span>
            }
<span class="fc" id="L2413">            return unsafe.objectFieldOffset(field);</span>
        }

        static &lt;T&gt; boolean casReflectionData(Class&lt;?&gt; clazz,
                                             SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
                                             SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) {
<span class="fc" id="L2419">            return unsafe.compareAndSwapObject(clazz, reflectionDataOffset, oldData, newData);</span>
        }

        static &lt;T&gt; boolean casAnnotationType(Class&lt;?&gt; clazz,
                                             AnnotationType oldType,
                                             AnnotationType newType) {
<span class="fc" id="L2425">            return unsafe.compareAndSwapObject(clazz, annotationTypeOffset, oldType, newType);</span>
        }

        static &lt;T&gt; boolean casAnnotationData(Class&lt;?&gt; clazz,
                                             AnnotationData oldData,
                                             AnnotationData newData) {
<span class="fc" id="L2431">            return unsafe.compareAndSwapObject(clazz, annotationDataOffset, oldData, newData);</span>
        }
    }

    /**
     * Reflection support.
     */

    // Caches for certain reflective results
<span class="nc" id="L2440">    private static boolean useCaches = true;</span>

    // reflection data that might get invalidated when JVM TI RedefineClasses() is called
    private static class ReflectionData&lt;T&gt; {
        volatile Field[] declaredFields;
        volatile Field[] publicFields;
        volatile Method[] declaredMethods;
        volatile Method[] publicMethods;
        volatile Constructor&lt;T&gt;[] declaredConstructors;
        volatile Constructor&lt;T&gt;[] publicConstructors;
        // Intermediate results for getFields and getMethods
        volatile Field[] declaredPublicFields;
        volatile Method[] declaredPublicMethods;
        volatile Class&lt;?&gt;[] interfaces;

        // Value of classRedefinedCount when we created this ReflectionData instance
        final int redefinedCount;

<span class="fc" id="L2458">        ReflectionData(int redefinedCount) {</span>
<span class="fc" id="L2459">            this.redefinedCount = redefinedCount;</span>
<span class="fc" id="L2460">        }</span>
    }

    private volatile transient SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;

    // Incremented by the VM on each call to JVM TI RedefineClasses()
    // that redefines this class or a superclass.
<span class="nc" id="L2467">    private volatile transient int classRedefinedCount = 0;</span>

    // Lazily create and cache ReflectionData
    private ReflectionData&lt;T&gt; reflectionData() {
<span class="nc" id="L2471">        SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;</span>
<span class="nc" id="L2472">        int classRedefinedCount = this.classRedefinedCount;</span>
        ReflectionData&lt;T&gt; rd;
<span class="nc bnc" id="L2474" title="All 4 branches missed.">        if (useCaches &amp;&amp;</span>
            reflectionData != null &amp;&amp;
<span class="nc bnc" id="L2476" title="All 4 branches missed.">            (rd = reflectionData.get()) != null &amp;&amp;</span>
            rd.redefinedCount == classRedefinedCount) {
<span class="nc" id="L2478">            return rd;</span>
        }
        // else no SoftReference or cleared SoftReference or stale ReflectionData
        // -&gt; create and replace new instance
<span class="nc" id="L2482">        return newReflectionData(reflectionData, classRedefinedCount);</span>
    }

    private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
                                                int classRedefinedCount) {
<span class="nc bnc" id="L2487" title="All 2 branches missed.">        if (!useCaches) return null;</span>

        while (true) {
<span class="nc" id="L2490">            ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);</span>
            // try to CAS it...
<span class="nc bnc" id="L2492" title="All 2 branches missed.">            if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {</span>
<span class="nc" id="L2493">                return rd;</span>
            }
            // else retry
<span class="nc" id="L2496">            oldReflectionData = this.reflectionData;</span>
<span class="nc" id="L2497">            classRedefinedCount = this.classRedefinedCount;</span>
<span class="nc bnc" id="L2498" title="All 2 branches missed.">            if (oldReflectionData != null &amp;&amp;</span>
<span class="nc bnc" id="L2499" title="All 4 branches missed.">                (rd = oldReflectionData.get()) != null &amp;&amp;</span>
                rd.redefinedCount == classRedefinedCount) {
<span class="nc" id="L2501">                return rd;</span>
            }
<span class="nc" id="L2503">        }</span>
    }

    // Generic signature handling
    private native String getGenericSignature0();

    // Generic info repository; lazily initialized
    private volatile transient ClassRepository genericInfo;

    // accessor for factory
    private GenericsFactory getFactory() {
        // create scope and factory
<span class="nc" id="L2515">        return CoreReflectionFactory.make(this, ClassScope.make(this));</span>
    }

    // accessor for generic info repository;
    // generic info is lazily initialized
    private ClassRepository getGenericInfo() {
<span class="nc" id="L2521">        ClassRepository genericInfo = this.genericInfo;</span>
<span class="nc bnc" id="L2522" title="All 2 branches missed.">        if (genericInfo == null) {</span>
<span class="nc" id="L2523">            String signature = getGenericSignature0();</span>
<span class="nc bnc" id="L2524" title="All 2 branches missed.">            if (signature == null) {</span>
<span class="nc" id="L2525">                genericInfo = ClassRepository.NONE;</span>
            } else {
<span class="nc" id="L2527">                genericInfo = ClassRepository.make(signature, getFactory());</span>
            }
<span class="nc" id="L2529">            this.genericInfo = genericInfo;</span>
        }
<span class="nc bnc" id="L2531" title="All 2 branches missed.">        return (genericInfo != ClassRepository.NONE) ? genericInfo : null;</span>
    }

    // Annotations handling
    native byte[] getRawAnnotations();
    // Since 1.8
    native byte[] getRawTypeAnnotations();
    static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
<span class="nc" id="L2539">        return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);</span>
    }

    native ConstantPool getConstantPool();

    //
    //
    // java.lang.reflect.Field handling
    //
    //

    // Returns an array of &quot;root&quot; fields. These Field objects must NOT
    // be propagated to the outside world, but must instead be copied
    // via ReflectionFactory.copyField.
    private Field[] privateGetDeclaredFields(boolean publicOnly) {
<span class="nc" id="L2554">        checkInitted();</span>
        Field[] res;
<span class="nc" id="L2556">        ReflectionData&lt;T&gt; rd = reflectionData();</span>
<span class="nc bnc" id="L2557" title="All 2 branches missed.">        if (rd != null) {</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">            res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;</span>
<span class="nc bnc" id="L2559" title="All 2 branches missed.">            if (res != null) return res;</span>
        }
        // No cached value available; request value from VM
<span class="nc" id="L2562">        res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));</span>
<span class="nc bnc" id="L2563" title="All 2 branches missed.">        if (rd != null) {</span>
<span class="nc bnc" id="L2564" title="All 2 branches missed.">            if (publicOnly) {</span>
<span class="nc" id="L2565">                rd.declaredPublicFields = res;</span>
            } else {
<span class="nc" id="L2567">                rd.declaredFields = res;</span>
            }
        }
<span class="nc" id="L2570">        return res;</span>
    }

    // Returns an array of &quot;root&quot; fields. These Field objects must NOT
    // be propagated to the outside world, but must instead be copied
    // via ReflectionFactory.copyField.
    private Field[] privateGetPublicFields(Set&lt;Class&lt;?&gt;&gt; traversedInterfaces) {
<span class="nc" id="L2577">        checkInitted();</span>
        Field[] res;
<span class="nc" id="L2579">        ReflectionData&lt;T&gt; rd = reflectionData();</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">        if (rd != null) {</span>
<span class="nc" id="L2581">            res = rd.publicFields;</span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">            if (res != null) return res;</span>
        }

        // No cached value available; compute value recursively.
        // Traverse in correct order for getField().
<span class="nc" id="L2587">        List&lt;Field&gt; fields = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L2588" title="All 2 branches missed.">        if (traversedInterfaces == null) {</span>
<span class="nc" id="L2589">            traversedInterfaces = new HashSet&lt;&gt;();</span>
        }

        // Local fields
<span class="nc" id="L2593">        Field[] tmp = privateGetDeclaredFields(true);</span>
<span class="nc" id="L2594">        addAll(fields, tmp);</span>

        // Direct superinterfaces, recursively
<span class="nc bnc" id="L2597" title="All 2 branches missed.">        for (Class&lt;?&gt; c : getInterfaces()) {</span>
<span class="nc bnc" id="L2598" title="All 2 branches missed.">            if (!traversedInterfaces.contains(c)) {</span>
<span class="nc" id="L2599">                traversedInterfaces.add(c);</span>
<span class="nc" id="L2600">                addAll(fields, c.privateGetPublicFields(traversedInterfaces));</span>
            }
        }

        // Direct superclass, recursively
<span class="nc bnc" id="L2605" title="All 2 branches missed.">        if (!isInterface()) {</span>
<span class="nc" id="L2606">            Class&lt;?&gt; c = getSuperclass();</span>
<span class="nc bnc" id="L2607" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L2608">                addAll(fields, c.privateGetPublicFields(traversedInterfaces));</span>
            }
        }

<span class="nc" id="L2612">        res = new Field[fields.size()];</span>
<span class="nc" id="L2613">        fields.toArray(res);</span>
<span class="nc bnc" id="L2614" title="All 2 branches missed.">        if (rd != null) {</span>
<span class="nc" id="L2615">            rd.publicFields = res;</span>
        }
<span class="nc" id="L2617">        return res;</span>
    }

    private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
<span class="nc bnc" id="L2621" title="All 2 branches missed.">        for (int i = 0; i &lt; o.length; i++) {</span>
<span class="nc" id="L2622">            c.add(o[i]);</span>
        }
<span class="nc" id="L2624">    }</span>


    //
    //
    // java.lang.reflect.Constructor handling
    //
    //

    // Returns an array of &quot;root&quot; constructors. These Constructor
    // objects must NOT be propagated to the outside world, but must
    // instead be copied via ReflectionFactory.copyConstructor.
    private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
<span class="nc" id="L2637">        checkInitted();</span>
        Constructor&lt;T&gt;[] res;
<span class="nc" id="L2639">        ReflectionData&lt;T&gt; rd = reflectionData();</span>
<span class="nc bnc" id="L2640" title="All 2 branches missed.">        if (rd != null) {</span>
<span class="nc bnc" id="L2641" title="All 2 branches missed.">            res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;</span>
<span class="nc bnc" id="L2642" title="All 2 branches missed.">            if (res != null) return res;</span>
        }
        // No cached value available; request value from VM
<span class="nc bnc" id="L2645" title="All 2 branches missed.">        if (isInterface()) {</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L2647">            Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];</span>
<span class="nc" id="L2648">            res = temporaryRes;</span>
<span class="nc" id="L2649">        } else {</span>
<span class="nc" id="L2650">            res = getDeclaredConstructors0(publicOnly);</span>
        }
<span class="nc bnc" id="L2652" title="All 2 branches missed.">        if (rd != null) {</span>
<span class="nc bnc" id="L2653" title="All 2 branches missed.">            if (publicOnly) {</span>
<span class="nc" id="L2654">                rd.publicConstructors = res;</span>
            } else {
<span class="nc" id="L2656">                rd.declaredConstructors = res;</span>
            }
        }
<span class="nc" id="L2659">        return res;</span>
    }

    //
    //
    // java.lang.reflect.Method handling
    //
    //

    // Returns an array of &quot;root&quot; methods. These Method objects must NOT
    // be propagated to the outside world, but must instead be copied
    // via ReflectionFactory.copyMethod.
    private Method[] privateGetDeclaredMethods(boolean publicOnly) {
<span class="nc" id="L2672">        checkInitted();</span>
        Method[] res;
<span class="nc" id="L2674">        ReflectionData&lt;T&gt; rd = reflectionData();</span>
<span class="nc bnc" id="L2675" title="All 2 branches missed.">        if (rd != null) {</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">            res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">            if (res != null) return res;</span>
        }
        // No cached value available; request value from VM
<span class="nc" id="L2680">        res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));</span>
<span class="nc bnc" id="L2681" title="All 2 branches missed.">        if (rd != null) {</span>
<span class="nc bnc" id="L2682" title="All 2 branches missed.">            if (publicOnly) {</span>
<span class="nc" id="L2683">                rd.declaredPublicMethods = res;</span>
            } else {
<span class="nc" id="L2685">                rd.declaredMethods = res;</span>
            }
        }
<span class="nc" id="L2688">        return res;</span>
    }

    static class MethodArray {
        private Method[] methods;
        private int length;

<span class="fc" id="L2695">        MethodArray() {</span>
<span class="fc" id="L2696">            methods = new Method[20];</span>
<span class="fc" id="L2697">            length = 0;</span>
<span class="fc" id="L2698">        }</span>

        void add(Method m) {
<span class="fc bfc" id="L2701" title="All 2 branches covered.">            if (length == methods.length) {</span>
<span class="fc" id="L2702">                methods = Arrays.copyOf(methods, 2 * methods.length);</span>
            }
<span class="fc" id="L2704">            methods[length++] = m;</span>
<span class="fc" id="L2705">        }</span>

        void addAll(Method[] ma) {
<span class="fc bfc" id="L2708" title="All 2 branches covered.">            for (int i = 0; i &lt; ma.length; i++) {</span>
<span class="fc" id="L2709">                add(ma[i]);</span>
            }
<span class="fc" id="L2711">        }</span>

        void addAll(MethodArray ma) {
<span class="fc bfc" id="L2714" title="All 2 branches covered.">            for (int i = 0; i &lt; ma.length(); i++) {</span>
<span class="fc" id="L2715">                add(ma.get(i));</span>
            }
<span class="fc" id="L2717">        }</span>

        void addIfNotPresent(Method newMethod) {
<span class="fc bfc" id="L2720" title="All 2 branches covered.">            for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L2721">                Method m = methods[i];</span>
<span class="pc bpc" id="L2722" title="3 of 6 branches missed.">                if (m == newMethod || (m != null &amp;&amp; m.equals(newMethod))) {</span>
<span class="nc" id="L2723">                    return;</span>
                }
            }
<span class="fc" id="L2726">            add(newMethod);</span>
<span class="fc" id="L2727">        }</span>

        void addAllIfNotPresent(MethodArray newMethods) {
<span class="fc bfc" id="L2730" title="All 2 branches covered.">            for (int i = 0; i &lt; newMethods.length(); i++) {</span>
<span class="fc" id="L2731">                Method m = newMethods.get(i);</span>
<span class="fc bfc" id="L2732" title="All 2 branches covered.">                if (m != null) {</span>
<span class="fc" id="L2733">                    addIfNotPresent(m);</span>
                }
            }
<span class="fc" id="L2736">        }</span>

        void addAllNonStatic(Method[] methods) {
<span class="fc bfc" id="L2739" title="All 2 branches covered.">            for (Method candidate : methods) {</span>
<span class="pc bpc" id="L2740" title="1 of 2 branches missed.">                if (!Modifier.isStatic(candidate.getModifiers())) {</span>
<span class="fc" id="L2741">                    add(candidate);</span>
                }
            }
<span class="fc" id="L2744">        }</span>

        int length() {
<span class="fc" id="L2747">            return length;</span>
        }

        Method get(int i) {
<span class="fc" id="L2751">            return methods[i];</span>
        }

        void removeByNameAndSignature(Method toRemove) {
<span class="fc bfc" id="L2755" title="All 2 branches covered.">            for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L2756">                Method m = methods[i];</span>
<span class="fc bfc" id="L2757" title="All 2 branches covered.">                if (m != null &amp;&amp;</span>
<span class="fc bfc" id="L2758" title="All 2 branches covered.">                    m.getReturnType() == toRemove.getReturnType() &amp;&amp;</span>
<span class="fc bfc" id="L2759" title="All 2 branches covered.">                    m.getName() == toRemove.getName() &amp;&amp;</span>
<span class="fc bfc" id="L2760" title="All 2 branches covered.">                    arrayContentsEq(m.getParameterTypes(),</span>
<span class="fc" id="L2761">                                    toRemove.getParameterTypes())) {</span>
<span class="fc" id="L2762">                    methods[i] = null;</span>
                }
            }
<span class="fc" id="L2765">        }</span>

        void compactAndTrim() {
<span class="fc" id="L2768">            int newPos = 0;</span>
            // Get rid of null slots
<span class="fc bfc" id="L2770" title="All 2 branches covered.">            for (int pos = 0; pos &lt; length; pos++) {</span>
<span class="fc" id="L2771">                Method m = methods[pos];</span>
<span class="pc bpc" id="L2772" title="1 of 2 branches missed.">                if (m != null) {</span>
<span class="pc bpc" id="L2773" title="1 of 2 branches missed.">                    if (pos != newPos) {</span>
<span class="nc" id="L2774">                        methods[newPos] = m;</span>
                    }
<span class="fc" id="L2776">                    newPos++;</span>
                }
            }
<span class="fc bfc" id="L2779" title="All 2 branches covered.">            if (newPos != methods.length) {</span>
<span class="fc" id="L2780">                methods = Arrays.copyOf(methods, newPos);</span>
            }
<span class="fc" id="L2782">        }</span>

        Method[] getArray() {
<span class="fc" id="L2785">            return methods;</span>
        }
    }


    // Returns an array of &quot;root&quot; methods. These Method objects must NOT
    // be propagated to the outside world, but must instead be copied
    // via ReflectionFactory.copyMethod.
    private Method[] privateGetPublicMethods() {
<span class="nc" id="L2794">        checkInitted();</span>
        Method[] res;
<span class="nc" id="L2796">        ReflectionData&lt;T&gt; rd = reflectionData();</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">        if (rd != null) {</span>
<span class="nc" id="L2798">            res = rd.publicMethods;</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">            if (res != null) return res;</span>
        }

        // No cached value available; compute value recursively.
        // Start by fetching public declared methods
<span class="nc" id="L2804">        MethodArray methods = new MethodArray();</span>
        {
<span class="nc" id="L2806">            Method[] tmp = privateGetDeclaredMethods(true);</span>
<span class="nc" id="L2807">            methods.addAll(tmp);</span>
        }
        // Now recur over superclass and direct superinterfaces.
        // Go over superinterfaces first so we can more easily filter
        // out concrete implementations inherited from superclasses at
        // the end.
<span class="nc" id="L2813">        MethodArray inheritedMethods = new MethodArray();</span>
<span class="nc" id="L2814">        Class&lt;?&gt;[] interfaces = getInterfaces();</span>
<span class="nc bnc" id="L2815" title="All 2 branches missed.">        for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="nc" id="L2816">            inheritedMethods.addAllNonStatic(interfaces[i].privateGetPublicMethods());</span>
        }
<span class="nc bnc" id="L2818" title="All 2 branches missed.">        if (!isInterface()) {</span>
<span class="nc" id="L2819">            Class&lt;?&gt; c = getSuperclass();</span>
<span class="nc bnc" id="L2820" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc" id="L2821">                MethodArray supers = new MethodArray();</span>
<span class="nc" id="L2822">                supers.addAll(c.privateGetPublicMethods());</span>
                // Filter out concrete implementations of any
                // interface methods
<span class="nc bnc" id="L2825" title="All 2 branches missed.">                for (int i = 0; i &lt; supers.length(); i++) {</span>
<span class="nc" id="L2826">                    Method m = supers.get(i);</span>
<span class="nc bnc" id="L2827" title="All 4 branches missed.">                    if (m != null &amp;&amp; !Modifier.isAbstract(m.getModifiers())) {</span>
<span class="nc" id="L2828">                        inheritedMethods.removeByNameAndSignature(m);</span>
                    }
                }
                // Insert superclass's inherited methods before
                // superinterfaces' to satisfy getMethod's search
                // order
<span class="nc" id="L2834">                supers.addAll(inheritedMethods);</span>
<span class="nc" id="L2835">                inheritedMethods = supers;</span>
            }
        }
        // Filter out all local methods from inherited ones
<span class="nc bnc" id="L2839" title="All 2 branches missed.">        for (int i = 0; i &lt; methods.length(); i++) {</span>
<span class="nc" id="L2840">            Method m = methods.get(i);</span>
<span class="nc" id="L2841">            inheritedMethods.removeByNameAndSignature(m);</span>
        }
<span class="nc" id="L2843">        methods.addAllIfNotPresent(inheritedMethods);</span>
<span class="nc" id="L2844">        methods.compactAndTrim();</span>
<span class="nc" id="L2845">        res = methods.getArray();</span>
<span class="nc bnc" id="L2846" title="All 2 branches missed.">        if (rd != null) {</span>
<span class="nc" id="L2847">            rd.publicMethods = res;</span>
        }
<span class="nc" id="L2849">        return res;</span>
    }


    //
    // Helpers for fetchers of one field, method, or constructor
    //

    private static Field searchFields(Field[] fields, String name) {
<span class="nc" id="L2858">        String internedName = name.intern();</span>
<span class="nc bnc" id="L2859" title="All 2 branches missed.">        for (int i = 0; i &lt; fields.length; i++) {</span>
<span class="nc bnc" id="L2860" title="All 2 branches missed.">            if (fields[i].getName() == internedName) {</span>
<span class="nc" id="L2861">                return getReflectionFactory().copyField(fields[i]);</span>
            }
        }
<span class="nc" id="L2864">        return null;</span>
    }

    private Field getField0(String name) throws NoSuchFieldException {
        // Note: the intent is that the search algorithm this routine
        // uses be equivalent to the ordering imposed by
        // privateGetPublicFields(). It fetches only the declared
        // public fields for each class, however, to reduce the number
        // of Field objects which have to be created for the common
        // case where the field being requested is declared in the
        // class which is being queried.
        Field res;
        // Search declared public fields
<span class="nc bnc" id="L2877" title="All 2 branches missed.">        if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {</span>
<span class="nc" id="L2878">            return res;</span>
        }
        // Direct superinterfaces, recursively
<span class="nc" id="L2881">        Class&lt;?&gt;[] interfaces = getInterfaces();</span>
<span class="nc bnc" id="L2882" title="All 2 branches missed.">        for (int i = 0; i &lt; interfaces.length; i++) {</span>
<span class="nc" id="L2883">            Class&lt;?&gt; c = interfaces[i];</span>
<span class="nc bnc" id="L2884" title="All 2 branches missed.">            if ((res = c.getField0(name)) != null) {</span>
<span class="nc" id="L2885">                return res;</span>
            }
        }
        // Direct superclass, recursively
<span class="nc bnc" id="L2889" title="All 2 branches missed.">        if (!isInterface()) {</span>
<span class="nc" id="L2890">            Class&lt;?&gt; c = getSuperclass();</span>
<span class="nc bnc" id="L2891" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc bnc" id="L2892" title="All 2 branches missed.">                if ((res = c.getField0(name)) != null) {</span>
<span class="nc" id="L2893">                    return res;</span>
                }
            }
        }
<span class="nc" id="L2897">        return null;</span>
    }

    private static Method searchMethods(Method[] methods,
                                        String name,
                                        Class&lt;?&gt;[] parameterTypes)
    {
<span class="nc" id="L2904">        Method res = null;</span>
<span class="nc" id="L2905">        String internedName = name.intern();</span>
<span class="nc bnc" id="L2906" title="All 2 branches missed.">        for (int i = 0; i &lt; methods.length; i++) {</span>
<span class="nc" id="L2907">            Method m = methods[i];</span>
<span class="nc bnc" id="L2908" title="All 2 branches missed.">            if (m.getName() == internedName</span>
<span class="nc bnc" id="L2909" title="All 4 branches missed.">                &amp;&amp; arrayContentsEq(parameterTypes, m.getParameterTypes())</span>
                &amp;&amp; (res == null
<span class="nc bnc" id="L2911" title="All 2 branches missed.">                    || res.getReturnType().isAssignableFrom(m.getReturnType())))</span>
<span class="nc" id="L2912">                res = m;</span>
        }

<span class="nc bnc" id="L2915" title="All 2 branches missed.">        return (res == null ? res : getReflectionFactory().copyMethod(res));</span>
    }


    private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes, boolean includeStaticMethods) {
        // Note: the intent is that the search algorithm this routine
        // uses be equivalent to the ordering imposed by
        // privateGetPublicMethods(). It fetches only the declared
        // public methods for each class, however, to reduce the
        // number of Method objects which have to be created for the
        // common case where the method being requested is declared in
        // the class which is being queried.
        Method res;
        // Search declared public methods
<span class="nc bnc" id="L2929" title="All 2 branches missed.">        if ((res = searchMethods(privateGetDeclaredMethods(true),</span>
                                 name,
                                 parameterTypes)) != null) {
<span class="nc bnc" id="L2932" title="All 4 branches missed.">            if (includeStaticMethods || !Modifier.isStatic(res.getModifiers()))</span>
<span class="nc" id="L2933">                return res;</span>
        }
        // Search superclass's methods
<span class="nc bnc" id="L2936" title="All 2 branches missed.">        if (!isInterface()) {</span>
<span class="nc" id="L2937">            Class&lt;? super T&gt; c = getSuperclass();</span>
<span class="nc bnc" id="L2938" title="All 2 branches missed.">            if (c != null) {</span>
<span class="nc bnc" id="L2939" title="All 2 branches missed.">                if ((res = c.getMethod0(name, parameterTypes, true)) != null) {</span>
<span class="nc" id="L2940">                    return res;</span>
                }
            }
        }
        // Search superinterfaces' methods
<span class="nc" id="L2945">        Class&lt;?&gt;[] interfaces = getInterfaces();</span>
<span class="nc bnc" id="L2946" title="All 2 branches missed.">        for (Class&lt;?&gt; c : interfaces)</span>
<span class="nc bnc" id="L2947" title="All 2 branches missed.">            if ((res = c.getMethod0(name, parameterTypes, false)) != null)</span>
<span class="nc" id="L2948">                return res;</span>
        // Not found
<span class="nc" id="L2950">        return null;</span>
    }

    private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
                                        int which) throws NoSuchMethodException
    {
<span class="nc bnc" id="L2956" title="All 2 branches missed.">        Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));</span>
<span class="nc bnc" id="L2957" title="All 2 branches missed.">        for (Constructor&lt;T&gt; constructor : constructors) {</span>
<span class="nc bnc" id="L2958" title="All 2 branches missed.">            if (arrayContentsEq(parameterTypes,</span>
<span class="nc" id="L2959">                                constructor.getParameterTypes())) {</span>
<span class="nc" id="L2960">                return getReflectionFactory().copyConstructor(constructor);</span>
            }
        }
<span class="nc" id="L2963">        throw new NoSuchMethodException(getName() + &quot;.&lt;init&gt;&quot; + argumentTypesToString(parameterTypes));</span>
    }

    //
    // Other helpers and base implementation
    //

    private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
<span class="nc bnc" id="L2971" title="All 2 branches missed.">        if (a1 == null) {</span>
<span class="nc bnc" id="L2972" title="All 4 branches missed.">            return a2 == null || a2.length == 0;</span>
        }

<span class="nc bnc" id="L2975" title="All 2 branches missed.">        if (a2 == null) {</span>
<span class="nc bnc" id="L2976" title="All 2 branches missed.">            return a1.length == 0;</span>
        }

<span class="nc bnc" id="L2979" title="All 2 branches missed.">        if (a1.length != a2.length) {</span>
<span class="nc" id="L2980">            return false;</span>
        }

<span class="nc bnc" id="L2983" title="All 2 branches missed.">        for (int i = 0; i &lt; a1.length; i++) {</span>
<span class="nc bnc" id="L2984" title="All 2 branches missed.">            if (a1[i] != a2[i]) {</span>
<span class="nc" id="L2985">                return false;</span>
            }
        }

<span class="nc" id="L2989">        return true;</span>
    }

    private static Field[] copyFields(Field[] arg) {
<span class="nc" id="L2993">        Field[] out = new Field[arg.length];</span>
<span class="nc" id="L2994">        ReflectionFactory fact = getReflectionFactory();</span>
<span class="nc bnc" id="L2995" title="All 2 branches missed.">        for (int i = 0; i &lt; arg.length; i++) {</span>
<span class="nc" id="L2996">            out[i] = fact.copyField(arg[i]);</span>
        }
<span class="nc" id="L2998">        return out;</span>
    }

    private static Method[] copyMethods(Method[] arg) {
<span class="nc" id="L3002">        Method[] out = new Method[arg.length];</span>
<span class="nc" id="L3003">        ReflectionFactory fact = getReflectionFactory();</span>
<span class="nc bnc" id="L3004" title="All 2 branches missed.">        for (int i = 0; i &lt; arg.length; i++) {</span>
<span class="nc" id="L3005">            out[i] = fact.copyMethod(arg[i]);</span>
        }
<span class="nc" id="L3007">        return out;</span>
    }

    private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
<span class="nc" id="L3011">        Constructor&lt;U&gt;[] out = arg.clone();</span>
<span class="nc" id="L3012">        ReflectionFactory fact = getReflectionFactory();</span>
<span class="nc bnc" id="L3013" title="All 2 branches missed.">        for (int i = 0; i &lt; out.length; i++) {</span>
<span class="nc" id="L3014">            out[i] = fact.copyConstructor(out[i]);</span>
        }
<span class="nc" id="L3016">        return out;</span>
    }

    private native Field[]       getDeclaredFields0(boolean publicOnly);
    private native Method[]      getDeclaredMethods0(boolean publicOnly);
    private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
    private native Class&lt;?&gt;[]   getDeclaredClasses0();

    private static String        argumentTypesToString(Class&lt;?&gt;[] argTypes) {
<span class="nc" id="L3025">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L3026">        buf.append(&quot;(&quot;);</span>
<span class="nc bnc" id="L3027" title="All 2 branches missed.">        if (argTypes != null) {</span>
<span class="nc bnc" id="L3028" title="All 2 branches missed.">            for (int i = 0; i &lt; argTypes.length; i++) {</span>
<span class="nc bnc" id="L3029" title="All 2 branches missed.">                if (i &gt; 0) {</span>
<span class="nc" id="L3030">                    buf.append(&quot;, &quot;);</span>
                }
<span class="nc" id="L3032">                Class&lt;?&gt; c = argTypes[i];</span>
<span class="nc bnc" id="L3033" title="All 2 branches missed.">                buf.append((c == null) ? &quot;null&quot; : c.getName());</span>
            }
        }
<span class="nc" id="L3036">        buf.append(&quot;)&quot;);</span>
<span class="nc" id="L3037">        return buf.toString();</span>
    }

    /** use serialVersionUID from JDK 1.1 for interoperability */
    private static final long serialVersionUID = 3206093459760846163L;


    /**
     * Class Class is special cased within the Serialization Stream Protocol.
     *
     * A Class instance is written initially into an ObjectOutputStream in the
     * following format:
     * &lt;pre&gt;
     *      {@code TC_CLASS} ClassDescriptor
     *      A ClassDescriptor is a special cased serialization of
     *      a {@code java.io.ObjectStreamClass} instance.
     * &lt;/pre&gt;
     * A new handle is generated for the initial time the class descriptor
     * is written into the stream. Future references to the class descriptor
     * are written as references to the initial class descriptor instance.
     *
     * @see java.io.ObjectStreamClass
     */
<span class="nc" id="L3060">    private static final ObjectStreamField[] serialPersistentFields =</span>
        new ObjectStreamField[0];


    /**
     * Returns the assertion status that would be assigned to this
     * class if it were to be initialized at the time this method is invoked.
     * If this class has had its assertion status set, the most recent
     * setting will be returned; otherwise, if any package default assertion
     * status pertains to this class, the most recent setting for the most
     * specific pertinent package default assertion status is returned;
     * otherwise, if this class is not a system class (i.e., it has a
     * class loader) its class loader's default assertion status is returned;
     * otherwise, the system class default assertion status is returned.
     * &lt;p&gt;
     * Few programmers will have any need for this method; it is provided
     * for the benefit of the JRE itself.  (It allows a class to determine at
     * the time that it is initialized whether assertions should be enabled.)
     * Note that this method is not guaranteed to return the actual
     * assertion status that was (or will be) associated with the specified
     * class when it was (or will be) initialized.
     *
     * @return the desired assertion status of the specified class.
     * @see    java.lang.ClassLoader#setClassAssertionStatus
     * @see    java.lang.ClassLoader#setPackageAssertionStatus
     * @see    java.lang.ClassLoader#setDefaultAssertionStatus
     * @since  1.4
     */
    public boolean desiredAssertionStatus() {
<span class="nc" id="L3089">        ClassLoader loader = getClassLoader();</span>
        // If the loader is null this is a system class, so ask the VM
<span class="nc bnc" id="L3091" title="All 2 branches missed.">        if (loader == null)</span>
<span class="nc" id="L3092">            return desiredAssertionStatus0(this);</span>

        // If the classloader has been initialized with the assertion
        // directives, ask it. Otherwise, ask the VM.
<span class="nc" id="L3096">        synchronized(loader.assertionLock) {</span>
<span class="nc bnc" id="L3097" title="All 2 branches missed.">            if (loader.classAssertionStatus != null) {</span>
<span class="nc" id="L3098">                return loader.desiredAssertionStatus(getName());</span>
            }
<span class="nc" id="L3100">        }</span>
<span class="nc" id="L3101">        return desiredAssertionStatus0(this);</span>
    }

    // Retrieves the desired assertion status of this class from the VM
    private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);

    /**
     * Returns true if and only if this class was declared as an enum in the
     * source code.
     *
     * @return true if and only if this class was declared as an enum in the
     *     source code
     * @since 1.5
     */
    public boolean isEnum() {
        // An enum must both directly extend java.lang.Enum and have
        // the ENUM bit set; classes for specialized enum constants
        // don't do the former.
<span class="nc bnc" id="L3119" title="All 2 branches missed.">        return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;</span>
<span class="nc bnc" id="L3120" title="All 2 branches missed.">        this.getSuperclass() == java.lang.Enum.class;</span>
    }

    // Fetches the factory for reflective objects
    private static ReflectionFactory getReflectionFactory() {
<span class="nc bnc" id="L3125" title="All 2 branches missed.">        if (reflectionFactory == null) {</span>
<span class="nc" id="L3126">            reflectionFactory =</span>
                java.security.AccessController.doPrivileged
<span class="nc" id="L3128">                    (new sun.reflect.ReflectionFactory.GetReflectionFactoryAction());</span>
        }
<span class="nc" id="L3130">        return reflectionFactory;</span>
    }
    private static ReflectionFactory reflectionFactory;

    // To be able to query system properties as soon as they're available
<span class="nc" id="L3135">    private static boolean initted = false;</span>
    private static void checkInitted() {
<span class="nc bnc" id="L3137" title="All 2 branches missed.">        if (initted) return;</span>
<span class="pc" id="L3138">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
                    // Tests to ensure the system properties table is fully
                    // initialized. This is needed because reflection code is
                    // called very early in the initialization process (before
                    // command-line arguments have been parsed and therefore
                    // these user-settable properties installed.) We assume that
                    // if System.out is non-null then the System class has been
                    // fully initialized and that the bulk of the startup code
                    // has been run.

<span class="fc bfc" id="L3149" title="All 2 branches covered.">                    if (System.out == null) {</span>
                        // java.lang.System not yet fully initialized
<span class="fc" id="L3151">                        return null;</span>
                    }

                    // Doesn't use Boolean.getBoolean to avoid class init.
<span class="fc" id="L3155">                    String val =</span>
<span class="fc" id="L3156">                        System.getProperty(&quot;sun.reflect.noCaches&quot;);</span>
<span class="pc bpc" id="L3157" title="3 of 4 branches missed.">                    if (val != null &amp;&amp; val.equals(&quot;true&quot;)) {</span>
<span class="nc" id="L3158">                        useCaches = false;</span>
                    }

<span class="fc" id="L3161">                    initted = true;</span>
<span class="fc" id="L3162">                    return null;</span>
                }
            });
<span class="nc" id="L3165">    }</span>

    /**
     * Returns the elements of this enum class or null if this
     * Class object does not represent an enum type.
     *
     * @return an array containing the values comprising the enum class
     *     represented by this Class object in the order they're
     *     declared, or null if this Class object does not
     *     represent an enum type
     * @since 1.5
     */
    public T[] getEnumConstants() {
<span class="nc" id="L3178">        T[] values = getEnumConstantsShared();</span>
<span class="nc bnc" id="L3179" title="All 2 branches missed.">        return (values != null) ? values.clone() : null;</span>
    }

    /**
     * Returns the elements of this enum class or null if this
     * Class object does not represent an enum type;
     * identical to getEnumConstants except that the result is
     * uncloned, cached, and shared by all callers.
     */
    T[] getEnumConstantsShared() {
<span class="nc bnc" id="L3189" title="All 2 branches missed.">        if (enumConstants == null) {</span>
<span class="nc bnc" id="L3190" title="All 2 branches missed.">            if (!isEnum()) return null;</span>
            try {
<span class="nc" id="L3192">                final Method values = getMethod(&quot;values&quot;);</span>
<span class="nc" id="L3193">                java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L3194">                    new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                        public Void run() {
<span class="fc" id="L3196">                                values.setAccessible(true);</span>
<span class="fc" id="L3197">                                return null;</span>
                            }
                        });
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L3201">                T[] temporaryConstants = (T[])values.invoke(null);</span>
<span class="nc" id="L3202">                enumConstants = temporaryConstants;</span>
            }
            // These can happen when users concoct enum-like classes
            // that don't comply with the enum spec.
<span class="nc" id="L3206">            catch (InvocationTargetException | NoSuchMethodException |</span>
<span class="nc" id="L3207">                   IllegalAccessException ex) { return null; }</span>
        }
<span class="nc" id="L3209">        return enumConstants;</span>
    }
<span class="nc" id="L3211">    private volatile transient T[] enumConstants = null;</span>

    /**
     * Returns a map from simple name to enum constant.  This package-private
     * method is used internally by Enum to implement
     * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
     * efficiently.  Note that the map is returned by this method is
     * created lazily on first use.  Typically it won't ever get created.
     */
    Map&lt;String, T&gt; enumConstantDirectory() {
<span class="nc bnc" id="L3221" title="All 2 branches missed.">        if (enumConstantDirectory == null) {</span>
<span class="nc" id="L3222">            T[] universe = getEnumConstantsShared();</span>
<span class="nc bnc" id="L3223" title="All 2 branches missed.">            if (universe == null)</span>
<span class="nc" id="L3224">                throw new IllegalArgumentException(</span>
<span class="nc" id="L3225">                    getName() + &quot; is not an enum type&quot;);</span>
<span class="nc" id="L3226">            Map&lt;String, T&gt; m = new HashMap&lt;&gt;(2 * universe.length);</span>
<span class="nc bnc" id="L3227" title="All 2 branches missed.">            for (T constant : universe)</span>
<span class="nc" id="L3228">                m.put(((Enum&lt;?&gt;)constant).name(), constant);</span>
<span class="nc" id="L3229">            enumConstantDirectory = m;</span>
        }
<span class="nc" id="L3231">        return enumConstantDirectory;</span>
    }
<span class="nc" id="L3233">    private volatile transient Map&lt;String, T&gt; enumConstantDirectory = null;</span>

    /**
     * Casts an object to the class or interface represented
     * by this {@code Class} object.
     *
     * @param obj the object to be cast
     * @return the object after casting, or null if obj is null
     *
     * @throws ClassCastException if the object is not
     * null and is not assignable to the type T.
     *
     * @since 1.5
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public T cast(Object obj) {
<span class="nc bnc" id="L3249" title="All 4 branches missed.">        if (obj != null &amp;&amp; !isInstance(obj))</span>
<span class="nc" id="L3250">            throw new ClassCastException(cannotCastMsg(obj));</span>
<span class="nc" id="L3251">        return (T) obj;</span>
    }

    private String cannotCastMsg(Object obj) {
<span class="nc" id="L3255">        return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();</span>
    }

    /**
     * Casts this {@code Class} object to represent a subclass of the class
     * represented by the specified class object.  Checks that the cast
     * is valid, and throws a {@code ClassCastException} if it is not.  If
     * this method succeeds, it always returns a reference to this class object.
     *
     * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
     * a {@code Class} object to pass it to an API that restricts the
     * {@code Class} objects that it is willing to accept.  A cast would
     * generate a compile-time warning, as the correctness of the cast
     * could not be checked at runtime (because generic types are implemented
     * by erasure).
     *
     * @param &lt;U&gt; the type to cast this class object to
     * @param clazz the class of the type to cast this class object to
     * @return this {@code Class} object, cast to represent a subclass of
     *    the specified class object.
     * @throws ClassCastException if this {@code Class} object does not
     *    represent a subclass of the specified class (here &quot;subclass&quot; includes
     *    the class itself).
     * @since 1.5
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
<span class="nc bnc" id="L3282" title="All 2 branches missed.">        if (clazz.isAssignableFrom(this))</span>
<span class="nc" id="L3283">            return (Class&lt;? extends U&gt;) this;</span>
        else
<span class="nc" id="L3285">            throw new ClassCastException(this.toString());</span>
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     * @since 1.5
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
<span class="nc" id="L3294">        Objects.requireNonNull(annotationClass);</span>

<span class="nc" id="L3296">        return (A) annotationData().annotations.get(annotationClass);</span>
    }

    /**
     * {@inheritDoc}
     * @throws NullPointerException {@inheritDoc}
     * @since 1.5
     */
    @Override
    public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
<span class="nc" id="L3306">        return GenericDeclaration.super.isAnnotationPresent(annotationClass);</span>
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
<span class="nc" id="L3315">        Objects.requireNonNull(annotationClass);</span>

<span class="nc" id="L3317">        AnnotationData annotationData = annotationData();</span>
<span class="nc" id="L3318">        return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,</span>
                                                          this,
                                                          annotationClass);
    }

    /**
     * @since 1.5
     */
    public Annotation[] getAnnotations() {
<span class="nc" id="L3327">        return AnnotationParser.toArray(annotationData().annotations);</span>
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
<span class="nc" id="L3337">        Objects.requireNonNull(annotationClass);</span>

<span class="nc" id="L3339">        return (A) annotationData().declaredAnnotations.get(annotationClass);</span>
    }

    /**
     * @throws NullPointerException {@inheritDoc}
     * @since 1.8
     */
    @Override
    public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
<span class="nc" id="L3348">        Objects.requireNonNull(annotationClass);</span>

<span class="nc" id="L3350">        return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,</span>
                                                                 annotationClass);
    }

    /**
     * @since 1.5
     */
    public Annotation[] getDeclaredAnnotations()  {
<span class="nc" id="L3358">        return AnnotationParser.toArray(annotationData().declaredAnnotations);</span>
    }

    // annotation data that might get invalidated when JVM TI RedefineClasses() is called
    private static class AnnotationData {
        final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
        final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;

        // Value of classRedefinedCount when we created this AnnotationData instance
        final int redefinedCount;

        AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
                       Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
<span class="fc" id="L3371">                       int redefinedCount) {</span>
<span class="fc" id="L3372">            this.annotations = annotations;</span>
<span class="fc" id="L3373">            this.declaredAnnotations = declaredAnnotations;</span>
<span class="fc" id="L3374">            this.redefinedCount = redefinedCount;</span>
<span class="fc" id="L3375">        }</span>
    }

    // Annotations cache
    @SuppressWarnings(&quot;UnusedDeclaration&quot;)
    private volatile transient AnnotationData annotationData;

    private AnnotationData annotationData() {
        while (true) { // retry loop
<span class="nc" id="L3384">            AnnotationData annotationData = this.annotationData;</span>
<span class="nc" id="L3385">            int classRedefinedCount = this.classRedefinedCount;</span>
<span class="nc bnc" id="L3386" title="All 4 branches missed.">            if (annotationData != null &amp;&amp;</span>
                annotationData.redefinedCount == classRedefinedCount) {
<span class="nc" id="L3388">                return annotationData;</span>
            }
            // null or stale annotationData -&gt; optimistically create new instance
<span class="nc" id="L3391">            AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);</span>
            // try to install it
<span class="nc bnc" id="L3393" title="All 2 branches missed.">            if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {</span>
                // successfully installed new AnnotationData
<span class="nc" id="L3395">                return newAnnotationData;</span>
            }
<span class="nc" id="L3397">        }</span>
    }

    private AnnotationData createAnnotationData(int classRedefinedCount) {
<span class="nc" id="L3401">        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =</span>
<span class="nc" id="L3402">            AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);</span>
<span class="nc" id="L3403">        Class&lt;?&gt; superClass = getSuperclass();</span>
<span class="nc" id="L3404">        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;</span>
<span class="nc bnc" id="L3405" title="All 2 branches missed.">        if (superClass != null) {</span>
<span class="nc" id="L3406">            Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =</span>
<span class="nc" id="L3407">                superClass.annotationData().annotations;</span>
<span class="nc bnc" id="L3408" title="All 2 branches missed.">            for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {</span>
<span class="nc" id="L3409">                Class&lt;? extends Annotation&gt; annotationClass = e.getKey();</span>
<span class="nc bnc" id="L3410" title="All 2 branches missed.">                if (AnnotationType.getInstance(annotationClass).isInherited()) {</span>
<span class="nc bnc" id="L3411" title="All 2 branches missed.">                    if (annotations == null) { // lazy construction</span>
<span class="nc" id="L3412">                        annotations = new LinkedHashMap&lt;&gt;((Math.max(</span>
<span class="nc" id="L3413">                                declaredAnnotations.size(),</span>
<span class="nc" id="L3414">                                Math.min(12, declaredAnnotations.size() + superAnnotations.size())</span>
                            ) * 4 + 2) / 3
                        );
                    }
<span class="nc" id="L3418">                    annotations.put(annotationClass, e.getValue());</span>
                }
<span class="nc" id="L3420">            }</span>
        }
<span class="nc bnc" id="L3422" title="All 2 branches missed.">        if (annotations == null) {</span>
            // no inherited annotations -&gt; share the Map with declaredAnnotations
<span class="nc" id="L3424">            annotations = declaredAnnotations;</span>
        } else {
            // at least one inherited annotation -&gt; declared may override inherited
<span class="nc" id="L3427">            annotations.putAll(declaredAnnotations);</span>
        }
<span class="nc" id="L3429">        return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);</span>
    }

    // Annotation types cache their internal (AnnotationType) form

    @SuppressWarnings(&quot;UnusedDeclaration&quot;)
    private volatile transient AnnotationType annotationType;

    boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
<span class="nc" id="L3438">        return Atomic.casAnnotationType(this, oldType, newType);</span>
    }

    AnnotationType getAnnotationType() {
<span class="nc" id="L3442">        return annotationType;</span>
    }

    Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
<span class="nc" id="L3446">        return annotationData().declaredAnnotations;</span>
    }

    /* Backing store of user-defined values pertaining to this class.
     * Maintained by the ClassValue class.
     */
    transient ClassValue.ClassValueMap classValueMap;

    /**
     * Returns an {@code AnnotatedType} object that represents the use of a
     * type to specify the superclass of the entity represented by this {@code
     * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
     * in '...  extends Foo' is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
     * Foo.)
     *
     * &lt;p&gt; If this {@code Class} object represents a type whose declaration
     * does not explicitly indicate an annotated superclass, then the return
     * value is an {@code AnnotatedType} object representing an element with no
     * annotations.
     *
     * &lt;p&gt; If this {@code Class} represents either the {@code Object} class, an
     * interface type, an array type, a primitive type, or void, the return
     * value is {@code null}.
     *
     * @return an object representing the superclass
     * @since 1.8
     */
    public AnnotatedType getAnnotatedSuperclass() {
<span class="nc bnc" id="L3474" title="All 2 branches missed.">        if (this == Object.class ||</span>
<span class="nc bnc" id="L3475" title="All 2 branches missed.">                isInterface() ||</span>
<span class="nc bnc" id="L3476" title="All 2 branches missed.">                isArray() ||</span>
<span class="nc bnc" id="L3477" title="All 4 branches missed.">                isPrimitive() ||</span>
                this == Void.TYPE) {
<span class="nc" id="L3479">            return null;</span>
        }

<span class="nc" id="L3482">        return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);</span>
    }

    /**
     * Returns an array of {@code AnnotatedType} objects that represent the use
     * of types to specify superinterfaces of the entity represented by this
     * {@code Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
     * superinterface in '... implements Foo' is distinct from the
     * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
     *
     * &lt;p&gt; If this {@code Class} object represents a class, the return value is
     * an array containing objects representing the uses of interface types to
     * specify interfaces implemented by the class. The order of the objects in
     * the array corresponds to the order of the interface types used in the
     * 'implements' clause of the declaration of this {@code Class} object.
     *
     * &lt;p&gt; If this {@code Class} object represents an interface, the return
     * value is an array containing objects representing the uses of interface
     * types to specify interfaces directly extended by the interface. The
     * order of the objects in the array corresponds to the order of the
     * interface types used in the 'extends' clause of the declaration of this
     * {@code Class} object.
     *
     * &lt;p&gt; If this {@code Class} object represents a class or interface whose
     * declaration does not explicitly indicate any annotated superinterfaces,
     * the return value is an array of length 0.
     *
     * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
     * class, an array type, a primitive type, or void, the return value is an
     * array of length 0.
     *
     * @return an array representing the superinterfaces
     * @since 1.8
     */
    public AnnotatedType[] getAnnotatedInterfaces() {
<span class="nc" id="L3517">         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>