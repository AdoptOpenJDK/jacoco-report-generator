<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClassLoader.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang</a> &gt; <span class="el_source">ClassLoader.java</span></div><h1>ClassLoader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.lang;

import java.io.InputStream;
import java.io.IOException;
import java.io.File;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.MalformedURLException;
import java.net.URL;
import java.security.AccessController;
import java.security.AccessControlContext;
import java.security.CodeSource;
import java.security.Policy;
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.security.ProtectionDomain;
import java.security.cert.Certificate;
import java.util.Collections;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.Stack;
import java.util.Map;
import java.util.Vector;
import java.util.Hashtable;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import sun.misc.CompoundEnumeration;
import sun.misc.Resource;
import sun.misc.URLClassPath;
import sun.misc.VM;
import sun.reflect.CallerSensitive;
import sun.reflect.Reflection;
import sun.reflect.misc.ReflectUtil;
import sun.security.util.SecurityConstants;

/**
 * A class loader is an object that is responsible for loading classes. The
 * class &lt;tt&gt;ClassLoader&lt;/tt&gt; is an abstract class.  Given the &lt;a
 * href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of a class, a class loader should attempt to
 * locate or generate data that constitutes a definition for the class.  A
 * typical strategy is to transform the name into a file name and then read a
 * &quot;class file&quot; of that name from a file system.
 *
 * &lt;p&gt; Every {@link Class &lt;tt&gt;Class&lt;/tt&gt;} object contains a {@link
 * Class#getClassLoader() reference} to the &lt;tt&gt;ClassLoader&lt;/tt&gt; that defined
 * it.
 *
 * &lt;p&gt; &lt;tt&gt;Class&lt;/tt&gt; objects for array classes are not created by class
 * loaders, but are created automatically as required by the Java runtime.
 * The class loader for an array class, as returned by {@link
 * Class#getClassLoader()} is the same as the class loader for its element
 * type; if the element type is a primitive type, then the array class has no
 * class loader.
 *
 * &lt;p&gt; Applications implement subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; in order to
 * extend the manner in which the Java virtual machine dynamically loads
 * classes.
 *
 * &lt;p&gt; Class loaders may typically be used by security managers to indicate
 * security domains.
 *
 * &lt;p&gt; The &lt;tt&gt;ClassLoader&lt;/tt&gt; class uses a delegation model to search for
 * classes and resources.  Each instance of &lt;tt&gt;ClassLoader&lt;/tt&gt; has an
 * associated parent class loader.  When requested to find a class or
 * resource, a &lt;tt&gt;ClassLoader&lt;/tt&gt; instance will delegate the search for the
 * class or resource to its parent class loader before attempting to find the
 * class or resource itself.  The virtual machine's built-in class loader,
 * called the &quot;bootstrap class loader&quot;, does not itself have a parent but may
 * serve as the parent of a &lt;tt&gt;ClassLoader&lt;/tt&gt; instance.
 *
 * &lt;p&gt; Class loaders that support concurrent loading of classes are known as
 * &lt;em&gt;parallel capable&lt;/em&gt; class loaders and are required to register
 * themselves at their class initialization time by invoking the
 * {@link
 * #registerAsParallelCapable &lt;tt&gt;ClassLoader.registerAsParallelCapable&lt;/tt&gt;}
 * method. Note that the &lt;tt&gt;ClassLoader&lt;/tt&gt; class is registered as parallel
 * capable by default. However, its subclasses still need to register themselves
 * if they are parallel capable. &lt;br&gt;
 * In environments in which the delegation model is not strictly
 * hierarchical, class loaders need to be parallel capable, otherwise class
 * loading can lead to deadlocks because the loader lock is held for the
 * duration of the class loading process (see {@link #loadClass
 * &lt;tt&gt;loadClass&lt;/tt&gt;} methods).
 *
 * &lt;p&gt; Normally, the Java virtual machine loads classes from the local file
 * system in a platform-dependent manner.  For example, on UNIX systems, the
 * virtual machine loads classes from the directory defined by the
 * &lt;tt&gt;CLASSPATH&lt;/tt&gt; environment variable.
 *
 * &lt;p&gt; However, some classes may not originate from a file; they may originate
 * from other sources, such as the network, or they could be constructed by an
 * application.  The method {@link #defineClass(String, byte[], int, int)
 * &lt;tt&gt;defineClass&lt;/tt&gt;} converts an array of bytes into an instance of class
 * &lt;tt&gt;Class&lt;/tt&gt;. Instances of this newly defined class can be created using
 * {@link Class#newInstance &lt;tt&gt;Class.newInstance&lt;/tt&gt;}.
 *
 * &lt;p&gt; The methods and constructors of objects created by a class loader may
 * reference other classes.  To determine the class(es) referred to, the Java
 * virtual machine invokes the {@link #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;} method of
 * the class loader that originally created the class.
 *
 * &lt;p&gt; For example, an application could create a network class loader to
 * download class files from a server.  Sample code might look like:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *   ClassLoader loader&amp;nbsp;= new NetworkClassLoader(host,&amp;nbsp;port);
 *   Object main&amp;nbsp;= loader.loadClass(&quot;Main&quot;, true).newInstance();
 *       &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;p&gt; The network class loader subclass must define the methods {@link
 * #findClass &lt;tt&gt;findClass&lt;/tt&gt;} and &lt;tt&gt;loadClassData&lt;/tt&gt; to load a class
 * from the network.  Once it has downloaded the bytes that make up the class,
 * it should use the method {@link #defineClass &lt;tt&gt;defineClass&lt;/tt&gt;} to
 * create a class instance.  A sample implementation is:
 *
 * &lt;blockquote&gt;&lt;pre&gt;
 *     class NetworkClassLoader extends ClassLoader {
 *         String host;
 *         int port;
 *
 *         public Class findClass(String name) {
 *             byte[] b = loadClassData(name);
 *             return defineClass(name, b, 0, b.length);
 *         }
 *
 *         private byte[] loadClassData(String name) {
 *             // load the class data from the connection
 *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
 *         }
 *     }
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * &lt;h3&gt; &lt;a name=&quot;name&quot;&gt;Binary names&lt;/a&gt; &lt;/h3&gt;
 *
 * &lt;p&gt; Any class name provided as a {@link String} parameter to methods in
 * &lt;tt&gt;ClassLoader&lt;/tt&gt; must be a binary name as defined by
 * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
 *
 * &lt;p&gt; Examples of valid class names include:
 * &lt;blockquote&gt;&lt;pre&gt;
 *   &quot;java.lang.String&quot;
 *   &quot;javax.swing.JSpinner$DefaultEditor&quot;
 *   &quot;java.security.KeyStore$Builder$FileBuilder$1&quot;
 *   &quot;java.net.URLClassLoader$3$1&quot;
 * &lt;/pre&gt;&lt;/blockquote&gt;
 *
 * @see      #resolveClass(Class)
 * @since 1.0
 */
public abstract class ClassLoader {

    private static native void registerNatives();
    static {
<span class="nc" id="L182">        registerNatives();</span>
    }

    // The parent class loader for delegation
    // Note: VM hardcoded the offset of this field, thus all new fields
    // must be added *after* it.
    private final ClassLoader parent;

    /**
     * Encapsulates the set of parallel capable loader types.
     */
    private static class ParallelLoaders {
<span class="nc" id="L194">        private ParallelLoaders() {}</span>

        // the set of parallel capable loader types
<span class="fc" id="L197">        private static final Set&lt;Class&lt;? extends ClassLoader&gt;&gt; loaderTypes =</span>
<span class="fc" id="L198">            Collections.newSetFromMap(</span>
                new WeakHashMap&lt;Class&lt;? extends ClassLoader&gt;, Boolean&gt;());
        static {
<span class="pc" id="L201">            synchronized (loaderTypes) { loaderTypes.add(ClassLoader.class); }</span>
<span class="fc" id="L202">        }</span>

        /**
         * Registers the given class loader type as parallel capabale.
         * Returns {@code true} is successfully registered; {@code false} if
         * loader's super class is not registered.
         */
        static boolean register(Class&lt;? extends ClassLoader&gt; c) {
<span class="fc" id="L210">            synchronized (loaderTypes) {</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">                if (loaderTypes.contains(c.getSuperclass())) {</span>
                    // register the class loader as parallel capable
                    // if and only if all of its super classes are.
                    // Note: given current classloading sequence, if
                    // the immediate super class is parallel capable,
                    // all the super classes higher up must be too.
<span class="fc" id="L217">                    loaderTypes.add(c);</span>
<span class="fc" id="L218">                    return true;</span>
                } else {
<span class="nc" id="L220">                    return false;</span>
                }
<span class="nc" id="L222">            }</span>
        }

        /**
         * Returns {@code true} if the given class loader type is
         * registered as parallel capable.
         */
        static boolean isRegistered(Class&lt;? extends ClassLoader&gt; c) {
<span class="fc" id="L230">            synchronized (loaderTypes) {</span>
<span class="fc" id="L231">                return loaderTypes.contains(c);</span>
<span class="nc" id="L232">            }</span>
        }
    }

    // Maps class name to the corresponding lock object when the current
    // class loader is parallel capable.
    // Note: VM also uses this field to decide if the current class loader
    // is parallel capable and the appropriate lock object for class loading.
    private final ConcurrentHashMap&lt;String, Object&gt; parallelLockMap;

    // Hashtable that maps packages to certs
    private final Map &lt;String, Certificate[]&gt; package2certs;

    // Shared among all packages with unsigned classes
<span class="nc" id="L246">    private static final Certificate[] nocerts = new Certificate[0];</span>

    // The classes loaded by this class loader. The only purpose of this table
    // is to keep the classes from being GC'ed until the loader is GC'ed.
<span class="nc" id="L250">    private final Vector&lt;Class&lt;?&gt;&gt; classes = new Vector&lt;&gt;();</span>

    // The &quot;default&quot; domain. Set as the default ProtectionDomain on newly
    // created classes.
<span class="nc" id="L254">    private final ProtectionDomain defaultDomain =</span>
        new ProtectionDomain(new CodeSource(null, (Certificate[]) null),
                             null, this, null);

    // The initiating protection domains for all classes loaded by this loader
    private final Set&lt;ProtectionDomain&gt; domains;

    // Invoked by the VM to record every loaded class with this loader.
    void addClass(Class&lt;?&gt; c) {
<span class="nc" id="L263">        classes.addElement(c);</span>
<span class="nc" id="L264">    }</span>

    // The packages defined in this class loader.  Each package name is mapped
    // to its corresponding Package object.
    // @GuardedBy(&quot;itself&quot;)
<span class="nc" id="L269">    private final HashMap&lt;String, Package&gt; packages = new HashMap&lt;&gt;();</span>

    private static Void checkCreateClassLoader() {
<span class="nc" id="L272">        SecurityManager security = System.getSecurityManager();</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (security != null) {</span>
<span class="nc" id="L274">            security.checkCreateClassLoader();</span>
        }
<span class="nc" id="L276">        return null;</span>
    }

<span class="nc" id="L279">    private ClassLoader(Void unused, ClassLoader parent) {</span>
<span class="nc" id="L280">        this.parent = parent;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (ParallelLoaders.isRegistered(this.getClass())) {</span>
<span class="nc" id="L282">            parallelLockMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L283">            package2certs = new ConcurrentHashMap&lt;&gt;();</span>
<span class="nc" id="L284">            domains =</span>
<span class="nc" id="L285">                Collections.synchronizedSet(new HashSet&lt;ProtectionDomain&gt;());</span>
<span class="nc" id="L286">            assertionLock = new Object();</span>
        } else {
            // no finer-grained lock; lock on the classloader instance
<span class="nc" id="L289">            parallelLockMap = null;</span>
<span class="nc" id="L290">            package2certs = new Hashtable&lt;&gt;();</span>
<span class="nc" id="L291">            domains = new HashSet&lt;&gt;();</span>
<span class="nc" id="L292">            assertionLock = this;</span>
        }
<span class="nc" id="L294">    }</span>

    /**
     * Creates a new class loader using the specified parent class loader for
     * delegation.
     *
     * &lt;p&gt; If there is a security manager, its {@link
     * SecurityManager#checkCreateClassLoader()
     * &lt;tt&gt;checkCreateClassLoader&lt;/tt&gt;} method is invoked.  This may result in
     * a security exception.  &lt;/p&gt;
     *
     * @param  parent
     *         The parent class loader
     *
     * @throws  SecurityException
     *          If a security manager exists and its
     *          &lt;tt&gt;checkCreateClassLoader&lt;/tt&gt; method doesn't allow creation
     *          of a new class loader.
     *
     * @since  1.2
     */
    protected ClassLoader(ClassLoader parent) {
<span class="nc" id="L316">        this(checkCreateClassLoader(), parent);</span>
<span class="nc" id="L317">    }</span>

    /**
     * Creates a new class loader using the &lt;tt&gt;ClassLoader&lt;/tt&gt; returned by
     * the method {@link #getSystemClassLoader()
     * &lt;tt&gt;getSystemClassLoader()&lt;/tt&gt;} as the parent class loader.
     *
     * &lt;p&gt; If there is a security manager, its {@link
     * SecurityManager#checkCreateClassLoader()
     * &lt;tt&gt;checkCreateClassLoader&lt;/tt&gt;} method is invoked.  This may result in
     * a security exception.  &lt;/p&gt;
     *
     * @throws  SecurityException
     *          If a security manager exists and its
     *          &lt;tt&gt;checkCreateClassLoader&lt;/tt&gt; method doesn't allow creation
     *          of a new class loader.
     */
    protected ClassLoader() {
<span class="nc" id="L335">        this(checkCreateClassLoader(), getSystemClassLoader());</span>
<span class="nc" id="L336">    }</span>

    // -- Class --

    /**
     * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.
     * This method searches for classes in the same manner as the {@link
     * #loadClass(String, boolean)} method.  It is invoked by the Java virtual
     * machine to resolve class references.  Invoking this method is equivalent
     * to invoking {@link #loadClass(String, boolean) &lt;tt&gt;loadClass(name,
     * false)&lt;/tt&gt;}.
     *
     * @param  name
     *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
     *
     * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object
     *
     * @throws  ClassNotFoundException
     *          If the class was not found
     */
    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException {
<span class="nc" id="L357">        return loadClass(name, false);</span>
    }

    /**
     * Loads the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  The
     * default implementation of this method searches for classes in the
     * following order:
     *
     * &lt;ol&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Invoke {@link #findLoadedClass(String)} to check if the class
     *   has already been loaded.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Invoke the {@link #loadClass(String) &lt;tt&gt;loadClass&lt;/tt&gt;} method
     *   on the parent class loader.  If the parent is &lt;tt&gt;null&lt;/tt&gt; the class
     *   loader built-in to the virtual machine is used, instead.  &lt;/p&gt;&lt;/li&gt;
     *
     *   &lt;li&gt;&lt;p&gt; Invoke the {@link #findClass(String)} method to find the
     *   class.  &lt;/p&gt;&lt;/li&gt;
     *
     * &lt;/ol&gt;
     *
     * &lt;p&gt; If the class was found using the above steps, and the
     * &lt;tt&gt;resolve&lt;/tt&gt; flag is true, this method will then invoke the {@link
     * #resolveClass(Class)} method on the resulting &lt;tt&gt;Class&lt;/tt&gt; object.
     *
     * &lt;p&gt; Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; are encouraged to override {@link
     * #findClass(String)}, rather than this method.  &lt;/p&gt;
     *
     * &lt;p&gt; Unless overridden, this method synchronizes on the result of
     * {@link #getClassLoadingLock &lt;tt&gt;getClassLoadingLock&lt;/tt&gt;} method
     * during the entire class loading process.
     *
     * @param  name
     *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
     *
     * @param  resolve
     *         If &lt;tt&gt;true&lt;/tt&gt; then resolve the class
     *
     * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object
     *
     * @throws  ClassNotFoundException
     *          If the class could not be found
     */
    protected Class&lt;?&gt; loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
<span class="nc" id="L404">        synchronized (getClassLoadingLock(name)) {</span>
            // First, check if the class has already been loaded
<span class="nc" id="L406">            Class&lt;?&gt; c = findLoadedClass(name);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">            if (c == null) {</span>
<span class="nc" id="L408">                long t0 = System.nanoTime();</span>
                try {
<span class="nc bnc" id="L410" title="All 2 branches missed.">                    if (parent != null) {</span>
<span class="nc" id="L411">                        c = parent.loadClass(name, false);</span>
                    } else {
<span class="nc" id="L413">                        c = findBootstrapClassOrNull(name);</span>
                    }
<span class="nc" id="L415">                } catch (ClassNotFoundException e) {</span>
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
<span class="nc" id="L418">                }</span>

<span class="nc bnc" id="L420" title="All 2 branches missed.">                if (c == null) {</span>
                    // If still not found, then invoke findClass in order
                    // to find the class.
<span class="nc" id="L423">                    long t1 = System.nanoTime();</span>
<span class="nc" id="L424">                    c = findClass(name);</span>

                    // this is the defining class loader; record the stats
<span class="nc" id="L427">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span>
<span class="nc" id="L428">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span>
<span class="nc" id="L429">                    sun.misc.PerfCounter.getFindClasses().increment();</span>
                }
            }
<span class="nc bnc" id="L432" title="All 2 branches missed.">            if (resolve) {</span>
<span class="nc" id="L433">                resolveClass(c);</span>
            }
<span class="nc" id="L435">            return c;</span>
<span class="nc" id="L436">        }</span>
    }

    /**
     * Returns the lock object for class loading operations.
     * For backward compatibility, the default implementation of this method
     * behaves as follows. If this ClassLoader object is registered as
     * parallel capable, the method returns a dedicated object associated
     * with the specified class name. Otherwise, the method returns this
     * ClassLoader object.
     *
     * @param  className
     *         The name of the to-be-loaded class
     *
     * @return the lock for class loading operations
     *
     * @throws NullPointerException
     *         If registered as parallel capable and &lt;tt&gt;className&lt;/tt&gt; is null
     *
     * @see #loadClass(String, boolean)
     *
     * @since  1.7
     */
    protected Object getClassLoadingLock(String className) {
<span class="nc" id="L460">        Object lock = this;</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (parallelLockMap != null) {</span>
<span class="nc" id="L462">            Object newLock = new Object();</span>
<span class="nc" id="L463">            lock = parallelLockMap.putIfAbsent(className, newLock);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">            if (lock == null) {</span>
<span class="nc" id="L465">                lock = newLock;</span>
            }
        }
<span class="nc" id="L468">        return lock;</span>
    }

    // This method is invoked by the virtual machine to load a class.
    private Class&lt;?&gt; loadClassInternal(String name)
        throws ClassNotFoundException
    {
        // For backward compatibility, explicitly lock on 'this' when
        // the current class loader is not parallel capable.
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (parallelLockMap == null) {</span>
<span class="nc" id="L478">            synchronized (this) {</span>
<span class="nc" id="L479">                 return loadClass(name);</span>
<span class="nc" id="L480">            }</span>
        } else {
<span class="nc" id="L482">            return loadClass(name);</span>
        }
    }

    // Invoked by the VM after loading class with this loader.
    private void checkPackageAccess(Class&lt;?&gt; cls, ProtectionDomain pd) {
<span class="nc" id="L488">        final SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">            if (ReflectUtil.isNonPublicProxyClass(cls)) {</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                for (Class&lt;?&gt; intf: cls.getInterfaces()) {</span>
<span class="nc" id="L492">                    checkPackageAccess(intf, pd);</span>
                }
<span class="nc" id="L494">                return;</span>
            }

<span class="nc" id="L497">            final String name = cls.getName();</span>
<span class="nc" id="L498">            final int i = name.lastIndexOf('.');</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">            if (i != -1) {</span>
<span class="pc" id="L500">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                    public Void run() {
<span class="fc" id="L502">                        sm.checkPackageAccess(name.substring(0, i));</span>
<span class="fc" id="L503">                        return null;</span>
                    }
                }, new AccessControlContext(new ProtectionDomain[] {pd}));
            }
        }
<span class="nc" id="L508">        domains.add(pd);</span>
<span class="nc" id="L509">    }</span>

    /**
     * Finds the class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.
     * This method should be overridden by class loader implementations that
     * follow the delegation model for loading classes, and will be invoked by
     * the {@link #loadClass &lt;tt&gt;loadClass&lt;/tt&gt;} method after checking the
     * parent class loader for the requested class.  The default implementation
     * throws a &lt;tt&gt;ClassNotFoundException&lt;/tt&gt;.
     *
     * @param  name
     *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
     *
     * @return  The resulting &lt;tt&gt;Class&lt;/tt&gt; object
     *
     * @throws  ClassNotFoundException
     *          If the class could not be found
     *
     * @since  1.2
     */
    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
<span class="nc" id="L530">        throw new ClassNotFoundException(name);</span>
    }

    /**
     * Converts an array of bytes into an instance of class &lt;tt&gt;Class&lt;/tt&gt;.
     * Before the &lt;tt&gt;Class&lt;/tt&gt; can be used it must be resolved.  This method
     * is deprecated in favor of the version that takes a &lt;a
     * href=&quot;#name&quot;&gt;binary name&lt;/a&gt; as its first argument, and is more secure.
     *
     * @param  b
     *         The bytes that make up the class data.  The bytes in positions
     *         &lt;tt&gt;off&lt;/tt&gt; through &lt;tt&gt;off+len-1&lt;/tt&gt; should have the format
     *         of a valid class file as defined by
     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
     *
     * @param  off
     *         The start offset in &lt;tt&gt;b&lt;/tt&gt; of the class data
     *
     * @param  len
     *         The length of the class data
     *
     * @return  The &lt;tt&gt;Class&lt;/tt&gt; object that was created from the specified
     *          class data
     *
     * @throws  ClassFormatError
     *          If the data did not contain a valid class
     *
     * @throws  IndexOutOfBoundsException
     *          If either &lt;tt&gt;off&lt;/tt&gt; or &lt;tt&gt;len&lt;/tt&gt; is negative, or if
     *          &lt;tt&gt;off+len&lt;/tt&gt; is greater than &lt;tt&gt;b.length&lt;/tt&gt;.
     *
     * @throws  SecurityException
     *          If an attempt is made to add this class to a package that
     *          contains classes that were signed by a different set of
     *          certificates than this class, or if an attempt is made
     *          to define a class in a package with a fully-qualified name
     *          that starts with &quot;{@code java.}&quot;.
     *
     * @see  #loadClass(String, boolean)
     * @see  #resolveClass(Class)
     *
     * @deprecated  Replaced by {@link #defineClass(String, byte[], int, int)
     * defineClass(String, byte[], int, int)}
     */
    @Deprecated
    protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len)
        throws ClassFormatError
    {
<span class="nc" id="L578">        return defineClass(null, b, off, len, null);</span>
    }

    /**
     * Converts an array of bytes into an instance of class &lt;tt&gt;Class&lt;/tt&gt;.
     * Before the &lt;tt&gt;Class&lt;/tt&gt; can be used it must be resolved.
     *
     * &lt;p&gt; This method assigns a default {@link java.security.ProtectionDomain
     * &lt;tt&gt;ProtectionDomain&lt;/tt&gt;} to the newly defined class.  The
     * &lt;tt&gt;ProtectionDomain&lt;/tt&gt; is effectively granted the same set of
     * permissions returned when {@link
     * java.security.Policy#getPermissions(java.security.CodeSource)
     * &lt;tt&gt;Policy.getPolicy().getPermissions(new CodeSource(null, null))&lt;/tt&gt;}
     * is invoked.  The default domain is created on the first invocation of
     * {@link #defineClass(String, byte[], int, int) &lt;tt&gt;defineClass&lt;/tt&gt;},
     * and re-used on subsequent invocations.
     *
     * &lt;p&gt; To assign a specific &lt;tt&gt;ProtectionDomain&lt;/tt&gt; to the class, use
     * the {@link #defineClass(String, byte[], int, int,
     * java.security.ProtectionDomain) &lt;tt&gt;defineClass&lt;/tt&gt;} method that takes a
     * &lt;tt&gt;ProtectionDomain&lt;/tt&gt; as one of its arguments.  &lt;/p&gt;
     *
     * @param  name
     *         The expected &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class, or
     *         &lt;tt&gt;null&lt;/tt&gt; if not known
     *
     * @param  b
     *         The bytes that make up the class data.  The bytes in positions
     *         &lt;tt&gt;off&lt;/tt&gt; through &lt;tt&gt;off+len-1&lt;/tt&gt; should have the format
     *         of a valid class file as defined by
     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
     *
     * @param  off
     *         The start offset in &lt;tt&gt;b&lt;/tt&gt; of the class data
     *
     * @param  len
     *         The length of the class data
     *
     * @return  The &lt;tt&gt;Class&lt;/tt&gt; object that was created from the specified
     *          class data.
     *
     * @throws  ClassFormatError
     *          If the data did not contain a valid class
     *
     * @throws  IndexOutOfBoundsException
     *          If either &lt;tt&gt;off&lt;/tt&gt; or &lt;tt&gt;len&lt;/tt&gt; is negative, or if
     *          &lt;tt&gt;off+len&lt;/tt&gt; is greater than &lt;tt&gt;b.length&lt;/tt&gt;.
     *
     * @throws  SecurityException
     *          If an attempt is made to add this class to a package that
     *          contains classes that were signed by a different set of
     *          certificates than this class (which is unsigned), or if
     *          &lt;tt&gt;name&lt;/tt&gt; begins with &quot;&lt;tt&gt;java.&lt;/tt&gt;&quot;.
     *
     * @see  #loadClass(String, boolean)
     * @see  #resolveClass(Class)
     * @see  java.security.CodeSource
     * @see  java.security.SecureClassLoader
     *
     * @since  1.1
     */
    protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)
        throws ClassFormatError
    {
<span class="nc" id="L642">        return defineClass(name, b, off, len, null);</span>
    }

    /* Determine protection domain, and check that:
        - not define java.* class,
        - signer of this class matches signers for the rest of the classes in
          package.
    */
    private ProtectionDomain preDefineClass(String name,
                                            ProtectionDomain pd)
    {
<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (!checkName(name))</span>
<span class="nc" id="L654">            throw new NoClassDefFoundError(&quot;IllegalName: &quot; + name);</span>

<span class="nc bnc" id="L656" title="All 4 branches missed.">        if ((name != null) &amp;&amp; name.startsWith(&quot;java.&quot;)) {</span>
<span class="nc" id="L657">            throw new SecurityException</span>
                (&quot;Prohibited package name: &quot; +
<span class="nc" id="L659">                 name.substring(0, name.lastIndexOf('.')));</span>
        }
<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (pd == null) {</span>
<span class="nc" id="L662">            pd = defaultDomain;</span>
        }

<span class="nc bnc" id="L665" title="All 2 branches missed.">        if (name != null) checkCerts(name, pd.getCodeSource());</span>

<span class="nc" id="L667">        return pd;</span>
    }

    private String defineClassSourceLocation(ProtectionDomain pd)
    {
<span class="nc" id="L672">        CodeSource cs = pd.getCodeSource();</span>
<span class="nc" id="L673">        String source = null;</span>
<span class="nc bnc" id="L674" title="All 4 branches missed.">        if (cs != null &amp;&amp; cs.getLocation() != null) {</span>
<span class="nc" id="L675">            source = cs.getLocation().toString();</span>
        }
<span class="nc" id="L677">        return source;</span>
    }

    private void postDefineClass(Class&lt;?&gt; c, ProtectionDomain pd)
    {
<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (pd.getCodeSource() != null) {</span>
<span class="nc" id="L683">            Certificate certs[] = pd.getCodeSource().getCertificates();</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">            if (certs != null)</span>
<span class="nc" id="L685">                setSigners(c, certs);</span>
        }
<span class="nc" id="L687">    }</span>

    /**
     * Converts an array of bytes into an instance of class &lt;tt&gt;Class&lt;/tt&gt;,
     * with an optional &lt;tt&gt;ProtectionDomain&lt;/tt&gt;.  If the domain is
     * &lt;tt&gt;null&lt;/tt&gt;, then a default domain will be assigned to the class as
     * specified in the documentation for {@link #defineClass(String, byte[],
     * int, int)}.  Before the class can be used it must be resolved.
     *
     * &lt;p&gt; The first class defined in a package determines the exact set of
     * certificates that all subsequent classes defined in that package must
     * contain.  The set of certificates for a class is obtained from the
     * {@link java.security.CodeSource &lt;tt&gt;CodeSource&lt;/tt&gt;} within the
     * &lt;tt&gt;ProtectionDomain&lt;/tt&gt; of the class.  Any classes added to that
     * package must contain the same set of certificates or a
     * &lt;tt&gt;SecurityException&lt;/tt&gt; will be thrown.  Note that if
     * &lt;tt&gt;name&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;, this check is not performed.
     * You should always pass in the &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the
     * class you are defining as well as the bytes.  This ensures that the
     * class you are defining is indeed the class you think it is.
     *
     * &lt;p&gt; The specified &lt;tt&gt;name&lt;/tt&gt; cannot begin with &quot;&lt;tt&gt;java.&lt;/tt&gt;&quot;, since
     * all classes in the &quot;&lt;tt&gt;java.*&lt;/tt&gt; packages can only be defined by the
     * bootstrap class loader.  If &lt;tt&gt;name&lt;/tt&gt; is not &lt;tt&gt;null&lt;/tt&gt;, it
     * must be equal to the &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
     * specified by the byte array &quot;&lt;tt&gt;b&lt;/tt&gt;&quot;, otherwise a {@link
     * NoClassDefFoundError &lt;tt&gt;NoClassDefFoundError&lt;/tt&gt;} will be thrown. &lt;/p&gt;
     *
     * @param  name
     *         The expected &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class, or
     *         &lt;tt&gt;null&lt;/tt&gt; if not known
     *
     * @param  b
     *         The bytes that make up the class data. The bytes in positions
     *         &lt;tt&gt;off&lt;/tt&gt; through &lt;tt&gt;off+len-1&lt;/tt&gt; should have the format
     *         of a valid class file as defined by
     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
     *
     * @param  off
     *         The start offset in &lt;tt&gt;b&lt;/tt&gt; of the class data
     *
     * @param  len
     *         The length of the class data
     *
     * @param  protectionDomain
     *         The ProtectionDomain of the class
     *
     * @return  The &lt;tt&gt;Class&lt;/tt&gt; object created from the data,
     *          and optional &lt;tt&gt;ProtectionDomain&lt;/tt&gt;.
     *
     * @throws  ClassFormatError
     *          If the data did not contain a valid class
     *
     * @throws  NoClassDefFoundError
     *          If &lt;tt&gt;name&lt;/tt&gt; is not equal to the &lt;a href=&quot;#name&quot;&gt;binary
     *          name&lt;/a&gt; of the class specified by &lt;tt&gt;b&lt;/tt&gt;
     *
     * @throws  IndexOutOfBoundsException
     *          If either &lt;tt&gt;off&lt;/tt&gt; or &lt;tt&gt;len&lt;/tt&gt; is negative, or if
     *          &lt;tt&gt;off+len&lt;/tt&gt; is greater than &lt;tt&gt;b.length&lt;/tt&gt;.
     *
     * @throws  SecurityException
     *          If an attempt is made to add this class to a package that
     *          contains classes that were signed by a different set of
     *          certificates than this class, or if &lt;tt&gt;name&lt;/tt&gt; begins with
     *          &quot;&lt;tt&gt;java.&lt;/tt&gt;&quot;.
     */
    protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
                                         ProtectionDomain protectionDomain)
        throws ClassFormatError
    {
<span class="nc" id="L758">        protectionDomain = preDefineClass(name, protectionDomain);</span>
<span class="nc" id="L759">        String source = defineClassSourceLocation(protectionDomain);</span>
<span class="nc" id="L760">        Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span>
<span class="nc" id="L761">        postDefineClass(c, protectionDomain);</span>
<span class="nc" id="L762">        return c;</span>
    }

    /**
     * Converts a {@link java.nio.ByteBuffer &lt;tt&gt;ByteBuffer&lt;/tt&gt;}
     * into an instance of class &lt;tt&gt;Class&lt;/tt&gt;,
     * with an optional &lt;tt&gt;ProtectionDomain&lt;/tt&gt;.  If the domain is
     * &lt;tt&gt;null&lt;/tt&gt;, then a default domain will be assigned to the class as
     * specified in the documentation for {@link #defineClass(String, byte[],
     * int, int)}.  Before the class can be used it must be resolved.
     *
     * &lt;p&gt;The rules about the first class defined in a package determining the
     * set of certificates for the package, and the restrictions on class names
     * are identical to those specified in the documentation for {@link
     * #defineClass(String, byte[], int, int, ProtectionDomain)}.
     *
     * &lt;p&gt; An invocation of this method of the form
     * &lt;i&gt;cl&lt;/i&gt;&lt;tt&gt;.defineClass(&lt;/tt&gt;&lt;i&gt;name&lt;/i&gt;&lt;tt&gt;,&lt;/tt&gt;
     * &lt;i&gt;bBuffer&lt;/i&gt;&lt;tt&gt;,&lt;/tt&gt; &lt;i&gt;pd&lt;/i&gt;&lt;tt&gt;)&lt;/tt&gt; yields exactly the same
     * result as the statements
     *
     *&lt;p&gt; &lt;tt&gt;
     * ...&lt;br&gt;
     * byte[] temp = new byte[bBuffer.{@link
     * java.nio.ByteBuffer#remaining remaining}()];&lt;br&gt;
     *     bBuffer.{@link java.nio.ByteBuffer#get(byte[])
     * get}(temp);&lt;br&gt;
     *     return {@link #defineClass(String, byte[], int, int, ProtectionDomain)
     * cl.defineClass}(name, temp, 0,
     * temp.length, pd);&lt;br&gt;
     * &lt;/tt&gt;&lt;/p&gt;
     *
     * @param  name
     *         The expected &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;. of the class, or
     *         &lt;tt&gt;null&lt;/tt&gt; if not known
     *
     * @param  b
     *         The bytes that make up the class data. The bytes from positions
     *         &lt;tt&gt;b.position()&lt;/tt&gt; through &lt;tt&gt;b.position() + b.limit() -1
     *         &lt;/tt&gt; should have the format of a valid class file as defined by
     *         &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
     *
     * @param  protectionDomain
     *         The ProtectionDomain of the class, or &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @return  The &lt;tt&gt;Class&lt;/tt&gt; object created from the data,
     *          and optional &lt;tt&gt;ProtectionDomain&lt;/tt&gt;.
     *
     * @throws  ClassFormatError
     *          If the data did not contain a valid class.
     *
     * @throws  NoClassDefFoundError
     *          If &lt;tt&gt;name&lt;/tt&gt; is not equal to the &lt;a href=&quot;#name&quot;&gt;binary
     *          name&lt;/a&gt; of the class specified by &lt;tt&gt;b&lt;/tt&gt;
     *
     * @throws  SecurityException
     *          If an attempt is made to add this class to a package that
     *          contains classes that were signed by a different set of
     *          certificates than this class, or if &lt;tt&gt;name&lt;/tt&gt; begins with
     *          &quot;&lt;tt&gt;java.&lt;/tt&gt;&quot;.
     *
     * @see      #defineClass(String, byte[], int, int, ProtectionDomain)
     *
     * @since  1.5
     */
    protected final Class&lt;?&gt; defineClass(String name, java.nio.ByteBuffer b,
                                         ProtectionDomain protectionDomain)
        throws ClassFormatError
    {
<span class="nc" id="L831">        int len = b.remaining();</span>

        // Use byte[] if not a direct ByteBufer:
<span class="nc bnc" id="L834" title="All 2 branches missed.">        if (!b.isDirect()) {</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">            if (b.hasArray()) {</span>
<span class="nc" id="L836">                return defineClass(name, b.array(),</span>
<span class="nc" id="L837">                                   b.position() + b.arrayOffset(), len,</span>
                                   protectionDomain);
            } else {
                // no array, or read-only array
<span class="nc" id="L841">                byte[] tb = new byte[len];</span>
<span class="nc" id="L842">                b.get(tb);  // get bytes out of byte buffer.</span>
<span class="nc" id="L843">                return defineClass(name, tb, 0, len, protectionDomain);</span>
            }
        }

<span class="nc" id="L847">        protectionDomain = preDefineClass(name, protectionDomain);</span>
<span class="nc" id="L848">        String source = defineClassSourceLocation(protectionDomain);</span>
<span class="nc" id="L849">        Class&lt;?&gt; c = defineClass2(name, b, b.position(), len, protectionDomain, source);</span>
<span class="nc" id="L850">        postDefineClass(c, protectionDomain);</span>
<span class="nc" id="L851">        return c;</span>
    }

    private native Class&lt;?&gt; defineClass0(String name, byte[] b, int off, int len,
                                         ProtectionDomain pd);

    private native Class&lt;?&gt; defineClass1(String name, byte[] b, int off, int len,
                                         ProtectionDomain pd, String source);

    private native Class&lt;?&gt; defineClass2(String name, java.nio.ByteBuffer b,
                                         int off, int len, ProtectionDomain pd,
                                         String source);

    // true if the name is null or has the potential to be a valid binary name
    private boolean checkName(String name) {
<span class="nc bnc" id="L866" title="All 4 branches missed.">        if ((name == null) || (name.length() == 0))</span>
<span class="nc" id="L867">            return true;</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">        if ((name.indexOf('/') != -1)</span>
<span class="nc bnc" id="L869" title="All 4 branches missed.">            || (!VM.allowArraySyntax() &amp;&amp; (name.charAt(0) == '[')))</span>
<span class="nc" id="L870">            return false;</span>
<span class="nc" id="L871">        return true;</span>
    }

    private void checkCerts(String name, CodeSource cs) {
<span class="nc" id="L875">        int i = name.lastIndexOf('.');</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">        String pname = (i == -1) ? &quot;&quot; : name.substring(0, i);</span>

<span class="nc" id="L878">        Certificate[] certs = null;</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if (cs != null) {</span>
<span class="nc" id="L880">            certs = cs.getCertificates();</span>
        }
<span class="nc" id="L882">        Certificate[] pcerts = null;</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">        if (parallelLockMap == null) {</span>
<span class="nc" id="L884">            synchronized (this) {</span>
<span class="nc" id="L885">                pcerts = package2certs.get(pname);</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">                if (pcerts == null) {</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">                    package2certs.put(pname, (certs == null? nocerts:certs));</span>
                }
<span class="nc" id="L889">            }</span>
        } else {
<span class="nc bnc" id="L891" title="All 2 branches missed.">            pcerts = ((ConcurrentHashMap&lt;String, Certificate[]&gt;)package2certs).</span>
<span class="nc" id="L892">                putIfAbsent(pname, (certs == null? nocerts:certs));</span>
        }
<span class="nc bnc" id="L894" title="All 4 branches missed.">        if (pcerts != null &amp;&amp; !compareCerts(pcerts, certs)) {</span>
<span class="nc" id="L895">            throw new SecurityException(&quot;class \&quot;&quot;+ name +</span>
                 &quot;\&quot;'s signer information does not match signer information of other classes in the same package&quot;);
        }
<span class="nc" id="L898">    }</span>

    /**
     * check to make sure the certs for the new class (certs) are the same as
     * the certs for the first class inserted in the package (pcerts)
     */
    private boolean compareCerts(Certificate[] pcerts,
                                 Certificate[] certs)
    {
        // certs can be null, indicating no certs.
<span class="nc bnc" id="L908" title="All 4 branches missed.">        if ((certs == null) || (certs.length == 0)) {</span>
<span class="nc bnc" id="L909" title="All 2 branches missed.">            return pcerts.length == 0;</span>
        }

        // the length must be the same at this point
<span class="nc bnc" id="L913" title="All 2 branches missed.">        if (certs.length != pcerts.length)</span>
<span class="nc" id="L914">            return false;</span>

        // go through and make sure all the certs in one array
        // are in the other and vice-versa.
        boolean match;
<span class="nc bnc" id="L919" title="All 2 branches missed.">        for (int i = 0; i &lt; certs.length; i++) {</span>
<span class="nc" id="L920">            match = false;</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">            for (int j = 0; j &lt; pcerts.length; j++) {</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">                if (certs[i].equals(pcerts[j])) {</span>
<span class="nc" id="L923">                    match = true;</span>
<span class="nc" id="L924">                    break;</span>
                }
            }
<span class="nc bnc" id="L927" title="All 2 branches missed.">            if (!match) return false;</span>
        }

        // now do the same for pcerts
<span class="nc bnc" id="L931" title="All 2 branches missed.">        for (int i = 0; i &lt; pcerts.length; i++) {</span>
<span class="nc" id="L932">            match = false;</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">            for (int j = 0; j &lt; certs.length; j++) {</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">                if (pcerts[i].equals(certs[j])) {</span>
<span class="nc" id="L935">                    match = true;</span>
<span class="nc" id="L936">                    break;</span>
                }
            }
<span class="nc bnc" id="L939" title="All 2 branches missed.">            if (!match) return false;</span>
        }

<span class="nc" id="L942">        return true;</span>
    }

    /**
     * Links the specified class.  This (misleadingly named) method may be
     * used by a class loader to link a class.  If the class &lt;tt&gt;c&lt;/tt&gt; has
     * already been linked, then this method simply returns. Otherwise, the
     * class is linked as described in the &quot;Execution&quot; chapter of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
     *
     * @param  c
     *         The class to link
     *
     * @throws  NullPointerException
     *          If &lt;tt&gt;c&lt;/tt&gt; is &lt;tt&gt;null&lt;/tt&gt;.
     *
     * @see  #defineClass(String, byte[], int, int)
     */
    protected final void resolveClass(Class&lt;?&gt; c) {
<span class="nc" id="L961">        resolveClass0(c);</span>
<span class="nc" id="L962">    }</span>

    private native void resolveClass0(Class&lt;?&gt; c);

    /**
     * Finds a class with the specified &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;,
     * loading it if necessary.
     *
     * &lt;p&gt; This method loads the class through the system class loader (see
     * {@link #getSystemClassLoader()}).  The &lt;tt&gt;Class&lt;/tt&gt; object returned
     * might have more than one &lt;tt&gt;ClassLoader&lt;/tt&gt; associated with it.
     * Subclasses of &lt;tt&gt;ClassLoader&lt;/tt&gt; need not usually invoke this method,
     * because most class loaders need to override just {@link
     * #findClass(String)}.  &lt;/p&gt;
     *
     * @param  name
     *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
     *
     * @return  The &lt;tt&gt;Class&lt;/tt&gt; object for the specified &lt;tt&gt;name&lt;/tt&gt;
     *
     * @throws  ClassNotFoundException
     *          If the class could not be found
     *
     * @see  #ClassLoader(ClassLoader)
     * @see  #getParent()
     */
    protected final Class&lt;?&gt; findSystemClass(String name)
        throws ClassNotFoundException
    {
<span class="nc" id="L991">        ClassLoader system = getSystemClassLoader();</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">        if (system == null) {</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">            if (!checkName(name))</span>
<span class="nc" id="L994">                throw new ClassNotFoundException(name);</span>
<span class="nc" id="L995">            Class&lt;?&gt; cls = findBootstrapClass(name);</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">            if (cls == null) {</span>
<span class="nc" id="L997">                throw new ClassNotFoundException(name);</span>
            }
<span class="nc" id="L999">            return cls;</span>
        }
<span class="nc" id="L1001">        return system.loadClass(name);</span>
    }

    /**
     * Returns a class loaded by the bootstrap class loader;
     * or return null if not found.
     */
    private Class&lt;?&gt; findBootstrapClassOrNull(String name)
    {
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        if (!checkName(name)) return null;</span>

<span class="nc" id="L1012">        return findBootstrapClass(name);</span>
    }

    // return null if not found
    private native Class&lt;?&gt; findBootstrapClass(String name);

    /**
     * Returns the class with the given &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; if this
     * loader has been recorded by the Java virtual machine as an initiating
     * loader of a class with that &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt;.  Otherwise
     * &lt;tt&gt;null&lt;/tt&gt; is returned.
     *
     * @param  name
     *         The &lt;a href=&quot;#name&quot;&gt;binary name&lt;/a&gt; of the class
     *
     * @return  The &lt;tt&gt;Class&lt;/tt&gt; object, or &lt;tt&gt;null&lt;/tt&gt; if the class has
     *          not been loaded
     *
     * @since  1.1
     */
    protected final Class&lt;?&gt; findLoadedClass(String name) {
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (!checkName(name))</span>
<span class="nc" id="L1034">            return null;</span>
<span class="nc" id="L1035">        return findLoadedClass0(name);</span>
    }

    private native final Class&lt;?&gt; findLoadedClass0(String name);

    /**
     * Sets the signers of a class.  This should be invoked after defining a
     * class.
     *
     * @param  c
     *         The &lt;tt&gt;Class&lt;/tt&gt; object
     *
     * @param  signers
     *         The signers for the class
     *
     * @since  1.1
     */
    protected final void setSigners(Class&lt;?&gt; c, Object[] signers) {
<span class="nc" id="L1053">        c.setSigners(signers);</span>
<span class="nc" id="L1054">    }</span>


    // -- Resource --

    /**
     * Finds the resource with the given name.  A resource is some data
     * (images, audio, text, etc) that can be accessed by class code in a way
     * that is independent of the location of the code.
     *
     * &lt;p&gt; The name of a resource is a '&lt;tt&gt;/&lt;/tt&gt;'-separated path name that
     * identifies the resource.
     *
     * &lt;p&gt; This method will first search the parent class loader for the
     * resource; if the parent is &lt;tt&gt;null&lt;/tt&gt; the path of the class loader
     * built-in to the virtual machine is searched.  That failing, this method
     * will invoke {@link #findResource(String)} to find the resource.  &lt;/p&gt;
     *
     * @apiNote When overriding this method it is recommended that an
     * implementation ensures that any delegation is consistent with the {@link
     * #getResources(java.lang.String) getResources(String)} method.
     *
     * @param  name
     *         The resource name
     *
     * @return  A &lt;tt&gt;URL&lt;/tt&gt; object for reading the resource, or
     *          &lt;tt&gt;null&lt;/tt&gt; if the resource could not be found or the invoker
     *          doesn't have adequate  privileges to get the resource.
     *
     * @since  1.1
     */
    public URL getResource(String name) {
        URL url;
<span class="nc bnc" id="L1087" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L1088">            url = parent.getResource(name);</span>
        } else {
<span class="nc" id="L1090">            url = getBootstrapResource(name);</span>
        }
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        if (url == null) {</span>
<span class="nc" id="L1093">            url = findResource(name);</span>
        }
<span class="nc" id="L1095">        return url;</span>
    }

    /**
     * Finds all the resources with the given name. A resource is some data
     * (images, audio, text, etc) that can be accessed by class code in a way
     * that is independent of the location of the code.
     *
     * &lt;p&gt;The name of a resource is a &lt;tt&gt;/&lt;/tt&gt;-separated path name that
     * identifies the resource.
     *
     * &lt;p&gt; The search order is described in the documentation for {@link
     * #getResource(String)}.  &lt;/p&gt;
     *
     * @apiNote When overriding this method it is recommended that an
     * implementation ensures that any delegation is consistent with the {@link
     * #getResource(java.lang.String) getResource(String)} method. This should
     * ensure that the first element returned by the Enumeration's
     * {@code nextElement} method is the same resource that the
     * {@code getResource(String)} method would return.
     *
     * @param  name
     *         The resource name
     *
     * @return  An enumeration of {@link java.net.URL &lt;tt&gt;URL&lt;/tt&gt;} objects for
     *          the resource.  If no resources could  be found, the enumeration
     *          will be empty.  Resources that the class loader doesn't have
     *          access to will not be in the enumeration.
     *
     * @throws  IOException
     *          If I/O errors occur
     *
     * @see  #findResources(String)
     *
     * @since  1.2
     */
    public Enumeration&lt;URL&gt; getResources(String name) throws IOException {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1133">        Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) new Enumeration&lt;?&gt;[2];</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L1135">            tmp[0] = parent.getResources(name);</span>
        } else {
<span class="nc" id="L1137">            tmp[0] = getBootstrapResources(name);</span>
        }
<span class="nc" id="L1139">        tmp[1] = findResources(name);</span>

<span class="nc" id="L1141">        return new CompoundEnumeration&lt;&gt;(tmp);</span>
    }

    /**
     * Finds the resource with the given name. Class loader implementations
     * should override this method to specify where to find resources.
     *
     * @param  name
     *         The resource name
     *
     * @return  A &lt;tt&gt;URL&lt;/tt&gt; object for reading the resource, or
     *          &lt;tt&gt;null&lt;/tt&gt; if the resource could not be found
     *
     * @since  1.2
     */
    protected URL findResource(String name) {
<span class="nc" id="L1157">        return null;</span>
    }

    /**
     * Returns an enumeration of {@link java.net.URL &lt;tt&gt;URL&lt;/tt&gt;} objects
     * representing all the resources with the given name. Class loader
     * implementations should override this method to specify where to load
     * resources from.
     *
     * @param  name
     *         The resource name
     *
     * @return  An enumeration of {@link java.net.URL &lt;tt&gt;URL&lt;/tt&gt;} objects for
     *          the resources
     *
     * @throws  IOException
     *          If I/O errors occur
     *
     * @since  1.2
     */
    protected Enumeration&lt;URL&gt; findResources(String name) throws IOException {
<span class="nc" id="L1178">        return java.util.Collections.emptyEnumeration();</span>
    }

    /**
     * Registers the caller as parallel capable.
     * The registration succeeds if and only if all of the following
     * conditions are met:
     * &lt;ol&gt;
     * &lt;li&gt; no instance of the caller has been created&lt;/li&gt;
     * &lt;li&gt; all of the super classes (except class Object) of the caller are
     * registered as parallel capable&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;p&gt;Note that once a class loader is registered as parallel capable, there
     * is no way to change it back.&lt;/p&gt;
     *
     * @return  true if the caller is successfully registered as
     *          parallel capable and false if otherwise.
     *
     * @since   1.7
     */
    @CallerSensitive
    protected static boolean registerAsParallelCapable() {
        Class&lt;? extends ClassLoader&gt; callerClass =
<span class="nc" id="L1201">            Reflection.getCallerClass().asSubclass(ClassLoader.class);</span>
<span class="nc" id="L1202">        return ParallelLoaders.register(callerClass);</span>
    }

    /**
     * Find a resource of the specified name from the search path used to load
     * classes.  This method locates the resource through the system class
     * loader (see {@link #getSystemClassLoader()}).
     *
     * @param  name
     *         The resource name
     *
     * @return  A {@link java.net.URL &lt;tt&gt;URL&lt;/tt&gt;} object for reading the
     *          resource, or &lt;tt&gt;null&lt;/tt&gt; if the resource could not be found
     *
     * @since  1.1
     */
    public static URL getSystemResource(String name) {
<span class="nc" id="L1219">        ClassLoader system = getSystemClassLoader();</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        if (system == null) {</span>
<span class="nc" id="L1221">            return getBootstrapResource(name);</span>
        }
<span class="nc" id="L1223">        return system.getResource(name);</span>
    }

    /**
     * Finds all resources of the specified name from the search path used to
     * load classes.  The resources thus found are returned as an
     * {@link java.util.Enumeration &lt;tt&gt;Enumeration&lt;/tt&gt;} of {@link
     * java.net.URL &lt;tt&gt;URL&lt;/tt&gt;} objects.
     *
     * &lt;p&gt; The search order is described in the documentation for {@link
     * #getSystemResource(String)}.  &lt;/p&gt;
     *
     * @param  name
     *         The resource name
     *
     * @return  An enumeration of resource {@link java.net.URL &lt;tt&gt;URL&lt;/tt&gt;}
     *          objects
     *
     * @throws  IOException
     *          If I/O errors occur

     * @since  1.2
     */
    public static Enumeration&lt;URL&gt; getSystemResources(String name)
        throws IOException
    {
<span class="nc" id="L1249">        ClassLoader system = getSystemClassLoader();</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">        if (system == null) {</span>
<span class="nc" id="L1251">            return getBootstrapResources(name);</span>
        }
<span class="nc" id="L1253">        return system.getResources(name);</span>
    }

    /**
     * Find resources from the VM's built-in classloader.
     */
    private static URL getBootstrapResource(String name) {
<span class="nc" id="L1260">        URLClassPath ucp = getBootstrapClassPath();</span>
<span class="nc" id="L1261">        Resource res = ucp.getResource(name);</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">        return res != null ? res.getURL() : null;</span>
    }

    /**
     * Find resources from the VM's built-in classloader.
     */
    private static Enumeration&lt;URL&gt; getBootstrapResources(String name)
        throws IOException
    {
        final Enumeration&lt;Resource&gt; e =
<span class="nc" id="L1272">            getBootstrapClassPath().getResources(name);</span>
<span class="pc" id="L1273">        return new Enumeration&lt;URL&gt; () {</span>
            public URL nextElement() {
<span class="nc" id="L1275">                return e.nextElement().getURL();</span>
            }
            public boolean hasMoreElements() {
<span class="fc" id="L1278">                return e.hasMoreElements();</span>
            }
        };
    }

    // Returns the URLClassPath that is used for finding system resources.
    static URLClassPath getBootstrapClassPath() {
<span class="nc" id="L1285">        return sun.misc.Launcher.getBootstrapClassPath();</span>
    }


    /**
     * Returns an input stream for reading the specified resource.
     *
     * &lt;p&gt; The search order is described in the documentation for {@link
     * #getResource(String)}.  &lt;/p&gt;
     *
     * @param  name
     *         The resource name
     *
     * @return  An input stream for reading the resource, or &lt;tt&gt;null&lt;/tt&gt;
     *          if the resource could not be found
     *
     * @since  1.1
     */
    public InputStream getResourceAsStream(String name) {
<span class="nc" id="L1304">        URL url = getResource(name);</span>
        try {
<span class="nc bnc" id="L1306" title="All 2 branches missed.">            return url != null ? url.openStream() : null;</span>
<span class="nc" id="L1307">        } catch (IOException e) {</span>
<span class="nc" id="L1308">            return null;</span>
        }
    }

    /**
     * Open for reading, a resource of the specified name from the search path
     * used to load classes.  This method locates the resource through the
     * system class loader (see {@link #getSystemClassLoader()}).
     *
     * @param  name
     *         The resource name
     *
     * @return  An input stream for reading the resource, or &lt;tt&gt;null&lt;/tt&gt;
     *          if the resource could not be found
     *
     * @since  1.1
     */
    public static InputStream getSystemResourceAsStream(String name) {
<span class="nc" id="L1326">        URL url = getSystemResource(name);</span>
        try {
<span class="nc bnc" id="L1328" title="All 2 branches missed.">            return url != null ? url.openStream() : null;</span>
<span class="nc" id="L1329">        } catch (IOException e) {</span>
<span class="nc" id="L1330">            return null;</span>
        }
    }


    // -- Hierarchy --

    /**
     * Returns the parent class loader for delegation. Some implementations may
     * use &lt;tt&gt;null&lt;/tt&gt; to represent the bootstrap class loader. This method
     * will return &lt;tt&gt;null&lt;/tt&gt; in such implementations if this class loader's
     * parent is the bootstrap class loader.
     *
     * &lt;p&gt; If a security manager is present, and the invoker's class loader is
     * not &lt;tt&gt;null&lt;/tt&gt; and is not an ancestor of this class loader, then this
     * method invokes the security manager's {@link
     * SecurityManager#checkPermission(java.security.Permission)
     * &lt;tt&gt;checkPermission&lt;/tt&gt;} method with a {@link
     * RuntimePermission#RuntimePermission(String)
     * &lt;tt&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/tt&gt;} permission to verify
     * access to the parent class loader is permitted.  If not, a
     * &lt;tt&gt;SecurityException&lt;/tt&gt; will be thrown.  &lt;/p&gt;
     *
     * @return  The parent &lt;tt&gt;ClassLoader&lt;/tt&gt;
     *
     * @throws  SecurityException
     *          If a security manager exists and its &lt;tt&gt;checkPermission&lt;/tt&gt;
     *          method doesn't allow access to this class loader's parent class
     *          loader.
     *
     * @since  1.2
     */
    @CallerSensitive
    public final ClassLoader getParent() {
<span class="nc bnc" id="L1364" title="All 2 branches missed.">        if (parent == null)</span>
<span class="nc" id="L1365">            return null;</span>
<span class="nc" id="L1366">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L1368">            checkClassLoaderPermission(this, Reflection.getCallerClass());</span>
        }
<span class="nc" id="L1370">        return parent;</span>
    }

    /**
     * Returns the system class loader for delegation.  This is the default
     * delegation parent for new &lt;tt&gt;ClassLoader&lt;/tt&gt; instances, and is
     * typically the class loader used to start the application.
     *
     * &lt;p&gt; This method is first invoked early in the runtime's startup
     * sequence, at which point it creates the system class loader and sets it
     * as the context class loader of the invoking &lt;tt&gt;Thread&lt;/tt&gt;.
     *
     * &lt;p&gt; The default system class loader is an implementation-dependent
     * instance of this class.
     *
     * &lt;p&gt; If the system property &quot;&lt;tt&gt;java.system.class.loader&lt;/tt&gt;&quot; is defined
     * when this method is first invoked then the value of that property is
     * taken to be the name of a class that will be returned as the system
     * class loader.  The class is loaded using the default system class loader
     * and must define a public constructor that takes a single parameter of
     * type &lt;tt&gt;ClassLoader&lt;/tt&gt; which is used as the delegation parent.  An
     * instance is then created using this constructor with the default system
     * class loader as the parameter.  The resulting class loader is defined
     * to be the system class loader.
     *
     * &lt;p&gt; If a security manager is present, and the invoker's class loader is
     * not &lt;tt&gt;null&lt;/tt&gt; and the invoker's class loader is not the same as or
     * an ancestor of the system class loader, then this method invokes the
     * security manager's {@link
     * SecurityManager#checkPermission(java.security.Permission)
     * &lt;tt&gt;checkPermission&lt;/tt&gt;} method with a {@link
     * RuntimePermission#RuntimePermission(String)
     * &lt;tt&gt;RuntimePermission(&quot;getClassLoader&quot;)&lt;/tt&gt;} permission to verify
     * access to the system class loader.  If not, a
     * &lt;tt&gt;SecurityException&lt;/tt&gt; will be thrown.  &lt;/p&gt;
     *
     * @return  The system &lt;tt&gt;ClassLoader&lt;/tt&gt; for delegation, or
     *          &lt;tt&gt;null&lt;/tt&gt; if none
     *
     * @throws  SecurityException
     *          If a security manager exists and its &lt;tt&gt;checkPermission&lt;/tt&gt;
     *          method doesn't allow access to the system class loader.
     *
     * @throws  IllegalStateException
     *          If invoked recursively during the construction of the class
     *          loader specified by the &quot;&lt;tt&gt;java.system.class.loader&lt;/tt&gt;&quot;
     *          property.
     *
     * @throws  Error
     *          If the system property &quot;&lt;tt&gt;java.system.class.loader&lt;/tt&gt;&quot;
     *          is defined but the named class could not be loaded, the
     *          provider class does not define the required constructor, or an
     *          exception is thrown by that constructor when it is invoked. The
     *          underlying cause of the error can be retrieved via the
     *          {@link Throwable#getCause()} method.
     *
     * @revised  1.4
     */
    @CallerSensitive
    public static ClassLoader getSystemClassLoader() {
<span class="nc" id="L1430">        initSystemClassLoader();</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">        if (scl == null) {</span>
<span class="nc" id="L1432">            return null;</span>
        }
<span class="nc" id="L1434">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L1436">            checkClassLoaderPermission(scl, Reflection.getCallerClass());</span>
        }
<span class="nc" id="L1438">        return scl;</span>
    }

    private static synchronized void initSystemClassLoader() {
<span class="nc bnc" id="L1442" title="All 2 branches missed.">        if (!sclSet) {</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">            if (scl != null)</span>
<span class="nc" id="L1444">                throw new IllegalStateException(&quot;recursive invocation&quot;);</span>
<span class="nc" id="L1445">            sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">            if (l != null) {</span>
<span class="nc" id="L1447">                Throwable oops = null;</span>
<span class="nc" id="L1448">                scl = l.getClassLoader();</span>
                try {
<span class="nc" id="L1450">                    scl = AccessController.doPrivileged(</span>
                        new SystemClassLoaderAction(scl));
<span class="nc" id="L1452">                } catch (PrivilegedActionException pae) {</span>
<span class="nc" id="L1453">                    oops = pae.getCause();</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">                    if (oops instanceof InvocationTargetException) {</span>
<span class="nc" id="L1455">                        oops = oops.getCause();</span>
                    }
<span class="nc" id="L1457">                }</span>
<span class="nc bnc" id="L1458" title="All 2 branches missed.">                if (oops != null) {</span>
<span class="nc bnc" id="L1459" title="All 2 branches missed.">                    if (oops instanceof Error) {</span>
<span class="nc" id="L1460">                        throw (Error) oops;</span>
                    } else {
                        // wrap the exception
<span class="nc" id="L1463">                        throw new Error(oops);</span>
                    }
                }
            }
<span class="nc" id="L1467">            sclSet = true;</span>
        }
<span class="nc" id="L1469">    }</span>

    // Returns true if the specified class loader can be found in this class
    // loader's delegation chain.
    boolean isAncestor(ClassLoader cl) {
<span class="nc" id="L1474">        ClassLoader acl = this;</span>
        do {
<span class="nc" id="L1476">            acl = acl.parent;</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">            if (cl == acl) {</span>
<span class="nc" id="L1478">                return true;</span>
            }
<span class="nc bnc" id="L1480" title="All 2 branches missed.">        } while (acl != null);</span>
<span class="nc" id="L1481">        return false;</span>
    }

    // Tests if class loader access requires &quot;getClassLoader&quot; permission
    // check.  A class loader 'from' can access class loader 'to' if
    // class loader 'from' is same as class loader 'to' or an ancestor
    // of 'to'.  The class loader in a system domain can access
    // any class loader.
    private static boolean needsClassLoaderPermissionCheck(ClassLoader from,
                                                           ClassLoader to)
    {
<span class="nc bnc" id="L1492" title="All 2 branches missed.">        if (from == to)</span>
<span class="nc" id="L1493">            return false;</span>

<span class="nc bnc" id="L1495" title="All 2 branches missed.">        if (from == null)</span>
<span class="nc" id="L1496">            return false;</span>

<span class="nc bnc" id="L1498" title="All 2 branches missed.">        return !to.isAncestor(from);</span>
    }

    // Returns the class's class loader, or null if none.
    static ClassLoader getClassLoader(Class&lt;?&gt; caller) {
        // This can be null if the VM is requesting it
<span class="nc bnc" id="L1504" title="All 2 branches missed.">        if (caller == null) {</span>
<span class="nc" id="L1505">            return null;</span>
        }
        // Circumvent security check since this is package-private
<span class="nc" id="L1508">        return caller.getClassLoader0();</span>
    }

    static void checkClassLoaderPermission(ClassLoader cl, Class&lt;?&gt; caller) {
<span class="nc" id="L1512">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">        if (sm != null) {</span>
            // caller can be null if the VM is requesting it
<span class="nc" id="L1515">            ClassLoader ccl = getClassLoader(caller);</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">            if (needsClassLoaderPermissionCheck(ccl, cl)) {</span>
<span class="nc" id="L1517">                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);</span>
            }
        }
<span class="nc" id="L1520">    }</span>

    // The class loader for the system
    // @GuardedBy(&quot;ClassLoader.class&quot;)
    private static ClassLoader scl;

    // Set to true once the system class loader has been set
    // @GuardedBy(&quot;ClassLoader.class&quot;)
    private static boolean sclSet;


    // -- Package --

    /**
     * Defines a package by name in this &lt;tt&gt;ClassLoader&lt;/tt&gt;.  This allows
     * class loaders to define the packages for their classes. Packages must
     * be created before the class is defined, and package names must be
     * unique within a class loader and cannot be redefined or changed once
     * created.
     *
     * @param  name
     *         The package name
     *
     * @param  specTitle
     *         The specification title
     *
     * @param  specVersion
     *         The specification version
     *
     * @param  specVendor
     *         The specification vendor
     *
     * @param  implTitle
     *         The implementation title
     *
     * @param  implVersion
     *         The implementation version
     *
     * @param  implVendor
     *         The implementation vendor
     *
     * @param  sealBase
     *         If not &lt;tt&gt;null&lt;/tt&gt;, then this package is sealed with
     *         respect to the given code source {@link java.net.URL
     *         &lt;tt&gt;URL&lt;/tt&gt;}  object.  Otherwise, the package is not sealed.
     *
     * @return  The newly defined &lt;tt&gt;Package&lt;/tt&gt; object
     *
     * @throws  IllegalArgumentException
     *          If package name duplicates an existing package either in this
     *          class loader or one of its ancestors
     *
     * @since  1.2
     */
    protected Package definePackage(String name, String specTitle,
                                    String specVersion, String specVendor,
                                    String implTitle, String implVersion,
                                    String implVendor, URL sealBase)
        throws IllegalArgumentException
    {
<span class="nc" id="L1580">        synchronized (packages) {</span>
<span class="nc" id="L1581">            Package pkg = getPackage(name);</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">            if (pkg != null) {</span>
<span class="nc" id="L1583">                throw new IllegalArgumentException(name);</span>
            }
<span class="nc" id="L1585">            pkg = new Package(name, specTitle, specVersion, specVendor,</span>
                              implTitle, implVersion, implVendor,
                              sealBase, this);
<span class="nc" id="L1588">            packages.put(name, pkg);</span>
<span class="nc" id="L1589">            return pkg;</span>
<span class="nc" id="L1590">        }</span>
    }

    /**
     * Returns a &lt;tt&gt;Package&lt;/tt&gt; that has been defined by this class loader
     * or any of its ancestors.
     *
     * @param  name
     *         The package name
     *
     * @return  The &lt;tt&gt;Package&lt;/tt&gt; corresponding to the given name, or
     *          &lt;tt&gt;null&lt;/tt&gt; if not found
     *
     * @since  1.2
     */
    protected Package getPackage(String name) {
        Package pkg;
<span class="nc" id="L1607">        synchronized (packages) {</span>
<span class="nc" id="L1608">            pkg = packages.get(name);</span>
<span class="nc" id="L1609">        }</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">        if (pkg == null) {</span>
<span class="nc bnc" id="L1611" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L1612">                pkg = parent.getPackage(name);</span>
            } else {
<span class="nc" id="L1614">                pkg = Package.getSystemPackage(name);</span>
            }
<span class="nc bnc" id="L1616" title="All 2 branches missed.">            if (pkg != null) {</span>
<span class="nc" id="L1617">                synchronized (packages) {</span>
<span class="nc" id="L1618">                    Package pkg2 = packages.get(name);</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">                    if (pkg2 == null) {</span>
<span class="nc" id="L1620">                        packages.put(name, pkg);</span>
                    } else {
<span class="nc" id="L1622">                        pkg = pkg2;</span>
                    }
<span class="nc" id="L1624">                }</span>
            }
        }
<span class="nc" id="L1627">        return pkg;</span>
    }

    /**
     * Returns all of the &lt;tt&gt;Packages&lt;/tt&gt; defined by this class loader and
     * its ancestors.
     *
     * @return  The array of &lt;tt&gt;Package&lt;/tt&gt; objects defined by this
     *          &lt;tt&gt;ClassLoader&lt;/tt&gt;
     *
     * @since  1.2
     */
    protected Package[] getPackages() {
        Map&lt;String, Package&gt; map;
<span class="nc" id="L1641">        synchronized (packages) {</span>
<span class="nc" id="L1642">            map = new HashMap&lt;&gt;(packages);</span>
<span class="nc" id="L1643">        }</span>
        Package[] pkgs;
<span class="nc bnc" id="L1645" title="All 2 branches missed.">        if (parent != null) {</span>
<span class="nc" id="L1646">            pkgs = parent.getPackages();</span>
        } else {
<span class="nc" id="L1648">            pkgs = Package.getSystemPackages();</span>
        }
<span class="nc bnc" id="L1650" title="All 2 branches missed.">        if (pkgs != null) {</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">            for (int i = 0; i &lt; pkgs.length; i++) {</span>
<span class="nc" id="L1652">                String pkgName = pkgs[i].getName();</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">                if (map.get(pkgName) == null) {</span>
<span class="nc" id="L1654">                    map.put(pkgName, pkgs[i]);</span>
                }
            }
        }
<span class="nc" id="L1658">        return map.values().toArray(new Package[map.size()]);</span>
    }


    // -- Native library access --

    /**
     * Returns the absolute path name of a native library.  The VM invokes this
     * method to locate the native libraries that belong to classes loaded with
     * this class loader. If this method returns &lt;tt&gt;null&lt;/tt&gt;, the VM
     * searches the library along the path specified as the
     * &quot;&lt;tt&gt;java.library.path&lt;/tt&gt;&quot; property.
     *
     * @param  libname
     *         The library name
     *
     * @return  The absolute path of the native library
     *
     * @see  System#loadLibrary(String)
     * @see  System#mapLibraryName(String)
     *
     * @since  1.2
     */
    protected String findLibrary(String libname) {
<span class="nc" id="L1682">        return null;</span>
    }

    /**
     * The inner class NativeLibrary denotes a loaded native library instance.
     * Every classloader contains a vector of loaded native libraries in the
     * private field &lt;tt&gt;nativeLibraries&lt;/tt&gt;.  The native libraries loaded
     * into the system are entered into the &lt;tt&gt;systemNativeLibraries&lt;/tt&gt;
     * vector.
     *
     * &lt;p&gt; Every native library requires a particular version of JNI. This is
     * denoted by the private &lt;tt&gt;jniVersion&lt;/tt&gt; field.  This field is set by
     * the VM when it loads the library, and used by the VM to pass the correct
     * version of JNI to the native methods.  &lt;/p&gt;
     *
     * @see      ClassLoader
     * @since    1.2
     */
    static class NativeLibrary {
        // opaque handle to native library, used in native code.
        long handle;
        // the version of JNI environment the native library requires.
        private int jniVersion;
        // the class from which the library is loaded, also indicates
        // the loader this native library belongs.
        private final Class&lt;?&gt; fromClass;
        // the canonicalized name of the native library.
        // or static library name
        String name;
        // Indicates if the native library is linked into the VM
        boolean isBuiltin;
        // Indicates if the native library is loaded
        boolean loaded;
        native void load(String name, boolean isBuiltin);

        native long find(String name);
        native void unload(String name, boolean isBuiltin);
        static native String findBuiltinLib(String name);

<span class="fc" id="L1721">        public NativeLibrary(Class&lt;?&gt; fromClass, String name, boolean isBuiltin) {</span>
<span class="fc" id="L1722">            this.name = name;</span>
<span class="fc" id="L1723">            this.fromClass = fromClass;</span>
<span class="fc" id="L1724">            this.isBuiltin = isBuiltin;</span>
<span class="fc" id="L1725">        }</span>

        protected void finalize() {
<span class="nc" id="L1728">            synchronized (loadedLibraryNames) {</span>
<span class="nc bnc" id="L1729" title="All 4 branches missed.">                if (fromClass.getClassLoader() != null &amp;&amp; loaded) {</span>
                    /* remove the native library name */
<span class="nc" id="L1731">                    int size = loadedLibraryNames.size();</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">                    for (int i = 0; i &lt; size; i++) {</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">                        if (name.equals(loadedLibraryNames.elementAt(i))) {</span>
<span class="nc" id="L1734">                            loadedLibraryNames.removeElementAt(i);</span>
<span class="nc" id="L1735">                            break;</span>
                        }
                    }
                    /* unload the library. */
<span class="nc" id="L1739">                    ClassLoader.nativeLibraryContext.push(this);</span>
                    try {
<span class="nc" id="L1741">                        unload(name, isBuiltin);</span>
                    } finally {
<span class="nc" id="L1743">                        ClassLoader.nativeLibraryContext.pop();</span>
<span class="nc" id="L1744">                    }</span>
                }
<span class="nc" id="L1746">            }</span>
<span class="nc" id="L1747">        }</span>
        // Invoked in the VM to determine the context class in
        // JNI_Load/JNI_Unload
        static Class&lt;?&gt; getFromClass() {
<span class="fc" id="L1751">            return ClassLoader.nativeLibraryContext.peek().fromClass;</span>
        }
    }

    // All native library names we've loaded.
<span class="nc" id="L1756">    private static Vector&lt;String&gt; loadedLibraryNames = new Vector&lt;&gt;();</span>

    // Native libraries belonging to system classes.
<span class="nc" id="L1759">    private static Vector&lt;NativeLibrary&gt; systemNativeLibraries</span>
        = new Vector&lt;&gt;();

    // Native libraries associated with the class loader.
<span class="nc" id="L1763">    private Vector&lt;NativeLibrary&gt; nativeLibraries = new Vector&lt;&gt;();</span>

    // native libraries being loaded/unloaded.
<span class="nc" id="L1766">    private static Stack&lt;NativeLibrary&gt; nativeLibraryContext = new Stack&lt;&gt;();</span>

    // The paths searched for libraries
    private static String usr_paths[];
    private static String sys_paths[];

    private static String[] initializePath(String propname) {
<span class="nc" id="L1773">        String ldpath = System.getProperty(propname, &quot;&quot;);</span>
<span class="nc" id="L1774">        String ps = File.pathSeparator;</span>
<span class="nc" id="L1775">        int ldlen = ldpath.length();</span>
        int i, j, n;
        // Count the separators in the path
<span class="nc" id="L1778">        i = ldpath.indexOf(ps);</span>
<span class="nc" id="L1779">        n = 0;</span>
<span class="nc bnc" id="L1780" title="All 2 branches missed.">        while (i &gt;= 0) {</span>
<span class="nc" id="L1781">            n++;</span>
<span class="nc" id="L1782">            i = ldpath.indexOf(ps, i + 1);</span>
        }

        // allocate the array of paths - n :'s = n + 1 path elements
<span class="nc" id="L1786">        String[] paths = new String[n + 1];</span>

        // Fill the array with paths from the ldpath
<span class="nc" id="L1789">        n = i = 0;</span>
<span class="nc" id="L1790">        j = ldpath.indexOf(ps);</span>
<span class="nc bnc" id="L1791" title="All 2 branches missed.">        while (j &gt;= 0) {</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">            if (j - i &gt; 0) {</span>
<span class="nc" id="L1793">                paths[n++] = ldpath.substring(i, j);</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">            } else if (j - i == 0) {</span>
<span class="nc" id="L1795">                paths[n++] = &quot;.&quot;;</span>
            }
<span class="nc" id="L1797">            i = j + 1;</span>
<span class="nc" id="L1798">            j = ldpath.indexOf(ps, i);</span>
        }
<span class="nc" id="L1800">        paths[n] = ldpath.substring(i, ldlen);</span>
<span class="nc" id="L1801">        return paths;</span>
    }

    // Invoked in the java.lang.Runtime class to implement load and loadLibrary.
    static void loadLibrary(Class&lt;?&gt; fromClass, String name,
                            boolean isAbsolute) {
<span class="nc bnc" id="L1807" title="All 2 branches missed.">        ClassLoader loader =</span>
<span class="nc" id="L1808">            (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="nc bnc" id="L1809" title="All 2 branches missed.">        if (sys_paths == null) {</span>
<span class="nc" id="L1810">            usr_paths = initializePath(&quot;java.library.path&quot;);</span>
<span class="nc" id="L1811">            sys_paths = initializePath(&quot;sun.boot.library.path&quot;);</span>
        }
<span class="nc bnc" id="L1813" title="All 2 branches missed.">        if (isAbsolute) {</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">            if (loadLibrary0(fromClass, new File(name))) {</span>
<span class="nc" id="L1815">                return;</span>
            }
<span class="nc" id="L1817">            throw new UnsatisfiedLinkError(&quot;Can't load library: &quot; + name);</span>
        }
<span class="nc bnc" id="L1819" title="All 2 branches missed.">        if (loader != null) {</span>
<span class="nc" id="L1820">            String libfilename = loader.findLibrary(name);</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">            if (libfilename != null) {</span>
<span class="nc" id="L1822">                File libfile = new File(libfilename);</span>
<span class="nc bnc" id="L1823" title="All 2 branches missed.">                if (!libfile.isAbsolute()) {</span>
<span class="nc" id="L1824">                    throw new UnsatisfiedLinkError(</span>
    &quot;ClassLoader.findLibrary failed to return an absolute path: &quot; + libfilename);
                }
<span class="nc bnc" id="L1827" title="All 2 branches missed.">                if (loadLibrary0(fromClass, libfile)) {</span>
<span class="nc" id="L1828">                    return;</span>
                }
<span class="nc" id="L1830">                throw new UnsatisfiedLinkError(&quot;Can't load &quot; + libfilename);</span>
            }
        }
<span class="nc bnc" id="L1833" title="All 2 branches missed.">        for (int i = 0 ; i &lt; sys_paths.length ; i++) {</span>
<span class="nc" id="L1834">            File libfile = new File(sys_paths[i], System.mapLibraryName(name));</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">            if (loadLibrary0(fromClass, libfile)) {</span>
<span class="nc" id="L1836">                return;</span>
            }
<span class="nc" id="L1838">            libfile = ClassLoaderHelper.mapAlternativeName(libfile);</span>
<span class="nc bnc" id="L1839" title="All 4 branches missed.">            if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {</span>
<span class="nc" id="L1840">                return;</span>
            }
        }
<span class="nc bnc" id="L1843" title="All 2 branches missed.">        if (loader != null) {</span>
<span class="nc bnc" id="L1844" title="All 2 branches missed.">            for (int i = 0 ; i &lt; usr_paths.length ; i++) {</span>
<span class="nc" id="L1845">                File libfile = new File(usr_paths[i],</span>
<span class="nc" id="L1846">                                        System.mapLibraryName(name));</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">                if (loadLibrary0(fromClass, libfile)) {</span>
<span class="nc" id="L1848">                    return;</span>
                }
<span class="nc" id="L1850">                libfile = ClassLoaderHelper.mapAlternativeName(libfile);</span>
<span class="nc bnc" id="L1851" title="All 4 branches missed.">                if (libfile != null &amp;&amp; loadLibrary0(fromClass, libfile)) {</span>
<span class="nc" id="L1852">                    return;</span>
                }
            }
        }
        // Oops, it failed
<span class="nc" id="L1857">        throw new UnsatisfiedLinkError(&quot;no &quot; + name + &quot; in java.library.path&quot;);</span>
    }

    private static boolean loadLibrary0(Class&lt;?&gt; fromClass, final File file) {
        // Check to see if we're attempting to access a static library
<span class="nc" id="L1862">        String name = NativeLibrary.findBuiltinLib(file.getName());</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">        boolean isBuiltin = (name != null);</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">        if (!isBuiltin) {</span>
<span class="nc bnc" id="L1865" title="All 2 branches missed.">            boolean exists = AccessController.doPrivileged(</span>
<span class="fc" id="L1866">                new PrivilegedAction&lt;Object&gt;() {</span>
                    public Object run() {
<span class="fc bfc" id="L1868" title="All 2 branches covered.">                        return file.exists() ? Boolean.TRUE : null;</span>
                    }})
                != null;
<span class="nc bnc" id="L1871" title="All 2 branches missed.">            if (!exists) {</span>
<span class="nc" id="L1872">                return false;</span>
            }
            try {
<span class="nc" id="L1875">                name = file.getCanonicalPath();</span>
<span class="nc" id="L1876">            } catch (IOException e) {</span>
<span class="nc" id="L1877">                return false;</span>
<span class="nc" id="L1878">            }</span>
        }
<span class="nc bnc" id="L1880" title="All 2 branches missed.">        ClassLoader loader =</span>
<span class="nc" id="L1881">            (fromClass == null) ? null : fromClass.getClassLoader();</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">        Vector&lt;NativeLibrary&gt; libs =</span>
            loader != null ? loader.nativeLibraries : systemNativeLibraries;
<span class="nc" id="L1884">        synchronized (libs) {</span>
<span class="nc" id="L1885">            int size = libs.size();</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1887">                NativeLibrary lib = libs.elementAt(i);</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">                if (name.equals(lib.name)) {</span>
<span class="nc" id="L1889">                    return true;</span>
                }
            }

<span class="nc" id="L1893">            synchronized (loadedLibraryNames) {</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">                if (loadedLibraryNames.contains(name)) {</span>
<span class="nc" id="L1895">                    throw new UnsatisfiedLinkError</span>
                        (&quot;Native Library &quot; +
                         name +
                         &quot; already loaded in another classloader&quot;);
                }
                /* If the library is being loaded (must be by the same thread,
                 * because Runtime.load and Runtime.loadLibrary are
                 * synchronous). The reason is can occur is that the JNI_OnLoad
                 * function can cause another loadLibrary invocation.
                 *
                 * Thus we can use a static stack to hold the list of libraries
                 * we are loading.
                 *
                 * If there is a pending load operation for the library, we
                 * immediately return success; otherwise, we raise
                 * UnsatisfiedLinkError.
                 */
<span class="nc" id="L1912">                int n = nativeLibraryContext.size();</span>
<span class="nc bnc" id="L1913" title="All 2 branches missed.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L1914">                    NativeLibrary lib = nativeLibraryContext.elementAt(i);</span>
<span class="nc bnc" id="L1915" title="All 2 branches missed.">                    if (name.equals(lib.name)) {</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">                        if (loader == lib.fromClass.getClassLoader()) {</span>
<span class="nc" id="L1917">                            return true;</span>
                        } else {
<span class="nc" id="L1919">                            throw new UnsatisfiedLinkError</span>
                                (&quot;Native Library &quot; +
                                 name +
                                 &quot; is being loaded in another classloader&quot;);
                        }
                    }
                }
<span class="nc" id="L1926">                NativeLibrary lib = new NativeLibrary(fromClass, name, isBuiltin);</span>
<span class="nc" id="L1927">                nativeLibraryContext.push(lib);</span>
                try {
<span class="nc" id="L1929">                    lib.load(name, isBuiltin);</span>
                } finally {
<span class="nc" id="L1931">                    nativeLibraryContext.pop();</span>
<span class="nc" id="L1932">                }</span>
<span class="nc bnc" id="L1933" title="All 2 branches missed.">                if (lib.loaded) {</span>
<span class="nc" id="L1934">                    loadedLibraryNames.addElement(name);</span>
<span class="nc" id="L1935">                    libs.addElement(lib);</span>
<span class="nc" id="L1936">                    return true;</span>
                }
<span class="nc" id="L1938">                return false;</span>
<span class="nc" id="L1939">            }</span>
<span class="nc" id="L1940">        }</span>
    }

    // Invoked in the VM class linking code.
    static long findNative(ClassLoader loader, String name) {
<span class="nc bnc" id="L1945" title="All 2 branches missed.">        Vector&lt;NativeLibrary&gt; libs =</span>
            loader != null ? loader.nativeLibraries : systemNativeLibraries;
<span class="nc" id="L1947">        synchronized (libs) {</span>
<span class="nc" id="L1948">            int size = libs.size();</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1950">                NativeLibrary lib = libs.elementAt(i);</span>
<span class="nc" id="L1951">                long entry = lib.find(name);</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">                if (entry != 0)</span>
<span class="nc" id="L1953">                    return entry;</span>
            }
<span class="nc" id="L1955">        }</span>
<span class="nc" id="L1956">        return 0;</span>
    }


    // -- Assertion management --

    final Object assertionLock;

    // The default toggle for assertion checking.
    // @GuardedBy(&quot;assertionLock&quot;)
<span class="nc" id="L1966">    private boolean defaultAssertionStatus = false;</span>

    // Maps String packageName to Boolean package default assertion status Note
    // that the default package is placed under a null map key.  If this field
    // is null then we are delegating assertion status queries to the VM, i.e.,
    // none of this ClassLoader's assertion status modification methods have
    // been invoked.
    // @GuardedBy(&quot;assertionLock&quot;)
<span class="nc" id="L1974">    private Map&lt;String, Boolean&gt; packageAssertionStatus = null;</span>

    // Maps String fullyQualifiedClassName to Boolean assertionStatus If this
    // field is null then we are delegating assertion status queries to the VM,
    // i.e., none of this ClassLoader's assertion status modification methods
    // have been invoked.
    // @GuardedBy(&quot;assertionLock&quot;)
<span class="nc" id="L1981">    Map&lt;String, Boolean&gt; classAssertionStatus = null;</span>

    /**
     * Sets the default assertion status for this class loader.  This setting
     * determines whether classes loaded by this class loader and initialized
     * in the future will have assertions enabled or disabled by default.
     * This setting may be overridden on a per-package or per-class basis by
     * invoking {@link #setPackageAssertionStatus(String, boolean)} or {@link
     * #setClassAssertionStatus(String, boolean)}.
     *
     * @param  enabled
     *         &lt;tt&gt;true&lt;/tt&gt; if classes loaded by this class loader will
     *         henceforth have assertions enabled by default, &lt;tt&gt;false&lt;/tt&gt;
     *         if they will have assertions disabled by default.
     *
     * @since  1.4
     */
    public void setDefaultAssertionStatus(boolean enabled) {
<span class="nc" id="L1999">        synchronized (assertionLock) {</span>
<span class="nc bnc" id="L2000" title="All 2 branches missed.">            if (classAssertionStatus == null)</span>
<span class="nc" id="L2001">                initializeJavaAssertionMaps();</span>

<span class="nc" id="L2003">            defaultAssertionStatus = enabled;</span>
<span class="nc" id="L2004">        }</span>
<span class="nc" id="L2005">    }</span>

    /**
     * Sets the package default assertion status for the named package.  The
     * package default assertion status determines the assertion status for
     * classes initialized in the future that belong to the named package or
     * any of its &quot;subpackages&quot;.
     *
     * &lt;p&gt; A subpackage of a package named p is any package whose name begins
     * with &quot;&lt;tt&gt;p.&lt;/tt&gt;&quot;.  For example, &lt;tt&gt;javax.swing.text&lt;/tt&gt; is a
     * subpackage of &lt;tt&gt;javax.swing&lt;/tt&gt;, and both &lt;tt&gt;java.util&lt;/tt&gt; and
     * &lt;tt&gt;java.lang.reflect&lt;/tt&gt; are subpackages of &lt;tt&gt;java&lt;/tt&gt;.
     *
     * &lt;p&gt; In the event that multiple package defaults apply to a given class,
     * the package default pertaining to the most specific package takes
     * precedence over the others.  For example, if &lt;tt&gt;javax.lang&lt;/tt&gt; and
     * &lt;tt&gt;javax.lang.reflect&lt;/tt&gt; both have package defaults associated with
     * them, the latter package default applies to classes in
     * &lt;tt&gt;javax.lang.reflect&lt;/tt&gt;.
     *
     * &lt;p&gt; Package defaults take precedence over the class loader's default
     * assertion status, and may be overridden on a per-class basis by invoking
     * {@link #setClassAssertionStatus(String, boolean)}.  &lt;/p&gt;
     *
     * @param  packageName
     *         The name of the package whose package default assertion status
     *         is to be set. A &lt;tt&gt;null&lt;/tt&gt; value indicates the unnamed
     *         package that is &quot;current&quot;
     *         (see section 7.4.2 of
     *         &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.)
     *
     * @param  enabled
     *         &lt;tt&gt;true&lt;/tt&gt; if classes loaded by this classloader and
     *         belonging to the named package or any of its subpackages will
     *         have assertions enabled by default, &lt;tt&gt;false&lt;/tt&gt; if they will
     *         have assertions disabled by default.
     *
     * @since  1.4
     */
    public void setPackageAssertionStatus(String packageName,
                                          boolean enabled) {
<span class="nc" id="L2046">        synchronized (assertionLock) {</span>
<span class="nc bnc" id="L2047" title="All 2 branches missed.">            if (packageAssertionStatus == null)</span>
<span class="nc" id="L2048">                initializeJavaAssertionMaps();</span>

<span class="nc" id="L2050">            packageAssertionStatus.put(packageName, enabled);</span>
<span class="nc" id="L2051">        }</span>
<span class="nc" id="L2052">    }</span>

    /**
     * Sets the desired assertion status for the named top-level class in this
     * class loader and any nested classes contained therein.  This setting
     * takes precedence over the class loader's default assertion status, and
     * over any applicable per-package default.  This method has no effect if
     * the named class has already been initialized.  (Once a class is
     * initialized, its assertion status cannot change.)
     *
     * &lt;p&gt; If the named class is not a top-level class, this invocation will
     * have no effect on the actual assertion status of any class. &lt;/p&gt;
     *
     * @param  className
     *         The fully qualified class name of the top-level class whose
     *         assertion status is to be set.
     *
     * @param  enabled
     *         &lt;tt&gt;true&lt;/tt&gt; if the named class is to have assertions
     *         enabled when (and if) it is initialized, &lt;tt&gt;false&lt;/tt&gt; if the
     *         class is to have assertions disabled.
     *
     * @since  1.4
     */
    public void setClassAssertionStatus(String className, boolean enabled) {
<span class="nc" id="L2077">        synchronized (assertionLock) {</span>
<span class="nc bnc" id="L2078" title="All 2 branches missed.">            if (classAssertionStatus == null)</span>
<span class="nc" id="L2079">                initializeJavaAssertionMaps();</span>

<span class="nc" id="L2081">            classAssertionStatus.put(className, enabled);</span>
<span class="nc" id="L2082">        }</span>
<span class="nc" id="L2083">    }</span>

    /**
     * Sets the default assertion status for this class loader to
     * &lt;tt&gt;false&lt;/tt&gt; and discards any package defaults or class assertion
     * status settings associated with the class loader.  This method is
     * provided so that class loaders can be made to ignore any command line or
     * persistent assertion status settings and &quot;start with a clean slate.&quot;
     *
     * @since  1.4
     */
    public void clearAssertionStatus() {
        /*
         * Whether or not &quot;Java assertion maps&quot; are initialized, set
         * them to empty maps, effectively ignoring any present settings.
         */
<span class="nc" id="L2099">        synchronized (assertionLock) {</span>
<span class="nc" id="L2100">            classAssertionStatus = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2101">            packageAssertionStatus = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2102">            defaultAssertionStatus = false;</span>
<span class="nc" id="L2103">        }</span>
<span class="nc" id="L2104">    }</span>

    /**
     * Returns the assertion status that would be assigned to the specified
     * class if it were to be initialized at the time this method is invoked.
     * If the named class has had its assertion status set, the most recent
     * setting will be returned; otherwise, if any package default assertion
     * status pertains to this class, the most recent setting for the most
     * specific pertinent package default assertion status is returned;
     * otherwise, this class loader's default assertion status is returned.
     * &lt;/p&gt;
     *
     * @param  className
     *         The fully qualified class name of the class whose desired
     *         assertion status is being queried.
     *
     * @return  The desired assertion status of the specified class.
     *
     * @see  #setClassAssertionStatus(String, boolean)
     * @see  #setPackageAssertionStatus(String, boolean)
     * @see  #setDefaultAssertionStatus(boolean)
     *
     * @since  1.4
     */
    boolean desiredAssertionStatus(String className) {
<span class="nc" id="L2129">        synchronized (assertionLock) {</span>
            // assert classAssertionStatus   != null;
            // assert packageAssertionStatus != null;

            // Check for a class entry
<span class="nc" id="L2134">            Boolean result = classAssertionStatus.get(className);</span>
<span class="nc bnc" id="L2135" title="All 2 branches missed.">            if (result != null)</span>
<span class="nc" id="L2136">                return result.booleanValue();</span>

            // Check for most specific package entry
<span class="nc" id="L2139">            int dotIndex = className.lastIndexOf(&quot;.&quot;);</span>
<span class="nc bnc" id="L2140" title="All 2 branches missed.">            if (dotIndex &lt; 0) { // default package</span>
<span class="nc" id="L2141">                result = packageAssertionStatus.get(null);</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">                if (result != null)</span>
<span class="nc" id="L2143">                    return result.booleanValue();</span>
            }
<span class="nc bnc" id="L2145" title="All 2 branches missed.">            while(dotIndex &gt; 0) {</span>
<span class="nc" id="L2146">                className = className.substring(0, dotIndex);</span>
<span class="nc" id="L2147">                result = packageAssertionStatus.get(className);</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">                if (result != null)</span>
<span class="nc" id="L2149">                    return result.booleanValue();</span>
<span class="nc" id="L2150">                dotIndex = className.lastIndexOf(&quot;.&quot;, dotIndex-1);</span>
            }

            // Return the classloader default
<span class="nc" id="L2154">            return defaultAssertionStatus;</span>
<span class="nc" id="L2155">        }</span>
    }

    // Set up the assertions with information provided by the VM.
    // Note: Should only be called inside a synchronized block
    private void initializeJavaAssertionMaps() {
        // assert Thread.holdsLock(assertionLock);

<span class="nc" id="L2163">        classAssertionStatus = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2164">        packageAssertionStatus = new HashMap&lt;&gt;();</span>
<span class="nc" id="L2165">        AssertionStatusDirectives directives = retrieveDirectives();</span>

<span class="nc bnc" id="L2167" title="All 2 branches missed.">        for(int i = 0; i &lt; directives.classes.length; i++)</span>
<span class="nc" id="L2168">            classAssertionStatus.put(directives.classes[i],</span>
<span class="nc" id="L2169">                                     directives.classEnabled[i]);</span>

<span class="nc bnc" id="L2171" title="All 2 branches missed.">        for(int i = 0; i &lt; directives.packages.length; i++)</span>
<span class="nc" id="L2172">            packageAssertionStatus.put(directives.packages[i],</span>
<span class="nc" id="L2173">                                       directives.packageEnabled[i]);</span>

<span class="nc" id="L2175">        defaultAssertionStatus = directives.deflt;</span>
<span class="nc" id="L2176">    }</span>

    // Retrieves the assertion directives from the VM.
    private static native AssertionStatusDirectives retrieveDirectives();
}


class SystemClassLoaderAction
    implements PrivilegedExceptionAction&lt;ClassLoader&gt; {
    private ClassLoader parent;

<span class="fc" id="L2187">    SystemClassLoaderAction(ClassLoader parent) {</span>
<span class="fc" id="L2188">        this.parent = parent;</span>
<span class="fc" id="L2189">    }</span>

    public ClassLoader run() throws Exception {
<span class="fc" id="L2192">        String cls = System.getProperty(&quot;java.system.class.loader&quot;);</span>
<span class="pc bpc" id="L2193" title="1 of 2 branches missed.">        if (cls == null) {</span>
<span class="fc" id="L2194">            return parent;</span>
        }

<span class="nc" id="L2197">        Constructor&lt;?&gt; ctor = Class.forName(cls, true, parent)</span>
<span class="nc" id="L2198">            .getDeclaredConstructor(new Class&lt;?&gt;[] { ClassLoader.class });</span>
<span class="nc" id="L2199">        ClassLoader sys = (ClassLoader) ctor.newInstance(</span>
            new Object[] { parent });
<span class="nc" id="L2201">        Thread.currentThread().setContextClassLoader(sys);</span>
<span class="nc" id="L2202">        return sys;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>