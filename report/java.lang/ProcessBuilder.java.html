<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ProcessBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.lang</a> &gt; <span class="el_source">ProcessBuilder.java</span></div><h1>ProcessBuilder.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * This class is used to create operating system processes.
 *
 * &lt;p&gt;Each {@code ProcessBuilder} instance manages a collection
 * of process attributes.  The {@link #start()} method creates a new
 * {@link Process} instance with those attributes.  The {@link
 * #start()} method can be invoked repeatedly from the same instance
 * to create new subprocesses with identical or related attributes.
 *
 * &lt;p&gt;Each process builder manages these process attributes:
 *
 * &lt;ul&gt;
 *
 * &lt;li&gt;a &lt;i&gt;command&lt;/i&gt;, a list of strings which signifies the
 * external program file to be invoked and its arguments, if any.
 * Which string lists represent a valid operating system command is
 * system-dependent.  For example, it is common for each conceptual
 * argument to be an element in this list, but there are operating
 * systems where programs are expected to tokenize command line
 * strings themselves - on such a system a Java implementation might
 * require commands to contain exactly two elements.
 *
 * &lt;li&gt;an &lt;i&gt;environment&lt;/i&gt;, which is a system-dependent mapping from
 * &lt;i&gt;variables&lt;/i&gt; to &lt;i&gt;values&lt;/i&gt;.  The initial value is a copy of
 * the environment of the current process (see {@link System#getenv()}).
 *
 * &lt;li&gt;a &lt;i&gt;working directory&lt;/i&gt;.  The default value is the current
 * working directory of the current process, usually the directory
 * named by the system property {@code user.dir}.
 *
 * &lt;li&gt;&lt;a name=&quot;redirect-input&quot;&gt;a source of &lt;i&gt;standard input&lt;/i&gt;&lt;/a&gt;.
 * By default, the subprocess reads input from a pipe.  Java code
 * can access this pipe via the output stream returned by
 * {@link Process#getOutputStream()}.  However, standard input may
 * be redirected to another source using
 * {@link #redirectInput(Redirect) redirectInput}.
 * In this case, {@link Process#getOutputStream()} will return a
 * &lt;i&gt;null output stream&lt;/i&gt;, for which:
 *
 * &lt;ul&gt;
 * &lt;li&gt;the {@link OutputStream#write(int) write} methods always
 * throw {@code IOException}
 * &lt;li&gt;the {@link OutputStream#close() close} method does nothing
 * &lt;/ul&gt;
 *
 * &lt;li&gt;&lt;a name=&quot;redirect-output&quot;&gt;a destination for &lt;i&gt;standard output&lt;/i&gt;
 * and &lt;i&gt;standard error&lt;/i&gt;&lt;/a&gt;.  By default, the subprocess writes standard
 * output and standard error to pipes.  Java code can access these pipes
 * via the input streams returned by {@link Process#getInputStream()} and
 * {@link Process#getErrorStream()}.  However, standard output and
 * standard error may be redirected to other destinations using
 * {@link #redirectOutput(Redirect) redirectOutput} and
 * {@link #redirectError(Redirect) redirectError}.
 * In this case, {@link Process#getInputStream()} and/or
 * {@link Process#getErrorStream()} will return a &lt;i&gt;null input
 * stream&lt;/i&gt;, for which:
 *
 * &lt;ul&gt;
 * &lt;li&gt;the {@link InputStream#read() read} methods always return
 * {@code -1}
 * &lt;li&gt;the {@link InputStream#available() available} method always returns
 * {@code 0}
 * &lt;li&gt;the {@link InputStream#close() close} method does nothing
 * &lt;/ul&gt;
 *
 * &lt;li&gt;a &lt;i&gt;redirectErrorStream&lt;/i&gt; property.  Initially, this property
 * is {@code false}, meaning that the standard output and error
 * output of a subprocess are sent to two separate streams, which can
 * be accessed using the {@link Process#getInputStream()} and {@link
 * Process#getErrorStream()} methods.
 *
 * &lt;p&gt;If the value is set to {@code true}, then:
 *
 * &lt;ul&gt;
 * &lt;li&gt;standard error is merged with the standard output and always sent
 * to the same destination (this makes it easier to correlate error
 * messages with the corresponding output)
 * &lt;li&gt;the common destination of standard error and standard output can be
 * redirected using
 * {@link #redirectOutput(Redirect) redirectOutput}
 * &lt;li&gt;any redirection set by the
 * {@link #redirectError(Redirect) redirectError}
 * method is ignored when creating a subprocess
 * &lt;li&gt;the stream returned from {@link Process#getErrorStream()} will
 * always be a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;
 * &lt;/ul&gt;
 *
 * &lt;/ul&gt;
 *
 * &lt;p&gt;Modifying a process builder's attributes will affect processes
 * subsequently started by that object's {@link #start()} method, but
 * will never affect previously started processes or the Java process
 * itself.
 *
 * &lt;p&gt;Most error checking is performed by the {@link #start()} method.
 * It is possible to modify the state of an object so that {@link
 * #start()} will fail.  For example, setting the command attribute to
 * an empty list will not throw an exception unless {@link #start()}
 * is invoked.
 *
 * &lt;p&gt;&lt;strong&gt;Note that this class is not synchronized.&lt;/strong&gt;
 * If multiple threads access a {@code ProcessBuilder} instance
 * concurrently, and at least one of the threads modifies one of the
 * attributes structurally, it &lt;i&gt;must&lt;/i&gt; be synchronized externally.
 *
 * &lt;p&gt;Starting a new process which uses the default working directory
 * and environment is easy:
 *
 * &lt;pre&gt; {@code
 * Process p = new ProcessBuilder(&quot;myCommand&quot;, &quot;myArg&quot;).start();
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;Here is an example that starts a process with a modified working
 * directory and environment, and redirects standard output and error
 * to be appended to a log file:
 *
 * &lt;pre&gt; {@code
 * ProcessBuilder pb =
 *   new ProcessBuilder(&quot;myCommand&quot;, &quot;myArg1&quot;, &quot;myArg2&quot;);
 * Map&lt;String, String&gt; env = pb.environment();
 * env.put(&quot;VAR1&quot;, &quot;myValue&quot;);
 * env.remove(&quot;OTHERVAR&quot;);
 * env.put(&quot;VAR2&quot;, env.get(&quot;VAR1&quot;) + &quot;suffix&quot;);
 * pb.directory(new File(&quot;myDir&quot;));
 * File log = new File(&quot;log&quot;);
 * pb.redirectErrorStream(true);
 * pb.redirectOutput(Redirect.appendTo(log));
 * Process p = pb.start();
 * assert pb.redirectInput() == Redirect.PIPE;
 * assert pb.redirectOutput().file() == log;
 * assert p.getInputStream().read() == -1;
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;To start a process with an explicit set of environment
 * variables, first call {@link java.util.Map#clear() Map.clear()}
 * before adding environment variables.
 *
 * @author Martin Buchholz
 * @since 1.5
 */

<span class="fc bfc" id="L178" title="All 2 branches covered.">public final class ProcessBuilder</span>
{
    private List&lt;String&gt; command;
    private File directory;
    private Map&lt;String,String&gt; environment;
    private boolean redirectErrorStream;
    private Redirect[] redirects;

    /**
     * Constructs a process builder with the specified operating
     * system program and arguments.  This constructor does &lt;i&gt;not&lt;/i&gt;
     * make a copy of the {@code command} list.  Subsequent
     * updates to the list will be reflected in the state of the
     * process builder.  It is not checked whether
     * {@code command} corresponds to a valid operating system
     * command.
     *
     * @param  command the list containing the program and its arguments
     * @throws NullPointerException if the argument is null
     */
<span class="fc" id="L198">    public ProcessBuilder(List&lt;String&gt; command) {</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (command == null)</span>
<span class="fc" id="L200">            throw new NullPointerException();</span>
<span class="fc" id="L201">        this.command = command;</span>
<span class="fc" id="L202">    }</span>

    /**
     * Constructs a process builder with the specified operating
     * system program and arguments.  This is a convenience
     * constructor that sets the process builder's command to a string
     * list containing the same strings as the {@code command}
     * array, in the same order.  It is not checked whether
     * {@code command} corresponds to a valid operating system
     * command.
     *
     * @param command a string array containing the program and its arguments
     */
<span class="fc" id="L215">    public ProcessBuilder(String... command) {</span>
<span class="fc" id="L216">        this.command = new ArrayList&lt;&gt;(command.length);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (String arg : command)</span>
<span class="fc" id="L218">            this.command.add(arg);</span>
<span class="fc" id="L219">    }</span>

    /**
     * Sets this process builder's operating system program and
     * arguments.  This method does &lt;i&gt;not&lt;/i&gt; make a copy of the
     * {@code command} list.  Subsequent updates to the list will
     * be reflected in the state of the process builder.  It is not
     * checked whether {@code command} corresponds to a valid
     * operating system command.
     *
     * @param  command the list containing the program and its arguments
     * @return this process builder
     *
     * @throws NullPointerException if the argument is null
     */
    public ProcessBuilder command(List&lt;String&gt; command) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">        if (command == null)</span>
<span class="fc" id="L236">            throw new NullPointerException();</span>
<span class="fc" id="L237">        this.command = command;</span>
<span class="fc" id="L238">        return this;</span>
    }

    /**
     * Sets this process builder's operating system program and
     * arguments.  This is a convenience method that sets the command
     * to a string list containing the same strings as the
     * {@code command} array, in the same order.  It is not
     * checked whether {@code command} corresponds to a valid
     * operating system command.
     *
     * @param  command a string array containing the program and its arguments
     * @return this process builder
     */
    public ProcessBuilder command(String... command) {
<span class="fc" id="L253">        this.command = new ArrayList&lt;&gt;(command.length);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">        for (String arg : command)</span>
<span class="fc" id="L255">            this.command.add(arg);</span>
<span class="fc" id="L256">        return this;</span>
    }

    /**
     * Returns this process builder's operating system program and
     * arguments.  The returned list is &lt;i&gt;not&lt;/i&gt; a copy.  Subsequent
     * updates to the list will be reflected in the state of this
     * process builder.
     *
     * @return this process builder's program and its arguments
     */
    public List&lt;String&gt; command() {
<span class="fc" id="L268">        return command;</span>
    }

    /**
     * Returns a string map view of this process builder's environment.
     *
     * Whenever a process builder is created, the environment is
     * initialized to a copy of the current process environment (see
     * {@link System#getenv()}).  Subprocesses subsequently started by
     * this object's {@link #start()} method will use this map as
     * their environment.
     *
     * &lt;p&gt;The returned object may be modified using ordinary {@link
     * java.util.Map Map} operations.  These modifications will be
     * visible to subprocesses started via the {@link #start()}
     * method.  Two {@code ProcessBuilder} instances always
     * contain independent process environments, so changes to the
     * returned map will never be reflected in any other
     * {@code ProcessBuilder} instance or the values returned by
     * {@link System#getenv System.getenv}.
     *
     * &lt;p&gt;If the system does not support environment variables, an
     * empty map is returned.
     *
     * &lt;p&gt;The returned map does not permit null keys or values.
     * Attempting to insert or query the presence of a null key or
     * value will throw a {@link NullPointerException}.
     * Attempting to query the presence of a key or value which is not
     * of type {@link String} will throw a {@link ClassCastException}.
     *
     * &lt;p&gt;The behavior of the returned map is system-dependent.  A
     * system may not allow modifications to environment variables or
     * may forbid certain variable names or values.  For this reason,
     * attempts to modify the map may fail with
     * {@link UnsupportedOperationException} or
     * {@link IllegalArgumentException}
     * if the modification is not permitted by the operating system.
     *
     * &lt;p&gt;Since the external format of environment variable names and
     * values is system-dependent, there may not be a one-to-one
     * mapping between them and Java's Unicode strings.  Nevertheless,
     * the map is implemented in such a way that environment variables
     * which are not modified by Java code will have an unmodified
     * native representation in the subprocess.
     *
     * &lt;p&gt;The returned map and its collection views may not obey the
     * general contract of the {@link Object#equals} and
     * {@link Object#hashCode} methods.
     *
     * &lt;p&gt;The returned map is typically case-sensitive on all platforms.
     *
     * &lt;p&gt;If a security manager exists, its
     * {@link SecurityManager#checkPermission checkPermission} method
     * is called with a
     * {@link RuntimePermission}{@code (&quot;getenv.*&quot;)} permission.
     * This may result in a {@link SecurityException} being thrown.
     *
     * &lt;p&gt;When passing information to a Java subprocess,
     * &lt;a href=System.html#EnvironmentVSSystemProperties&gt;system properties&lt;/a&gt;
     * are generally preferred over environment variables.
     *
     * @return this process builder's environment
     *
     * @throws SecurityException
     *         if a security manager exists and its
     *         {@link SecurityManager#checkPermission checkPermission}
     *         method doesn't allow access to the process environment
     *
     * @see    Runtime#exec(String[],String[],java.io.File)
     * @see    System#getenv()
     */
    public Map&lt;String,String&gt; environment() {
<span class="fc" id="L340">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (security != null)</span>
<span class="fc" id="L342">            security.checkPermission(new RuntimePermission(&quot;getenv.*&quot;));</span>

<span class="fc bfc" id="L344" title="All 2 branches covered.">        if (environment == null)</span>
<span class="fc" id="L345">            environment = ProcessEnvironment.environment();</span>

<span class="pc bpc" id="L347" title="1 of 4 branches missed.">        assert environment != null;</span>

<span class="fc" id="L349">        return environment;</span>
    }

    // Only for use by Runtime.exec(...envp...)
    ProcessBuilder environment(String[] envp) {
<span class="pc bpc" id="L354" title="1 of 4 branches missed.">        assert environment == null;</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (envp != null) {</span>
<span class="fc" id="L356">            environment = ProcessEnvironment.emptyEnvironment(envp.length);</span>
<span class="pc bpc" id="L357" title="2 of 4 branches missed.">            assert environment != null;</span>

<span class="fc bfc" id="L359" title="All 2 branches covered.">            for (String envstring : envp) {</span>
                // Before 1.5, we blindly passed invalid envstrings
                // to the child process.
                // We would like to throw an exception, but do not,
                // for compatibility with old broken code.

                // Silently discard any trailing junk.
<span class="fc bfc" id="L366" title="All 2 branches covered.">                if (envstring.indexOf((int) '\u0000') != -1)</span>
<span class="fc" id="L367">                    envstring = envstring.replaceFirst(&quot;\u0000.*&quot;, &quot;&quot;);</span>

<span class="fc" id="L369">                int eqlsign =</span>
<span class="fc" id="L370">                    envstring.indexOf('=', ProcessEnvironment.MIN_NAME_LENGTH);</span>
                // Silently ignore envstrings lacking the required `='.
<span class="fc bfc" id="L372" title="All 2 branches covered.">                if (eqlsign != -1)</span>
<span class="fc" id="L373">                    environment.put(envstring.substring(0,eqlsign),</span>
<span class="fc" id="L374">                                    envstring.substring(eqlsign+1));</span>
            }
        }
<span class="fc" id="L377">        return this;</span>
    }

    /**
     * Returns this process builder's working directory.
     *
     * Subprocesses subsequently started by this object's {@link
     * #start()} method will use this as their working directory.
     * The returned value may be {@code null} -- this means to use
     * the working directory of the current Java process, usually the
     * directory named by the system property {@code user.dir},
     * as the working directory of the child process.
     *
     * @return this process builder's working directory
     */
    public File directory() {
<span class="fc" id="L393">        return directory;</span>
    }

    /**
     * Sets this process builder's working directory.
     *
     * Subprocesses subsequently started by this object's {@link
     * #start()} method will use this as their working directory.
     * The argument may be {@code null} -- this means to use the
     * working directory of the current Java process, usually the
     * directory named by the system property {@code user.dir},
     * as the working directory of the child process.
     *
     * @param  directory the new working directory
     * @return this process builder
     */
    public ProcessBuilder directory(File directory) {
<span class="fc" id="L410">        this.directory = directory;</span>
<span class="fc" id="L411">        return this;</span>
    }

    // ---------------- I/O Redirection ----------------

    /**
     * Implements a &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.
     */
    static class NullInputStream extends InputStream {
<span class="fc" id="L420">        static final NullInputStream INSTANCE = new NullInputStream();</span>
<span class="fc" id="L421">        private NullInputStream() {}</span>
<span class="fc" id="L422">        public int read()      { return -1; }</span>
<span class="fc" id="L423">        public int available() { return 0; }</span>
    }

    /**
     * Implements a &lt;a href=&quot;#redirect-input&quot;&gt;null output stream&lt;/a&gt;.
     */
    static class NullOutputStream extends OutputStream {
<span class="fc" id="L430">        static final NullOutputStream INSTANCE = new NullOutputStream();</span>
<span class="fc" id="L431">        private NullOutputStream() {}</span>
        public void write(int b) throws IOException {
<span class="fc" id="L433">            throw new IOException(&quot;Stream closed&quot;);</span>
        }
    }

    /**
     * Represents a source of subprocess input or a destination of
     * subprocess output.
     *
     * Each {@code Redirect} instance is one of the following:
     *
     * &lt;ul&gt;
     * &lt;li&gt;the special value {@link #PIPE Redirect.PIPE}
     * &lt;li&gt;the special value {@link #INHERIT Redirect.INHERIT}
     * &lt;li&gt;a redirection to read from a file, created by an invocation of
     *     {@link Redirect#from Redirect.from(File)}
     * &lt;li&gt;a redirection to write to a file,  created by an invocation of
     *     {@link Redirect#to Redirect.to(File)}
     * &lt;li&gt;a redirection to append to a file, created by an invocation of
     *     {@link Redirect#appendTo Redirect.appendTo(File)}
     * &lt;/ul&gt;
     *
     * &lt;p&gt;Each of the above categories has an associated unique
     * {@link Type Type}.
     *
     * @since 1.7
     */
<span class="fc bfc" id="L459" title="All 2 branches covered.">    public static abstract class Redirect {</span>
        /**
         * The type of a {@link Redirect}.
         */
<span class="pc" id="L463">        public enum Type {</span>
            /**
             * The type of {@link Redirect#PIPE Redirect.PIPE}.
             */
<span class="fc" id="L467">            PIPE,</span>

            /**
             * The type of {@link Redirect#INHERIT Redirect.INHERIT}.
             */
<span class="fc" id="L472">            INHERIT,</span>

            /**
             * The type of redirects returned from
             * {@link Redirect#from Redirect.from(File)}.
             */
<span class="fc" id="L478">            READ,</span>

            /**
             * The type of redirects returned from
             * {@link Redirect#to Redirect.to(File)}.
             */
<span class="fc" id="L484">            WRITE,</span>

            /**
             * The type of redirects returned from
             * {@link Redirect#appendTo Redirect.appendTo(File)}.
             */
<span class="fc" id="L490">            APPEND</span>
        };

        /**
         * Returns the type of this {@code Redirect}.
         * @return the type of this {@code Redirect}
         */
        public abstract Type type();

        /**
         * Indicates that subprocess I/O will be connected to the
         * current Java process over a pipe.
         *
         * This is the default handling of subprocess standard I/O.
         *
         * &lt;p&gt;It will always be true that
         *  &lt;pre&gt; {@code
         * Redirect.PIPE.file() == null &amp;&amp;
         * Redirect.PIPE.type() == Redirect.Type.PIPE
         * }&lt;/pre&gt;
         */
<span class="fc" id="L511">        public static final Redirect PIPE = new Redirect() {</span>
<span class="fc" id="L512">                public Type type() { return Type.PIPE; }</span>
<span class="fc" id="L513">                public String toString() { return type().toString(); }};</span>

        /**
         * Indicates that subprocess I/O source or destination will be the
         * same as those of the current process.  This is the normal
         * behavior of most operating system command interpreters (shells).
         *
         * &lt;p&gt;It will always be true that
         *  &lt;pre&gt; {@code
         * Redirect.INHERIT.file() == null &amp;&amp;
         * Redirect.INHERIT.type() == Redirect.Type.INHERIT
         * }&lt;/pre&gt;
         */
<span class="fc" id="L526">        public static final Redirect INHERIT = new Redirect() {</span>
<span class="fc" id="L527">                public Type type() { return Type.INHERIT; }</span>
<span class="fc" id="L528">                public String toString() { return type().toString(); }};</span>

        /**
         * Returns the {@link File} source or destination associated
         * with this redirect, or {@code null} if there is no such file.
         *
         * @return the file associated with this redirect,
         *         or {@code null} if there is no such file
         */
<span class="fc" id="L537">        public File file() { return null; }</span>

        /**
         * When redirected to a destination file, indicates if the output
         * is to be written to the end of the file.
         */
        boolean append() {
<span class="nc" id="L544">            throw new UnsupportedOperationException();</span>
        }

        /**
         * Returns a redirect to read from the specified file.
         *
         * &lt;p&gt;It will always be true that
         *  &lt;pre&gt; {@code
         * Redirect.from(file).file() == file &amp;&amp;
         * Redirect.from(file).type() == Redirect.Type.READ
         * }&lt;/pre&gt;
         *
         * @param file The {@code File} for the {@code Redirect}.
         * @throws NullPointerException if the specified file is null
         * @return a redirect to read from the specified file
         */
        public static Redirect from(final File file) {
<span class="pc bpc" id="L561" title="1 of 2 branches missed.">            if (file == null)</span>
<span class="nc" id="L562">                throw new NullPointerException();</span>
<span class="fc" id="L563">            return new Redirect() {</span>
<span class="fc" id="L564">                    public Type type() { return Type.READ; }</span>
<span class="fc" id="L565">                    public File file() { return file; }</span>
                    public String toString() {
<span class="fc" id="L567">                        return &quot;redirect to read from file \&quot;&quot; + file + &quot;\&quot;&quot;;</span>
                    }
                };
        }

        /**
         * Returns a redirect to write to the specified file.
         * If the specified file exists when the subprocess is started,
         * its previous contents will be discarded.
         *
         * &lt;p&gt;It will always be true that
         *  &lt;pre&gt; {@code
         * Redirect.to(file).file() == file &amp;&amp;
         * Redirect.to(file).type() == Redirect.Type.WRITE
         * }&lt;/pre&gt;
         *
         * @param file The {@code File} for the {@code Redirect}.
         * @throws NullPointerException if the specified file is null
         * @return a redirect to write to the specified file
         */
        public static Redirect to(final File file) {
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">            if (file == null)</span>
<span class="nc" id="L589">                throw new NullPointerException();</span>
<span class="fc" id="L590">            return new Redirect() {</span>
<span class="fc" id="L591">                    public Type type() { return Type.WRITE; }</span>
<span class="fc" id="L592">                    public File file() { return file; }</span>
                    public String toString() {
<span class="fc" id="L594">                        return &quot;redirect to write to file \&quot;&quot; + file + &quot;\&quot;&quot;;</span>
                    }
<span class="fc" id="L596">                    boolean append() { return false; }</span>
                };
        }

        /**
         * Returns a redirect to append to the specified file.
         * Each write operation first advances the position to the
         * end of the file and then writes the requested data.
         * Whether the advancement of the position and the writing
         * of the data are done in a single atomic operation is
         * system-dependent and therefore unspecified.
         *
         * &lt;p&gt;It will always be true that
         *  &lt;pre&gt; {@code
         * Redirect.appendTo(file).file() == file &amp;&amp;
         * Redirect.appendTo(file).type() == Redirect.Type.APPEND
         * }&lt;/pre&gt;
         *
         * @param file The {@code File} for the {@code Redirect}.
         * @throws NullPointerException if the specified file is null
         * @return a redirect to append to the specified file
         */
        public static Redirect appendTo(final File file) {
<span class="pc bpc" id="L619" title="1 of 2 branches missed.">            if (file == null)</span>
<span class="nc" id="L620">                throw new NullPointerException();</span>
<span class="fc" id="L621">            return new Redirect() {</span>
<span class="fc" id="L622">                    public Type type() { return Type.APPEND; }</span>
<span class="fc" id="L623">                    public File file() { return file; }</span>
                    public String toString() {
<span class="fc" id="L625">                        return &quot;redirect to append to file \&quot;&quot; + file + &quot;\&quot;&quot;;</span>
                    }
<span class="fc" id="L627">                    boolean append() { return true; }</span>
                };
        }

        /**
         * Compares the specified object with this {@code Redirect} for
         * equality.  Returns {@code true} if and only if the two
         * objects are identical or both objects are {@code Redirect}
         * instances of the same type associated with non-null equal
         * {@code File} instances.
         */
        public boolean equals(Object obj) {
<span class="fc bfc" id="L639" title="All 2 branches covered.">            if (obj == this)</span>
<span class="fc" id="L640">                return true;</span>
<span class="pc bpc" id="L641" title="1 of 2 branches missed.">            if (! (obj instanceof Redirect))</span>
<span class="nc" id="L642">                return false;</span>
<span class="fc" id="L643">            Redirect r = (Redirect) obj;</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">            if (r.type() != this.type())</span>
<span class="fc" id="L645">                return false;</span>
<span class="pc bpc" id="L646" title="2 of 4 branches missed.">            assert this.file() != null;</span>
<span class="fc" id="L647">            return this.file().equals(r.file());</span>
        }

        /**
         * Returns a hash code value for this {@code Redirect}.
         * @return a hash code value for this {@code Redirect}
         */
        public int hashCode() {
<span class="fc" id="L655">            File file = file();</span>
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">            if (file == null)</span>
<span class="nc" id="L657">                return super.hashCode();</span>
            else
<span class="fc" id="L659">                return file.hashCode();</span>
        }

        /**
         * No public constructors.  Clients must use predefined
         * static {@code Redirect} instances or factory methods.
         */
<span class="fc" id="L666">        private Redirect() {}</span>
    }

    private Redirect[] redirects() {
<span class="fc bfc" id="L670" title="All 2 branches covered.">        if (redirects == null)</span>
<span class="fc" id="L671">            redirects = new Redirect[] {</span>
                Redirect.PIPE, Redirect.PIPE, Redirect.PIPE
            };
<span class="fc" id="L674">        return redirects;</span>
    }

    /**
     * Sets this process builder's standard input source.
     *
     * Subprocesses subsequently started by this object's {@link #start()}
     * method obtain their standard input from this source.
     *
     * &lt;p&gt;If the source is {@link Redirect#PIPE Redirect.PIPE}
     * (the initial value), then the standard input of a
     * subprocess can be written to using the output stream
     * returned by {@link Process#getOutputStream()}.
     * If the source is set to any other value, then
     * {@link Process#getOutputStream()} will return a
     * &lt;a href=&quot;#redirect-input&quot;&gt;null output stream&lt;/a&gt;.
     *
     * @param  source the new standard input source
     * @return this process builder
     * @throws IllegalArgumentException
     *         if the redirect does not correspond to a valid source
     *         of data, that is, has type
     *         {@link Redirect.Type#WRITE WRITE} or
     *         {@link Redirect.Type#APPEND APPEND}
     * @since  1.7
     */
    public ProcessBuilder redirectInput(Redirect source) {
<span class="fc bfc" id="L701" title="All 2 branches covered.">        if (source.type() == Redirect.Type.WRITE ||</span>
<span class="fc bfc" id="L702" title="All 2 branches covered.">            source.type() == Redirect.Type.APPEND)</span>
<span class="fc" id="L703">            throw new IllegalArgumentException(</span>
                &quot;Redirect invalid for reading: &quot; + source);
<span class="fc" id="L705">        redirects()[0] = source;</span>
<span class="fc" id="L706">        return this;</span>
    }

    /**
     * Sets this process builder's standard output destination.
     *
     * Subprocesses subsequently started by this object's {@link #start()}
     * method send their standard output to this destination.
     *
     * &lt;p&gt;If the destination is {@link Redirect#PIPE Redirect.PIPE}
     * (the initial value), then the standard output of a subprocess
     * can be read using the input stream returned by {@link
     * Process#getInputStream()}.
     * If the destination is set to any other value, then
     * {@link Process#getInputStream()} will return a
     * &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.
     *
     * @param  destination the new standard output destination
     * @return this process builder
     * @throws IllegalArgumentException
     *         if the redirect does not correspond to a valid
     *         destination of data, that is, has type
     *         {@link Redirect.Type#READ READ}
     * @since  1.7
     */
    public ProcessBuilder redirectOutput(Redirect destination) {
<span class="fc bfc" id="L732" title="All 2 branches covered.">        if (destination.type() == Redirect.Type.READ)</span>
<span class="fc" id="L733">            throw new IllegalArgumentException(</span>
                &quot;Redirect invalid for writing: &quot; + destination);
<span class="fc" id="L735">        redirects()[1] = destination;</span>
<span class="fc" id="L736">        return this;</span>
    }

    /**
     * Sets this process builder's standard error destination.
     *
     * Subprocesses subsequently started by this object's {@link #start()}
     * method send their standard error to this destination.
     *
     * &lt;p&gt;If the destination is {@link Redirect#PIPE Redirect.PIPE}
     * (the initial value), then the error output of a subprocess
     * can be read using the input stream returned by {@link
     * Process#getErrorStream()}.
     * If the destination is set to any other value, then
     * {@link Process#getErrorStream()} will return a
     * &lt;a href=&quot;#redirect-output&quot;&gt;null input stream&lt;/a&gt;.
     *
     * &lt;p&gt;If the {@link #redirectErrorStream redirectErrorStream}
     * attribute has been set {@code true}, then the redirection set
     * by this method has no effect.
     *
     * @param  destination the new standard error destination
     * @return this process builder
     * @throws IllegalArgumentException
     *         if the redirect does not correspond to a valid
     *         destination of data, that is, has type
     *         {@link Redirect.Type#READ READ}
     * @since  1.7
     */
    public ProcessBuilder redirectError(Redirect destination) {
<span class="fc bfc" id="L766" title="All 2 branches covered.">        if (destination.type() == Redirect.Type.READ)</span>
<span class="fc" id="L767">            throw new IllegalArgumentException(</span>
                &quot;Redirect invalid for writing: &quot; + destination);
<span class="fc" id="L769">        redirects()[2] = destination;</span>
<span class="fc" id="L770">        return this;</span>
    }

    /**
     * Sets this process builder's standard input source to a file.
     *
     * &lt;p&gt;This is a convenience method.  An invocation of the form
     * {@code redirectInput(file)}
     * behaves in exactly the same way as the invocation
     * {@link #redirectInput(Redirect) redirectInput}
     * {@code (Redirect.from(file))}.
     *
     * @param  file the new standard input source
     * @return this process builder
     * @since  1.7
     */
    public ProcessBuilder redirectInput(File file) {
<span class="fc" id="L787">        return redirectInput(Redirect.from(file));</span>
    }

    /**
     * Sets this process builder's standard output destination to a file.
     *
     * &lt;p&gt;This is a convenience method.  An invocation of the form
     * {@code redirectOutput(file)}
     * behaves in exactly the same way as the invocation
     * {@link #redirectOutput(Redirect) redirectOutput}
     * {@code (Redirect.to(file))}.
     *
     * @param  file the new standard output destination
     * @return this process builder
     * @since  1.7
     */
    public ProcessBuilder redirectOutput(File file) {
<span class="fc" id="L804">        return redirectOutput(Redirect.to(file));</span>
    }

    /**
     * Sets this process builder's standard error destination to a file.
     *
     * &lt;p&gt;This is a convenience method.  An invocation of the form
     * {@code redirectError(file)}
     * behaves in exactly the same way as the invocation
     * {@link #redirectError(Redirect) redirectError}
     * {@code (Redirect.to(file))}.
     *
     * @param  file the new standard error destination
     * @return this process builder
     * @since  1.7
     */
    public ProcessBuilder redirectError(File file) {
<span class="fc" id="L821">        return redirectError(Redirect.to(file));</span>
    }

    /**
     * Returns this process builder's standard input source.
     *
     * Subprocesses subsequently started by this object's {@link #start()}
     * method obtain their standard input from this source.
     * The initial value is {@link Redirect#PIPE Redirect.PIPE}.
     *
     * @return this process builder's standard input source
     * @since  1.7
     */
    public Redirect redirectInput() {
<span class="fc bfc" id="L835" title="All 2 branches covered.">        return (redirects == null) ? Redirect.PIPE : redirects[0];</span>
    }

    /**
     * Returns this process builder's standard output destination.
     *
     * Subprocesses subsequently started by this object's {@link #start()}
     * method redirect their standard output to this destination.
     * The initial value is {@link Redirect#PIPE Redirect.PIPE}.
     *
     * @return this process builder's standard output destination
     * @since  1.7
     */
    public Redirect redirectOutput() {
<span class="fc bfc" id="L849" title="All 2 branches covered.">        return (redirects == null) ? Redirect.PIPE : redirects[1];</span>
    }

    /**
     * Returns this process builder's standard error destination.
     *
     * Subprocesses subsequently started by this object's {@link #start()}
     * method redirect their standard error to this destination.
     * The initial value is {@link Redirect#PIPE Redirect.PIPE}.
     *
     * @return this process builder's standard error destination
     * @since  1.7
     */
    public Redirect redirectError() {
<span class="fc bfc" id="L863" title="All 2 branches covered.">        return (redirects == null) ? Redirect.PIPE : redirects[2];</span>
    }

    /**
     * Sets the source and destination for subprocess standard I/O
     * to be the same as those of the current Java process.
     *
     * &lt;p&gt;This is a convenience method.  An invocation of the form
     *  &lt;pre&gt; {@code
     * pb.inheritIO()
     * }&lt;/pre&gt;
     * behaves in exactly the same way as the invocation
     *  &lt;pre&gt; {@code
     * pb.redirectInput(Redirect.INHERIT)
     *   .redirectOutput(Redirect.INHERIT)
     *   .redirectError(Redirect.INHERIT)
     * }&lt;/pre&gt;
     *
     * This gives behavior equivalent to most operating system
     * command interpreters, or the standard C library function
     * {@code system()}.
     *
     * @return this process builder
     * @since  1.7
     */
    public ProcessBuilder inheritIO() {
<span class="fc" id="L889">        Arrays.fill(redirects(), Redirect.INHERIT);</span>
<span class="fc" id="L890">        return this;</span>
    }

    /**
     * Tells whether this process builder merges standard error and
     * standard output.
     *
     * &lt;p&gt;If this property is {@code true}, then any error output
     * generated by subprocesses subsequently started by this object's
     * {@link #start()} method will be merged with the standard
     * output, so that both can be read using the
     * {@link Process#getInputStream()} method.  This makes it easier
     * to correlate error messages with the corresponding output.
     * The initial value is {@code false}.
     *
     * @return this process builder's {@code redirectErrorStream} property
     */
    public boolean redirectErrorStream() {
<span class="fc" id="L908">        return redirectErrorStream;</span>
    }

    /**
     * Sets this process builder's {@code redirectErrorStream} property.
     *
     * &lt;p&gt;If this property is {@code true}, then any error output
     * generated by subprocesses subsequently started by this object's
     * {@link #start()} method will be merged with the standard
     * output, so that both can be read using the
     * {@link Process#getInputStream()} method.  This makes it easier
     * to correlate error messages with the corresponding output.
     * The initial value is {@code false}.
     *
     * @param  redirectErrorStream the new property value
     * @return this process builder
     */
    public ProcessBuilder redirectErrorStream(boolean redirectErrorStream) {
<span class="fc" id="L926">        this.redirectErrorStream = redirectErrorStream;</span>
<span class="fc" id="L927">        return this;</span>
    }

    /**
     * Starts a new process using the attributes of this process builder.
     *
     * &lt;p&gt;The new process will
     * invoke the command and arguments given by {@link #command()},
     * in a working directory as given by {@link #directory()},
     * with a process environment as given by {@link #environment()}.
     *
     * &lt;p&gt;This method checks that the command is a valid operating
     * system command.  Which commands are valid is system-dependent,
     * but at the very least the command must be a non-empty list of
     * non-null strings.
     *
     * &lt;p&gt;A minimal set of system dependent environment variables may
     * be required to start a process on some operating systems.
     * As a result, the subprocess may inherit additional environment variable
     * settings beyond those in the process builder's {@link #environment()}.
     *
     * &lt;p&gt;If there is a security manager, its
     * {@link SecurityManager#checkExec checkExec}
     * method is called with the first component of this object's
     * {@code command} array as its argument. This may result in
     * a {@link SecurityException} being thrown.
     *
     * &lt;p&gt;Starting an operating system process is highly system-dependent.
     * Among the many things that can go wrong are:
     * &lt;ul&gt;
     * &lt;li&gt;The operating system program file was not found.
     * &lt;li&gt;Access to the program file was denied.
     * &lt;li&gt;The working directory does not exist.
     * &lt;/ul&gt;
     *
     * &lt;p&gt;In such cases an exception will be thrown.  The exact nature
     * of the exception is system-dependent, but it will always be a
     * subclass of {@link IOException}.
     *
     * &lt;p&gt;Subsequent modifications to this process builder will not
     * affect the returned {@link Process}.
     *
     * @return a new {@link Process} object for managing the subprocess
     *
     * @throws NullPointerException
     *         if an element of the command list is null
     *
     * @throws IndexOutOfBoundsException
     *         if the command is an empty list (has size {@code 0})
     *
     * @throws SecurityException
     *         if a security manager exists and
     *         &lt;ul&gt;
     *
     *         &lt;li&gt;its
     *         {@link SecurityManager#checkExec checkExec}
     *         method doesn't allow creation of the subprocess, or
     *
     *         &lt;li&gt;the standard input to the subprocess was
     *         {@linkplain #redirectInput redirected from a file}
     *         and the security manager's
     *         {@link SecurityManager#checkRead checkRead} method
     *         denies read access to the file, or
     *
     *         &lt;li&gt;the standard output or standard error of the
     *         subprocess was
     *         {@linkplain #redirectOutput redirected to a file}
     *         and the security manager's
     *         {@link SecurityManager#checkWrite checkWrite} method
     *         denies write access to the file
     *
     *         &lt;/ul&gt;
     *
     * @throws IOException if an I/O error occurs
     *
     * @see Runtime#exec(String[], String[], java.io.File)
     */
    public Process start() throws IOException {
        // Must convert to array first -- a malicious user-supplied
        // list might try to circumvent the security check.
<span class="fc" id="L1007">        String[] cmdarray = command.toArray(new String[command.size()]);</span>
<span class="fc" id="L1008">        cmdarray = cmdarray.clone();</span>

<span class="fc bfc" id="L1010" title="All 2 branches covered.">        for (String arg : cmdarray)</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">            if (arg == null)</span>
<span class="fc" id="L1012">                throw new NullPointerException();</span>
        // Throws IndexOutOfBoundsException if command is empty
<span class="fc" id="L1014">        String prog = cmdarray[0];</span>

<span class="fc" id="L1016">        SecurityManager security = System.getSecurityManager();</span>
<span class="fc bfc" id="L1017" title="All 2 branches covered.">        if (security != null)</span>
<span class="fc" id="L1018">            security.checkExec(prog);</span>

<span class="fc bfc" id="L1020" title="All 2 branches covered.">        String dir = directory == null ? null : directory.toString();</span>

        try {
<span class="fc" id="L1023">            return ProcessImpl.start(cmdarray,</span>
                                     environment,
                                     dir,
                                     redirects,
                                     redirectErrorStream);
<span class="fc" id="L1028">        } catch (IOException | IllegalArgumentException e) {</span>
<span class="fc" id="L1029">            String exceptionInfo = &quot;: &quot; + e.getMessage();</span>
<span class="fc" id="L1030">            Throwable cause = e;</span>
<span class="pc bpc" id="L1031" title="2 of 4 branches missed.">            if ((e instanceof IOException) &amp;&amp; security != null) {</span>
                // Can not disclose the fail reason for read-protected files.
                try {
<span class="nc" id="L1034">                    security.checkRead(prog);</span>
<span class="nc" id="L1035">                } catch (SecurityException se) {</span>
<span class="nc" id="L1036">                    exceptionInfo = &quot;&quot;;</span>
<span class="nc" id="L1037">                    cause = se;</span>
<span class="nc" id="L1038">                }</span>
            }
            // It's much easier for us to create a high-quality error
            // message than the low-level C code which found the problem.
<span class="fc bfc" id="L1042" title="All 2 branches covered.">            throw new IOException(</span>
                &quot;Cannot run program \&quot;&quot; + prog + &quot;\&quot;&quot;
                + (dir == null ? &quot;&quot; : &quot; (in directory \&quot;&quot; + dir + &quot;\&quot;)&quot;)
                + exceptionInfo,
                cause);
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>