<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Shutdown.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.lang</a> &gt; <span class="el_source">Shutdown.java</span></div><h1>Shutdown.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.lang;


/**
 * Package-private utility class containing data structures and logic
 * governing the virtual-machine shutdown sequence.
 *
 * @author   Mark Reinhold
 * @since    1.3
 */

<span class="nc" id="L37">class Shutdown {</span>

    /* Shutdown state */
    private static final int RUNNING = 0;
    private static final int HOOKS = 1;
    private static final int FINALIZERS = 2;
<span class="nc" id="L43">    private static int state = RUNNING;</span>

    /* Should we run all finalizers upon exit? */
<span class="nc" id="L46">    private static boolean runFinalizersOnExit = false;</span>

    // The system shutdown hooks are registered with a predefined slot.
    // The list of shutdown hooks is as follows:
    // (0) Console restore hook
    // (1) Application hooks
    // (2) DeleteOnExit hook
    private static final int MAX_SYSTEM_HOOKS = 10;
<span class="nc" id="L54">    private static final Runnable[] hooks = new Runnable[MAX_SYSTEM_HOOKS];</span>

    // the index of the currently running shutdown hook to the hooks array
<span class="nc" id="L57">    private static int currentRunningHook = 0;</span>

    /* The preceding static fields are protected by this lock */
<span class="nc" id="L60">    private static class Lock { };</span>
<span class="nc" id="L61">    private static Object lock = new Lock();</span>

    /* Lock object for the native halt method */
<span class="nc" id="L64">    private static Object haltLock = new Lock();</span>

    /* Invoked by Runtime.runFinalizersOnExit */
    static void setRunFinalizersOnExit(boolean run) {
<span class="nc" id="L68">        synchronized (lock) {</span>
<span class="nc" id="L69">            runFinalizersOnExit = run;</span>
<span class="nc" id="L70">        }</span>
<span class="nc" id="L71">    }</span>


    /**
     * Add a new shutdown hook.  Checks the shutdown state and the hook itself,
     * but does not do any security checks.
     *
     * The registerShutdownInProgress parameter should be false except
     * registering the DeleteOnExitHook since the first file may
     * be added to the delete on exit list by the application shutdown
     * hooks.
     *
     * @params slot  the slot in the shutdown hook array, whose element
     *               will be invoked in order during shutdown
     * @params registerShutdownInProgress true to allow the hook
     *               to be registered even if the shutdown is in progress.
     * @params hook  the hook to be registered
     *
     * @throw IllegalStateException
     *        if registerShutdownInProgress is false and shutdown is in progress; or
     *        if registerShutdownInProgress is true and the shutdown process
     *           already passes the given slot
     */
    static void add(int slot, boolean registerShutdownInProgress, Runnable hook) {
<span class="nc" id="L95">        synchronized (lock) {</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">            if (hooks[slot] != null)</span>
<span class="nc" id="L97">                throw new InternalError(&quot;Shutdown hook at slot &quot; + slot + &quot; already registered&quot;);</span>

<span class="nc bnc" id="L99" title="All 2 branches missed.">            if (!registerShutdownInProgress) {</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                if (state &gt; RUNNING)</span>
<span class="nc" id="L101">                    throw new IllegalStateException(&quot;Shutdown in progress&quot;);</span>
            } else {
<span class="nc bnc" id="L103" title="All 6 branches missed.">                if (state &gt; HOOKS || (state == HOOKS &amp;&amp; slot &lt;= currentRunningHook))</span>
<span class="nc" id="L104">                    throw new IllegalStateException(&quot;Shutdown in progress&quot;);</span>
            }

<span class="nc" id="L107">            hooks[slot] = hook;</span>
<span class="nc" id="L108">        }</span>
<span class="nc" id="L109">    }</span>

    /* Run all registered shutdown hooks
     */
    private static void runHooks() {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        for (int i=0; i &lt; MAX_SYSTEM_HOOKS; i++) {</span>
            try {
                Runnable hook;
<span class="nc" id="L117">                synchronized (lock) {</span>
                    // acquire the lock to make sure the hook registered during
                    // shutdown is visible here.
<span class="nc" id="L120">                    currentRunningHook = i;</span>
<span class="nc" id="L121">                    hook = hooks[i];</span>
<span class="nc" id="L122">                }</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                if (hook != null) hook.run();</span>
<span class="nc" id="L124">            } catch(Throwable t) {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">                if (t instanceof ThreadDeath) {</span>
<span class="nc" id="L126">                    ThreadDeath td = (ThreadDeath)t;</span>
<span class="nc" id="L127">                    throw td;</span>
                }
<span class="nc" id="L129">            }</span>
        }
<span class="nc" id="L131">    }</span>

    /* The halt method is synchronized on the halt lock
     * to avoid corruption of the delete-on-shutdown file list.
     * It invokes the true native halt method.
     */
    static void halt(int status) {
<span class="nc" id="L138">        synchronized (haltLock) {</span>
<span class="nc" id="L139">            halt0(status);</span>
<span class="nc" id="L140">        }</span>
<span class="nc" id="L141">    }</span>

    static native void halt0(int status);

    /* Wormhole for invoking java.lang.ref.Finalizer.runAllFinalizers */
    private static native void runAllFinalizers();


    /* The actual shutdown sequence is defined here.
     *
     * If it weren't for runFinalizersOnExit, this would be simple -- we'd just
     * run the hooks and then halt.  Instead we need to keep track of whether
     * we're running hooks or finalizers.  In the latter case a finalizer could
     * invoke exit(1) to cause immediate termination, while in the former case
     * any further invocations of exit(n), for any n, simply stall.  Note that
     * if on-exit finalizers are enabled they're run iff the shutdown is
     * initiated by an exit(0); they're never run on exit(n) for n != 0 or in
     * response to SIGINT, SIGTERM, etc.
     */
    private static void sequence() {
<span class="nc" id="L161">        synchronized (lock) {</span>
            /* Guard against the possibility of a daemon thread invoking exit
             * after DestroyJavaVM initiates the shutdown sequence
             */
<span class="nc bnc" id="L165" title="All 2 branches missed.">            if (state != HOOKS) return;</span>
<span class="nc" id="L166">        }</span>
<span class="nc" id="L167">        runHooks();</span>
        boolean rfoe;
<span class="nc" id="L169">        synchronized (lock) {</span>
<span class="nc" id="L170">            state = FINALIZERS;</span>
<span class="nc" id="L171">            rfoe = runFinalizersOnExit;</span>
<span class="nc" id="L172">        }</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (rfoe) runAllFinalizers();</span>
<span class="nc" id="L174">    }</span>


    /* Invoked by Runtime.exit, which does all the security checks.
     * Also invoked by handlers for system-provided termination events,
     * which should pass a nonzero status code.
     */
    static void exit(int status) {
<span class="nc" id="L182">        boolean runMoreFinalizers = false;</span>
<span class="nc" id="L183">        synchronized (lock) {</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            if (status != 0) runFinalizersOnExit = false;</span>
<span class="nc bnc" id="L185" title="All 4 branches missed.">            switch (state) {</span>
            case RUNNING:       /* Initiate shutdown */
<span class="nc" id="L187">                state = HOOKS;</span>
<span class="nc" id="L188">                break;</span>
            case HOOKS:         /* Stall and halt */
<span class="nc" id="L190">                break;</span>
            case FINALIZERS:
<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (status != 0) {</span>
                    /* Halt immediately on nonzero status */
<span class="nc" id="L194">                    halt(status);</span>
                } else {
                    /* Compatibility with old behavior:
                     * Run more finalizers and then halt
                     */
<span class="nc" id="L199">                    runMoreFinalizers = runFinalizersOnExit;</span>
                }
                break;
            }
<span class="nc" id="L203">        }</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (runMoreFinalizers) {</span>
<span class="nc" id="L205">            runAllFinalizers();</span>
<span class="nc" id="L206">            halt(status);</span>
        }
<span class="nc" id="L208">        synchronized (Shutdown.class) {</span>
            /* Synchronize on the class object, causing any other thread
             * that attempts to initiate shutdown to stall indefinitely
             */
<span class="nc" id="L212">            sequence();</span>
<span class="nc" id="L213">            halt(status);</span>
<span class="nc" id="L214">        }</span>
<span class="nc" id="L215">    }</span>


    /* Invoked by the JNI DestroyJavaVM procedure when the last non-daemon
     * thread has finished.  Unlike the exit method, this method does not
     * actually halt the VM.
     */
    static void shutdown() {
<span class="nc" id="L223">        synchronized (lock) {</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">            switch (state) {</span>
            case RUNNING:       /* Initiate shutdown */
<span class="nc" id="L226">                state = HOOKS;</span>
<span class="nc" id="L227">                break;</span>
            case HOOKS:         /* Stall and then return */
            case FINALIZERS:
                break;
            }
<span class="nc" id="L232">        }</span>
<span class="nc" id="L233">        synchronized (Shutdown.class) {</span>
<span class="nc" id="L234">            sequence();</span>
<span class="nc" id="L235">        }</span>
<span class="nc" id="L236">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>