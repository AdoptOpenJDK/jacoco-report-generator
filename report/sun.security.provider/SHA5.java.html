<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SHA5.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.provider</a> &gt; <span class="el_source">SHA5.java</span></div><h1>SHA5.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.security.*;
import java.math.BigInteger;

import static sun.security.provider.ByteArrayAccess.*;

/**
 * This class implements the Secure Hash Algorithm SHA-384 and SHA-512
 * developed by the National Institute of Standards and Technology along
 * with the National Security Agency.
 *
 * The two algorithms are almost identical. This file contains a base
 * class SHA5 and two nested static subclasses as the classes to be used
 * by the JCA framework.
 *
 * &lt;p&gt;It implements java.security.MessageDigestSpi, and can be used
 * through Java Cryptography Architecture (JCA), as a pluggable
 * MessageDigest implementation.
 *
 * @since       1.4.2
 * @author      Valerie Peng
 * @author      Andreas Sterbenz
 */
abstract class SHA5 extends DigestBase {

    private static final int ITERATION = 80;
    // Constants for each round/iteration
<span class="fc" id="L54">    private static final long[] ROUND_CONSTS = {</span>
        0x428A2F98D728AE22L, 0x7137449123EF65CDL, 0xB5C0FBCFEC4D3B2FL,
        0xE9B5DBA58189DBBCL, 0x3956C25BF348B538L, 0x59F111F1B605D019L,
        0x923F82A4AF194F9BL, 0xAB1C5ED5DA6D8118L, 0xD807AA98A3030242L,
        0x12835B0145706FBEL, 0x243185BE4EE4B28CL, 0x550C7DC3D5FFB4E2L,
        0x72BE5D74F27B896FL, 0x80DEB1FE3B1696B1L, 0x9BDC06A725C71235L,
        0xC19BF174CF692694L, 0xE49B69C19EF14AD2L, 0xEFBE4786384F25E3L,
        0x0FC19DC68B8CD5B5L, 0x240CA1CC77AC9C65L, 0x2DE92C6F592B0275L,
        0x4A7484AA6EA6E483L, 0x5CB0A9DCBD41FBD4L, 0x76F988DA831153B5L,
        0x983E5152EE66DFABL, 0xA831C66D2DB43210L, 0xB00327C898FB213FL,
        0xBF597FC7BEEF0EE4L, 0xC6E00BF33DA88FC2L, 0xD5A79147930AA725L,
        0x06CA6351E003826FL, 0x142929670A0E6E70L, 0x27B70A8546D22FFCL,
        0x2E1B21385C26C926L, 0x4D2C6DFC5AC42AEDL, 0x53380D139D95B3DFL,
        0x650A73548BAF63DEL, 0x766A0ABB3C77B2A8L, 0x81C2C92E47EDAEE6L,
        0x92722C851482353BL, 0xA2BFE8A14CF10364L, 0xA81A664BBC423001L,
        0xC24B8B70D0F89791L, 0xC76C51A30654BE30L, 0xD192E819D6EF5218L,
        0xD69906245565A910L, 0xF40E35855771202AL, 0x106AA07032BBD1B8L,
        0x19A4C116B8D2D0C8L, 0x1E376C085141AB53L, 0x2748774CDF8EEB99L,
        0x34B0BCB5E19B48A8L, 0x391C0CB3C5C95A63L, 0x4ED8AA4AE3418ACBL,
        0x5B9CCA4F7763E373L, 0x682E6FF3D6B2B8A3L, 0x748F82EE5DEFB2FCL,
        0x78A5636F43172F60L, 0x84C87814A1F0AB72L, 0x8CC702081A6439ECL,
        0x90BEFFFA23631E28L, 0xA4506CEBDE82BDE9L, 0xBEF9A3F7B2C67915L,
        0xC67178F2E372532BL, 0xCA273ECEEA26619CL, 0xD186B8C721C0C207L,
        0xEADA7DD6CDE0EB1EL, 0xF57D4F7FEE6ED178L, 0x06F067AA72176FBAL,
        0x0A637DC5A2C898A6L, 0x113F9804BEF90DAEL, 0x1B710B35131C471BL,
        0x28DB77F523047D84L, 0x32CAAB7B40C72493L, 0x3C9EBE0A15C9BEBCL,
        0x431D67C49C100D4CL, 0x4CC5D4BECB3E42B6L, 0x597F299CFC657E2AL,
        0x5FCB6FAB3AD6FAECL, 0x6C44198C4A475817L
    };

    // buffer used by implCompress()
    private long[] W;

    // state of this object
    private long[] state;

    // initial state value. different between SHA-384 and SHA-512
    private final long[] initialHashes;

    /**
     * Creates a new SHA object.
     */
    SHA5(String name, int digestLength, long[] initialHashes) {
<span class="fc" id="L97">        super(name, digestLength, 128);</span>
<span class="fc" id="L98">        this.initialHashes = initialHashes;</span>
<span class="fc" id="L99">        state = new long[8];</span>
<span class="fc" id="L100">        W = new long[80];</span>
<span class="fc" id="L101">        implReset();</span>
<span class="fc" id="L102">    }</span>

    final void implReset() {
<span class="fc" id="L105">        System.arraycopy(initialHashes, 0, state, 0, state.length);</span>
<span class="fc" id="L106">    }</span>

    final void implDigest(byte[] out, int ofs) {
<span class="fc" id="L109">        long bitsProcessed = bytesProcessed &lt;&lt; 3;</span>

<span class="fc" id="L111">        int index = (int)bytesProcessed &amp; 0x7f;</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        int padLen = (index &lt; 112) ? (112 - index) : (240 - index);</span>
<span class="fc" id="L113">        engineUpdate(padding, 0, padLen + 8);</span>

<span class="fc" id="L115">        i2bBig4((int)(bitsProcessed &gt;&gt;&gt; 32), buffer, 120);</span>
<span class="fc" id="L116">        i2bBig4((int)bitsProcessed, buffer, 124);</span>
<span class="fc" id="L117">        implCompress(buffer, 0);</span>

<span class="fc" id="L119">        l2bBig(state, 0, out, ofs, engineGetDigestLength());</span>
<span class="fc" id="L120">    }</span>

    /**
     * logical function ch(x,y,z) as defined in spec:
     * @return (x and y) xor ((complement x) and z)
     * @param x long
     * @param y long
     * @param z long
     */
    private static long lf_ch(long x, long y, long z) {
<span class="fc" id="L130">        return (x &amp; y) ^ ((~x) &amp; z);</span>
    }

    /**
     * logical function maj(x,y,z) as defined in spec:
     * @return (x and y) xor (x and z) xor (y and z)
     * @param x long
     * @param y long
     * @param z long
     */
    private static long lf_maj(long x, long y, long z) {
<span class="fc" id="L141">        return (x &amp; y) ^ (x &amp; z) ^ (y &amp; z);</span>
    }

    /**
     * logical function R(x,s) - right shift
     * @return x right shift for s times
     * @param x long
     * @param s int
     */
    private static long lf_R(long x, int s) {
<span class="fc" id="L151">        return (x &gt;&gt;&gt; s);</span>
    }

    /**
     * logical function S(x,s) - right rotation
     * @return x circular right shift for s times
     * @param x long
     * @param s int
     */
    private static long lf_S(long x, int s) {
<span class="fc" id="L161">        return (x &gt;&gt;&gt; s) | (x &lt;&lt; (64 - s));</span>
    }

    /**
     * logical function sigma0(x) - xor of results of right rotations
     * @return S(x,28) xor S(x,34) xor S(x,39)
     * @param x long
     */
    private static long lf_sigma0(long x) {
<span class="fc" id="L170">        return lf_S(x, 28) ^ lf_S(x, 34) ^ lf_S(x, 39);</span>
    }

    /**
     * logical function sigma1(x) - xor of results of right rotations
     * @return S(x,14) xor S(x,18) xor S(x,41)
     * @param x long
     */
    private static long lf_sigma1(long x) {
<span class="fc" id="L179">        return lf_S(x, 14) ^ lf_S(x, 18) ^ lf_S(x, 41);</span>
    }

    /**
     * logical function delta0(x) - xor of results of right shifts/rotations
     * @return long
     * @param x long
     */
    private static long lf_delta0(long x) {
<span class="fc" id="L188">        return lf_S(x, 1) ^ lf_S(x, 8) ^ lf_R(x, 7);</span>
    }

    /**
     * logical function delta1(x) - xor of results of right shifts/rotations
     * @return long
     * @param x long
     */
    private static long lf_delta1(long x) {
<span class="fc" id="L197">        return lf_S(x, 19) ^ lf_S(x, 61) ^ lf_R(x, 6);</span>
    }

    /**
     * Compute the hash for the current block.
     *
     * This is in the same vein as Peter Gutmann's algorithm listed in
     * the back of Applied Cryptography, Compact implementation of
     * &quot;old&quot; NIST Secure Hash Algorithm.
     */
    final void implCompress(byte[] buf, int ofs) {
<span class="fc" id="L208">        b2lBig128(buf, ofs, W);</span>

        // The first 16 longs are from the byte stream, compute the rest of
        // the W[]'s
<span class="fc bfc" id="L212" title="All 2 branches covered.">        for (int t = 16; t &lt; ITERATION; t++) {</span>
<span class="fc" id="L213">            W[t] = lf_delta1(W[t-2]) + W[t-7] + lf_delta0(W[t-15])</span>
                   + W[t-16];
        }

<span class="fc" id="L217">        long a = state[0];</span>
<span class="fc" id="L218">        long b = state[1];</span>
<span class="fc" id="L219">        long c = state[2];</span>
<span class="fc" id="L220">        long d = state[3];</span>
<span class="fc" id="L221">        long e = state[4];</span>
<span class="fc" id="L222">        long f = state[5];</span>
<span class="fc" id="L223">        long g = state[6];</span>
<span class="fc" id="L224">        long h = state[7];</span>

<span class="fc bfc" id="L226" title="All 2 branches covered.">        for (int i = 0; i &lt; ITERATION; i++) {</span>
<span class="fc" id="L227">            long T1 = h + lf_sigma1(e) + lf_ch(e,f,g) + ROUND_CONSTS[i] + W[i];</span>
<span class="fc" id="L228">            long T2 = lf_sigma0(a) + lf_maj(a,b,c);</span>
<span class="fc" id="L229">            h = g;</span>
<span class="fc" id="L230">            g = f;</span>
<span class="fc" id="L231">            f = e;</span>
<span class="fc" id="L232">            e = d + T1;</span>
<span class="fc" id="L233">            d = c;</span>
<span class="fc" id="L234">            c = b;</span>
<span class="fc" id="L235">            b = a;</span>
<span class="fc" id="L236">            a = T1 + T2;</span>
        }
<span class="fc" id="L238">        state[0] += a;</span>
<span class="fc" id="L239">        state[1] += b;</span>
<span class="fc" id="L240">        state[2] += c;</span>
<span class="fc" id="L241">        state[3] += d;</span>
<span class="fc" id="L242">        state[4] += e;</span>
<span class="fc" id="L243">        state[5] += f;</span>
<span class="fc" id="L244">        state[6] += g;</span>
<span class="fc" id="L245">        state[7] += h;</span>
<span class="fc" id="L246">    }</span>

    public Object clone() throws CloneNotSupportedException {
<span class="fc" id="L249">        SHA5 copy = (SHA5) super.clone();</span>
<span class="fc" id="L250">        copy.state = copy.state.clone();</span>
<span class="fc" id="L251">        copy.W = new long[80];</span>
<span class="fc" id="L252">        return copy;</span>
    }

    /**
     * SHA-512 implementation class.
     */
    public static final class SHA512 extends SHA5 {

<span class="fc" id="L260">        private static final long[] INITIAL_HASHES = {</span>
            0x6a09e667f3bcc908L, 0xbb67ae8584caa73bL,
            0x3c6ef372fe94f82bL, 0xa54ff53a5f1d36f1L,
            0x510e527fade682d1L, 0x9b05688c2b3e6c1fL,
            0x1f83d9abfb41bd6bL, 0x5be0cd19137e2179L
        };

        public SHA512() {
<span class="fc" id="L268">            super(&quot;SHA-512&quot;, 64, INITIAL_HASHES);</span>
<span class="fc" id="L269">        }</span>
    }

    /**
     * SHA-384 implementation class.
     */
    public static final class SHA384 extends SHA5 {

<span class="fc" id="L277">        private static final long[] INITIAL_HASHES = {</span>
            0xcbbb9d5dc1059ed8L, 0x629a292a367cd507L,
            0x9159015a3070dd17L, 0x152fecd8f70e5939L,
            0x67332667ffc00b31L, 0x8eb44a8768581511L,
            0xdb0c2e0d64f98fa7L, 0x47b5481dbefa4fa4L
        };

        public SHA384() {
<span class="fc" id="L285">            super(&quot;SHA-384&quot;, 48, INITIAL_HASHES);</span>
<span class="fc" id="L286">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>