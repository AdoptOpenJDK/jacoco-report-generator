<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ByteArrayAccess.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.provider</a> &gt; <span class="el_source">ByteArrayAccess.java</span></div><h1>ByteArrayAccess.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import static java.lang.Integer.reverseBytes;
import static java.lang.Long.reverseBytes;

import java.nio.ByteOrder;

import sun.misc.Unsafe;

/**
 * Optimized methods for converting between byte[] and int[]/long[], both for
 * big endian and little endian byte orders.
 *
 * Currently, it includes a default code path plus two optimized code paths.
 * One is for little endian architectures that support full speed int/long
 * access at unaligned addresses (i.e. x86/amd64). The second is for big endian
 * architectures (that only support correctly aligned access), such as SPARC.
 * These are the only platforms we currently support, but other optimized
 * variants could be added as needed.
 *
 * NOTE that because this code performs unchecked direct memory access, it
 * MUST be restricted to trusted code. It is imperative that the caller protects
 * against out of bounds memory access by performing the necessary bounds
 * checks before calling methods in this class.
 *
 * This class may also be helpful in improving the performance of the
 * crypto code in the SunJCE provider. However, for now it is only accessible by
 * the message digest implementation in the SUN provider.
 *
 * @since   1.6
 * @author  Andreas Sterbenz
 */
final class ByteArrayAccess {

<span class="nc" id="L60">    private ByteArrayAccess() {</span>
        // empty
<span class="nc" id="L62">    }</span>

<span class="fc" id="L64">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span>

    // whether to use the optimized path for little endian platforms that
    // support full speed unaligned memory access.
    private static final boolean littleEndianUnaligned;

    // whether to use the optimzied path for big endian platforms that
    // support only correctly aligned full speed memory access.
    // (Note that on SPARC unaligned memory access is possible, but it is
    // implemented using a software trap and therefore very slow)
    private static final boolean bigEndian;

<span class="fc" id="L76">    private final static int byteArrayOfs = unsafe.arrayBaseOffset(byte[].class);</span>

    static {
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        boolean scaleOK = ((unsafe.arrayIndexScale(byte[].class) == 1)</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">            &amp;&amp; (unsafe.arrayIndexScale(int[].class) == 4)</span>
<span class="pc bpc" id="L81" title="2 of 4 branches missed.">            &amp;&amp; (unsafe.arrayIndexScale(long[].class) == 8)</span>
            &amp;&amp; ((byteArrayOfs &amp; 3) == 0));

<span class="fc" id="L84">        ByteOrder byteOrder = ByteOrder.nativeOrder();</span>
<span class="pc bpc" id="L85" title="1 of 2 branches missed.">        littleEndianUnaligned =</span>
<span class="pc bpc" id="L86" title="2 of 4 branches missed.">            scaleOK &amp;&amp; unaligned() &amp;&amp; (byteOrder == ByteOrder.LITTLE_ENDIAN);</span>
<span class="pc bpc" id="L87" title="2 of 4 branches missed.">        bigEndian =</span>
            scaleOK &amp;&amp; (byteOrder == ByteOrder.BIG_ENDIAN);
<span class="fc" id="L89">    }</span>

    // Return whether this platform supports full speed int/long memory access
    // at unaligned addresses.
    // This code was copied from java.nio.Bits because there is no equivalent
    // public API.
    private static boolean unaligned() {
<span class="fc" id="L96">        String arch = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L97">            (new sun.security.action.GetPropertyAction(&quot;os.arch&quot;, &quot;&quot;));</span>
<span class="pc bpc" id="L98" title="3 of 6 branches missed.">        return arch.equals(&quot;i386&quot;) || arch.equals(&quot;x86&quot;) || arch.equals(&quot;amd64&quot;)</span>
<span class="pc bnc" id="L99" title="All 2 branches missed.">            || arch.equals(&quot;x86_64&quot;);</span>
    }

    /**
     * byte[] to int[] conversion, little endian byte order.
     */
    static void b2iLittle(byte[] in, int inOfs, int[] out, int outOfs, int len) {
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (littleEndianUnaligned) {</span>
<span class="nc" id="L107">            inOfs += byteArrayOfs;</span>
<span class="nc" id="L108">            len += inOfs;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">            while (inOfs &lt; len) {</span>
<span class="nc" id="L110">                out[outOfs++] = unsafe.getInt(in, (long)inOfs);</span>
<span class="nc" id="L111">                inOfs += 4;</span>
            }
<span class="nc bnc" id="L113" title="All 4 branches missed.">        } else if (bigEndian &amp;&amp; ((inOfs &amp; 3) == 0)) {</span>
<span class="nc" id="L114">            inOfs += byteArrayOfs;</span>
<span class="nc" id="L115">            len += inOfs;</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            while (inOfs &lt; len) {</span>
<span class="nc" id="L117">                out[outOfs++] = reverseBytes(unsafe.getInt(in, (long)inOfs));</span>
<span class="nc" id="L118">                inOfs += 4;</span>
            }
        } else {
<span class="nc" id="L121">            len += inOfs;</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">            while (inOfs &lt; len) {</span>
<span class="nc" id="L123">                out[outOfs++] = ((in[inOfs    ] &amp; 0xff)      )</span>
                              | ((in[inOfs + 1] &amp; 0xff) &lt;&lt;  8)
                              | ((in[inOfs + 2] &amp; 0xff) &lt;&lt; 16)
                              | ((in[inOfs + 3]       ) &lt;&lt; 24);
<span class="nc" id="L127">                inOfs += 4;</span>
            }
        }
<span class="nc" id="L130">    }</span>

    // Special optimization of b2iLittle(in, inOfs, out, 0, 64)
    static void b2iLittle64(byte[] in, int inOfs, int[] out) {
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if (littleEndianUnaligned) {</span>
<span class="fc" id="L135">            inOfs += byteArrayOfs;</span>
<span class="fc" id="L136">            out[ 0] = unsafe.getInt(in, (long)(inOfs     ));</span>
<span class="fc" id="L137">            out[ 1] = unsafe.getInt(in, (long)(inOfs +  4));</span>
<span class="fc" id="L138">            out[ 2] = unsafe.getInt(in, (long)(inOfs +  8));</span>
<span class="fc" id="L139">            out[ 3] = unsafe.getInt(in, (long)(inOfs + 12));</span>
<span class="fc" id="L140">            out[ 4] = unsafe.getInt(in, (long)(inOfs + 16));</span>
<span class="fc" id="L141">            out[ 5] = unsafe.getInt(in, (long)(inOfs + 20));</span>
<span class="fc" id="L142">            out[ 6] = unsafe.getInt(in, (long)(inOfs + 24));</span>
<span class="fc" id="L143">            out[ 7] = unsafe.getInt(in, (long)(inOfs + 28));</span>
<span class="fc" id="L144">            out[ 8] = unsafe.getInt(in, (long)(inOfs + 32));</span>
<span class="fc" id="L145">            out[ 9] = unsafe.getInt(in, (long)(inOfs + 36));</span>
<span class="fc" id="L146">            out[10] = unsafe.getInt(in, (long)(inOfs + 40));</span>
<span class="fc" id="L147">            out[11] = unsafe.getInt(in, (long)(inOfs + 44));</span>
<span class="fc" id="L148">            out[12] = unsafe.getInt(in, (long)(inOfs + 48));</span>
<span class="fc" id="L149">            out[13] = unsafe.getInt(in, (long)(inOfs + 52));</span>
<span class="fc" id="L150">            out[14] = unsafe.getInt(in, (long)(inOfs + 56));</span>
<span class="fc" id="L151">            out[15] = unsafe.getInt(in, (long)(inOfs + 60));</span>
<span class="nc bnc" id="L152" title="All 4 branches missed.">        } else if (bigEndian &amp;&amp; ((inOfs &amp; 3) == 0)) {</span>
<span class="nc" id="L153">            inOfs += byteArrayOfs;</span>
<span class="nc" id="L154">            out[ 0] = reverseBytes(unsafe.getInt(in, (long)(inOfs     )));</span>
<span class="nc" id="L155">            out[ 1] = reverseBytes(unsafe.getInt(in, (long)(inOfs +  4)));</span>
<span class="nc" id="L156">            out[ 2] = reverseBytes(unsafe.getInt(in, (long)(inOfs +  8)));</span>
<span class="nc" id="L157">            out[ 3] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 12)));</span>
<span class="nc" id="L158">            out[ 4] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 16)));</span>
<span class="nc" id="L159">            out[ 5] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 20)));</span>
<span class="nc" id="L160">            out[ 6] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 24)));</span>
<span class="nc" id="L161">            out[ 7] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 28)));</span>
<span class="nc" id="L162">            out[ 8] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 32)));</span>
<span class="nc" id="L163">            out[ 9] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 36)));</span>
<span class="nc" id="L164">            out[10] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 40)));</span>
<span class="nc" id="L165">            out[11] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 44)));</span>
<span class="nc" id="L166">            out[12] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 48)));</span>
<span class="nc" id="L167">            out[13] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 52)));</span>
<span class="nc" id="L168">            out[14] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 56)));</span>
<span class="nc" id="L169">            out[15] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 60)));</span>
        } else {
<span class="nc" id="L171">            b2iLittle(in, inOfs, out, 0, 64);</span>
        }
<span class="fc" id="L173">    }</span>

    /**
     * int[] to byte[] conversion, little endian byte order.
     */
    static void i2bLittle(int[] in, int inOfs, byte[] out, int outOfs, int len) {
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (littleEndianUnaligned) {</span>
<span class="fc" id="L180">            outOfs += byteArrayOfs;</span>
<span class="fc" id="L181">            len += outOfs;</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">            while (outOfs &lt; len) {</span>
<span class="fc" id="L183">                unsafe.putInt(out, (long)outOfs, in[inOfs++]);</span>
<span class="fc" id="L184">                outOfs += 4;</span>
            }
<span class="nc bnc" id="L186" title="All 4 branches missed.">        } else if (bigEndian &amp;&amp; ((outOfs &amp; 3) == 0)) {</span>
<span class="nc" id="L187">            outOfs += byteArrayOfs;</span>
<span class="nc" id="L188">            len += outOfs;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            while (outOfs &lt; len) {</span>
<span class="nc" id="L190">                unsafe.putInt(out, (long)outOfs, reverseBytes(in[inOfs++]));</span>
<span class="nc" id="L191">                outOfs += 4;</span>
            }
        } else {
<span class="nc" id="L194">            len += outOfs;</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">            while (outOfs &lt; len) {</span>
<span class="nc" id="L196">                int i = in[inOfs++];</span>
<span class="nc" id="L197">                out[outOfs++] = (byte)(i      );</span>
<span class="nc" id="L198">                out[outOfs++] = (byte)(i &gt;&gt;  8);</span>
<span class="nc" id="L199">                out[outOfs++] = (byte)(i &gt;&gt; 16);</span>
<span class="nc" id="L200">                out[outOfs++] = (byte)(i &gt;&gt; 24);</span>
<span class="nc" id="L201">            }</span>
        }
<span class="fc" id="L203">    }</span>

    // Store one 32-bit value into out[outOfs..outOfs+3] in little endian order.
    static void i2bLittle4(int val, byte[] out, int outOfs) {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        if (littleEndianUnaligned) {</span>
<span class="fc" id="L208">            unsafe.putInt(out, (long)(byteArrayOfs + outOfs), val);</span>
<span class="nc bnc" id="L209" title="All 4 branches missed.">        } else if (bigEndian &amp;&amp; ((outOfs &amp; 3) == 0)) {</span>
<span class="nc" id="L210">            unsafe.putInt(out, (long)(byteArrayOfs + outOfs), reverseBytes(val));</span>
        } else {
<span class="nc" id="L212">            out[outOfs    ] = (byte)(val      );</span>
<span class="nc" id="L213">            out[outOfs + 1] = (byte)(val &gt;&gt;  8);</span>
<span class="nc" id="L214">            out[outOfs + 2] = (byte)(val &gt;&gt; 16);</span>
<span class="nc" id="L215">            out[outOfs + 3] = (byte)(val &gt;&gt; 24);</span>
        }
<span class="fc" id="L217">    }</span>

    /**
     * byte[] to int[] conversion, big endian byte order.
     */
    static void b2iBig(byte[] in, int inOfs, int[] out, int outOfs, int len) {
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (littleEndianUnaligned) {</span>
<span class="nc" id="L224">            inOfs += byteArrayOfs;</span>
<span class="nc" id="L225">            len += inOfs;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">            while (inOfs &lt; len) {</span>
<span class="nc" id="L227">                out[outOfs++] = reverseBytes(unsafe.getInt(in, (long)inOfs));</span>
<span class="nc" id="L228">                inOfs += 4;</span>
            }
<span class="nc bnc" id="L230" title="All 4 branches missed.">        } else if (bigEndian &amp;&amp; ((inOfs &amp; 3) == 0)) {</span>
<span class="nc" id="L231">            inOfs += byteArrayOfs;</span>
<span class="nc" id="L232">            len += inOfs;</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            while (inOfs &lt; len) {</span>
<span class="nc" id="L234">                out[outOfs++] = unsafe.getInt(in, (long)inOfs);</span>
<span class="nc" id="L235">                inOfs += 4;</span>
            }
        } else {
<span class="nc" id="L238">            len += inOfs;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            while (inOfs &lt; len) {</span>
<span class="nc" id="L240">                out[outOfs++] = ((in[inOfs + 3] &amp; 0xff)      )</span>
                              | ((in[inOfs + 2] &amp; 0xff) &lt;&lt;  8)
                              | ((in[inOfs + 1] &amp; 0xff) &lt;&lt; 16)
                              | ((in[inOfs    ]       ) &lt;&lt; 24);
<span class="nc" id="L244">                inOfs += 4;</span>
            }
        }
<span class="nc" id="L247">    }</span>

    // Special optimization of b2iBig(in, inOfs, out, 0, 64)
    static void b2iBig64(byte[] in, int inOfs, int[] out) {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        if (littleEndianUnaligned) {</span>
<span class="fc" id="L252">            inOfs += byteArrayOfs;</span>
<span class="fc" id="L253">            out[ 0] = reverseBytes(unsafe.getInt(in, (long)(inOfs     )));</span>
<span class="fc" id="L254">            out[ 1] = reverseBytes(unsafe.getInt(in, (long)(inOfs +  4)));</span>
<span class="fc" id="L255">            out[ 2] = reverseBytes(unsafe.getInt(in, (long)(inOfs +  8)));</span>
<span class="fc" id="L256">            out[ 3] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 12)));</span>
<span class="fc" id="L257">            out[ 4] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 16)));</span>
<span class="fc" id="L258">            out[ 5] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 20)));</span>
<span class="fc" id="L259">            out[ 6] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 24)));</span>
<span class="fc" id="L260">            out[ 7] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 28)));</span>
<span class="fc" id="L261">            out[ 8] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 32)));</span>
<span class="fc" id="L262">            out[ 9] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 36)));</span>
<span class="fc" id="L263">            out[10] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 40)));</span>
<span class="fc" id="L264">            out[11] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 44)));</span>
<span class="fc" id="L265">            out[12] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 48)));</span>
<span class="fc" id="L266">            out[13] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 52)));</span>
<span class="fc" id="L267">            out[14] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 56)));</span>
<span class="fc" id="L268">            out[15] = reverseBytes(unsafe.getInt(in, (long)(inOfs + 60)));</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">        } else if (bigEndian &amp;&amp; ((inOfs &amp; 3) == 0)) {</span>
<span class="nc" id="L270">            inOfs += byteArrayOfs;</span>
<span class="nc" id="L271">            out[ 0] = unsafe.getInt(in, (long)(inOfs     ));</span>
<span class="nc" id="L272">            out[ 1] = unsafe.getInt(in, (long)(inOfs +  4));</span>
<span class="nc" id="L273">            out[ 2] = unsafe.getInt(in, (long)(inOfs +  8));</span>
<span class="nc" id="L274">            out[ 3] = unsafe.getInt(in, (long)(inOfs + 12));</span>
<span class="nc" id="L275">            out[ 4] = unsafe.getInt(in, (long)(inOfs + 16));</span>
<span class="nc" id="L276">            out[ 5] = unsafe.getInt(in, (long)(inOfs + 20));</span>
<span class="nc" id="L277">            out[ 6] = unsafe.getInt(in, (long)(inOfs + 24));</span>
<span class="nc" id="L278">            out[ 7] = unsafe.getInt(in, (long)(inOfs + 28));</span>
<span class="nc" id="L279">            out[ 8] = unsafe.getInt(in, (long)(inOfs + 32));</span>
<span class="nc" id="L280">            out[ 9] = unsafe.getInt(in, (long)(inOfs + 36));</span>
<span class="nc" id="L281">            out[10] = unsafe.getInt(in, (long)(inOfs + 40));</span>
<span class="nc" id="L282">            out[11] = unsafe.getInt(in, (long)(inOfs + 44));</span>
<span class="nc" id="L283">            out[12] = unsafe.getInt(in, (long)(inOfs + 48));</span>
<span class="nc" id="L284">            out[13] = unsafe.getInt(in, (long)(inOfs + 52));</span>
<span class="nc" id="L285">            out[14] = unsafe.getInt(in, (long)(inOfs + 56));</span>
<span class="nc" id="L286">            out[15] = unsafe.getInt(in, (long)(inOfs + 60));</span>
        } else {
<span class="nc" id="L288">            b2iBig(in, inOfs, out, 0, 64);</span>
        }
<span class="fc" id="L290">    }</span>

    /**
     * int[] to byte[] conversion, big endian byte order.
     */
    static void i2bBig(int[] in, int inOfs, byte[] out, int outOfs, int len) {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (littleEndianUnaligned) {</span>
<span class="fc" id="L297">            outOfs += byteArrayOfs;</span>
<span class="fc" id="L298">            len += outOfs;</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            while (outOfs &lt; len) {</span>
<span class="fc" id="L300">                unsafe.putInt(out, (long)outOfs, reverseBytes(in[inOfs++]));</span>
<span class="fc" id="L301">                outOfs += 4;</span>
            }
<span class="nc bnc" id="L303" title="All 4 branches missed.">        } else if (bigEndian &amp;&amp; ((outOfs &amp; 3) == 0)) {</span>
<span class="nc" id="L304">            outOfs += byteArrayOfs;</span>
<span class="nc" id="L305">            len += outOfs;</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            while (outOfs &lt; len) {</span>
<span class="nc" id="L307">                unsafe.putInt(out, (long)outOfs, in[inOfs++]);</span>
<span class="nc" id="L308">                outOfs += 4;</span>
            }
        } else {
<span class="nc" id="L311">            len += outOfs;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">            while (outOfs &lt; len) {</span>
<span class="nc" id="L313">                int i = in[inOfs++];</span>
<span class="nc" id="L314">                out[outOfs++] = (byte)(i &gt;&gt; 24);</span>
<span class="nc" id="L315">                out[outOfs++] = (byte)(i &gt;&gt; 16);</span>
<span class="nc" id="L316">                out[outOfs++] = (byte)(i &gt;&gt;  8);</span>
<span class="nc" id="L317">                out[outOfs++] = (byte)(i      );</span>
<span class="nc" id="L318">            }</span>
        }
<span class="fc" id="L320">    }</span>

    // Store one 32-bit value into out[outOfs..outOfs+3] in big endian order.
    static void i2bBig4(int val, byte[] out, int outOfs) {
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (littleEndianUnaligned) {</span>
<span class="fc" id="L325">            unsafe.putInt(out, (long)(byteArrayOfs + outOfs), reverseBytes(val));</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">        } else if (bigEndian &amp;&amp; ((outOfs &amp; 3) == 0)) {</span>
<span class="nc" id="L327">            unsafe.putInt(out, (long)(byteArrayOfs + outOfs), val);</span>
        } else {
<span class="nc" id="L329">            out[outOfs    ] = (byte)(val &gt;&gt; 24);</span>
<span class="nc" id="L330">            out[outOfs + 1] = (byte)(val &gt;&gt; 16);</span>
<span class="nc" id="L331">            out[outOfs + 2] = (byte)(val &gt;&gt;  8);</span>
<span class="nc" id="L332">            out[outOfs + 3] = (byte)(val      );</span>
        }
<span class="fc" id="L334">    }</span>

    /**
     * byte[] to long[] conversion, big endian byte order.
     */
    static void b2lBig(byte[] in, int inOfs, long[] out, int outOfs, int len) {
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (littleEndianUnaligned) {</span>
<span class="nc" id="L341">            inOfs += byteArrayOfs;</span>
<span class="nc" id="L342">            len += inOfs;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            while (inOfs &lt; len) {</span>
<span class="nc" id="L344">                out[outOfs++] = reverseBytes(unsafe.getLong(in, (long)inOfs));</span>
<span class="nc" id="L345">                inOfs += 8;</span>
            }
<span class="nc bnc" id="L347" title="All 4 branches missed.">        } else if (bigEndian &amp;&amp; ((inOfs &amp; 3) == 0)) {</span>
            // In the current HotSpot memory layout, the first element of a
            // byte[] is only 32-bit aligned, not 64-bit.
            // That means we could use getLong() only for offset 4, 12, etc.,
            // which would rarely occur in practice. Instead, we use an
            // optimization that uses getInt() so that it works for offset 0.
<span class="nc" id="L353">            inOfs += byteArrayOfs;</span>
<span class="nc" id="L354">            len += inOfs;</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">            while (inOfs &lt; len) {</span>
<span class="nc" id="L356">                out[outOfs++] =</span>
<span class="nc" id="L357">                      ((long)unsafe.getInt(in, (long)inOfs) &lt;&lt; 32)</span>
<span class="nc" id="L358">                          | (unsafe.getInt(in, (long)(inOfs + 4)) &amp; 0xffffffffL);</span>
<span class="nc" id="L359">                inOfs += 8;</span>
            }
        } else {
<span class="nc" id="L362">            len += inOfs;</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            while (inOfs &lt; len) {</span>
<span class="nc" id="L364">                int i1 = ((in[inOfs + 3] &amp; 0xff)      )</span>
                       | ((in[inOfs + 2] &amp; 0xff) &lt;&lt;  8)
                       | ((in[inOfs + 1] &amp; 0xff) &lt;&lt; 16)
                       | ((in[inOfs    ]       ) &lt;&lt; 24);
<span class="nc" id="L368">                inOfs += 4;</span>
<span class="nc" id="L369">                int i2 = ((in[inOfs + 3] &amp; 0xff)      )</span>
                       | ((in[inOfs + 2] &amp; 0xff) &lt;&lt;  8)
                       | ((in[inOfs + 1] &amp; 0xff) &lt;&lt; 16)
                       | ((in[inOfs    ]       ) &lt;&lt; 24);
<span class="nc" id="L373">                out[outOfs++] = ((long)i1 &lt;&lt; 32) | (i2 &amp; 0xffffffffL);</span>
<span class="nc" id="L374">                inOfs += 4;</span>
<span class="nc" id="L375">            }</span>
        }
<span class="nc" id="L377">    }</span>

    // Special optimization of b2lBig(in, inOfs, out, 0, 128)
    static void b2lBig128(byte[] in, int inOfs, long[] out) {
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (littleEndianUnaligned) {</span>
<span class="fc" id="L382">            inOfs += byteArrayOfs;</span>
<span class="fc" id="L383">            out[ 0] = reverseBytes(unsafe.getLong(in, (long)(inOfs      )));</span>
<span class="fc" id="L384">            out[ 1] = reverseBytes(unsafe.getLong(in, (long)(inOfs +   8)));</span>
<span class="fc" id="L385">            out[ 2] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  16)));</span>
<span class="fc" id="L386">            out[ 3] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  24)));</span>
<span class="fc" id="L387">            out[ 4] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  32)));</span>
<span class="fc" id="L388">            out[ 5] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  40)));</span>
<span class="fc" id="L389">            out[ 6] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  48)));</span>
<span class="fc" id="L390">            out[ 7] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  56)));</span>
<span class="fc" id="L391">            out[ 8] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  64)));</span>
<span class="fc" id="L392">            out[ 9] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  72)));</span>
<span class="fc" id="L393">            out[10] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  80)));</span>
<span class="fc" id="L394">            out[11] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  88)));</span>
<span class="fc" id="L395">            out[12] = reverseBytes(unsafe.getLong(in, (long)(inOfs +  96)));</span>
<span class="fc" id="L396">            out[13] = reverseBytes(unsafe.getLong(in, (long)(inOfs + 104)));</span>
<span class="fc" id="L397">            out[14] = reverseBytes(unsafe.getLong(in, (long)(inOfs + 112)));</span>
<span class="fc" id="L398">            out[15] = reverseBytes(unsafe.getLong(in, (long)(inOfs + 120)));</span>
        } else {
            // no optimization for big endian, see comments in b2lBig
<span class="nc" id="L401">            b2lBig(in, inOfs, out, 0, 128);</span>
        }
<span class="fc" id="L403">    }</span>

    /**
     * long[] to byte[] conversion, big endian byte order.
     */
    static void l2bBig(long[] in, int inOfs, byte[] out, int outOfs, int len) {
<span class="fc" id="L409">        len += outOfs;</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        while (outOfs &lt; len) {</span>
<span class="fc" id="L411">            long i = in[inOfs++];</span>
<span class="fc" id="L412">            out[outOfs++] = (byte)(i &gt;&gt; 56);</span>
<span class="fc" id="L413">            out[outOfs++] = (byte)(i &gt;&gt; 48);</span>
<span class="fc" id="L414">            out[outOfs++] = (byte)(i &gt;&gt; 40);</span>
<span class="fc" id="L415">            out[outOfs++] = (byte)(i &gt;&gt; 32);</span>
<span class="fc" id="L416">            out[outOfs++] = (byte)(i &gt;&gt; 24);</span>
<span class="fc" id="L417">            out[outOfs++] = (byte)(i &gt;&gt; 16);</span>
<span class="fc" id="L418">            out[outOfs++] = (byte)(i &gt;&gt;  8);</span>
<span class="fc" id="L419">            out[outOfs++] = (byte)(i      );</span>
<span class="fc" id="L420">        }</span>
<span class="fc" id="L421">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>