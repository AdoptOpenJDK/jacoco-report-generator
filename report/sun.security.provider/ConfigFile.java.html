<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConfigFile.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.provider</a> &gt; <span class="el_source">ConfigFile.java</span></div><h1>ConfigFile.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.io.*;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.security.Security;
import java.security.URIParameter;
import java.text.MessageFormat;
import java.util.*;
import javax.security.auth.AuthPermission;
import javax.security.auth.login.AppConfigurationEntry;
import javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag;
import javax.security.auth.login.Configuration;
import javax.security.auth.login.ConfigurationSpi;
import sun.security.util.Debug;
import sun.security.util.PropertyExpander;
import sun.security.util.ResourcesMgr;

/**
 * This class represents a default implementation for
 * {@code javax.security.auth.login.Configuration}.
 *
 * &lt;p&gt; This object stores the runtime login configuration representation,
 * and is the amalgamation of multiple static login configurations that
 * resides in files. The algorithm for locating the login configuration
 * file(s) and reading their information into this {@code Configuration}
 * object is:
 *
 * &lt;ol&gt;
 * &lt;li&gt;
 *   Loop through the security properties,
 *   &lt;i&gt;login.config.url.1&lt;/i&gt;, &lt;i&gt;login.config.url.2&lt;/i&gt;, ...,
 *   &lt;i&gt;login.config.url.X&lt;/i&gt;.
 *   Each property value specifies a {@code URL} pointing to a
 *   login configuration file to be loaded.  Read in and load
 *   each configuration.
 *
 * &lt;li&gt;
 *   The {@code java.lang.System} property
 *   &lt;i&gt;java.security.auth.login.config&lt;/i&gt;
 *   may also be set to a {@code URL} pointing to another
 *   login configuration file
 *   (which is the case when a user uses the -D switch at runtime).
 *   If this property is defined, and its use is allowed by the
 *   security property file (the Security property,
 *   &lt;i&gt;policy.allowSystemProperty&lt;/i&gt; is set to &lt;i&gt;true&lt;/i&gt;),
 *   also load that login configuration.
 *
 * &lt;li&gt;
 *   If the &lt;i&gt;java.security.auth.login.config&lt;/i&gt; property is defined using
 *   &quot;==&quot; (rather than &quot;=&quot;), then ignore all other specified
 *   login configurations and only load this configuration.
 *
 * &lt;li&gt;
 *   If no system or security properties were set, try to read from the file,
 *   ${user.home}/.java.login.config, where ${user.home} is the value
 *   represented by the &quot;user.home&quot; System property.
 * &lt;/ol&gt;
 *
 * &lt;p&gt; The configuration syntax supported by this implementation
 * is exactly that syntax specified in the
 * {@code javax.security.auth.login.Configuration} class.
 *
 * @see javax.security.auth.login.LoginContext
 * @see java.security.Security security properties
 */
public final class ConfigFile extends Configuration {

    private final Spi spi;

<span class="fc" id="L101">    public ConfigFile() {</span>
<span class="fc" id="L102">        spi = new Spi();</span>
<span class="fc" id="L103">    }</span>

    @Override
    public AppConfigurationEntry[] getAppConfigurationEntry(String appName) {
<span class="fc" id="L107">        return spi.engineGetAppConfigurationEntry(appName);</span>
    }

    @Override
    public synchronized void refresh() {
<span class="fc" id="L112">        spi.engineRefresh();</span>
<span class="fc" id="L113">    }</span>

    public final static class Spi extends ConfigurationSpi {

        private URL url;
<span class="pc" id="L118">        private boolean expandProp = true;</span>
        private Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; configuration;
        private int linenum;
        private StreamTokenizer st;
        private int lookahead;

<span class="fc" id="L124">        private static Debug debugConfig = Debug.getInstance(&quot;configfile&quot;);</span>
<span class="fc" id="L125">        private static Debug debugParser = Debug.getInstance(&quot;configparser&quot;);</span>

        /**
         * Creates a new {@code ConfigurationSpi} object.
         *
         * @throws SecurityException if the {@code ConfigurationSpi} can not be
         *                           initialized
         */
<span class="fc" id="L133">        public Spi() {</span>
            try {
<span class="fc" id="L135">                init();</span>
<span class="fc" id="L136">            } catch (IOException ioe) {</span>
<span class="fc" id="L137">                throw new SecurityException(ioe);</span>
<span class="fc" id="L138">            }</span>
<span class="fc" id="L139">        }</span>

        /**
         * Creates a new {@code ConfigurationSpi} object from the specified
         * {@code URI}.
         *
         * @param uri the {@code URI}
         * @throws SecurityException if the {@code ConfigurationSpi} can not be
         *                           initialized
         * @throws NullPointerException if {@code uri} is null
         */
<span class="nc" id="L150">        public Spi(URI uri) {</span>
            // only load config from the specified URI
            try {
<span class="nc" id="L153">                url = uri.toURL();</span>
<span class="nc" id="L154">                init();</span>
<span class="nc" id="L155">            } catch (IOException ioe) {</span>
<span class="nc" id="L156">                throw new SecurityException(ioe);</span>
<span class="nc" id="L157">            }</span>
<span class="nc" id="L158">        }</span>

<span class="fc" id="L160">        public Spi(final Configuration.Parameters params) throws IOException {</span>

            // call in a doPrivileged
            //
            // we have already passed the Configuration.getInstance
            // security check.  also this class is not freely accessible
            // (it is in the &quot;sun&quot; package).

            try {
<span class="fc" id="L169">                AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Void&gt;() {</span>
                    public Void run() throws IOException {
<span class="fc bfc" id="L171" title="All 2 branches covered.">                        if (params == null) {</span>
<span class="fc" id="L172">                            init();</span>
                        } else {
<span class="fc bfc" id="L174" title="All 2 branches covered.">                            if (!(params instanceof URIParameter)) {</span>
<span class="fc" id="L175">                                throw new IllegalArgumentException</span>
                                        (&quot;Unrecognized parameter: &quot; + params);
                            }
<span class="fc" id="L178">                            URIParameter uriParam = (URIParameter)params;</span>
<span class="fc" id="L179">                            url = uriParam.getURI().toURL();</span>
<span class="fc" id="L180">                            init();</span>
                        }
<span class="fc" id="L182">                        return null;</span>
                    }
                });
<span class="fc" id="L185">            } catch (PrivilegedActionException pae) {</span>
<span class="fc" id="L186">                throw (IOException)pae.getException();</span>
<span class="fc" id="L187">            }</span>

            // if init() throws some other RuntimeException,
            // let it percolate up naturally.
<span class="fc" id="L191">        }</span>

        /**
         * Read and initialize the entire login Configuration from the
         * configured URL.
         *
         * @throws IOException if the Configuration can not be initialized
         * @throws SecurityException if the caller does not have permission
         *                           to initialize the Configuration
         */
        private void init() throws IOException {

<span class="fc" id="L203">            boolean initialized = false;</span>

            // For policy.expandProperties, check if either a security or system
            // property is set to false (old code erroneously checked the system
            // prop so we must check both to preserve compatibility).
<span class="fc" id="L208">            String expand = Security.getProperty(&quot;policy.expandProperties&quot;);</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">            if (expand == null) {</span>
<span class="nc" id="L210">                expand = System.getProperty(&quot;policy.expandProperties&quot;);</span>
            }
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">            if (&quot;false&quot;.equals(expand)) {</span>
<span class="nc" id="L213">                expandProp = false;</span>
            }

            // new configuration
<span class="fc" id="L217">            Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L219" title="All 2 branches covered.">            if (url != null) {</span>
                /**
                 * If the caller specified a URI via Configuration.getInstance,
                 * we only read from that URI
                 */
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">                if (debugConfig != null) {</span>
<span class="nc" id="L225">                    debugConfig.println(&quot;reading &quot; + url);</span>
                }
<span class="fc" id="L227">                init(url, newConfig);</span>
<span class="fc" id="L228">                configuration = newConfig;</span>
<span class="fc" id="L229">                return;</span>
            }

            /**
             * Caller did not specify URI via Configuration.getInstance.
             * Read from URLs listed in the java.security properties file.
             */
<span class="fc" id="L236">            String allowSys = Security.getProperty(&quot;policy.allowSystemProperty&quot;);</span>

<span class="pc bpc" id="L238" title="1 of 2 branches missed.">            if (&quot;true&quot;.equalsIgnoreCase(allowSys)) {</span>
<span class="fc" id="L239">                String extra_config = System.getProperty</span>
<span class="fc" id="L240">                                      (&quot;java.security.auth.login.config&quot;);</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">                if (extra_config != null) {</span>
<span class="fc" id="L242">                    boolean overrideAll = false;</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">                    if (extra_config.startsWith(&quot;=&quot;)) {</span>
<span class="fc" id="L244">                        overrideAll = true;</span>
<span class="fc" id="L245">                        extra_config = extra_config.substring(1);</span>
                    }
                    try {
<span class="fc" id="L248">                        extra_config = PropertyExpander.expand(extra_config);</span>
<span class="nc" id="L249">                    } catch (PropertyExpander.ExpandException peee) {</span>
<span class="nc" id="L250">                        throw ioException(&quot;Unable.to.properly.expand.config&quot;,</span>
                                          extra_config);
<span class="fc" id="L252">                    }</span>

<span class="fc" id="L254">                    URL configURL = null;</span>
                    try {
<span class="fc" id="L256">                        configURL = new URL(extra_config);</span>
<span class="fc" id="L257">                    } catch (MalformedURLException mue) {</span>
<span class="fc" id="L258">                        File configFile = new File(extra_config);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">                        if (configFile.exists()) {</span>
<span class="fc" id="L260">                            configURL = configFile.toURI().toURL();</span>
                        } else {
<span class="fc" id="L262">                            throw ioException(</span>
                                &quot;extra.config.No.such.file.or.directory.&quot;,
                                extra_config);
                        }
<span class="fc" id="L266">                    }</span>

<span class="pc bpc" id="L268" title="1 of 2 branches missed.">                    if (debugConfig != null) {</span>
<span class="nc" id="L269">                        debugConfig.println(&quot;reading &quot;+configURL);</span>
                    }
<span class="fc" id="L271">                    init(configURL, newConfig);</span>
<span class="fc" id="L272">                    initialized = true;</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">                    if (overrideAll) {</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">                        if (debugConfig != null) {</span>
<span class="nc" id="L275">                            debugConfig.println(&quot;overriding other policies!&quot;);</span>
                        }
<span class="fc" id="L277">                        configuration = newConfig;</span>
<span class="fc" id="L278">                        return;</span>
                    }
                }
            }

<span class="fc" id="L283">            int n = 1;</span>
            String config_url;
<span class="fc" id="L285">            while ((config_url = Security.getProperty</span>
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">                                     (&quot;login.config.url.&quot;+n)) != null) {</span>
                try {
<span class="nc" id="L288">                    config_url = PropertyExpander.expand</span>
<span class="nc" id="L289">                        (config_url).replace(File.separatorChar, '/');</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                    if (debugConfig != null) {</span>
<span class="nc" id="L291">                        debugConfig.println(&quot;\tReading config: &quot; + config_url);</span>
                    }
<span class="nc" id="L293">                    init(new URL(config_url), newConfig);</span>
<span class="nc" id="L294">                    initialized = true;</span>
<span class="nc" id="L295">                } catch (PropertyExpander.ExpandException peee) {</span>
<span class="nc" id="L296">                    throw ioException(&quot;Unable.to.properly.expand.config&quot;,</span>
                                      config_url);
<span class="nc" id="L298">                }</span>
<span class="nc" id="L299">                n++;</span>
            }

<span class="pc bpc" id="L302" title="5 of 6 branches missed.">            if (initialized == false &amp;&amp; n == 1 &amp;&amp; config_url == null) {</span>

                // get the config from the user's home directory
<span class="nc bnc" id="L305" title="All 2 branches missed.">                if (debugConfig != null) {</span>
<span class="nc" id="L306">                    debugConfig.println(&quot;\tReading Policy &quot; +</span>
                                &quot;from ~/.java.login.config&quot;);
                }
<span class="nc" id="L309">                config_url = System.getProperty(&quot;user.home&quot;);</span>
<span class="nc" id="L310">                String userConfigFile = config_url + File.separatorChar +</span>
                                        &quot;.java.login.config&quot;;

                // No longer throws an exception when there's no config file
                // at all. Returns an empty Configuration instead.
<span class="nc bnc" id="L315" title="All 2 branches missed.">                if (new File(userConfigFile).exists()) {</span>
<span class="nc" id="L316">                    init(new File(userConfigFile).toURI().toURL(), newConfig);</span>
                }
            }

<span class="fc" id="L320">            configuration = newConfig;</span>
<span class="fc" id="L321">        }</span>

        private void init(URL config,
                          Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig)
                          throws IOException {

<span class="fc" id="L327">            try (InputStreamReader isr</span>
<span class="fc" id="L328">                    = new InputStreamReader(getInputStream(config), &quot;UTF-8&quot;)) {</span>
<span class="fc" id="L329">                readConfig(isr, newConfig);</span>
<span class="pc bpc" id="L330" title="4 of 8 branches missed.">            } catch (FileNotFoundException fnfe) {</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">                if (debugConfig != null) {</span>
<span class="nc" id="L332">                    debugConfig.println(fnfe.toString());</span>
                }
<span class="fc" id="L334">                throw new IOException(ResourcesMgr.getString</span>
<span class="fc" id="L335">                    (&quot;Configuration.Error.No.such.file.or.directory&quot;,</span>
                    &quot;sun.security.util.AuthResources&quot;));
<span class="fc" id="L337">            }</span>
<span class="fc" id="L338">        }</span>

        /**
         * Retrieve an entry from the Configuration using an application name
         * as an index.
         *
         * @param applicationName the name used to index the Configuration.
         * @return an array of AppConfigurationEntries which correspond to
         *         the stacked configuration of LoginModules for this
         *         application, or null if this application has no configured
         *         LoginModules.
         */
        @Override
        public AppConfigurationEntry[] engineGetAppConfigurationEntry
            (String applicationName) {

<span class="fc" id="L354">            List&lt;AppConfigurationEntry&gt; list = null;</span>
<span class="fc" id="L355">            synchronized (configuration) {</span>
<span class="fc" id="L356">                list = configuration.get(applicationName);</span>
<span class="pc" id="L357">            }</span>

<span class="pc bpc" id="L359" title="1 of 4 branches missed.">            if (list == null || list.size() == 0) {</span>
<span class="fc" id="L360">                return null;</span>
            }

<span class="fc" id="L363">            AppConfigurationEntry[] entries =</span>
<span class="fc" id="L364">                                    new AppConfigurationEntry[list.size()];</span>
<span class="fc" id="L365">            Iterator&lt;AppConfigurationEntry&gt; iterator = list.iterator();</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">            for (int i = 0; iterator.hasNext(); i++) {</span>
<span class="fc" id="L367">                AppConfigurationEntry e = iterator.next();</span>
<span class="fc" id="L368">                entries[i] = new AppConfigurationEntry(e.getLoginModuleName(),</span>
<span class="fc" id="L369">                                                       e.getControlFlag(),</span>
<span class="fc" id="L370">                                                       e.getOptions());</span>
            }
<span class="fc" id="L372">            return entries;</span>
        }

        /**
         * Refresh and reload the Configuration by re-reading all of the
         * login configurations.
         *
         * @throws SecurityException if the caller does not have permission
         *                           to refresh the Configuration.
         */
        @Override
        public synchronized void engineRefresh() {

<span class="fc" id="L385">            SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">            if (sm != null) {</span>
<span class="nc" id="L387">                sm.checkPermission(</span>
                    new AuthPermission(&quot;refreshLoginConfiguration&quot;));
            }

<span class="fc" id="L391">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
                    try {
<span class="fc" id="L394">                        init();</span>
<span class="nc" id="L395">                    } catch (IOException ioe) {</span>
<span class="nc" id="L396">                        throw new SecurityException(ioe.getLocalizedMessage(),</span>
                                                    ioe);
<span class="fc" id="L398">                    }</span>
<span class="fc" id="L399">                    return null;</span>
                }
            });
<span class="fc" id="L402">        }</span>

        private void readConfig(Reader reader,
            Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig)
            throws IOException {

<span class="fc" id="L408">            linenum = 1;</span>

<span class="pc bpc" id="L410" title="1 of 2 branches missed.">            if (!(reader instanceof BufferedReader)) {</span>
<span class="fc" id="L411">                reader = new BufferedReader(reader);</span>
            }

<span class="fc" id="L414">            st = new StreamTokenizer(reader);</span>
<span class="fc" id="L415">            st.quoteChar('&quot;');</span>
<span class="fc" id="L416">            st.wordChars('$', '$');</span>
<span class="fc" id="L417">            st.wordChars('_', '_');</span>
<span class="fc" id="L418">            st.wordChars('-', '-');</span>
<span class="fc" id="L419">            st.wordChars('*', '*');</span>
<span class="fc" id="L420">            st.lowerCaseMode(false);</span>
<span class="fc" id="L421">            st.slashSlashComments(true);</span>
<span class="fc" id="L422">            st.slashStarComments(true);</span>
<span class="fc" id="L423">            st.eolIsSignificant(true);</span>

<span class="fc" id="L425">            lookahead = nextToken();</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">            while (lookahead != StreamTokenizer.TT_EOF) {</span>
<span class="fc" id="L427">                parseLoginEntry(newConfig);</span>
            }
<span class="fc" id="L429">        }</span>

        private void parseLoginEntry(
            Map&lt;String, List&lt;AppConfigurationEntry&gt;&gt; newConfig)
            throws IOException {

<span class="fc" id="L435">            List&lt;AppConfigurationEntry&gt; configEntries = new LinkedList&lt;&gt;();</span>

            // application name
<span class="fc" id="L438">            String appName = st.sval;</span>
<span class="fc" id="L439">            lookahead = nextToken();</span>

<span class="pc bpc" id="L441" title="1 of 2 branches missed.">            if (debugParser != null) {</span>
<span class="nc" id="L442">                debugParser.println(&quot;\tReading next config entry: &quot; + appName);</span>
            }

<span class="fc" id="L445">            match(&quot;{&quot;);</span>

            // get the modules
<span class="fc bfc" id="L448" title="All 2 branches covered.">            while (peek(&quot;}&quot;) == false) {</span>
                // get the module class name
<span class="fc" id="L450">                String moduleClass = match(&quot;module class name&quot;);</span>

                // controlFlag (required, optional, etc)
                LoginModuleControlFlag controlFlag;
<span class="fc" id="L454">                String sflag = match(&quot;controlFlag&quot;).toUpperCase();</span>
<span class="pc bpc" id="L455" title="9 of 18 branches missed.">                switch (sflag) {</span>
                    case &quot;REQUIRED&quot;:
<span class="fc" id="L457">                        controlFlag = LoginModuleControlFlag.REQUIRED;</span>
<span class="fc" id="L458">                        break;</span>
                    case &quot;REQUISITE&quot;:
<span class="nc" id="L460">                        controlFlag = LoginModuleControlFlag.REQUISITE;</span>
<span class="nc" id="L461">                        break;</span>
                    case &quot;SUFFICIENT&quot;:
<span class="fc" id="L463">                        controlFlag = LoginModuleControlFlag.SUFFICIENT;</span>
<span class="fc" id="L464">                        break;</span>
                    case &quot;OPTIONAL&quot;:
<span class="fc" id="L466">                        controlFlag = LoginModuleControlFlag.OPTIONAL;</span>
<span class="fc" id="L467">                        break;</span>
                    default:
<span class="nc" id="L469">                        throw ioException(</span>
                            &quot;Configuration.Error.Invalid.control.flag.flag&quot;,
                            sflag);
                }

                // get the args
<span class="fc" id="L475">                Map&lt;String, String&gt; options = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">                while (peek(&quot;;&quot;) == false) {</span>
<span class="fc" id="L477">                    String key = match(&quot;option key&quot;);</span>
<span class="fc" id="L478">                    match(&quot;=&quot;);</span>
                    try {
<span class="fc" id="L480">                        options.put(key, expand(match(&quot;option value&quot;)));</span>
<span class="nc" id="L481">                    } catch (PropertyExpander.ExpandException peee) {</span>
<span class="nc" id="L482">                        throw new IOException(peee.getLocalizedMessage());</span>
<span class="fc" id="L483">                    }</span>
<span class="fc" id="L484">                }</span>

<span class="fc" id="L486">                lookahead = nextToken();</span>

                // create the new element
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                if (debugParser != null) {</span>
<span class="nc" id="L490">                    debugParser.println(&quot;\t\t&quot; + moduleClass + &quot;, &quot; + sflag);</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                    for (String key : options.keySet()) {</span>
<span class="nc" id="L492">                        debugParser.println(&quot;\t\t\t&quot; + key +</span>
<span class="nc" id="L493">                                            &quot;=&quot; + options.get(key));</span>
<span class="nc" id="L494">                    }</span>
                }
<span class="fc" id="L496">                configEntries.add(new AppConfigurationEntry(moduleClass,</span>
                                                            controlFlag,
                                                            options));
<span class="fc" id="L499">            }</span>

<span class="fc" id="L501">            match(&quot;}&quot;);</span>
<span class="fc" id="L502">            match(&quot;;&quot;);</span>

            // add this configuration entry
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">            if (newConfig.containsKey(appName)) {</span>
<span class="nc" id="L506">                throw ioException(</span>
                    &quot;Configuration.Error.Can.not.specify.multiple.entries.for.appName&quot;,
                    appName);
            }
<span class="fc" id="L510">            newConfig.put(appName, configEntries);</span>
<span class="fc" id="L511">        }</span>

        private String match(String expect) throws IOException {

<span class="fc" id="L515">            String value = null;</span>

<span class="pc bpc" id="L517" title="2 of 7 branches missed.">            switch(lookahead) {</span>
            case StreamTokenizer.TT_EOF:
<span class="nc" id="L519">                throw ioException(</span>
                    &quot;Configuration.Error.expected.expect.read.end.of.file.&quot;,
                    expect);

            case '&quot;':
            case StreamTokenizer.TT_WORD:
<span class="fc bfc" id="L525" title="All 2 branches covered.">                if (expect.equalsIgnoreCase(&quot;module class name&quot;) ||</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">                    expect.equalsIgnoreCase(&quot;controlFlag&quot;) ||</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                    expect.equalsIgnoreCase(&quot;option key&quot;) ||</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">                    expect.equalsIgnoreCase(&quot;option value&quot;)) {</span>
<span class="fc" id="L529">                    value = st.sval;</span>
<span class="fc" id="L530">                    lookahead = nextToken();</span>
                } else {
<span class="fc" id="L532">                    throw ioException(</span>
                        &quot;Configuration.Error.Line.line.expected.expect.found.value.&quot;,
                        new Integer(linenum), expect, st.sval);
                }
                break;

            case '{':
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">                if (expect.equalsIgnoreCase(&quot;{&quot;)) {</span>
<span class="fc" id="L540">                    lookahead = nextToken();</span>
                } else {
<span class="nc" id="L542">                    throw ioException(</span>
                        &quot;Configuration.Error.Line.line.expected.expect.&quot;,
                        new Integer(linenum), expect, st.sval);
                }
                break;

            case ';':
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">                if (expect.equalsIgnoreCase(&quot;;&quot;)) {</span>
<span class="fc" id="L550">                    lookahead = nextToken();</span>
                } else {
<span class="nc" id="L552">                    throw ioException(</span>
                        &quot;Configuration.Error.Line.line.expected.expect.&quot;,
                        new Integer(linenum), expect, st.sval);
                }
                break;

            case '}':
<span class="pc bpc" id="L559" title="1 of 2 branches missed.">                if (expect.equalsIgnoreCase(&quot;}&quot;)) {</span>
<span class="fc" id="L560">                    lookahead = nextToken();</span>
                } else {
<span class="nc" id="L562">                    throw ioException(</span>
                        &quot;Configuration.Error.Line.line.expected.expect.&quot;,
                        new Integer(linenum), expect, st.sval);
                }
                break;

            case '=':
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">                if (expect.equalsIgnoreCase(&quot;=&quot;)) {</span>
<span class="fc" id="L570">                    lookahead = nextToken();</span>
                } else {
<span class="nc" id="L572">                    throw ioException(</span>
                        &quot;Configuration.Error.Line.line.expected.expect.&quot;,
                        new Integer(linenum), expect, st.sval);
                }
                break;

            default:
<span class="nc" id="L579">                throw ioException(</span>
                    &quot;Configuration.Error.Line.line.expected.expect.found.value.&quot;,
                    new Integer(linenum), expect, st.sval);
            }
<span class="fc" id="L583">            return value;</span>
        }

        private boolean peek(String expect) {
<span class="pc bpc" id="L587" title="2 of 5 branches missed.">            switch (lookahead) {</span>
                case ',':
<span class="nc" id="L589">                    return expect.equalsIgnoreCase(&quot;,&quot;);</span>
                case ';':
<span class="fc" id="L591">                    return expect.equalsIgnoreCase(&quot;;&quot;);</span>
                case '{':
<span class="nc" id="L593">                    return expect.equalsIgnoreCase(&quot;{&quot;);</span>
                case '}':
<span class="fc" id="L595">                    return expect.equalsIgnoreCase(&quot;}&quot;);</span>
                default:
<span class="fc" id="L597">                    return false;</span>
            }
        }

        private int nextToken() throws IOException {
            int tok;
<span class="fc bfc" id="L603" title="All 2 branches covered.">            while ((tok = st.nextToken()) == StreamTokenizer.TT_EOL) {</span>
<span class="fc" id="L604">                linenum++;</span>
            }
<span class="fc" id="L606">            return tok;</span>
        }

        private InputStream getInputStream(URL url) throws IOException {
<span class="pc bpc" id="L610" title="1 of 2 branches missed.">            if (&quot;file&quot;.equalsIgnoreCase(url.getProtocol())) {</span>
                // Compatibility notes:
                //
                // Code changed from
                //   String path = url.getFile().replace('/', File.separatorChar);
                //   return new FileInputStream(path);
                //
                // The original implementation would search for &quot;/tmp/a%20b&quot;
                // when url is &quot;file:///tmp/a%20b&quot;. This is incorrect. The
                // current codes fix this bug and searches for &quot;/tmp/a b&quot;.
                // For compatibility reasons, when the file &quot;/tmp/a b&quot; does
                // not exist, the file named &quot;/tmp/a%20b&quot; will be tried.
                //
                // This also means that if both file exists, the behavior of
                // this method is changed, and the current codes choose the
                // correct one.
                try {
<span class="fc" id="L627">                    return url.openStream();</span>
<span class="fc" id="L628">                } catch (Exception e) {</span>
<span class="fc" id="L629">                    String file = url.getPath();</span>
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">                    if (url.getHost().length() &gt; 0) {  // For Windows UNC</span>
<span class="nc" id="L631">                        file = &quot;//&quot; + url.getHost() + file;</span>
                    }
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">                    if (debugConfig != null) {</span>
<span class="nc" id="L634">                        debugConfig.println(&quot;cannot read &quot; + url +</span>
                                            &quot;, try &quot; + file);
                    }
<span class="nc" id="L637">                    return new FileInputStream(file);</span>
                }
            } else {
<span class="nc" id="L640">                return url.openStream();</span>
            }
        }

        private String expand(String value)
            throws PropertyExpander.ExpandException, IOException {

<span class="fc bfc" id="L647" title="All 2 branches covered.">            if (value.isEmpty()) {</span>
<span class="fc" id="L648">                return value;</span>
            }

<span class="pc bpc" id="L651" title="1 of 2 branches missed.">            if (!expandProp) {</span>
<span class="nc" id="L652">                return value;</span>
            }
<span class="fc" id="L654">            String s = PropertyExpander.expand(value);</span>
<span class="pc bpc" id="L655" title="2 of 4 branches missed.">            if (s == null || s.length() == 0) {</span>
<span class="nc" id="L656">                throw ioException(</span>
                    &quot;Configuration.Error.Line.line.system.property.value.expanded.to.empty.value&quot;,
                    new Integer(linenum), value);
            }
<span class="fc" id="L660">            return s;</span>
        }

        private IOException ioException(String resourceKey, Object... args) {
<span class="fc" id="L664">            MessageFormat form = new MessageFormat(ResourcesMgr.getString</span>
<span class="fc" id="L665">                (resourceKey, &quot;sun.security.util.AuthResources&quot;));</span>
<span class="fc" id="L666">            return new IOException(form.format(args));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>