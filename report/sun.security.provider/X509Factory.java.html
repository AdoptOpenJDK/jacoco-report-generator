<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>X509Factory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.provider</a> &gt; <span class="el_source">X509Factory.java</span></div><h1>X509Factory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.io.*;
import java.util.*;
import java.security.cert.*;
import sun.security.x509.X509CertImpl;
import sun.security.x509.X509CRLImpl;
import sun.security.pkcs.PKCS7;
import sun.security.provider.certpath.X509CertPath;
import sun.security.provider.certpath.X509CertificatePair;
import sun.security.util.DerValue;
import sun.security.util.Cache;
import java.util.Base64;
import sun.security.pkcs.ParsingException;

/**
 * This class defines a certificate factory for X.509 v3 certificates &amp;
 * certification paths, and X.509 v2 certificate revocation lists (CRLs).
 *
 * @author Jan Luehe
 * @author Hemma Prafullchandra
 * @author Sean Mullan
 *
 *
 * @see java.security.cert.CertificateFactorySpi
 * @see java.security.cert.Certificate
 * @see java.security.cert.CertPath
 * @see java.security.cert.CRL
 * @see java.security.cert.X509Certificate
 * @see java.security.cert.X509CRL
 * @see sun.security.x509.X509CertImpl
 * @see sun.security.x509.X509CRLImpl
 */

<span class="fc" id="L60">public class X509Factory extends CertificateFactorySpi {</span>

    public static final String BEGIN_CERT = &quot;-----BEGIN CERTIFICATE-----&quot;;
    public static final String END_CERT = &quot;-----END CERTIFICATE-----&quot;;

    private static final int ENC_MAX_LENGTH = 4096 * 1024; // 4 MB MAX

<span class="fc" id="L67">    private static final Cache&lt;Object, X509CertImpl&gt; certCache</span>
<span class="fc" id="L68">        = Cache.newSoftMemoryCache(750);</span>
<span class="fc" id="L69">    private static final Cache&lt;Object, X509CRLImpl&gt; crlCache</span>
<span class="fc" id="L70">        = Cache.newSoftMemoryCache(750);</span>

    /**
     * Generates an X.509 certificate object and initializes it with
     * the data read from the input stream &lt;code&gt;is&lt;/code&gt;.
     *
     * @param is an input stream with the certificate data.
     *
     * @return an X.509 certificate object initialized with the data
     * from the input stream.
     *
     * @exception CertificateException on parsing errors.
     */
    public Certificate engineGenerateCertificate(InputStream is)
        throws CertificateException
    {
<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (is == null) {</span>
            // clear the caches (for debugging)
<span class="fc" id="L88">            certCache.clear();</span>
<span class="fc" id="L89">            X509CertificatePair.clearCache();</span>
<span class="fc" id="L90">            throw new CertificateException(&quot;Missing input stream&quot;);</span>
        }
        try {
<span class="fc" id="L93">            byte[] encoding = readOneBlock(is);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">            if (encoding != null) {</span>
<span class="fc" id="L95">                X509CertImpl cert = getFromCache(certCache, encoding);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">                if (cert != null) {</span>
<span class="fc" id="L97">                    return cert;</span>
                }
<span class="fc" id="L99">                cert = new X509CertImpl(encoding);</span>
<span class="fc" id="L100">                addToCache(certCache, cert.getEncodedInternal(), cert);</span>
<span class="fc" id="L101">                return cert;</span>
            } else {
<span class="fc" id="L103">                throw new IOException(&quot;Empty input&quot;);</span>
            }
<span class="fc" id="L105">        } catch (IOException ioe) {</span>
<span class="fc" id="L106">            throw (CertificateException)new CertificateException</span>
<span class="fc" id="L107">            (&quot;Could not parse certificate: &quot; + ioe.toString()).initCause(ioe);</span>
        }
    }

    /**
     * Read from the stream until length bytes have been read or EOF has
     * been reached. Return the number of bytes actually read.
     */
    private static int readFully(InputStream in, ByteArrayOutputStream bout,
            int length) throws IOException {
<span class="fc" id="L117">        int read = 0;</span>
<span class="fc" id="L118">        byte[] buffer = new byte[2048];</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">        while (length &gt; 0) {</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">            int n = in.read(buffer, 0, length&lt;2048?length:2048);</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">            if (n &lt;= 0) {</span>
<span class="nc" id="L122">                break;</span>
            }
<span class="fc" id="L124">            bout.write(buffer, 0, n);</span>
<span class="fc" id="L125">            read += n;</span>
<span class="fc" id="L126">            length -= n;</span>
<span class="fc" id="L127">        }</span>
<span class="fc" id="L128">        return read;</span>
    }

    /**
     * Return an interned X509CertImpl for the given certificate.
     * If the given X509Certificate or X509CertImpl is already present
     * in the cert cache, the cached object is returned. Otherwise,
     * if it is a X509Certificate, it is first converted to a X509CertImpl.
     * Then the X509CertImpl is added to the cache and returned.
     *
     * Note that all certificates created via generateCertificate(InputStream)
     * are already interned and this method does not need to be called.
     * It is useful for certificates that cannot be created via
     * generateCertificate() and for converting other X509Certificate
     * implementations to an X509CertImpl.
     */
    public static synchronized X509CertImpl intern(X509Certificate c)
            throws CertificateException {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L147">            return null;</span>
        }
<span class="nc" id="L149">        boolean isImpl = c instanceof X509CertImpl;</span>
        byte[] encoding;
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (isImpl) {</span>
<span class="nc" id="L152">            encoding = ((X509CertImpl)c).getEncodedInternal();</span>
        } else {
<span class="nc" id="L154">            encoding = c.getEncoded();</span>
        }
<span class="nc" id="L156">        X509CertImpl newC = getFromCache(certCache, encoding);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (newC != null) {</span>
<span class="nc" id="L158">            return newC;</span>
        }
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (isImpl) {</span>
<span class="nc" id="L161">            newC = (X509CertImpl)c;</span>
        } else {
<span class="nc" id="L163">            newC = new X509CertImpl(encoding);</span>
<span class="nc" id="L164">            encoding = newC.getEncodedInternal();</span>
        }
<span class="nc" id="L166">        addToCache(certCache, encoding, newC);</span>
<span class="nc" id="L167">        return newC;</span>
    }

    /**
     * Return an interned X509CRLImpl for the given certificate.
     * For more information, see intern(X509Certificate).
     */
    public static synchronized X509CRLImpl intern(X509CRL c)
            throws CRLException {
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L177">            return null;</span>
        }
<span class="nc" id="L179">        boolean isImpl = c instanceof X509CRLImpl;</span>
        byte[] encoding;
<span class="nc bnc" id="L181" title="All 2 branches missed.">        if (isImpl) {</span>
<span class="nc" id="L182">            encoding = ((X509CRLImpl)c).getEncodedInternal();</span>
        } else {
<span class="nc" id="L184">            encoding = c.getEncoded();</span>
        }
<span class="nc" id="L186">        X509CRLImpl newC = getFromCache(crlCache, encoding);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (newC != null) {</span>
<span class="nc" id="L188">            return newC;</span>
        }
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (isImpl) {</span>
<span class="nc" id="L191">            newC = (X509CRLImpl)c;</span>
        } else {
<span class="nc" id="L193">            newC = new X509CRLImpl(encoding);</span>
<span class="nc" id="L194">            encoding = newC.getEncodedInternal();</span>
        }
<span class="nc" id="L196">        addToCache(crlCache, encoding, newC);</span>
<span class="nc" id="L197">        return newC;</span>
    }

    /**
     * Get the X509CertImpl or X509CRLImpl from the cache.
     */
    private static synchronized &lt;K,V&gt; V getFromCache(Cache&lt;K,V&gt; cache,
            byte[] encoding) {
<span class="fc" id="L205">        Object key = new Cache.EqualByteArray(encoding);</span>
<span class="fc" id="L206">        return cache.get(key);</span>
    }

    /**
     * Add the X509CertImpl or X509CRLImpl to the cache.
     */
    private static synchronized &lt;V&gt; void addToCache(Cache&lt;Object, V&gt; cache,
            byte[] encoding, V value) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (encoding.length &gt; ENC_MAX_LENGTH) {</span>
<span class="fc" id="L215">            return;</span>
        }
<span class="fc" id="L217">        Object key = new Cache.EqualByteArray(encoding);</span>
<span class="fc" id="L218">        cache.put(key, value);</span>
<span class="fc" id="L219">    }</span>

    /**
     * Generates a &lt;code&gt;CertPath&lt;/code&gt; object and initializes it with
     * the data read from the &lt;code&gt;InputStream&lt;/code&gt; inStream. The data
     * is assumed to be in the default encoding.
     *
     * @param inStream an &lt;code&gt;InputStream&lt;/code&gt; containing the data
     * @return a &lt;code&gt;CertPath&lt;/code&gt; initialized with the data from the
     *   &lt;code&gt;InputStream&lt;/code&gt;
     * @exception CertificateException if an exception occurs while decoding
     * @since 1.4
     */
    public CertPath engineGenerateCertPath(InputStream inStream)
        throws CertificateException
    {
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (inStream == null) {</span>
<span class="nc" id="L236">            throw new CertificateException(&quot;Missing input stream&quot;);</span>
        }
        try {
<span class="nc" id="L239">            byte[] encoding = readOneBlock(inStream);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (encoding != null) {</span>
<span class="nc" id="L241">                return new X509CertPath(new ByteArrayInputStream(encoding));</span>
            } else {
<span class="nc" id="L243">                throw new IOException(&quot;Empty input&quot;);</span>
            }
<span class="nc" id="L245">        } catch (IOException ioe) {</span>
<span class="nc" id="L246">            throw new CertificateException(ioe.getMessage());</span>
        }
    }

    /**
     * Generates a &lt;code&gt;CertPath&lt;/code&gt; object and initializes it with
     * the data read from the &lt;code&gt;InputStream&lt;/code&gt; inStream. The data
     * is assumed to be in the specified encoding.
     *
     * @param inStream an &lt;code&gt;InputStream&lt;/code&gt; containing the data
     * @param encoding the encoding used for the data
     * @return a &lt;code&gt;CertPath&lt;/code&gt; initialized with the data from the
     *   &lt;code&gt;InputStream&lt;/code&gt;
     * @exception CertificateException if an exception occurs while decoding or
     *   the encoding requested is not supported
     * @since 1.4
     */
    public CertPath engineGenerateCertPath(InputStream inStream,
        String encoding) throws CertificateException
    {
<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (inStream == null) {</span>
<span class="nc" id="L267">            throw new CertificateException(&quot;Missing input stream&quot;);</span>
        }
        try {
<span class="nc" id="L270">            byte[] data = readOneBlock(inStream);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">            if (data != null) {</span>
<span class="nc" id="L272">                return new X509CertPath(new ByteArrayInputStream(data), encoding);</span>
            } else {
<span class="nc" id="L274">                throw new IOException(&quot;Empty input&quot;);</span>
            }
<span class="nc" id="L276">        } catch (IOException ioe) {</span>
<span class="nc" id="L277">            throw new CertificateException(ioe.getMessage());</span>
        }
    }

    /**
     * Generates a &lt;code&gt;CertPath&lt;/code&gt; object and initializes it with
     * a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Certificate&lt;/code&gt;s.
     * &lt;p&gt;
     * The certificates supplied must be of a type supported by the
     * &lt;code&gt;CertificateFactory&lt;/code&gt;. They will be copied out of the supplied
     * &lt;code&gt;List&lt;/code&gt; object.
     *
     * @param certificates a &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;Certificate&lt;/code&gt;s
     * @return a &lt;code&gt;CertPath&lt;/code&gt; initialized with the supplied list of
     *   certificates
     * @exception CertificateException if an exception occurs
     * @since 1.4
     */
    public CertPath
        engineGenerateCertPath(List&lt;? extends Certificate&gt; certificates)
        throws CertificateException
    {
<span class="fc" id="L299">        return(new X509CertPath(certificates));</span>
    }

    /**
     * Returns an iteration of the &lt;code&gt;CertPath&lt;/code&gt; encodings supported
     * by this certificate factory, with the default encoding first.
     * &lt;p&gt;
     * Attempts to modify the returned &lt;code&gt;Iterator&lt;/code&gt; via its
     * &lt;code&gt;remove&lt;/code&gt; method result in an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; over the names of the supported
     *         &lt;code&gt;CertPath&lt;/code&gt; encodings (as &lt;code&gt;String&lt;/code&gt;s)
     * @since 1.4
     */
    public Iterator&lt;String&gt; engineGetCertPathEncodings() {
<span class="nc" id="L315">        return(X509CertPath.getEncodingsStatic());</span>
    }

    /**
     * Returns a (possibly empty) collection view of X.509 certificates read
     * from the given input stream &lt;code&gt;is&lt;/code&gt;.
     *
     * @param is the input stream with the certificates.
     *
     * @return a (possibly empty) collection view of X.509 certificate objects
     * initialized with the data from the input stream.
     *
     * @exception CertificateException on parsing errors.
     */
    public Collection&lt;? extends java.security.cert.Certificate&gt;
            engineGenerateCertificates(InputStream is)
            throws CertificateException {
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if (is == null) {</span>
<span class="nc" id="L333">            throw new CertificateException(&quot;Missing input stream&quot;);</span>
        }
        try {
<span class="fc" id="L336">            return parseX509orPKCS7Cert(is);</span>
<span class="fc" id="L337">        } catch (IOException ioe) {</span>
<span class="fc" id="L338">            throw new CertificateException(ioe);</span>
        }
    }

    /**
     * Generates an X.509 certificate revocation list (CRL) object and
     * initializes it with the data read from the given input stream
     * &lt;code&gt;is&lt;/code&gt;.
     *
     * @param is an input stream with the CRL data.
     *
     * @return an X.509 CRL object initialized with the data
     * from the input stream.
     *
     * @exception CRLException on parsing errors.
     */
    public CRL engineGenerateCRL(InputStream is)
        throws CRLException
    {
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">        if (is == null) {</span>
            // clear the cache (for debugging)
<span class="nc" id="L359">            crlCache.clear();</span>
<span class="nc" id="L360">            throw new CRLException(&quot;Missing input stream&quot;);</span>
        }
        try {
<span class="fc" id="L363">            byte[] encoding = readOneBlock(is);</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">            if (encoding != null) {</span>
<span class="fc" id="L365">                X509CRLImpl crl = getFromCache(crlCache, encoding);</span>
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">                if (crl != null) {</span>
<span class="nc" id="L367">                    return crl;</span>
                }
<span class="fc" id="L369">                crl = new X509CRLImpl(encoding);</span>
<span class="fc" id="L370">                addToCache(crlCache, crl.getEncodedInternal(), crl);</span>
<span class="fc" id="L371">                return crl;</span>
            } else {
<span class="nc" id="L373">                throw new IOException(&quot;Empty input&quot;);</span>
            }
<span class="nc" id="L375">        } catch (IOException ioe) {</span>
<span class="nc" id="L376">            throw new CRLException(ioe.getMessage());</span>
        }
    }

    /**
     * Returns a (possibly empty) collection view of X.509 CRLs read
     * from the given input stream &lt;code&gt;is&lt;/code&gt;.
     *
     * @param is the input stream with the CRLs.
     *
     * @return a (possibly empty) collection view of X.509 CRL objects
     * initialized with the data from the input stream.
     *
     * @exception CRLException on parsing errors.
     */
    public Collection&lt;? extends java.security.cert.CRL&gt; engineGenerateCRLs(
            InputStream is) throws CRLException
    {
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">        if (is == null) {</span>
<span class="nc" id="L395">            throw new CRLException(&quot;Missing input stream&quot;);</span>
        }
        try {
<span class="fc" id="L398">            return parseX509orPKCS7CRL(is);</span>
<span class="nc" id="L399">        } catch (IOException ioe) {</span>
<span class="nc" id="L400">            throw new CRLException(ioe.getMessage());</span>
        }
    }

    /*
     * Parses the data in the given input stream as a sequence of DER
     * encoded X.509 certificates (in binary or base 64 encoded format) OR
     * as a single PKCS#7 encoded blob (in binary or base64 encoded format).
     */
    private Collection&lt;? extends java.security.cert.Certificate&gt;
        parseX509orPKCS7Cert(InputStream is)
        throws CertificateException, IOException
    {
<span class="fc" id="L413">        Collection&lt;X509CertImpl&gt; coll = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L414">        byte[] data = readOneBlock(is);</span>
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">        if (data == null) {</span>
<span class="nc" id="L416">            return new ArrayList&lt;&gt;(0);</span>
        }
        try {
<span class="nc" id="L419">            PKCS7 pkcs7 = new PKCS7(data);</span>
<span class="nc" id="L420">            X509Certificate[] certs = pkcs7.getCertificates();</span>
            // certs are optional in PKCS #7
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (certs != null) {</span>
<span class="nc" id="L423">                return Arrays.asList(certs);</span>
            } else {
                // no crls provided
<span class="nc" id="L426">                return new ArrayList&lt;&gt;(0);</span>
            }
<span class="fc" id="L428">        } catch (ParsingException e) {</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">            while (data != null) {</span>
<span class="fc" id="L430">                coll.add(new X509CertImpl(data));</span>
<span class="fc" id="L431">                data = readOneBlock(is);</span>
            }
        }
<span class="fc" id="L434">        return coll;</span>
    }

    /*
     * Parses the data in the given input stream as a sequence of DER encoded
     * X.509 CRLs (in binary or base 64 encoded format) OR as a single PKCS#7
     * encoded blob (in binary or base 64 encoded format).
     */
    private Collection&lt;? extends java.security.cert.CRL&gt;
        parseX509orPKCS7CRL(InputStream is)
        throws CRLException, IOException
    {
<span class="fc" id="L446">        Collection&lt;X509CRLImpl&gt; coll = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L447">        byte[] data = readOneBlock(is);</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if (data == null) {</span>
<span class="nc" id="L449">            return new ArrayList&lt;&gt;(0);</span>
        }
        try {
<span class="nc" id="L452">            PKCS7 pkcs7 = new PKCS7(data);</span>
<span class="nc" id="L453">            X509CRL[] crls = pkcs7.getCRLs();</span>
            // CRLs are optional in PKCS #7
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (crls != null) {</span>
<span class="nc" id="L456">                return Arrays.asList(crls);</span>
            } else {
                // no crls provided
<span class="nc" id="L459">                return new ArrayList&lt;&gt;(0);</span>
            }
<span class="fc" id="L461">        } catch (ParsingException e) {</span>
<span class="fc bfc" id="L462" title="All 2 branches covered.">            while (data != null) {</span>
<span class="fc" id="L463">                coll.add(new X509CRLImpl(data));</span>
<span class="fc" id="L464">                data = readOneBlock(is);</span>
            }
        }
<span class="fc" id="L467">        return coll;</span>
    }

    /**
     * Returns an ASN.1 SEQUENCE from a stream, which might be a BER-encoded
     * binary block or a PEM-style BASE64-encoded ASCII data. In the latter
     * case, it's de-BASE64'ed before return.
     *
     * After the reading, the input stream pointer is after the BER block, or
     * after the newline character after the -----END SOMETHING----- line.
     *
     * @param is the InputStream
     * @returns byte block or null if end of stream
     * @throws IOException If any parsing error
     */
    private static byte[] readOneBlock(InputStream is) throws IOException {

        // The first character of a BLOCK.
<span class="fc" id="L485">        int c = is.read();</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">        if (c == -1) {</span>
<span class="fc" id="L487">            return null;</span>
        }
<span class="fc bfc" id="L489" title="All 2 branches covered.">        if (c == DerValue.tag_Sequence) {</span>
<span class="fc" id="L490">            ByteArrayOutputStream bout = new ByteArrayOutputStream(2048);</span>
<span class="fc" id="L491">            bout.write(c);</span>
<span class="fc" id="L492">            readBERInternal(is, bout, c);</span>
<span class="fc" id="L493">            return bout.toByteArray();</span>
        } else {
            // Read BASE64 encoded data, might skip info at the beginning
<span class="fc" id="L496">            char[] data = new char[2048];</span>
<span class="fc" id="L497">            int pos = 0;</span>

            // Step 1: Read until header is found
<span class="fc bfc" id="L500" title="All 2 branches covered.">            int hyphen = (c=='-') ? 1: 0;   // count of consequent hyphens</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">            int last = (c=='-') ? -1: c;    // the char before hyphen</span>
            while (true) {
<span class="fc" id="L503">                int next = is.read();</span>
<span class="fc bfc" id="L504" title="All 2 branches covered.">                if (next == -1) {</span>
                    // We accept useless data after the last block,
                    // say, empty lines.
<span class="fc" id="L507">                    return null;</span>
                }
<span class="fc bfc" id="L509" title="All 2 branches covered.">                if (next == '-') {</span>
<span class="fc" id="L510">                    hyphen++;</span>
                } else {
<span class="fc" id="L512">                    hyphen = 0;</span>
<span class="fc" id="L513">                    last = next;</span>
                }
<span class="pc bpc" id="L515" title="5 of 8 branches missed.">                if (hyphen == 5 &amp;&amp; (last == -1 || last == '\r' || last == '\n')) {</span>
<span class="nc" id="L516">                    break;</span>
                }
<span class="fc" id="L518">            }</span>

            // Step 2: Read the rest of header, determine the line end
            int end;
<span class="fc" id="L522">            StringBuffer header = new StringBuffer(&quot;-----&quot;);</span>
            while (true) {
<span class="fc" id="L524">                int next = is.read();</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                if (next == -1) {</span>
<span class="nc" id="L526">                    throw new IOException(&quot;Incomplete data&quot;);</span>
                }
<span class="fc bfc" id="L528" title="All 2 branches covered.">                if (next == '\n') {</span>
<span class="fc" id="L529">                    end = '\n';</span>
<span class="fc" id="L530">                    break;</span>
                }
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">                if (next == '\r') {</span>
<span class="nc" id="L533">                    next = is.read();</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">                    if (next == -1) {</span>
<span class="nc" id="L535">                        throw new IOException(&quot;Incomplete data&quot;);</span>
                    }
<span class="nc bnc" id="L537" title="All 2 branches missed.">                    if (next == '\n') {</span>
<span class="nc" id="L538">                        end = '\n';</span>
                    } else {
<span class="nc" id="L540">                        end = '\r';</span>
<span class="nc" id="L541">                        data[pos++] = (char)next;</span>
                    }
<span class="nc" id="L543">                    break;</span>
                }
<span class="fc" id="L545">                header.append((char)next);</span>
<span class="fc" id="L546">            }</span>

            // Step 3: Read the data
            while (true) {
<span class="fc" id="L550">                int next = is.read();</span>
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                if (next == -1) {</span>
<span class="nc" id="L552">                    throw new IOException(&quot;Incomplete data&quot;);</span>
                }
<span class="fc bfc" id="L554" title="All 2 branches covered.">                if (next != '-') {</span>
<span class="fc" id="L555">                    data[pos++] = (char)next;</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">                    if (pos &gt;= data.length) {</span>
<span class="fc" id="L557">                        data = Arrays.copyOf(data, data.length+1024);</span>
                    }
                } else {
                    break;
                }
<span class="fc" id="L562">            }</span>

            // Step 4: Consume the footer
<span class="fc" id="L565">            StringBuffer footer = new StringBuffer(&quot;-&quot;);</span>
            while (true) {
<span class="fc" id="L567">                int next = is.read();</span>
                // Add next == '\n' for maximum safety, in case endline
                // is not consistent.
<span class="pc bpc" id="L570" title="1 of 6 branches missed.">                if (next == -1 || next == end || next == '\n') {</span>
<span class="nc" id="L571">                    break;</span>
                }
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">                if (next != '\r') footer.append((char)next);</span>
<span class="fc" id="L574">            }</span>

<span class="fc" id="L576">            checkHeaderJDKter(header.toString(), footer.toString());</span>

<span class="fc" id="L578">            return Base64.getMimeDecoder().decode(new String(data, 0, pos));</span>
        }
    }

    private static void checkHeaderJDKter(String header,
            String footer) throws IOException {
<span class="pc bpc" id="L584" title="2 of 4 branches missed.">        if (header.length() &lt; 16 || !header.startsWith(&quot;-----BEGIN &quot;) ||</span>
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">                !header.endsWith(&quot;-----&quot;)) {</span>
<span class="nc" id="L586">            throw new IOException(&quot;Illegal header: &quot; + header);</span>
        }
<span class="pc bpc" id="L588" title="1 of 4 branches missed.">        if (footer.length() &lt; 14 || !footer.startsWith(&quot;-----END &quot;) ||</span>
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">                !footer.endsWith(&quot;-----&quot;)) {</span>
<span class="fc" id="L590">            throw new IOException(&quot;Illegal footer: &quot; + footer);</span>
        }
<span class="fc" id="L592">        String headerType = header.substring(11, header.length()-5);</span>
<span class="fc" id="L593">        String footerType = footer.substring(9, footer.length()-5);</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">        if (!headerType.equals(footerType)) {</span>
<span class="nc" id="L595">            throw new IOException(&quot;Header and footer do not match: &quot; +</span>
                    header + &quot; &quot; + footer);
        }
<span class="fc" id="L598">    }</span>

    /**
     * Read one BER data block. This method is aware of indefinite-length BER
     * encoding and will read all of the sub-sections in a recursive way
     *
     * @param is    Read from this InputStream
     * @param bout  Write into this OutputStream
     * @param tag   Tag already read (-1 mean not read)
     * @returns     The current tag, used to check EOC in indefinite-length BER
     * @throws IOException Any parsing error
     */
    private static int readBERInternal(InputStream is,
            ByteArrayOutputStream bout, int tag) throws IOException {

<span class="pc bpc" id="L613" title="1 of 2 branches missed.">        if (tag == -1) {        // Not read before the call, read now</span>
<span class="nc" id="L614">            tag = is.read();</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (tag == -1) {</span>
<span class="nc" id="L616">                throw new IOException(&quot;BER/DER tag info absent&quot;);</span>
            }
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if ((tag &amp; 0x1f) == 0x1f) {</span>
<span class="nc" id="L619">                throw new IOException(&quot;Multi octets tag not supported&quot;);</span>
            }
<span class="nc" id="L621">            bout.write(tag);</span>
        }

<span class="fc" id="L624">        int n = is.read();</span>
<span class="pc bpc" id="L625" title="1 of 2 branches missed.">        if (n == -1) {</span>
<span class="nc" id="L626">            throw new IOException(&quot;BER/DER length info ansent&quot;);</span>
        }
<span class="fc" id="L628">        bout.write(n);</span>

        int length;

<span class="pc bpc" id="L632" title="1 of 2 branches missed.">        if (n == 0x80) {        // Indefinite-length encoding</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">            if ((tag &amp; 0x20) != 0x20) {</span>
<span class="nc" id="L634">                throw new IOException(</span>
                        &quot;Non constructed encoding must have definite length&quot;);
            }
            while (true) {
<span class="nc" id="L638">                int subTag = readBERInternal(is, bout, -1);</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">                if (subTag == 0) {   // EOC, end of indefinite-length section</span>
<span class="nc" id="L640">                    break;</span>
                }
<span class="nc" id="L642">            }</span>
        } else {
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">            if (n &lt; 0x80) {</span>
<span class="nc" id="L645">                length = n;</span>
<span class="pc bpc" id="L646" title="1 of 2 branches missed.">            } else if (n == 0x81) {</span>
<span class="nc" id="L647">                length = is.read();</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">                if (length == -1) {</span>
<span class="nc" id="L649">                    throw new IOException(&quot;Incomplete BER/DER length info&quot;);</span>
                }
<span class="nc" id="L651">                bout.write(length);</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">            } else if (n == 0x82) {</span>
<span class="fc" id="L653">                int highByte = is.read();</span>
<span class="fc" id="L654">                int lowByte = is.read();</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">                if (lowByte == -1) {</span>
<span class="nc" id="L656">                    throw new IOException(&quot;Incomplete BER/DER length info&quot;);</span>
                }
<span class="fc" id="L658">                bout.write(highByte);</span>
<span class="fc" id="L659">                bout.write(lowByte);</span>
<span class="fc" id="L660">                length = (highByte &lt;&lt; 8) | lowByte;</span>
<span class="pc bpc" id="L661" title="1 of 2 branches missed.">            } else if (n == 0x83) {</span>
<span class="nc" id="L662">                int highByte = is.read();</span>
<span class="nc" id="L663">                int midByte = is.read();</span>
<span class="nc" id="L664">                int lowByte = is.read();</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">                if (lowByte == -1) {</span>
<span class="nc" id="L666">                    throw new IOException(&quot;Incomplete BER/DER length info&quot;);</span>
                }
<span class="nc" id="L668">                bout.write(highByte);</span>
<span class="nc" id="L669">                bout.write(midByte);</span>
<span class="nc" id="L670">                bout.write(lowByte);</span>
<span class="nc" id="L671">                length = (highByte &lt;&lt; 16) | (midByte &lt;&lt; 8) | lowByte;</span>
<span class="pc bpc" id="L672" title="1 of 2 branches missed.">            } else if (n == 0x84) {</span>
<span class="fc" id="L673">                int highByte = is.read();</span>
<span class="fc" id="L674">                int nextByte = is.read();</span>
<span class="fc" id="L675">                int midByte = is.read();</span>
<span class="fc" id="L676">                int lowByte = is.read();</span>
<span class="pc bpc" id="L677" title="1 of 2 branches missed.">                if (lowByte == -1) {</span>
<span class="nc" id="L678">                    throw new IOException(&quot;Incomplete BER/DER length info&quot;);</span>
                }
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">                if (highByte &gt; 127) {</span>
<span class="nc" id="L681">                    throw new IOException(&quot;Invalid BER/DER data (a little huge?)&quot;);</span>
                }
<span class="fc" id="L683">                bout.write(highByte);</span>
<span class="fc" id="L684">                bout.write(nextByte);</span>
<span class="fc" id="L685">                bout.write(midByte);</span>
<span class="fc" id="L686">                bout.write(lowByte);</span>
<span class="fc" id="L687">                length = (highByte &lt;&lt; 24 ) | (nextByte &lt;&lt; 16) |</span>
                        (midByte &lt;&lt; 8) | lowByte;
<span class="fc" id="L689">            } else { // ignore longer length forms</span>
<span class="nc" id="L690">                throw new IOException(&quot;Invalid BER/DER data (too huge?)&quot;);</span>
            }
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">            if (readFully(is, bout, length) != length) {</span>
<span class="nc" id="L693">                throw new IOException(&quot;Incomplete BER/DER data&quot;);</span>
            }
        }
<span class="fc" id="L696">        return tag;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>