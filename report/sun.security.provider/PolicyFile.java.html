<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PolicyFile.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.provider</a> &gt; <span class="el_source">PolicyFile.java</span></div><h1>PolicyFile.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.io.*;
import java.lang.reflect.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URI;
import java.util.*;
import java.text.MessageFormat;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import javax.security.auth.Subject;
import javax.security.auth.x500.X500Principal;
import java.io.FilePermission;
import java.net.SocketPermission;
import java.net.NetPermission;
import java.util.concurrent.atomic.AtomicReference;
import sun.misc.JavaSecurityProtectionDomainAccess;
import static sun.misc.JavaSecurityProtectionDomainAccess.ProtectionDomainCache;
import sun.misc.SharedSecrets;
import sun.security.util.PolicyUtil;
import sun.security.util.PropertyExpander;
import sun.security.util.Debug;
import sun.security.util.ResourcesMgr;
import sun.security.util.SecurityConstants;
import sun.net.www.ParseUtil;

/**
 * This class represents a default implementation for
 * &lt;code&gt;java.security.Policy&lt;/code&gt;.
 *
 * Note:
 * For backward compatibility with JAAS 1.0 it loads
 * both java.auth.policy and java.policy. However it
 * is recommended that java.auth.policy be not used
 * and the java.policy contain all grant entries including
 * that contain principal-based entries.
 *
 *
 * &lt;p&gt; This object stores the policy for entire Java runtime,
 * and is the amalgamation of multiple static policy
 * configurations that resides in files.
 * The algorithm for locating the policy file(s) and reading their
 * information into this &lt;code&gt;Policy&lt;/code&gt; object is:
 *
 * &lt;ol&gt;
 * &lt;li&gt;
 *   Loop through the &lt;code&gt;java.security.Security&lt;/code&gt; properties,
 *   &lt;i&gt;policy.url.1&lt;/i&gt;, &lt;i&gt;policy.url.2&lt;/i&gt;, ...,
 *   &lt;i&gt;policy.url.X&lt;/i&gt;&quot; and
 *   &lt;i&gt;auth.policy.url.1&lt;/i&gt;, &lt;i&gt;auth.policy.url.2&lt;/i&gt;, ...,
 *   &lt;i&gt;auth.policy.url.X&lt;/i&gt;&quot;.  These properties are set
 *   in the Java security properties file, which is located in the file named
 *   &amp;lt;JAVA_HOME&amp;gt;/lib/security/java.security.
 *   &amp;lt;JAVA_HOME&amp;gt; refers to the value of the java.home system property,
 *   and specifies the directory where the JRE is installed.
 *   Each property value specifies a &lt;code&gt;URL&lt;/code&gt; pointing to a
 *   policy file to be loaded.  Read in and load each policy.
 *
 *   &lt;i&gt;auth.policy.url&lt;/i&gt; is supported only for backward compatibility.
 *
 * &lt;li&gt;
 *   The &lt;code&gt;java.lang.System&lt;/code&gt; property &lt;i&gt;java.security.policy&lt;/i&gt;
 *   may also be set to a &lt;code&gt;URL&lt;/code&gt; pointing to another policy file
 *   (which is the case when a user uses the -D switch at runtime).
 *   If this property is defined, and its use is allowed by the
 *   security property file (the Security property,
 *   &lt;i&gt;policy.allowSystemProperty&lt;/i&gt; is set to &lt;i&gt;true&lt;/i&gt;),
 *   also load that policy.
 *
 * &lt;li&gt;
 *   The &lt;code&gt;java.lang.System&lt;/code&gt; property
 *   &lt;i&gt;java.security.auth.policy&lt;/i&gt; may also be set to a
 *   &lt;code&gt;URL&lt;/code&gt; pointing to another policy file
 *   (which is the case when a user uses the -D switch at runtime).
 *   If this property is defined, and its use is allowed by the
 *   security property file (the Security property,
 *   &lt;i&gt;policy.allowSystemProperty&lt;/i&gt; is set to &lt;i&gt;true&lt;/i&gt;),
 *   also load that policy.
 *
 *   &lt;i&gt;java.security.auth.policy&lt;/i&gt; is supported only for backward
 *   compatibility.
 *
 *   If the  &lt;i&gt;java.security.policy&lt;/i&gt; or
 *   &lt;i&gt;java.security.auth.policy&lt;/i&gt; property is defined using
 *   &quot;==&quot; (rather than &quot;=&quot;), then ignore all other specified
 *   policies and only load this policy.
 * &lt;/ol&gt;
 *
 * Each policy file consists of one or more grant entries, each of
 * which consists of a number of permission entries.
 *
 * &lt;pre&gt;
 *   grant signedBy &quot;&lt;b&gt;alias&lt;/b&gt;&quot;, codeBase &quot;&lt;b&gt;URL&lt;/b&gt;&quot;,
 *         principal &lt;b&gt;principalClass&lt;/b&gt; &quot;&lt;b&gt;principalName&lt;/b&gt;&quot;,
 *         principal &lt;b&gt;principalClass&lt;/b&gt; &quot;&lt;b&gt;principalName&lt;/b&gt;&quot;,
 *         ... {
 *
 *     permission &lt;b&gt;Type&lt;/b&gt; &quot;&lt;b&gt;name&lt;/b&gt; &quot;&lt;b&gt;action&lt;/b&gt;&quot;,
 *         signedBy &quot;&lt;b&gt;alias&lt;/b&gt;&quot;;
 *     permission &lt;b&gt;Type&lt;/b&gt; &quot;&lt;b&gt;name&lt;/b&gt; &quot;&lt;b&gt;action&lt;/b&gt;&quot;,
 *         signedBy &quot;&lt;b&gt;alias&lt;/b&gt;&quot;;
 *     ....
 *   };
 * &lt;/pre&gt;
 *
 * All non-bold items above must appear as is (although case
 * doesn't matter and some are optional, as noted below).
 * principal entries are optional and need not be present.
 * Italicized items represent variable values.
 *
 * &lt;p&gt; A grant entry must begin with the word &lt;code&gt;grant&lt;/code&gt;.
 * The &lt;code&gt;signedBy&lt;/code&gt;,&lt;code&gt;codeBase&lt;/code&gt; and &lt;code&gt;principal&lt;/code&gt;
 * name/value pairs are optional.
 * If they are not present, then any signer (including unsigned code)
 * will match, and any codeBase will match.
 * Note that the &lt;i&gt;principalClass&lt;/i&gt;
 * may be set to the wildcard value, *, which allows it to match
 * any &lt;code&gt;Principal&lt;/code&gt; class.  In addition, the &lt;i&gt;principalName&lt;/i&gt;
 * may also be set to the wildcard value, *, allowing it to match
 * any &lt;code&gt;Principal&lt;/code&gt; name.  When setting the &lt;i&gt;principalName&lt;/i&gt;
 * to the *, do not surround the * with quotes.
 *
 * &lt;p&gt; A permission entry must begin with the word &lt;code&gt;permission&lt;/code&gt;.
 * The word &lt;code&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/code&gt; in the template above is
 * a specific permission type, such as &lt;code&gt;java.io.FilePermission&lt;/code&gt;
 * or &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;.
 *
 * &lt;p&gt; The &quot;&lt;i&gt;action&lt;/i&gt;&quot; is required for
 * many permission types, such as &lt;code&gt;java.io.FilePermission&lt;/code&gt;
 * (where it specifies what type of file access that is permitted).
 * It is not required for categories such as
 * &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;
 * where it is not necessary - you either have the
 * permission specified by the &lt;code&gt;&quot;&lt;i&gt;name&lt;/i&gt;&quot;&lt;/code&gt;
 * value following the type name or you don't.
 *
 * &lt;p&gt; The &lt;code&gt;signedBy&lt;/code&gt; name/value pair for a permission entry
 * is optional. If present, it indicates a signed permission. That is,
 * the permission class itself must be signed by the given alias in
 * order for it to be granted. For example,
 * suppose you have the following grant entry:
 *
 * &lt;pre&gt;
 *   grant principal foo.com.Principal &quot;Duke&quot; {
 *     permission Foo &quot;foobar&quot;, signedBy &quot;FooSoft&quot;;
 *   }
 * &lt;/pre&gt;
 *
 * &lt;p&gt; Then this permission of type &lt;i&gt;Foo&lt;/i&gt; is granted if the
 * &lt;code&gt;Foo.class&lt;/code&gt; permission has been signed by the
 * &quot;FooSoft&quot; alias, or if XXX &lt;code&gt;Foo.class&lt;/code&gt; is a
 * system class (i.e., is found on the CLASSPATH).
 *
 *
 * &lt;p&gt; Items that appear in an entry must appear in the specified order
 * (&lt;code&gt;permission&lt;/code&gt;, &lt;i&gt;Type&lt;/i&gt;, &quot;&lt;i&gt;name&lt;/i&gt;&quot;, and
 * &quot;&lt;i&gt;action&lt;/i&gt;&quot;). An entry is terminated with a semicolon.
 *
 * &lt;p&gt; Case is unimportant for the identifiers (&lt;code&gt;permission&lt;/code&gt;,
 * &lt;code&gt;signedBy&lt;/code&gt;, &lt;code&gt;codeBase&lt;/code&gt;, etc.) but is
 * significant for the &lt;i&gt;Type&lt;/i&gt;
 * or for any string that is passed in as a value. &lt;p&gt;
 *
 * &lt;p&gt; An example of two entries in a policy configuration file is
 * &lt;pre&gt;
 *   // if the code is comes from &quot;foo.com&quot; and is running as &quot;Duke&quot;,
 *   // grant it read/write to all files in /tmp.
 *
 *   grant codeBase &quot;foo.com&quot;, principal foo.com.Principal &quot;Duke&quot; {
 *              permission java.io.FilePermission &quot;/tmp/*&quot;, &quot;read,write&quot;;
 *   };
 *
 *   // grant any code running as &quot;Duke&quot; permission to read
 *   // the &quot;java.vendor&quot; Property.
 *
 *   grant principal foo.com.Principal &quot;Duke&quot; {
 *         permission java.util.PropertyPermission &quot;java.vendor&quot;;
 *
 *
 * &lt;/pre&gt;
 *  This Policy implementation supports special handling of any
 *  permission that contains the string, &quot;&lt;b&gt;${{self}}&lt;/b&gt;&quot;, as part of
 *  its target name.  When such a permission is evaluated
 *  (such as during a security check), &lt;b&gt;${{self}}&lt;/b&gt; is replaced
 *  with one or more Principal class/name pairs.  The exact
 *  replacement performed depends upon the contents of the
 *  grant clause to which the permission belongs.
 *&lt;p&gt;
 *
 *  If the grant clause does not contain any principal information,
 *  the permission will be ignored (permissions containing
 *  &lt;b&gt;${{self}}&lt;/b&gt; in their target names are only valid in the context
 *  of a principal-based grant clause).  For example, BarPermission
 *  will always be ignored in the following grant clause:
 *
 *&lt;pre&gt;
 *    grant codebase &quot;www.foo.com&quot;, signedby &quot;duke&quot; {
 *      permission BarPermission &quot;... ${{self}} ...&quot;;
 *    };
 *&lt;/pre&gt;
 *
 *  If the grant clause contains principal information, &lt;b&gt;${{self}}&lt;/b&gt;
 *  will be replaced with that same principal information.
 *  For example, &lt;b&gt;${{self}}&lt;/b&gt; in BarPermission will be replaced by
 *  &lt;b&gt;javax.security.auth.x500.X500Principal &quot;cn=Duke&quot;&lt;/b&gt;
 *  in the following grant clause:
 *
 *  &lt;pre&gt;
 *    grant principal javax.security.auth.x500.X500Principal &quot;cn=Duke&quot; {
 *      permission BarPermission &quot;... ${{self}} ...&quot;;
 *    };
 *  &lt;/pre&gt;
 *
 *  If there is a comma-separated list of principals in the grant
 *  clause, then &lt;b&gt;${{self}}&lt;/b&gt; will be replaced by the same
 *  comma-separated list or principals.
 *  In the case where both the principal class and name are
 *  wildcarded in the grant clause, &lt;b&gt;${{self}}&lt;/b&gt; is replaced
 *  with all the principals associated with the &lt;code&gt;Subject&lt;/code&gt;
 *  in the current &lt;code&gt;AccessControlContext&lt;/code&gt;.
 *
 *
 * &lt;p&gt; For PrivateCredentialPermissions, you can also use &quot;&lt;b&gt;self&lt;/b&gt;&quot;
 * instead of &quot;&lt;b&gt;${{self}}&lt;/b&gt;&quot;. However the use of &quot;&lt;b&gt;self&lt;/b&gt;&quot; is
 * deprecated in favour of &quot;&lt;b&gt;${{self}}&lt;/b&gt;&quot;.
 *
 * @see java.security.CodeSource
 * @see java.security.Permissions
 * @see java.security.ProtectionDomain
 */
public class PolicyFile extends java.security.Policy {

<span class="fc" id="L260">    private static final Debug debug = Debug.getInstance(&quot;policy&quot;);</span>

    private static final String NONE = &quot;NONE&quot;;
    private static final String P11KEYSTORE = &quot;PKCS11&quot;;

    private static final String SELF = &quot;${{self}}&quot;;
    private static final String X500PRINCIPAL =
                        &quot;javax.security.auth.x500.X500Principal&quot;;
    private static final String POLICY = &quot;java.security.policy&quot;;
    private static final String SECURITY_MANAGER = &quot;java.security.manager&quot;;
    private static final String POLICY_URL = &quot;policy.url.&quot;;
    private static final String AUTH_POLICY = &quot;java.security.auth.policy&quot;;
    private static final String AUTH_POLICY_URL = &quot;auth.policy.url.&quot;;

    private static final int DEFAULT_CACHE_SIZE = 1;

    // contains the policy grant entries, PD cache, and alias mapping
<span class="fc" id="L277">    private AtomicReference&lt;PolicyInfo&gt; policyInfo = new AtomicReference&lt;&gt;();</span>
<span class="fc" id="L278">    private boolean constructed = false;</span>

<span class="fc" id="L280">    private boolean expandProperties = true;</span>
<span class="fc" id="L281">    private boolean ignoreIdentityScope = true;</span>
<span class="fc" id="L282">    private boolean allowSystemProperties = true;</span>
<span class="fc" id="L283">    private boolean notUtf8 = false;</span>
    private URL url;

    // for use with the reflection API

<span class="fc" id="L288">    private static final Class[] PARAMS0 = { };</span>
<span class="fc" id="L289">    private static final Class[] PARAMS1 = { String.class };</span>
<span class="fc" id="L290">    private static final Class[] PARAMS2 = { String.class, String.class };</span>

    /**
     * Initializes the Policy object and reads the default policy
     * configuration file(s) into the Policy object.
     */
<span class="fc" id="L296">    public PolicyFile() {</span>
<span class="fc" id="L297">        init((URL)null);</span>
<span class="fc" id="L298">    }</span>

    /**
     * Initializes the Policy object and reads the default policy
     * from the specified URL only.
     */
<span class="fc" id="L304">    public PolicyFile(URL url) {</span>
<span class="fc" id="L305">        this.url = url;</span>
<span class="fc" id="L306">        init(url);</span>
<span class="fc" id="L307">    }</span>

    /**
     * Initializes the Policy object and reads the default policy
     * configuration file(s) into the Policy object.
     *
     * The algorithm for locating the policy file(s) and reading their
     * information into the Policy object is:
     * &lt;pre&gt;
     *   loop through the Security Properties named &quot;policy.url.1&quot;,
     *  &quot;&quot;policy.url.2&quot;, &quot;auth.policy.url.1&quot;,  &quot;auth.policy.url.2&quot; etc, until
     *   you don't find one. Each of these specify a policy file.
     *
     *   if none of these could be loaded, use a builtin static policy
     *      equivalent to the default lib/security/java.policy file.
     *
     *   if the system property &quot;java.policy&quot; or &quot;java.auth.policy&quot; is defined
     * (which is the
     *      case when the user uses the -D switch at runtime), and
     *     its use is allowed by the security property file,
     *     also load it.
     * &lt;/pre&gt;
     *
     * Each policy file consists of one or more grant entries, each of
     * which consists of a number of permission entries.
     * &lt;pre&gt;
     *   grant signedBy &quot;&lt;i&gt;alias&lt;/i&gt;&quot;, codeBase &quot;&lt;i&gt;URL&lt;/i&gt;&quot; {
     *     permission &lt;i&gt;Type&lt;/i&gt; &quot;&lt;i&gt;name&lt;/i&gt;&quot;, &quot;&lt;i&gt;action&lt;/i&gt;&quot;,
     *         signedBy &quot;&lt;i&gt;alias&lt;/i&gt;&quot;;
     *     ....
     *     permission &lt;i&gt;Type&lt;/i&gt; &quot;&lt;i&gt;name&lt;/i&gt;&quot;, &quot;&lt;i&gt;action&lt;/i&gt;&quot;,
     *         signedBy &quot;&lt;i&gt;alias&lt;/i&gt;&quot;;
     *   };
     *
     * &lt;/pre&gt;
     *
     * All non-italicized items above must appear as is (although case
     * doesn't matter and some are optional, as noted below).
     * Italicized items represent variable values.
     *
     * &lt;p&gt; A grant entry must begin with the word &lt;code&gt;grant&lt;/code&gt;.
     * The &lt;code&gt;signedBy&lt;/code&gt; and &lt;code&gt;codeBase&lt;/code&gt; name/value
     * pairs are optional.
     * If they are not present, then any signer (including unsigned code)
     * will match, and any codeBase will match.
     *
     * &lt;p&gt; A permission entry must begin with the word &lt;code&gt;permission&lt;/code&gt;.
     * The word &lt;code&gt;&lt;i&gt;Type&lt;/i&gt;&lt;/code&gt; in the template above would actually
     * be a specific permission type, such as
     * &lt;code&gt;java.io.FilePermission&lt;/code&gt; or
     * &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;.
     *
     * &lt;p&gt;The &quot;&lt;i&gt;action&lt;/i&gt;&quot; is required for
     * many permission types, such as &lt;code&gt;java.io.FilePermission&lt;/code&gt;
     * (where it specifies what type of file access is permitted).
     * It is not required for categories such as
     * &lt;code&gt;java.lang.RuntimePermission&lt;/code&gt;
     * where it is not necessary - you either have the
     * permission specified by the &lt;code&gt;&quot;&lt;i&gt;name&lt;/i&gt;&quot;&lt;/code&gt;
     * value following the type name or you don't.
     *
     * &lt;p&gt;The &lt;code&gt;signedBy&lt;/code&gt; name/value pair for a permission entry
     * is optional. If present, it indicates a signed permission. That is,
     * the permission class itself must be signed by the given alias in
     * order for it to be granted. For example,
     * suppose you have the following grant entry:
     *
     * &lt;pre&gt;
     *   grant {
     *     permission Foo &quot;foobar&quot;, signedBy &quot;FooSoft&quot;;
     *   }
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Then this permission of type &lt;i&gt;Foo&lt;/i&gt; is granted if the
     * &lt;code&gt;Foo.class&lt;/code&gt; permission has been signed by the
     * &quot;FooSoft&quot; alias, or if &lt;code&gt;Foo.class&lt;/code&gt; is a
     * system class (i.e., is found on the CLASSPATH).
     *
     * &lt;p&gt;Items that appear in an entry must appear in the specified order
     * (&lt;code&gt;permission&lt;/code&gt;, &lt;i&gt;Type&lt;/i&gt;, &quot;&lt;i&gt;name&lt;/i&gt;&quot;, and
     * &quot;&lt;i&gt;action&lt;/i&gt;&quot;). An entry is terminated with a semicolon.
     *
     * &lt;p&gt;Case is unimportant for the identifiers (&lt;code&gt;permission&lt;/code&gt;,
     * &lt;code&gt;signedBy&lt;/code&gt;, &lt;code&gt;codeBase&lt;/code&gt;, etc.) but is
     * significant for the &lt;i&gt;Type&lt;/i&gt;
     * or for any string that is passed in as a value. &lt;p&gt;
     *
     * &lt;p&gt;An example of two entries in a policy configuration file is
     * &lt;pre&gt;
     *   //  if the code is signed by &quot;Duke&quot;, grant it read/write to all
     *   // files in /tmp.
     *
     *   grant signedBy &quot;Duke&quot; {
     *          permission java.io.FilePermission &quot;/tmp/*&quot;, &quot;read,write&quot;;
     *   };
     * &lt;p&gt;
     *   // grant everyone the following permission
     *
     *   grant {
     *     permission java.util.PropertyPermission &quot;java.vendor&quot;;
     *   };
     *  &lt;/pre&gt;
     */
    private void init(URL url) {
        // Properties are set once for each init(); ignore changes between
        // between diff invocations of initPolicyFile(policy, url, info).
<span class="fc" id="L413">        String numCacheStr =</span>
<span class="fc" id="L414">          AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {</span>
            public String run() {
<span class="fc" id="L416">                expandProperties = &quot;true&quot;.equalsIgnoreCase</span>
<span class="fc" id="L417">                    (Security.getProperty(&quot;policy.expandProperties&quot;));</span>
<span class="fc" id="L418">                ignoreIdentityScope = &quot;true&quot;.equalsIgnoreCase</span>
<span class="fc" id="L419">                    (Security.getProperty(&quot;policy.ignoreIdentityScope&quot;));</span>
<span class="fc" id="L420">                allowSystemProperties = &quot;true&quot;.equalsIgnoreCase</span>
<span class="fc" id="L421">                    (Security.getProperty(&quot;policy.allowSystemProperty&quot;));</span>
<span class="fc" id="L422">                notUtf8 = &quot;false&quot;.equalsIgnoreCase</span>
<span class="fc" id="L423">                    (System.getProperty(&quot;sun.security.policy.utf8&quot;));</span>
<span class="fc" id="L424">                return System.getProperty(&quot;sun.security.policy.numcaches&quot;);</span>
            }});

        int numCaches;
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">        if (numCacheStr != null) {</span>
            try {
<span class="nc" id="L430">                numCaches = Integer.parseInt(numCacheStr);</span>
<span class="nc" id="L431">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L432">                numCaches = DEFAULT_CACHE_SIZE;</span>
<span class="nc" id="L433">            }</span>
        } else {
<span class="fc" id="L435">            numCaches = DEFAULT_CACHE_SIZE;</span>
        }
        // System.out.println(&quot;number caches=&quot; + numCaches);
<span class="fc" id="L438">        PolicyInfo newInfo = new PolicyInfo(numCaches);</span>
<span class="fc" id="L439">        initPolicyFile(newInfo, url);</span>
<span class="fc" id="L440">        policyInfo.set(newInfo);</span>
<span class="fc" id="L441">    }</span>

    private void initPolicyFile(final PolicyInfo newInfo, final URL url) {

<span class="fc bfc" id="L445" title="All 2 branches covered.">        if (url != null) {</span>

            /**
             * If the caller specified a URL via Policy.getInstance,
             * we only read from that URL
             */

<span class="pc bpc" id="L452" title="1 of 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L453">                debug.println(&quot;reading &quot;+url);</span>
            }
<span class="fc" id="L455">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                public Void run() {
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">                    if (init(url, newInfo) == false) {</span>
                        // use static policy if all else fails
<span class="nc" id="L459">                        initStaticPolicy(newInfo);</span>
                    }
<span class="fc" id="L461">                    return null;</span>
                }
            });

        } else {

            /**
             * Caller did not specify URL via Policy.getInstance.
             * Read from URLs listed in the java.security properties file.
             *
             * We call initPolicyFile with POLICY , POLICY_URL and then
             * call it with AUTH_POLICY and AUTH_POLICY_URL
             * So first we will process the JAVA standard policy
             * and then process the JAVA AUTH Policy.
             * This is for backward compatibility as well as to handle
             * cases where the user has a single unified policyfile
             * with both java policy entries and auth entries
             */

<span class="fc" id="L480">            boolean loaded_one = initPolicyFile(POLICY, POLICY_URL, newInfo);</span>
            // To maintain strict backward compatibility
            // we load the static policy only if POLICY load failed
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">            if (!loaded_one) {</span>
                // use static policy if all else fails
<span class="nc" id="L485">                initStaticPolicy(newInfo);</span>
            }

<span class="fc" id="L488">            initPolicyFile(AUTH_POLICY, AUTH_POLICY_URL, newInfo);</span>
        }
<span class="fc" id="L490">    }</span>

    private boolean initPolicyFile(final String propname, final String urlname,
                                final PolicyInfo newInfo) {
<span class="fc" id="L494">        Boolean loadedPolicy =</span>
<span class="fc" id="L495">            AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {</span>
            public Boolean run() {
<span class="fc" id="L497">                boolean loaded_policy = false;</span>

<span class="pc bpc" id="L499" title="1 of 2 branches missed.">                if (allowSystemProperties) {</span>
<span class="fc" id="L500">                    String extra_policy = System.getProperty(propname);</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">                    if (extra_policy != null) {</span>
<span class="fc" id="L502">                        boolean overrideAll = false;</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">                        if (extra_policy.startsWith(&quot;=&quot;)) {</span>
<span class="fc" id="L504">                            overrideAll = true;</span>
<span class="fc" id="L505">                            extra_policy = extra_policy.substring(1);</span>
                        }
                        try {
<span class="fc" id="L508">                            extra_policy =</span>
<span class="fc" id="L509">                                PropertyExpander.expand(extra_policy);</span>
                            URL policyURL;

<span class="fc" id="L512">                            File policyFile = new File(extra_policy);</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">                            if (policyFile.exists()) {</span>
<span class="fc" id="L514">                                policyURL = ParseUtil.fileToEncodedURL</span>
<span class="fc" id="L515">                                    (new File(policyFile.getCanonicalPath()));</span>
                            } else {
<span class="fc" id="L517">                                policyURL = new URL(extra_policy);</span>
                            }
<span class="fc bfc" id="L519" title="All 2 branches covered.">                            if (debug != null)</span>
<span class="fc" id="L520">                                debug.println(&quot;reading &quot;+policyURL);</span>
<span class="pc bpc" id="L521" title="1 of 2 branches missed.">                            if (init(policyURL, newInfo))</span>
<span class="fc" id="L522">                                loaded_policy = true;</span>
<span class="fc" id="L523">                        } catch (Exception e) {</span>
                            // ignore.
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">                            if (debug != null) {</span>
<span class="nc" id="L526">                                debug.println(&quot;caught exception: &quot;+e);</span>
                            }
<span class="fc" id="L528">                        }</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">                        if (overrideAll) {</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">                            if (debug != null) {</span>
<span class="fc" id="L531">                                debug.println(&quot;overriding other policies!&quot;);</span>
                            }
<span class="fc" id="L533">                            return Boolean.valueOf(loaded_policy);</span>
                        }
                    }
                }

<span class="fc" id="L538">                int n = 1;</span>
                String policy_uri;

<span class="fc bfc" id="L541" title="All 2 branches covered.">                while ((policy_uri = Security.getProperty(urlname+n)) != null) {</span>
                    try {
<span class="fc" id="L543">                        URL policy_url = null;</span>
<span class="fc" id="L544">                        String expanded_uri = PropertyExpander.expand</span>
<span class="fc" id="L545">                                (policy_uri).replace(File.separatorChar, '/');</span>

<span class="fc bfc" id="L547" title="All 2 branches covered.">                        if (policy_uri.startsWith(&quot;file:${java.home}/&quot;) ||</span>
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">                            policy_uri.startsWith(&quot;file:${user.home}/&quot;)) {</span>

                            // this special case accommodates
                            // the situation java.home/user.home
                            // expand to a single slash, resulting in
                            // a file://foo URI
<span class="fc" id="L554">                            policy_url = new File</span>
<span class="fc" id="L555">                                (expanded_uri.substring(5)).toURI().toURL();</span>
                        } else {
<span class="nc" id="L557">                            policy_url = new URI(expanded_uri).toURL();</span>
                        }

<span class="pc bpc" id="L560" title="1 of 2 branches missed.">                        if (debug != null)</span>
<span class="nc" id="L561">                            debug.println(&quot;reading &quot;+policy_url);</span>
<span class="pc bpc" id="L562" title="1 of 2 branches missed.">                        if (init(policy_url, newInfo))</span>
<span class="fc" id="L563">                            loaded_policy = true;</span>
<span class="nc" id="L564">                    } catch (Exception e) {</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                        if (debug != null) {</span>
<span class="nc" id="L566">                            debug.println(&quot;error reading policy &quot;+e);</span>
<span class="nc" id="L567">                            e.printStackTrace();</span>
                        }
                        // ignore that policy
<span class="fc" id="L570">                    }</span>
<span class="fc" id="L571">                    n++;</span>
                }
<span class="fc" id="L573">                return Boolean.valueOf(loaded_policy);</span>
            }
        });

<span class="fc" id="L577">        return loadedPolicy.booleanValue();</span>
    }

    /**
     * Reads a policy configuration into the Policy object using a
     * Reader object.
     *
     * @param policyFile the policy Reader object.
     */
    private boolean init(URL policy, PolicyInfo newInfo) {
<span class="fc" id="L587">        boolean success = false;</span>
<span class="fc" id="L588">        PolicyParser pp = new PolicyParser(expandProperties);</span>
<span class="fc" id="L589">        InputStreamReader isr = null;</span>
        try {

            // read in policy using UTF-8 by default
            //
            // check non-standard system property to see if
            // the default encoding should be used instead

<span class="fc bfc" id="L597" title="All 2 branches covered.">            if (notUtf8) {</span>
<span class="fc" id="L598">                isr = new InputStreamReader</span>
<span class="fc" id="L599">                                (PolicyUtil.getInputStream(policy));</span>
            } else {
<span class="fc" id="L601">                isr = new InputStreamReader</span>
<span class="fc" id="L602">                                (PolicyUtil.getInputStream(policy), &quot;UTF-8&quot;);</span>
            }

<span class="fc" id="L605">            pp.read(isr);</span>

<span class="fc" id="L607">            KeyStore keyStore = null;</span>
            try {
<span class="fc" id="L609">                keyStore = PolicyUtil.getKeyStore</span>
<span class="fc" id="L610">                                (policy,</span>
<span class="fc" id="L611">                                pp.getKeyStoreUrl(),</span>
<span class="fc" id="L612">                                pp.getKeyStoreType(),</span>
<span class="fc" id="L613">                                pp.getKeyStoreProvider(),</span>
<span class="fc" id="L614">                                pp.getStorePassURL(),</span>
                                debug);
<span class="fc" id="L616">            } catch (Exception e) {</span>
                // ignore, treat it like we have no keystore
<span class="fc bfc" id="L618" title="All 2 branches covered.">                if (debug != null) {</span>
<span class="fc" id="L619">                    e.printStackTrace();</span>
                }
<span class="fc" id="L621">            }</span>

<span class="fc" id="L623">            Enumeration&lt;PolicyParser.GrantEntry&gt; enum_ = pp.grantElements();</span>
<span class="fc bfc" id="L624" title="All 2 branches covered.">            while (enum_.hasMoreElements()) {</span>
<span class="fc" id="L625">                PolicyParser.GrantEntry ge = enum_.nextElement();</span>
<span class="fc" id="L626">                addGrantEntry(ge, keyStore, newInfo);</span>
<span class="fc" id="L627">            }</span>
<span class="nc" id="L628">        } catch (PolicyParser.ParsingException pe) {</span>
<span class="nc" id="L629">            MessageFormat form = new MessageFormat(ResourcesMgr.getString</span>
<span class="nc" id="L630">                (POLICY + &quot;.error.parsing.policy.message&quot;));</span>
<span class="nc" id="L631">            Object[] source = {policy, pe.getLocalizedMessage()};</span>
<span class="nc" id="L632">            System.err.println(form.format(source));</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">            if (debug != null)</span>
<span class="nc" id="L634">                pe.printStackTrace();</span>

<span class="fc" id="L636">        } catch (Exception e) {</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L638">                debug.println(&quot;error parsing &quot;+policy);</span>
<span class="nc" id="L639">                debug.println(e.toString());</span>
<span class="nc" id="L640">                e.printStackTrace();</span>
            }
        } finally {
<span class="pc bpc" id="L643" title="6 of 8 branches missed.">            if (isr != null) {</span>
                try {
<span class="pc" id="L645">                    isr.close();</span>
<span class="pc" id="L646">                    success = true;</span>
<span class="nc" id="L647">                } catch (IOException e) {</span>
                    // ignore the exception
<span class="pc" id="L649">                }</span>
            } else {
<span class="pc" id="L651">                success = true;</span>
            }
<span class="pc" id="L653">        }</span>

<span class="fc" id="L655">        return success;</span>
    }

    private void initStaticPolicy(final PolicyInfo newInfo) {
<span class="nc" id="L659">        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
            public Void run() {
<span class="nc" id="L661">                PolicyEntry pe = new PolicyEntry(new CodeSource(null,</span>
                    (Certificate[]) null));
<span class="nc" id="L663">                pe.add(SecurityConstants.LOCAL_LISTEN_PERMISSION);</span>
<span class="nc" id="L664">                pe.add(new PropertyPermission(&quot;java.version&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L666">                pe.add(new PropertyPermission(&quot;java.vendor&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L668">                pe.add(new PropertyPermission(&quot;java.vendor.url&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L670">                pe.add(new PropertyPermission(&quot;java.class.version&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L672">                pe.add(new PropertyPermission(&quot;os.name&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L674">                pe.add(new PropertyPermission(&quot;os.version&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L676">                pe.add(new PropertyPermission(&quot;os.arch&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L678">                pe.add(new PropertyPermission(&quot;file.separator&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L680">                pe.add(new PropertyPermission(&quot;path.separator&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L682">                pe.add(new PropertyPermission(&quot;line.separator&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L684">                pe.add(new PropertyPermission</span>
                                (&quot;java.specification.version&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L687">                pe.add(new PropertyPermission</span>
                                (&quot;java.specification.vendor&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L690">                pe.add(new PropertyPermission</span>
                                (&quot;java.specification.name&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L693">                pe.add(new PropertyPermission</span>
                                (&quot;java.vm.specification.version&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L696">                pe.add(new PropertyPermission</span>
                                (&quot;java.vm.specification.vendor&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L699">                pe.add(new PropertyPermission</span>
                                (&quot;java.vm.specification.name&quot;,
                                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L702">                pe.add(new PropertyPermission(&quot;java.vm.version&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L704">                pe.add(new PropertyPermission(&quot;java.vm.vendor&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));
<span class="nc" id="L706">                pe.add(new PropertyPermission(&quot;java.vm.name&quot;,</span>
                    SecurityConstants.PROPERTY_READ_ACTION));

                // No need to sync because noone has access to newInfo yet
<span class="nc" id="L710">                newInfo.policyEntries.add(pe);</span>

                // Add AllPermissions for standard extensions
<span class="nc" id="L713">                String[] extCodebases = PolicyParser.parseExtDirs(</span>
                    PolicyParser.EXTDIRS_EXPANSION, 0);
<span class="nc bnc" id="L715" title="All 4 branches missed.">                if (extCodebases != null &amp;&amp; extCodebases.length &gt; 0) {</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">                    for (int i = 0; i &lt; extCodebases.length; i++) {</span>
                        try {
<span class="nc" id="L718">                            pe = new PolicyEntry(canonicalizeCodebase(</span>
                                new CodeSource(new URL(extCodebases[i]),
                                    (Certificate[]) null), false ));
<span class="nc" id="L721">                            pe.add(SecurityConstants.ALL_PERMISSION);</span>

                            // No need to sync because noone has access to
                            // newInfo yet
<span class="nc" id="L725">                            newInfo.policyEntries.add(pe);</span>
<span class="nc" id="L726">                        } catch (Exception e) {</span>
                            // this is probably bad (though not dangerous).
                            // What should we do?
<span class="nc" id="L729">                        }</span>
                    }
                }
<span class="nc" id="L732">                return null;</span>
            }
        });
<span class="nc" id="L735">    }</span>

    /**
     * Given a GrantEntry, create a codeSource.
     *
     * @return null if signedBy alias is not recognized
     */
    private CodeSource getCodeSource(PolicyParser.GrantEntry ge, KeyStore keyStore,
        PolicyInfo newInfo) throws java.net.MalformedURLException
    {
<span class="fc" id="L745">        Certificate[] certs = null;</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">        if (ge.signedBy != null) {</span>
<span class="nc" id="L747">            certs = getCertificates(keyStore, ge.signedBy, newInfo);</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">            if (certs == null) {</span>
                // we don't have a key for this alias,
                // just return
<span class="nc bnc" id="L751" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L752">                    debug.println(&quot;  -- No certs for alias '&quot; +</span>
                                       ge.signedBy + &quot;' - ignoring entry&quot;);
                }
<span class="nc" id="L755">                return null;</span>
            }
        }

        URL location;

<span class="fc bfc" id="L761" title="All 2 branches covered.">        if (ge.codeBase != null)</span>
<span class="fc" id="L762">            location = new URL(ge.codeBase);</span>
        else
<span class="fc" id="L764">            location = null;</span>

<span class="fc" id="L766">        return (canonicalizeCodebase(new CodeSource(location, certs),false));</span>
    }

    /**
     * Add one policy entry to the list.
     */
    private void addGrantEntry(PolicyParser.GrantEntry ge,
                               KeyStore keyStore, PolicyInfo newInfo) {

<span class="fc bfc" id="L775" title="All 2 branches covered.">        if (debug != null) {</span>
<span class="fc" id="L776">            debug.println(&quot;Adding policy entry: &quot;);</span>
<span class="fc" id="L777">            debug.println(&quot;  signedBy &quot; + ge.signedBy);</span>
<span class="fc" id="L778">            debug.println(&quot;  codeBase &quot; + ge.codeBase);</span>
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">            if (ge.principals != null) {</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">                for (PolicyParser.PrincipalEntry pppe : ge.principals) {</span>
<span class="fc" id="L781">                    debug.println(&quot;  &quot; + pppe.toString());</span>
<span class="fc" id="L782">                }</span>
            }
        }

        try {
<span class="fc" id="L787">            CodeSource codesource = getCodeSource(ge, keyStore, newInfo);</span>
            // skip if signedBy alias was unknown...
<span class="pc bpc" id="L789" title="1 of 2 branches missed.">            if (codesource == null) return;</span>

            // perform keystore alias principal replacement.
            // for example, if alias resolves to X509 certificate,
            // replace principal with:  &lt;X500Principal class&gt;  &lt;SubjectDN&gt;
            // -- skip if alias is unknown
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">            if (replacePrincipals(ge.principals, keyStore) == false)</span>
<span class="nc" id="L796">                return;</span>
<span class="fc" id="L797">            PolicyEntry entry = new PolicyEntry(codesource, ge.principals);</span>
<span class="fc" id="L798">            Enumeration&lt;PolicyParser.PermissionEntry&gt; enum_ =</span>
<span class="fc" id="L799">                                                ge.permissionElements();</span>
<span class="fc bfc" id="L800" title="All 2 branches covered.">            while (enum_.hasMoreElements()) {</span>
<span class="fc" id="L801">                PolicyParser.PermissionEntry pe = enum_.nextElement();</span>

                try {
                    // perform ${{ ... }} expansions within permission name
<span class="fc" id="L805">                    expandPermissionName(pe, keyStore);</span>

                    // XXX special case PrivateCredentialPermission-SELF
                    Permission perm;
<span class="fc" id="L809">                    if (pe.permission.equals</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">                        (&quot;javax.security.auth.PrivateCredentialPermission&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L811" title="1 of 2 branches missed.">                        pe.name.endsWith(&quot; self&quot;)) {</span>
<span class="nc" id="L812">                        pe.name = pe.name.substring(0, pe.name.indexOf(&quot;self&quot;))</span>
                                + SELF;
                    }
                    // check for self
<span class="fc bfc" id="L816" title="All 4 branches covered.">                    if (pe.name != null &amp;&amp; pe.name.indexOf(SELF) != -1) {</span>
                        // Create a &quot;SelfPermission&quot; , it could be an
                        // an unresolved permission which will be resolved
                        // when implies is called
                        // Add it to entry
                        Certificate certs[];
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">                        if (pe.signedBy != null) {</span>
<span class="nc" id="L823">                            certs = getCertificates(keyStore,</span>
                                                    pe.signedBy,
                                                    newInfo);
                        } else {
<span class="fc" id="L827">                            certs = null;</span>
                        }
<span class="fc" id="L829">                        perm = new SelfPermission(pe.permission,</span>
                                                  pe.name,
                                                  pe.action,
                                                  certs);
<span class="fc" id="L833">                    } else {</span>
<span class="fc" id="L834">                        perm = getInstance(pe.permission,</span>
                                           pe.name,
                                           pe.action);
                    }
<span class="fc" id="L838">                    entry.add(perm);</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">                    if (debug != null) {</span>
<span class="fc" id="L840">                        debug.println(&quot;  &quot;+perm);</span>
                    }
<span class="fc" id="L842">                } catch (ClassNotFoundException cnfe) {</span>
                    Certificate certs[];
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">                    if (pe.signedBy != null) {</span>
<span class="nc" id="L845">                        certs = getCertificates(keyStore,</span>
                                                pe.signedBy,
                                                newInfo);
                    } else {
<span class="fc" id="L849">                        certs = null;</span>
                    }

                    // only add if we had no signer or we had a
                    // a signer and found the keys for it.
<span class="pc bpc" id="L854" title="2 of 4 branches missed.">                    if (certs != null || pe.signedBy == null) {</span>
<span class="fc" id="L855">                        Permission perm = new UnresolvedPermission(</span>
                                                  pe.permission,
                                                  pe.name,
                                                  pe.action,
                                                  certs);
<span class="fc" id="L860">                        entry.add(perm);</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">                        if (debug != null) {</span>
<span class="fc" id="L862">                            debug.println(&quot;  &quot;+perm);</span>
                        }
                    }
<span class="nc" id="L865">                } catch (java.lang.reflect.InvocationTargetException ite) {</span>
<span class="nc" id="L866">                    MessageFormat form = new MessageFormat</span>
                        (ResourcesMgr.getString
<span class="nc" id="L868">                         (POLICY +</span>
                          &quot;.error.adding.Permission.perm.message&quot;));
<span class="nc" id="L870">                    Object[] source = {pe.permission,</span>
<span class="nc" id="L871">                                       ite.getTargetException().toString()};</span>
<span class="nc" id="L872">                    System.err.println(form.format(source));</span>
<span class="fc" id="L873">                } catch (Exception e) {</span>
<span class="fc" id="L874">                    MessageFormat form = new MessageFormat</span>
                        (ResourcesMgr.getString
<span class="fc" id="L876">                         (POLICY +</span>
                          &quot;.error.adding.Permission.perm.message&quot;));
<span class="fc" id="L878">                    Object[] source = {pe.permission,</span>
<span class="fc" id="L879">                                       e.toString()};</span>
<span class="fc" id="L880">                    System.err.println(form.format(source));</span>
<span class="pc" id="L881">                }</span>
<span class="fc" id="L882">            }</span>

            // No need to sync because noone has access to newInfo yet
<span class="fc" id="L885">            newInfo.policyEntries.add(entry);</span>
<span class="nc" id="L886">        } catch (Exception e) {</span>
<span class="nc" id="L887">            MessageFormat form = new MessageFormat(ResourcesMgr.getString</span>
<span class="nc" id="L888">                                         (POLICY</span>
                                         + &quot;.error.adding.Entry.message&quot;));
<span class="nc" id="L890">            Object[] source = {e.toString()};</span>
<span class="nc" id="L891">            System.err.println(form.format(source));</span>
<span class="fc" id="L892">        }</span>
<span class="fc bfc" id="L893" title="All 2 branches covered.">        if (debug != null)</span>
<span class="fc" id="L894">            debug.println();</span>
<span class="fc" id="L895">    }</span>

    /**
     * Returns a new Permission object of the given Type. The Permission is
     * created by getting the
     * Class object using the &lt;code&gt;Class.forName&lt;/code&gt; method, and using
     * the reflection API to invoke the (String name, String actions)
     * constructor on the
     * object.
     *
     * @param type the type of Permission being created.
     * @param name the name of the Permission being created.
     * @param actions the actions of the Permission being created.
     *
     * @exception  ClassNotFoundException  if the particular Permission
     *             class could not be found.
     *
     * @exception  IllegalAccessException  if the class or initializer is
     *               not accessible.
     *
     * @exception  InstantiationException  if getInstance tries to
     *               instantiate an abstract class or an interface, or if the
     *               instantiation fails for some other reason.
     *
     * @exception  NoSuchMethodException if the (String, String) constructor
     *               is not found.
     *
     * @exception  InvocationTargetException if the underlying Permission
     *               constructor throws an exception.
     *
     */

    private static final Permission getInstance(String type,
                                    String name,
                                    String actions)
        throws ClassNotFoundException,
               InstantiationException,
               IllegalAccessException,
               NoSuchMethodException,
               InvocationTargetException
    {
        //XXX we might want to keep a hash of created factories...
<span class="fc" id="L937">        Class&lt;?&gt; pc = Class.forName(type, false, null);</span>
<span class="fc" id="L938">        Permission answer = getKnownInstance(pc, name, actions);</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">        if (answer != null) {</span>
<span class="fc" id="L940">            return answer;</span>
        }
<span class="pc bpc" id="L942" title="1 of 2 branches missed.">        if (!Permission.class.isAssignableFrom(pc)) {</span>
            // not the right subtype
<span class="nc" id="L944">            throw new ClassCastException(type + &quot; is not a Permission&quot;);</span>
        }

<span class="pc bpc" id="L947" title="1 of 4 branches missed.">        if (name == null &amp;&amp; actions == null) {</span>
            try {
<span class="fc" id="L949">                Constructor&lt;?&gt; c = pc.getConstructor(PARAMS0);</span>
<span class="fc" id="L950">                return (Permission) c.newInstance(new Object[] {});</span>
<span class="nc" id="L951">            } catch (NoSuchMethodException ne) {</span>
                try {
<span class="nc" id="L953">                    Constructor&lt;?&gt; c = pc.getConstructor(PARAMS1);</span>
<span class="nc" id="L954">                    return (Permission) c.newInstance(</span>
                              new Object[] { name});
<span class="nc" id="L956">                } catch (NoSuchMethodException ne1 ) {</span>
<span class="nc" id="L957">                    Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);</span>
<span class="nc" id="L958">                    return (Permission) c.newInstance(</span>
                        new Object[] { name, actions });
                }
            }
        } else {
<span class="pc bpc" id="L963" title="1 of 4 branches missed.">            if (name != null &amp;&amp; actions == null) {</span>
                try {
<span class="fc" id="L965">                    Constructor&lt;?&gt; c = pc.getConstructor(PARAMS1);</span>
<span class="fc" id="L966">                    return (Permission) c.newInstance(new Object[] { name});</span>
<span class="fc" id="L967">                } catch (NoSuchMethodException ne) {</span>
<span class="fc" id="L968">                    Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);</span>
<span class="fc" id="L969">                    return (Permission) c.newInstance(</span>
                          new Object[] { name, actions });
                }
            } else {
<span class="fc" id="L973">                Constructor&lt;?&gt; c = pc.getConstructor(PARAMS2);</span>
<span class="fc" id="L974">                return (Permission) c.newInstance(</span>
                      new Object[] { name, actions });
             }
        }
    }

    /**
     * Creates one of the well-known permissions directly instead of
     * via reflection. Keep list short to not penalize non-JDK-defined
     * permissions.
     */
    private static final Permission getKnownInstance(Class&lt;?&gt; claz,
        String name, String actions) {
<span class="fc bfc" id="L987" title="All 2 branches covered.">        if (claz.equals(FilePermission.class)) {</span>
<span class="fc" id="L988">            return new FilePermission(name, actions);</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">        } else if (claz.equals(SocketPermission.class)) {</span>
<span class="fc" id="L990">            return new SocketPermission(name, actions);</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">        } else if (claz.equals(RuntimePermission.class)) {</span>
<span class="fc" id="L992">            return new RuntimePermission(name, actions);</span>
<span class="fc bfc" id="L993" title="All 2 branches covered.">        } else if (claz.equals(PropertyPermission.class)) {</span>
<span class="fc" id="L994">            return new PropertyPermission(name, actions);</span>
<span class="pc bpc" id="L995" title="1 of 2 branches missed.">        } else if (claz.equals(NetPermission.class)) {</span>
<span class="nc" id="L996">            return new NetPermission(name, actions);</span>
<span class="fc bfc" id="L997" title="All 2 branches covered.">        } else if (claz.equals(AllPermission.class)) {</span>
<span class="fc" id="L998">            return SecurityConstants.ALL_PERMISSION;</span>
        } else {
<span class="fc" id="L1000">            return null;</span>
        }
    }

    /**
     * Fetch all certs associated with this alias.
     */
    private Certificate[] getCertificates
                (KeyStore keyStore, String aliases, PolicyInfo newInfo) {

<span class="nc" id="L1010">        List&lt;Certificate&gt; vcerts = null;</span>

<span class="nc" id="L1012">        StringTokenizer st = new StringTokenizer(aliases, &quot;,&quot;);</span>
<span class="nc" id="L1013">        int n = 0;</span>

<span class="nc bnc" id="L1015" title="All 2 branches missed.">        while (st.hasMoreTokens()) {</span>
<span class="nc" id="L1016">            String alias = st.nextToken().trim();</span>
<span class="nc" id="L1017">            n++;</span>
<span class="nc" id="L1018">            Certificate cert = null;</span>
            // See if this alias's cert has already been cached
<span class="nc" id="L1020">            synchronized (newInfo.aliasMapping) {</span>
<span class="nc" id="L1021">                cert = (Certificate)newInfo.aliasMapping.get(alias);</span>

<span class="nc bnc" id="L1023" title="All 4 branches missed.">                if (cert == null &amp;&amp; keyStore != null) {</span>

                    try {
<span class="nc" id="L1026">                        cert = keyStore.getCertificate(alias);</span>
<span class="nc" id="L1027">                    } catch (KeyStoreException kse) {</span>
                        // never happens, because keystore has already been loaded
                        // when we call this
<span class="nc" id="L1030">                    }</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">                    if (cert != null) {</span>
<span class="nc" id="L1032">                        newInfo.aliasMapping.put(alias, cert);</span>
<span class="nc" id="L1033">                        newInfo.aliasMapping.put(cert, alias);</span>
                    }
                }
<span class="nc" id="L1036">            }</span>

<span class="nc bnc" id="L1038" title="All 2 branches missed.">            if (cert != null) {</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">                if (vcerts == null)</span>
<span class="nc" id="L1040">                    vcerts = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1041">                vcerts.add(cert);</span>
            }
<span class="nc" id="L1043">        }</span>

        // make sure n == vcerts.size, since we are doing a logical *and*
<span class="nc bnc" id="L1046" title="All 4 branches missed.">        if (vcerts != null &amp;&amp; n == vcerts.size()) {</span>
<span class="nc" id="L1047">            Certificate[] certs = new Certificate[vcerts.size()];</span>
<span class="nc" id="L1048">            vcerts.toArray(certs);</span>
<span class="nc" id="L1049">            return certs;</span>
        } else {
<span class="nc" id="L1051">            return null;</span>
        }
    }

    /**
     * Refreshes the policy object by re-reading all the policy files.
     */
    @Override public void refresh() {
<span class="nc" id="L1059">        init(url);</span>
<span class="nc" id="L1060">    }</span>

    /**
     * Evaluates the the global policy for the permissions granted to
     * the ProtectionDomain and tests whether the permission is
     * granted.
     *
     * @param domain the ProtectionDomain to test
     * @param permission the Permission object to be tested for implication.
     *
     * @return true if &quot;permission&quot; is a proper subset of a permission
     * granted to this ProtectionDomain.
     *
     * @see java.security.ProtectionDomain
     */
    @Override
    public boolean implies(ProtectionDomain pd, Permission p) {
<span class="fc" id="L1077">        PolicyInfo pi = policyInfo.get();</span>
<span class="fc" id="L1078">        ProtectionDomainCache pdMap = pi.getPdMapping();</span>

<span class="fc" id="L1080">        PermissionCollection pc = pdMap.get(pd);</span>

<span class="fc bfc" id="L1082" title="All 2 branches covered.">        if (pc != null) {</span>
<span class="fc" id="L1083">            return pc.implies(p);</span>
        }

<span class="fc" id="L1086">        pc = getPermissions(pd);</span>
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">        if (pc == null) {</span>
<span class="nc" id="L1088">            return false;</span>
        }

        // cache mapping of protection domain to its PermissionCollection
<span class="fc" id="L1092">        pdMap.put(pd, pc);</span>
<span class="fc" id="L1093">        return pc.implies(p);</span>
    }

    /**
     * Examines this &lt;code&gt;Policy&lt;/code&gt; and returns the permissions granted
     * to the specified &lt;code&gt;ProtectionDomain&lt;/code&gt;.  This includes
     * the permissions currently associated with the domain as well
     * as the policy permissions granted to the domain's
     * CodeSource, ClassLoader, and Principals.
     *
     * &lt;p&gt; Note that this &lt;code&gt;Policy&lt;/code&gt; implementation has
     * special handling for PrivateCredentialPermissions.
     * When this method encounters a &lt;code&gt;PrivateCredentialPermission&lt;/code&gt;
     * which specifies &quot;self&quot; as the &lt;code&gt;Principal&lt;/code&gt; class and name,
     * it does not add that &lt;code&gt;Permission&lt;/code&gt; to the returned
     * &lt;code&gt;PermissionCollection&lt;/code&gt;.  Instead, it builds
     * a new &lt;code&gt;PrivateCredentialPermission&lt;/code&gt;
     * for each &lt;code&gt;Principal&lt;/code&gt; associated with the provided
     * &lt;code&gt;Subject&lt;/code&gt;.  Each new &lt;code&gt;PrivateCredentialPermission&lt;/code&gt;
     * contains the same Credential class as specified in the
     * originally granted permission, as well as the Class and name
     * for the respective &lt;code&gt;Principal&lt;/code&gt;.
     *
     * &lt;p&gt;
     *
     * @param domain the Permissions granted to this
     *          &lt;code&gt;ProtectionDomain&lt;/code&gt; are returned.
     *
     * @return the Permissions granted to the provided
     *          &lt;code&gt;ProtectionDomain&lt;/code&gt;.
     */
    @Override
    public PermissionCollection getPermissions(ProtectionDomain domain) {
<span class="fc" id="L1126">        Permissions perms = new Permissions();</span>

<span class="pc bpc" id="L1128" title="1 of 2 branches missed.">        if (domain == null)</span>
<span class="nc" id="L1129">           return perms;</span>

        // first get policy perms
<span class="fc" id="L1132">        getPermissions(perms, domain);</span>

        // add static perms
        //      - adding static perms after policy perms is necessary
        //        to avoid a regression for 4301064
<span class="fc" id="L1137">        PermissionCollection pc = domain.getPermissions();</span>
<span class="fc bfc" id="L1138" title="All 2 branches covered.">        if (pc != null) {</span>
<span class="fc" id="L1139">            synchronized (pc) {</span>
<span class="fc" id="L1140">                Enumeration&lt;Permission&gt; e = pc.elements();</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">                while (e.hasMoreElements()) {</span>
<span class="fc" id="L1142">                    perms.add(e.nextElement());</span>
                }
<span class="pc" id="L1144">            }</span>
        }

<span class="fc" id="L1147">        return perms;</span>
    }

    /**
     * Examines this Policy and creates a PermissionCollection object with
     * the set of permissions for the specified CodeSource.
     *
     * @param CodeSource the codesource associated with the caller.
     * This encapsulates the original location of the code (where the code
     * came from) and the public key(s) of its signer.
     *
     * @return the set of permissions according to the policy.
     */
    @Override
    public PermissionCollection getPermissions(CodeSource codesource) {
<span class="fc" id="L1162">        return getPermissions(new Permissions(), codesource);</span>
    }

    /**
     * Examines the global policy and returns the provided Permissions
     * object with additional permissions granted to the specified
     * ProtectionDomain.
     *
     * @param perm the Permissions to populate
     * @param pd the ProtectionDomain associated with the caller.
     *
     * @return the set of Permissions according to the policy.
     */
    private PermissionCollection getPermissions(Permissions perms,
                                        ProtectionDomain pd ) {
<span class="fc bfc" id="L1177" title="All 2 branches covered.">        if (debug != null) {</span>
<span class="fc" id="L1178">            debug.println(&quot;getPermissions:\n\t&quot; + printPD(pd));</span>
        }

<span class="fc" id="L1181">        final CodeSource cs = pd.getCodeSource();</span>
<span class="fc bfc" id="L1182" title="All 2 branches covered.">        if (cs == null)</span>
<span class="fc" id="L1183">            return perms;</span>

<span class="fc" id="L1185">        CodeSource canonCodeSource = AccessController.doPrivileged(</span>
<span class="fc" id="L1186">            new java.security.PrivilegedAction&lt;CodeSource&gt;(){</span>
                public CodeSource run() {
<span class="fc" id="L1188">                    return canonicalizeCodebase(cs, true);</span>
                }
            });
<span class="fc" id="L1191">        return getPermissions(perms, canonCodeSource, pd.getPrincipals());</span>
    }

    /**
     * Examines the global policy and returns the provided Permissions
     * object with additional permissions granted to the specified
     * CodeSource.
     *
     * @param permissions the permissions to populate
     * @param codesource the codesource associated with the caller.
     * This encapsulates the original location of the code (where the code
     * came from) and the public key(s) of its signer.
     *
     * @return the set of permissions according to the policy.
     */
    private PermissionCollection getPermissions(Permissions perms,
                                                final CodeSource cs) {

<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">        if (cs == null)</span>
<span class="nc" id="L1210">            return perms;</span>

<span class="fc" id="L1212">        CodeSource canonCodeSource = AccessController.doPrivileged(</span>
<span class="fc" id="L1213">            new java.security.PrivilegedAction&lt;CodeSource&gt;(){</span>
                public CodeSource run() {
<span class="fc" id="L1215">                    return canonicalizeCodebase(cs, true);</span>
                }
            });

<span class="fc" id="L1219">        return getPermissions(perms, canonCodeSource, null);</span>
    }

    private Permissions getPermissions(Permissions perms,
                                       final CodeSource cs,
                                       Principal[] principals) {
<span class="fc" id="L1225">        PolicyInfo pi = policyInfo.get();</span>

<span class="fc bfc" id="L1227" title="All 2 branches covered.">        for (PolicyEntry entry : pi.policyEntries) {</span>
<span class="fc" id="L1228">            addPermissions(perms, cs, principals, entry);</span>
<span class="fc" id="L1229">        }</span>

        // Go through policyEntries gotten from identity db; sync required
        // because checkForTrustedIdentity (below) might update list
<span class="fc" id="L1233">        synchronized (pi.identityPolicyEntries) {</span>
<span class="pc bpc" id="L1234" title="1 of 2 branches missed.">            for (PolicyEntry entry : pi.identityPolicyEntries) {</span>
<span class="nc" id="L1235">                addPermissions(perms, cs, principals, entry);</span>
<span class="nc" id="L1236">            }</span>
<span class="pc" id="L1237">        }</span>

        // now see if any of the keys are trusted ids.
<span class="pc bpc" id="L1240" title="1 of 2 branches missed.">        if (!ignoreIdentityScope) {</span>
<span class="fc" id="L1241">            Certificate certs[] = cs.getCertificates();</span>
<span class="fc bfc" id="L1242" title="All 2 branches covered.">            if (certs != null) {</span>
<span class="pc bpc" id="L1243" title="1 of 2 branches missed.">                for (int k=0; k &lt; certs.length; k++) {</span>
<span class="nc" id="L1244">                    Object idMap = pi.aliasMapping.get(certs[k]);</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">                    if (idMap == null &amp;&amp;</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">                        checkForTrustedIdentity(certs[k], pi)) {</span>
                        // checkForTrustedIdentity added it
                        // to the policy for us. next time
                        // around we'll find it. This time
                        // around we need to add it.
<span class="nc" id="L1251">                        perms.add(SecurityConstants.ALL_PERMISSION);</span>
                    }
                }
            }
        }
<span class="fc" id="L1256">        return perms;</span>
    }

    private void addPermissions(Permissions perms,
        final CodeSource cs,
        Principal[] principals,
        final PolicyEntry entry) {

<span class="fc bfc" id="L1264" title="All 2 branches covered.">        if (debug != null) {</span>
<span class="fc" id="L1265">            debug.println(&quot;evaluate codesources:\n&quot; +</span>
<span class="fc" id="L1266">                &quot;\tPolicy CodeSource: &quot; + entry.getCodeSource() + &quot;\n&quot; +</span>
                &quot;\tActive CodeSource: &quot; + cs);
        }

        // check to see if the CodeSource implies
<span class="fc" id="L1271">        Boolean imp = AccessController.doPrivileged</span>
<span class="fc" id="L1272">            (new PrivilegedAction&lt;Boolean&gt;() {</span>
            public Boolean run() {
<span class="fc" id="L1274">                return new Boolean(entry.getCodeSource().implies(cs));</span>
            }
        });
<span class="fc bfc" id="L1277" title="All 2 branches covered.">        if (!imp.booleanValue()) {</span>
<span class="fc bfc" id="L1278" title="All 2 branches covered.">            if (debug != null) {</span>
<span class="fc" id="L1279">                debug.println(&quot;evaluation (codesource) failed&quot;);</span>
            }

            // CodeSource does not imply - return and try next policy entry
<span class="fc" id="L1283">            return;</span>
        }

        // check to see if the Principals imply

<span class="fc" id="L1288">        List&lt;PolicyParser.PrincipalEntry&gt; entryPs = entry.getPrincipals();</span>
<span class="fc bfc" id="L1289" title="All 2 branches covered.">        if (debug != null) {</span>
<span class="fc" id="L1290">            List&lt;PolicyParser.PrincipalEntry&gt; accPs = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1291" title="1 of 2 branches missed.">            if (principals != null) {</span>
<span class="fc bfc" id="L1292" title="All 2 branches covered.">                for (int i = 0; i &lt; principals.length; i++) {</span>
<span class="fc" id="L1293">                    accPs.add(new PolicyParser.PrincipalEntry</span>
<span class="fc" id="L1294">                                        (principals[i].getClass().getName(),</span>
<span class="fc" id="L1295">                                        principals[i].getName()));</span>
                }
            }
<span class="fc" id="L1298">            debug.println(&quot;evaluate principals:\n&quot; +</span>
                &quot;\tPolicy Principals: &quot; + entryPs + &quot;\n&quot; +
                &quot;\tActive Principals: &quot; + accPs);
        }

<span class="pc bpc" id="L1303" title="1 of 4 branches missed.">        if (entryPs == null || entryPs.isEmpty()) {</span>

            // policy entry has no principals -
            // add perms regardless of principals in current ACC

<span class="fc" id="L1308">            addPerms(perms, principals, entry);</span>
<span class="fc bfc" id="L1309" title="All 2 branches covered.">            if (debug != null) {</span>
<span class="fc" id="L1310">                debug.println(&quot;evaluation (codesource/principals) passed&quot;);</span>
            }
<span class="fc" id="L1312">            return;</span>

<span class="pc bpc" id="L1314" title="1 of 4 branches missed.">        } else if (principals == null || principals.length == 0) {</span>

            // current thread has no principals but this policy entry
            // has principals - perms are not added

<span class="pc bpc" id="L1319" title="1 of 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L1320">                debug.println(&quot;evaluation (principals) failed&quot;);</span>
            }
<span class="fc" id="L1322">            return;</span>
        }

        // current thread has principals and this policy entry
        // has principals.  see if policy entry principals match
        // principals in current ACC

<span class="fc bfc" id="L1329" title="All 2 branches covered.">        for (PolicyParser.PrincipalEntry pppe : entryPs) {</span>

            // Check for wildcards
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">            if (pppe.isWildcardClass()) {</span>
                // a wildcard class matches all principals in current ACC
<span class="nc" id="L1334">                continue;</span>
            }

<span class="fc bfc" id="L1337" title="All 2 branches covered.">            if (pppe.isWildcardName()) {</span>
                // a wildcard name matches any principal with the same class
<span class="pc bpc" id="L1339" title="1 of 2 branches missed.">                if (wildcardPrincipalNameImplies(pppe.principalClass,</span>
                                                 principals)) {
<span class="fc" id="L1341">                    continue;</span>
                }
<span class="nc bnc" id="L1343" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L1344">                    debug.println(&quot;evaluation (principal name wildcard) failed&quot;);</span>
                }
                // policy entry principal not in current ACC -
                // immediately return and go to next policy entry
<span class="nc" id="L1348">                return;</span>
            }

<span class="fc" id="L1351">            Set&lt;Principal&gt; pSet = new HashSet&lt;&gt;(Arrays.asList(principals));</span>
<span class="fc" id="L1352">            Subject subject = new Subject(true, pSet,</span>
                                          Collections.EMPTY_SET,
                                          Collections.EMPTY_SET);
            try {
<span class="fc" id="L1356">                ClassLoader cl = Thread.currentThread().getContextClassLoader();</span>
<span class="fc" id="L1357">                Class&lt;?&gt; pClass = Class.forName(pppe.principalClass, false, cl);</span>
<span class="pc bpc" id="L1358" title="1 of 2 branches missed.">                if (!Principal.class.isAssignableFrom(pClass)) {</span>
                    // not the right subtype
<span class="nc" id="L1360">                    throw new ClassCastException(pppe.principalClass +</span>
                                                 &quot; is not a Principal&quot;);
                }

<span class="fc" id="L1364">                Constructor&lt;?&gt; c = pClass.getConstructor(PARAMS1);</span>
<span class="fc" id="L1365">                Principal p = (Principal)c.newInstance(new Object[] {</span>
                                                       pppe.principalName });

<span class="fc bfc" id="L1368" title="All 2 branches covered.">                if (debug != null) {</span>
<span class="fc" id="L1369">                    debug.println(&quot;found Principal &quot; + p.getClass().getName());</span>
                }

                // check if the Principal implies the current
                // thread's principals
<span class="fc bfc" id="L1374" title="All 2 branches covered.">                if (!p.implies(subject)) {</span>
<span class="pc bpc" id="L1375" title="1 of 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L1376">                        debug.println(&quot;evaluation (principal implies) failed&quot;);</span>
                    }

                    // policy principal does not imply the current Subject -
                    // immediately return and go to next policy entry
<span class="fc" id="L1381">                    return;</span>
                }
<span class="nc" id="L1383">            } catch (Exception e) {</span>
                // fall back to default principal comparison.
                // see if policy entry principal is in current ACC

<span class="nc bnc" id="L1387" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L1388">                    e.printStackTrace();</span>
                }

<span class="nc bnc" id="L1391" title="All 2 branches missed.">                if (!pppe.implies(subject)) {</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L1393">                        debug.println(&quot;evaluation (default principal implies) failed&quot;);</span>
                    }

                    // policy entry principal not in current ACC -
                    // immediately return and go to next policy entry
<span class="nc" id="L1398">                    return;</span>
                }
<span class="fc" id="L1400">            }</span>

            // either the principal information matched,
            // or the Principal.implies succeeded.
            // continue loop and test the next policy principal
<span class="fc" id="L1405">        }</span>

        // all policy entry principals were found in the current ACC -
        // grant the policy permissions

<span class="fc bfc" id="L1410" title="All 2 branches covered.">        if (debug != null) {</span>
<span class="fc" id="L1411">            debug.println(&quot;evaluation (codesource/principals) passed&quot;);</span>
        }
<span class="fc" id="L1413">        addPerms(perms, principals, entry);</span>
<span class="fc" id="L1414">    }</span>

    /**
     * Returns true if the array of principals contains at least one
     * principal of the specified class.
     */
    private static boolean wildcardPrincipalNameImplies(String principalClass,
                                                        Principal[] principals)
    {
<span class="pc bpc" id="L1423" title="1 of 2 branches missed.">        for (Principal p : principals) {</span>
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">            if (principalClass.equals(p.getClass().getName())) {</span>
<span class="fc" id="L1425">                return true;</span>
            }
        }
<span class="nc" id="L1428">        return false;</span>
    }

    private void addPerms(Permissions perms,
                        Principal[] accPs,
                        PolicyEntry entry) {
<span class="fc bfc" id="L1434" title="All 2 branches covered.">        for (int i = 0; i &lt; entry.permissions.size(); i++) {</span>
<span class="fc" id="L1435">            Permission p = entry.permissions.get(i);</span>
<span class="fc bfc" id="L1436" title="All 2 branches covered.">            if (debug != null) {</span>
<span class="fc" id="L1437">                debug.println(&quot;  granting &quot; + p);</span>
            }

<span class="fc bfc" id="L1440" title="All 2 branches covered.">            if (p instanceof SelfPermission) {</span>
                // handle &quot;SELF&quot; permissions
<span class="fc" id="L1442">                expandSelf((SelfPermission)p,</span>
<span class="fc" id="L1443">                        entry.getPrincipals(),</span>
                        accPs,
                        perms);
            } else {
<span class="fc" id="L1447">                perms.add(p);</span>
            }
        }
<span class="fc" id="L1450">    }</span>

    /**
     * &lt;p&gt;
     *
     * @param sp the SelfPermission that needs to be expanded &lt;p&gt;
     *
     * @param entryPs list of principals for the Policy entry.
     *
     * @param pdp Principal array from the current ProtectionDomain.
     *
     * @param perms the PermissionCollection where the individual
     *                  Permissions will be added after expansion.
     */

    private void expandSelf(SelfPermission sp,
                            List&lt;PolicyParser.PrincipalEntry&gt; entryPs,
                            Principal[] pdp,
                            Permissions perms) {

<span class="pc bpc" id="L1470" title="2 of 4 branches missed.">        if (entryPs == null || entryPs.isEmpty()) {</span>
            // No principals in the grant to substitute
<span class="nc bnc" id="L1472" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L1473">                debug.println(&quot;Ignoring permission &quot;</span>
<span class="nc" id="L1474">                                + sp.getSelfType()</span>
                                + &quot; with target name (&quot;
<span class="nc" id="L1476">                                + sp.getSelfName() + &quot;).  &quot;</span>
                                + &quot;No Principal(s) specified &quot;
                                + &quot;in the grant clause.  &quot;
                                + &quot;SELF-based target names are &quot;
                                + &quot;only valid in the context &quot;
                                + &quot;of a Principal-based grant entry.&quot;
                             );
            }
<span class="nc" id="L1484">            return;</span>
        }
<span class="fc" id="L1486">        int startIndex = 0;</span>
        int v;
<span class="fc" id="L1488">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L1489" title="All 2 branches covered.">        while ((v = sp.getSelfName().indexOf(SELF, startIndex)) != -1) {</span>

            // add non-SELF string
<span class="fc" id="L1492">            sb.append(sp.getSelfName().substring(startIndex, v));</span>

            // expand SELF
<span class="fc" id="L1495">            Iterator&lt;PolicyParser.PrincipalEntry&gt; pli = entryPs.iterator();</span>
<span class="fc bfc" id="L1496" title="All 2 branches covered.">            while (pli.hasNext()) {</span>
<span class="fc" id="L1497">                PolicyParser.PrincipalEntry pppe = pli.next();</span>
<span class="fc" id="L1498">                String[][] principalInfo = getPrincipalInfo(pppe,pdp);</span>
<span class="fc bfc" id="L1499" title="All 2 branches covered.">                for (int i = 0; i &lt; principalInfo.length; i++) {</span>
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">                    if (i != 0) {</span>
<span class="nc" id="L1501">                        sb.append(&quot;, &quot;);</span>
                    }
<span class="fc" id="L1503">                    sb.append(principalInfo[i][0] + &quot; &quot; +</span>
                        &quot;\&quot;&quot; + principalInfo[i][1] + &quot;\&quot;&quot;);
                }
<span class="pc bpc" id="L1506" title="1 of 2 branches missed.">                if (pli.hasNext()) {</span>
<span class="nc" id="L1507">                    sb.append(&quot;, &quot;);</span>
                }
<span class="fc" id="L1509">            }</span>
<span class="fc" id="L1510">            startIndex = v + SELF.length();</span>
<span class="fc" id="L1511">        }</span>
        // add remaining string (might be the entire string)
<span class="fc" id="L1513">        sb.append(sp.getSelfName().substring(startIndex));</span>

<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L1516">            debug.println(&quot;  expanded:\n\t&quot; + sp.getSelfName()</span>
<span class="nc" id="L1517">                        + &quot;\n  into:\n\t&quot; + sb.toString());</span>
        }
        try {
            // first try to instantiate the permission
<span class="fc" id="L1521">            perms.add(getInstance(sp.getSelfType(),</span>
<span class="fc" id="L1522">                                  sb.toString(),</span>
<span class="fc" id="L1523">                                  sp.getSelfActions()));</span>
<span class="nc" id="L1524">        } catch (ClassNotFoundException cnfe) {</span>
            // ok, the permission is not in the bootclasspath.
            // before we add an UnresolvedPermission, check to see
            // whether this perm already belongs to the collection.
            // if so, use that perm's ClassLoader to create a new
            // one.
<span class="nc" id="L1530">            Class&lt;?&gt; pc = null;</span>
<span class="nc" id="L1531">            synchronized (perms) {</span>
<span class="nc" id="L1532">                Enumeration&lt;Permission&gt; e = perms.elements();</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">                while (e.hasMoreElements()) {</span>
<span class="nc" id="L1534">                    Permission pElement = e.nextElement();</span>
<span class="nc bnc" id="L1535" title="All 2 branches missed.">                    if (pElement.getClass().getName().equals(sp.getSelfType())) {</span>
<span class="nc" id="L1536">                        pc = pElement.getClass();</span>
<span class="nc" id="L1537">                        break;</span>
                    }
<span class="nc" id="L1539">                }</span>
<span class="nc" id="L1540">            }</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">            if (pc == null) {</span>
                // create an UnresolvedPermission
<span class="nc" id="L1543">                perms.add(new UnresolvedPermission(sp.getSelfType(),</span>
<span class="nc" id="L1544">                                                        sb.toString(),</span>
<span class="nc" id="L1545">                                                        sp.getSelfActions(),</span>
<span class="nc" id="L1546">                                                        sp.getCerts()));</span>
            } else {
                try {
                    // we found an instantiated permission.
                    // use its class loader to instantiate a new permission.
                    Constructor&lt;?&gt; c;
                    // name parameter can not be null
<span class="nc bnc" id="L1553" title="All 2 branches missed.">                    if (sp.getSelfActions() == null) {</span>
                        try {
<span class="nc" id="L1555">                            c = pc.getConstructor(PARAMS1);</span>
<span class="nc" id="L1556">                            perms.add((Permission)c.newInstance</span>
<span class="nc" id="L1557">                                 (new Object[] {sb.toString()}));</span>
<span class="nc" id="L1558">                        } catch (NoSuchMethodException ne) {</span>
<span class="nc" id="L1559">                            c = pc.getConstructor(PARAMS2);</span>
<span class="nc" id="L1560">                            perms.add((Permission)c.newInstance</span>
<span class="nc" id="L1561">                                 (new Object[] {sb.toString(),</span>
<span class="nc" id="L1562">                                                sp.getSelfActions() }));</span>
<span class="nc" id="L1563">                        }</span>
                    } else {
<span class="nc" id="L1565">                        c = pc.getConstructor(PARAMS2);</span>
<span class="nc" id="L1566">                        perms.add((Permission)c.newInstance</span>
<span class="nc" id="L1567">                           (new Object[] {sb.toString(),</span>
<span class="nc" id="L1568">                                          sp.getSelfActions()}));</span>
                    }
<span class="nc" id="L1570">                } catch (Exception nme) {</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L1572">                        debug.println(&quot;self entry expansion &quot; +</span>
                        &quot; instantiation failed: &quot;
<span class="nc" id="L1574">                        +  nme.toString());</span>
                    }
<span class="nc" id="L1576">                }</span>
            }
<span class="nc" id="L1578">        } catch (Exception e) {</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L1580">                debug.println(e.toString());</span>
            }
<span class="pc" id="L1582">        }</span>
<span class="fc" id="L1583">    }</span>

    /**
     * return the principal class/name pair in the 2D array.
     * array[x][y]:     x corresponds to the array length.
     *                  if (y == 0), it's the principal class.
     *                  if (y == 1), it's the principal name.
     */
    private String[][] getPrincipalInfo
        (PolicyParser.PrincipalEntry pe, Principal[] pdp) {

        // there are 3 possibilities:
        // 1) the entry's Principal class and name are not wildcarded
        // 2) the entry's Principal name is wildcarded only
        // 3) the entry's Principal class and name are wildcarded

<span class="pc bpc" id="L1599" title="2 of 4 branches missed.">        if (!pe.isWildcardClass() &amp;&amp; !pe.isWildcardName()) {</span>

            // build an info array for the principal
            // from the Policy entry
<span class="fc" id="L1603">            String[][] info = new String[1][2];</span>
<span class="fc" id="L1604">            info[0][0] = pe.principalClass;</span>
<span class="fc" id="L1605">            info[0][1] = pe.principalName;</span>
<span class="fc" id="L1606">            return info;</span>

<span class="nc bnc" id="L1608" title="All 4 branches missed.">        } else if (!pe.isWildcardClass() &amp;&amp; pe.isWildcardName()) {</span>

            // build an info array for every principal
            // in the current domain which has a principal class
            // that is equal to policy entry principal class name
<span class="nc" id="L1613">            List&lt;Principal&gt; plist = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">            for (int i = 0; i &lt; pdp.length; i++) {</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">                if (pe.principalClass.equals(pdp[i].getClass().getName()))</span>
<span class="nc" id="L1616">                    plist.add(pdp[i]);</span>
            }
<span class="nc" id="L1618">            String[][] info = new String[plist.size()][2];</span>
<span class="nc" id="L1619">            int i = 0;</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">            for (Principal p : plist) {</span>
<span class="nc" id="L1621">                info[i][0] = p.getClass().getName();</span>
<span class="nc" id="L1622">                info[i][1] = p.getName();</span>
<span class="nc" id="L1623">                i++;</span>
<span class="nc" id="L1624">            }</span>
<span class="nc" id="L1625">            return info;</span>

        } else {

            // build an info array for every
            // one of the current Domain's principals

<span class="nc" id="L1632">            String[][] info = new String[pdp.length][2];</span>

<span class="nc bnc" id="L1634" title="All 2 branches missed.">            for (int i = 0; i &lt; pdp.length; i++) {</span>
<span class="nc" id="L1635">                info[i][0] = pdp[i].getClass().getName();</span>
<span class="nc" id="L1636">                info[i][1] = pdp[i].getName();</span>
            }
<span class="nc" id="L1638">            return info;</span>
        }
    }

    /*
     * Returns the signer certificates from the list of certificates
     * associated with the given code source.
     *
     * The signer certificates are those certificates that were used
     * to verifysigned code originating from the codesource location.
     *
     * This method assumes that in the given code source, each signer
     * certificate is followed by its supporting certificate chain
     * (which may be empty), and that the signer certificate and its
     * supporting certificate chain are ordered bottom-to-top
     * (i.e., with the signer certificate first and the (root) certificate
     * authority last).
     */
    protected Certificate[] getSignerCertificates(CodeSource cs) {
<span class="fc" id="L1657">        Certificate[] certs = null;</span>
<span class="fc bfc" id="L1658" title="All 2 branches covered.">        if ((certs = cs.getCertificates()) == null)</span>
<span class="fc" id="L1659">            return null;</span>
<span class="pc bpc" id="L1660" title="1 of 2 branches missed.">        for (int i=0; i&lt;certs.length; i++) {</span>
<span class="nc bnc" id="L1661" title="All 2 branches missed.">            if (!(certs[i] instanceof X509Certificate))</span>
<span class="nc" id="L1662">                return cs.getCertificates();</span>
        }

        // Do we have to do anything?
<span class="fc" id="L1666">        int i = 0;</span>
<span class="fc" id="L1667">        int count = 0;</span>
<span class="pc bpc" id="L1668" title="1 of 2 branches missed.">        while (i &lt; certs.length) {</span>
<span class="nc" id="L1669">            count++;</span>
<span class="nc bnc" id="L1670" title="All 2 branches missed.">            while (((i+1) &lt; certs.length)</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">                   &amp;&amp; ((X509Certificate)certs[i]).getIssuerDN().equals(</span>
<span class="nc" id="L1672">                           ((X509Certificate)certs[i+1]).getSubjectDN())) {</span>
<span class="nc" id="L1673">                i++;</span>
            }
<span class="nc" id="L1675">            i++;</span>
        }
<span class="pc bpc" id="L1677" title="1 of 2 branches missed.">        if (count == certs.length)</span>
            // Done
<span class="fc" id="L1679">            return certs;</span>

<span class="nc" id="L1681">        List&lt;Certificate&gt; userCertList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1682">        i = 0;</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">        while (i &lt; certs.length) {</span>
<span class="nc" id="L1684">            userCertList.add(certs[i]);</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">            while (((i+1) &lt; certs.length)</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">                   &amp;&amp; ((X509Certificate)certs[i]).getIssuerDN().equals(</span>
<span class="nc" id="L1687">                           ((X509Certificate)certs[i+1]).getSubjectDN())) {</span>
<span class="nc" id="L1688">                i++;</span>
            }
<span class="nc" id="L1690">            i++;</span>
        }
<span class="nc" id="L1692">        Certificate[] userCerts = new Certificate[userCertList.size()];</span>
<span class="nc" id="L1693">        userCertList.toArray(userCerts);</span>
<span class="nc" id="L1694">        return userCerts;</span>
    }

    private CodeSource canonicalizeCodebase(CodeSource cs,
                                            boolean extractSignerCerts) {

<span class="fc" id="L1700">        String path = null;</span>

<span class="fc" id="L1702">        CodeSource canonCs = cs;</span>
<span class="fc" id="L1703">        URL u = cs.getLocation();</span>
<span class="fc bfc" id="L1704" title="All 2 branches covered.">        if (u != null) {</span>
<span class="fc bfc" id="L1705" title="All 2 branches covered.">            if (u.getProtocol().equals(&quot;jar&quot;)) {</span>
                // unwrap url embedded inside jar url
<span class="fc" id="L1707">                String spec = u.getFile();</span>
<span class="fc" id="L1708">                int separator = spec.indexOf(&quot;!/&quot;);</span>
<span class="pc bpc" id="L1709" title="1 of 2 branches missed.">                if (separator != -1) {</span>
                    try {
<span class="fc" id="L1711">                        u = new URL(spec.substring(0, separator));</span>
<span class="nc" id="L1712">                    } catch (MalformedURLException e) {</span>
                        // Fail silently. In this case, url stays what
                        // it was above
<span class="fc" id="L1715">                    }</span>
                }
            }
<span class="fc bfc" id="L1718" title="All 2 branches covered.">            if (u.getProtocol().equals(&quot;file&quot;)) {</span>
<span class="fc" id="L1719">                boolean isLocalFile = false;</span>
<span class="fc" id="L1720">                String host = u.getHost();</span>
<span class="pc bpc" id="L1721" title="2 of 4 branches missed.">                isLocalFile = (host == null || host.equals(&quot;&quot;) ||</span>
<span class="pc bnc" id="L1722" title="All 4 branches missed.">                    host.equals(&quot;~&quot;) || host.equalsIgnoreCase(&quot;localhost&quot;));</span>

<span class="pc bpc" id="L1724" title="1 of 2 branches missed.">                if (isLocalFile) {</span>
<span class="fc" id="L1725">                    path = u.getFile().replace('/', File.separatorChar);</span>
<span class="fc" id="L1726">                    path = ParseUtil.decode(path);</span>
                }
            }
        }

<span class="fc bfc" id="L1731" title="All 2 branches covered.">        if (path != null) {</span>
            try {
<span class="fc" id="L1733">                URL csUrl = null;</span>
<span class="fc" id="L1734">                path = canonPath(path);</span>
<span class="fc" id="L1735">                csUrl = ParseUtil.fileToEncodedURL(new File(path));</span>

<span class="fc bfc" id="L1737" title="All 2 branches covered.">                if (extractSignerCerts) {</span>
<span class="fc" id="L1738">                    canonCs = new CodeSource(csUrl,</span>
<span class="fc" id="L1739">                                             getSignerCertificates(cs));</span>
                } else {
<span class="fc" id="L1741">                    canonCs = new CodeSource(csUrl,</span>
<span class="fc" id="L1742">                                             cs.getCertificates());</span>
                }
<span class="nc" id="L1744">            } catch (IOException ioe) {</span>
                // leave codesource as it is, unless we have to extract its
                // signer certificates
<span class="nc bnc" id="L1747" title="All 2 branches missed.">                if (extractSignerCerts) {</span>
<span class="nc" id="L1748">                    canonCs = new CodeSource(cs.getLocation(),</span>
<span class="nc" id="L1749">                                             getSignerCertificates(cs));</span>
                }
<span class="pc" id="L1751">            }</span>
        } else {
<span class="fc bfc" id="L1753" title="All 2 branches covered.">            if (extractSignerCerts) {</span>
<span class="fc" id="L1754">                canonCs = new CodeSource(cs.getLocation(),</span>
<span class="fc" id="L1755">                                         getSignerCertificates(cs));</span>
            }
        }
<span class="fc" id="L1758">        return canonCs;</span>
    }

    // Wrapper to return a canonical path that avoids calling getCanonicalPath()
    // with paths that are intended to match all entries in the directory
    private static String canonPath(String path) throws IOException {
<span class="fc bfc" id="L1764" title="All 2 branches covered.">        if (path.endsWith(&quot;*&quot;)) {</span>
<span class="fc" id="L1765">            path = path.substring(0, path.length()-1) + &quot;-&quot;;</span>
<span class="fc" id="L1766">            path = new File(path).getCanonicalPath();</span>
<span class="fc" id="L1767">            return path.substring(0, path.length()-1) + &quot;*&quot;;</span>
        } else {
<span class="fc" id="L1769">            return new File(path).getCanonicalPath();</span>
        }
    }

    private String printPD(ProtectionDomain pd) {
<span class="fc" id="L1774">        Principal[] principals = pd.getPrincipals();</span>
<span class="fc" id="L1775">        String pals = &quot;&lt;no principals&gt;&quot;;</span>
<span class="pc bpc" id="L1776" title="1 of 4 branches missed.">        if (principals != null &amp;&amp; principals.length &gt; 0) {</span>
<span class="fc" id="L1777">            StringBuilder palBuf = new StringBuilder(&quot;(principals &quot;);</span>
<span class="fc bfc" id="L1778" title="All 2 branches covered.">            for (int i = 0; i &lt; principals.length; i++) {</span>
<span class="fc" id="L1779">                palBuf.append(principals[i].getClass().getName() +</span>
<span class="fc" id="L1780">                              &quot; \&quot;&quot; + principals[i].getName() +</span>
                              &quot;\&quot;&quot;);
<span class="pc bpc" id="L1782" title="1 of 2 branches missed.">                if (i &lt; principals.length-1)</span>
<span class="nc" id="L1783">                    palBuf.append(&quot;, &quot;);</span>
                else
<span class="fc" id="L1785">                    palBuf.append(&quot;)&quot;);</span>
            }
<span class="fc" id="L1787">            pals = palBuf.toString();</span>
        }
<span class="fc" id="L1789">        return &quot;PD CodeSource: &quot;</span>
<span class="fc" id="L1790">                + pd.getCodeSource()</span>
                +&quot;\n\t&quot; + &quot;PD ClassLoader: &quot;
<span class="fc" id="L1792">                + pd.getClassLoader()</span>
                +&quot;\n\t&quot; + &quot;PD Principals: &quot;
                + pals;
    }

    /**
     * return true if no replacement was performed,
     * or if replacement succeeded.
     */
    private boolean replacePrincipals(
        List&lt;PolicyParser.PrincipalEntry&gt; principals, KeyStore keystore) {

<span class="pc bpc" id="L1804" title="1 of 6 branches missed.">        if (principals == null || principals.isEmpty() || keystore == null)</span>
<span class="fc" id="L1805">            return true;</span>

<span class="fc bfc" id="L1807" title="All 2 branches covered.">        for (PolicyParser.PrincipalEntry pppe : principals) {</span>
<span class="fc bfc" id="L1808" title="All 2 branches covered.">            if (pppe.isReplaceName()) {</span>

                // perform replacement
                // (only X509 replacement is possible now)
                String name;
<span class="pc bpc" id="L1813" title="1 of 2 branches missed.">                if ((name = getDN(pppe.principalName, keystore)) == null) {</span>
<span class="nc" id="L1814">                    return false;</span>
                }

<span class="pc bpc" id="L1817" title="1 of 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L1818">                    debug.println(&quot;  Replacing \&quot;&quot; +</span>
                        pppe.principalName +
                        &quot;\&quot; with &quot; +
                        X500PRINCIPAL + &quot;/\&quot;&quot; +
                        name +
                        &quot;\&quot;&quot;);
                }

<span class="fc" id="L1826">                pppe.principalClass = X500PRINCIPAL;</span>
<span class="fc" id="L1827">                pppe.principalName = name;</span>
            }
<span class="fc" id="L1829">        }</span>
        // return true if no replacement was performed,
        // or if replacement succeeded
<span class="fc" id="L1832">        return true;</span>
    }

    private void expandPermissionName(PolicyParser.PermissionEntry pe,
                                        KeyStore keystore) throws Exception {
        // short cut the common case
<span class="fc bfc" id="L1838" title="All 4 branches covered.">        if (pe.name == null || pe.name.indexOf(&quot;${{&quot;, 0) == -1) {</span>
<span class="fc" id="L1839">            return;</span>
        }

<span class="fc" id="L1842">        int startIndex = 0;</span>
        int b, e;
<span class="fc" id="L1844">        StringBuilder sb = new StringBuilder();</span>
<span class="fc bfc" id="L1845" title="All 2 branches covered.">        while ((b = pe.name.indexOf(&quot;${{&quot;, startIndex)) != -1) {</span>
<span class="fc" id="L1846">            e = pe.name.indexOf(&quot;}}&quot;, b);</span>
<span class="pc bpc" id="L1847" title="1 of 2 branches missed.">            if (e &lt; 1) {</span>
<span class="nc" id="L1848">                break;</span>
            }
<span class="fc" id="L1850">            sb.append(pe.name.substring(startIndex, b));</span>

            // get the value in ${{...}}
<span class="fc" id="L1853">            String value = pe.name.substring(b+3, e);</span>

            // parse up to the first ':'
            int colonIndex;
<span class="fc" id="L1857">            String prefix = value;</span>
            String suffix;
<span class="fc bfc" id="L1859" title="All 2 branches covered.">            if ((colonIndex = value.indexOf(&quot;:&quot;)) != -1) {</span>
<span class="fc" id="L1860">                prefix = value.substring(0, colonIndex);</span>
            }

            // handle different prefix possibilities
<span class="fc bfc" id="L1864" title="All 2 branches covered.">            if (prefix.equalsIgnoreCase(&quot;self&quot;)) {</span>
                // do nothing - handled later
<span class="fc" id="L1866">                sb.append(pe.name.substring(b, e+2));</span>
<span class="fc" id="L1867">                startIndex = e+2;</span>
<span class="fc" id="L1868">                continue;</span>
<span class="fc bfc" id="L1869" title="All 2 branches covered.">            } else if (prefix.equalsIgnoreCase(&quot;alias&quot;)) {</span>
                // get the suffix and perform keystore alias replacement
<span class="fc bfc" id="L1871" title="All 2 branches covered.">                if (colonIndex == -1) {</span>
<span class="fc" id="L1872">                    MessageFormat form = new MessageFormat</span>
                        (ResourcesMgr.getString
<span class="fc" id="L1874">                        (&quot;alias.name.not.provided.pe.name.&quot;));</span>
<span class="fc" id="L1875">                    Object[] source = {pe.name};</span>
<span class="fc" id="L1876">                    throw new Exception(form.format(source));</span>
                }
<span class="fc" id="L1878">                suffix = value.substring(colonIndex+1);</span>
<span class="fc bfc" id="L1879" title="All 2 branches covered.">                if ((suffix = getDN(suffix, keystore)) == null) {</span>
<span class="fc" id="L1880">                    MessageFormat form = new MessageFormat</span>
                        (ResourcesMgr.getString
<span class="fc" id="L1882">                        (&quot;unable.to.perform.substitution.on.alias.suffix&quot;));</span>
<span class="fc" id="L1883">                    Object[] source = {value.substring(colonIndex+1)};</span>
<span class="fc" id="L1884">                    throw new Exception(form.format(source));</span>
                }

<span class="fc" id="L1887">                sb.append(X500PRINCIPAL + &quot; \&quot;&quot; + suffix + &quot;\&quot;&quot;);</span>
<span class="fc" id="L1888">                startIndex = e+2;</span>
            } else {
<span class="fc" id="L1890">                MessageFormat form = new MessageFormat</span>
                        (ResourcesMgr.getString
<span class="fc" id="L1892">                        (&quot;substitution.value.prefix.unsupported&quot;));</span>
<span class="fc" id="L1893">                Object[] source = {prefix};</span>
<span class="fc" id="L1894">                throw new Exception(form.format(source));</span>
            }
<span class="fc" id="L1896">        }</span>

        // copy the rest of the value
<span class="fc" id="L1899">        sb.append(pe.name.substring(startIndex));</span>

        // replace the name with expanded value
<span class="pc bpc" id="L1902" title="1 of 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L1903">            debug.println(&quot;  Permission name expanded from:\n\t&quot; +</span>
<span class="nc" id="L1904">                        pe.name + &quot;\nto\n\t&quot; + sb.toString());</span>
        }
<span class="fc" id="L1906">        pe.name = sb.toString();</span>
<span class="fc" id="L1907">    }</span>

    private String getDN(String alias, KeyStore keystore) {
<span class="fc" id="L1910">        Certificate cert = null;</span>
        try {
<span class="fc" id="L1912">            cert = keystore.getCertificate(alias);</span>
<span class="nc" id="L1913">        } catch (Exception e) {</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L1915">                debug.println(&quot;  Error retrieving certificate for '&quot; +</span>
                                alias +
                                &quot;': &quot; +
<span class="nc" id="L1918">                                e.toString());</span>
            }
<span class="nc" id="L1920">            return null;</span>
<span class="fc" id="L1921">        }</span>

<span class="pc bpc" id="L1923" title="1 of 4 branches missed.">        if (cert == null || !(cert instanceof X509Certificate)) {</span>
<span class="pc bpc" id="L1924" title="1 of 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L1925">                debug.println(&quot;  -- No certificate for '&quot; +</span>
                                alias +
                                &quot;' - ignoring entry&quot;);
            }
<span class="fc" id="L1929">            return null;</span>
        } else {
<span class="fc" id="L1931">            X509Certificate x509Cert = (X509Certificate)cert;</span>

            // 4702543:  X500 names with an EmailAddress
            // were encoded incorrectly.  create new
            // X500Principal name with correct encoding

<span class="fc" id="L1937">            X500Principal p = new X500Principal</span>
<span class="fc" id="L1938">                (x509Cert.getSubjectX500Principal().toString());</span>
<span class="fc" id="L1939">            return p.getName();</span>
        }
    }

    /**
     * Checks public key. If it is marked as trusted in
     * the identity database, add it to the policy
     * with the AllPermission.
     */
    private boolean checkForTrustedIdentity(final Certificate cert,
        PolicyInfo myInfo)
    {
<span class="nc" id="L1951">        return false;</span>
    }

    /**
     * Each entry in the policy configuration file is represented by a
     * PolicyEntry object.  &lt;p&gt;
     *
     * A PolicyEntry is a (CodeSource,Permission) pair.  The
     * CodeSource contains the (URL, PublicKey) that together identify
     * where the Java bytecodes come from and who (if anyone) signed
     * them.  The URL could refer to localhost.  The URL could also be
     * null, meaning that this policy entry is given to all comers, as
     * long as they match the signer field.  The signer could be null,
     * meaning the code is not signed. &lt;p&gt;
     *
     * The Permission contains the (Type, Name, Action) triplet. &lt;p&gt;
     *
     * For now, the Policy object retrieves the public key from the
     * X.509 certificate on disk that corresponds to the signedBy
     * alias specified in the Policy config file.  For reasons of
     * efficiency, the Policy object keeps a hashtable of certs already
     * read in.  This could be replaced by a secure internal key
     * store.
     *
     * &lt;p&gt;
     * For example, the entry
     * &lt;pre&gt;
     *          permission java.io.File &quot;/tmp&quot;, &quot;read,write&quot;,
     *          signedBy &quot;Duke&quot;;
     * &lt;/pre&gt;
     * is represented internally
     * &lt;pre&gt;
     *
     * FilePermission f = new FilePermission(&quot;/tmp&quot;, &quot;read,write&quot;);
     * PublicKey p = publickeys.get(&quot;Duke&quot;);
     * URL u = InetAddress.getLocalHost();
     * CodeBase c = new CodeBase( p, u );
     * pe = new PolicyEntry(f, c);
     * &lt;/pre&gt;
     *
     * @author Marianne Mueller
     * @author Roland Schemers
     * @see java.security.CodeSource
     * @see java.security.Policy
     * @see java.security.Permissions
     * @see java.security.ProtectionDomain
     */
    private static class PolicyEntry {

        private final CodeSource codesource;
        final List&lt;Permission&gt; permissions;
        private final List&lt;PolicyParser.PrincipalEntry&gt; principals;

        /**
         * Given a Permission and a CodeSource, create a policy entry.
         *
         * XXX Decide if/how to add validity fields and &quot;purpose&quot; fields to
         * XXX policy entries
         *
         * @param cs the CodeSource, which encapsulates the URL and the
         *        public key
         *        attributes from the policy config file. Validity checks
         *        are performed on the public key before PolicyEntry is
         *        called.
         *
         */
        PolicyEntry(CodeSource cs, List&lt;PolicyParser.PrincipalEntry&gt; principals)
<span class="fc" id="L2018">        {</span>
<span class="fc" id="L2019">            this.codesource = cs;</span>
<span class="fc" id="L2020">            this.permissions = new ArrayList&lt;Permission&gt;();</span>
<span class="fc" id="L2021">            this.principals = principals; // can be null</span>
<span class="fc" id="L2022">        }</span>

        PolicyEntry(CodeSource cs)
        {
<span class="nc" id="L2026">            this(cs, null);</span>
<span class="nc" id="L2027">        }</span>

        List&lt;PolicyParser.PrincipalEntry&gt; getPrincipals() {
<span class="fc" id="L2030">            return principals; // can be null</span>
        }

        /**
         * add a Permission object to this entry.
         * No need to sync add op because perms are added to entry only
         * while entry is being initialized
         */
        void add(Permission p) {
<span class="fc" id="L2039">            permissions.add(p);</span>
<span class="fc" id="L2040">        }</span>

        /**
         * Return the CodeSource for this policy entry
         */
        CodeSource getCodeSource() {
<span class="fc" id="L2046">            return codesource;</span>
        }

        @Override public String toString(){
<span class="nc" id="L2050">            StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L2051">            sb.append(ResourcesMgr.getString(&quot;LPARAM&quot;));</span>
<span class="nc" id="L2052">            sb.append(getCodeSource());</span>
<span class="nc" id="L2053">            sb.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">            for (int j = 0; j &lt; permissions.size(); j++) {</span>
<span class="nc" id="L2055">                Permission p = permissions.get(j);</span>
<span class="nc" id="L2056">                sb.append(ResourcesMgr.getString(&quot;SPACE&quot;));</span>
<span class="nc" id="L2057">                sb.append(ResourcesMgr.getString(&quot;SPACE&quot;));</span>
<span class="nc" id="L2058">                sb.append(p);</span>
<span class="nc" id="L2059">                sb.append(ResourcesMgr.getString(&quot;NEWLINE&quot;));</span>
            }
<span class="nc" id="L2061">            sb.append(ResourcesMgr.getString(&quot;RPARAM&quot;));</span>
<span class="nc" id="L2062">            sb.append(ResourcesMgr.getString(&quot;NEWLINE&quot;));</span>
<span class="nc" id="L2063">            return sb.toString();</span>
        }
    }

    private static class SelfPermission extends Permission {

        private static final long serialVersionUID = -8315562579967246806L;

        /**
         * The class name of the Permission class that will be
         * created when this self permission is expanded .
         *
         * @serial
         */
        private String type;

        /**
         * The permission name.
         *
         * @serial
         */
        private String name;

        /**
         * The actions of the permission.
         *
         * @serial
         */
        private String actions;

        /**
         * The certs of the permission.
         *
         * @serial
         */
        private Certificate certs[];

        /**
         * Creates a new SelfPermission containing the permission
         * information needed later to expand the self
         * @param type the class name of the Permission class that will be
         * created when this permission is expanded and if necessary resolved.
         * @param name the name of the permission.
         * @param actions the actions of the permission.
         * @param certs the certificates the permission's class was signed with.
         * This is a list of certificate chains, where each chain is composed of
         * a signer certificate and optionally its supporting certificate chain.
         * Each chain is ordered bottom-to-top (i.e., with the signer
         * certificate first and the (root) certificate authority last).
         */
        public SelfPermission(String type, String name, String actions,
                              Certificate certs[])
        {
<span class="fc" id="L2116">            super(type);</span>
<span class="pc bpc" id="L2117" title="1 of 2 branches missed.">            if (type == null) {</span>
<span class="nc" id="L2118">                throw new NullPointerException</span>
<span class="nc" id="L2119">                    (ResourcesMgr.getString(&quot;type.can.t.be.null&quot;));</span>
            }
<span class="fc" id="L2121">            this.type = type;</span>
<span class="fc" id="L2122">            this.name = name;</span>
<span class="fc" id="L2123">            this.actions = actions;</span>
<span class="pc bpc" id="L2124" title="1 of 2 branches missed.">            if (certs != null) {</span>
                // Extract the signer certs from the list of certificates.
<span class="nc bnc" id="L2126" title="All 2 branches missed.">                for (int i=0; i&lt;certs.length; i++) {</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">                    if (!(certs[i] instanceof X509Certificate)) {</span>
                        // there is no concept of signer certs, so we store the
                        // entire cert array
<span class="nc" id="L2130">                        this.certs = certs.clone();</span>
<span class="nc" id="L2131">                        break;</span>
                    }
                }

<span class="nc bnc" id="L2135" title="All 2 branches missed.">                if (this.certs == null) {</span>
                    // Go through the list of certs and see if all the certs are
                    // signer certs.
<span class="nc" id="L2138">                    int i = 0;</span>
<span class="nc" id="L2139">                    int count = 0;</span>
<span class="nc bnc" id="L2140" title="All 2 branches missed.">                    while (i &lt; certs.length) {</span>
<span class="nc" id="L2141">                        count++;</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">                        while (((i+1) &lt; certs.length) &amp;&amp;</span>
<span class="nc bnc" id="L2143" title="All 2 branches missed.">                            ((X509Certificate)certs[i]).getIssuerDN().equals(</span>
<span class="nc" id="L2144">                            ((X509Certificate)certs[i+1]).getSubjectDN())) {</span>
<span class="nc" id="L2145">                            i++;</span>
                        }
<span class="nc" id="L2147">                        i++;</span>
                    }
<span class="nc bnc" id="L2149" title="All 2 branches missed.">                    if (count == certs.length) {</span>
                        // All the certs are signer certs, so we store the
                        // entire array
<span class="nc" id="L2152">                        this.certs = certs.clone();</span>
                    }

<span class="nc bnc" id="L2155" title="All 2 branches missed.">                    if (this.certs == null) {</span>
                        // extract the signer certs
<span class="nc" id="L2157">                        List&lt;Certificate&gt; signerCerts = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2158">                        i = 0;</span>
<span class="nc bnc" id="L2159" title="All 2 branches missed.">                        while (i &lt; certs.length) {</span>
<span class="nc" id="L2160">                            signerCerts.add(certs[i]);</span>
<span class="nc bnc" id="L2161" title="All 2 branches missed.">                            while (((i+1) &lt; certs.length) &amp;&amp;</span>
<span class="nc bnc" id="L2162" title="All 2 branches missed.">                                ((X509Certificate)certs[i]).getIssuerDN().equals(</span>
<span class="nc" id="L2163">                                ((X509Certificate)certs[i+1]).getSubjectDN())) {</span>
<span class="nc" id="L2164">                                i++;</span>
                            }
<span class="nc" id="L2166">                            i++;</span>
                        }
<span class="nc" id="L2168">                        this.certs = new Certificate[signerCerts.size()];</span>
<span class="nc" id="L2169">                        signerCerts.toArray(this.certs);</span>
                    }
                }
            }
<span class="fc" id="L2173">        }</span>

        /**
         * This method always returns false for SelfPermission permissions.
         * That is, an SelfPermission never considered to
         * imply another permission.
         *
         * @param p the permission to check against.
         *
         * @return false.
         */
        @Override public boolean implies(Permission p) {
<span class="nc" id="L2185">            return false;</span>
        }

        /**
         * Checks two SelfPermission objects for equality.
         *
         * Checks that &lt;i&gt;obj&lt;/i&gt; is an SelfPermission, and has
         * the same type (class) name, permission name, actions, and
         * certificates as this object.
         *
         * @param obj the object we are testing for equality with this object.
         *
         * @return true if obj is an SelfPermission, and has the same
         * type (class) name, permission name, actions, and
         * certificates as this object.
         */
        @Override public boolean equals(Object obj) {
<span class="nc bnc" id="L2202" title="All 2 branches missed.">            if (obj == this)</span>
<span class="nc" id="L2203">                return true;</span>

<span class="nc bnc" id="L2205" title="All 2 branches missed.">            if (! (obj instanceof SelfPermission))</span>
<span class="nc" id="L2206">                return false;</span>
<span class="nc" id="L2207">            SelfPermission that = (SelfPermission) obj;</span>

<span class="nc bnc" id="L2209" title="All 2 branches missed.">            if (!(this.type.equals(that.type) &amp;&amp;</span>
<span class="nc bnc" id="L2210" title="All 2 branches missed.">                this.name.equals(that.name) &amp;&amp;</span>
<span class="nc bnc" id="L2211" title="All 2 branches missed.">                this.actions.equals(that.actions)))</span>
<span class="nc" id="L2212">                return false;</span>

<span class="nc bnc" id="L2214" title="All 2 branches missed.">            if (this.certs.length != that.certs.length)</span>
<span class="nc" id="L2215">                return false;</span>

            int i,j;
            boolean match;

<span class="nc bnc" id="L2220" title="All 2 branches missed.">            for (i = 0; i &lt; this.certs.length; i++) {</span>
<span class="nc" id="L2221">                match = false;</span>
<span class="nc bnc" id="L2222" title="All 2 branches missed.">                for (j = 0; j &lt; that.certs.length; j++) {</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">                    if (this.certs[i].equals(that.certs[j])) {</span>
<span class="nc" id="L2224">                        match = true;</span>
<span class="nc" id="L2225">                        break;</span>
                    }
                }
<span class="nc bnc" id="L2228" title="All 2 branches missed.">                if (!match) return false;</span>
            }

<span class="nc bnc" id="L2231" title="All 2 branches missed.">            for (i = 0; i &lt; that.certs.length; i++) {</span>
<span class="nc" id="L2232">                match = false;</span>
<span class="nc bnc" id="L2233" title="All 2 branches missed.">                for (j = 0; j &lt; this.certs.length; j++) {</span>
<span class="nc bnc" id="L2234" title="All 2 branches missed.">                    if (that.certs[i].equals(this.certs[j])) {</span>
<span class="nc" id="L2235">                        match = true;</span>
<span class="nc" id="L2236">                        break;</span>
                    }
                }
<span class="nc bnc" id="L2239" title="All 2 branches missed.">                if (!match) return false;</span>
            }
<span class="nc" id="L2241">            return true;</span>
        }

        /**
         * Returns the hash code value for this object.
         *
         * @return a hash code value for this object.
         */
        @Override public int hashCode() {
<span class="nc" id="L2250">            int hash = type.hashCode();</span>
<span class="nc bnc" id="L2251" title="All 2 branches missed.">            if (name != null)</span>
<span class="nc" id="L2252">                hash ^= name.hashCode();</span>
<span class="nc bnc" id="L2253" title="All 2 branches missed.">            if (actions != null)</span>
<span class="nc" id="L2254">                hash ^= actions.hashCode();</span>
<span class="nc" id="L2255">            return hash;</span>
        }

        /**
         * Returns the canonical string representation of the actions,
         * which currently is the empty string &quot;&quot;, since there are no actions
         * for an SelfPermission. That is, the actions for the
         * permission that will be created when this SelfPermission
         * is resolved may be non-null, but an SelfPermission
         * itself is never considered to have any actions.
         *
         * @return the empty string &quot;&quot;.
         */
        @Override public String getActions() {
<span class="nc" id="L2269">            return &quot;&quot;;</span>
        }

        public String getSelfType() {
<span class="fc" id="L2273">            return type;</span>
        }

        public String getSelfName() {
<span class="fc" id="L2277">            return name;</span>
        }

        public String getSelfActions() {
<span class="fc" id="L2281">            return actions;</span>
        }

        public Certificate[] getCerts() {
<span class="nc" id="L2285">            return certs;</span>
        }

        /**
         * Returns a string describing this SelfPermission.  The convention
         * is to specify the class name, the permission name, and the actions,
         * in the following format: '(unresolved &quot;ClassName&quot; &quot;name&quot; &quot;actions&quot;)'.
         *
         * @return information about this SelfPermission.
         */
        @Override public String toString() {
<span class="nc" id="L2296">            return &quot;(SelfPermission &quot; + type + &quot; &quot; + name + &quot; &quot; + actions + &quot;)&quot;;</span>
        }
    }

    /**
     * holds policy information that we need to synch on
     */
    private static class PolicyInfo {
        private static final boolean verbose = false;

        // Stores grant entries in the policy
        final List&lt;PolicyEntry&gt; policyEntries;

        // Stores grant entries gotten from identity database
        // Use separate lists to avoid sync on policyEntries
        final List&lt;PolicyEntry&gt; identityPolicyEntries;

        // Maps aliases to certs
        final Map&lt;Object, Object&gt; aliasMapping;

        // Maps ProtectionDomain to PermissionCollection
        private final ProtectionDomainCache[] pdMapping;
        private java.util.Random random;

<span class="fc" id="L2320">        PolicyInfo(int numCaches) {</span>
<span class="fc" id="L2321">            policyEntries = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L2322">            identityPolicyEntries =</span>
<span class="fc" id="L2323">                Collections.synchronizedList(new ArrayList&lt;PolicyEntry&gt;(2));</span>
<span class="fc" id="L2324">            aliasMapping = Collections.synchronizedMap(new HashMap&lt;&gt;(11));</span>

<span class="fc" id="L2326">            pdMapping = new ProtectionDomainCache[numCaches];</span>
            JavaSecurityProtectionDomainAccess jspda
<span class="fc" id="L2328">                = SharedSecrets.getJavaSecurityProtectionDomainAccess();</span>
<span class="fc bfc" id="L2329" title="All 2 branches covered.">            for (int i = 0; i &lt; numCaches; i++) {</span>
<span class="fc" id="L2330">                pdMapping[i] = jspda.getProtectionDomainCache();</span>
            }
<span class="pc bpc" id="L2332" title="1 of 2 branches missed.">            if (numCaches &gt; 1) {</span>
<span class="nc" id="L2333">                random = new java.util.Random();</span>
            }
<span class="fc" id="L2335">        }</span>
        ProtectionDomainCache getPdMapping() {
<span class="pc bpc" id="L2337" title="1 of 2 branches missed.">            if (pdMapping.length == 1) {</span>
<span class="fc" id="L2338">                return pdMapping[0];</span>
            } else {
<span class="nc" id="L2340">                int i = java.lang.Math.abs(random.nextInt() % pdMapping.length);</span>
<span class="nc" id="L2341">                return pdMapping[i];</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>