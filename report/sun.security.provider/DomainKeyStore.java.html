<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DomainKeyStore.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.provider</a> &gt; <span class="el_source">DomainKeyStore.java</span></div><h1>DomainKeyStore.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.io.*;
import java.net.*;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.CertificateException;
import java.util.*;

import sun.misc.IOUtils;
import sun.security.pkcs.EncryptedPrivateKeyInfo;
import sun.security.util.PolicyUtil;

/**
 * This class provides the domain keystore type identified as &quot;DKS&quot;.
 * DKS presents a collection of separate keystores as a single logical keystore.
 * The collection of keystores is specified in a domain configuration file which
 * is passed to DKS in a {@link DomainLoadStoreParameter}.
 * &lt;p&gt;
 * The following properties are supported:
 * &lt;dl&gt;
 * &lt;dt&gt; {@code keystoreType=&quot;&lt;type&gt;&quot;} &lt;/dt&gt;
 *     &lt;dd&gt; The keystore type. &lt;/dd&gt;
 * &lt;dt&gt; {@code keystoreURI=&quot;&lt;url&gt;&quot;} &lt;/dt&gt;
 *     &lt;dd&gt; The keystore location. &lt;/dd&gt;
 * &lt;dt&gt; {@code keystoreProviderName=&quot;&lt;name&gt;&quot;} &lt;/dt&gt;
 *     &lt;dd&gt; The name of the keystore's JCE provider. &lt;/dd&gt;
 * &lt;dt&gt; {@code keystorePasswordEnv=&quot;&lt;environment-variable&gt;&quot;} &lt;/dt&gt;
 *     &lt;dd&gt; The environment variable that stores a keystore password.
 * &lt;dt&gt; {@code entryNameSeparator=&quot;&lt;separator&gt;&quot;} &lt;/dt&gt;
 *     &lt;dd&gt; The separator between a keystore name prefix and an entry name.
 *          When specified, it applies to all the entries in a domain.
 *          Its default value is a space. &lt;/dd&gt;
 * &lt;/dl&gt;
 *
 * @since 1.8
 */

abstract class DomainKeyStore extends KeyStoreSpi {

    // regular DKS
<span class="fc" id="L68">    public static final class DKS extends DomainKeyStore {</span>
        String convertAlias(String alias) {
<span class="nc" id="L70">            return alias.toLowerCase(Locale.ENGLISH);</span>
        }
    }

    // DKS property names
    private static final String ENTRY_NAME_SEPARATOR = &quot;entrynameseparator&quot;;
    private static final String KEYSTORE_PROVIDER_NAME = &quot;keystoreprovidername&quot;;
    private static final String KEYSTORE_TYPE = &quot;keystoretype&quot;;
    private static final String KEYSTORE_URI = &quot;keystoreuri&quot;;
    private static final String KEYSTORE_PASSWORD_ENV = &quot;keystorepasswordenv&quot;;

    // RegEx meta characters
    private static final String REGEX_META = &quot;.$|()[{^?*+\\&quot;;

    // Default prefix for keystores loaded-by-stream
    private static final String DEFAULT_STREAM_PREFIX = &quot;iostream&quot;;
<span class="fc" id="L86">    private int streamCounter = 1;</span>
<span class="fc" id="L87">    private String entryNameSeparator = &quot; &quot;;</span>
<span class="fc" id="L88">    private String entryNameSeparatorRegEx = &quot; &quot;;</span>

    // Default keystore type
<span class="fc" id="L91">    private static final String DEFAULT_KEYSTORE_TYPE =</span>
<span class="fc" id="L92">        KeyStore.getDefaultType();</span>

    // Domain keystores
<span class="fc" id="L95">    private final Map&lt;String, KeyStore&gt; keystores = new HashMap&lt;&gt;();</span>

<span class="fc" id="L97">    DomainKeyStore() {</span>
<span class="fc" id="L98">    }</span>

    // convert an alias to internal form, overridden in subclasses:
    // lower case for regular DKS
    abstract String convertAlias(String alias);

    /**
     * Returns the key associated with the given alias, using the given
     * password to recover it.
     *
     * @param alias the alias name
     * @param password the password for recovering the key
     *
     * @return the requested key, or null if the given alias does not exist
     * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
     *
     * @exception NoSuchAlgorithmException if the algorithm for recovering the
     * key cannot be found
     * @exception UnrecoverableKeyException if the key cannot be recovered
     * (e.g., the given password is wrong).
     */
    public Key engineGetKey(String alias, char[] password)
        throws NoSuchAlgorithmException, UnrecoverableKeyException
    {
<span class="nc" id="L122">        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L123">            getKeystoresForReading(alias);</span>
<span class="nc" id="L124">        Key key = null;</span>

        try {
<span class="nc" id="L127">            String entryAlias = pair.getKey();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">            for (KeyStore keystore : pair.getValue()) {</span>
<span class="nc" id="L129">                key = keystore.getKey(entryAlias, password);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">                if (key != null) {</span>
<span class="nc" id="L131">                    break;</span>
                }
<span class="nc" id="L133">            }</span>
<span class="nc" id="L134">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L135">            throw new IllegalStateException(e);</span>
<span class="nc" id="L136">        }</span>

<span class="nc" id="L138">        return key;</span>
    }

    /**
     * Returns the certificate chain associated with the given alias.
     *
     * @param alias the alias name
     *
     * @return the certificate chain (ordered with the user's certificate first
     * and the root certificate authority last), or null if the given alias
     * does not exist or does not contain a certificate chain (i.e., the given
     * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
     * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
     */
    public Certificate[] engineGetCertificateChain(String alias) {

<span class="nc" id="L154">        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L155">            getKeystoresForReading(alias);</span>
<span class="nc" id="L156">        Certificate[] chain = null;</span>

        try {
<span class="nc" id="L159">            String entryAlias = pair.getKey();</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">            for (KeyStore keystore : pair.getValue()) {</span>
<span class="nc" id="L161">                chain = keystore.getCertificateChain(entryAlias);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                if (chain != null) {</span>
<span class="nc" id="L163">                    break;</span>
                }
<span class="nc" id="L165">            }</span>
<span class="nc" id="L166">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L167">            throw new IllegalStateException(e);</span>
<span class="nc" id="L168">        }</span>

<span class="nc" id="L170">        return chain;</span>
    }

    /**
     * Returns the certificate associated with the given alias.
     *
     * &lt;p&gt;If the given alias name identifies a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
     * entry is returned. If the given alias name identifies a
     * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
     * entry is returned, or null if that entry does not have a certificate
     * chain.
     *
     * @param alias the alias name
     *
     * @return the certificate, or null if the given alias does not exist or
     * does not contain a certificate.
     */
    public Certificate engineGetCertificate(String alias) {

<span class="nc" id="L190">        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L191">            getKeystoresForReading(alias);</span>
<span class="nc" id="L192">        Certificate cert = null;</span>

        try {
<span class="nc" id="L195">            String entryAlias = pair.getKey();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">            for (KeyStore keystore : pair.getValue()) {</span>
<span class="nc" id="L197">                cert = keystore.getCertificate(entryAlias);</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">                if (cert != null) {</span>
<span class="nc" id="L199">                    break;</span>
                }
<span class="nc" id="L201">            }</span>
<span class="nc" id="L202">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L203">            throw new IllegalStateException(e);</span>
<span class="nc" id="L204">        }</span>

<span class="nc" id="L206">        return cert;</span>
    }

    /**
     * Returns the creation date of the entry identified by the given alias.
     *
     * @param alias the alias name
     *
     * @return the creation date of this entry, or null if the given alias does
     * not exist
     */
    public Date engineGetCreationDate(String alias) {

<span class="nc" id="L219">        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L220">            getKeystoresForReading(alias);</span>
<span class="nc" id="L221">        Date date = null;</span>

        try {
<span class="nc" id="L224">            String entryAlias = pair.getKey();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            for (KeyStore keystore : pair.getValue()) {</span>
<span class="nc" id="L226">                date = keystore.getCreationDate(entryAlias);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                if (date != null) {</span>
<span class="nc" id="L228">                    break;</span>
                }
<span class="nc" id="L230">            }</span>
<span class="nc" id="L231">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L232">            throw new IllegalStateException(e);</span>
<span class="nc" id="L233">        }</span>

<span class="nc" id="L235">        return date;</span>
    }

    /**
     * Assigns the given private key to the given alias, protecting
     * it with the given password as defined in PKCS8.
     *
     * &lt;p&gt;The given java.security.PrivateKey &lt;code&gt;key&lt;/code&gt; must
     * be accompanied by a certificate chain certifying the
     * corresponding public key.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key and certificate
     * chain.
     *
     * @param alias the alias name
     * @param key the private key to be associated with the alias
     * @param password the password to protect the key
     * @param chain the certificate chain for the corresponding public
     * key (only required if the given key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
     *
     * @exception KeyStoreException if the given key is not a private key,
     * cannot be protected, or this operation fails for some other reason
     */
    public void engineSetKeyEntry(String alias, Key key, char[] password,
                                  Certificate[] chain)
        throws KeyStoreException
    {
        AbstractMap.SimpleEntry&lt;String,
<span class="nc" id="L265">            AbstractMap.SimpleEntry&lt;String, KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L266">                getKeystoreForWriting(alias);</span>

<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (pair == null) {</span>
<span class="nc" id="L269">            throw new KeyStoreException(&quot;Error setting key entry for '&quot; +</span>
                alias + &quot;'&quot;);
        }
<span class="nc" id="L272">        String entryAlias = pair.getKey();</span>
<span class="nc" id="L273">        Map.Entry&lt;String, KeyStore&gt; keystore = pair.getValue();</span>
<span class="nc" id="L274">        keystore.getValue().setKeyEntry(entryAlias, key, password, chain);</span>
<span class="nc" id="L275">    }</span>

    /**
     * Assigns the given key (that has already been protected) to the given
     * alias.
     *
     * &lt;p&gt;If the protected key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
     * certificate chain certifying the corresponding public key. If the
     * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
     * &lt;code&gt;key&lt;/code&gt; must be encoded as an
     * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key (and possibly
     * certificate chain).
     *
     * @param alias the alias name
     * @param key the key (in protected format) to be associated with the alias
     * @param chain the certificate chain for the corresponding public
     * key (only useful if the protected key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
     *
     * @exception KeyStoreException if this operation fails.
     */
    public void engineSetKeyEntry(String alias, byte[] key,
                                  Certificate[] chain)
        throws KeyStoreException
    {
        AbstractMap.SimpleEntry&lt;String,
<span class="nc" id="L305">            AbstractMap.SimpleEntry&lt;String, KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L306">                getKeystoreForWriting(alias);</span>

<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (pair == null) {</span>
<span class="nc" id="L309">            throw new KeyStoreException(</span>
                &quot;Error setting protected key entry for '&quot; + alias + &quot;'&quot;);
        }
<span class="nc" id="L312">        String entryAlias = pair.getKey();</span>
<span class="nc" id="L313">        Map.Entry&lt;String, KeyStore&gt; keystore = pair.getValue();</span>
<span class="nc" id="L314">        keystore.getValue().setKeyEntry(entryAlias, key, chain);</span>
<span class="nc" id="L315">    }</span>

    /**
     * Assigns the given certificate to the given alias.
     *
     * &lt;p&gt;If the given alias already exists in this keystore and identifies a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
     * overridden by the given certificate.
     *
     * @param alias the alias name
     * @param cert the certificate
     *
     * @exception KeyStoreException if the given alias already exists and does
     * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation
     * fails for some other reason.
     */
    public void engineSetCertificateEntry(String alias, Certificate cert)
        throws KeyStoreException
    {
        AbstractMap.SimpleEntry&lt;String,
<span class="nc" id="L335">            AbstractMap.SimpleEntry&lt;String, KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L336">                getKeystoreForWriting(alias);</span>

<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (pair == null) {</span>
<span class="nc" id="L339">            throw new KeyStoreException(&quot;Error setting certificate entry for '&quot;</span>
                + alias + &quot;'&quot;);
        }
<span class="nc" id="L342">        String entryAlias = pair.getKey();</span>
<span class="nc" id="L343">        Map.Entry&lt;String, KeyStore&gt; keystore = pair.getValue();</span>
<span class="nc" id="L344">        keystore.getValue().setCertificateEntry(entryAlias, cert);</span>
<span class="nc" id="L345">    }</span>

    /**
     * Deletes the entry identified by the given alias from this keystore.
     *
     * @param alias the alias name
     *
     * @exception KeyStoreException if the entry cannot be removed.
     */
    public void engineDeleteEntry(String alias) throws KeyStoreException
    {
        AbstractMap.SimpleEntry&lt;String,
<span class="nc" id="L357">            AbstractMap.SimpleEntry&lt;String, KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L358">                getKeystoreForWriting(alias);</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (pair == null) {</span>
<span class="nc" id="L361">            throw new KeyStoreException(&quot;Error deleting entry for '&quot; + alias +</span>
                &quot;'&quot;);
        }
<span class="nc" id="L364">        String entryAlias = pair.getKey();</span>
<span class="nc" id="L365">        Map.Entry&lt;String, KeyStore&gt; keystore = pair.getValue();</span>
<span class="nc" id="L366">        keystore.getValue().deleteEntry(entryAlias);</span>
<span class="nc" id="L367">    }</span>

    /**
     * Lists all the alias names of this keystore.
     *
     * @return enumeration of the alias names
     */
    public Enumeration&lt;String&gt; engineAliases() {
<span class="fc" id="L375">        final Iterator&lt;Map.Entry&lt;String, KeyStore&gt;&gt; iterator =</span>
<span class="fc" id="L376">            keystores.entrySet().iterator();</span>

<span class="fc" id="L378">        return new Enumeration&lt;String&gt;() {</span>
<span class="fc" id="L379">            private int index = 0;</span>
<span class="fc" id="L380">            private Map.Entry&lt;String, KeyStore&gt; keystoresEntry = null;</span>
<span class="fc" id="L381">            private String prefix = null;</span>
<span class="fc" id="L382">            private Enumeration&lt;String&gt; aliases = null;</span>

            public boolean hasMoreElements() {
                try {
<span class="fc bfc" id="L386" title="All 2 branches covered.">                    if (aliases == null) {</span>
<span class="pc bpc" id="L387" title="1 of 2 branches missed.">                        if (iterator.hasNext()) {</span>
<span class="fc" id="L388">                            keystoresEntry = iterator.next();</span>
<span class="fc" id="L389">                            prefix = keystoresEntry.getKey() +</span>
<span class="fc" id="L390">                                entryNameSeparator;</span>
<span class="fc" id="L391">                            aliases = keystoresEntry.getValue().aliases();</span>
                        } else {
<span class="nc" id="L393">                            return false;</span>
                        }
                    }
<span class="fc bfc" id="L396" title="All 2 branches covered.">                    if (aliases.hasMoreElements()) {</span>
<span class="fc" id="L397">                        return true;</span>
                    } else {
<span class="fc bfc" id="L399" title="All 2 branches covered.">                        if (iterator.hasNext()) {</span>
<span class="fc" id="L400">                            keystoresEntry = iterator.next();</span>
<span class="fc" id="L401">                            prefix = keystoresEntry.getKey() +</span>
<span class="fc" id="L402">                                entryNameSeparator;</span>
<span class="fc" id="L403">                            aliases = keystoresEntry.getValue().aliases();</span>
                        } else {
<span class="fc" id="L405">                            return false;</span>
                        }
                    }
<span class="nc" id="L408">                } catch (KeyStoreException e) {</span>
<span class="nc" id="L409">                    return false;</span>
<span class="fc" id="L410">                }</span>

<span class="fc" id="L412">                return aliases.hasMoreElements();</span>
            }

            public String nextElement() {
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">                if (hasMoreElements()) {</span>
<span class="fc" id="L417">                    return prefix + aliases.nextElement();</span>
                }
<span class="nc" id="L419">                throw new NoSuchElementException();</span>
            }
        };
    }

    /**
     * Checks if the given alias exists in this keystore.
     *
     * @param alias the alias name
     *
     * @return true if the alias exists, false otherwise
     */
    public boolean engineContainsAlias(String alias) {

<span class="nc" id="L433">        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L434">            getKeystoresForReading(alias);</span>

        try {
<span class="nc" id="L437">            String entryAlias = pair.getKey();</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (KeyStore keystore : pair.getValue()) {</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">                if (keystore.containsAlias(entryAlias)) {</span>
<span class="nc" id="L440">                    return true;</span>
                }
<span class="nc" id="L442">            }</span>
<span class="nc" id="L443">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L444">            throw new IllegalStateException(e);</span>
<span class="nc" id="L445">        }</span>

<span class="nc" id="L447">        return false;</span>
    }

    /**
     * Retrieves the number of entries in this keystore.
     *
     * @return the number of entries in this keystore
     */
    public int engineSize() {

<span class="fc" id="L457">        int size = 0;</span>
        try {
<span class="fc bfc" id="L459" title="All 2 branches covered.">            for (KeyStore keystore : keystores.values()) {</span>
<span class="fc" id="L460">                size += keystore.size();</span>
<span class="fc" id="L461">            }</span>
<span class="nc" id="L462">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L463">            throw new IllegalStateException(e);</span>
<span class="fc" id="L464">        }</span>

<span class="fc" id="L466">        return size;</span>
    }

    /**
     * Returns true if the entry identified by the given alias is a
     * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
     *
     * @return true if the entry identified by the given alias is a
     * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
     */
    public boolean engineIsKeyEntry(String alias) {

<span class="nc" id="L478">        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L479">            getKeystoresForReading(alias);</span>

        try {
<span class="nc" id="L482">            String entryAlias = pair.getKey();</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">            for (KeyStore keystore : pair.getValue()) {</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if (keystore.isKeyEntry(entryAlias)) {</span>
<span class="nc" id="L485">                    return true;</span>
                }
<span class="nc" id="L487">            }</span>
<span class="nc" id="L488">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L489">            throw new IllegalStateException(e);</span>
<span class="nc" id="L490">        }</span>

<span class="nc" id="L492">        return false;</span>
    }

    /**
     * Returns true if the entry identified by the given alias is a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
     *
     * @return true if the entry identified by the given alias is a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
     */
    public boolean engineIsCertificateEntry(String alias) {

<span class="nc" id="L504">        AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt; pair =</span>
<span class="nc" id="L505">            getKeystoresForReading(alias);</span>

        try {
<span class="nc" id="L508">            String entryAlias = pair.getKey();</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">            for (KeyStore keystore : pair.getValue()) {</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                if (keystore.isCertificateEntry(entryAlias)) {</span>
<span class="nc" id="L511">                    return true;</span>
                }
<span class="nc" id="L513">            }</span>
<span class="nc" id="L514">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L515">            throw new IllegalStateException(e);</span>
<span class="nc" id="L516">        }</span>

<span class="nc" id="L518">        return false;</span>
    }

    /*
     * Returns a keystore entry alias and a list of target keystores.
     * When the supplied alias prefix identifies a keystore then that single
     * keystore is returned. When no alias prefix is supplied then all the
     * keystores are returned.
     */
    private AbstractMap.SimpleEntry&lt;String, Collection&lt;KeyStore&gt;&gt;
        getKeystoresForReading(String alias) {

<span class="nc" id="L530">        String[] splits = alias.split(this.entryNameSeparatorRegEx, 2);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (splits.length == 2) { // prefixed alias</span>
<span class="nc" id="L532">            KeyStore keystore = keystores.get(splits[0]);</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            if (keystore != null) {</span>
<span class="nc" id="L534">                return new AbstractMap.SimpleEntry&lt;&gt;(splits[1],</span>
<span class="nc" id="L535">                    (Collection&lt;KeyStore&gt;) Collections.singleton(keystore));</span>
            }
<span class="nc bnc" id="L537" title="All 2 branches missed.">        } else if (splits.length == 1) { // unprefixed alias</span>
            // Check all keystores for the first occurrence of the alias
<span class="nc" id="L539">            return new AbstractMap.SimpleEntry&lt;&gt;(alias, keystores.values());</span>
        }
<span class="nc" id="L541">        return new AbstractMap.SimpleEntry&lt;&gt;(&quot;&quot;,</span>
<span class="nc" id="L542">            (Collection&lt;KeyStore&gt;) Collections.&lt;KeyStore&gt;emptyList());</span>
    }

    /*
     * Returns a keystore entry alias and a single target keystore.
     * An alias prefix must be supplied.
     */
    private
    AbstractMap.SimpleEntry&lt;String, AbstractMap.SimpleEntry&lt;String, KeyStore&gt;&gt;
        getKeystoreForWriting(String alias) {

<span class="nc" id="L553">        String[] splits = alias.split(this.entryNameSeparator, 2);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (splits.length == 2) { // prefixed alias</span>
<span class="nc" id="L555">            KeyStore keystore = keystores.get(splits[0]);</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">            if (keystore != null) {</span>
<span class="nc" id="L557">                return new AbstractMap.SimpleEntry&lt;&gt;(splits[1],</span>
                    new AbstractMap.SimpleEntry&lt;&gt;(splits[0], keystore));
            }
        }
<span class="nc" id="L561">        return null;</span>
    }

    /**
     * Returns the (alias) name of the first keystore entry whose certificate
     * matches the given certificate.
     *
     * &lt;p&gt;This method attempts to match the given certificate with each
     * keystore entry. If the entry being considered
     * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
     * compared to that entry's certificate. If the entry being considered is
     * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
     * element of that entry's certificate chain (if a chain exists).
     *
     * @param cert the certificate to match with.
     *
     * @return the (alias) name of the first entry with matching certificate,
     * or null if no such entry exists in this keystore.
     */
    public String engineGetCertificateAlias(Certificate cert) {

        try {

<span class="nc" id="L584">            String alias = null;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">            for (KeyStore keystore : keystores.values()) {</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">                if ((alias = keystore.getCertificateAlias(cert)) != null) {</span>
<span class="nc" id="L587">                    break;</span>
                }
<span class="nc" id="L589">            }</span>
<span class="nc" id="L590">            return alias;</span>

<span class="nc" id="L592">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L593">            throw new IllegalStateException(e);</span>
        }
    }

    /**
     * Stores this keystore to the given output stream, and protects its
     * integrity with the given password.
     *
     * @param stream the output stream to which this keystore is written.
     * @param password the password to generate the keystore integrity check
     *
     * @exception IOException if there was an I/O problem with data
     * @exception NoSuchAlgorithmException if the appropriate data integrity
     * algorithm could not be found
     * @exception CertificateException if any of the certificates included in
     * the keystore data could not be stored
     */
    public void engineStore(OutputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
        // Support storing to a stream only when a single keystore has been
        // configured
        try {
<span class="nc bnc" id="L616" title="All 2 branches missed.">            if (keystores.size() == 1) {</span>
<span class="nc" id="L617">                keystores.values().iterator().next().store(stream, password);</span>
<span class="nc" id="L618">                return;</span>
            }
<span class="nc" id="L620">        } catch (KeyStoreException e) {</span>
<span class="nc" id="L621">            throw new IllegalStateException(e);</span>
<span class="nc" id="L622">        }</span>

<span class="nc" id="L624">        throw new UnsupportedOperationException(</span>
            &quot;This keystore must be stored using a DomainLoadStoreParameter&quot;);
    }

    @Override
    public void engineStore(KeyStore.LoadStoreParameter param)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (param instanceof DomainLoadStoreParameter) {</span>
<span class="nc" id="L633">            DomainLoadStoreParameter domainParameter =</span>
                (DomainLoadStoreParameter) param;
<span class="nc" id="L635">            List&lt;KeyStoreBuilderComponents&gt; builders = getBuilders(</span>
<span class="nc" id="L636">                domainParameter.getConfiguration(),</span>
<span class="nc" id="L637">                    domainParameter.getProtectionParams());</span>

<span class="nc bnc" id="L639" title="All 2 branches missed.">            for (KeyStoreBuilderComponents builder : builders) {</span>

                try {

<span class="nc" id="L643">                    KeyStore.ProtectionParameter pp = builder.protection;</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                    if (!(pp instanceof KeyStore.PasswordProtection)) {</span>
<span class="nc" id="L645">                        throw new KeyStoreException(</span>
                            new IllegalArgumentException(&quot;ProtectionParameter&quot; +
                                &quot; must be a KeyStore.PasswordProtection&quot;));
                    }
<span class="nc" id="L649">                    char[] password =</span>
                        ((KeyStore.PasswordProtection) builder.protection)
<span class="nc" id="L651">                            .getPassword();</span>

                    // Store the keystores
<span class="nc" id="L654">                    KeyStore keystore = keystores.get(builder.name);</span>

<span class="nc" id="L656">                    try (FileOutputStream stream =</span>
                        new FileOutputStream(builder.file)) {

<span class="nc" id="L659">                        keystore.store(stream, password);</span>
<span class="nc bnc" id="L660" title="All 8 branches missed.">                    }</span>
<span class="nc" id="L661">                } catch (KeyStoreException e) {</span>
<span class="nc" id="L662">                    throw new IOException(e);</span>
<span class="nc" id="L663">                }</span>
<span class="nc" id="L664">            }</span>
<span class="nc" id="L665">        } else {</span>
<span class="nc" id="L666">            throw new UnsupportedOperationException(</span>
                &quot;This keystore must be stored using a &quot; +
                &quot;DomainLoadStoreParameter&quot;);
        }
<span class="nc" id="L670">    }</span>

    /**
     * Loads the keystore from the given input stream.
     *
     * &lt;p&gt;If a password is given, it is used to check the integrity of the
     * keystore data. Otherwise, the integrity of the keystore is not checked.
     *
     * @param stream the input stream from which the keystore is loaded
     * @param password the (optional) password used to check the integrity of
     * the keystore.
     *
     * @exception IOException if there is an I/O or format problem with the
     * keystore data
     * @exception NoSuchAlgorithmException if the algorithm used to check
     * the integrity of the keystore cannot be found
     * @exception CertificateException if any of the certificates in the
     * keystore could not be loaded
     */
    public void engineLoad(InputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
        // Support loading from a stream only for a JKS or default type keystore
        try {
<span class="nc" id="L694">            KeyStore keystore = null;</span>

            try {
<span class="nc" id="L697">                keystore = KeyStore.getInstance(&quot;JKS&quot;);</span>
<span class="nc" id="L698">                keystore.load(stream, password);</span>

<span class="nc" id="L700">            } catch (Exception e) {</span>
                // Retry
<span class="nc bnc" id="L702" title="All 2 branches missed.">                if (!&quot;JKS&quot;.equalsIgnoreCase(DEFAULT_KEYSTORE_TYPE)) {</span>
<span class="nc" id="L703">                    keystore = KeyStore.getInstance(DEFAULT_KEYSTORE_TYPE);</span>
<span class="nc" id="L704">                    keystore.load(stream, password);</span>
                } else {
<span class="nc" id="L706">                    throw e;</span>
                }
<span class="nc" id="L708">            }</span>
<span class="nc" id="L709">            String keystoreName = DEFAULT_STREAM_PREFIX + streamCounter++;</span>
<span class="nc" id="L710">            keystores.put(keystoreName, keystore);</span>

<span class="nc" id="L712">        } catch (Exception e) {</span>
<span class="nc" id="L713">            throw new UnsupportedOperationException(</span>
                &quot;This keystore must be loaded using a &quot; +
                &quot;DomainLoadStoreParameter&quot;);
<span class="nc" id="L716">        }</span>
<span class="nc" id="L717">    }</span>

    @Override
    public void engineLoad(KeyStore.LoadStoreParameter param)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
<span class="pc bpc" id="L723" title="1 of 2 branches missed.">        if (param instanceof DomainLoadStoreParameter) {</span>
<span class="fc" id="L724">            DomainLoadStoreParameter domainParameter =</span>
                (DomainLoadStoreParameter) param;
<span class="fc" id="L726">            List&lt;KeyStoreBuilderComponents&gt; builders = getBuilders(</span>
<span class="fc" id="L727">                domainParameter.getConfiguration(),</span>
<span class="fc" id="L728">                    domainParameter.getProtectionParams());</span>

<span class="fc bfc" id="L730" title="All 2 branches covered.">            for (KeyStoreBuilderComponents builder : builders) {</span>

                try {
                    // Load the keystores (file-based and non-file-based)
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">                    if (builder.file != null) {</span>
<span class="fc" id="L735">                        keystores.put(builder.name,</span>
<span class="fc" id="L736">                            KeyStore.Builder.newInstance(builder.type,</span>
                                builder.provider, builder.file,
                                builder.protection)
<span class="fc" id="L739">                                    .getKeyStore());</span>
                    } else {
<span class="nc" id="L741">                        keystores.put(builder.name,</span>
<span class="nc" id="L742">                            KeyStore.Builder.newInstance(builder.type,</span>
                                builder.provider, builder.protection)
<span class="nc" id="L744">                                    .getKeyStore());</span>
                    }
<span class="nc" id="L746">                } catch (KeyStoreException e) {</span>
<span class="nc" id="L747">                    throw new IOException(e);</span>
<span class="fc" id="L748">                }</span>
<span class="fc" id="L749">            }</span>
<span class="fc" id="L750">        } else {</span>
<span class="nc" id="L751">            throw new UnsupportedOperationException(</span>
                &quot;This keystore must be loaded using a &quot; +
                &quot;DomainLoadStoreParameter&quot;);
        }
<span class="fc" id="L755">    }</span>

    /*
     * Parse a keystore domain configuration file and associated collection
     * of keystore passwords to create a collection of KeyStore.Builder.
     */
    private List&lt;KeyStoreBuilderComponents&gt; getBuilders(URI configuration,
        Map&lt;String, KeyStore.ProtectionParameter&gt; passwords)
            throws IOException {

<span class="fc" id="L765">        PolicyParser parser = new PolicyParser(true); // expand properties</span>
<span class="fc" id="L766">        Collection&lt;PolicyParser.DomainEntry&gt; domains = null;</span>
<span class="fc" id="L767">        List&lt;KeyStoreBuilderComponents&gt; builders = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L768">        String uriDomain = configuration.getFragment();</span>

<span class="pc" id="L770">        try (InputStreamReader configurationReader =</span>
            new InputStreamReader(
<span class="fc" id="L772">                PolicyUtil.getInputStream(configuration.toURL()), &quot;UTF-8&quot;)) {</span>
<span class="fc" id="L773">            parser.read(configurationReader);</span>
<span class="fc" id="L774">            domains = parser.getDomainEntries();</span>

<span class="pc bpc" id="L776" title="6 of 8 branches missed.">        } catch (MalformedURLException mue) {</span>
<span class="nc" id="L777">            throw new IOException(mue);</span>

<span class="nc" id="L779">        } catch (PolicyParser.ParsingException pe) {</span>
<span class="nc" id="L780">            throw new IOException(pe);</span>
<span class="fc" id="L781">        }</span>

<span class="pc bpc" id="L783" title="1 of 2 branches missed.">        for (PolicyParser.DomainEntry domain : domains) {</span>
<span class="fc" id="L784">            Map&lt;String, String&gt; domainProperties = domain.getProperties();</span>

<span class="pc bpc" id="L786" title="1 of 2 branches missed.">            if (uriDomain != null &amp;&amp;</span>
<span class="fc bfc" id="L787" title="All 2 branches covered.">                (!uriDomain.equalsIgnoreCase(domain.getName()))) {</span>
<span class="fc" id="L788">                continue; // skip this domain</span>
            }

<span class="pc bpc" id="L791" title="1 of 2 branches missed.">            if (domainProperties.containsKey(ENTRY_NAME_SEPARATOR)) {</span>
<span class="nc" id="L792">                this.entryNameSeparator =</span>
<span class="nc" id="L793">                    domainProperties.get(ENTRY_NAME_SEPARATOR);</span>
                // escape any regex meta characters
<span class="nc" id="L795">                char ch = 0;</span>
<span class="nc" id="L796">                StringBuilder s = new StringBuilder();</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">                for (int i = 0; i &lt; this.entryNameSeparator.length(); i++) {</span>
<span class="nc" id="L798">                    ch = this.entryNameSeparator.charAt(i);</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                    if (REGEX_META.indexOf(ch) != -1) {</span>
<span class="nc" id="L800">                        s.append('\\');</span>
                    }
<span class="nc" id="L802">                    s.append(ch);</span>
                }
<span class="nc" id="L804">                this.entryNameSeparatorRegEx = s.toString();</span>
            }

<span class="fc" id="L807">            Collection&lt;PolicyParser.KeyStoreEntry&gt; keystores =</span>
<span class="fc" id="L808">                domain.getEntries();</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">            for (PolicyParser.KeyStoreEntry keystore : keystores) {</span>
<span class="fc" id="L810">                String keystoreName = keystore.getName();</span>
<span class="fc" id="L811">                Map&lt;String, String&gt; properties =</span>
                    new HashMap&lt;&gt;(domainProperties);
<span class="fc" id="L813">                properties.putAll(keystore.getProperties());</span>

<span class="fc" id="L815">                String keystoreType = DEFAULT_KEYSTORE_TYPE;</span>
<span class="pc bpc" id="L816" title="1 of 2 branches missed.">                if (properties.containsKey(KEYSTORE_TYPE)) {</span>
<span class="fc" id="L817">                    keystoreType = properties.get(KEYSTORE_TYPE);</span>
                }

<span class="fc" id="L820">                Provider keystoreProvider = null;</span>
<span class="fc bfc" id="L821" title="All 2 branches covered.">                if (properties.containsKey(KEYSTORE_PROVIDER_NAME)) {</span>
<span class="fc" id="L822">                    String keystoreProviderName =</span>
<span class="fc" id="L823">                        properties.get(KEYSTORE_PROVIDER_NAME);</span>
<span class="fc" id="L824">                    keystoreProvider =</span>
<span class="fc" id="L825">                        Security.getProvider(keystoreProviderName);</span>
<span class="pc bpc" id="L826" title="1 of 2 branches missed.">                    if (keystoreProvider == null) {</span>
<span class="nc" id="L827">                        throw new IOException(&quot;Error locating JCE provider: &quot; +</span>
                            keystoreProviderName);
                    }
                }

<span class="fc" id="L832">                File keystoreFile = null;</span>
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">                if (properties.containsKey(KEYSTORE_URI)) {</span>
<span class="fc" id="L834">                    String uri = properties.get(KEYSTORE_URI);</span>

                    try {
<span class="pc bpc" id="L837" title="1 of 2 branches missed.">                        if (uri.startsWith(&quot;file://&quot;)) {</span>
<span class="nc" id="L838">                            keystoreFile = new File(new URI(uri));</span>
                        } else {
<span class="fc" id="L840">                            keystoreFile = new File(uri);</span>
                        }

<span class="nc" id="L843">                    } catch (URISyntaxException | IllegalArgumentException e) {</span>
<span class="nc" id="L844">                        throw new IOException(</span>
                            &quot;Error processing keystore property: &quot; +
                                &quot;keystoreURI=\&quot;&quot; + uri + &quot;\&quot;&quot;, e);
<span class="fc" id="L847">                    }</span>
                }

<span class="fc" id="L850">                KeyStore.ProtectionParameter keystoreProtection = null;</span>
<span class="fc bfc" id="L851" title="All 2 branches covered.">                if (passwords.containsKey(keystoreName)) {</span>
<span class="fc" id="L852">                    keystoreProtection = passwords.get(keystoreName);</span>

<span class="pc bpc" id="L854" title="1 of 2 branches missed.">                } else if (properties.containsKey(KEYSTORE_PASSWORD_ENV)) {</span>
<span class="fc" id="L855">                    String env = properties.get(KEYSTORE_PASSWORD_ENV);</span>
<span class="fc" id="L856">                    String pwd = System.getenv(env);</span>
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">                    if (pwd != null) {</span>
<span class="fc" id="L858">                        keystoreProtection =</span>
<span class="fc" id="L859">                            new KeyStore.PasswordProtection(pwd.toCharArray());</span>
                    } else {
<span class="nc" id="L861">                        throw new IOException(</span>
                            &quot;Error processing keystore property: &quot; +
                                &quot;keystorePasswordEnv=\&quot;&quot; + env + &quot;\&quot;&quot;);
                    }
<span class="fc" id="L865">                } else {</span>
<span class="nc" id="L866">                    keystoreProtection = new KeyStore.PasswordProtection(null);</span>
                }

<span class="fc" id="L869">                builders.add(new KeyStoreBuilderComponents(keystoreName,</span>
                    keystoreType, keystoreProvider, keystoreFile,
                    keystoreProtection));
<span class="fc" id="L872">            }</span>
<span class="fc" id="L873">            break; // skip other domains</span>
        }
<span class="pc bpc" id="L875" title="1 of 2 branches missed.">        if (builders.isEmpty()) {</span>
<span class="nc" id="L876">            throw new IOException(&quot;Error locating domain configuration data &quot; +</span>
                &quot;for: &quot; + configuration);
        }

<span class="fc" id="L880">        return builders;</span>
    }

/*
 * Utility class that holds the components used to construct a KeyStore.Builder
 */
class KeyStoreBuilderComponents {
    String name;
    String type;
    Provider provider;
    File file;
    KeyStore.ProtectionParameter protection;

    KeyStoreBuilderComponents(String name, String type, Provider provider,
<span class="fc" id="L894">        File file, KeyStore.ProtectionParameter protection) {</span>
<span class="fc" id="L895">        this.name = name;</span>
<span class="fc" id="L896">        this.type = type;</span>
<span class="fc" id="L897">        this.provider = provider;</span>
<span class="fc" id="L898">        this.file = file;</span>
<span class="fc" id="L899">        this.protection = protection;</span>
<span class="fc" id="L900">    }</span>
}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>