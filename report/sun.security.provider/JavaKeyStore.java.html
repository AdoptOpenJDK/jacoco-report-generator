<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JavaKeyStore.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.provider</a> &gt; <span class="el_source">JavaKeyStore.java</span></div><h1>JavaKeyStore.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.provider;

import java.io.*;
import java.security.*;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.CertificateException;
import java.util.*;
import sun.misc.IOUtils;

import sun.security.pkcs.EncryptedPrivateKeyInfo;

/**
 * This class provides the keystore implementation referred to as &quot;JKS&quot;.
 *
 * @author Jan Luehe
 * @author David Brownell
 *
 *
 * @see KeyProtector
 * @see java.security.KeyStoreSpi
 * @see KeyTool
 *
 * @since 1.2
 */

abstract class JavaKeyStore extends KeyStoreSpi {

    // regular JKS
<span class="fc" id="L55">    public static final class JKS extends JavaKeyStore {</span>
        String convertAlias(String alias) {
<span class="fc" id="L57">            return alias.toLowerCase(Locale.ENGLISH);</span>
        }
    }

    // special JKS that uses case sensitive aliases
<span class="fc" id="L62">    public static final class CaseExactJKS extends JavaKeyStore {</span>
        String convertAlias(String alias) {
<span class="nc" id="L64">            return alias;</span>
        }
    }

    private static final int MAGIC = 0xfeedfeed;
    private static final int VERSION_1 = 0x01;
    private static final int VERSION_2 = 0x02;

    // Private keys and their supporting certificate chains
<span class="fc" id="L73">    private static class KeyEntry {</span>
        Date date; // the creation date of this entry
        byte[] protectedPrivKey;
        Certificate chain[];
    };

    // Trusted certificates
<span class="fc" id="L80">    private static class TrustedCertEntry {</span>
        Date date; // the creation date of this entry
        Certificate cert;
    };

    /**
     * Private keys and certificates are stored in a hashtable.
     * Hash entries are keyed by alias names.
     */
    private final Hashtable&lt;String, Object&gt; entries;

<span class="fc" id="L91">    JavaKeyStore() {</span>
<span class="fc" id="L92">        entries = new Hashtable&lt;String, Object&gt;();</span>
<span class="fc" id="L93">    }</span>

    // convert an alias to internal form, overridden in subclasses:
    // lower case for regular JKS
    // original string for CaseExactJKS
    abstract String convertAlias(String alias);

    /**
     * Returns the key associated with the given alias, using the given
     * password to recover it.
     *
     * @param alias the alias name
     * @param password the password for recovering the key
     *
     * @return the requested key, or null if the given alias does not exist
     * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
     *
     * @exception NoSuchAlgorithmException if the algorithm for recovering the
     * key cannot be found
     * @exception UnrecoverableKeyException if the key cannot be recovered
     * (e.g., the given password is wrong).
     */
    public Key engineGetKey(String alias, char[] password)
        throws NoSuchAlgorithmException, UnrecoverableKeyException
    {
<span class="fc" id="L118">        Object entry = entries.get(convertAlias(alias));</span>

<span class="pc bpc" id="L120" title="2 of 4 branches missed.">        if (entry == null || !(entry instanceof KeyEntry)) {</span>
<span class="nc" id="L121">            return null;</span>
        }
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if (password == null) {</span>
<span class="nc" id="L124">            throw new UnrecoverableKeyException(&quot;Password must not be null&quot;);</span>
        }

<span class="fc" id="L127">        KeyProtector keyProtector = new KeyProtector(password);</span>
<span class="fc" id="L128">        byte[] encrBytes = ((KeyEntry)entry).protectedPrivKey;</span>
        EncryptedPrivateKeyInfo encrInfo;
        byte[] plain;
        try {
<span class="fc" id="L132">            encrInfo = new EncryptedPrivateKeyInfo(encrBytes);</span>
<span class="nc" id="L133">        } catch (IOException ioe) {</span>
<span class="nc" id="L134">            throw new UnrecoverableKeyException(&quot;Private key not stored as &quot;</span>
                                                + &quot;PKCS #8 &quot;
                                                + &quot;EncryptedPrivateKeyInfo&quot;);
<span class="fc" id="L137">        }</span>
<span class="fc" id="L138">        return keyProtector.recover(encrInfo);</span>
    }

    /**
     * Returns the certificate chain associated with the given alias.
     *
     * @param alias the alias name
     *
     * @return the certificate chain (ordered with the user's certificate first
     * and the root certificate authority last), or null if the given alias
     * does not exist or does not contain a certificate chain (i.e., the given
     * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a
     * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).
     */
    public Certificate[] engineGetCertificateChain(String alias) {
<span class="fc" id="L153">        Object entry = entries.get(convertAlias(alias));</span>

<span class="pc bpc" id="L155" title="1 of 4 branches missed.">        if (entry != null &amp;&amp; entry instanceof KeyEntry) {</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">            if (((KeyEntry)entry).chain == null) {</span>
<span class="nc" id="L157">                return null;</span>
            } else {
<span class="fc" id="L159">                return ((KeyEntry)entry).chain.clone();</span>
            }
        } else {
<span class="fc" id="L162">            return null;</span>
        }
    }

    /**
     * Returns the certificate associated with the given alias.
     *
     * &lt;p&gt;If the given alias name identifies a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with that
     * entry is returned. If the given alias name identifies a
     * &lt;i&gt;key entry&lt;/i&gt;, the first element of the certificate chain of that
     * entry is returned, or null if that entry does not have a certificate
     * chain.
     *
     * @param alias the alias name
     *
     * @return the certificate, or null if the given alias does not exist or
     * does not contain a certificate.
     */
    public Certificate engineGetCertificate(String alias) {
<span class="fc" id="L182">        Object entry = entries.get(convertAlias(alias));</span>

<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (entry != null) {</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">            if (entry instanceof TrustedCertEntry) {</span>
<span class="fc" id="L186">                return ((TrustedCertEntry)entry).cert;</span>
            } else {
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">                if (((KeyEntry)entry).chain == null) {</span>
<span class="nc" id="L189">                    return null;</span>
                } else {
<span class="fc" id="L191">                    return ((KeyEntry)entry).chain[0];</span>
                }
            }
        } else {
<span class="fc" id="L195">            return null;</span>
        }
    }

    /**
     * Returns the creation date of the entry identified by the given alias.
     *
     * @param alias the alias name
     *
     * @return the creation date of this entry, or null if the given alias does
     * not exist
     */
    public Date engineGetCreationDate(String alias) {
<span class="nc" id="L208">        Object entry = entries.get(convertAlias(alias));</span>

<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (entry != null) {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (entry instanceof TrustedCertEntry) {</span>
<span class="nc" id="L212">                return new Date(((TrustedCertEntry)entry).date.getTime());</span>
            } else {
<span class="nc" id="L214">                return new Date(((KeyEntry)entry).date.getTime());</span>
            }
        } else {
<span class="nc" id="L217">            return null;</span>
        }
    }

    /**
     * Assigns the given private key to the given alias, protecting
     * it with the given password as defined in PKCS8.
     *
     * &lt;p&gt;The given java.security.PrivateKey &lt;code&gt;key&lt;/code&gt; must
     * be accompanied by a certificate chain certifying the
     * corresponding public key.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key and certificate
     * chain.
     *
     * @param alias the alias name
     * @param key the private key to be associated with the alias
     * @param password the password to protect the key
     * @param chain the certificate chain for the corresponding public
     * key (only required if the given key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
     *
     * @exception KeyStoreException if the given key is not a private key,
     * cannot be protected, or this operation fails for some other reason
     */
    public void engineSetKeyEntry(String alias, Key key, char[] password,
                                  Certificate[] chain)
        throws KeyStoreException
    {
<span class="fc" id="L247">        KeyProtector keyProtector = null;</span>

<span class="pc bpc" id="L249" title="1 of 2 branches missed.">        if (!(key instanceof java.security.PrivateKey)) {</span>
<span class="nc" id="L250">            throw new KeyStoreException(&quot;Cannot store non-PrivateKeys&quot;);</span>
        }
        try {
<span class="fc" id="L253">            synchronized(entries) {</span>
<span class="fc" id="L254">                KeyEntry entry = new KeyEntry();</span>
<span class="fc" id="L255">                entry.date = new Date();</span>

                // Protect the encoding of the key
<span class="fc" id="L258">                keyProtector = new KeyProtector(password);</span>
<span class="fc" id="L259">                entry.protectedPrivKey = keyProtector.protect(key);</span>

                // clone the chain
<span class="pc bpc" id="L262" title="2 of 4 branches missed.">                if ((chain != null) &amp;&amp;</span>
                    (chain.length != 0)) {
<span class="fc" id="L264">                    entry.chain = chain.clone();</span>
                } else {
<span class="nc" id="L266">                    entry.chain = null;</span>
                }

<span class="fc" id="L269">                entries.put(convertAlias(alias), entry);</span>
<span class="fc" id="L270">            }</span>
<span class="nc" id="L271">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L272">            throw new KeyStoreException(&quot;Key protection algorithm not found&quot;);</span>
        } finally {
<span class="fc" id="L274">            keyProtector = null;</span>
<span class="fc" id="L275">        }</span>
<span class="fc" id="L276">    }</span>

    /**
     * Assigns the given key (that has already been protected) to the given
     * alias.
     *
     * &lt;p&gt;If the protected key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
     * certificate chain certifying the corresponding public key. If the
     * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
     * &lt;code&gt;key&lt;/code&gt; must be encoded as an
     * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
     *
     * &lt;p&gt;If the given alias already exists, the keystore information
     * associated with it is overridden by the given key (and possibly
     * certificate chain).
     *
     * @param alias the alias name
     * @param key the key (in protected format) to be associated with the alias
     * @param chain the certificate chain for the corresponding public
     * key (only useful if the protected key is of type
     * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).
     *
     * @exception KeyStoreException if this operation fails.
     */
    public void engineSetKeyEntry(String alias, byte[] key,
                                  Certificate[] chain)
        throws KeyStoreException
    {
<span class="nc" id="L305">        synchronized(entries) {</span>
            // key must be encoded as EncryptedPrivateKeyInfo as defined in
            // PKCS#8
            try {
<span class="nc" id="L309">                new EncryptedPrivateKeyInfo(key);</span>
<span class="nc" id="L310">            } catch (IOException ioe) {</span>
<span class="nc" id="L311">                throw new KeyStoreException(&quot;key is not encoded as &quot;</span>
                                            + &quot;EncryptedPrivateKeyInfo&quot;);
<span class="nc" id="L313">            }</span>

<span class="nc" id="L315">            KeyEntry entry = new KeyEntry();</span>
<span class="nc" id="L316">            entry.date = new Date();</span>

<span class="nc" id="L318">            entry.protectedPrivKey = key.clone();</span>
<span class="nc bnc" id="L319" title="All 4 branches missed.">            if ((chain != null) &amp;&amp;</span>
                (chain.length != 0)) {
<span class="nc" id="L321">                entry.chain = chain.clone();</span>
            } else {
<span class="nc" id="L323">                entry.chain = null;</span>
            }

<span class="nc" id="L326">            entries.put(convertAlias(alias), entry);</span>
<span class="nc" id="L327">        }</span>
<span class="nc" id="L328">    }</span>

    /**
     * Assigns the given certificate to the given alias.
     *
     * &lt;p&gt;If the given alias already exists in this keystore and identifies a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
     * overridden by the given certificate.
     *
     * @param alias the alias name
     * @param cert the certificate
     *
     * @exception KeyStoreException if the given alias already exists and does
     * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation
     * fails for some other reason.
     */
    public void engineSetCertificateEntry(String alias, Certificate cert)
        throws KeyStoreException
    {
<span class="fc" id="L347">        synchronized(entries) {</span>

<span class="fc" id="L349">            Object entry = entries.get(convertAlias(alias));</span>
<span class="pc bpc" id="L350" title="3 of 4 branches missed.">            if ((entry != null) &amp;&amp; (entry instanceof KeyEntry)) {</span>
<span class="nc" id="L351">                throw new KeyStoreException</span>
                    (&quot;Cannot overwrite own certificate&quot;);
            }

<span class="fc" id="L355">            TrustedCertEntry trustedCertEntry = new TrustedCertEntry();</span>
<span class="fc" id="L356">            trustedCertEntry.cert = cert;</span>
<span class="fc" id="L357">            trustedCertEntry.date = new Date();</span>
<span class="fc" id="L358">            entries.put(convertAlias(alias), trustedCertEntry);</span>
<span class="pc" id="L359">        }</span>
<span class="fc" id="L360">    }</span>

    /**
     * Deletes the entry identified by the given alias from this keystore.
     *
     * @param alias the alias name
     *
     * @exception KeyStoreException if the entry cannot be removed.
     */
    public void engineDeleteEntry(String alias)
        throws KeyStoreException
    {
<span class="nc" id="L372">        synchronized(entries) {</span>
<span class="nc" id="L373">            entries.remove(convertAlias(alias));</span>
<span class="nc" id="L374">        }</span>
<span class="nc" id="L375">    }</span>

    /**
     * Lists all the alias names of this keystore.
     *
     * @return enumeration of the alias names
     */
    public Enumeration&lt;String&gt; engineAliases() {
<span class="fc" id="L383">        return entries.keys();</span>
    }

    /**
     * Checks if the given alias exists in this keystore.
     *
     * @param alias the alias name
     *
     * @return true if the alias exists, false otherwise
     */
    public boolean engineContainsAlias(String alias) {
<span class="fc" id="L394">        return entries.containsKey(convertAlias(alias));</span>
    }

    /**
     * Retrieves the number of entries in this keystore.
     *
     * @return the number of entries in this keystore
     */
    public int engineSize() {
<span class="fc" id="L403">        return entries.size();</span>
    }

    /**
     * Returns true if the entry identified by the given alias is a
     * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
     *
     * @return true if the entry identified by the given alias is a
     * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
     */
    public boolean engineIsKeyEntry(String alias) {
<span class="fc" id="L414">        Object entry = entries.get(convertAlias(alias));</span>
<span class="pc bpc" id="L415" title="1 of 4 branches missed.">        if ((entry != null) &amp;&amp; (entry instanceof KeyEntry)) {</span>
<span class="fc" id="L416">            return true;</span>
        } else {
<span class="fc" id="L418">            return false;</span>
        }
    }

    /**
     * Returns true if the entry identified by the given alias is a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
     *
     * @return true if the entry identified by the given alias is a
     * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
     */
    public boolean engineIsCertificateEntry(String alias) {
<span class="fc" id="L430">        Object entry = entries.get(convertAlias(alias));</span>
<span class="pc bpc" id="L431" title="1 of 4 branches missed.">        if ((entry != null) &amp;&amp; (entry instanceof TrustedCertEntry)) {</span>
<span class="fc" id="L432">            return true;</span>
        } else {
<span class="fc" id="L434">            return false;</span>
        }
    }

    /**
     * Returns the (alias) name of the first keystore entry whose certificate
     * matches the given certificate.
     *
     * &lt;p&gt;This method attempts to match the given certificate with each
     * keystore entry. If the entry being considered
     * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
     * compared to that entry's certificate. If the entry being considered is
     * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
     * element of that entry's certificate chain (if a chain exists).
     *
     * @param cert the certificate to match with.
     *
     * @return the (alias) name of the first entry with matching certificate,
     * or null if no such entry exists in this keystore.
     */
    public String engineGetCertificateAlias(Certificate cert) {
        Certificate certElem;

<span class="nc bnc" id="L457" title="All 2 branches missed.">        for (Enumeration&lt;String&gt; e = entries.keys(); e.hasMoreElements(); ) {</span>
<span class="nc" id="L458">            String alias = e.nextElement();</span>
<span class="nc" id="L459">            Object entry = entries.get(alias);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">            if (entry instanceof TrustedCertEntry) {</span>
<span class="nc" id="L461">                certElem = ((TrustedCertEntry)entry).cert;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">            } else if (((KeyEntry)entry).chain != null) {</span>
<span class="nc" id="L463">                certElem = ((KeyEntry)entry).chain[0];</span>
            } else {
                continue;
            }
<span class="nc bnc" id="L467" title="All 2 branches missed.">            if (certElem.equals(cert)) {</span>
<span class="nc" id="L468">                return alias;</span>
            }
<span class="nc" id="L470">        }</span>
<span class="nc" id="L471">        return null;</span>
    }

    /**
     * Stores this keystore to the given output stream, and protects its
     * integrity with the given password.
     *
     * @param stream the output stream to which this keystore is written.
     * @param password the password to generate the keystore integrity check
     *
     * @exception IOException if there was an I/O problem with data
     * @exception NoSuchAlgorithmException if the appropriate data integrity
     * algorithm could not be found
     * @exception CertificateException if any of the certificates included in
     * the keystore data could not be stored
     */
    public void engineStore(OutputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
<span class="fc" id="L490">        synchronized(entries) {</span>
            /*
             * KEYSTORE FORMAT:
             *
             * Magic number (big-endian integer),
             * Version of this file format (big-endian integer),
             *
             * Count (big-endian integer),
             * followed by &quot;count&quot; instances of either:
             *
             *     {
             *      tag=1 (big-endian integer),
             *      alias (UTF string)
             *      timestamp
             *      encrypted private-key info according to PKCS #8
             *          (integer length followed by encoding)
             *      cert chain (integer count, then certs; for each cert,
             *          integer length followed by encoding)
             *     }
             *
             * or:
             *
             *     {
             *      tag=2 (big-endian integer)
             *      alias (UTF string)
             *      timestamp
             *      cert (integer length followed by encoding)
             *     }
             *
             * ended by a keyed SHA1 hash (bytes only) of
             *     { password + whitener + preceding body }
             */

            // password is mandatory when storing
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">            if (password == null) {</span>
<span class="nc" id="L525">                throw new IllegalArgumentException(&quot;password can't be null&quot;);</span>
            }

            byte[] encoded; // the certificate encoding

<span class="fc" id="L530">            MessageDigest md = getPreKeyedHash(password);</span>
<span class="fc" id="L531">            DataOutputStream dos</span>
                = new DataOutputStream(new DigestOutputStream(stream, md));

<span class="fc" id="L534">            dos.writeInt(MAGIC);</span>
            // always write the latest version
<span class="fc" id="L536">            dos.writeInt(VERSION_2);</span>

<span class="fc" id="L538">            dos.writeInt(entries.size());</span>

<span class="pc bpc" id="L540" title="1 of 2 branches missed.">            for (Enumeration&lt;String&gt; e = entries.keys(); e.hasMoreElements();) {</span>

<span class="nc" id="L542">                String alias = e.nextElement();</span>
<span class="nc" id="L543">                Object entry = entries.get(alias);</span>

<span class="nc bnc" id="L545" title="All 2 branches missed.">                if (entry instanceof KeyEntry) {</span>

                    // Store this entry as a KeyEntry
<span class="nc" id="L548">                    dos.writeInt(1);</span>

                    // Write the alias
<span class="nc" id="L551">                    dos.writeUTF(alias);</span>

                    // Write the (entry creation) date
<span class="nc" id="L554">                    dos.writeLong(((KeyEntry)entry).date.getTime());</span>

                    // Write the protected private key
<span class="nc" id="L557">                    dos.writeInt(((KeyEntry)entry).protectedPrivKey.length);</span>
<span class="nc" id="L558">                    dos.write(((KeyEntry)entry).protectedPrivKey);</span>

                    // Write the certificate chain
                    int chainLen;
<span class="nc bnc" id="L562" title="All 2 branches missed.">                    if (((KeyEntry)entry).chain == null) {</span>
<span class="nc" id="L563">                        chainLen = 0;</span>
                    } else {
<span class="nc" id="L565">                        chainLen = ((KeyEntry)entry).chain.length;</span>
                    }
<span class="nc" id="L567">                    dos.writeInt(chainLen);</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">                    for (int i = 0; i &lt; chainLen; i++) {</span>
<span class="nc" id="L569">                        encoded = ((KeyEntry)entry).chain[i].getEncoded();</span>
<span class="nc" id="L570">                        dos.writeUTF(((KeyEntry)entry).chain[i].getType());</span>
<span class="nc" id="L571">                        dos.writeInt(encoded.length);</span>
<span class="nc" id="L572">                        dos.write(encoded);</span>
                    }
<span class="nc" id="L574">                } else {</span>

                    // Store this entry as a certificate
<span class="nc" id="L577">                    dos.writeInt(2);</span>

                    // Write the alias
<span class="nc" id="L580">                    dos.writeUTF(alias);</span>

                    // Write the (entry creation) date
<span class="nc" id="L583">                    dos.writeLong(((TrustedCertEntry)entry).date.getTime());</span>

                    // Write the trusted certificate
<span class="nc" id="L586">                    encoded = ((TrustedCertEntry)entry).cert.getEncoded();</span>
<span class="nc" id="L587">                    dos.writeUTF(((TrustedCertEntry)entry).cert.getType());</span>
<span class="nc" id="L588">                    dos.writeInt(encoded.length);</span>
<span class="nc" id="L589">                    dos.write(encoded);</span>
                }
<span class="nc" id="L591">            }</span>

            /*
             * Write the keyed hash which is used to detect tampering with
             * the keystore (such as deleting or modifying key or
             * certificate entries).
             */
<span class="fc" id="L598">            byte digest[] = md.digest();</span>

<span class="fc" id="L600">            dos.write(digest);</span>
<span class="fc" id="L601">            dos.flush();</span>
<span class="pc" id="L602">        }</span>
<span class="fc" id="L603">    }</span>

    /**
     * Loads the keystore from the given input stream.
     *
     * &lt;p&gt;If a password is given, it is used to check the integrity of the
     * keystore data. Otherwise, the integrity of the keystore is not checked.
     *
     * @param stream the input stream from which the keystore is loaded
     * @param password the (optional) password used to check the integrity of
     * the keystore.
     *
     * @exception IOException if there is an I/O or format problem with the
     * keystore data
     * @exception NoSuchAlgorithmException if the algorithm used to check
     * the integrity of the keystore cannot be found
     * @exception CertificateException if any of the certificates in the
     * keystore could not be loaded
     */
    public void engineLoad(InputStream stream, char[] password)
        throws IOException, NoSuchAlgorithmException, CertificateException
    {
<span class="fc" id="L625">        synchronized(entries) {</span>
            DataInputStream dis;
<span class="fc" id="L627">            MessageDigest md = null;</span>
<span class="fc" id="L628">            CertificateFactory cf = null;</span>
<span class="fc" id="L629">            Hashtable&lt;String, CertificateFactory&gt; cfs = null;</span>
<span class="fc" id="L630">            ByteArrayInputStream bais = null;</span>
<span class="fc" id="L631">            byte[] encoded = null;</span>

<span class="fc bfc" id="L633" title="All 2 branches covered.">            if (stream == null)</span>
<span class="fc" id="L634">                return;</span>

<span class="fc bfc" id="L636" title="All 2 branches covered.">            if (password != null) {</span>
<span class="fc" id="L637">                md = getPreKeyedHash(password);</span>
<span class="fc" id="L638">                dis = new DataInputStream(new DigestInputStream(stream, md));</span>
            } else {
<span class="fc" id="L640">                dis = new DataInputStream(stream);</span>
            }

            // Body format: see store method

<span class="fc" id="L645">            int xMagic = dis.readInt();</span>
<span class="fc" id="L646">            int xVersion = dis.readInt();</span>

<span class="pc bpc" id="L648" title="3 of 6 branches missed.">            if (xMagic!=MAGIC ||</span>
                (xVersion!=VERSION_1 &amp;&amp; xVersion!=VERSION_2)) {
<span class="nc" id="L650">                throw new IOException(&quot;Invalid keystore format&quot;);</span>
            }

<span class="pc bpc" id="L653" title="1 of 2 branches missed.">            if (xVersion == VERSION_1) {</span>
<span class="nc" id="L654">                cf = CertificateFactory.getInstance(&quot;X509&quot;);</span>
            } else {
                // version 2
<span class="fc" id="L657">                cfs = new Hashtable&lt;String, CertificateFactory&gt;(3);</span>
            }

<span class="fc" id="L660">            entries.clear();</span>
<span class="fc" id="L661">            int count = dis.readInt();</span>

<span class="fc bfc" id="L663" title="All 2 branches covered.">            for (int i = 0; i &lt; count; i++) {</span>
                int tag;
                String alias;

<span class="fc" id="L667">                tag = dis.readInt();</span>

<span class="fc bfc" id="L669" title="All 2 branches covered.">                if (tag == 1) { // private key entry</span>

<span class="fc" id="L671">                    KeyEntry entry = new KeyEntry();</span>

                    // Read the alias
<span class="fc" id="L674">                    alias = dis.readUTF();</span>

                    // Read the (entry creation) date
<span class="fc" id="L677">                    entry.date = new Date(dis.readLong());</span>

                    // Read the private key
<span class="fc" id="L680">                    entry.protectedPrivKey =</span>
<span class="fc" id="L681">                            IOUtils.readFully(dis, dis.readInt(), true);</span>

                    // Read the certificate chain
<span class="fc" id="L684">                    int numOfCerts = dis.readInt();</span>
<span class="pc bpc" id="L685" title="1 of 2 branches missed.">                    if (numOfCerts &gt; 0) {</span>
<span class="pc bpc" id="L686" title="1 of 2 branches missed.">                        List&lt;Certificate&gt; certs = new ArrayList&lt;&gt;(</span>
                                numOfCerts &gt; 10 ? 10 : numOfCerts);
<span class="fc bfc" id="L688" title="All 2 branches covered.">                        for (int j = 0; j &lt; numOfCerts; j++) {</span>
<span class="pc bpc" id="L689" title="1 of 2 branches missed.">                            if (xVersion == 2) {</span>
                                // read the certificate type, and instantiate a
                                // certificate factory of that type (reuse
                                // existing factory if possible)
<span class="fc" id="L693">                                String certType = dis.readUTF();</span>
<span class="fc bfc" id="L694" title="All 2 branches covered.">                                if (cfs.containsKey(certType)) {</span>
                                    // reuse certificate factory
<span class="fc" id="L696">                                    cf = cfs.get(certType);</span>
                                } else {
                                    // create new certificate factory
<span class="fc" id="L699">                                    cf = CertificateFactory.getInstance(certType);</span>
                                    // store the certificate factory so we can
                                    // reuse it later
<span class="fc" id="L702">                                    cfs.put(certType, cf);</span>
                                }
                            }
                            // instantiate the certificate
<span class="fc" id="L706">                            encoded = IOUtils.readFully(dis, dis.readInt(), true);</span>
<span class="fc" id="L707">                            bais = new ByteArrayInputStream(encoded);</span>
<span class="fc" id="L708">                            certs.add(cf.generateCertificate(bais));</span>
<span class="fc" id="L709">                            bais.close();</span>
                        }
                        // We can be sure now that numOfCerts of certs are read
<span class="fc" id="L712">                        entry.chain = certs.toArray(new Certificate[numOfCerts]);</span>
                    }

                    // Add the entry to the list
<span class="fc" id="L716">                    entries.put(alias, entry);</span>

<span class="pc bpc" id="L718" title="1 of 2 branches missed.">                } else if (tag == 2) { // trusted certificate entry</span>

<span class="fc" id="L720">                    TrustedCertEntry entry = new TrustedCertEntry();</span>

                    // Read the alias
<span class="fc" id="L723">                    alias = dis.readUTF();</span>

                    // Read the (entry creation) date
<span class="fc" id="L726">                    entry.date = new Date(dis.readLong());</span>

                    // Read the trusted certificate
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">                    if (xVersion == 2) {</span>
                        // read the certificate type, and instantiate a
                        // certificate factory of that type (reuse
                        // existing factory if possible)
<span class="fc" id="L733">                        String certType = dis.readUTF();</span>
<span class="fc bfc" id="L734" title="All 2 branches covered.">                        if (cfs.containsKey(certType)) {</span>
                            // reuse certificate factory
<span class="fc" id="L736">                            cf = cfs.get(certType);</span>
                        } else {
                            // create new certificate factory
<span class="fc" id="L739">                            cf = CertificateFactory.getInstance(certType);</span>
                            // store the certificate factory so we can
                            // reuse it later
<span class="fc" id="L742">                            cfs.put(certType, cf);</span>
                        }
                    }
<span class="fc" id="L745">                    encoded = IOUtils.readFully(dis, dis.readInt(), true);</span>
<span class="fc" id="L746">                    bais = new ByteArrayInputStream(encoded);</span>
<span class="fc" id="L747">                    entry.cert = cf.generateCertificate(bais);</span>
<span class="fc" id="L748">                    bais.close();</span>

                    // Add the entry to the list
<span class="fc" id="L751">                    entries.put(alias, entry);</span>

<span class="fc" id="L753">                } else {</span>
<span class="nc" id="L754">                    throw new IOException(&quot;Unrecognized keystore entry&quot;);</span>
                }
            }

            /*
             * If a password has been provided, we check the keyed digest
             * at the end. If this check fails, the store has been tampered
             * with
             */
<span class="fc bfc" id="L763" title="All 2 branches covered.">            if (password != null) {</span>
                byte computed[], actual[];
<span class="fc" id="L765">                computed = md.digest();</span>
<span class="fc" id="L766">                actual = new byte[computed.length];</span>
<span class="fc" id="L767">                dis.readFully(actual);</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">                for (int i = 0; i &lt; computed.length; i++) {</span>
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">                    if (computed[i] != actual[i]) {</span>
<span class="nc" id="L770">                        Throwable t = new UnrecoverableKeyException</span>
                            (&quot;Password verification failed&quot;);
<span class="nc" id="L772">                        throw (IOException)new IOException</span>
                            (&quot;Keystore was tampered with, or &quot;
<span class="nc" id="L774">                            + &quot;password was incorrect&quot;).initCause(t);</span>
                    }
                }
            }
<span class="pc" id="L778">        }</span>
<span class="fc" id="L779">    }</span>

    /**
     * To guard against tampering with the keystore, we append a keyed
     * hash with a bit of whitener.
     */
    private MessageDigest getPreKeyedHash(char[] password)
        throws NoSuchAlgorithmException, UnsupportedEncodingException
    {
        int i, j;

<span class="fc" id="L790">        MessageDigest md = MessageDigest.getInstance(&quot;SHA&quot;);</span>
<span class="fc" id="L791">        byte[] passwdBytes = new byte[password.length * 2];</span>
<span class="fc bfc" id="L792" title="All 2 branches covered.">        for (i=0, j=0; i&lt;password.length; i++) {</span>
<span class="fc" id="L793">            passwdBytes[j++] = (byte)(password[i] &gt;&gt; 8);</span>
<span class="fc" id="L794">            passwdBytes[j++] = (byte)password[i];</span>
        }
<span class="fc" id="L796">        md.update(passwdBytes);</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">        for (i=0; i&lt;passwdBytes.length; i++)</span>
<span class="fc" id="L798">            passwdBytes[i] = 0;</span>
<span class="fc" id="L799">        md.update(&quot;Mighty Aphrodite&quot;.getBytes(&quot;UTF8&quot;));</span>
<span class="fc" id="L800">        return md;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>