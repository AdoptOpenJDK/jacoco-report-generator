<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Cache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.misc</a> &gt; <span class="el_source">Cache.java</span></div><h1>Cache.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 1996, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.misc;

import java.util.Dictionary;
import java.util.Enumeration;
import java.util.NoSuchElementException;

/**
 * Caches the collision list.
 */
<span class="nc" id="L35">class CacheEntry extends Ref {</span>
    int hash;
    Object key;
    CacheEntry next;
    public Object reconstitute() {
<span class="nc" id="L40">        return null;</span>
    }
}

/**
 * The Cache class. Maps keys to values. Any object can be used as
 * a key and/or value.  This is very similar to the Hashtable
 * class, except that after putting an object into the Cache,
 * it is not guaranteed that a subsequent get will return it.
 * The Cache will automatically remove entries if memory is
 * getting tight and if the entry is not referenced from outside
 * the Cache.&lt;p&gt;
 *
 * To sucessfully store and retrieve objects from a hash table the
 * object used as the key must implement the hashCode() and equals()
 * methods.&lt;p&gt;
 *
 * This example creates a Cache of numbers. It uses the names of
 * the numbers as keys:
 * &lt;pre&gt;
 *      Cache numbers = new Cache();
 *      numbers.put(&quot;one&quot;, new Integer(1));
 *      numbers.put(&quot;two&quot;, new Integer(1));
 *      numbers.put(&quot;three&quot;, new Integer(1));
 * &lt;/pre&gt;
 * To retrieve a number use:
 * &lt;pre&gt;
 *      Integer n = (Integer)numbers.get(&quot;two&quot;);
 *      if (n != null) {
 *          System.out.println(&quot;two = &quot; + n);
 *      }
 * &lt;/pre&gt;
 *
 * @see java.lang.Object#hashCode
 * @see java.lang.Object#equals
 * @see sun.misc.Ref
 */
public
class Cache extends Dictionary {
    /**
     * The hash table data.
     */
    private CacheEntry table[];

    /**
     * The total number of entries in the hash table.
     */
    private int count;

    /**
     * Rehashes the table when count exceeds this threshold.
     */
    private int threshold;

    /**
     * The load factor for the hashtable.
     */
    private float loadFactor;

    private void init(int initialCapacity, float loadFactor) {
<span class="nc bnc" id="L100" title="All 4 branches missed.">        if ((initialCapacity &lt;= 0) || (loadFactor &lt;= 0.0)) {</span>
<span class="nc" id="L101">            throw new IllegalArgumentException();</span>
        }
<span class="nc" id="L103">        this.loadFactor = loadFactor;</span>
<span class="nc" id="L104">        table = new CacheEntry[initialCapacity];</span>
<span class="nc" id="L105">        threshold = (int) (initialCapacity * loadFactor);</span>
<span class="nc" id="L106">    }</span>

    /**
     * Constructs a new, empty Cache with the specified initial
     * capacity and the specified load factor.
     * @param initialCapacity the initial number of buckets
     * @param loadFactor a number between 0.0 and 1.0, it defines
     *          the threshold for rehashing the Cache into
     *          a bigger one.
     * @exception IllegalArgumentException If the initial capacity
     * is less than or equal to zero.
     * @exception IllegalArgumentException If the load factor is
     * less than or equal to zero.
     */
<span class="nc" id="L120">    public Cache (int initialCapacity, float loadFactor) {</span>
<span class="nc" id="L121">        init(initialCapacity, loadFactor);</span>
<span class="nc" id="L122">    }</span>

    /**
     * Constructs a new, empty Cache with the specified initial
     * capacity.
     * @param initialCapacity the initial number of buckets
     */
<span class="nc" id="L129">    public Cache (int initialCapacity) {</span>
<span class="nc" id="L130">        init(initialCapacity, 0.75f);</span>
<span class="nc" id="L131">    }</span>

    /**
     * Constructs a new, empty Cache. A default capacity and load factor
     * is used. Note that the Cache will automatically grow when it gets
     * full.
     */
<span class="nc" id="L138">    public Cache () {</span>
        try {
<span class="nc" id="L140">            init(101, 0.75f);</span>
<span class="nc" id="L141">        } catch (IllegalArgumentException ex) {</span>
            // This should never happen
<span class="nc" id="L143">            throw new Error(&quot;panic&quot;);</span>
<span class="nc" id="L144">        }</span>
<span class="nc" id="L145">    }</span>

    /**
     * Returns the number of elements contained within the Cache.
     */
    public int size() {
<span class="nc" id="L151">        return count;</span>
    }

    /**
     * Returns true if the Cache contains no elements.
     */
    public boolean isEmpty() {
<span class="nc bnc" id="L158" title="All 2 branches missed.">        return count == 0;</span>
    }

    /**
     * Returns an enumeration of the Cache's keys.
     * @see Cache#elements
     * @see Enumeration
     */
    public synchronized Enumeration keys() {
<span class="nc" id="L167">        return new CacheEnumerator(table, true);</span>
    }

    /**
     * Returns an enumeration of the elements. Use the Enumeration methods
     * on the returned object to fetch the elements sequentially.
     * @see Cache#keys
     * @see Enumeration
     */
    public synchronized Enumeration elements() {
<span class="nc" id="L177">        return new CacheEnumerator(table, false);</span>
    }

    /**
     * Gets the object associated with the specified key in the Cache.
     * @param key the key in the hash table
     * @returns the element for the key or null if the key
     *          is not defined in the hash table.
     * @see Cache#put
     */
    public synchronized Object get(Object key) {
<span class="nc" id="L188">        CacheEntry tab[] = table;</span>
<span class="nc" id="L189">        int hash = key.hashCode();</span>
<span class="nc" id="L190">        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        for (CacheEntry e = tab[index]; e != null; e = e.next) {</span>
<span class="nc bnc" id="L192" title="All 4 branches missed.">            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {</span>
<span class="nc" id="L193">                return e.check();</span>
            }
        }
<span class="nc" id="L196">        return null;</span>
    }

    /**
     * Rehashes the contents of the table into a bigger table.
     * This is method is called automatically when the Cache's
     * size exceeds the threshold.
     */
    protected void rehash() {
<span class="nc" id="L205">        int oldCapacity = table.length;</span>
<span class="nc" id="L206">        CacheEntry oldTable[] = table;</span>

<span class="nc" id="L208">        int newCapacity = oldCapacity * 2 + 1;</span>
<span class="nc" id="L209">        CacheEntry newTable[] = new CacheEntry[newCapacity];</span>

<span class="nc" id="L211">        threshold = (int) (newCapacity * loadFactor);</span>
<span class="nc" id="L212">        table = newTable;</span>

        // System.out.println(&quot;rehash old=&quot; + oldCapacity + &quot;, new=&quot; +
        // newCapacity + &quot;, thresh=&quot; + threshold + &quot;, count=&quot; + count);

<span class="nc bnc" id="L217" title="All 2 branches missed.">        for (int i = oldCapacity; i-- &gt; 0;) {</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            for (CacheEntry old = oldTable[i]; old != null;) {</span>
<span class="nc" id="L219">                CacheEntry e = old;</span>
<span class="nc" id="L220">                old = old.next;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">                if (e.check() != null) {</span>
<span class="nc" id="L222">                    int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span>
<span class="nc" id="L223">                    e.next = newTable[index];</span>
<span class="nc" id="L224">                    newTable[index] = e;</span>
<span class="nc" id="L225">                } else</span>
<span class="nc" id="L226">                    count--;    /* remove entries that have disappeared */</span>
<span class="nc" id="L227">            }</span>
        }
<span class="nc" id="L229">    }</span>

    /**
     * Puts the specified element into the Cache, using the specified
     * key.  The element may be retrieved by doing a get() with the same
     * key.  The key and the element cannot be null.
     * @param key the specified hashtable key
     * @param value the specified element
     * @return the old value of the key, or null if it did not have one.
     * @exception NullPointerException If the value of the specified
     * element is null.
     * @see Cache#get
     */
    public synchronized Object put(Object key, Object value) {
        // Make sure the value is not null
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L245">            throw new NullPointerException();</span>
        }
        // Makes sure the key is not already in the cache.
<span class="nc" id="L248">        CacheEntry tab[] = table;</span>
<span class="nc" id="L249">        int hash = key.hashCode();</span>
<span class="nc" id="L250">        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span>
<span class="nc" id="L251">        CacheEntry ne = null;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        for (CacheEntry e = tab[index]; e != null; e = e.next) {</span>
<span class="nc bnc" id="L253" title="All 4 branches missed.">            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {</span>
<span class="nc" id="L254">                Object old = e.check();</span>
<span class="nc" id="L255">                e.setThing(value);</span>
<span class="nc" id="L256">                return old;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            } else if (e.check() == null)</span>
<span class="nc" id="L258">                ne = e;         /* reuse old flushed value */</span>
        }

<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (count &gt;= threshold) {</span>
            // Rehash the table if the threshold is exceeded
<span class="nc" id="L263">            rehash();</span>
<span class="nc" id="L264">            return put(key, value);</span>
        }
        // Creates the new entry.
<span class="nc bnc" id="L267" title="All 2 branches missed.">        if (ne == null) {</span>
<span class="nc" id="L268">            ne = new CacheEntry ();</span>
<span class="nc" id="L269">            ne.next = tab[index];</span>
<span class="nc" id="L270">            tab[index] = ne;</span>
<span class="nc" id="L271">            count++;</span>
        }
<span class="nc" id="L273">        ne.hash = hash;</span>
<span class="nc" id="L274">        ne.key = key;</span>
<span class="nc" id="L275">        ne.setThing(value);</span>
<span class="nc" id="L276">        return null;</span>
    }

    /**
     * Removes the element corresponding to the key. Does nothing if the
     * key is not present.
     * @param key the key that needs to be removed
     * @return the value of key, or null if the key was not found.
     */
    public synchronized Object remove(Object key) {
<span class="nc" id="L286">        CacheEntry tab[] = table;</span>
<span class="nc" id="L287">        int hash = key.hashCode();</span>
<span class="nc" id="L288">        int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">        for (CacheEntry e = tab[index], prev = null; e != null; prev = e, e = e.next) {</span>
<span class="nc bnc" id="L290" title="All 4 branches missed.">            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                if (prev != null) {</span>
<span class="nc" id="L292">                    prev.next = e.next;</span>
                } else {
<span class="nc" id="L294">                    tab[index] = e.next;</span>
                }
<span class="nc" id="L296">                count--;</span>
<span class="nc" id="L297">                return e.check();</span>
            }
        }
<span class="nc" id="L300">        return null;</span>
    }
}

/**
 * A Cache enumerator class.  This class should remain opaque
 * to the client. It will use the Enumeration interface.
 */
class CacheEnumerator implements Enumeration {
    boolean keys;
    int index;
    CacheEntry table[];
    CacheEntry entry;

<span class="nc" id="L314">    CacheEnumerator (CacheEntry table[], boolean keys) {</span>
<span class="nc" id="L315">        this.table = table;</span>
<span class="nc" id="L316">        this.keys = keys;</span>
<span class="nc" id="L317">        this.index = table.length;</span>
<span class="nc" id="L318">    }</span>

    public boolean hasMoreElements() {
<span class="nc bnc" id="L321" title="All 2 branches missed.">        while (index &gt;= 0) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            while (entry != null)</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                if (entry.check() != null)</span>
<span class="nc" id="L324">                    return true;</span>
                else
<span class="nc" id="L326">                    entry = entry.next;</span>
<span class="nc bnc" id="L327" title="All 4 branches missed.">            while (--index &gt;= 0 &amp;&amp; (entry = table[index]) == null) ;</span>
        }
<span class="nc" id="L329">        return false;</span>
    }

    public Object nextElement() {
<span class="nc bnc" id="L333" title="All 2 branches missed.">        while (index &gt;= 0) {</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">            if (entry == null)</span>
<span class="nc bnc" id="L335" title="All 4 branches missed.">                while (--index &gt;= 0 &amp;&amp; (entry = table[index]) == null) ;</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (entry != null) {</span>
<span class="nc" id="L337">                CacheEntry e = entry;</span>
<span class="nc" id="L338">                entry = e.next;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">                if (e.check() != null)</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                    return keys ? e.key : e.check();</span>
<span class="nc" id="L341">            }</span>
        }
<span class="nc" id="L343">        throw new NoSuchElementException(&quot;CacheEnumerator&quot;);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>