<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FDBigInteger.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.misc</a> &gt; <span class="el_source">FDBigInteger.java</span></div><h1>FDBigInteger.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package sun.misc;

import java.math.BigInteger;
import java.util.Arrays;
//@ model import org.jmlspecs.models.JMLMath;

/**
 * A simple big integer package specifically for floating point base conversion.
 */
<span class="fc bfc" id="L34" title="All 2 branches covered.">public /*@ spec_bigint_math @*/ class FDBigInteger {</span>

    //
    // This class contains many comments that start with &quot;/*@&quot; mark.
    // They are behavourial specification in
    // the Java Modelling Language (JML):
    // http://www.eecs.ucf.edu/~leavens/JML//index.shtml
    //

    /*@
    @ public pure model static \bigint UNSIGNED(int v) {
    @     return v &gt;= 0 ? v : v + (((\bigint)1) &lt;&lt; 32);
    @ }
    @
    @ public pure model static \bigint UNSIGNED(long v) {
    @     return v &gt;= 0 ? v : v + (((\bigint)1) &lt;&lt; 64);
    @ }
    @
    @ public pure model static \bigint AP(int[] data, int len) {
    @     return (\sum int i; 0 &lt;= 0 &amp;&amp; i &lt; len; UNSIGNED(data[i]) &lt;&lt; (i*32));
    @ }
    @
    @ public pure model static \bigint pow52(int p5, int p2) {
    @     ghost \bigint v = 1;
    @     for (int i = 0; i &lt; p5; i++) v *= 5;
    @     return v &lt;&lt; p2;
    @ }
    @
    @ public pure model static \bigint pow10(int p10) {
    @     return pow52(p10, p10);
    @ }
    @*/

<span class="fc" id="L67">    static final int[] SMALL_5_POW = {</span>
            1,
            5,
            5 * 5,
            5 * 5 * 5,
            5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5
    };

<span class="fc" id="L84">    static final long[] LONG_5_POW = {</span>
            1L,
            5L,
            5L * 5,
            5L * 5 * 5,
            5L * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
            5L * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5 * 5,
    };

    // Maximum size of cache of powers of 5 as FDBigIntegers.
    private static final int MAX_FIVE_POW = 340;

    // Cache of big powers of 5 as FDBigIntegers.
    private static final FDBigInteger POW_5_CACHE[];

    // Initialize FDBigInteger cache of powers of 5.
    static {
<span class="fc" id="L122">        POW_5_CACHE = new FDBigInteger[MAX_FIVE_POW];</span>
<span class="fc" id="L123">        int i = 0;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        while (i &lt; SMALL_5_POW.length) {</span>
<span class="fc" id="L125">            FDBigInteger pow5 = new FDBigInteger(new int[]{SMALL_5_POW[i]}, 0);</span>
<span class="fc" id="L126">            pow5.makeImmutable();</span>
<span class="fc" id="L127">            POW_5_CACHE[i] = pow5;</span>
<span class="fc" id="L128">            i++;</span>
<span class="fc" id="L129">        }</span>
<span class="fc" id="L130">        FDBigInteger prev = POW_5_CACHE[i - 1];</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        while (i &lt; MAX_FIVE_POW) {</span>
<span class="fc" id="L132">            POW_5_CACHE[i] = prev = prev.mult(5);</span>
<span class="fc" id="L133">            prev.makeImmutable();</span>
<span class="fc" id="L134">            i++;</span>
        }
    }

    // Zero as an FDBigInteger.
<span class="fc" id="L139">    public static final FDBigInteger ZERO = new FDBigInteger(new int[0], 0);</span>

    // Ensure ZERO is immutable.
    static {
<span class="fc" id="L143">        ZERO.makeImmutable();</span>
<span class="fc" id="L144">    }</span>

    // Constant for casting an int to a long via bitwise AND.
    private final static long LONG_MASK = 0xffffffffL;

    //@ spec_public non_null;
    private int data[];  // value: data[0] is least significant
    //@ spec_public;
    private int offset;  // number of least significant zero padding ints
    //@ spec_public;
    private int nWords;  // data[nWords-1]!=0, all values above are zero
                 // if nWords==0 -&gt; this FDBigInteger is zero
    //@ spec_public;
<span class="fc" id="L157">    private boolean isImmutable = false;</span>

    /*@
     @ public invariant 0 &lt;= nWords &amp;&amp; nWords &lt;= data.length &amp;&amp; offset &gt;= 0;
     @ public invariant nWords == 0 ==&gt; offset == 0;
     @ public invariant nWords &gt; 0 ==&gt; data[nWords - 1] != 0;
     @ public invariant (\forall int i; nWords &lt;= i &amp;&amp; i &lt; data.length; data[i] == 0);
     @ public pure model \bigint value() {
     @     return AP(data, nWords) &lt;&lt; (offset*32);
     @ }
     @*/

    /**
     * Constructs an &lt;code&gt;FDBigInteger&lt;/code&gt; from data and padding. The
     * &lt;code&gt;data&lt;/code&gt; parameter has the least significant &lt;code&gt;int&lt;/code&gt; at
     * the zeroth index. The &lt;code&gt;offset&lt;/code&gt; parameter gives the number of
     * zero &lt;code&gt;int&lt;/code&gt;s to be inferred below the least significant element
     * of &lt;code&gt;data&lt;/code&gt;.
     *
     * @param data An array containing all non-zero &lt;code&gt;int&lt;/code&gt;s of the value.
     * @param offset An offset indicating the number of zero &lt;code&gt;int&lt;/code&gt;s to pad
     * below the least significant element of &lt;code&gt;data&lt;/code&gt;.
     */
    /*@
     @ requires data != null &amp;&amp; offset &gt;= 0;
     @ ensures this.value() == \old(AP(data, data.length) &lt;&lt; (offset*32));
     @ ensures this.data == \old(data);
     @*/
<span class="fc" id="L185">    private FDBigInteger(int[] data, int offset) {</span>
<span class="fc" id="L186">        this.data = data;</span>
<span class="fc" id="L187">        this.offset = offset;</span>
<span class="fc" id="L188">        this.nWords = data.length;</span>
<span class="fc" id="L189">        trimLeadingZeros();</span>
<span class="fc" id="L190">    }</span>

    /**
     * Constructs an &lt;code&gt;FDBigInteger&lt;/code&gt; from a starting value and some
     * decimal digits.
     *
     * @param lValue The starting value.
     * @param digits The decimal digits.
     * @param kDigits The initial index into &lt;code&gt;digits&lt;/code&gt;.
     * @param nDigits The final index into &lt;code&gt;digits&lt;/code&gt;.
     */
    /*@
     @ requires digits != null;
     @ requires 0 &lt;= kDigits &amp;&amp; kDigits &lt;= nDigits &amp;&amp; nDigits &lt;= digits.length;
     @ requires (\forall int i; 0 &lt;= i &amp;&amp; i &lt; nDigits; '0' &lt;= digits[i] &amp;&amp; digits[i] &lt;= '9');
     @ ensures this.value() == \old(lValue * pow10(nDigits - kDigits) + (\sum int i; kDigits &lt;= i &amp;&amp; i &lt; nDigits; (digits[i] - '0') * pow10(nDigits - i - 1)));
     @*/
<span class="fc" id="L207">    public FDBigInteger(long lValue, char[] digits, int kDigits, int nDigits) {</span>
<span class="fc" id="L208">        int n = Math.max((nDigits + 8) / 9, 2);        // estimate size needed.</span>
<span class="fc" id="L209">        data = new int[n];      // allocate enough space</span>
<span class="fc" id="L210">        data[0] = (int) lValue;    // starting value</span>
<span class="fc" id="L211">        data[1] = (int) (lValue &gt;&gt;&gt; 32);</span>
<span class="fc" id="L212">        offset = 0;</span>
<span class="fc" id="L213">        nWords = 2;</span>
<span class="fc" id="L214">        int i = kDigits;</span>
<span class="fc" id="L215">        int limit = nDigits - 5;       // slurp digits 5 at a time.</span>
        int v;
<span class="fc bfc" id="L217" title="All 2 branches covered.">        while (i &lt; limit) {</span>
<span class="fc" id="L218">            int ilim = i + 5;</span>
<span class="fc" id="L219">            v = (int) digits[i++] - (int) '0';</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            while (i &lt; ilim) {</span>
<span class="fc" id="L221">                v = 10 * v + (int) digits[i++] - (int) '0';</span>
            }
<span class="fc" id="L223">            multAddMe(100000, v); // ... where 100000 is 10^5.</span>
<span class="fc" id="L224">        }</span>
<span class="fc" id="L225">        int factor = 1;</span>
<span class="fc" id="L226">        v = 0;</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">        while (i &lt; nDigits) {</span>
<span class="fc" id="L228">            v = 10 * v + (int) digits[i++] - (int) '0';</span>
<span class="fc" id="L229">            factor *= 10;</span>
        }
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (factor != 1) {</span>
<span class="fc" id="L232">            multAddMe(factor, v);</span>
        }
<span class="fc" id="L234">        trimLeadingZeros();</span>
<span class="fc" id="L235">    }</span>

    /**
     * Returns an &lt;code&gt;FDBigInteger&lt;/code&gt; with the numerical value
     * &lt;code&gt;5&lt;sup&gt;p5&lt;/sup&gt; * 2&lt;sup&gt;p2&lt;/sup&gt;&lt;/code&gt;.
     *
     * @param p5 The exponent of the power-of-five factor.
     * @param p2 The exponent of the power-of-two factor.
     * @return &lt;code&gt;5&lt;sup&gt;p5&lt;/sup&gt; * 2&lt;sup&gt;p2&lt;/sup&gt;&lt;/code&gt;
     */
    /*@
     @ requires p5 &gt;= 0 &amp;&amp; p2 &gt;= 0;
     @ assignable \nothing;
     @ ensures \result.value() == \old(pow52(p5, p2));
     @*/
    public static FDBigInteger valueOfPow52(int p5, int p2) {
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (p5 != 0) {</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">            if (p2 == 0) {</span>
<span class="fc" id="L253">                return big5pow(p5);</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">            } else if (p5 &lt; SMALL_5_POW.length) {</span>
<span class="fc" id="L255">                int pow5 = SMALL_5_POW[p5];</span>
<span class="fc" id="L256">                int wordcount = p2 &gt;&gt; 5;</span>
<span class="fc" id="L257">                int bitcount = p2 &amp; 0x1f;</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">                if (bitcount == 0) {</span>
<span class="fc" id="L259">                    return new FDBigInteger(new int[]{pow5}, wordcount);</span>
                } else {
<span class="fc" id="L261">                    return new FDBigInteger(new int[]{</span>
                            pow5 &lt;&lt; bitcount,
                            pow5 &gt;&gt;&gt; (32 - bitcount)
                    }, wordcount);
                }
            } else {
<span class="fc" id="L267">                return big5pow(p5).leftShift(p2);</span>
            }
        } else {
<span class="fc" id="L270">            return valueOfPow2(p2);</span>
        }
    }

    /**
     * Returns an &lt;code&gt;FDBigInteger&lt;/code&gt; with the numerical value
     * &lt;code&gt;value * 5&lt;sup&gt;p5&lt;/sup&gt; * 2&lt;sup&gt;p2&lt;/sup&gt;&lt;/code&gt;.
     *
     * @param value The constant factor.
     * @param p5 The exponent of the power-of-five factor.
     * @param p2 The exponent of the power-of-two factor.
     * @return &lt;code&gt;value * 5&lt;sup&gt;p5&lt;/sup&gt; * 2&lt;sup&gt;p2&lt;/sup&gt;&lt;/code&gt;
     */
    /*@
     @ requires p5 &gt;= 0 &amp;&amp; p2 &gt;= 0;
     @ assignable \nothing;
     @ ensures \result.value() == \old(UNSIGNED(value) * pow52(p5, p2));
     @*/
    public static FDBigInteger valueOfMulPow52(long value, int p5, int p2) {
<span class="pc bpc" id="L289" title="2 of 4 branches missed.">        assert p5 &gt;= 0 : p5;</span>
<span class="pc bpc" id="L290" title="2 of 4 branches missed.">        assert p2 &gt;= 0 : p2;</span>
<span class="fc" id="L291">        int v0 = (int) value;</span>
<span class="fc" id="L292">        int v1 = (int) (value &gt;&gt;&gt; 32);</span>
<span class="fc" id="L293">        int wordcount = p2 &gt;&gt; 5;</span>
<span class="fc" id="L294">        int bitcount = p2 &amp; 0x1f;</span>
<span class="fc bfc" id="L295" title="All 2 branches covered.">        if (p5 != 0) {</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            if (p5 &lt; SMALL_5_POW.length) {</span>
<span class="fc" id="L297">                long pow5 = SMALL_5_POW[p5] &amp; LONG_MASK;</span>
<span class="fc" id="L298">                long carry = (v0 &amp; LONG_MASK) * pow5;</span>
<span class="fc" id="L299">                v0 = (int) carry;</span>
<span class="fc" id="L300">                carry &gt;&gt;&gt;= 32;</span>
<span class="fc" id="L301">                carry = (v1 &amp; LONG_MASK) * pow5 + carry;</span>
<span class="fc" id="L302">                v1 = (int) carry;</span>
<span class="fc" id="L303">                int v2 = (int) (carry &gt;&gt;&gt; 32);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">                if (bitcount == 0) {</span>
<span class="fc" id="L305">                    return new FDBigInteger(new int[]{v0, v1, v2}, wordcount);</span>
                } else {
<span class="fc" id="L307">                    return new FDBigInteger(new int[]{</span>
                            v0 &lt;&lt; bitcount,
                            (v1 &lt;&lt; bitcount) | (v0 &gt;&gt;&gt; (32 - bitcount)),
                            (v2 &lt;&lt; bitcount) | (v1 &gt;&gt;&gt; (32 - bitcount)),
                            v2 &gt;&gt;&gt; (32 - bitcount)
                    }, wordcount);
                }
            } else {
<span class="fc" id="L315">                FDBigInteger pow5 = big5pow(p5);</span>
                int[] r;
<span class="fc bfc" id="L317" title="All 2 branches covered.">                if (v1 == 0) {</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">                    r = new int[pow5.nWords + 1 + ((p2 != 0) ? 1 : 0)];</span>
<span class="fc" id="L319">                    mult(pow5.data, pow5.nWords, v0, r);</span>
                } else {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">                    r = new int[pow5.nWords + 2 + ((p2 != 0) ? 1 : 0)];</span>
<span class="fc" id="L322">                    mult(pow5.data, pow5.nWords, v0, v1, r);</span>
                }
<span class="fc" id="L324">                return (new FDBigInteger(r, pow5.offset)).leftShift(p2);</span>
            }
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        } else if (p2 != 0) {</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">            if (bitcount == 0) {</span>
<span class="fc" id="L328">                return new FDBigInteger(new int[]{v0, v1}, wordcount);</span>
            } else {
<span class="fc" id="L330">                return new FDBigInteger(new int[]{</span>
                         v0 &lt;&lt; bitcount,
                        (v1 &lt;&lt; bitcount) | (v0 &gt;&gt;&gt; (32 - bitcount)),
                        v1 &gt;&gt;&gt; (32 - bitcount)
                }, wordcount);
            }
        }
<span class="nc" id="L337">        return new FDBigInteger(new int[]{v0, v1}, 0);</span>
    }

    /**
     * Returns an &lt;code&gt;FDBigInteger&lt;/code&gt; with the numerical value
     * &lt;code&gt;2&lt;sup&gt;p2&lt;/sup&gt;&lt;/code&gt;.
     *
     * @param p2 The exponent of 2.
     * @return &lt;code&gt;2&lt;sup&gt;p2&lt;/sup&gt;&lt;/code&gt;
     */
    /*@
     @ requires p2 &gt;= 0;
     @ assignable \nothing;
     @ ensures \result.value() == pow52(0, p2);
     @*/
    private static FDBigInteger valueOfPow2(int p2) {
<span class="fc" id="L353">        int wordcount = p2 &gt;&gt; 5;</span>
<span class="fc" id="L354">        int bitcount = p2 &amp; 0x1f;</span>
<span class="fc" id="L355">        return new FDBigInteger(new int[]{1 &lt;&lt; bitcount}, wordcount);</span>
    }

    /**
     * Removes all leading zeros from this &lt;code&gt;FDBigInteger&lt;/code&gt; adjusting
     * the offset and number of non-zero leading words accordingly.
     */
    /*@
     @ requires data != null;
     @ requires 0 &lt;= nWords &amp;&amp; nWords &lt;= data.length &amp;&amp; offset &gt;= 0;
     @ requires nWords == 0 ==&gt; offset == 0;
     @ ensures nWords == 0 ==&gt; offset == 0;
     @ ensures nWords &gt; 0 ==&gt; data[nWords - 1] != 0;
     @*/
    private /*@ helper @*/ void trimLeadingZeros() {
<span class="fc" id="L370">        int i = nWords;</span>
<span class="fc bfc" id="L371" title="All 4 branches covered.">        if (i &gt; 0 &amp;&amp; (data[--i] == 0)) {</span>
            //for (; i &gt; 0 &amp;&amp; data[i - 1] == 0; i--) ;
<span class="pc bpc" id="L373" title="1 of 4 branches missed.">            while(i &gt; 0 &amp;&amp; data[i - 1] == 0) {</span>
<span class="fc" id="L374">                i--;</span>
            }
<span class="fc" id="L376">            this.nWords = i;</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">            if (i == 0) { // all words are zero</span>
<span class="nc" id="L378">                this.offset = 0;</span>
            }
        }
<span class="fc" id="L381">    }</span>

    /**
     * Retrieves the normalization bias of the &lt;code&gt;FDBigIntger&lt;/code&gt;. The
     * normalization bias is a left shift such that after it the highest word
     * of the value will have the 4 highest bits equal to zero:
     * &lt;code&gt;(highestWord &amp; 0xf0000000) == 0&lt;/code&gt;, but the next bit should be 1
     * &lt;code&gt;(highestWord &amp; 0x08000000) != 0&lt;/code&gt;.
     *
     * @return The normalization bias.
     */
    /*@
     @ requires this.value() &gt; 0;
     @*/
    public /*@ pure @*/ int getNormalizationBias() {
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (nWords == 0) {</span>
<span class="nc" id="L397">            throw new IllegalArgumentException(&quot;Zero value cannot be normalized&quot;);</span>
        }
<span class="fc" id="L399">        int zeros = Integer.numberOfLeadingZeros(data[nWords - 1]);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        return (zeros &lt; 4) ? 28 + zeros : zeros - 4;</span>
    }

    // TODO: Why is anticount param needed if it is always 32 - bitcount?
    /**
     * Left shifts the contents of one int array into another.
     *
     * @param src The source array.
     * @param idx The initial index of the source array.
     * @param result The destination array.
     * @param bitcount The left shift.
     * @param anticount The left anti-shift, e.g., &lt;code&gt;32-bitcount&lt;/code&gt;.
     * @param prev The prior source value.
     */
    /*@
     @ requires 0 &lt; bitcount &amp;&amp; bitcount &lt; 32 &amp;&amp; anticount == 32 - bitcount;
     @ requires src.length &gt;= idx &amp;&amp; result.length &gt; idx;
     @ assignable result[*];
     @ ensures AP(result, \old(idx + 1)) == \old((AP(src, idx) + UNSIGNED(prev) &lt;&lt; (idx*32)) &lt;&lt; bitcount);
     @*/
    private static void leftShift(int[] src, int idx, int result[], int bitcount, int anticount, int prev){
<span class="fc bfc" id="L421" title="All 2 branches covered.">        for (; idx &gt; 0; idx--) {</span>
<span class="fc" id="L422">            int v = (prev &lt;&lt; bitcount);</span>
<span class="fc" id="L423">            prev = src[idx - 1];</span>
<span class="fc" id="L424">            v |= (prev &gt;&gt;&gt; anticount);</span>
<span class="fc" id="L425">            result[idx] = v;</span>
        }
<span class="fc" id="L427">        int v = prev &lt;&lt; bitcount;</span>
<span class="fc" id="L428">        result[0] = v;</span>
<span class="fc" id="L429">    }</span>

    /**
     * Shifts this &lt;code&gt;FDBigInteger&lt;/code&gt; to the left. The shift is performed
     * in-place unless the &lt;code&gt;FDBigInteger&lt;/code&gt; is immutable in which case
     * a new instance of &lt;code&gt;FDBigInteger&lt;/code&gt; is returned.
     *
     * @param shift The number of bits to shift left.
     * @return The shifted &lt;code&gt;FDBigInteger&lt;/code&gt;.
     */
    /*@
     @ requires this.value() == 0 || shift == 0;
     @ assignable \nothing;
     @ ensures \result == this;
     @
     @  also
     @
     @ requires this.value() &gt; 0 &amp;&amp; shift &gt; 0 &amp;&amp; this.isImmutable;
     @ assignable \nothing;
     @ ensures \result.value() == \old(this.value() &lt;&lt; shift);
     @
     @  also
     @
     @ requires this.value() &gt; 0 &amp;&amp; shift &gt; 0 &amp;&amp; this.isImmutable;
     @ assignable \nothing;
     @ ensures \result == this;
     @ ensures \result.value() == \old(this.value() &lt;&lt; shift);
     @*/
    public FDBigInteger leftShift(int shift) {
<span class="pc bpc" id="L458" title="1 of 4 branches missed.">        if (shift == 0 || nWords == 0) {</span>
<span class="fc" id="L459">            return this;</span>
        }
<span class="fc" id="L461">        int wordcount = shift &gt;&gt; 5;</span>
<span class="fc" id="L462">        int bitcount = shift &amp; 0x1f;</span>
<span class="fc bfc" id="L463" title="All 2 branches covered.">        if (this.isImmutable) {</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">            if (bitcount == 0) {</span>
<span class="nc" id="L465">                return new FDBigInteger(Arrays.copyOf(data, nWords), offset + wordcount);</span>
            } else {
<span class="fc" id="L467">                int anticount = 32 - bitcount;</span>
<span class="fc" id="L468">                int idx = nWords - 1;</span>
<span class="fc" id="L469">                int prev = data[idx];</span>
<span class="fc" id="L470">                int hi = prev &gt;&gt;&gt; anticount;</span>
                int[] result;
<span class="fc bfc" id="L472" title="All 2 branches covered.">                if (hi != 0) {</span>
<span class="fc" id="L473">                    result = new int[nWords + 1];</span>
<span class="fc" id="L474">                    result[nWords] = hi;</span>
                } else {
<span class="fc" id="L476">                    result = new int[nWords];</span>
                }
<span class="fc" id="L478">                leftShift(data,idx,result,bitcount,anticount,prev);</span>
<span class="fc" id="L479">                return new FDBigInteger(result, offset + wordcount);</span>
            }
        } else {
<span class="fc bfc" id="L482" title="All 2 branches covered.">            if (bitcount != 0) {</span>
<span class="fc" id="L483">                int anticount = 32 - bitcount;</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">                if ((data[0] &lt;&lt; bitcount) == 0) {</span>
<span class="fc" id="L485">                    int idx = 0;</span>
<span class="fc" id="L486">                    int prev = data[idx];</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">                    for (; idx &lt; nWords - 1; idx++) {</span>
<span class="fc" id="L488">                        int v = (prev &gt;&gt;&gt; anticount);</span>
<span class="fc" id="L489">                        prev = data[idx + 1];</span>
<span class="fc" id="L490">                        v |= (prev &lt;&lt; bitcount);</span>
<span class="fc" id="L491">                        data[idx] = v;</span>
                    }
<span class="fc" id="L493">                    int v = prev &gt;&gt;&gt; anticount;</span>
<span class="fc" id="L494">                    data[idx] = v;</span>
<span class="fc bfc" id="L495" title="All 2 branches covered.">                    if(v==0) {</span>
<span class="fc" id="L496">                        nWords--;</span>
                    }
<span class="fc" id="L498">                    offset++;</span>
<span class="fc" id="L499">                } else {</span>
<span class="fc" id="L500">                    int idx = nWords - 1;</span>
<span class="fc" id="L501">                    int prev = data[idx];</span>
<span class="fc" id="L502">                    int hi = prev &gt;&gt;&gt; anticount;</span>
<span class="fc" id="L503">                    int[] result = data;</span>
<span class="fc" id="L504">                    int[] src = data;</span>
<span class="fc bfc" id="L505" title="All 2 branches covered.">                    if (hi != 0) {</span>
<span class="fc bfc" id="L506" title="All 2 branches covered.">                        if(nWords == data.length) {</span>
<span class="fc" id="L507">                            data = result = new int[nWords + 1];</span>
                        }
<span class="fc" id="L509">                        result[nWords++] = hi;</span>
                    }
<span class="fc" id="L511">                    leftShift(src,idx,result,bitcount,anticount,prev);</span>
                }
            }
<span class="fc" id="L514">            offset += wordcount;</span>
<span class="fc" id="L515">            return this;</span>
        }
    }

    /**
     * Returns the number of &lt;code&gt;int&lt;/code&gt;s this &lt;code&gt;FDBigInteger&lt;/code&gt; represents.
     *
     * @return Number of &lt;code&gt;int&lt;/code&gt;s required to represent this &lt;code&gt;FDBigInteger&lt;/code&gt;.
     */
    /*@
     @ requires this.value() == 0;
     @ ensures \result == 0;
     @
     @  also
     @
     @ requires this.value() &gt; 0;
     @ ensures ((\bigint)1) &lt;&lt; (\result - 1) &lt;= this.value() &amp;&amp; this.value() &lt;= ((\bigint)1) &lt;&lt; \result;
     @*/
    private /*@ pure @*/ int size() {
<span class="fc" id="L534">        return nWords + offset;</span>
    }


    /**
     * Computes
     * &lt;pre&gt;
     * q = (int)( this / S )
     * this = 10 * ( this mod S )
     * Return q.
     * &lt;/pre&gt;
     * This is the iteration step of digit development for output.
     * We assume that S has been normalized, as above, and that
     * &quot;this&quot; has been left-shifted accordingly.
     * Also assumed, of course, is that the result, q, can be expressed
     * as an integer, 0 &lt;= q &lt; 10.
     *
     * @param The divisor of this &lt;code&gt;FDBigInteger&lt;/code&gt;.
     * @return &lt;code&gt;q = (int)(this / S)&lt;/code&gt;.
     */
    /*@
     @ requires !this.isImmutable;
     @ requires this.size() &lt;= S.size();
     @ requires this.data.length + this.offset &gt;= S.size();
     @ requires S.value() &gt;= ((\bigint)1) &lt;&lt; (S.size()*32 - 4);
     @ assignable this.nWords, this.offset, this.data, this.data[*];
     @ ensures \result == \old(this.value() / S.value());
     @ ensures this.value() == \old(10 * (this.value() % S.value()));
     @*/
    public int quoRemIteration(FDBigInteger S) throws IllegalArgumentException {
<span class="pc bpc" id="L564" title="2 of 4 branches missed.">        assert !this.isImmutable : &quot;cannot modify immutable value&quot;;</span>
        // ensure that this and S have the same number of
        // digits. If S is properly normalized and q &lt; 10 then
        // this must be so.
<span class="fc" id="L568">        int thSize = this.size();</span>
<span class="fc" id="L569">        int sSize = S.size();</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (thSize &lt; sSize) {</span>
            // this value is significantly less than S, result of division is zero.
            // just mult this by 10.
<span class="fc" id="L573">            int p = multAndCarryBy10(this.data, this.nWords, this.data);</span>
<span class="pc bpc" id="L574" title="1 of 2 branches missed.">            if(p!=0) {</span>
<span class="nc" id="L575">                this.data[nWords++] = p;</span>
            } else {
<span class="fc" id="L577">                trimLeadingZeros();</span>
            }
<span class="fc" id="L579">            return 0;</span>
<span class="pc bpc" id="L580" title="1 of 2 branches missed.">        } else if (thSize &gt; sSize) {</span>
<span class="nc" id="L581">            throw new IllegalArgumentException(&quot;disparate values&quot;);</span>
        }
        // estimate q the obvious way. We will usually be
        // right. If not, then we're only off by a little and
        // will re-add.
<span class="fc" id="L586">        long q = (this.data[this.nWords - 1] &amp; LONG_MASK) / (S.data[S.nWords - 1] &amp; LONG_MASK);</span>
<span class="fc" id="L587">        long diff = multDiffMe(q, S);</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">        if (diff != 0L) {</span>
            //@ assert q != 0;
            //@ assert this.offset == \old(Math.min(this.offset, S.offset));
            //@ assert this.offset &lt;= S.offset;

            // q is too big.
            // add S back in until this turns +. This should
            // not be very many times!
<span class="nc" id="L596">            long sum = 0L;</span>
<span class="nc" id="L597">            int tStart = S.offset - this.offset;</span>
            //@ assert tStart &gt;= 0;
<span class="nc" id="L599">            int[] sd = S.data;</span>
<span class="nc" id="L600">            int[] td = this.data;</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">            while (sum == 0L) {</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">                for (int sIndex = 0, tIndex = tStart; tIndex &lt; this.nWords; sIndex++, tIndex++) {</span>
<span class="nc" id="L603">                    sum += (td[tIndex] &amp; LONG_MASK) + (sd[sIndex] &amp; LONG_MASK);</span>
<span class="nc" id="L604">                    td[tIndex] = (int) sum;</span>
<span class="nc" id="L605">                    sum &gt;&gt;&gt;= 32; // Signed or unsigned, answer is 0 or 1</span>
                }
                //
                // Originally the following line read
                // &quot;if ( sum !=0 &amp;&amp; sum != -1 )&quot;
                // but that would be wrong, because of the
                // treatment of the two values as entirely unsigned,
                // it would be impossible for a carry-out to be interpreted
                // as -1 -- it would have to be a single-bit carry-out, or +1.
                //
<span class="nc bnc" id="L615" title="All 6 branches missed.">                assert sum == 0 || sum == 1 : sum; // carry out of division correction</span>
<span class="nc" id="L616">                q -= 1;</span>
            }
        }
        // finally, we can multiply this by 10.
        // it cannot overflow, right, as the high-order word has
        // at least 4 high-order zeros!
<span class="fc" id="L622">        int p = multAndCarryBy10(this.data, this.nWords, this.data);</span>
<span class="pc bpc" id="L623" title="2 of 4 branches missed.">        assert p == 0 : p; // Carry out of *10</span>
<span class="fc" id="L624">        trimLeadingZeros();</span>
<span class="fc" id="L625">        return (int) q;</span>
    }

    /**
     * Multiplies this &lt;code&gt;FDBigInteger&lt;/code&gt; by 10. The operation will be
     * performed in place unless the &lt;code&gt;FDBigInteger&lt;/code&gt; is immutable in
     * which case a new &lt;code&gt;FDBigInteger&lt;/code&gt; will be returned.
     *
     * @return The &lt;code&gt;FDBigInteger&lt;/code&gt; multiplied by 10.
     */
    /*@
     @ requires this.value() == 0;
     @ assignable \nothing;
     @ ensures \result == this;
     @
     @  also
     @
     @ requires this.value() &gt; 0 &amp;&amp; this.isImmutable;
     @ assignable \nothing;
     @ ensures \result.value() == \old(this.value() * 10);
     @
     @  also
     @
     @ requires this.value() &gt; 0 &amp;&amp; !this.isImmutable;
     @ assignable this.nWords, this.data, this.data[*];
     @ ensures \result == this;
     @ ensures \result.value() == \old(this.value() * 10);
     @*/
    public FDBigInteger multBy10() {
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">        if (nWords == 0) {</span>
<span class="nc" id="L655">            return this;</span>
        }
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">        if (isImmutable) {</span>
<span class="nc" id="L658">            int[] res = new int[nWords + 1];</span>
<span class="nc" id="L659">            res[nWords] = multAndCarryBy10(data, nWords, res);</span>
<span class="nc" id="L660">            return new FDBigInteger(res, offset);</span>
        } else {
<span class="fc" id="L662">            int p = multAndCarryBy10(this.data, this.nWords, this.data);</span>
<span class="fc bfc" id="L663" title="All 2 branches covered.">            if (p != 0) {</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">                if (nWords == data.length) {</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">                    if (data[0] == 0) {</span>
<span class="fc" id="L666">                        System.arraycopy(data, 1, data, 0, --nWords);</span>
<span class="fc" id="L667">                        offset++;</span>
                    } else {
<span class="fc" id="L669">                        data = Arrays.copyOf(data, data.length + 1);</span>
                    }
                }
<span class="fc" id="L672">                data[nWords++] = p;</span>
            } else {
<span class="fc" id="L674">                trimLeadingZeros();</span>
            }
<span class="fc" id="L676">            return this;</span>
        }
    }

    /**
     * Multiplies this &lt;code&gt;FDBigInteger&lt;/code&gt; by
     * &lt;code&gt;5&lt;sup&gt;p5&lt;/sup&gt; * 2&lt;sup&gt;p2&lt;/sup&gt;&lt;/code&gt;. The operation will be
     * performed in place if possible, otherwise a new &lt;code&gt;FDBigInteger&lt;/code&gt;
     * will be returned.
     *
     * @param p5 The exponent of the power-of-five factor.
     * @param p2 The exponent of the power-of-two factor.
     * @return
     */
    /*@
     @ requires this.value() == 0 || p5 == 0 &amp;&amp; p2 == 0;
     @ assignable \nothing;
     @ ensures \result == this;
     @
     @  also
     @
     @ requires this.value() &gt; 0 &amp;&amp; (p5 &gt; 0 &amp;&amp; p2 &gt;= 0 || p5 == 0 &amp;&amp; p2 &gt; 0 &amp;&amp; this.isImmutable);
     @ assignable \nothing;
     @ ensures \result.value() == \old(this.value() * pow52(p5, p2));
     @
     @  also
     @
     @ requires this.value() &gt; 0 &amp;&amp; p5 == 0 &amp;&amp; p2 &gt; 0 &amp;&amp; !this.isImmutable;
     @ assignable this.nWords, this.data, this.data[*];
     @ ensures \result == this;
     @ ensures \result.value() == \old(this.value() * pow52(p5, p2));
     @*/
    public FDBigInteger multByPow52(int p5, int p2) {
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">        if (this.nWords == 0) {</span>
<span class="nc" id="L710">            return this;</span>
        }
<span class="fc" id="L712">        FDBigInteger res = this;</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">        if (p5 != 0) {</span>
            int[] r;
<span class="pc bpc" id="L715" title="1 of 2 branches missed.">            int extraSize = (p2 != 0) ? 1 : 0;</span>
<span class="fc bfc" id="L716" title="All 2 branches covered.">            if (p5 &lt; SMALL_5_POW.length) {</span>
<span class="fc" id="L717">                r = new int[this.nWords + 1 + extraSize];</span>
<span class="fc" id="L718">                mult(this.data, this.nWords, SMALL_5_POW[p5], r);</span>
<span class="fc" id="L719">                res = new FDBigInteger(r, this.offset);</span>
            } else {
<span class="fc" id="L721">                FDBigInteger pow5 = big5pow(p5);</span>
<span class="fc" id="L722">                r = new int[this.nWords + pow5.size() + extraSize];</span>
<span class="fc" id="L723">                mult(this.data, this.nWords, pow5.data, pow5.nWords, r);</span>
<span class="fc" id="L724">                res = new FDBigInteger(r, this.offset + pow5.offset);</span>
            }
        }
<span class="fc" id="L727">        return res.leftShift(p2);</span>
    }

    /**
     * Multiplies two big integers represented as int arrays.
     *
     * @param s1 The first array factor.
     * @param s1Len The number of elements of &lt;code&gt;s1&lt;/code&gt; to use.
     * @param s2 The second array factor.
     * @param s2Len The number of elements of &lt;code&gt;s2&lt;/code&gt; to use.
     * @param dst The product array.
     */
    /*@
     @ requires s1 != dst &amp;&amp; s2 != dst;
     @ requires s1.length &gt;= s1Len &amp;&amp; s2.length &gt;= s2Len &amp;&amp; dst.length &gt;= s1Len + s2Len;
     @ assignable dst[0 .. s1Len + s2Len - 1];
     @ ensures AP(dst, s1Len + s2Len) == \old(AP(s1, s1Len) * AP(s2, s2Len));
     @*/
    private static void mult(int[] s1, int s1Len, int[] s2, int s2Len, int[] dst) {
<span class="fc bfc" id="L746" title="All 2 branches covered.">        for (int i = 0; i &lt; s1Len; i++) {</span>
<span class="fc" id="L747">            long v = s1[i] &amp; LONG_MASK;</span>
<span class="fc" id="L748">            long p = 0L;</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">            for (int j = 0; j &lt; s2Len; j++) {</span>
<span class="fc" id="L750">                p += (dst[i + j] &amp; LONG_MASK) + v * (s2[j] &amp; LONG_MASK);</span>
<span class="fc" id="L751">                dst[i + j] = (int) p;</span>
<span class="fc" id="L752">                p &gt;&gt;&gt;= 32;</span>
            }
<span class="fc" id="L754">            dst[i + s2Len] = (int) p;</span>
        }
<span class="fc" id="L756">    }</span>

    /**
     * Subtracts the supplied &lt;code&gt;FDBigInteger&lt;/code&gt; subtrahend from this
     * &lt;code&gt;FDBigInteger&lt;/code&gt;. Assert that the result is positive.
     * If the subtrahend is immutable, store the result in this(minuend).
     * If this(minuend) is immutable a new &lt;code&gt;FDBigInteger&lt;/code&gt; is created.
     *
     * @param subtrahend The &lt;code&gt;FDBigInteger&lt;/code&gt; to be subtracted.
     * @return This &lt;code&gt;FDBigInteger&lt;/code&gt; less the subtrahend.
     */
    /*@
     @ requires this.isImmutable;
     @ requires this.value() &gt;= subtrahend.value();
     @ assignable \nothing;
     @ ensures \result.value() == \old(this.value() - subtrahend.value());
     @
     @  also
     @
     @ requires !subtrahend.isImmutable;
     @ requires this.value() &gt;= subtrahend.value();
     @ assignable this.nWords, this.offset, this.data, this.data[*];
     @ ensures \result == this;
     @ ensures \result.value() == \old(this.value() - subtrahend.value());
     @*/
    public FDBigInteger leftInplaceSub(FDBigInteger subtrahend) {
<span class="pc bpc" id="L782" title="2 of 4 branches missed.">        assert this.size() &gt;= subtrahend.size() : &quot;result should be positive&quot;;</span>
        FDBigInteger minuend;
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">        if (this.isImmutable) {</span>
<span class="nc" id="L785">            minuend = new FDBigInteger(this.data.clone(), this.offset);</span>
        } else {
<span class="fc" id="L787">            minuend = this;</span>
        }
<span class="fc" id="L789">        int offsetDiff = subtrahend.offset - minuend.offset;</span>
<span class="fc" id="L790">        int[] sData = subtrahend.data;</span>
<span class="fc" id="L791">        int[] mData = minuend.data;</span>
<span class="fc" id="L792">        int subLen = subtrahend.nWords;</span>
<span class="fc" id="L793">        int minLen = minuend.nWords;</span>
<span class="fc bfc" id="L794" title="All 2 branches covered.">        if (offsetDiff &lt; 0) {</span>
            // need to expand minuend
<span class="fc" id="L796">            int rLen = minLen - offsetDiff;</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">            if (rLen &lt; mData.length) {</span>
<span class="fc" id="L798">                System.arraycopy(mData, 0, mData, -offsetDiff, minLen);</span>
<span class="fc" id="L799">                Arrays.fill(mData, 0, -offsetDiff, 0);</span>
            } else {
<span class="fc" id="L801">                int[] r = new int[rLen];</span>
<span class="fc" id="L802">                System.arraycopy(mData, 0, r, -offsetDiff, minLen);</span>
<span class="fc" id="L803">                minuend.data = mData = r;</span>
            }
<span class="fc" id="L805">            minuend.offset = subtrahend.offset;</span>
<span class="fc" id="L806">            minuend.nWords = minLen = rLen;</span>
<span class="fc" id="L807">            offsetDiff = 0;</span>
        }
<span class="fc" id="L809">        long borrow = 0L;</span>
<span class="fc" id="L810">        int mIndex = offsetDiff;</span>
<span class="pc bpc" id="L811" title="1 of 4 branches missed.">        for (int sIndex = 0; sIndex &lt; subLen &amp;&amp; mIndex &lt; minLen; sIndex++, mIndex++) {</span>
<span class="fc" id="L812">            long diff = (mData[mIndex] &amp; LONG_MASK) - (sData[sIndex] &amp; LONG_MASK) + borrow;</span>
<span class="fc" id="L813">            mData[mIndex] = (int) diff;</span>
<span class="fc" id="L814">            borrow = diff &gt;&gt; 32; // signed shift</span>
        }
<span class="pc bpc" id="L816" title="1 of 4 branches missed.">        for (; borrow != 0 &amp;&amp; mIndex &lt; minLen; mIndex++) {</span>
<span class="fc" id="L817">            long diff = (mData[mIndex] &amp; LONG_MASK) + borrow;</span>
<span class="fc" id="L818">            mData[mIndex] = (int) diff;</span>
<span class="fc" id="L819">            borrow = diff &gt;&gt; 32; // signed shift</span>
        }
<span class="pc bpc" id="L821" title="2 of 4 branches missed.">        assert borrow == 0L : borrow; // borrow out of subtract,</span>
        // result should be positive
<span class="fc" id="L823">        minuend.trimLeadingZeros();</span>
<span class="fc" id="L824">        return minuend;</span>
    }

    /**
     * Subtracts the supplied &lt;code&gt;FDBigInteger&lt;/code&gt; subtrahend from this
     * &lt;code&gt;FDBigInteger&lt;/code&gt;. Assert that the result is positive.
     * If the this(minuend) is immutable, store the result in subtrahend.
     * If subtrahend is immutable a new &lt;code&gt;FDBigInteger&lt;/code&gt; is created.
     *
     * @param subtrahend The &lt;code&gt;FDBigInteger&lt;/code&gt; to be subtracted.
     * @return This &lt;code&gt;FDBigInteger&lt;/code&gt; less the subtrahend.
     */
    /*@
     @ requires subtrahend.isImmutable;
     @ requires this.value() &gt;= subtrahend.value();
     @ assignable \nothing;
     @ ensures \result.value() == \old(this.value() - subtrahend.value());
     @
     @  also
     @
     @ requires !subtrahend.isImmutable;
     @ requires this.value() &gt;= subtrahend.value();
     @ assignable subtrahend.nWords, subtrahend.offset, subtrahend.data, subtrahend.data[*];
     @ ensures \result == subtrahend;
     @ ensures \result.value() == \old(this.value() - subtrahend.value());
     @*/
    public FDBigInteger rightInplaceSub(FDBigInteger subtrahend) {
<span class="pc bpc" id="L851" title="2 of 4 branches missed.">        assert this.size() &gt;= subtrahend.size() : &quot;result should be positive&quot;;</span>
<span class="fc" id="L852">        FDBigInteger minuend = this;</span>
<span class="pc bpc" id="L853" title="1 of 2 branches missed.">        if (subtrahend.isImmutable) {</span>
<span class="nc" id="L854">            subtrahend = new FDBigInteger(subtrahend.data.clone(), subtrahend.offset);</span>
        }
<span class="fc" id="L856">        int offsetDiff = minuend.offset - subtrahend.offset;</span>
<span class="fc" id="L857">        int[] sData = subtrahend.data;</span>
<span class="fc" id="L858">        int[] mData = minuend.data;</span>
<span class="fc" id="L859">        int subLen = subtrahend.nWords;</span>
<span class="fc" id="L860">        int minLen = minuend.nWords;</span>
<span class="fc bfc" id="L861" title="All 2 branches covered.">        if (offsetDiff &lt; 0) {</span>
<span class="fc" id="L862">            int rLen = minLen;</span>
<span class="fc bfc" id="L863" title="All 2 branches covered.">            if (rLen &lt; sData.length) {</span>
<span class="fc" id="L864">                System.arraycopy(sData, 0, sData, -offsetDiff, subLen);</span>
<span class="fc" id="L865">                Arrays.fill(sData, 0, -offsetDiff, 0);</span>
            } else {
<span class="fc" id="L867">                int[] r = new int[rLen];</span>
<span class="fc" id="L868">                System.arraycopy(sData, 0, r, -offsetDiff, subLen);</span>
<span class="fc" id="L869">                subtrahend.data = sData = r;</span>
            }
<span class="fc" id="L871">            subtrahend.offset = minuend.offset;</span>
<span class="fc" id="L872">            subLen -= offsetDiff;</span>
<span class="fc" id="L873">            offsetDiff = 0;</span>
<span class="fc" id="L874">        } else {</span>
<span class="fc" id="L875">            int rLen = minLen + offsetDiff;</span>
<span class="fc bfc" id="L876" title="All 2 branches covered.">            if (rLen &gt;= sData.length) {</span>
<span class="fc" id="L877">                subtrahend.data = sData = Arrays.copyOf(sData, rLen);</span>
            }
        }
        //@ assert minuend == this &amp;&amp; minuend.value() == \old(this.value());
        //@ assert mData == minuend.data &amp;&amp; minLen == minuend.nWords;
        //@ assert subtrahend.offset + subtrahend.data.length &gt;= minuend.size();
        //@ assert sData == subtrahend.data;
        //@ assert AP(subtrahend.data, subtrahend.data.length) &lt;&lt; subtrahend.offset == \old(subtrahend.value());
        //@ assert subtrahend.offset == Math.min(\old(this.offset), minuend.offset);
        //@ assert offsetDiff == minuend.offset - subtrahend.offset;
        //@ assert 0 &lt;= offsetDiff &amp;&amp; offsetDiff + minLen &lt;= sData.length;
<span class="fc" id="L888">        int sIndex = 0;</span>
<span class="fc" id="L889">        long borrow = 0L;</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">        for (; sIndex &lt; offsetDiff; sIndex++) {</span>
<span class="fc" id="L891">            long diff = 0L - (sData[sIndex] &amp; LONG_MASK) + borrow;</span>
<span class="fc" id="L892">            sData[sIndex] = (int) diff;</span>
<span class="fc" id="L893">            borrow = diff &gt;&gt; 32; // signed shift</span>
        }
        //@ assert sIndex == offsetDiff;
<span class="fc bfc" id="L896" title="All 2 branches covered.">        for (int mIndex = 0; mIndex &lt; minLen; sIndex++, mIndex++) {</span>
            //@ assert sIndex == offsetDiff + mIndex;
<span class="fc" id="L898">            long diff = (mData[mIndex] &amp; LONG_MASK) - (sData[sIndex] &amp; LONG_MASK) + borrow;</span>
<span class="fc" id="L899">            sData[sIndex] = (int) diff;</span>
<span class="fc" id="L900">            borrow = diff &gt;&gt; 32; // signed shift</span>
        }
<span class="pc bpc" id="L902" title="2 of 4 branches missed.">        assert borrow == 0L : borrow; // borrow out of subtract,</span>
        // result should be positive
<span class="fc" id="L904">        subtrahend.nWords = sIndex;</span>
<span class="fc" id="L905">        subtrahend.trimLeadingZeros();</span>
<span class="fc" id="L906">        return subtrahend;</span>

    }

    /**
     * Determines whether all elements of an array are zero for all indices less
     * than a given index.
     *
     * @param a The array to be examined.
     * @param from The index strictly below which elements are to be examined.
     * @return Zero if all elements in range are zero, 1 otherwise.
     */
    /*@
     @ requires 0 &lt;= from &amp;&amp; from &lt;= a.length;
     @ ensures \result == (AP(a, from) == 0 ? 0 : 1);
     @*/
    private /*@ pure @*/ static int checkZeroTail(int[] a, int from) {
<span class="fc bfc" id="L923" title="All 2 branches covered.">        while (from &gt; 0) {</span>
<span class="fc bfc" id="L924" title="All 2 branches covered.">            if (a[--from] != 0) {</span>
<span class="fc" id="L925">                return 1;</span>
            }
        }
<span class="fc" id="L928">        return 0;</span>
    }

    /**
     * Compares the parameter with this &lt;code&gt;FDBigInteger&lt;/code&gt;. Returns an
     * integer accordingly as:
     * &lt;pre&gt;
     * &gt;0: this &gt; other
     *  0: this == other
     * &lt;0: this &lt; other
     * &lt;/pre&gt;
     *
     * @param other The &lt;code&gt;FDBigInteger&lt;/code&gt; to compare.
     * @return A negative value, zero, or a positive value according to the
     * result of the comparison.
     */
    /*@
     @ ensures \result == (this.value() &lt; other.value() ? -1 : this.value() &gt; other.value() ? +1 : 0);
     @*/
    public /*@ pure @*/ int cmp(FDBigInteger other) {
<span class="fc" id="L948">        int aSize = nWords + offset;</span>
<span class="fc" id="L949">        int bSize = other.nWords + other.offset;</span>
<span class="fc bfc" id="L950" title="All 2 branches covered.">        if (aSize &gt; bSize) {</span>
<span class="fc" id="L951">            return 1;</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">        } else if (aSize &lt; bSize) {</span>
<span class="fc" id="L953">            return -1;</span>
        }
<span class="fc" id="L955">        int aLen = nWords;</span>
<span class="fc" id="L956">        int bLen = other.nWords;</span>
<span class="pc bpc" id="L957" title="1 of 4 branches missed.">        while (aLen &gt; 0 &amp;&amp; bLen &gt; 0) {</span>
<span class="fc" id="L958">            int a = data[--aLen];</span>
<span class="fc" id="L959">            int b = other.data[--bLen];</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">            if (a != b) {</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">                return ((a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK)) ? -1 : 1;</span>
            }
<span class="fc" id="L963">        }</span>
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">        if (aLen &gt; 0) {</span>
<span class="nc" id="L965">            return checkZeroTail(data, aLen);</span>
        }
<span class="fc bfc" id="L967" title="All 2 branches covered.">        if (bLen &gt; 0) {</span>
<span class="fc" id="L968">            return -checkZeroTail(other.data, bLen);</span>
        }
<span class="fc" id="L970">        return 0;</span>
    }

    /**
     * Compares this &lt;code&gt;FDBigInteger&lt;/code&gt; with
     * &lt;code&gt;5&lt;sup&gt;p5&lt;/sup&gt; * 2&lt;sup&gt;p2&lt;/sup&gt;&lt;/code&gt;.
     * Returns an integer accordingly as:
     * &lt;pre&gt;
     * &gt;0: this &gt; other
     *  0: this == other
     * &lt;0: this &lt; other
     * &lt;/pre&gt;
     * @param p5 The exponent of the power-of-five factor.
     * @param p2 The exponent of the power-of-two factor.
     * @return A negative value, zero, or a positive value according to the
     * result of the comparison.
     */
    /*@
     @ requires p5 &gt;= 0 &amp;&amp; p2 &gt;= 0;
     @ ensures \result == (this.value() &lt; pow52(p5, p2) ? -1 : this.value() &gt;  pow52(p5, p2) ? +1 : 0);
     @*/
    public /*@ pure @*/ int cmpPow52(int p5, int p2) {
<span class="fc bfc" id="L992" title="All 2 branches covered.">        if (p5 == 0) {</span>
<span class="fc" id="L993">            int wordcount = p2 &gt;&gt; 5;</span>
<span class="fc" id="L994">            int bitcount = p2 &amp; 0x1f;</span>
<span class="fc" id="L995">            int size = this.nWords + this.offset;</span>
<span class="fc bfc" id="L996" title="All 2 branches covered.">            if (size &gt; wordcount + 1) {</span>
<span class="fc" id="L997">                return 1;</span>
<span class="fc bfc" id="L998" title="All 2 branches covered.">            } else if (size &lt; wordcount + 1) {</span>
<span class="fc" id="L999">                return -1;</span>
            }
<span class="fc" id="L1001">            int a = this.data[this.nWords -1];</span>
<span class="fc" id="L1002">            int b = 1 &lt;&lt; bitcount;</span>
<span class="fc bfc" id="L1003" title="All 2 branches covered.">            if (a != b) {</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">                return ( (a &amp; LONG_MASK) &lt; (b &amp; LONG_MASK)) ? -1 : 1;</span>
            }
<span class="fc" id="L1006">            return checkZeroTail(this.data, this.nWords - 1);</span>
        }
<span class="fc" id="L1008">        return this.cmp(big5pow(p5).leftShift(p2));</span>
    }

    /**
     * Compares this &lt;code&gt;FDBigInteger&lt;/code&gt; with &lt;code&gt;x + y&lt;/code&gt;. Returns a
     * value according to the comparison as:
     * &lt;pre&gt;
     * -1: this &lt;  x + y
     *  0: this == x + y
     *  1: this &gt;  x + y
     * &lt;/pre&gt;
     * @param x The first addend of the sum to compare.
     * @param y The second addend of the sum to compare.
     * @return -1, 0, or 1 according to the result of the comparison.
     */
    /*@
     @ ensures \result == (this.value() &lt; x.value() + y.value() ? -1 : this.value() &gt; x.value() + y.value() ? +1 : 0);
     @*/
    public /*@ pure @*/ int addAndCmp(FDBigInteger x, FDBigInteger y) {
        FDBigInteger big;
        FDBigInteger small;
<span class="fc" id="L1029">        int xSize = x.size();</span>
<span class="fc" id="L1030">        int ySize = y.size();</span>
        int bSize;
        int sSize;
<span class="fc bfc" id="L1033" title="All 2 branches covered.">        if (xSize &gt;= ySize) {</span>
<span class="fc" id="L1034">            big = x;</span>
<span class="fc" id="L1035">            small = y;</span>
<span class="fc" id="L1036">            bSize = xSize;</span>
<span class="fc" id="L1037">            sSize = ySize;</span>
        } else {
<span class="fc" id="L1039">            big = y;</span>
<span class="fc" id="L1040">            small = x;</span>
<span class="fc" id="L1041">            bSize = ySize;</span>
<span class="fc" id="L1042">            sSize = xSize;</span>
        }
<span class="fc" id="L1044">        int thSize = this.size();</span>
<span class="pc bpc" id="L1045" title="1 of 2 branches missed.">        if (bSize == 0) {</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            return thSize == 0 ? 0 : 1;</span>
        }
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">        if (sSize == 0) {</span>
<span class="nc" id="L1049">            return this.cmp(big);</span>
        }
<span class="fc bfc" id="L1051" title="All 2 branches covered.">        if (bSize &gt; thSize) {</span>
<span class="fc" id="L1052">            return -1;</span>
        }
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">        if (bSize + 1 &lt; thSize) {</span>
<span class="nc" id="L1055">            return 1;</span>
        }
<span class="fc" id="L1057">        long top = (big.data[big.nWords - 1] &amp; LONG_MASK);</span>
<span class="fc bfc" id="L1058" title="All 2 branches covered.">        if (sSize == bSize) {</span>
<span class="fc" id="L1059">            top += (small.data[small.nWords - 1] &amp; LONG_MASK);</span>
        }
<span class="fc bfc" id="L1061" title="All 2 branches covered.">        if ((top &gt;&gt;&gt; 32) == 0) {</span>
<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">            if (((top + 1) &gt;&gt;&gt; 32) == 0) {</span>
                // good case - no carry extension
<span class="fc bfc" id="L1064" title="All 2 branches covered.">                if (bSize &lt; thSize) {</span>
<span class="fc" id="L1065">                    return 1;</span>
                }
                // here sum.nWords == this.nWords
<span class="fc" id="L1068">                long v = (this.data[this.nWords - 1] &amp; LONG_MASK);</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">                if (v &lt; top) {</span>
<span class="fc" id="L1070">                    return -1;</span>
                }
<span class="fc bfc" id="L1072" title="All 2 branches covered.">                if (v &gt; top + 1) {</span>
<span class="fc" id="L1073">                    return 1;</span>
                }
<span class="fc" id="L1075">            }</span>
        } else { // (top&gt;&gt;&gt;32)!=0 guaranteed carry extension
<span class="pc bpc" id="L1077" title="1 of 2 branches missed.">            if (bSize + 1 &gt; thSize) {</span>
<span class="fc" id="L1078">                return -1;</span>
            }
            // here sum.nWords == this.nWords
<span class="nc" id="L1081">            top &gt;&gt;&gt;= 32;</span>
<span class="nc" id="L1082">            long v = (this.data[this.nWords - 1] &amp; LONG_MASK);</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            if (v &lt; top) {</span>
<span class="nc" id="L1084">                return -1;</span>
            }
<span class="nc bnc" id="L1086" title="All 2 branches missed.">            if (v &gt; top + 1) {</span>
<span class="nc" id="L1087">                return 1;</span>
            }
        }
<span class="fc" id="L1090">        return this.cmp(big.add(small));</span>
    }

    /**
     * Makes this &lt;code&gt;FDBigInteger&lt;/code&gt; immutable.
     */
    /*@
     @ assignable this.isImmutable;
     @ ensures this.isImmutable;
     @*/
    public void makeImmutable() {
<span class="fc" id="L1101">        this.isImmutable = true;</span>
<span class="fc" id="L1102">    }</span>

    /**
     * Multiplies this &lt;code&gt;FDBigInteger&lt;/code&gt; by an integer.
     *
     * @param i The factor by which to multiply this &lt;code&gt;FDBigInteger&lt;/code&gt;.
     * @return This &lt;code&gt;FDBigInteger&lt;/code&gt; multiplied by an integer.
     */
    /*@
     @ requires this.value() == 0;
     @ assignable \nothing;
     @ ensures \result == this;
     @
     @  also
     @
     @ requires this.value() != 0;
     @ assignable \nothing;
     @ ensures \result.value() == \old(this.value() * UNSIGNED(i));
     @*/
    private FDBigInteger mult(int i) {
<span class="pc bpc" id="L1122" title="1 of 2 branches missed.">        if (this.nWords == 0) {</span>
<span class="nc" id="L1123">            return this;</span>
        }
<span class="fc" id="L1125">        int[] r = new int[nWords + 1];</span>
<span class="fc" id="L1126">        mult(data, nWords, i, r);</span>
<span class="fc" id="L1127">        return new FDBigInteger(r, offset);</span>
    }

    /**
     * Multiplies this &lt;code&gt;FDBigInteger&lt;/code&gt; by another &lt;code&gt;FDBigInteger&lt;/code&gt;.
     *
     * @param other The &lt;code&gt;FDBigInteger&lt;/code&gt; factor by which to multiply.
     * @return The product of this and the parameter &lt;code&gt;FDBigInteger&lt;/code&gt;s.
     */
    /*@
     @ requires this.value() == 0;
     @ assignable \nothing;
     @ ensures \result == this;
     @
     @  also
     @
     @ requires this.value() != 0 &amp;&amp; other.value() == 0;
     @ assignable \nothing;
     @ ensures \result == other;
     @
     @  also
     @
     @ requires this.value() != 0 &amp;&amp; other.value() != 0;
     @ assignable \nothing;
     @ ensures \result.value() == \old(this.value() * other.value());
     @*/
    private FDBigInteger mult(FDBigInteger other) {
<span class="pc bpc" id="L1154" title="1 of 2 branches missed.">        if (this.nWords == 0) {</span>
<span class="nc" id="L1155">            return this;</span>
        }
<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">        if (this.size() == 1) {</span>
<span class="nc" id="L1158">            return other.mult(data[0]);</span>
        }
<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">        if (other.nWords == 0) {</span>
<span class="nc" id="L1161">            return other;</span>
        }
<span class="pc bpc" id="L1163" title="1 of 2 branches missed.">        if (other.size() == 1) {</span>
<span class="nc" id="L1164">            return this.mult(other.data[0]);</span>
        }
<span class="fc" id="L1166">        int[] r = new int[nWords + other.nWords];</span>
<span class="fc" id="L1167">        mult(this.data, this.nWords, other.data, other.nWords, r);</span>
<span class="fc" id="L1168">        return new FDBigInteger(r, this.offset + other.offset);</span>
    }

    /**
     * Adds another &lt;code&gt;FDBigInteger&lt;/code&gt; to this &lt;code&gt;FDBigInteger&lt;/code&gt;.
     *
     * @param other The &lt;code&gt;FDBigInteger&lt;/code&gt; to add.
     * @return The sum of the &lt;code&gt;FDBigInteger&lt;/code&gt;s.
     */
    /*@
     @ assignable \nothing;
     @ ensures \result.value() == \old(this.value() + other.value());
     @*/
    private FDBigInteger add(FDBigInteger other) {
        FDBigInteger big, small;
        int bigLen, smallLen;
<span class="fc" id="L1184">        int tSize = this.size();</span>
<span class="fc" id="L1185">        int oSize = other.size();</span>
<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">        if (tSize &gt;= oSize) {</span>
<span class="fc" id="L1187">            big = this;</span>
<span class="fc" id="L1188">            bigLen = tSize;</span>
<span class="fc" id="L1189">            small = other;</span>
<span class="fc" id="L1190">            smallLen = oSize;</span>
        } else {
<span class="nc" id="L1192">            big = other;</span>
<span class="nc" id="L1193">            bigLen = oSize;</span>
<span class="nc" id="L1194">            small = this;</span>
<span class="nc" id="L1195">            smallLen = tSize;</span>
        }
<span class="fc" id="L1197">        int[] r = new int[bigLen + 1];</span>
<span class="fc" id="L1198">        int i = 0;</span>
<span class="fc" id="L1199">        long carry = 0L;</span>
<span class="fc bfc" id="L1200" title="All 2 branches covered.">        for (; i &lt; smallLen; i++) {</span>
<span class="fc bfc" id="L1201" title="All 4 branches covered.">            carry += (i &lt; big.offset   ? 0L : (big.data[i - big.offset] &amp; LONG_MASK) )</span>
                   + ((i &lt; small.offset ? 0L : (small.data[i - small.offset] &amp; LONG_MASK)));
<span class="fc" id="L1203">            r[i] = (int) carry;</span>
<span class="fc" id="L1204">            carry &gt;&gt;= 32; // signed shift.</span>
        }
<span class="fc bfc" id="L1206" title="All 2 branches covered.">        for (; i &lt; bigLen; i++) {</span>
<span class="pc bpc" id="L1207" title="1 of 2 branches missed.">            carry += (i &lt; big.offset ? 0L : (big.data[i - big.offset] &amp; LONG_MASK) );</span>
<span class="fc" id="L1208">            r[i] = (int) carry;</span>
<span class="fc" id="L1209">            carry &gt;&gt;= 32; // signed shift.</span>
        }
<span class="fc" id="L1211">        r[bigLen] = (int) carry;</span>
<span class="fc" id="L1212">        return new FDBigInteger(r, 0);</span>
    }


    /**
     * Multiplies a &lt;code&gt;FDBigInteger&lt;/code&gt; by an int and adds another int. The
     * result is computed in place. This method is intended only to be invoked
     * from
     * &lt;code&gt;
     * FDBigInteger(long lValue, char[] digits, int kDigits, int nDigits)
     * &lt;/code&gt;.
     *
     * @param iv The factor by which to multiply this &lt;code&gt;FDBigInteger&lt;/code&gt;.
     * @param addend The value to add to the product of this
     * &lt;code&gt;FDBigInteger&lt;/code&gt; and &lt;code&gt;iv&lt;/code&gt;.
     */
    /*@
     @ requires this.value()*UNSIGNED(iv) + UNSIGNED(addend) &lt; ((\bigint)1) &lt;&lt; ((this.data.length + this.offset)*32);
     @ assignable this.data[*];
     @ ensures this.value() == \old(this.value()*UNSIGNED(iv) + UNSIGNED(addend));
     @*/
    private /*@ helper @*/ void multAddMe(int iv, int addend) {
<span class="fc" id="L1234">        long v = iv &amp; LONG_MASK;</span>
        // unroll 0th iteration, doing addition.
<span class="fc" id="L1236">        long p = v * (data[0] &amp; LONG_MASK) + (addend &amp; LONG_MASK);</span>
<span class="fc" id="L1237">        data[0] = (int) p;</span>
<span class="fc" id="L1238">        p &gt;&gt;&gt;= 32;</span>
<span class="fc bfc" id="L1239" title="All 2 branches covered.">        for (int i = 1; i &lt; nWords; i++) {</span>
<span class="fc" id="L1240">            p += v * (data[i] &amp; LONG_MASK);</span>
<span class="fc" id="L1241">            data[i] = (int) p;</span>
<span class="fc" id="L1242">            p &gt;&gt;&gt;= 32;</span>
        }
<span class="fc bfc" id="L1244" title="All 2 branches covered.">        if (p != 0L) {</span>
<span class="fc" id="L1245">            data[nWords++] = (int) p; // will fail noisily if illegal!</span>
        }
<span class="fc" id="L1247">    }</span>

    //
    // original doc:
    //
    // do this -=q*S
    // returns borrow
    //
    /**
     * Multiplies the parameters and subtracts them from this
     * &lt;code&gt;FDBigInteger&lt;/code&gt;.
     *
     * @param q The integer parameter.
     * @param S The &lt;code&gt;FDBigInteger&lt;/code&gt; parameter.
     * @return &lt;code&gt;this - q*S&lt;/code&gt;.
     */
    /*@
     @ ensures nWords == 0 ==&gt; offset == 0;
     @ ensures nWords &gt; 0 ==&gt; data[nWords - 1] != 0;
     @*/
    /*@
     @ requires 0 &lt; q &amp;&amp; q &lt;= (1L &lt;&lt; 31);
     @ requires data != null;
     @ requires 0 &lt;= nWords &amp;&amp; nWords &lt;= data.length &amp;&amp; offset &gt;= 0;
     @ requires !this.isImmutable;
     @ requires this.size() == S.size();
     @ requires this != S;
     @ assignable this.nWords, this.offset, this.data, this.data[*];
     @ ensures -q &lt;= \result &amp;&amp; \result &lt;= 0;
     @ ensures this.size() == \old(this.size());
     @ ensures this.value() + (\result &lt;&lt; (this.size()*32)) == \old(this.value() - q*S.value());
     @ ensures this.offset == \old(Math.min(this.offset, S.offset));
     @ ensures \old(this.offset &lt;= S.offset) ==&gt; this.nWords == \old(this.nWords);
     @ ensures \old(this.offset &lt;= S.offset) ==&gt; this.offset == \old(this.offset);
     @ ensures \old(this.offset &lt;= S.offset) ==&gt; this.data == \old(this.data);
     @
     @  also
     @
     @ requires q == 0;
     @ assignable \nothing;
     @ ensures \result == 0;
     @*/
    private /*@ helper @*/ long multDiffMe(long q, FDBigInteger S) {
<span class="fc" id="L1290">        long diff = 0L;</span>
<span class="fc bfc" id="L1291" title="All 2 branches covered.">        if (q != 0) {</span>
<span class="fc" id="L1292">            int deltaSize = S.offset - this.offset;</span>
<span class="fc bfc" id="L1293" title="All 2 branches covered.">            if (deltaSize &gt;= 0) {</span>
<span class="fc" id="L1294">                int[] sd = S.data;</span>
<span class="fc" id="L1295">                int[] td = this.data;</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">                for (int sIndex = 0, tIndex = deltaSize; sIndex &lt; S.nWords; sIndex++, tIndex++) {</span>
<span class="fc" id="L1297">                    diff += (td[tIndex] &amp; LONG_MASK) - q * (sd[sIndex] &amp; LONG_MASK);</span>
<span class="fc" id="L1298">                    td[tIndex] = (int) diff;</span>
<span class="fc" id="L1299">                    diff &gt;&gt;= 32; // N.B. SIGNED shift.</span>
                }
<span class="fc" id="L1301">            } else {</span>
<span class="fc" id="L1302">                deltaSize = -deltaSize;</span>
<span class="fc" id="L1303">                int[] rd = new int[nWords + deltaSize];</span>
<span class="fc" id="L1304">                int sIndex = 0;</span>
<span class="fc" id="L1305">                int rIndex = 0;</span>
<span class="fc" id="L1306">                int[] sd = S.data;</span>
<span class="pc bpc" id="L1307" title="1 of 4 branches missed.">                for (; rIndex &lt; deltaSize &amp;&amp; sIndex &lt; S.nWords; sIndex++, rIndex++) {</span>
<span class="fc" id="L1308">                    diff -= q * (sd[sIndex] &amp; LONG_MASK);</span>
<span class="fc" id="L1309">                    rd[rIndex] = (int) diff;</span>
<span class="fc" id="L1310">                    diff &gt;&gt;= 32; // N.B. SIGNED shift.</span>
                }
<span class="fc" id="L1312">                int tIndex = 0;</span>
<span class="fc" id="L1313">                int[] td = this.data;</span>
<span class="fc bfc" id="L1314" title="All 2 branches covered.">                for (; sIndex &lt; S.nWords; sIndex++, tIndex++, rIndex++) {</span>
<span class="fc" id="L1315">                    diff += (td[tIndex] &amp; LONG_MASK) - q * (sd[sIndex] &amp; LONG_MASK);</span>
<span class="fc" id="L1316">                    rd[rIndex] = (int) diff;</span>
<span class="fc" id="L1317">                    diff &gt;&gt;= 32; // N.B. SIGNED shift.</span>
                }
<span class="fc" id="L1319">                this.nWords += deltaSize;</span>
<span class="fc" id="L1320">                this.offset -= deltaSize;</span>
<span class="fc" id="L1321">                this.data = rd;</span>
            }
        }
<span class="fc" id="L1324">        return diff;</span>
    }


    /**
     * Multiplies by 10 a big integer represented as an array. The final carry
     * is returned.
     *
     * @param src The array representation of the big integer.
     * @param srcLen The number of elements of &lt;code&gt;src&lt;/code&gt; to use.
     * @param dst The product array.
     * @return The final carry of the multiplication.
     */
    /*@
     @ requires src.length &gt;= srcLen &amp;&amp; dst.length &gt;= srcLen;
     @ assignable dst[0 .. srcLen - 1];
     @ ensures 0 &lt;= \result &amp;&amp; \result &lt; 10;
     @ ensures AP(dst, srcLen) + (\result &lt;&lt; (srcLen*32)) == \old(AP(src, srcLen) * 10);
     @*/
    private static int multAndCarryBy10(int[] src, int srcLen, int[] dst) {
<span class="fc" id="L1344">        long carry = 0;</span>
<span class="fc bfc" id="L1345" title="All 2 branches covered.">        for (int i = 0; i &lt; srcLen; i++) {</span>
<span class="fc" id="L1346">            long product = (src[i] &amp; LONG_MASK) * 10L + carry;</span>
<span class="fc" id="L1347">            dst[i] = (int) product;</span>
<span class="fc" id="L1348">            carry = product &gt;&gt;&gt; 32;</span>
        }
<span class="fc" id="L1350">        return (int) carry;</span>
    }

    /**
     * Multiplies by a constant value a big integer represented as an array.
     * The constant factor is an &lt;code&gt;int&lt;/code&gt;.
     *
     * @param src The array representation of the big integer.
     * @param srcLen The number of elements of &lt;code&gt;src&lt;/code&gt; to use.
     * @param value The constant factor by which to multiply.
     * @param dst The product array.
     */
    /*@
     @ requires src.length &gt;= srcLen &amp;&amp; dst.length &gt;= srcLen + 1;
     @ assignable dst[0 .. srcLen];
     @ ensures AP(dst, srcLen + 1) == \old(AP(src, srcLen) * UNSIGNED(value));
     @*/
    private static void mult(int[] src, int srcLen, int value, int[] dst) {
<span class="fc" id="L1368">        long val = value &amp; LONG_MASK;</span>
<span class="fc" id="L1369">        long carry = 0;</span>
<span class="fc bfc" id="L1370" title="All 2 branches covered.">        for (int i = 0; i &lt; srcLen; i++) {</span>
<span class="fc" id="L1371">            long product = (src[i] &amp; LONG_MASK) * val + carry;</span>
<span class="fc" id="L1372">            dst[i] = (int) product;</span>
<span class="fc" id="L1373">            carry = product &gt;&gt;&gt; 32;</span>
        }
<span class="fc" id="L1375">        dst[srcLen] = (int) carry;</span>
<span class="fc" id="L1376">    }</span>

    /**
     * Multiplies by a constant value a big integer represented as an array.
     * The constant factor is a long represent as two &lt;code&gt;int&lt;/code&gt;s.
     *
     * @param src The array representation of the big integer.
     * @param srcLen The number of elements of &lt;code&gt;src&lt;/code&gt; to use.
     * @param v0 The lower 32 bits of the long factor.
     * @param v1 The upper 32 bits of the long factor.
     * @param dst The product array.
     */
    /*@
     @ requires src != dst;
     @ requires src.length &gt;= srcLen &amp;&amp; dst.length &gt;= srcLen + 2;
     @ assignable dst[0 .. srcLen + 1];
     @ ensures AP(dst, srcLen + 2) == \old(AP(src, srcLen) * (UNSIGNED(v0) + (UNSIGNED(v1) &lt;&lt; 32)));
     @*/
    private static void mult(int[] src, int srcLen, int v0, int v1, int[] dst) {
<span class="fc" id="L1395">        long v = v0 &amp; LONG_MASK;</span>
<span class="fc" id="L1396">        long carry = 0;</span>
<span class="fc bfc" id="L1397" title="All 2 branches covered.">        for (int j = 0; j &lt; srcLen; j++) {</span>
<span class="fc" id="L1398">            long product = v * (src[j] &amp; LONG_MASK) + carry;</span>
<span class="fc" id="L1399">            dst[j] = (int) product;</span>
<span class="fc" id="L1400">            carry = product &gt;&gt;&gt; 32;</span>
        }
<span class="fc" id="L1402">        dst[srcLen] = (int) carry;</span>
<span class="fc" id="L1403">        v = v1 &amp; LONG_MASK;</span>
<span class="fc" id="L1404">        carry = 0;</span>
<span class="fc bfc" id="L1405" title="All 2 branches covered.">        for (int j = 0; j &lt; srcLen; j++) {</span>
<span class="fc" id="L1406">            long product = (dst[j + 1] &amp; LONG_MASK) + v * (src[j] &amp; LONG_MASK) + carry;</span>
<span class="fc" id="L1407">            dst[j + 1] = (int) product;</span>
<span class="fc" id="L1408">            carry = product &gt;&gt;&gt; 32;</span>
        }
<span class="fc" id="L1410">        dst[srcLen + 1] = (int) carry;</span>
<span class="fc" id="L1411">    }</span>

    // Fails assertion for negative exponent.
    /**
     * Computes &lt;code&gt;5&lt;/code&gt; raised to a given power.
     *
     * @param p The exponent of 5.
     * @return &lt;code&gt;5&lt;sup&gt;p&lt;/sup&gt;&lt;/code&gt;.
     */
    private static FDBigInteger big5pow(int p) {
<span class="pc bpc" id="L1421" title="2 of 4 branches missed.">        assert p &gt;= 0 : p; // negative power of 5</span>
<span class="fc bfc" id="L1422" title="All 2 branches covered.">        if (p &lt; MAX_FIVE_POW) {</span>
<span class="fc" id="L1423">            return POW_5_CACHE[p];</span>
        }
<span class="fc" id="L1425">        return big5powRec(p);</span>
    }

    // slow path
    /**
     * Computes &lt;code&gt;5&lt;/code&gt; raised to a given power.
     *
     * @param p The exponent of 5.
     * @return &lt;code&gt;5&lt;sup&gt;p&lt;/sup&gt;&lt;/code&gt;.
     */
    private static FDBigInteger big5powRec(int p) {
<span class="fc bfc" id="L1436" title="All 2 branches covered.">        if (p &lt; MAX_FIVE_POW) {</span>
<span class="fc" id="L1437">            return POW_5_CACHE[p];</span>
        }
        // construct the value.
        // recursively.
        int q, r;
        // in order to compute 5^p,
        // compute its square root, 5^(p/2) and square.
        // or, let q = p / 2, r = p -q, then
        // 5^p = 5^(q+r) = 5^q * 5^r
<span class="fc" id="L1446">        q = p &gt;&gt; 1;</span>
<span class="fc" id="L1447">        r = p - q;</span>
<span class="fc" id="L1448">        FDBigInteger bigq = big5powRec(q);</span>
<span class="pc bpc" id="L1449" title="1 of 2 branches missed.">        if (r &lt; SMALL_5_POW.length) {</span>
<span class="nc" id="L1450">            return bigq.mult(SMALL_5_POW[r]);</span>
        } else {
<span class="fc" id="L1452">            return bigq.mult(big5powRec(r));</span>
        }
    }

    // for debugging ...
    /**
     * Converts this &lt;code&gt;FDBigInteger&lt;/code&gt; to a hexadecimal string.
     *
     * @return The hexadecimal string representation.
     */
    public String toHexString(){
<span class="nc bnc" id="L1463" title="All 2 branches missed.">        if(nWords ==0) {</span>
<span class="nc" id="L1464">            return &quot;0&quot;;</span>
        }
<span class="nc" id="L1466">        StringBuilder sb = new StringBuilder((nWords +offset)*8);</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">        for(int i= nWords -1; i&gt;=0; i--) {</span>
<span class="nc" id="L1468">            String subStr = Integer.toHexString(data[i]);</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">            for(int j = subStr.length(); j&lt;8; j++) {</span>
<span class="nc" id="L1470">                sb.append('0');</span>
            }
<span class="nc" id="L1472">            sb.append(subStr);</span>
        }
<span class="nc bnc" id="L1474" title="All 2 branches missed.">        for(int i=offset; i&gt;0; i--) {</span>
<span class="nc" id="L1475">            sb.append(&quot;00000000&quot;);</span>
        }
<span class="nc" id="L1477">        return sb.toString();</span>
    }

    // for debugging ...
    /**
     * Converts this &lt;code&gt;FDBigInteger&lt;/code&gt; to a &lt;code&gt;BigInteger&lt;/code&gt;.
     *
     * @return The &lt;code&gt;BigInteger&lt;/code&gt; representation.
     */
    public BigInteger toBigInteger() {
<span class="nc" id="L1487">        byte[] magnitude = new byte[nWords * 4 + 1];</span>
<span class="nc bnc" id="L1488" title="All 2 branches missed.">        for (int i = 0; i &lt; nWords; i++) {</span>
<span class="nc" id="L1489">            int w = data[i];</span>
<span class="nc" id="L1490">            magnitude[magnitude.length - 4 * i - 1] = (byte) w;</span>
<span class="nc" id="L1491">            magnitude[magnitude.length - 4 * i - 2] = (byte) (w &gt;&gt; 8);</span>
<span class="nc" id="L1492">            magnitude[magnitude.length - 4 * i - 3] = (byte) (w &gt;&gt; 16);</span>
<span class="nc" id="L1493">            magnitude[magnitude.length - 4 * i - 4] = (byte) (w &gt;&gt; 24);</span>
        }
<span class="nc" id="L1495">        return new BigInteger(magnitude).shiftLeft(offset * 32);</span>
    }

    // for debugging ...
    /**
     * Converts this &lt;code&gt;FDBigInteger&lt;/code&gt; to a string.
     *
     * @return The string representation.
     */
    @Override
    public String toString(){
<span class="nc" id="L1506">        return toBigInteger().toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>