<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RegexpPool.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.misc</a> &gt; <span class="el_source">RegexpPool.java</span></div><h1>RegexpPool.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2001, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.misc;
import java.io.*;

/**
 * A class to represent a pool of regular expressions.  A string
 * can be matched against the whole pool all at once.  It is much
 * faster than doing individual regular expression matches one-by-one.
 *
 * @see java.misc.RegexpTarget
 * @author  James Gosling
 */

public class RegexpPool {
<span class="fc" id="L39">    private RegexpNode prefixMachine = new RegexpNode();</span>
<span class="fc" id="L40">    private RegexpNode suffixMachine = new RegexpNode();</span>
    private static final int BIG = 0x7FFFFFFF;
<span class="fc" id="L42">    private int lastDepth = BIG;</span>

<span class="fc" id="L44">    public RegexpPool () {</span>
<span class="fc" id="L45">    }</span>

    /**
     * Add a regular expression to the pool of regular expressions.
     * @param   re  The regular expression to add to the pool.
            For now, only handles strings that either begin or end with
            a '*'.
     * @param   ret The object to be returned when this regular expression is
            matched.  If ret is an instance of the RegexpTarget class, ret.found
            is called with the string fragment that matched the '*' as its
            parameter.
     * @exception REException error
     */
    public void add(String re, Object ret) throws REException {
<span class="fc" id="L59">        add(re, ret, false);</span>
<span class="fc" id="L60">    }</span>

    /**
     * Replace the target for the regular expression with a different
     * target.
     *
     * @param   re  The regular expression to be replaced in the pool.
     *      For now, only handles strings that either begin or end with
     *      a '*'.
     * @param   ret The object to be returned when this regular expression is
     *      matched.  If ret is an instance of the RegexpTarget class, ret.found
     *      is called with the string fragment that matched the '*' as its
     *      parameter.
     */
    public void replace(String re, Object ret) {
        try {
<span class="nc" id="L76">            add(re, ret, true);</span>
<span class="nc" id="L77">        } catch(Exception e) {</span>
            // should never occur if replace is true
<span class="nc" id="L79">        }</span>
<span class="nc" id="L80">    }</span>

    /**
     * Delete the regular expression and its target.
     * @param re The regular expression to be deleted from the pool.
     *           must begin or end with a '*'
     * @return target - the old target.
     */
    public Object delete(String re) {
<span class="nc" id="L89">        Object o = null;</span>
<span class="nc" id="L90">        RegexpNode p = prefixMachine;</span>
<span class="nc" id="L91">        RegexpNode best = p;</span>
<span class="nc" id="L92">        int len = re.length() - 1;</span>
        int i;
<span class="nc" id="L94">        boolean prefix = true;</span>

<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (!re.startsWith(&quot;*&quot;) ||</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            !re.endsWith(&quot;*&quot;))</span>
<span class="nc" id="L98">            len++;</span>

<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (len &lt;= 0)</span>
<span class="nc" id="L101">            return null;</span>

        /* March forward through the prefix machine */
<span class="nc bnc" id="L104" title="All 2 branches missed.">        for (i = 0; p != null; i++) {</span>
<span class="nc bnc" id="L105" title="All 8 branches missed.">            if (p.result != null &amp;&amp; p.depth &lt; BIG</span>
                &amp;&amp; (!p.exact || i == len)) {
<span class="nc" id="L107">                best = p;</span>
            }
<span class="nc bnc" id="L109" title="All 2 branches missed.">            if (i &gt;= len)</span>
<span class="nc" id="L110">                break;</span>
<span class="nc" id="L111">            p = p.find(re.charAt(i));</span>
        }

        /* march backward through the suffix machine */
<span class="nc" id="L115">        p = suffixMachine;</span>
<span class="nc bnc" id="L116" title="All 4 branches missed.">        for (i = len; --i &gt;= 0 &amp;&amp; p != null;) {</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">            if (p.result != null &amp;&amp; p.depth &lt; BIG) {</span>
<span class="nc" id="L118">                prefix = false;</span>
<span class="nc" id="L119">                best = p;</span>
            }
<span class="nc" id="L121">            p = p.find(re.charAt(i));</span>
        }

        // delete only if there is an exact match
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (prefix) {</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">            if (re.equals(best.re)) {</span>
<span class="nc" id="L127">                o = best.result;</span>
<span class="nc" id="L128">                best.result = null;</span>

            }
        } else {
<span class="nc bnc" id="L132" title="All 2 branches missed.">            if (re.equals(best.re)) {</span>
<span class="nc" id="L133">                o = best.result;</span>
<span class="nc" id="L134">                best.result = null;</span>
            }
        }
<span class="nc" id="L137">        return o;</span>
    }

    /** Search for a match to a string &amp; return the object associated
        with it with the match.  When multiple regular expressions
        would match the string, the best match is returned first.
        The next best match is returned the next time matchNext is
        called.
        @param s    The string to match against the regular expressions
                    in the pool.
        @return     null on failure, otherwise the object associated with
                    the regular expression when it was added to the pool.
                    If the object is an instance of RegexpTarget, then
                    the return value is the result from calling
                    return.found(string_that_matched_wildcard).
    */
    public Object match(String s) {
<span class="fc" id="L154">        return matchAfter(s, BIG);</span>
    }

    /** Identical to match except that it will only find matches to
        regular expressions that were added to the pool &lt;i&gt;after&lt;/i&gt;
        the last regular expression that matched in the last call
        to match() or matchNext() */
    public Object matchNext(String s) {
<span class="nc" id="L162">        return matchAfter(s, lastDepth);</span>
    }

    private void add(String re, Object ret, boolean replace) throws REException {
<span class="fc" id="L166">        int len = re.length();</span>
        RegexpNode p;
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        if (re.charAt(0) == '*') {</span>
<span class="nc" id="L169">            p = suffixMachine;</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            while (len &gt; 1)</span>
<span class="nc" id="L171">                p = p.add(re.charAt(--len));</span>
        } else {
<span class="fc" id="L173">            boolean exact = false;</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (re.charAt(len - 1) == '*')</span>
<span class="fc" id="L175">                len--;</span>
            else
<span class="fc" id="L177">                exact = true;</span>
<span class="fc" id="L178">            p = prefixMachine;</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            for (int i = 0; i &lt; len; i++)</span>
<span class="fc" id="L180">                p = p.add(re.charAt(i));</span>
<span class="fc" id="L181">            p.exact = exact;</span>
        }

<span class="pc bpc" id="L184" title="1 of 4 branches missed.">        if (p.result != null &amp;&amp; !replace)</span>
<span class="fc" id="L185">            throw new REException(re + &quot; is a duplicate&quot;);</span>

<span class="fc" id="L187">        p.re = re;</span>
<span class="fc" id="L188">        p.result = ret;</span>
<span class="fc" id="L189">    }</span>

    private Object matchAfter(String s, int lastMatchDepth) {
<span class="fc" id="L192">        RegexpNode p = prefixMachine;</span>
<span class="fc" id="L193">        RegexpNode best = p;</span>
<span class="fc" id="L194">        int bst = 0;</span>
<span class="fc" id="L195">        int bend = 0;</span>
<span class="fc" id="L196">        int len = s.length();</span>
        int i;
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">        if (len &lt;= 0)</span>
<span class="nc" id="L199">            return null;</span>
        /* March forward through the prefix machine */
<span class="fc bfc" id="L201" title="All 2 branches covered.">        for (i = 0; p != null; i++) {</span>
<span class="pc bpc" id="L202" title="2 of 8 branches missed.">            if (p.result != null &amp;&amp; p.depth &lt; lastMatchDepth</span>
                &amp;&amp; (!p.exact || i == len)) {
<span class="fc" id="L204">                lastDepth = p.depth;</span>
<span class="fc" id="L205">                best = p;</span>
<span class="fc" id="L206">                bst = i;</span>
<span class="fc" id="L207">                bend = len;</span>
            }
<span class="fc bfc" id="L209" title="All 2 branches covered.">            if (i &gt;= len)</span>
<span class="fc" id="L210">                break;</span>
<span class="fc" id="L211">            p = p.find(s.charAt(i));</span>
        }
        /* march backward through the suffix machine */
<span class="fc" id="L214">        p = suffixMachine;</span>
<span class="pc bpc" id="L215" title="1 of 4 branches missed.">        for (i = len; --i &gt;= 0 &amp;&amp; p != null;) {</span>
<span class="pc bpc" id="L216" title="3 of 4 branches missed.">            if (p.result != null &amp;&amp; p.depth &lt; lastMatchDepth) {</span>
<span class="nc" id="L217">                lastDepth = p.depth;</span>
<span class="nc" id="L218">                best = p;</span>
<span class="nc" id="L219">                bst = 0;</span>
<span class="nc" id="L220">                bend = i+1;</span>
            }
<span class="fc" id="L222">            p = p.find(s.charAt(i));</span>
        }
<span class="fc" id="L224">        Object o = best.result;</span>
<span class="pc bpc" id="L225" title="1 of 4 branches missed.">        if (o != null &amp;&amp; o instanceof RegexpTarget)</span>
<span class="nc" id="L226">            o = ((RegexpTarget) o).found(s.substring(bst, bend));</span>
<span class="fc" id="L227">        return o;</span>
    }

    /** Resets the pool so that the next call to matchNext looks
        at all regular expressions in the pool.  match(s); is equivalent
        to reset(); matchNext(s);
        &lt;p&gt;&lt;b&gt;Multithreading note:&lt;/b&gt; reset/nextMatch leave state in the
        regular expression pool.  If multiple threads could be using this
        pool this way, they should be syncronized to avoid race hazards.
        match() was done in such a way that there are no such race
        hazards: multiple threads can be matching in the same pool
        simultaneously. */
    public void reset() {
<span class="nc" id="L240">        lastDepth = BIG;</span>
<span class="nc" id="L241">    }</span>

    /** Print this pool to standard output */
    public void print(PrintStream out) {
<span class="nc" id="L245">        out.print(&quot;Regexp pool:\n&quot;);</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (suffixMachine.firstchild != null) {</span>
<span class="nc" id="L247">            out.print(&quot; Suffix machine: &quot;);</span>
<span class="nc" id="L248">            suffixMachine.firstchild.print(out);</span>
<span class="nc" id="L249">            out.print(&quot;\n&quot;);</span>
        }
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (prefixMachine.firstchild != null) {</span>
<span class="nc" id="L252">            out.print(&quot; Prefix machine: &quot;);</span>
<span class="nc" id="L253">            prefixMachine.firstchild.print(out);</span>
<span class="nc" id="L254">            out.print(&quot;\n&quot;);</span>
        }
<span class="nc" id="L256">    }</span>

}

/* A node in a regular expression finite state machine. */
class RegexpNode {
    char c;
    RegexpNode firstchild;
    RegexpNode nextsibling;
    int depth;
    boolean exact;
    Object result;
<span class="fc" id="L268">    String re = null;</span>

<span class="fc" id="L270">    RegexpNode () {</span>
<span class="fc" id="L271">        c = '#';</span>
<span class="fc" id="L272">        depth = 0;</span>
<span class="fc" id="L273">    }</span>
<span class="fc" id="L274">    RegexpNode (char C, int depth) {</span>
<span class="fc" id="L275">        c = C;</span>
<span class="fc" id="L276">        this.depth = depth;</span>
<span class="fc" id="L277">    }</span>
    RegexpNode add(char C) {
<span class="fc" id="L279">        RegexpNode p = firstchild;</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">        if (p == null)</span>
<span class="fc" id="L281">            p = new RegexpNode (C, depth+1);</span>
        else {
<span class="fc bfc" id="L283" title="All 2 branches covered.">            while (p != null)</span>
<span class="fc bfc" id="L284" title="All 2 branches covered.">                if (p.c == C)</span>
<span class="fc" id="L285">                    return p;</span>
                else
<span class="fc" id="L287">                    p = p.nextsibling;</span>
<span class="fc" id="L288">            p = new RegexpNode (C, depth+1);</span>
<span class="fc" id="L289">            p.nextsibling = firstchild;</span>
        }
<span class="fc" id="L291">        firstchild = p;</span>
<span class="fc" id="L292">        return p;</span>
    }
    RegexpNode find(char C) {
<span class="fc" id="L295">        for (RegexpNode p = firstchild;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">                p != null;</span>
<span class="fc" id="L297">                p = p.nextsibling)</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">            if (p.c == C)</span>
<span class="fc" id="L299">                return p;</span>
<span class="fc" id="L300">        return null;</span>
    }
    void print(PrintStream out) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (nextsibling != null) {</span>
<span class="nc" id="L304">            RegexpNode p = this;</span>
<span class="nc" id="L305">            out.print(&quot;(&quot;);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            while (p != null) {</span>
<span class="nc" id="L307">                out.write(p.c);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">                if (p.firstchild != null)</span>
<span class="nc" id="L309">                    p.firstchild.print(out);</span>
<span class="nc" id="L310">                p = p.nextsibling;</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                out.write(p != null ? '|' : ')');</span>
            }
<span class="nc" id="L313">        } else {</span>
<span class="nc" id="L314">            out.write(c);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (firstchild != null)</span>
<span class="nc" id="L316">                firstchild.print(out);</span>
        }
<span class="nc" id="L318">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>