<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SoftCache.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.misc</a> &gt; <span class="el_source">SoftCache.java</span></div><h1>SoftCache.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.misc;

import java.lang.ref.SoftReference;
import java.lang.ref.ReferenceQueue;

import java.util.Iterator;
import java.util.Map;
import java.util.AbstractMap;
import java.util.HashMap;
import java.util.Set;
import java.util.AbstractSet;
import java.util.NoSuchElementException;


/**
 * A memory-sensitive implementation of the &lt;code&gt;Map&lt;/code&gt; interface.
 *
 * &lt;p&gt; A &lt;code&gt;SoftCache&lt;/code&gt; object uses {@link java.lang.ref.SoftReference
 * soft references} to implement a memory-sensitive hash map.  If the garbage
 * collector determines at a certain point in time that a value object in a
 * &lt;code&gt;SoftCache&lt;/code&gt; entry is no longer strongly reachable, then it may
 * remove that entry in order to release the memory occupied by the value
 * object.  All &lt;code&gt;SoftCache&lt;/code&gt; objects are guaranteed to be completely
 * cleared before the virtual machine will throw an
 * &lt;code&gt;OutOfMemoryError&lt;/code&gt;.  Because of this automatic clearing feature,
 * the behavior of this class is somewhat different from that of other
 * &lt;code&gt;Map&lt;/code&gt; implementations.
 *
 * &lt;p&gt; Both null values and the null key are supported.  This class has the
 * same performance characteristics as the &lt;code&gt;HashMap&lt;/code&gt; class, and has
 * the same efficiency parameters of &lt;em&gt;initial capacity&lt;/em&gt; and &lt;em&gt;load
 * factor&lt;/em&gt;.
 *
 * &lt;p&gt; Like most collection classes, this class is not synchronized.  A
 * synchronized &lt;code&gt;SoftCache&lt;/code&gt; may be constructed using the
 * &lt;code&gt;Collections.synchronizedMap&lt;/code&gt; method.
 *
 * &lt;p&gt; In typical usage this class will be subclassed and the &lt;code&gt;fill&lt;/code&gt;
 * method will be overridden.  When the &lt;code&gt;get&lt;/code&gt; method is invoked on a
 * key for which there is no mapping in the cache, it will in turn invoke the
 * &lt;code&gt;fill&lt;/code&gt; method on that key in an attempt to construct a
 * corresponding value.  If the &lt;code&gt;fill&lt;/code&gt; method returns such a value
 * then the cache will be updated and the new value will be returned.  Thus,
 * for example, a simple URL-content cache can be constructed as follows:
 *
 * &lt;pre&gt;
 *     public class URLCache extends SoftCache {
 *         protected Object fill(Object key) {
 *             return ((URL)key).getContent();
 *         }
 *     }
 * &lt;/pre&gt;
 *
 * &lt;p&gt; The behavior of the &lt;code&gt;SoftCache&lt;/code&gt; class depends in part upon
 * the actions of the garbage collector, so several familiar (though not
 * required) &lt;code&gt;Map&lt;/code&gt; invariants do not hold for this class.  &lt;p&gt;
 * Because entries are removed from a &lt;code&gt;SoftCache&lt;/code&gt; in response to
 * dynamic advice from the garbage collector, a &lt;code&gt;SoftCache&lt;/code&gt; may
 * behave as though an unknown thread is silently removing entries.  In
 * particular, even if you synchronize on a &lt;code&gt;SoftCache&lt;/code&gt; instance and
 * invoke none of its mutator methods, it is possible for the &lt;code&gt;size&lt;/code&gt;
 * method to return smaller values over time, for the &lt;code&gt;isEmpty&lt;/code&gt;
 * method to return &lt;code&gt;false&lt;/code&gt; and then &lt;code&gt;true&lt;/code&gt;, for the
 * &lt;code&gt;containsKey&lt;/code&gt; method to return &lt;code&gt;true&lt;/code&gt; and later
 * &lt;code&gt;false&lt;/code&gt; for a given key, for the &lt;code&gt;get&lt;/code&gt; method to
 * return a value for a given key but later return &lt;code&gt;null&lt;/code&gt;, for the
 * &lt;code&gt;put&lt;/code&gt; method to return &lt;code&gt;null&lt;/code&gt; and the
 * &lt;code&gt;remove&lt;/code&gt; method to return &lt;code&gt;false&lt;/code&gt; for a key that
 * previously appeared to be in the map, and for successive examinations of the
 * key set, the value set, and the entry set to yield successively smaller
 * numbers of elements.
 *
 * @author      Mark Reinhold
 * @since       1.2
 * @see         java.util.HashMap
 * @see         java.lang.ref.SoftReference
 */


public class SoftCache extends AbstractMap implements Map {

    /* The basic idea of this implementation is to maintain an internal HashMap
       that maps keys to soft references whose referents are the keys' values;
       the various accessor methods dereference these soft references before
       returning values.  Because we don't have access to the innards of the
       HashMap, each soft reference must contain the key that maps to it so
       that the processQueue method can remove keys whose values have been
       discarded.  Thus the HashMap actually maps keys to instances of the
       ValueCell class, which is a simple extension of the SoftReference class.
     */


    static private class ValueCell extends SoftReference {
<span class="nc" id="L119">        static private Object INVALID_KEY = new Object();</span>
<span class="nc" id="L120">        static private int dropped = 0;</span>
        private Object key;

        private ValueCell(Object key, Object value, ReferenceQueue queue) {
<span class="nc" id="L124">            super(value, queue);</span>
<span class="nc" id="L125">            this.key = key;</span>
<span class="nc" id="L126">        }</span>

        private static ValueCell create(Object key, Object value,
                                        ReferenceQueue queue)
        {
<span class="nc bnc" id="L131" title="All 2 branches missed.">            if (value == null) return null;</span>
<span class="nc" id="L132">            return new ValueCell(key, value, queue);</span>
        }

        private static Object strip(Object val, boolean drop) {
<span class="nc bnc" id="L136" title="All 2 branches missed.">            if (val == null) return null;</span>
<span class="nc" id="L137">            ValueCell vc = (ValueCell)val;</span>
<span class="nc" id="L138">            Object o = vc.get();</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (drop) vc.drop();</span>
<span class="nc" id="L140">            return o;</span>
        }

        private boolean isValid() {
<span class="nc bnc" id="L144" title="All 2 branches missed.">            return (key != INVALID_KEY);</span>
        }

        private void drop() {
<span class="nc" id="L148">            super.clear();</span>
<span class="nc" id="L149">            key = INVALID_KEY;</span>
<span class="nc" id="L150">            dropped++;</span>
<span class="nc" id="L151">        }</span>

    }


    /* Hash table mapping keys to ValueCells */
    private Map hash;

    /* Reference queue for cleared ValueCells */
<span class="pc" id="L160">    private ReferenceQueue queue = new ReferenceQueue();</span>


    /* Process any ValueCells that have been cleared and enqueued by the
       garbage collector.  This method should be invoked once by each public
       mutator in this class.  We don't invoke this method in public accessors
       because that can lead to surprising ConcurrentModificationExceptions.
     */
    private void processQueue() {
        ValueCell vc;
<span class="nc bnc" id="L170" title="All 2 branches missed.">        while ((vc = (ValueCell)queue.poll()) != null) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            if (vc.isValid()) hash.remove(vc.key);</span>
<span class="nc" id="L172">            else ValueCell.dropped--;</span>
        }
<span class="nc" id="L174">    }</span>


    /* -- Constructors -- */

    /**
     * Construct a new, empty &lt;code&gt;SoftCache&lt;/code&gt; with the given
     * initial capacity and the given load factor.
     *
     * @param  initialCapacity  The initial capacity of the cache
     *
     * @param  loadFactor       A number between 0.0 and 1.0
     *
     * @throws IllegalArgumentException  If the initial capacity is less than
     *                                   or equal to zero, or if the load
     *                                   factor is less than zero
     */
<span class="nc" id="L191">    public SoftCache(int initialCapacity, float loadFactor) {</span>
<span class="nc" id="L192">        hash = new HashMap(initialCapacity, loadFactor);</span>
<span class="nc" id="L193">    }</span>

    /**
     * Construct a new, empty &lt;code&gt;SoftCache&lt;/code&gt; with the given
     * initial capacity and the default load factor.
     *
     * @param  initialCapacity  The initial capacity of the cache
     *
     * @throws IllegalArgumentException  If the initial capacity is less than
     *                                   or equal to zero
     */
<span class="nc" id="L204">    public SoftCache(int initialCapacity) {</span>
<span class="nc" id="L205">        hash = new HashMap(initialCapacity);</span>
<span class="nc" id="L206">    }</span>

    /**
     * Construct a new, empty &lt;code&gt;SoftCache&lt;/code&gt; with the default
     * capacity and the default load factor.
     */
<span class="fc" id="L212">    public SoftCache() {</span>
<span class="fc" id="L213">        hash = new HashMap();</span>
<span class="fc" id="L214">    }</span>


    /* -- Simple queries -- */

    /**
     * Return the number of key-value mappings in this cache.  The time
     * required by this operation is linear in the size of the map.
     */
    public int size() {
<span class="nc" id="L224">        return entrySet().size();</span>
    }

    /**
     * Return &lt;code&gt;true&lt;/code&gt; if this cache contains no key-value mappings.
     */
    public boolean isEmpty() {
<span class="nc" id="L231">        return entrySet().isEmpty();</span>
    }

    /**
     * Return &lt;code&gt;true&lt;/code&gt; if this cache contains a mapping for the
     * specified key.  If there is no mapping for the key, this method will not
     * attempt to construct one by invoking the &lt;code&gt;fill&lt;/code&gt; method.
     *
     * @param   key   The key whose presence in the cache is to be tested
     */
    public boolean containsKey(Object key) {
<span class="nc bnc" id="L242" title="All 2 branches missed.">        return ValueCell.strip(hash.get(key), false) != null;</span>
    }


    /* -- Lookup and modification operations -- */

    /**
     * Create a value object for the given &lt;code&gt;key&lt;/code&gt;.  This method is
     * invoked by the &lt;code&gt;get&lt;/code&gt; method when there is no entry for
     * &lt;code&gt;key&lt;/code&gt;.  If this method returns a non-&lt;code&gt;null&lt;/code&gt; value,
     * then the cache will be updated to map &lt;code&gt;key&lt;/code&gt; to that value,
     * and that value will be returned by the &lt;code&gt;get&lt;/code&gt; method.
     *
     * &lt;p&gt; The default implementation of this method simply returns
     * &lt;code&gt;null&lt;/code&gt; for every &lt;code&gt;key&lt;/code&gt; value.  A subclass may
     * override this method to provide more useful behavior.
     *
     * @param  key  The key for which a value is to be computed
     *
     * @return      A value for &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if one
     *              could not be computed
     * @see #get
     */
    protected Object fill(Object key) {
<span class="nc" id="L266">        return null;</span>
    }

    /**
     * Return the value to which this cache maps the specified
     * &lt;code&gt;key&lt;/code&gt;.  If the cache does not presently contain a value for
     * this key, then invoke the &lt;code&gt;fill&lt;/code&gt; method in an attempt to
     * compute such a value.  If that method returns a non-&lt;code&gt;null&lt;/code&gt;
     * value, then update the cache and return the new value.  Otherwise,
     * return &lt;code&gt;null&lt;/code&gt;.
     *
     * &lt;p&gt; Note that because this method may update the cache, it is considered
     * a mutator and may cause &lt;code&gt;ConcurrentModificationException&lt;/code&gt;s to
     * be thrown if invoked while an iterator is in use.
     *
     * @param  key  The key whose associated value, if any, is to be returned
     *
     * @see #fill
     */
    public Object get(Object key) {
<span class="nc" id="L286">        processQueue();</span>
<span class="nc" id="L287">        Object v = hash.get(key);</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (v == null) {</span>
<span class="nc" id="L289">            v = fill(key);</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (v != null) {</span>
<span class="nc" id="L291">                hash.put(key, ValueCell.create(key, v, queue));</span>
<span class="nc" id="L292">                return v;</span>
            }
        }
<span class="nc" id="L295">        return ValueCell.strip(v, false);</span>
    }

    /**
     * Update this cache so that the given &lt;code&gt;key&lt;/code&gt; maps to the given
     * &lt;code&gt;value&lt;/code&gt;.  If the cache previously contained a mapping for
     * &lt;code&gt;key&lt;/code&gt; then that mapping is replaced and the old value is
     * returned.
     *
     * @param  key    The key that is to be mapped to the given
     *                &lt;code&gt;value&lt;/code&gt;
     * @param  value  The value to which the given &lt;code&gt;key&lt;/code&gt; is to be
     *                mapped
     *
     * @return  The previous value to which this key was mapped, or
     *          &lt;code&gt;null&lt;/code&gt; if if there was no mapping for the key
     */
    public Object put(Object key, Object value) {
<span class="nc" id="L313">        processQueue();</span>
<span class="nc" id="L314">        ValueCell vc = ValueCell.create(key, value, queue);</span>
<span class="nc" id="L315">        return ValueCell.strip(hash.put(key, vc), true);</span>
    }

    /**
     * Remove the mapping for the given &lt;code&gt;key&lt;/code&gt; from this cache, if
     * present.
     *
     * @param  key  The key whose mapping is to be removed
     *
     * @return  The value to which this key was mapped, or &lt;code&gt;null&lt;/code&gt; if
     *          there was no mapping for the key
     */
    public Object remove(Object key) {
<span class="nc" id="L328">        processQueue();</span>
<span class="nc" id="L329">        return ValueCell.strip(hash.remove(key), true);</span>
    }

    /**
     * Remove all mappings from this cache.
     */
    public void clear() {
<span class="nc" id="L336">        processQueue();</span>
<span class="nc" id="L337">        hash.clear();</span>
<span class="nc" id="L338">    }</span>


    /* -- Views -- */

    private static boolean valEquals(Object o1, Object o2) {
<span class="nc bnc" id="L344" title="All 4 branches missed.">        return (o1 == null) ? (o2 == null) : o1.equals(o2);</span>
    }


    /* Internal class for entries.
       Because it uses SoftCache.this.queue, this class cannot be static.
     */
    private class Entry implements Map.Entry {
        private Map.Entry ent;
        private Object value;   /* Strong reference to value, to prevent the GC
                                   from flushing the value while this Entry
                                   exists */

<span class="nc" id="L357">        Entry(Map.Entry ent, Object value) {</span>
<span class="nc" id="L358">            this.ent = ent;</span>
<span class="nc" id="L359">            this.value = value;</span>
<span class="nc" id="L360">        }</span>

        public Object getKey() {
<span class="nc" id="L363">            return ent.getKey();</span>
        }

        public Object getValue() {
<span class="nc" id="L367">            return value;</span>
        }

        public Object setValue(Object value) {
<span class="nc" id="L371">            return ent.setValue(ValueCell.create(ent.getKey(), value, queue));</span>
        }

        public boolean equals(Object o) {
<span class="nc bnc" id="L375" title="All 2 branches missed.">            if (! (o instanceof Map.Entry)) return false;</span>
<span class="nc" id="L376">            Map.Entry e = (Map.Entry)o;</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">            return (valEquals(ent.getKey(), e.getKey())</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                    &amp;&amp; valEquals(value, e.getValue()));</span>
        }

        public int hashCode() {
            Object k;
<span class="nc bnc" id="L383" title="All 4 branches missed.">            return ((((k = getKey()) == null) ? 0 : k.hashCode())</span>
<span class="nc" id="L384">                    ^ ((value == null) ? 0 : value.hashCode()));</span>
        }

    }


    /* Internal class for entry sets */
<span class="nc" id="L391">    private class EntrySet extends AbstractSet {</span>
<span class="nc" id="L392">        Set hashEntries = hash.entrySet();</span>

        public Iterator iterator() {

<span class="nc" id="L396">            return new Iterator() {</span>
<span class="nc" id="L397">                Iterator hashIterator = hashEntries.iterator();</span>
<span class="nc" id="L398">                Entry next = null;</span>

                public boolean hasNext() {
<span class="nc bnc" id="L401" title="All 2 branches missed.">                    while (hashIterator.hasNext()) {</span>
<span class="nc" id="L402">                        Map.Entry ent = (Map.Entry)hashIterator.next();</span>
<span class="nc" id="L403">                        ValueCell vc = (ValueCell)ent.getValue();</span>
<span class="nc" id="L404">                        Object v = null;</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">                        if ((vc != null) &amp;&amp; ((v = vc.get()) == null)) {</span>
                            /* Value has been flushed by GC */
<span class="nc" id="L407">                            continue;</span>
                        }
<span class="nc" id="L409">                        next = new Entry(ent, v);</span>
<span class="nc" id="L410">                        return true;</span>
                    }
<span class="nc" id="L412">                    return false;</span>
                }

                public Object next() {
<span class="nc bnc" id="L416" title="All 4 branches missed.">                    if ((next == null) &amp;&amp; !hasNext())</span>
<span class="nc" id="L417">                        throw new NoSuchElementException();</span>
<span class="nc" id="L418">                    Entry e = next;</span>
<span class="nc" id="L419">                    next = null;</span>
<span class="nc" id="L420">                    return e;</span>
                }

                public void remove() {
<span class="nc" id="L424">                    hashIterator.remove();</span>
<span class="nc" id="L425">                }</span>

            };
        }

        public boolean isEmpty() {
<span class="nc bnc" id="L431" title="All 2 branches missed.">            return !(iterator().hasNext());</span>
        }

        public int size() {
<span class="nc" id="L435">            int j = 0;</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            for (Iterator i = iterator(); i.hasNext(); i.next()) j++;</span>
<span class="nc" id="L437">            return j;</span>
        }

        public boolean remove(Object o) {
<span class="nc" id="L441">            processQueue();</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">            if (o instanceof Entry) return hashEntries.remove(((Entry)o).ent);</span>
<span class="nc" id="L443">            else return false;</span>
        }

    }


<span class="pc" id="L449">    private Set entrySet = null;</span>

    /**
     * Return a &lt;code&gt;Set&lt;/code&gt; view of the mappings in this cache.
     */
    public Set entrySet() {
<span class="nc bnc" id="L455" title="All 2 branches missed.">        if (entrySet == null) entrySet = new EntrySet();</span>
<span class="nc" id="L456">        return entrySet;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>