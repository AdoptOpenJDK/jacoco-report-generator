<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Service.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.misc</a> &gt; <span class="el_source">Service.java</span></div><h1>Service.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.misc;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.TreeSet;


/**
 * A simple service-provider lookup mechanism.  A &lt;i&gt;service&lt;/i&gt; is a
 * well-known set of interfaces and (usually abstract) classes.  A &lt;i&gt;service
 * provider&lt;/i&gt; is a specific implementation of a service.  The classes in a
 * provider typically implement the interfaces and subclass the classes defined
 * in the service itself.  Service providers may be installed in an
 * implementation of the Java platform in the form of extensions, that is, jar
 * files placed into any of the usual extension directories.  Providers may
 * also be made available by adding them to the applet or application class
 * path or by some other platform-specific means.
 *
 * &lt;p&gt; In this lookup mechanism a service is represented by an interface or an
 * abstract class.  (A concrete class may be used, but this is not
 * recommended.)  A provider of a given service contains one or more concrete
 * classes that extend this &lt;i&gt;service class&lt;/i&gt; with data and code specific to
 * the provider.  This &lt;i&gt;provider class&lt;/i&gt; will typically not be the entire
 * provider itself but rather a proxy that contains enough information to
 * decide whether the provider is able to satisfy a particular request together
 * with code that can create the actual provider on demand.  The details of
 * provider classes tend to be highly service-specific; no single class or
 * interface could possibly unify them, so no such class has been defined.  The
 * only requirement enforced here is that provider classes must have a
 * zero-argument constructor so that they may be instantiated during lookup.
 *
 * &lt;p&gt; A service provider identifies itself by placing a provider-configuration
 * file in the resource directory &lt;tt&gt;META-INF/services&lt;/tt&gt;.  The file's name
 * should consist of the fully-qualified name of the abstract service class.
 * The file should contain a list of fully-qualified concrete provider-class
 * names, one per line.  Space and tab characters surrounding each name, as
 * well as blank lines, are ignored.  The comment character is &lt;tt&gt;'#'&lt;/tt&gt;
 * (&lt;tt&gt;0x23&lt;/tt&gt;); on each line all characters following the first comment
 * character are ignored.  The file must be encoded in UTF-8.
 *
 * &lt;p&gt; If a particular concrete provider class is named in more than one
 * configuration file, or is named in the same configuration file more than
 * once, then the duplicates will be ignored.  The configuration file naming a
 * particular provider need not be in the same jar file or other distribution
 * unit as the provider itself.  The provider must be accessible from the same
 * class loader that was initially queried to locate the configuration file;
 * note that this is not necessarily the class loader that found the file.
 *
 * &lt;p&gt; &lt;b&gt;Example:&lt;/b&gt; Suppose we have a service class named
 * &lt;tt&gt;java.io.spi.CharCodec&lt;/tt&gt;.  It has two abstract methods:
 *
 * &lt;pre&gt;
 *   public abstract CharEncoder getEncoder(String encodingName);
 *   public abstract CharDecoder getDecoder(String encodingName);
 * &lt;/pre&gt;
 *
 * Each method returns an appropriate object or &lt;tt&gt;null&lt;/tt&gt; if it cannot
 * translate the given encoding.  Typical &lt;tt&gt;CharCodec&lt;/tt&gt; providers will
 * support more than one encoding.
 *
 * &lt;p&gt; If &lt;tt&gt;sun.io.StandardCodec&lt;/tt&gt; is a provider of the &lt;tt&gt;CharCodec&lt;/tt&gt;
 * service then its jar file would contain the file
 * &lt;tt&gt;META-INF/services/java.io.spi.CharCodec&lt;/tt&gt;.  This file would contain
 * the single line:
 *
 * &lt;pre&gt;
 *   sun.io.StandardCodec    # Standard codecs for the platform
 * &lt;/pre&gt;
 *
 * To locate an encoder for a given encoding name, the internal I/O code would
 * do something like this:
 *
 * &lt;pre&gt;
 *   CharEncoder getEncoder(String encodingName) {
 *       Iterator ps = Service.providers(CharCodec.class);
 *       while (ps.hasNext()) {
 *           CharCodec cc = (CharCodec)ps.next();
 *           CharEncoder ce = cc.getEncoder(encodingName);
 *           if (ce != null)
 *               return ce;
 *       }
 *       return null;
 *   }
 * &lt;/pre&gt;
 *
 * The provider-lookup mechanism always executes in the security context of the
 * caller.  Trusted system code should typically invoke the methods in this
 * class from within a privileged security context.
 *
 * @author Mark Reinhold
 * @since 1.3
 */

public final class Service&lt;S&gt; {

    private static final String prefix = &quot;META-INF/services/&quot;;

<span class="nc" id="L132">    private Service() { }</span>

    private static void fail(Class&lt;?&gt; service, String msg, Throwable cause)
        throws ServiceConfigurationError
    {
<span class="nc" id="L137">        ServiceConfigurationError sce</span>
<span class="nc" id="L138">            = new ServiceConfigurationError(service.getName() + &quot;: &quot; + msg);</span>
<span class="nc" id="L139">        sce.initCause(cause);</span>
<span class="nc" id="L140">        throw sce;</span>
    }

    private static void fail(Class&lt;?&gt; service, String msg)
        throws ServiceConfigurationError
    {
<span class="nc" id="L146">        throw new ServiceConfigurationError(service.getName() + &quot;: &quot; + msg);</span>
    }

    private static void fail(Class&lt;?&gt; service, URL u, int line, String msg)
        throws ServiceConfigurationError
    {
<span class="nc" id="L152">        fail(service, u + &quot;:&quot; + line + &quot;: &quot; + msg);</span>
<span class="nc" id="L153">    }</span>

    /**
     * Parse a single line from the given configuration file, adding the name
     * on the line to both the names list and the returned set iff the name is
     * not already a member of the returned set.
     */
    private static int parseLine(Class&lt;?&gt; service, URL u, BufferedReader r, int lc,
                                 List&lt;String&gt; names, Set&lt;String&gt; returned)
        throws IOException, ServiceConfigurationError
    {
<span class="fc" id="L164">        String ln = r.readLine();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (ln == null) {</span>
<span class="fc" id="L166">            return -1;</span>
        }
<span class="fc" id="L168">        int ci = ln.indexOf('#');</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (ci &gt;= 0) ln = ln.substring(0, ci);</span>
<span class="fc" id="L170">        ln = ln.trim();</span>
<span class="fc" id="L171">        int n = ln.length();</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">        if (n != 0) {</span>
<span class="pc bpc" id="L173" title="2 of 4 branches missed.">            if ((ln.indexOf(' ') &gt;= 0) || (ln.indexOf('\t') &gt;= 0))</span>
<span class="nc" id="L174">                fail(service, u, lc, &quot;Illegal configuration-file syntax&quot;);</span>
<span class="fc" id="L175">            int cp = ln.codePointAt(0);</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">            if (!Character.isJavaIdentifierStart(cp))</span>
<span class="nc" id="L177">                fail(service, u, lc, &quot;Illegal provider-class name: &quot; + ln);</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">            for (int i = Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) {</span>
<span class="fc" id="L179">                cp = ln.codePointAt(i);</span>
<span class="pc bpc" id="L180" title="1 of 4 branches missed.">                if (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != '.'))</span>
<span class="nc" id="L181">                    fail(service, u, lc, &quot;Illegal provider-class name: &quot; + ln);</span>
            }
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            if (!returned.contains(ln)) {</span>
<span class="fc" id="L184">                names.add(ln);</span>
<span class="fc" id="L185">                returned.add(ln);</span>
            }
        }
<span class="fc" id="L188">        return lc + 1;</span>
    }

    /**
     * Parse the content of the given URL as a provider-configuration file.
     *
     * @param  service
     *         The service class for which providers are being sought;
     *         used to construct error detail strings
     *
     * @param  url
     *         The URL naming the configuration file to be parsed
     *
     * @param  returned
     *         A Set containing the names of provider classes that have already
     *         been returned.  This set will be updated to contain the names
     *         that will be yielded from the returned &lt;tt&gt;Iterator&lt;/tt&gt;.
     *
     * @return A (possibly empty) &lt;tt&gt;Iterator&lt;/tt&gt; that will yield the
     *         provider-class names in the given configuration file that are
     *         not yet members of the returned set
     *
     * @throws ServiceConfigurationError
     *         If an I/O error occurs while reading from the given URL, or
     *         if a configuration-file format error is detected
     */
    private static Iterator&lt;String&gt; parse(Class&lt;?&gt; service, URL u, Set&lt;String&gt; returned)
        throws ServiceConfigurationError
    {
<span class="fc" id="L217">        InputStream in = null;</span>
<span class="fc" id="L218">        BufferedReader r = null;</span>
<span class="fc" id="L219">        ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;();</span>
        try {
<span class="fc" id="L221">            in = u.openStream();</span>
<span class="fc" id="L222">            r = new BufferedReader(new InputStreamReader(in, &quot;utf-8&quot;));</span>
<span class="fc" id="L223">            int lc = 1;</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">            while ((lc = parseLine(service, u, r, lc, names, returned)) &gt;= 0);</span>
<span class="nc" id="L225">        } catch (IOException x) {</span>
<span class="nc" id="L226">            fail(service, &quot;: &quot; + x);</span>
        } finally {
<span class="nc" id="L228">            try {</span>
<span class="pc bpc" id="L229" title="5 of 6 branches missed.">                if (r != null) r.close();</span>
<span class="pc bpc" id="L230" title="5 of 6 branches missed.">                if (in != null) in.close();</span>
<span class="nc" id="L231">            } catch (IOException y) {</span>
<span class="nc" id="L232">                fail(service, &quot;: &quot; + y);</span>
<span class="pc" id="L233">            }</span>
<span class="nc" id="L234">        }</span>
<span class="fc" id="L235">        return names.iterator();</span>
    }


    /**
     * Private inner class implementing fully-lazy provider lookup
     */
    private static class LazyIterator&lt;S&gt; implements Iterator&lt;S&gt; {

        Class&lt;S&gt; service;
        ClassLoader loader;
<span class="fc" id="L246">        Enumeration&lt;URL&gt; configs = null;</span>
<span class="fc" id="L247">        Iterator&lt;String&gt; pending = null;</span>
<span class="fc" id="L248">        Set&lt;String&gt; returned = new TreeSet&lt;&gt;();</span>
<span class="fc" id="L249">        String nextName = null;</span>

<span class="fc" id="L251">        private LazyIterator(Class&lt;S&gt; service, ClassLoader loader) {</span>
<span class="fc" id="L252">            this.service = service;</span>
<span class="fc" id="L253">            this.loader = loader;</span>
<span class="fc" id="L254">        }</span>

        public boolean hasNext() throws ServiceConfigurationError {
<span class="fc bfc" id="L257" title="All 2 branches covered.">            if (nextName != null) {</span>
<span class="fc" id="L258">                return true;</span>
            }
<span class="fc bfc" id="L260" title="All 2 branches covered.">            if (configs == null) {</span>
                try {
<span class="fc" id="L262">                    String fullName = prefix + service.getName();</span>
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">                    if (loader == null)</span>
<span class="nc" id="L264">                        configs = ClassLoader.getSystemResources(fullName);</span>
                    else
<span class="fc" id="L266">                        configs = loader.getResources(fullName);</span>
<span class="nc" id="L267">                } catch (IOException x) {</span>
<span class="nc" id="L268">                    fail(service, &quot;: &quot; + x);</span>
<span class="fc" id="L269">                }</span>
            }
<span class="fc bfc" id="L271" title="All 4 branches covered.">            while ((pending == null) || !pending.hasNext()) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                if (!configs.hasMoreElements()) {</span>
<span class="fc" id="L273">                    return false;</span>
                }
<span class="fc" id="L275">                pending = parse(service, configs.nextElement(), returned);</span>
            }
<span class="fc" id="L277">            nextName = pending.next();</span>
<span class="fc" id="L278">            return true;</span>
        }

        public S next() throws ServiceConfigurationError {
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">            if (!hasNext()) {</span>
<span class="nc" id="L283">                throw new NoSuchElementException();</span>
            }
<span class="fc" id="L285">            String cn = nextName;</span>
<span class="fc" id="L286">            nextName = null;</span>
<span class="fc" id="L287">            Class&lt;?&gt; c = null;</span>
            try {
<span class="fc" id="L289">                c = Class.forName(cn, false, loader);</span>
<span class="nc" id="L290">            } catch (ClassNotFoundException x) {</span>
<span class="nc" id="L291">                fail(service,</span>
                     &quot;Provider &quot; + cn + &quot; not found&quot;);
<span class="fc" id="L293">            }</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">            if (!service.isAssignableFrom(c)) {</span>
<span class="nc" id="L295">                fail(service,</span>
                     &quot;Provider &quot; + cn  + &quot; not a subtype&quot;);
            }
            try {
<span class="fc" id="L299">                return service.cast(c.newInstance());</span>
<span class="nc" id="L300">            } catch (Throwable x) {</span>
<span class="nc" id="L301">                fail(service,</span>
                     &quot;Provider &quot; + cn + &quot; could not be instantiated: &quot; + x,
                     x);
            }
<span class="nc" id="L305">            return null;        /* This cannot happen */</span>
        }

        public void remove() {
<span class="nc" id="L309">            throw new UnsupportedOperationException();</span>
        }

    }


    /**
     * Locates and incrementally instantiates the available providers of a
     * given service using the given class loader.
     *
     * &lt;p&gt; This method transforms the name of the given service class into a
     * provider-configuration filename as described above and then uses the
     * &lt;tt&gt;getResources&lt;/tt&gt; method of the given class loader to find all
     * available files with that name.  These files are then read and parsed to
     * produce a list of provider-class names.  The iterator that is returned
     * uses the given class loader to lookup and then instantiate each element
     * of the list.
     *
     * &lt;p&gt; Because it is possible for extensions to be installed into a running
     * Java virtual machine, this method may return different results each time
     * it is invoked. &lt;p&gt;
     *
     * @param  service
     *         The service's abstract service class
     *
     * @param  loader
     *         The class loader to be used to load provider-configuration files
     *         and instantiate provider classes, or &lt;tt&gt;null&lt;/tt&gt; if the system
     *         class loader (or, failing that the bootstrap class loader) is to
     *         be used
     *
     * @return An &lt;tt&gt;Iterator&lt;/tt&gt; that yields provider objects for the given
     *         service, in some arbitrary order.  The iterator will throw a
     *         &lt;tt&gt;ServiceConfigurationError&lt;/tt&gt; if a provider-configuration
     *         file violates the specified format or if a provider class cannot
     *         be found and instantiated.
     *
     * @throws ServiceConfigurationError
     *         If a provider-configuration file violates the specified format
     *         or names a provider class that cannot be found and instantiated
     *
     * @see #providers(java.lang.Class)
     * @see #installedProviders(java.lang.Class)
     */
    public static &lt;S&gt; Iterator&lt;S&gt; providers(Class&lt;S&gt; service, ClassLoader loader)
        throws ServiceConfigurationError
    {
<span class="fc" id="L356">        return new LazyIterator&lt;S&gt;(service, loader);</span>
    }


    /**
     * Locates and incrementally instantiates the available providers of a
     * given service using the context class loader.  This convenience method
     * is equivalent to
     *
     * &lt;pre&gt;
     *   ClassLoader cl = Thread.currentThread().getContextClassLoader();
     *   return Service.providers(service, cl);
     * &lt;/pre&gt;
     *
     * @param  service
     *         The service's abstract service class
     *
     * @return An &lt;tt&gt;Iterator&lt;/tt&gt; that yields provider objects for the given
     *         service, in some arbitrary order.  The iterator will throw a
     *         &lt;tt&gt;ServiceConfigurationError&lt;/tt&gt; if a provider-configuration
     *         file violates the specified format or if a provider class cannot
     *         be found and instantiated.
     *
     * @throws ServiceConfigurationError
     *         If a provider-configuration file violates the specified format
     *         or names a provider class that cannot be found and instantiated
     *
     * @see #providers(java.lang.Class, java.lang.ClassLoader)
     */
    public static &lt;S&gt; Iterator&lt;S&gt; providers(Class&lt;S&gt; service)
        throws ServiceConfigurationError
    {
<span class="nc" id="L388">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span>
<span class="nc" id="L389">        return Service.providers(service, cl);</span>
    }


    /**
     * Locates and incrementally instantiates the available providers of a
     * given service using the extension class loader.  This convenience method
     * simply locates the extension class loader, call it
     * &lt;tt&gt;extClassLoader&lt;/tt&gt;, and then does
     *
     * &lt;pre&gt;
     *   return Service.providers(service, extClassLoader);
     * &lt;/pre&gt;
     *
     * If the extension class loader cannot be found then the system class
     * loader is used; if there is no system class loader then the bootstrap
     * class loader is used.
     *
     * @param  service
     *         The service's abstract service class
     *
     * @return An &lt;tt&gt;Iterator&lt;/tt&gt; that yields provider objects for the given
     *         service, in some arbitrary order.  The iterator will throw a
     *         &lt;tt&gt;ServiceConfigurationError&lt;/tt&gt; if a provider-configuration
     *         file violates the specified format or if a provider class cannot
     *         be found and instantiated.
     *
     * @throws ServiceConfigurationError
     *         If a provider-configuration file violates the specified format
     *         or names a provider class that cannot be found and instantiated
     *
     * @see #providers(java.lang.Class, java.lang.ClassLoader)
     */
    public static &lt;S&gt; Iterator&lt;S&gt; installedProviders(Class&lt;S&gt; service)
        throws ServiceConfigurationError
    {
<span class="nc" id="L425">        ClassLoader cl = ClassLoader.getSystemClassLoader();</span>
<span class="nc" id="L426">        ClassLoader prev = null;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        while (cl != null) {</span>
<span class="nc" id="L428">            prev = cl;</span>
<span class="nc" id="L429">            cl = cl.getParent();</span>
        }
<span class="nc" id="L431">        return Service.providers(service, prev);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>