<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FloatingDecimal.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.misc</a> &gt; <span class="el_source">FloatingDecimal.java</span></div><h1>FloatingDecimal.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.misc;

import java.util.Arrays;
import java.util.regex.*;

/**
 * A class for converting between ASCII and decimal representations of a single
 * or double precision floating point number. Most conversions are provided via
 * static convenience methods, although a &lt;code&gt;BinaryToASCIIConverter&lt;/code&gt;
 * instance may be obtained and reused.
 */
<span class="pc bfc" id="L37" title="All 2 branches covered.">public class FloatingDecimal{</span>
    //
    // Constants of the implementation;
    // most are IEEE-754 related.
    // (There are more really boring constants at the end.)
    //
    static final int    EXP_SHIFT = DoubleConsts.SIGNIFICAND_WIDTH - 1;
    static final long   FRACT_HOB = ( 1L&lt;&lt;EXP_SHIFT ); // assumed High-Order bit
    static final long   EXP_ONE   = ((long)DoubleConsts.EXP_BIAS)&lt;&lt;EXP_SHIFT; // exponent of 1.0
    static final int    MAX_SMALL_BIN_EXP = 62;
    static final int    MIN_SMALL_BIN_EXP = -( 63 / 3 );
    static final int    MAX_DECIMAL_DIGITS = 15;
    static final int    MAX_DECIMAL_EXPONENT = 308;
    static final int    MIN_DECIMAL_EXPONENT = -324;
    static final int    BIG_DECIMAL_EXPONENT = 324; // i.e. abs(MIN_DECIMAL_EXPONENT)
    static final int    MAX_NDIGITS = 1100;

    static final int    SINGLE_EXP_SHIFT  =   FloatConsts.SIGNIFICAND_WIDTH - 1;
    static final int    SINGLE_FRACT_HOB  =   1&lt;&lt;SINGLE_EXP_SHIFT;
    static final int    SINGLE_MAX_DECIMAL_DIGITS = 7;
    static final int    SINGLE_MAX_DECIMAL_EXPONENT = 38;
    static final int    SINGLE_MIN_DECIMAL_EXPONENT = -45;
    static final int    SINGLE_MAX_NDIGITS = 200;

    static final int    INT_DECIMAL_DIGITS = 9;

    /**
     * Converts a double precision floating point value to a &lt;code&gt;String&lt;/code&gt;.
     *
     * @param d The double precision value.
     * @return The value converted to a &lt;code&gt;String&lt;/code&gt;.
     */
    public static String toJavaFormatString(double d) {
<span class="fc" id="L70">        return getBinaryToASCIIConverter(d).toJavaFormatString();</span>
    }

    /**
     * Converts a single precision floating point value to a &lt;code&gt;String&lt;/code&gt;.
     *
     * @param f The single precision value.
     * @return The value converted to a &lt;code&gt;String&lt;/code&gt;.
     */
    public static String toJavaFormatString(float f) {
<span class="fc" id="L80">        return getBinaryToASCIIConverter(f).toJavaFormatString();</span>
    }

    /**
     * Appends a double precision floating point value to an &lt;code&gt;Appendable&lt;/code&gt;.
     * @param d The double precision value.
     * @param buf The &lt;code&gt;Appendable&lt;/code&gt; with the value appended.
     */
    public static void appendTo(double d, Appendable buf) {
<span class="fc" id="L89">        getBinaryToASCIIConverter(d).appendTo(buf);</span>
<span class="fc" id="L90">    }</span>

    /**
     * Appends a single precision floating point value to an &lt;code&gt;Appendable&lt;/code&gt;.
     * @param f The single precision value.
     * @param buf The &lt;code&gt;Appendable&lt;/code&gt; with the value appended.
     */
    public static void appendTo(float f, Appendable buf) {
<span class="fc" id="L98">        getBinaryToASCIIConverter(f).appendTo(buf);</span>
<span class="fc" id="L99">    }</span>

    /**
     * Converts a &lt;code&gt;String&lt;/code&gt; to a double precision floating point value.
     *
     * @param s The &lt;code&gt;String&lt;/code&gt; to convert.
     * @return The double precision value.
     * @throws NumberFormatException If the &lt;code&gt;String&lt;/code&gt; does not
     * represent a properly formatted double precision value.
     */
    public static double parseDouble(String s) throws NumberFormatException {
<span class="fc" id="L110">        return readJavaFormatString(s).doubleValue();</span>
    }

    /**
     * Converts a &lt;code&gt;String&lt;/code&gt; to a single precision floating point value.
     *
     * @param s The &lt;code&gt;String&lt;/code&gt; to convert.
     * @return The single precision value.
     * @throws NumberFormatException If the &lt;code&gt;String&lt;/code&gt; does not
     * represent a properly formatted single precision value.
     */
    public static float parseFloat(String s) throws NumberFormatException {
<span class="fc" id="L122">        return readJavaFormatString(s).floatValue();</span>
    }

    /**
     * A converter which can process single or double precision floating point
     * values into an ASCII &lt;code&gt;String&lt;/code&gt; representation.
     */
    public interface BinaryToASCIIConverter {
        /**
         * Converts a floating point value into an ASCII &lt;code&gt;String&lt;/code&gt;.
         * @return The value converted to a &lt;code&gt;String&lt;/code&gt;.
         */
        public String toJavaFormatString();

        /**
         * Appends a floating point value to an &lt;code&gt;Appendable&lt;/code&gt;.
         * @param buf The &lt;code&gt;Appendable&lt;/code&gt; to receive the value.
         */
        public void appendTo(Appendable buf);

        /**
         * Retrieves the decimal exponent most closely corresponding to this value.
         * @return The decimal exponent.
         */
        public int getDecimalExponent();

        /**
         * Retrieves the value as an array of digits.
         * @param digits The digit array.
         * @return The number of valid digits copied into the array.
         */
        public int getDigits(char[] digits);

        /**
         * Indicates the sign of the value.
         * @return &lt;code&gt;value &lt; 0.0&lt;/code&gt;.
         */
        public boolean isNegative();

        /**
         * Indicates whether the value is either infinite or not a number.
         *
         * @return &lt;code&gt;true&lt;/code&gt; if and only if the value is &lt;code&gt;NaN&lt;/code&gt;
         * or infinite.
         */
        public boolean isExceptional();

        /**
         * Indicates whether the value was rounded up during the binary to ASCII
         * conversion.
         *
         * @return &lt;code&gt;true&lt;/code&gt; if and only if the value was rounded up.
         */
        public boolean digitsRoundedUp();

        /**
         * Indicates whether the binary to ASCII conversion was exact.
         *
         * @return &lt;code&gt;true&lt;/code&gt; if any only if the conversion was exact.
         */
        public boolean decimalDigitsExact();
    }

    /**
     * A &lt;code&gt;BinaryToASCIIConverter&lt;/code&gt; which represents &lt;code&gt;NaN&lt;/code&gt;
     * and infinite values.
     */
<span class="fc bfc" id="L189" title="All 2 branches covered.">    private static class ExceptionalBinaryToASCIIBuffer implements BinaryToASCIIConverter {</span>
        final private String image;
        private boolean isNegative;

<span class="fc" id="L193">        public ExceptionalBinaryToASCIIBuffer(String image, boolean isNegative) {</span>
<span class="fc" id="L194">            this.image = image;</span>
<span class="fc" id="L195">            this.isNegative = isNegative;</span>
<span class="fc" id="L196">        }</span>

        @Override
        public String toJavaFormatString() {
<span class="nc" id="L200">            return image;</span>
        }

        @Override
        public void appendTo(Appendable buf) {
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">            if (buf instanceof StringBuilder) {</span>
<span class="fc" id="L206">                ((StringBuilder) buf).append(image);</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            } else if (buf instanceof StringBuffer) {</span>
<span class="nc" id="L208">                ((StringBuffer) buf).append(image);</span>
            } else {
<span class="nc bnc" id="L210" title="All 2 branches missed.">                assert false;</span>
            }
<span class="fc" id="L212">        }</span>

        @Override
        public int getDecimalExponent() {
<span class="nc" id="L216">            throw new IllegalArgumentException(&quot;Exceptional value does not have an exponent&quot;);</span>
        }

        @Override
        public int getDigits(char[] digits) {
<span class="nc" id="L221">            throw new IllegalArgumentException(&quot;Exceptional value does not have digits&quot;);</span>
        }

        @Override
        public boolean isNegative() {
<span class="nc" id="L226">            return isNegative;</span>
        }

        @Override
        public boolean isExceptional() {
<span class="nc" id="L231">            return true;</span>
        }

        @Override
        public boolean digitsRoundedUp() {
<span class="nc" id="L236">            throw new IllegalArgumentException(&quot;Exceptional value is not rounded&quot;);</span>
        }

        @Override
        public boolean decimalDigitsExact() {
<span class="nc" id="L241">            throw new IllegalArgumentException(&quot;Exceptional value is not exact&quot;);</span>
        }
    }

    private static final String INFINITY_REP = &quot;Infinity&quot;;
<span class="fc" id="L246">    private static final int INFINITY_LENGTH = INFINITY_REP.length();</span>
    private static final String NAN_REP = &quot;NaN&quot;;
<span class="fc" id="L248">    private static final int NAN_LENGTH = NAN_REP.length();</span>

<span class="fc" id="L250">    private static final BinaryToASCIIConverter B2AC_POSITIVE_INFINITY = new ExceptionalBinaryToASCIIBuffer(INFINITY_REP, false);</span>
<span class="fc" id="L251">    private static final BinaryToASCIIConverter B2AC_NEGATIVE_INFINITY = new ExceptionalBinaryToASCIIBuffer(&quot;-&quot; + INFINITY_REP, true);</span>
<span class="fc" id="L252">    private static final BinaryToASCIIConverter B2AC_NOT_A_NUMBER = new ExceptionalBinaryToASCIIBuffer(NAN_REP, false);</span>
<span class="fc" id="L253">    private static final BinaryToASCIIConverter B2AC_POSITIVE_ZERO = new BinaryToASCIIBuffer(false, new char[]{'0'});</span>
<span class="fc" id="L254">    private static final BinaryToASCIIConverter B2AC_NEGATIVE_ZERO = new BinaryToASCIIBuffer(true,  new char[]{'0'});</span>

    /**
     * A buffered implementation of &lt;code&gt;BinaryToASCIIConverter&lt;/code&gt;.
     */
<span class="fc bfc" id="L259" title="All 2 branches covered.">    static class BinaryToASCIIBuffer implements BinaryToASCIIConverter {</span>
        private boolean isNegative;
        private int decExponent;
        private int firstDigitIndex;
        private int nDigits;
        private final char[] digits;
<span class="fc" id="L265">        private final char[] buffer = new char[26];</span>

        //
        // The fields below provide additional information about the result of
        // the binary to decimal digits conversion done in dtoa() and roundup()
        // methods. They are changed if needed by those two methods.
        //

        // True if the dtoa() binary to decimal conversion was exact.
<span class="fc" id="L274">        private boolean exactDecimalConversion = false;</span>

        // True if the result of the binary to decimal conversion was rounded-up
        // at the end of the conversion process, i.e. roundUp() method was called.
<span class="fc" id="L278">        private boolean decimalDigitsRoundedUp = false;</span>

        /**
         * Default constructor; used for non-zero values,
         * &lt;code&gt;BinaryToASCIIBuffer&lt;/code&gt; may be thread-local and reused
         */
<span class="fc" id="L284">        BinaryToASCIIBuffer(){</span>
<span class="fc" id="L285">            this.digits = new char[20];</span>
<span class="fc" id="L286">        }</span>

        /**
         * Creates a specialized value (positive and negative zeros).
         */
<span class="fc" id="L291">        BinaryToASCIIBuffer(boolean isNegative, char[] digits){</span>
<span class="fc" id="L292">            this.isNegative = isNegative;</span>
<span class="fc" id="L293">            this.decExponent  = 0;</span>
<span class="fc" id="L294">            this.digits = digits;</span>
<span class="fc" id="L295">            this.firstDigitIndex = 0;</span>
<span class="fc" id="L296">            this.nDigits = digits.length;</span>
<span class="fc" id="L297">        }</span>

        @Override
        public String toJavaFormatString() {
<span class="fc" id="L301">            int len = getChars(buffer);</span>
<span class="fc" id="L302">            return new String(buffer, 0, len);</span>
        }

        @Override
        public void appendTo(Appendable buf) {
<span class="fc" id="L307">            int len = getChars(buffer);</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">            if (buf instanceof StringBuilder) {</span>
<span class="fc" id="L309">                ((StringBuilder) buf).append(buffer, 0, len);</span>
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">            } else if (buf instanceof StringBuffer) {</span>
<span class="fc" id="L311">                ((StringBuffer) buf).append(buffer, 0, len);</span>
            } else {
<span class="nc bnc" id="L313" title="All 2 branches missed.">                assert false;</span>
            }
<span class="fc" id="L315">        }</span>

        @Override
        public int getDecimalExponent() {
<span class="fc" id="L319">            return decExponent;</span>
        }

        @Override
        public int getDigits(char[] digits) {
<span class="fc" id="L324">            System.arraycopy(this.digits,firstDigitIndex,digits,0,this.nDigits);</span>
<span class="fc" id="L325">            return this.nDigits;</span>
        }

        @Override
        public boolean isNegative() {
<span class="fc" id="L330">            return isNegative;</span>
        }

        @Override
        public boolean isExceptional() {
<span class="fc" id="L335">            return false;</span>
        }

        @Override
        public boolean digitsRoundedUp() {
<span class="nc" id="L340">            return decimalDigitsRoundedUp;</span>
        }

        @Override
        public boolean decimalDigitsExact() {
<span class="nc" id="L345">            return exactDecimalConversion;</span>
        }

        private void setSign(boolean isNegative) {
<span class="fc" id="L349">            this.isNegative = isNegative;</span>
<span class="fc" id="L350">        }</span>

        /**
         * This is the easy subcase --
         * all the significant bits, after scaling, are held in lvalue.
         * negSign and decExponent tell us what processing and scaling
         * has already been done. Exceptional cases have already been
         * stripped out.
         * In particular:
         * lvalue is a finite number (not Inf, nor NaN)
         * lvalue &gt; 0L (not zero, nor negative).
         *
         * The only reason that we develop the digits here, rather than
         * calling on Long.toString() is that we can do it a little faster,
         * and besides want to treat trailing 0s specially. If Long.toString
         * changes, we should re-evaluate this strategy!
         */
        private void developLongDigits( int decExponent, long lvalue, int insignificantDigits ){
<span class="fc bfc" id="L368" title="All 2 branches covered.">            if ( insignificantDigits != 0 ){</span>
                // Discard non-significant low-order bits, while rounding,
                // up to insignificant value.
<span class="fc" id="L371">                long pow10 = FDBigInteger.LONG_5_POW[insignificantDigits] &lt;&lt; insignificantDigits; // 10^i == 5^i * 2^i;</span>
<span class="fc" id="L372">                long residue = lvalue % pow10;</span>
<span class="fc" id="L373">                lvalue /= pow10;</span>
<span class="fc" id="L374">                decExponent += insignificantDigits;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">                if ( residue &gt;= (pow10&gt;&gt;1) ){</span>
                    // round up based on the low-order bits we're discarding
<span class="fc" id="L377">                    lvalue++;</span>
                }
            }
<span class="fc" id="L380">            int  digitno = digits.length -1;</span>
            int  c;
<span class="fc bfc" id="L382" title="All 2 branches covered.">            if ( lvalue &lt;= Integer.MAX_VALUE ){</span>
<span class="pc bpc" id="L383" title="1 of 4 branches missed.">                assert lvalue &gt; 0L : lvalue; // lvalue &lt;= 0</span>
                // even easier subcase!
                // can do int arithmetic rather than long!
<span class="fc" id="L386">                int  ivalue = (int)lvalue;</span>
<span class="fc" id="L387">                c = ivalue%10;</span>
<span class="fc" id="L388">                ivalue /= 10;</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                while ( c == 0 ){</span>
<span class="fc" id="L390">                    decExponent++;</span>
<span class="fc" id="L391">                    c = ivalue%10;</span>
<span class="fc" id="L392">                    ivalue /= 10;</span>
                }
<span class="fc bfc" id="L394" title="All 2 branches covered.">                while ( ivalue != 0){</span>
<span class="fc" id="L395">                    digits[digitno--] = (char)(c+'0');</span>
<span class="fc" id="L396">                    decExponent++;</span>
<span class="fc" id="L397">                    c = ivalue%10;</span>
<span class="fc" id="L398">                    ivalue /= 10;</span>
                }
<span class="fc" id="L400">                digits[digitno] = (char)(c+'0');</span>
<span class="fc" id="L401">            } else {</span>
                // same algorithm as above (same bugs, too )
                // but using long arithmetic.
<span class="fc" id="L404">                c = (int)(lvalue%10L);</span>
<span class="fc" id="L405">                lvalue /= 10L;</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">                while ( c == 0 ){</span>
<span class="fc" id="L407">                    decExponent++;</span>
<span class="fc" id="L408">                    c = (int)(lvalue%10L);</span>
<span class="fc" id="L409">                    lvalue /= 10L;</span>
                }
<span class="fc bfc" id="L411" title="All 2 branches covered.">                while ( lvalue != 0L ){</span>
<span class="fc" id="L412">                    digits[digitno--] = (char)(c+'0');</span>
<span class="fc" id="L413">                    decExponent++;</span>
<span class="fc" id="L414">                    c = (int)(lvalue%10L);</span>
<span class="fc" id="L415">                    lvalue /= 10;</span>
                }
<span class="fc" id="L417">                digits[digitno] = (char)(c+'0');</span>
            }
<span class="fc" id="L419">            this.decExponent = decExponent+1;</span>
<span class="fc" id="L420">            this.firstDigitIndex = digitno;</span>
<span class="fc" id="L421">            this.nDigits = this.digits.length - digitno;</span>
<span class="fc" id="L422">        }</span>

        private void dtoa( int binExp, long fractBits, int nSignificantBits, boolean isCompatibleFormat)
        {
<span class="pc bpc" id="L426" title="1 of 4 branches missed.">            assert fractBits &gt; 0 ; // fractBits here can't be zero or negative</span>
<span class="pc bpc" id="L427" title="1 of 4 branches missed.">            assert (fractBits &amp; FRACT_HOB)!=0  ; // Hi-order bit should be set</span>
            // Examine number. Determine if it is an easy case,
            // which we can do pretty trivially using float/long conversion,
            // or whether we must do real work.
<span class="fc" id="L431">            final int tailZeros = Long.numberOfTrailingZeros(fractBits);</span>

            // number of significant bits of fractBits;
<span class="fc" id="L434">            final int nFractBits = EXP_SHIFT+1-tailZeros;</span>

            // reset flags to default values as dtoa() does not always set these
            // flags and a prior call to dtoa() might have set them to incorrect
            // values with respect to the current state.
<span class="fc" id="L439">            decimalDigitsRoundedUp = false;</span>
<span class="fc" id="L440">            exactDecimalConversion = false;</span>

            // number of significant bits to the right of the point.
<span class="fc" id="L443">            int nTinyBits = Math.max( 0, nFractBits - binExp - 1 );</span>
<span class="fc bfc" id="L444" title="All 4 branches covered.">            if ( binExp &lt;= MAX_SMALL_BIN_EXP &amp;&amp; binExp &gt;= MIN_SMALL_BIN_EXP ){</span>
                // Look more closely at the number to decide if,
                // with scaling by 10^nTinyBits, the result will fit in
                // a long.
<span class="fc bfc" id="L448" title="All 4 branches covered.">                if ( (nTinyBits &lt; FDBigInteger.LONG_5_POW.length) &amp;&amp; ((nFractBits + N_5_BITS[nTinyBits]) &lt; 64 ) ){</span>
                    //
                    // We can do this:
                    // take the fraction bits, which are normalized.
                    // (a) nTinyBits == 0: Shift left or right appropriately
                    //     to align the binary point at the extreme right, i.e.
                    //     where a long int point is expected to be. The integer
                    //     result is easily converted to a string.
                    // (b) nTinyBits &gt; 0: Shift right by EXP_SHIFT-nFractBits,
                    //     which effectively converts to long and scales by
                    //     2^nTinyBits. Then multiply by 5^nTinyBits to
                    //     complete the scaling. We know this won't overflow
                    //     because we just counted the number of bits necessary
                    //     in the result. The integer you get from this can
                    //     then be converted to a string pretty easily.
                    //
<span class="fc bfc" id="L464" title="All 2 branches covered.">                    if ( nTinyBits == 0 ) {</span>
                        int insignificant;
<span class="fc bfc" id="L466" title="All 2 branches covered.">                        if ( binExp &gt; nSignificantBits ){</span>
<span class="fc" id="L467">                            insignificant = insignificantDigitsForPow2(binExp-nSignificantBits-1);</span>
                        } else {
<span class="fc" id="L469">                            insignificant = 0;</span>
                        }
<span class="fc bfc" id="L471" title="All 2 branches covered.">                        if ( binExp &gt;= EXP_SHIFT ){</span>
<span class="fc" id="L472">                            fractBits &lt;&lt;= (binExp-EXP_SHIFT);</span>
                        } else {
<span class="fc" id="L474">                            fractBits &gt;&gt;&gt;= (EXP_SHIFT-binExp) ;</span>
                        }
<span class="fc" id="L476">                        developLongDigits( 0, fractBits, insignificant );</span>
<span class="fc" id="L477">                        return;</span>
                    }
                    //
                    // The following causes excess digits to be printed
                    // out in the single-float case. Our manipulation of
                    // halfULP here is apparently not correct. If we
                    // better understand how this works, perhaps we can
                    // use this special case again. But for the time being,
                    // we do not.
                    // else {
                    //     fractBits &gt;&gt;&gt;= EXP_SHIFT+1-nFractBits;
                    //     fractBits//= long5pow[ nTinyBits ];
                    //     halfULP = long5pow[ nTinyBits ] &gt;&gt; (1+nSignificantBits-nFractBits);
                    //     developLongDigits( -nTinyBits, fractBits, insignificantDigits(halfULP) );
                    //     return;
                    // }
                    //
                }
            }
            //
            // This is the hard case. We are going to compute large positive
            // integers B and S and integer decExp, s.t.
            //      d = ( B / S )// 10^decExp
            //      1 &lt;= B / S &lt; 10
            // Obvious choices are:
            //      decExp = floor( log10(d) )
            //      B      = d// 2^nTinyBits// 10^max( 0, -decExp )
            //      S      = 10^max( 0, decExp)// 2^nTinyBits
            // (noting that nTinyBits has already been forced to non-negative)
            // I am also going to compute a large positive integer
            //      M      = (1/2^nSignificantBits)// 2^nTinyBits// 10^max( 0, -decExp )
            // i.e. M is (1/2) of the ULP of d, scaled like B.
            // When we iterate through dividing B/S and picking off the
            // quotient bits, we will know when to stop when the remainder
            // is &lt;= M.
            //
            // We keep track of powers of 2 and powers of 5.
            //
<span class="fc" id="L515">            int decExp = estimateDecExp(fractBits,binExp);</span>
            int B2, B5; // powers of 2 and powers of 5, respectively, in B
            int S2, S5; // powers of 2 and powers of 5, respectively, in S
            int M2, M5; // powers of 2 and powers of 5, respectively, in M

<span class="fc" id="L520">            B5 = Math.max( 0, -decExp );</span>
<span class="fc" id="L521">            B2 = B5 + nTinyBits + binExp;</span>

<span class="fc" id="L523">            S5 = Math.max( 0, decExp );</span>
<span class="fc" id="L524">            S2 = S5 + nTinyBits;</span>

<span class="fc" id="L526">            M5 = B5;</span>
<span class="fc" id="L527">            M2 = B2 - nSignificantBits;</span>

            //
            // the long integer fractBits contains the (nFractBits) interesting
            // bits from the mantissa of d ( hidden 1 added if necessary) followed
            // by (EXP_SHIFT+1-nFractBits) zeros. In the interest of compactness,
            // I will shift out those zeros before turning fractBits into a
            // FDBigInteger. The resulting whole number will be
            //      d * 2^(nFractBits-1-binExp).
            //
<span class="fc" id="L537">            fractBits &gt;&gt;&gt;= tailZeros;</span>
<span class="fc" id="L538">            B2 -= nFractBits-1;</span>
<span class="fc" id="L539">            int common2factor = Math.min( B2, S2 );</span>
<span class="fc" id="L540">            B2 -= common2factor;</span>
<span class="fc" id="L541">            S2 -= common2factor;</span>
<span class="fc" id="L542">            M2 -= common2factor;</span>

            //
            // HACK!! For exact powers of two, the next smallest number
            // is only half as far away as we think (because the meaning of
            // ULP changes at power-of-two bounds) for this reason, we
            // hack M2. Hope this works.
            //
<span class="fc bfc" id="L550" title="All 2 branches covered.">            if ( nFractBits == 1 ) {</span>
<span class="fc" id="L551">                M2 -= 1;</span>
            }

<span class="fc bfc" id="L554" title="All 2 branches covered.">            if ( M2 &lt; 0 ){</span>
                // oops.
                // since we cannot scale M down far enough,
                // we must scale the other values up.
<span class="fc" id="L558">                B2 -= M2;</span>
<span class="fc" id="L559">                S2 -= M2;</span>
<span class="fc" id="L560">                M2 =  0;</span>
            }
            //
            // Construct, Scale, iterate.
            // Some day, we'll write a stopping test that takes
            // account of the asymmetry of the spacing of floating-point
            // numbers below perfect powers of 2
            // 26 Sept 96 is not that day.
            // So we use a symmetric test.
            //
<span class="fc" id="L570">            int ndigit = 0;</span>
            boolean low, high;
            long lowDigitDifference;
            int  q;

            //
            // Detect the special cases where all the numbers we are about
            // to compute will fit in int or long integers.
            // In these cases, we will avoid doing FDBigInteger arithmetic.
            // We use the same algorithms, except that we &quot;normalize&quot;
            // our FDBigIntegers before iterating. This is to make division easier,
            // as it makes our fist guess (quotient of high-order words)
            // more accurate!
            //
            // Some day, we'll write a stopping test that takes
            // account of the asymmetry of the spacing of floating-point
            // numbers below perfect powers of 2
            // 26 Sept 96 is not that day.
            // So we use a symmetric test.
            //
            // binary digits needed to represent B, approx.
<span class="fc bfc" id="L591" title="All 2 branches covered.">            int Bbits = nFractBits + B2 + (( B5 &lt; N_5_BITS.length )? N_5_BITS[B5] : ( B5*3 ));</span>

            // binary digits needed to represent 10*S, approx.
<span class="fc bfc" id="L594" title="All 2 branches covered.">            int tenSbits = S2+1 + (( (S5+1) &lt; N_5_BITS.length )? N_5_BITS[(S5+1)] : ( (S5+1)*3 ));</span>
<span class="fc bfc" id="L595" title="All 4 branches covered.">            if ( Bbits &lt; 64 &amp;&amp; tenSbits &lt; 64){</span>
<span class="fc bfc" id="L596" title="All 4 branches covered.">                if ( Bbits &lt; 32 &amp;&amp; tenSbits &lt; 32){</span>
                    // wa-hoo! They're all ints!
<span class="fc" id="L598">                    int b = ((int)fractBits * FDBigInteger.SMALL_5_POW[B5] ) &lt;&lt; B2;</span>
<span class="fc" id="L599">                    int s = FDBigInteger.SMALL_5_POW[S5] &lt;&lt; S2;</span>
<span class="fc" id="L600">                    int m = FDBigInteger.SMALL_5_POW[M5] &lt;&lt; M2;</span>
<span class="fc" id="L601">                    int tens = s * 10;</span>
                    //
                    // Unroll the first iteration. If our decExp estimate
                    // was too high, our first quotient will be zero. In this
                    // case, we discard it and decrement decExp.
                    //
<span class="fc" id="L607">                    ndigit = 0;</span>
<span class="fc" id="L608">                    q = b / s;</span>
<span class="fc" id="L609">                    b = 10 * ( b % s );</span>
<span class="fc" id="L610">                    m *= 10;</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">                    low  = (b &lt;  m );</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">                    high = (b+m &gt; tens );</span>
<span class="pc bpc" id="L613" title="2 of 4 branches missed.">                    assert q &lt; 10 : q; // excessively large digit</span>
<span class="pc bpc" id="L614" title="1 of 4 branches missed.">                    if ( (q == 0) &amp;&amp; ! high ){</span>
                        // oops. Usually ignore leading zero.
<span class="fc" id="L616">                        decExp--;</span>
                    } else {
<span class="fc" id="L618">                        digits[ndigit++] = (char)('0' + q);</span>
                    }
                    //
                    // HACK! Java spec sez that we always have at least
                    // one digit after the . in either F- or E-form output.
                    // Thus we will need more than one digit if we're using
                    // E-form
                    //
<span class="pc bpc" id="L626" title="3 of 6 branches missed.">                    if ( !isCompatibleFormat ||decExp &lt; -3 || decExp &gt;= 8 ){</span>
<span class="nc" id="L627">                        high = low = false;</span>
                    }
<span class="fc bfc" id="L629" title="All 4 branches covered.">                    while( ! low &amp;&amp; ! high ){</span>
<span class="fc" id="L630">                        q = b / s;</span>
<span class="fc" id="L631">                        b = 10 * ( b % s );</span>
<span class="fc" id="L632">                        m *= 10;</span>
<span class="pc bpc" id="L633" title="2 of 4 branches missed.">                        assert q &lt; 10 : q; // excessively large digit</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">                        if ( m &gt; 0L ){</span>
<span class="fc bfc" id="L635" title="All 2 branches covered.">                            low  = (b &lt;  m );</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">                            high = (b+m &gt; tens );</span>
                        } else {
                            // hack -- m might overflow!
                            // in this case, it is certainly &gt; b,
                            // which won't
                            // and b+m &gt; tens, too, since that has overflowed
                            // either!
<span class="fc" id="L643">                            low = true;</span>
<span class="fc" id="L644">                            high = true;</span>
                        }
<span class="fc" id="L646">                        digits[ndigit++] = (char)('0' + q);</span>
                    }
<span class="fc" id="L648">                    lowDigitDifference = (b&lt;&lt;1) - tens;</span>
<span class="fc bfc" id="L649" title="All 2 branches covered.">                    exactDecimalConversion  = (b == 0);</span>
<span class="fc" id="L650">                } else {</span>
                    // still good! they're all longs!
<span class="fc" id="L652">                    long b = (fractBits * FDBigInteger.LONG_5_POW[B5] ) &lt;&lt; B2;</span>
<span class="fc" id="L653">                    long s = FDBigInteger.LONG_5_POW[S5] &lt;&lt; S2;</span>
<span class="fc" id="L654">                    long m = FDBigInteger.LONG_5_POW[M5] &lt;&lt; M2;</span>
<span class="fc" id="L655">                    long tens = s * 10L;</span>
                    //
                    // Unroll the first iteration. If our decExp estimate
                    // was too high, our first quotient will be zero. In this
                    // case, we discard it and decrement decExp.
                    //
<span class="fc" id="L661">                    ndigit = 0;</span>
<span class="fc" id="L662">                    q = (int) ( b / s );</span>
<span class="fc" id="L663">                    b = 10L * ( b % s );</span>
<span class="fc" id="L664">                    m *= 10L;</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">                    low  = (b &lt;  m );</span>
<span class="fc bfc" id="L666" title="All 2 branches covered.">                    high = (b+m &gt; tens );</span>
<span class="pc bpc" id="L667" title="1 of 4 branches missed.">                    assert q &lt; 10 : q; // excessively large digit</span>
<span class="fc bfc" id="L668" title="All 4 branches covered.">                    if ( (q == 0) &amp;&amp; ! high ){</span>
                        // oops. Usually ignore leading zero.
<span class="fc" id="L670">                        decExp--;</span>
                    } else {
<span class="fc" id="L672">                        digits[ndigit++] = (char)('0' + q);</span>
                    }
                    //
                    // HACK! Java spec sez that we always have at least
                    // one digit after the . in either F- or E-form output.
                    // Thus we will need more than one digit if we're using
                    // E-form
                    //
<span class="pc bpc" id="L680" title="1 of 6 branches missed.">                    if ( !isCompatibleFormat || decExp &lt; -3 || decExp &gt;= 8 ){</span>
<span class="fc" id="L681">                        high = low = false;</span>
                    }
<span class="fc bfc" id="L683" title="All 4 branches covered.">                    while( ! low &amp;&amp; ! high ){</span>
<span class="fc" id="L684">                        q = (int) ( b / s );</span>
<span class="fc" id="L685">                        b = 10 * ( b % s );</span>
<span class="fc" id="L686">                        m *= 10;</span>
<span class="pc bpc" id="L687" title="1 of 4 branches missed.">                        assert q &lt; 10 : q;  // excessively large digit</span>
<span class="pc bpc" id="L688" title="1 of 2 branches missed.">                        if ( m &gt; 0L ){</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">                            low  = (b &lt;  m );</span>
<span class="fc bfc" id="L690" title="All 2 branches covered.">                            high = (b+m &gt; tens );</span>
                        } else {
                            // hack -- m might overflow!
                            // in this case, it is certainly &gt; b,
                            // which won't
                            // and b+m &gt; tens, too, since that has overflowed
                            // either!
<span class="nc" id="L697">                            low = true;</span>
<span class="nc" id="L698">                            high = true;</span>
                        }
<span class="fc" id="L700">                        digits[ndigit++] = (char)('0' + q);</span>
                    }
<span class="fc" id="L702">                    lowDigitDifference = (b&lt;&lt;1) - tens;</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">                    exactDecimalConversion  = (b == 0);</span>
<span class="fc" id="L704">                }</span>
            } else {
                //
                // We really must do FDBigInteger arithmetic.
                // Fist, construct our FDBigInteger initial values.
                //
<span class="fc" id="L710">                FDBigInteger Sval = FDBigInteger.valueOfPow52(S5, S2);</span>
<span class="fc" id="L711">                int shiftBias = Sval.getNormalizationBias();</span>
<span class="fc" id="L712">                Sval = Sval.leftShift(shiftBias); // normalize so that division works better</span>

<span class="fc" id="L714">                FDBigInteger Bval = FDBigInteger.valueOfMulPow52(fractBits, B5, B2 + shiftBias);</span>
<span class="fc" id="L715">                FDBigInteger Mval = FDBigInteger.valueOfPow52(M5 + 1, M2 + shiftBias + 1);</span>

<span class="fc" id="L717">                FDBigInteger tenSval = FDBigInteger.valueOfPow52(S5 + 1, S2 + shiftBias + 1); //Sval.mult( 10 );</span>
                //
                // Unroll the first iteration. If our decExp estimate
                // was too high, our first quotient will be zero. In this
                // case, we discard it and decrement decExp.
                //
<span class="fc" id="L723">                ndigit = 0;</span>
<span class="fc" id="L724">                q = Bval.quoRemIteration( Sval );</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">                low  = (Bval.cmp( Mval ) &lt; 0);</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">                high = tenSval.addAndCmp(Bval,Mval)&lt;=0;</span>

<span class="pc bpc" id="L728" title="2 of 4 branches missed.">                assert q &lt; 10 : q; // excessively large digit</span>
<span class="fc bfc" id="L729" title="All 4 branches covered.">                if ( (q == 0) &amp;&amp; ! high ){</span>
                    // oops. Usually ignore leading zero.
<span class="fc" id="L731">                    decExp--;</span>
                } else {
<span class="fc" id="L733">                    digits[ndigit++] = (char)('0' + q);</span>
                }
                //
                // HACK! Java spec sez that we always have at least
                // one digit after the . in either F- or E-form output.
                // Thus we will need more than one digit if we're using
                // E-form
                //
<span class="pc bpc" id="L741" title="3 of 6 branches missed.">                if (!isCompatibleFormat || decExp &lt; -3 || decExp &gt;= 8 ){</span>
<span class="fc" id="L742">                    high = low = false;</span>
                }
<span class="fc bfc" id="L744" title="All 4 branches covered.">                while( ! low &amp;&amp; ! high ){</span>
<span class="fc" id="L745">                    q = Bval.quoRemIteration( Sval );</span>
<span class="pc bpc" id="L746" title="2 of 4 branches missed.">                    assert q &lt; 10 : q;  // excessively large digit</span>
<span class="fc" id="L747">                    Mval = Mval.multBy10(); //Mval = Mval.mult( 10 );</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">                    low  = (Bval.cmp( Mval ) &lt; 0);</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">                    high = tenSval.addAndCmp(Bval,Mval)&lt;=0;</span>
<span class="fc" id="L750">                    digits[ndigit++] = (char)('0' + q);</span>
                }
<span class="fc bfc" id="L752" title="All 4 branches covered.">                if ( high &amp;&amp; low ){</span>
<span class="fc" id="L753">                    Bval = Bval.leftShift(1);</span>
<span class="fc" id="L754">                    lowDigitDifference = Bval.cmp(tenSval);</span>
                } else {
<span class="fc" id="L756">                    lowDigitDifference = 0L; // this here only for flow analysis!</span>
                }
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">                exactDecimalConversion  = (Bval.cmp( FDBigInteger.ZERO ) == 0);</span>
            }
<span class="fc" id="L760">            this.decExponent = decExp+1;</span>
<span class="fc" id="L761">            this.firstDigitIndex = 0;</span>
<span class="fc" id="L762">            this.nDigits = ndigit;</span>
            //
            // Last digit gets rounded based on stopping condition.
            //
<span class="fc bfc" id="L766" title="All 2 branches covered.">            if ( high ){</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">                if ( low ){</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">                    if ( lowDigitDifference == 0L ){</span>
                        // it's a tie!
                        // choose based on which digits we like.
<span class="nc bnc" id="L771" title="All 2 branches missed.">                        if ( (digits[firstDigitIndex+nDigits-1]&amp;1) != 0 ) {</span>
<span class="nc" id="L772">                            roundup();</span>
                        }
<span class="fc bfc" id="L774" title="All 2 branches covered.">                    } else if ( lowDigitDifference &gt; 0 ){</span>
<span class="fc" id="L775">                        roundup();</span>
                    }
                } else {
<span class="fc" id="L778">                    roundup();</span>
                }
            }
<span class="fc" id="L781">        }</span>

        // add one to the least significant digit.
        // in the unlikely event there is a carry out, deal with it.
        // assert that this will only happen where there
        // is only one digit, e.g. (float)1e-44 seems to do it.
        //
        private void roundup() {
<span class="fc" id="L789">            int i = (firstDigitIndex + nDigits - 1);</span>
<span class="fc" id="L790">            int q = digits[i];</span>
<span class="fc bfc" id="L791" title="All 2 branches covered.">            if (q == '9') {</span>
<span class="pc bpc" id="L792" title="1 of 4 branches missed.">                while (q == '9' &amp;&amp; i &gt; firstDigitIndex) {</span>
<span class="fc" id="L793">                    digits[i] = '0';</span>
<span class="fc" id="L794">                    q = digits[--i];</span>
                }
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">                if (q == '9') {</span>
                    // carryout! High-order 1, rest 0s, larger exp.
<span class="nc" id="L798">                    decExponent += 1;</span>
<span class="nc" id="L799">                    digits[firstDigitIndex] = '1';</span>
<span class="nc" id="L800">                    return;</span>
                }
                // else fall through.
            }
<span class="fc" id="L804">            digits[i] = (char) (q + 1);</span>
<span class="fc" id="L805">            decimalDigitsRoundedUp = true;</span>
<span class="fc" id="L806">        }</span>

        /**
         * Estimate decimal exponent. (If it is small-ish,
         * we could double-check.)
         *
         * First, scale the mantissa bits such that 1 &lt;= d2 &lt; 2.
         * We are then going to estimate
         *          log10(d2) ~=~  (d2-1.5)/1.5 + log(1.5)
         * and so we can estimate
         *      log10(d) ~=~ log10(d2) + binExp * log10(2)
         * take the floor and call it decExp.
         */
        static int estimateDecExp(long fractBits, int binExp) {
<span class="fc" id="L820">            double d2 = Double.longBitsToDouble( EXP_ONE | ( fractBits &amp; DoubleConsts.SIGNIF_BIT_MASK ) );</span>
<span class="fc" id="L821">            double d = (d2-1.5D)*0.289529654D + 0.176091259 + (double)binExp * 0.301029995663981;</span>
<span class="fc" id="L822">            long dBits = Double.doubleToRawLongBits(d);  //can't be NaN here so use raw</span>
<span class="fc" id="L823">            int exponent = (int)((dBits &amp; DoubleConsts.EXP_BIT_MASK) &gt;&gt; EXP_SHIFT) - DoubleConsts.EXP_BIAS;</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">            boolean isNegative = (dBits &amp; DoubleConsts.SIGN_BIT_MASK) != 0; // discover sign</span>
<span class="pc bpc" id="L825" title="1 of 4 branches missed.">            if(exponent&gt;=0 &amp;&amp; exponent&lt;52) { // hot path</span>
<span class="fc" id="L826">                long mask   = DoubleConsts.SIGNIF_BIT_MASK &gt;&gt; exponent;</span>
<span class="fc" id="L827">                int r = (int)(( (dBits&amp;DoubleConsts.SIGNIF_BIT_MASK) | FRACT_HOB )&gt;&gt;(EXP_SHIFT-exponent));</span>
<span class="pc bpc" id="L828" title="1 of 4 branches missed.">                return isNegative ? (((mask &amp; dBits) == 0L ) ? -r : -r-1 ) : r;</span>
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">            } else if (exponent &lt; 0) {</span>
<span class="pc bpc" id="L830" title="1 of 4 branches missed.">                return (((dBits&amp;~DoubleConsts.SIGN_BIT_MASK) == 0) ? 0 :</span>
                        ( (isNegative) ? -1 : 0) );
            } else { //if (exponent &gt;= 52)
<span class="nc" id="L833">                return (int)d;</span>
            }
        }

        private static int insignificantDigits(int insignificant) {
            int i;
<span class="nc bnc" id="L839" title="All 2 branches missed.">            for ( i = 0; insignificant &gt;= 10L; i++ ) {</span>
<span class="nc" id="L840">                insignificant /= 10L;</span>
            }
<span class="nc" id="L842">            return i;</span>
        }

        /**
         * Calculates
         * &lt;pre&gt;
         * insignificantDigitsForPow2(v) == insignificantDigits(1L&lt;&lt;v)
         * &lt;/pre&gt;
         */
        private static int insignificantDigitsForPow2(int p2) {
<span class="pc bpc" id="L852" title="1 of 4 branches missed.">            if(p2&gt;1 &amp;&amp; p2 &lt; insignificantDigitsNumber.length) {</span>
<span class="fc" id="L853">                return insignificantDigitsNumber[p2];</span>
            }
<span class="fc" id="L855">            return 0;</span>
        }

        /**
         *  If insignificant==(1L &lt;&lt; ixd)
         *  i = insignificantDigitsNumber[idx] is the same as:
         *  int i;
         *  for ( i = 0; insignificant &gt;= 10L; i++ )
         *         insignificant /= 10L;
         */
<span class="fc" id="L865">        private static int[] insignificantDigitsNumber = {</span>
            0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3,
            4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7,
            8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11,
            12, 12, 12, 12, 13, 13, 13, 14, 14, 14,
            15, 15, 15, 15, 16, 16, 16, 17, 17, 17,
            18, 18, 18, 19
        };

        // approximately ceil( log2( long5pow[i] ) )
<span class="fc" id="L875">        private static final int[] N_5_BITS = {</span>
                0,
                3,
                5,
                7,
                10,
                12,
                14,
                17,
                19,
                21,
                24,
                26,
                28,
                31,
                33,
                35,
                38,
                40,
                42,
                45,
                47,
                49,
                52,
                54,
                56,
                59,
                61,
        };

        private int getChars(char[] result) {
<span class="pc bpc" id="L906" title="1 of 4 branches missed.">            assert nDigits &lt;= 19 : nDigits; // generous bound on size of nDigits</span>
<span class="fc" id="L907">            int i = 0;</span>
<span class="fc bfc" id="L908" title="All 2 branches covered.">            if (isNegative) {</span>
<span class="fc" id="L909">                result[0] = '-';</span>
<span class="fc" id="L910">                i = 1;</span>
            }
<span class="fc bfc" id="L912" title="All 4 branches covered.">            if (decExponent &gt; 0 &amp;&amp; decExponent &lt; 8) {</span>
                // print digits.digits.
<span class="fc" id="L914">                int charLength = Math.min(nDigits, decExponent);</span>
<span class="fc" id="L915">                System.arraycopy(digits, firstDigitIndex, result, i, charLength);</span>
<span class="fc" id="L916">                i += charLength;</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">                if (charLength &lt; decExponent) {</span>
<span class="fc" id="L918">                    charLength = decExponent - charLength;</span>
<span class="fc" id="L919">                    Arrays.fill(result,i,i+charLength,'0');</span>
<span class="fc" id="L920">                    i += charLength;</span>
<span class="fc" id="L921">                    result[i++] = '.';</span>
<span class="fc" id="L922">                    result[i++] = '0';</span>
                } else {
<span class="fc" id="L924">                    result[i++] = '.';</span>
<span class="fc bfc" id="L925" title="All 2 branches covered.">                    if (charLength &lt; nDigits) {</span>
<span class="fc" id="L926">                        int t = nDigits - charLength;</span>
<span class="fc" id="L927">                        System.arraycopy(digits, firstDigitIndex+charLength, result, i, t);</span>
<span class="fc" id="L928">                        i += t;</span>
<span class="fc" id="L929">                    } else {</span>
<span class="fc" id="L930">                        result[i++] = '0';</span>
                    }
                }
<span class="fc bfc" id="L933" title="All 4 branches covered.">            } else if (decExponent &lt;= 0 &amp;&amp; decExponent &gt; -3) {</span>
<span class="fc" id="L934">                result[i++] = '0';</span>
<span class="fc" id="L935">                result[i++] = '.';</span>
<span class="fc bfc" id="L936" title="All 2 branches covered.">                if (decExponent != 0) {</span>
<span class="fc" id="L937">                    Arrays.fill(result, i, i-decExponent, '0');</span>
<span class="fc" id="L938">                    i -= decExponent;</span>
                }
<span class="fc" id="L940">                System.arraycopy(digits, firstDigitIndex, result, i, nDigits);</span>
<span class="fc" id="L941">                i += nDigits;</span>
            } else {
<span class="fc" id="L943">                result[i++] = digits[firstDigitIndex];</span>
<span class="fc" id="L944">                result[i++] = '.';</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">                if (nDigits &gt; 1) {</span>
<span class="fc" id="L946">                    System.arraycopy(digits, firstDigitIndex+1, result, i, nDigits - 1);</span>
<span class="fc" id="L947">                    i += nDigits - 1;</span>
                } else {
<span class="nc" id="L949">                    result[i++] = '0';</span>
                }
<span class="fc" id="L951">                result[i++] = 'E';</span>
                int e;
<span class="fc bfc" id="L953" title="All 2 branches covered.">                if (decExponent &lt;= 0) {</span>
<span class="fc" id="L954">                    result[i++] = '-';</span>
<span class="fc" id="L955">                    e = -decExponent + 1;</span>
                } else {
<span class="fc" id="L957">                    e = decExponent - 1;</span>
                }
                // decExponent has 1, 2, or 3, digits
<span class="fc bfc" id="L960" title="All 2 branches covered.">                if (e &lt;= 9) {</span>
<span class="fc" id="L961">                    result[i++] = (char) (e + '0');</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">                } else if (e &lt;= 99) {</span>
<span class="fc" id="L963">                    result[i++] = (char) (e / 10 + '0');</span>
<span class="fc" id="L964">                    result[i++] = (char) (e % 10 + '0');</span>
                } else {
<span class="fc" id="L966">                    result[i++] = (char) (e / 100 + '0');</span>
<span class="fc" id="L967">                    e %= 100;</span>
<span class="fc" id="L968">                    result[i++] = (char) (e / 10 + '0');</span>
<span class="fc" id="L969">                    result[i++] = (char) (e % 10 + '0');</span>
                }
            }
<span class="fc" id="L972">            return i;</span>
        }

    }

<span class="fc" id="L977">    private static final ThreadLocal&lt;BinaryToASCIIBuffer&gt; threadLocalBinaryToASCIIBuffer =</span>
<span class="fc" id="L978">            new ThreadLocal&lt;BinaryToASCIIBuffer&gt;() {</span>
                @Override
                protected BinaryToASCIIBuffer initialValue() {
<span class="fc" id="L981">                    return new BinaryToASCIIBuffer();</span>
                }
            };

    private static BinaryToASCIIBuffer getBinaryToASCIIBuffer() {
<span class="fc" id="L986">        return threadLocalBinaryToASCIIBuffer.get();</span>
    }

    /**
     * A converter which can process an ASCII &lt;code&gt;String&lt;/code&gt; representation
     * of a single or double precision floating point value into a
     * &lt;code&gt;float&lt;/code&gt; or a &lt;code&gt;double&lt;/code&gt;.
     */
    interface ASCIIToBinaryConverter {

        double doubleValue();

        float floatValue();

    }

    /**
     * A &lt;code&gt;ASCIIToBinaryConverter&lt;/code&gt; container for a &lt;code&gt;double&lt;/code&gt;.
     */
    static class PreparedASCIIToBinaryBuffer implements ASCIIToBinaryConverter {
        final private double doubleVal;
        final private float floatVal;

<span class="fc" id="L1009">        public PreparedASCIIToBinaryBuffer(double doubleVal, float floatVal) {</span>
<span class="fc" id="L1010">            this.doubleVal = doubleVal;</span>
<span class="fc" id="L1011">            this.floatVal = floatVal;</span>
<span class="fc" id="L1012">        }</span>

        @Override
        public double doubleValue() {
<span class="fc" id="L1016">            return doubleVal;</span>
        }

        @Override
        public float floatValue() {
<span class="fc" id="L1021">            return floatVal;</span>
        }
    }

<span class="fc" id="L1025">    static final ASCIIToBinaryConverter A2BC_POSITIVE_INFINITY = new PreparedASCIIToBinaryBuffer(Double.POSITIVE_INFINITY, Float.POSITIVE_INFINITY);</span>
<span class="fc" id="L1026">    static final ASCIIToBinaryConverter A2BC_NEGATIVE_INFINITY = new PreparedASCIIToBinaryBuffer(Double.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);</span>
<span class="fc" id="L1027">    static final ASCIIToBinaryConverter A2BC_NOT_A_NUMBER  = new PreparedASCIIToBinaryBuffer(Double.NaN, Float.NaN);</span>
<span class="fc" id="L1028">    static final ASCIIToBinaryConverter A2BC_POSITIVE_ZERO = new PreparedASCIIToBinaryBuffer(0.0d, 0.0f);</span>
<span class="fc" id="L1029">    static final ASCIIToBinaryConverter A2BC_NEGATIVE_ZERO = new PreparedASCIIToBinaryBuffer(-0.0d, -0.0f);</span>

    /**
     * A buffered implementation of &lt;code&gt;ASCIIToBinaryConverter&lt;/code&gt;.
     */
<span class="fc bfc" id="L1034" title="All 2 branches covered.">    static class ASCIIToBinaryBuffer implements ASCIIToBinaryConverter {</span>
        boolean     isNegative;
        int         decExponent;
        char        digits[];
        int         nDigits;

        ASCIIToBinaryBuffer( boolean negSign, int decExponent, char[] digits, int n)
<span class="fc" id="L1041">        {</span>
<span class="fc" id="L1042">            this.isNegative = negSign;</span>
<span class="fc" id="L1043">            this.decExponent = decExponent;</span>
<span class="fc" id="L1044">            this.digits = digits;</span>
<span class="fc" id="L1045">            this.nDigits = n;</span>
<span class="fc" id="L1046">        }</span>

        /**
         * Takes a FloatingDecimal, which we presumably just scanned in,
         * and finds out what its value is, as a double.
         *
         * AS A SIDE EFFECT, SET roundDir TO INDICATE PREFERRED
         * ROUNDING DIRECTION in case the result is really destined
         * for a single-precision float.
         */
        @Override
        public double doubleValue() {
<span class="fc" id="L1058">            int kDigits = Math.min(nDigits, MAX_DECIMAL_DIGITS + 1);</span>
            //
            // convert the lead kDigits to a long integer.
            //
            // (special performance hack: start to do it using int)
<span class="fc" id="L1063">            int iValue = (int) digits[0] - (int) '0';</span>
<span class="fc" id="L1064">            int iDigits = Math.min(kDigits, INT_DECIMAL_DIGITS);</span>
<span class="fc bfc" id="L1065" title="All 2 branches covered.">            for (int i = 1; i &lt; iDigits; i++) {</span>
<span class="fc" id="L1066">                iValue = iValue * 10 + (int) digits[i] - (int) '0';</span>
            }
<span class="fc" id="L1068">            long lValue = (long) iValue;</span>
<span class="fc bfc" id="L1069" title="All 2 branches covered.">            for (int i = iDigits; i &lt; kDigits; i++) {</span>
<span class="fc" id="L1070">                lValue = lValue * 10L + (long) ((int) digits[i] - (int) '0');</span>
            }
<span class="fc" id="L1072">            double dValue = (double) lValue;</span>
<span class="fc" id="L1073">            int exp = decExponent - kDigits;</span>
            //
            // lValue now contains a long integer with the value of
            // the first kDigits digits of the number.
            // dValue contains the (double) of the same.
            //

<span class="fc bfc" id="L1080" title="All 2 branches covered.">            if (nDigits &lt;= MAX_DECIMAL_DIGITS) {</span>
                //
                // possibly an easy case.
                // We know that the digits can be represented
                // exactly. And if the exponent isn't too outrageous,
                // the whole thing can be done with one operation,
                // thus one rounding error.
                // Note that all our constructors trim all leading and
                // trailing zeros, so simple values (including zero)
                // will always end up here
                //
<span class="pc bpc" id="L1091" title="1 of 4 branches missed.">                if (exp == 0 || dValue == 0.0) {</span>
<span class="fc bfc" id="L1092" title="All 2 branches covered.">                    return (isNegative) ? -dValue : dValue; // small floating integer</span>
                }
<span class="fc bfc" id="L1094" title="All 2 branches covered.">                else if (exp &gt;= 0) {</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">                    if (exp &lt;= MAX_SMALL_TEN) {</span>
                        //
                        // Can get the answer with one operation,
                        // thus one roundoff.
                        //
<span class="fc" id="L1100">                        double rValue = dValue * SMALL_10_POW[exp];</span>
<span class="fc bfc" id="L1101" title="All 2 branches covered.">                        return (isNegative) ? -rValue : rValue;</span>
                    }
<span class="fc" id="L1103">                    int slop = MAX_DECIMAL_DIGITS - kDigits;</span>
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">                    if (exp &lt;= MAX_SMALL_TEN + slop) {</span>
                        //
                        // We can multiply dValue by 10^(slop)
                        // and it is still &quot;small&quot; and exact.
                        // Then we can multiply by 10^(exp-slop)
                        // with one rounding.
                        //
<span class="nc" id="L1111">                        dValue *= SMALL_10_POW[slop];</span>
<span class="nc" id="L1112">                        double rValue = dValue * SMALL_10_POW[exp - slop];</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">                        return (isNegative) ? -rValue : rValue;</span>
                    }
                    //
                    // Else we have a hard case with a positive exp.
                    //
<span class="fc" id="L1118">                } else {</span>
<span class="fc bfc" id="L1119" title="All 2 branches covered.">                    if (exp &gt;= -MAX_SMALL_TEN) {</span>
                        //
                        // Can get the answer in one division.
                        //
<span class="fc" id="L1123">                        double rValue = dValue / SMALL_10_POW[-exp];</span>
<span class="fc bfc" id="L1124" title="All 2 branches covered.">                        return (isNegative) ? -rValue : rValue;</span>
                    }
                    //
                    // Else we have a hard case with a negative exp.
                    //
                }
            }

            //
            // Harder cases:
            // The sum of digits plus exponent is greater than
            // what we think we can do with one error.
            //
            // Start by approximating the right answer by,
            // naively, scaling by powers of 10.
            //
<span class="fc bfc" id="L1140" title="All 2 branches covered.">            if (exp &gt; 0) {</span>
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">                if (decExponent &gt; MAX_DECIMAL_EXPONENT + 1) {</span>
                    //
                    // Lets face it. This is going to be
                    // Infinity. Cut to the chase.
                    //
<span class="nc bnc" id="L1146" title="All 2 branches missed.">                    return (isNegative) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;</span>
                }
<span class="fc bfc" id="L1148" title="All 2 branches covered.">                if ((exp &amp; 15) != 0) {</span>
<span class="fc" id="L1149">                    dValue *= SMALL_10_POW[exp &amp; 15];</span>
                }
<span class="fc bfc" id="L1151" title="All 2 branches covered.">                if ((exp &gt;&gt;= 4) != 0) {</span>
                    int j;
<span class="fc bfc" id="L1153" title="All 2 branches covered.">                    for (j = 0; exp &gt; 1; j++, exp &gt;&gt;= 1) {</span>
<span class="fc bfc" id="L1154" title="All 2 branches covered.">                        if ((exp &amp; 1) != 0) {</span>
<span class="fc" id="L1155">                            dValue *= BIG_10_POW[j];</span>
                        }
                    }
                    //
                    // The reason for the weird exp &gt; 1 condition
                    // in the above loop was so that the last multiply
                    // would get unrolled. We handle it here.
                    // It could overflow.
                    //
<span class="fc" id="L1164">                    double t = dValue * BIG_10_POW[j];</span>
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">                    if (Double.isInfinite(t)) {</span>
                        //
                        // It did overflow.
                        // Look more closely at the result.
                        // If the exponent is just one too large,
                        // then use the maximum finite as our estimate
                        // value. Else call the result infinity
                        // and punt it.
                        // ( I presume this could happen because
                        // rounding forces the result here to be
                        // an ULP or two larger than
                        // Double.MAX_VALUE ).
                        //
<span class="nc" id="L1178">                        t = dValue / 2.0;</span>
<span class="nc" id="L1179">                        t *= BIG_10_POW[j];</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">                        if (Double.isInfinite(t)) {</span>
<span class="nc bnc" id="L1181" title="All 2 branches missed.">                            return (isNegative) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;</span>
                        }
<span class="nc" id="L1183">                        t = Double.MAX_VALUE;</span>
                    }
<span class="fc" id="L1185">                    dValue = t;</span>
<span class="fc" id="L1186">                }</span>
<span class="fc bfc" id="L1187" title="All 2 branches covered.">            } else if (exp &lt; 0) {</span>
<span class="fc" id="L1188">                exp = -exp;</span>
<span class="pc bpc" id="L1189" title="1 of 2 branches missed.">                if (decExponent &lt; MIN_DECIMAL_EXPONENT - 1) {</span>
                    //
                    // Lets face it. This is going to be
                    // zero. Cut to the chase.
                    //
<span class="nc bnc" id="L1194" title="All 2 branches missed.">                    return (isNegative) ? -0.0 : 0.0;</span>
                }
<span class="fc bfc" id="L1196" title="All 2 branches covered.">                if ((exp &amp; 15) != 0) {</span>
<span class="fc" id="L1197">                    dValue /= SMALL_10_POW[exp &amp; 15];</span>
                }
<span class="fc bfc" id="L1199" title="All 2 branches covered.">                if ((exp &gt;&gt;= 4) != 0) {</span>
                    int j;
<span class="fc bfc" id="L1201" title="All 2 branches covered.">                    for (j = 0; exp &gt; 1; j++, exp &gt;&gt;= 1) {</span>
<span class="fc bfc" id="L1202" title="All 2 branches covered.">                        if ((exp &amp; 1) != 0) {</span>
<span class="fc" id="L1203">                            dValue *= TINY_10_POW[j];</span>
                        }
                    }
                    //
                    // The reason for the weird exp &gt; 1 condition
                    // in the above loop was so that the last multiply
                    // would get unrolled. We handle it here.
                    // It could underflow.
                    //
<span class="fc" id="L1212">                    double t = dValue * TINY_10_POW[j];</span>
<span class="fc bfc" id="L1213" title="All 2 branches covered.">                    if (t == 0.0) {</span>
                        //
                        // It did underflow.
                        // Look more closely at the result.
                        // If the exponent is just one too small,
                        // then use the minimum finite as our estimate
                        // value. Else call the result 0.0
                        // and punt it.
                        // ( I presume this could happen because
                        // rounding forces the result here to be
                        // an ULP or two less than
                        // Double.MIN_VALUE ).
                        //
<span class="fc" id="L1226">                        t = dValue * 2.0;</span>
<span class="fc" id="L1227">                        t *= TINY_10_POW[j];</span>
<span class="pc bpc" id="L1228" title="1 of 2 branches missed.">                        if (t == 0.0) {</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">                            return (isNegative) ? -0.0 : 0.0;</span>
                        }
<span class="fc" id="L1231">                        t = Double.MIN_VALUE;</span>
                    }
<span class="fc" id="L1233">                    dValue = t;</span>
                }
            }

            //
            // dValue is now approximately the result.
            // The hard part is adjusting it, by comparison
            // with FDBigInteger arithmetic.
            // Formulate the EXACT big-number result as
            // bigD0 * 10^exp
            //
<span class="pc bpc" id="L1244" title="1 of 2 branches missed.">            if (nDigits &gt; MAX_NDIGITS) {</span>
<span class="nc" id="L1245">                nDigits = MAX_NDIGITS + 1;</span>
<span class="nc" id="L1246">                digits[MAX_NDIGITS] = '1';</span>
            }
<span class="fc" id="L1248">            FDBigInteger bigD0 = new FDBigInteger(lValue, digits, kDigits, nDigits);</span>
<span class="fc" id="L1249">            exp = decExponent - nDigits;</span>

<span class="fc" id="L1251">            long ieeeBits = Double.doubleToRawLongBits(dValue); // IEEE-754 bits of double candidate</span>
<span class="fc" id="L1252">            final int B5 = Math.max(0, -exp); // powers of 5 in bigB, value is not modified inside correctionLoop</span>
<span class="fc" id="L1253">            final int D5 = Math.max(0, exp); // powers of 5 in bigD, value is not modified inside correctionLoop</span>
<span class="fc" id="L1254">            bigD0 = bigD0.multByPow52(D5, 0);</span>
<span class="fc" id="L1255">            bigD0.makeImmutable();   // prevent bigD0 modification inside correctionLoop</span>
<span class="fc" id="L1256">            FDBigInteger bigD = null;</span>
<span class="fc" id="L1257">            int prevD2 = 0;</span>

            correctionLoop:
            while (true) {
                // here ieeeBits can't be NaN, Infinity or zero
<span class="fc" id="L1262">                int binexp = (int) (ieeeBits &gt;&gt;&gt; EXP_SHIFT);</span>
<span class="fc" id="L1263">                long bigBbits = ieeeBits &amp; DoubleConsts.SIGNIF_BIT_MASK;</span>
<span class="fc bfc" id="L1264" title="All 2 branches covered.">                if (binexp &gt; 0) {</span>
<span class="fc" id="L1265">                    bigBbits |= FRACT_HOB;</span>
                } else { // Normalize denormalized numbers.
<span class="pc bpc" id="L1267" title="2 of 4 branches missed.">                    assert bigBbits != 0L : bigBbits; // doubleToBigInt(0.0)</span>
<span class="fc" id="L1268">                    int leadingZeros = Long.numberOfLeadingZeros(bigBbits);</span>
<span class="fc" id="L1269">                    int shift = leadingZeros - (63 - EXP_SHIFT);</span>
<span class="fc" id="L1270">                    bigBbits &lt;&lt;= shift;</span>
<span class="fc" id="L1271">                    binexp = 1 - shift;</span>
                }
<span class="fc" id="L1273">                binexp -= DoubleConsts.EXP_BIAS;</span>
<span class="fc" id="L1274">                int lowOrderZeros = Long.numberOfTrailingZeros(bigBbits);</span>
<span class="fc" id="L1275">                bigBbits &gt;&gt;&gt;= lowOrderZeros;</span>
<span class="fc" id="L1276">                final int bigIntExp = binexp - EXP_SHIFT + lowOrderZeros;</span>
<span class="fc" id="L1277">                final int bigIntNBits = EXP_SHIFT + 1 - lowOrderZeros;</span>

                //
                // Scale bigD, bigB appropriately for
                // big-integer operations.
                // Naively, we multiply by powers of ten
                // and powers of two. What we actually do
                // is keep track of the powers of 5 and
                // powers of 2 we would use, then factor out
                // common divisors before doing the work.
                //
<span class="fc" id="L1288">                int B2 = B5; // powers of 2 in bigB</span>
<span class="fc" id="L1289">                int D2 = D5; // powers of 2 in bigD</span>
                int Ulp2;   // powers of 2 in halfUlp.
<span class="fc bfc" id="L1291" title="All 2 branches covered.">                if (bigIntExp &gt;= 0) {</span>
<span class="fc" id="L1292">                    B2 += bigIntExp;</span>
                } else {
<span class="fc" id="L1294">                    D2 -= bigIntExp;</span>
                }
<span class="fc" id="L1296">                Ulp2 = B2;</span>
                // shift bigB and bigD left by a number s. t.
                // halfUlp is still an integer.
                int hulpbias;
<span class="fc bfc" id="L1300" title="All 2 branches covered.">                if (binexp &lt;= -DoubleConsts.EXP_BIAS) {</span>
                    // This is going to be a denormalized number
                    // (if not actually zero).
                    // half an ULP is at 2^-(DoubleConsts.EXP_BIAS+EXP_SHIFT+1)
<span class="fc" id="L1304">                    hulpbias = binexp + lowOrderZeros + DoubleConsts.EXP_BIAS;</span>
                } else {
<span class="fc" id="L1306">                    hulpbias = 1 + lowOrderZeros;</span>
                }
<span class="fc" id="L1308">                B2 += hulpbias;</span>
<span class="fc" id="L1309">                D2 += hulpbias;</span>
                // if there are common factors of 2, we might just as well
                // factor them out, as they add nothing useful.
<span class="fc" id="L1312">                int common2 = Math.min(B2, Math.min(D2, Ulp2));</span>
<span class="fc" id="L1313">                B2 -= common2;</span>
<span class="fc" id="L1314">                D2 -= common2;</span>
<span class="fc" id="L1315">                Ulp2 -= common2;</span>
                // do multiplications by powers of 5 and 2
<span class="fc" id="L1317">                FDBigInteger bigB = FDBigInteger.valueOfMulPow52(bigBbits, B5, B2);</span>
<span class="fc bfc" id="L1318" title="All 4 branches covered.">                if (bigD == null || prevD2 != D2) {</span>
<span class="fc" id="L1319">                    bigD = bigD0.leftShift(D2);</span>
<span class="fc" id="L1320">                    prevD2 = D2;</span>
                }
                //
                // to recap:
                // bigB is the scaled-big-int version of our floating-point
                // candidate.
                // bigD is the scaled-big-int version of the exact value
                // as we understand it.
                // halfUlp is 1/2 an ulp of bigB, except for special cases
                // of exact powers of 2
                //
                // the plan is to compare bigB with bigD, and if the difference
                // is less than halfUlp, then we're satisfied. Otherwise,
                // use the ratio of difference to halfUlp to calculate a fudge
                // factor to add to the floating value, then go 'round again.
                //
                FDBigInteger diff;
                int cmpResult;
                boolean overvalue;
<span class="fc bfc" id="L1339" title="All 2 branches covered.">                if ((cmpResult = bigB.cmp(bigD)) &gt; 0) {</span>
<span class="fc" id="L1340">                    overvalue = true; // our candidate is too big.</span>
<span class="fc" id="L1341">                    diff = bigB.leftInplaceSub(bigD); // bigB is not user further - reuse</span>
<span class="fc bfc" id="L1342" title="All 4 branches covered.">                    if ((bigIntNBits == 1) &amp;&amp; (bigIntExp &gt; -DoubleConsts.EXP_BIAS + 1)) {</span>
                        // candidate is a normalized exact power of 2 and
                        // is too big (larger than Double.MIN_NORMAL). We will be subtracting.
                        // For our purposes, ulp is the ulp of the
                        // next smaller range.
<span class="fc" id="L1347">                        Ulp2 -= 1;</span>
<span class="pc bpc" id="L1348" title="1 of 2 branches missed.">                        if (Ulp2 &lt; 0) {</span>
                            // rats. Cannot de-scale ulp this far.
                            // must scale diff in other direction.
<span class="nc" id="L1351">                            Ulp2 = 0;</span>
<span class="nc" id="L1352">                            diff = diff.leftShift(1);</span>
                        }
                    }
<span class="fc bfc" id="L1355" title="All 2 branches covered.">                } else if (cmpResult &lt; 0) {</span>
<span class="fc" id="L1356">                    overvalue = false; // our candidate is too small.</span>
<span class="fc" id="L1357">                    diff = bigD.rightInplaceSub(bigB); // bigB is not user further - reuse</span>
                } else {
                    // the candidate is exactly right!
                    // this happens with surprising frequency
                    break correctionLoop;
                }
<span class="fc" id="L1363">                cmpResult = diff.cmpPow52(B5, Ulp2);</span>
<span class="fc bfc" id="L1364" title="All 2 branches covered.">                if ((cmpResult) &lt; 0) {</span>
                    // difference is small.
                    // this is close enough
<span class="fc" id="L1367">                    break correctionLoop;</span>
<span class="fc bfc" id="L1368" title="All 2 branches covered.">                } else if (cmpResult == 0) {</span>
                    // difference is exactly half an ULP
                    // round to some other value maybe, then finish
<span class="fc bfc" id="L1371" title="All 2 branches covered.">                    if ((ieeeBits &amp; 1) != 0) { // half ties to even</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">                        ieeeBits += overvalue ? -1 : 1; // nextDown or nextUp</span>
                    }
                    break correctionLoop;
                } else {
                    // difference is non-trivial.
                    // could scale addend by ratio of difference to
                    // halfUlp here, if we bothered to compute that difference.
                    // Most of the time ( I hope ) it is about 1 anyway.
<span class="fc bfc" id="L1380" title="All 2 branches covered.">                    ieeeBits += overvalue ? -1 : 1; // nextDown or nextUp</span>
<span class="pc bpc" id="L1381" title="2 of 4 branches missed.">                    if (ieeeBits == 0 || ieeeBits == DoubleConsts.EXP_BIT_MASK) { // 0.0 or Double.POSITIVE_INFINITY</span>
<span class="nc" id="L1382">                        break correctionLoop; // oops. Fell off end of range.</span>
                    }
                    continue; // try again.
                }

            }
<span class="fc bfc" id="L1388" title="All 2 branches covered.">            if (isNegative) {</span>
<span class="fc" id="L1389">                ieeeBits |= DoubleConsts.SIGN_BIT_MASK;</span>
            }
<span class="fc" id="L1391">            return Double.longBitsToDouble(ieeeBits);</span>
        }

        /**
         * Takes a FloatingDecimal, which we presumably just scanned in,
         * and finds out what its value is, as a float.
         * This is distinct from doubleValue() to avoid the extremely
         * unlikely case of a double rounding error, wherein the conversion
         * to double has one rounding error, and the conversion of that double
         * to a float has another rounding error, IN THE WRONG DIRECTION,
         * ( because of the preference to a zero low-order bit ).
         */
        @Override
        public float floatValue() {
<span class="fc" id="L1405">            int kDigits = Math.min(nDigits, SINGLE_MAX_DECIMAL_DIGITS + 1);</span>
            //
            // convert the lead kDigits to an integer.
            //
<span class="fc" id="L1409">            int iValue = (int) digits[0] - (int) '0';</span>
<span class="fc bfc" id="L1410" title="All 2 branches covered.">            for (int i = 1; i &lt; kDigits; i++) {</span>
<span class="fc" id="L1411">                iValue = iValue * 10 + (int) digits[i] - (int) '0';</span>
            }
<span class="fc" id="L1413">            float fValue = (float) iValue;</span>
<span class="fc" id="L1414">            int exp = decExponent - kDigits;</span>
            //
            // iValue now contains an integer with the value of
            // the first kDigits digits of the number.
            // fValue contains the (float) of the same.
            //

<span class="fc bfc" id="L1421" title="All 2 branches covered.">            if (nDigits &lt;= SINGLE_MAX_DECIMAL_DIGITS) {</span>
                //
                // possibly an easy case.
                // We know that the digits can be represented
                // exactly. And if the exponent isn't too outrageous,
                // the whole thing can be done with one operation,
                // thus one rounding error.
                // Note that all our constructors trim all leading and
                // trailing zeros, so simple values (including zero)
                // will always end up here.
                //
<span class="pc bpc" id="L1432" title="1 of 4 branches missed.">                if (exp == 0 || fValue == 0.0f) {</span>
<span class="pc bpc" id="L1433" title="1 of 2 branches missed.">                    return (isNegative) ? -fValue : fValue; // small floating integer</span>
<span class="fc bfc" id="L1434" title="All 2 branches covered.">                } else if (exp &gt;= 0) {</span>
<span class="pc bpc" id="L1435" title="1 of 2 branches missed.">                    if (exp &lt;= SINGLE_MAX_SMALL_TEN) {</span>
                        //
                        // Can get the answer with one operation,
                        // thus one roundoff.
                        //
<span class="fc" id="L1440">                        fValue *= SINGLE_SMALL_10_POW[exp];</span>
<span class="pc bpc" id="L1441" title="1 of 2 branches missed.">                        return (isNegative) ? -fValue : fValue;</span>
                    }
<span class="nc" id="L1443">                    int slop = SINGLE_MAX_DECIMAL_DIGITS - kDigits;</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">                    if (exp &lt;= SINGLE_MAX_SMALL_TEN + slop) {</span>
                        //
                        // We can multiply fValue by 10^(slop)
                        // and it is still &quot;small&quot; and exact.
                        // Then we can multiply by 10^(exp-slop)
                        // with one rounding.
                        //
<span class="nc" id="L1451">                        fValue *= SINGLE_SMALL_10_POW[slop];</span>
<span class="nc" id="L1452">                        fValue *= SINGLE_SMALL_10_POW[exp - slop];</span>
<span class="nc bnc" id="L1453" title="All 2 branches missed.">                        return (isNegative) ? -fValue : fValue;</span>
                    }
                    //
                    // Else we have a hard case with a positive exp.
                    //
<span class="nc" id="L1458">                } else {</span>
<span class="pc bpc" id="L1459" title="1 of 2 branches missed.">                    if (exp &gt;= -SINGLE_MAX_SMALL_TEN) {</span>
                        //
                        // Can get the answer in one division.
                        //
<span class="fc" id="L1463">                        fValue /= SINGLE_SMALL_10_POW[-exp];</span>
<span class="pc bpc" id="L1464" title="1 of 2 branches missed.">                        return (isNegative) ? -fValue : fValue;</span>
                    }
                    //
                    // Else we have a hard case with a negative exp.
                    //
                }
<span class="pc bpc" id="L1470" title="1 of 4 branches missed.">            } else if ((decExponent &gt;= nDigits) &amp;&amp; (nDigits + decExponent &lt;= MAX_DECIMAL_DIGITS)) {</span>
                //
                // In double-precision, this is an exact floating integer.
                // So we can compute to double, then shorten to float
                // with one round, and get the right answer.
                //
                // First, finish accumulating digits.
                // Then convert that integer to a double, multiply
                // by the appropriate power of ten, and convert to float.
                //
<span class="nc" id="L1480">                long lValue = (long) iValue;</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">                for (int i = kDigits; i &lt; nDigits; i++) {</span>
<span class="nc" id="L1482">                    lValue = lValue * 10L + (long) ((int) digits[i] - (int) '0');</span>
                }
<span class="nc" id="L1484">                double dValue = (double) lValue;</span>
<span class="nc" id="L1485">                exp = decExponent - nDigits;</span>
<span class="nc" id="L1486">                dValue *= SMALL_10_POW[exp];</span>
<span class="nc" id="L1487">                fValue = (float) dValue;</span>
<span class="nc bnc" id="L1488" title="All 2 branches missed.">                return (isNegative) ? -fValue : fValue;</span>

            }
            //
            // Harder cases:
            // The sum of digits plus exponent is greater than
            // what we think we can do with one error.
            //
            // Start by approximating the right answer by,
            // naively, scaling by powers of 10.
            // Scaling uses doubles to avoid overflow/underflow.
            //
<span class="fc" id="L1500">            double dValue = fValue;</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">            if (exp &gt; 0) {</span>
<span class="pc bpc" id="L1502" title="1 of 2 branches missed.">                if (decExponent &gt; SINGLE_MAX_DECIMAL_EXPONENT + 1) {</span>
                    //
                    // Lets face it. This is going to be
                    // Infinity. Cut to the chase.
                    //
<span class="nc bnc" id="L1507" title="All 2 branches missed.">                    return (isNegative) ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;</span>
                }
<span class="pc bpc" id="L1509" title="1 of 2 branches missed.">                if ((exp &amp; 15) != 0) {</span>
<span class="fc" id="L1510">                    dValue *= SMALL_10_POW[exp &amp; 15];</span>
                }
<span class="fc bfc" id="L1512" title="All 2 branches covered.">                if ((exp &gt;&gt;= 4) != 0) {</span>
                    int j;
<span class="fc bfc" id="L1514" title="All 2 branches covered.">                    for (j = 0; exp &gt; 0; j++, exp &gt;&gt;= 1) {</span>
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">                        if ((exp &amp; 1) != 0) {</span>
<span class="fc" id="L1516">                            dValue *= BIG_10_POW[j];</span>
                        }
                    }
<span class="fc" id="L1519">                }</span>
<span class="pc bpc" id="L1520" title="1 of 2 branches missed.">            } else if (exp &lt; 0) {</span>
<span class="fc" id="L1521">                exp = -exp;</span>
<span class="pc bpc" id="L1522" title="1 of 2 branches missed.">                if (decExponent &lt; SINGLE_MIN_DECIMAL_EXPONENT - 1) {</span>
                    //
                    // Lets face it. This is going to be
                    // zero. Cut to the chase.
                    //
<span class="nc bnc" id="L1527" title="All 2 branches missed.">                    return (isNegative) ? -0.0f : 0.0f;</span>
                }
<span class="pc bpc" id="L1529" title="1 of 2 branches missed.">                if ((exp &amp; 15) != 0) {</span>
<span class="fc" id="L1530">                    dValue /= SMALL_10_POW[exp &amp; 15];</span>
                }
<span class="pc bpc" id="L1532" title="1 of 2 branches missed.">                if ((exp &gt;&gt;= 4) != 0) {</span>
                    int j;
<span class="nc bnc" id="L1534" title="All 2 branches missed.">                    for (j = 0; exp &gt; 0; j++, exp &gt;&gt;= 1) {</span>
<span class="nc bnc" id="L1535" title="All 2 branches missed.">                        if ((exp &amp; 1) != 0) {</span>
<span class="nc" id="L1536">                            dValue *= TINY_10_POW[j];</span>
                        }
                    }
                }
            }
<span class="fc" id="L1541">            fValue = Math.max(Float.MIN_VALUE, Math.min(Float.MAX_VALUE, (float) dValue));</span>

            //
            // fValue is now approximately the result.
            // The hard part is adjusting it, by comparison
            // with FDBigInteger arithmetic.
            // Formulate the EXACT big-number result as
            // bigD0 * 10^exp
            //
<span class="pc bpc" id="L1550" title="1 of 2 branches missed.">            if (nDigits &gt; SINGLE_MAX_NDIGITS) {</span>
<span class="nc" id="L1551">                nDigits = SINGLE_MAX_NDIGITS + 1;</span>
<span class="nc" id="L1552">                digits[SINGLE_MAX_NDIGITS] = '1';</span>
            }
<span class="fc" id="L1554">            FDBigInteger bigD0 = new FDBigInteger(iValue, digits, kDigits, nDigits);</span>
<span class="fc" id="L1555">            exp = decExponent - nDigits;</span>

<span class="fc" id="L1557">            int ieeeBits = Float.floatToRawIntBits(fValue); // IEEE-754 bits of float candidate</span>
<span class="fc" id="L1558">            final int B5 = Math.max(0, -exp); // powers of 5 in bigB, value is not modified inside correctionLoop</span>
<span class="fc" id="L1559">            final int D5 = Math.max(0, exp); // powers of 5 in bigD, value is not modified inside correctionLoop</span>
<span class="fc" id="L1560">            bigD0 = bigD0.multByPow52(D5, 0);</span>
<span class="fc" id="L1561">            bigD0.makeImmutable();   // prevent bigD0 modification inside correctionLoop</span>
<span class="fc" id="L1562">            FDBigInteger bigD = null;</span>
<span class="fc" id="L1563">            int prevD2 = 0;</span>

            correctionLoop:
            while (true) {
                // here ieeeBits can't be NaN, Infinity or zero
<span class="fc" id="L1568">                int binexp = ieeeBits &gt;&gt;&gt; SINGLE_EXP_SHIFT;</span>
<span class="fc" id="L1569">                int bigBbits = ieeeBits &amp; FloatConsts.SIGNIF_BIT_MASK;</span>
<span class="pc bpc" id="L1570" title="1 of 2 branches missed.">                if (binexp &gt; 0) {</span>
<span class="fc" id="L1571">                    bigBbits |= SINGLE_FRACT_HOB;</span>
                } else { // Normalize denormalized numbers.
<span class="nc bnc" id="L1573" title="All 4 branches missed.">                    assert bigBbits != 0 : bigBbits; // floatToBigInt(0.0)</span>
<span class="nc" id="L1574">                    int leadingZeros = Integer.numberOfLeadingZeros(bigBbits);</span>
<span class="nc" id="L1575">                    int shift = leadingZeros - (31 - SINGLE_EXP_SHIFT);</span>
<span class="nc" id="L1576">                    bigBbits &lt;&lt;= shift;</span>
<span class="nc" id="L1577">                    binexp = 1 - shift;</span>
                }
<span class="fc" id="L1579">                binexp -= FloatConsts.EXP_BIAS;</span>
<span class="fc" id="L1580">                int lowOrderZeros = Integer.numberOfTrailingZeros(bigBbits);</span>
<span class="fc" id="L1581">                bigBbits &gt;&gt;&gt;= lowOrderZeros;</span>
<span class="fc" id="L1582">                final int bigIntExp = binexp - SINGLE_EXP_SHIFT + lowOrderZeros;</span>
<span class="fc" id="L1583">                final int bigIntNBits = SINGLE_EXP_SHIFT + 1 - lowOrderZeros;</span>

                //
                // Scale bigD, bigB appropriately for
                // big-integer operations.
                // Naively, we multiply by powers of ten
                // and powers of two. What we actually do
                // is keep track of the powers of 5 and
                // powers of 2 we would use, then factor out
                // common divisors before doing the work.
                //
<span class="fc" id="L1594">                int B2 = B5; // powers of 2 in bigB</span>
<span class="fc" id="L1595">                int D2 = D5; // powers of 2 in bigD</span>
                int Ulp2;   // powers of 2 in halfUlp.
<span class="fc bfc" id="L1597" title="All 2 branches covered.">                if (bigIntExp &gt;= 0) {</span>
<span class="fc" id="L1598">                    B2 += bigIntExp;</span>
                } else {
<span class="fc" id="L1600">                    D2 -= bigIntExp;</span>
                }
<span class="fc" id="L1602">                Ulp2 = B2;</span>
                // shift bigB and bigD left by a number s. t.
                // halfUlp is still an integer.
                int hulpbias;
<span class="pc bpc" id="L1606" title="1 of 2 branches missed.">                if (binexp &lt;= -FloatConsts.EXP_BIAS) {</span>
                    // This is going to be a denormalized number
                    // (if not actually zero).
                    // half an ULP is at 2^-(FloatConsts.EXP_BIAS+SINGLE_EXP_SHIFT+1)
<span class="nc" id="L1610">                    hulpbias = binexp + lowOrderZeros + FloatConsts.EXP_BIAS;</span>
                } else {
<span class="fc" id="L1612">                    hulpbias = 1 + lowOrderZeros;</span>
                }
<span class="fc" id="L1614">                B2 += hulpbias;</span>
<span class="fc" id="L1615">                D2 += hulpbias;</span>
                // if there are common factors of 2, we might just as well
                // factor them out, as they add nothing useful.
<span class="fc" id="L1618">                int common2 = Math.min(B2, Math.min(D2, Ulp2));</span>
<span class="fc" id="L1619">                B2 -= common2;</span>
<span class="fc" id="L1620">                D2 -= common2;</span>
<span class="fc" id="L1621">                Ulp2 -= common2;</span>
                // do multiplications by powers of 5 and 2
<span class="fc" id="L1623">                FDBigInteger bigB = FDBigInteger.valueOfMulPow52(bigBbits, B5, B2);</span>
<span class="pc bpc" id="L1624" title="3 of 4 branches missed.">                if (bigD == null || prevD2 != D2) {</span>
<span class="fc" id="L1625">                    bigD = bigD0.leftShift(D2);</span>
<span class="fc" id="L1626">                    prevD2 = D2;</span>
                }
                //
                // to recap:
                // bigB is the scaled-big-int version of our floating-point
                // candidate.
                // bigD is the scaled-big-int version of the exact value
                // as we understand it.
                // halfUlp is 1/2 an ulp of bigB, except for special cases
                // of exact powers of 2
                //
                // the plan is to compare bigB with bigD, and if the difference
                // is less than halfUlp, then we're satisfied. Otherwise,
                // use the ratio of difference to halfUlp to calculate a fudge
                // factor to add to the floating value, then go 'round again.
                //
                FDBigInteger diff;
                int cmpResult;
                boolean overvalue;
<span class="fc bfc" id="L1645" title="All 2 branches covered.">                if ((cmpResult = bigB.cmp(bigD)) &gt; 0) {</span>
<span class="fc" id="L1646">                    overvalue = true; // our candidate is too big.</span>
<span class="fc" id="L1647">                    diff = bigB.leftInplaceSub(bigD); // bigB is not user further - reuse</span>
<span class="pc bpc" id="L1648" title="1 of 4 branches missed.">                    if ((bigIntNBits == 1) &amp;&amp; (bigIntExp &gt; -FloatConsts.EXP_BIAS + 1)) {</span>
                        // candidate is a normalized exact power of 2 and
                        // is too big (larger than Float.MIN_NORMAL). We will be subtracting.
                        // For our purposes, ulp is the ulp of the
                        // next smaller range.
<span class="fc" id="L1653">                        Ulp2 -= 1;</span>
<span class="pc bpc" id="L1654" title="1 of 2 branches missed.">                        if (Ulp2 &lt; 0) {</span>
                            // rats. Cannot de-scale ulp this far.
                            // must scale diff in other direction.
<span class="nc" id="L1657">                            Ulp2 = 0;</span>
<span class="nc" id="L1658">                            diff = diff.leftShift(1);</span>
                        }
                    }
<span class="fc bfc" id="L1661" title="All 2 branches covered.">                } else if (cmpResult &lt; 0) {</span>
<span class="fc" id="L1662">                    overvalue = false; // our candidate is too small.</span>
<span class="fc" id="L1663">                    diff = bigD.rightInplaceSub(bigB); // bigB is not user further - reuse</span>
                } else {
                    // the candidate is exactly right!
                    // this happens with surprising frequency
                    break correctionLoop;
                }
<span class="fc" id="L1669">                cmpResult = diff.cmpPow52(B5, Ulp2);</span>
<span class="pc bpc" id="L1670" title="1 of 2 branches missed.">                if ((cmpResult) &lt; 0) {</span>
                    // difference is small.
                    // this is close enough
<span class="fc" id="L1673">                    break correctionLoop;</span>
<span class="nc bnc" id="L1674" title="All 2 branches missed.">                } else if (cmpResult == 0) {</span>
                    // difference is exactly half an ULP
                    // round to some other value maybe, then finish
<span class="nc bnc" id="L1677" title="All 2 branches missed.">                    if ((ieeeBits &amp; 1) != 0) { // half ties to even</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">                        ieeeBits += overvalue ? -1 : 1; // nextDown or nextUp</span>
                    }
                    break correctionLoop;
                } else {
                    // difference is non-trivial.
                    // could scale addend by ratio of difference to
                    // halfUlp here, if we bothered to compute that difference.
                    // Most of the time ( I hope ) it is about 1 anyway.
<span class="nc bnc" id="L1686" title="All 2 branches missed.">                    ieeeBits += overvalue ? -1 : 1; // nextDown or nextUp</span>
<span class="nc bnc" id="L1687" title="All 4 branches missed.">                    if (ieeeBits == 0 || ieeeBits == FloatConsts.EXP_BIT_MASK) { // 0.0 or Float.POSITIVE_INFINITY</span>
<span class="nc" id="L1688">                        break correctionLoop; // oops. Fell off end of range.</span>
                    }
                    continue; // try again.
                }

            }
<span class="fc bfc" id="L1694" title="All 2 branches covered.">            if (isNegative) {</span>
<span class="fc" id="L1695">                ieeeBits |= FloatConsts.SIGN_BIT_MASK;</span>
            }
<span class="fc" id="L1697">            return Float.intBitsToFloat(ieeeBits);</span>
        }


        /**
         * All the positive powers of 10 that can be
         * represented exactly in double/float.
         */
<span class="fc" id="L1705">        private static final double[] SMALL_10_POW = {</span>
            1.0e0,
            1.0e1, 1.0e2, 1.0e3, 1.0e4, 1.0e5,
            1.0e6, 1.0e7, 1.0e8, 1.0e9, 1.0e10,
            1.0e11, 1.0e12, 1.0e13, 1.0e14, 1.0e15,
            1.0e16, 1.0e17, 1.0e18, 1.0e19, 1.0e20,
            1.0e21, 1.0e22
        };

<span class="fc" id="L1714">        private static final float[] SINGLE_SMALL_10_POW = {</span>
            1.0e0f,
            1.0e1f, 1.0e2f, 1.0e3f, 1.0e4f, 1.0e5f,
            1.0e6f, 1.0e7f, 1.0e8f, 1.0e9f, 1.0e10f
        };

<span class="fc" id="L1720">        private static final double[] BIG_10_POW = {</span>
            1e16, 1e32, 1e64, 1e128, 1e256 };
<span class="fc" id="L1722">        private static final double[] TINY_10_POW = {</span>
            1e-16, 1e-32, 1e-64, 1e-128, 1e-256 };

<span class="fc" id="L1725">        private static final int MAX_SMALL_TEN = SMALL_10_POW.length-1;</span>
<span class="fc" id="L1726">        private static final int SINGLE_MAX_SMALL_TEN = SINGLE_SMALL_10_POW.length-1;</span>

    }

    /**
     * Returns a &lt;code&gt;BinaryToASCIIConverter&lt;/code&gt; for a &lt;code&gt;double&lt;/code&gt;.
     * The returned object is a &lt;code&gt;ThreadLocal&lt;/code&gt; variable of this class.
     *
     * @param d The double precision value to convert.
     * @return The converter.
     */
    public static BinaryToASCIIConverter getBinaryToASCIIConverter(double d) {
<span class="fc" id="L1738">        return getBinaryToASCIIConverter(d, true);</span>
    }

    /**
     * Returns a &lt;code&gt;BinaryToASCIIConverter&lt;/code&gt; for a &lt;code&gt;double&lt;/code&gt;.
     * The returned object is a &lt;code&gt;ThreadLocal&lt;/code&gt; variable of this class.
     *
     * @param d The double precision value to convert.
     * @param isCompatibleFormat
     * @return The converter.
     */
    static BinaryToASCIIConverter getBinaryToASCIIConverter(double d, boolean isCompatibleFormat) {
<span class="fc" id="L1750">        long dBits = Double.doubleToRawLongBits(d);</span>
<span class="fc bfc" id="L1751" title="All 2 branches covered.">        boolean isNegative = (dBits&amp;DoubleConsts.SIGN_BIT_MASK) != 0; // discover sign</span>
<span class="fc" id="L1752">        long fractBits = dBits &amp; DoubleConsts.SIGNIF_BIT_MASK;</span>
<span class="fc" id="L1753">        int  binExp = (int)( (dBits&amp;DoubleConsts.EXP_BIT_MASK) &gt;&gt; EXP_SHIFT );</span>
        // Discover obvious special cases of NaN and Infinity.
<span class="pc bpc" id="L1755" title="1 of 2 branches missed.">        if ( binExp == (int)(DoubleConsts.EXP_BIT_MASK&gt;&gt;EXP_SHIFT) ) {</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">            if ( fractBits == 0L ){</span>
<span class="nc bnc" id="L1757" title="All 2 branches missed.">                return isNegative ? B2AC_NEGATIVE_INFINITY : B2AC_POSITIVE_INFINITY;</span>
            } else {
<span class="nc" id="L1759">                return B2AC_NOT_A_NUMBER;</span>
            }
        }
        // Finish unpacking
        // Normalize denormalized numbers.
        // Insert assumed high-order bit for normalized numbers.
        // Subtract exponent bias.
        int  nSignificantBits;
<span class="fc bfc" id="L1767" title="All 2 branches covered.">        if ( binExp == 0 ){</span>
<span class="fc bfc" id="L1768" title="All 2 branches covered.">            if ( fractBits == 0L ){</span>
                // not a denorm, just a 0!
<span class="fc bfc" id="L1770" title="All 2 branches covered.">                return isNegative ? B2AC_NEGATIVE_ZERO : B2AC_POSITIVE_ZERO;</span>
            }
<span class="fc" id="L1772">            int leadingZeros = Long.numberOfLeadingZeros(fractBits);</span>
<span class="fc" id="L1773">            int shift = leadingZeros-(63-EXP_SHIFT);</span>
<span class="fc" id="L1774">            fractBits &lt;&lt;= shift;</span>
<span class="fc" id="L1775">            binExp = 1 - shift;</span>
<span class="fc" id="L1776">            nSignificantBits =  64-leadingZeros; // recall binExp is  - shift count.</span>
<span class="fc" id="L1777">        } else {</span>
<span class="fc" id="L1778">            fractBits |= FRACT_HOB;</span>
<span class="fc" id="L1779">            nSignificantBits = EXP_SHIFT+1;</span>
        }
<span class="fc" id="L1781">        binExp -= DoubleConsts.EXP_BIAS;</span>
<span class="fc" id="L1782">        BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();</span>
<span class="fc" id="L1783">        buf.setSign(isNegative);</span>
        // call the routine that actually does all the hard work.
<span class="fc" id="L1785">        buf.dtoa(binExp, fractBits, nSignificantBits, isCompatibleFormat);</span>
<span class="fc" id="L1786">        return buf;</span>
    }

    private static BinaryToASCIIConverter getBinaryToASCIIConverter(float f) {
<span class="fc" id="L1790">        int fBits = Float.floatToRawIntBits( f );</span>
<span class="fc bfc" id="L1791" title="All 2 branches covered.">        boolean isNegative = (fBits&amp;FloatConsts.SIGN_BIT_MASK) != 0;</span>
<span class="fc" id="L1792">        int fractBits = fBits&amp;FloatConsts.SIGNIF_BIT_MASK;</span>
<span class="fc" id="L1793">        int binExp = (fBits&amp;FloatConsts.EXP_BIT_MASK) &gt;&gt; SINGLE_EXP_SHIFT;</span>
        // Discover obvious special cases of NaN and Infinity.
<span class="fc bfc" id="L1795" title="All 2 branches covered.">        if ( binExp == (FloatConsts.EXP_BIT_MASK&gt;&gt;SINGLE_EXP_SHIFT) ) {</span>
<span class="pc bpc" id="L1796" title="1 of 2 branches missed.">            if ( fractBits == 0L ){</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">                return isNegative ? B2AC_NEGATIVE_INFINITY : B2AC_POSITIVE_INFINITY;</span>
            } else {
<span class="fc" id="L1799">                return B2AC_NOT_A_NUMBER;</span>
            }
        }
        // Finish unpacking
        // Normalize denormalized numbers.
        // Insert assumed high-order bit for normalized numbers.
        // Subtract exponent bias.
        int  nSignificantBits;
<span class="fc bfc" id="L1807" title="All 2 branches covered.">        if ( binExp == 0 ){</span>
<span class="pc bpc" id="L1808" title="1 of 2 branches missed.">            if ( fractBits == 0 ){</span>
                // not a denorm, just a 0!
<span class="fc bfc" id="L1810" title="All 2 branches covered.">                return isNegative ? B2AC_NEGATIVE_ZERO : B2AC_POSITIVE_ZERO;</span>
            }
<span class="nc" id="L1812">            int leadingZeros = Integer.numberOfLeadingZeros(fractBits);</span>
<span class="nc" id="L1813">            int shift = leadingZeros-(31-SINGLE_EXP_SHIFT);</span>
<span class="nc" id="L1814">            fractBits &lt;&lt;= shift;</span>
<span class="nc" id="L1815">            binExp = 1 - shift;</span>
<span class="nc" id="L1816">            nSignificantBits =  32 - leadingZeros; // recall binExp is  - shift count.</span>
<span class="nc" id="L1817">        } else {</span>
<span class="fc" id="L1818">            fractBits |= SINGLE_FRACT_HOB;</span>
<span class="fc" id="L1819">            nSignificantBits = SINGLE_EXP_SHIFT+1;</span>
        }
<span class="fc" id="L1821">        binExp -= FloatConsts.EXP_BIAS;</span>
<span class="fc" id="L1822">        BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();</span>
<span class="fc" id="L1823">        buf.setSign(isNegative);</span>
        // call the routine that actually does all the hard work.
<span class="fc" id="L1825">        buf.dtoa(binExp, ((long)fractBits)&lt;&lt;(EXP_SHIFT-SINGLE_EXP_SHIFT), nSignificantBits, true);</span>
<span class="fc" id="L1826">        return buf;</span>
    }

    @SuppressWarnings(&quot;fallthrough&quot;)
    static ASCIIToBinaryConverter readJavaFormatString( String in ) throws NumberFormatException {
<span class="fc" id="L1831">        boolean isNegative = false;</span>
<span class="fc" id="L1832">        boolean signSeen   = false;</span>
        int     decExp;
        char    c;

    parseNumber:
        try{
<span class="fc" id="L1838">            in = in.trim(); // don't fool around with white space.</span>
                            // throws NullPointerException if null
<span class="fc" id="L1840">            int len = in.length();</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">            if ( len == 0 ) {</span>
<span class="fc" id="L1842">                throw new NumberFormatException(&quot;empty String&quot;);</span>
            }
<span class="fc" id="L1844">            int i = 0;</span>
<span class="fc bfc" id="L1845" title="All 3 branches covered.">            switch (in.charAt(i)){</span>
            case '-':
<span class="fc" id="L1847">                isNegative = true;</span>
                //FALLTHROUGH
            case '+':
<span class="fc" id="L1850">                i++;</span>
<span class="fc" id="L1851">                signSeen = true;</span>
            }
<span class="fc" id="L1853">            c = in.charAt(i);</span>
<span class="fc bfc" id="L1854" title="All 2 branches covered.">            if(c == 'N') { // Check for NaN</span>
<span class="pc bpc" id="L1855" title="2 of 4 branches missed.">                if((len-i)==NAN_LENGTH &amp;&amp; in.indexOf(NAN_REP,i)==i) {</span>
<span class="fc" id="L1856">                    return A2BC_NOT_A_NUMBER;</span>
                }
                // something went wrong, throw exception
<span class="nc" id="L1859">                break parseNumber;</span>
<span class="fc bfc" id="L1860" title="All 2 branches covered.">            } else if(c == 'I') { // Check for Infinity strings</span>
<span class="pc bpc" id="L1861" title="2 of 4 branches missed.">                if((len-i)==INFINITY_LENGTH &amp;&amp; in.indexOf(INFINITY_REP,i)==i) {</span>
<span class="fc bfc" id="L1862" title="All 2 branches covered.">                    return isNegative? A2BC_NEGATIVE_INFINITY : A2BC_POSITIVE_INFINITY;</span>
                }
                // something went wrong, throw exception
<span class="nc" id="L1865">                break parseNumber;</span>
<span class="fc bfc" id="L1866" title="All 2 branches covered.">            } else if (c == '0')  { // check for hexadecimal floating-point number</span>
<span class="fc bfc" id="L1867" title="All 2 branches covered.">                if (len &gt; i+1 ) {</span>
<span class="fc" id="L1868">                    char ch = in.charAt(i+1);</span>
<span class="fc bfc" id="L1869" title="All 4 branches covered.">                    if (ch == 'x' || ch == 'X' ) { // possible hex string</span>
<span class="fc" id="L1870">                        return parseHexString(in);</span>
                    }
                }
            }  // look for and process decimal floating-point string

<span class="fc" id="L1875">            char[] digits = new char[ len ];</span>
<span class="fc" id="L1876">            int    nDigits= 0;</span>
<span class="fc" id="L1877">            boolean decSeen = false;</span>
<span class="fc" id="L1878">            int decPt = 0;</span>
<span class="fc" id="L1879">            int nLeadZero = 0;</span>
<span class="fc" id="L1880">            int nTrailZero= 0;</span>

        skipLeadingZerosLoop:
<span class="fc bfc" id="L1883" title="All 2 branches covered.">            while (i &lt; len) {</span>
<span class="fc" id="L1884">                c = in.charAt(i);</span>
<span class="fc bfc" id="L1885" title="All 2 branches covered.">                if (c == '0') {</span>
<span class="fc" id="L1886">                    nLeadZero++;</span>
<span class="fc bfc" id="L1887" title="All 2 branches covered.">                } else if (c == '.') {</span>
<span class="pc bpc" id="L1888" title="1 of 2 branches missed.">                    if (decSeen) {</span>
                        // already saw one ., this is the 2nd.
<span class="nc" id="L1890">                        throw new NumberFormatException(&quot;multiple points&quot;);</span>
                    }
<span class="fc" id="L1892">                    decPt = i;</span>
<span class="pc bpc" id="L1893" title="1 of 2 branches missed.">                    if (signSeen) {</span>
<span class="nc" id="L1894">                        decPt -= 1;</span>
                    }
<span class="fc" id="L1896">                    decSeen = true;</span>
                } else {
                    break skipLeadingZerosLoop;
                }
<span class="fc" id="L1900">                i++;</span>
            }
        digitLoop:
<span class="fc bfc" id="L1903" title="All 2 branches covered.">            while (i &lt; len) {</span>
<span class="fc" id="L1904">                c = in.charAt(i);</span>
<span class="fc bfc" id="L1905" title="All 4 branches covered.">                if (c &gt;= '1' &amp;&amp; c &lt;= '9') {</span>
<span class="fc" id="L1906">                    digits[nDigits++] = c;</span>
<span class="fc" id="L1907">                    nTrailZero = 0;</span>
<span class="fc bfc" id="L1908" title="All 2 branches covered.">                } else if (c == '0') {</span>
<span class="fc" id="L1909">                    digits[nDigits++] = c;</span>
<span class="fc" id="L1910">                    nTrailZero++;</span>
<span class="fc bfc" id="L1911" title="All 2 branches covered.">                } else if (c == '.') {</span>
<span class="fc bfc" id="L1912" title="All 2 branches covered.">                    if (decSeen) {</span>
                        // already saw one ., this is the 2nd.
<span class="fc" id="L1914">                        throw new NumberFormatException(&quot;multiple points&quot;);</span>
                    }
<span class="fc" id="L1916">                    decPt = i;</span>
<span class="fc bfc" id="L1917" title="All 2 branches covered.">                    if (signSeen) {</span>
<span class="fc" id="L1918">                        decPt -= 1;</span>
                    }
<span class="fc" id="L1920">                    decSeen = true;</span>
                } else {
                    break digitLoop;
                }
<span class="fc" id="L1924">                i++;</span>
            }
<span class="fc" id="L1926">            nDigits -=nTrailZero;</span>
            //
            // At this point, we've scanned all the digits and decimal
            // point we're going to see. Trim off leading and trailing
            // zeros, which will just confuse us later, and adjust
            // our initial decimal exponent accordingly.
            // To review:
            // we have seen i total characters.
            // nLeadZero of them were zeros before any other digits.
            // nTrailZero of them were zeros after any other digits.
            // if ( decSeen ), then a . was seen after decPt characters
            // ( including leading zeros which have been discarded )
            // nDigits characters were neither lead nor trailing
            // zeros, nor point
            //
            //
            // special hack: if we saw no non-zero digits, then the
            // answer is zero!
            // Unfortunately, we feel honor-bound to keep parsing!
            //
<span class="fc bfc" id="L1946" title="All 2 branches covered.">            boolean isZero = (nDigits == 0);</span>
<span class="pc bpc" id="L1947" title="1 of 4 branches missed.">            if ( isZero &amp;&amp;  nLeadZero == 0 ){</span>
                // we saw NO DIGITS AT ALL,
                // not even a crummy 0!
                // this is not allowed.
<span class="nc" id="L1951">                break parseNumber; // go throw exception</span>
            }
            //
            // Our initial exponent is decPt, adjusted by the number of
            // discarded zeros. Or, if there was no decPt,
            // then its just nDigits adjusted by discarded trailing zeros.
            //
<span class="fc bfc" id="L1958" title="All 2 branches covered.">            if ( decSeen ){</span>
<span class="fc" id="L1959">                decExp = decPt - nLeadZero;</span>
            } else {
<span class="fc" id="L1961">                decExp = nDigits + nTrailZero;</span>
            }

            //
            // Look for 'e' or 'E' and an optionally signed integer.
            //
<span class="fc bfc" id="L1967" title="All 6 branches covered.">            if ( (i &lt; len) &amp;&amp;  (((c = in.charAt(i) )=='e') || (c == 'E') ) ){</span>
<span class="fc" id="L1968">                int expSign = 1;</span>
<span class="fc" id="L1969">                int expVal  = 0;</span>
<span class="fc" id="L1970">                int reallyBig = Integer.MAX_VALUE / 10;</span>
<span class="fc" id="L1971">                boolean expOverflow = false;</span>
<span class="fc bfc" id="L1972" title="All 3 branches covered.">                switch( in.charAt(++i) ){</span>
                case '-':
<span class="fc" id="L1974">                    expSign = -1;</span>
                    //FALLTHROUGH
                case '+':
<span class="fc" id="L1977">                    i++;</span>
                }
<span class="fc" id="L1979">                int expAt = i;</span>
            expLoop:
<span class="fc bfc" id="L1981" title="All 2 branches covered.">                while ( i &lt; len  ){</span>
<span class="pc bpc" id="L1982" title="1 of 2 branches missed.">                    if ( expVal &gt;= reallyBig ){</span>
                        // the next character will cause integer
                        // overflow.
<span class="nc" id="L1985">                        expOverflow = true;</span>
                    }
<span class="fc" id="L1987">                    c = in.charAt(i++);</span>
<span class="pc bpc" id="L1988" title="1 of 4 branches missed.">                    if(c&gt;='0' &amp;&amp; c&lt;='9') {</span>
<span class="fc" id="L1989">                        expVal = expVal*10 + ( (int)c - (int)'0' );</span>
                    } else {
<span class="fc" id="L1991">                        i--;           // back up.</span>
<span class="fc" id="L1992">                        break expLoop; // stop parsing exponent.</span>
                    }
                }
<span class="fc" id="L1995">                int expLimit = BIG_DECIMAL_EXPONENT+nDigits+nTrailZero;</span>
<span class="pc bpc" id="L1996" title="2 of 4 branches missed.">                if ( expOverflow || ( expVal &gt; expLimit ) ){</span>
                    //
                    // The intent here is to end up with
                    // infinity or zero, as appropriate.
                    // The reason for yielding such a small decExponent,
                    // rather than something intuitive such as
                    // expSign*Integer.MAX_VALUE, is that this value
                    // is subject to further manipulation in
                    // doubleValue() and floatValue(), and I don't want
                    // it to be able to cause overflow there!
                    // (The only way we can get into trouble here is for
                    // really outrageous nDigits+nTrailZero, such as 2 billion. )
                    //
<span class="nc" id="L2009">                    decExp = expSign*expLimit;</span>
                } else {
                    // this should not overflow, since we tested
                    // for expVal &gt; (MAX+N), where N &gt;= abs(decExp)
<span class="fc" id="L2013">                    decExp = decExp + expSign*expVal;</span>
                }

                // if we saw something not a digit ( or end of string )
                // after the [Ee][+-], without seeing any digits at all
                // this is certainly an error. If we saw some digits,
                // but then some trailing garbage, that might be ok.
                // so we just fall through in that case.
                // HUMBUG
<span class="pc bpc" id="L2022" title="1 of 2 branches missed.">                if ( i == expAt ) {</span>
<span class="nc" id="L2023">                    break parseNumber; // certainly bad</span>
                }
            }
            //
            // We parsed everything we could.
            // If there are leftovers, then this is not good input!
            //
<span class="fc bfc" id="L2030" title="All 4 branches covered.">            if ( i &lt; len &amp;&amp;</span>
                ((i != len - 1) ||
<span class="fc bfc" id="L2032" title="All 2 branches covered.">                (in.charAt(i) != 'f' &amp;&amp;</span>
<span class="fc bfc" id="L2033" title="All 2 branches covered.">                 in.charAt(i) != 'F' &amp;&amp;</span>
<span class="fc bfc" id="L2034" title="All 2 branches covered.">                 in.charAt(i) != 'd' &amp;&amp;</span>
<span class="pc bpc" id="L2035" title="1 of 2 branches missed.">                 in.charAt(i) != 'D'))) {</span>
<span class="fc" id="L2036">                break parseNumber; // go throw exception</span>
            }
<span class="fc bfc" id="L2038" title="All 2 branches covered.">            if(isZero) {</span>
<span class="fc bfc" id="L2039" title="All 2 branches covered.">                return isNegative ? A2BC_NEGATIVE_ZERO : A2BC_POSITIVE_ZERO;</span>
            }
<span class="fc" id="L2041">            return new ASCIIToBinaryBuffer(isNegative, decExp, digits, nDigits);</span>
<span class="nc" id="L2042">        } catch ( StringIndexOutOfBoundsException e ){ }</span>
<span class="fc" id="L2043">        throw new NumberFormatException(&quot;For input string: \&quot;&quot; + in + &quot;\&quot;&quot;);</span>
    }

<span class="nc" id="L2046">    private static class HexFloatPattern {</span>
        /**
         * Grammar is compatible with hexadecimal floating-point constants
         * described in section 6.4.4.2 of the C99 specification.
         */
<span class="fc" id="L2051">        private static final Pattern VALUE = Pattern.compile(</span>
                   //1           234                   56                7                   8      9
                    &quot;([-+])?0[xX](((\\p{XDigit}+)\\.?)|((\\p{XDigit}*)\\.(\\p{XDigit}+)))[pP]([-+])?(\\p{Digit}+)[fFdD]?&quot;
                    );
    }

    /**
     * Converts string s to a suitable floating decimal; uses the
     * double constructor and sets the roundDir variable appropriately
     * in case the value is later converted to a float.
     *
     * @param s The &lt;code&gt;String&lt;/code&gt; to parse.
     */
   static ASCIIToBinaryConverter parseHexString(String s) {
            // Verify string is a member of the hexadecimal floating-point
            // string language.
<span class="fc" id="L2067">            Matcher m = HexFloatPattern.VALUE.matcher(s);</span>
<span class="fc" id="L2068">            boolean validInput = m.matches();</span>
<span class="pc bpc" id="L2069" title="1 of 2 branches missed.">            if (!validInput) {</span>
                // Input does not match pattern
<span class="nc" id="L2071">                throw new NumberFormatException(&quot;For input string: \&quot;&quot; + s + &quot;\&quot;&quot;);</span>
            } else { // validInput
                //
                // We must isolate the sign, significand, and exponent
                // fields.  The sign value is straightforward.  Since
                // floating-point numbers are stored with a normalized
                // representation, the significand and exponent are
                // interrelated.
                //
                // After extracting the sign, we normalized the
                // significand as a hexadecimal value, calculating an
                // exponent adjust for any shifts made during
                // normalization.  If the significand is zero, the
                // exponent doesn't need to be examined since the output
                // will be zero.
                //
                // Next the exponent in the input string is extracted.
                // Afterwards, the significand is normalized as a *binary*
                // value and the input value's normalized exponent can be
                // computed.  The significand bits are copied into a
                // double significand; if the string has more logical bits
                // than can fit in a double, the extra bits affect the
                // round and sticky bits which are used to round the final
                // value.
                //
                //  Extract significand sign
<span class="fc" id="L2097">                String group1 = m.group(1);</span>
<span class="fc bfc" id="L2098" title="All 4 branches covered.">                boolean isNegative = ((group1 != null) &amp;&amp; group1.equals(&quot;-&quot;));</span>

                //  Extract Significand magnitude
                //
                // Based on the form of the significand, calculate how the
                // binary exponent needs to be adjusted to create a
                // normalized//hexadecimal* floating-point number; that
                // is, a number where there is one nonzero hex digit to
                // the left of the (hexa)decimal point.  Since we are
                // adjusting a binary, not hexadecimal exponent, the
                // exponent is adjusted by a multiple of 4.
                //
                // There are a number of significand scenarios to consider;
                // letters are used in indicate nonzero digits:
                //
                // 1. 000xxxx       =&gt;      x.xxx   normalized
                //    increase exponent by (number of x's - 1)*4
                //
                // 2. 000xxx.yyyy =&gt;        x.xxyyyy        normalized
                //    increase exponent by (number of x's - 1)*4
                //
                // 3. .000yyy  =&gt;   y.yy    normalized
                //    decrease exponent by (number of zeros + 1)*4
                //
                // 4. 000.00000yyy =&gt; y.yy normalized
                //    decrease exponent by (number of zeros to right of point + 1)*4
                //
                // If the significand is exactly zero, return a properly
                // signed zero.
                //

<span class="fc" id="L2129">                String significandString = null;</span>
<span class="fc" id="L2130">                int signifLength = 0;</span>
<span class="fc" id="L2131">                int exponentAdjust = 0;</span>
                {
<span class="fc" id="L2133">                    int leftDigits = 0; // number of meaningful digits to</span>
                    // left of &quot;decimal&quot; point
                    // (leading zeros stripped)
<span class="fc" id="L2136">                    int rightDigits = 0; // number of digits to right of</span>
                    // &quot;decimal&quot; point; leading zeros
                    // must always be accounted for
                    //
                    // The significand is made up of either
                    //
                    // 1. group 4 entirely (integer portion only)
                    //
                    // OR
                    //
                    // 2. the fractional portion from group 7 plus any
                    // (optional) integer portions from group 6.
                    //
                    String group4;
<span class="fc bfc" id="L2150" title="All 2 branches covered.">                    if ((group4 = m.group(4)) != null) {  // Integer-only significand</span>
                        // Leading zeros never matter on the integer portion
<span class="fc" id="L2152">                        significandString = stripLeadingZeros(group4);</span>
<span class="fc" id="L2153">                        leftDigits = significandString.length();</span>
                    } else {
                        // Group 6 is the optional integer; leading zeros
                        // never matter on the integer portion
<span class="fc" id="L2157">                        String group6 = stripLeadingZeros(m.group(6));</span>
<span class="fc" id="L2158">                        leftDigits = group6.length();</span>

                        // fraction
<span class="fc" id="L2161">                        String group7 = m.group(7);</span>
<span class="fc" id="L2162">                        rightDigits = group7.length();</span>

                        // Turn &quot;integer.fraction&quot; into &quot;integer&quot;+&quot;fraction&quot;
<span class="pc bpc" id="L2165" title="1 of 2 branches missed.">                        significandString =</span>
                                ((group6 == null) ? &quot;&quot; : group6) + // is the null
                                        // check necessary?
                                        group7;
                    }

<span class="fc" id="L2171">                    significandString = stripLeadingZeros(significandString);</span>
<span class="fc" id="L2172">                    signifLength = significandString.length();</span>

                    //
                    // Adjust exponent as described above
                    //
<span class="fc bfc" id="L2177" title="All 2 branches covered.">                    if (leftDigits &gt;= 1) {  // Cases 1 and 2</span>
<span class="fc" id="L2178">                        exponentAdjust = 4 * (leftDigits - 1);</span>
                    } else {                // Cases 3 and 4
<span class="fc" id="L2180">                        exponentAdjust = -4 * (rightDigits - signifLength + 1);</span>
                    }

                    // If the significand is zero, the exponent doesn't
                    // matter; return a properly signed zero.

<span class="fc bfc" id="L2186" title="All 2 branches covered.">                    if (signifLength == 0) { // Only zeros in input</span>
<span class="fc bfc" id="L2187" title="All 2 branches covered.">                        return isNegative ? A2BC_NEGATIVE_ZERO : A2BC_POSITIVE_ZERO;</span>
                    }
                }

                //  Extract Exponent
                //
                // Use an int to read in the exponent value; this should
                // provide more than sufficient range for non-contrived
                // inputs.  If reading the exponent in as an int does
                // overflow, examine the sign of the exponent and
                // significand to determine what to do.
                //
<span class="fc" id="L2199">                String group8 = m.group(8);</span>
<span class="pc bpc" id="L2200" title="1 of 4 branches missed.">                boolean positiveExponent = (group8 == null) || group8.equals(&quot;+&quot;);</span>
                long unsignedRawExponent;
                try {
<span class="fc" id="L2203">                    unsignedRawExponent = Integer.parseInt(m.group(9));</span>
                }
<span class="fc" id="L2205">                catch (NumberFormatException e) {</span>
                    // At this point, we know the exponent is
                    // syntactically well-formed as a sequence of
                    // digits.  Therefore, if an NumberFormatException
                    // is thrown, it must be due to overflowing int's
                    // range.  Also, at this point, we have already
                    // checked for a zero significand.  Thus the signs
                    // of the exponent and significand determine the
                    // final result:
                    //
                    //                      significand
                    //                      +               -
                    // exponent     +       +infinity       -infinity
                    //              -       +0.0            -0.0
<span class="fc bfc" id="L2219" title="All 6 branches covered.">                    return isNegative ?</span>
                              (positiveExponent ? A2BC_NEGATIVE_INFINITY : A2BC_NEGATIVE_ZERO)
                            : (positiveExponent ? A2BC_POSITIVE_INFINITY : A2BC_POSITIVE_ZERO);

<span class="fc" id="L2223">                }</span>

<span class="fc bfc" id="L2225" title="All 2 branches covered.">                long rawExponent =</span>
                        (positiveExponent ? 1L : -1L) * // exponent sign
                                unsignedRawExponent;            // exponent magnitude

                // Calculate partially adjusted exponent
<span class="fc" id="L2230">                long exponent = rawExponent + exponentAdjust;</span>

                // Starting copying non-zero bits into proper position in
                // a long; copy explicit bit too; this will be masked
                // later for normal values.

<span class="fc" id="L2236">                boolean round = false;</span>
<span class="fc" id="L2237">                boolean sticky = false;</span>
<span class="fc" id="L2238">                int nextShift = 0;</span>
<span class="fc" id="L2239">                long significand = 0L;</span>
                // First iteration is different, since we only copy
                // from the leading significand bit; one more exponent
                // adjust will be needed...

                // IMPORTANT: make leadingDigit a long to avoid
                // surprising shift semantics!
<span class="fc" id="L2246">                long leadingDigit = getHexDigit(significandString, 0);</span>

                //
                // Left shift the leading digit (53 - (bit position of
                // leading 1 in digit)); this sets the top bit of the
                // significand to 1.  The nextShift value is adjusted
                // to take into account the number of bit positions of
                // the leadingDigit actually used.  Finally, the
                // exponent is adjusted to normalize the significand
                // as a binary value, not just a hex value.
                //
<span class="fc bfc" id="L2257" title="All 2 branches covered.">                if (leadingDigit == 1) {</span>
<span class="fc" id="L2258">                    significand |= leadingDigit &lt;&lt; 52;</span>
<span class="fc" id="L2259">                    nextShift = 52 - 4;</span>
                    // exponent += 0
<span class="fc bfc" id="L2261" title="All 2 branches covered.">                } else if (leadingDigit &lt;= 3) { // [2, 3]</span>
<span class="fc" id="L2262">                    significand |= leadingDigit &lt;&lt; 51;</span>
<span class="fc" id="L2263">                    nextShift = 52 - 5;</span>
<span class="fc" id="L2264">                    exponent += 1;</span>
<span class="fc bfc" id="L2265" title="All 2 branches covered.">                } else if (leadingDigit &lt;= 7) { // [4, 7]</span>
<span class="fc" id="L2266">                    significand |= leadingDigit &lt;&lt; 50;</span>
<span class="fc" id="L2267">                    nextShift = 52 - 6;</span>
<span class="fc" id="L2268">                    exponent += 2;</span>
<span class="pc bpc" id="L2269" title="1 of 2 branches missed.">                } else if (leadingDigit &lt;= 15) { // [8, f]</span>
<span class="fc" id="L2270">                    significand |= leadingDigit &lt;&lt; 49;</span>
<span class="fc" id="L2271">                    nextShift = 52 - 7;</span>
<span class="fc" id="L2272">                    exponent += 3;</span>
                } else {
<span class="nc" id="L2274">                    throw new AssertionError(&quot;Result from digit conversion too large!&quot;);</span>
                }
                // The preceding if-else could be replaced by a single
                // code block based on the high-order bit set in
                // leadingDigit.  Given leadingOnePosition,

                // significand |= leadingDigit &lt;&lt; (SIGNIFICAND_WIDTH - leadingOnePosition);
                // nextShift = 52 - (3 + leadingOnePosition);
                // exponent += (leadingOnePosition-1);

                //
                // Now the exponent variable is equal to the normalized
                // binary exponent.  Code below will make representation
                // adjustments if the exponent is incremented after
                // rounding (includes overflows to infinity) or if the
                // result is subnormal.
                //

                // Copy digit into significand until the significand can't
                // hold another full hex digit or there are no more input
                // hex digits.
<span class="fc" id="L2295">                int i = 0;</span>
<span class="fc" id="L2296">                for (i = 1;</span>
<span class="fc bfc" id="L2297" title="All 4 branches covered.">                     i &lt; signifLength &amp;&amp; nextShift &gt;= 0;</span>
<span class="fc" id="L2298">                     i++) {</span>
<span class="fc" id="L2299">                    long currentDigit = getHexDigit(significandString, i);</span>
<span class="fc" id="L2300">                    significand |= (currentDigit &lt;&lt; nextShift);</span>
<span class="fc" id="L2301">                    nextShift -= 4;</span>
                }

                // After the above loop, the bulk of the string is copied.
                // Now, we must copy any partial hex digits into the
                // significand AND compute the round bit and start computing
                // sticky bit.

<span class="fc bfc" id="L2309" title="All 2 branches covered.">                if (i &lt; signifLength) { // at least one hex input digit exists</span>
<span class="fc" id="L2310">                    long currentDigit = getHexDigit(significandString, i);</span>

                    // from nextShift, figure out how many bits need
                    // to be copied, if any
<span class="pc bpc" id="L2314" title="1 of 5 branches missed.">                    switch (nextShift) { // must be negative</span>
                        case -1:
                            // three bits need to be copied in; can
                            // set round bit
<span class="fc" id="L2318">                            significand |= ((currentDigit &amp; 0xEL) &gt;&gt; 1);</span>
<span class="fc bfc" id="L2319" title="All 2 branches covered.">                            round = (currentDigit &amp; 0x1L) != 0L;</span>
<span class="fc" id="L2320">                            break;</span>

                        case -2:
                            // two bits need to be copied in; can
                            // set round and start sticky
<span class="fc" id="L2325">                            significand |= ((currentDigit &amp; 0xCL) &gt;&gt; 2);</span>
<span class="fc bfc" id="L2326" title="All 2 branches covered.">                            round = (currentDigit &amp; 0x2L) != 0L;</span>
<span class="fc bfc" id="L2327" title="All 2 branches covered.">                            sticky = (currentDigit &amp; 0x1L) != 0;</span>
<span class="fc" id="L2328">                            break;</span>

                        case -3:
                            // one bit needs to be copied in
<span class="fc" id="L2332">                            significand |= ((currentDigit &amp; 0x8L) &gt;&gt; 3);</span>
                            // Now set round and start sticky, if possible
<span class="fc bfc" id="L2334" title="All 2 branches covered.">                            round = (currentDigit &amp; 0x4L) != 0L;</span>
<span class="fc bfc" id="L2335" title="All 2 branches covered.">                            sticky = (currentDigit &amp; 0x3L) != 0;</span>
<span class="fc" id="L2336">                            break;</span>

                        case -4:
                            // all bits copied into significand; set
                            // round and start sticky
<span class="fc bfc" id="L2341" title="All 2 branches covered.">                            round = ((currentDigit &amp; 0x8L) != 0);  // is top bit set?</span>
                            // nonzeros in three low order bits?
<span class="fc bfc" id="L2343" title="All 2 branches covered.">                            sticky = (currentDigit &amp; 0x7L) != 0;</span>
<span class="fc" id="L2344">                            break;</span>

                        default:
<span class="nc" id="L2347">                            throw new AssertionError(&quot;Unexpected shift distance remainder.&quot;);</span>
                            // break;
                    }

                    // Round is set; sticky might be set.

                    // For the sticky bit, it suffices to check the
                    // current digit and test for any nonzero digits in
                    // the remaining unprocessed input.
<span class="fc" id="L2356">                    i++;</span>
<span class="fc bfc" id="L2357" title="All 4 branches covered.">                    while (i &lt; signifLength &amp;&amp; !sticky) {</span>
<span class="fc" id="L2358">                        currentDigit = getHexDigit(significandString, i);</span>
<span class="pc bpc" id="L2359" title="1 of 4 branches missed.">                        sticky = sticky || (currentDigit != 0);</span>
<span class="fc" id="L2360">                        i++;</span>
                    }

                }
                // else all of string was seen, round and sticky are
                // correct as false.

                // Float calculations
<span class="fc bfc" id="L2368" title="All 2 branches covered.">                int floatBits = isNegative ? FloatConsts.SIGN_BIT_MASK : 0;</span>
<span class="fc bfc" id="L2369" title="All 2 branches covered.">                if (exponent &gt;= FloatConsts.MIN_EXPONENT) {</span>
<span class="fc bfc" id="L2370" title="All 2 branches covered.">                    if (exponent &gt; FloatConsts.MAX_EXPONENT) {</span>
                        // Float.POSITIVE_INFINITY
<span class="fc" id="L2372">                        floatBits |= FloatConsts.EXP_BIT_MASK;</span>
                    } else {
<span class="fc" id="L2374">                        int threshShift = DoubleConsts.SIGNIFICAND_WIDTH - FloatConsts.SIGNIFICAND_WIDTH - 1;</span>
<span class="fc bfc" id="L2375" title="All 6 branches covered.">                        boolean floatSticky = (significand &amp; ((1L &lt;&lt; threshShift) - 1)) != 0 || round || sticky;</span>
<span class="fc" id="L2376">                        int iValue = (int) (significand &gt;&gt;&gt; threshShift);</span>
<span class="pc bpc" id="L2377" title="1 of 4 branches missed.">                        if ((iValue &amp; 3) != 1 || floatSticky) {</span>
<span class="fc" id="L2378">                            iValue++;</span>
                        }
<span class="fc" id="L2380">                        floatBits |= (((((int) exponent) + (FloatConsts.EXP_BIAS - 1))) &lt;&lt; SINGLE_EXP_SHIFT) + (iValue &gt;&gt; 1);</span>
<span class="fc" id="L2381">                    }</span>
                } else {
<span class="fc bfc" id="L2383" title="All 2 branches covered.">                    if (exponent &lt; FloatConsts.MIN_SUB_EXPONENT - 1) {</span>
                        // 0
                    } else {
                        // exponent == -127 ==&gt; threshShift = 53 - 2 + (-149) - (-127) = 53 - 24
<span class="fc" id="L2387">                        int threshShift = (int) ((DoubleConsts.SIGNIFICAND_WIDTH - 2 + FloatConsts.MIN_SUB_EXPONENT) - exponent);</span>
<span class="pc bpc" id="L2388" title="2 of 4 branches missed.">                        assert threshShift &gt;= DoubleConsts.SIGNIFICAND_WIDTH - FloatConsts.SIGNIFICAND_WIDTH;</span>
<span class="pc bpc" id="L2389" title="2 of 4 branches missed.">                        assert threshShift &lt; DoubleConsts.SIGNIFICAND_WIDTH;</span>
<span class="pc bpc" id="L2390" title="1 of 6 branches missed.">                        boolean floatSticky = (significand &amp; ((1L &lt;&lt; threshShift) - 1)) != 0 || round || sticky;</span>
<span class="fc" id="L2391">                        int iValue = (int) (significand &gt;&gt;&gt; threshShift);</span>
<span class="pc bpc" id="L2392" title="1 of 4 branches missed.">                        if ((iValue &amp; 3) != 1 || floatSticky) {</span>
<span class="fc" id="L2393">                            iValue++;</span>
                        }
<span class="fc" id="L2395">                        floatBits |= iValue &gt;&gt; 1;</span>
                    }
                }
<span class="fc" id="L2398">                float fValue = Float.intBitsToFloat(floatBits);</span>

                // Check for overflow and update exponent accordingly.
<span class="fc bfc" id="L2401" title="All 2 branches covered.">                if (exponent &gt; DoubleConsts.MAX_EXPONENT) {         // Infinite result</span>
                    // overflow to properly signed infinity
<span class="fc bfc" id="L2403" title="All 2 branches covered.">                    return isNegative ? A2BC_NEGATIVE_INFINITY : A2BC_POSITIVE_INFINITY;</span>
                } else {  // Finite return value
<span class="pc bpc" id="L2405" title="1 of 4 branches missed.">                    if (exponent &lt;= DoubleConsts.MAX_EXPONENT &amp;&amp; // (Usually) normal result</span>
                            exponent &gt;= DoubleConsts.MIN_EXPONENT) {

                        // The result returned in this block cannot be a
                        // zero or subnormal; however after the
                        // significand is adjusted from rounding, we could
                        // still overflow in infinity.

                        // AND exponent bits into significand; if the
                        // significand is incremented and overflows from
                        // rounding, this combination will update the
                        // exponent correctly, even in the case of
                        // Double.MAX_VALUE overflowing to infinity.

<span class="fc" id="L2419">                        significand = ((( exponent +</span>
                                (long) DoubleConsts.EXP_BIAS) &lt;&lt;
                                (DoubleConsts.SIGNIFICAND_WIDTH - 1))
                                &amp; DoubleConsts.EXP_BIT_MASK) |
                                (DoubleConsts.SIGNIF_BIT_MASK &amp; significand);

                    } else {  // Subnormal or zero
                        // (exponent &lt; DoubleConsts.MIN_EXPONENT)

<span class="fc bfc" id="L2428" title="All 2 branches covered.">                        if (exponent &lt; (DoubleConsts.MIN_SUB_EXPONENT - 1)) {</span>
                            // No way to round back to nonzero value
                            // regardless of significand if the exponent is
                            // less than -1075.
<span class="fc bfc" id="L2432" title="All 2 branches covered.">                            return isNegative ? A2BC_NEGATIVE_ZERO : A2BC_POSITIVE_ZERO;</span>
                        } else { //  -1075 &lt;= exponent &lt;= MIN_EXPONENT -1 = -1023
                            //
                            // Find bit position to round to; recompute
                            // round and sticky bits, and shift
                            // significand right appropriately.
                            //

<span class="pc bpc" id="L2440" title="1 of 4 branches missed.">                            sticky = sticky || round;</span>
<span class="fc" id="L2441">                            round = false;</span>

                            // Number of bits of significand to preserve is
                            // exponent - abs_min_exp +1
                            // check:
                            // -1075 +1074 + 1 = 0
                            // -1023 +1074 + 1 = 52

<span class="fc" id="L2449">                            int bitsDiscarded = 53 -</span>
                                    ((int) exponent - DoubleConsts.MIN_SUB_EXPONENT + 1);
<span class="pc bpc" id="L2451" title="3 of 6 branches missed.">                            assert bitsDiscarded &gt;= 1 &amp;&amp; bitsDiscarded &lt;= 53;</span>

                            // What to do here:
                            // First, isolate the new round bit
<span class="fc bfc" id="L2455" title="All 2 branches covered.">                            round = (significand &amp; (1L &lt;&lt; (bitsDiscarded - 1))) != 0L;</span>
<span class="fc bfc" id="L2456" title="All 2 branches covered.">                            if (bitsDiscarded &gt; 1) {</span>
                                // create mask to update sticky bits; low
                                // order bitsDiscarded bits should be 1
<span class="fc" id="L2459">                                long mask = ~((~0L) &lt;&lt; (bitsDiscarded - 1));</span>
<span class="fc bfc" id="L2460" title="All 4 branches covered.">                                sticky = sticky || ((significand &amp; mask) != 0L);</span>
                            }

                            // Now, discard the bits
<span class="fc" id="L2464">                            significand = significand &gt;&gt; bitsDiscarded;</span>

<span class="fc" id="L2466">                            significand = ((((long) (DoubleConsts.MIN_EXPONENT - 1) + // subnorm exp.</span>
                                    (long) DoubleConsts.EXP_BIAS) &lt;&lt;
                                    (DoubleConsts.SIGNIFICAND_WIDTH - 1))
                                    &amp; DoubleConsts.EXP_BIT_MASK) |
                                    (DoubleConsts.SIGNIF_BIT_MASK &amp; significand);
                        }
                    }

                    // The significand variable now contains the currently
                    // appropriate exponent bits too.

                    //
                    // Determine if significand should be incremented;
                    // making this determination depends on the least
                    // significant bit and the round and sticky bits.
                    //
                    // Round to nearest even rounding table, adapted from
                    // table 4.7 in &quot;Computer Arithmetic&quot; by IsraelKoren.
                    // The digit to the left of the &quot;decimal&quot; point is the
                    // least significant bit, the digits to the right of
                    // the point are the round and sticky bits
                    //
                    // Number       Round(x)
                    // x0.00        x0.
                    // x0.01        x0.
                    // x0.10        x0.
                    // x0.11        x1. = x0. +1
                    // x1.00        x1.
                    // x1.01        x1.
                    // x1.10        x1. + 1
                    // x1.11        x1. + 1
                    //
<span class="fc bfc" id="L2498" title="All 2 branches covered.">                    boolean leastZero = ((significand &amp; 1L) == 0L);</span>
<span class="fc bfc" id="L2499" title="All 10 branches covered.">                    if ((leastZero &amp;&amp; round &amp;&amp; sticky) ||</span>
                            ((!leastZero) &amp;&amp; round)) {
<span class="fc" id="L2501">                        significand++;</span>
                    }

<span class="fc bfc" id="L2504" title="All 2 branches covered.">                    double value = isNegative ?</span>
<span class="fc" id="L2505">                            Double.longBitsToDouble(significand | DoubleConsts.SIGN_BIT_MASK) :</span>
<span class="fc" id="L2506">                            Double.longBitsToDouble(significand );</span>

<span class="fc" id="L2508">                    return new PreparedASCIIToBinaryBuffer(value, fValue);</span>
                }
            }
    }

    /**
     * Returns &lt;code&gt;s&lt;/code&gt; with any leading zeros removed.
     */
    static String stripLeadingZeros(String s) {
//        return  s.replaceFirst(&quot;^0+&quot;, &quot;&quot;);
<span class="fc bfc" id="L2518" title="All 4 branches covered.">        if(!s.isEmpty() &amp;&amp; s.charAt(0)=='0') {</span>
<span class="fc bfc" id="L2519" title="All 2 branches covered.">            for(int i=1; i&lt;s.length(); i++) {</span>
<span class="fc bfc" id="L2520" title="All 2 branches covered.">                if(s.charAt(i)!='0') {</span>
<span class="fc" id="L2521">                    return s.substring(i);</span>
                }
            }
<span class="fc" id="L2524">            return &quot;&quot;;</span>
        }
<span class="fc" id="L2526">        return s;</span>
    }

    /**
     * Extracts a hexadecimal digit from position &lt;code&gt;position&lt;/code&gt;
     * of string &lt;code&gt;s&lt;/code&gt;.
     */
    static int getHexDigit(String s, int position) {
<span class="fc" id="L2534">        int value = Character.digit(s.charAt(position), 16);</span>
<span class="pc bpc" id="L2535" title="2 of 4 branches missed.">        if (value &lt;= -1 || value &gt;= 16) {</span>
<span class="nc" id="L2536">            throw new AssertionError(&quot;Unexpected failure of digit conversion of &quot; +</span>
<span class="nc" id="L2537">                                     s.charAt(position));</span>
        }
<span class="fc" id="L2539">        return value;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>