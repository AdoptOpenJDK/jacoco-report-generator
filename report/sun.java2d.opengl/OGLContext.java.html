<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>OGLContext.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.java2d.opengl</a> &gt; <span class="el_source">OGLContext.java</span></div><h1>OGLContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.opengl;

import sun.java2d.pipe.BufferedContext;
import sun.java2d.pipe.RenderBuffer;
import sun.java2d.pipe.RenderQueue;
import sun.java2d.pipe.hw.ContextCapabilities;
import static sun.java2d.pipe.BufferedOpCodes.*;
import static sun.java2d.pipe.hw.ContextCapabilities.*;

import java.lang.annotation.Native;

/**
 * Note that the RenderQueue lock must be acquired before calling any of
 * the methods in this class.
 */
public class OGLContext extends BufferedContext {

    private final OGLGraphicsConfig config;

    OGLContext(RenderQueue rq, OGLGraphicsConfig config) {
<span class="nc" id="L46">        super(rq);</span>
<span class="nc" id="L47">        this.config = config;</span>
<span class="nc" id="L48">    }</span>

    /**
     * Convenience method that delegates to setScratchSurface() below.
     */
    static void setScratchSurface(OGLGraphicsConfig gc) {
<span class="nc" id="L54">        setScratchSurface(gc.getNativeConfigInfo());</span>
<span class="nc" id="L55">    }</span>

    /**
     * Makes the given GraphicsConfig's context current to its associated
     * &quot;scratch surface&quot;.  Each GraphicsConfig maintains a native context
     * (GLXContext on Unix, HGLRC on Windows) as well as a native pbuffer
     * known as the &quot;scratch surface&quot;.  By making the context current to the
     * scratch surface, we are assured that we have a current context for
     * the relevant GraphicsConfig, and can therefore perform operations
     * depending on the capabilities of that GraphicsConfig.  For example,
     * if the GraphicsConfig supports the GL_ARB_texture_non_power_of_two
     * extension, then we should be able to make a non-pow2 texture for this
     * GraphicsConfig once we make the context current to the scratch surface.
     *
     * This method should be used for operations with an OpenGL texture
     * as the destination surface (e.g. a sw-&gt;texture blit loop), or in those
     * situations where we may not otherwise have a current context (e.g.
     * when disposing a texture-based surface).
     */
    static void setScratchSurface(long pConfigInfo) {
        // assert OGLRenderQueue.getInstance().lock.isHeldByCurrentThread();

        // invalidate the current context
<span class="nc" id="L78">        currentContext = null;</span>

        // set the scratch context
<span class="nc" id="L81">        OGLRenderQueue rq = OGLRenderQueue.getInstance();</span>
<span class="nc" id="L82">        RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L83">        rq.ensureCapacityAndAlignment(12, 4);</span>
<span class="nc" id="L84">        buf.putInt(SET_SCRATCH_SURFACE);</span>
<span class="nc" id="L85">        buf.putLong(pConfigInfo);</span>
<span class="nc" id="L86">    }</span>

    /**
     * Invalidates the currentContext field to ensure that we properly
     * revalidate the OGLContext (make it current, etc.) next time through
     * the validate() method.  This is typically invoked from methods
     * that affect the current context state (e.g. disposing a context or
     * surface).
     */
    static void invalidateCurrentContext() {
        // assert OGLRenderQueue.getInstance().lock.isHeldByCurrentThread();

        // invalidate the current Java-level context so that we
        // revalidate everything the next time around
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (currentContext != null) {</span>
<span class="nc" id="L101">            currentContext.invalidateContext();</span>
<span class="nc" id="L102">            currentContext = null;</span>
        }

        // invalidate the context reference at the native level, and
        // then flush the queue so that we have no pending operations
        // dependent on the current context
<span class="nc" id="L108">        OGLRenderQueue rq = OGLRenderQueue.getInstance();</span>
<span class="nc" id="L109">        rq.ensureCapacity(4);</span>
<span class="nc" id="L110">        rq.getBuffer().putInt(INVALIDATE_CONTEXT);</span>
<span class="nc" id="L111">        rq.flushNow();</span>
<span class="nc" id="L112">    }</span>

    public RenderQueue getRenderQueue() {
<span class="nc" id="L115">        return OGLRenderQueue.getInstance();</span>
    }

    /**
     * Returns a string representing adapter id (vendor, renderer, version).
     * Must be called on the rendering thread.
     *
     * @return an id string for the adapter
     */
    static final native String getOGLIdString();

    @Override
    public void saveState() {
        // assert rq.lock.isHeldByCurrentThread();

        // reset all attributes of this and current contexts
<span class="nc" id="L131">        invalidateContext();</span>
<span class="nc" id="L132">        invalidateCurrentContext();</span>

<span class="nc" id="L134">        setScratchSurface(config);</span>

        // save the state on the native level
<span class="nc" id="L137">        rq.ensureCapacity(4);</span>
<span class="nc" id="L138">        buf.putInt(SAVE_STATE);</span>
<span class="nc" id="L139">        rq.flushNow();</span>
<span class="nc" id="L140">    }</span>

    @Override
    public void restoreState() {
        // assert rq.lock.isHeldByCurrentThread();

        // reset all attributes of this and current contexts
<span class="nc" id="L147">        invalidateContext();</span>
<span class="nc" id="L148">        invalidateCurrentContext();</span>

<span class="nc" id="L150">        setScratchSurface(config);</span>

        // restore the state on the native level
<span class="nc" id="L153">        rq.ensureCapacity(4);</span>
<span class="nc" id="L154">        buf.putInt(RESTORE_STATE);</span>
<span class="nc" id="L155">        rq.flushNow();</span>
<span class="nc" id="L156">    }</span>

    static class OGLContextCaps extends ContextCapabilities {
        /**
         * Indicates the presence of the GL_EXT_framebuffer_object extension.
         * This cap will only be set if the fbobject system property has been
         * enabled and we are able to create an FBO with depth buffer.
         */
        @Native
        static final int CAPS_EXT_FBOBJECT     =
                (CAPS_RT_TEXTURE_ALPHA | CAPS_RT_TEXTURE_OPAQUE);
        /** Indicates that the context supports a stored alpha channel. */
        @Native
        static final int CAPS_STORED_ALPHA     = CAPS_RT_PLAIN_ALPHA;
        /** Indicates that the context is doublebuffered. */
        @Native
        static final int CAPS_DOUBLEBUFFERED   = (FIRST_PRIVATE_CAP &lt;&lt; 0);
        /**
         * Indicates the presence of the GL_ARB_fragment_shader extension.
         * This cap will only be set if the lcdshader system property has been
         * enabled and the hardware supports the minimum number of texture units
         */
        @Native
        static final int CAPS_EXT_LCD_SHADER   = (FIRST_PRIVATE_CAP &lt;&lt; 1);
        /**
         * Indicates the presence of the GL_ARB_fragment_shader extension.
         * This cap will only be set if the biopshader system property has been
         * enabled and the hardware meets our minimum requirements.
         */
        @Native
        static final int CAPS_EXT_BIOP_SHADER  = (FIRST_PRIVATE_CAP &lt;&lt; 2);
        /**
         * Indicates the presence of the GL_ARB_fragment_shader extension.
         * This cap will only be set if the gradshader system property has been
         * enabled and the hardware meets our minimum requirements.
         */
        @Native
        static final int CAPS_EXT_GRAD_SHADER  = (FIRST_PRIVATE_CAP &lt;&lt; 3);
        /** Indicates the presence of the GL_ARB_texture_rectangle extension. */
        @Native
        static final int CAPS_EXT_TEXRECT      = (FIRST_PRIVATE_CAP &lt;&lt; 4);

        OGLContextCaps(int caps, String adapterId) {
<span class="nc" id="L199">            super(caps, adapterId);</span>
<span class="nc" id="L200">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L204">            StringBuffer buf = new StringBuffer(super.toString());</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if ((caps &amp; CAPS_EXT_FBOBJECT) != 0) {</span>
<span class="nc" id="L206">                buf.append(&quot;CAPS_EXT_FBOBJECT|&quot;);</span>
            }
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if ((caps &amp; CAPS_STORED_ALPHA) != 0) {</span>
<span class="nc" id="L209">                buf.append(&quot;CAPS_STORED_ALPHA|&quot;);</span>
            }
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if ((caps &amp; CAPS_DOUBLEBUFFERED) != 0) {</span>
<span class="nc" id="L212">                buf.append(&quot;CAPS_DOUBLEBUFFERED|&quot;);</span>
            }
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if ((caps &amp; CAPS_EXT_LCD_SHADER) != 0) {</span>
<span class="nc" id="L215">                buf.append(&quot;CAPS_EXT_LCD_SHADER|&quot;);</span>
            }
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if ((caps &amp; CAPS_EXT_BIOP_SHADER) != 0) {</span>
<span class="nc" id="L218">                buf.append(&quot;CAPS_BIOP_SHADER|&quot;);</span>
            }
<span class="nc bnc" id="L220" title="All 2 branches missed.">            if ((caps &amp; CAPS_EXT_GRAD_SHADER) != 0) {</span>
<span class="nc" id="L221">                buf.append(&quot;CAPS_EXT_GRAD_SHADER|&quot;);</span>
            }
<span class="nc bnc" id="L223" title="All 2 branches missed.">            if ((caps &amp; CAPS_EXT_TEXRECT) != 0) {</span>
<span class="nc" id="L224">                buf.append(&quot;CAPS_EXT_TEXRECT|&quot;);</span>
            }
<span class="nc" id="L226">            return buf.toString();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>