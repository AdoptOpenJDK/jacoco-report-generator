<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>OGLSurfaceData.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.java2d.opengl</a> &gt; <span class="el_source">OGLSurfaceData.java</span></div><h1>OGLSurfaceData.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.opengl;

import java.awt.AlphaComposite;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.Transparency;
import java.awt.image.ColorModel;
import java.awt.image.Raster;
import sun.awt.SunHints;
import sun.awt.image.PixelConverter;
import sun.java2d.pipe.hw.AccelSurface;
import sun.java2d.SunGraphics2D;
import sun.java2d.SurfaceData;
import sun.java2d.SurfaceDataProxy;
import sun.java2d.loops.CompositeType;
import sun.java2d.loops.GraphicsPrimitive;
import sun.java2d.loops.MaskFill;
import sun.java2d.loops.SurfaceType;
import sun.java2d.pipe.ParallelogramPipe;
import sun.java2d.pipe.PixelToParallelogramConverter;
import sun.java2d.pipe.RenderBuffer;
import sun.java2d.pipe.TextPipe;
import static sun.java2d.pipe.BufferedOpCodes.*;
import static sun.java2d.opengl.OGLContext.OGLContextCaps.*;

/**
 * This class describes an OpenGL &quot;surface&quot;, that is, a region of pixels
 * managed via OpenGL.  An OGLSurfaceData can be tagged with one of three
 * different SurfaceType objects for the purpose of registering loops, etc.
 * This diagram shows the hierarchy of OGL SurfaceTypes:
 *
 *                               Any
 *                             /     \
 *                 OpenGLSurface     OpenGLTexture
 *                      |
 *               OpenGLSurfaceRTT
 *
 * OpenGLSurface
 * This kind of surface can be rendered to using OpenGL APIs.  It is also
 * possible to copy an OpenGLSurface to another OpenGLSurface (or to itself).
 * This is typically accomplished by calling MakeContextCurrent(dstSD, srcSD)
 * and then calling glCopyPixels() (although there are other techniques to
 * achieve the same goal).
 *
 * OpenGLTexture
 * This kind of surface cannot be rendered to using OpenGL (in the same sense
 * as in OpenGLSurface).  However, it is possible to upload a region of pixels
 * to an OpenGLTexture object via glTexSubImage2D().  One can also copy a
 * surface of type OpenGLTexture to an OpenGLSurface by binding the texture
 * to a quad and then rendering it to the destination surface (this process
 * is known as &quot;texture mapping&quot;).
 *
 * OpenGLSurfaceRTT
 * This kind of surface can be thought of as a sort of hybrid between
 * OpenGLSurface and OpenGLTexture, in that one can render to this kind of
 * surface as if it were of type OpenGLSurface, but the process of copying
 * this kind of surface to another is more like an OpenGLTexture.  (Note that
 * &quot;RTT&quot; stands for &quot;render-to-texture&quot;.)
 *
 * In addition to these SurfaceType variants, we have also defined some
 * constants that describe in more detail the type of underlying OpenGL
 * surface.  This table helps explain the relationships between those
 * &quot;type&quot; constants and their corresponding SurfaceType:
 *
 * OGL Type          Corresponding SurfaceType
 * --------          -------------------------
 * WINDOW            OpenGLSurface
 * PBUFFER           OpenGLSurface
 * TEXTURE           OpenGLTexture
 * FLIP_BACKBUFFER   OpenGLSurface
 * FBOBJECT          OpenGLSurfaceRTT
 */
public abstract class OGLSurfaceData extends SurfaceData
    implements AccelSurface {

    /**
     * OGL-specific surface types
     *
     * @see sun.java2d.pipe.hw.AccelSurface
     */
    public static final int PBUFFER         = RT_PLAIN;
    public static final int FBOBJECT        = RT_TEXTURE;

    /**
     * Pixel formats
     */
    public static final int PF_INT_ARGB        = 0;
    public static final int PF_INT_ARGB_PRE    = 1;
    public static final int PF_INT_RGB         = 2;
    public static final int PF_INT_RGBX        = 3;
    public static final int PF_INT_BGR         = 4;
    public static final int PF_INT_BGRX        = 5;
    public static final int PF_USHORT_565_RGB  = 6;
    public static final int PF_USHORT_555_RGB  = 7;
    public static final int PF_USHORT_555_RGBX = 8;
    public static final int PF_BYTE_GRAY       = 9;
    public static final int PF_USHORT_GRAY     = 10;
    public static final int PF_3BYTE_BGR       = 11;

    /**
     * SurfaceTypes
     */
    private static final String DESC_OPENGL_SURFACE = &quot;OpenGL Surface&quot;;
    private static final String DESC_OPENGL_SURFACE_RTT =
        &quot;OpenGL Surface (render-to-texture)&quot;;
    private static final String DESC_OPENGL_TEXTURE = &quot;OpenGL Texture&quot;;

<span class="nc" id="L133">    static final SurfaceType OpenGLSurface =</span>
<span class="nc" id="L134">        SurfaceType.Any.deriveSubType(DESC_OPENGL_SURFACE,</span>
                                      PixelConverter.ArgbPre.instance);
<span class="nc" id="L136">    static final SurfaceType OpenGLSurfaceRTT =</span>
<span class="nc" id="L137">        OpenGLSurface.deriveSubType(DESC_OPENGL_SURFACE_RTT);</span>
<span class="nc" id="L138">    static final SurfaceType OpenGLTexture =</span>
<span class="nc" id="L139">        SurfaceType.Any.deriveSubType(DESC_OPENGL_TEXTURE);</span>

    /** This will be true if the fbobject system property has been enabled. */
    private static boolean isFBObjectEnabled;

    /** This will be true if the lcdshader system property has been enabled.*/
    private static boolean isLCDShaderEnabled;

    /** This will be true if the biopshader system property has been enabled.*/
    private static boolean isBIOpShaderEnabled;

    /** This will be true if the gradshader system property has been enabled.*/
    private static boolean isGradShaderEnabled;

    private OGLGraphicsConfig graphicsConfig;
    protected int type;
    // these fields are set from the native code when the surface is
    // initialized
    private int nativeWidth, nativeHeight;

    protected static OGLRenderer oglRenderPipe;
    protected static PixelToParallelogramConverter oglTxRenderPipe;
    protected static ParallelogramPipe oglAAPgramPipe;
    protected static OGLTextRenderer oglTextPipe;
    protected static OGLDrawImage oglImagePipe;

    protected native boolean initTexture(long pData,
                                         boolean isOpaque, boolean texNonPow2,
                                         boolean texRect,
                                         int width, int height);
    protected native boolean initFBObject(long pData,
                                          boolean isOpaque, boolean texNonPow2,
                                          boolean texRect,
                                          int width, int height);
    protected native boolean initFlipBackbuffer(long pData);
    protected abstract boolean initPbuffer(long pData, long pConfigInfo,
                                           boolean isOpaque,
                                           int width, int height);

    private native int getTextureTarget(long pData);
    private native int getTextureID(long pData);

    static {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (!GraphicsEnvironment.isHeadless()) {</span>
            // fbobject currently enabled by default; use &quot;false&quot; to disable
<span class="nc" id="L184">            String fbo = (String)java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetPropertyAction(
                    &quot;sun.java2d.opengl.fbobject&quot;));
<span class="nc bnc" id="L187" title="All 2 branches missed.">            isFBObjectEnabled = !&quot;false&quot;.equals(fbo);</span>

            // lcdshader currently enabled by default; use &quot;false&quot; to disable
<span class="nc" id="L190">            String lcd = (String)java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetPropertyAction(
                    &quot;sun.java2d.opengl.lcdshader&quot;));
<span class="nc bnc" id="L193" title="All 2 branches missed.">            isLCDShaderEnabled = !&quot;false&quot;.equals(lcd);</span>

            // biopshader currently enabled by default; use &quot;false&quot; to disable
<span class="nc" id="L196">            String biop = (String)java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetPropertyAction(
                    &quot;sun.java2d.opengl.biopshader&quot;));
<span class="nc bnc" id="L199" title="All 2 branches missed.">            isBIOpShaderEnabled = !&quot;false&quot;.equals(biop);</span>

            // gradshader currently enabled by default; use &quot;false&quot; to disable
<span class="nc" id="L202">            String grad = (String)java.security.AccessController.doPrivileged(</span>
                new sun.security.action.GetPropertyAction(
                    &quot;sun.java2d.opengl.gradshader&quot;));
<span class="nc bnc" id="L205" title="All 2 branches missed.">            isGradShaderEnabled = !&quot;false&quot;.equals(grad);</span>

<span class="nc" id="L207">            OGLRenderQueue rq = OGLRenderQueue.getInstance();</span>
<span class="nc" id="L208">            oglImagePipe = new OGLDrawImage();</span>
<span class="nc" id="L209">            oglTextPipe = new OGLTextRenderer(rq);</span>
<span class="nc" id="L210">            oglRenderPipe = new OGLRenderer(rq);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (GraphicsPrimitive.tracingEnabled()) {</span>
<span class="nc" id="L212">                oglTextPipe = oglTextPipe.traceWrap();</span>
                //The wrapped oglRenderPipe will wrap the AA pipe as well...
                //oglAAPgramPipe = oglRenderPipe.traceWrap();
            }
<span class="nc" id="L216">            oglAAPgramPipe = oglRenderPipe.getAAParallelogramPipe();</span>
<span class="nc" id="L217">            oglTxRenderPipe =</span>
                new PixelToParallelogramConverter(oglRenderPipe,
                                                  oglRenderPipe,
                                                  1.0, 0.25, true);

<span class="nc" id="L222">            OGLBlitLoops.register();</span>
<span class="nc" id="L223">            OGLMaskFill.register();</span>
<span class="nc" id="L224">            OGLMaskBlit.register();</span>
        }
<span class="nc" id="L226">    }</span>

    protected OGLSurfaceData(OGLGraphicsConfig gc,
                             ColorModel cm, int type)
    {
<span class="nc" id="L231">        super(getCustomSurfaceType(type), cm);</span>
<span class="nc" id="L232">        this.graphicsConfig = gc;</span>
<span class="nc" id="L233">        this.type = type;</span>
<span class="nc" id="L234">        setBlitProxyKey(gc.getProxyKey());</span>
<span class="nc" id="L235">    }</span>

    @Override
    public SurfaceDataProxy makeProxyFor(SurfaceData srcData) {
<span class="nc" id="L239">        return OGLSurfaceDataProxy.createProxy(srcData, graphicsConfig);</span>
    }

    /**
     * Returns the appropriate SurfaceType corresponding to the given OpenGL
     * surface type constant (e.g. TEXTURE -&gt; OpenGLTexture).
     */
    private static SurfaceType getCustomSurfaceType(int oglType) {
<span class="nc bnc" id="L247" title="All 3 branches missed.">        switch (oglType) {</span>
        case TEXTURE:
<span class="nc" id="L249">            return OpenGLTexture;</span>
        case FBOBJECT:
<span class="nc" id="L251">            return OpenGLSurfaceRTT;</span>
        case PBUFFER:
        default:
<span class="nc" id="L254">            return OpenGLSurface;</span>
        }
    }

    /**
     * Note: This should only be called from the QFT under the AWT lock.
     * This method is kept separate from the initSurface() method below just
     * to keep the code a bit cleaner.
     */
    private void initSurfaceNow(int width, int height) {
<span class="nc bnc" id="L264" title="All 2 branches missed.">        boolean isOpaque = (getTransparency() == Transparency.OPAQUE);</span>
<span class="nc" id="L265">        boolean success = false;</span>

<span class="nc bnc" id="L267" title="All 5 branches missed.">        switch (type) {</span>
        case PBUFFER:
<span class="nc" id="L269">            success = initPbuffer(getNativeOps(),</span>
<span class="nc" id="L270">                                  graphicsConfig.getNativeConfigInfo(),</span>
                                  isOpaque,
                                  width, height);
<span class="nc" id="L273">            break;</span>

        case TEXTURE:
<span class="nc" id="L276">            success = initTexture(getNativeOps(),</span>
<span class="nc" id="L277">                                  isOpaque, isTexNonPow2Available(),</span>
<span class="nc" id="L278">                                  isTexRectAvailable(),</span>
                                  width, height);
<span class="nc" id="L280">            break;</span>

        case FBOBJECT:
<span class="nc" id="L283">            success = initFBObject(getNativeOps(),</span>
<span class="nc" id="L284">                                   isOpaque, isTexNonPow2Available(),</span>
<span class="nc" id="L285">                                   isTexRectAvailable(),</span>
                                   width, height);
<span class="nc" id="L287">            break;</span>

        case FLIP_BACKBUFFER:
<span class="nc" id="L290">            success = initFlipBackbuffer(getNativeOps());</span>
<span class="nc" id="L291">            break;</span>

        default:
            break;
        }

<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (!success) {</span>
<span class="nc" id="L298">            throw new OutOfMemoryError(&quot;can't create offscreen surface&quot;);</span>
        }
<span class="nc" id="L300">    }</span>

    /**
     * Initializes the appropriate OpenGL offscreen surface based on the value
     * of the type parameter.  If the surface creation fails for any reason,
     * an OutOfMemoryError will be thrown.
     */
    protected void initSurface(final int width, final int height) {
<span class="nc" id="L308">        OGLRenderQueue rq = OGLRenderQueue.getInstance();</span>
<span class="nc" id="L309">        rq.lock();</span>
        try {
<span class="nc bnc" id="L311" title="All 2 branches missed.">            switch (type) {</span>
            case TEXTURE:
            case PBUFFER:
            case FBOBJECT:
                // need to make sure the context is current before
                // creating the texture (or pbuffer, or fbobject)
<span class="nc" id="L317">                OGLContext.setScratchSurface(graphicsConfig);</span>
<span class="nc" id="L318">                break;</span>
            default:
                break;
            }
<span class="nc" id="L322">            rq.flushAndInvokeNow(new Runnable() {</span>
                public void run() {
<span class="nc" id="L324">                    initSurfaceNow(width, height);</span>
<span class="nc" id="L325">                }</span>
            });
        } finally {
<span class="nc" id="L328">            rq.unlock();</span>
<span class="nc" id="L329">        }</span>
<span class="nc" id="L330">    }</span>

    /**
     * Returns the OGLContext for the GraphicsConfig associated with this
     * surface.
     */
    public final OGLContext getContext() {
<span class="nc" id="L337">        return graphicsConfig.getContext();</span>
    }

    /**
     * Returns the OGLGraphicsConfig associated with this surface.
     */
    final OGLGraphicsConfig getOGLGraphicsConfig() {
<span class="nc" id="L344">        return graphicsConfig;</span>
    }

    /**
     * Returns one of the surface type constants defined above.
     */
    public final int getType() {
<span class="nc" id="L351">        return type;</span>
    }

    /**
     * If this surface is backed by a texture object, returns the target
     * for that texture (either GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB).
     * Otherwise, this method will return zero.
     */
    public final int getTextureTarget() {
<span class="nc" id="L360">        return getTextureTarget(getNativeOps());</span>
    }

    /**
     * If this surface is backed by a texture object, returns the texture ID
     * for that texture.
     * Otherwise, this method will return zero.
     */
    public final int getTextureID() {
<span class="nc" id="L369">        return getTextureID(getNativeOps());</span>
    }

    /**
     * Returns native resource of specified {@code resType} associated with
     * this surface.
     *
     * Specifically, for {@code OGLSurfaceData} this method returns the
     * the following:
     * &lt;pre&gt;
     * TEXTURE              - texture id
     * &lt;/pre&gt;
     *
     * Note: the resource returned by this method is only valid on the rendering
     * thread.
     *
     * @return native resource of specified type or 0L if
     * such resource doesn't exist or can not be retrieved.
     * @see sun.java2d.pipe.hw.AccelSurface#getNativeResource
     */
    public long getNativeResource(int resType) {
<span class="nc bnc" id="L390" title="All 2 branches missed.">        if (resType == TEXTURE) {</span>
<span class="nc" id="L391">            return getTextureID();</span>
        }
<span class="nc" id="L393">        return 0L;</span>
    }

    public Raster getRaster(int x, int y, int w, int h) {
<span class="nc" id="L397">        throw new InternalError(&quot;not implemented yet&quot;);</span>
    }

    /**
     * For now, we can only render LCD text if:
     *   - the fragment shader extension is available, and
     *   - blending is disabled, and
     *   - the source color is opaque
     *   - and the destination is opaque
     *
     * Eventually, we could enhance the native OGL text rendering code
     * and remove the above restrictions, but that would require significantly
     * more code just to support a few uncommon cases.
     */
    public boolean canRenderLCDText(SunGraphics2D sg2d) {
<span class="nc" id="L412">        return</span>
<span class="nc bnc" id="L413" title="All 6 branches missed.">            graphicsConfig.isCapPresent(CAPS_EXT_LCD_SHADER) &amp;&amp;</span>
            sg2d.compositeState &lt;= SunGraphics2D.COMP_ISCOPY &amp;&amp;
            sg2d.paintState &lt;= SunGraphics2D.PAINT_OPAQUECOLOR &amp;&amp;
<span class="nc bnc" id="L416" title="All 2 branches missed.">            sg2d.surfaceData.getTransparency() == Transparency.OPAQUE;</span>
    }

    public void validatePipe(SunGraphics2D sg2d) {
        TextPipe textpipe;
<span class="nc" id="L421">        boolean validated = false;</span>

        // OGLTextRenderer handles both AA and non-AA text, but
        // only works with the following modes:
        // (Note: For LCD text we only enter this code path if
        // canRenderLCDText() has already validated that the mode is
        // CompositeType.SrcNoEa (opaque color), which will be subsumed
        // by the CompositeType.SrcNoEa (any color) test below.)

<span class="nc bnc" id="L430" title="All 8 branches missed.">        if (/* CompositeType.SrcNoEa (any color) */</span>
            (sg2d.compositeState &lt;= SunGraphics2D.COMP_ISCOPY &amp;&amp;
             sg2d.paintState &lt;= SunGraphics2D.PAINT_ALPHACOLOR)         ||

            /* CompositeType.SrcOver (any color) */
            (sg2d.compositeState == SunGraphics2D.COMP_ALPHA   &amp;&amp;
             sg2d.paintState &lt;= SunGraphics2D.PAINT_ALPHACOLOR &amp;&amp;
<span class="nc bnc" id="L437" title="All 6 branches missed.">             (((AlphaComposite)sg2d.composite).getRule() ==</span>
              AlphaComposite.SRC_OVER))                                 ||

            /* CompositeType.Xor (any color) */
            (sg2d.compositeState == SunGraphics2D.COMP_XOR &amp;&amp;
             sg2d.paintState &lt;= SunGraphics2D.PAINT_ALPHACOLOR))
        {
<span class="nc" id="L444">            textpipe = oglTextPipe;</span>
        } else {
            // do this to initialize textpipe correctly; we will attempt
            // to override the non-text pipes below
<span class="nc" id="L448">            super.validatePipe(sg2d);</span>
<span class="nc" id="L449">            textpipe = sg2d.textpipe;</span>
<span class="nc" id="L450">            validated = true;</span>
        }

<span class="nc" id="L453">        PixelToParallelogramConverter txPipe = null;</span>
<span class="nc" id="L454">        OGLRenderer nonTxPipe = null;</span>

<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (sg2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON) {</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">            if (sg2d.paintState &lt;= SunGraphics2D.PAINT_ALPHACOLOR) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                if (sg2d.compositeState &lt;= SunGraphics2D.COMP_XOR) {</span>
<span class="nc" id="L459">                    txPipe = oglTxRenderPipe;</span>
<span class="nc" id="L460">                    nonTxPipe = oglRenderPipe;</span>
                }
<span class="nc bnc" id="L462" title="All 2 branches missed.">            } else if (sg2d.compositeState &lt;= SunGraphics2D.COMP_ALPHA) {</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                if (OGLPaints.isValid(sg2d)) {</span>
<span class="nc" id="L464">                    txPipe = oglTxRenderPipe;</span>
<span class="nc" id="L465">                    nonTxPipe = oglRenderPipe;</span>
                }
                // custom paints handled by super.validatePipe() below
            }
        } else {
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (sg2d.paintState &lt;= SunGraphics2D.PAINT_ALPHACOLOR) {</span>
<span class="nc bnc" id="L471" title="All 6 branches missed.">                if (graphicsConfig.isCapPresent(CAPS_PS30) &amp;&amp;</span>
                    (sg2d.imageComp == CompositeType.SrcOverNoEa ||
                     sg2d.imageComp == CompositeType.SrcOver))
                {
<span class="nc bnc" id="L475" title="All 2 branches missed.">                    if (!validated) {</span>
<span class="nc" id="L476">                        super.validatePipe(sg2d);</span>
<span class="nc" id="L477">                        validated = true;</span>
                    }
<span class="nc" id="L479">                    PixelToParallelogramConverter aaConverter =</span>
                        new PixelToParallelogramConverter(sg2d.shapepipe,
                                                          oglAAPgramPipe,
                                                          1.0/8.0, 0.499,
                                                          false);
<span class="nc" id="L484">                    sg2d.drawpipe = aaConverter;</span>
<span class="nc" id="L485">                    sg2d.fillpipe = aaConverter;</span>
<span class="nc" id="L486">                    sg2d.shapepipe = aaConverter;</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">                } else if (sg2d.compositeState == SunGraphics2D.COMP_XOR) {</span>
                    // install the solid pipes when AA and XOR are both enabled
<span class="nc" id="L489">                    txPipe = oglTxRenderPipe;</span>
<span class="nc" id="L490">                    nonTxPipe = oglRenderPipe;</span>
                }
            }
            // other cases handled by super.validatePipe() below
        }

<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (txPipe != null) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            if (sg2d.transformState &gt;= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {</span>
<span class="nc" id="L498">                sg2d.drawpipe = txPipe;</span>
<span class="nc" id="L499">                sg2d.fillpipe = txPipe;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            } else if (sg2d.strokeState != SunGraphics2D.STROKE_THIN) {</span>
<span class="nc" id="L501">                sg2d.drawpipe = txPipe;</span>
<span class="nc" id="L502">                sg2d.fillpipe = nonTxPipe;</span>
            } else {
<span class="nc" id="L504">                sg2d.drawpipe = nonTxPipe;</span>
<span class="nc" id="L505">                sg2d.fillpipe = nonTxPipe;</span>
            }
            // Note that we use the transforming pipe here because it
            // will examine the shape and possibly perform an optimized
            // operation if it can be simplified.  The simplifications
            // will be valid for all STROKE and TRANSFORM types.
<span class="nc" id="L511">            sg2d.shapepipe = txPipe;</span>
        } else {
<span class="nc bnc" id="L513" title="All 2 branches missed.">            if (!validated) {</span>
<span class="nc" id="L514">                super.validatePipe(sg2d);</span>
            }
        }

        // install the text pipe based on our earlier decision
<span class="nc" id="L519">        sg2d.textpipe = textpipe;</span>

        // always override the image pipe with the specialized OGL pipe
<span class="nc" id="L522">        sg2d.imagepipe = oglImagePipe;</span>
<span class="nc" id="L523">    }</span>

    @Override
    protected MaskFill getMaskFill(SunGraphics2D sg2d) {
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (sg2d.paintState &gt; SunGraphics2D.PAINT_ALPHACOLOR) {</span>
            /*
             * We can only accelerate non-Color MaskFill operations if
             * all of the following conditions hold true:
             *   - there is an implementation for the given paintState
             *   - the current Paint can be accelerated for this destination
             *   - multitexturing is available (since we need to modulate
             *     the alpha mask texture with the paint texture)
             *
             * In all other cases, we return null, in which case the
             * validation code will choose a more general software-based loop.
             */
<span class="nc bnc" id="L539" title="All 2 branches missed.">            if (!OGLPaints.isValid(sg2d) ||</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">                !graphicsConfig.isCapPresent(CAPS_MULTITEXTURE))</span>
            {
<span class="nc" id="L542">                return null;</span>
            }
        }
<span class="nc" id="L545">        return super.getMaskFill(sg2d);</span>
    }

    public boolean copyArea(SunGraphics2D sg2d,
                            int x, int y, int w, int h, int dx, int dy)
    {
<span class="nc bnc" id="L551" title="All 4 branches missed.">        if (sg2d.transformState &lt; SunGraphics2D.TRANSFORM_TRANSLATESCALE &amp;&amp;</span>
            sg2d.compositeState &lt; SunGraphics2D.COMP_XOR)
        {
<span class="nc" id="L554">            x += sg2d.transX;</span>
<span class="nc" id="L555">            y += sg2d.transY;</span>

<span class="nc" id="L557">            oglRenderPipe.copyArea(sg2d, x, y, w, h, dx, dy);</span>

<span class="nc" id="L559">            return true;</span>
        }
<span class="nc" id="L561">        return false;</span>
    }

    public void flush() {
<span class="nc" id="L565">        invalidate();</span>
<span class="nc" id="L566">        OGLRenderQueue rq = OGLRenderQueue.getInstance();</span>
<span class="nc" id="L567">        rq.lock();</span>
        try {
            // make sure we have a current context before
            // disposing the native resources (e.g. texture object)
<span class="nc" id="L571">            OGLContext.setScratchSurface(graphicsConfig);</span>

<span class="nc" id="L573">            RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L574">            rq.ensureCapacityAndAlignment(12, 4);</span>
<span class="nc" id="L575">            buf.putInt(FLUSH_SURFACE);</span>
<span class="nc" id="L576">            buf.putLong(getNativeOps());</span>

            // this call is expected to complete synchronously, so flush now
<span class="nc" id="L579">            rq.flushNow();</span>
        } finally {
<span class="nc" id="L581">            rq.unlock();</span>
<span class="nc" id="L582">        }</span>
<span class="nc" id="L583">    }</span>

    /**
     * Disposes the native resources associated with the given OGLSurfaceData
     * (referenced by the pData parameter).  This method is invoked from
     * the native Dispose() method from the Disposer thread when the
     * Java-level OGLSurfaceData object is about to go away.  Note that we
     * also pass a reference to the native GLX/WGLGraphicsConfigInfo
     * (pConfigInfo) for the purposes of making a context current.
     */
    static void dispose(long pData, long pConfigInfo) {
<span class="nc" id="L594">        OGLRenderQueue rq = OGLRenderQueue.getInstance();</span>
<span class="nc" id="L595">        rq.lock();</span>
        try {
            // make sure we have a current context before
            // disposing the native resources (e.g. texture object)
<span class="nc" id="L599">            OGLContext.setScratchSurface(pConfigInfo);</span>

<span class="nc" id="L601">            RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L602">            rq.ensureCapacityAndAlignment(12, 4);</span>
<span class="nc" id="L603">            buf.putInt(DISPOSE_SURFACE);</span>
<span class="nc" id="L604">            buf.putLong(pData);</span>

            // this call is expected to complete synchronously, so flush now
<span class="nc" id="L607">            rq.flushNow();</span>
        } finally {
<span class="nc" id="L609">            rq.unlock();</span>
<span class="nc" id="L610">        }</span>
<span class="nc" id="L611">    }</span>

    static void swapBuffers(long window) {
<span class="nc" id="L614">        OGLRenderQueue rq = OGLRenderQueue.getInstance();</span>
<span class="nc" id="L615">        rq.lock();</span>
        try {
<span class="nc" id="L617">            RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L618">            rq.ensureCapacityAndAlignment(12, 4);</span>
<span class="nc" id="L619">            buf.putInt(SWAP_BUFFERS);</span>
<span class="nc" id="L620">            buf.putLong(window);</span>
<span class="nc" id="L621">            rq.flushNow();</span>
        } finally {
<span class="nc" id="L623">            rq.unlock();</span>
<span class="nc" id="L624">        }</span>
<span class="nc" id="L625">    }</span>

    /**
     * Returns true if OpenGL textures can have non-power-of-two dimensions
     * when using the basic GL_TEXTURE_2D target.
     */
    boolean isTexNonPow2Available() {
<span class="nc" id="L632">        return graphicsConfig.isCapPresent(CAPS_TEXNONPOW2);</span>
    }

    /**
     * Returns true if OpenGL textures can have non-power-of-two dimensions
     * when using the GL_TEXTURE_RECTANGLE_ARB target (only available when the
     * GL_ARB_texture_rectangle extension is present).
     */
    boolean isTexRectAvailable() {
<span class="nc" id="L641">        return graphicsConfig.isCapPresent(CAPS_EXT_TEXRECT);</span>
    }

    public Rectangle getNativeBounds() {
<span class="nc" id="L645">        OGLRenderQueue rq = OGLRenderQueue.getInstance();</span>
<span class="nc" id="L646">        rq.lock();</span>
        try {
<span class="nc" id="L648">            return new Rectangle(nativeWidth, nativeHeight);</span>
        } finally {
<span class="nc" id="L650">            rq.unlock();</span>
        }
    }

    /**
     * Returns true if the surface is an on-screen window surface or
     * a FBO texture attached to an on-screen CALayer.
     *
     * Needed by Mac OS X port.
     */
    boolean isOnScreen() {
<span class="nc bnc" id="L661" title="All 2 branches missed.">        return getType() == WINDOW;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>