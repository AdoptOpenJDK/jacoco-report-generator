<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>OGLRenderQueue.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.java2d.opengl</a> &gt; <span class="el_source">OGLRenderQueue.java</span></div><h1>OGLRenderQueue.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.java2d.opengl;

import sun.java2d.pipe.RenderBuffer;
import sun.java2d.pipe.RenderQueue;
import static sun.java2d.pipe.BufferedOpCodes.*;
import java.security.AccessController;
import java.security.PrivilegedAction;

/**
 * OGL-specific implementation of RenderQueue.  This class provides a
 * single (daemon) thread that is responsible for periodically flushing
 * the queue, thus ensuring that only one thread communicates with the native
 * OpenGL libraries for the entire process.
 */
public class OGLRenderQueue extends RenderQueue {

    private static OGLRenderQueue theInstance;
    private final QueueFlusher flusher;

<span class="nc" id="L45">    private OGLRenderQueue() {</span>
        /*
         * The thread must be a member of a thread group
         * which will not get GCed before VM exit.
         */
<span class="nc" id="L50">        flusher = AccessController.doPrivileged(new PrivilegedAction&lt;QueueFlusher&gt;() {</span>
            public QueueFlusher run() {
<span class="nc" id="L52">                ThreadGroup rootThreadGroup = Thread.currentThread().getThreadGroup();</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">                while (rootThreadGroup.getParent() != null) {</span>
<span class="nc" id="L54">                    rootThreadGroup = rootThreadGroup.getParent();</span>
                }
<span class="nc" id="L56">                return new QueueFlusher(rootThreadGroup);</span>
            }
        });
<span class="nc" id="L59">    }</span>

    /**
     * Returns the single OGLRenderQueue instance.  If it has not yet been
     * initialized, this method will first construct the single instance
     * before returning it.
     */
    public static synchronized OGLRenderQueue getInstance() {
<span class="nc bnc" id="L67" title="All 2 branches missed.">        if (theInstance == null) {</span>
<span class="nc" id="L68">            theInstance = new OGLRenderQueue();</span>
        }
<span class="nc" id="L70">        return theInstance;</span>
    }

    /**
     * Flushes the single OGLRenderQueue instance synchronously.  If an
     * OGLRenderQueue has not yet been instantiated, this method is a no-op.
     * This method is useful in the case of Toolkit.sync(), in which we want
     * to flush the OGL pipeline, but only if the OGL pipeline is currently
     * enabled.  Since this class has few external dependencies, callers need
     * not be concerned that calling this method will trigger initialization
     * of the OGL pipeline and related classes.
     */
    public static void sync() {
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (theInstance != null) {</span>
<span class="nc" id="L84">            theInstance.lock();</span>
            try {
<span class="nc" id="L86">                theInstance.ensureCapacity(4);</span>
<span class="nc" id="L87">                theInstance.getBuffer().putInt(SYNC);</span>
<span class="nc" id="L88">                theInstance.flushNow();</span>
            } finally {
<span class="nc" id="L90">                theInstance.unlock();</span>
<span class="nc" id="L91">            }</span>
        }
<span class="nc" id="L93">    }</span>

    /**
     * Disposes the native memory associated with the given native
     * graphics config info pointer on the single queue flushing thread.
     */
    public static void disposeGraphicsConfig(long pConfigInfo) {
<span class="nc" id="L100">        OGLRenderQueue rq = getInstance();</span>
<span class="nc" id="L101">        rq.lock();</span>
        try {
            // make sure we make the context associated with the given
            // GraphicsConfig current before disposing the native resources
<span class="nc" id="L105">            OGLContext.setScratchSurface(pConfigInfo);</span>

<span class="nc" id="L107">            RenderBuffer buf = rq.getBuffer();</span>
<span class="nc" id="L108">            rq.ensureCapacityAndAlignment(12, 4);</span>
<span class="nc" id="L109">            buf.putInt(DISPOSE_CONFIG);</span>
<span class="nc" id="L110">            buf.putLong(pConfigInfo);</span>

            // this call is expected to complete synchronously, so flush now
<span class="nc" id="L113">            rq.flushNow();</span>
        } finally {
<span class="nc" id="L115">            rq.unlock();</span>
<span class="nc" id="L116">        }</span>
<span class="nc" id="L117">    }</span>

    /**
     * Returns true if the current thread is the OGL QueueFlusher thread.
     */
    public static boolean isQueueFlusherThread() {
<span class="nc bnc" id="L123" title="All 2 branches missed.">        return (Thread.currentThread() == getInstance().flusher);</span>
    }

    public void flushNow() {
        // assert lock.isHeldByCurrentThread();
        try {
<span class="nc" id="L129">            flusher.flushNow();</span>
<span class="nc" id="L130">        } catch (Exception e) {</span>
<span class="nc" id="L131">            System.err.println(&quot;exception in flushNow:&quot;);</span>
<span class="nc" id="L132">            e.printStackTrace();</span>
<span class="nc" id="L133">        }</span>
<span class="nc" id="L134">    }</span>

    public void flushAndInvokeNow(Runnable r) {
        // assert lock.isHeldByCurrentThread();
        try {
<span class="nc" id="L139">            flusher.flushAndInvokeNow(r);</span>
<span class="nc" id="L140">        } catch (Exception e) {</span>
<span class="nc" id="L141">            System.err.println(&quot;exception in flushAndInvokeNow:&quot;);</span>
<span class="nc" id="L142">            e.printStackTrace();</span>
<span class="nc" id="L143">        }</span>
<span class="nc" id="L144">    }</span>

    private native void flushBuffer(long buf, int limit);

    private void flushBuffer() {
        // assert lock.isHeldByCurrentThread();
<span class="nc" id="L150">        int limit = buf.position();</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (limit &gt; 0) {</span>
            // process the queue
<span class="nc" id="L153">            flushBuffer(buf.getAddress(), limit);</span>
        }
        // reset the buffer position
<span class="nc" id="L156">        buf.clear();</span>
        // clear the set of references, since we no longer need them
<span class="nc" id="L158">        refSet.clear();</span>
<span class="nc" id="L159">    }</span>

    private class QueueFlusher extends Thread {
        private boolean needsFlush;
        private Runnable task;
        private Error error;

<span class="nc" id="L166">        public QueueFlusher(ThreadGroup threadGroup) {</span>
<span class="nc" id="L167">            super(threadGroup, &quot;Java2D Queue Flusher&quot;);</span>
<span class="nc" id="L168">            setDaemon(true);</span>
<span class="nc" id="L169">            setPriority(Thread.MAX_PRIORITY);</span>
<span class="nc" id="L170">            start();</span>
<span class="nc" id="L171">        }</span>

        public synchronized void flushNow() {
            // wake up the flusher
<span class="nc" id="L175">            needsFlush = true;</span>
<span class="nc" id="L176">            notify();</span>

            // wait for flush to complete
<span class="nc bnc" id="L179" title="All 2 branches missed.">            while (needsFlush) {</span>
                try {
<span class="nc" id="L181">                    wait();</span>
<span class="nc" id="L182">                } catch (InterruptedException e) {</span>
<span class="nc" id="L183">                }</span>
            }

            // re-throw any error that may have occurred during the flush
<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (error != null) {</span>
<span class="nc" id="L188">                throw error;</span>
            }
<span class="nc" id="L190">        }</span>

        public synchronized void flushAndInvokeNow(Runnable task) {
<span class="nc" id="L193">            this.task = task;</span>
<span class="nc" id="L194">            flushNow();</span>
<span class="nc" id="L195">        }</span>

        public synchronized void run() {
<span class="nc" id="L198">            boolean timedOut = false;</span>
            while (true) {
<span class="nc bnc" id="L200" title="All 2 branches missed.">                while (!needsFlush) {</span>
                    try {
<span class="nc" id="L202">                        timedOut = false;</span>
                        /*
                         * Wait until we're woken up with a flushNow() call,
                         * or the timeout period elapses (so that we can
                         * flush the queue periodically).
                         */
<span class="nc" id="L208">                        wait(100);</span>
                        /*
                         * We will automatically flush the queue if the
                         * following conditions apply:
                         *   - the wait() timed out
                         *   - we can lock the queue (without blocking)
                         *   - there is something in the queue to flush
                         * Otherwise, just continue (we'll flush eventually).
                         */
<span class="nc bnc" id="L217" title="All 4 branches missed.">                        if (!needsFlush &amp;&amp; (timedOut = tryLock())) {</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                            if (buf.position() &gt; 0) {</span>
<span class="nc" id="L219">                                needsFlush = true;</span>
                            } else {
<span class="nc" id="L221">                                unlock();</span>
                            }
                        }
<span class="nc" id="L224">                    } catch (InterruptedException e) {</span>
<span class="nc" id="L225">                    }</span>
                }
                try {
                    // reset the throwable state
<span class="nc" id="L229">                    error = null;</span>
                    // flush the buffer now
<span class="nc" id="L231">                    flushBuffer();</span>
                    // if there's a task, invoke that now as well
<span class="nc bnc" id="L233" title="All 2 branches missed.">                    if (task != null) {</span>
<span class="nc" id="L234">                        task.run();</span>
                    }
<span class="nc" id="L236">                } catch (Error e) {</span>
<span class="nc" id="L237">                    error = e;</span>
<span class="nc" id="L238">                } catch (Exception x) {</span>
<span class="nc" id="L239">                    System.err.println(&quot;exception in QueueFlusher:&quot;);</span>
<span class="nc" id="L240">                    x.printStackTrace();</span>
                } finally {
<span class="nc bnc" id="L242" title="All 8 branches missed.">                    if (timedOut) {</span>
<span class="nc" id="L243">                        unlock();</span>
                    }
<span class="nc" id="L245">                    task = null;</span>
                    // allow the waiting thread to continue
<span class="nc" id="L247">                    needsFlush = false;</span>
<span class="nc" id="L248">                    notify();</span>
<span class="nc" id="L249">                }</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>