<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Reifier.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.reflect.generics.visitor</a> &gt; <span class="el_source">Reifier.java</span></div><h1>Reifier.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.reflect.generics.visitor;


import java.lang.reflect.Type;
import java.util.List;
import java.util.Iterator;
import sun.reflect.generics.tree.*;
import sun.reflect.generics.factory.*;



/**
 * Visitor that converts AST to reified types.
 */
<span class="fc bfc" id="L40" title="All 2 branches covered.">public class Reifier implements TypeTreeVisitor&lt;Type&gt; {</span>
    private Type resultType;
    private GenericsFactory factory;

<span class="fc" id="L44">    private Reifier(GenericsFactory f){</span>
<span class="fc" id="L45">        factory = f;</span>
<span class="fc" id="L46">    }</span>

<span class="fc" id="L48">    private GenericsFactory getFactory(){ return factory;}</span>

    /**
     * Factory method. The resulting visitor will convert an AST
     * representing generic signatures into corresponding reflective
     * objects, using the provided factory, &lt;tt&gt;f&lt;/tt&gt;.
     * @param f - a factory that can be used to manufacture reflective
     * objects returned by this visitor
     * @return A visitor that can be used to reify ASTs representing
     * generic type information into reflective objects
     */
    public static Reifier make(GenericsFactory f){
<span class="fc" id="L60">        return new Reifier(f);</span>
    }

    // Helper method. Visits an array of TypeArgument and produces
    // reified Type array.
    private Type[] reifyTypeArguments(TypeArgument[] tas) {
<span class="fc" id="L66">        Type[] ts = new Type[tas.length];</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">        for (int i = 0; i &lt; tas.length; i++) {</span>
<span class="fc" id="L68">            tas[i].accept(this);</span>
<span class="fc" id="L69">            ts[i] = resultType;</span>
        }
<span class="fc" id="L71">        return ts;</span>
    }


    /**
     * Accessor for the result of the last visit by this visitor,
     * @return The type computed by this visitor based on its last
     * visit
     */
<span class="pc bpc" id="L80" title="1 of 4 branches missed.">    public Type getResult() { assert resultType != null;return resultType;}</span>

    public void visitFormalTypeParameter(FormalTypeParameter ftp){
<span class="fc" id="L83">        resultType = getFactory().makeTypeVariable(ftp.getName(),</span>
<span class="fc" id="L84">                                                   ftp.getBounds());</span>
<span class="fc" id="L85">    }</span>


    public void visitClassTypeSignature(ClassTypeSignature ct){
        // This method examines the pathname stored in ct, which has the form
        // n1.n2...nk&lt;targs&gt;....
        // where n1 ... nk-1 might not exist OR
        // nk might not exist (but not both). It may be that k equals 1.
        // The idea is that nk is the simple class type name that has
        // any type parameters associated with it.
        //  We process this path in two phases.
        //  First, we scan until we reach nk (if it exists).
        //  If nk does not exist, this identifies a raw class n1 ... nk-1
        // which we can return.
        // if nk does exist, we begin the 2nd phase.
        // Here nk defines a parameterized type. Every further step nj (j &gt; k)
        // down the path must also be represented as a parameterized type,
        // whose owner is the representation of the previous step in the path,
        // n{j-1}.

        // extract iterator on list of simple class type sigs
<span class="fc" id="L106">        List&lt;SimpleClassTypeSignature&gt; scts = ct.getPath();</span>
<span class="pc bpc" id="L107" title="1 of 4 branches missed.">        assert(!scts.isEmpty());</span>
<span class="fc" id="L108">        Iterator&lt;SimpleClassTypeSignature&gt; iter = scts.iterator();</span>
<span class="fc" id="L109">        SimpleClassTypeSignature sc = iter.next();</span>
<span class="fc" id="L110">        StringBuilder n = new StringBuilder(sc.getName());</span>
<span class="fc" id="L111">        boolean dollar = sc.getDollar();</span>

        // phase 1: iterate over simple class types until
        // we are either done or we hit one with non-empty type parameters
<span class="pc bpc" id="L115" title="1 of 4 branches missed.">        while (iter.hasNext() &amp;&amp; sc.getTypeArguments().length == 0) {</span>
<span class="nc" id="L116">            sc = iter.next();</span>
<span class="nc" id="L117">            dollar = sc.getDollar();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            n.append(dollar?&quot;$&quot;:&quot;.&quot;).append(sc.getName());</span>
        }

        // Now, either sc is the last element of the list, or
        // it has type arguments (or both)
<span class="pc bpc" id="L123" title="1 of 6 branches missed.">        assert(!(iter.hasNext()) || (sc.getTypeArguments().length &gt; 0));</span>
        // Create the raw type
<span class="fc" id="L125">        Type c = getFactory().makeNamedType(n.toString());</span>
        // if there are no type arguments
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (sc.getTypeArguments().length == 0) {</span>
            //we have surely reached the end of the path
<span class="pc bpc" id="L129" title="1 of 4 branches missed.">            assert(!iter.hasNext());</span>
<span class="fc" id="L130">            resultType = c; // the result is the raw type</span>
        } else {
<span class="pc bpc" id="L132" title="2 of 4 branches missed.">            assert(sc.getTypeArguments().length &gt; 0);</span>
            // otherwise, we have type arguments, so we create a parameterized
            // type, whose declaration is the raw type c, and whose owner is
            // the declaring class of c (if any). This latter fact is indicated
            // by passing null as the owner.
            // First, we reify the type arguments
<span class="fc" id="L138">            Type[] pts = reifyTypeArguments(sc.getTypeArguments());</span>

<span class="fc" id="L140">            Type owner = getFactory().makeParameterizedType(c, pts, null);</span>
            // phase 2: iterate over remaining simple class types
<span class="fc" id="L142">            dollar =false;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            while (iter.hasNext()) {</span>
<span class="fc" id="L144">                sc = iter.next();</span>
<span class="fc" id="L145">                dollar = sc.getDollar();</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">                n.append(dollar?&quot;$&quot;:&quot;.&quot;).append(sc.getName()); // build up raw class name</span>
<span class="fc" id="L147">                c = getFactory().makeNamedType(n.toString()); // obtain raw class</span>
<span class="fc" id="L148">                pts = reifyTypeArguments(sc.getTypeArguments());// reify params</span>
                // Create a parameterized type, based on type args, raw type
                // and previous owner
<span class="fc" id="L151">                owner = getFactory().makeParameterizedType(c, pts, owner);</span>
            }
<span class="fc" id="L153">            resultType = owner;</span>
        }
<span class="fc" id="L155">    }</span>

    public void visitArrayTypeSignature(ArrayTypeSignature a){
        // extract and reify component type
<span class="fc" id="L159">        a.getComponentType().accept(this);</span>
<span class="fc" id="L160">        Type ct = resultType;</span>
<span class="fc" id="L161">        resultType = getFactory().makeArrayType(ct);</span>
<span class="fc" id="L162">    }</span>

    public void visitTypeVariableSignature(TypeVariableSignature tv){
<span class="fc" id="L165">        resultType = getFactory().findTypeVariable(tv.getIdentifier());</span>
<span class="fc" id="L166">    }</span>

    public void visitWildcard(Wildcard w){
<span class="fc" id="L169">        resultType = getFactory().makeWildcard(w.getUpperBounds(),</span>
<span class="fc" id="L170">                                               w.getLowerBounds());</span>
<span class="fc" id="L171">    }</span>

    public void visitSimpleClassTypeSignature(SimpleClassTypeSignature sct){
<span class="fc" id="L174">        resultType = getFactory().makeNamedType(sct.getName());</span>
<span class="fc" id="L175">    }</span>

    public void visitBottomSignature(BottomSignature b){

<span class="nc" id="L179">    }</span>

    public void visitByteSignature(ByteSignature b){
<span class="nc" id="L182">        resultType = getFactory().makeByte();</span>
<span class="nc" id="L183">    }</span>

    public void visitBooleanSignature(BooleanSignature b){
<span class="fc" id="L186">        resultType = getFactory().makeBool();</span>
<span class="fc" id="L187">    }</span>

    public void visitShortSignature(ShortSignature s){
<span class="nc" id="L190">        resultType = getFactory().makeShort();</span>
<span class="nc" id="L191">    }</span>

    public void visitCharSignature(CharSignature c){
<span class="nc" id="L194">        resultType = getFactory().makeChar();</span>
<span class="nc" id="L195">    }</span>

    public void visitIntSignature(IntSignature i){
<span class="fc" id="L198">        resultType = getFactory().makeInt();</span>
<span class="fc" id="L199">    }</span>

    public void visitLongSignature(LongSignature l){
<span class="nc" id="L202">        resultType = getFactory().makeLong();</span>
<span class="nc" id="L203">    }</span>

    public void visitFloatSignature(FloatSignature f){
<span class="nc" id="L206">        resultType = getFactory().makeFloat();</span>
<span class="nc" id="L207">    }</span>

    public void visitDoubleSignature(DoubleSignature d){
<span class="nc" id="L210">        resultType = getFactory().makeDouble();</span>
<span class="nc" id="L211">    }</span>

    public void visitVoidDescriptor(VoidDescriptor v){
<span class="fc" id="L214">        resultType = getFactory().makeVoid();</span>
<span class="fc" id="L215">    }</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>