<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SetOfIntegerSyntax.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.print.attribute</a> &gt; <span class="el_source">SetOfIntegerSyntax.java</span></div><h1>SetOfIntegerSyntax.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package javax.print.attribute;

import java.io.Serializable;
import java.util.Vector;

/**
 * Class SetOfIntegerSyntax is an abstract base class providing the common
 * implementation of all attributes whose value is a set of nonnegative
 * integers. This includes attributes whose value is a single range of integers
 * and attributes whose value is a set of ranges of integers.
 * &lt;P&gt;
 * You can construct an instance of SetOfIntegerSyntax by giving it in &quot;string
 * form.&quot; The string consists of zero or more comma-separated integer groups.
 * Each integer group consists of either one integer, two integers separated by
 * a hyphen (&lt;CODE&gt;-&lt;/CODE&gt;), or two integers separated by a colon
 * (&lt;CODE&gt;:&lt;/CODE&gt;). Each integer consists of one or more decimal digits
 * (&lt;CODE&gt;0&lt;/CODE&gt; through &lt;CODE&gt;9&lt;/CODE&gt;). Whitespace characters cannot
 * appear within an integer but are otherwise ignored. For example:
 * &lt;CODE&gt;&quot;&quot;&lt;/CODE&gt;, &lt;CODE&gt;&quot;1&quot;&lt;/CODE&gt;, &lt;CODE&gt;&quot;5-10&quot;&lt;/CODE&gt;, &lt;CODE&gt;&quot;1:2,
 * 4&quot;&lt;/CODE&gt;.
 * &lt;P&gt;
 * You can also construct an instance of SetOfIntegerSyntax by giving it in
 * &quot;array form.&quot; Array form consists of an array of zero or more integer groups
 * where each integer group is a length-1 or length-2 array of
 * &lt;CODE&gt;int&lt;/CODE&gt;s; for example, &lt;CODE&gt;int[0][]&lt;/CODE&gt;,
 * &lt;CODE&gt;int[][]{{1}}&lt;/CODE&gt;, &lt;CODE&gt;int[][]{{5,10}}&lt;/CODE&gt;,
 * &lt;CODE&gt;int[][]{{1,2},{4}}&lt;/CODE&gt;.
 * &lt;P&gt;
 * In both string form and array form, each successive integer group gives a
 * range of integers to be included in the set. The first integer in each group
 * gives the lower bound of the range; the second integer in each group gives
 * the upper bound of the range; if there is only one integer in the group, the
 * upper bound is the same as the lower bound. If the upper bound is less than
 * the lower bound, it denotes a null range (no values). If the upper bound is
 * equal to the lower bound, it denotes a range consisting of a single value. If
 * the upper bound is greater than the lower bound, it denotes a range
 * consisting of more than one value. The ranges may appear in any order and are
 * allowed to overlap. The union of all the ranges gives the set's contents.
 * Once a SetOfIntegerSyntax instance is constructed, its value is immutable.
 * &lt;P&gt;
 * The SetOfIntegerSyntax object's value is actually stored in &quot;&lt;I&gt;canonical&lt;/I&gt;
 * array form.&quot; This is the same as array form, except there are no null ranges;
 * the members of the set are represented in as few ranges as possible (i.e.,
 * overlapping ranges are coalesced); the ranges appear in ascending order; and
 * each range is always represented as a length-two array of &lt;CODE&gt;int&lt;/CODE&gt;s
 * in the form {lower bound, upper bound}. An empty set is represented as a
 * zero-length array.
 * &lt;P&gt;
 * Class SetOfIntegerSyntax has operations to return the set's members in
 * canonical array form, to test whether a given integer is a member of the
 * set, and to iterate through the members of the set.
 * &lt;P&gt;
 *
 * @author  David Mendenhall
 * @author  Alan Kaminsky
 */
public abstract class SetOfIntegerSyntax implements Serializable, Cloneable {

    private static final long serialVersionUID = 3666874174847632203L;

    /**
     * This set's members in canonical array form.
     * @serial
     */
    private int[][] members;


    /**
     * Construct a new set-of-integer attribute with the given members in
     * string form.
     *
     * @param  members  Set members in string form. If null, an empty set is
     *                     constructed.
     *
     * @exception  IllegalArgumentException
     *     (Unchecked exception) Thrown if &lt;CODE&gt;members&lt;/CODE&gt; does not
     *    obey  the proper syntax.
     */
<span class="nc" id="L105">    protected SetOfIntegerSyntax(String members) {</span>
<span class="nc" id="L106">        this.members = parse (members);</span>
<span class="nc" id="L107">    }</span>

    /**
     * Parse the given string, returning canonical array form.
     */
    private static int[][] parse(String members) {
        // Create vector to hold int[] elements, each element being one range
        // parsed out of members.
<span class="nc" id="L115">        Vector theRanges = new Vector();</span>

        // Run state machine over members.
<span class="nc bnc" id="L118" title="All 2 branches missed.">        int n = (members == null ? 0 : members.length());</span>
<span class="nc" id="L119">        int i = 0;</span>
<span class="nc" id="L120">        int state = 0;</span>
<span class="nc" id="L121">        int lb = 0;</span>
<span class="nc" id="L122">        int ub = 0;</span>
        char c;
        int digit;
<span class="nc bnc" id="L125" title="All 2 branches missed.">        while (i &lt; n) {</span>
<span class="nc" id="L126">            c = members.charAt(i ++);</span>
<span class="nc bnc" id="L127" title="All 8 branches missed.">            switch (state) {</span>

            case 0: // Before first integer in first group
<span class="nc bnc" id="L130" title="All 2 branches missed.">                if (Character.isWhitespace(c)) {</span>
<span class="nc" id="L131">                    state = 0;</span>
                }
<span class="nc bnc" id="L133" title="All 2 branches missed.">                else if ((digit = Character.digit(c, 10)) != -1) {</span>
<span class="nc" id="L134">                    lb = digit;</span>
<span class="nc" id="L135">                    state = 1;</span>
                } else {
<span class="nc" id="L137">                    throw new IllegalArgumentException();</span>
                }
                break;

            case 1: // In first integer in a group
<span class="nc bnc" id="L142" title="All 2 branches missed.">                if (Character.isWhitespace(c)){</span>
<span class="nc" id="L143">                        state = 2;</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">                } else if ((digit = Character.digit(c, 10)) != -1) {</span>
<span class="nc" id="L145">                    lb = 10 * lb + digit;</span>
<span class="nc" id="L146">                    state = 1;</span>
<span class="nc bnc" id="L147" title="All 4 branches missed.">                } else if (c == '-' || c == ':') {</span>
<span class="nc" id="L148">                    state = 3;</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">                } else if (c == ',') {</span>
<span class="nc" id="L150">                    accumulate (theRanges, lb, lb);</span>
<span class="nc" id="L151">                    state = 6;</span>
                } else {
<span class="nc" id="L153">                    throw new IllegalArgumentException();</span>
                }
                break;

            case 2: // After first integer in a group
<span class="nc bnc" id="L158" title="All 2 branches missed.">                if (Character.isWhitespace(c)) {</span>
<span class="nc" id="L159">                    state = 2;</span>
                }
<span class="nc bnc" id="L161" title="All 4 branches missed.">                else if (c == '-' || c == ':') {</span>
<span class="nc" id="L162">                    state = 3;</span>
                }
<span class="nc bnc" id="L164" title="All 2 branches missed.">                else if (c == ',') {</span>
<span class="nc" id="L165">                    accumulate(theRanges, lb, lb);</span>
<span class="nc" id="L166">                    state = 6;</span>
                } else {
<span class="nc" id="L168">                    throw new IllegalArgumentException();</span>
                }
                break;

            case 3: // Before second integer in a group
<span class="nc bnc" id="L173" title="All 2 branches missed.">                if (Character.isWhitespace(c)) {</span>
<span class="nc" id="L174">                    state = 3;</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                } else if ((digit = Character.digit(c, 10)) != -1) {</span>
<span class="nc" id="L176">                    ub = digit;</span>
<span class="nc" id="L177">                    state = 4;</span>
                } else {
<span class="nc" id="L179">                    throw new IllegalArgumentException();</span>
                }
                break;

            case 4: // In second integer in a group
<span class="nc bnc" id="L184" title="All 2 branches missed.">                if (Character.isWhitespace(c)) {</span>
<span class="nc" id="L185">                    state = 5;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                } else if ((digit = Character.digit(c, 10)) != -1) {</span>
<span class="nc" id="L187">                    ub = 10 * ub + digit;</span>
<span class="nc" id="L188">                    state = 4;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                } else if (c == ',') {</span>
<span class="nc" id="L190">                    accumulate(theRanges, lb, ub);</span>
<span class="nc" id="L191">                    state = 6;</span>
                } else {
<span class="nc" id="L193">                    throw new IllegalArgumentException();</span>
                }
                break;

            case 5: // After second integer in a group
<span class="nc bnc" id="L198" title="All 2 branches missed.">                if (Character.isWhitespace(c)) {</span>
<span class="nc" id="L199">                    state = 5;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                } else if (c == ',') {</span>
<span class="nc" id="L201">                    accumulate(theRanges, lb, ub);</span>
<span class="nc" id="L202">                    state = 6;</span>
                } else {
<span class="nc" id="L204">                    throw new IllegalArgumentException();</span>
                }
                break;

            case 6: // Before first integer in second or later group
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (Character.isWhitespace(c)) {</span>
<span class="nc" id="L210">                    state = 6;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">                } else if ((digit = Character.digit(c, 10)) != -1) {</span>
<span class="nc" id="L212">                    lb = digit;</span>
<span class="nc" id="L213">                    state = 1;</span>
                } else {
<span class="nc" id="L215">                    throw new IllegalArgumentException();</span>
                }
<span class="nc" id="L217">                break;</span>
            }
        }

        // Finish off the state machine.
<span class="nc bnc" id="L222" title="All 5 branches missed.">        switch (state) {</span>
        case 0: // Before first integer in first group
<span class="nc" id="L224">            break;</span>
        case 1: // In first integer in a group
        case 2: // After first integer in a group
<span class="nc" id="L227">            accumulate(theRanges, lb, lb);</span>
<span class="nc" id="L228">            break;</span>
        case 4: // In second integer in a group
        case 5: // After second integer in a group
<span class="nc" id="L231">            accumulate(theRanges, lb, ub);</span>
<span class="nc" id="L232">            break;</span>
        case 3: // Before second integer in a group
        case 6: // Before first integer in second or later group
<span class="nc" id="L235">            throw new IllegalArgumentException();</span>
        }

        // Return canonical array form.
<span class="nc" id="L239">        return canonicalArrayForm (theRanges);</span>
    }

    /**
     * Accumulate the given range (lb .. ub) into the canonical array form
     * into the given vector of int[] objects.
     */
    private static void accumulate(Vector ranges, int lb,int ub) {
        // Make sure range is non-null.
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (lb &lt;= ub) {</span>
            // Stick range at the back of the vector.
<span class="nc" id="L250">            ranges.add(new int[] {lb, ub});</span>

            // Work towards the front of the vector to integrate the new range
            // with the existing ranges.
<span class="nc bnc" id="L254" title="All 2 branches missed.">            for (int j = ranges.size()-2; j &gt;= 0; -- j) {</span>
            // Get lower and upper bounds of the two ranges being compared.
<span class="nc" id="L256">                int[] rangea = (int[]) ranges.elementAt (j);</span>
<span class="nc" id="L257">                int lba = rangea[0];</span>
<span class="nc" id="L258">                int uba = rangea[1];</span>
<span class="nc" id="L259">                int[] rangeb = (int[]) ranges.elementAt (j+1);</span>
<span class="nc" id="L260">                int lbb = rangeb[0];</span>
<span class="nc" id="L261">                int ubb = rangeb[1];</span>

                /* If the two ranges overlap or are adjacent, coalesce them.
                 * The two ranges overlap if the larger lower bound is less
                 * than or equal to the smaller upper bound. The two ranges
                 * are adjacent if the larger lower bound is one greater
                 * than the smaller upper bound.
                 */
<span class="nc bnc" id="L269" title="All 2 branches missed.">                if (Math.max(lba, lbb) - Math.min(uba, ubb) &lt;= 1) {</span>
                    // The coalesced range is from the smaller lower bound to
                    // the larger upper bound.
<span class="nc" id="L272">                    ranges.setElementAt(new int[]</span>
<span class="nc" id="L273">                                           {Math.min(lba, lbb),</span>
<span class="nc" id="L274">                                                Math.max(uba, ubb)}, j);</span>
<span class="nc" id="L275">                    ranges.remove (j+1);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                } else if (lba &gt; lbb) {</span>

                    /* If the two ranges don't overlap and aren't adjacent but
                     * are out of order, swap them.
                     */
<span class="nc" id="L281">                    ranges.setElementAt (rangeb, j);</span>
<span class="nc" id="L282">                    ranges.setElementAt (rangea, j+1);</span>
                } else {
                /* If the two ranges don't overlap and aren't adjacent and
                 * aren't out of order, we're done early.
                 */
                    break;
                }
            }
        }
<span class="nc" id="L291">    }</span>

    /**
     * Convert the given vector of int[] objects to canonical array form.
     */
    private static int[][] canonicalArrayForm(Vector ranges) {
<span class="nc" id="L297">        return (int[][]) ranges.toArray (new int[ranges.size()][]);</span>
    }

    /**
     * Construct a new set-of-integer attribute with the given members in
     * array form.
     *
     * @param  members  Set members in array form. If null, an empty set is
     *                     constructed.
     *
     * @exception  NullPointerException
     *     (Unchecked exception) Thrown if any element of
     *     &lt;CODE&gt;members&lt;/CODE&gt; is null.
     * @exception  IllegalArgumentException
     *     (Unchecked exception) Thrown if any element of
     *     &lt;CODE&gt;members&lt;/CODE&gt; is not a length-one or length-two array or if
     *     any non-null range in &lt;CODE&gt;members&lt;/CODE&gt; has a lower bound less
     *     than zero.
     */
<span class="nc" id="L316">    protected SetOfIntegerSyntax(int[][] members) {</span>
<span class="nc" id="L317">        this.members = parse (members);</span>
<span class="nc" id="L318">    }</span>

    /**
     * Parse the given array form, returning canonical array form.
     */
    private static int[][] parse(int[][] members) {
        // Create vector to hold int[] elements, each element being one range
        // parsed out of members.
<span class="nc" id="L326">        Vector ranges = new Vector();</span>

        // Process all integer groups in members.
<span class="nc bnc" id="L329" title="All 2 branches missed.">        int n = (members == null ? 0 : members.length);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++ i) {</span>
            // Get lower and upper bounds of the range.
            int lb, ub;
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (members[i].length == 1) {</span>
<span class="nc" id="L334">                lb = ub = members[i][0];</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">            } else if (members[i].length == 2) {</span>
<span class="nc" id="L336">                lb = members[i][0];</span>
<span class="nc" id="L337">                ub = members[i][1];</span>
            } else {
<span class="nc" id="L339">                throw new IllegalArgumentException();</span>
            }

            // Verify valid bounds.
<span class="nc bnc" id="L343" title="All 4 branches missed.">            if (lb &lt;= ub &amp;&amp; lb &lt; 0) {</span>
<span class="nc" id="L344">                throw new IllegalArgumentException();</span>
            }

            // Accumulate the range.
<span class="nc" id="L348">            accumulate(ranges, lb, ub);</span>
        }

                // Return canonical array form.
<span class="nc" id="L352">                return canonicalArrayForm (ranges);</span>
                }

    /**
     * Construct a new set-of-integer attribute containing a single integer.
     *
     * @param  member  Set member.
     *
     * @exception  IllegalArgumentException
     *     (Unchecked exception) Thrown if &lt;CODE&gt;member&lt;/CODE&gt; is less than
     *     zero.
     */
<span class="nc" id="L364">    protected SetOfIntegerSyntax(int member) {</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (member &lt; 0) {</span>
<span class="nc" id="L366">            throw new IllegalArgumentException();</span>
        }
<span class="nc" id="L368">        members = new int[][] {{member, member}};</span>
<span class="nc" id="L369">    }</span>

    /**
     * Construct a new set-of-integer attribute containing a single range of
     * integers. If the lower bound is greater than the upper bound (a null
     * range), an empty set is constructed.
     *
     * @param  lowerBound  Lower bound of the range.
     * @param  upperBound  Upper bound of the range.
     *
     * @exception  IllegalArgumentException
     *     (Unchecked exception) Thrown if the range is non-null and
     *     &lt;CODE&gt;lowerBound&lt;/CODE&gt; is less than zero.
     */
<span class="nc" id="L383">    protected SetOfIntegerSyntax(int lowerBound, int upperBound) {</span>
<span class="nc bnc" id="L384" title="All 4 branches missed.">        if (lowerBound &lt;= upperBound &amp;&amp; lowerBound &lt; 0) {</span>
<span class="nc" id="L385">            throw new IllegalArgumentException();</span>
        }
<span class="nc bnc" id="L387" title="All 2 branches missed.">        members = lowerBound &lt;=upperBound ?</span>
            new int[][] {{lowerBound, upperBound}} :
            new int[0][];
<span class="nc" id="L390">    }</span>


    /**
     * Obtain this set-of-integer attribute's members in canonical array form.
     * The returned array is &quot;safe;&quot; the client may alter it without affecting
     * this set-of-integer attribute.
     *
     * @return  This set-of-integer attribute's members in canonical array form.
     */
    public int[][] getMembers() {
<span class="nc" id="L401">        int n = members.length;</span>
<span class="nc" id="L402">        int[][] result = new int[n][];</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++ i) {</span>
<span class="nc" id="L404">            result[i] = new int[] {members[i][0], members[i][1]};</span>
        }
<span class="nc" id="L406">        return result;</span>
    }

    /**
     * Determine if this set-of-integer attribute contains the given value.
     *
     * @param  x  Integer value.
     *
     * @return  True if this set-of-integer attribute contains the value
     *          &lt;CODE&gt;x&lt;/CODE&gt;, false otherwise.
     */
    public boolean contains(int x) {
        // Do a linear search to find the range that contains x, if any.
<span class="nc" id="L419">        int n = members.length;</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++ i) {</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (x &lt; members[i][0]) {</span>
<span class="nc" id="L422">                return false;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            } else if (x &lt;= members[i][1]) {</span>
<span class="nc" id="L424">                return true;</span>
            }
        }
<span class="nc" id="L427">        return false;</span>
    }

    /**
     * Determine if this set-of-integer attribute contains the given integer
     * attribute's value.
     *
     * @param  attribute  Integer attribute.
     *
     * @return  True if this set-of-integer attribute contains
     *          &lt;CODE&gt;theAttribute&lt;/CODE&gt;'s value, false otherwise.
     */
    public boolean contains(IntegerSyntax attribute) {
<span class="nc" id="L440">        return contains (attribute.getValue());</span>
    }

    /**
     * Determine the smallest integer in this set-of-integer attribute that is
     * greater than the given value. If there are no integers in this
     * set-of-integer attribute greater than the given value, &lt;CODE&gt;-1&lt;/CODE&gt; is
     * returned. (Since a set-of-integer attribute can only contain nonnegative
     * values, &lt;CODE&gt;-1&lt;/CODE&gt; will never appear in the set.) You can use the
     * &lt;CODE&gt;next()&lt;/CODE&gt; method to iterate through the integer values in a
     * set-of-integer attribute in ascending order, like this:
     * &lt;PRE&gt;
     *     SetOfIntegerSyntax attribute = . . .;
     *     int i = -1;
     *     while ((i = attribute.next (i)) != -1)
     *         {
     *         foo (i);
     *         }
     * &lt;/PRE&gt;
     *
     * @param  x  Integer value.
     *
     * @return  The smallest integer in this set-of-integer attribute that is
     *          greater than &lt;CODE&gt;x&lt;/CODE&gt;, or &lt;CODE&gt;-1&lt;/CODE&gt; if no integer in
     *          this set-of-integer attribute is greater than &lt;CODE&gt;x&lt;/CODE&gt;.
     */
    public int next(int x) {
        // Do a linear search to find the range that contains x, if any.
<span class="nc" id="L468">        int n = members.length;</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++ i) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (x &lt; members[i][0]) {</span>
<span class="nc" id="L471">                return members[i][0];</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            } else if (x &lt; members[i][1]) {</span>
<span class="nc" id="L473">                return x + 1;</span>
            }
        }
<span class="nc" id="L476">        return -1;</span>
    }

    /**
     * Returns whether this set-of-integer attribute is equivalent to the passed
     * in object. To be equivalent, all of the following conditions must be
     * true:
     * &lt;OL TYPE=1&gt;
     * &lt;LI&gt;
     * &lt;CODE&gt;object&lt;/CODE&gt; is not null.
     * &lt;LI&gt;
     * &lt;CODE&gt;object&lt;/CODE&gt; is an instance of class SetOfIntegerSyntax.
     * &lt;LI&gt;
     * This set-of-integer attribute's members and &lt;CODE&gt;object&lt;/CODE&gt;'s
     * members are the same.
     * &lt;/OL&gt;
     *
     * @param  object  Object to compare to.
     *
     * @return  True if &lt;CODE&gt;object&lt;/CODE&gt; is equivalent to this
     *          set-of-integer attribute, false otherwise.
     */
    public boolean equals(Object object) {
<span class="nc bnc" id="L499" title="All 4 branches missed.">        if (object != null &amp;&amp; object instanceof SetOfIntegerSyntax) {</span>
<span class="nc" id="L500">            int[][] myMembers = this.members;</span>
<span class="nc" id="L501">            int[][] otherMembers = ((SetOfIntegerSyntax) object).members;</span>
<span class="nc" id="L502">            int m = myMembers.length;</span>
<span class="nc" id="L503">            int n = otherMembers.length;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">            if (m == n) {</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                for (int i = 0; i &lt; m; ++ i) {</span>
<span class="nc bnc" id="L506" title="All 4 branches missed.">                    if (myMembers[i][0] != otherMembers[i][0] ||</span>
                        myMembers[i][1] != otherMembers[i][1]) {
<span class="nc" id="L508">                        return false;</span>
                    }
                }
<span class="nc" id="L511">                return true;</span>
            } else {
<span class="nc" id="L513">                return false;</span>
            }
        } else {
<span class="nc" id="L516">            return false;</span>
        }
    }

    /**
     * Returns a hash code value for this set-of-integer attribute. The hash
     * code is the sum of the lower and upper bounds of the ranges in the
     * canonical array form, or 0 for an empty set.
     */
    public int hashCode() {
<span class="nc" id="L526">        int result = 0;</span>
<span class="nc" id="L527">        int n = members.length;</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        for (int i = 0; i &lt; n; ++ i) {</span>
<span class="nc" id="L529">            result += members[i][0] + members[i][1];</span>
        }
<span class="nc" id="L531">        return result;</span>
    }

    /**
     * Returns a string value corresponding to this set-of-integer attribute.
     * The string value is a zero-length string if this set is empty. Otherwise,
     * the string value is a comma-separated list of the ranges in the canonical
     * array form, where each range is represented as &lt;CODE&gt;&quot;&lt;I&gt;i&lt;/I&gt;&quot;&lt;/CODE&gt; if
     * the lower bound equals the upper bound or
     * &lt;CODE&gt;&quot;&lt;I&gt;i&lt;/I&gt;-&lt;I&gt;j&lt;/I&gt;&quot;&lt;/CODE&gt; otherwise.
     */
    public String toString() {
<span class="nc" id="L543">        StringBuffer result = new StringBuffer();</span>
<span class="nc" id="L544">        int n = members.length;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            if (i &gt; 0) {</span>
<span class="nc" id="L547">                result.append (',');</span>
            }
<span class="nc" id="L549">            result.append (members[i][0]);</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">            if (members[i][0] != members[i][1]) {</span>
<span class="nc" id="L551">                result.append ('-');</span>
<span class="nc" id="L552">                result.append (members[i][1]);</span>
            }
        }
<span class="nc" id="L555">        return result.toString();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>