<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>TypeResolver.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.beans</a> &gt; <span class="el_source">TypeResolver.java</span></div><h1>TypeResolver.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package com.sun.beans;

import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.HashMap;
import java.util.Map;

import sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl;
import sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl;

/**
 * This is utility class to resolve types.
 *
 * @since 1.7
 *
 * @author Eamonn McManus
 * @author Sergey Malenkov
 */
<span class="nc bnc" id="L47" title="All 2 branches missed.">public final class TypeResolver {</span>

<span class="nc" id="L49">    private static final WeakCache&lt;Type, Map&lt;Type, Type&gt;&gt; CACHE = new WeakCache&lt;&gt;();</span>

    /**
     * Replaces the given {@code type} in an inherited method
     * with the actual type it has in the given {@code inClass}.
     *
     * &lt;p&gt;Although type parameters are not inherited by subclasses in the Java
     * language, they &lt;em&gt;are&lt;/em&gt; effectively inherited when using reflection.
     * For example, if you declare an interface like this...&lt;/p&gt;
     *
     * &lt;pre&gt;
     * public interface StringToIntMap extends Map&amp;lt;String,Integer&gt; {}
     * &lt;/pre&gt;
     *
     * &lt;p&gt;...then StringToIntMap.class.getMethods() will show that it has methods
     * like put(K,V) even though StringToIntMap has no type parameters.  The K
     * and V variables are the ones declared by Map, so
     * {@link TypeVariable#getGenericDeclaration()} will return Map.class.&lt;/p&gt;
     *
     * &lt;p&gt;The purpose of this method is to take a Type from a possibly-inherited
     * method and replace it with the correct Type for the inheriting class.
     * So given parameters of K and StringToIntMap.class in the above example,
     * this method will return String.&lt;/p&gt;
     *
     * @param inClass  the base class used to resolve
     * @param type     the type to resolve
     * @return a resolved type
     *
     * @see #getActualType(Class)
     * @see #resolve(Type,Type)
     */
    public static Type resolveInClass(Class&lt;?&gt; inClass, Type type) {
<span class="nc" id="L81">        return resolve(getActualType(inClass), type);</span>
    }

    /**
     * Replaces all {@code types} in the given array
     * with the actual types they have in the given {@code inClass}.
     *
     * @param inClass  the base class used to resolve
     * @param types    the array of types to resolve
     * @return an array of resolved types
     *
     * @see #getActualType(Class)
     * @see #resolve(Type,Type[])
     */
    public static Type[] resolveInClass(Class&lt;?&gt; inClass, Type[] types) {
<span class="nc" id="L96">        return resolve(getActualType(inClass), types);</span>
    }

    /**
     * Replaces type variables of the given {@code formal} type
     * with the types they stand for in the given {@code actual} type.
     *
     * &lt;p&gt;A ParameterizedType is a class with type parameters, and the values
     * of those parameters.  For example, Map&amp;lt;K,V&gt; is a generic class, and
     * a corresponding ParameterizedType might look like
     * Map&amp;lt;K=String,V=Integer&gt;.  Given such a ParameterizedType, this method
     * will replace K with String, or List&amp;lt;K&gt; with List&amp;ltString;, or
     * List&amp;lt;? super K&gt; with List&amp;lt;? super String&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The {@code actual} argument to this method can also be a Class.
     * In this case, either it is equivalent to a ParameterizedType with
     * no parameters (for example, Integer.class), or it is equivalent to
     * a &quot;raw&quot; ParameterizedType (for example, Map.class).  In the latter
     * case, every type parameter declared or inherited by the class is replaced
     * by its &quot;erasure&quot;.  For a type parameter declared as &amp;lt;T&gt;, the erasure
     * is Object.  For a type parameter declared as &amp;lt;T extends Number&gt;,
     * the erasure is Number.&lt;/p&gt;
     *
     * &lt;p&gt;Although type parameters are not inherited by subclasses in the Java
     * language, they &lt;em&gt;are&lt;/em&gt; effectively inherited when using reflection.
     * For example, if you declare an interface like this...&lt;/p&gt;
     *
     * &lt;pre&gt;
     * public interface StringToIntMap extends Map&amp;lt;String,Integer&gt; {}
     * &lt;/pre&gt;
     *
     * &lt;p&gt;...then StringToIntMap.class.getMethods() will show that it has methods
     * like put(K,V) even though StringToIntMap has no type parameters.  The K
     * and V variables are the ones declared by Map, so
     * {@link TypeVariable#getGenericDeclaration()} will return {@link Map Map.class}.&lt;/p&gt;
     *
     * &lt;p&gt;For this reason, this method replaces inherited type parameters too.
     * Therefore if this method is called with {@code actual} being
     * StringToIntMap.class and {@code formal} being the K from Map,
     * it will return {@link String String.class}.&lt;/p&gt;
     *
     * &lt;p&gt;In the case where {@code actual} is a &quot;raw&quot; ParameterizedType, the
     * inherited type parameters will also be replaced by their erasures.
     * The erasure of a Class is the Class itself, so a &quot;raw&quot; subinterface of
     * StringToIntMap will still show the K from Map as String.class.  But
     * in a case like this...
     *
     * &lt;pre&gt;
     * public interface StringToIntListMap extends Map&amp;lt;String,List&amp;lt;Integer&gt;&gt; {}
     * public interface RawStringToIntListMap extends StringToIntListMap {}
     * &lt;/pre&gt;
     *
     * &lt;p&gt;...the V inherited from Map will show up as List&amp;lt;Integer&gt; in
     * StringToIntListMap, but as plain List in RawStringToIntListMap.&lt;/p&gt;
     *
     * @param actual  the type that supplies bindings for type variables
     * @param formal  the type where occurrences of the variables
     *                in {@code actual} will be replaced by the corresponding bound values
     * @return a resolved type
     */
    public static Type resolve(Type actual, Type formal) {
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (formal instanceof Class) {</span>
<span class="nc" id="L158">            return formal;</span>
        }
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (formal instanceof GenericArrayType) {</span>
<span class="nc" id="L161">            Type comp = ((GenericArrayType) formal).getGenericComponentType();</span>
<span class="nc" id="L162">            comp = resolve(actual, comp);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            return (comp instanceof Class)</span>
<span class="nc" id="L164">                    ? Array.newInstance((Class&lt;?&gt;) comp, 0).getClass()</span>
<span class="nc" id="L165">                    : GenericArrayTypeImpl.make(comp);</span>
        }
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (formal instanceof ParameterizedType) {</span>
<span class="nc" id="L168">            ParameterizedType fpt = (ParameterizedType) formal;</span>
<span class="nc" id="L169">            Type[] actuals = resolve(actual, fpt.getActualTypeArguments());</span>
<span class="nc" id="L170">            return ParameterizedTypeImpl.make(</span>
<span class="nc" id="L171">                    (Class&lt;?&gt;) fpt.getRawType(), actuals, fpt.getOwnerType());</span>
        }
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (formal instanceof WildcardType) {</span>
<span class="nc" id="L174">            WildcardType fwt = (WildcardType) formal;</span>
<span class="nc" id="L175">            Type[] upper = resolve(actual, fwt.getUpperBounds());</span>
<span class="nc" id="L176">            Type[] lower = resolve(actual, fwt.getLowerBounds());</span>
<span class="nc" id="L177">            return new WildcardTypeImpl(upper, lower);</span>
        }
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (formal instanceof TypeVariable) {</span>
            Map&lt;Type, Type&gt; map;
<span class="nc" id="L181">            synchronized (CACHE) {</span>
<span class="nc" id="L182">                map = CACHE.get(actual);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">                if (map == null) {</span>
<span class="nc" id="L184">                    map = new HashMap&lt;&gt;();</span>
<span class="nc" id="L185">                    prepare(map, actual);</span>
<span class="nc" id="L186">                    CACHE.put(actual, map);</span>
                }
<span class="nc" id="L188">            }</span>
<span class="nc" id="L189">            Type result = map.get(formal);</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">            if (result == null || result.equals(formal)) {</span>
<span class="nc" id="L191">                return formal;</span>
            }
<span class="nc" id="L193">            result = fixGenericArray(result);</span>
            // A variable can be bound to another variable that is itself bound
            // to something.  For example, given:
            // class Super&lt;T&gt; {...}
            // class Mid&lt;X&gt; extends Super&lt;T&gt; {...}
            // class Sub extends Mid&lt;String&gt;
            // the variable T is bound to X, which is in turn bound to String.
            // So if we have to resolve T, we need the tail recursion here.
<span class="nc" id="L201">            return resolve(actual, result);</span>
        }
<span class="nc" id="L203">        throw new IllegalArgumentException(&quot;Bad Type kind: &quot; + formal.getClass());</span>
    }

    /**
     * Replaces type variables of all formal types in the given array
     * with the types they stand for in the given {@code actual} type.
     *
     * @param actual   the type that supplies bindings for type variables
     * @param formals  the array of types to resolve
     * @return an array of resolved types
     */
    public static Type[] resolve(Type actual, Type[] formals) {
<span class="nc" id="L215">        int length = formals.length;</span>
<span class="nc" id="L216">        Type[] actuals = new Type[length];</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L218">            actuals[i] = resolve(actual, formals[i]);</span>
        }
<span class="nc" id="L220">        return actuals;</span>
    }

    /**
     * Converts the given {@code type} to the corresponding class.
     * This method implements the concept of type erasure,
     * that is described in section 4.6 of
     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
     *
     * @param type  the array of types to convert
     * @return a corresponding class
     */
    public static Class&lt;?&gt; erase(Type type) {
<span class="nc bnc" id="L233" title="All 2 branches missed.">        if (type instanceof Class) {</span>
<span class="nc" id="L234">            return (Class&lt;?&gt;) type;</span>
        }
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (type instanceof ParameterizedType) {</span>
<span class="nc" id="L237">            ParameterizedType pt = (ParameterizedType) type;</span>
<span class="nc" id="L238">            return (Class&lt;?&gt;) pt.getRawType();</span>
        }
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (type instanceof TypeVariable) {</span>
<span class="nc" id="L241">            TypeVariable tv = (TypeVariable)type;</span>
<span class="nc" id="L242">            Type[] bounds = tv.getBounds();</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">            return (0 &lt; bounds.length)</span>
<span class="nc" id="L244">                    ? erase(bounds[0])</span>
                    : Object.class;
        }
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (type instanceof WildcardType) {</span>
<span class="nc" id="L248">            WildcardType wt = (WildcardType)type;</span>
<span class="nc" id="L249">            Type[] bounds = wt.getUpperBounds();</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            return (0 &lt; bounds.length)</span>
<span class="nc" id="L251">                    ? erase(bounds[0])</span>
                    : Object.class;
        }
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (type instanceof GenericArrayType) {</span>
<span class="nc" id="L255">            GenericArrayType gat = (GenericArrayType)type;</span>
<span class="nc" id="L256">            return Array.newInstance(erase(gat.getGenericComponentType()), 0).getClass();</span>
        }
<span class="nc" id="L258">        throw new IllegalArgumentException(&quot;Unknown Type kind: &quot; + type.getClass());</span>
    }

    /**
     * Converts all {@code types} in the given array
     * to the corresponding classes.
     *
     * @param types  the array of types to convert
     * @return an array of corresponding classes
     *
     * @see #erase(Type)
     */
    public static Class[] erase(Type[] types) {
<span class="nc" id="L271">        int length = types.length;</span>
<span class="nc" id="L272">        Class[] classes = new Class[length];</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L274">            classes[i] = TypeResolver.erase(types[i]);</span>
        }
<span class="nc" id="L276">        return classes;</span>
    }

    /**
     * Fills the map from type parameters
     * to types as seen by the given {@code type}.
     * The method is recursive because the {@code type}
     * inherits mappings from its parent classes and interfaces.
     * The {@code type} can be either a {@link Class Class}
     * or a {@link ParameterizedType ParameterizedType}.
     * If it is a {@link Class Class}, it is either equivalent
     * to a {@link ParameterizedType ParameterizedType} with no parameters,
     * or it represents the erasure of a {@link ParameterizedType ParameterizedType}.
     *
     * @param map   the mappings of all type variables
     * @param type  the next type in the hierarchy
     */
    private static void prepare(Map&lt;Type, Type&gt; map, Type type) {
<span class="nc bnc" id="L294" title="All 2 branches missed.">        Class&lt;?&gt; raw = (Class&lt;?&gt;)((type instanceof Class&lt;?&gt;)</span>
                ? type
<span class="nc" id="L296">                : ((ParameterizedType)type).getRawType());</span>

<span class="nc" id="L298">        TypeVariable&lt;?&gt;[] formals = raw.getTypeParameters();</span>

<span class="nc bnc" id="L300" title="All 2 branches missed.">        Type[] actuals = (type instanceof Class&lt;?&gt;)</span>
                ? formals
<span class="nc" id="L302">                : ((ParameterizedType)type).getActualTypeArguments();</span>

<span class="nc bnc" id="L304" title="All 4 branches missed.">        assert formals.length == actuals.length;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        for (int i = 0; i &lt; formals.length; i++) {</span>
<span class="nc" id="L306">            map.put(formals[i], actuals[i]);</span>
        }
<span class="nc" id="L308">        Type gSuperclass = raw.getGenericSuperclass();</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (gSuperclass != null) {</span>
<span class="nc" id="L310">            prepare(map, gSuperclass);</span>
        }
<span class="nc bnc" id="L312" title="All 2 branches missed.">        for (Type gInterface : raw.getGenericInterfaces()) {</span>
<span class="nc" id="L313">            prepare(map, gInterface);</span>
        }
        // If type is the raw version of a parameterized class, we type-erase
        // all of its type variables, including inherited ones.
<span class="nc bnc" id="L317" title="All 4 branches missed.">        if (type instanceof Class&lt;?&gt; &amp;&amp; formals.length &gt; 0) {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            for (Map.Entry&lt;Type, Type&gt; entry : map.entrySet()) {</span>
<span class="nc" id="L319">                entry.setValue(erase(entry.getValue()));</span>
<span class="nc" id="L320">            }</span>
        }
<span class="nc" id="L322">    }</span>

    /**
     * Replaces a {@link GenericArrayType GenericArrayType}
     * with plain array class where it is possible.
     * Bug &lt;a href=&quot;http://bugs.sun.com/view_bug.do?bug_id=5041784&quot;&gt;5041784&lt;/a&gt;
     * is that arrays of non-generic type sometimes show up
     * as {@link GenericArrayType GenericArrayType} when using reflection.
     * For example, a {@code String[]} might show up
     * as a {@link GenericArrayType GenericArrayType}
     * where {@link GenericArrayType#getGenericComponentType getGenericComponentType}
     * is {@code String.class}.  This violates the specification,
     * which says that {@link GenericArrayType GenericArrayType}
     * is used when the component type is a type variable or parameterized type.
     * We fit the specification here.
     *
     * @param type  the type to fix
     * @return a corresponding type for the generic array type,
     *         or the same type as {@code type}
     */
    private static Type fixGenericArray(Type type) {
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (type instanceof GenericArrayType) {</span>
<span class="nc" id="L344">            Type comp = ((GenericArrayType)type).getGenericComponentType();</span>
<span class="nc" id="L345">            comp = fixGenericArray(comp);</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (comp instanceof Class) {</span>
<span class="nc" id="L347">                return Array.newInstance((Class&lt;?&gt;)comp, 0).getClass();</span>
            }
        }
<span class="nc" id="L350">        return type;</span>
    }

    /**
     * Replaces a {@link Class Class} with type parameters
     * with a {@link ParameterizedType ParameterizedType}
     * where every parameter is bound to itself.
     * When calling {@link #resolveInClass} in the context of {@code inClass},
     * we can't just pass {@code inClass} as the {@code actual} parameter,
     * because if {@code inClass} has type parameters
     * that would be interpreted as accessing the raw type,
     * so we would get unwanted erasure.
     * This is why we bind each parameter to itself.
     * If {@code inClass} does have type parameters and has methods
     * where those parameters appear in the return type or argument types,
     * we will correctly leave those types alone.
     *
     * @param inClass  the base class used to resolve
     * @return a parameterized type for the class,
     *         or the same class as {@code inClass}
     */
    private static Type getActualType(Class&lt;?&gt; inClass) {
<span class="nc" id="L372">        Type[] params = inClass.getTypeParameters();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        return (params.length == 0)</span>
                ? inClass
<span class="nc" id="L375">                : ParameterizedTypeImpl.make(</span>
<span class="nc" id="L376">                        inClass, params, inClass.getEnclosingClass());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>