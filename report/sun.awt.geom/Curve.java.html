<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Curve.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.awt.geom</a> &gt; <span class="el_source">Curve.java</span></div><h1>Curve.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.geom;

import java.awt.geom.Rectangle2D;
import java.awt.geom.QuadCurve2D;
import java.awt.geom.CubicCurve2D;
import java.awt.geom.PathIterator;
import java.awt.geom.IllegalPathStateException;
import java.util.Vector;

public abstract class Curve {
    public static final int INCREASING = 1;
    public static final int DECREASING = -1;

    protected int direction;

    public static void insertMove(Vector curves, double x, double y) {
<span class="nc" id="L42">        curves.add(new Order0(x, y));</span>
<span class="nc" id="L43">    }</span>

    public static void insertLine(Vector curves,
                                  double x0, double y0,
                                  double x1, double y1)
    {
<span class="nc bnc" id="L49" title="All 2 branches missed.">        if (y0 &lt; y1) {</span>
<span class="nc" id="L50">            curves.add(new Order1(x0, y0,</span>
                                  x1, y1,
                                  INCREASING));
<span class="nc bnc" id="L53" title="All 2 branches missed.">        } else if (y0 &gt; y1) {</span>
<span class="nc" id="L54">            curves.add(new Order1(x1, y1,</span>
                                  x0, y0,
                                  DECREASING));
        } else {
            // Do not add horizontal lines
        }
<span class="nc" id="L60">    }</span>

    public static void insertQuad(Vector curves,
                                  double x0, double y0,
                                  double coords[])
    {
<span class="nc" id="L66">        double y1 = coords[3];</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">        if (y0 &gt; y1) {</span>
<span class="nc" id="L68">            Order2.insert(curves, coords,</span>
                          coords[2], y1,
                          coords[0], coords[1],
                          x0, y0,
                          DECREASING);
<span class="nc bnc" id="L73" title="All 4 branches missed.">        } else if (y0 == y1 &amp;&amp; y0 == coords[1]) {</span>
            // Do not add horizontal lines
<span class="nc" id="L75">            return;</span>
        } else {
<span class="nc" id="L77">            Order2.insert(curves, coords,</span>
                          x0, y0,
                          coords[0], coords[1],
                          coords[2], y1,
                          INCREASING);
        }
<span class="nc" id="L83">    }</span>

    public static void insertCubic(Vector curves,
                                   double x0, double y0,
                                   double coords[])
    {
<span class="nc" id="L89">        double y1 = coords[5];</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">        if (y0 &gt; y1) {</span>
<span class="nc" id="L91">            Order3.insert(curves, coords,</span>
                          coords[4], y1,
                          coords[2], coords[3],
                          coords[0], coords[1],
                          x0, y0,
                          DECREASING);
<span class="nc bnc" id="L97" title="All 6 branches missed.">        } else if (y0 == y1 &amp;&amp; y0 == coords[1] &amp;&amp; y0 == coords[3]) {</span>
            // Do not add horizontal lines
<span class="nc" id="L99">            return;</span>
        } else {
<span class="nc" id="L101">            Order3.insert(curves, coords,</span>
                          x0, y0,
                          coords[0], coords[1],
                          coords[2], coords[3],
                          coords[4], y1,
                          INCREASING);
        }
<span class="nc" id="L108">    }</span>

    /**
     * Calculates the number of times the given path
     * crosses the ray extending to the right from (px,py).
     * If the point lies on a part of the path,
     * then no crossings are counted for that intersection.
     * +1 is added for each crossing where the Y coordinate is increasing
     * -1 is added for each crossing where the Y coordinate is decreasing
     * The return value is the sum of all crossings for every segment in
     * the path.
     * The path must start with a SEG_MOVETO, otherwise an exception is
     * thrown.
     * The caller must check p[xy] for NaN values.
     * The caller may also reject infinite p[xy] values as well.
     */
    public static int pointCrossingsForPath(PathIterator pi,
                                            double px, double py)
    {
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (pi.isDone()) {</span>
<span class="nc" id="L128">            return 0;</span>
        }
<span class="nc" id="L130">        double coords[] = new double[6];</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (pi.currentSegment(coords) != PathIterator.SEG_MOVETO) {</span>
<span class="nc" id="L132">            throw new IllegalPathStateException(&quot;missing initial moveto &quot;+</span>
                                                &quot;in path definition&quot;);
        }
<span class="nc" id="L135">        pi.next();</span>
<span class="nc" id="L136">        double movx = coords[0];</span>
<span class="nc" id="L137">        double movy = coords[1];</span>
<span class="nc" id="L138">        double curx = movx;</span>
<span class="nc" id="L139">        double cury = movy;</span>
        double endx, endy;
<span class="nc" id="L141">        int crossings = 0;</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        while (!pi.isDone()) {</span>
<span class="nc bnc" id="L143" title="All 6 branches missed.">            switch (pi.currentSegment(coords)) {</span>
            case PathIterator.SEG_MOVETO:
<span class="nc bnc" id="L145" title="All 2 branches missed.">                if (cury != movy) {</span>
<span class="nc" id="L146">                    crossings += pointCrossingsForLine(px, py,</span>
                                                       curx, cury,
                                                       movx, movy);
                }
<span class="nc" id="L150">                movx = curx = coords[0];</span>
<span class="nc" id="L151">                movy = cury = coords[1];</span>
<span class="nc" id="L152">                break;</span>
            case PathIterator.SEG_LINETO:
<span class="nc" id="L154">                endx = coords[0];</span>
<span class="nc" id="L155">                endy = coords[1];</span>
<span class="nc" id="L156">                crossings += pointCrossingsForLine(px, py,</span>
                                                   curx, cury,
                                                   endx, endy);
<span class="nc" id="L159">                curx = endx;</span>
<span class="nc" id="L160">                cury = endy;</span>
<span class="nc" id="L161">                break;</span>
            case PathIterator.SEG_QUADTO:
<span class="nc" id="L163">                endx = coords[2];</span>
<span class="nc" id="L164">                endy = coords[3];</span>
<span class="nc" id="L165">                crossings += pointCrossingsForQuad(px, py,</span>
                                                   curx, cury,
                                                   coords[0], coords[1],
                                                   endx, endy, 0);
<span class="nc" id="L169">                curx = endx;</span>
<span class="nc" id="L170">                cury = endy;</span>
<span class="nc" id="L171">                break;</span>
            case PathIterator.SEG_CUBICTO:
<span class="nc" id="L173">                endx = coords[4];</span>
<span class="nc" id="L174">                endy = coords[5];</span>
<span class="nc" id="L175">                crossings += pointCrossingsForCubic(px, py,</span>
                                                    curx, cury,
                                                    coords[0], coords[1],
                                                    coords[2], coords[3],
                                                    endx, endy, 0);
<span class="nc" id="L180">                curx = endx;</span>
<span class="nc" id="L181">                cury = endy;</span>
<span class="nc" id="L182">                break;</span>
            case PathIterator.SEG_CLOSE:
<span class="nc bnc" id="L184" title="All 2 branches missed.">                if (cury != movy) {</span>
<span class="nc" id="L185">                    crossings += pointCrossingsForLine(px, py,</span>
                                                       curx, cury,
                                                       movx, movy);
                }
<span class="nc" id="L189">                curx = movx;</span>
<span class="nc" id="L190">                cury = movy;</span>
                break;
            }
<span class="nc" id="L193">            pi.next();</span>
        }
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (cury != movy) {</span>
<span class="nc" id="L196">            crossings += pointCrossingsForLine(px, py,</span>
                                               curx, cury,
                                               movx, movy);
        }
<span class="nc" id="L200">        return crossings;</span>
    }

    /**
     * Calculates the number of times the line from (x0,y0) to (x1,y1)
     * crosses the ray extending to the right from (px,py).
     * If the point lies on the line, then no crossings are recorded.
     * +1 is returned for a crossing where the Y coordinate is increasing
     * -1 is returned for a crossing where the Y coordinate is decreasing
     */
    public static int pointCrossingsForLine(double px, double py,
                                            double x0, double y0,
                                            double x1, double y1)
    {
<span class="nc bnc" id="L214" title="All 4 branches missed.">        if (py &lt;  y0 &amp;&amp; py &lt;  y1) return 0;</span>
<span class="nc bnc" id="L215" title="All 4 branches missed.">        if (py &gt;= y0 &amp;&amp; py &gt;= y1) return 0;</span>
        // assert(y0 != y1);
<span class="nc bnc" id="L217" title="All 4 branches missed.">        if (px &gt;= x0 &amp;&amp; px &gt;= x1) return 0;</span>
<span class="nc bnc" id="L218" title="All 6 branches missed.">        if (px &lt;  x0 &amp;&amp; px &lt;  x1) return (y0 &lt; y1) ? 1 : -1;</span>
<span class="nc" id="L219">        double xintercept = x0 + (py - y0) * (x1 - x0) / (y1 - y0);</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (px &gt;= xintercept) return 0;</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">        return (y0 &lt; y1) ? 1 : -1;</span>
    }

    /**
     * Calculates the number of times the quad from (x0,y0) to (x1,y1)
     * crosses the ray extending to the right from (px,py).
     * If the point lies on a part of the curve,
     * then no crossings are counted for that intersection.
     * the level parameter should be 0 at the top-level call and will count
     * up for each recursion level to prevent infinite recursion
     * +1 is added for each crossing where the Y coordinate is increasing
     * -1 is added for each crossing where the Y coordinate is decreasing
     */
    public static int pointCrossingsForQuad(double px, double py,
                                            double x0, double y0,
                                            double xc, double yc,
                                            double x1, double y1, int level)
    {
<span class="nc bnc" id="L239" title="All 6 branches missed.">        if (py &lt;  y0 &amp;&amp; py &lt;  yc &amp;&amp; py &lt;  y1) return 0;</span>
<span class="nc bnc" id="L240" title="All 6 branches missed.">        if (py &gt;= y0 &amp;&amp; py &gt;= yc &amp;&amp; py &gt;= y1) return 0;</span>
        // Note y0 could equal y1...
<span class="nc bnc" id="L242" title="All 6 branches missed.">        if (px &gt;= x0 &amp;&amp; px &gt;= xc &amp;&amp; px &gt;= x1) return 0;</span>
<span class="nc bnc" id="L243" title="All 6 branches missed.">        if (px &lt;  x0 &amp;&amp; px &lt;  xc &amp;&amp; px &lt;  x1) {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (py &gt;= y0) {</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">                if (py &lt; y1) return 1;</span>
            } else {
                // py &lt; y0
<span class="nc bnc" id="L248" title="All 2 branches missed.">                if (py &gt;= y1) return -1;</span>
            }
            // py outside of y01 range, and/or y0==y1
<span class="nc" id="L251">            return 0;</span>
        }
        // double precision only has 52 bits of mantissa
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (level &gt; 52) return pointCrossingsForLine(px, py, x0, y0, x1, y1);</span>
<span class="nc" id="L255">        double x0c = (x0 + xc) / 2;</span>
<span class="nc" id="L256">        double y0c = (y0 + yc) / 2;</span>
<span class="nc" id="L257">        double xc1 = (xc + x1) / 2;</span>
<span class="nc" id="L258">        double yc1 = (yc + y1) / 2;</span>
<span class="nc" id="L259">        xc = (x0c + xc1) / 2;</span>
<span class="nc" id="L260">        yc = (y0c + yc1) / 2;</span>
<span class="nc bnc" id="L261" title="All 4 branches missed.">        if (Double.isNaN(xc) || Double.isNaN(yc)) {</span>
            // [xy]c are NaN if any of [xy]0c or [xy]c1 are NaN
            // [xy]0c or [xy]c1 are NaN if any of [xy][0c1] are NaN
            // These values are also NaN if opposing infinities are added
<span class="nc" id="L265">            return 0;</span>
        }
<span class="nc" id="L267">        return (pointCrossingsForQuad(px, py,</span>
                                      x0, y0, x0c, y0c, xc, yc,
                                      level+1) +
<span class="nc" id="L270">                pointCrossingsForQuad(px, py,</span>
                                      xc, yc, xc1, yc1, x1, y1,
                                      level+1));
    }

    /**
     * Calculates the number of times the cubic from (x0,y0) to (x1,y1)
     * crosses the ray extending to the right from (px,py).
     * If the point lies on a part of the curve,
     * then no crossings are counted for that intersection.
     * the level parameter should be 0 at the top-level call and will count
     * up for each recursion level to prevent infinite recursion
     * +1 is added for each crossing where the Y coordinate is increasing
     * -1 is added for each crossing where the Y coordinate is decreasing
     */
    public static int pointCrossingsForCubic(double px, double py,
                                             double x0, double y0,
                                             double xc0, double yc0,
                                             double xc1, double yc1,
                                             double x1, double y1, int level)
    {
<span class="nc bnc" id="L291" title="All 8 branches missed.">        if (py &lt;  y0 &amp;&amp; py &lt;  yc0 &amp;&amp; py &lt;  yc1 &amp;&amp; py &lt;  y1) return 0;</span>
<span class="nc bnc" id="L292" title="All 8 branches missed.">        if (py &gt;= y0 &amp;&amp; py &gt;= yc0 &amp;&amp; py &gt;= yc1 &amp;&amp; py &gt;= y1) return 0;</span>
        // Note y0 could equal yc0...
<span class="nc bnc" id="L294" title="All 8 branches missed.">        if (px &gt;= x0 &amp;&amp; px &gt;= xc0 &amp;&amp; px &gt;= xc1 &amp;&amp; px &gt;= x1) return 0;</span>
<span class="nc bnc" id="L295" title="All 8 branches missed.">        if (px &lt;  x0 &amp;&amp; px &lt;  xc0 &amp;&amp; px &lt;  xc1 &amp;&amp; px &lt;  x1) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">            if (py &gt;= y0) {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                if (py &lt; y1) return 1;</span>
            } else {
                // py &lt; y0
<span class="nc bnc" id="L300" title="All 2 branches missed.">                if (py &gt;= y1) return -1;</span>
            }
            // py outside of y01 range, and/or y0==yc0
<span class="nc" id="L303">            return 0;</span>
        }
        // double precision only has 52 bits of mantissa
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (level &gt; 52) return pointCrossingsForLine(px, py, x0, y0, x1, y1);</span>
<span class="nc" id="L307">        double xmid = (xc0 + xc1) / 2;</span>
<span class="nc" id="L308">        double ymid = (yc0 + yc1) / 2;</span>
<span class="nc" id="L309">        xc0 = (x0 + xc0) / 2;</span>
<span class="nc" id="L310">        yc0 = (y0 + yc0) / 2;</span>
<span class="nc" id="L311">        xc1 = (xc1 + x1) / 2;</span>
<span class="nc" id="L312">        yc1 = (yc1 + y1) / 2;</span>
<span class="nc" id="L313">        double xc0m = (xc0 + xmid) / 2;</span>
<span class="nc" id="L314">        double yc0m = (yc0 + ymid) / 2;</span>
<span class="nc" id="L315">        double xmc1 = (xmid + xc1) / 2;</span>
<span class="nc" id="L316">        double ymc1 = (ymid + yc1) / 2;</span>
<span class="nc" id="L317">        xmid = (xc0m + xmc1) / 2;</span>
<span class="nc" id="L318">        ymid = (yc0m + ymc1) / 2;</span>
<span class="nc bnc" id="L319" title="All 4 branches missed.">        if (Double.isNaN(xmid) || Double.isNaN(ymid)) {</span>
            // [xy]mid are NaN if any of [xy]c0m or [xy]mc1 are NaN
            // [xy]c0m or [xy]mc1 are NaN if any of [xy][c][01] are NaN
            // These values are also NaN if opposing infinities are added
<span class="nc" id="L323">            return 0;</span>
        }
<span class="nc" id="L325">        return (pointCrossingsForCubic(px, py,</span>
                                       x0, y0, xc0, yc0,
                                       xc0m, yc0m, xmid, ymid, level+1) +
<span class="nc" id="L328">                pointCrossingsForCubic(px, py,</span>
                                       xmid, ymid, xmc1, ymc1,
                                       xc1, yc1, x1, y1, level+1));
    }

    /**
     * The rectangle intersection test counts the number of times
     * that the path crosses through the shadow that the rectangle
     * projects to the right towards (x =&gt; +INFINITY).
     *
     * During processing of the path it actually counts every time
     * the path crosses either or both of the top and bottom edges
     * of that shadow.  If the path enters from the top, the count
     * is incremented.  If it then exits back through the top, the
     * same way it came in, the count is decremented and there is
     * no impact on the winding count.  If, instead, the path exits
     * out the bottom, then the count is incremented again and a
     * full pass through the shadow is indicated by the winding count
     * having been incremented by 2.
     *
     * Thus, the winding count that it accumulates is actually double
     * the real winding count.  Since the path is continuous, the
     * final answer should be a multiple of 2, otherwise there is a
     * logic error somewhere.
     *
     * If the path ever has a direct hit on the rectangle, then a
     * special value is returned.  This special value terminates
     * all ongoing accumulation on up through the call chain and
     * ends up getting returned to the calling function which can
     * then produce an answer directly.  For intersection tests,
     * the answer is always &quot;true&quot; if the path intersects the
     * rectangle.  For containment tests, the answer is always
     * &quot;false&quot; if the path intersects the rectangle.  Thus, no
     * further processing is ever needed if an intersection occurs.
     */
    public static final int RECT_INTERSECTS = 0x80000000;

    /**
     * Accumulate the number of times the path crosses the shadow
     * extending to the right of the rectangle.  See the comment
     * for the RECT_INTERSECTS constant for more complete details.
     * The return value is the sum of all crossings for both the
     * top and bottom of the shadow for every segment in the path,
     * or the special value RECT_INTERSECTS if the path ever enters
     * the interior of the rectangle.
     * The path must start with a SEG_MOVETO, otherwise an exception is
     * thrown.
     * The caller must check r[xy]{min,max} for NaN values.
     */
    public static int rectCrossingsForPath(PathIterator pi,
                                           double rxmin, double rymin,
                                           double rxmax, double rymax)
    {
<span class="nc bnc" id="L381" title="All 4 branches missed.">        if (rxmax &lt;= rxmin || rymax &lt;= rymin) {</span>
<span class="nc" id="L382">            return 0;</span>
        }
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (pi.isDone()) {</span>
<span class="nc" id="L385">            return 0;</span>
        }
<span class="nc" id="L387">        double coords[] = new double[6];</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (pi.currentSegment(coords) != PathIterator.SEG_MOVETO) {</span>
<span class="nc" id="L389">            throw new IllegalPathStateException(&quot;missing initial moveto &quot;+</span>
                                                &quot;in path definition&quot;);
        }
<span class="nc" id="L392">        pi.next();</span>
        double curx, cury, movx, movy, endx, endy;
<span class="nc" id="L394">        curx = movx = coords[0];</span>
<span class="nc" id="L395">        cury = movy = coords[1];</span>
<span class="nc" id="L396">        int crossings = 0;</span>
<span class="nc bnc" id="L397" title="All 4 branches missed.">        while (crossings != RECT_INTERSECTS &amp;&amp; !pi.isDone()) {</span>
<span class="nc bnc" id="L398" title="All 6 branches missed.">            switch (pi.currentSegment(coords)) {</span>
            case PathIterator.SEG_MOVETO:
<span class="nc bnc" id="L400" title="All 4 branches missed.">                if (curx != movx || cury != movy) {</span>
<span class="nc" id="L401">                    crossings = rectCrossingsForLine(crossings,</span>
                                                     rxmin, rymin,
                                                     rxmax, rymax,
                                                     curx, cury,
                                                     movx, movy);
                }
                // Count should always be a multiple of 2 here.
                // assert((crossings &amp; 1) != 0);
<span class="nc" id="L409">                movx = curx = coords[0];</span>
<span class="nc" id="L410">                movy = cury = coords[1];</span>
<span class="nc" id="L411">                break;</span>
            case PathIterator.SEG_LINETO:
<span class="nc" id="L413">                endx = coords[0];</span>
<span class="nc" id="L414">                endy = coords[1];</span>
<span class="nc" id="L415">                crossings = rectCrossingsForLine(crossings,</span>
                                                 rxmin, rymin,
                                                 rxmax, rymax,
                                                 curx, cury,
                                                 endx, endy);
<span class="nc" id="L420">                curx = endx;</span>
<span class="nc" id="L421">                cury = endy;</span>
<span class="nc" id="L422">                break;</span>
            case PathIterator.SEG_QUADTO:
<span class="nc" id="L424">                endx = coords[2];</span>
<span class="nc" id="L425">                endy = coords[3];</span>
<span class="nc" id="L426">                crossings = rectCrossingsForQuad(crossings,</span>
                                                 rxmin, rymin,
                                                 rxmax, rymax,
                                                 curx, cury,
                                                 coords[0], coords[1],
                                                 endx, endy, 0);
<span class="nc" id="L432">                curx = endx;</span>
<span class="nc" id="L433">                cury = endy;</span>
<span class="nc" id="L434">                break;</span>
            case PathIterator.SEG_CUBICTO:
<span class="nc" id="L436">                endx = coords[4];</span>
<span class="nc" id="L437">                endy = coords[5];</span>
<span class="nc" id="L438">                crossings = rectCrossingsForCubic(crossings,</span>
                                                  rxmin, rymin,
                                                  rxmax, rymax,
                                                  curx, cury,
                                                  coords[0], coords[1],
                                                  coords[2], coords[3],
                                                  endx, endy, 0);
<span class="nc" id="L445">                curx = endx;</span>
<span class="nc" id="L446">                cury = endy;</span>
<span class="nc" id="L447">                break;</span>
            case PathIterator.SEG_CLOSE:
<span class="nc bnc" id="L449" title="All 4 branches missed.">                if (curx != movx || cury != movy) {</span>
<span class="nc" id="L450">                    crossings = rectCrossingsForLine(crossings,</span>
                                                     rxmin, rymin,
                                                     rxmax, rymax,
                                                     curx, cury,
                                                     movx, movy);
                }
<span class="nc" id="L456">                curx = movx;</span>
<span class="nc" id="L457">                cury = movy;</span>
                // Count should always be a multiple of 2 here.
                // assert((crossings &amp; 1) != 0);
                break;
            }
<span class="nc" id="L462">            pi.next();</span>
        }
<span class="nc bnc" id="L464" title="All 6 branches missed.">        if (crossings != RECT_INTERSECTS &amp;&amp; (curx != movx || cury != movy)) {</span>
<span class="nc" id="L465">            crossings = rectCrossingsForLine(crossings,</span>
                                             rxmin, rymin,
                                             rxmax, rymax,
                                             curx, cury,
                                             movx, movy);
        }
        // Count should always be a multiple of 2 here.
        // assert((crossings &amp; 1) != 0);
<span class="nc" id="L473">        return crossings;</span>
    }

    /**
     * Accumulate the number of times the line crosses the shadow
     * extending to the right of the rectangle.  See the comment
     * for the RECT_INTERSECTS constant for more complete details.
     */
    public static int rectCrossingsForLine(int crossings,
                                           double rxmin, double rymin,
                                           double rxmax, double rymax,
                                           double x0, double y0,
                                           double x1, double y1)
    {
<span class="nc bnc" id="L487" title="All 4 branches missed.">        if (y0 &gt;= rymax &amp;&amp; y1 &gt;= rymax) return crossings;</span>
<span class="nc bnc" id="L488" title="All 4 branches missed.">        if (y0 &lt;= rymin &amp;&amp; y1 &lt;= rymin) return crossings;</span>
<span class="nc bnc" id="L489" title="All 4 branches missed.">        if (x0 &lt;= rxmin &amp;&amp; x1 &lt;= rxmin) return crossings;</span>
<span class="nc bnc" id="L490" title="All 4 branches missed.">        if (x0 &gt;= rxmax &amp;&amp; x1 &gt;= rxmax) {</span>
            // Line is entirely to the right of the rect
            // and the vertical ranges of the two overlap by a non-empty amount
            // Thus, this line segment is partially in the &quot;right-shadow&quot;
            // Path may have done a complete crossing
            // Or path may have entered or exited the right-shadow
<span class="nc bnc" id="L496" title="All 2 branches missed.">            if (y0 &lt; y1) {</span>
                // y-increasing line segment...
                // We know that y0 &lt; rymax and y1 &gt; rymin
<span class="nc bnc" id="L499" title="All 2 branches missed.">                if (y0 &lt;= rymin) crossings++;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                if (y1 &gt;= rymax) crossings++;</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">            } else if (y1 &lt; y0) {</span>
                // y-decreasing line segment...
                // We know that y1 &lt; rymax and y0 &gt; rymin
<span class="nc bnc" id="L504" title="All 2 branches missed.">                if (y1 &lt;= rymin) crossings--;</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (y0 &gt;= rymax) crossings--;</span>
            }
<span class="nc" id="L507">            return crossings;</span>
        }
        // Remaining case:
        // Both x and y ranges overlap by a non-empty amount
        // First do trivial INTERSECTS rejection of the cases
        // where one of the endpoints is inside the rectangle.
<span class="nc bnc" id="L513" title="All 16 branches missed.">        if ((x0 &gt; rxmin &amp;&amp; x0 &lt; rxmax &amp;&amp; y0 &gt; rymin &amp;&amp; y0 &lt; rymax) ||</span>
            (x1 &gt; rxmin &amp;&amp; x1 &lt; rxmax &amp;&amp; y1 &gt; rymin &amp;&amp; y1 &lt; rymax))
        {
<span class="nc" id="L516">            return RECT_INTERSECTS;</span>
        }
        // Otherwise calculate the y intercepts and see where
        // they fall with respect to the rectangle
<span class="nc" id="L520">        double xi0 = x0;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        if (y0 &lt; rymin) {</span>
<span class="nc" id="L522">            xi0 += ((rymin - y0) * (x1 - x0) / (y1 - y0));</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">        } else if (y0 &gt; rymax) {</span>
<span class="nc" id="L524">            xi0 += ((rymax - y0) * (x1 - x0) / (y1 - y0));</span>
        }
<span class="nc" id="L526">        double xi1 = x1;</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (y1 &lt; rymin) {</span>
<span class="nc" id="L528">            xi1 += ((rymin - y1) * (x0 - x1) / (y0 - y1));</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">        } else if (y1 &gt; rymax) {</span>
<span class="nc" id="L530">            xi1 += ((rymax - y1) * (x0 - x1) / (y0 - y1));</span>
        }
<span class="nc bnc" id="L532" title="All 4 branches missed.">        if (xi0 &lt;= rxmin &amp;&amp; xi1 &lt;= rxmin) return crossings;</span>
<span class="nc bnc" id="L533" title="All 4 branches missed.">        if (xi0 &gt;= rxmax &amp;&amp; xi1 &gt;= rxmax) {</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">            if (y0 &lt; y1) {</span>
                // y-increasing line segment...
                // We know that y0 &lt; rymax and y1 &gt; rymin
<span class="nc bnc" id="L537" title="All 2 branches missed.">                if (y0 &lt;= rymin) crossings++;</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">                if (y1 &gt;= rymax) crossings++;</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">            } else if (y1 &lt; y0) {</span>
                // y-decreasing line segment...
                // We know that y1 &lt; rymax and y0 &gt; rymin
<span class="nc bnc" id="L542" title="All 2 branches missed.">                if (y1 &lt;= rymin) crossings--;</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">                if (y0 &gt;= rymax) crossings--;</span>
            }
<span class="nc" id="L545">            return crossings;</span>
        }
<span class="nc" id="L547">        return RECT_INTERSECTS;</span>
    }

    /**
     * Accumulate the number of times the quad crosses the shadow
     * extending to the right of the rectangle.  See the comment
     * for the RECT_INTERSECTS constant for more complete details.
     */
    public static int rectCrossingsForQuad(int crossings,
                                           double rxmin, double rymin,
                                           double rxmax, double rymax,
                                           double x0, double y0,
                                           double xc, double yc,
                                           double x1, double y1,
                                           int level)
    {
<span class="nc bnc" id="L563" title="All 6 branches missed.">        if (y0 &gt;= rymax &amp;&amp; yc &gt;= rymax &amp;&amp; y1 &gt;= rymax) return crossings;</span>
<span class="nc bnc" id="L564" title="All 6 branches missed.">        if (y0 &lt;= rymin &amp;&amp; yc &lt;= rymin &amp;&amp; y1 &lt;= rymin) return crossings;</span>
<span class="nc bnc" id="L565" title="All 6 branches missed.">        if (x0 &lt;= rxmin &amp;&amp; xc &lt;= rxmin &amp;&amp; x1 &lt;= rxmin) return crossings;</span>
<span class="nc bnc" id="L566" title="All 6 branches missed.">        if (x0 &gt;= rxmax &amp;&amp; xc &gt;= rxmax &amp;&amp; x1 &gt;= rxmax) {</span>
            // Quad is entirely to the right of the rect
            // and the vertical range of the 3 Y coordinates of the quad
            // overlaps the vertical range of the rect by a non-empty amount
            // We now judge the crossings solely based on the line segment
            // connecting the endpoints of the quad.
            // Note that we may have 0, 1, or 2 crossings as the control
            // point may be causing the Y range intersection while the
            // two endpoints are entirely above or below.
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (y0 &lt; y1) {</span>
                // y-increasing line segment...
<span class="nc bnc" id="L577" title="All 4 branches missed.">                if (y0 &lt;= rymin &amp;&amp; y1 &gt;  rymin) crossings++;</span>
<span class="nc bnc" id="L578" title="All 4 branches missed.">                if (y0 &lt;  rymax &amp;&amp; y1 &gt;= rymax) crossings++;</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">            } else if (y1 &lt; y0) {</span>
                // y-decreasing line segment...
<span class="nc bnc" id="L581" title="All 4 branches missed.">                if (y1 &lt;= rymin &amp;&amp; y0 &gt;  rymin) crossings--;</span>
<span class="nc bnc" id="L582" title="All 4 branches missed.">                if (y1 &lt;  rymax &amp;&amp; y0 &gt;= rymax) crossings--;</span>
            }
<span class="nc" id="L584">            return crossings;</span>
        }
        // The intersection of ranges is more complicated
        // First do trivial INTERSECTS rejection of the cases
        // where one of the endpoints is inside the rectangle.
<span class="nc bnc" id="L589" title="All 16 branches missed.">        if ((x0 &lt; rxmax &amp;&amp; x0 &gt; rxmin &amp;&amp; y0 &lt; rymax &amp;&amp; y0 &gt; rymin) ||</span>
            (x1 &lt; rxmax &amp;&amp; x1 &gt; rxmin &amp;&amp; y1 &lt; rymax &amp;&amp; y1 &gt; rymin))
        {
<span class="nc" id="L592">            return RECT_INTERSECTS;</span>
        }
        // Otherwise, subdivide and look for one of the cases above.
        // double precision only has 52 bits of mantissa
<span class="nc bnc" id="L596" title="All 2 branches missed.">        if (level &gt; 52) {</span>
<span class="nc" id="L597">            return rectCrossingsForLine(crossings,</span>
                                        rxmin, rymin, rxmax, rymax,
                                        x0, y0, x1, y1);
        }
<span class="nc" id="L601">        double x0c = (x0 + xc) / 2;</span>
<span class="nc" id="L602">        double y0c = (y0 + yc) / 2;</span>
<span class="nc" id="L603">        double xc1 = (xc + x1) / 2;</span>
<span class="nc" id="L604">        double yc1 = (yc + y1) / 2;</span>
<span class="nc" id="L605">        xc = (x0c + xc1) / 2;</span>
<span class="nc" id="L606">        yc = (y0c + yc1) / 2;</span>
<span class="nc bnc" id="L607" title="All 4 branches missed.">        if (Double.isNaN(xc) || Double.isNaN(yc)) {</span>
            // [xy]c are NaN if any of [xy]0c or [xy]c1 are NaN
            // [xy]0c or [xy]c1 are NaN if any of [xy][0c1] are NaN
            // These values are also NaN if opposing infinities are added
<span class="nc" id="L611">            return 0;</span>
        }
<span class="nc" id="L613">        crossings = rectCrossingsForQuad(crossings,</span>
                                         rxmin, rymin, rxmax, rymax,
                                         x0, y0, x0c, y0c, xc, yc,
                                         level+1);
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (crossings != RECT_INTERSECTS) {</span>
<span class="nc" id="L618">            crossings = rectCrossingsForQuad(crossings,</span>
                                             rxmin, rymin, rxmax, rymax,
                                             xc, yc, xc1, yc1, x1, y1,
                                             level+1);
        }
<span class="nc" id="L623">        return crossings;</span>
    }

    /**
     * Accumulate the number of times the cubic crosses the shadow
     * extending to the right of the rectangle.  See the comment
     * for the RECT_INTERSECTS constant for more complete details.
     */
    public static int rectCrossingsForCubic(int crossings,
                                            double rxmin, double rymin,
                                            double rxmax, double rymax,
                                            double x0,  double y0,
                                            double xc0, double yc0,
                                            double xc1, double yc1,
                                            double x1,  double y1,
                                            int level)
    {
<span class="nc bnc" id="L640" title="All 8 branches missed.">        if (y0 &gt;= rymax &amp;&amp; yc0 &gt;= rymax &amp;&amp; yc1 &gt;= rymax &amp;&amp; y1 &gt;= rymax) {</span>
<span class="nc" id="L641">            return crossings;</span>
        }
<span class="nc bnc" id="L643" title="All 8 branches missed.">        if (y0 &lt;= rymin &amp;&amp; yc0 &lt;= rymin &amp;&amp; yc1 &lt;= rymin &amp;&amp; y1 &lt;= rymin) {</span>
<span class="nc" id="L644">            return crossings;</span>
        }
<span class="nc bnc" id="L646" title="All 8 branches missed.">        if (x0 &lt;= rxmin &amp;&amp; xc0 &lt;= rxmin &amp;&amp; xc1 &lt;= rxmin &amp;&amp; x1 &lt;= rxmin) {</span>
<span class="nc" id="L647">            return crossings;</span>
        }
<span class="nc bnc" id="L649" title="All 8 branches missed.">        if (x0 &gt;= rxmax &amp;&amp; xc0 &gt;= rxmax &amp;&amp; xc1 &gt;= rxmax &amp;&amp; x1 &gt;= rxmax) {</span>
            // Cubic is entirely to the right of the rect
            // and the vertical range of the 4 Y coordinates of the cubic
            // overlaps the vertical range of the rect by a non-empty amount
            // We now judge the crossings solely based on the line segment
            // connecting the endpoints of the cubic.
            // Note that we may have 0, 1, or 2 crossings as the control
            // points may be causing the Y range intersection while the
            // two endpoints are entirely above or below.
<span class="nc bnc" id="L658" title="All 2 branches missed.">            if (y0 &lt; y1) {</span>
                // y-increasing line segment...
<span class="nc bnc" id="L660" title="All 4 branches missed.">                if (y0 &lt;= rymin &amp;&amp; y1 &gt;  rymin) crossings++;</span>
<span class="nc bnc" id="L661" title="All 4 branches missed.">                if (y0 &lt;  rymax &amp;&amp; y1 &gt;= rymax) crossings++;</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            } else if (y1 &lt; y0) {</span>
                // y-decreasing line segment...
<span class="nc bnc" id="L664" title="All 4 branches missed.">                if (y1 &lt;= rymin &amp;&amp; y0 &gt;  rymin) crossings--;</span>
<span class="nc bnc" id="L665" title="All 4 branches missed.">                if (y1 &lt;  rymax &amp;&amp; y0 &gt;= rymax) crossings--;</span>
            }
<span class="nc" id="L667">            return crossings;</span>
        }
        // The intersection of ranges is more complicated
        // First do trivial INTERSECTS rejection of the cases
        // where one of the endpoints is inside the rectangle.
<span class="nc bnc" id="L672" title="All 16 branches missed.">        if ((x0 &gt; rxmin &amp;&amp; x0 &lt; rxmax &amp;&amp; y0 &gt; rymin &amp;&amp; y0 &lt; rymax) ||</span>
            (x1 &gt; rxmin &amp;&amp; x1 &lt; rxmax &amp;&amp; y1 &gt; rymin &amp;&amp; y1 &lt; rymax))
        {
<span class="nc" id="L675">            return RECT_INTERSECTS;</span>
        }
        // Otherwise, subdivide and look for one of the cases above.
        // double precision only has 52 bits of mantissa
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (level &gt; 52) {</span>
<span class="nc" id="L680">            return rectCrossingsForLine(crossings,</span>
                                        rxmin, rymin, rxmax, rymax,
                                        x0, y0, x1, y1);
        }
<span class="nc" id="L684">        double xmid = (xc0 + xc1) / 2;</span>
<span class="nc" id="L685">        double ymid = (yc0 + yc1) / 2;</span>
<span class="nc" id="L686">        xc0 = (x0 + xc0) / 2;</span>
<span class="nc" id="L687">        yc0 = (y0 + yc0) / 2;</span>
<span class="nc" id="L688">        xc1 = (xc1 + x1) / 2;</span>
<span class="nc" id="L689">        yc1 = (yc1 + y1) / 2;</span>
<span class="nc" id="L690">        double xc0m = (xc0 + xmid) / 2;</span>
<span class="nc" id="L691">        double yc0m = (yc0 + ymid) / 2;</span>
<span class="nc" id="L692">        double xmc1 = (xmid + xc1) / 2;</span>
<span class="nc" id="L693">        double ymc1 = (ymid + yc1) / 2;</span>
<span class="nc" id="L694">        xmid = (xc0m + xmc1) / 2;</span>
<span class="nc" id="L695">        ymid = (yc0m + ymc1) / 2;</span>
<span class="nc bnc" id="L696" title="All 4 branches missed.">        if (Double.isNaN(xmid) || Double.isNaN(ymid)) {</span>
            // [xy]mid are NaN if any of [xy]c0m or [xy]mc1 are NaN
            // [xy]c0m or [xy]mc1 are NaN if any of [xy][c][01] are NaN
            // These values are also NaN if opposing infinities are added
<span class="nc" id="L700">            return 0;</span>
        }
<span class="nc" id="L702">        crossings = rectCrossingsForCubic(crossings,</span>
                                          rxmin, rymin, rxmax, rymax,
                                          x0, y0, xc0, yc0,
                                          xc0m, yc0m, xmid, ymid, level+1);
<span class="nc bnc" id="L706" title="All 2 branches missed.">        if (crossings != RECT_INTERSECTS) {</span>
<span class="nc" id="L707">            crossings = rectCrossingsForCubic(crossings,</span>
                                              rxmin, rymin, rxmax, rymax,
                                              xmid, ymid, xmc1, ymc1,
                                              xc1, yc1, x1, y1, level+1);
        }
<span class="nc" id="L712">        return crossings;</span>
    }

<span class="nc" id="L715">    public Curve(int direction) {</span>
<span class="nc" id="L716">        this.direction = direction;</span>
<span class="nc" id="L717">    }</span>

    public final int getDirection() {
<span class="nc" id="L720">        return direction;</span>
    }

    public final Curve getWithDirection(int direction) {
<span class="nc bnc" id="L724" title="All 2 branches missed.">        return (this.direction == direction ? this : getReversedCurve());</span>
    }

    public static double round(double v) {
        //return Math.rint(v*10)/10;
<span class="nc" id="L729">        return v;</span>
    }

    public static int orderof(double x1, double x2) {
<span class="nc bnc" id="L733" title="All 2 branches missed.">        if (x1 &lt; x2) {</span>
<span class="nc" id="L734">            return -1;</span>
        }
<span class="nc bnc" id="L736" title="All 2 branches missed.">        if (x1 &gt; x2) {</span>
<span class="nc" id="L737">            return 1;</span>
        }
<span class="nc" id="L739">        return 0;</span>
    }

    public static long signeddiffbits(double y1, double y2) {
<span class="nc" id="L743">        return (Double.doubleToLongBits(y1) - Double.doubleToLongBits(y2));</span>
    }
    public static long diffbits(double y1, double y2) {
<span class="nc" id="L746">        return Math.abs(Double.doubleToLongBits(y1) -</span>
<span class="nc" id="L747">                        Double.doubleToLongBits(y2));</span>
    }
    public static double prev(double v) {
<span class="nc" id="L750">        return Double.longBitsToDouble(Double.doubleToLongBits(v)-1);</span>
    }
    public static double next(double v) {
<span class="nc" id="L753">        return Double.longBitsToDouble(Double.doubleToLongBits(v)+1);</span>
    }

    public String toString() {
<span class="nc" id="L757">        return (&quot;Curve[&quot;+</span>
<span class="nc" id="L758">                getOrder()+&quot;, &quot;+</span>
<span class="nc" id="L759">                (&quot;(&quot;+round(getX0())+&quot;, &quot;+round(getY0())+&quot;), &quot;)+</span>
<span class="nc" id="L760">                controlPointString()+</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">                (&quot;(&quot;+round(getX1())+&quot;, &quot;+round(getY1())+&quot;), &quot;)+</span>
                (direction == INCREASING ? &quot;D&quot; : &quot;U&quot;)+
                &quot;]&quot;);
    }

    public String controlPointString() {
<span class="nc" id="L767">        return &quot;&quot;;</span>
    }

    public abstract int getOrder();

    public abstract double getXTop();
    public abstract double getYTop();
    public abstract double getXBot();
    public abstract double getYBot();

    public abstract double getXMin();
    public abstract double getXMax();

    public abstract double getX0();
    public abstract double getY0();
    public abstract double getX1();
    public abstract double getY1();

    public abstract double XforY(double y);
    public abstract double TforY(double y);
    public abstract double XforT(double t);
    public abstract double YforT(double t);
    public abstract double dXforT(double t, int deriv);
    public abstract double dYforT(double t, int deriv);

    public abstract double nextVertical(double t0, double t1);

    public int crossingsFor(double x, double y) {
<span class="nc bnc" id="L795" title="All 4 branches missed.">        if (y &gt;= getYTop() &amp;&amp; y &lt; getYBot()) {</span>
<span class="nc bnc" id="L796" title="All 6 branches missed.">            if (x &lt; getXMax() &amp;&amp; (x &lt; getXMin() || x &lt; XforY(y))) {</span>
<span class="nc" id="L797">                return 1;</span>
            }
        }
<span class="nc" id="L800">        return 0;</span>
    }

    public boolean accumulateCrossings(Crossings c) {
<span class="nc" id="L804">        double xhi = c.getXHi();</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">        if (getXMin() &gt;= xhi) {</span>
<span class="nc" id="L806">            return false;</span>
        }
<span class="nc" id="L808">        double xlo = c.getXLo();</span>
<span class="nc" id="L809">        double ylo = c.getYLo();</span>
<span class="nc" id="L810">        double yhi = c.getYHi();</span>
<span class="nc" id="L811">        double y0 = getYTop();</span>
<span class="nc" id="L812">        double y1 = getYBot();</span>
        double tstart, ystart, tend, yend;
<span class="nc bnc" id="L814" title="All 2 branches missed.">        if (y0 &lt; ylo) {</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">            if (y1 &lt;= ylo) {</span>
<span class="nc" id="L816">                return false;</span>
            }
<span class="nc" id="L818">            ystart = ylo;</span>
<span class="nc" id="L819">            tstart = TforY(ylo);</span>
        } else {
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if (y0 &gt;= yhi) {</span>
<span class="nc" id="L822">                return false;</span>
            }
<span class="nc" id="L824">            ystart = y0;</span>
<span class="nc" id="L825">            tstart = 0;</span>
        }
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (y1 &gt; yhi) {</span>
<span class="nc" id="L828">            yend = yhi;</span>
<span class="nc" id="L829">            tend = TforY(yhi);</span>
        } else {
<span class="nc" id="L831">            yend = y1;</span>
<span class="nc" id="L832">            tend = 1;</span>
        }
<span class="nc" id="L834">        boolean hitLo = false;</span>
<span class="nc" id="L835">        boolean hitHi = false;</span>
        while (true) {
<span class="nc" id="L837">            double x = XforT(tstart);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">            if (x &lt; xhi) {</span>
<span class="nc bnc" id="L839" title="All 4 branches missed.">                if (hitHi || x &gt; xlo) {</span>
<span class="nc" id="L840">                    return true;</span>
                }
<span class="nc" id="L842">                hitLo = true;</span>
            } else {
<span class="nc bnc" id="L844" title="All 2 branches missed.">                if (hitLo) {</span>
<span class="nc" id="L845">                    return true;</span>
                }
<span class="nc" id="L847">                hitHi = true;</span>
            }
<span class="nc bnc" id="L849" title="All 2 branches missed.">            if (tstart &gt;= tend) {</span>
<span class="nc" id="L850">                break;</span>
            }
<span class="nc" id="L852">            tstart = nextVertical(tstart, tend);</span>
<span class="nc" id="L853">        }</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">        if (hitLo) {</span>
<span class="nc" id="L855">            c.record(ystart, yend, direction);</span>
        }
<span class="nc" id="L857">        return false;</span>
    }

    public abstract void enlarge(Rectangle2D r);

    public Curve getSubCurve(double ystart, double yend) {
<span class="nc" id="L863">        return getSubCurve(ystart, yend, direction);</span>
    }

    public abstract Curve getReversedCurve();
    public abstract Curve getSubCurve(double ystart, double yend, int dir);

    public int compareTo(Curve that, double yrange[]) {
        /*
        System.out.println(this+&quot;.compareTo(&quot;+that+&quot;)&quot;);
        System.out.println(&quot;target range = &quot;+yrange[0]+&quot;=&gt;&quot;+yrange[1]);
        */
<span class="nc" id="L874">        double y0 = yrange[0];</span>
<span class="nc" id="L875">        double y1 = yrange[1];</span>
<span class="nc" id="L876">        y1 = Math.min(Math.min(y1, this.getYBot()), that.getYBot());</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">        if (y1 &lt;= yrange[0]) {</span>
<span class="nc" id="L878">            System.err.println(&quot;this == &quot;+this);</span>
<span class="nc" id="L879">            System.err.println(&quot;that == &quot;+that);</span>
<span class="nc" id="L880">            System.out.println(&quot;target range = &quot;+yrange[0]+&quot;=&gt;&quot;+yrange[1]);</span>
<span class="nc" id="L881">            throw new InternalError(&quot;backstepping from &quot;+yrange[0]+&quot; to &quot;+y1);</span>
        }
<span class="nc" id="L883">        yrange[1] = y1;</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">        if (this.getXMax() &lt;= that.getXMin()) {</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">            if (this.getXMin() == that.getXMax()) {</span>
<span class="nc" id="L886">                return 0;</span>
            }
<span class="nc" id="L888">            return -1;</span>
        }
<span class="nc bnc" id="L890" title="All 2 branches missed.">        if (this.getXMin() &gt;= that.getXMax()) {</span>
<span class="nc" id="L891">            return 1;</span>
        }
        // Parameter s for thi(s) curve and t for tha(t) curve
        // [st]0 = parameters for top of current section of interest
        // [st]1 = parameters for bottom of valid range
        // [st]h = parameters for hypothesis point
        // [d][xy]s = valuations of thi(s) curve at sh
        // [d][xy]t = valuations of tha(t) curve at th
<span class="nc" id="L899">        double s0 = this.TforY(y0);</span>
<span class="nc" id="L900">        double ys0 = this.YforT(s0);</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if (ys0 &lt; y0) {</span>
<span class="nc" id="L902">            s0 = refineTforY(s0, ys0, y0);</span>
<span class="nc" id="L903">            ys0 = this.YforT(s0);</span>
        }
<span class="nc" id="L905">        double s1 = this.TforY(y1);</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">        if (this.YforT(s1) &lt; y0) {</span>
<span class="nc" id="L907">            s1 = refineTforY(s1, this.YforT(s1), y0);</span>
            //System.out.println(&quot;s1 problem!&quot;);
        }
<span class="nc" id="L910">        double t0 = that.TforY(y0);</span>
<span class="nc" id="L911">        double yt0 = that.YforT(t0);</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">        if (yt0 &lt; y0) {</span>
<span class="nc" id="L913">            t0 = that.refineTforY(t0, yt0, y0);</span>
<span class="nc" id="L914">            yt0 = that.YforT(t0);</span>
        }
<span class="nc" id="L916">        double t1 = that.TforY(y1);</span>
<span class="nc bnc" id="L917" title="All 2 branches missed.">        if (that.YforT(t1) &lt; y0) {</span>
<span class="nc" id="L918">            t1 = that.refineTforY(t1, that.YforT(t1), y0);</span>
            //System.out.println(&quot;t1 problem!&quot;);
        }
<span class="nc" id="L921">        double xs0 = this.XforT(s0);</span>
<span class="nc" id="L922">        double xt0 = that.XforT(t0);</span>
<span class="nc" id="L923">        double scale = Math.max(Math.abs(y0), Math.abs(y1));</span>
<span class="nc" id="L924">        double ymin = Math.max(scale * 1E-14, 1E-300);</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">        if (fairlyClose(xs0, xt0)) {</span>
<span class="nc" id="L926">            double bump = ymin;</span>
<span class="nc" id="L927">            double maxbump = Math.min(ymin * 1E13, (y1 - y0) * .1);</span>
<span class="nc" id="L928">            double y = y0 + bump;</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">            while (y &lt;= y1) {</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">                if (fairlyClose(this.XforY(y), that.XforY(y))) {</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">                    if ((bump *= 2) &gt; maxbump) {</span>
<span class="nc" id="L932">                        bump = maxbump;</span>
                    }
                } else {
<span class="nc" id="L935">                    y -= bump;</span>
                    while (true) {
<span class="nc" id="L937">                        bump /= 2;</span>
<span class="nc" id="L938">                        double newy = y + bump;</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">                        if (newy &lt;= y) {</span>
<span class="nc" id="L940">                            break;</span>
                        }
<span class="nc bnc" id="L942" title="All 2 branches missed.">                        if (fairlyClose(this.XforY(newy), that.XforY(newy))) {</span>
<span class="nc" id="L943">                            y = newy;</span>
                        }
<span class="nc" id="L945">                    }</span>
                    break;
                }
<span class="nc" id="L948">                y += bump;</span>
            }
<span class="nc bnc" id="L950" title="All 2 branches missed.">            if (y &gt; y0) {</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">                if (y &lt; y1) {</span>
<span class="nc" id="L952">                    yrange[1] = y;</span>
                }
<span class="nc" id="L954">                return 0;</span>
            }
        }
        //double ymin = y1 * 1E-14;
<span class="nc bnc" id="L958" title="All 2 branches missed.">        if (ymin &lt;= 0) {</span>
<span class="nc" id="L959">            System.out.println(&quot;ymin = &quot;+ymin);</span>
        }
        /*
        System.out.println(&quot;s range = &quot;+s0+&quot; to &quot;+s1);
        System.out.println(&quot;t range = &quot;+t0+&quot; to &quot;+t1);
        */
<span class="nc bnc" id="L965" title="All 4 branches missed.">        while (s0 &lt; s1 &amp;&amp; t0 &lt; t1) {</span>
<span class="nc" id="L966">            double sh = this.nextVertical(s0, s1);</span>
<span class="nc" id="L967">            double xsh = this.XforT(sh);</span>
<span class="nc" id="L968">            double ysh = this.YforT(sh);</span>
<span class="nc" id="L969">            double th = that.nextVertical(t0, t1);</span>
<span class="nc" id="L970">            double xth = that.XforT(th);</span>
<span class="nc" id="L971">            double yth = that.YforT(th);</span>
            /*
            System.out.println(&quot;sh = &quot;+sh);
            System.out.println(&quot;th = &quot;+th);
            */
        try {
<span class="nc bnc" id="L977" title="All 2 branches missed.">            if (findIntersect(that, yrange, ymin, 0, 0,</span>
                              s0, xs0, ys0, sh, xsh, ysh,
                              t0, xt0, yt0, th, xth, yth)) {
<span class="nc" id="L980">                break;</span>
            }
<span class="nc" id="L982">        } catch (Throwable t) {</span>
<span class="nc" id="L983">            System.err.println(&quot;Error: &quot;+t);</span>
<span class="nc" id="L984">            System.err.println(&quot;y range was &quot;+yrange[0]+&quot;=&gt;&quot;+yrange[1]);</span>
<span class="nc" id="L985">            System.err.println(&quot;s y range is &quot;+ys0+&quot;=&gt;&quot;+ysh);</span>
<span class="nc" id="L986">            System.err.println(&quot;t y range is &quot;+yt0+&quot;=&gt;&quot;+yth);</span>
<span class="nc" id="L987">            System.err.println(&quot;ymin is &quot;+ymin);</span>
<span class="nc" id="L988">            return 0;</span>
<span class="nc" id="L989">        }</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">            if (ysh &lt; yth) {</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">                if (ysh &gt; yrange[0]) {</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">                    if (ysh &lt; yrange[1]) {</span>
<span class="nc" id="L993">                        yrange[1] = ysh;</span>
                    }
                    break;
                }
<span class="nc" id="L997">                s0 = sh;</span>
<span class="nc" id="L998">                xs0 = xsh;</span>
<span class="nc" id="L999">                ys0 = ysh;</span>
            } else {
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                if (yth &gt; yrange[0]) {</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">                    if (yth &lt; yrange[1]) {</span>
<span class="nc" id="L1003">                        yrange[1] = yth;</span>
                    }
                    break;
                }
<span class="nc" id="L1007">                t0 = th;</span>
<span class="nc" id="L1008">                xt0 = xth;</span>
<span class="nc" id="L1009">                yt0 = yth;</span>
            }
<span class="nc" id="L1011">        }</span>
<span class="nc" id="L1012">        double ymid = (yrange[0] + yrange[1]) / 2;</span>
        /*
        System.out.println(&quot;final this[&quot;+s0+&quot;, &quot;+sh+&quot;, &quot;+s1+&quot;]&quot;);
        System.out.println(&quot;final    y[&quot;+ys0+&quot;, &quot;+ysh+&quot;]&quot;);
        System.out.println(&quot;final that[&quot;+t0+&quot;, &quot;+th+&quot;, &quot;+t1+&quot;]&quot;);
        System.out.println(&quot;final    y[&quot;+yt0+&quot;, &quot;+yth+&quot;]&quot;);
        System.out.println(&quot;final order = &quot;+orderof(this.XforY(ymid),
                                                    that.XforY(ymid)));
        System.out.println(&quot;final range = &quot;+yrange[0]+&quot;=&gt;&quot;+yrange[1]);
        */
        /*
        System.out.println(&quot;final sx = &quot;+this.XforY(ymid));
        System.out.println(&quot;final tx = &quot;+that.XforY(ymid));
        System.out.println(&quot;final order = &quot;+orderof(this.XforY(ymid),
                                                    that.XforY(ymid)));
        */
<span class="nc" id="L1028">        return orderof(this.XforY(ymid), that.XforY(ymid));</span>
    }

    public static final double TMIN = 1E-3;

    public boolean findIntersect(Curve that, double yrange[], double ymin,
                                 int slevel, int tlevel,
                                 double s0, double xs0, double ys0,
                                 double s1, double xs1, double ys1,
                                 double t0, double xt0, double yt0,
                                 double t1, double xt1, double yt1)
    {
        /*
        String pad = &quot;        &quot;;
        pad = pad+pad+pad+pad+pad;
        pad = pad+pad;
        System.out.println(&quot;----------------------------------------------&quot;);
        System.out.println(pad.substring(0, slevel)+ys0);
        System.out.println(pad.substring(0, slevel)+ys1);
        System.out.println(pad.substring(0, slevel)+(s1-s0));
        System.out.println(&quot;-------&quot;);
        System.out.println(pad.substring(0, tlevel)+yt0);
        System.out.println(pad.substring(0, tlevel)+yt1);
        System.out.println(pad.substring(0, tlevel)+(t1-t0));
        */
<span class="nc bnc" id="L1053" title="All 4 branches missed.">        if (ys0 &gt; yt1 || yt0 &gt; ys1) {</span>
<span class="nc" id="L1054">            return false;</span>
        }
<span class="nc bnc" id="L1056" title="All 2 branches missed.">        if (Math.min(xs0, xs1) &gt; Math.max(xt0, xt1) ||</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">            Math.max(xs0, xs1) &lt; Math.min(xt0, xt1))</span>
        {
<span class="nc" id="L1059">            return false;</span>
        }
        // Bounding boxes intersect - back off the larger of
        // the two subcurves by half until they stop intersecting
        // (or until they get small enough to switch to a more
        //  intensive algorithm).
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        if (s1 - s0 &gt; TMIN) {</span>
<span class="nc" id="L1066">            double s = (s0 + s1) / 2;</span>
<span class="nc" id="L1067">            double xs = this.XforT(s);</span>
<span class="nc" id="L1068">            double ys = this.YforT(s);</span>
<span class="nc bnc" id="L1069" title="All 4 branches missed.">            if (s == s0 || s == s1) {</span>
<span class="nc" id="L1070">                System.out.println(&quot;s0 = &quot;+s0);</span>
<span class="nc" id="L1071">                System.out.println(&quot;s1 = &quot;+s1);</span>
<span class="nc" id="L1072">                throw new InternalError(&quot;no s progress!&quot;);</span>
            }
<span class="nc bnc" id="L1074" title="All 2 branches missed.">            if (t1 - t0 &gt; TMIN) {</span>
<span class="nc" id="L1075">                double t = (t0 + t1) / 2;</span>
<span class="nc" id="L1076">                double xt = that.XforT(t);</span>
<span class="nc" id="L1077">                double yt = that.YforT(t);</span>
<span class="nc bnc" id="L1078" title="All 4 branches missed.">                if (t == t0 || t == t1) {</span>
<span class="nc" id="L1079">                    System.out.println(&quot;t0 = &quot;+t0);</span>
<span class="nc" id="L1080">                    System.out.println(&quot;t1 = &quot;+t1);</span>
<span class="nc" id="L1081">                    throw new InternalError(&quot;no t progress!&quot;);</span>
                }
<span class="nc bnc" id="L1083" title="All 4 branches missed.">                if (ys &gt;= yt0 &amp;&amp; yt &gt;= ys0) {</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">                    if (findIntersect(that, yrange, ymin, slevel+1, tlevel+1,</span>
                                      s0, xs0, ys0, s, xs, ys,
                                      t0, xt0, yt0, t, xt, yt)) {
<span class="nc" id="L1087">                        return true;</span>
                    }
                }
<span class="nc bnc" id="L1090" title="All 2 branches missed.">                if (ys &gt;= yt) {</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">                    if (findIntersect(that, yrange, ymin, slevel+1, tlevel+1,</span>
                                      s0, xs0, ys0, s, xs, ys,
                                      t, xt, yt, t1, xt1, yt1)) {
<span class="nc" id="L1094">                        return true;</span>
                    }
                }
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                if (yt &gt;= ys) {</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">                    if (findIntersect(that, yrange, ymin, slevel+1, tlevel+1,</span>
                                      s, xs, ys, s1, xs1, ys1,
                                      t0, xt0, yt0, t, xt, yt)) {
<span class="nc" id="L1101">                        return true;</span>
                    }
                }
<span class="nc bnc" id="L1104" title="All 4 branches missed.">                if (ys1 &gt;= yt &amp;&amp; yt1 &gt;= ys) {</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                    if (findIntersect(that, yrange, ymin, slevel+1, tlevel+1,</span>
                                      s, xs, ys, s1, xs1, ys1,
                                      t, xt, yt, t1, xt1, yt1)) {
<span class="nc" id="L1108">                        return true;</span>
                    }
                }
<span class="nc" id="L1111">            } else {</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">                if (ys &gt;= yt0) {</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">                    if (findIntersect(that, yrange, ymin, slevel+1, tlevel,</span>
                                      s0, xs0, ys0, s, xs, ys,
                                      t0, xt0, yt0, t1, xt1, yt1)) {
<span class="nc" id="L1116">                        return true;</span>
                    }
                }
<span class="nc bnc" id="L1119" title="All 2 branches missed.">                if (yt1 &gt;= ys) {</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                    if (findIntersect(that, yrange, ymin, slevel+1, tlevel,</span>
                                      s, xs, ys, s1, xs1, ys1,
                                      t0, xt0, yt0, t1, xt1, yt1)) {
<span class="nc" id="L1123">                        return true;</span>
                    }
                }
            }
<span class="nc bnc" id="L1127" title="All 2 branches missed.">        } else if (t1 - t0 &gt; TMIN) {</span>
<span class="nc" id="L1128">            double t = (t0 + t1) / 2;</span>
<span class="nc" id="L1129">            double xt = that.XforT(t);</span>
<span class="nc" id="L1130">            double yt = that.YforT(t);</span>
<span class="nc bnc" id="L1131" title="All 4 branches missed.">            if (t == t0 || t == t1) {</span>
<span class="nc" id="L1132">                System.out.println(&quot;t0 = &quot;+t0);</span>
<span class="nc" id="L1133">                System.out.println(&quot;t1 = &quot;+t1);</span>
<span class="nc" id="L1134">                throw new InternalError(&quot;no t progress!&quot;);</span>
            }
<span class="nc bnc" id="L1136" title="All 2 branches missed.">            if (yt &gt;= ys0) {</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">                if (findIntersect(that, yrange, ymin, slevel, tlevel+1,</span>
                                  s0, xs0, ys0, s1, xs1, ys1,
                                  t0, xt0, yt0, t, xt, yt)) {
<span class="nc" id="L1140">                    return true;</span>
                }
            }
<span class="nc bnc" id="L1143" title="All 2 branches missed.">            if (ys1 &gt;= yt) {</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">                if (findIntersect(that, yrange, ymin, slevel, tlevel+1,</span>
                                  s0, xs0, ys0, s1, xs1, ys1,
                                  t, xt, yt, t1, xt1, yt1)) {
<span class="nc" id="L1147">                    return true;</span>
                }
            }
<span class="nc" id="L1150">        } else {</span>
            // No more subdivisions
<span class="nc" id="L1152">            double xlk = xs1 - xs0;</span>
<span class="nc" id="L1153">            double ylk = ys1 - ys0;</span>
<span class="nc" id="L1154">            double xnm = xt1 - xt0;</span>
<span class="nc" id="L1155">            double ynm = yt1 - yt0;</span>
<span class="nc" id="L1156">            double xmk = xt0 - xs0;</span>
<span class="nc" id="L1157">            double ymk = yt0 - ys0;</span>
<span class="nc" id="L1158">            double det = xnm * ylk - ynm * xlk;</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">            if (det != 0) {</span>
<span class="nc" id="L1160">                double detinv = 1 / det;</span>
<span class="nc" id="L1161">                double s = (xnm * ymk - ynm * xmk) * detinv;</span>
<span class="nc" id="L1162">                double t = (xlk * ymk - ylk * xmk) * detinv;</span>
<span class="nc bnc" id="L1163" title="All 8 branches missed.">                if (s &gt;= 0 &amp;&amp; s &lt;= 1 &amp;&amp; t &gt;= 0 &amp;&amp; t &lt;= 1) {</span>
<span class="nc" id="L1164">                    s = s0 + s * (s1 - s0);</span>
<span class="nc" id="L1165">                    t = t0 + t * (t1 - t0);</span>
<span class="nc bnc" id="L1166" title="All 8 branches missed.">                    if (s &lt; 0 || s &gt; 1 || t &lt; 0 || t &gt; 1) {</span>
<span class="nc" id="L1167">                        System.out.println(&quot;Uh oh!&quot;);</span>
                    }
<span class="nc" id="L1169">                    double y = (this.YforT(s) + that.YforT(t)) / 2;</span>
<span class="nc bnc" id="L1170" title="All 4 branches missed.">                    if (y &lt;= yrange[1] &amp;&amp; y &gt; yrange[0]) {</span>
<span class="nc" id="L1171">                        yrange[1] = y;</span>
<span class="nc" id="L1172">                        return true;</span>
                    }
                }
            }
            //System.out.println(&quot;Testing lines!&quot;);
        }
<span class="nc" id="L1178">        return false;</span>
    }

    public double refineTforY(double t0, double yt0, double y0) {
<span class="nc" id="L1182">        double t1 = 1;</span>
        while (true) {
<span class="nc" id="L1184">            double th = (t0 + t1) / 2;</span>
<span class="nc bnc" id="L1185" title="All 4 branches missed.">            if (th == t0 || th == t1) {</span>
<span class="nc" id="L1186">                return t1;</span>
            }
<span class="nc" id="L1188">            double y = YforT(th);</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">            if (y &lt; y0) {</span>
<span class="nc" id="L1190">                t0 = th;</span>
<span class="nc" id="L1191">                yt0 = y;</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">            } else if (y &gt; y0) {</span>
<span class="nc" id="L1193">                t1 = th;</span>
            } else {
<span class="nc" id="L1195">                return t1;</span>
            }
<span class="nc" id="L1197">        }</span>
    }

    public boolean fairlyClose(double v1, double v2) {
<span class="nc" id="L1201">        return (Math.abs(v1 - v2) &lt;</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">                Math.max(Math.abs(v1), Math.abs(v2)) * 1E-10);</span>
    }

    public abstract int getSegment(double coords[]);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>