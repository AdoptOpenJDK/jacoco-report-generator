<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Order2.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.awt.geom</a> &gt; <span class="el_source">Order2.java</span></div><h1>Order2.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.geom;

import java.awt.geom.Rectangle2D;
import java.awt.geom.PathIterator;
import java.awt.geom.QuadCurve2D;
import java.util.Vector;

final class Order2 extends Curve {
    private double x0;
    private double y0;
    private double cx0;
    private double cy0;
    private double x1;
    private double y1;
    private double xmin;
    private double xmax;

    private double xcoeff0;
    private double xcoeff1;
    private double xcoeff2;
    private double ycoeff0;
    private double ycoeff1;
    private double ycoeff2;

    public static void insert(Vector curves, double tmp[],
                              double x0, double y0,
                              double cx0, double cy0,
                              double x1, double y1,
                              int direction)
    {
<span class="nc" id="L56">        int numparams = getHorizontalParams(y0, cy0, y1, tmp);</span>
<span class="nc bnc" id="L57" title="All 2 branches missed.">        if (numparams == 0) {</span>
            // We are using addInstance here to avoid inserting horisontal
            // segments
<span class="nc" id="L60">            addInstance(curves, x0, y0, cx0, cy0, x1, y1, direction);</span>
<span class="nc" id="L61">            return;</span>
        }
        // assert(numparams == 1);
<span class="nc" id="L64">        double t = tmp[0];</span>
<span class="nc" id="L65">        tmp[0] = x0;  tmp[1] = y0;</span>
<span class="nc" id="L66">        tmp[2] = cx0; tmp[3] = cy0;</span>
<span class="nc" id="L67">        tmp[4] = x1;  tmp[5] = y1;</span>
<span class="nc" id="L68">        split(tmp, 0, t);</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">        int i0 = (direction == INCREASING)? 0 : 4;</span>
<span class="nc" id="L70">        int i1 = 4 - i0;</span>
<span class="nc" id="L71">        addInstance(curves, tmp[i0], tmp[i0 + 1], tmp[i0 + 2], tmp[i0 + 3],</span>
                    tmp[i0 + 4], tmp[i0 + 5], direction);
<span class="nc" id="L73">        addInstance(curves, tmp[i1], tmp[i1 + 1], tmp[i1 + 2], tmp[i1 + 3],</span>
                    tmp[i1 + 4], tmp[i1 + 5], direction);
<span class="nc" id="L75">    }</span>

    public static void addInstance(Vector curves,
                                   double x0, double y0,
                                   double cx0, double cy0,
                                   double x1, double y1,
                                   int direction) {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (y0 &gt; y1) {</span>
<span class="nc" id="L83">            curves.add(new Order2(x1, y1, cx0, cy0, x0, y0, -direction));</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        } else if (y1 &gt; y0) {</span>
<span class="nc" id="L85">            curves.add(new Order2(x0, y0, cx0, cy0, x1, y1, direction));</span>
        }
<span class="nc" id="L87">    }</span>

    /*
     * Return the count of the number of horizontal sections of the
     * specified quadratic Bezier curve.  Put the parameters for the
     * horizontal sections into the specified &lt;code&gt;ret&lt;/code&gt; array.
     * &lt;p&gt;
     * If we examine the parametric equation in t, we have:
     *     Py(t) = C0*(1-t)^2 + 2*CP*t*(1-t) + C1*t^2
     *           = C0 - 2*C0*t + C0*t^2 + 2*CP*t - 2*CP*t^2 + C1*t^2
     *           = C0 + (2*CP - 2*C0)*t + (C0 - 2*CP + C1)*t^2
     *     Py(t) = (C0 - 2*CP + C1)*t^2 + (2*CP - 2*C0)*t + (C0)
     * If we take the derivative, we get:
     *     Py(t) = At^2 + Bt + C
     *     dPy(t) = 2At + B = 0
     *     2*(C0 - 2*CP + C1)t + 2*(CP - C0) = 0
     *     2*(C0 - 2*CP + C1)t = 2*(C0 - CP)
     *     t = 2*(C0 - CP) / 2*(C0 - 2*CP + C1)
     *     t = (C0 - CP) / (C0 - CP + C1 - CP)
     * Note that this method will return 0 if the equation is a line,
     * which is either always horizontal or never horizontal.
     * Completely horizontal curves need to be eliminated by other
     * means outside of this method.
     */
    public static int getHorizontalParams(double c0, double cp, double c1,
                                          double ret[]) {
<span class="nc bnc" id="L113" title="All 4 branches missed.">        if (c0 &lt;= cp &amp;&amp; cp &lt;= c1) {</span>
<span class="nc" id="L114">            return 0;</span>
        }
<span class="nc" id="L116">        c0 -= cp;</span>
<span class="nc" id="L117">        c1 -= cp;</span>
<span class="nc" id="L118">        double denom = c0 + c1;</span>
        // If denom == 0 then cp == (c0+c1)/2 and we have a line.
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (denom == 0) {</span>
<span class="nc" id="L121">            return 0;</span>
        }
<span class="nc" id="L123">        double t = c0 / denom;</span>
        // No splits at t==0 and t==1
<span class="nc bnc" id="L125" title="All 4 branches missed.">        if (t &lt;= 0 || t &gt;= 1) {</span>
<span class="nc" id="L126">            return 0;</span>
        }
<span class="nc" id="L128">        ret[0] = t;</span>
<span class="nc" id="L129">        return 1;</span>
    }

    /*
     * Split the quadratic Bezier stored at coords[pos...pos+5] representing
     * the paramtric range [0..1] into two subcurves representing the
     * parametric subranges [0..t] and [t..1].  Store the results back
     * into the array at coords[pos...pos+5] and coords[pos+4...pos+9].
     */
    public static void split(double coords[], int pos, double t) {
        double x0, y0, cx, cy, x1, y1;
<span class="nc" id="L140">        coords[pos+8] = x1 = coords[pos+4];</span>
<span class="nc" id="L141">        coords[pos+9] = y1 = coords[pos+5];</span>
<span class="nc" id="L142">        cx = coords[pos+2];</span>
<span class="nc" id="L143">        cy = coords[pos+3];</span>
<span class="nc" id="L144">        x1 = cx + (x1 - cx) * t;</span>
<span class="nc" id="L145">        y1 = cy + (y1 - cy) * t;</span>
<span class="nc" id="L146">        x0 = coords[pos+0];</span>
<span class="nc" id="L147">        y0 = coords[pos+1];</span>
<span class="nc" id="L148">        x0 = x0 + (cx - x0) * t;</span>
<span class="nc" id="L149">        y0 = y0 + (cy - y0) * t;</span>
<span class="nc" id="L150">        cx = x0 + (x1 - x0) * t;</span>
<span class="nc" id="L151">        cy = y0 + (y1 - y0) * t;</span>
<span class="nc" id="L152">        coords[pos+2] = x0;</span>
<span class="nc" id="L153">        coords[pos+3] = y0;</span>
<span class="nc" id="L154">        coords[pos+4] = cx;</span>
<span class="nc" id="L155">        coords[pos+5] = cy;</span>
<span class="nc" id="L156">        coords[pos+6] = x1;</span>
<span class="nc" id="L157">        coords[pos+7] = y1;</span>
<span class="nc" id="L158">    }</span>

    public Order2(double x0, double y0,
                  double cx0, double cy0,
                  double x1, double y1,
                  int direction)
    {
<span class="nc" id="L165">        super(direction);</span>
        // REMIND: Better accuracy in the root finding methods would
        //  ensure that cy0 is in range.  As it stands, it is never
        //  more than &quot;1 mantissa bit&quot; out of range...
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (cy0 &lt; y0) {</span>
<span class="nc" id="L170">            cy0 = y0;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">        } else if (cy0 &gt; y1) {</span>
<span class="nc" id="L172">            cy0 = y1;</span>
        }
<span class="nc" id="L174">        this.x0 = x0;</span>
<span class="nc" id="L175">        this.y0 = y0;</span>
<span class="nc" id="L176">        this.cx0 = cx0;</span>
<span class="nc" id="L177">        this.cy0 = cy0;</span>
<span class="nc" id="L178">        this.x1 = x1;</span>
<span class="nc" id="L179">        this.y1 = y1;</span>
<span class="nc" id="L180">        xmin = Math.min(Math.min(x0, x1), cx0);</span>
<span class="nc" id="L181">        xmax = Math.max(Math.max(x0, x1), cx0);</span>
<span class="nc" id="L182">        xcoeff0 = x0;</span>
<span class="nc" id="L183">        xcoeff1 = cx0 + cx0 - x0 - x0;</span>
<span class="nc" id="L184">        xcoeff2 = x0 - cx0 - cx0 + x1;</span>
<span class="nc" id="L185">        ycoeff0 = y0;</span>
<span class="nc" id="L186">        ycoeff1 = cy0 + cy0 - y0 - y0;</span>
<span class="nc" id="L187">        ycoeff2 = y0 - cy0 - cy0 + y1;</span>
<span class="nc" id="L188">    }</span>

    public int getOrder() {
<span class="nc" id="L191">        return 2;</span>
    }

    public double getXTop() {
<span class="nc" id="L195">        return x0;</span>
    }

    public double getYTop() {
<span class="nc" id="L199">        return y0;</span>
    }

    public double getXBot() {
<span class="nc" id="L203">        return x1;</span>
    }

    public double getYBot() {
<span class="nc" id="L207">        return y1;</span>
    }

    public double getXMin() {
<span class="nc" id="L211">        return xmin;</span>
    }

    public double getXMax() {
<span class="nc" id="L215">        return xmax;</span>
    }

    public double getX0() {
<span class="nc bnc" id="L219" title="All 2 branches missed.">        return (direction == INCREASING) ? x0 : x1;</span>
    }

    public double getY0() {
<span class="nc bnc" id="L223" title="All 2 branches missed.">        return (direction == INCREASING) ? y0 : y1;</span>
    }

    public double getCX0() {
<span class="nc" id="L227">        return cx0;</span>
    }

    public double getCY0() {
<span class="nc" id="L231">        return cy0;</span>
    }

    public double getX1() {
<span class="nc bnc" id="L235" title="All 2 branches missed.">        return (direction == DECREASING) ? x0 : x1;</span>
    }

    public double getY1() {
<span class="nc bnc" id="L239" title="All 2 branches missed.">        return (direction == DECREASING) ? y0 : y1;</span>
    }

    public double XforY(double y) {
<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (y &lt;= y0) {</span>
<span class="nc" id="L244">            return x0;</span>
        }
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (y &gt;= y1) {</span>
<span class="nc" id="L247">            return x1;</span>
        }
<span class="nc" id="L249">        return XforT(TforY(y));</span>
    }

    public double TforY(double y) {
<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (y &lt;= y0) {</span>
<span class="nc" id="L254">            return 0;</span>
        }
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (y &gt;= y1) {</span>
<span class="nc" id="L257">            return 1;</span>
        }
<span class="nc" id="L259">        return TforY(y, ycoeff0, ycoeff1, ycoeff2);</span>
    }

    public static double TforY(double y,
                               double ycoeff0, double ycoeff1, double ycoeff2)
    {
        // The caller should have already eliminated y values
        // outside of the y0 to y1 range.
<span class="nc" id="L267">        ycoeff0 -= y;</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">        if (ycoeff2 == 0.0) {</span>
            // The quadratic parabola has degenerated to a line.
            // ycoeff1 should not be 0.0 since we have already eliminated
            // totally horizontal lines, but if it is, then we will generate
            // infinity here for the root, which will not be in the [0,1]
            // range so we will pass to the failure code below.
<span class="nc" id="L274">            double root = -ycoeff0 / ycoeff1;</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">            if (root &gt;= 0 &amp;&amp; root &lt;= 1) {</span>
<span class="nc" id="L276">                return root;</span>
            }
<span class="nc" id="L278">        } else {</span>
            // From Numerical Recipes, 5.6, Quadratic and Cubic Equations
<span class="nc" id="L280">            double d = ycoeff1 * ycoeff1 - 4.0 * ycoeff2 * ycoeff0;</span>
            // If d &lt; 0.0, then there are no roots
<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (d &gt;= 0.0) {</span>
<span class="nc" id="L283">                d = Math.sqrt(d);</span>
                // For accuracy, calculate one root using:
                //     (-ycoeff1 +/- d) / 2ycoeff2
                // and the other using:
                //     2ycoeff0 / (-ycoeff1 +/- d)
                // Choose the sign of the +/- so that ycoeff1+d
                // gets larger in magnitude
<span class="nc bnc" id="L290" title="All 2 branches missed.">                if (ycoeff1 &lt; 0.0) {</span>
<span class="nc" id="L291">                    d = -d;</span>
                }
<span class="nc" id="L293">                double q = (ycoeff1 + d) / -2.0;</span>
                // We already tested ycoeff2 for being 0 above
<span class="nc" id="L295">                double root = q / ycoeff2;</span>
<span class="nc bnc" id="L296" title="All 4 branches missed.">                if (root &gt;= 0 &amp;&amp; root &lt;= 1) {</span>
<span class="nc" id="L297">                    return root;</span>
                }
<span class="nc bnc" id="L299" title="All 2 branches missed.">                if (q != 0.0) {</span>
<span class="nc" id="L300">                    root = ycoeff0 / q;</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">                    if (root &gt;= 0 &amp;&amp; root &lt;= 1) {</span>
<span class="nc" id="L302">                        return root;</span>
                    }
                }
            }
        }
        /* We failed to find a root in [0,1].  What could have gone wrong?
         * First, remember that these curves are constructed to be monotonic
         * in Y and totally horizontal curves have already been eliminated.
         * Now keep in mind that the Y coefficients of the polynomial form
         * of the curve are calculated from the Y coordinates which define
         * our curve.  They should theoretically define the same curve,
         * but they can be off by a couple of bits of precision after the
         * math is done and so can represent a slightly modified curve.
         * This is normally not an issue except when we have solutions near
         * the endpoints.  Since the answers we get from solving the polynomial
         * may be off by a few bits that means that they could lie just a
         * few bits of precision outside the [0,1] range.
         *
         * Another problem could be that while the parametric curve defined
         * by the Y coordinates has a local minima or maxima at or just
         * outside of the endpoints, the polynomial form might express
         * that same min/max just inside of and just shy of the Y coordinate
         * of that endpoint.  In that case, if we solve for a Y coordinate
         * at or near that endpoint, we may be solving for a Y coordinate
         * that is below that minima or above that maxima and we would find
         * no solutions at all.
         *
         * In either case, we can assume that y is so near one of the
         * endpoints that we can just collapse it onto the nearest endpoint
         * without losing more than a couple of bits of precision.
         */
        // First calculate the midpoint between y0 and y1 and choose to
        // return either 0.0 or 1.0 depending on whether y is above
        // or below the midpoint...
        // Note that we subtracted y from ycoeff0 above so both y0 and y1
        // will be &quot;relative to y&quot; so we are really just looking at where
        // zero falls with respect to the &quot;relative midpoint&quot; here.
<span class="nc" id="L339">        double y0 = ycoeff0;</span>
<span class="nc" id="L340">        double y1 = ycoeff0 + ycoeff1 + ycoeff2;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        return (0 &lt; (y0 + y1) / 2) ? 0.0 : 1.0;</span>
    }

    public double XforT(double t) {
<span class="nc" id="L345">        return (xcoeff2 * t + xcoeff1) * t + xcoeff0;</span>
    }

    public double YforT(double t) {
<span class="nc" id="L349">        return (ycoeff2 * t + ycoeff1) * t + ycoeff0;</span>
    }

    public double dXforT(double t, int deriv) {
<span class="nc bnc" id="L353" title="All 4 branches missed.">        switch (deriv) {</span>
        case 0:
<span class="nc" id="L355">            return (xcoeff2 * t + xcoeff1) * t + xcoeff0;</span>
        case 1:
<span class="nc" id="L357">            return 2 * xcoeff2 * t + xcoeff1;</span>
        case 2:
<span class="nc" id="L359">            return 2 * xcoeff2;</span>
        default:
<span class="nc" id="L361">            return 0;</span>
        }
    }

    public double dYforT(double t, int deriv) {
<span class="nc bnc" id="L366" title="All 4 branches missed.">        switch (deriv) {</span>
        case 0:
<span class="nc" id="L368">            return (ycoeff2 * t + ycoeff1) * t + ycoeff0;</span>
        case 1:
<span class="nc" id="L370">            return 2 * ycoeff2 * t + ycoeff1;</span>
        case 2:
<span class="nc" id="L372">            return 2 * ycoeff2;</span>
        default:
<span class="nc" id="L374">            return 0;</span>
        }
    }

    public double nextVertical(double t0, double t1) {
<span class="nc" id="L379">        double t = -xcoeff1 / (2 * xcoeff2);</span>
<span class="nc bnc" id="L380" title="All 4 branches missed.">        if (t &gt; t0 &amp;&amp; t &lt; t1) {</span>
<span class="nc" id="L381">            return t;</span>
        }
<span class="nc" id="L383">        return t1;</span>
    }

    public void enlarge(Rectangle2D r) {
<span class="nc" id="L387">        r.add(x0, y0);</span>
<span class="nc" id="L388">        double t = -xcoeff1 / (2 * xcoeff2);</span>
<span class="nc bnc" id="L389" title="All 4 branches missed.">        if (t &gt; 0 &amp;&amp; t &lt; 1) {</span>
<span class="nc" id="L390">            r.add(XforT(t), YforT(t));</span>
        }
<span class="nc" id="L392">        r.add(x1, y1);</span>
<span class="nc" id="L393">    }</span>

    public Curve getSubCurve(double ystart, double yend, int dir) {
        double t0, t1;
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (ystart &lt;= y0) {</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            if (yend &gt;= y1) {</span>
<span class="nc" id="L399">                return getWithDirection(dir);</span>
            }
<span class="nc" id="L401">            t0 = 0;</span>
        } else {
<span class="nc" id="L403">            t0 = TforY(ystart, ycoeff0, ycoeff1, ycoeff2);</span>
        }
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (yend &gt;= y1) {</span>
<span class="nc" id="L406">            t1 = 1;</span>
        } else {
<span class="nc" id="L408">            t1 = TforY(yend, ycoeff0, ycoeff1, ycoeff2);</span>
        }
<span class="nc" id="L410">        double eqn[] = new double[10];</span>
<span class="nc" id="L411">        eqn[0] = x0;</span>
<span class="nc" id="L412">        eqn[1] = y0;</span>
<span class="nc" id="L413">        eqn[2] = cx0;</span>
<span class="nc" id="L414">        eqn[3] = cy0;</span>
<span class="nc" id="L415">        eqn[4] = x1;</span>
<span class="nc" id="L416">        eqn[5] = y1;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (t1 &lt; 1) {</span>
<span class="nc" id="L418">            split(eqn, 0, t1);</span>
        }
        int i;
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if (t0 &lt;= 0) {</span>
<span class="nc" id="L422">            i = 0;</span>
        } else {
<span class="nc" id="L424">            split(eqn, 0, t0 / t1);</span>
<span class="nc" id="L425">            i = 4;</span>
        }
<span class="nc" id="L427">        return new Order2(eqn[i+0], ystart,</span>
                          eqn[i+2], eqn[i+3],
                          eqn[i+4], yend,
                          dir);
    }

    public Curve getReversedCurve() {
<span class="nc" id="L434">        return new Order2(x0, y0, cx0, cy0, x1, y1, -direction);</span>
    }

    public int getSegment(double coords[]) {
<span class="nc" id="L438">        coords[0] = cx0;</span>
<span class="nc" id="L439">        coords[1] = cy0;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (direction == INCREASING) {</span>
<span class="nc" id="L441">            coords[2] = x1;</span>
<span class="nc" id="L442">            coords[3] = y1;</span>
        } else {
<span class="nc" id="L444">            coords[2] = x0;</span>
<span class="nc" id="L445">            coords[3] = y0;</span>
        }
<span class="nc" id="L447">        return PathIterator.SEG_QUADTO;</span>
    }

    public String controlPointString() {
<span class="nc" id="L451">        return (&quot;(&quot;+round(cx0)+&quot;, &quot;+round(cy0)+&quot;), &quot;);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>