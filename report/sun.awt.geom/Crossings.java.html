<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Crossings.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.awt.geom</a> &gt; <span class="el_source">Crossings.java</span></div><h1>Crossings.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.geom;

import java.awt.geom.PathIterator;
import java.util.Vector;
import java.util.Enumeration;

public abstract class Crossings {
    public static final boolean debug = false;

<span class="nc" id="L35">    int limit = 0;</span>
<span class="nc" id="L36">    double yranges[] = new double[10];</span>

    double xlo, ylo, xhi, yhi;

<span class="nc" id="L40">    public Crossings(double xlo, double ylo, double xhi, double yhi) {</span>
<span class="nc" id="L41">        this.xlo = xlo;</span>
<span class="nc" id="L42">        this.ylo = ylo;</span>
<span class="nc" id="L43">        this.xhi = xhi;</span>
<span class="nc" id="L44">        this.yhi = yhi;</span>
<span class="nc" id="L45">    }</span>

    public final double getXLo() {
<span class="nc" id="L48">        return xlo;</span>
    }

    public final double getYLo() {
<span class="nc" id="L52">        return ylo;</span>
    }

    public final double getXHi() {
<span class="nc" id="L56">        return xhi;</span>
    }

    public final double getYHi() {
<span class="nc" id="L60">        return yhi;</span>
    }

    public abstract void record(double ystart, double yend, int direction);

    public void print() {
<span class="nc" id="L66">        System.out.println(&quot;Crossings [&quot;);</span>
<span class="nc" id="L67">        System.out.println(&quot;  bounds = [&quot;+ylo+&quot;, &quot;+yhi+&quot;]&quot;);</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">        for (int i = 0; i &lt; limit; i += 2) {</span>
<span class="nc" id="L69">            System.out.println(&quot;  [&quot;+yranges[i]+&quot;, &quot;+yranges[i+1]+&quot;]&quot;);</span>
        }
<span class="nc" id="L71">        System.out.println(&quot;]&quot;);</span>
<span class="nc" id="L72">    }</span>

    public final boolean isEmpty() {
<span class="nc bnc" id="L75" title="All 2 branches missed.">        return (limit == 0);</span>
    }

    public abstract boolean covers(double ystart, double yend);

    public static Crossings findCrossings(Vector curves,
                                          double xlo, double ylo,
                                          double xhi, double yhi)
    {
<span class="nc" id="L84">        Crossings cross = new EvenOdd(xlo, ylo, xhi, yhi);</span>
<span class="nc" id="L85">        Enumeration enum_ = curves.elements();</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L87">            Curve c = (Curve) enum_.nextElement();</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">            if (c.accumulateCrossings(cross)) {</span>
<span class="nc" id="L89">                return null;</span>
            }
<span class="nc" id="L91">        }</span>
        if (debug) {
            cross.print();
        }
<span class="nc" id="L95">        return cross;</span>
    }

    public static Crossings findCrossings(PathIterator pi,
                                          double xlo, double ylo,
                                          double xhi, double yhi)
    {
        Crossings cross;
<span class="nc bnc" id="L103" title="All 2 branches missed.">        if (pi.getWindingRule() == pi.WIND_EVEN_ODD) {</span>
<span class="nc" id="L104">            cross = new EvenOdd(xlo, ylo, xhi, yhi);</span>
        } else {
<span class="nc" id="L106">            cross = new NonZero(xlo, ylo, xhi, yhi);</span>
        }
        // coords array is big enough for holding:
        //     coordinates returned from currentSegment (6)
        //     OR
        //         two subdivided quadratic curves (2+4+4=10)
        //         AND
        //             0-1 horizontal splitting parameters
        //             OR
        //             2 parametric equation derivative coefficients
        //     OR
        //         three subdivided cubic curves (2+6+6+6=20)
        //         AND
        //             0-2 horizontal splitting parameters
        //             OR
        //             3 parametric equation derivative coefficients
<span class="nc" id="L122">        double coords[] = new double[23];</span>
<span class="nc" id="L123">        double movx = 0;</span>
<span class="nc" id="L124">        double movy = 0;</span>
<span class="nc" id="L125">        double curx = 0;</span>
<span class="nc" id="L126">        double cury = 0;</span>
        double newx, newy;
<span class="nc bnc" id="L128" title="All 2 branches missed.">        while (!pi.isDone()) {</span>
<span class="nc" id="L129">            int type = pi.currentSegment(coords);</span>
<span class="nc bnc" id="L130" title="All 6 branches missed.">            switch (type) {</span>
            case PathIterator.SEG_MOVETO:
<span class="nc bnc" id="L132" title="All 2 branches missed.">                if (movy != cury &amp;&amp;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">                    cross.accumulateLine(curx, cury, movx, movy))</span>
                {
<span class="nc" id="L135">                    return null;</span>
                }
<span class="nc" id="L137">                movx = curx = coords[0];</span>
<span class="nc" id="L138">                movy = cury = coords[1];</span>
<span class="nc" id="L139">                break;</span>
            case PathIterator.SEG_LINETO:
<span class="nc" id="L141">                newx = coords[0];</span>
<span class="nc" id="L142">                newy = coords[1];</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">                if (cross.accumulateLine(curx, cury, newx, newy)) {</span>
<span class="nc" id="L144">                    return null;</span>
                }
<span class="nc" id="L146">                curx = newx;</span>
<span class="nc" id="L147">                cury = newy;</span>
<span class="nc" id="L148">                break;</span>
            case PathIterator.SEG_QUADTO:
<span class="nc" id="L150">                newx = coords[2];</span>
<span class="nc" id="L151">                newy = coords[3];</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">                if (cross.accumulateQuad(curx, cury, coords)) {</span>
<span class="nc" id="L153">                    return null;</span>
                }
<span class="nc" id="L155">                curx = newx;</span>
<span class="nc" id="L156">                cury = newy;</span>
<span class="nc" id="L157">                break;</span>
            case PathIterator.SEG_CUBICTO:
<span class="nc" id="L159">                newx = coords[4];</span>
<span class="nc" id="L160">                newy = coords[5];</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">                if (cross.accumulateCubic(curx, cury, coords)) {</span>
<span class="nc" id="L162">                    return null;</span>
                }
<span class="nc" id="L164">                curx = newx;</span>
<span class="nc" id="L165">                cury = newy;</span>
<span class="nc" id="L166">                break;</span>
            case PathIterator.SEG_CLOSE:
<span class="nc bnc" id="L168" title="All 2 branches missed.">                if (movy != cury &amp;&amp;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">                    cross.accumulateLine(curx, cury, movx, movy))</span>
                {
<span class="nc" id="L171">                    return null;</span>
                }
<span class="nc" id="L173">                curx = movx;</span>
<span class="nc" id="L174">                cury = movy;</span>
                break;
            }
<span class="nc" id="L177">            pi.next();</span>
<span class="nc" id="L178">        }</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (movy != cury) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (cross.accumulateLine(curx, cury, movx, movy)) {</span>
<span class="nc" id="L181">                return null;</span>
            }
        }
        if (debug) {
            cross.print();
        }
<span class="nc" id="L187">        return cross;</span>
    }

    public boolean accumulateLine(double x0, double y0,
                                  double x1, double y1)
    {
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (y0 &lt;= y1) {</span>
<span class="nc" id="L194">            return accumulateLine(x0, y0, x1, y1, 1);</span>
        } else {
<span class="nc" id="L196">            return accumulateLine(x1, y1, x0, y0, -1);</span>
        }
    }

    public boolean accumulateLine(double x0, double y0,
                                  double x1, double y1,
                                  int direction)
    {
<span class="nc bnc" id="L204" title="All 4 branches missed.">        if (yhi &lt;= y0 || ylo &gt;= y1) {</span>
<span class="nc" id="L205">            return false;</span>
        }
<span class="nc bnc" id="L207" title="All 4 branches missed.">        if (x0 &gt;= xhi &amp;&amp; x1 &gt;= xhi) {</span>
<span class="nc" id="L208">            return false;</span>
        }
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (y0 == y1) {</span>
<span class="nc bnc" id="L211" title="All 4 branches missed.">            return (x0 &gt;= xlo || x1 &gt;= xlo);</span>
        }
        double xstart, ystart, xend, yend;
<span class="nc" id="L214">        double dx = (x1 - x0);</span>
<span class="nc" id="L215">        double dy = (y1 - y0);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (y0 &lt; ylo) {</span>
<span class="nc" id="L217">            xstart = x0 + (ylo - y0) * dx / dy;</span>
<span class="nc" id="L218">            ystart = ylo;</span>
        } else {
<span class="nc" id="L220">            xstart = x0;</span>
<span class="nc" id="L221">            ystart = y0;</span>
        }
<span class="nc bnc" id="L223" title="All 2 branches missed.">        if (yhi &lt; y1) {</span>
<span class="nc" id="L224">            xend = x0 + (yhi - y0) * dx / dy;</span>
<span class="nc" id="L225">            yend = yhi;</span>
        } else {
<span class="nc" id="L227">            xend = x1;</span>
<span class="nc" id="L228">            yend = y1;</span>
        }
<span class="nc bnc" id="L230" title="All 4 branches missed.">        if (xstart &gt;= xhi &amp;&amp; xend &gt;= xhi) {</span>
<span class="nc" id="L231">            return false;</span>
        }
<span class="nc bnc" id="L233" title="All 4 branches missed.">        if (xstart &gt; xlo || xend &gt; xlo) {</span>
<span class="nc" id="L234">            return true;</span>
        }
<span class="nc" id="L236">        record(ystart, yend, direction);</span>
<span class="nc" id="L237">        return false;</span>
    }

<span class="nc" id="L240">    private Vector tmp = new Vector();</span>

    public boolean accumulateQuad(double x0, double y0, double coords[]) {
<span class="nc bnc" id="L243" title="All 6 branches missed.">        if (y0 &lt; ylo &amp;&amp; coords[1] &lt; ylo &amp;&amp; coords[3] &lt; ylo) {</span>
<span class="nc" id="L244">            return false;</span>
        }
<span class="nc bnc" id="L246" title="All 6 branches missed.">        if (y0 &gt; yhi &amp;&amp; coords[1] &gt; yhi &amp;&amp; coords[3] &gt; yhi) {</span>
<span class="nc" id="L247">            return false;</span>
        }
<span class="nc bnc" id="L249" title="All 6 branches missed.">        if (x0 &gt; xhi &amp;&amp; coords[0] &gt; xhi &amp;&amp; coords[2] &gt; xhi) {</span>
<span class="nc" id="L250">            return false;</span>
        }
<span class="nc bnc" id="L252" title="All 6 branches missed.">        if (x0 &lt; xlo &amp;&amp; coords[0] &lt; xlo &amp;&amp; coords[2] &lt; xlo) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            if (y0 &lt; coords[3]) {</span>
<span class="nc" id="L254">                record(Math.max(y0, ylo), Math.min(coords[3], yhi), 1);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">            } else if (y0 &gt; coords[3]) {</span>
<span class="nc" id="L256">                record(Math.max(coords[3], ylo), Math.min(y0, yhi), -1);</span>
            }
<span class="nc" id="L258">            return false;</span>
        }
<span class="nc" id="L260">        Curve.insertQuad(tmp, x0, y0, coords);</span>
<span class="nc" id="L261">        Enumeration enum_ = tmp.elements();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L263">            Curve c = (Curve) enum_.nextElement();</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (c.accumulateCrossings(this)) {</span>
<span class="nc" id="L265">                return true;</span>
            }
<span class="nc" id="L267">        }</span>
<span class="nc" id="L268">        tmp.clear();</span>
<span class="nc" id="L269">        return false;</span>
    }

    public boolean accumulateCubic(double x0, double y0, double coords[]) {
<span class="nc bnc" id="L273" title="All 8 branches missed.">        if (y0 &lt; ylo &amp;&amp; coords[1] &lt; ylo &amp;&amp;</span>
            coords[3] &lt; ylo &amp;&amp; coords[5] &lt; ylo)
        {
<span class="nc" id="L276">            return false;</span>
        }
<span class="nc bnc" id="L278" title="All 8 branches missed.">        if (y0 &gt; yhi &amp;&amp; coords[1] &gt; yhi &amp;&amp;</span>
            coords[3] &gt; yhi &amp;&amp; coords[5] &gt; yhi)
        {
<span class="nc" id="L281">            return false;</span>
        }
<span class="nc bnc" id="L283" title="All 8 branches missed.">        if (x0 &gt; xhi &amp;&amp; coords[0] &gt; xhi &amp;&amp;</span>
            coords[2] &gt; xhi &amp;&amp; coords[4] &gt; xhi)
        {
<span class="nc" id="L286">            return false;</span>
        }
<span class="nc bnc" id="L288" title="All 8 branches missed.">        if (x0 &lt; xlo &amp;&amp; coords[0] &lt; xlo &amp;&amp;</span>
            coords[2] &lt; xlo &amp;&amp; coords[4] &lt; xlo)
        {
<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (y0 &lt;= coords[5]) {</span>
<span class="nc" id="L292">                record(Math.max(y0, ylo), Math.min(coords[5], yhi), 1);</span>
            } else {
<span class="nc" id="L294">                record(Math.max(coords[5], ylo), Math.min(y0, yhi), -1);</span>
            }
<span class="nc" id="L296">            return false;</span>
        }
<span class="nc" id="L298">        Curve.insertCubic(tmp, x0, y0, coords);</span>
<span class="nc" id="L299">        Enumeration enum_ = tmp.elements();</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">        while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L301">            Curve c = (Curve) enum_.nextElement();</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            if (c.accumulateCrossings(this)) {</span>
<span class="nc" id="L303">                return true;</span>
            }
<span class="nc" id="L305">        }</span>
<span class="nc" id="L306">        tmp.clear();</span>
<span class="nc" id="L307">        return false;</span>
    }

    public final static class EvenOdd extends Crossings {
        public EvenOdd(double xlo, double ylo, double xhi, double yhi) {
<span class="nc" id="L312">            super(xlo, ylo, xhi, yhi);</span>
<span class="nc" id="L313">        }</span>

        public final boolean covers(double ystart, double yend) {
<span class="nc bnc" id="L316" title="All 6 branches missed.">            return (limit == 2 &amp;&amp; yranges[0] &lt;= ystart &amp;&amp; yranges[1] &gt;= yend);</span>
        }

        public void record(double ystart, double yend, int direction) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (ystart &gt;= yend) {</span>
<span class="nc" id="L321">                return;</span>
            }
<span class="nc" id="L323">            int from = 0;</span>
            // Quickly jump over all pairs that are completely &quot;above&quot;
<span class="nc bnc" id="L325" title="All 4 branches missed.">            while (from &lt; limit &amp;&amp; ystart &gt; yranges[from+1]) {</span>
<span class="nc" id="L326">                from += 2;</span>
            }
<span class="nc" id="L328">            int to = from;</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            while (from &lt; limit) {</span>
<span class="nc" id="L330">                double yrlo = yranges[from++];</span>
<span class="nc" id="L331">                double yrhi = yranges[from++];</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">                if (yend &lt; yrlo) {</span>
                    // Quickly handle insertion of the new range
<span class="nc" id="L334">                    yranges[to++] = ystart;</span>
<span class="nc" id="L335">                    yranges[to++] = yend;</span>
<span class="nc" id="L336">                    ystart = yrlo;</span>
<span class="nc" id="L337">                    yend = yrhi;</span>
<span class="nc" id="L338">                    continue;</span>
                }
                // The ranges overlap - sort, collapse, insert, iterate
                double yll, ylh, yhl, yhh;
<span class="nc bnc" id="L342" title="All 2 branches missed.">                if (ystart &lt; yrlo) {</span>
<span class="nc" id="L343">                    yll = ystart;</span>
<span class="nc" id="L344">                    ylh = yrlo;</span>
                } else {
<span class="nc" id="L346">                    yll = yrlo;</span>
<span class="nc" id="L347">                    ylh = ystart;</span>
                }
<span class="nc bnc" id="L349" title="All 2 branches missed.">                if (yend &lt; yrhi) {</span>
<span class="nc" id="L350">                    yhl = yend;</span>
<span class="nc" id="L351">                    yhh = yrhi;</span>
                } else {
<span class="nc" id="L353">                    yhl = yrhi;</span>
<span class="nc" id="L354">                    yhh = yend;</span>
                }
<span class="nc bnc" id="L356" title="All 2 branches missed.">                if (ylh == yhl) {</span>
<span class="nc" id="L357">                    ystart = yll;</span>
<span class="nc" id="L358">                    yend = yhh;</span>
                } else {
<span class="nc bnc" id="L360" title="All 2 branches missed.">                    if (ylh &gt; yhl) {</span>
<span class="nc" id="L361">                        ystart = yhl;</span>
<span class="nc" id="L362">                        yhl = ylh;</span>
<span class="nc" id="L363">                        ylh = ystart;</span>
                    }
<span class="nc bnc" id="L365" title="All 2 branches missed.">                    if (yll != ylh) {</span>
<span class="nc" id="L366">                        yranges[to++] = yll;</span>
<span class="nc" id="L367">                        yranges[to++] = ylh;</span>
                    }
<span class="nc" id="L369">                    ystart = yhl;</span>
<span class="nc" id="L370">                    yend = yhh;</span>
                }
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if (ystart &gt;= yend) {</span>
<span class="nc" id="L373">                    break;</span>
                }
<span class="nc" id="L375">            }</span>
<span class="nc bnc" id="L376" title="All 4 branches missed.">            if (to &lt; from &amp;&amp; from &lt; limit) {</span>
<span class="nc" id="L377">                System.arraycopy(yranges, from, yranges, to, limit-from);</span>
            }
<span class="nc" id="L379">            to += (limit-from);</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            if (ystart &lt; yend) {</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">                if (to &gt;= yranges.length) {</span>
<span class="nc" id="L382">                    double newranges[] = new double[to+10];</span>
<span class="nc" id="L383">                    System.arraycopy(yranges, 0, newranges, 0, to);</span>
<span class="nc" id="L384">                    yranges = newranges;</span>
                }
<span class="nc" id="L386">                yranges[to++] = ystart;</span>
<span class="nc" id="L387">                yranges[to++] = yend;</span>
            }
<span class="nc" id="L389">            limit = to;</span>
<span class="nc" id="L390">        }</span>
    }

    public final static class NonZero extends Crossings {
        private int crosscounts[];

        public NonZero(double xlo, double ylo, double xhi, double yhi) {
<span class="nc" id="L397">            super(xlo, ylo, xhi, yhi);</span>
<span class="nc" id="L398">            crosscounts = new int[yranges.length / 2];</span>
<span class="nc" id="L399">        }</span>

        public final boolean covers(double ystart, double yend) {
<span class="nc" id="L402">            int i = 0;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            while (i &lt; limit) {</span>
<span class="nc" id="L404">                double ylo = yranges[i++];</span>
<span class="nc" id="L405">                double yhi = yranges[i++];</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                if (ystart &gt;= yhi) {</span>
<span class="nc" id="L407">                    continue;</span>
                }
<span class="nc bnc" id="L409" title="All 2 branches missed.">                if (ystart &lt; ylo) {</span>
<span class="nc" id="L410">                    return false;</span>
                }
<span class="nc bnc" id="L412" title="All 2 branches missed.">                if (yend &lt;= yhi) {</span>
<span class="nc" id="L413">                    return true;</span>
                }
<span class="nc" id="L415">                ystart = yhi;</span>
<span class="nc" id="L416">            }</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            return (ystart &gt;= yend);</span>
        }

        public void remove(int cur) {
<span class="nc" id="L421">            limit -= 2;</span>
<span class="nc" id="L422">            int rem = limit - cur;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            if (rem &gt; 0) {</span>
<span class="nc" id="L424">                System.arraycopy(yranges, cur+2, yranges, cur, rem);</span>
<span class="nc" id="L425">                System.arraycopy(crosscounts, cur/2+1,</span>
                                 crosscounts, cur/2,
                                 rem/2);
            }
<span class="nc" id="L429">        }</span>

        public void insert(int cur, double lo, double hi, int dir) {
<span class="nc" id="L432">            int rem = limit - cur;</span>
<span class="nc" id="L433">            double oldranges[] = yranges;</span>
<span class="nc" id="L434">            int oldcounts[] = crosscounts;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            if (limit &gt;= yranges.length) {</span>
<span class="nc" id="L436">                yranges = new double[limit+10];</span>
<span class="nc" id="L437">                System.arraycopy(oldranges, 0, yranges, 0, cur);</span>
<span class="nc" id="L438">                crosscounts = new int[(limit+10)/2];</span>
<span class="nc" id="L439">                System.arraycopy(oldcounts, 0, crosscounts, 0, cur/2);</span>
            }
<span class="nc bnc" id="L441" title="All 2 branches missed.">            if (rem &gt; 0) {</span>
<span class="nc" id="L442">                System.arraycopy(oldranges, cur, yranges, cur+2, rem);</span>
<span class="nc" id="L443">                System.arraycopy(oldcounts, cur/2,</span>
                                 crosscounts, cur/2+1,
                                 rem/2);
            }
<span class="nc" id="L447">            yranges[cur+0] = lo;</span>
<span class="nc" id="L448">            yranges[cur+1] = hi;</span>
<span class="nc" id="L449">            crosscounts[cur/2] = dir;</span>
<span class="nc" id="L450">            limit += 2;</span>
<span class="nc" id="L451">        }</span>

        public void record(double ystart, double yend, int direction) {
<span class="nc bnc" id="L454" title="All 2 branches missed.">            if (ystart &gt;= yend) {</span>
<span class="nc" id="L455">                return;</span>
            }
<span class="nc" id="L457">            int cur = 0;</span>
            // Quickly jump over all pairs that are completely &quot;above&quot;
<span class="nc bnc" id="L459" title="All 4 branches missed.">            while (cur &lt; limit &amp;&amp; ystart &gt; yranges[cur+1]) {</span>
<span class="nc" id="L460">                cur += 2;</span>
            }
<span class="nc bnc" id="L462" title="All 2 branches missed.">            if (cur &lt; limit) {</span>
<span class="nc" id="L463">                int rdir = crosscounts[cur/2];</span>
<span class="nc" id="L464">                double yrlo = yranges[cur+0];</span>
<span class="nc" id="L465">                double yrhi = yranges[cur+1];</span>
<span class="nc bnc" id="L466" title="All 4 branches missed.">                if (yrhi == ystart &amp;&amp; rdir == direction) {</span>
                    // Remove the range from the list and collapse it
                    // into the range being inserted.  Note that the
                    // new combined range may overlap the following range
                    // so we must not simply combine the ranges in place
                    // unless we are at the last range.
<span class="nc bnc" id="L472" title="All 2 branches missed.">                    if (cur+2 == limit) {</span>
<span class="nc" id="L473">                        yranges[cur+1] = yend;</span>
<span class="nc" id="L474">                        return;</span>
                    }
<span class="nc" id="L476">                    remove(cur);</span>
<span class="nc" id="L477">                    ystart = yrlo;</span>
<span class="nc" id="L478">                    rdir = crosscounts[cur/2];</span>
<span class="nc" id="L479">                    yrlo = yranges[cur+0];</span>
<span class="nc" id="L480">                    yrhi = yranges[cur+1];</span>
                }
<span class="nc bnc" id="L482" title="All 2 branches missed.">                if (yend &lt; yrlo) {</span>
                    // Just insert the new range at the current location
<span class="nc" id="L484">                    insert(cur, ystart, yend, direction);</span>
<span class="nc" id="L485">                    return;</span>
                }
<span class="nc bnc" id="L487" title="All 4 branches missed.">                if (yend == yrlo &amp;&amp; rdir == direction) {</span>
                    // Just prepend the new range to the current one
<span class="nc" id="L489">                    yranges[cur] = ystart;</span>
<span class="nc" id="L490">                    return;</span>
                }
                // The ranges must overlap - (yend &gt; yrlo &amp;&amp; yrhi &gt; ystart)
<span class="nc bnc" id="L493" title="All 2 branches missed.">                if (ystart &lt; yrlo) {</span>
<span class="nc" id="L494">                    insert(cur, ystart, yrlo, direction);</span>
<span class="nc" id="L495">                    cur += 2;</span>
<span class="nc" id="L496">                    ystart = yrlo;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                } else if (yrlo &lt; ystart) {</span>
<span class="nc" id="L498">                    insert(cur, yrlo, ystart, rdir);</span>
<span class="nc" id="L499">                    cur += 2;</span>
<span class="nc" id="L500">                    yrlo = ystart;</span>
                }
                // assert(yrlo == ystart);
<span class="nc" id="L503">                int newdir = rdir + direction;</span>
<span class="nc" id="L504">                double newend = Math.min(yend, yrhi);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (newdir == 0) {</span>
<span class="nc" id="L506">                    remove(cur);</span>
                } else {
<span class="nc" id="L508">                    crosscounts[cur/2] = newdir;</span>
<span class="nc" id="L509">                    yranges[cur++] = ystart;</span>
<span class="nc" id="L510">                    yranges[cur++] = newend;</span>
                }
<span class="nc" id="L512">                ystart = yrlo = newend;</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">                if (yrlo &lt; yrhi) {</span>
<span class="nc" id="L514">                    insert(cur, yrlo, yrhi, rdir);</span>
                }
            }
<span class="nc bnc" id="L517" title="All 2 branches missed.">            if (ystart &lt; yend) {</span>
<span class="nc" id="L518">                insert(cur, ystart, yend, direction);</span>
            }
<span class="nc" id="L520">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>