<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AreaOp.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.awt.geom</a> &gt; <span class="el_source">AreaOp.java</span></div><h1>AreaOp.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.geom;

import java.util.Vector;
import java.util.Enumeration;
import java.util.Comparator;
import java.util.Arrays;

public abstract class AreaOp {
<span class="nc" id="L34">    public static abstract class CAGOp extends AreaOp {</span>
        boolean inLeft;
        boolean inRight;
        boolean inResult;

        public void newRow() {
<span class="nc" id="L40">            inLeft = false;</span>
<span class="nc" id="L41">            inRight = false;</span>
<span class="nc" id="L42">            inResult = false;</span>
<span class="nc" id="L43">        }</span>

        public int classify(Edge e) {
<span class="nc bnc" id="L46" title="All 2 branches missed.">            if (e.getCurveTag() == CTAG_LEFT) {</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">                inLeft = !inLeft;</span>
            } else {
<span class="nc bnc" id="L49" title="All 2 branches missed.">                inRight = !inRight;</span>
            }
<span class="nc" id="L51">            boolean newClass = newClassification(inLeft, inRight);</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">            if (inResult == newClass) {</span>
<span class="nc" id="L53">                return ETAG_IGNORE;</span>
            }
<span class="nc" id="L55">            inResult = newClass;</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">            return (newClass ? ETAG_ENTER : ETAG_EXIT);</span>
        }

        public int getState() {
<span class="nc bnc" id="L60" title="All 2 branches missed.">            return (inResult ? RSTAG_INSIDE : RSTAG_OUTSIDE);</span>
        }

        public abstract boolean newClassification(boolean inLeft,
                                                  boolean inRight);
    }

<span class="nc" id="L67">    public static class AddOp extends CAGOp {</span>
        public boolean newClassification(boolean inLeft, boolean inRight) {
<span class="nc bnc" id="L69" title="All 4 branches missed.">            return (inLeft || inRight);</span>
        }
    }

<span class="nc" id="L73">    public static class SubOp extends CAGOp {</span>
        public boolean newClassification(boolean inLeft, boolean inRight) {
<span class="nc bnc" id="L75" title="All 4 branches missed.">            return (inLeft &amp;&amp; !inRight);</span>
        }
    }

<span class="nc" id="L79">    public static class IntOp extends CAGOp {</span>
        public boolean newClassification(boolean inLeft, boolean inRight) {
<span class="nc bnc" id="L81" title="All 4 branches missed.">            return (inLeft &amp;&amp; inRight);</span>
        }
    }

<span class="nc" id="L85">    public static class XorOp extends CAGOp {</span>
        public boolean newClassification(boolean inLeft, boolean inRight) {
<span class="nc bnc" id="L87" title="All 2 branches missed.">            return (inLeft != inRight);</span>
        }
    }

<span class="nc" id="L91">    public static class NZWindOp extends AreaOp {</span>
        private int count;

        public void newRow() {
<span class="nc" id="L95">            count = 0;</span>
<span class="nc" id="L96">        }</span>

        public int classify(Edge e) {
            // Note: the right curves should be an empty set with this op...
            // assert(e.getCurveTag() == CTAG_LEFT);
<span class="nc" id="L101">            int newCount = count;</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">            int type = (newCount == 0 ? ETAG_ENTER : ETAG_IGNORE);</span>
<span class="nc" id="L103">            newCount += e.getCurve().getDirection();</span>
<span class="nc" id="L104">            count = newCount;</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">            return (newCount == 0 ? ETAG_EXIT : type);</span>
        }

        public int getState() {
<span class="nc bnc" id="L109" title="All 2 branches missed.">            return ((count == 0) ? RSTAG_OUTSIDE : RSTAG_INSIDE);</span>
        }
    }

<span class="nc" id="L113">    public static class EOWindOp extends AreaOp {</span>
        private boolean inside;

        public void newRow() {
<span class="nc" id="L117">            inside = false;</span>
<span class="nc" id="L118">        }</span>

        public int classify(Edge e) {
            // Note: the right curves should be an empty set with this op...
            // assert(e.getCurveTag() == CTAG_LEFT);
<span class="nc bnc" id="L123" title="All 2 branches missed.">            boolean newInside = !inside;</span>
<span class="nc" id="L124">            inside = newInside;</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            return (newInside ? ETAG_ENTER : ETAG_EXIT);</span>
        }

        public int getState() {
<span class="nc bnc" id="L129" title="All 2 branches missed.">            return (inside ? RSTAG_INSIDE : RSTAG_OUTSIDE);</span>
        }
    }

<span class="nc" id="L133">    private AreaOp() {</span>
<span class="nc" id="L134">    }</span>

    /* Constants to tag the left and right curves in the edge list */
    public static final int CTAG_LEFT = 0;
    public static final int CTAG_RIGHT = 1;

    /* Constants to classify edges */
    public static final int ETAG_IGNORE = 0;
    public static final int ETAG_ENTER = 1;
    public static final int ETAG_EXIT = -1;

    /* Constants used to classify result state */
    public static final int RSTAG_INSIDE = 1;
    public static final int RSTAG_OUTSIDE = -1;

    public abstract void newRow();

    public abstract int classify(Edge e);

    public abstract int getState();

    public Vector calculate(Vector left, Vector right) {
<span class="nc" id="L156">        Vector edges = new Vector();</span>
<span class="nc" id="L157">        addEdges(edges, left, AreaOp.CTAG_LEFT);</span>
<span class="nc" id="L158">        addEdges(edges, right, AreaOp.CTAG_RIGHT);</span>
<span class="nc" id="L159">        edges = pruneEdges(edges);</span>
        if (false) {
            System.out.println(&quot;result: &quot;);
            int numcurves = edges.size();
            Curve[] curvelist = (Curve[]) edges.toArray(new Curve[numcurves]);
            for (int i = 0; i &lt; numcurves; i++) {
                System.out.println(&quot;curvelist[&quot;+i+&quot;] = &quot;+curvelist[i]);
            }
        }
<span class="nc" id="L168">        return edges;</span>
    }

    private static void addEdges(Vector edges, Vector curves, int curvetag) {
<span class="nc" id="L172">        Enumeration enum_ = curves.elements();</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L174">            Curve c = (Curve) enum_.nextElement();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (c.getOrder() &gt; 0) {</span>
<span class="nc" id="L176">                edges.add(new Edge(c, curvetag));</span>
            }
<span class="nc" id="L178">        }</span>
<span class="nc" id="L179">    }</span>

<span class="nc" id="L181">    private static Comparator YXTopComparator = new Comparator() {</span>
        public int compare(Object o1, Object o2) {
<span class="nc" id="L183">            Curve c1 = ((Edge) o1).getCurve();</span>
<span class="nc" id="L184">            Curve c2 = ((Edge) o2).getCurve();</span>
            double v1, v2;
<span class="nc bnc" id="L186" title="All 2 branches missed.">            if ((v1 = c1.getYTop()) == (v2 = c2.getYTop())) {</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">                if ((v1 = c1.getXTop()) == (v2 = c2.getXTop())) {</span>
<span class="nc" id="L188">                    return 0;</span>
                }
            }
<span class="nc bnc" id="L191" title="All 2 branches missed.">            if (v1 &lt; v2) {</span>
<span class="nc" id="L192">                return -1;</span>
            }
<span class="nc" id="L194">            return 1;</span>
        }
    };

    private Vector pruneEdges(Vector edges) {
<span class="nc" id="L199">        int numedges = edges.size();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (numedges &lt; 2) {</span>
<span class="nc" id="L201">            return edges;</span>
        }
<span class="nc" id="L203">        Edge[] edgelist = (Edge[]) edges.toArray(new Edge[numedges]);</span>
<span class="nc" id="L204">        Arrays.sort(edgelist, YXTopComparator);</span>
        if (false) {
            System.out.println(&quot;pruning: &quot;);
            for (int i = 0; i &lt; numedges; i++) {
                System.out.println(&quot;edgelist[&quot;+i+&quot;] = &quot;+edgelist[i]);
            }
        }
        Edge e;
<span class="nc" id="L212">        int left = 0;</span>
<span class="nc" id="L213">        int right = 0;</span>
<span class="nc" id="L214">        int cur = 0;</span>
<span class="nc" id="L215">        int next = 0;</span>
<span class="nc" id="L216">        double yrange[] = new double[2];</span>
<span class="nc" id="L217">        Vector subcurves = new Vector();</span>
<span class="nc" id="L218">        Vector chains = new Vector();</span>
<span class="nc" id="L219">        Vector links = new Vector();</span>
        // Active edges are between left (inclusive) and right (exclusive)
<span class="nc bnc" id="L221" title="All 2 branches missed.">        while (left &lt; numedges) {</span>
<span class="nc" id="L222">            double y = yrange[0];</span>
            // Prune active edges that fall off the top of the active y range
<span class="nc bnc" id="L224" title="All 2 branches missed.">            for (cur = next = right - 1; cur &gt;= left; cur--) {</span>
<span class="nc" id="L225">                e = edgelist[cur];</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">                if (e.getCurve().getYBot() &gt; y) {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                    if (next &gt; cur) {</span>
<span class="nc" id="L228">                        edgelist[next] = e;</span>
                    }
<span class="nc" id="L230">                    next--;</span>
                }
            }
<span class="nc" id="L233">            left = next + 1;</span>
            // Grab a new &quot;top of Y range&quot; if the active edges are empty
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (left &gt;= right) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">                if (right &gt;= numedges) {</span>
<span class="nc" id="L237">                    break;</span>
                }
<span class="nc" id="L239">                y = edgelist[right].getCurve().getYTop();</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                if (y &gt; yrange[0]) {</span>
<span class="nc" id="L241">                    finalizeSubCurves(subcurves, chains);</span>
                }
<span class="nc" id="L243">                yrange[0] = y;</span>
            }
            // Incorporate new active edges that enter the active y range
<span class="nc bnc" id="L246" title="All 2 branches missed.">            while (right &lt; numedges) {</span>
<span class="nc" id="L247">                e = edgelist[right];</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">                if (e.getCurve().getYTop() &gt; y) {</span>
<span class="nc" id="L249">                    break;</span>
                }
<span class="nc" id="L251">                right++;</span>
            }
            // Sort the current active edges by their X values and
            // determine the maximum valid Y range where the X ordering
            // is correct
<span class="nc" id="L256">            yrange[1] = edgelist[left].getCurve().getYBot();</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">            if (right &lt; numedges) {</span>
<span class="nc" id="L258">                y = edgelist[right].getCurve().getYTop();</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">                if (yrange[1] &gt; y) {</span>
<span class="nc" id="L260">                    yrange[1] = y;</span>
                }
            }
            if (false) {
                System.out.println(&quot;current line: y = [&quot;+
                                   yrange[0]+&quot;, &quot;+yrange[1]+&quot;]&quot;);
                for (cur = left; cur &lt; right; cur++) {
                    System.out.println(&quot;  &quot;+edgelist[cur]);
                }
            }
            // Note: We could start at left+1, but we need to make
            // sure that edgelist[left] has its equivalence set to 0.
<span class="nc" id="L272">            int nexteq = 1;</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">            for (cur = left; cur &lt; right; cur++) {</span>
<span class="nc" id="L274">                e = edgelist[cur];</span>
<span class="nc" id="L275">                e.setEquivalence(0);</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                for (next = cur; next &gt; left; next--) {</span>
<span class="nc" id="L277">                    Edge prevedge = edgelist[next-1];</span>
<span class="nc" id="L278">                    int ordering = e.compareTo(prevedge, yrange);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                    if (yrange[1] &lt;= yrange[0]) {</span>
<span class="nc" id="L280">                        throw new InternalError(&quot;backstepping to &quot;+yrange[1]+</span>
                                                &quot; from &quot;+yrange[0]);
                    }
<span class="nc bnc" id="L283" title="All 2 branches missed.">                    if (ordering &gt;= 0) {</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">                        if (ordering == 0) {</span>
                            // If the curves are equal, mark them to be
                            // deleted later if they cancel each other
                            // out so that we avoid having extraneous
                            // curve segments.
<span class="nc" id="L289">                            int eq = prevedge.getEquivalence();</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                            if (eq == 0) {</span>
<span class="nc" id="L291">                                eq = nexteq++;</span>
<span class="nc" id="L292">                                prevedge.setEquivalence(eq);</span>
                            }
<span class="nc" id="L294">                            e.setEquivalence(eq);</span>
<span class="nc" id="L295">                        }</span>
                        break;
                    }
<span class="nc" id="L298">                    edgelist[next] = prevedge;</span>
                }
<span class="nc" id="L300">                edgelist[next] = e;</span>
            }
            if (false) {
                System.out.println(&quot;current sorted line: y = [&quot;+
                                   yrange[0]+&quot;, &quot;+yrange[1]+&quot;]&quot;);
                for (cur = left; cur &lt; right; cur++) {
                    System.out.println(&quot;  &quot;+edgelist[cur]);
                }
            }
            // Now prune the active edge list.
            // For each edge in the list, determine its classification
            // (entering shape, exiting shape, ignore - no change) and
            // record the current Y range and its classification in the
            // Edge object for use later in constructing the new outline.
<span class="nc" id="L314">            newRow();</span>
<span class="nc" id="L315">            double ystart = yrange[0];</span>
<span class="nc" id="L316">            double yend = yrange[1];</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">            for (cur = left; cur &lt; right; cur++) {</span>
<span class="nc" id="L318">                e = edgelist[cur];</span>
                int etag;
<span class="nc" id="L320">                int eq = e.getEquivalence();</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">                if (eq != 0) {</span>
                    // Find one of the segments in the &quot;equal&quot; range
                    // with the right transition state and prefer an
                    // edge that was either active up until ystart
                    // or the edge that extends the furthest downward
                    // (i.e. has the most potential for continuation)
<span class="nc" id="L327">                    int origstate = getState();</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">                    etag = (origstate == AreaOp.RSTAG_INSIDE</span>
                            ? AreaOp.ETAG_EXIT
                            : AreaOp.ETAG_ENTER);
<span class="nc" id="L331">                    Edge activematch = null;</span>
<span class="nc" id="L332">                    Edge longestmatch = e;</span>
<span class="nc" id="L333">                    double furthesty = yend;</span>
                    do {
                        // Note: classify() must be called
                        // on every edge we consume here.
<span class="nc" id="L337">                        classify(e);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                        if (activematch == null &amp;&amp;</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">                            e.isActiveFor(ystart, etag))</span>
                        {
<span class="nc" id="L341">                            activematch = e;</span>
                        }
<span class="nc" id="L343">                        y = e.getCurve().getYBot();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                        if (y &gt; furthesty) {</span>
<span class="nc" id="L345">                            longestmatch = e;</span>
<span class="nc" id="L346">                            furthesty = y;</span>
                        }
<span class="nc bnc" id="L348" title="All 2 branches missed.">                    } while (++cur &lt; right &amp;&amp;</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">                             (e = edgelist[cur]).getEquivalence() == eq);</span>
<span class="nc" id="L350">                    --cur;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (getState() == origstate) {</span>
<span class="nc" id="L352">                        etag = AreaOp.ETAG_IGNORE;</span>
                    } else {
<span class="nc bnc" id="L354" title="All 2 branches missed.">                        e = (activematch != null ? activematch : longestmatch);</span>
                    }
<span class="nc" id="L356">                } else {</span>
<span class="nc" id="L357">                    etag = classify(e);</span>
                }
<span class="nc bnc" id="L359" title="All 2 branches missed.">                if (etag != AreaOp.ETAG_IGNORE) {</span>
<span class="nc" id="L360">                    e.record(yend, etag);</span>
<span class="nc" id="L361">                    links.add(new CurveLink(e.getCurve(), ystart, yend, etag));</span>
                }
            }
            // assert(getState() == AreaOp.RSTAG_OUTSIDE);
<span class="nc bnc" id="L365" title="All 2 branches missed.">            if (getState() != AreaOp.RSTAG_OUTSIDE) {</span>
<span class="nc" id="L366">                System.out.println(&quot;Still inside at end of active edge list!&quot;);</span>
<span class="nc" id="L367">                System.out.println(&quot;num curves = &quot;+(right-left));</span>
<span class="nc" id="L368">                System.out.println(&quot;num links = &quot;+links.size());</span>
<span class="nc" id="L369">                System.out.println(&quot;y top = &quot;+yrange[0]);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">                if (right &lt; numedges) {</span>
<span class="nc" id="L371">                    System.out.println(&quot;y top of next curve = &quot;+</span>
<span class="nc" id="L372">                                       edgelist[right].getCurve().getYTop());</span>
                } else {
<span class="nc" id="L374">                    System.out.println(&quot;no more curves&quot;);</span>
                }
<span class="nc bnc" id="L376" title="All 2 branches missed.">                for (cur = left; cur &lt; right; cur++) {</span>
<span class="nc" id="L377">                    e = edgelist[cur];</span>
<span class="nc" id="L378">                    System.out.println(e);</span>
<span class="nc" id="L379">                    int eq = e.getEquivalence();</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">                    if (eq != 0) {</span>
<span class="nc" id="L381">                        System.out.println(&quot;  was equal to &quot;+eq+&quot;...&quot;);</span>
                    }
                }
            }
            if (false) {
                System.out.println(&quot;new links:&quot;);
                for (int i = 0; i &lt; links.size(); i++) {
                    CurveLink link = (CurveLink) links.elementAt(i);
                    System.out.println(&quot;  &quot;+link.getSubCurve());
                }
            }
<span class="nc" id="L392">            resolveLinks(subcurves, chains, links);</span>
<span class="nc" id="L393">            links.clear();</span>
            // Finally capture the bottom of the valid Y range as the top
            // of the next Y range.
<span class="nc" id="L396">            yrange[0] = yend;</span>
<span class="nc" id="L397">        }</span>
<span class="nc" id="L398">        finalizeSubCurves(subcurves, chains);</span>
<span class="nc" id="L399">        Vector ret = new Vector();</span>
<span class="nc" id="L400">        Enumeration enum_ = subcurves.elements();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L402">            CurveLink link = (CurveLink) enum_.nextElement();</span>
<span class="nc" id="L403">            ret.add(link.getMoveto());</span>
<span class="nc" id="L404">            CurveLink nextlink = link;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            while ((nextlink = nextlink.getNext()) != null) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                if (!link.absorb(nextlink)) {</span>
<span class="nc" id="L407">                    ret.add(link.getSubCurve());</span>
<span class="nc" id="L408">                    link = nextlink;</span>
                }
            }
<span class="nc" id="L411">            ret.add(link.getSubCurve());</span>
<span class="nc" id="L412">        }</span>
<span class="nc" id="L413">        return ret;</span>
    }

    public static void finalizeSubCurves(Vector subcurves, Vector chains) {
<span class="nc" id="L417">        int numchains = chains.size();</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (numchains == 0) {</span>
<span class="nc" id="L419">            return;</span>
        }
<span class="nc bnc" id="L421" title="All 2 branches missed.">        if ((numchains &amp; 1) != 0) {</span>
<span class="nc" id="L422">            throw new InternalError(&quot;Odd number of chains!&quot;);</span>
        }
<span class="nc" id="L424">        ChainEnd[] endlist = new ChainEnd[numchains];</span>
<span class="nc" id="L425">        chains.toArray(endlist);</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">        for (int i = 1; i &lt; numchains; i += 2) {</span>
<span class="nc" id="L427">            ChainEnd open = endlist[i - 1];</span>
<span class="nc" id="L428">            ChainEnd close = endlist[i];</span>
<span class="nc" id="L429">            CurveLink subcurve = open.linkTo(close);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">            if (subcurve != null) {</span>
<span class="nc" id="L431">                subcurves.add(subcurve);</span>
            }
        }
<span class="nc" id="L434">        chains.clear();</span>
<span class="nc" id="L435">    }</span>

<span class="nc" id="L437">    private static CurveLink[] EmptyLinkList = new CurveLink[2];</span>
<span class="nc" id="L438">    private static ChainEnd[] EmptyChainList = new ChainEnd[2];</span>

    public static void resolveLinks(Vector subcurves,
                                    Vector chains,
                                    Vector links)
    {
<span class="nc" id="L444">        int numlinks = links.size();</span>
        CurveLink[] linklist;
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (numlinks == 0) {</span>
<span class="nc" id="L447">            linklist = EmptyLinkList;</span>
        } else {
<span class="nc bnc" id="L449" title="All 2 branches missed.">            if ((numlinks &amp; 1) != 0) {</span>
<span class="nc" id="L450">                throw new InternalError(&quot;Odd number of new curves!&quot;);</span>
            }
<span class="nc" id="L452">            linklist = new CurveLink[numlinks+2];</span>
<span class="nc" id="L453">            links.toArray(linklist);</span>
        }
<span class="nc" id="L455">        int numchains = chains.size();</span>
        ChainEnd[] endlist;
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (numchains == 0) {</span>
<span class="nc" id="L458">            endlist = EmptyChainList;</span>
        } else {
<span class="nc bnc" id="L460" title="All 2 branches missed.">            if ((numchains &amp; 1) != 0) {</span>
<span class="nc" id="L461">                throw new InternalError(&quot;Odd number of chains!&quot;);</span>
            }
<span class="nc" id="L463">            endlist = new ChainEnd[numchains+2];</span>
<span class="nc" id="L464">            chains.toArray(endlist);</span>
        }
<span class="nc" id="L466">        int curchain = 0;</span>
<span class="nc" id="L467">        int curlink = 0;</span>
<span class="nc" id="L468">        chains.clear();</span>
<span class="nc" id="L469">        ChainEnd chain = endlist[0];</span>
<span class="nc" id="L470">        ChainEnd nextchain = endlist[1];</span>
<span class="nc" id="L471">        CurveLink link = linklist[0];</span>
<span class="nc" id="L472">        CurveLink nextlink = linklist[1];</span>
<span class="nc bnc" id="L473" title="All 4 branches missed.">        while (chain != null || link != null) {</span>
            /*
             * Strategy 1:
             * Connect chains or links if they are the only things left...
             */
<span class="nc bnc" id="L478" title="All 2 branches missed.">            boolean connectchains = (link == null);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">            boolean connectlinks = (chain == null);</span>

<span class="nc bnc" id="L481" title="All 4 branches missed.">            if (!connectchains &amp;&amp; !connectlinks) {</span>
                // assert(link != null &amp;&amp; chain != null);
                /*
                 * Strategy 2:
                 * Connect chains or links if they close off an open area...
                 */
<span class="nc bnc" id="L487" title="All 2 branches missed.">                connectchains = ((curchain &amp; 1) == 0 &amp;&amp;</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">                                 chain.getX() == nextchain.getX());</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                connectlinks = ((curlink &amp; 1) == 0 &amp;&amp;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                                link.getX() == nextlink.getX());</span>

<span class="nc bnc" id="L492" title="All 4 branches missed.">                if (!connectchains &amp;&amp; !connectlinks) {</span>
                    /*
                     * Strategy 3:
                     * Connect chains or links if their successor is
                     * between them and their potential connectee...
                     */
<span class="nc" id="L498">                    double cx = chain.getX();</span>
<span class="nc" id="L499">                    double lx = link.getX();</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">                    connectchains =</span>
                        (nextchain != null &amp;&amp; cx &lt; lx &amp;&amp;
<span class="nc bnc" id="L502" title="All 2 branches missed.">                         obstructs(nextchain.getX(), lx, curchain));</span>
<span class="nc bnc" id="L503" title="All 4 branches missed.">                    connectlinks =</span>
                        (nextlink != null &amp;&amp; lx &lt; cx &amp;&amp;
<span class="nc bnc" id="L505" title="All 2 branches missed.">                         obstructs(nextlink.getX(), cx, curlink));</span>
                }
            }
<span class="nc bnc" id="L508" title="All 2 branches missed.">            if (connectchains) {</span>
<span class="nc" id="L509">                CurveLink subcurve = chain.linkTo(nextchain);</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                if (subcurve != null) {</span>
<span class="nc" id="L511">                    subcurves.add(subcurve);</span>
                }
<span class="nc" id="L513">                curchain += 2;</span>
<span class="nc" id="L514">                chain = endlist[curchain];</span>
<span class="nc" id="L515">                nextchain = endlist[curchain+1];</span>
            }
<span class="nc bnc" id="L517" title="All 2 branches missed.">            if (connectlinks) {</span>
<span class="nc" id="L518">                ChainEnd openend = new ChainEnd(link, null);</span>
<span class="nc" id="L519">                ChainEnd closeend = new ChainEnd(nextlink, openend);</span>
<span class="nc" id="L520">                openend.setOtherEnd(closeend);</span>
<span class="nc" id="L521">                chains.add(openend);</span>
<span class="nc" id="L522">                chains.add(closeend);</span>
<span class="nc" id="L523">                curlink += 2;</span>
<span class="nc" id="L524">                link = linklist[curlink];</span>
<span class="nc" id="L525">                nextlink = linklist[curlink+1];</span>
            }
<span class="nc bnc" id="L527" title="All 4 branches missed.">            if (!connectchains &amp;&amp; !connectlinks) {</span>
                // assert(link != null);
                // assert(chain != null);
                // assert(chain.getEtag() == link.getEtag());
<span class="nc" id="L531">                chain.addLink(link);</span>
<span class="nc" id="L532">                chains.add(chain);</span>
<span class="nc" id="L533">                curchain++;</span>
<span class="nc" id="L534">                chain = nextchain;</span>
<span class="nc" id="L535">                nextchain = endlist[curchain+1];</span>
<span class="nc" id="L536">                curlink++;</span>
<span class="nc" id="L537">                link = nextlink;</span>
<span class="nc" id="L538">                nextlink = linklist[curlink+1];</span>
            }
<span class="nc" id="L540">        }</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if ((chains.size() &amp; 1) != 0) {</span>
<span class="nc" id="L542">            System.out.println(&quot;Odd number of chains!&quot;);</span>
        }
<span class="nc" id="L544">    }</span>

    /*
     * Does the position of the next edge at v1 &quot;obstruct&quot; the
     * connectivity between current edge and the potential
     * partner edge which is positioned at v2?
     *
     * Phase tells us whether we are testing for a transition
     * into or out of the interior part of the resulting area.
     *
     * Require 4-connected continuity if this edge and the partner
     * edge are both &quot;entering into&quot; type edges
     * Allow 8-connected continuity for &quot;exiting from&quot; type edges
     */
    public static boolean obstructs(double v1, double v2, int phase) {
<span class="nc bnc" id="L559" title="All 6 branches missed.">        return (((phase &amp; 1) == 0) ? (v1 &lt;= v2) : (v1 &lt; v2));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>