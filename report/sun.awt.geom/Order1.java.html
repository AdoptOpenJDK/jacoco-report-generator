<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Order1.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.awt.geom</a> &gt; <span class="el_source">Order1.java</span></div><h1>Order1.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.geom;

import java.awt.geom.Rectangle2D;
import java.awt.geom.PathIterator;
import java.util.Vector;

final class Order1 extends Curve {
    private double x0;
    private double y0;
    private double x1;
    private double y1;
    private double xmin;
    private double xmax;

    public Order1(double x0, double y0,
                  double x1, double y1,
                  int direction)
    {
<span class="nc" id="L44">        super(direction);</span>
<span class="nc" id="L45">        this.x0 = x0;</span>
<span class="nc" id="L46">        this.y0 = y0;</span>
<span class="nc" id="L47">        this.x1 = x1;</span>
<span class="nc" id="L48">        this.y1 = y1;</span>
<span class="nc bnc" id="L49" title="All 2 branches missed.">        if (x0 &lt; x1) {</span>
<span class="nc" id="L50">            this.xmin = x0;</span>
<span class="nc" id="L51">            this.xmax = x1;</span>
        } else {
<span class="nc" id="L53">            this.xmin = x1;</span>
<span class="nc" id="L54">            this.xmax = x0;</span>
        }
<span class="nc" id="L56">    }</span>

    public int getOrder() {
<span class="nc" id="L59">        return 1;</span>
    }

    public double getXTop() {
<span class="nc" id="L63">        return x0;</span>
    }

    public double getYTop() {
<span class="nc" id="L67">        return y0;</span>
    }

    public double getXBot() {
<span class="nc" id="L71">        return x1;</span>
    }

    public double getYBot() {
<span class="nc" id="L75">        return y1;</span>
    }

    public double getXMin() {
<span class="nc" id="L79">        return xmin;</span>
    }

    public double getXMax() {
<span class="nc" id="L83">        return xmax;</span>
    }

    public double getX0() {
<span class="nc bnc" id="L87" title="All 2 branches missed.">        return (direction == INCREASING) ? x0 : x1;</span>
    }

    public double getY0() {
<span class="nc bnc" id="L91" title="All 2 branches missed.">        return (direction == INCREASING) ? y0 : y1;</span>
    }

    public double getX1() {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        return (direction == DECREASING) ? x0 : x1;</span>
    }

    public double getY1() {
<span class="nc bnc" id="L99" title="All 2 branches missed.">        return (direction == DECREASING) ? y0 : y1;</span>
    }

    public double XforY(double y) {
<span class="nc bnc" id="L103" title="All 4 branches missed.">        if (x0 == x1 || y &lt;= y0) {</span>
<span class="nc" id="L104">            return x0;</span>
        }
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (y &gt;= y1) {</span>
<span class="nc" id="L107">            return x1;</span>
        }
        // assert(y0 != y1); /* No horizontal lines... */
<span class="nc" id="L110">        return (x0 + (y - y0) * (x1 - x0) / (y1 - y0));</span>
    }

    public double TforY(double y) {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (y &lt;= y0) {</span>
<span class="nc" id="L115">            return 0;</span>
        }
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (y &gt;= y1) {</span>
<span class="nc" id="L118">            return 1;</span>
        }
<span class="nc" id="L120">        return (y - y0) / (y1 - y0);</span>
    }

    public double XforT(double t) {
<span class="nc" id="L124">        return x0 + t * (x1 - x0);</span>
    }

    public double YforT(double t) {
<span class="nc" id="L128">        return y0 + t * (y1 - y0);</span>
    }

    public double dXforT(double t, int deriv) {
<span class="nc bnc" id="L132" title="All 3 branches missed.">        switch (deriv) {</span>
        case 0:
<span class="nc" id="L134">            return x0 + t * (x1 - x0);</span>
        case 1:
<span class="nc" id="L136">            return (x1 - x0);</span>
        default:
<span class="nc" id="L138">            return 0;</span>
        }
    }

    public double dYforT(double t, int deriv) {
<span class="nc bnc" id="L143" title="All 3 branches missed.">        switch (deriv) {</span>
        case 0:
<span class="nc" id="L145">            return y0 + t * (y1 - y0);</span>
        case 1:
<span class="nc" id="L147">            return (y1 - y0);</span>
        default:
<span class="nc" id="L149">            return 0;</span>
        }
    }

    public double nextVertical(double t0, double t1) {
<span class="nc" id="L154">        return t1;</span>
    }

    public boolean accumulateCrossings(Crossings c) {
<span class="nc" id="L158">        double xlo = c.getXLo();</span>
<span class="nc" id="L159">        double ylo = c.getYLo();</span>
<span class="nc" id="L160">        double xhi = c.getXHi();</span>
<span class="nc" id="L161">        double yhi = c.getYHi();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (xmin &gt;= xhi) {</span>
<span class="nc" id="L163">            return false;</span>
        }
        double xstart, ystart, xend, yend;
<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (y0 &lt; ylo) {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">            if (y1 &lt;= ylo) {</span>
<span class="nc" id="L168">                return false;</span>
            }
<span class="nc" id="L170">            ystart = ylo;</span>
<span class="nc" id="L171">            xstart = XforY(ylo);</span>
        } else {
<span class="nc bnc" id="L173" title="All 2 branches missed.">            if (y0 &gt;= yhi) {</span>
<span class="nc" id="L174">                return false;</span>
            }
<span class="nc" id="L176">            ystart = y0;</span>
<span class="nc" id="L177">            xstart = x0;</span>
        }
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (y1 &gt; yhi) {</span>
<span class="nc" id="L180">            yend = yhi;</span>
<span class="nc" id="L181">            xend = XforY(yhi);</span>
        } else {
<span class="nc" id="L183">            yend = y1;</span>
<span class="nc" id="L184">            xend = x1;</span>
        }
<span class="nc bnc" id="L186" title="All 4 branches missed.">        if (xstart &gt;= xhi &amp;&amp; xend &gt;= xhi) {</span>
<span class="nc" id="L187">            return false;</span>
        }
<span class="nc bnc" id="L189" title="All 4 branches missed.">        if (xstart &gt; xlo || xend &gt; xlo) {</span>
<span class="nc" id="L190">            return true;</span>
        }
<span class="nc" id="L192">        c.record(ystart, yend, direction);</span>
<span class="nc" id="L193">        return false;</span>
    }

    public void enlarge(Rectangle2D r) {
<span class="nc" id="L197">        r.add(x0, y0);</span>
<span class="nc" id="L198">        r.add(x1, y1);</span>
<span class="nc" id="L199">    }</span>

    public Curve getSubCurve(double ystart, double yend, int dir) {
<span class="nc bnc" id="L202" title="All 4 branches missed.">        if (ystart == y0 &amp;&amp; yend == y1) {</span>
<span class="nc" id="L203">            return getWithDirection(dir);</span>
        }
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (x0 == x1) {</span>
<span class="nc" id="L206">            return new Order1(x0, ystart, x1, yend, dir);</span>
        }
<span class="nc" id="L208">        double num = x0 - x1;</span>
<span class="nc" id="L209">        double denom = y0 - y1;</span>
<span class="nc" id="L210">        double xstart = (x0 + (ystart - y0) * num / denom);</span>
<span class="nc" id="L211">        double xend = (x0 + (yend - y0) * num / denom);</span>
<span class="nc" id="L212">        return new Order1(xstart, ystart, xend, yend, dir);</span>
    }

    public Curve getReversedCurve() {
<span class="nc" id="L216">        return new Order1(x0, y0, x1, y1, -direction);</span>
    }

    public int compareTo(Curve other, double yrange[]) {
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (!(other instanceof Order1)) {</span>
<span class="nc" id="L221">            return super.compareTo(other, yrange);</span>
        }
<span class="nc" id="L223">        Order1 c1 = (Order1) other;</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (yrange[1] &lt;= yrange[0]) {</span>
<span class="nc" id="L225">            throw new InternalError(&quot;yrange already screwed up...&quot;);</span>
        }
<span class="nc" id="L227">        yrange[1] = Math.min(Math.min(yrange[1], y1), c1.y1);</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (yrange[1] &lt;= yrange[0]) {</span>
<span class="nc" id="L229">            throw new InternalError(&quot;backstepping from &quot;+yrange[0]+&quot; to &quot;+yrange[1]);</span>
        }
<span class="nc bnc" id="L231" title="All 2 branches missed.">        if (xmax &lt;= c1.xmin) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            return (xmin == c1.xmax) ? 0 : -1;</span>
        }
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (xmin &gt;= c1.xmax) {</span>
<span class="nc" id="L235">            return 1;</span>
        }
        /*
         * If &quot;this&quot; is curve A and &quot;other&quot; is curve B, then...
         * xA(y) = x0A + (y - y0A) (x1A - x0A) / (y1A - y0A)
         * xB(y) = x0B + (y - y0B) (x1B - x0B) / (y1B - y0B)
         * xA(y) == xB(y)
         * x0A + (y - y0A) (x1A - x0A) / (y1A - y0A)
         *    == x0B + (y - y0B) (x1B - x0B) / (y1B - y0B)
         * 0 == x0A (y1A - y0A) (y1B - y0B) + (y - y0A) (x1A - x0A) (y1B - y0B)
         *    - x0B (y1A - y0A) (y1B - y0B) - (y - y0B) (x1B - x0B) (y1A - y0A)
         * 0 == (x0A - x0B) (y1A - y0A) (y1B - y0B)
         *    + (y - y0A) (x1A - x0A) (y1B - y0B)
         *    - (y - y0B) (x1B - x0B) (y1A - y0A)
         * If (dxA == x1A - x0A), etc...
         * 0 == (x0A - x0B) * dyA * dyB
         *    + (y - y0A) * dxA * dyB
         *    - (y - y0B) * dxB * dyA
         * 0 == (x0A - x0B) * dyA * dyB
         *    + y * dxA * dyB - y0A * dxA * dyB
         *    - y * dxB * dyA + y0B * dxB * dyA
         * 0 == (x0A - x0B) * dyA * dyB
         *    + y * dxA * dyB - y * dxB * dyA
         *    - y0A * dxA * dyB + y0B * dxB * dyA
         * 0 == (x0A - x0B) * dyA * dyB
         *    + y * (dxA * dyB - dxB * dyA)
         *    - y0A * dxA * dyB + y0B * dxB * dyA
         * y == ((x0A - x0B) * dyA * dyB
         *       - y0A * dxA * dyB + y0B * dxB * dyA)
         *    / (-(dxA * dyB - dxB * dyA))
         * y == ((x0A - x0B) * dyA * dyB
         *       - y0A * dxA * dyB + y0B * dxB * dyA)
         *    / (dxB * dyA - dxA * dyB)
         */
<span class="nc" id="L269">        double dxa = x1 - x0;</span>
<span class="nc" id="L270">        double dya = y1 - y0;</span>
<span class="nc" id="L271">        double dxb = c1.x1 - c1.x0;</span>
<span class="nc" id="L272">        double dyb = c1.y1 - c1.y0;</span>
<span class="nc" id="L273">        double denom = dxb * dya - dxa * dyb;</span>
        double y;
<span class="nc bnc" id="L275" title="All 2 branches missed.">        if (denom != 0) {</span>
<span class="nc" id="L276">            double num = ((x0 - c1.x0) * dya * dyb</span>
                          - y0 * dxa * dyb
                          + c1.y0 * dxb * dya);
<span class="nc" id="L279">            y = num / denom;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            if (y &lt;= yrange[0]) {</span>
                // intersection is above us
                // Use bottom-most common y for comparison
<span class="nc" id="L283">                y = Math.min(y1, c1.y1);</span>
            } else {
                // intersection is below the top of our range
<span class="nc bnc" id="L286" title="All 2 branches missed.">                if (y &lt; yrange[1]) {</span>
                    // If intersection is in our range, adjust valid range
<span class="nc" id="L288">                    yrange[1] = y;</span>
                }
                // Use top-most common y for comparison
<span class="nc" id="L291">                y = Math.max(y0, c1.y0);</span>
            }
<span class="nc" id="L293">        } else {</span>
            // lines are parallel, choose any common y for comparison
            // Note - prefer an endpoint for speed of calculating the X
            // (see shortcuts in Order1.XforY())
<span class="nc" id="L297">            y = Math.max(y0, c1.y0);</span>
        }
<span class="nc" id="L299">        return orderof(XforY(y), c1.XforY(y));</span>
    }

    public int getSegment(double coords[]) {
<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (direction == INCREASING) {</span>
<span class="nc" id="L304">            coords[0] = x1;</span>
<span class="nc" id="L305">            coords[1] = y1;</span>
        } else {
<span class="nc" id="L307">            coords[0] = x0;</span>
<span class="nc" id="L308">            coords[1] = y0;</span>
        }
<span class="nc" id="L310">        return PathIterator.SEG_LINETO;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>