<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Order3.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.awt.geom</a> &gt; <span class="el_source">Order3.java</span></div><h1>Order3.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.awt.geom;

import java.awt.geom.Rectangle2D;
import java.awt.geom.PathIterator;
import java.awt.geom.QuadCurve2D;
import java.util.Vector;

final class Order3 extends Curve {
    private double x0;
    private double y0;
    private double cx0;
    private double cy0;
    private double cx1;
    private double cy1;
    private double x1;
    private double y1;

    private double xmin;
    private double xmax;

    private double xcoeff0;
    private double xcoeff1;
    private double xcoeff2;
    private double xcoeff3;

    private double ycoeff0;
    private double ycoeff1;
    private double ycoeff2;
    private double ycoeff3;

    public static void insert(Vector curves, double tmp[],
                              double x0, double y0,
                              double cx0, double cy0,
                              double cx1, double cy1,
                              double x1, double y1,
                              int direction)
    {
<span class="nc" id="L63">        int numparams = getHorizontalParams(y0, cy0, cy1, y1, tmp);</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">        if (numparams == 0) {</span>
            // We are using addInstance here to avoid inserting horisontal
            // segments
<span class="nc" id="L67">            addInstance(curves, x0, y0, cx0, cy0, cx1, cy1, x1, y1, direction);</span>
<span class="nc" id="L68">            return;</span>
        }
        // Store coordinates for splitting at tmp[3..10]
<span class="nc" id="L71">        tmp[3] = x0;  tmp[4]  = y0;</span>
<span class="nc" id="L72">        tmp[5] = cx0; tmp[6]  = cy0;</span>
<span class="nc" id="L73">        tmp[7] = cx1; tmp[8]  = cy1;</span>
<span class="nc" id="L74">        tmp[9] = x1;  tmp[10] = y1;</span>
<span class="nc" id="L75">        double t = tmp[0];</span>
<span class="nc bnc" id="L76" title="All 4 branches missed.">        if (numparams &gt; 1 &amp;&amp; t &gt; tmp[1]) {</span>
            // Perform a &quot;2 element sort&quot;...
<span class="nc" id="L78">            tmp[0] = tmp[1];</span>
<span class="nc" id="L79">            tmp[1] = t;</span>
<span class="nc" id="L80">            t = tmp[0];</span>
        }
<span class="nc" id="L82">        split(tmp, 3, t);</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (numparams &gt; 1) {</span>
            // Recalculate tmp[1] relative to the range [tmp[0]...1]
<span class="nc" id="L85">            t = (tmp[1] - t) / (1 - t);</span>
<span class="nc" id="L86">            split(tmp, 9, t);</span>
        }
<span class="nc" id="L88">        int index = 3;</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">        if (direction == DECREASING) {</span>
<span class="nc" id="L90">            index += numparams * 6;</span>
        }
<span class="nc bnc" id="L92" title="All 2 branches missed.">        while (numparams &gt;= 0) {</span>
<span class="nc" id="L93">            addInstance(curves,</span>
                        tmp[index + 0], tmp[index + 1],
                        tmp[index + 2], tmp[index + 3],
                        tmp[index + 4], tmp[index + 5],
                        tmp[index + 6], tmp[index + 7],
                        direction);
<span class="nc" id="L99">            numparams--;</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">            if (direction == INCREASING) {</span>
<span class="nc" id="L101">                index += 6;</span>
            } else {
<span class="nc" id="L103">                index -= 6;</span>
            }
        }
<span class="nc" id="L106">    }</span>

    public static void addInstance(Vector curves,
                                   double x0, double y0,
                                   double cx0, double cy0,
                                   double cx1, double cy1,
                                   double x1, double y1,
                                   int direction) {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (y0 &gt; y1) {</span>
<span class="nc" id="L115">            curves.add(new Order3(x1, y1, cx1, cy1, cx0, cy0, x0, y0,</span>
                                  -direction));
<span class="nc bnc" id="L117" title="All 2 branches missed.">        } else if (y1 &gt; y0) {</span>
<span class="nc" id="L118">            curves.add(new Order3(x0, y0, cx0, cy0, cx1, cy1, x1, y1,</span>
                                  direction));
        }
<span class="nc" id="L121">    }</span>

    /*
     * Return the count of the number of horizontal sections of the
     * specified cubic Bezier curve.  Put the parameters for the
     * horizontal sections into the specified &lt;code&gt;ret&lt;/code&gt; array.
     * &lt;p&gt;
     * If we examine the parametric equation in t, we have:
     *   Py(t) = C0(1-t)^3 + 3CP0 t(1-t)^2 + 3CP1 t^2(1-t) + C1 t^3
     *         = C0 - 3C0t + 3C0t^2 - C0t^3 +
     *           3CP0t - 6CP0t^2 + 3CP0t^3 +
     *           3CP1t^2 - 3CP1t^3 +
     *           C1t^3
     *   Py(t) = (C1 - 3CP1 + 3CP0 - C0) t^3 +
     *           (3C0 - 6CP0 + 3CP1) t^2 +
     *           (3CP0 - 3C0) t +
     *           (C0)
     * If we take the derivative, we get:
     *   Py(t) = Dt^3 + At^2 + Bt + C
     *   dPy(t) = 3Dt^2 + 2At + B = 0
     *        0 = 3*(C1 - 3*CP1 + 3*CP0 - C0)t^2
     *          + 2*(3*CP1 - 6*CP0 + 3*C0)t
     *          + (3*CP0 - 3*C0)
     *        0 = 3*(C1 - 3*CP1 + 3*CP0 - C0)t^2
     *          + 3*2*(CP1 - 2*CP0 + C0)t
     *          + 3*(CP0 - C0)
     *        0 = (C1 - CP1 - CP1 - CP1 + CP0 + CP0 + CP0 - C0)t^2
     *          + 2*(CP1 - CP0 - CP0 + C0)t
     *          + (CP0 - C0)
     *        0 = (C1 - CP1 + CP0 - CP1 + CP0 - CP1 + CP0 - C0)t^2
     *          + 2*(CP1 - CP0 - CP0 + C0)t
     *          + (CP0 - C0)
     *        0 = ((C1 - CP1) - (CP1 - CP0) - (CP1 - CP0) + (CP0 - C0))t^2
     *          + 2*((CP1 - CP0) - (CP0 - C0))t
     *          + (CP0 - C0)
     * Note that this method will return 0 if the equation is a line,
     * which is either always horizontal or never horizontal.
     * Completely horizontal curves need to be eliminated by other
     * means outside of this method.
     */
    public static int getHorizontalParams(double c0, double cp0,
                                          double cp1, double c1,
                                          double ret[]) {
<span class="nc bnc" id="L164" title="All 6 branches missed.">        if (c0 &lt;= cp0 &amp;&amp; cp0 &lt;= cp1 &amp;&amp; cp1 &lt;= c1) {</span>
<span class="nc" id="L165">            return 0;</span>
        }
<span class="nc" id="L167">        c1 -= cp1;</span>
<span class="nc" id="L168">        cp1 -= cp0;</span>
<span class="nc" id="L169">        cp0 -= c0;</span>
<span class="nc" id="L170">        ret[0] = cp0;</span>
<span class="nc" id="L171">        ret[1] = (cp1 - cp0) * 2;</span>
<span class="nc" id="L172">        ret[2] = (c1 - cp1 - cp1 + cp0);</span>
<span class="nc" id="L173">        int numroots = QuadCurve2D.solveQuadratic(ret, ret);</span>
<span class="nc" id="L174">        int j = 0;</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        for (int i = 0; i &lt; numroots; i++) {</span>
<span class="nc" id="L176">            double t = ret[i];</span>
            // No splits at t==0 and t==1
<span class="nc bnc" id="L178" title="All 4 branches missed.">            if (t &gt; 0 &amp;&amp; t &lt; 1) {</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                if (j &lt; i) {</span>
<span class="nc" id="L180">                    ret[j] = t;</span>
                }
<span class="nc" id="L182">                j++;</span>
            }
        }
<span class="nc" id="L185">        return j;</span>
    }

    /*
     * Split the cubic Bezier stored at coords[pos...pos+7] representing
     * the parametric range [0..1] into two subcurves representing the
     * parametric subranges [0..t] and [t..1].  Store the results back
     * into the array at coords[pos...pos+7] and coords[pos+6...pos+13].
     */
    public static void split(double coords[], int pos, double t) {
        double x0, y0, cx0, cy0, cx1, cy1, x1, y1;
<span class="nc" id="L196">        coords[pos+12] = x1 = coords[pos+6];</span>
<span class="nc" id="L197">        coords[pos+13] = y1 = coords[pos+7];</span>
<span class="nc" id="L198">        cx1 = coords[pos+4];</span>
<span class="nc" id="L199">        cy1 = coords[pos+5];</span>
<span class="nc" id="L200">        x1 = cx1 + (x1 - cx1) * t;</span>
<span class="nc" id="L201">        y1 = cy1 + (y1 - cy1) * t;</span>
<span class="nc" id="L202">        x0 = coords[pos+0];</span>
<span class="nc" id="L203">        y0 = coords[pos+1];</span>
<span class="nc" id="L204">        cx0 = coords[pos+2];</span>
<span class="nc" id="L205">        cy0 = coords[pos+3];</span>
<span class="nc" id="L206">        x0 = x0 + (cx0 - x0) * t;</span>
<span class="nc" id="L207">        y0 = y0 + (cy0 - y0) * t;</span>
<span class="nc" id="L208">        cx0 = cx0 + (cx1 - cx0) * t;</span>
<span class="nc" id="L209">        cy0 = cy0 + (cy1 - cy0) * t;</span>
<span class="nc" id="L210">        cx1 = cx0 + (x1 - cx0) * t;</span>
<span class="nc" id="L211">        cy1 = cy0 + (y1 - cy0) * t;</span>
<span class="nc" id="L212">        cx0 = x0 + (cx0 - x0) * t;</span>
<span class="nc" id="L213">        cy0 = y0 + (cy0 - y0) * t;</span>
<span class="nc" id="L214">        coords[pos+2] = x0;</span>
<span class="nc" id="L215">        coords[pos+3] = y0;</span>
<span class="nc" id="L216">        coords[pos+4] = cx0;</span>
<span class="nc" id="L217">        coords[pos+5] = cy0;</span>
<span class="nc" id="L218">        coords[pos+6] = cx0 + (cx1 - cx0) * t;</span>
<span class="nc" id="L219">        coords[pos+7] = cy0 + (cy1 - cy0) * t;</span>
<span class="nc" id="L220">        coords[pos+8] = cx1;</span>
<span class="nc" id="L221">        coords[pos+9] = cy1;</span>
<span class="nc" id="L222">        coords[pos+10] = x1;</span>
<span class="nc" id="L223">        coords[pos+11] = y1;</span>
<span class="nc" id="L224">    }</span>

    public Order3(double x0, double y0,
                  double cx0, double cy0,
                  double cx1, double cy1,
                  double x1, double y1,
                  int direction)
    {
<span class="nc" id="L232">        super(direction);</span>
        // REMIND: Better accuracy in the root finding methods would
        //  ensure that cys are in range.  As it stands, they are never
        //  more than &quot;1 mantissa bit&quot; out of range...
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (cy0 &lt; y0) cy0 = y0;</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (cy1 &gt; y1) cy1 = y1;</span>
<span class="nc" id="L238">        this.x0 = x0;</span>
<span class="nc" id="L239">        this.y0 = y0;</span>
<span class="nc" id="L240">        this.cx0 = cx0;</span>
<span class="nc" id="L241">        this.cy0 = cy0;</span>
<span class="nc" id="L242">        this.cx1 = cx1;</span>
<span class="nc" id="L243">        this.cy1 = cy1;</span>
<span class="nc" id="L244">        this.x1 = x1;</span>
<span class="nc" id="L245">        this.y1 = y1;</span>
<span class="nc" id="L246">        xmin = Math.min(Math.min(x0, x1), Math.min(cx0, cx1));</span>
<span class="nc" id="L247">        xmax = Math.max(Math.max(x0, x1), Math.max(cx0, cx1));</span>
<span class="nc" id="L248">        xcoeff0 = x0;</span>
<span class="nc" id="L249">        xcoeff1 = (cx0 - x0) * 3.0;</span>
<span class="nc" id="L250">        xcoeff2 = (cx1 - cx0 - cx0 + x0) * 3.0;</span>
<span class="nc" id="L251">        xcoeff3 = x1 - (cx1 - cx0) * 3.0 - x0;</span>
<span class="nc" id="L252">        ycoeff0 = y0;</span>
<span class="nc" id="L253">        ycoeff1 = (cy0 - y0) * 3.0;</span>
<span class="nc" id="L254">        ycoeff2 = (cy1 - cy0 - cy0 + y0) * 3.0;</span>
<span class="nc" id="L255">        ycoeff3 = y1 - (cy1 - cy0) * 3.0 - y0;</span>
<span class="nc" id="L256">        YforT1 = YforT2 = YforT3 = y0;</span>
<span class="nc" id="L257">    }</span>

    public int getOrder() {
<span class="nc" id="L260">        return 3;</span>
    }

    public double getXTop() {
<span class="nc" id="L264">        return x0;</span>
    }

    public double getYTop() {
<span class="nc" id="L268">        return y0;</span>
    }

    public double getXBot() {
<span class="nc" id="L272">        return x1;</span>
    }

    public double getYBot() {
<span class="nc" id="L276">        return y1;</span>
    }

    public double getXMin() {
<span class="nc" id="L280">        return xmin;</span>
    }

    public double getXMax() {
<span class="nc" id="L284">        return xmax;</span>
    }

    public double getX0() {
<span class="nc bnc" id="L288" title="All 2 branches missed.">        return (direction == INCREASING) ? x0 : x1;</span>
    }

    public double getY0() {
<span class="nc bnc" id="L292" title="All 2 branches missed.">        return (direction == INCREASING) ? y0 : y1;</span>
    }

    public double getCX0() {
<span class="nc bnc" id="L296" title="All 2 branches missed.">        return (direction == INCREASING) ? cx0 : cx1;</span>
    }

    public double getCY0() {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        return (direction == INCREASING) ? cy0 : cy1;</span>
    }

    public double getCX1() {
<span class="nc bnc" id="L304" title="All 2 branches missed.">        return (direction == DECREASING) ? cx0 : cx1;</span>
    }

    public double getCY1() {
<span class="nc bnc" id="L308" title="All 2 branches missed.">        return (direction == DECREASING) ? cy0 : cy1;</span>
    }

    public double getX1() {
<span class="nc bnc" id="L312" title="All 2 branches missed.">        return (direction == DECREASING) ? x0 : x1;</span>
    }

    public double getY1() {
<span class="nc bnc" id="L316" title="All 2 branches missed.">        return (direction == DECREASING) ? y0 : y1;</span>
    }

    private double TforY1;
    private double YforT1;
    private double TforY2;
    private double YforT2;
    private double TforY3;
    private double YforT3;

    /*
     * Solve the cubic whose coefficients are in the a,b,c,d fields and
     * return the first root in the range [0, 1].
     * The cubic solved is represented by the equation:
     *     x^3 + (ycoeff2)x^2 + (ycoeff1)x + (ycoeff0) = y
     * @return the first valid root (in the range [0, 1])
     */
    public double TforY(double y) {
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (y &lt;= y0) return 0;</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (y &gt;= y1) return 1;</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (y == YforT1) return TforY1;</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (y == YforT2) return TforY2;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (y == YforT3) return TforY3;</span>
        // From Numerical Recipes, 5.6, Quadratic and Cubic Equations
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (ycoeff3 == 0.0) {</span>
            // The cubic degenerated to quadratic (or line or ...).
<span class="nc" id="L342">            return Order2.TforY(y, ycoeff0, ycoeff1, ycoeff2);</span>
        }
<span class="nc" id="L344">        double a = ycoeff2 / ycoeff3;</span>
<span class="nc" id="L345">        double b = ycoeff1 / ycoeff3;</span>
<span class="nc" id="L346">        double c = (ycoeff0 - y) / ycoeff3;</span>
<span class="nc" id="L347">        int roots = 0;</span>
<span class="nc" id="L348">        double Q = (a * a - 3.0 * b) / 9.0;</span>
<span class="nc" id="L349">        double R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;</span>
<span class="nc" id="L350">        double R2 = R * R;</span>
<span class="nc" id="L351">        double Q3 = Q * Q * Q;</span>
<span class="nc" id="L352">        double a_3 = a / 3.0;</span>
        double t;
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (R2 &lt; Q3) {</span>
<span class="nc" id="L355">            double theta = Math.acos(R / Math.sqrt(Q3));</span>
<span class="nc" id="L356">            Q = -2.0 * Math.sqrt(Q);</span>
<span class="nc" id="L357">            t = refine(a, b, c, y, Q * Math.cos(theta / 3.0) - a_3);</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">            if (t &lt; 0) {</span>
<span class="nc" id="L359">                t = refine(a, b, c, y,</span>
<span class="nc" id="L360">                           Q * Math.cos((theta + Math.PI * 2.0)/ 3.0) - a_3);</span>
            }
<span class="nc bnc" id="L362" title="All 2 branches missed.">            if (t &lt; 0) {</span>
<span class="nc" id="L363">                t = refine(a, b, c, y,</span>
<span class="nc" id="L364">                           Q * Math.cos((theta - Math.PI * 2.0)/ 3.0) - a_3);</span>
            }
<span class="nc" id="L366">        } else {</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            boolean neg = (R &lt; 0.0);</span>
<span class="nc" id="L368">            double S = Math.sqrt(R2 - Q3);</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (neg) {</span>
<span class="nc" id="L370">                R = -R;</span>
            }
<span class="nc" id="L372">            double A = Math.pow(R + S, 1.0 / 3.0);</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            if (!neg) {</span>
<span class="nc" id="L374">                A = -A;</span>
            }
<span class="nc bnc" id="L376" title="All 2 branches missed.">            double B = (A == 0.0) ? 0.0 : (Q / A);</span>
<span class="nc" id="L377">            t = refine(a, b, c, y, (A + B) - a_3);</span>
        }
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (t &lt; 0) {</span>
            //throw new InternalError(&quot;bad t&quot;);
<span class="nc" id="L381">            double t0 = 0;</span>
<span class="nc" id="L382">            double t1 = 1;</span>
            while (true) {
<span class="nc" id="L384">                t = (t0 + t1) / 2;</span>
<span class="nc bnc" id="L385" title="All 4 branches missed.">                if (t == t0 || t == t1) {</span>
<span class="nc" id="L386">                    break;</span>
                }
<span class="nc" id="L388">                double yt = YforT(t);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                if (yt &lt; y) {</span>
<span class="nc" id="L390">                    t0 = t;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">                } else if (yt &gt; y) {</span>
<span class="nc" id="L392">                    t1 = t;</span>
                } else {
                    break;
                }
<span class="nc" id="L396">            }</span>
        }
<span class="nc bnc" id="L398" title="All 2 branches missed.">        if (t &gt;= 0) {</span>
<span class="nc" id="L399">            TforY3 = TforY2;</span>
<span class="nc" id="L400">            YforT3 = YforT2;</span>
<span class="nc" id="L401">            TforY2 = TforY1;</span>
<span class="nc" id="L402">            YforT2 = YforT1;</span>
<span class="nc" id="L403">            TforY1 = t;</span>
<span class="nc" id="L404">            YforT1 = y;</span>
        }
<span class="nc" id="L406">        return t;</span>
    }

    public double refine(double a, double b, double c,
                         double target, double t)
    {
<span class="nc bnc" id="L412" title="All 4 branches missed.">        if (t &lt; -0.1 || t &gt; 1.1) {</span>
<span class="nc" id="L413">            return -1;</span>
        }
<span class="nc" id="L415">        double y = YforT(t);</span>
        double t0, t1;
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (y &lt; target) {</span>
<span class="nc" id="L418">            t0 = t;</span>
<span class="nc" id="L419">            t1 = 1;</span>
        } else {
<span class="nc" id="L421">            t0 = 0;</span>
<span class="nc" id="L422">            t1 = t;</span>
        }
<span class="nc" id="L424">        double origt = t;</span>
<span class="nc" id="L425">        double origy = y;</span>
<span class="nc" id="L426">        boolean useslope = true;</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">        while (y != target) {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">            if (!useslope) {</span>
<span class="nc" id="L429">                double t2 = (t0 + t1) / 2;</span>
<span class="nc bnc" id="L430" title="All 4 branches missed.">                if (t2 == t0 || t2 == t1) {</span>
<span class="nc" id="L431">                    break;</span>
                }
<span class="nc" id="L433">                t = t2;</span>
<span class="nc" id="L434">            } else {</span>
<span class="nc" id="L435">                double slope = dYforT(t, 1);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                if (slope == 0) {</span>
<span class="nc" id="L437">                    useslope = false;</span>
<span class="nc" id="L438">                    continue;</span>
                }
<span class="nc" id="L440">                double t2 = t + ((target - y) / slope);</span>
<span class="nc bnc" id="L441" title="All 6 branches missed.">                if (t2 == t || t2 &lt;= t0 || t2 &gt;= t1) {</span>
<span class="nc" id="L442">                    useslope = false;</span>
<span class="nc" id="L443">                    continue;</span>
                }
<span class="nc" id="L445">                t = t2;</span>
            }
<span class="nc" id="L447">            y = YforT(t);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (y &lt; target) {</span>
<span class="nc" id="L449">                t0 = t;</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">            } else if (y &gt; target) {</span>
<span class="nc" id="L451">                t1 = t;</span>
            } else {
                break;
            }
        }
<span class="nc" id="L456">        boolean verbose = false;</span>
        if (false &amp;&amp; t &gt;= 0 &amp;&amp; t &lt;= 1) {
            y = YforT(t);
            long tdiff = diffbits(t, origt);
            long ydiff = diffbits(y, origy);
            long yerr = diffbits(y, target);
            if (yerr &gt; 0 || (verbose &amp;&amp; tdiff &gt; 0)) {
                System.out.println(&quot;target was y = &quot;+target);
                System.out.println(&quot;original was y = &quot;+origy+&quot;, t = &quot;+origt);
                System.out.println(&quot;final was y = &quot;+y+&quot;, t = &quot;+t);
                System.out.println(&quot;t diff is &quot;+tdiff);
                System.out.println(&quot;y diff is &quot;+ydiff);
                System.out.println(&quot;y error is &quot;+yerr);
                double tlow = prev(t);
                double ylow = YforT(tlow);
                double thi = next(t);
                double yhi = YforT(thi);
                if (Math.abs(target - ylow) &lt; Math.abs(target - y) ||
                    Math.abs(target - yhi) &lt; Math.abs(target - y))
                {
                    System.out.println(&quot;adjacent y's = [&quot;+ylow+&quot;, &quot;+yhi+&quot;]&quot;);
                }
            }
        }
<span class="nc bnc" id="L480" title="All 2 branches missed.">        return (t &gt; 1) ? -1 : t;</span>
    }

    public double XforY(double y) {
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (y &lt;= y0) {</span>
<span class="nc" id="L485">            return x0;</span>
        }
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (y &gt;= y1) {</span>
<span class="nc" id="L488">            return x1;</span>
        }
<span class="nc" id="L490">        return XforT(TforY(y));</span>
    }

    public double XforT(double t) {
<span class="nc" id="L494">        return (((xcoeff3 * t) + xcoeff2) * t + xcoeff1) * t + xcoeff0;</span>
    }

    public double YforT(double t) {
<span class="nc" id="L498">        return (((ycoeff3 * t) + ycoeff2) * t + ycoeff1) * t + ycoeff0;</span>
    }

    public double dXforT(double t, int deriv) {
<span class="nc bnc" id="L502" title="All 5 branches missed.">        switch (deriv) {</span>
        case 0:
<span class="nc" id="L504">            return (((xcoeff3 * t) + xcoeff2) * t + xcoeff1) * t + xcoeff0;</span>
        case 1:
<span class="nc" id="L506">            return ((3 * xcoeff3 * t) + 2 * xcoeff2) * t + xcoeff1;</span>
        case 2:
<span class="nc" id="L508">            return (6 * xcoeff3 * t) + 2 * xcoeff2;</span>
        case 3:
<span class="nc" id="L510">            return 6 * xcoeff3;</span>
        default:
<span class="nc" id="L512">            return 0;</span>
        }
    }

    public double dYforT(double t, int deriv) {
<span class="nc bnc" id="L517" title="All 5 branches missed.">        switch (deriv) {</span>
        case 0:
<span class="nc" id="L519">            return (((ycoeff3 * t) + ycoeff2) * t + ycoeff1) * t + ycoeff0;</span>
        case 1:
<span class="nc" id="L521">            return ((3 * ycoeff3 * t) + 2 * ycoeff2) * t + ycoeff1;</span>
        case 2:
<span class="nc" id="L523">            return (6 * ycoeff3 * t) + 2 * ycoeff2;</span>
        case 3:
<span class="nc" id="L525">            return 6 * ycoeff3;</span>
        default:
<span class="nc" id="L527">            return 0;</span>
        }
    }

    public double nextVertical(double t0, double t1) {
<span class="nc" id="L532">        double eqn[] = {xcoeff1, 2 * xcoeff2, 3 * xcoeff3};</span>
<span class="nc" id="L533">        int numroots = QuadCurve2D.solveQuadratic(eqn, eqn);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        for (int i = 0; i &lt; numroots; i++) {</span>
<span class="nc bnc" id="L535" title="All 4 branches missed.">            if (eqn[i] &gt; t0 &amp;&amp; eqn[i] &lt; t1) {</span>
<span class="nc" id="L536">                t1 = eqn[i];</span>
            }
        }
<span class="nc" id="L539">        return t1;</span>
    }

    public void enlarge(Rectangle2D r) {
<span class="nc" id="L543">        r.add(x0, y0);</span>
<span class="nc" id="L544">        double eqn[] = {xcoeff1, 2 * xcoeff2, 3 * xcoeff3};</span>
<span class="nc" id="L545">        int numroots = QuadCurve2D.solveQuadratic(eqn, eqn);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        for (int i = 0; i &lt; numroots; i++) {</span>
<span class="nc" id="L547">            double t = eqn[i];</span>
<span class="nc bnc" id="L548" title="All 4 branches missed.">            if (t &gt; 0 &amp;&amp; t &lt; 1) {</span>
<span class="nc" id="L549">                r.add(XforT(t), YforT(t));</span>
            }
        }
<span class="nc" id="L552">        r.add(x1, y1);</span>
<span class="nc" id="L553">    }</span>

    public Curve getSubCurve(double ystart, double yend, int dir) {
<span class="nc bnc" id="L556" title="All 4 branches missed.">        if (ystart &lt;= y0 &amp;&amp; yend &gt;= y1) {</span>
<span class="nc" id="L557">            return getWithDirection(dir);</span>
        }
<span class="nc" id="L559">        double eqn[] = new double[14];</span>
        double t0, t1;
<span class="nc" id="L561">        t0 = TforY(ystart);</span>
<span class="nc" id="L562">        t1 = TforY(yend);</span>
<span class="nc" id="L563">        eqn[0] = x0;</span>
<span class="nc" id="L564">        eqn[1] = y0;</span>
<span class="nc" id="L565">        eqn[2] = cx0;</span>
<span class="nc" id="L566">        eqn[3] = cy0;</span>
<span class="nc" id="L567">        eqn[4] = cx1;</span>
<span class="nc" id="L568">        eqn[5] = cy1;</span>
<span class="nc" id="L569">        eqn[6] = x1;</span>
<span class="nc" id="L570">        eqn[7] = y1;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (t0 &gt; t1) {</span>
            /* This happens in only rare cases where ystart is
             * very near yend and solving for the yend root ends
             * up stepping slightly lower in t than solving for
             * the ystart root.
             * Ideally we might want to skip this tiny little
             * segment and just fudge the surrounding coordinates
             * to bridge the gap left behind, but there is no way
             * to do that from here.  Higher levels could
             * potentially eliminate these tiny &quot;fixup&quot; segments,
             * but not without a lot of extra work on the code that
             * coalesces chains of curves into subpaths.  The
             * simplest solution for now is to just reorder the t
             * values and chop out a miniscule curve piece.
             */
<span class="nc" id="L586">            double t = t0;</span>
<span class="nc" id="L587">            t0 = t1;</span>
<span class="nc" id="L588">            t1 = t;</span>
        }
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if (t1 &lt; 1) {</span>
<span class="nc" id="L591">            split(eqn, 0, t1);</span>
        }
        int i;
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (t0 &lt;= 0) {</span>
<span class="nc" id="L595">            i = 0;</span>
        } else {
<span class="nc" id="L597">            split(eqn, 0, t0 / t1);</span>
<span class="nc" id="L598">            i = 6;</span>
        }
<span class="nc" id="L600">        return new Order3(eqn[i+0], ystart,</span>
                          eqn[i+2], eqn[i+3],
                          eqn[i+4], eqn[i+5],
                          eqn[i+6], yend,
                          dir);
    }

    public Curve getReversedCurve() {
<span class="nc" id="L608">        return new Order3(x0, y0, cx0, cy0, cx1, cy1, x1, y1, -direction);</span>
    }

    public int getSegment(double coords[]) {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (direction == INCREASING) {</span>
<span class="nc" id="L613">            coords[0] = cx0;</span>
<span class="nc" id="L614">            coords[1] = cy0;</span>
<span class="nc" id="L615">            coords[2] = cx1;</span>
<span class="nc" id="L616">            coords[3] = cy1;</span>
<span class="nc" id="L617">            coords[4] = x1;</span>
<span class="nc" id="L618">            coords[5] = y1;</span>
        } else {
<span class="nc" id="L620">            coords[0] = cx1;</span>
<span class="nc" id="L621">            coords[1] = cy1;</span>
<span class="nc" id="L622">            coords[2] = cx0;</span>
<span class="nc" id="L623">            coords[3] = cy0;</span>
<span class="nc" id="L624">            coords[4] = x0;</span>
<span class="nc" id="L625">            coords[5] = y0;</span>
        }
<span class="nc" id="L627">        return PathIterator.SEG_CUBICTO;</span>
    }

    public String controlPointString() {
<span class="nc" id="L631">        return ((&quot;(&quot;+round(getCX0())+&quot;, &quot;+round(getCY0())+&quot;), &quot;)+</span>
<span class="nc" id="L632">                (&quot;(&quot;+round(getCX1())+&quot;, &quot;+round(getCY1())+&quot;), &quot;));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>