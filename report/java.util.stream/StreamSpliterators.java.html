<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>StreamSpliterators.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.stream</a> &gt; <span class="el_source">StreamSpliterators.java</span></div><h1>StreamSpliterators.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util.stream;

import java.util.Comparator;
import java.util.Objects;
import java.util.Spliterator;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import java.util.function.DoubleConsumer;
import java.util.function.DoubleSupplier;
import java.util.function.IntConsumer;
import java.util.function.IntSupplier;
import java.util.function.LongConsumer;
import java.util.function.LongSupplier;
import java.util.function.Supplier;

/**
 * Spliterator implementations for wrapping and delegating spliterators, used
 * in the implementation of the {@link Stream#spliterator()} method.
 *
 * @since 1.8
 */
<span class="nc" id="L48">class StreamSpliterators {</span>

    /**
     * Abstract wrapping spliterator that binds to the spliterator of a
     * pipeline helper on first operation.
     *
     * &lt;p&gt;This spliterator is not late-binding and will bind to the source
     * spliterator when first operated on.
     *
     * &lt;p&gt;A wrapping spliterator produced from a sequential stream
     * cannot be split if there are stateful operations present.
     */
    private static abstract class AbstractWrappingSpliterator&lt;P_IN, P_OUT,
                                                              T_BUFFER extends AbstractSpinedBuffer&gt;
            implements Spliterator&lt;P_OUT&gt; {

        // @@@ Detect if stateful operations are present or not
        //     If not then can split otherwise cannot

        /**
         * True if this spliterator supports splitting
         */
        final boolean isParallel;

        final PipelineHelper&lt;P_OUT&gt; ph;

        /**
         * Supplier for the source spliterator.  Client provides either a
         * spliterator or a supplier.
         */
        private Supplier&lt;Spliterator&lt;P_IN&gt;&gt; spliteratorSupplier;

        /**
         * Source spliterator.  Either provided from client or obtained from
         * supplier.
         */
        Spliterator&lt;P_IN&gt; spliterator;

        /**
         * Sink chain for the downstream stages of the pipeline, ultimately
         * leading to the buffer. Used during partial traversal.
         */
        Sink&lt;P_IN&gt; bufferSink;

        /**
         * A function that advances one element of the spliterator, pushing
         * it to bufferSink.  Returns whether any elements were processed.
         * Used during partial traversal.
         */
        BooleanSupplier pusher;

        /** Next element to consume from the buffer, used during partial traversal */
        long nextToConsume;

        /** Buffer into which elements are pushed.  Used during partial traversal. */
        T_BUFFER buffer;

        /**
         * True if full traversal has occurred (with possible cancelation).
         * If doing a partial traversal, there may be still elements in buffer.
         */
        boolean finished;

        /**
         * Construct an AbstractWrappingSpliterator from a
         * {@code Supplier&lt;Spliterator&gt;}.
         */
        AbstractWrappingSpliterator(PipelineHelper&lt;P_OUT&gt; ph,
                                    Supplier&lt;Spliterator&lt;P_IN&gt;&gt; spliteratorSupplier,
<span class="fc" id="L117">                                    boolean parallel) {</span>
<span class="fc" id="L118">            this.ph = ph;</span>
<span class="fc" id="L119">            this.spliteratorSupplier = spliteratorSupplier;</span>
<span class="fc" id="L120">            this.spliterator = null;</span>
<span class="fc" id="L121">            this.isParallel = parallel;</span>
<span class="fc" id="L122">        }</span>

        /**
         * Construct an AbstractWrappingSpliterator from a
         * {@code Spliterator}.
         */
        AbstractWrappingSpliterator(PipelineHelper&lt;P_OUT&gt; ph,
                                    Spliterator&lt;P_IN&gt; spliterator,
<span class="nc" id="L130">                                    boolean parallel) {</span>
<span class="nc" id="L131">            this.ph = ph;</span>
<span class="nc" id="L132">            this.spliteratorSupplier = null;</span>
<span class="nc" id="L133">            this.spliterator = spliterator;</span>
<span class="nc" id="L134">            this.isParallel = parallel;</span>
<span class="nc" id="L135">        }</span>

        /**
         * Called before advancing to set up spliterator, if needed.
         */
        final void init() {
<span class="fc bfc" id="L141" title="All 2 branches covered.">            if (spliterator == null) {</span>
<span class="fc" id="L142">                spliterator = spliteratorSupplier.get();</span>
<span class="fc" id="L143">                spliteratorSupplier = null;</span>
            }
<span class="fc" id="L145">        }</span>

        /**
         * Get an element from the source, pushing it into the sink chain,
         * setting up the buffer if needed
         * @return whether there are elements to consume from the buffer
         */
        final boolean doAdvance() {
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (buffer == null) {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                if (finished)</span>
<span class="nc" id="L155">                    return false;</span>

<span class="nc" id="L157">                init();</span>
<span class="nc" id="L158">                initPartialTraversalState();</span>
<span class="nc" id="L159">                nextToConsume = 0;</span>
<span class="nc" id="L160">                bufferSink.begin(spliterator.getExactSizeIfKnown());</span>
<span class="nc" id="L161">                return fillBuffer();</span>
            }
            else {
<span class="nc" id="L164">                ++nextToConsume;</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                boolean hasNext = nextToConsume &lt; buffer.count();</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">                if (!hasNext) {</span>
<span class="nc" id="L167">                    nextToConsume = 0;</span>
<span class="nc" id="L168">                    buffer.clear();</span>
<span class="nc" id="L169">                    hasNext = fillBuffer();</span>
                }
<span class="nc" id="L171">                return hasNext;</span>
            }
        }

        /**
         * Invokes the shape-specific constructor with the provided arguments
         * and returns the result.
         */
        abstract AbstractWrappingSpliterator&lt;P_IN, P_OUT, ?&gt; wrap(Spliterator&lt;P_IN&gt; s);

        /**
         * Initializes buffer, sink chain, and pusher for a shape-specific
         * implementation.
         */
        abstract void initPartialTraversalState();

        @Override
        public Spliterator&lt;P_OUT&gt; trySplit() {
<span class="nc bnc" id="L189" title="All 4 branches missed.">            if (isParallel &amp;&amp; !finished) {</span>
<span class="nc" id="L190">                init();</span>

<span class="nc" id="L192">                Spliterator&lt;P_IN&gt; split = spliterator.trySplit();</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                return (split == null) ? null : wrap(split);</span>
            }
            else
<span class="nc" id="L196">                return null;</span>
        }

        /**
         * If the buffer is empty, push elements into the sink chain until
         * the source is empty or cancellation is requested.
         * @return whether there are elements to consume from the buffer
         */
        private boolean fillBuffer() {
<span class="nc bnc" id="L205" title="All 2 branches missed.">            while (buffer.count() == 0) {</span>
<span class="nc bnc" id="L206" title="All 4 branches missed.">                if (bufferSink.cancellationRequested() || !pusher.getAsBoolean()) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                    if (finished)</span>
<span class="nc" id="L208">                        return false;</span>
                    else {
<span class="nc" id="L210">                        bufferSink.end(); // might trigger more elements</span>
<span class="nc" id="L211">                        finished = true;</span>
                    }
                }
            }
<span class="nc" id="L215">            return true;</span>
        }

        @Override
        public final long estimateSize() {
<span class="nc" id="L220">            init();</span>
            // Use the estimate of the wrapped spliterator
            // Note this may not be accurate if there are filter/flatMap
            // operations filtering or adding elements to the stream
<span class="nc" id="L224">            return spliterator.estimateSize();</span>
        }

        @Override
        public final long getExactSizeIfKnown() {
<span class="fc" id="L229">            init();</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            return StreamOpFlag.SIZED.isKnown(ph.getStreamAndOpFlags())</span>
<span class="pc" id="L231">                   ? spliterator.getExactSizeIfKnown()</span>
                   : -1;
        }

        @Override
        public final int characteristics() {
<span class="nc" id="L237">            init();</span>

            // Get the characteristics from the pipeline
<span class="nc" id="L240">            int c = StreamOpFlag.toCharacteristics(StreamOpFlag.toStreamFlags(ph.getStreamAndOpFlags()));</span>

            // Mask off the size and uniform characteristics and replace with
            // those of the spliterator
            // Note that a non-uniform spliterator can change from something
            // with an exact size to an estimate for a sub-split, for example
            // with HashSet where the size is known at the top level spliterator
            // but for sub-splits only an estimate is known
<span class="nc bnc" id="L248" title="All 2 branches missed.">            if ((c &amp; Spliterator.SIZED) != 0) {</span>
<span class="nc" id="L249">                c &amp;= ~(Spliterator.SIZED | Spliterator.SUBSIZED);</span>
<span class="nc" id="L250">                c |= (spliterator.characteristics() &amp; (Spliterator.SIZED | Spliterator.SUBSIZED));</span>
            }

<span class="nc" id="L253">            return c;</span>
        }

        @Override
        public Comparator&lt;? super P_OUT&gt; getComparator() {
<span class="nc bnc" id="L258" title="All 2 branches missed.">            if (!hasCharacteristics(SORTED))</span>
<span class="nc" id="L259">                throw new IllegalStateException();</span>
<span class="nc" id="L260">            return null;</span>
        }

        @Override
        public final String toString() {
<span class="nc" id="L265">            return String.format(&quot;%s[%s]&quot;, getClass().getName(), spliterator);</span>
        }
    }

    static final class WrappingSpliterator&lt;P_IN, P_OUT&gt;
            extends AbstractWrappingSpliterator&lt;P_IN, P_OUT, SpinedBuffer&lt;P_OUT&gt;&gt; {

        WrappingSpliterator(PipelineHelper&lt;P_OUT&gt; ph,
                            Supplier&lt;Spliterator&lt;P_IN&gt;&gt; supplier,
                            boolean parallel) {
<span class="fc" id="L275">            super(ph, supplier, parallel);</span>
<span class="fc" id="L276">        }</span>

        WrappingSpliterator(PipelineHelper&lt;P_OUT&gt; ph,
                            Spliterator&lt;P_IN&gt; spliterator,
                            boolean parallel) {
<span class="nc" id="L281">            super(ph, spliterator, parallel);</span>
<span class="nc" id="L282">        }</span>

        @Override
        WrappingSpliterator&lt;P_IN, P_OUT&gt; wrap(Spliterator&lt;P_IN&gt; s) {
<span class="nc" id="L286">            return new WrappingSpliterator&lt;&gt;(ph, s, isParallel);</span>
        }

        @Override
        void initPartialTraversalState() {
<span class="fc" id="L291">            SpinedBuffer&lt;P_OUT&gt; b = new SpinedBuffer&lt;&gt;();</span>
<span class="fc" id="L292">            buffer = b;</span>
<span class="fc" id="L293">            bufferSink = ph.wrapSink(b::accept);</span>
<span class="fc" id="L294">            pusher = () -&gt; spliterator.tryAdvance(bufferSink);</span>
<span class="fc" id="L295">        }</span>

        @Override
        public boolean tryAdvance(Consumer&lt;? super P_OUT&gt; consumer) {
<span class="nc" id="L299">            Objects.requireNonNull(consumer);</span>
<span class="nc" id="L300">            boolean hasNext = doAdvance();</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            if (hasNext)</span>
<span class="nc" id="L302">                consumer.accept(buffer.get(nextToConsume));</span>
<span class="nc" id="L303">            return hasNext;</span>
        }

        @Override
        public void forEachRemaining(Consumer&lt;? super P_OUT&gt; consumer) {
<span class="nc bnc" id="L308" title="All 4 branches missed.">            if (buffer == null &amp;&amp; !finished) {</span>
<span class="nc" id="L309">                Objects.requireNonNull(consumer);</span>
<span class="nc" id="L310">                init();</span>

<span class="nc" id="L312">                ph.wrapAndCopyInto((Sink&lt;P_OUT&gt;) consumer::accept, spliterator);</span>
<span class="nc" id="L313">                finished = true;</span>
            }
            else {
<span class="nc bnc" id="L316" title="All 2 branches missed.">                do { } while (tryAdvance(consumer));</span>
            }
<span class="nc" id="L318">        }</span>
    }

    static final class IntWrappingSpliterator&lt;P_IN&gt;
            extends AbstractWrappingSpliterator&lt;P_IN, Integer, SpinedBuffer.OfInt&gt;
            implements Spliterator.OfInt {

        IntWrappingSpliterator(PipelineHelper&lt;Integer&gt; ph,
                               Supplier&lt;Spliterator&lt;P_IN&gt;&gt; supplier,
                               boolean parallel) {
<span class="fc" id="L328">            super(ph, supplier, parallel);</span>
<span class="fc" id="L329">        }</span>

        IntWrappingSpliterator(PipelineHelper&lt;Integer&gt; ph,
                               Spliterator&lt;P_IN&gt; spliterator,
                               boolean parallel) {
<span class="nc" id="L334">            super(ph, spliterator, parallel);</span>
<span class="nc" id="L335">        }</span>

        @Override
        AbstractWrappingSpliterator&lt;P_IN, Integer, ?&gt; wrap(Spliterator&lt;P_IN&gt; s) {
<span class="nc" id="L339">            return new IntWrappingSpliterator&lt;&gt;(ph, s, isParallel);</span>
        }

        @Override
        void initPartialTraversalState() {
<span class="fc" id="L344">            SpinedBuffer.OfInt b = new SpinedBuffer.OfInt();</span>
<span class="fc" id="L345">            buffer = b;</span>
<span class="fc" id="L346">            bufferSink = ph.wrapSink((Sink.OfInt) b::accept);</span>
<span class="fc" id="L347">            pusher = () -&gt; spliterator.tryAdvance(bufferSink);</span>
<span class="fc" id="L348">        }</span>

        @Override
        public Spliterator.OfInt trySplit() {
<span class="nc" id="L352">            return (Spliterator.OfInt) super.trySplit();</span>
        }

        @Override
        public boolean tryAdvance(IntConsumer consumer) {
<span class="nc" id="L357">            Objects.requireNonNull(consumer);</span>
<span class="nc" id="L358">            boolean hasNext = doAdvance();</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (hasNext)</span>
<span class="nc" id="L360">                consumer.accept(buffer.get(nextToConsume));</span>
<span class="nc" id="L361">            return hasNext;</span>
        }

        @Override
        public void forEachRemaining(IntConsumer consumer) {
<span class="nc bnc" id="L366" title="All 4 branches missed.">            if (buffer == null &amp;&amp; !finished) {</span>
<span class="nc" id="L367">                Objects.requireNonNull(consumer);</span>
<span class="nc" id="L368">                init();</span>

<span class="nc" id="L370">                ph.wrapAndCopyInto((Sink.OfInt) consumer::accept, spliterator);</span>
<span class="nc" id="L371">                finished = true;</span>
            }
            else {
<span class="nc bnc" id="L374" title="All 2 branches missed.">                do { } while (tryAdvance(consumer));</span>
            }
<span class="nc" id="L376">        }</span>
    }

    static final class LongWrappingSpliterator&lt;P_IN&gt;
            extends AbstractWrappingSpliterator&lt;P_IN, Long, SpinedBuffer.OfLong&gt;
            implements Spliterator.OfLong {

        LongWrappingSpliterator(PipelineHelper&lt;Long&gt; ph,
                                Supplier&lt;Spliterator&lt;P_IN&gt;&gt; supplier,
                                boolean parallel) {
<span class="fc" id="L386">            super(ph, supplier, parallel);</span>
<span class="fc" id="L387">        }</span>

        LongWrappingSpliterator(PipelineHelper&lt;Long&gt; ph,
                                Spliterator&lt;P_IN&gt; spliterator,
                                boolean parallel) {
<span class="nc" id="L392">            super(ph, spliterator, parallel);</span>
<span class="nc" id="L393">        }</span>

        @Override
        AbstractWrappingSpliterator&lt;P_IN, Long, ?&gt; wrap(Spliterator&lt;P_IN&gt; s) {
<span class="nc" id="L397">            return new LongWrappingSpliterator&lt;&gt;(ph, s, isParallel);</span>
        }

        @Override
        void initPartialTraversalState() {
<span class="nc" id="L402">            SpinedBuffer.OfLong b = new SpinedBuffer.OfLong();</span>
<span class="nc" id="L403">            buffer = b;</span>
<span class="nc" id="L404">            bufferSink = ph.wrapSink((Sink.OfLong) b::accept);</span>
<span class="nc" id="L405">            pusher = () -&gt; spliterator.tryAdvance(bufferSink);</span>
<span class="nc" id="L406">        }</span>

        @Override
        public Spliterator.OfLong trySplit() {
<span class="nc" id="L410">            return (Spliterator.OfLong) super.trySplit();</span>
        }

        @Override
        public boolean tryAdvance(LongConsumer consumer) {
<span class="nc" id="L415">            Objects.requireNonNull(consumer);</span>
<span class="nc" id="L416">            boolean hasNext = doAdvance();</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (hasNext)</span>
<span class="nc" id="L418">                consumer.accept(buffer.get(nextToConsume));</span>
<span class="nc" id="L419">            return hasNext;</span>
        }

        @Override
        public void forEachRemaining(LongConsumer consumer) {
<span class="nc bnc" id="L424" title="All 4 branches missed.">            if (buffer == null &amp;&amp; !finished) {</span>
<span class="nc" id="L425">                Objects.requireNonNull(consumer);</span>
<span class="nc" id="L426">                init();</span>

<span class="nc" id="L428">                ph.wrapAndCopyInto((Sink.OfLong) consumer::accept, spliterator);</span>
<span class="nc" id="L429">                finished = true;</span>
            }
            else {
<span class="nc bnc" id="L432" title="All 2 branches missed.">                do { } while (tryAdvance(consumer));</span>
            }
<span class="nc" id="L434">        }</span>
    }

    static final class DoubleWrappingSpliterator&lt;P_IN&gt;
            extends AbstractWrappingSpliterator&lt;P_IN, Double, SpinedBuffer.OfDouble&gt;
            implements Spliterator.OfDouble {

        DoubleWrappingSpliterator(PipelineHelper&lt;Double&gt; ph,
                                  Supplier&lt;Spliterator&lt;P_IN&gt;&gt; supplier,
                                  boolean parallel) {
<span class="fc" id="L444">            super(ph, supplier, parallel);</span>
<span class="fc" id="L445">        }</span>

        DoubleWrappingSpliterator(PipelineHelper&lt;Double&gt; ph,
                                  Spliterator&lt;P_IN&gt; spliterator,
                                  boolean parallel) {
<span class="nc" id="L450">            super(ph, spliterator, parallel);</span>
<span class="nc" id="L451">        }</span>

        @Override
        AbstractWrappingSpliterator&lt;P_IN, Double, ?&gt; wrap(Spliterator&lt;P_IN&gt; s) {
<span class="nc" id="L455">            return new DoubleWrappingSpliterator&lt;&gt;(ph, s, isParallel);</span>
        }

        @Override
        void initPartialTraversalState() {
<span class="nc" id="L460">            SpinedBuffer.OfDouble b = new SpinedBuffer.OfDouble();</span>
<span class="nc" id="L461">            buffer = b;</span>
<span class="nc" id="L462">            bufferSink = ph.wrapSink((Sink.OfDouble) b::accept);</span>
<span class="nc" id="L463">            pusher = () -&gt; spliterator.tryAdvance(bufferSink);</span>
<span class="nc" id="L464">        }</span>

        @Override
        public Spliterator.OfDouble trySplit() {
<span class="nc" id="L468">            return (Spliterator.OfDouble) super.trySplit();</span>
        }

        @Override
        public boolean tryAdvance(DoubleConsumer consumer) {
<span class="nc" id="L473">            Objects.requireNonNull(consumer);</span>
<span class="nc" id="L474">            boolean hasNext = doAdvance();</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">            if (hasNext)</span>
<span class="nc" id="L476">                consumer.accept(buffer.get(nextToConsume));</span>
<span class="nc" id="L477">            return hasNext;</span>
        }

        @Override
        public void forEachRemaining(DoubleConsumer consumer) {
<span class="nc bnc" id="L482" title="All 4 branches missed.">            if (buffer == null &amp;&amp; !finished) {</span>
<span class="nc" id="L483">                Objects.requireNonNull(consumer);</span>
<span class="nc" id="L484">                init();</span>

<span class="nc" id="L486">                ph.wrapAndCopyInto((Sink.OfDouble) consumer::accept, spliterator);</span>
<span class="nc" id="L487">                finished = true;</span>
            }
            else {
<span class="nc bnc" id="L490" title="All 2 branches missed.">                do { } while (tryAdvance(consumer));</span>
            }
<span class="nc" id="L492">        }</span>
    }

    /**
     * Spliterator implementation that delegates to an underlying spliterator,
     * acquiring the spliterator from a {@code Supplier&lt;Spliterator&gt;} on the
     * first call to any spliterator method.
     * @param &lt;T&gt;
     */
    static class DelegatingSpliterator&lt;T, T_SPLITR extends Spliterator&lt;T&gt;&gt;
            implements Spliterator&lt;T&gt; {
        private final Supplier&lt;? extends T_SPLITR&gt; supplier;

        private T_SPLITR s;

<span class="nc" id="L507">        DelegatingSpliterator(Supplier&lt;? extends T_SPLITR&gt; supplier) {</span>
<span class="nc" id="L508">            this.supplier = supplier;</span>
<span class="nc" id="L509">        }</span>

        T_SPLITR get() {
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (s == null) {</span>
<span class="nc" id="L513">                s = supplier.get();</span>
            }
<span class="nc" id="L515">            return s;</span>
        }

        @Override
        public T_SPLITR trySplit() {
<span class="nc" id="L520">            return (T_SPLITR) get().trySplit();</span>
        }

        @Override
        public boolean tryAdvance(Consumer&lt;? super T&gt; consumer) {
<span class="nc" id="L525">            return get().tryAdvance(consumer);</span>
        }

        @Override
        public void forEachRemaining(Consumer&lt;? super T&gt; consumer) {
<span class="nc" id="L530">            get().forEachRemaining(consumer);</span>
<span class="nc" id="L531">        }</span>

        @Override
        public long estimateSize() {
<span class="nc" id="L535">            return get().estimateSize();</span>
        }

        @Override
        public int characteristics() {
<span class="nc" id="L540">            return get().characteristics();</span>
        }

        @Override
        public Comparator&lt;? super T&gt; getComparator() {
<span class="nc" id="L545">            return get().getComparator();</span>
        }

        @Override
        public long getExactSizeIfKnown() {
<span class="nc" id="L550">            return get().getExactSizeIfKnown();</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L555">            return getClass().getName() + &quot;[&quot; + get() + &quot;]&quot;;</span>
        }

        static class OfPrimitive&lt;T, T_CONS, T_SPLITR extends Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt;&gt;
            extends DelegatingSpliterator&lt;T, T_SPLITR&gt;
            implements Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt; {
            OfPrimitive(Supplier&lt;? extends T_SPLITR&gt; supplier) {
<span class="nc" id="L562">                super(supplier);</span>
<span class="nc" id="L563">            }</span>

            @Override
            public boolean tryAdvance(T_CONS consumer) {
<span class="nc" id="L567">                return get().tryAdvance(consumer);</span>
            }

            @Override
            public void forEachRemaining(T_CONS consumer) {
<span class="nc" id="L572">                get().forEachRemaining(consumer);</span>
<span class="nc" id="L573">            }</span>
        }

        static final class OfInt
                extends OfPrimitive&lt;Integer, IntConsumer, Spliterator.OfInt&gt;
                implements Spliterator.OfInt {

            OfInt(Supplier&lt;Spliterator.OfInt&gt; supplier) {
<span class="nc" id="L581">                super(supplier);</span>
<span class="nc" id="L582">            }</span>
        }

        static final class OfLong
                extends OfPrimitive&lt;Long, LongConsumer, Spliterator.OfLong&gt;
                implements Spliterator.OfLong {

            OfLong(Supplier&lt;Spliterator.OfLong&gt; supplier) {
<span class="nc" id="L590">                super(supplier);</span>
<span class="nc" id="L591">            }</span>
        }

        static final class OfDouble
                extends OfPrimitive&lt;Double, DoubleConsumer, Spliterator.OfDouble&gt;
                implements Spliterator.OfDouble {

            OfDouble(Supplier&lt;Spliterator.OfDouble&gt; supplier) {
<span class="nc" id="L599">                super(supplier);</span>
<span class="nc" id="L600">            }</span>
        }
    }

    /**
     * A slice Spliterator from a source Spliterator that reports
     * {@code SUBSIZED}.
     *
     */
<span class="nc bnc" id="L609" title="All 2 branches missed.">    static abstract class SliceSpliterator&lt;T, T_SPLITR extends Spliterator&lt;T&gt;&gt; {</span>
        // The start index of the slice
        final long sliceOrigin;
        // One past the last index of the slice
        final long sliceFence;

        // The spliterator to slice
        T_SPLITR s;
        // current (absolute) index, modified on advance/split
        long index;
        // one past last (absolute) index or sliceFence, which ever is smaller
        long fence;

<span class="nc" id="L622">        SliceSpliterator(T_SPLITR s, long sliceOrigin, long sliceFence, long origin, long fence) {</span>
<span class="nc bnc" id="L623" title="All 4 branches missed.">            assert s.hasCharacteristics(Spliterator.SUBSIZED);</span>
<span class="nc" id="L624">            this.s = s;</span>
<span class="nc" id="L625">            this.sliceOrigin = sliceOrigin;</span>
<span class="nc" id="L626">            this.sliceFence = sliceFence;</span>
<span class="nc" id="L627">            this.index = origin;</span>
<span class="nc" id="L628">            this.fence = fence;</span>
<span class="nc" id="L629">        }</span>

        protected abstract T_SPLITR makeSpliterator(T_SPLITR s, long sliceOrigin, long sliceFence, long origin, long fence);

        public T_SPLITR trySplit() {
<span class="nc bnc" id="L634" title="All 2 branches missed.">            if (sliceOrigin &gt;= fence)</span>
<span class="nc" id="L635">                return null;</span>

<span class="nc bnc" id="L637" title="All 2 branches missed.">            if (index &gt;= fence)</span>
<span class="nc" id="L638">                return null;</span>

            // Keep splitting until the left and right splits intersect with the slice
            // thereby ensuring the size estimate decreases.
            // This also avoids creating empty spliterators which can result in
            // existing and additionally created F/J tasks that perform
            // redundant work on no elements.
            while (true) {
<span class="nc" id="L646">                T_SPLITR leftSplit = (T_SPLITR) s.trySplit();</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">                if (leftSplit == null)</span>
<span class="nc" id="L648">                    return null;</span>

<span class="nc" id="L650">                long leftSplitFenceUnbounded = index + leftSplit.estimateSize();</span>
<span class="nc" id="L651">                long leftSplitFence = Math.min(leftSplitFenceUnbounded, sliceFence);</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                if (sliceOrigin &gt;= leftSplitFence) {</span>
                    // The left split does not intersect with, and is to the left of, the slice
                    // The right split does intersect
                    // Discard the left split and split further with the right split
<span class="nc" id="L656">                    index = leftSplitFence;</span>
                }
<span class="nc bnc" id="L658" title="All 2 branches missed.">                else if (leftSplitFence &gt;= sliceFence) {</span>
                    // The right split does not intersect with, and is to the right of, the slice
                    // The left split does intersect
                    // Discard the right split and split further with the left split
<span class="nc" id="L662">                    s = leftSplit;</span>
<span class="nc" id="L663">                    fence = leftSplitFence;</span>
                }
<span class="nc bnc" id="L665" title="All 4 branches missed.">                else if (index &gt;= sliceOrigin &amp;&amp; leftSplitFenceUnbounded &lt;= sliceFence) {</span>
                    // The left split is contained within the slice, return the underlying left split
                    // Right split is contained within or intersects with the slice
<span class="nc" id="L668">                    index = leftSplitFence;</span>
<span class="nc" id="L669">                    return leftSplit;</span>
                } else {
                    // The left split intersects with the slice
                    // Right split is contained within or intersects with the slice
<span class="nc" id="L673">                    return makeSpliterator(leftSplit, sliceOrigin, sliceFence, index, index = leftSplitFence);</span>
                }
<span class="nc" id="L675">            }</span>
        }

        public long estimateSize() {
<span class="nc bnc" id="L679" title="All 2 branches missed.">            return (sliceOrigin &lt; fence)</span>
<span class="nc" id="L680">                   ? fence - Math.max(sliceOrigin, index) : 0;</span>
        }

        public int characteristics() {
<span class="nc" id="L684">            return s.characteristics();</span>
        }

        static final class OfRef&lt;T&gt;
                extends SliceSpliterator&lt;T, Spliterator&lt;T&gt;&gt;
                implements Spliterator&lt;T&gt; {

            OfRef(Spliterator&lt;T&gt; s, long sliceOrigin, long sliceFence) {
<span class="nc" id="L692">                this(s, sliceOrigin, sliceFence, 0, Math.min(s.estimateSize(), sliceFence));</span>
<span class="nc" id="L693">            }</span>

            private OfRef(Spliterator&lt;T&gt; s,
                          long sliceOrigin, long sliceFence, long origin, long fence) {
<span class="nc" id="L697">                super(s, sliceOrigin, sliceFence, origin, fence);</span>
<span class="nc" id="L698">            }</span>

            @Override
            protected Spliterator&lt;T&gt; makeSpliterator(Spliterator&lt;T&gt; s,
                                                     long sliceOrigin, long sliceFence,
                                                     long origin, long fence) {
<span class="nc" id="L704">                return new OfRef&lt;&gt;(s, sliceOrigin, sliceFence, origin, fence);</span>
            }

            @Override
            public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="nc" id="L709">                Objects.requireNonNull(action);</span>

<span class="nc bnc" id="L711" title="All 2 branches missed.">                if (sliceOrigin &gt;= fence)</span>
<span class="nc" id="L712">                    return false;</span>

<span class="nc bnc" id="L714" title="All 2 branches missed.">                while (sliceOrigin &gt; index) {</span>
<span class="nc" id="L715">                    s.tryAdvance(e -&gt; {});</span>
<span class="nc" id="L716">                    index++;</span>
                }

<span class="nc bnc" id="L719" title="All 2 branches missed.">                if (index &gt;= fence)</span>
<span class="nc" id="L720">                    return false;</span>

<span class="nc" id="L722">                index++;</span>
<span class="nc" id="L723">                return s.tryAdvance(action);</span>
            }

            @Override
            public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="nc" id="L728">                Objects.requireNonNull(action);</span>

<span class="nc bnc" id="L730" title="All 2 branches missed.">                if (sliceOrigin &gt;= fence)</span>
<span class="nc" id="L731">                    return;</span>

<span class="nc bnc" id="L733" title="All 2 branches missed.">                if (index &gt;= fence)</span>
<span class="nc" id="L734">                    return;</span>

<span class="nc bnc" id="L736" title="All 4 branches missed.">                if (index &gt;= sliceOrigin &amp;&amp; (index + s.estimateSize()) &lt;= sliceFence) {</span>
                    // The spliterator is contained within the slice
<span class="nc" id="L738">                    s.forEachRemaining(action);</span>
<span class="nc" id="L739">                    index = fence;</span>
                } else {
                    // The spliterator intersects with the slice
<span class="nc bnc" id="L742" title="All 2 branches missed.">                    while (sliceOrigin &gt; index) {</span>
<span class="nc" id="L743">                        s.tryAdvance(e -&gt; {});</span>
<span class="nc" id="L744">                        index++;</span>
                    }
                    // Traverse elements up to the fence
<span class="nc bnc" id="L747" title="All 2 branches missed.">                    for (;index &lt; fence; index++) {</span>
<span class="nc" id="L748">                        s.tryAdvance(action);</span>
                    }
                }
<span class="nc" id="L751">            }</span>
        }

        static abstract class OfPrimitive&lt;T,
                T_SPLITR extends Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt;,
                T_CONS&gt;
                extends SliceSpliterator&lt;T, T_SPLITR&gt;
                implements Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt; {

            OfPrimitive(T_SPLITR s, long sliceOrigin, long sliceFence) {
<span class="nc" id="L761">                this(s, sliceOrigin, sliceFence, 0, Math.min(s.estimateSize(), sliceFence));</span>
<span class="nc" id="L762">            }</span>

            private OfPrimitive(T_SPLITR s,
                                long sliceOrigin, long sliceFence, long origin, long fence) {
<span class="nc" id="L766">                super(s, sliceOrigin, sliceFence, origin, fence);</span>
<span class="nc" id="L767">            }</span>

            @Override
            public boolean tryAdvance(T_CONS action) {
<span class="nc" id="L771">                Objects.requireNonNull(action);</span>

<span class="nc bnc" id="L773" title="All 2 branches missed.">                if (sliceOrigin &gt;= fence)</span>
<span class="nc" id="L774">                    return false;</span>

<span class="nc bnc" id="L776" title="All 2 branches missed.">                while (sliceOrigin &gt; index) {</span>
<span class="nc" id="L777">                    s.tryAdvance(emptyConsumer());</span>
<span class="nc" id="L778">                    index++;</span>
                }

<span class="nc bnc" id="L781" title="All 2 branches missed.">                if (index &gt;= fence)</span>
<span class="nc" id="L782">                    return false;</span>

<span class="nc" id="L784">                index++;</span>
<span class="nc" id="L785">                return s.tryAdvance(action);</span>
            }

            @Override
            public void forEachRemaining(T_CONS action) {
<span class="nc" id="L790">                Objects.requireNonNull(action);</span>

<span class="nc bnc" id="L792" title="All 2 branches missed.">                if (sliceOrigin &gt;= fence)</span>
<span class="nc" id="L793">                    return;</span>

<span class="nc bnc" id="L795" title="All 2 branches missed.">                if (index &gt;= fence)</span>
<span class="nc" id="L796">                    return;</span>

<span class="nc bnc" id="L798" title="All 4 branches missed.">                if (index &gt;= sliceOrigin &amp;&amp; (index + s.estimateSize()) &lt;= sliceFence) {</span>
                    // The spliterator is contained within the slice
<span class="nc" id="L800">                    s.forEachRemaining(action);</span>
<span class="nc" id="L801">                    index = fence;</span>
                } else {
                    // The spliterator intersects with the slice
<span class="nc bnc" id="L804" title="All 2 branches missed.">                    while (sliceOrigin &gt; index) {</span>
<span class="nc" id="L805">                        s.tryAdvance(emptyConsumer());</span>
<span class="nc" id="L806">                        index++;</span>
                    }
                    // Traverse elements up to the fence
<span class="nc bnc" id="L809" title="All 2 branches missed.">                    for (;index &lt; fence; index++) {</span>
<span class="nc" id="L810">                        s.tryAdvance(action);</span>
                    }
                }
<span class="nc" id="L813">            }</span>

            protected abstract T_CONS emptyConsumer();
        }

        static final class OfInt extends OfPrimitive&lt;Integer, Spliterator.OfInt, IntConsumer&gt;
                implements Spliterator.OfInt {
            OfInt(Spliterator.OfInt s, long sliceOrigin, long sliceFence) {
<span class="nc" id="L821">                super(s, sliceOrigin, sliceFence);</span>
<span class="nc" id="L822">            }</span>

            OfInt(Spliterator.OfInt s,
                  long sliceOrigin, long sliceFence, long origin, long fence) {
<span class="nc" id="L826">                super(s, sliceOrigin, sliceFence, origin, fence);</span>
<span class="nc" id="L827">            }</span>

            @Override
            protected Spliterator.OfInt makeSpliterator(Spliterator.OfInt s,
                                                        long sliceOrigin, long sliceFence,
                                                        long origin, long fence) {
<span class="nc" id="L833">                return new SliceSpliterator.OfInt(s, sliceOrigin, sliceFence, origin, fence);</span>
            }

            @Override
            protected IntConsumer emptyConsumer() {
<span class="nc" id="L838">                return e -&gt; {};</span>
            }
        }

        static final class OfLong extends OfPrimitive&lt;Long, Spliterator.OfLong, LongConsumer&gt;
                implements Spliterator.OfLong {
            OfLong(Spliterator.OfLong s, long sliceOrigin, long sliceFence) {
<span class="nc" id="L845">                super(s, sliceOrigin, sliceFence);</span>
<span class="nc" id="L846">            }</span>

            OfLong(Spliterator.OfLong s,
                   long sliceOrigin, long sliceFence, long origin, long fence) {
<span class="nc" id="L850">                super(s, sliceOrigin, sliceFence, origin, fence);</span>
<span class="nc" id="L851">            }</span>

            @Override
            protected Spliterator.OfLong makeSpliterator(Spliterator.OfLong s,
                                                         long sliceOrigin, long sliceFence,
                                                         long origin, long fence) {
<span class="nc" id="L857">                return new SliceSpliterator.OfLong(s, sliceOrigin, sliceFence, origin, fence);</span>
            }

            @Override
            protected LongConsumer emptyConsumer() {
<span class="nc" id="L862">                return e -&gt; {};</span>
            }
        }

        static final class OfDouble extends OfPrimitive&lt;Double, Spliterator.OfDouble, DoubleConsumer&gt;
                implements Spliterator.OfDouble {
            OfDouble(Spliterator.OfDouble s, long sliceOrigin, long sliceFence) {
<span class="nc" id="L869">                super(s, sliceOrigin, sliceFence);</span>
<span class="nc" id="L870">            }</span>

            OfDouble(Spliterator.OfDouble s,
                     long sliceOrigin, long sliceFence, long origin, long fence) {
<span class="nc" id="L874">                super(s, sliceOrigin, sliceFence, origin, fence);</span>
<span class="nc" id="L875">            }</span>

            @Override
            protected Spliterator.OfDouble makeSpliterator(Spliterator.OfDouble s,
                                                           long sliceOrigin, long sliceFence,
                                                           long origin, long fence) {
<span class="nc" id="L881">                return new SliceSpliterator.OfDouble(s, sliceOrigin, sliceFence, origin, fence);</span>
            }

            @Override
            protected DoubleConsumer emptyConsumer() {
<span class="nc" id="L886">                return e -&gt; {};</span>
            }
        }
    }

    /**
     * A slice Spliterator that does not preserve order, if any, of a source
     * Spliterator.
     *
     * Note: The source spliterator may report {@code ORDERED} since that
     * spliterator be the result of a previous pipeline stage that was
     * collected to a {@code Node}. It is the order of the pipeline stage
     * that governs whether the this slice spliterator is to be used or not.
     */
<span class="nc bnc" id="L900" title="All 2 branches missed.">    static abstract class UnorderedSliceSpliterator&lt;T, T_SPLITR extends Spliterator&lt;T&gt;&gt; {</span>
        static final int CHUNK_SIZE = 1 &lt;&lt; 7;

        // The spliterator to slice
        protected final T_SPLITR s;
        protected final boolean unlimited;
        private final long skipThreshold;
        private final AtomicLong permits;

<span class="nc" id="L909">        UnorderedSliceSpliterator(T_SPLITR s, long skip, long limit) {</span>
<span class="nc" id="L910">            this.s = s;</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">            this.unlimited = limit &lt; 0;</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">            this.skipThreshold = limit &gt;= 0 ? limit : 0;</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">            this.permits = new AtomicLong(limit &gt;= 0 ? skip + limit : skip);</span>
<span class="nc" id="L914">        }</span>

        UnorderedSliceSpliterator(T_SPLITR s,
<span class="nc" id="L917">                                  UnorderedSliceSpliterator&lt;T, T_SPLITR&gt; parent) {</span>
<span class="nc" id="L918">            this.s = s;</span>
<span class="nc" id="L919">            this.unlimited = parent.unlimited;</span>
<span class="nc" id="L920">            this.permits = parent.permits;</span>
<span class="nc" id="L921">            this.skipThreshold = parent.skipThreshold;</span>
<span class="nc" id="L922">        }</span>

        /**
         * Acquire permission to skip or process elements.  The caller must
         * first acquire the elements, then consult this method for guidance
         * as to what to do with the data.
         *
         * &lt;p&gt;We use an {@code AtomicLong} to atomically maintain a counter,
         * which is initialized as skip+limit if we are limiting, or skip only
         * if we are not limiting.  The user should consult the method
         * {@code checkPermits()} before acquiring data elements.
         *
         * @param numElements the number of elements the caller has in hand
         * @return the number of elements that should be processed; any
         * remaining elements should be discarded.
         */
        protected final long acquirePermits(long numElements) {
            long remainingPermits;
            long grabbing;
            // permits never increase, and don't decrease below zero
<span class="nc bnc" id="L942" title="All 4 branches missed.">            assert numElements &gt; 0;</span>
            do {
<span class="nc" id="L944">                remainingPermits = permits.get();</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">                if (remainingPermits == 0)</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">                    return unlimited ? numElements : 0;</span>
<span class="nc" id="L947">                grabbing = Math.min(remainingPermits, numElements);</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">            } while (grabbing &gt; 0 &amp;&amp;</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                     !permits.compareAndSet(remainingPermits, remainingPermits - grabbing));</span>

<span class="nc bnc" id="L951" title="All 2 branches missed.">            if (unlimited)</span>
<span class="nc" id="L952">                return Math.max(numElements - grabbing, 0);</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">            else if (remainingPermits &gt; skipThreshold)</span>
<span class="nc" id="L954">                return Math.max(grabbing - (remainingPermits - skipThreshold), 0);</span>
            else
<span class="nc" id="L956">                return grabbing;</span>
        }

<span class="nc" id="L959">        enum PermitStatus { NO_MORE, MAYBE_MORE, UNLIMITED }</span>

        /** Call to check if permits might be available before acquiring data */
        protected final PermitStatus permitStatus() {
<span class="nc bnc" id="L963" title="All 2 branches missed.">            if (permits.get() &gt; 0)</span>
<span class="nc" id="L964">                return PermitStatus.MAYBE_MORE;</span>
            else
<span class="nc bnc" id="L966" title="All 2 branches missed.">                return unlimited ?  PermitStatus.UNLIMITED : PermitStatus.NO_MORE;</span>
        }

        public final T_SPLITR trySplit() {
            // Stop splitting when there are no more limit permits
<span class="nc bnc" id="L971" title="All 2 branches missed.">            if (permits.get() == 0)</span>
<span class="nc" id="L972">                return null;</span>
<span class="nc" id="L973">            T_SPLITR split = (T_SPLITR) s.trySplit();</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">            return split == null ? null : makeSpliterator(split);</span>
        }

        protected abstract T_SPLITR makeSpliterator(T_SPLITR s);

        public final long estimateSize() {
<span class="nc" id="L980">            return s.estimateSize();</span>
        }

        public final int characteristics() {
<span class="nc" id="L984">            return s.characteristics() &amp;</span>
                   ~(Spliterator.SIZED | Spliterator.SUBSIZED | Spliterator.ORDERED);
        }

        static final class OfRef&lt;T&gt; extends UnorderedSliceSpliterator&lt;T, Spliterator&lt;T&gt;&gt;
                implements Spliterator&lt;T&gt;, Consumer&lt;T&gt; {
            T tmpSlot;

            OfRef(Spliterator&lt;T&gt; s, long skip, long limit) {
<span class="nc" id="L993">                super(s, skip, limit);</span>
<span class="nc" id="L994">            }</span>

            OfRef(Spliterator&lt;T&gt; s, OfRef&lt;T&gt; parent) {
<span class="nc" id="L997">                super(s, parent);</span>
<span class="nc" id="L998">            }</span>

            @Override
            public final void accept(T t) {
<span class="nc" id="L1002">                tmpSlot = t;</span>
<span class="nc" id="L1003">            }</span>

            @Override
            public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="nc" id="L1007">                Objects.requireNonNull(action);</span>

<span class="nc bnc" id="L1009" title="All 2 branches missed.">                while (permitStatus() != PermitStatus.NO_MORE) {</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">                    if (!s.tryAdvance(this))</span>
<span class="nc" id="L1011">                        return false;</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                    else if (acquirePermits(1) == 1) {</span>
<span class="nc" id="L1013">                        action.accept(tmpSlot);</span>
<span class="nc" id="L1014">                        tmpSlot = null;</span>
<span class="nc" id="L1015">                        return true;</span>
                    }
                }
<span class="nc" id="L1018">                return false;</span>
            }

            @Override
            public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="nc" id="L1023">                Objects.requireNonNull(action);</span>

<span class="nc" id="L1025">                ArrayBuffer.OfRef&lt;T&gt; sb = null;</span>
                PermitStatus permitStatus;
<span class="nc bnc" id="L1027" title="All 2 branches missed.">                while ((permitStatus = permitStatus()) != PermitStatus.NO_MORE) {</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">                    if (permitStatus == PermitStatus.MAYBE_MORE) {</span>
                        // Optimistically traverse elements up to a threshold of CHUNK_SIZE
<span class="nc bnc" id="L1030" title="All 2 branches missed.">                        if (sb == null)</span>
<span class="nc" id="L1031">                            sb = new ArrayBuffer.OfRef&lt;&gt;(CHUNK_SIZE);</span>
                        else
<span class="nc" id="L1033">                            sb.reset();</span>
<span class="nc" id="L1034">                        long permitsRequested = 0;</span>
<span class="nc bnc" id="L1035" title="All 4 branches missed.">                        do { } while (s.tryAdvance(sb) &amp;&amp; ++permitsRequested &lt; CHUNK_SIZE);</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">                        if (permitsRequested == 0)</span>
<span class="nc" id="L1037">                            return;</span>
<span class="nc" id="L1038">                        sb.forEach(action, acquirePermits(permitsRequested));</span>
<span class="nc" id="L1039">                    }</span>
                    else {
                        // Must be UNLIMITED; let 'er rip
<span class="nc" id="L1042">                        s.forEachRemaining(action);</span>
<span class="nc" id="L1043">                        return;</span>
                    }
                }
<span class="nc" id="L1046">            }</span>

            @Override
            protected Spliterator&lt;T&gt; makeSpliterator(Spliterator&lt;T&gt; s) {
<span class="nc" id="L1050">                return new UnorderedSliceSpliterator.OfRef&lt;&gt;(s, this);</span>
            }
        }

        /**
         * Concrete sub-types must also be an instance of type {@code T_CONS}.
         *
         * @param &lt;T_BUFF&gt; the type of the spined buffer. Must also be a type of
         *        {@code T_CONS}.
         */
        static abstract class OfPrimitive&lt;
                T,
                T_CONS,
                T_BUFF extends ArrayBuffer.OfPrimitive&lt;T_CONS&gt;,
                T_SPLITR extends Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt;&gt;
                extends UnorderedSliceSpliterator&lt;T, T_SPLITR&gt;
                implements Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt; {
            OfPrimitive(T_SPLITR s, long skip, long limit) {
<span class="nc" id="L1068">                super(s, skip, limit);</span>
<span class="nc" id="L1069">            }</span>

            OfPrimitive(T_SPLITR s, UnorderedSliceSpliterator.OfPrimitive parent) {
<span class="nc" id="L1072">                super(s, parent);</span>
<span class="nc" id="L1073">            }</span>

            @Override
            public boolean tryAdvance(T_CONS action) {
<span class="nc" id="L1077">                Objects.requireNonNull(action);</span>

<span class="nc bnc" id="L1079" title="All 2 branches missed.">                while (permitStatus() != PermitStatus.NO_MORE) {</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">                    if (!s.tryAdvance((T_CONS) this))</span>
<span class="nc" id="L1081">                        return false;</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">                    else if (acquirePermits(1) == 1) {</span>
<span class="nc" id="L1083">                        acceptConsumed(action);</span>
<span class="nc" id="L1084">                        return true;</span>
                    }
                }
<span class="nc" id="L1087">                return false;</span>
            }

            protected abstract void acceptConsumed(T_CONS action);

            @Override
            public void forEachRemaining(T_CONS action) {
<span class="nc" id="L1094">                Objects.requireNonNull(action);</span>

<span class="nc" id="L1096">                T_BUFF sb = null;</span>
                PermitStatus permitStatus;
<span class="nc bnc" id="L1098" title="All 2 branches missed.">                while ((permitStatus = permitStatus()) != PermitStatus.NO_MORE) {</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">                    if (permitStatus == PermitStatus.MAYBE_MORE) {</span>
                        // Optimistically traverse elements up to a threshold of CHUNK_SIZE
<span class="nc bnc" id="L1101" title="All 2 branches missed.">                        if (sb == null)</span>
<span class="nc" id="L1102">                            sb = bufferCreate(CHUNK_SIZE);</span>
                        else
<span class="nc" id="L1104">                            sb.reset();</span>
                        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1106">                        T_CONS sbc = (T_CONS) sb;</span>
<span class="nc" id="L1107">                        long permitsRequested = 0;</span>
<span class="nc bnc" id="L1108" title="All 4 branches missed.">                        do { } while (s.tryAdvance(sbc) &amp;&amp; ++permitsRequested &lt; CHUNK_SIZE);</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">                        if (permitsRequested == 0)</span>
<span class="nc" id="L1110">                            return;</span>
<span class="nc" id="L1111">                        sb.forEach(action, acquirePermits(permitsRequested));</span>
<span class="nc" id="L1112">                    }</span>
                    else {
                        // Must be UNLIMITED; let 'er rip
<span class="nc" id="L1115">                        s.forEachRemaining(action);</span>
<span class="nc" id="L1116">                        return;</span>
                    }
                }
<span class="nc" id="L1119">            }</span>

            protected abstract T_BUFF bufferCreate(int initialCapacity);
        }

        static final class OfInt
                extends OfPrimitive&lt;Integer, IntConsumer, ArrayBuffer.OfInt, Spliterator.OfInt&gt;
                implements Spliterator.OfInt, IntConsumer {

            int tmpValue;

            OfInt(Spliterator.OfInt s, long skip, long limit) {
<span class="nc" id="L1131">                super(s, skip, limit);</span>
<span class="nc" id="L1132">            }</span>

            OfInt(Spliterator.OfInt s, UnorderedSliceSpliterator.OfInt parent) {
<span class="nc" id="L1135">                super(s, parent);</span>
<span class="nc" id="L1136">            }</span>

            @Override
            public void accept(int value) {
<span class="nc" id="L1140">                tmpValue = value;</span>
<span class="nc" id="L1141">            }</span>

            @Override
            protected void acceptConsumed(IntConsumer action) {
<span class="nc" id="L1145">                action.accept(tmpValue);</span>
<span class="nc" id="L1146">            }</span>

            @Override
            protected ArrayBuffer.OfInt bufferCreate(int initialCapacity) {
<span class="nc" id="L1150">                return new ArrayBuffer.OfInt(initialCapacity);</span>
            }

            @Override
            protected Spliterator.OfInt makeSpliterator(Spliterator.OfInt s) {
<span class="nc" id="L1155">                return new UnorderedSliceSpliterator.OfInt(s, this);</span>
            }
        }

        static final class OfLong
                extends OfPrimitive&lt;Long, LongConsumer, ArrayBuffer.OfLong, Spliterator.OfLong&gt;
                implements Spliterator.OfLong, LongConsumer {

            long tmpValue;

            OfLong(Spliterator.OfLong s, long skip, long limit) {
<span class="nc" id="L1166">                super(s, skip, limit);</span>
<span class="nc" id="L1167">            }</span>

            OfLong(Spliterator.OfLong s, UnorderedSliceSpliterator.OfLong parent) {
<span class="nc" id="L1170">                super(s, parent);</span>
<span class="nc" id="L1171">            }</span>

            @Override
            public void accept(long value) {
<span class="nc" id="L1175">                tmpValue = value;</span>
<span class="nc" id="L1176">            }</span>

            @Override
            protected void acceptConsumed(LongConsumer action) {
<span class="nc" id="L1180">                action.accept(tmpValue);</span>
<span class="nc" id="L1181">            }</span>

            @Override
            protected ArrayBuffer.OfLong bufferCreate(int initialCapacity) {
<span class="nc" id="L1185">                return new ArrayBuffer.OfLong(initialCapacity);</span>
            }

            @Override
            protected Spliterator.OfLong makeSpliterator(Spliterator.OfLong s) {
<span class="nc" id="L1190">                return new UnorderedSliceSpliterator.OfLong(s, this);</span>
            }
        }

        static final class OfDouble
                extends OfPrimitive&lt;Double, DoubleConsumer, ArrayBuffer.OfDouble, Spliterator.OfDouble&gt;
                implements Spliterator.OfDouble, DoubleConsumer {

            double tmpValue;

            OfDouble(Spliterator.OfDouble s, long skip, long limit) {
<span class="nc" id="L1201">                super(s, skip, limit);</span>
<span class="nc" id="L1202">            }</span>

            OfDouble(Spliterator.OfDouble s, UnorderedSliceSpliterator.OfDouble parent) {
<span class="nc" id="L1205">                super(s, parent);</span>
<span class="nc" id="L1206">            }</span>

            @Override
            public void accept(double value) {
<span class="nc" id="L1210">                tmpValue = value;</span>
<span class="nc" id="L1211">            }</span>

            @Override
            protected void acceptConsumed(DoubleConsumer action) {
<span class="nc" id="L1215">                action.accept(tmpValue);</span>
<span class="nc" id="L1216">            }</span>

            @Override
            protected ArrayBuffer.OfDouble bufferCreate(int initialCapacity) {
<span class="nc" id="L1220">                return new ArrayBuffer.OfDouble(initialCapacity);</span>
            }

            @Override
            protected Spliterator.OfDouble makeSpliterator(Spliterator.OfDouble s) {
<span class="nc" id="L1225">                return new UnorderedSliceSpliterator.OfDouble(s, this);</span>
            }
        }
    }

    /**
     * A wrapping spliterator that only reports distinct elements of the
     * underlying spliterator. Does not preserve size and encounter order.
     */
    static final class DistinctSpliterator&lt;T&gt; implements Spliterator&lt;T&gt;, Consumer&lt;T&gt; {

        // The value to represent null in the ConcurrentHashMap
<span class="nc" id="L1237">        private static final Object NULL_VALUE = new Object();</span>

        // The underlying spliterator
        private final Spliterator&lt;T&gt; s;

        // ConcurrentHashMap holding distinct elements as keys
        private final ConcurrentHashMap&lt;T, Boolean&gt; seen;

        // Temporary element, only used with tryAdvance
        private T tmpSlot;

        DistinctSpliterator(Spliterator&lt;T&gt; s) {
<span class="nc" id="L1249">            this(s, new ConcurrentHashMap&lt;&gt;());</span>
<span class="nc" id="L1250">        }</span>

<span class="nc" id="L1252">        private DistinctSpliterator(Spliterator&lt;T&gt; s, ConcurrentHashMap&lt;T, Boolean&gt; seen) {</span>
<span class="nc" id="L1253">            this.s = s;</span>
<span class="nc" id="L1254">            this.seen = seen;</span>
<span class="nc" id="L1255">        }</span>

        @Override
        public void accept(T t) {
<span class="nc" id="L1259">            this.tmpSlot = t;</span>
<span class="nc" id="L1260">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        private T mapNull(T t) {
<span class="nc bnc" id="L1264" title="All 2 branches missed.">            return t != null ? t : (T) NULL_VALUE;</span>
        }

        @Override
        public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="nc bnc" id="L1269" title="All 2 branches missed.">            while (s.tryAdvance(this)) {</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">                if (seen.putIfAbsent(mapNull(tmpSlot), Boolean.TRUE) == null) {</span>
<span class="nc" id="L1271">                    action.accept(tmpSlot);</span>
<span class="nc" id="L1272">                    tmpSlot = null;</span>
<span class="nc" id="L1273">                    return true;</span>
                }
            }
<span class="nc" id="L1276">            return false;</span>
        }

        @Override
        public void forEachRemaining(Consumer&lt;? super T&gt; action) {
<span class="nc" id="L1281">            s.forEachRemaining(t -&gt; {</span>
                if (seen.putIfAbsent(mapNull(t), Boolean.TRUE) == null) {
                    action.accept(t);
                }
            });
<span class="nc" id="L1286">        }</span>

        @Override
        public Spliterator&lt;T&gt; trySplit() {
<span class="nc" id="L1290">            Spliterator&lt;T&gt; split = s.trySplit();</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">            return (split != null) ? new DistinctSpliterator&lt;&gt;(split, seen) : null;</span>
        }

        @Override
        public long estimateSize() {
<span class="nc" id="L1296">            return s.estimateSize();</span>
        }

        @Override
        public int characteristics() {
<span class="nc" id="L1301">            return (s.characteristics() &amp; ~(Spliterator.SIZED | Spliterator.SUBSIZED |</span>
                                            Spliterator.SORTED | Spliterator.ORDERED))
                   | Spliterator.DISTINCT;
        }

        @Override
        public Comparator&lt;? super T&gt; getComparator() {
<span class="nc" id="L1308">            return s.getComparator();</span>
        }
    }

    /**
     * A Spliterator that infinitely supplies elements in no particular order.
     *
     * &lt;p&gt;Splitting divides the estimated size in two and stops when the
     * estimate size is 0.
     *
     * &lt;p&gt;The {@code forEachRemaining} method if invoked will never terminate.
     * The {@coe tryAdvance} method always returns true.
     *
     */
    static abstract class InfiniteSupplyingSpliterator&lt;T&gt; implements Spliterator&lt;T&gt; {
        long estimate;

<span class="fc" id="L1325">        protected InfiniteSupplyingSpliterator(long estimate) {</span>
<span class="fc" id="L1326">            this.estimate = estimate;</span>
<span class="fc" id="L1327">        }</span>

        @Override
        public long estimateSize() {
<span class="nc" id="L1331">            return estimate;</span>
        }

        @Override
        public int characteristics() {
<span class="fc" id="L1336">            return IMMUTABLE;</span>
        }

        static final class OfRef&lt;T&gt; extends InfiniteSupplyingSpliterator&lt;T&gt; {
            final Supplier&lt;T&gt; s;

            OfRef(long size, Supplier&lt;T&gt; s) {
<span class="fc" id="L1343">                super(size);</span>
<span class="fc" id="L1344">                this.s = s;</span>
<span class="fc" id="L1345">            }</span>

            @Override
            public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
<span class="nc" id="L1349">                Objects.requireNonNull(action);</span>

<span class="nc" id="L1351">                action.accept(s.get());</span>
<span class="nc" id="L1352">                return true;</span>
            }

            @Override
            public Spliterator&lt;T&gt; trySplit() {
<span class="nc bnc" id="L1357" title="All 2 branches missed.">                if (estimate == 0)</span>
<span class="nc" id="L1358">                    return null;</span>
<span class="nc" id="L1359">                return new InfiniteSupplyingSpliterator.OfRef&lt;&gt;(estimate &gt;&gt;&gt;= 1, s);</span>
            }
        }

        static final class OfInt extends InfiniteSupplyingSpliterator&lt;Integer&gt;
                implements Spliterator.OfInt {
            final IntSupplier s;

            OfInt(long size, IntSupplier s) {
<span class="fc" id="L1368">                super(size);</span>
<span class="fc" id="L1369">                this.s = s;</span>
<span class="fc" id="L1370">            }</span>

            @Override
            public boolean tryAdvance(IntConsumer action) {
<span class="nc" id="L1374">                Objects.requireNonNull(action);</span>

<span class="nc" id="L1376">                action.accept(s.getAsInt());</span>
<span class="nc" id="L1377">                return true;</span>
            }

            @Override
            public Spliterator.OfInt trySplit() {
<span class="nc bnc" id="L1382" title="All 2 branches missed.">                if (estimate == 0)</span>
<span class="nc" id="L1383">                    return null;</span>
<span class="nc" id="L1384">                return new InfiniteSupplyingSpliterator.OfInt(estimate = estimate &gt;&gt;&gt; 1, s);</span>
            }
        }

        static final class OfLong extends InfiniteSupplyingSpliterator&lt;Long&gt;
                implements Spliterator.OfLong {
            final LongSupplier s;

            OfLong(long size, LongSupplier s) {
<span class="fc" id="L1393">                super(size);</span>
<span class="fc" id="L1394">                this.s = s;</span>
<span class="fc" id="L1395">            }</span>

            @Override
            public boolean tryAdvance(LongConsumer action) {
<span class="nc" id="L1399">                Objects.requireNonNull(action);</span>

<span class="nc" id="L1401">                action.accept(s.getAsLong());</span>
<span class="nc" id="L1402">                return true;</span>
            }

            @Override
            public Spliterator.OfLong trySplit() {
<span class="nc bnc" id="L1407" title="All 2 branches missed.">                if (estimate == 0)</span>
<span class="nc" id="L1408">                    return null;</span>
<span class="nc" id="L1409">                return new InfiniteSupplyingSpliterator.OfLong(estimate = estimate &gt;&gt;&gt; 1, s);</span>
            }
        }

        static final class OfDouble extends InfiniteSupplyingSpliterator&lt;Double&gt;
                implements Spliterator.OfDouble {
            final DoubleSupplier s;

            OfDouble(long size, DoubleSupplier s) {
<span class="fc" id="L1418">                super(size);</span>
<span class="fc" id="L1419">                this.s = s;</span>
<span class="fc" id="L1420">            }</span>

            @Override
            public boolean tryAdvance(DoubleConsumer action) {
<span class="nc" id="L1424">                Objects.requireNonNull(action);</span>

<span class="nc" id="L1426">                action.accept(s.getAsDouble());</span>
<span class="nc" id="L1427">                return true;</span>
            }

            @Override
            public Spliterator.OfDouble trySplit() {
<span class="nc bnc" id="L1432" title="All 2 branches missed.">                if (estimate == 0)</span>
<span class="nc" id="L1433">                    return null;</span>
<span class="nc" id="L1434">                return new InfiniteSupplyingSpliterator.OfDouble(estimate = estimate &gt;&gt;&gt; 1, s);</span>
            }
        }
    }

    // @@@ Consolidate with Node.Builder
<span class="nc" id="L1440">    static abstract class ArrayBuffer {</span>
        int index;

        void reset() {
<span class="nc" id="L1444">            index = 0;</span>
<span class="nc" id="L1445">        }</span>

        static final class OfRef&lt;T&gt; extends ArrayBuffer implements Consumer&lt;T&gt; {
            final Object[] array;

<span class="nc" id="L1450">            OfRef(int size) {</span>
<span class="nc" id="L1451">                this.array = new Object[size];</span>
<span class="nc" id="L1452">            }</span>

            @Override
            public void accept(T t) {
<span class="nc" id="L1456">                array[index++] = t;</span>
<span class="nc" id="L1457">            }</span>

            public void forEach(Consumer&lt;? super T&gt; action, long fence) {
<span class="nc bnc" id="L1460" title="All 2 branches missed.">                for (int i = 0; i &lt; fence; i++) {</span>
                    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1462">                    T t = (T) array[i];</span>
<span class="nc" id="L1463">                    action.accept(t);</span>
                }
<span class="nc" id="L1465">            }</span>
        }

<span class="nc" id="L1468">        static abstract class OfPrimitive&lt;T_CONS&gt; extends ArrayBuffer {</span>
            int index;

            @Override
            void reset() {
<span class="nc" id="L1473">                index = 0;</span>
<span class="nc" id="L1474">            }</span>

            abstract void forEach(T_CONS action, long fence);
        }

        static final class OfInt extends OfPrimitive&lt;IntConsumer&gt;
                implements IntConsumer {
            final int[] array;

<span class="nc" id="L1483">            OfInt(int size) {</span>
<span class="nc" id="L1484">                this.array = new int[size];</span>
<span class="nc" id="L1485">            }</span>

            @Override
            public void accept(int t) {
<span class="nc" id="L1489">                array[index++] = t;</span>
<span class="nc" id="L1490">            }</span>

            @Override
            public void forEach(IntConsumer action, long fence) {
<span class="nc bnc" id="L1494" title="All 2 branches missed.">                for (int i = 0; i &lt; fence; i++) {</span>
<span class="nc" id="L1495">                    action.accept(array[i]);</span>
                }
<span class="nc" id="L1497">            }</span>
        }

        static final class OfLong extends OfPrimitive&lt;LongConsumer&gt;
                implements LongConsumer {
            final long[] array;

<span class="nc" id="L1504">            OfLong(int size) {</span>
<span class="nc" id="L1505">                this.array = new long[size];</span>
<span class="nc" id="L1506">            }</span>

            @Override
            public void accept(long t) {
<span class="nc" id="L1510">                array[index++] = t;</span>
<span class="nc" id="L1511">            }</span>

            @Override
            public void forEach(LongConsumer action, long fence) {
<span class="nc bnc" id="L1515" title="All 2 branches missed.">                for (int i = 0; i &lt; fence; i++) {</span>
<span class="nc" id="L1516">                    action.accept(array[i]);</span>
                }
<span class="nc" id="L1518">            }</span>
        }

<span class="nc" id="L1521">        static final class OfDouble extends OfPrimitive&lt;DoubleConsumer&gt;</span>
                implements DoubleConsumer {
            final double[] array;

<span class="nc" id="L1525">            OfDouble(int size) {</span>
<span class="nc" id="L1526">                this.array = new double[size];</span>
<span class="nc" id="L1527">            }</span>

            @Override
            public void accept(double t) {
<span class="nc" id="L1531">                array[index++] = t;</span>
<span class="nc" id="L1532">            }</span>

            @Override
            void forEach(DoubleConsumer action, long fence) {
<span class="nc bnc" id="L1536" title="All 2 branches missed.">                for (int i = 0; i &lt; fence; i++) {</span>
<span class="nc" id="L1537">                    action.accept(array[i]);</span>
                }
<span class="nc" id="L1539">            }</span>
        }
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>