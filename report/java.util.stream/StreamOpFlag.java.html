<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StreamOpFlag.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.stream</a> &gt; <span class="el_source">StreamOpFlag.java</span></div><h1>StreamOpFlag.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util.stream;

import java.util.EnumMap;
import java.util.Map;
import java.util.Spliterator;

/**
 * Flags corresponding to characteristics of streams and operations. Flags are
 * utilized by the stream framework to control, specialize or optimize
 * computation.
 *
 * &lt;p&gt;
 * Stream flags may be used to describe characteristics of several different
 * entities associated with streams: stream sources, intermediate operations,
 * and terminal operations.  Not all stream flags are meaningful for all
 * entities; the following table summarizes which flags are meaningful in what
 * contexts:
 *
 * &lt;div&gt;
 * &lt;table&gt;
 *   &lt;caption&gt;Type Characteristics&lt;/caption&gt;
 *   &lt;thead class=&quot;tableSubHeadingColor&quot;&gt;
 *     &lt;tr&gt;
 *       &lt;th colspan=&quot;2&quot;&gt;&amp;nbsp;&lt;/th&gt;
 *       &lt;th&gt;{@code DISTINCT}&lt;/th&gt;
 *       &lt;th&gt;{@code SORTED}&lt;/th&gt;
 *       &lt;th&gt;{@code ORDERED}&lt;/th&gt;
 *       &lt;th&gt;{@code SIZED}&lt;/th&gt;
 *       &lt;th&gt;{@code SHORT_CIRCUIT}&lt;/th&gt;
 *     &lt;/tr&gt;
 *   &lt;/thead&gt;
 *   &lt;tbody&gt;
 *      &lt;tr&gt;
 *        &lt;th colspan=&quot;2&quot; class=&quot;tableSubHeadingColor&quot;&gt;Stream source&lt;/th&gt;
 *        &lt;td&gt;Y&lt;/td&gt;
 *        &lt;td&gt;Y&lt;/td&gt;
 *        &lt;td&gt;Y&lt;/td&gt;
 *        &lt;td&gt;Y&lt;/td&gt;
 *        &lt;td&gt;N&lt;/td&gt;
 *      &lt;/tr&gt;
 *      &lt;tr&gt;
 *        &lt;th colspan=&quot;2&quot; class=&quot;tableSubHeadingColor&quot;&gt;Intermediate operation&lt;/th&gt;
 *        &lt;td&gt;PCI&lt;/td&gt;
 *        &lt;td&gt;PCI&lt;/td&gt;
 *        &lt;td&gt;PCI&lt;/td&gt;
 *        &lt;td&gt;PC&lt;/td&gt;
 *        &lt;td&gt;PI&lt;/td&gt;
 *      &lt;/tr&gt;
 *      &lt;tr&gt;
 *        &lt;th colspan=&quot;2&quot; class=&quot;tableSubHeadingColor&quot;&gt;Terminal operation&lt;/th&gt;
 *        &lt;td&gt;N&lt;/td&gt;
 *        &lt;td&gt;N&lt;/td&gt;
 *        &lt;td&gt;PC&lt;/td&gt;
 *        &lt;td&gt;N&lt;/td&gt;
 *        &lt;td&gt;PI&lt;/td&gt;
 *      &lt;/tr&gt;
 *   &lt;/tbody&gt;
 *   &lt;tfoot&gt;
 *       &lt;tr&gt;
 *         &lt;th class=&quot;tableSubHeadingColor&quot; colspan=&quot;2&quot;&gt;Legend&lt;/th&gt;
 *         &lt;th colspan=&quot;6&quot; rowspan=&quot;7&quot;&gt;&amp;nbsp;&lt;/th&gt;
 *       &lt;/tr&gt;
 *       &lt;tr&gt;
 *         &lt;th class=&quot;tableSubHeadingColor&quot;&gt;Flag&lt;/th&gt;
 *         &lt;th class=&quot;tableSubHeadingColor&quot;&gt;Meaning&lt;/th&gt;
 *         &lt;th colspan=&quot;6&quot;&gt;&lt;/th&gt;
 *       &lt;/tr&gt;
 *       &lt;tr&gt;&lt;td&gt;Y&lt;/td&gt;&lt;td&gt;Allowed&lt;/td&gt;&lt;/tr&gt;
 *       &lt;tr&gt;&lt;td&gt;N&lt;/td&gt;&lt;td&gt;Invalid&lt;/td&gt;&lt;/tr&gt;
 *       &lt;tr&gt;&lt;td&gt;P&lt;/td&gt;&lt;td&gt;Preserves&lt;/td&gt;&lt;/tr&gt;
 *       &lt;tr&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;Clears&lt;/td&gt;&lt;/tr&gt;
 *       &lt;tr&gt;&lt;td&gt;I&lt;/td&gt;&lt;td&gt;Injects&lt;/td&gt;&lt;/tr&gt;
 *   &lt;/tfoot&gt;
 * &lt;/table&gt;
 * &lt;/div&gt;
 *
 * &lt;p&gt;In the above table, &quot;PCI&quot; means &quot;may preserve, clear, or inject&quot;; &quot;PC&quot;
 * means &quot;may preserve or clear&quot;, &quot;PI&quot; means &quot;may preserve or inject&quot;, and &quot;N&quot;
 * means &quot;not valid&quot;.
 *
 * &lt;p&gt;Stream flags are represented by unioned bit sets, so that a single word
 * may describe all the characteristics of a given stream entity, and that, for
 * example, the flags for a stream source can be efficiently combined with the
 * flags for later operations on that stream.
 *
 * &lt;p&gt;The bit masks {@link #STREAM_MASK}, {@link #OP_MASK}, and
 * {@link #TERMINAL_OP_MASK} can be ANDed with a bit set of stream flags to
 * produce a mask containing only the valid flags for that entity type.
 *
 * &lt;p&gt;When describing a stream source, one only need describe what
 * characteristics that stream has; when describing a stream operation, one need
 * describe whether the operation preserves, injects, or clears that
 * characteristic.  Accordingly, two bits are used for each flag, so as to allow
 * representing not only the presence of of a characteristic, but how an
 * operation modifies that characteristic.  There are two common forms in which
 * flag bits are combined into an {@code int} bit set.  &lt;em&gt;Stream flags&lt;/em&gt;
 * are a unioned bit set constructed by ORing the enum characteristic values of
 * {@link #set()} (or, more commonly, ORing the corresponding static named
 * constants prefixed with {@code IS_}).  &lt;em&gt;Operation flags&lt;/em&gt; are a unioned
 * bit set constructed by ORing the enum characteristic values of {@link #set()}
 * or {@link #clear()} (to inject, or clear, respectively, the corresponding
 * flag), or more commonly ORing the corresponding named constants prefixed with
 * {@code IS_} or {@code NOT_}.  Flags that are not marked with {@code IS_} or
 * {@code NOT_} are implicitly treated as preserved.  Care must be taken when
 * combining bitsets that the correct combining operations are applied in the
 * correct order.
 *
 * &lt;p&gt;
 * With the exception of {@link #SHORT_CIRCUIT}, stream characteristics can be
 * derived from the equivalent {@link java.util.Spliterator} characteristics:
 * {@link java.util.Spliterator#DISTINCT}, {@link java.util.Spliterator#SORTED},
 * {@link java.util.Spliterator#ORDERED}, and
 * {@link java.util.Spliterator#SIZED}.  A spliterator characteristics bit set
 * can be converted to stream flags using the method
 * {@link #fromCharacteristics(java.util.Spliterator)} and converted back using
 * {@link #toCharacteristics(int)}.  (The bit set
 * {@link #SPLITERATOR_CHARACTERISTICS_MASK} is used to AND with a bit set to
 * produce a valid spliterator characteristics bit set that can be converted to
 * stream flags.)
 *
 * &lt;p&gt;
 * The source of a stream encapsulates a spliterator. The characteristics of
 * that source spliterator when transformed to stream flags will be a proper
 * subset of stream flags of that stream.
 * For example:
 * &lt;pre&gt; {@code
 *     Spliterator s = ...;
 *     Stream stream = Streams.stream(s);
 *     flagsFromSplitr = fromCharacteristics(s.characteristics());
 *     assert(flagsFromSplitr &amp; stream.getStreamFlags() == flagsFromSplitr);
 * }&lt;/pre&gt;
 *
 * &lt;p&gt;
 * An intermediate operation, performed on an input stream to create a new
 * output stream, may preserve, clear or inject stream or operation
 * characteristics.  Similarly, a terminal operation, performed on an input
 * stream to produce an output result may preserve, clear or inject stream or
 * operation characteristics.  Preservation means that if that characteristic
 * is present on the input, then it is also present on the output.  Clearing
 * means that the characteristic is not present on the output regardless of the
 * input.  Injection means that the characteristic is present on the output
 * regardless of the input.  If a characteristic is not cleared or injected then
 * it is implicitly preserved.
 *
 * &lt;p&gt;
 * A pipeline consists of a stream source encapsulating a spliterator, one or
 * more intermediate operations, and finally a terminal operation that produces
 * a result.  At each stage of the pipeline, a combined stream and operation
 * flags can be calculated, using {@link #combineOpFlags(int, int)}.  Such flags
 * ensure that preservation, clearing and injecting information is retained at
 * each stage.
 *
 * The combined stream and operation flags for the source stage of the pipeline
 * is calculated as follows:
 * &lt;pre&gt; {@code
 *     int flagsForSourceStage = combineOpFlags(sourceFlags, INITIAL_OPS_VALUE);
 * }&lt;/pre&gt;
 *
 * The combined stream and operation flags of each subsequent intermediate
 * operation stage in the pipeline is calculated as follows:
 * &lt;pre&gt; {@code
 *     int flagsForThisStage = combineOpFlags(flagsForPreviousStage, thisOpFlags);
 * }&lt;/pre&gt;
 *
 * Finally the flags output from the last intermediate operation of the pipeline
 * are combined with the operation flags of the terminal operation to produce
 * the flags output from the pipeline.
 *
 * &lt;p&gt;Those flags can then be used to apply optimizations. For example, if
 * {@code SIZED.isKnown(flags)} returns true then the stream size remains
 * constant throughout the pipeline, this information can be utilized to
 * pre-allocate data structures and combined with
 * {@link java.util.Spliterator#SUBSIZED} that information can be utilized to
 * perform concurrent in-place updates into a shared array.
 *
 * For specific details see the {@link AbstractPipeline} constructors.
 *
 * @since 1.8
 */
<span class="pc" id="L204">enum StreamOpFlag {</span>

    /*
     * Each characteristic takes up 2 bits in a bit set to accommodate
     * preserving, clearing and setting/injecting information.
     *
     * This applies to stream flags, intermediate/terminal operation flags, and
     * combined stream and operation flags. Even though the former only requires
     * 1 bit of information per characteristic, is it more efficient when
     * combining flags to align set and inject bits.
     *
     * Characteristics belong to certain types, see the Type enum. Bit masks for
     * the types are constructed as per the following table:
     *
     *                        DISTINCT  SORTED  ORDERED  SIZED  SHORT_CIRCUIT
     *          SPLITERATOR      01       01       01      01        00
     *               STREAM      01       01       01      01        00
     *                   OP      11       11       11      10        01
     *          TERMINAL_OP      00       00       10      00        01
     * UPSTREAM_TERMINAL_OP      00       00       10      00        00
     *
     * 01 = set/inject
     * 10 = clear
     * 11 = preserve
     *
     * Construction of the columns is performed using a simple builder for
     * non-zero values.
     */


    // The following flags correspond to characteristics on Spliterator
    // and the values MUST be equal.
    //

    /**
     * Characteristic value signifying that, for each pair of
     * encountered elements in a stream {@code x, y}, {@code !x.equals(y)}.
     * &lt;p&gt;
     * A stream may have this value or an intermediate operation can preserve,
     * clear or inject this value.
     */
    // 0, 0x00000001
    // Matches Spliterator.DISTINCT
<span class="fc" id="L247">    DISTINCT(0,</span>
<span class="fc" id="L248">             set(Type.SPLITERATOR).set(Type.STREAM).setAndClear(Type.OP)),</span>

    /**
     * Characteristic value signifying that encounter order follows a natural
     * sort order of comparable elements.
     * &lt;p&gt;
     * A stream can have this value or an intermediate operation can preserve,
     * clear or inject this value.
     * &lt;p&gt;
     * Note: The {@link java.util.Spliterator#SORTED} characteristic can define
     * a sort order with an associated non-null comparator.  Augmenting flag
     * state with addition properties such that those properties can be passed
     * to operations requires some disruptive changes for a singular use-case.
     * Furthermore, comparing comparators for equality beyond that of identity
     * is likely to be unreliable.  Therefore the {@code SORTED} characteristic
     * for a defined non-natural sort order is not mapped internally to the
     * {@code SORTED} flag.
     */
    // 1, 0x00000004
    // Matches Spliterator.SORTED
<span class="fc" id="L268">    SORTED(1,</span>
<span class="fc" id="L269">           set(Type.SPLITERATOR).set(Type.STREAM).setAndClear(Type.OP)),</span>

    /**
     * Characteristic value signifying that an encounter order is
     * defined for stream elements.
     * &lt;p&gt;
     * A stream can have this value, an intermediate operation can preserve,
     * clear or inject this value, or a terminal operation can preserve or clear
     * this value.
     */
    // 2, 0x00000010
    // Matches Spliterator.ORDERED
<span class="fc" id="L281">    ORDERED(2,</span>
<span class="fc" id="L282">            set(Type.SPLITERATOR).set(Type.STREAM).setAndClear(Type.OP).clear(Type.TERMINAL_OP)</span>
<span class="fc" id="L283">                    .clear(Type.UPSTREAM_TERMINAL_OP)),</span>

    /**
     * Characteristic value signifying that size of the stream
     * is of a known finite size that is equal to the known finite
     * size of the source spliterator input to the first stream
     * in the pipeline.
     * &lt;p&gt;
     * A stream can have this value or an intermediate operation can preserve or
     * clear this value.
     */
    // 3, 0x00000040
    // Matches Spliterator.SIZED
<span class="fc" id="L296">    SIZED(3,</span>
<span class="fc" id="L297">          set(Type.SPLITERATOR).set(Type.STREAM).clear(Type.OP)),</span>

    // The following Spliterator characteristics are not currently used but a
    // gap in the bit set is deliberately retained to enable corresponding
    // stream flags if//when required without modification to other flag values.
    //
    // 4, 0x00000100 NONNULL(4, ...
    // 5, 0x00000400 IMMUTABLE(5, ...
    // 6, 0x00001000 CONCURRENT(6, ...
    // 7, 0x00004000 SUBSIZED(7, ...

    // The following 4 flags are currently undefined and a free for any further
    // spliterator characteristics.
    //
    //  8, 0x00010000
    //  9, 0x00040000
    // 10, 0x00100000
    // 11, 0x00400000

    // The following flags are specific to streams and operations
    //

    /**
     * Characteristic value signifying that an operation may short-circuit the
     * stream.
     * &lt;p&gt;
     * An intermediate operation can preserve or inject this value,
     * or a terminal operation can preserve or inject this value.
     */
    // 12, 0x01000000
<span class="fc" id="L327">    SHORT_CIRCUIT(12,</span>
<span class="fc" id="L328">                  set(Type.OP).set(Type.TERMINAL_OP));</span>

    // The following 2 flags are currently undefined and a free for any further
    // stream flags if/when required
    //
    // 13, 0x04000000
    // 14, 0x10000000
    // 15, 0x40000000

    /**
     * Type of a flag
     */
<span class="pc" id="L340">    enum Type {</span>
        /**
         * The flag is associated with spliterator characteristics.
         */
<span class="fc" id="L344">        SPLITERATOR,</span>

        /**
         * The flag is associated with stream flags.
         */
<span class="fc" id="L349">        STREAM,</span>

        /**
         * The flag is associated with intermediate operation flags.
         */
<span class="fc" id="L354">        OP,</span>

        /**
         * The flag is associated with terminal operation flags.
         */
<span class="fc" id="L359">        TERMINAL_OP,</span>

        /**
         * The flag is associated with terminal operation flags that are
         * propagated upstream across the last stateful operation boundary
         */
<span class="fc" id="L365">        UPSTREAM_TERMINAL_OP</span>
    }

    /**
     * The bit pattern for setting/injecting a flag.
     */
    private static final int SET_BITS = 0b01;

    /**
     * The bit pattern for clearing a flag.
     */
    private static final int CLEAR_BITS = 0b10;

    /**
     * The bit pattern for preserving a flag.
     */
    private static final int PRESERVE_BITS = 0b11;

    private static MaskBuilder set(Type t) {
<span class="fc" id="L384">        return new MaskBuilder(new EnumMap&lt;&gt;(Type.class)).set(t);</span>
    }

    private static class MaskBuilder {
        final Map&lt;Type, Integer&gt; map;

<span class="fc" id="L390">        MaskBuilder(Map&lt;Type, Integer&gt; map) {</span>
<span class="fc" id="L391">            this.map = map;</span>
<span class="fc" id="L392">        }</span>

        MaskBuilder mask(Type t, Integer i) {
<span class="fc" id="L395">            map.put(t, i);</span>
<span class="fc" id="L396">            return this;</span>
        }

        MaskBuilder set(Type t) {
<span class="fc" id="L400">            return mask(t, SET_BITS);</span>
        }

        MaskBuilder clear(Type t) {
<span class="fc" id="L404">            return mask(t, CLEAR_BITS);</span>
        }

        MaskBuilder setAndClear(Type t) {
<span class="fc" id="L408">            return mask(t, PRESERVE_BITS);</span>
        }

        Map&lt;Type, Integer&gt; build() {
<span class="fc bfc" id="L412" title="All 2 branches covered.">            for (Type t : Type.values()) {</span>
<span class="fc" id="L413">                map.putIfAbsent(t, 0b00);</span>
            }
<span class="fc" id="L415">            return map;</span>
        }
    }

    /**
     * The mask table for a flag, this is used to determine if a flag
     * corresponds to a certain flag type and for creating mask constants.
     */
    private final Map&lt;Type, Integer&gt; maskTable;

    /**
     * The bit position in the bit mask.
     */
    private final int bitPosition;

    /**
     * The set 2 bit set offset at the bit position.
     */
    private final int set;

    /**
     * The clear 2 bit set offset at the bit position.
     */
    private final int clear;

    /**
     * The preserve 2 bit set offset at the bit position.
     */
    private final int preserve;

<span class="fc" id="L445">    private StreamOpFlag(int position, MaskBuilder maskBuilder) {</span>
<span class="fc" id="L446">        this.maskTable = maskBuilder.build();</span>
        // Two bits per flag
<span class="fc" id="L448">        position *= 2;</span>
<span class="fc" id="L449">        this.bitPosition = position;</span>
<span class="fc" id="L450">        this.set = SET_BITS &lt;&lt; position;</span>
<span class="fc" id="L451">        this.clear = CLEAR_BITS &lt;&lt; position;</span>
<span class="fc" id="L452">        this.preserve = PRESERVE_BITS &lt;&lt; position;</span>
<span class="fc" id="L453">    }</span>

    /**
     * Gets the bitmap associated with setting this characteristic.
     *
     * @return the bitmap for setting this characteristic
     */
    int set() {
<span class="fc" id="L461">        return set;</span>
    }

    /**
     * Gets the bitmap associated with clearing this characteristic.
     *
     * @return the bitmap for clearing this characteristic
     */
    int clear() {
<span class="fc" id="L470">        return clear;</span>
    }

    /**
     * Determines if this flag is a stream-based flag.
     *
     * @return true if a stream-based flag, otherwise false.
     */
    boolean isStreamFlag() {
<span class="fc bfc" id="L479" title="All 2 branches covered.">        return maskTable.get(Type.STREAM) &gt; 0;</span>
    }

    /**
     * Checks if this flag is set on stream flags, injected on operation flags,
     * and injected on combined stream and operation flags.
     *
     * @param flags the stream flags, operation flags, or combined stream and
     *        operation flags
     * @return true if this flag is known, otherwise false.
     */
    boolean isKnown(int flags) {
<span class="fc bfc" id="L491" title="All 2 branches covered.">        return (flags &amp; preserve) == set;</span>
    }

    /**
     * Checks if this flag is cleared on operation flags or combined stream and
     * operation flags.
     *
     * @param flags the operation flags or combined stream and operations flags.
     * @return true if this flag is preserved, otherwise false.
     */
    boolean isCleared(int flags) {
<span class="fc bfc" id="L502" title="All 2 branches covered.">        return (flags &amp; preserve) == clear;</span>
    }

    /**
     * Checks if this flag is preserved on combined stream and operation flags.
     *
     * @param flags the combined stream and operations flags.
     * @return true if this flag is preserved, otherwise false.
     */
    boolean isPreserved(int flags) {
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">        return (flags &amp; preserve) == preserve;</span>
    }

    /**
     * Determines if this flag can be set for a flag type.
     *
     * @param t the flag type.
     * @return true if this flag can be set for the flag type, otherwise false.
     */
    boolean canSet(Type t) {
<span class="fc bfc" id="L522" title="All 2 branches covered.">        return (maskTable.get(t) &amp; SET_BITS) &gt; 0;</span>
    }

    /**
     * The bit mask for spliterator characteristics
     */
<span class="fc" id="L528">    static final int SPLITERATOR_CHARACTERISTICS_MASK = createMask(Type.SPLITERATOR);</span>

    /**
     * The bit mask for source stream flags.
     */
<span class="fc" id="L533">    static final int STREAM_MASK = createMask(Type.STREAM);</span>

    /**
     * The bit mask for intermediate operation flags.
     */
<span class="fc" id="L538">    static final int OP_MASK = createMask(Type.OP);</span>

    /**
     * The bit mask for terminal operation flags.
     */
<span class="fc" id="L543">    static final int TERMINAL_OP_MASK = createMask(Type.TERMINAL_OP);</span>

    /**
     * The bit mask for upstream terminal operation flags.
     */
<span class="fc" id="L548">    static final int UPSTREAM_TERMINAL_OP_MASK = createMask(Type.UPSTREAM_TERMINAL_OP);</span>

    private static int createMask(Type t) {
<span class="fc" id="L551">        int mask = 0;</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">        for (StreamOpFlag flag : StreamOpFlag.values()) {</span>
<span class="fc" id="L553">            mask |= flag.maskTable.get(t) &lt;&lt; flag.bitPosition;</span>
        }
<span class="fc" id="L555">        return mask;</span>
    }

    /**
     * Complete flag mask.
     */
<span class="fc" id="L561">    private static final int FLAG_MASK = createFlagMask();</span>

    private static int createFlagMask() {
<span class="fc" id="L564">        int mask = 0;</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">        for (StreamOpFlag flag : StreamOpFlag.values()) {</span>
<span class="fc" id="L566">            mask |= flag.preserve;</span>
        }
<span class="fc" id="L568">        return mask;</span>
    }

    /**
     * Flag mask for stream flags that are set.
     */
<span class="fc" id="L574">    private static final int FLAG_MASK_IS = STREAM_MASK;</span>

    /**
     * Flag mask for stream flags that are cleared.
     */
<span class="fc" id="L579">    private static final int FLAG_MASK_NOT = STREAM_MASK &lt;&lt; 1;</span>

    /**
     * The initial value to be combined with the stream flags of the first
     * stream in the pipeline.
     */
<span class="fc" id="L585">    static final int INITIAL_OPS_VALUE = FLAG_MASK_IS | FLAG_MASK_NOT;</span>

    /**
     * The bit value to set or inject {@link #DISTINCT}.
     */
<span class="fc" id="L590">    static final int IS_DISTINCT = DISTINCT.set;</span>

    /**
     * The bit value to clear {@link #DISTINCT}.
     */
<span class="fc" id="L595">    static final int NOT_DISTINCT = DISTINCT.clear;</span>

    /**
     * The bit value to set or inject {@link #SORTED}.
     */
<span class="fc" id="L600">    static final int IS_SORTED = SORTED.set;</span>

    /**
     * The bit value to clear {@link #SORTED}.
     */
<span class="fc" id="L605">    static final int NOT_SORTED = SORTED.clear;</span>

    /**
     * The bit value to set or inject {@link #ORDERED}.
     */
<span class="fc" id="L610">    static final int IS_ORDERED = ORDERED.set;</span>

    /**
     * The bit value to clear {@link #ORDERED}.
     */
<span class="fc" id="L615">    static final int NOT_ORDERED = ORDERED.clear;</span>

    /**
     * The bit value to set {@link #SIZED}.
     */
<span class="fc" id="L620">    static final int IS_SIZED = SIZED.set;</span>

    /**
     * The bit value to clear {@link #SIZED}.
     */
<span class="fc" id="L625">    static final int NOT_SIZED = SIZED.clear;</span>

    /**
     * The bit value to inject {@link #SHORT_CIRCUIT}.
     */
<span class="fc" id="L630">    static final int IS_SHORT_CIRCUIT = SHORT_CIRCUIT.set;</span>

    private static int getMask(int flags) {
<span class="fc bfc" id="L633" title="All 2 branches covered.">        return (flags == 0)</span>
               ? FLAG_MASK
               : ~(flags | ((FLAG_MASK_IS &amp; flags) &lt;&lt; 1) | ((FLAG_MASK_NOT &amp; flags) &gt;&gt; 1));
    }

    /**
     * Combines stream or operation flags with previously combined stream and
     * operation flags to produce updated combined stream and operation flags.
     * &lt;p&gt;
     * A flag set on stream flags or injected on operation flags,
     * and injected combined stream and operation flags,
     * will be injected on the updated combined stream and operation flags.
     *
     * &lt;p&gt;
     * A flag set on stream flags or injected on operation flags,
     * and cleared on the combined stream and operation flags,
     * will be cleared on the updated combined stream and operation flags.
     *
     * &lt;p&gt;
     * A flag set on the stream flags or injected on operation flags,
     * and preserved on the combined stream and operation flags,
     * will be injected on the updated combined stream and operation flags.
     *
     * &lt;p&gt;
     * A flag not set on the stream flags or cleared/preserved on operation
     * flags, and injected on the combined stream and operation flags,
     * will be injected on the updated combined stream and operation flags.
     *
     * &lt;p&gt;
     * A flag not set on the stream flags or cleared/preserved on operation
     * flags, and cleared on the combined stream and operation flags,
     * will be cleared on the updated combined stream and operation flags.
     *
     * &lt;p&gt;
     * A flag not set on the stream flags,
     * and preserved on the combined stream and operation flags
     * will be preserved on the updated combined stream and operation flags.
     *
     * &lt;p&gt;
     * A flag cleared on operation flags,
     * and preserved on the combined stream and operation flags
     * will be cleared on the updated combined stream and operation flags.
     *
     * &lt;p&gt;
     * A flag preserved on operation flags,
     * and preserved on the combined stream and operation flags
     * will be preserved on the updated combined stream and operation flags.
     *
     * @param newStreamOrOpFlags the stream or operation flags.
     * @param prevCombOpFlags previously combined stream and operation flags.
     *        The value {#link INITIAL_OPS_VALUE} must be used as the seed value.
     * @return the updated combined stream and operation flags.
     */
    static int combineOpFlags(int newStreamOrOpFlags, int prevCombOpFlags) {
        // 0x01 or 0x10 nibbles are transformed to 0x11
        // 0x00 nibbles remain unchanged
        // Then all the bits are flipped
        // Then the result is logically or'ed with the operation flags.
<span class="fc" id="L691">        return (prevCombOpFlags &amp; StreamOpFlag.getMask(newStreamOrOpFlags)) | newStreamOrOpFlags;</span>
    }

    /**
     * Converts combined stream and operation flags to stream flags.
     *
     * &lt;p&gt;Each flag injected on the combined stream and operation flags will be
     * set on the stream flags.
     *
     * @param combOpFlags the combined stream and operation flags.
     * @return the stream flags.
     */
    static int toStreamFlags(int combOpFlags) {
        // By flipping the nibbles 0x11 become 0x00 and 0x01 become 0x10
        // Shift left 1 to restore set flags and mask off anything other than the set flags
<span class="fc" id="L706">        return ((~combOpFlags) &gt;&gt; 1) &amp; FLAG_MASK_IS &amp; combOpFlags;</span>
    }

    /**
     * Converts stream flags to a spliterator characteristic bit set.
     *
     * @param streamFlags the stream flags.
     * @return the spliterator characteristic bit set.
     */
    static int toCharacteristics(int streamFlags) {
<span class="fc" id="L716">        return streamFlags &amp; SPLITERATOR_CHARACTERISTICS_MASK;</span>
    }

    /**
     * Converts a spliterator characteristic bit set to stream flags.
     *
     * @implSpec
     * If the spliterator is naturally {@code SORTED} (the associated
     * {@code Comparator} is {@code null}) then the characteristic is converted
     * to the {@link #SORTED} flag, otherwise the characteristic is not
     * converted.
     *
     * @param spliterator the spliterator from which to obtain characteristic
     *        bit set.
     * @return the stream flags.
     */
    static int fromCharacteristics(Spliterator&lt;?&gt; spliterator) {
<span class="fc" id="L733">        int characteristics = spliterator.characteristics();</span>
<span class="fc bfc" id="L734" title="All 4 branches covered.">        if ((characteristics &amp; Spliterator.SORTED) != 0 &amp;&amp; spliterator.getComparator() != null) {</span>
            // Do not propagate the SORTED characteristic if it does not correspond
            // to a natural sort order
<span class="fc" id="L737">            return characteristics &amp; SPLITERATOR_CHARACTERISTICS_MASK &amp; ~Spliterator.SORTED;</span>
        }
        else {
<span class="fc" id="L740">            return characteristics &amp; SPLITERATOR_CHARACTERISTICS_MASK;</span>
        }
    }

    /**
     * Converts a spliterator characteristic bit set to stream flags.
     *
     * @param characteristics the spliterator characteristic bit set.
     * @return the stream flags.
     */
    static int fromCharacteristics(int characteristics) {
<span class="fc" id="L751">        return characteristics &amp; SPLITERATOR_CHARACTERISTICS_MASK;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>