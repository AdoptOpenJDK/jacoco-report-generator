<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Nodes.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.stream</a> &gt; <span class="el_source">Nodes.java</span></div><h1>Nodes.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util.stream;

import java.util.ArrayDeque;
import java.util.Arrays;
import java.util.Collection;
import java.util.Deque;
import java.util.List;
import java.util.Objects;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.concurrent.CountedCompleter;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.DoubleConsumer;
import java.util.function.IntConsumer;
import java.util.function.IntFunction;
import java.util.function.LongConsumer;
import java.util.function.LongFunction;

/**
 * Factory methods for constructing implementations of {@link Node} and
 * {@link Node.Builder} and their primitive specializations.  Fork/Join tasks
 * for collecting output from a {@link PipelineHelper} to a {@link Node} and
 * flattening {@link Node}s.
 *
 * @since 1.8
 */
final class Nodes {

<span class="nc" id="L54">    private Nodes() {</span>
<span class="nc" id="L55">        throw new Error(&quot;no instances&quot;);</span>
    }

    /**
     * The maximum size of an array that can be allocated.
     */
    static final long MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    // IllegalArgumentException messages
    static final String BAD_SIZE = &quot;Stream size exceeds max array size&quot;;

    @SuppressWarnings(&quot;raw&quot;)
<span class="fc" id="L67">    private static final Node EMPTY_NODE = new EmptyNode.OfRef();</span>
<span class="fc" id="L68">    private static final Node.OfInt EMPTY_INT_NODE = new EmptyNode.OfInt();</span>
<span class="fc" id="L69">    private static final Node.OfLong EMPTY_LONG_NODE = new EmptyNode.OfLong();</span>
<span class="fc" id="L70">    private static final Node.OfDouble EMPTY_DOUBLE_NODE = new EmptyNode.OfDouble();</span>

    // General shape-based node creation methods

    /**
     * Produces an empty node whose count is zero, has no children and no content.
     *
     * @param &lt;T&gt; the type of elements of the created node
     * @param shape the shape of the node to be created
     * @return an empty node.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Node&lt;T&gt; emptyNode(StreamShape shape) {
<span class="nc bnc" id="L83" title="All 5 branches missed.">        switch (shape) {</span>
<span class="nc" id="L84">            case REFERENCE:    return (Node&lt;T&gt;) EMPTY_NODE;</span>
<span class="nc" id="L85">            case INT_VALUE:    return (Node&lt;T&gt;) EMPTY_INT_NODE;</span>
<span class="nc" id="L86">            case LONG_VALUE:   return (Node&lt;T&gt;) EMPTY_LONG_NODE;</span>
<span class="nc" id="L87">            case DOUBLE_VALUE: return (Node&lt;T&gt;) EMPTY_DOUBLE_NODE;</span>
            default:
<span class="nc" id="L89">                throw new IllegalStateException(&quot;Unknown shape &quot; + shape);</span>
        }
    }

    /**
     * Produces a concatenated {@link Node} that has two or more children.
     * &lt;p&gt;The count of the concatenated node is equal to the sum of the count
     * of each child. Traversal of the concatenated node traverses the content
     * of each child in encounter order of the list of children. Splitting a
     * spliterator obtained from the concatenated node preserves the encounter
     * order of the list of children.
     *
     * &lt;p&gt;The result may be a concatenated node, the input sole node if the size
     * of the list is 1, or an empty node.
     *
     * @param &lt;T&gt; the type of elements of the concatenated node
     * @param shape the shape of the concatenated node to be created
     * @param left the left input node
     * @param right the right input node
     * @return a {@code Node} covering the elements of the input nodes
     * @throws IllegalStateException if all {@link Node} elements of the list
     * are an not instance of type supported by this factory.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    static &lt;T&gt; Node&lt;T&gt; conc(StreamShape shape, Node&lt;T&gt; left, Node&lt;T&gt; right) {
<span class="nc bnc" id="L114" title="All 5 branches missed.">        switch (shape) {</span>
            case REFERENCE:
<span class="nc" id="L116">                return new ConcNode&lt;&gt;(left, right);</span>
            case INT_VALUE:
<span class="nc" id="L118">                return (Node&lt;T&gt;) new ConcNode.OfInt((Node.OfInt) left, (Node.OfInt) right);</span>
            case LONG_VALUE:
<span class="nc" id="L120">                return (Node&lt;T&gt;) new ConcNode.OfLong((Node.OfLong) left, (Node.OfLong) right);</span>
            case DOUBLE_VALUE:
<span class="nc" id="L122">                return (Node&lt;T&gt;) new ConcNode.OfDouble((Node.OfDouble) left, (Node.OfDouble) right);</span>
            default:
<span class="nc" id="L124">                throw new IllegalStateException(&quot;Unknown shape &quot; + shape);</span>
        }
    }

    // Reference-based node methods

    /**
     * Produces a {@link Node} describing an array.
     *
     * &lt;p&gt;The node will hold a reference to the array and will not make a copy.
     *
     * @param &lt;T&gt; the type of elements held by the node
     * @param array the array
     * @return a node holding an array
     */
    static &lt;T&gt; Node&lt;T&gt; node(T[] array) {
<span class="fc" id="L140">        return new ArrayNode&lt;&gt;(array);</span>
    }

    /**
     * Produces a {@link Node} describing a {@link Collection}.
     * &lt;p&gt;
     * The node will hold a reference to the collection and will not make a copy.
     *
     * @param &lt;T&gt; the type of elements held by the node
     * @param c the collection
     * @return a node holding a collection
     */
    static &lt;T&gt; Node&lt;T&gt; node(Collection&lt;T&gt; c) {
<span class="fc" id="L153">        return new CollectionNode&lt;&gt;(c);</span>
    }

    /**
     * Produces a {@link Node.Builder}.
     *
     * @param exactSizeIfKnown -1 if a variable size builder is requested,
     * otherwise the exact capacity desired.  A fixed capacity builder will
     * fail if the wrong number of elements are added to the builder.
     * @param generator the array factory
     * @param &lt;T&gt; the type of elements of the node builder
     * @return a {@code Node.Builder}
     */
    static &lt;T&gt; Node.Builder&lt;T&gt; builder(long exactSizeIfKnown, IntFunction&lt;T[]&gt; generator) {
<span class="pc bpc" id="L167" title="1 of 4 branches missed.">        return (exactSizeIfKnown &gt;= 0 &amp;&amp; exactSizeIfKnown &lt; MAX_ARRAY_SIZE)</span>
               ? new FixedNodeBuilder&lt;&gt;(exactSizeIfKnown, generator)
<span class="fc" id="L169">               : builder();</span>
    }

    /**
     * Produces a variable size @{link Node.Builder}.
     *
     * @param &lt;T&gt; the type of elements of the node builder
     * @return a {@code Node.Builder}
     */
    static &lt;T&gt; Node.Builder&lt;T&gt; builder() {
<span class="fc" id="L179">        return new SpinedNodeBuilder&lt;&gt;();</span>
    }

    // Int nodes

    /**
     * Produces a {@link Node.OfInt} describing an int[] array.
     *
     * &lt;p&gt;The node will hold a reference to the array and will not make a copy.
     *
     * @param array the array
     * @return a node holding an array
     */
    static Node.OfInt node(int[] array) {
<span class="fc" id="L193">        return new IntArrayNode(array);</span>
    }

    /**
     * Produces a {@link Node.Builder.OfInt}.
     *
     * @param exactSizeIfKnown -1 if a variable size builder is requested,
     * otherwise the exact capacity desired.  A fixed capacity builder will
     * fail if the wrong number of elements are added to the builder.
     * @return a {@code Node.Builder.OfInt}
     */
    static Node.Builder.OfInt intBuilder(long exactSizeIfKnown) {
<span class="pc bpc" id="L205" title="1 of 4 branches missed.">        return (exactSizeIfKnown &gt;= 0 &amp;&amp; exactSizeIfKnown &lt; MAX_ARRAY_SIZE)</span>
               ? new IntFixedNodeBuilder(exactSizeIfKnown)
<span class="fc" id="L207">               : intBuilder();</span>
    }

    /**
     * Produces a variable size @{link Node.Builder.OfInt}.
     *
     * @return a {@code Node.Builder.OfInt}
     */
    static Node.Builder.OfInt intBuilder() {
<span class="fc" id="L216">        return new IntSpinedNodeBuilder();</span>
    }

    // Long nodes

    /**
     * Produces a {@link Node.OfLong} describing a long[] array.
     * &lt;p&gt;
     * The node will hold a reference to the array and will not make a copy.
     *
     * @param array the array
     * @return a node holding an array
     */
    static Node.OfLong node(final long[] array) {
<span class="fc" id="L230">        return new LongArrayNode(array);</span>
    }

    /**
     * Produces a {@link Node.Builder.OfLong}.
     *
     * @param exactSizeIfKnown -1 if a variable size builder is requested,
     * otherwise the exact capacity desired.  A fixed capacity builder will
     * fail if the wrong number of elements are added to the builder.
     * @return a {@code Node.Builder.OfLong}
     */
    static Node.Builder.OfLong longBuilder(long exactSizeIfKnown) {
<span class="pc bpc" id="L242" title="1 of 4 branches missed.">        return (exactSizeIfKnown &gt;= 0 &amp;&amp; exactSizeIfKnown &lt; MAX_ARRAY_SIZE)</span>
               ? new LongFixedNodeBuilder(exactSizeIfKnown)
<span class="fc" id="L244">               : longBuilder();</span>
    }

    /**
     * Produces a variable size @{link Node.Builder.OfLong}.
     *
     * @return a {@code Node.Builder.OfLong}
     */
    static Node.Builder.OfLong longBuilder() {
<span class="fc" id="L253">        return new LongSpinedNodeBuilder();</span>
    }

    // Double nodes

    /**
     * Produces a {@link Node.OfDouble} describing a double[] array.
     *
     * &lt;p&gt;The node will hold a reference to the array and will not make a copy.
     *
     * @param array the array
     * @return a node holding an array
     */
    static Node.OfDouble node(final double[] array) {
<span class="fc" id="L267">        return new DoubleArrayNode(array);</span>
    }

    /**
     * Produces a {@link Node.Builder.OfDouble}.
     *
     * @param exactSizeIfKnown -1 if a variable size builder is requested,
     * otherwise the exact capacity desired.  A fixed capacity builder will
     * fail if the wrong number of elements are added to the builder.
     * @return a {@code Node.Builder.OfDouble}
     */
    static Node.Builder.OfDouble doubleBuilder(long exactSizeIfKnown) {
<span class="pc bpc" id="L279" title="1 of 4 branches missed.">        return (exactSizeIfKnown &gt;= 0 &amp;&amp; exactSizeIfKnown &lt; MAX_ARRAY_SIZE)</span>
               ? new DoubleFixedNodeBuilder(exactSizeIfKnown)
<span class="fc" id="L281">               : doubleBuilder();</span>
    }

    /**
     * Produces a variable size @{link Node.Builder.OfDouble}.
     *
     * @return a {@code Node.Builder.OfDouble}
     */
    static Node.Builder.OfDouble doubleBuilder() {
<span class="fc" id="L290">        return new DoubleSpinedNodeBuilder();</span>
    }

    // Parallel evaluation of pipelines to nodes

    /**
     * Collect, in parallel, elements output from a pipeline and describe those
     * elements with a {@link Node}.
     *
     * @implSpec
     * If the exact size of the output from the pipeline is known and the source
     * {@link Spliterator} has the {@link Spliterator#SUBSIZED} characteristic,
     * then a flat {@link Node} will be returned whose content is an array,
     * since the size is known the array can be constructed in advance and
     * output elements can be placed into the array concurrently by leaf
     * tasks at the correct offsets.  If the exact size is not known, output
     * elements are collected into a conc-node whose shape mirrors that
     * of the computation. This conc-node can then be flattened in
     * parallel to produce a flat {@code Node} if desired.
     *
     * @param helper the pipeline helper describing the pipeline
     * @param flattenTree whether a conc node should be flattened into a node
     *                    describing an array before returning
     * @param generator the array generator
     * @return a {@link Node} describing the output elements
     */
    public static &lt;P_IN, P_OUT&gt; Node&lt;P_OUT&gt; collect(PipelineHelper&lt;P_OUT&gt; helper,
                                                    Spliterator&lt;P_IN&gt; spliterator,
                                                    boolean flattenTree,
                                                    IntFunction&lt;P_OUT[]&gt; generator) {
<span class="fc" id="L320">        long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="pc bpc" id="L321" title="3 of 4 branches missed.">        if (size &gt;= 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L323">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="nc" id="L324">            P_OUT[] array = generator.apply((int) size);</span>
<span class="nc" id="L325">            new SizedCollectorTask.OfRef&lt;&gt;(spliterator, helper, array).invoke();</span>
<span class="nc" id="L326">            return node(array);</span>
        } else {
<span class="nc" id="L328">            Node&lt;P_OUT&gt; node = new CollectorTask.OfRef&lt;&gt;(helper, generator, spliterator).invoke();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            return flattenTree ? flatten(node, generator) : node;</span>
        }
    }

    /**
     * Collect, in parallel, elements output from an int-valued pipeline and
     * describe those elements with a {@link Node.OfInt}.
     *
     * @implSpec
     * If the exact size of the output from the pipeline is known and the source
     * {@link Spliterator} has the {@link Spliterator#SUBSIZED} characteristic,
     * then a flat {@link Node} will be returned whose content is an array,
     * since the size is known the array can be constructed in advance and
     * output elements can be placed into the array concurrently by leaf
     * tasks at the correct offsets.  If the exact size is not known, output
     * elements are collected into a conc-node whose shape mirrors that
     * of the computation. This conc-node can then be flattened in
     * parallel to produce a flat {@code Node.OfInt} if desired.
     *
     * @param &lt;P_IN&gt; the type of elements from the source Spliterator
     * @param helper the pipeline helper describing the pipeline
     * @param flattenTree whether a conc node should be flattened into a node
     *                    describing an array before returning
     * @return a {@link Node.OfInt} describing the output elements
     */
    public static &lt;P_IN&gt; Node.OfInt collectInt(PipelineHelper&lt;Integer&gt; helper,
                                               Spliterator&lt;P_IN&gt; spliterator,
                                               boolean flattenTree) {
<span class="fc" id="L357">        long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="pc bpc" id="L358" title="3 of 4 branches missed.">        if (size &gt;= 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L360">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="nc" id="L361">            int[] array = new int[(int) size];</span>
<span class="nc" id="L362">            new SizedCollectorTask.OfInt&lt;&gt;(spliterator, helper, array).invoke();</span>
<span class="nc" id="L363">            return node(array);</span>
        }
        else {
<span class="nc" id="L366">            Node.OfInt node = new CollectorTask.OfInt&lt;&gt;(helper, spliterator).invoke();</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">            return flattenTree ? flattenInt(node) : node;</span>
        }
    }

    /**
     * Collect, in parallel, elements output from a long-valued pipeline and
     * describe those elements with a {@link Node.OfLong}.
     *
     * @implSpec
     * If the exact size of the output from the pipeline is known and the source
     * {@link Spliterator} has the {@link Spliterator#SUBSIZED} characteristic,
     * then a flat {@link Node} will be returned whose content is an array,
     * since the size is known the array can be constructed in advance and
     * output elements can be placed into the array concurrently by leaf
     * tasks at the correct offsets.  If the exact size is not known, output
     * elements are collected into a conc-node whose shape mirrors that
     * of the computation. This conc-node can then be flattened in
     * parallel to produce a flat {@code Node.OfLong} if desired.
     *
     * @param &lt;P_IN&gt; the type of elements from the source Spliterator
     * @param helper the pipeline helper describing the pipeline
     * @param flattenTree whether a conc node should be flattened into a node
     *                    describing an array before returning
     * @return a {@link Node.OfLong} describing the output elements
     */
    public static &lt;P_IN&gt; Node.OfLong collectLong(PipelineHelper&lt;Long&gt; helper,
                                                 Spliterator&lt;P_IN&gt; spliterator,
                                                 boolean flattenTree) {
<span class="fc" id="L395">        long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="pc bpc" id="L396" title="3 of 4 branches missed.">        if (size &gt;= 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L398">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="nc" id="L399">            long[] array = new long[(int) size];</span>
<span class="nc" id="L400">            new SizedCollectorTask.OfLong&lt;&gt;(spliterator, helper, array).invoke();</span>
<span class="nc" id="L401">            return node(array);</span>
        }
        else {
<span class="nc" id="L404">            Node.OfLong node = new CollectorTask.OfLong&lt;&gt;(helper, spliterator).invoke();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">            return flattenTree ? flattenLong(node) : node;</span>
        }
    }

    /**
     * Collect, in parallel, elements output from n double-valued pipeline and
     * describe those elements with a {@link Node.OfDouble}.
     *
     * @implSpec
     * If the exact size of the output from the pipeline is known and the source
     * {@link Spliterator} has the {@link Spliterator#SUBSIZED} characteristic,
     * then a flat {@link Node} will be returned whose content is an array,
     * since the size is known the array can be constructed in advance and
     * output elements can be placed into the array concurrently by leaf
     * tasks at the correct offsets.  If the exact size is not known, output
     * elements are collected into a conc-node whose shape mirrors that
     * of the computation. This conc-node can then be flattened in
     * parallel to produce a flat {@code Node.OfDouble} if desired.
     *
     * @param &lt;P_IN&gt; the type of elements from the source Spliterator
     * @param helper the pipeline helper describing the pipeline
     * @param flattenTree whether a conc node should be flattened into a node
     *                    describing an array before returning
     * @return a {@link Node.OfDouble} describing the output elements
     */
    public static &lt;P_IN&gt; Node.OfDouble collectDouble(PipelineHelper&lt;Double&gt; helper,
                                                     Spliterator&lt;P_IN&gt; spliterator,
                                                     boolean flattenTree) {
<span class="fc" id="L433">        long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="pc bpc" id="L434" title="3 of 4 branches missed.">        if (size &gt;= 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L436">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="nc" id="L437">            double[] array = new double[(int) size];</span>
<span class="nc" id="L438">            new SizedCollectorTask.OfDouble&lt;&gt;(spliterator, helper, array).invoke();</span>
<span class="nc" id="L439">            return node(array);</span>
        }
        else {
<span class="nc" id="L442">            Node.OfDouble node = new CollectorTask.OfDouble&lt;&gt;(helper, spliterator).invoke();</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">            return flattenTree ? flattenDouble(node) : node;</span>
        }
    }

    // Parallel flattening of nodes

    /**
     * Flatten, in parallel, a {@link Node}.  A flattened node is one that has
     * no children.  If the node is already flat, it is simply returned.
     *
     * @implSpec
     * If a new node is to be created, the generator is used to create an array
     * whose length is {@link Node#count()}.  Then the node tree is traversed
     * and leaf node elements are placed in the array concurrently by leaf tasks
     * at the correct offsets.
     *
     * @param &lt;T&gt; type of elements contained by the node
     * @param node the node to flatten
     * @param generator the array factory used to create array instances
     * @return a flat {@code Node}
     */
    public static &lt;T&gt; Node&lt;T&gt; flatten(Node&lt;T&gt; node, IntFunction&lt;T[]&gt; generator) {
<span class="fc bfc" id="L465" title="All 2 branches covered.">        if (node.getChildCount() &gt; 0) {</span>
<span class="fc" id="L466">            long size = node.count();</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L468">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="fc" id="L469">            T[] array = generator.apply((int) size);</span>
<span class="fc" id="L470">            new ToArrayTask.OfRef&lt;&gt;(node, array, 0).invoke();</span>
<span class="fc" id="L471">            return node(array);</span>
        } else {
<span class="fc" id="L473">            return node;</span>
        }
    }

    /**
     * Flatten, in parallel, a {@link Node.OfInt}.  A flattened node is one that
     * has no children.  If the node is already flat, it is simply returned.
     *
     * @implSpec
     * If a new node is to be created, a new int[] array is created whose length
     * is {@link Node#count()}.  Then the node tree is traversed and leaf node
     * elements are placed in the array concurrently by leaf tasks at the
     * correct offsets.
     *
     * @param node the node to flatten
     * @return a flat {@code Node.OfInt}
     */
    public static Node.OfInt flattenInt(Node.OfInt node) {
<span class="fc bfc" id="L491" title="All 2 branches covered.">        if (node.getChildCount() &gt; 0) {</span>
<span class="fc" id="L492">            long size = node.count();</span>
<span class="pc bpc" id="L493" title="1 of 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L494">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="fc" id="L495">            int[] array = new int[(int) size];</span>
<span class="fc" id="L496">            new ToArrayTask.OfInt(node, array, 0).invoke();</span>
<span class="fc" id="L497">            return node(array);</span>
        } else {
<span class="fc" id="L499">            return node;</span>
        }
    }

    /**
     * Flatten, in parallel, a {@link Node.OfLong}.  A flattened node is one that
     * has no children.  If the node is already flat, it is simply returned.
     *
     * @implSpec
     * If a new node is to be created, a new long[] array is created whose length
     * is {@link Node#count()}.  Then the node tree is traversed and leaf node
     * elements are placed in the array concurrently by leaf tasks at the
     * correct offsets.
     *
     * @param node the node to flatten
     * @return a flat {@code Node.OfLong}
     */
    public static Node.OfLong flattenLong(Node.OfLong node) {
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (node.getChildCount() &gt; 0) {</span>
<span class="fc" id="L518">            long size = node.count();</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L520">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="fc" id="L521">            long[] array = new long[(int) size];</span>
<span class="fc" id="L522">            new ToArrayTask.OfLong(node, array, 0).invoke();</span>
<span class="fc" id="L523">            return node(array);</span>
        } else {
<span class="fc" id="L525">            return node;</span>
        }
    }

    /**
     * Flatten, in parallel, a {@link Node.OfDouble}.  A flattened node is one that
     * has no children.  If the node is already flat, it is simply returned.
     *
     * @implSpec
     * If a new node is to be created, a new double[] array is created whose length
     * is {@link Node#count()}.  Then the node tree is traversed and leaf node
     * elements are placed in the array concurrently by leaf tasks at the
     * correct offsets.
     *
     * @param node the node to flatten
     * @return a flat {@code Node.OfDouble}
     */
    public static Node.OfDouble flattenDouble(Node.OfDouble node) {
<span class="fc bfc" id="L543" title="All 2 branches covered.">        if (node.getChildCount() &gt; 0) {</span>
<span class="fc" id="L544">            long size = node.count();</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L546">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="fc" id="L547">            double[] array = new double[(int) size];</span>
<span class="fc" id="L548">            new ToArrayTask.OfDouble(node, array, 0).invoke();</span>
<span class="fc" id="L549">            return node(array);</span>
        } else {
<span class="fc" id="L551">            return node;</span>
        }
    }

    // Implementations

    private static abstract class EmptyNode&lt;T, T_ARR, T_CONS&gt; implements Node&lt;T&gt; {
<span class="fc" id="L558">        EmptyNode() { }</span>

        @Override
        public T[] asArray(IntFunction&lt;T[]&gt; generator) {
<span class="nc" id="L562">            return generator.apply(0);</span>
        }

<span class="nc" id="L565">        public void copyInto(T_ARR array, int offset) { }</span>

        @Override
        public long count() {
<span class="nc" id="L569">            return 0;</span>
        }

<span class="nc" id="L572">        public void forEach(T_CONS consumer) { }</span>

        private static class OfRef&lt;T&gt; extends EmptyNode&lt;T, T[], Consumer&lt;? super T&gt;&gt; {
            private OfRef() {
<span class="fc" id="L576">                super();</span>
<span class="fc" id="L577">            }</span>

            @Override
            public Spliterator&lt;T&gt; spliterator() {
<span class="nc" id="L581">                return Spliterators.emptySpliterator();</span>
            }
        }

        private static final class OfInt
                extends EmptyNode&lt;Integer, int[], IntConsumer&gt;
                implements Node.OfInt {

<span class="fc" id="L589">            OfInt() { } // Avoid creation of special accessor</span>

            @Override
            public Spliterator.OfInt spliterator() {
<span class="nc" id="L593">                return Spliterators.emptyIntSpliterator();</span>
            }

            @Override
            public int[] asPrimitiveArray() {
<span class="nc" id="L598">                return EMPTY_INT_ARRAY;</span>
            }
        }

        private static final class OfLong
                extends EmptyNode&lt;Long, long[], LongConsumer&gt;
                implements Node.OfLong {

<span class="fc" id="L606">            OfLong() { } // Avoid creation of special accessor</span>

            @Override
            public Spliterator.OfLong spliterator() {
<span class="nc" id="L610">                return Spliterators.emptyLongSpliterator();</span>
            }

            @Override
            public long[] asPrimitiveArray() {
<span class="nc" id="L615">                return EMPTY_LONG_ARRAY;</span>
            }
        }

        private static final class OfDouble
                extends EmptyNode&lt;Double, double[], DoubleConsumer&gt;
                implements Node.OfDouble {

<span class="fc" id="L623">            OfDouble() { } // Avoid creation of special accessor</span>

            @Override
            public Spliterator.OfDouble spliterator() {
<span class="nc" id="L627">                return Spliterators.emptyDoubleSpliterator();</span>
            }

            @Override
            public double[] asPrimitiveArray() {
<span class="nc" id="L632">                return EMPTY_DOUBLE_ARRAY;</span>
            }
        }
    }

    /** Node class for a reference array */
    private static class ArrayNode&lt;T&gt; implements Node&lt;T&gt; {
        final T[] array;
        int curSize;

        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L643">        ArrayNode(long size, IntFunction&lt;T[]&gt; generator) {</span>
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L645">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="fc" id="L646">            this.array = generator.apply((int) size);</span>
<span class="fc" id="L647">            this.curSize = 0;</span>
<span class="fc" id="L648">        }</span>

<span class="fc" id="L650">        ArrayNode(T[] array) {</span>
<span class="fc" id="L651">            this.array = array;</span>
<span class="fc" id="L652">            this.curSize = array.length;</span>
<span class="fc" id="L653">        }</span>

        // Node

        @Override
        public Spliterator&lt;T&gt; spliterator() {
<span class="fc" id="L659">            return Arrays.spliterator(array, 0, curSize);</span>
        }

        @Override
        public void copyInto(T[] dest, int destOffset) {
<span class="fc" id="L664">            System.arraycopy(array, 0, dest, destOffset, curSize);</span>
<span class="fc" id="L665">        }</span>

        @Override
        public T[] asArray(IntFunction&lt;T[]&gt; generator) {
<span class="pc bpc" id="L669" title="1 of 2 branches missed.">            if (array.length == curSize) {</span>
<span class="fc" id="L670">                return array;</span>
            } else {
<span class="nc" id="L672">                throw new IllegalStateException();</span>
            }
        }

        @Override
        public long count() {
<span class="fc" id="L678">            return curSize;</span>
        }

        @Override
        public void forEach(Consumer&lt;? super T&gt; consumer) {
<span class="fc bfc" id="L683" title="All 2 branches covered.">            for (int i = 0; i &lt; curSize; i++) {</span>
<span class="fc" id="L684">                consumer.accept(array[i]);</span>
            }
<span class="fc" id="L686">        }</span>

        //

        @Override
        public String toString() {
<span class="fc" id="L692">            return String.format(&quot;ArrayNode[%d][%s]&quot;,</span>
<span class="fc" id="L693">                                 array.length - curSize, Arrays.toString(array));</span>
        }
    }

    /** Node class for a Collection */
    private static final class CollectionNode&lt;T&gt; implements Node&lt;T&gt; {
        private final Collection&lt;T&gt; c;

<span class="fc" id="L701">        CollectionNode(Collection&lt;T&gt; c) {</span>
<span class="fc" id="L702">            this.c = c;</span>
<span class="fc" id="L703">        }</span>

        // Node

        @Override
        public Spliterator&lt;T&gt; spliterator() {
<span class="nc" id="L709">            return c.stream().spliterator();</span>
        }

        @Override
        public void copyInto(T[] array, int offset) {
<span class="fc bfc" id="L714" title="All 2 branches covered.">            for (T t : c)</span>
<span class="fc" id="L715">                array[offset++] = t;</span>
<span class="fc" id="L716">        }</span>

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public T[] asArray(IntFunction&lt;T[]&gt; generator) {
<span class="fc" id="L721">            return c.toArray(generator.apply(c.size()));</span>
        }

        @Override
        public long count() {
<span class="fc" id="L726">            return c.size();</span>
        }

        @Override
        public void forEach(Consumer&lt;? super T&gt; consumer) {
<span class="fc" id="L731">            c.forEach(consumer);</span>
<span class="fc" id="L732">        }</span>

        //

        @Override
        public String toString() {
<span class="fc" id="L738">            return String.format(&quot;CollectionNode[%d][%s]&quot;, c.size(), c);</span>
        }
    }

    /**
     * Node class for an internal node with two or more children
     */
    private static abstract class AbstractConcNode&lt;T, T_NODE extends Node&lt;T&gt;&gt; implements Node&lt;T&gt; {
        protected final T_NODE left;
        protected final T_NODE right;
        private final long size;

<span class="fc" id="L750">        AbstractConcNode(T_NODE left, T_NODE right) {</span>
<span class="fc" id="L751">            this.left = left;</span>
<span class="fc" id="L752">            this.right = right;</span>
            // The Node count will be required when the Node spliterator is
            // obtained and it is cheaper to aggressively calculate bottom up
            // as the tree is built rather than later on from the top down
            // traversing the tree
<span class="fc" id="L757">            this.size = left.count() + right.count();</span>
<span class="fc" id="L758">        }</span>

        @Override
        public int getChildCount() {
<span class="fc" id="L762">            return 2;</span>
        }

        @Override
        public T_NODE getChild(int i) {
<span class="fc bfc" id="L767" title="All 2 branches covered.">            if (i == 0) return left;</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">            if (i == 1) return right;</span>
<span class="nc" id="L769">            throw new IndexOutOfBoundsException();</span>
        }

        @Override
        public long count() {
<span class="fc" id="L774">            return size;</span>
        }
    }

    static final class ConcNode&lt;T&gt;
            extends AbstractConcNode&lt;T, Node&lt;T&gt;&gt;
            implements Node&lt;T&gt; {

        ConcNode(Node&lt;T&gt; left, Node&lt;T&gt; right) {
<span class="fc" id="L783">            super(left, right);</span>
<span class="fc" id="L784">        }</span>

        @Override
        public Spliterator&lt;T&gt; spliterator() {
<span class="fc" id="L788">            return new Nodes.InternalNodeSpliterator.OfRef&lt;&gt;(this);</span>
        }

        @Override
        public void copyInto(T[] array, int offset) {
<span class="fc" id="L793">            Objects.requireNonNull(array);</span>
<span class="fc" id="L794">            left.copyInto(array, offset);</span>
            // Cast to int is safe since it is the callers responsibility to
            // ensure that there is sufficient room in the array
<span class="fc" id="L797">            right.copyInto(array, offset + (int) left.count());</span>
<span class="fc" id="L798">        }</span>

        @Override
        public T[] asArray(IntFunction&lt;T[]&gt; generator) {
<span class="fc" id="L802">            long size = count();</span>
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L804">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="fc" id="L805">            T[] array = generator.apply((int) size);</span>
<span class="fc" id="L806">            copyInto(array, 0);</span>
<span class="fc" id="L807">            return array;</span>
        }

        @Override
        public void forEach(Consumer&lt;? super T&gt; consumer) {
<span class="fc" id="L812">            left.forEach(consumer);</span>
<span class="fc" id="L813">            right.forEach(consumer);</span>
<span class="fc" id="L814">        }</span>

        @Override
        public Node&lt;T&gt; truncate(long from, long to, IntFunction&lt;T[]&gt; generator) {
<span class="pc bpc" id="L818" title="2 of 4 branches missed.">            if (from == 0 &amp;&amp; to == count())</span>
<span class="nc" id="L819">                return this;</span>
<span class="nc" id="L820">            long leftCount = left.count();</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">            if (from &gt;= leftCount)</span>
<span class="nc" id="L822">                return right.truncate(from - leftCount, to - leftCount, generator);</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">            else if (to &lt;= leftCount)</span>
<span class="nc" id="L824">                return left.truncate(from, to, generator);</span>
            else {
<span class="nc" id="L826">                return Nodes.conc(getShape(), left.truncate(from, leftCount, generator),</span>
<span class="nc" id="L827">                                  right.truncate(0, to - leftCount, generator));</span>
            }
        }

        @Override
        public String toString() {
<span class="fc bfc" id="L833" title="All 2 branches covered.">            if (count() &lt; 32) {</span>
<span class="fc" id="L834">                return String.format(&quot;ConcNode[%s.%s]&quot;, left, right);</span>
            } else {
<span class="fc" id="L836">                return String.format(&quot;ConcNode[size=%d]&quot;, count());</span>
            }
        }

        private abstract static class OfPrimitive&lt;E, T_CONS, T_ARR,
                                                  T_SPLITR extends Spliterator.OfPrimitive&lt;E, T_CONS, T_SPLITR&gt;,
                                                  T_NODE extends Node.OfPrimitive&lt;E, T_CONS, T_ARR, T_SPLITR, T_NODE&gt;&gt;
                extends AbstractConcNode&lt;E, T_NODE&gt;
                implements Node.OfPrimitive&lt;E, T_CONS, T_ARR, T_SPLITR, T_NODE&gt; {

            OfPrimitive(T_NODE left, T_NODE right) {
<span class="fc" id="L847">                super(left, right);</span>
<span class="fc" id="L848">            }</span>

            @Override
            public void forEach(T_CONS consumer) {
<span class="fc" id="L852">                left.forEach(consumer);</span>
<span class="fc" id="L853">                right.forEach(consumer);</span>
<span class="fc" id="L854">            }</span>

            @Override
            public void copyInto(T_ARR array, int offset) {
<span class="fc" id="L858">                left.copyInto(array, offset);</span>
                // Cast to int is safe since it is the callers responsibility to
                // ensure that there is sufficient room in the array
<span class="fc" id="L861">                right.copyInto(array, offset + (int) left.count());</span>
<span class="fc" id="L862">            }</span>

            @Override
            public T_ARR asPrimitiveArray() {
<span class="nc" id="L866">                long size = count();</span>
<span class="nc bnc" id="L867" title="All 2 branches missed.">                if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L868">                    throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="nc" id="L869">                T_ARR array = newArray((int) size);</span>
<span class="nc" id="L870">                copyInto(array, 0);</span>
<span class="nc" id="L871">                return array;</span>
            }

            @Override
            public String toString() {
<span class="fc bfc" id="L876" title="All 2 branches covered.">                if (count() &lt; 32)</span>
<span class="fc" id="L877">                    return String.format(&quot;%s[%s.%s]&quot;, this.getClass().getName(), left, right);</span>
                else
<span class="fc" id="L879">                    return String.format(&quot;%s[size=%d]&quot;, this.getClass().getName(), count());</span>
            }
        }

        static final class OfInt
                extends ConcNode.OfPrimitive&lt;Integer, IntConsumer, int[], Spliterator.OfInt, Node.OfInt&gt;
                implements Node.OfInt {

            OfInt(Node.OfInt left, Node.OfInt right) {
<span class="fc" id="L888">                super(left, right);</span>
<span class="fc" id="L889">            }</span>

            @Override
            public Spliterator.OfInt spliterator() {
<span class="fc" id="L893">                return new InternalNodeSpliterator.OfInt(this);</span>
            }
        }

        static final class OfLong
                extends ConcNode.OfPrimitive&lt;Long, LongConsumer, long[], Spliterator.OfLong, Node.OfLong&gt;
                implements Node.OfLong {

            OfLong(Node.OfLong left, Node.OfLong right) {
<span class="fc" id="L902">                super(left, right);</span>
<span class="fc" id="L903">            }</span>

            @Override
            public Spliterator.OfLong spliterator() {
<span class="fc" id="L907">                return new InternalNodeSpliterator.OfLong(this);</span>
            }
        }

        static final class OfDouble
                extends ConcNode.OfPrimitive&lt;Double, DoubleConsumer, double[], Spliterator.OfDouble, Node.OfDouble&gt;
                implements Node.OfDouble {

            OfDouble(Node.OfDouble left, Node.OfDouble right) {
<span class="fc" id="L916">                super(left, right);</span>
<span class="fc" id="L917">            }</span>

            @Override
            public Spliterator.OfDouble spliterator() {
<span class="fc" id="L921">                return new InternalNodeSpliterator.OfDouble(this);</span>
            }
        }
    }

    /** Abstract class for spliterator for all internal node classes */
    private static abstract class InternalNodeSpliterator&lt;T,
                                                          S extends Spliterator&lt;T&gt;,
                                                          N extends Node&lt;T&gt;&gt;
            implements Spliterator&lt;T&gt; {
        // Node we are pointing to
        // null if full traversal has occurred
        N curNode;

        // next child of curNode to consume
        int curChildIndex;

        // The spliterator of the curNode if that node is last and has no children.
        // This spliterator will be delegated to for splitting and traversing.
        // null if curNode has children
        S lastNodeSpliterator;

        // spliterator used while traversing with tryAdvance
        // null if no partial traversal has occurred
        S tryAdvanceSpliterator;

        // node stack used when traversing to search and find leaf nodes
        // null if no partial traversal has occurred
        Deque&lt;N&gt; tryAdvanceStack;

<span class="fc" id="L951">        InternalNodeSpliterator(N curNode) {</span>
<span class="fc" id="L952">            this.curNode = curNode;</span>
<span class="fc" id="L953">        }</span>

        /**
         * Initiate a stack containing, in left-to-right order, the child nodes
         * covered by this spliterator
         */
        protected final Deque&lt;N&gt; initStack() {
            // Bias size to the case where leaf nodes are close to this node
            // 8 is the minimum initial capacity for the ArrayDeque implementation
<span class="fc" id="L962">            Deque&lt;N&gt; stack = new ArrayDeque&lt;&gt;(8);</span>
<span class="fc bfc" id="L963" title="All 2 branches covered.">            for (int i = curNode.getChildCount() - 1; i &gt;= curChildIndex; i--)</span>
<span class="fc" id="L964">                stack.addFirst((N) curNode.getChild(i));</span>
<span class="fc" id="L965">            return stack;</span>
        }

        /**
         * Depth first search, in left-to-right order, of the node tree, using
         * an explicit stack, to find the next non-empty leaf node.
         */
        protected final N findNextLeafNode(Deque&lt;N&gt; stack) {
<span class="fc" id="L973">            N n = null;</span>
<span class="fc bfc" id="L974" title="All 2 branches covered.">            while ((n = stack.pollFirst()) != null) {</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">                if (n.getChildCount() == 0) {</span>
<span class="pc bpc" id="L976" title="1 of 2 branches missed.">                    if (n.count() &gt; 0)</span>
<span class="fc" id="L977">                        return n;</span>
                } else {
<span class="fc bfc" id="L979" title="All 2 branches covered.">                    for (int i = n.getChildCount() - 1; i &gt;= 0; i--)</span>
<span class="fc" id="L980">                        stack.addFirst((N) n.getChild(i));</span>
                }
            }

<span class="fc" id="L984">            return null;</span>
        }

        protected final boolean initTryAdvance() {
<span class="pc bpc" id="L988" title="1 of 2 branches missed.">            if (curNode == null)</span>
<span class="nc" id="L989">                return false;</span>

<span class="pc bpc" id="L991" title="1 of 2 branches missed.">            if (tryAdvanceSpliterator == null) {</span>
<span class="pc bpc" id="L992" title="1 of 2 branches missed.">                if (lastNodeSpliterator == null) {</span>
                    // Initiate the node stack
<span class="fc" id="L994">                    tryAdvanceStack = initStack();</span>
<span class="fc" id="L995">                    N leaf = findNextLeafNode(tryAdvanceStack);</span>
<span class="pc bpc" id="L996" title="1 of 2 branches missed.">                    if (leaf != null)</span>
<span class="fc" id="L997">                        tryAdvanceSpliterator = (S) leaf.spliterator();</span>
                    else {
                        // A non-empty leaf node was not found
                        // No elements to traverse
<span class="nc" id="L1001">                        curNode = null;</span>
<span class="nc" id="L1002">                        return false;</span>
                    }
<span class="fc" id="L1004">                }</span>
                else
<span class="nc" id="L1006">                    tryAdvanceSpliterator = lastNodeSpliterator;</span>
            }
<span class="fc" id="L1008">            return true;</span>
        }

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public final S trySplit() {
<span class="nc bnc" id="L1014" title="All 4 branches missed.">            if (curNode == null || tryAdvanceSpliterator != null)</span>
<span class="nc" id="L1015">                return null; // Cannot split if fully or partially traversed</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">            else if (lastNodeSpliterator != null)</span>
<span class="nc" id="L1017">                return (S) lastNodeSpliterator.trySplit();</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            else if (curChildIndex &lt; curNode.getChildCount() - 1)</span>
<span class="nc" id="L1019">                return (S) curNode.getChild(curChildIndex++).spliterator();</span>
            else {
<span class="nc" id="L1021">                curNode = (N) curNode.getChild(curChildIndex);</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">                if (curNode.getChildCount() == 0) {</span>
<span class="nc" id="L1023">                    lastNodeSpliterator = (S) curNode.spliterator();</span>
<span class="nc" id="L1024">                    return (S) lastNodeSpliterator.trySplit();</span>
                }
                else {
<span class="nc" id="L1027">                    curChildIndex = 0;</span>
<span class="nc" id="L1028">                    return (S) curNode.getChild(curChildIndex++).spliterator();</span>
                }
            }
        }

        @Override
        public final long estimateSize() {
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">            if (curNode == null)</span>
<span class="nc" id="L1036">                return 0;</span>

            // Will not reflect the effects of partial traversal.
            // This is compliant with the specification
<span class="pc bpc" id="L1040" title="1 of 2 branches missed.">            if (lastNodeSpliterator != null)</span>
<span class="nc" id="L1041">                return lastNodeSpliterator.estimateSize();</span>
            else {
<span class="fc" id="L1043">                long size = 0;</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">                for (int i = curChildIndex; i &lt; curNode.getChildCount(); i++)</span>
<span class="fc" id="L1045">                    size += curNode.getChild(i).count();</span>
<span class="fc" id="L1046">                return size;</span>
            }
        }

        @Override
        public final int characteristics() {
<span class="fc" id="L1052">            return Spliterator.SIZED;</span>
        }

        private static final class OfRef&lt;T&gt;
                extends InternalNodeSpliterator&lt;T, Spliterator&lt;T&gt;, Node&lt;T&gt;&gt; {

            OfRef(Node&lt;T&gt; curNode) {
<span class="fc" id="L1059">                super(curNode);</span>
<span class="fc" id="L1060">            }</span>

            @Override
            public boolean tryAdvance(Consumer&lt;? super T&gt; consumer) {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">                if (!initTryAdvance())</span>
<span class="nc" id="L1065">                    return false;</span>

<span class="nc" id="L1067">                boolean hasNext = tryAdvanceSpliterator.tryAdvance(consumer);</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                if (!hasNext) {</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">                    if (lastNodeSpliterator == null) {</span>
                        // Advance to the spliterator of the next non-empty leaf node
<span class="nc" id="L1071">                        Node&lt;T&gt; leaf = findNextLeafNode(tryAdvanceStack);</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                        if (leaf != null) {</span>
<span class="nc" id="L1073">                            tryAdvanceSpliterator = leaf.spliterator();</span>
                            // Since the node is not-empty the spliterator can be advanced
<span class="nc" id="L1075">                            return tryAdvanceSpliterator.tryAdvance(consumer);</span>
                        }
                    }
                    // No more elements to traverse
<span class="nc" id="L1079">                    curNode = null;</span>
                }
<span class="nc" id="L1081">                return hasNext;</span>
            }

            @Override
            public void forEachRemaining(Consumer&lt;? super T&gt; consumer) {
<span class="pc bpc" id="L1086" title="1 of 2 branches missed.">                if (curNode == null)</span>
<span class="nc" id="L1087">                    return;</span>

<span class="pc bpc" id="L1089" title="1 of 2 branches missed.">                if (tryAdvanceSpliterator == null) {</span>
<span class="pc bpc" id="L1090" title="1 of 2 branches missed.">                    if (lastNodeSpliterator == null) {</span>
<span class="fc" id="L1091">                        Deque&lt;Node&lt;T&gt;&gt; stack = initStack();</span>
                        Node&lt;T&gt; leaf;
<span class="fc bfc" id="L1093" title="All 2 branches covered.">                        while ((leaf = findNextLeafNode(stack)) != null) {</span>
<span class="fc" id="L1094">                            leaf.forEach(consumer);</span>
                        }
<span class="fc" id="L1096">                        curNode = null;</span>
<span class="fc" id="L1097">                    }</span>
                    else
<span class="nc" id="L1099">                        lastNodeSpliterator.forEachRemaining(consumer);</span>
                }
                else
<span class="nc bnc" id="L1102" title="All 2 branches missed.">                    while(tryAdvance(consumer)) { }</span>
<span class="fc" id="L1103">            }</span>
        }

        private static abstract class OfPrimitive&lt;T, T_CONS, T_ARR,
                                                  T_SPLITR extends Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt;,
                                                  N extends Node.OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, N&gt;&gt;
                extends InternalNodeSpliterator&lt;T, T_SPLITR, N&gt;
                implements Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt; {

            OfPrimitive(N cur) {
<span class="fc" id="L1113">                super(cur);</span>
<span class="fc" id="L1114">            }</span>

            @Override
            public boolean tryAdvance(T_CONS consumer) {
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                if (!initTryAdvance())</span>
<span class="nc" id="L1119">                    return false;</span>

<span class="nc" id="L1121">                boolean hasNext = tryAdvanceSpliterator.tryAdvance(consumer);</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">                if (!hasNext) {</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">                    if (lastNodeSpliterator == null) {</span>
                        // Advance to the spliterator of the next non-empty leaf node
<span class="nc" id="L1125">                        N leaf = findNextLeafNode(tryAdvanceStack);</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">                        if (leaf != null) {</span>
<span class="nc" id="L1127">                            tryAdvanceSpliterator = leaf.spliterator();</span>
                            // Since the node is not-empty the spliterator can be advanced
<span class="nc" id="L1129">                            return tryAdvanceSpliterator.tryAdvance(consumer);</span>
                        }
                    }
                    // No more elements to traverse
<span class="nc" id="L1133">                    curNode = null;</span>
                }
<span class="nc" id="L1135">                return hasNext;</span>
            }

            @Override
            public void forEachRemaining(T_CONS consumer) {
<span class="pc bpc" id="L1140" title="1 of 2 branches missed.">                if (curNode == null)</span>
<span class="nc" id="L1141">                    return;</span>

<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">                if (tryAdvanceSpliterator == null) {</span>
<span class="pc bpc" id="L1144" title="1 of 2 branches missed.">                    if (lastNodeSpliterator == null) {</span>
<span class="fc" id="L1145">                        Deque&lt;N&gt; stack = initStack();</span>
                        N leaf;
<span class="fc bfc" id="L1147" title="All 2 branches covered.">                        while ((leaf = findNextLeafNode(stack)) != null) {</span>
<span class="fc" id="L1148">                            leaf.forEach(consumer);</span>
                        }
<span class="fc" id="L1150">                        curNode = null;</span>
<span class="fc" id="L1151">                    }</span>
                    else
<span class="nc" id="L1153">                        lastNodeSpliterator.forEachRemaining(consumer);</span>
                }
                else
<span class="nc bnc" id="L1156" title="All 2 branches missed.">                    while(tryAdvance(consumer)) { }</span>
<span class="fc" id="L1157">            }</span>
        }

        private static final class OfInt
                extends OfPrimitive&lt;Integer, IntConsumer, int[], Spliterator.OfInt, Node.OfInt&gt;
                implements Spliterator.OfInt {

            OfInt(Node.OfInt cur) {
<span class="fc" id="L1165">                super(cur);</span>
<span class="fc" id="L1166">            }</span>
        }

        private static final class OfLong
                extends OfPrimitive&lt;Long, LongConsumer, long[], Spliterator.OfLong, Node.OfLong&gt;
                implements Spliterator.OfLong {

            OfLong(Node.OfLong cur) {
<span class="fc" id="L1174">                super(cur);</span>
<span class="fc" id="L1175">            }</span>
        }

        private static final class OfDouble
                extends OfPrimitive&lt;Double, DoubleConsumer, double[], Spliterator.OfDouble, Node.OfDouble&gt;
                implements Spliterator.OfDouble {

            OfDouble(Node.OfDouble cur) {
<span class="fc" id="L1183">                super(cur);</span>
<span class="fc" id="L1184">            }</span>
        }
    }

    /**
     * Fixed-sized builder class for reference nodes
     */
<span class="pc bpc" id="L1191" title="1 of 2 branches missed.">    private static final class FixedNodeBuilder&lt;T&gt;</span>
            extends ArrayNode&lt;T&gt;
            implements Node.Builder&lt;T&gt; {

        FixedNodeBuilder(long size, IntFunction&lt;T[]&gt; generator) {
<span class="fc" id="L1196">            super(size, generator);</span>
<span class="pc bpc" id="L1197" title="2 of 4 branches missed.">            assert size &lt; MAX_ARRAY_SIZE;</span>
<span class="fc" id="L1198">        }</span>

        @Override
        public Node&lt;T&gt; build() {
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">            if (curSize &lt; array.length)</span>
<span class="nc" id="L1203">                throw new IllegalStateException(String.format(&quot;Current size %d is less than fixed size %d&quot;,</span>
<span class="nc" id="L1204">                                                              curSize, array.length));</span>
<span class="fc" id="L1205">            return this;</span>
        }

        @Override
        public void begin(long size) {
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">            if (size != array.length)</span>
<span class="nc" id="L1211">                throw new IllegalStateException(String.format(&quot;Begin size %d is not equal to fixed size %d&quot;,</span>
<span class="nc" id="L1212">                                                              size, array.length));</span>
<span class="fc" id="L1213">            curSize = 0;</span>
<span class="fc" id="L1214">        }</span>

        @Override
        public void accept(T t) {
<span class="pc bpc" id="L1218" title="1 of 2 branches missed.">            if (curSize &lt; array.length) {</span>
<span class="fc" id="L1219">                array[curSize++] = t;</span>
            } else {
<span class="nc" id="L1221">                throw new IllegalStateException(String.format(&quot;Accept exceeded fixed size of %d&quot;,</span>
<span class="nc" id="L1222">                                                              array.length));</span>
            }
<span class="fc" id="L1224">        }</span>

        @Override
        public void end() {
<span class="pc bpc" id="L1228" title="1 of 2 branches missed.">            if (curSize &lt; array.length)</span>
<span class="nc" id="L1229">                throw new IllegalStateException(String.format(&quot;End size %d is less than fixed size %d&quot;,</span>
<span class="nc" id="L1230">                                                              curSize, array.length));</span>
<span class="fc" id="L1231">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L1235">            return String.format(&quot;FixedNodeBuilder[%d][%s]&quot;,</span>
<span class="fc" id="L1236">                                 array.length - curSize, Arrays.toString(array));</span>
        }
    }

    /**
     * Variable-sized builder class for reference nodes
     */
<span class="pc bpc" id="L1243" title="1 of 2 branches missed.">    private static final class SpinedNodeBuilder&lt;T&gt;</span>
            extends SpinedBuffer&lt;T&gt;
            implements Node&lt;T&gt;, Node.Builder&lt;T&gt; {
<span class="fc" id="L1246">        private boolean building = false;</span>

<span class="fc" id="L1248">        SpinedNodeBuilder() {} // Avoid creation of special accessor</span>

        @Override
        public Spliterator&lt;T&gt; spliterator() {
<span class="pc bpc" id="L1252" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1253">            return super.spliterator();</span>
        }

        @Override
        public void forEach(Consumer&lt;? super T&gt; consumer) {
<span class="pc bpc" id="L1258" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1259">            super.forEach(consumer);</span>
<span class="fc" id="L1260">        }</span>

        //
        @Override
        public void begin(long size) {
<span class="pc bpc" id="L1265" title="2 of 4 branches missed.">            assert !building : &quot;was already building&quot;;</span>
<span class="fc" id="L1266">            building = true;</span>
<span class="fc" id="L1267">            clear();</span>
<span class="fc" id="L1268">            ensureCapacity(size);</span>
<span class="fc" id="L1269">        }</span>

        @Override
        public void accept(T t) {
<span class="pc bpc" id="L1273" title="2 of 4 branches missed.">            assert building : &quot;not building&quot;;</span>
<span class="fc" id="L1274">            super.accept(t);</span>
<span class="fc" id="L1275">        }</span>

        @Override
        public void end() {
<span class="pc bpc" id="L1279" title="2 of 4 branches missed.">            assert building : &quot;was not building&quot;;</span>
<span class="fc" id="L1280">            building = false;</span>
            // @@@ check begin(size) and size
<span class="fc" id="L1282">        }</span>

        @Override
        public void copyInto(T[] array, int offset) {
<span class="pc bpc" id="L1286" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1287">            super.copyInto(array, offset);</span>
<span class="fc" id="L1288">        }</span>

        @Override
        public T[] asArray(IntFunction&lt;T[]&gt; arrayFactory) {
<span class="pc bpc" id="L1292" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1293">            return super.asArray(arrayFactory);</span>
        }

        @Override
        public Node&lt;T&gt; build() {
<span class="pc bpc" id="L1298" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1299">            return this;</span>
        }
    }

    //

<span class="fc" id="L1305">    private static final int[] EMPTY_INT_ARRAY = new int[0];</span>
<span class="fc" id="L1306">    private static final long[] EMPTY_LONG_ARRAY = new long[0];</span>
<span class="fc" id="L1307">    private static final double[] EMPTY_DOUBLE_ARRAY = new double[0];</span>

    private static class IntArrayNode implements Node.OfInt {
        final int[] array;
        int curSize;

<span class="fc" id="L1313">        IntArrayNode(long size) {</span>
<span class="pc bpc" id="L1314" title="1 of 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L1315">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="fc" id="L1316">            this.array = new int[(int) size];</span>
<span class="fc" id="L1317">            this.curSize = 0;</span>
<span class="fc" id="L1318">        }</span>

<span class="fc" id="L1320">        IntArrayNode(int[] array) {</span>
<span class="fc" id="L1321">            this.array = array;</span>
<span class="fc" id="L1322">            this.curSize = array.length;</span>
<span class="fc" id="L1323">        }</span>

        // Node

        @Override
        public Spliterator.OfInt spliterator() {
<span class="fc" id="L1329">            return Arrays.spliterator(array, 0, curSize);</span>
        }

        @Override
        public int[] asPrimitiveArray() {
<span class="pc bpc" id="L1334" title="1 of 2 branches missed.">            if (array.length == curSize) {</span>
<span class="fc" id="L1335">                return array;</span>
            } else {
<span class="nc" id="L1337">                return Arrays.copyOf(array, curSize);</span>
            }
        }

        @Override
        public void copyInto(int[] dest, int destOffset) {
<span class="fc" id="L1343">            System.arraycopy(array, 0, dest, destOffset, curSize);</span>
<span class="fc" id="L1344">        }</span>

        @Override
        public long count() {
<span class="fc" id="L1348">            return curSize;</span>
        }

        @Override
        public void forEach(IntConsumer consumer) {
<span class="fc bfc" id="L1353" title="All 2 branches covered.">            for (int i = 0; i &lt; curSize; i++) {</span>
<span class="fc" id="L1354">                consumer.accept(array[i]);</span>
            }
<span class="fc" id="L1356">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L1360">            return String.format(&quot;IntArrayNode[%d][%s]&quot;,</span>
<span class="fc" id="L1361">                                 array.length - curSize, Arrays.toString(array));</span>
        }
    }

    private static class LongArrayNode implements Node.OfLong {
        final long[] array;
        int curSize;

<span class="fc" id="L1369">        LongArrayNode(long size) {</span>
<span class="pc bpc" id="L1370" title="1 of 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L1371">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="fc" id="L1372">            this.array = new long[(int) size];</span>
<span class="fc" id="L1373">            this.curSize = 0;</span>
<span class="fc" id="L1374">        }</span>

<span class="fc" id="L1376">        LongArrayNode(long[] array) {</span>
<span class="fc" id="L1377">            this.array = array;</span>
<span class="fc" id="L1378">            this.curSize = array.length;</span>
<span class="fc" id="L1379">        }</span>

        @Override
        public Spliterator.OfLong spliterator() {
<span class="fc" id="L1383">            return Arrays.spliterator(array, 0, curSize);</span>
        }

        @Override
        public long[] asPrimitiveArray() {
<span class="pc bpc" id="L1388" title="1 of 2 branches missed.">            if (array.length == curSize) {</span>
<span class="fc" id="L1389">                return array;</span>
            } else {
<span class="nc" id="L1391">                return Arrays.copyOf(array, curSize);</span>
            }
        }

        @Override
        public void copyInto(long[] dest, int destOffset) {
<span class="fc" id="L1397">            System.arraycopy(array, 0, dest, destOffset, curSize);</span>
<span class="fc" id="L1398">        }</span>

        @Override
        public long count() {
<span class="fc" id="L1402">            return curSize;</span>
        }

        @Override
        public void forEach(LongConsumer consumer) {
<span class="fc bfc" id="L1407" title="All 2 branches covered.">            for (int i = 0; i &lt; curSize; i++) {</span>
<span class="fc" id="L1408">                consumer.accept(array[i]);</span>
            }
<span class="fc" id="L1410">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L1414">            return String.format(&quot;LongArrayNode[%d][%s]&quot;,</span>
<span class="fc" id="L1415">                                 array.length - curSize, Arrays.toString(array));</span>
        }
    }

    private static class DoubleArrayNode implements Node.OfDouble {
        final double[] array;
        int curSize;

<span class="fc" id="L1423">        DoubleArrayNode(long size) {</span>
<span class="pc bpc" id="L1424" title="1 of 2 branches missed.">            if (size &gt;= MAX_ARRAY_SIZE)</span>
<span class="nc" id="L1425">                throw new IllegalArgumentException(BAD_SIZE);</span>
<span class="fc" id="L1426">            this.array = new double[(int) size];</span>
<span class="fc" id="L1427">            this.curSize = 0;</span>
<span class="fc" id="L1428">        }</span>

<span class="fc" id="L1430">        DoubleArrayNode(double[] array) {</span>
<span class="fc" id="L1431">            this.array = array;</span>
<span class="fc" id="L1432">            this.curSize = array.length;</span>
<span class="fc" id="L1433">        }</span>

        @Override
        public Spliterator.OfDouble spliterator() {
<span class="fc" id="L1437">            return Arrays.spliterator(array, 0, curSize);</span>
        }

        @Override
        public double[] asPrimitiveArray() {
<span class="pc bpc" id="L1442" title="1 of 2 branches missed.">            if (array.length == curSize) {</span>
<span class="fc" id="L1443">                return array;</span>
            } else {
<span class="nc" id="L1445">                return Arrays.copyOf(array, curSize);</span>
            }
        }

        @Override
        public void copyInto(double[] dest, int destOffset) {
<span class="fc" id="L1451">            System.arraycopy(array, 0, dest, destOffset, curSize);</span>
<span class="fc" id="L1452">        }</span>

        @Override
        public long count() {
<span class="fc" id="L1456">            return curSize;</span>
        }

        @Override
        public void forEach(DoubleConsumer consumer) {
<span class="fc bfc" id="L1461" title="All 2 branches covered.">            for (int i = 0; i &lt; curSize; i++) {</span>
<span class="fc" id="L1462">                consumer.accept(array[i]);</span>
            }
<span class="fc" id="L1464">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L1468">            return String.format(&quot;DoubleArrayNode[%d][%s]&quot;,</span>
<span class="fc" id="L1469">                                 array.length - curSize, Arrays.toString(array));</span>
        }
    }

<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">    private static final class IntFixedNodeBuilder</span>
            extends IntArrayNode
            implements Node.Builder.OfInt {

        IntFixedNodeBuilder(long size) {
<span class="fc" id="L1478">            super(size);</span>
<span class="pc bpc" id="L1479" title="2 of 4 branches missed.">            assert size &lt; MAX_ARRAY_SIZE;</span>
<span class="fc" id="L1480">        }</span>

        @Override
        public Node.OfInt build() {
<span class="pc bpc" id="L1484" title="1 of 2 branches missed.">            if (curSize &lt; array.length) {</span>
<span class="nc" id="L1485">                throw new IllegalStateException(String.format(&quot;Current size %d is less than fixed size %d&quot;,</span>
<span class="nc" id="L1486">                                                              curSize, array.length));</span>
            }

<span class="fc" id="L1489">            return this;</span>
        }

        @Override
        public void begin(long size) {
<span class="pc bpc" id="L1494" title="1 of 2 branches missed.">            if (size != array.length) {</span>
<span class="nc" id="L1495">                throw new IllegalStateException(String.format(&quot;Begin size %d is not equal to fixed size %d&quot;,</span>
<span class="nc" id="L1496">                                                              size, array.length));</span>
            }

<span class="fc" id="L1499">            curSize = 0;</span>
<span class="fc" id="L1500">        }</span>

        @Override
        public void accept(int i) {
<span class="pc bpc" id="L1504" title="1 of 2 branches missed.">            if (curSize &lt; array.length) {</span>
<span class="fc" id="L1505">                array[curSize++] = i;</span>
            } else {
<span class="nc" id="L1507">                throw new IllegalStateException(String.format(&quot;Accept exceeded fixed size of %d&quot;,</span>
<span class="nc" id="L1508">                                                              array.length));</span>
            }
<span class="fc" id="L1510">        }</span>

        @Override
        public void end() {
<span class="pc bpc" id="L1514" title="1 of 2 branches missed.">            if (curSize &lt; array.length) {</span>
<span class="nc" id="L1515">                throw new IllegalStateException(String.format(&quot;End size %d is less than fixed size %d&quot;,</span>
<span class="nc" id="L1516">                                                              curSize, array.length));</span>
            }
<span class="fc" id="L1518">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L1522">            return String.format(&quot;IntFixedNodeBuilder[%d][%s]&quot;,</span>
<span class="fc" id="L1523">                                 array.length - curSize, Arrays.toString(array));</span>
        }
    }

<span class="pc bpc" id="L1527" title="1 of 2 branches missed.">    private static final class LongFixedNodeBuilder</span>
            extends LongArrayNode
            implements Node.Builder.OfLong {

        LongFixedNodeBuilder(long size) {
<span class="fc" id="L1532">            super(size);</span>
<span class="pc bpc" id="L1533" title="2 of 4 branches missed.">            assert size &lt; MAX_ARRAY_SIZE;</span>
<span class="fc" id="L1534">        }</span>

        @Override
        public Node.OfLong build() {
<span class="pc bpc" id="L1538" title="1 of 2 branches missed.">            if (curSize &lt; array.length) {</span>
<span class="nc" id="L1539">                throw new IllegalStateException(String.format(&quot;Current size %d is less than fixed size %d&quot;,</span>
<span class="nc" id="L1540">                                                              curSize, array.length));</span>
            }

<span class="fc" id="L1543">            return this;</span>
        }

        @Override
        public void begin(long size) {
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">            if (size != array.length) {</span>
<span class="nc" id="L1549">                throw new IllegalStateException(String.format(&quot;Begin size %d is not equal to fixed size %d&quot;,</span>
<span class="nc" id="L1550">                                                              size, array.length));</span>
            }

<span class="fc" id="L1553">            curSize = 0;</span>
<span class="fc" id="L1554">        }</span>

        @Override
        public void accept(long i) {
<span class="pc bpc" id="L1558" title="1 of 2 branches missed.">            if (curSize &lt; array.length) {</span>
<span class="fc" id="L1559">                array[curSize++] = i;</span>
            } else {
<span class="nc" id="L1561">                throw new IllegalStateException(String.format(&quot;Accept exceeded fixed size of %d&quot;,</span>
<span class="nc" id="L1562">                                                              array.length));</span>
            }
<span class="fc" id="L1564">        }</span>

        @Override
        public void end() {
<span class="pc bpc" id="L1568" title="1 of 2 branches missed.">            if (curSize &lt; array.length) {</span>
<span class="nc" id="L1569">                throw new IllegalStateException(String.format(&quot;End size %d is less than fixed size %d&quot;,</span>
<span class="nc" id="L1570">                                                              curSize, array.length));</span>
            }
<span class="fc" id="L1572">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L1576">            return String.format(&quot;LongFixedNodeBuilder[%d][%s]&quot;,</span>
<span class="fc" id="L1577">                                 array.length - curSize, Arrays.toString(array));</span>
        }
    }

<span class="pc bpc" id="L1581" title="1 of 2 branches missed.">    private static final class DoubleFixedNodeBuilder</span>
            extends DoubleArrayNode
            implements Node.Builder.OfDouble {

        DoubleFixedNodeBuilder(long size) {
<span class="fc" id="L1586">            super(size);</span>
<span class="pc bpc" id="L1587" title="2 of 4 branches missed.">            assert size &lt; MAX_ARRAY_SIZE;</span>
<span class="fc" id="L1588">        }</span>

        @Override
        public Node.OfDouble build() {
<span class="pc bpc" id="L1592" title="1 of 2 branches missed.">            if (curSize &lt; array.length) {</span>
<span class="nc" id="L1593">                throw new IllegalStateException(String.format(&quot;Current size %d is less than fixed size %d&quot;,</span>
<span class="nc" id="L1594">                                                              curSize, array.length));</span>
            }

<span class="fc" id="L1597">            return this;</span>
        }

        @Override
        public void begin(long size) {
<span class="pc bpc" id="L1602" title="1 of 2 branches missed.">            if (size != array.length) {</span>
<span class="nc" id="L1603">                throw new IllegalStateException(String.format(&quot;Begin size %d is not equal to fixed size %d&quot;,</span>
<span class="nc" id="L1604">                                                              size, array.length));</span>
            }

<span class="fc" id="L1607">            curSize = 0;</span>
<span class="fc" id="L1608">        }</span>

        @Override
        public void accept(double i) {
<span class="pc bpc" id="L1612" title="1 of 2 branches missed.">            if (curSize &lt; array.length) {</span>
<span class="fc" id="L1613">                array[curSize++] = i;</span>
            } else {
<span class="nc" id="L1615">                throw new IllegalStateException(String.format(&quot;Accept exceeded fixed size of %d&quot;,</span>
<span class="nc" id="L1616">                                                              array.length));</span>
            }
<span class="fc" id="L1618">        }</span>

        @Override
        public void end() {
<span class="pc bpc" id="L1622" title="1 of 2 branches missed.">            if (curSize &lt; array.length) {</span>
<span class="nc" id="L1623">                throw new IllegalStateException(String.format(&quot;End size %d is less than fixed size %d&quot;,</span>
<span class="nc" id="L1624">                                                              curSize, array.length));</span>
            }
<span class="fc" id="L1626">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L1630">            return String.format(&quot;DoubleFixedNodeBuilder[%d][%s]&quot;,</span>
<span class="fc" id="L1631">                                 array.length - curSize, Arrays.toString(array));</span>
        }
    }

<span class="pc bpc" id="L1635" title="1 of 2 branches missed.">    private static final class IntSpinedNodeBuilder</span>
            extends SpinedBuffer.OfInt
            implements Node.OfInt, Node.Builder.OfInt {
<span class="fc" id="L1638">        private boolean building = false;</span>

<span class="fc" id="L1640">        IntSpinedNodeBuilder() {} // Avoid creation of special accessor</span>

        @Override
        public Spliterator.OfInt spliterator() {
<span class="pc bpc" id="L1644" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1645">            return super.spliterator();</span>
        }

        @Override
        public void forEach(IntConsumer consumer) {
<span class="pc bpc" id="L1650" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1651">            super.forEach(consumer);</span>
<span class="fc" id="L1652">        }</span>

        //
        @Override
        public void begin(long size) {
<span class="pc bpc" id="L1657" title="2 of 4 branches missed.">            assert !building : &quot;was already building&quot;;</span>
<span class="fc" id="L1658">            building = true;</span>
<span class="fc" id="L1659">            clear();</span>
<span class="fc" id="L1660">            ensureCapacity(size);</span>
<span class="fc" id="L1661">        }</span>

        @Override
        public void accept(int i) {
<span class="pc bpc" id="L1665" title="2 of 4 branches missed.">            assert building : &quot;not building&quot;;</span>
<span class="fc" id="L1666">            super.accept(i);</span>
<span class="fc" id="L1667">        }</span>

        @Override
        public void end() {
<span class="pc bpc" id="L1671" title="2 of 4 branches missed.">            assert building : &quot;was not building&quot;;</span>
<span class="fc" id="L1672">            building = false;</span>
            // @@@ check begin(size) and size
<span class="fc" id="L1674">        }</span>

        @Override
        public void copyInto(int[] array, int offset) throws IndexOutOfBoundsException {
<span class="pc bpc" id="L1678" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1679">            super.copyInto(array, offset);</span>
<span class="fc" id="L1680">        }</span>

        @Override
        public int[] asPrimitiveArray() {
<span class="pc bpc" id="L1684" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1685">            return super.asPrimitiveArray();</span>
        }

        @Override
        public Node.OfInt build() {
<span class="pc bpc" id="L1690" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1691">            return this;</span>
        }
    }

<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">    private static final class LongSpinedNodeBuilder</span>
            extends SpinedBuffer.OfLong
            implements Node.OfLong, Node.Builder.OfLong {
<span class="fc" id="L1698">        private boolean building = false;</span>

<span class="fc" id="L1700">        LongSpinedNodeBuilder() {} // Avoid creation of special accessor</span>

        @Override
        public Spliterator.OfLong spliterator() {
<span class="pc bpc" id="L1704" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1705">            return super.spliterator();</span>
        }

        @Override
        public void forEach(LongConsumer consumer) {
<span class="pc bpc" id="L1710" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1711">            super.forEach(consumer);</span>
<span class="fc" id="L1712">        }</span>

        //
        @Override
        public void begin(long size) {
<span class="pc bpc" id="L1717" title="2 of 4 branches missed.">            assert !building : &quot;was already building&quot;;</span>
<span class="fc" id="L1718">            building = true;</span>
<span class="fc" id="L1719">            clear();</span>
<span class="fc" id="L1720">            ensureCapacity(size);</span>
<span class="fc" id="L1721">        }</span>

        @Override
        public void accept(long i) {
<span class="pc bpc" id="L1725" title="2 of 4 branches missed.">            assert building : &quot;not building&quot;;</span>
<span class="fc" id="L1726">            super.accept(i);</span>
<span class="fc" id="L1727">        }</span>

        @Override
        public void end() {
<span class="pc bpc" id="L1731" title="2 of 4 branches missed.">            assert building : &quot;was not building&quot;;</span>
<span class="fc" id="L1732">            building = false;</span>
            // @@@ check begin(size) and size
<span class="fc" id="L1734">        }</span>

        @Override
        public void copyInto(long[] array, int offset) {
<span class="pc bpc" id="L1738" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1739">            super.copyInto(array, offset);</span>
<span class="fc" id="L1740">        }</span>

        @Override
        public long[] asPrimitiveArray() {
<span class="pc bpc" id="L1744" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1745">            return super.asPrimitiveArray();</span>
        }

        @Override
        public Node.OfLong build() {
<span class="pc bpc" id="L1750" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1751">            return this;</span>
        }
    }

<span class="pc bpc" id="L1755" title="1 of 2 branches missed.">    private static final class DoubleSpinedNodeBuilder</span>
            extends SpinedBuffer.OfDouble
            implements Node.OfDouble, Node.Builder.OfDouble {
<span class="fc" id="L1758">        private boolean building = false;</span>

<span class="fc" id="L1760">        DoubleSpinedNodeBuilder() {} // Avoid creation of special accessor</span>

        @Override
        public Spliterator.OfDouble spliterator() {
<span class="pc bpc" id="L1764" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1765">            return super.spliterator();</span>
        }

        @Override
        public void forEach(DoubleConsumer consumer) {
<span class="pc bpc" id="L1770" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1771">            super.forEach(consumer);</span>
<span class="fc" id="L1772">        }</span>

        //
        @Override
        public void begin(long size) {
<span class="pc bpc" id="L1777" title="2 of 4 branches missed.">            assert !building : &quot;was already building&quot;;</span>
<span class="fc" id="L1778">            building = true;</span>
<span class="fc" id="L1779">            clear();</span>
<span class="fc" id="L1780">            ensureCapacity(size);</span>
<span class="fc" id="L1781">        }</span>

        @Override
        public void accept(double i) {
<span class="pc bpc" id="L1785" title="2 of 4 branches missed.">            assert building : &quot;not building&quot;;</span>
<span class="fc" id="L1786">            super.accept(i);</span>
<span class="fc" id="L1787">        }</span>

        @Override
        public void end() {
<span class="pc bpc" id="L1791" title="2 of 4 branches missed.">            assert building : &quot;was not building&quot;;</span>
<span class="fc" id="L1792">            building = false;</span>
            // @@@ check begin(size) and size
<span class="fc" id="L1794">        }</span>

        @Override
        public void copyInto(double[] array, int offset) {
<span class="pc bpc" id="L1798" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1799">            super.copyInto(array, offset);</span>
<span class="fc" id="L1800">        }</span>

        @Override
        public double[] asPrimitiveArray() {
<span class="pc bpc" id="L1804" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1805">            return super.asPrimitiveArray();</span>
        }

        @Override
        public Node.OfDouble build() {
<span class="pc bpc" id="L1810" title="2 of 4 branches missed.">            assert !building : &quot;during building&quot;;</span>
<span class="fc" id="L1811">            return this;</span>
        }
    }

    /*
     * This and subclasses are not intended to be serializable
     */
<span class="nc bnc" id="L1818" title="All 2 branches missed.">    @SuppressWarnings(&quot;serial&quot;)</span>
    private static abstract class SizedCollectorTask&lt;P_IN, P_OUT, T_SINK extends Sink&lt;P_OUT&gt;,
                                                     K extends SizedCollectorTask&lt;P_IN, P_OUT, T_SINK, K&gt;&gt;
            extends CountedCompleter&lt;Void&gt;
            implements Sink&lt;P_OUT&gt; {
        protected final Spliterator&lt;P_IN&gt; spliterator;
        protected final PipelineHelper&lt;P_OUT&gt; helper;
        protected final long targetSize;
        protected long offset;
        protected long length;
        // For Sink implementation
        protected int index, fence;

        SizedCollectorTask(Spliterator&lt;P_IN&gt; spliterator,
                           PipelineHelper&lt;P_OUT&gt; helper,
<span class="nc" id="L1833">                           int arrayLength) {</span>
<span class="nc bnc" id="L1834" title="All 4 branches missed.">            assert spliterator.hasCharacteristics(Spliterator.SUBSIZED);</span>
<span class="nc" id="L1835">            this.spliterator = spliterator;</span>
<span class="nc" id="L1836">            this.helper = helper;</span>
<span class="nc" id="L1837">            this.targetSize = AbstractTask.suggestTargetSize(spliterator.estimateSize());</span>
<span class="nc" id="L1838">            this.offset = 0;</span>
<span class="nc" id="L1839">            this.length = arrayLength;</span>
<span class="nc" id="L1840">        }</span>

        SizedCollectorTask(K parent, Spliterator&lt;P_IN&gt; spliterator,
                           long offset, long length, int arrayLength) {
<span class="nc" id="L1844">            super(parent);</span>
<span class="nc bnc" id="L1845" title="All 4 branches missed.">            assert spliterator.hasCharacteristics(Spliterator.SUBSIZED);</span>
<span class="nc" id="L1846">            this.spliterator = spliterator;</span>
<span class="nc" id="L1847">            this.helper = parent.helper;</span>
<span class="nc" id="L1848">            this.targetSize = parent.targetSize;</span>
<span class="nc" id="L1849">            this.offset = offset;</span>
<span class="nc" id="L1850">            this.length = length;</span>

<span class="nc bnc" id="L1852" title="All 6 branches missed.">            if (offset &lt; 0 || length &lt; 0 || (offset + length - 1 &gt;= arrayLength)) {</span>
<span class="nc" id="L1853">                throw new IllegalArgumentException(</span>
<span class="nc" id="L1854">                        String.format(&quot;offset and length interval [%d, %d + %d) is not within array size interval [0, %d)&quot;,</span>
<span class="nc" id="L1855">                                      offset, offset, length, arrayLength));</span>
            }
<span class="nc" id="L1857">        }</span>

        @Override
        public void compute() {
<span class="nc" id="L1861">            SizedCollectorTask&lt;P_IN, P_OUT, T_SINK, K&gt; task = this;</span>
<span class="nc" id="L1862">            Spliterator&lt;P_IN&gt; rightSplit = spliterator, leftSplit;</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">            while (rightSplit.estimateSize() &gt; task.targetSize &amp;&amp;</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">                   (leftSplit = rightSplit.trySplit()) != null) {</span>
<span class="nc" id="L1865">                task.setPendingCount(1);</span>
<span class="nc" id="L1866">                long leftSplitSize = leftSplit.estimateSize();</span>
<span class="nc" id="L1867">                task.makeChild(leftSplit, task.offset, leftSplitSize).fork();</span>
<span class="nc" id="L1868">                task = task.makeChild(rightSplit, task.offset + leftSplitSize,</span>
                                      task.length - leftSplitSize);
<span class="nc" id="L1870">            }</span>

<span class="nc bnc" id="L1872" title="All 4 branches missed.">            assert task.offset + task.length &lt; MAX_ARRAY_SIZE;</span>
<span class="nc" id="L1873">            T_SINK sink = (T_SINK) task;</span>
<span class="nc" id="L1874">            task.helper.wrapAndCopyInto(sink, rightSplit);</span>
<span class="nc" id="L1875">            task.propagateCompletion();</span>
<span class="nc" id="L1876">        }</span>

        abstract K makeChild(Spliterator&lt;P_IN&gt; spliterator, long offset, long size);

        @Override
        public void begin(long size) {
<span class="nc bnc" id="L1882" title="All 2 branches missed.">            if (size &gt; length)</span>
<span class="nc" id="L1883">                throw new IllegalStateException(&quot;size passed to Sink.begin exceeds array length&quot;);</span>
            // Casts to int are safe since absolute size is verified to be within
            // bounds when the root concrete SizedCollectorTask is constructed
            // with the shared array
<span class="nc" id="L1887">            index = (int) offset;</span>
<span class="nc" id="L1888">            fence = index + (int) length;</span>
<span class="nc" id="L1889">        }</span>

        @SuppressWarnings(&quot;serial&quot;)
        static final class OfRef&lt;P_IN, P_OUT&gt;
                extends SizedCollectorTask&lt;P_IN, P_OUT, Sink&lt;P_OUT&gt;, OfRef&lt;P_IN, P_OUT&gt;&gt;
                implements Sink&lt;P_OUT&gt; {
            private final P_OUT[] array;

            OfRef(Spliterator&lt;P_IN&gt; spliterator, PipelineHelper&lt;P_OUT&gt; helper, P_OUT[] array) {
<span class="nc" id="L1898">                super(spliterator, helper, array.length);</span>
<span class="nc" id="L1899">                this.array = array;</span>
<span class="nc" id="L1900">            }</span>

            OfRef(OfRef&lt;P_IN, P_OUT&gt; parent, Spliterator&lt;P_IN&gt; spliterator,
                  long offset, long length) {
<span class="nc" id="L1904">                super(parent, spliterator, offset, length, parent.array.length);</span>
<span class="nc" id="L1905">                this.array = parent.array;</span>
<span class="nc" id="L1906">            }</span>

            @Override
            OfRef&lt;P_IN, P_OUT&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator,
                                         long offset, long size) {
<span class="nc" id="L1911">                return new OfRef&lt;&gt;(this, spliterator, offset, size);</span>
            }

            @Override
            public void accept(P_OUT value) {
<span class="nc bnc" id="L1916" title="All 2 branches missed.">                if (index &gt;= fence) {</span>
<span class="nc" id="L1917">                    throw new IndexOutOfBoundsException(Integer.toString(index));</span>
                }
<span class="nc" id="L1919">                array[index++] = value;</span>
<span class="nc" id="L1920">            }</span>
        }

        @SuppressWarnings(&quot;serial&quot;)
        static final class OfInt&lt;P_IN&gt;
                extends SizedCollectorTask&lt;P_IN, Integer, Sink.OfInt, OfInt&lt;P_IN&gt;&gt;
                implements Sink.OfInt {
            private final int[] array;

            OfInt(Spliterator&lt;P_IN&gt; spliterator, PipelineHelper&lt;Integer&gt; helper, int[] array) {
<span class="nc" id="L1930">                super(spliterator, helper, array.length);</span>
<span class="nc" id="L1931">                this.array = array;</span>
<span class="nc" id="L1932">            }</span>

            OfInt(SizedCollectorTask.OfInt&lt;P_IN&gt; parent, Spliterator&lt;P_IN&gt; spliterator,
                  long offset, long length) {
<span class="nc" id="L1936">                super(parent, spliterator, offset, length, parent.array.length);</span>
<span class="nc" id="L1937">                this.array = parent.array;</span>
<span class="nc" id="L1938">            }</span>

            @Override
            SizedCollectorTask.OfInt&lt;P_IN&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator,
                                                     long offset, long size) {
<span class="nc" id="L1943">                return new SizedCollectorTask.OfInt&lt;&gt;(this, spliterator, offset, size);</span>
            }

            @Override
            public void accept(int value) {
<span class="nc bnc" id="L1948" title="All 2 branches missed.">                if (index &gt;= fence) {</span>
<span class="nc" id="L1949">                    throw new IndexOutOfBoundsException(Integer.toString(index));</span>
                }
<span class="nc" id="L1951">                array[index++] = value;</span>
<span class="nc" id="L1952">            }</span>
        }

        @SuppressWarnings(&quot;serial&quot;)
        static final class OfLong&lt;P_IN&gt;
                extends SizedCollectorTask&lt;P_IN, Long, Sink.OfLong, OfLong&lt;P_IN&gt;&gt;
                implements Sink.OfLong {
            private final long[] array;

            OfLong(Spliterator&lt;P_IN&gt; spliterator, PipelineHelper&lt;Long&gt; helper, long[] array) {
<span class="nc" id="L1962">                super(spliterator, helper, array.length);</span>
<span class="nc" id="L1963">                this.array = array;</span>
<span class="nc" id="L1964">            }</span>

            OfLong(SizedCollectorTask.OfLong&lt;P_IN&gt; parent, Spliterator&lt;P_IN&gt; spliterator,
                   long offset, long length) {
<span class="nc" id="L1968">                super(parent, spliterator, offset, length, parent.array.length);</span>
<span class="nc" id="L1969">                this.array = parent.array;</span>
<span class="nc" id="L1970">            }</span>

            @Override
            SizedCollectorTask.OfLong&lt;P_IN&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator,
                                                      long offset, long size) {
<span class="nc" id="L1975">                return new SizedCollectorTask.OfLong&lt;&gt;(this, spliterator, offset, size);</span>
            }

            @Override
            public void accept(long value) {
<span class="nc bnc" id="L1980" title="All 2 branches missed.">                if (index &gt;= fence) {</span>
<span class="nc" id="L1981">                    throw new IndexOutOfBoundsException(Integer.toString(index));</span>
                }
<span class="nc" id="L1983">                array[index++] = value;</span>
<span class="nc" id="L1984">            }</span>
        }

        @SuppressWarnings(&quot;serial&quot;)
        static final class OfDouble&lt;P_IN&gt;
                extends SizedCollectorTask&lt;P_IN, Double, Sink.OfDouble, OfDouble&lt;P_IN&gt;&gt;
                implements Sink.OfDouble {
            private final double[] array;

            OfDouble(Spliterator&lt;P_IN&gt; spliterator, PipelineHelper&lt;Double&gt; helper, double[] array) {
<span class="nc" id="L1994">                super(spliterator, helper, array.length);</span>
<span class="nc" id="L1995">                this.array = array;</span>
<span class="nc" id="L1996">            }</span>

            OfDouble(SizedCollectorTask.OfDouble&lt;P_IN&gt; parent, Spliterator&lt;P_IN&gt; spliterator,
                     long offset, long length) {
<span class="nc" id="L2000">                super(parent, spliterator, offset, length, parent.array.length);</span>
<span class="nc" id="L2001">                this.array = parent.array;</span>
<span class="nc" id="L2002">            }</span>

            @Override
            SizedCollectorTask.OfDouble&lt;P_IN&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator,
                                                        long offset, long size) {
<span class="nc" id="L2007">                return new SizedCollectorTask.OfDouble&lt;&gt;(this, spliterator, offset, size);</span>
            }

            @Override
            public void accept(double value) {
<span class="nc bnc" id="L2012" title="All 2 branches missed.">                if (index &gt;= fence) {</span>
<span class="nc" id="L2013">                    throw new IndexOutOfBoundsException(Integer.toString(index));</span>
                }
<span class="nc" id="L2015">                array[index++] = value;</span>
<span class="nc" id="L2016">            }</span>
        }
    }

    @SuppressWarnings(&quot;serial&quot;)
    private static abstract class ToArrayTask&lt;T, T_NODE extends Node&lt;T&gt;,
                                              K extends ToArrayTask&lt;T, T_NODE, K&gt;&gt;
            extends CountedCompleter&lt;Void&gt; {
        protected final T_NODE node;
        protected final int offset;

<span class="fc" id="L2027">        ToArrayTask(T_NODE node, int offset) {</span>
<span class="fc" id="L2028">            this.node = node;</span>
<span class="fc" id="L2029">            this.offset = offset;</span>
<span class="fc" id="L2030">        }</span>

        ToArrayTask(K parent, T_NODE node, int offset) {
<span class="fc" id="L2033">            super(parent);</span>
<span class="fc" id="L2034">            this.node = node;</span>
<span class="fc" id="L2035">            this.offset = offset;</span>
<span class="fc" id="L2036">        }</span>

        abstract void copyNodeToArray();

        abstract K makeChild(int childIndex, int offset);

        @Override
        public void compute() {
<span class="fc" id="L2044">            ToArrayTask&lt;T, T_NODE, K&gt; task = this;</span>
            while (true) {
<span class="fc bfc" id="L2046" title="All 2 branches covered.">                if (task.node.getChildCount() == 0) {</span>
<span class="fc" id="L2047">                    task.copyNodeToArray();</span>
<span class="fc" id="L2048">                    task.propagateCompletion();</span>
<span class="fc" id="L2049">                    return;</span>
                }
                else {
<span class="fc" id="L2052">                    task.setPendingCount(task.node.getChildCount() - 1);</span>

<span class="fc" id="L2054">                    int size = 0;</span>
<span class="fc" id="L2055">                    int i = 0;</span>
<span class="fc bfc" id="L2056" title="All 2 branches covered.">                    for (;i &lt; task.node.getChildCount() - 1; i++) {</span>
<span class="fc" id="L2057">                        K leftTask = task.makeChild(i, task.offset + size);</span>
<span class="fc" id="L2058">                        size += leftTask.node.count();</span>
<span class="fc" id="L2059">                        leftTask.fork();</span>
                    }
<span class="fc" id="L2061">                    task = task.makeChild(i, task.offset + size);</span>
<span class="fc" id="L2062">                }</span>
            }
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfRef&lt;T&gt;
                extends ToArrayTask&lt;T, Node&lt;T&gt;, OfRef&lt;T&gt;&gt; {
            private final T[] array;

            private OfRef(Node&lt;T&gt; node, T[] array, int offset) {
<span class="fc" id="L2072">                super(node, offset);</span>
<span class="fc" id="L2073">                this.array = array;</span>
<span class="fc" id="L2074">            }</span>

            private OfRef(OfRef&lt;T&gt; parent, Node&lt;T&gt; node, int offset) {
<span class="fc" id="L2077">                super(parent, node, offset);</span>
<span class="fc" id="L2078">                this.array = parent.array;</span>
<span class="fc" id="L2079">            }</span>

            @Override
            OfRef&lt;T&gt; makeChild(int childIndex, int offset) {
<span class="fc" id="L2083">                return new OfRef&lt;&gt;(this, node.getChild(childIndex), offset);</span>
            }

            @Override
            void copyNodeToArray() {
<span class="fc" id="L2088">                node.copyInto(array, offset);</span>
<span class="fc" id="L2089">            }</span>
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static class OfPrimitive&lt;T, T_CONS, T_ARR,
                                         T_SPLITR extends Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt;,
                                         T_NODE extends Node.OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, T_NODE&gt;&gt;
                extends ToArrayTask&lt;T, T_NODE, OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, T_NODE&gt;&gt; {
            private final T_ARR array;

            private OfPrimitive(T_NODE node, T_ARR array, int offset) {
<span class="fc" id="L2100">                super(node, offset);</span>
<span class="fc" id="L2101">                this.array = array;</span>
<span class="fc" id="L2102">            }</span>

            private OfPrimitive(OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, T_NODE&gt; parent, T_NODE node, int offset) {
<span class="fc" id="L2105">                super(parent, node, offset);</span>
<span class="fc" id="L2106">                this.array = parent.array;</span>
<span class="fc" id="L2107">            }</span>

            @Override
            OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, T_NODE&gt; makeChild(int childIndex, int offset) {
<span class="fc" id="L2111">                return new OfPrimitive&lt;&gt;(this, node.getChild(childIndex), offset);</span>
            }

            @Override
            void copyNodeToArray() {
<span class="fc" id="L2116">                node.copyInto(array, offset);</span>
<span class="fc" id="L2117">            }</span>
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfInt
                extends OfPrimitive&lt;Integer, IntConsumer, int[], Spliterator.OfInt, Node.OfInt&gt; {
            private OfInt(Node.OfInt node, int[] array, int offset) {
<span class="fc" id="L2124">                super(node, array, offset);</span>
<span class="fc" id="L2125">            }</span>
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfLong
                extends OfPrimitive&lt;Long, LongConsumer, long[], Spliterator.OfLong, Node.OfLong&gt; {
            private OfLong(Node.OfLong node, long[] array, int offset) {
<span class="fc" id="L2132">                super(node, array, offset);</span>
<span class="fc" id="L2133">            }</span>
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfDouble
                extends OfPrimitive&lt;Double, DoubleConsumer, double[], Spliterator.OfDouble, Node.OfDouble&gt; {
            private OfDouble(Node.OfDouble node, double[] array, int offset) {
<span class="fc" id="L2140">                super(node, array, offset);</span>
<span class="fc" id="L2141">            }</span>
        }
    }

    @SuppressWarnings(&quot;serial&quot;)
    private static class CollectorTask&lt;P_IN, P_OUT, T_NODE extends Node&lt;P_OUT&gt;, T_BUILDER extends Node.Builder&lt;P_OUT&gt;&gt;
            extends AbstractTask&lt;P_IN, P_OUT, T_NODE, CollectorTask&lt;P_IN, P_OUT, T_NODE, T_BUILDER&gt;&gt; {
        protected final PipelineHelper&lt;P_OUT&gt; helper;
        protected final LongFunction&lt;T_BUILDER&gt; builderFactory;
        protected final BinaryOperator&lt;T_NODE&gt; concFactory;

        CollectorTask(PipelineHelper&lt;P_OUT&gt; helper,
                      Spliterator&lt;P_IN&gt; spliterator,
                      LongFunction&lt;T_BUILDER&gt; builderFactory,
                      BinaryOperator&lt;T_NODE&gt; concFactory) {
<span class="fc" id="L2156">            super(helper, spliterator);</span>
<span class="fc" id="L2157">            this.helper = helper;</span>
<span class="fc" id="L2158">            this.builderFactory = builderFactory;</span>
<span class="fc" id="L2159">            this.concFactory = concFactory;</span>
<span class="fc" id="L2160">        }</span>

        CollectorTask(CollectorTask&lt;P_IN, P_OUT, T_NODE, T_BUILDER&gt; parent,
                      Spliterator&lt;P_IN&gt; spliterator) {
<span class="fc" id="L2164">            super(parent, spliterator);</span>
<span class="fc" id="L2165">            helper = parent.helper;</span>
<span class="fc" id="L2166">            builderFactory = parent.builderFactory;</span>
<span class="fc" id="L2167">            concFactory = parent.concFactory;</span>
<span class="fc" id="L2168">        }</span>

        @Override
        protected CollectorTask&lt;P_IN, P_OUT, T_NODE, T_BUILDER&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator) {
<span class="fc" id="L2172">            return new CollectorTask&lt;&gt;(this, spliterator);</span>
        }

        @Override
        protected T_NODE doLeaf() {
<span class="nc" id="L2177">            T_BUILDER builder = builderFactory.apply(helper.exactOutputSizeIfKnown(spliterator));</span>
<span class="nc" id="L2178">            return (T_NODE) helper.wrapAndCopyInto(builder, spliterator).build();</span>
        }

        @Override
        public void onCompletion(CountedCompleter&lt;?&gt; caller) {
<span class="nc bnc" id="L2183" title="All 2 branches missed.">            if (!isLeaf())</span>
<span class="nc" id="L2184">                setLocalResult(concFactory.apply(leftChild.getLocalResult(), rightChild.getLocalResult()));</span>
<span class="nc" id="L2185">            super.onCompletion(caller);</span>
<span class="nc" id="L2186">        }</span>

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfRef&lt;P_IN, P_OUT&gt;
                extends CollectorTask&lt;P_IN, P_OUT, Node&lt;P_OUT&gt;, Node.Builder&lt;P_OUT&gt;&gt; {
            OfRef(PipelineHelper&lt;P_OUT&gt; helper,
                  IntFunction&lt;P_OUT[]&gt; generator,
                  Spliterator&lt;P_IN&gt; spliterator) {
<span class="fc" id="L2194">                super(helper, spliterator, s -&gt; builder(s, generator), ConcNode::new);</span>
<span class="fc" id="L2195">            }</span>
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfInt&lt;P_IN&gt;
                extends CollectorTask&lt;P_IN, Integer, Node.OfInt, Node.Builder.OfInt&gt; {
            OfInt(PipelineHelper&lt;Integer&gt; helper, Spliterator&lt;P_IN&gt; spliterator) {
<span class="fc" id="L2202">                super(helper, spliterator, Nodes::intBuilder, ConcNode.OfInt::new);</span>
<span class="fc" id="L2203">            }</span>
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfLong&lt;P_IN&gt;
                extends CollectorTask&lt;P_IN, Long, Node.OfLong, Node.Builder.OfLong&gt; {
            OfLong(PipelineHelper&lt;Long&gt; helper, Spliterator&lt;P_IN&gt; spliterator) {
<span class="fc" id="L2210">                super(helper, spliterator, Nodes::longBuilder, ConcNode.OfLong::new);</span>
<span class="fc" id="L2211">            }</span>
        }

        @SuppressWarnings(&quot;serial&quot;)
        private static final class OfDouble&lt;P_IN&gt;
                extends CollectorTask&lt;P_IN, Double, Node.OfDouble, Node.Builder.OfDouble&gt; {
            OfDouble(PipelineHelper&lt;Double&gt; helper, Spliterator&lt;P_IN&gt; spliterator) {
<span class="fc" id="L2218">                super(helper, spliterator, Nodes::doubleBuilder, ConcNode.OfDouble::new);</span>
<span class="fc" id="L2219">            }</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>