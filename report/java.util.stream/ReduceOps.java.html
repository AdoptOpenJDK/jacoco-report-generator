<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ReduceOps.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.stream</a> &gt; <span class="el_source">ReduceOps.java</span></div><h1>ReduceOps.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util.stream;

import java.util.Objects;
import java.util.Optional;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.OptionalLong;
import java.util.Spliterator;
import java.util.concurrent.CountedCompleter;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.DoubleBinaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.ObjDoubleConsumer;
import java.util.function.ObjIntConsumer;
import java.util.function.ObjLongConsumer;
import java.util.function.Supplier;

/**
 * Factory for creating instances of {@code TerminalOp} that implement
 * reductions.
 *
 * @since 1.8
 */
final class ReduceOps {

<span class="nc" id="L53">    private ReduceOps() { }</span>

    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * reference values.
     *
     * @param &lt;T&gt; the type of the input elements
     * @param &lt;U&gt; the type of the result
     * @param seed the identity element for the reduction
     * @param reducer the accumulating function that incorporates an additional
     *        input element into the result
     * @param combiner the combining function that combines two intermediate
     *        results
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static &lt;T, U&gt; TerminalOp&lt;T, U&gt;
    makeRef(U seed, BiFunction&lt;U, ? super T, U&gt; reducer, BinaryOperator&lt;U&gt; combiner) {
<span class="fc" id="L70">        Objects.requireNonNull(reducer);</span>
<span class="fc" id="L71">        Objects.requireNonNull(combiner);</span>
<span class="nc" id="L72">        class ReducingSink extends Box&lt;U&gt; implements AccumulatingSink&lt;T, U, ReducingSink&gt; {</span>
            @Override
            public void begin(long size) {
<span class="nc" id="L75">                state = seed;</span>
<span class="nc" id="L76">            }</span>

            @Override
            public void accept(T t) {
<span class="nc" id="L80">                state = reducer.apply(state, t);</span>
<span class="nc" id="L81">            }</span>

            @Override
            public void combine(ReducingSink other) {
<span class="nc" id="L85">                state = combiner.apply(state, other.state);</span>
<span class="nc" id="L86">            }</span>
        }
<span class="fc" id="L88">        return new ReduceOp&lt;T, U, ReducingSink&gt;(StreamShape.REFERENCE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L91">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * reference values producing an optional reference result.
     *
     * @param &lt;T&gt; The type of the input elements, and the type of the result
     * @param operator The reducing function
     * @return A {@code TerminalOp} implementing the reduction
     */
    public static &lt;T&gt; TerminalOp&lt;T, Optional&lt;T&gt;&gt;
    makeRef(BinaryOperator&lt;T&gt; operator) {
<span class="nc" id="L106">        Objects.requireNonNull(operator);</span>
<span class="nc" id="L107">        class ReducingSink</span>
                implements AccumulatingSink&lt;T, Optional&lt;T&gt;, ReducingSink&gt; {
            private boolean empty;
            private T state;

            public void begin(long size) {
<span class="nc" id="L113">                empty = true;</span>
<span class="nc" id="L114">                state = null;</span>
<span class="nc" id="L115">            }</span>

            @Override
            public void accept(T t) {
<span class="nc bnc" id="L119" title="All 2 branches missed.">                if (empty) {</span>
<span class="nc" id="L120">                    empty = false;</span>
<span class="nc" id="L121">                    state = t;</span>
                } else {
<span class="nc" id="L123">                    state = operator.apply(state, t);</span>
                }
<span class="nc" id="L125">            }</span>

            @Override
            public Optional&lt;T&gt; get() {
<span class="nc bnc" id="L129" title="All 2 branches missed.">                return empty ? Optional.empty() : Optional.of(state);</span>
            }

            @Override
            public void combine(ReducingSink other) {
<span class="nc bnc" id="L134" title="All 2 branches missed.">                if (!other.empty)</span>
<span class="nc" id="L135">                    accept(other.state);</span>
<span class="nc" id="L136">            }</span>
        }
<span class="nc" id="L138">        return new ReduceOp&lt;T, Optional&lt;T&gt;, ReducingSink&gt;(StreamShape.REFERENCE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L141">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a mutable reduce on
     * reference values.
     *
     * @param &lt;T&gt; the type of the input elements
     * @param &lt;I&gt; the type of the intermediate reduction result
     * @param collector a {@code Collector} defining the reduction
     * @return a {@code ReduceOp} implementing the reduction
     */
    public static &lt;T, I&gt; TerminalOp&lt;T, I&gt;
    makeRef(Collector&lt;? super T, I, ?&gt; collector) {
<span class="fc" id="L157">        Supplier&lt;I&gt; supplier = Objects.requireNonNull(collector).supplier();</span>
<span class="fc" id="L158">        BiConsumer&lt;I, ? super T&gt; accumulator = collector.accumulator();</span>
<span class="fc" id="L159">        BinaryOperator&lt;I&gt; combiner = collector.combiner();</span>
<span class="fc" id="L160">        class ReducingSink extends Box&lt;I&gt;</span>
                implements AccumulatingSink&lt;T, I, ReducingSink&gt; {
            @Override
            public void begin(long size) {
<span class="nc" id="L164">                state = supplier.get();</span>
<span class="nc" id="L165">            }</span>

            @Override
            public void accept(T t) {
<span class="nc" id="L169">                accumulator.accept(state, t);</span>
<span class="nc" id="L170">            }</span>

            @Override
            public void combine(ReducingSink other) {
<span class="nc" id="L174">                state = combiner.apply(state, other.state);</span>
<span class="nc" id="L175">            }</span>
        }
<span class="fc" id="L177">        return new ReduceOp&lt;T, I, ReducingSink&gt;(StreamShape.REFERENCE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="fc" id="L180">                return new ReducingSink();</span>
            }

            @Override
            public int getOpFlags() {
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">                return collector.characteristics().contains(Collector.Characteristics.UNORDERED)</span>
                       ? StreamOpFlag.NOT_ORDERED
                       : 0;
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a mutable reduce on
     * reference values.
     *
     * @param &lt;T&gt; the type of the input elements
     * @param &lt;R&gt; the type of the result
     * @param seedFactory a factory to produce a new base accumulator
     * @param accumulator a function to incorporate an element into an
     *        accumulator
     * @param reducer a function to combine an accumulator into another
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static &lt;T, R&gt; TerminalOp&lt;T, R&gt;
    makeRef(Supplier&lt;R&gt; seedFactory,
            BiConsumer&lt;R, ? super T&gt; accumulator,
            BiConsumer&lt;R,R&gt; reducer) {
<span class="nc" id="L208">        Objects.requireNonNull(seedFactory);</span>
<span class="nc" id="L209">        Objects.requireNonNull(accumulator);</span>
<span class="nc" id="L210">        Objects.requireNonNull(reducer);</span>
<span class="nc" id="L211">        class ReducingSink extends Box&lt;R&gt;</span>
                implements AccumulatingSink&lt;T, R, ReducingSink&gt; {
            @Override
            public void begin(long size) {
<span class="nc" id="L215">                state = seedFactory.get();</span>
<span class="nc" id="L216">            }</span>

            @Override
            public void accept(T t) {
<span class="nc" id="L220">                accumulator.accept(state, t);</span>
<span class="nc" id="L221">            }</span>

            @Override
            public void combine(ReducingSink other) {
<span class="nc" id="L225">                reducer.accept(state, other.state);</span>
<span class="nc" id="L226">            }</span>
        }
<span class="nc" id="L228">        return new ReduceOp&lt;T, R, ReducingSink&gt;(StreamShape.REFERENCE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L231">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * {@code int} values.
     *
     * @param identity the identity for the combining function
     * @param operator the combining function
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static TerminalOp&lt;Integer, Integer&gt;
    makeInt(int identity, IntBinaryOperator operator) {
<span class="fc" id="L246">        Objects.requireNonNull(operator);</span>
<span class="nc" id="L247">        class ReducingSink</span>
                implements AccumulatingSink&lt;Integer, Integer, ReducingSink&gt;, Sink.OfInt {
            private int state;

            @Override
            public void begin(long size) {
<span class="nc" id="L253">                state = identity;</span>
<span class="nc" id="L254">            }</span>

            @Override
            public void accept(int t) {
<span class="nc" id="L258">                state = operator.applyAsInt(state, t);</span>
<span class="nc" id="L259">            }</span>

            @Override
            public Integer get() {
<span class="nc" id="L263">                return state;</span>
            }

            @Override
            public void combine(ReducingSink other) {
<span class="nc" id="L268">                accept(other.state);</span>
<span class="nc" id="L269">            }</span>
        }
<span class="fc" id="L271">        return new ReduceOp&lt;Integer, Integer, ReducingSink&gt;(StreamShape.INT_VALUE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L274">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * {@code int} values, producing an optional integer result.
     *
     * @param operator the combining function
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static TerminalOp&lt;Integer, OptionalInt&gt;
    makeInt(IntBinaryOperator operator) {
<span class="nc" id="L288">        Objects.requireNonNull(operator);</span>
<span class="nc" id="L289">        class ReducingSink</span>
                implements AccumulatingSink&lt;Integer, OptionalInt, ReducingSink&gt;, Sink.OfInt {
            private boolean empty;
            private int state;

            public void begin(long size) {
<span class="nc" id="L295">                empty = true;</span>
<span class="nc" id="L296">                state = 0;</span>
<span class="nc" id="L297">            }</span>

            @Override
            public void accept(int t) {
<span class="nc bnc" id="L301" title="All 2 branches missed.">                if (empty) {</span>
<span class="nc" id="L302">                    empty = false;</span>
<span class="nc" id="L303">                    state = t;</span>
                }
                else {
<span class="nc" id="L306">                    state = operator.applyAsInt(state, t);</span>
                }
<span class="nc" id="L308">            }</span>

            @Override
            public OptionalInt get() {
<span class="nc bnc" id="L312" title="All 2 branches missed.">                return empty ? OptionalInt.empty() : OptionalInt.of(state);</span>
            }

            @Override
            public void combine(ReducingSink other) {
<span class="nc bnc" id="L317" title="All 2 branches missed.">                if (!other.empty)</span>
<span class="nc" id="L318">                    accept(other.state);</span>
<span class="nc" id="L319">            }</span>
        }
<span class="nc" id="L321">        return new ReduceOp&lt;Integer, OptionalInt, ReducingSink&gt;(StreamShape.INT_VALUE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L324">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a mutable reduce on
     * {@code int} values.
     *
     * @param &lt;R&gt; The type of the result
     * @param supplier a factory to produce a new accumulator of the result type
     * @param accumulator a function to incorporate an int into an
     *        accumulator
     * @param combiner a function to combine an accumulator into another
     * @return A {@code ReduceOp} implementing the reduction
     */
    public static &lt;R&gt; TerminalOp&lt;Integer, R&gt;
    makeInt(Supplier&lt;R&gt; supplier,
            ObjIntConsumer&lt;R&gt; accumulator,
            BinaryOperator&lt;R&gt; combiner) {
<span class="nc" id="L344">        Objects.requireNonNull(supplier);</span>
<span class="nc" id="L345">        Objects.requireNonNull(accumulator);</span>
<span class="nc" id="L346">        Objects.requireNonNull(combiner);</span>
<span class="nc" id="L347">        class ReducingSink extends Box&lt;R&gt;</span>
                implements AccumulatingSink&lt;Integer, R, ReducingSink&gt;, Sink.OfInt {
            @Override
            public void begin(long size) {
<span class="nc" id="L351">                state = supplier.get();</span>
<span class="nc" id="L352">            }</span>

            @Override
            public void accept(int t) {
<span class="nc" id="L356">                accumulator.accept(state, t);</span>
<span class="nc" id="L357">            }</span>

            @Override
            public void combine(ReducingSink other) {
<span class="nc" id="L361">                state = combiner.apply(state, other.state);</span>
<span class="nc" id="L362">            }</span>
        }
<span class="nc" id="L364">        return new ReduceOp&lt;Integer, R, ReducingSink&gt;(StreamShape.INT_VALUE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L367">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * {@code long} values.
     *
     * @param identity the identity for the combining function
     * @param operator the combining function
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static TerminalOp&lt;Long, Long&gt;
    makeLong(long identity, LongBinaryOperator operator) {
<span class="fc" id="L382">        Objects.requireNonNull(operator);</span>
<span class="nc" id="L383">        class ReducingSink</span>
                implements AccumulatingSink&lt;Long, Long, ReducingSink&gt;, Sink.OfLong {
            private long state;

            @Override
            public void begin(long size) {
<span class="nc" id="L389">                state = identity;</span>
<span class="nc" id="L390">            }</span>

            @Override
            public void accept(long t) {
<span class="nc" id="L394">                state = operator.applyAsLong(state, t);</span>
<span class="nc" id="L395">            }</span>

            @Override
            public Long get() {
<span class="nc" id="L399">                return state;</span>
            }

            @Override
            public void combine(ReducingSink other) {
<span class="nc" id="L404">                accept(other.state);</span>
<span class="nc" id="L405">            }</span>
        }
<span class="fc" id="L407">        return new ReduceOp&lt;Long, Long, ReducingSink&gt;(StreamShape.LONG_VALUE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L410">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * {@code long} values, producing an optional long result.
     *
     * @param operator the combining function
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static TerminalOp&lt;Long, OptionalLong&gt;
    makeLong(LongBinaryOperator operator) {
<span class="nc" id="L424">        Objects.requireNonNull(operator);</span>
<span class="nc" id="L425">        class ReducingSink</span>
                implements AccumulatingSink&lt;Long, OptionalLong, ReducingSink&gt;, Sink.OfLong {
            private boolean empty;
            private long state;

            public void begin(long size) {
<span class="nc" id="L431">                empty = true;</span>
<span class="nc" id="L432">                state = 0;</span>
<span class="nc" id="L433">            }</span>

            @Override
            public void accept(long t) {
<span class="nc bnc" id="L437" title="All 2 branches missed.">                if (empty) {</span>
<span class="nc" id="L438">                    empty = false;</span>
<span class="nc" id="L439">                    state = t;</span>
                }
                else {
<span class="nc" id="L442">                    state = operator.applyAsLong(state, t);</span>
                }
<span class="nc" id="L444">            }</span>

            @Override
            public OptionalLong get() {
<span class="nc bnc" id="L448" title="All 2 branches missed.">                return empty ? OptionalLong.empty() : OptionalLong.of(state);</span>
            }

            @Override
            public void combine(ReducingSink other) {
<span class="nc bnc" id="L453" title="All 2 branches missed.">                if (!other.empty)</span>
<span class="nc" id="L454">                    accept(other.state);</span>
<span class="nc" id="L455">            }</span>
        }
<span class="nc" id="L457">        return new ReduceOp&lt;Long, OptionalLong, ReducingSink&gt;(StreamShape.LONG_VALUE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L460">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a mutable reduce on
     * {@code long} values.
     *
     * @param &lt;R&gt; the type of the result
     * @param supplier a factory to produce a new accumulator of the result type
     * @param accumulator a function to incorporate an int into an
     *        accumulator
     * @param combiner a function to combine an accumulator into another
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static &lt;R&gt; TerminalOp&lt;Long, R&gt;
    makeLong(Supplier&lt;R&gt; supplier,
             ObjLongConsumer&lt;R&gt; accumulator,
             BinaryOperator&lt;R&gt; combiner) {
<span class="nc" id="L480">        Objects.requireNonNull(supplier);</span>
<span class="nc" id="L481">        Objects.requireNonNull(accumulator);</span>
<span class="nc" id="L482">        Objects.requireNonNull(combiner);</span>
<span class="nc" id="L483">        class ReducingSink extends Box&lt;R&gt;</span>
                implements AccumulatingSink&lt;Long, R, ReducingSink&gt;, Sink.OfLong {
            @Override
            public void begin(long size) {
<span class="nc" id="L487">                state = supplier.get();</span>
<span class="nc" id="L488">            }</span>

            @Override
            public void accept(long t) {
<span class="nc" id="L492">                accumulator.accept(state, t);</span>
<span class="nc" id="L493">            }</span>

            @Override
            public void combine(ReducingSink other) {
<span class="nc" id="L497">                state = combiner.apply(state, other.state);</span>
<span class="nc" id="L498">            }</span>
        }
<span class="nc" id="L500">        return new ReduceOp&lt;Long, R, ReducingSink&gt;(StreamShape.LONG_VALUE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L503">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * {@code double} values.
     *
     * @param identity the identity for the combining function
     * @param operator the combining function
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static TerminalOp&lt;Double, Double&gt;
    makeDouble(double identity, DoubleBinaryOperator operator) {
<span class="fc" id="L518">        Objects.requireNonNull(operator);</span>
<span class="nc" id="L519">        class ReducingSink</span>
                implements AccumulatingSink&lt;Double, Double, ReducingSink&gt;, Sink.OfDouble {
            private double state;

            @Override
            public void begin(long size) {
<span class="nc" id="L525">                state = identity;</span>
<span class="nc" id="L526">            }</span>

            @Override
            public void accept(double t) {
<span class="nc" id="L530">                state = operator.applyAsDouble(state, t);</span>
<span class="nc" id="L531">            }</span>

            @Override
            public Double get() {
<span class="nc" id="L535">                return state;</span>
            }

            @Override
            public void combine(ReducingSink other) {
<span class="nc" id="L540">                accept(other.state);</span>
<span class="nc" id="L541">            }</span>
        }
<span class="fc" id="L543">        return new ReduceOp&lt;Double, Double, ReducingSink&gt;(StreamShape.DOUBLE_VALUE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L546">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a functional reduce on
     * {@code double} values, producing an optional double result.
     *
     * @param operator the combining function
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static TerminalOp&lt;Double, OptionalDouble&gt;
    makeDouble(DoubleBinaryOperator operator) {
<span class="nc" id="L560">        Objects.requireNonNull(operator);</span>
<span class="nc" id="L561">        class ReducingSink</span>
                implements AccumulatingSink&lt;Double, OptionalDouble, ReducingSink&gt;, Sink.OfDouble {
            private boolean empty;
            private double state;

            public void begin(long size) {
<span class="nc" id="L567">                empty = true;</span>
<span class="nc" id="L568">                state = 0;</span>
<span class="nc" id="L569">            }</span>

            @Override
            public void accept(double t) {
<span class="nc bnc" id="L573" title="All 2 branches missed.">                if (empty) {</span>
<span class="nc" id="L574">                    empty = false;</span>
<span class="nc" id="L575">                    state = t;</span>
                }
                else {
<span class="nc" id="L578">                    state = operator.applyAsDouble(state, t);</span>
                }
<span class="nc" id="L580">            }</span>

            @Override
            public OptionalDouble get() {
<span class="nc bnc" id="L584" title="All 2 branches missed.">                return empty ? OptionalDouble.empty() : OptionalDouble.of(state);</span>
            }

            @Override
            public void combine(ReducingSink other) {
<span class="nc bnc" id="L589" title="All 2 branches missed.">                if (!other.empty)</span>
<span class="nc" id="L590">                    accept(other.state);</span>
<span class="nc" id="L591">            }</span>
        }
<span class="nc" id="L593">        return new ReduceOp&lt;Double, OptionalDouble, ReducingSink&gt;(StreamShape.DOUBLE_VALUE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L596">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * Constructs a {@code TerminalOp} that implements a mutable reduce on
     * {@code double} values.
     *
     * @param &lt;R&gt; the type of the result
     * @param supplier a factory to produce a new accumulator of the result type
     * @param accumulator a function to incorporate an int into an
     *        accumulator
     * @param combiner a function to combine an accumulator into another
     * @return a {@code TerminalOp} implementing the reduction
     */
    public static &lt;R&gt; TerminalOp&lt;Double, R&gt;
    makeDouble(Supplier&lt;R&gt; supplier,
               ObjDoubleConsumer&lt;R&gt; accumulator,
               BinaryOperator&lt;R&gt; combiner) {
<span class="nc" id="L616">        Objects.requireNonNull(supplier);</span>
<span class="nc" id="L617">        Objects.requireNonNull(accumulator);</span>
<span class="nc" id="L618">        Objects.requireNonNull(combiner);</span>
<span class="nc" id="L619">        class ReducingSink extends Box&lt;R&gt;</span>
                implements AccumulatingSink&lt;Double, R, ReducingSink&gt;, Sink.OfDouble {
            @Override
            public void begin(long size) {
<span class="nc" id="L623">                state = supplier.get();</span>
<span class="nc" id="L624">            }</span>

            @Override
            public void accept(double t) {
<span class="nc" id="L628">                accumulator.accept(state, t);</span>
<span class="nc" id="L629">            }</span>

            @Override
            public void combine(ReducingSink other) {
<span class="nc" id="L633">                state = combiner.apply(state, other.state);</span>
<span class="nc" id="L634">            }</span>
        }
<span class="nc" id="L636">        return new ReduceOp&lt;Double, R, ReducingSink&gt;(StreamShape.DOUBLE_VALUE) {</span>
            @Override
            public ReducingSink makeSink() {
<span class="nc" id="L639">                return new ReducingSink();</span>
            }
        };
    }

    /**
     * A type of {@code TerminalSink} that implements an associative reducing
     * operation on elements of type {@code T} and producing a result of type
     * {@code R}.
     *
     * @param &lt;T&gt; the type of input element to the combining operation
     * @param &lt;R&gt; the result type
     * @param &lt;K&gt; the type of the {@code AccumulatingSink}.
     */
    private interface AccumulatingSink&lt;T, R, K extends AccumulatingSink&lt;T, R, K&gt;&gt;
            extends TerminalSink&lt;T, R&gt; {
        public void combine(K other);
    }

    /**
     * State box for a single state element, used as a base class for
     * {@code AccumulatingSink} instances
     *
     * @param &lt;U&gt; The type of the state element
     */
    private static abstract class Box&lt;U&gt; {
        U state;

<span class="fc" id="L667">        Box() {} // Avoid creation of special accessor</span>

        public U get() {
<span class="nc" id="L670">            return state;</span>
        }
    }

    /**
     * A {@code TerminalOp} that evaluates a stream pipeline and sends the
     * output into an {@code AccumulatingSink}, which performs a reduce
     * operation. The {@code AccumulatingSink} must represent an associative
     * reducing operation.
     *
     * @param &lt;T&gt; the output type of the stream pipeline
     * @param &lt;R&gt; the result type of the reducing operation
     * @param &lt;S&gt; the type of the {@code AccumulatingSink}
     */
    private static abstract class ReduceOp&lt;T, R, S extends AccumulatingSink&lt;T, R, S&gt;&gt;
            implements TerminalOp&lt;T, R&gt; {
        private final StreamShape inputShape;

        /**
         * Create a {@code ReduceOp} of the specified stream shape which uses
         * the specified {@code Supplier} to create accumulating sinks.
         *
         * @param shape The shape of the stream pipeline
         */
<span class="fc" id="L694">        ReduceOp(StreamShape shape) {</span>
<span class="fc" id="L695">            inputShape = shape;</span>
<span class="fc" id="L696">        }</span>

        public abstract S makeSink();

        @Override
        public StreamShape inputShape() {
<span class="fc" id="L702">            return inputShape;</span>
        }

        @Override
        public &lt;P_IN&gt; R evaluateSequential(PipelineHelper&lt;T&gt; helper,
                                           Spliterator&lt;P_IN&gt; spliterator) {
<span class="nc" id="L708">            return helper.wrapAndCopyInto(makeSink(), spliterator).get();</span>
        }

        @Override
        public &lt;P_IN&gt; R evaluateParallel(PipelineHelper&lt;T&gt; helper,
                                         Spliterator&lt;P_IN&gt; spliterator) {
<span class="nc" id="L714">            return new ReduceTask&lt;&gt;(this, helper, spliterator).invoke().get();</span>
        }
    }

    /**
     * A {@code ForkJoinTask} for performing a parallel reduce operation.
     */
    @SuppressWarnings(&quot;serial&quot;)
    private static final class ReduceTask&lt;P_IN, P_OUT, R,
                                          S extends AccumulatingSink&lt;P_OUT, R, S&gt;&gt;
            extends AbstractTask&lt;P_IN, P_OUT, S, ReduceTask&lt;P_IN, P_OUT, R, S&gt;&gt; {
        private final ReduceOp&lt;P_OUT, R, S&gt; op;

        ReduceTask(ReduceOp&lt;P_OUT, R, S&gt; op,
                   PipelineHelper&lt;P_OUT&gt; helper,
                   Spliterator&lt;P_IN&gt; spliterator) {
<span class="fc" id="L730">            super(helper, spliterator);</span>
<span class="fc" id="L731">            this.op = op;</span>
<span class="fc" id="L732">        }</span>

        ReduceTask(ReduceTask&lt;P_IN, P_OUT, R, S&gt; parent,
                   Spliterator&lt;P_IN&gt; spliterator) {
<span class="fc" id="L736">            super(parent, spliterator);</span>
<span class="fc" id="L737">            this.op = parent.op;</span>
<span class="fc" id="L738">        }</span>

        @Override
        protected ReduceTask&lt;P_IN, P_OUT, R, S&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator) {
<span class="fc" id="L742">            return new ReduceTask&lt;&gt;(this, spliterator);</span>
        }

        @Override
        protected S doLeaf() {
<span class="nc" id="L747">            return helper.wrapAndCopyInto(op.makeSink(), spliterator);</span>
        }

        @Override
        public void onCompletion(CountedCompleter&lt;?&gt; caller) {
<span class="nc bnc" id="L752" title="All 2 branches missed.">            if (!isLeaf()) {</span>
<span class="nc" id="L753">                S leftResult = leftChild.getLocalResult();</span>
<span class="nc" id="L754">                leftResult.combine(rightChild.getLocalResult());</span>
<span class="nc" id="L755">                setLocalResult(leftResult);</span>
            }
            // GC spliterator, left and right child
<span class="nc" id="L758">            super.onCompletion(caller);</span>
<span class="nc" id="L759">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>