<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SliceOps.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.util.stream</a> &gt; <span class="el_source">SliceOps.java</span></div><h1>SliceOps.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util.stream;

import java.util.Spliterator;
import java.util.concurrent.CountedCompleter;
import java.util.function.IntFunction;

/**
 * Factory for instances of a short-circuiting stateful intermediate operations
 * that produce subsequences of their input stream.
 *
 * @since 1.8
 */
<span class="pc bpc" id="L37" title="1 of 2 branches missed.">final class SliceOps {</span>

    // No instances
<span class="nc" id="L40">    private SliceOps() { }</span>

    /**
     * Calculates the sliced size given the current size, number of elements
     * skip, and the number of elements to limit.
     *
     * @param size the current size
     * @param skip the number of elements to skip, assumed to be &gt;= 0
     * @param limit the number of elements to limit, assumed to be &gt;= 0, with
     *        a value of {@code Long.MAX_VALUE} if there is no limit
     * @return the sliced size
     */
    private static long calcSize(long size, long skip, long limit) {
<span class="nc bnc" id="L53" title="All 2 branches missed.">        return size &gt;= 0 ? Math.max(-1, Math.min(size - skip, limit)) : -1;</span>
    }

    /**
     * Calculates the slice fence, which is one past the index of the slice
     * range
     * @param skip the number of elements to skip, assumed to be &gt;= 0
     * @param limit the number of elements to limit, assumed to be &gt;= 0, with
     *        a value of {@code Long.MAX_VALUE} if there is no limit
     * @return the slice fence.
     */
    private static long calcSliceFence(long skip, long limit) {
<span class="nc bnc" id="L65" title="All 2 branches missed.">        long sliceFence = limit &gt;= 0 ? skip + limit : Long.MAX_VALUE;</span>
        // Check for overflow
<span class="nc bnc" id="L67" title="All 2 branches missed.">        return (sliceFence &gt;= 0) ? sliceFence : Long.MAX_VALUE;</span>
    }

    /**
     * Creates a slice spliterator given a stream shape governing the
     * spliterator type.  Requires that the underlying Spliterator
     * be SUBSIZED.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private static &lt;P_IN&gt; Spliterator&lt;P_IN&gt; sliceSpliterator(StreamShape shape,
                                                             Spliterator&lt;P_IN&gt; s,
                                                             long skip, long limit) {
<span class="nc bnc" id="L79" title="All 4 branches missed.">        assert s.hasCharacteristics(Spliterator.SUBSIZED);</span>
<span class="nc" id="L80">        long sliceFence = calcSliceFence(skip, limit);</span>
<span class="nc bnc" id="L81" title="All 5 branches missed.">        switch (shape) {</span>
            case REFERENCE:
<span class="nc" id="L83">                return new StreamSpliterators</span>
                        .SliceSpliterator.OfRef&lt;&gt;(s, skip, sliceFence);
            case INT_VALUE:
<span class="nc" id="L86">                return (Spliterator&lt;P_IN&gt;) new StreamSpliterators</span>
                        .SliceSpliterator.OfInt((Spliterator.OfInt) s, skip, sliceFence);
            case LONG_VALUE:
<span class="nc" id="L89">                return (Spliterator&lt;P_IN&gt;) new StreamSpliterators</span>
                        .SliceSpliterator.OfLong((Spliterator.OfLong) s, skip, sliceFence);
            case DOUBLE_VALUE:
<span class="nc" id="L92">                return (Spliterator&lt;P_IN&gt;) new StreamSpliterators</span>
                        .SliceSpliterator.OfDouble((Spliterator.OfDouble) s, skip, sliceFence);
            default:
<span class="nc" id="L95">                throw new IllegalStateException(&quot;Unknown shape &quot; + shape);</span>
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private static &lt;T&gt; IntFunction&lt;T[]&gt; castingArray() {
<span class="nc" id="L101">        return size -&gt; (T[]) new Object[size];</span>
    }

    /**
     * Appends a &quot;slice&quot; operation to the provided stream.  The slice operation
     * may be may be skip-only, limit-only, or skip-and-limit.
     *
     * @param &lt;T&gt; the type of both input and output elements
     * @param upstream a reference stream with element type T
     * @param skip the number of elements to skip.  Must be &gt;= 0.
     * @param limit the maximum size of the resulting stream, or -1 if no limit
     *        is to be imposed
     */
    public static &lt;T&gt; Stream&lt;T&gt; makeRef(AbstractPipeline&lt;?, T, ?&gt; upstream,
                                        long skip, long limit) {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (skip &lt; 0)</span>
<span class="nc" id="L117">            throw new IllegalArgumentException(&quot;Skip must be non-negative: &quot; + skip);</span>

<span class="fc" id="L119">        return new ReferencePipeline.StatefulOp&lt;T, T&gt;(upstream, StreamShape.REFERENCE,</span>
<span class="fc" id="L120">                                                      flags(limit)) {</span>
            Spliterator&lt;T&gt; unorderedSkipLimitSpliterator(Spliterator&lt;T&gt; s,
                                                         long skip, long limit, long sizeIfKnown) {
<span class="nc bnc" id="L123" title="All 2 branches missed.">                if (skip &lt;= sizeIfKnown) {</span>
                    // Use just the limit if the number of elements
                    // to skip is &lt;= the known pipeline size
<span class="nc bnc" id="L126" title="All 2 branches missed.">                    limit = limit &gt;= 0 ? Math.min(limit, sizeIfKnown - skip) : sizeIfKnown - skip;</span>
<span class="nc" id="L127">                    skip = 0;</span>
                }
<span class="nc" id="L129">                return new StreamSpliterators.UnorderedSliceSpliterator.OfRef&lt;&gt;(s, skip, limit);</span>
            }

            @Override
            &lt;P_IN&gt; Spliterator&lt;T&gt; opEvaluateParallelLazy(PipelineHelper&lt;T&gt; helper, Spliterator&lt;P_IN&gt; spliterator) {
<span class="nc" id="L134">                long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="nc bnc" id="L135" title="All 4 branches missed.">                if (size &gt; 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
<span class="nc" id="L136">                    return new StreamSpliterators.SliceSpliterator.OfRef&lt;&gt;(</span>
<span class="nc" id="L137">                            helper.wrapSpliterator(spliterator),</span>
                            skip,
<span class="nc" id="L139">                            calcSliceFence(skip, limit));</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                } else if (!StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L141">                    return unorderedSkipLimitSpliterator(</span>
<span class="nc" id="L142">                            helper.wrapSpliterator(spliterator),</span>
                            skip, limit, size);
                }
                else {
                    // @@@ OOMEs will occur for LongStream.longs().filter(i -&gt; true).limit(n)
                    //     regardless of the value of n
                    //     Need to adjust the target size of splitting for the
                    //     SliceTask from say (size / k) to say min(size / k, 1 &lt;&lt; 14)
                    //     This will limit the size of the buffers created at the leaf nodes
                    //     cancellation will be more aggressive cancelling later tasks
                    //     if the target slice size has been reached from a given task,
                    //     cancellation should also clear local results if any
<span class="nc" id="L154">                    return new SliceTask&lt;&gt;(this, helper, spliterator, castingArray(), skip, limit).</span>
<span class="nc" id="L155">                            invoke().spliterator();</span>
                }
            }

            @Override
            &lt;P_IN&gt; Node&lt;T&gt; opEvaluateParallel(PipelineHelper&lt;T&gt; helper,
                                              Spliterator&lt;P_IN&gt; spliterator,
                                              IntFunction&lt;T[]&gt; generator) {
<span class="nc" id="L163">                long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="nc bnc" id="L164" title="All 4 branches missed.">                if (size &gt; 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
                    // Because the pipeline is SIZED the slice spliterator
                    // can be created from the source, this requires matching
                    // to shape of the source, and is potentially more efficient
                    // than creating the slice spliterator from the pipeline
                    // wrapping spliterator
<span class="nc" id="L170">                    Spliterator&lt;P_IN&gt; s = sliceSpliterator(helper.getSourceShape(), spliterator, skip, limit);</span>
<span class="nc" id="L171">                    return Nodes.collect(helper, s, true, generator);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">                } else if (!StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L173">                    Spliterator&lt;T&gt; s =  unorderedSkipLimitSpliterator(</span>
<span class="nc" id="L174">                            helper.wrapSpliterator(spliterator),</span>
                            skip, limit, size);
                    // Collect using this pipeline, which is empty and therefore
                    // can be used with the pipeline wrapping spliterator
                    // Note that we cannot create a slice spliterator from
                    // the source spliterator if the pipeline is not SIZED
<span class="nc" id="L180">                    return Nodes.collect(this, s, true, generator);</span>
                }
                else {
<span class="nc" id="L183">                    return new SliceTask&lt;&gt;(this, helper, spliterator, generator, skip, limit).</span>
<span class="nc" id="L184">                            invoke();</span>
                }
            }

            @Override
            Sink&lt;T&gt; opWrapSink(int flags, Sink&lt;T&gt; sink) {
<span class="fc" id="L190">                return new Sink.ChainedReference&lt;T, T&gt;(sink) {</span>
<span class="fc" id="L191">                    long n = skip;</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                    long m = limit &gt;= 0 ? limit : Long.MAX_VALUE;</span>

                    @Override
                    public void begin(long size) {
<span class="nc" id="L196">                        downstream.begin(calcSize(size, skip, m));</span>
<span class="nc" id="L197">                    }</span>

                    @Override
                    public void accept(T t) {
<span class="nc bnc" id="L201" title="All 2 branches missed.">                        if (n == 0) {</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">                            if (m &gt; 0) {</span>
<span class="nc" id="L203">                                m--;</span>
<span class="nc" id="L204">                                downstream.accept(t);</span>
                            }
                        }
                        else {
<span class="nc" id="L208">                            n--;</span>
                        }
<span class="nc" id="L210">                    }</span>

                    @Override
                    public boolean cancellationRequested() {
<span class="nc bnc" id="L214" title="All 4 branches missed.">                        return m == 0 || downstream.cancellationRequested();</span>
                    }
                };
            }
        };
    }

    /**
     * Appends a &quot;slice&quot; operation to the provided IntStream.  The slice
     * operation may be may be skip-only, limit-only, or skip-and-limit.
     *
     * @param upstream An IntStream
     * @param skip The number of elements to skip.  Must be &gt;= 0.
     * @param limit The maximum size of the resulting stream, or -1 if no limit
     *        is to be imposed
     */
    public static IntStream makeInt(AbstractPipeline&lt;?, Integer, ?&gt; upstream,
                                    long skip, long limit) {
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">        if (skip &lt; 0)</span>
<span class="nc" id="L233">            throw new IllegalArgumentException(&quot;Skip must be non-negative: &quot; + skip);</span>

<span class="fc" id="L235">        return new IntPipeline.StatefulOp&lt;Integer&gt;(upstream, StreamShape.INT_VALUE,</span>
<span class="fc" id="L236">                                                   flags(limit)) {</span>
            Spliterator.OfInt unorderedSkipLimitSpliterator(
                    Spliterator.OfInt s, long skip, long limit, long sizeIfKnown) {
<span class="nc bnc" id="L239" title="All 2 branches missed.">                if (skip &lt;= sizeIfKnown) {</span>
                    // Use just the limit if the number of elements
                    // to skip is &lt;= the known pipeline size
<span class="nc bnc" id="L242" title="All 2 branches missed.">                    limit = limit &gt;= 0 ? Math.min(limit, sizeIfKnown - skip) : sizeIfKnown - skip;</span>
<span class="nc" id="L243">                    skip = 0;</span>
                }
<span class="nc" id="L245">                return new StreamSpliterators.UnorderedSliceSpliterator.OfInt(s, skip, limit);</span>
            }

            @Override
            &lt;P_IN&gt; Spliterator&lt;Integer&gt; opEvaluateParallelLazy(PipelineHelper&lt;Integer&gt; helper,
                                                               Spliterator&lt;P_IN&gt; spliterator) {
<span class="nc" id="L251">                long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">                if (size &gt; 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
<span class="nc" id="L253">                    return new StreamSpliterators.SliceSpliterator.OfInt(</span>
<span class="nc" id="L254">                            (Spliterator.OfInt) helper.wrapSpliterator(spliterator),</span>
                            skip,
<span class="nc" id="L256">                            calcSliceFence(skip, limit));</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">                } else if (!StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L258">                    return unorderedSkipLimitSpliterator(</span>
<span class="nc" id="L259">                            (Spliterator.OfInt) helper.wrapSpliterator(spliterator),</span>
                            skip, limit, size);
                }
                else {
<span class="nc" id="L263">                    return new SliceTask&lt;&gt;(this, helper, spliterator, Integer[]::new, skip, limit).</span>
<span class="nc" id="L264">                            invoke().spliterator();</span>
                }
            }

            @Override
            &lt;P_IN&gt; Node&lt;Integer&gt; opEvaluateParallel(PipelineHelper&lt;Integer&gt; helper,
                                                    Spliterator&lt;P_IN&gt; spliterator,
                                                    IntFunction&lt;Integer[]&gt; generator) {
<span class="fc" id="L272">                long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="pc bpc" id="L273" title="3 of 4 branches missed.">                if (size &gt; 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
                    // Because the pipeline is SIZED the slice spliterator
                    // can be created from the source, this requires matching
                    // to shape of the source, and is potentially more efficient
                    // than creating the slice spliterator from the pipeline
                    // wrapping spliterator
<span class="nc" id="L279">                    Spliterator&lt;P_IN&gt; s = sliceSpliterator(helper.getSourceShape(), spliterator, skip, limit);</span>
<span class="nc" id="L280">                    return Nodes.collectInt(helper, s, true);</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">                } else if (!StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L282">                    Spliterator.OfInt s =  unorderedSkipLimitSpliterator(</span>
<span class="nc" id="L283">                            (Spliterator.OfInt) helper.wrapSpliterator(spliterator),</span>
                            skip, limit, size);
                    // Collect using this pipeline, which is empty and therefore
                    // can be used with the pipeline wrapping spliterator
                    // Note that we cannot create a slice spliterator from
                    // the source spliterator if the pipeline is not SIZED
<span class="nc" id="L289">                    return Nodes.collectInt(this, s, true);</span>
                }
                else {
<span class="nc" id="L292">                    return new SliceTask&lt;&gt;(this, helper, spliterator, generator, skip, limit).</span>
<span class="nc" id="L293">                            invoke();</span>
                }
            }

            @Override
            Sink&lt;Integer&gt; opWrapSink(int flags, Sink&lt;Integer&gt; sink) {
<span class="fc" id="L299">                return new Sink.ChainedInt&lt;Integer&gt;(sink) {</span>
<span class="fc" id="L300">                    long n = skip;</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">                    long m = limit &gt;= 0 ? limit : Long.MAX_VALUE;</span>

                    @Override
                    public void begin(long size) {
<span class="nc" id="L305">                        downstream.begin(calcSize(size, skip, m));</span>
<span class="nc" id="L306">                    }</span>

                    @Override
                    public void accept(int t) {
<span class="nc bnc" id="L310" title="All 2 branches missed.">                        if (n == 0) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">                            if (m &gt; 0) {</span>
<span class="nc" id="L312">                                m--;</span>
<span class="nc" id="L313">                                downstream.accept(t);</span>
                            }
                        }
                        else {
<span class="nc" id="L317">                            n--;</span>
                        }
<span class="nc" id="L319">                    }</span>

                    @Override
                    public boolean cancellationRequested() {
<span class="nc bnc" id="L323" title="All 4 branches missed.">                        return m == 0 || downstream.cancellationRequested();</span>
                    }
                };
            }
        };
    }

    /**
     * Appends a &quot;slice&quot; operation to the provided LongStream.  The slice
     * operation may be may be skip-only, limit-only, or skip-and-limit.
     *
     * @param upstream A LongStream
     * @param skip The number of elements to skip.  Must be &gt;= 0.
     * @param limit The maximum size of the resulting stream, or -1 if no limit
     *        is to be imposed
     */
    public static LongStream makeLong(AbstractPipeline&lt;?, Long, ?&gt; upstream,
                                      long skip, long limit) {
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">        if (skip &lt; 0)</span>
<span class="nc" id="L342">            throw new IllegalArgumentException(&quot;Skip must be non-negative: &quot; + skip);</span>

<span class="fc" id="L344">        return new LongPipeline.StatefulOp&lt;Long&gt;(upstream, StreamShape.LONG_VALUE,</span>
<span class="fc" id="L345">                                                 flags(limit)) {</span>
            Spliterator.OfLong unorderedSkipLimitSpliterator(
                    Spliterator.OfLong s, long skip, long limit, long sizeIfKnown) {
<span class="nc bnc" id="L348" title="All 2 branches missed.">                if (skip &lt;= sizeIfKnown) {</span>
                    // Use just the limit if the number of elements
                    // to skip is &lt;= the known pipeline size
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    limit = limit &gt;= 0 ? Math.min(limit, sizeIfKnown - skip) : sizeIfKnown - skip;</span>
<span class="nc" id="L352">                    skip = 0;</span>
                }
<span class="nc" id="L354">                return new StreamSpliterators.UnorderedSliceSpliterator.OfLong(s, skip, limit);</span>
            }

            @Override
            &lt;P_IN&gt; Spliterator&lt;Long&gt; opEvaluateParallelLazy(PipelineHelper&lt;Long&gt; helper,
                                                            Spliterator&lt;P_IN&gt; spliterator) {
<span class="nc" id="L360">                long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="nc bnc" id="L361" title="All 4 branches missed.">                if (size &gt; 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
<span class="nc" id="L362">                    return new StreamSpliterators.SliceSpliterator.OfLong(</span>
<span class="nc" id="L363">                            (Spliterator.OfLong) helper.wrapSpliterator(spliterator),</span>
                            skip,
<span class="nc" id="L365">                            calcSliceFence(skip, limit));</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                } else if (!StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L367">                    return unorderedSkipLimitSpliterator(</span>
<span class="nc" id="L368">                            (Spliterator.OfLong) helper.wrapSpliterator(spliterator),</span>
                            skip, limit, size);
                }
                else {
<span class="nc" id="L372">                    return new SliceTask&lt;&gt;(this, helper, spliterator, Long[]::new, skip, limit).</span>
<span class="nc" id="L373">                            invoke().spliterator();</span>
                }
            }

            @Override
            &lt;P_IN&gt; Node&lt;Long&gt; opEvaluateParallel(PipelineHelper&lt;Long&gt; helper,
                                                 Spliterator&lt;P_IN&gt; spliterator,
                                                 IntFunction&lt;Long[]&gt; generator) {
<span class="nc" id="L381">                long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="nc bnc" id="L382" title="All 4 branches missed.">                if (size &gt; 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
                    // Because the pipeline is SIZED the slice spliterator
                    // can be created from the source, this requires matching
                    // to shape of the source, and is potentially more efficient
                    // than creating the slice spliterator from the pipeline
                    // wrapping spliterator
<span class="nc" id="L388">                    Spliterator&lt;P_IN&gt; s = sliceSpliterator(helper.getSourceShape(), spliterator, skip, limit);</span>
<span class="nc" id="L389">                    return Nodes.collectLong(helper, s, true);</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                } else if (!StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L391">                    Spliterator.OfLong s =  unorderedSkipLimitSpliterator(</span>
<span class="nc" id="L392">                            (Spliterator.OfLong) helper.wrapSpliterator(spliterator),</span>
                            skip, limit, size);
                    // Collect using this pipeline, which is empty and therefore
                    // can be used with the pipeline wrapping spliterator
                    // Note that we cannot create a slice spliterator from
                    // the source spliterator if the pipeline is not SIZED
<span class="nc" id="L398">                    return Nodes.collectLong(this, s, true);</span>
                }
                else {
<span class="nc" id="L401">                    return new SliceTask&lt;&gt;(this, helper, spliterator, generator, skip, limit).</span>
<span class="nc" id="L402">                            invoke();</span>
                }
            }

            @Override
            Sink&lt;Long&gt; opWrapSink(int flags, Sink&lt;Long&gt; sink) {
<span class="fc" id="L408">                return new Sink.ChainedLong&lt;Long&gt;(sink) {</span>
<span class="fc" id="L409">                    long n = skip;</span>
<span class="pc bpc" id="L410" title="1 of 2 branches missed.">                    long m = limit &gt;= 0 ? limit : Long.MAX_VALUE;</span>

                    @Override
                    public void begin(long size) {
<span class="nc" id="L414">                        downstream.begin(calcSize(size, skip, m));</span>
<span class="nc" id="L415">                    }</span>

                    @Override
                    public void accept(long t) {
<span class="nc bnc" id="L419" title="All 2 branches missed.">                        if (n == 0) {</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                            if (m &gt; 0) {</span>
<span class="nc" id="L421">                                m--;</span>
<span class="nc" id="L422">                                downstream.accept(t);</span>
                            }
                        }
                        else {
<span class="nc" id="L426">                            n--;</span>
                        }
<span class="nc" id="L428">                    }</span>

                    @Override
                    public boolean cancellationRequested() {
<span class="nc bnc" id="L432" title="All 4 branches missed.">                        return m == 0 || downstream.cancellationRequested();</span>
                    }
                };
            }
        };
    }

    /**
     * Appends a &quot;slice&quot; operation to the provided DoubleStream.  The slice
     * operation may be may be skip-only, limit-only, or skip-and-limit.
     *
     * @param upstream A DoubleStream
     * @param skip The number of elements to skip.  Must be &gt;= 0.
     * @param limit The maximum size of the resulting stream, or -1 if no limit
     *        is to be imposed
     */
    public static DoubleStream makeDouble(AbstractPipeline&lt;?, Double, ?&gt; upstream,
                                          long skip, long limit) {
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        if (skip &lt; 0)</span>
<span class="nc" id="L451">            throw new IllegalArgumentException(&quot;Skip must be non-negative: &quot; + skip);</span>

<span class="fc" id="L453">        return new DoublePipeline.StatefulOp&lt;Double&gt;(upstream, StreamShape.DOUBLE_VALUE,</span>
<span class="fc" id="L454">                                                     flags(limit)) {</span>
            Spliterator.OfDouble unorderedSkipLimitSpliterator(
                    Spliterator.OfDouble s, long skip, long limit, long sizeIfKnown) {
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (skip &lt;= sizeIfKnown) {</span>
                    // Use just the limit if the number of elements
                    // to skip is &lt;= the known pipeline size
<span class="nc bnc" id="L460" title="All 2 branches missed.">                    limit = limit &gt;= 0 ? Math.min(limit, sizeIfKnown - skip) : sizeIfKnown - skip;</span>
<span class="nc" id="L461">                    skip = 0;</span>
                }
<span class="nc" id="L463">                return new StreamSpliterators.UnorderedSliceSpliterator.OfDouble(s, skip, limit);</span>
            }

            @Override
            &lt;P_IN&gt; Spliterator&lt;Double&gt; opEvaluateParallelLazy(PipelineHelper&lt;Double&gt; helper,
                                                              Spliterator&lt;P_IN&gt; spliterator) {
<span class="nc" id="L469">                long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="nc bnc" id="L470" title="All 4 branches missed.">                if (size &gt; 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
<span class="nc" id="L471">                    return new StreamSpliterators.SliceSpliterator.OfDouble(</span>
<span class="nc" id="L472">                            (Spliterator.OfDouble) helper.wrapSpliterator(spliterator),</span>
                            skip,
<span class="nc" id="L474">                            calcSliceFence(skip, limit));</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">                } else if (!StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L476">                    return unorderedSkipLimitSpliterator(</span>
<span class="nc" id="L477">                            (Spliterator.OfDouble) helper.wrapSpliterator(spliterator),</span>
                            skip, limit, size);
                }
                else {
<span class="nc" id="L481">                    return new SliceTask&lt;&gt;(this, helper, spliterator, Double[]::new, skip, limit).</span>
<span class="nc" id="L482">                            invoke().spliterator();</span>
                }
            }

            @Override
            &lt;P_IN&gt; Node&lt;Double&gt; opEvaluateParallel(PipelineHelper&lt;Double&gt; helper,
                                                   Spliterator&lt;P_IN&gt; spliterator,
                                                   IntFunction&lt;Double[]&gt; generator) {
<span class="nc" id="L490">                long size = helper.exactOutputSizeIfKnown(spliterator);</span>
<span class="nc bnc" id="L491" title="All 4 branches missed.">                if (size &gt; 0 &amp;&amp; spliterator.hasCharacteristics(Spliterator.SUBSIZED)) {</span>
                    // Because the pipeline is SIZED the slice spliterator
                    // can be created from the source, this requires matching
                    // to shape of the source, and is potentially more efficient
                    // than creating the slice spliterator from the pipeline
                    // wrapping spliterator
<span class="nc" id="L497">                    Spliterator&lt;P_IN&gt; s = sliceSpliterator(helper.getSourceShape(), spliterator, skip, limit);</span>
<span class="nc" id="L498">                    return Nodes.collectDouble(helper, s, true);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                } else if (!StreamOpFlag.ORDERED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L500">                    Spliterator.OfDouble s =  unorderedSkipLimitSpliterator(</span>
<span class="nc" id="L501">                            (Spliterator.OfDouble) helper.wrapSpliterator(spliterator),</span>
                            skip, limit, size);
                    // Collect using this pipeline, which is empty and therefore
                    // can be used with the pipeline wrapping spliterator
                    // Note that we cannot create a slice spliterator from
                    // the source spliterator if the pipeline is not SIZED
<span class="nc" id="L507">                    return Nodes.collectDouble(this, s, true);</span>
                }
                else {
<span class="nc" id="L510">                    return new SliceTask&lt;&gt;(this, helper, spliterator, generator, skip, limit).</span>
<span class="nc" id="L511">                            invoke();</span>
                }
            }

            @Override
            Sink&lt;Double&gt; opWrapSink(int flags, Sink&lt;Double&gt; sink) {
<span class="fc" id="L517">                return new Sink.ChainedDouble&lt;Double&gt;(sink) {</span>
<span class="fc" id="L518">                    long n = skip;</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">                    long m = limit &gt;= 0 ? limit : Long.MAX_VALUE;</span>

                    @Override
                    public void begin(long size) {
<span class="nc" id="L523">                        downstream.begin(calcSize(size, skip, m));</span>
<span class="nc" id="L524">                    }</span>

                    @Override
                    public void accept(double t) {
<span class="nc bnc" id="L528" title="All 2 branches missed.">                        if (n == 0) {</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">                            if (m &gt; 0) {</span>
<span class="nc" id="L530">                                m--;</span>
<span class="nc" id="L531">                                downstream.accept(t);</span>
                            }
                        }
                        else {
<span class="nc" id="L535">                            n--;</span>
                        }
<span class="nc" id="L537">                    }</span>

                    @Override
                    public boolean cancellationRequested() {
<span class="nc bnc" id="L541" title="All 4 branches missed.">                        return m == 0 || downstream.cancellationRequested();</span>
                    }
                };
            }
        };
    }

    private static int flags(long limit) {
<span class="pc bpc" id="L549" title="1 of 2 branches missed.">        return StreamOpFlag.NOT_SIZED | ((limit != -1) ? StreamOpFlag.IS_SHORT_CIRCUIT : 0);</span>
    }

    /**
     * {@code ForkJoinTask} implementing slice computation.
     *
     * @param &lt;P_IN&gt; Input element type to the stream pipeline
     * @param &lt;P_OUT&gt; Output element type from the stream pipeline
     */
    @SuppressWarnings(&quot;serial&quot;)
    private static final class SliceTask&lt;P_IN, P_OUT&gt;
            extends AbstractShortCircuitTask&lt;P_IN, P_OUT, Node&lt;P_OUT&gt;, SliceTask&lt;P_IN, P_OUT&gt;&gt; {
        private final AbstractPipeline&lt;P_OUT, P_OUT, ?&gt; op;
        private final IntFunction&lt;P_OUT[]&gt; generator;
        private final long targetOffset, targetSize;
        private long thisNodeSize;

        private volatile boolean completed;

        SliceTask(AbstractPipeline&lt;P_OUT, P_OUT, ?&gt; op,
                  PipelineHelper&lt;P_OUT&gt; helper,
                  Spliterator&lt;P_IN&gt; spliterator,
                  IntFunction&lt;P_OUT[]&gt; generator,
                  long offset, long size) {
<span class="fc" id="L573">            super(helper, spliterator);</span>
<span class="fc" id="L574">            this.op = op;</span>
<span class="fc" id="L575">            this.generator = generator;</span>
<span class="fc" id="L576">            this.targetOffset = offset;</span>
<span class="fc" id="L577">            this.targetSize = size;</span>
<span class="fc" id="L578">        }</span>

        SliceTask(SliceTask&lt;P_IN, P_OUT&gt; parent, Spliterator&lt;P_IN&gt; spliterator) {
<span class="nc" id="L581">            super(parent, spliterator);</span>
<span class="nc" id="L582">            this.op = parent.op;</span>
<span class="nc" id="L583">            this.generator = parent.generator;</span>
<span class="nc" id="L584">            this.targetOffset = parent.targetOffset;</span>
<span class="nc" id="L585">            this.targetSize = parent.targetSize;</span>
<span class="nc" id="L586">        }</span>

        @Override
        protected SliceTask&lt;P_IN, P_OUT&gt; makeChild(Spliterator&lt;P_IN&gt; spliterator) {
<span class="nc" id="L590">            return new SliceTask&lt;&gt;(this, spliterator);</span>
        }

        @Override
        protected final Node&lt;P_OUT&gt; getEmptyResult() {
<span class="nc" id="L595">            return Nodes.emptyNode(op.getOutputShape());</span>
        }

        @Override
        protected final Node&lt;P_OUT&gt; doLeaf() {
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">            if (isRoot()) {</span>
<span class="pc bpc" id="L601" title="1 of 2 branches missed.">                long sizeIfKnown = StreamOpFlag.SIZED.isPreserved(op.sourceOrOpFlags)</span>
<span class="pc" id="L602">                                   ? op.exactOutputSizeIfKnown(spliterator)</span>
                                   : -1;
<span class="nc" id="L604">                final Node.Builder&lt;P_OUT&gt; nb = op.makeNodeBuilder(sizeIfKnown, generator);</span>
<span class="nc" id="L605">                Sink&lt;P_OUT&gt; opSink = op.opWrapSink(helper.getStreamAndOpFlags(), nb);</span>
<span class="nc" id="L606">                helper.copyIntoWithCancel(helper.wrapSink(opSink), spliterator);</span>
                // There is no need to truncate since the op performs the
                // skipping and limiting of elements
<span class="nc" id="L609">                return nb.build();</span>
            }
            else {
<span class="nc" id="L612">                Node&lt;P_OUT&gt; node = helper.wrapAndCopyInto(helper.makeNodeBuilder(-1, generator),</span>
<span class="nc" id="L613">                                                          spliterator).build();</span>
<span class="nc" id="L614">                thisNodeSize = node.count();</span>
<span class="nc" id="L615">                completed = true;</span>
<span class="nc" id="L616">                spliterator = null;</span>
<span class="nc" id="L617">                return node;</span>
            }
        }

        @Override
        public final void onCompletion(CountedCompleter&lt;?&gt; caller) {
<span class="nc bnc" id="L623" title="All 2 branches missed.">            if (!isLeaf()) {</span>
                Node&lt;P_OUT&gt; result;
<span class="nc" id="L625">                thisNodeSize = leftChild.thisNodeSize + rightChild.thisNodeSize;</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                if (canceled) {</span>
<span class="nc" id="L627">                    thisNodeSize = 0;</span>
<span class="nc" id="L628">                    result = getEmptyResult();</span>
                }
<span class="nc bnc" id="L630" title="All 2 branches missed.">                else if (thisNodeSize == 0)</span>
<span class="nc" id="L631">                    result = getEmptyResult();</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">                else if (leftChild.thisNodeSize == 0)</span>
<span class="nc" id="L633">                    result = rightChild.getLocalResult();</span>
                else {
<span class="nc" id="L635">                    result = Nodes.conc(op.getOutputShape(),</span>
<span class="nc" id="L636">                                        leftChild.getLocalResult(), rightChild.getLocalResult());</span>
                }
<span class="nc bnc" id="L638" title="All 2 branches missed.">                setLocalResult(isRoot() ? doTruncate(result) : result);</span>
<span class="nc" id="L639">                completed = true;</span>
            }
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (targetSize &gt;= 0</span>
<span class="nc bnc" id="L642" title="All 2 branches missed.">                &amp;&amp; !isRoot()</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                &amp;&amp; isLeftCompleted(targetOffset + targetSize))</span>
<span class="nc" id="L644">                    cancelLaterNodes();</span>

<span class="nc" id="L646">            super.onCompletion(caller);</span>
<span class="nc" id="L647">        }</span>

        @Override
        protected void cancel() {
<span class="nc" id="L651">            super.cancel();</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">            if (completed)</span>
<span class="nc" id="L653">                setLocalResult(getEmptyResult());</span>
<span class="nc" id="L654">        }</span>

        private Node&lt;P_OUT&gt; doTruncate(Node&lt;P_OUT&gt; input) {
<span class="nc bnc" id="L657" title="All 2 branches missed.">            long to = targetSize &gt;= 0 ? Math.min(input.count(), targetOffset + targetSize) : thisNodeSize;</span>
<span class="nc" id="L658">            return input.truncate(targetOffset, to, generator);</span>
        }

        /**
         * Determine if the number of completed elements in this node and nodes
         * to the left of this node is greater than or equal to the target size.
         *
         * @param target the target size
         * @return true if the number of elements is greater than or equal to
         *         the target size, otherwise false.
         */
        private boolean isLeftCompleted(long target) {
<span class="nc bnc" id="L670" title="All 2 branches missed.">            long size = completed ? thisNodeSize : completedSize(target);</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">            if (size &gt;= target)</span>
<span class="nc" id="L672">                return true;</span>
<span class="nc" id="L673">            for (SliceTask&lt;P_IN, P_OUT&gt; parent = getParent(), node = this;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                 parent != null;</span>
<span class="nc" id="L675">                 node = parent, parent = parent.getParent()) {</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">                if (node == parent.rightChild) {</span>
<span class="nc" id="L677">                    SliceTask&lt;P_IN, P_OUT&gt; left = parent.leftChild;</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">                    if (left != null) {</span>
<span class="nc" id="L679">                        size += left.completedSize(target);</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                        if (size &gt;= target)</span>
<span class="nc" id="L681">                            return true;</span>
                    }
                }
            }
<span class="nc bnc" id="L685" title="All 2 branches missed.">            return size &gt;= target;</span>
        }

        /**
         * Compute the number of completed elements in this node.
         * &lt;p&gt;
         * Computation terminates if all nodes have been processed or the
         * number of completed elements is greater than or equal to the target
         * size.
         *
         * @param target the target size
         * @return return the number of completed elements
         */
        private long completedSize(long target) {
<span class="nc bnc" id="L699" title="All 2 branches missed.">            if (completed)</span>
<span class="nc" id="L700">                return thisNodeSize;</span>
            else {
<span class="nc" id="L702">                SliceTask&lt;P_IN, P_OUT&gt; left = leftChild;</span>
<span class="nc" id="L703">                SliceTask&lt;P_IN, P_OUT&gt; right = rightChild;</span>
<span class="nc bnc" id="L704" title="All 4 branches missed.">                if (left == null || right == null) {</span>
                    // must be completed
<span class="nc" id="L706">                    return thisNodeSize;</span>
                }
                else {
<span class="nc" id="L709">                    long leftSize = left.completedSize(target);</span>
<span class="nc bnc" id="L710" title="All 2 branches missed.">                    return (leftSize &gt;= target) ? leftSize : leftSize + right.completedSize(target);</span>
                }
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>