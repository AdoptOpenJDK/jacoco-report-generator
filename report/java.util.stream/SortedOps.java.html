<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SortedOps.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.stream</a> &gt; <span class="el_source">SortedOps.java</span></div><h1>SortedOps.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util.stream;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Objects;
import java.util.Spliterator;
import java.util.concurrent.ForkJoinTask;
import java.util.function.IntFunction;


/**
 * Factory methods for transforming streams into sorted streams.
 *
 * @since 1.8
 */
final class SortedOps {

<span class="nc" id="L43">    private SortedOps() { }</span>

    /**
     * Appends a &quot;sorted&quot; operation to the provided stream.
     *
     * @param &lt;T&gt; the type of both input and output elements
     * @param upstream a reference stream with element type T
     */
    static &lt;T&gt; Stream&lt;T&gt; makeRef(AbstractPipeline&lt;?, T, ?&gt; upstream) {
<span class="nc" id="L52">        return new OfRef&lt;&gt;(upstream);</span>
    }

    /**
     * Appends a &quot;sorted&quot; operation to the provided stream.
     *
     * @param &lt;T&gt; the type of both input and output elements
     * @param upstream a reference stream with element type T
     * @param comparator the comparator to order elements by
     */
    static &lt;T&gt; Stream&lt;T&gt; makeRef(AbstractPipeline&lt;?, T, ?&gt; upstream,
                                Comparator&lt;? super T&gt; comparator) {
<span class="nc" id="L64">        return new OfRef&lt;&gt;(upstream, comparator);</span>
    }

    /**
     * Appends a &quot;sorted&quot; operation to the provided stream.
     *
     * @param &lt;T&gt; the type of both input and output elements
     * @param upstream a reference stream with element type T
     */
    static &lt;T&gt; IntStream makeInt(AbstractPipeline&lt;?, Integer, ?&gt; upstream) {
<span class="fc" id="L74">        return new OfInt(upstream);</span>
    }

    /**
     * Appends a &quot;sorted&quot; operation to the provided stream.
     *
     * @param &lt;T&gt; the type of both input and output elements
     * @param upstream a reference stream with element type T
     */
    static &lt;T&gt; LongStream makeLong(AbstractPipeline&lt;?, Long, ?&gt; upstream) {
<span class="fc" id="L84">        return new OfLong(upstream);</span>
    }

    /**
     * Appends a &quot;sorted&quot; operation to the provided stream.
     *
     * @param &lt;T&gt; the type of both input and output elements
     * @param upstream a reference stream with element type T
     */
    static &lt;T&gt; DoubleStream makeDouble(AbstractPipeline&lt;?, Double, ?&gt; upstream) {
<span class="fc" id="L94">        return new OfDouble(upstream);</span>
    }

    /**
     * Specialized subtype for sorting reference streams
     */
    private static final class OfRef&lt;T&gt; extends ReferencePipeline.StatefulOp&lt;T, T&gt; {
        /**
         * Comparator used for sorting
         */
        private final boolean isNaturalSort;
        private final Comparator&lt;? super T&gt; comparator;

        /**
         * Sort using natural order of {@literal &lt;T&gt;} which must be
         * {@code Comparable}.
         */
        OfRef(AbstractPipeline&lt;?, T, ?&gt; upstream) {
<span class="nc" id="L112">            super(upstream, StreamShape.REFERENCE,</span>
                  StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);
<span class="nc" id="L114">            this.isNaturalSort = true;</span>
            // Will throw CCE when we try to sort if T is not Comparable
<span class="nc" id="L116">            this.comparator = (Comparator&lt;? super T&gt;) Comparator.naturalOrder();</span>
<span class="nc" id="L117">        }</span>

        /**
         * Sort using the provided comparator.
         *
         * @param comparator The comparator to be used to evaluate ordering.
         */
        OfRef(AbstractPipeline&lt;?, T, ?&gt; upstream, Comparator&lt;? super T&gt; comparator) {
<span class="nc" id="L125">            super(upstream, StreamShape.REFERENCE,</span>
                  StreamOpFlag.IS_ORDERED | StreamOpFlag.NOT_SORTED);
<span class="nc" id="L127">            this.isNaturalSort = false;</span>
<span class="nc" id="L128">            this.comparator = Objects.requireNonNull(comparator);</span>
<span class="nc" id="L129">        }</span>

        @Override
        public Sink&lt;T&gt; opWrapSink(int flags, Sink&lt;T&gt; sink) {
<span class="nc" id="L133">            Objects.requireNonNull(sink);</span>

            // If the input is already naturally sorted and this operation
            // also naturally sorted then this is a no-op
<span class="nc bnc" id="L137" title="All 4 branches missed.">            if (StreamOpFlag.SORTED.isKnown(flags) &amp;&amp; isNaturalSort)</span>
<span class="nc" id="L138">                return sink;</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            else if (StreamOpFlag.SIZED.isKnown(flags))</span>
<span class="nc" id="L140">                return new SizedRefSortingSink&lt;&gt;(sink, comparator);</span>
            else
<span class="nc" id="L142">                return new RefSortingSink&lt;&gt;(sink, comparator);</span>
        }

        @Override
        public &lt;P_IN&gt; Node&lt;T&gt; opEvaluateParallel(PipelineHelper&lt;T&gt; helper,
                                                 Spliterator&lt;P_IN&gt; spliterator,
                                                 IntFunction&lt;T[]&gt; generator) {
            // If the input is already naturally sorted and this operation
            // naturally sorts then collect the output
<span class="nc bnc" id="L151" title="All 4 branches missed.">            if (StreamOpFlag.SORTED.isKnown(helper.getStreamAndOpFlags()) &amp;&amp; isNaturalSort) {</span>
<span class="nc" id="L152">                return helper.evaluate(spliterator, false, generator);</span>
            }
            else {
                // @@@ Weak two-pass parallel implementation; parallel collect, parallel sort
<span class="nc" id="L156">                T[] flattenedData = helper.evaluate(spliterator, true, generator).asArray(generator);</span>
<span class="nc" id="L157">                Arrays.parallelSort(flattenedData, comparator);</span>
<span class="nc" id="L158">                return Nodes.node(flattenedData);</span>
            }
        }
    }

    /**
     * Specialized subtype for sorting int streams.
     */
    private static final class OfInt extends IntPipeline.StatefulOp&lt;Integer&gt; {
        OfInt(AbstractPipeline&lt;?, Integer, ?&gt; upstream) {
<span class="fc" id="L168">            super(upstream, StreamShape.INT_VALUE,</span>
                  StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);
<span class="fc" id="L170">        }</span>

        @Override
        public Sink&lt;Integer&gt; opWrapSink(int flags, Sink sink) {
<span class="fc" id="L174">            Objects.requireNonNull(sink);</span>

<span class="fc bfc" id="L176" title="All 2 branches covered.">            if (StreamOpFlag.SORTED.isKnown(flags))</span>
<span class="fc" id="L177">                return sink;</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">            else if (StreamOpFlag.SIZED.isKnown(flags))</span>
<span class="fc" id="L179">                return new SizedIntSortingSink(sink);</span>
            else
<span class="fc" id="L181">                return new IntSortingSink(sink);</span>
        }

        @Override
        public &lt;P_IN&gt; Node&lt;Integer&gt; opEvaluateParallel(PipelineHelper&lt;Integer&gt; helper,
                                                       Spliterator&lt;P_IN&gt; spliterator,
                                                       IntFunction&lt;Integer[]&gt; generator) {
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (StreamOpFlag.SORTED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L189">                return helper.evaluate(spliterator, false, generator);</span>
            }
            else {
<span class="nc" id="L192">                Node.OfInt n = (Node.OfInt) helper.evaluate(spliterator, true, generator);</span>

<span class="nc" id="L194">                int[] content = n.asPrimitiveArray();</span>
<span class="nc" id="L195">                Arrays.parallelSort(content);</span>

<span class="nc" id="L197">                return Nodes.node(content);</span>
            }
        }
    }

    /**
     * Specialized subtype for sorting long streams.
     */
    private static final class OfLong extends LongPipeline.StatefulOp&lt;Long&gt; {
        OfLong(AbstractPipeline&lt;?, Long, ?&gt; upstream) {
<span class="fc" id="L207">            super(upstream, StreamShape.LONG_VALUE,</span>
                  StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);
<span class="fc" id="L209">        }</span>

        @Override
        public Sink&lt;Long&gt; opWrapSink(int flags, Sink&lt;Long&gt; sink) {
<span class="fc" id="L213">            Objects.requireNonNull(sink);</span>

<span class="fc bfc" id="L215" title="All 2 branches covered.">            if (StreamOpFlag.SORTED.isKnown(flags))</span>
<span class="fc" id="L216">                return sink;</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">            else if (StreamOpFlag.SIZED.isKnown(flags))</span>
<span class="fc" id="L218">                return new SizedLongSortingSink(sink);</span>
            else
<span class="fc" id="L220">                return new LongSortingSink(sink);</span>
        }

        @Override
        public &lt;P_IN&gt; Node&lt;Long&gt; opEvaluateParallel(PipelineHelper&lt;Long&gt; helper,
                                                    Spliterator&lt;P_IN&gt; spliterator,
                                                    IntFunction&lt;Long[]&gt; generator) {
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (StreamOpFlag.SORTED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L228">                return helper.evaluate(spliterator, false, generator);</span>
            }
            else {
<span class="nc" id="L231">                Node.OfLong n = (Node.OfLong) helper.evaluate(spliterator, true, generator);</span>

<span class="nc" id="L233">                long[] content = n.asPrimitiveArray();</span>
<span class="nc" id="L234">                Arrays.parallelSort(content);</span>

<span class="nc" id="L236">                return Nodes.node(content);</span>
            }
        }
    }

    /**
     * Specialized subtype for sorting double streams.
     */
    private static final class OfDouble extends DoublePipeline.StatefulOp&lt;Double&gt; {
        OfDouble(AbstractPipeline&lt;?, Double, ?&gt; upstream) {
<span class="fc" id="L246">            super(upstream, StreamShape.DOUBLE_VALUE,</span>
                  StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);
<span class="fc" id="L248">        }</span>

        @Override
        public Sink&lt;Double&gt; opWrapSink(int flags, Sink&lt;Double&gt; sink) {
<span class="fc" id="L252">            Objects.requireNonNull(sink);</span>

<span class="fc bfc" id="L254" title="All 2 branches covered.">            if (StreamOpFlag.SORTED.isKnown(flags))</span>
<span class="fc" id="L255">                return sink;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            else if (StreamOpFlag.SIZED.isKnown(flags))</span>
<span class="fc" id="L257">                return new SizedDoubleSortingSink(sink);</span>
            else
<span class="fc" id="L259">                return new DoubleSortingSink(sink);</span>
        }

        @Override
        public &lt;P_IN&gt; Node&lt;Double&gt; opEvaluateParallel(PipelineHelper&lt;Double&gt; helper,
                                                      Spliterator&lt;P_IN&gt; spliterator,
                                                      IntFunction&lt;Double[]&gt; generator) {
<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (StreamOpFlag.SORTED.isKnown(helper.getStreamAndOpFlags())) {</span>
<span class="nc" id="L267">                return helper.evaluate(spliterator, false, generator);</span>
            }
            else {
<span class="nc" id="L270">                Node.OfDouble n = (Node.OfDouble) helper.evaluate(spliterator, true, generator);</span>

<span class="nc" id="L272">                double[] content = n.asPrimitiveArray();</span>
<span class="nc" id="L273">                Arrays.parallelSort(content);</span>

<span class="nc" id="L275">                return Nodes.node(content);</span>
            }
        }
    }

    /**
     * {@link Sink} for implementing sort on SIZED reference streams.
     */
    private static final class SizedRefSortingSink&lt;T&gt; extends Sink.ChainedReference&lt;T, T&gt; {
        private final Comparator&lt;? super T&gt; comparator;
        private T[] array;
        private int offset;

        SizedRefSortingSink(Sink&lt;? super T&gt; sink, Comparator&lt;? super T&gt; comparator) {
<span class="nc" id="L289">            super(sink);</span>
<span class="nc" id="L290">            this.comparator = comparator;</span>
<span class="nc" id="L291">        }</span>

        @Override
        public void begin(long size) {
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (size &gt;= Nodes.MAX_ARRAY_SIZE)</span>
<span class="nc" id="L296">                throw new IllegalArgumentException(Nodes.BAD_SIZE);</span>
<span class="nc" id="L297">            array = (T[]) new Object[(int) size];</span>
<span class="nc" id="L298">        }</span>

        @Override
        public void end() {
<span class="nc" id="L302">            Arrays.sort(array, 0, offset, comparator);</span>
<span class="nc" id="L303">            downstream.begin(offset);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">            for (int i = 0; i &lt; offset; i++)</span>
<span class="nc" id="L305">                downstream.accept(array[i]);</span>
<span class="nc" id="L306">            downstream.end();</span>
<span class="nc" id="L307">            array = null;</span>
<span class="nc" id="L308">        }</span>

        @Override
        public void accept(T t) {
<span class="nc" id="L312">            array[offset++] = t;</span>
<span class="nc" id="L313">        }</span>
    }

    /**
     * {@link Sink} for implementing sort on reference streams.
     */
    private static final class RefSortingSink&lt;T&gt; extends Sink.ChainedReference&lt;T, T&gt; {
        private final Comparator&lt;? super T&gt; comparator;
        private ArrayList&lt;T&gt; list;

        RefSortingSink(Sink&lt;? super T&gt; sink, Comparator&lt;? super T&gt; comparator) {
<span class="nc" id="L324">            super(sink);</span>
<span class="nc" id="L325">            this.comparator = comparator;</span>
<span class="nc" id="L326">        }</span>

        @Override
        public void begin(long size) {
<span class="nc bnc" id="L330" title="All 2 branches missed.">            if (size &gt;= Nodes.MAX_ARRAY_SIZE)</span>
<span class="nc" id="L331">                throw new IllegalArgumentException(Nodes.BAD_SIZE);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            list = (size &gt;= 0) ? new ArrayList&lt;T&gt;((int) size) : new ArrayList&lt;T&gt;();</span>
<span class="nc" id="L333">        }</span>

        @Override
        public void end() {
<span class="nc" id="L337">            list.sort(comparator);</span>
<span class="nc" id="L338">            downstream.begin(list.size());</span>
<span class="nc" id="L339">            list.forEach(downstream::accept);</span>
<span class="nc" id="L340">            downstream.end();</span>
<span class="nc" id="L341">            list = null;</span>
<span class="nc" id="L342">        }</span>

        @Override
        public void accept(T t) {
<span class="nc" id="L346">            list.add(t);</span>
<span class="nc" id="L347">        }</span>
    }

    /**
     * {@link Sink} for implementing sort on SIZED int streams.
     */
    private static final class SizedIntSortingSink extends Sink.ChainedInt&lt;Integer&gt; {
        private int[] array;
        private int offset;

        SizedIntSortingSink(Sink&lt;? super Integer&gt; downstream) {
<span class="fc" id="L358">            super(downstream);</span>
<span class="fc" id="L359">        }</span>

        @Override
        public void begin(long size) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if (size &gt;= Nodes.MAX_ARRAY_SIZE)</span>
<span class="nc" id="L364">                throw new IllegalArgumentException(Nodes.BAD_SIZE);</span>
<span class="nc" id="L365">            array = new int[(int) size];</span>
<span class="nc" id="L366">        }</span>

        @Override
        public void end() {
<span class="nc" id="L370">            Arrays.sort(array, 0, offset);</span>
<span class="nc" id="L371">            downstream.begin(offset);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            for (int i = 0; i &lt; offset; i++)</span>
<span class="nc" id="L373">                downstream.accept(array[i]);</span>
<span class="nc" id="L374">            downstream.end();</span>
<span class="nc" id="L375">            array = null;</span>
<span class="nc" id="L376">        }</span>

        @Override
        public void accept(int t) {
<span class="nc" id="L380">            array[offset++] = t;</span>
<span class="nc" id="L381">        }</span>
    }

    /**
     * {@link Sink} for implementing sort on int streams.
     */
    private static final class IntSortingSink extends Sink.ChainedInt&lt;Integer&gt; {
        private SpinedBuffer.OfInt b;

        IntSortingSink(Sink&lt;? super Integer&gt; sink) {
<span class="fc" id="L391">            super(sink);</span>
<span class="fc" id="L392">        }</span>

        @Override
        public void begin(long size) {
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (size &gt;= Nodes.MAX_ARRAY_SIZE)</span>
<span class="nc" id="L397">                throw new IllegalArgumentException(Nodes.BAD_SIZE);</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            b = (size &gt; 0) ? new SpinedBuffer.OfInt((int) size) : new SpinedBuffer.OfInt();</span>
<span class="nc" id="L399">        }</span>

        @Override
        public void end() {
<span class="nc" id="L403">            int[] ints = b.asPrimitiveArray();</span>
<span class="nc" id="L404">            Arrays.sort(ints);</span>
<span class="nc" id="L405">            downstream.begin(ints.length);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            for (int anInt : ints)</span>
<span class="nc" id="L407">                downstream.accept(anInt);</span>
<span class="nc" id="L408">            downstream.end();</span>
<span class="nc" id="L409">        }</span>

        @Override
        public void accept(int t) {
<span class="nc" id="L413">            b.accept(t);</span>
<span class="nc" id="L414">        }</span>
    }

    /**
     * {@link Sink} for implementing sort on SIZED long streams.
     */
    private static final class SizedLongSortingSink extends Sink.ChainedLong&lt;Long&gt; {
        private long[] array;
        private int offset;

        SizedLongSortingSink(Sink&lt;? super Long&gt; downstream) {
<span class="fc" id="L425">            super(downstream);</span>
<span class="fc" id="L426">        }</span>

        @Override
        public void begin(long size) {
<span class="nc bnc" id="L430" title="All 2 branches missed.">            if (size &gt;= Nodes.MAX_ARRAY_SIZE)</span>
<span class="nc" id="L431">                throw new IllegalArgumentException(Nodes.BAD_SIZE);</span>
<span class="nc" id="L432">            array = new long[(int) size];</span>
<span class="nc" id="L433">        }</span>

        @Override
        public void end() {
<span class="nc" id="L437">            Arrays.sort(array, 0, offset);</span>
<span class="nc" id="L438">            downstream.begin(offset);</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            for (int i = 0; i &lt; offset; i++)</span>
<span class="nc" id="L440">                downstream.accept(array[i]);</span>
<span class="nc" id="L441">            downstream.end();</span>
<span class="nc" id="L442">            array = null;</span>
<span class="nc" id="L443">        }</span>

        @Override
        public void accept(long t) {
<span class="nc" id="L447">            array[offset++] = t;</span>
<span class="nc" id="L448">        }</span>
    }

    /**
     * {@link Sink} for implementing sort on long streams.
     */
    private static final class LongSortingSink extends Sink.ChainedLong&lt;Long&gt; {
        private SpinedBuffer.OfLong b;

        LongSortingSink(Sink&lt;? super Long&gt; sink) {
<span class="fc" id="L458">            super(sink);</span>
<span class="fc" id="L459">        }</span>

        @Override
        public void begin(long size) {
<span class="nc bnc" id="L463" title="All 2 branches missed.">            if (size &gt;= Nodes.MAX_ARRAY_SIZE)</span>
<span class="nc" id="L464">                throw new IllegalArgumentException(Nodes.BAD_SIZE);</span>
<span class="nc bnc" id="L465" title="All 2 branches missed.">            b = (size &gt; 0) ? new SpinedBuffer.OfLong((int) size) : new SpinedBuffer.OfLong();</span>
<span class="nc" id="L466">        }</span>

        @Override
        public void end() {
<span class="nc" id="L470">            long[] longs = b.asPrimitiveArray();</span>
<span class="nc" id="L471">            Arrays.sort(longs);</span>
<span class="nc" id="L472">            downstream.begin(longs.length);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">            for (long aLong : longs)</span>
<span class="nc" id="L474">                downstream.accept(aLong);</span>
<span class="nc" id="L475">            downstream.end();</span>
<span class="nc" id="L476">        }</span>

        @Override
        public void accept(long t) {
<span class="nc" id="L480">            b.accept(t);</span>
<span class="nc" id="L481">        }</span>
    }

    /**
     * {@link Sink} for implementing sort on SIZED double streams.
     */
    private static final class SizedDoubleSortingSink extends Sink.ChainedDouble&lt;Double&gt; {
        private double[] array;
        private int offset;

        SizedDoubleSortingSink(Sink&lt;? super Double&gt; downstream) {
<span class="fc" id="L492">            super(downstream);</span>
<span class="fc" id="L493">        }</span>

        @Override
        public void begin(long size) {
<span class="nc bnc" id="L497" title="All 2 branches missed.">            if (size &gt;= Nodes.MAX_ARRAY_SIZE)</span>
<span class="nc" id="L498">                throw new IllegalArgumentException(Nodes.BAD_SIZE);</span>
<span class="nc" id="L499">            array = new double[(int) size];</span>
<span class="nc" id="L500">        }</span>

        @Override
        public void end() {
<span class="nc" id="L504">            Arrays.sort(array, 0, offset);</span>
<span class="nc" id="L505">            downstream.begin(offset);</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">            for (int i = 0; i &lt; offset; i++)</span>
<span class="nc" id="L507">                downstream.accept(array[i]);</span>
<span class="nc" id="L508">            downstream.end();</span>
<span class="nc" id="L509">            array = null;</span>
<span class="nc" id="L510">        }</span>

        @Override
        public void accept(double t) {
<span class="nc" id="L514">            array[offset++] = t;</span>
<span class="nc" id="L515">        }</span>
    }

    /**
     * {@link Sink} for implementing sort on double streams.
     */
    private static final class DoubleSortingSink extends Sink.ChainedDouble&lt;Double&gt; {
        private SpinedBuffer.OfDouble b;

        DoubleSortingSink(Sink&lt;? super Double&gt; sink) {
<span class="fc" id="L525">            super(sink);</span>
<span class="fc" id="L526">        }</span>

        @Override
        public void begin(long size) {
<span class="nc bnc" id="L530" title="All 2 branches missed.">            if (size &gt;= Nodes.MAX_ARRAY_SIZE)</span>
<span class="nc" id="L531">                throw new IllegalArgumentException(Nodes.BAD_SIZE);</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">            b = (size &gt; 0) ? new SpinedBuffer.OfDouble((int) size) : new SpinedBuffer.OfDouble();</span>
<span class="nc" id="L533">        }</span>

        @Override
        public void end() {
<span class="nc" id="L537">            double[] doubles = b.asPrimitiveArray();</span>
<span class="nc" id="L538">            Arrays.sort(doubles);</span>
<span class="nc" id="L539">            downstream.begin(doubles.length);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            for (double aDouble : doubles)</span>
<span class="nc" id="L541">                downstream.accept(aDouble);</span>
<span class="nc" id="L542">            downstream.end();</span>
<span class="nc" id="L543">        }</span>

        @Override
        public void accept(double t) {
<span class="nc" id="L547">            b.accept(t);</span>
<span class="nc" id="L548">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>