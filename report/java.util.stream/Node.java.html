<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Node.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.util.stream</a> &gt; <span class="el_source">Node.java</span></div><h1>Node.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package java.util.stream;

import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.function.DoubleConsumer;
import java.util.function.IntConsumer;
import java.util.function.IntFunction;
import java.util.function.LongConsumer;

/**
 * An immutable container for describing an ordered sequence of elements of some
 * type {@code T}.
 *
 * &lt;p&gt;A {@code Node} contains a fixed number of elements, which can be accessed
 * via the {@link #count}, {@link #spliterator}, {@link #forEach},
 * {@link #asArray}, or {@link #copyInto} methods.  A {@code Node} may have zero
 * or more child {@code Node}s; if it has no children (accessed via
 * {@link #getChildCount} and {@link #getChild(int)}, it is considered &lt;em&gt;flat
 * &lt;/em&gt; or a &lt;em&gt;leaf&lt;/em&gt;; if it has children, it is considered an
 * &lt;em&gt;internal&lt;/em&gt; node.  The size of an internal node is the sum of sizes of
 * its children.
 *
 * @apiNote
 * &lt;p&gt;A {@code Node} typically does not store the elements directly, but instead
 * mediates access to one or more existing (effectively immutable) data
 * structures such as a {@code Collection}, array, or a set of other
 * {@code Node}s.  Commonly {@code Node}s are formed into a tree whose shape
 * corresponds to the computation tree that produced the elements that are
 * contained in the leaf nodes.  The use of {@code Node} within the stream
 * framework is largely to avoid copying data unnecessarily during parallel
 * operations.
 *
 * @param &lt;T&gt; the type of elements.
 * @since 1.8
 */
interface Node&lt;T&gt; {

    /**
     * Returns a {@link Spliterator} describing the elements contained in this
     * {@code Node}.
     *
     * @return a {@code Spliterator} describing the elements contained in this
     *         {@code Node}
     */
    Spliterator&lt;T&gt; spliterator();

    /**
     * Traverses the elements of this node, and invoke the provided
     * {@code Consumer} with each element.  Elements are provided in encounter
     * order if the source for the {@code Node} has a defined encounter order.
     *
     * @param consumer a {@code Consumer} that is to be invoked with each
     *        element in this {@code Node}
     */
    void forEach(Consumer&lt;? super T&gt; consumer);

    /**
     * Returns the number of child nodes of this node.
     *
     * @implSpec The default implementation returns zero.
     *
     * @return the number of child nodes
     */
    default int getChildCount() {
<span class="fc" id="L89">        return 0;</span>
    }

    /**
     * Retrieves the child {@code Node} at a given index.
     *
     * @implSpec The default implementation always throws
     * {@code IndexOutOfBoundsException}.
     *
     * @param i the index to the child node
     * @return the child node
     * @throws IndexOutOfBoundsException if the index is less than 0 or greater
     *         than or equal to the number of child nodes
     */
    default Node&lt;T&gt; getChild(int i) {
<span class="nc" id="L104">        throw new IndexOutOfBoundsException();</span>
    }

    /**
     * Return a node describing a subsequence of the elements of this node,
     * starting at the given inclusive start offset and ending at the given
     * exclusive end offset.
     *
     * @param from The (inclusive) starting offset of elements to include, must
     *             be in range 0..count().
     * @param to The (exclusive) end offset of elements to include, must be
     *           in range 0..count().
     * @param generator A function to be used to create a new array, if needed,
     *                  for reference nodes.
     * @return the truncated node
     */
    default Node&lt;T&gt; truncate(long from, long to, IntFunction&lt;T[]&gt; generator) {
<span class="nc bnc" id="L121" title="All 4 branches missed.">        if (from == 0 &amp;&amp; to == count())</span>
<span class="nc" id="L122">            return this;</span>
<span class="nc" id="L123">        Spliterator&lt;T&gt; spliterator = spliterator();</span>
<span class="nc" id="L124">        long size = to - from;</span>
<span class="nc" id="L125">        Node.Builder&lt;T&gt; nodeBuilder = Nodes.builder(size, generator);</span>
<span class="nc" id="L126">        nodeBuilder.begin(size);</span>
<span class="nc bnc" id="L127" title="All 4 branches missed.">        for (int i = 0; i &lt; from &amp;&amp; spliterator.tryAdvance(e -&gt; { }); i++) { }</span>
<span class="nc bnc" id="L128" title="All 4 branches missed.">        for (int i = 0; (i &lt; size) &amp;&amp; spliterator.tryAdvance(nodeBuilder); i++) { }</span>
<span class="nc" id="L129">        nodeBuilder.end();</span>
<span class="nc" id="L130">        return nodeBuilder.build();</span>
    }

    /**
     * Provides an array view of the contents of this node.
     *
     * &lt;p&gt;Depending on the underlying implementation, this may return a
     * reference to an internal array rather than a copy.  Since the returned
     * array may be shared, the returned array should not be modified.  The
     * {@code generator} function may be consulted to create the array if a new
     * array needs to be created.
     *
     * @param generator a factory function which takes an integer parameter and
     *        returns a new, empty array of that size and of the appropriate
     *        array type
     * @return an array containing the contents of this {@code Node}
     */
    T[] asArray(IntFunction&lt;T[]&gt; generator);

    /**
     * Copies the content of this {@code Node} into an array, starting at a
     * given offset into the array.  It is the caller's responsibility to ensure
     * there is sufficient room in the array, otherwise unspecified behaviour
     * will occur if the array length is less than the number of elements
     * contained in this node.
     *
     * @param array the array into which to copy the contents of this
     *       {@code Node}
     * @param offset the starting offset within the array
     * @throws IndexOutOfBoundsException if copying would cause access of data
     *         outside array bounds
     * @throws NullPointerException if {@code array} is {@code null}
     */
    void copyInto(T[] array, int offset);

    /**
     * Gets the {@code StreamShape} associated with this {@code Node}.
     *
     * @implSpec The default in {@code Node} returns
     * {@code StreamShape.REFERENCE}
     *
     * @return the stream shape associated with this node
     */
    default StreamShape getShape() {
<span class="nc" id="L174">        return StreamShape.REFERENCE;</span>
    }

    /**
     * Returns the number of elements contained in this node.
     *
     * @return the number of elements contained in this node
     */
    long count();

    /**
     * A mutable builder for a {@code Node} that implements {@link Sink}, which
     * builds a flat node containing the elements that have been pushed to it.
     */
    interface Builder&lt;T&gt; extends Sink&lt;T&gt; {

        /**
         * Builds the node.  Should be called after all elements have been
         * pushed and signalled with an invocation of {@link Sink#end()}.
         *
         * @return the resulting {@code Node}
         */
        Node&lt;T&gt; build();

        /**
         * Specialized @{code Node.Builder} for int elements
         */
        interface OfInt extends Node.Builder&lt;Integer&gt;, Sink.OfInt {
            @Override
            Node.OfInt build();
        }

        /**
         * Specialized @{code Node.Builder} for long elements
         */
        interface OfLong extends Node.Builder&lt;Long&gt;, Sink.OfLong {
            @Override
            Node.OfLong build();
        }

        /**
         * Specialized @{code Node.Builder} for double elements
         */
        interface OfDouble extends Node.Builder&lt;Double&gt;, Sink.OfDouble {
            @Override
            Node.OfDouble build();
        }
    }

    public interface OfPrimitive&lt;T, T_CONS, T_ARR,
                                 T_SPLITR extends Spliterator.OfPrimitive&lt;T, T_CONS, T_SPLITR&gt;,
                                 T_NODE extends OfPrimitive&lt;T, T_CONS, T_ARR, T_SPLITR, T_NODE&gt;&gt;
            extends Node&lt;T&gt; {

        /**
         * {@inheritDoc}
         *
         * @return a {@link Spliterator.OfPrimitive} describing the elements of
         *         this node
         */
        @Override
        T_SPLITR spliterator();

        /**
         * Traverses the elements of this node, and invoke the provided
         * {@code action} with each element.
         *
         * @param action a consumer that is to be invoked with each
         *        element in this {@code Node.OfPrimitive}
         */
        @SuppressWarnings(&quot;overloads&quot;)
        void forEach(T_CONS action);

        @Override
        default T_NODE getChild(int i) {
<span class="nc" id="L249">            throw new IndexOutOfBoundsException();</span>
        }

        T_NODE truncate(long from, long to, IntFunction&lt;T[]&gt; generator);

        /**
         * {@inheritDoc}
         *
         * @implSpec the default implementation invokes the generator to create
         * an instance of a boxed primitive array with a length of
         * {@link #count()} and then invokes {@link #copyInto(T[], int)} with
         * that array at an offset of 0.
         */
        @Override
        default T[] asArray(IntFunction&lt;T[]&gt; generator) {
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (java.util.stream.Tripwire.ENABLED)</span>
<span class="nc" id="L265">                java.util.stream.Tripwire.trip(getClass(), &quot;{0} calling Node.OfPrimitive.asArray&quot;);</span>

<span class="nc" id="L267">            long size = count();</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">            if (size &gt;= Nodes.MAX_ARRAY_SIZE)</span>
<span class="nc" id="L269">                throw new IllegalArgumentException(Nodes.BAD_SIZE);</span>
<span class="nc" id="L270">            T[] boxed = generator.apply((int) count());</span>
<span class="nc" id="L271">            copyInto(boxed, 0);</span>
<span class="nc" id="L272">            return boxed;</span>
        }

        /**
         * Views this node as a primitive array.
         *
         * &lt;p&gt;Depending on the underlying implementation this may return a
         * reference to an internal array rather than a copy.  It is the callers
         * responsibility to decide if either this node or the array is utilized
         * as the primary reference for the data.&lt;/p&gt;
         *
         * @return an array containing the contents of this {@code Node}
         */
        T_ARR asPrimitiveArray();

        /**
         * Creates a new primitive array.
         *
         * @param count the length of the primitive array.
         * @return the new primitive array.
         */
        T_ARR newArray(int count);

        /**
         * Copies the content of this {@code Node} into a primitive array,
         * starting at a given offset into the array.  It is the caller's
         * responsibility to ensure there is sufficient room in the array.
         *
         * @param array the array into which to copy the contents of this
         *              {@code Node}
         * @param offset the starting offset within the array
         * @throws IndexOutOfBoundsException if copying would cause access of
         *         data outside array bounds
         * @throws NullPointerException if {@code array} is {@code null}
         */
        void copyInto(T_ARR array, int offset);
    }

    /**
     * Specialized {@code Node} for int elements
     */
    interface OfInt extends OfPrimitive&lt;Integer, IntConsumer, int[], Spliterator.OfInt, OfInt&gt; {

        /**
         * {@inheritDoc}
         *
         * @param consumer a {@code Consumer} that is to be invoked with each
         *        element in this {@code Node}.  If this is an
         *        {@code IntConsumer}, it is cast to {@code IntConsumer} so the
         *        elements may be processed without boxing.
         */
        @Override
        default void forEach(Consumer&lt;? super Integer&gt; consumer) {
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (consumer instanceof IntConsumer) {</span>
<span class="nc" id="L326">                forEach((IntConsumer) consumer);</span>
            }
            else {
<span class="nc bnc" id="L329" title="All 2 branches missed.">                if (Tripwire.ENABLED)</span>
<span class="nc" id="L330">                    Tripwire.trip(getClass(), &quot;{0} calling Node.OfInt.forEachRemaining(Consumer)&quot;);</span>
<span class="nc" id="L331">                spliterator().forEachRemaining(consumer);</span>
            }
<span class="nc" id="L333">        }</span>

        /**
         * {@inheritDoc}
         *
         * @implSpec the default implementation invokes {@link #asPrimitiveArray()} to
         * obtain an int[] array then and copies the elements from that int[]
         * array into the boxed Integer[] array.  This is not efficient and it
         * is recommended to invoke {@link #copyInto(Object, int)}.
         */
        @Override
        default void copyInto(Integer[] boxed, int offset) {
<span class="nc bnc" id="L345" title="All 2 branches missed.">            if (Tripwire.ENABLED)</span>
<span class="nc" id="L346">                Tripwire.trip(getClass(), &quot;{0} calling Node.OfInt.copyInto(Integer[], int)&quot;);</span>

<span class="nc" id="L348">            int[] array = asPrimitiveArray();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">            for (int i = 0; i &lt; array.length; i++) {</span>
<span class="nc" id="L350">                boxed[offset + i] = array[i];</span>
            }
<span class="nc" id="L352">        }</span>

        @Override
        default Node.OfInt truncate(long from, long to, IntFunction&lt;Integer[]&gt; generator) {
<span class="nc bnc" id="L356" title="All 4 branches missed.">            if (from == 0 &amp;&amp; to == count())</span>
<span class="nc" id="L357">                return this;</span>
<span class="nc" id="L358">            long size = to - from;</span>
<span class="nc" id="L359">            Spliterator.OfInt spliterator = spliterator();</span>
<span class="nc" id="L360">            Node.Builder.OfInt nodeBuilder = Nodes.intBuilder(size);</span>
<span class="nc" id="L361">            nodeBuilder.begin(size);</span>
<span class="nc bnc" id="L362" title="All 4 branches missed.">            for (int i = 0; i &lt; from &amp;&amp; spliterator.tryAdvance((IntConsumer) e -&gt; { }); i++) { }</span>
<span class="nc bnc" id="L363" title="All 4 branches missed.">            for (int i = 0; (i &lt; size) &amp;&amp; spliterator.tryAdvance((IntConsumer) nodeBuilder); i++) { }</span>
<span class="nc" id="L364">            nodeBuilder.end();</span>
<span class="nc" id="L365">            return nodeBuilder.build();</span>
        }

        @Override
        default int[] newArray(int count) {
<span class="nc" id="L370">            return new int[count];</span>
        }

        /**
         * {@inheritDoc}
         * @implSpec The default in {@code Node.OfInt} returns
         * {@code StreamShape.INT_VALUE}
         */
        default StreamShape getShape() {
<span class="nc" id="L379">            return StreamShape.INT_VALUE;</span>
        }
    }

    /**
     * Specialized {@code Node} for long elements
     */
    interface OfLong extends OfPrimitive&lt;Long, LongConsumer, long[], Spliterator.OfLong, OfLong&gt; {

        /**
         * {@inheritDoc}
         *
         * @param consumer A {@code Consumer} that is to be invoked with each
         *        element in this {@code Node}.  If this is an
         *        {@code LongConsumer}, it is cast to {@code LongConsumer} so
         *        the elements may be processed without boxing.
         */
        @Override
        default void forEach(Consumer&lt;? super Long&gt; consumer) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">            if (consumer instanceof LongConsumer) {</span>
<span class="nc" id="L399">                forEach((LongConsumer) consumer);</span>
            }
            else {
<span class="nc bnc" id="L402" title="All 2 branches missed.">                if (Tripwire.ENABLED)</span>
<span class="nc" id="L403">                    Tripwire.trip(getClass(), &quot;{0} calling Node.OfLong.forEachRemaining(Consumer)&quot;);</span>
<span class="nc" id="L404">                spliterator().forEachRemaining(consumer);</span>
            }
<span class="nc" id="L406">        }</span>

        /**
         * {@inheritDoc}
         *
         * @implSpec the default implementation invokes {@link #asPrimitiveArray()}
         * to obtain a long[] array then and copies the elements from that
         * long[] array into the boxed Long[] array.  This is not efficient and
         * it is recommended to invoke {@link #copyInto(Object, int)}.
         */
        @Override
        default void copyInto(Long[] boxed, int offset) {
<span class="nc bnc" id="L418" title="All 2 branches missed.">            if (Tripwire.ENABLED)</span>
<span class="nc" id="L419">                Tripwire.trip(getClass(), &quot;{0} calling Node.OfInt.copyInto(Long[], int)&quot;);</span>

<span class="nc" id="L421">            long[] array = asPrimitiveArray();</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            for (int i = 0; i &lt; array.length; i++) {</span>
<span class="nc" id="L423">                boxed[offset + i] = array[i];</span>
            }
<span class="nc" id="L425">        }</span>

        @Override
        default Node.OfLong truncate(long from, long to, IntFunction&lt;Long[]&gt; generator) {
<span class="nc bnc" id="L429" title="All 4 branches missed.">            if (from == 0 &amp;&amp; to == count())</span>
<span class="nc" id="L430">                return this;</span>
<span class="nc" id="L431">            long size = to - from;</span>
<span class="nc" id="L432">            Spliterator.OfLong spliterator = spliterator();</span>
<span class="nc" id="L433">            Node.Builder.OfLong nodeBuilder = Nodes.longBuilder(size);</span>
<span class="nc" id="L434">            nodeBuilder.begin(size);</span>
<span class="nc bnc" id="L435" title="All 4 branches missed.">            for (int i = 0; i &lt; from &amp;&amp; spliterator.tryAdvance((LongConsumer) e -&gt; { }); i++) { }</span>
<span class="nc bnc" id="L436" title="All 4 branches missed.">            for (int i = 0; (i &lt; size) &amp;&amp; spliterator.tryAdvance((LongConsumer) nodeBuilder); i++) { }</span>
<span class="nc" id="L437">            nodeBuilder.end();</span>
<span class="nc" id="L438">            return nodeBuilder.build();</span>
        }

        @Override
        default long[] newArray(int count) {
<span class="nc" id="L443">            return new long[count];</span>
        }

        /**
         * {@inheritDoc}
         * @implSpec The default in {@code Node.OfLong} returns
         * {@code StreamShape.LONG_VALUE}
         */
        default StreamShape getShape() {
<span class="nc" id="L452">            return StreamShape.LONG_VALUE;</span>
        }
    }

    /**
     * Specialized {@code Node} for double elements
     */
    interface OfDouble extends OfPrimitive&lt;Double, DoubleConsumer, double[], Spliterator.OfDouble, OfDouble&gt; {

        /**
         * {@inheritDoc}
         *
         * @param consumer A {@code Consumer} that is to be invoked with each
         *        element in this {@code Node}.  If this is an
         *        {@code DoubleConsumer}, it is cast to {@code DoubleConsumer}
         *        so the elements may be processed without boxing.
         */
        @Override
        default void forEach(Consumer&lt;? super Double&gt; consumer) {
<span class="nc bnc" id="L471" title="All 2 branches missed.">            if (consumer instanceof DoubleConsumer) {</span>
<span class="nc" id="L472">                forEach((DoubleConsumer) consumer);</span>
            }
            else {
<span class="nc bnc" id="L475" title="All 2 branches missed.">                if (Tripwire.ENABLED)</span>
<span class="nc" id="L476">                    Tripwire.trip(getClass(), &quot;{0} calling Node.OfLong.forEachRemaining(Consumer)&quot;);</span>
<span class="nc" id="L477">                spliterator().forEachRemaining(consumer);</span>
            }
<span class="nc" id="L479">        }</span>

        //

        /**
         * {@inheritDoc}
         *
         * @implSpec the default implementation invokes {@link #asPrimitiveArray()}
         * to obtain a double[] array then and copies the elements from that
         * double[] array into the boxed Double[] array.  This is not efficient
         * and it is recommended to invoke {@link #copyInto(Object, int)}.
         */
        @Override
        default void copyInto(Double[] boxed, int offset) {
<span class="nc bnc" id="L493" title="All 2 branches missed.">            if (Tripwire.ENABLED)</span>
<span class="nc" id="L494">                Tripwire.trip(getClass(), &quot;{0} calling Node.OfDouble.copyInto(Double[], int)&quot;);</span>

<span class="nc" id="L496">            double[] array = asPrimitiveArray();</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">            for (int i = 0; i &lt; array.length; i++) {</span>
<span class="nc" id="L498">                boxed[offset + i] = array[i];</span>
            }
<span class="nc" id="L500">        }</span>

        @Override
        default Node.OfDouble truncate(long from, long to, IntFunction&lt;Double[]&gt; generator) {
<span class="nc bnc" id="L504" title="All 4 branches missed.">            if (from == 0 &amp;&amp; to == count())</span>
<span class="nc" id="L505">                return this;</span>
<span class="nc" id="L506">            long size = to - from;</span>
<span class="nc" id="L507">            Spliterator.OfDouble spliterator = spliterator();</span>
<span class="nc" id="L508">            Node.Builder.OfDouble nodeBuilder = Nodes.doubleBuilder(size);</span>
<span class="nc" id="L509">            nodeBuilder.begin(size);</span>
<span class="nc bnc" id="L510" title="All 4 branches missed.">            for (int i = 0; i &lt; from &amp;&amp; spliterator.tryAdvance((DoubleConsumer) e -&gt; { }); i++) { }</span>
<span class="nc bnc" id="L511" title="All 4 branches missed.">            for (int i = 0; (i &lt; size) &amp;&amp; spliterator.tryAdvance((DoubleConsumer) nodeBuilder); i++) { }</span>
<span class="nc" id="L512">            nodeBuilder.end();</span>
<span class="nc" id="L513">            return nodeBuilder.build();</span>
        }

        @Override
        default double[] newArray(int count) {
<span class="nc" id="L518">            return new double[count];</span>
        }

        /**
         * {@inheritDoc}
         *
         * @implSpec The default in {@code Node.OfDouble} returns
         * {@code StreamShape.DOUBLE_VALUE}
         */
        default StreamShape getShape() {
<span class="nc" id="L528">            return StreamShape.DOUBLE_VALUE;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>