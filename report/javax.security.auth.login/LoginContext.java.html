<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LoginContext.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.security.auth.login</a> &gt; <span class="el_source">LoginContext.java</span></div><h1>LoginContext.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.security.auth.login;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.LinkedList;
import java.util.Map;
import java.util.HashMap;
import java.text.MessageFormat;
import javax.security.auth.Subject;
import javax.security.auth.AuthPermission;
import javax.security.auth.callback.*;
import java.security.AccessController;
import java.security.AccessControlContext;
import sun.security.util.PendingException;
import sun.security.util.ResourcesMgr;

/**
 * &lt;p&gt; The {@code LoginContext} class describes the basic methods used
 * to authenticate Subjects and provides a way to develop an
 * application independent of the underlying authentication technology.
 * A {@code Configuration} specifies the authentication technology, or
 * {@code LoginModule}, to be used with a particular application.
 * Different LoginModules can be plugged in under an application
 * without requiring any modifications to the application itself.
 *
 * &lt;p&gt; In addition to supporting &lt;i&gt;pluggable&lt;/i&gt; authentication, this class
 * also supports the notion of &lt;i&gt;stacked&lt;/i&gt; authentication.
 * Applications may be configured to use more than one
 * LoginModule.  For example, one could
 * configure both a Kerberos LoginModule and a smart card
 * LoginModule under an application.
 *
 * &lt;p&gt; A typical caller instantiates a LoginContext with
 * a &lt;i&gt;name&lt;/i&gt; and a {@code CallbackHandler}.
 * LoginContext uses the &lt;i&gt;name&lt;/i&gt; as the index into a
 * Configuration to determine which LoginModules should be used,
 * and which ones must succeed in order for the overall authentication to
 * succeed.  The {@code CallbackHandler} is passed to the underlying
 * LoginModules so they may communicate and interact with users
 * (prompting for a username and password via a graphical user interface,
 * for example).
 *
 * &lt;p&gt; Once the caller has instantiated a LoginContext,
 * it invokes the {@code login} method to authenticate
 * a {@code Subject}.  The {@code login} method invokes
 * the configured modules to perform their respective types of authentication
 * (username/password, smart card pin verification, etc.).
 * Note that the LoginModules will not attempt authentication retries nor
 * introduce delays if the authentication fails.
 * Such tasks belong to the LoginContext caller.
 *
 * &lt;p&gt; If the {@code login} method returns without
 * throwing an exception, then the overall authentication succeeded.
 * The caller can then retrieve
 * the newly authenticated Subject by invoking the
 * {@code getSubject} method.  Principals and Credentials associated
 * with the Subject may be retrieved by invoking the Subject's
 * respective {@code getPrincipals}, {@code getPublicCredentials},
 * and {@code getPrivateCredentials} methods.
 *
 * &lt;p&gt; To logout the Subject, the caller calls
 * the {@code logout} method.  As with the {@code login}
 * method, this {@code logout} method invokes the {@code logout}
 * method for the configured modules.
 *
 * &lt;p&gt; A LoginContext should not be used to authenticate
 * more than one Subject.  A separate LoginContext
 * should be used to authenticate each different Subject.
 *
 * &lt;p&gt; The following documentation applies to all LoginContext constructors:
 * &lt;ol&gt;
 *
 * &lt;li&gt; {@code Subject}
 * &lt;ul&gt;
 * &lt;li&gt; If the constructor has a Subject
 * input parameter, the LoginContext uses the caller-specified
 * Subject object.
 * &lt;p&gt;
 * &lt;li&gt; If the caller specifies a {@code null} Subject
 * and a {@code null} value is permitted,
 * the LoginContext instantiates a new Subject.
 * &lt;p&gt;
 * &lt;li&gt; If the constructor does &lt;b&gt;not&lt;/b&gt; have a Subject
 * input parameter, the LoginContext instantiates a new Subject.
 * &lt;p&gt;
 * &lt;/ul&gt;
 *
 * &lt;li&gt; {@code Configuration}
 * &lt;ul&gt;
 * &lt;li&gt; If the constructor has a Configuration
 * input parameter and the caller specifies a non-null Configuration,
 * the LoginContext uses the caller-specified Configuration.
 * &lt;p&gt;
 * If the constructor does &lt;b&gt;not&lt;/b&gt; have a Configuration
 * input parameter, or if the caller specifies a {@code null}
 * Configuration object, the constructor uses the following call to
 * get the installed Configuration:
 * &lt;pre&gt;
 *      config = Configuration.getConfiguration();
 * &lt;/pre&gt;
 * For both cases,
 * the &lt;i&gt;name&lt;/i&gt; argument given to the constructor is passed to the
 * {@code Configuration.getAppConfigurationEntry} method.
 * If the Configuration has no entries for the specified &lt;i&gt;name&lt;/i&gt;,
 * then the {@code LoginContext} calls
 * {@code getAppConfigurationEntry} with the name, &quot;&lt;i&gt;other&lt;/i&gt;&quot;
 * (the default entry name).  If there is no entry for &quot;&lt;i&gt;other&lt;/i&gt;&quot;,
 * then a {@code LoginException} is thrown.
 * &lt;p&gt;
 * &lt;li&gt; When LoginContext uses the installed Configuration, the caller
 * requires the createLoginContext.&lt;em&gt;name&lt;/em&gt; and possibly
 * createLoginContext.other AuthPermissions. Furthermore, the
 * LoginContext will invoke configured modules from within an
 * {@code AccessController.doPrivileged} call so that modules that
 * perform security-sensitive tasks (such as connecting to remote hosts,
 * and updating the Subject) will require the respective permissions, but
 * the callers of the LoginContext will not require those permissions.
 * &lt;p&gt;
 * &lt;li&gt; When LoginContext uses a caller-specified Configuration, the caller
 * does not require any createLoginContext AuthPermission.  The LoginContext
 * saves the {@code AccessControlContext} for the caller,
 * and invokes the configured modules from within an
 * {@code AccessController.doPrivileged} call constrained by that context.
 * This means the caller context (stored when the LoginContext was created)
 * must have sufficient permissions to perform any security-sensitive tasks
 * that the modules may perform.
 * &lt;p&gt;
 * &lt;/ul&gt;
 *
 * &lt;li&gt; {@code CallbackHandler}
 * &lt;ul&gt;
 * &lt;li&gt; If the constructor has a CallbackHandler
 * input parameter, the LoginContext uses the caller-specified
 * CallbackHandler object.
 * &lt;p&gt;
 * &lt;li&gt; If the constructor does &lt;b&gt;not&lt;/b&gt; have a CallbackHandler
 * input parameter, or if the caller specifies a {@code null}
 * CallbackHandler object (and a {@code null} value is permitted),
 * the LoginContext queries the
 * {@code auth.login.defaultCallbackHandler} security property for the
 * fully qualified class name of a default handler
 * implementation. If the security property is not set,
 * then the underlying modules will not have a
 * CallbackHandler for use in communicating
 * with users.  The caller thus assumes that the configured
 * modules have alternative means for authenticating the user.
 *
 * &lt;p&gt;
 * &lt;li&gt; When the LoginContext uses the installed Configuration (instead of
 * a caller-specified Configuration, see above),
 * then this LoginContext must wrap any
 * caller-specified or default CallbackHandler implementation
 * in a new CallbackHandler implementation
 * whose {@code handle} method implementation invokes the
 * specified CallbackHandler's {@code handle} method in a
 * {@code java.security.AccessController.doPrivileged} call
 * constrained by the caller's current {@code AccessControlContext}.
 * &lt;/ul&gt;
 * &lt;/ol&gt;
 *
 * @see java.security.Security
 * @see javax.security.auth.AuthPermission
 * @see javax.security.auth.Subject
 * @see javax.security.auth.callback.CallbackHandler
 * @see javax.security.auth.login.Configuration
 * @see javax.security.auth.spi.LoginModule
 * @see java.security.Security security properties
 */
public class LoginContext {

    private static final String INIT_METHOD             = &quot;initialize&quot;;
    private static final String LOGIN_METHOD            = &quot;login&quot;;
    private static final String COMMIT_METHOD           = &quot;commit&quot;;
    private static final String ABORT_METHOD            = &quot;abort&quot;;
    private static final String LOGOUT_METHOD           = &quot;logout&quot;;
    private static final String OTHER                   = &quot;other&quot;;
    private static final String DEFAULT_HANDLER         =
                                &quot;auth.login.defaultCallbackHandler&quot;;
<span class="fc" id="L205">    private Subject subject = null;</span>
<span class="fc" id="L206">    private boolean subjectProvided = false;</span>
<span class="fc" id="L207">    private boolean loginSucceeded = false;</span>
    private CallbackHandler callbackHandler;
<span class="fc" id="L209">    private Map&lt;String,?&gt; state = new HashMap&lt;String,Object&gt;();</span>

    private Configuration config;
<span class="fc" id="L212">    private boolean configProvided = false;</span>
<span class="fc" id="L213">    private AccessControlContext creatorAcc = null;</span>
    private ModuleInfo[] moduleStack;
<span class="fc" id="L215">    private ClassLoader contextClassLoader = null;</span>
<span class="fc" id="L216">    private static final Class&lt;?&gt;[] PARAMS = { };</span>

    // state saved in the event a user-specified asynchronous exception
    // was specified and thrown

<span class="fc" id="L221">    private int moduleIndex = 0;</span>
<span class="fc" id="L222">    private LoginException firstError = null;</span>
<span class="fc" id="L223">    private LoginException firstRequiredError = null;</span>
<span class="fc" id="L224">    private boolean success = false;</span>

<span class="fc" id="L226">    private static final sun.security.util.Debug debug =</span>
<span class="fc" id="L227">        sun.security.util.Debug.getInstance(&quot;logincontext&quot;, &quot;\t[LoginContext]&quot;);</span>

    private void init(String name) throws LoginException {

<span class="fc" id="L231">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L232" title="All 4 branches covered.">        if (sm != null &amp;&amp; !configProvided) {</span>
<span class="fc" id="L233">            sm.checkPermission(new AuthPermission</span>
                                (&quot;createLoginContext.&quot; + name));
        }

<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (name == null)</span>
<span class="fc" id="L238">            throw new LoginException</span>
<span class="fc" id="L239">                (ResourcesMgr.getString(&quot;Invalid.null.input.name&quot;));</span>

        // get the Configuration
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if (config == null) {</span>
<span class="fc" id="L243">            config = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L244">                (new java.security.PrivilegedAction&lt;Configuration&gt;() {</span>
                public Configuration run() {
<span class="fc" id="L246">                    return Configuration.getConfiguration();</span>
                }
            });
        }

        // get the LoginModules configured for this application
<span class="fc" id="L252">        AppConfigurationEntry[] entries = config.getAppConfigurationEntry(name);</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">        if (entries == null) {</span>

<span class="fc bfc" id="L255" title="All 4 branches covered.">            if (sm != null &amp;&amp; !configProvided) {</span>
<span class="fc" id="L256">                sm.checkPermission(new AuthPermission</span>
                                (&quot;createLoginContext.&quot; + OTHER));
            }

<span class="fc" id="L260">            entries = config.getAppConfigurationEntry(OTHER);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">            if (entries == null) {</span>
<span class="fc" id="L262">                MessageFormat form = new MessageFormat(ResourcesMgr.getString</span>
<span class="fc" id="L263">                        (&quot;No.LoginModules.configured.for.name&quot;));</span>
<span class="fc" id="L264">                Object[] source = {name};</span>
<span class="fc" id="L265">                throw new LoginException(form.format(source));</span>
            }
        }
<span class="fc" id="L268">        moduleStack = new ModuleInfo[entries.length];</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">        for (int i = 0; i &lt; entries.length; i++) {</span>
            // clone returned array
<span class="fc" id="L271">            moduleStack[i] = new ModuleInfo</span>
                                (new AppConfigurationEntry
<span class="fc" id="L273">                                        (entries[i].getLoginModuleName(),</span>
<span class="fc" id="L274">                                        entries[i].getControlFlag(),</span>
<span class="fc" id="L275">                                        entries[i].getOptions()),</span>
                                null);
        }

<span class="fc" id="L279">        contextClassLoader = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L280">                (new java.security.PrivilegedAction&lt;ClassLoader&gt;() {</span>
                public ClassLoader run() {
<span class="fc" id="L282">                    return Thread.currentThread().getContextClassLoader();</span>
                }
        });
<span class="fc" id="L285">    }</span>

    private void loadDefaultCallbackHandler() throws LoginException {

        // get the default handler class
        try {

<span class="fc" id="L292">            final ClassLoader finalLoader = contextClassLoader;</span>

<span class="fc" id="L294">            this.callbackHandler = java.security.AccessController.doPrivileged(</span>
<span class="fc" id="L295">                new java.security.PrivilegedExceptionAction&lt;CallbackHandler&gt;() {</span>
                public CallbackHandler run() throws Exception {
<span class="fc" id="L297">                    String defaultHandler = java.security.Security.getProperty</span>
<span class="fc" id="L298">                        (DEFAULT_HANDLER);</span>
<span class="pc bpc" id="L299" title="1 of 4 branches missed.">                    if (defaultHandler == null || defaultHandler.length() == 0)</span>
<span class="fc" id="L300">                        return null;</span>
<span class="fc" id="L301">                    Class&lt;?&gt; c = Class.forName(defaultHandler,</span>
                                        true,
                                        finalLoader);
<span class="fc" id="L304">                    return (CallbackHandler)c.newInstance();</span>
                }
            });
<span class="nc" id="L307">        } catch (java.security.PrivilegedActionException pae) {</span>
<span class="nc" id="L308">            throw new LoginException(pae.getException().toString());</span>
<span class="fc" id="L309">        }</span>

        // secure it with the caller's ACC
<span class="fc bfc" id="L312" title="All 4 branches covered.">        if (this.callbackHandler != null &amp;&amp; !configProvided) {</span>
<span class="fc" id="L313">            this.callbackHandler = new SecureCallbackHandler</span>
<span class="fc" id="L314">                                (java.security.AccessController.getContext(),</span>
                                this.callbackHandler);
        }
<span class="fc" id="L317">    }</span>

    /**
     * Instantiate a new {@code LoginContext} object with a name.
     *
     * @param name the name used as the index into the
     *          {@code Configuration}.
     *
     * @exception LoginException if the caller-specified {@code name}
     *          does not appear in the {@code Configuration}
     *          and there is no {@code Configuration} entry
     *          for &quot;&lt;i&gt;other&lt;/i&gt;&quot;, or if the
     *          &lt;i&gt;auth.login.defaultCallbackHandler&lt;/i&gt;
     *          security property was set, but the implementation
     *          class could not be loaded.
     *          &lt;p&gt;
     * @exception SecurityException if a SecurityManager is set and
     *          the caller does not have
     *          AuthPermission(&quot;createLoginContext.&lt;i&gt;name&lt;/i&gt;&quot;),
     *          or if a configuration entry for &lt;i&gt;name&lt;/i&gt; does not exist and
     *          the caller does not additionally have
     *          AuthPermission(&quot;createLoginContext.other&quot;)
     */
<span class="fc" id="L340">    public LoginContext(String name) throws LoginException {</span>
<span class="fc" id="L341">        init(name);</span>
<span class="fc" id="L342">        loadDefaultCallbackHandler();</span>
<span class="fc" id="L343">    }</span>

    /**
     * Instantiate a new {@code LoginContext} object with a name
     * and a {@code Subject} object.
     *
     * &lt;p&gt;
     *
     * @param name the name used as the index into the
     *          {@code Configuration}. &lt;p&gt;
     *
     * @param subject the {@code Subject} to authenticate.
     *
     * @exception LoginException if the caller-specified {@code name}
     *          does not appear in the {@code Configuration}
     *          and there is no {@code Configuration} entry
     *          for &quot;&lt;i&gt;other&lt;/i&gt;&quot;, if the caller-specified {@code subject}
     *          is {@code null}, or if the
     *          &lt;i&gt;auth.login.defaultCallbackHandler&lt;/i&gt;
     *          security property was set, but the implementation
     *          class could not be loaded.
     *          &lt;p&gt;
     * @exception SecurityException if a SecurityManager is set and
     *          the caller does not have
     *          AuthPermission(&quot;createLoginContext.&lt;i&gt;name&lt;/i&gt;&quot;),
     *          or if a configuration entry for &lt;i&gt;name&lt;/i&gt; does not exist and
     *          the caller does not additionally have
     *          AuthPermission(&quot;createLoginContext.other&quot;)
     */
    public LoginContext(String name, Subject subject)
<span class="fc" id="L373">    throws LoginException {</span>
<span class="fc" id="L374">        init(name);</span>
<span class="pc bpc" id="L375" title="1 of 2 branches missed.">        if (subject == null)</span>
<span class="fc" id="L376">            throw new LoginException</span>
<span class="fc" id="L377">                (ResourcesMgr.getString(&quot;invalid.null.Subject.provided&quot;));</span>
<span class="nc" id="L378">        this.subject = subject;</span>
<span class="nc" id="L379">        subjectProvided = true;</span>
<span class="nc" id="L380">        loadDefaultCallbackHandler();</span>
<span class="nc" id="L381">    }</span>

    /**
     * Instantiate a new {@code LoginContext} object with a name
     * and a {@code CallbackHandler} object.
     *
     * &lt;p&gt;
     *
     * @param name the name used as the index into the
     *          {@code Configuration}. &lt;p&gt;
     *
     * @param callbackHandler the {@code CallbackHandler} object used by
     *          LoginModules to communicate with the user.
     *
     * @exception LoginException if the caller-specified {@code name}
     *          does not appear in the {@code Configuration}
     *          and there is no {@code Configuration} entry
     *          for &quot;&lt;i&gt;other&lt;/i&gt;&quot;, or if the caller-specified
     *          {@code callbackHandler} is {@code null}.
     *          &lt;p&gt;
     * @exception SecurityException if a SecurityManager is set and
     *          the caller does not have
     *          AuthPermission(&quot;createLoginContext.&lt;i&gt;name&lt;/i&gt;&quot;),
     *          or if a configuration entry for &lt;i&gt;name&lt;/i&gt; does not exist and
     *          the caller does not additionally have
     *          AuthPermission(&quot;createLoginContext.other&quot;)
     */
    public LoginContext(String name, CallbackHandler callbackHandler)
<span class="fc" id="L409">    throws LoginException {</span>
<span class="fc" id="L410">        init(name);</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        if (callbackHandler == null)</span>
<span class="fc" id="L412">            throw new LoginException(ResourcesMgr.getString</span>
<span class="fc" id="L413">                                (&quot;invalid.null.CallbackHandler.provided&quot;));</span>
<span class="nc" id="L414">        this.callbackHandler = new SecureCallbackHandler</span>
<span class="nc" id="L415">                                (java.security.AccessController.getContext(),</span>
                                callbackHandler);
<span class="nc" id="L417">    }</span>

    /**
     * Instantiate a new {@code LoginContext} object with a name,
     * a {@code Subject} to be authenticated, and a
     * {@code CallbackHandler} object.
     *
     * &lt;p&gt;
     *
     * @param name the name used as the index into the
     *          {@code Configuration}. &lt;p&gt;
     *
     * @param subject the {@code Subject} to authenticate. &lt;p&gt;
     *
     * @param callbackHandler the {@code CallbackHandler} object used by
     *          LoginModules to communicate with the user.
     *
     * @exception LoginException if the caller-specified {@code name}
     *          does not appear in the {@code Configuration}
     *          and there is no {@code Configuration} entry
     *          for &quot;&lt;i&gt;other&lt;/i&gt;&quot;, or if the caller-specified
     *          {@code subject} is {@code null},
     *          or if the caller-specified
     *          {@code callbackHandler} is {@code null}.
     *          &lt;p&gt;
     * @exception SecurityException if a SecurityManager is set and
     *          the caller does not have
     *          AuthPermission(&quot;createLoginContext.&lt;i&gt;name&lt;/i&gt;&quot;),
     *          or if a configuration entry for &lt;i&gt;name&lt;/i&gt; does not exist and
     *          the caller does not additionally have
     *          AuthPermission(&quot;createLoginContext.other&quot;)
     */
    public LoginContext(String name, Subject subject,
                        CallbackHandler callbackHandler) throws LoginException {
<span class="nc" id="L451">        this(name, subject);</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (callbackHandler == null)</span>
<span class="nc" id="L453">            throw new LoginException(ResourcesMgr.getString</span>
<span class="nc" id="L454">                                (&quot;invalid.null.CallbackHandler.provided&quot;));</span>
<span class="nc" id="L455">        this.callbackHandler = new SecureCallbackHandler</span>
<span class="nc" id="L456">                                (java.security.AccessController.getContext(),</span>
                                callbackHandler);
<span class="nc" id="L458">    }</span>

    /**
     * Instantiate a new {@code LoginContext} object with a name,
     * a {@code Subject} to be authenticated,
     * a {@code CallbackHandler} object, and a login
     * {@code Configuration}.
     *
     * &lt;p&gt;
     *
     * @param name the name used as the index into the caller-specified
     *          {@code Configuration}. &lt;p&gt;
     *
     * @param subject the {@code Subject} to authenticate,
     *          or {@code null}. &lt;p&gt;
     *
     * @param callbackHandler the {@code CallbackHandler} object used by
     *          LoginModules to communicate with the user, or {@code null}.
     *          &lt;p&gt;
     *
     * @param config the {@code Configuration} that lists the
     *          login modules to be called to perform the authentication,
     *          or {@code null}.
     *
     * @exception LoginException if the caller-specified {@code name}
     *          does not appear in the {@code Configuration}
     *          and there is no {@code Configuration} entry
     *          for &quot;&lt;i&gt;other&lt;/i&gt;&quot;.
     *          &lt;p&gt;
     * @exception SecurityException if a SecurityManager is set,
     *          &lt;i&gt;config&lt;/i&gt; is {@code null},
     *          and either the caller does not have
     *          AuthPermission(&quot;createLoginContext.&lt;i&gt;name&lt;/i&gt;&quot;),
     *          or if a configuration entry for &lt;i&gt;name&lt;/i&gt; does not exist and
     *          the caller does not additionally have
     *          AuthPermission(&quot;createLoginContext.other&quot;)
     *
     * @since 1.5
     */
    public LoginContext(String name, Subject subject,
                        CallbackHandler callbackHandler,
<span class="fc" id="L499">                        Configuration config) throws LoginException {</span>
<span class="fc" id="L500">        this.config = config;</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">        configProvided = (config != null) ? true : false;</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">        if (configProvided) {</span>
<span class="fc" id="L503">            creatorAcc = java.security.AccessController.getContext();</span>
        }

<span class="fc" id="L506">        init(name);</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">        if (subject != null) {</span>
<span class="fc" id="L508">            this.subject = subject;</span>
<span class="fc" id="L509">            subjectProvided = true;</span>
        }
<span class="fc bfc" id="L511" title="All 2 branches covered.">        if (callbackHandler == null) {</span>
<span class="fc" id="L512">            loadDefaultCallbackHandler();</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">        } else if (!configProvided) {</span>
<span class="fc" id="L514">            this.callbackHandler = new SecureCallbackHandler</span>
<span class="fc" id="L515">                                (java.security.AccessController.getContext(),</span>
                                callbackHandler);
        } else {
<span class="fc" id="L518">            this.callbackHandler = callbackHandler;</span>
        }
<span class="fc" id="L520">    }</span>

    /**
     * Perform the authentication.
     *
     * &lt;p&gt; This method invokes the {@code login} method for each
     * LoginModule configured for the &lt;i&gt;name&lt;/i&gt; specified to the
     * {@code LoginContext} constructor, as determined by the login
     * {@code Configuration}.  Each {@code LoginModule}
     * then performs its respective type of authentication
     * (username/password, smart card pin verification, etc.).
     *
     * &lt;p&gt; This method completes a 2-phase authentication process by
     * calling each configured LoginModule's {@code commit} method
     * if the overall authentication succeeded (the relevant REQUIRED,
     * REQUISITE, SUFFICIENT, and OPTIONAL LoginModules succeeded),
     * or by calling each configured LoginModule's {@code abort} method
     * if the overall authentication failed.  If authentication succeeded,
     * each successful LoginModule's {@code commit} method associates
     * the relevant Principals and Credentials with the {@code Subject}.
     * If authentication failed, each LoginModule's {@code abort} method
     * removes/destroys any previously stored state.
     *
     * &lt;p&gt; If the {@code commit} phase of the authentication process
     * fails, then the overall authentication fails and this method
     * invokes the {@code abort} method for each configured
     * {@code LoginModule}.
     *
     * &lt;p&gt; If the {@code abort} phase
     * fails for any reason, then this method propagates the
     * original exception thrown either during the {@code login} phase
     * or the {@code commit} phase.  In either case, the overall
     * authentication fails.
     *
     * &lt;p&gt; In the case where multiple LoginModules fail,
     * this method propagates the exception raised by the first
     * {@code LoginModule} which failed.
     *
     * &lt;p&gt; Note that if this method enters the {@code abort} phase
     * (either the {@code login} or {@code commit} phase failed),
     * this method invokes all LoginModules configured for the
     * application regardless of their respective {@code Configuration}
     * flag parameters.  Essentially this means that {@code Requisite}
     * and {@code Sufficient} semantics are ignored during the
     * {@code abort} phase.  This guarantees that proper cleanup
     * and state restoration can take place.
     *
     * &lt;p&gt;
     *
     * @exception LoginException if the authentication fails.
     */
    public void login() throws LoginException {

<span class="fc" id="L573">        loginSucceeded = false;</span>

<span class="fc bfc" id="L575" title="All 2 branches covered.">        if (subject == null) {</span>
<span class="fc" id="L576">            subject = new Subject();</span>
        }

        try {
<span class="fc bfc" id="L580" title="All 2 branches covered.">            if (configProvided) {</span>
                // module invoked in doPrivileged with creatorAcc
<span class="fc" id="L582">                invokeCreatorPriv(LOGIN_METHOD);</span>
<span class="fc" id="L583">                invokeCreatorPriv(COMMIT_METHOD);</span>
            } else {
                // module invoked in doPrivileged
<span class="fc" id="L586">                invokePriv(LOGIN_METHOD);</span>
<span class="fc" id="L587">                invokePriv(COMMIT_METHOD);</span>
            }
<span class="fc" id="L589">            loginSucceeded = true;</span>
<span class="fc" id="L590">        } catch (LoginException le) {</span>
            try {
<span class="fc bfc" id="L592" title="All 2 branches covered.">                if (configProvided) {</span>
<span class="fc" id="L593">                    invokeCreatorPriv(ABORT_METHOD);</span>
                } else {
<span class="fc" id="L595">                    invokePriv(ABORT_METHOD);</span>
                }
<span class="fc" id="L597">            } catch (LoginException le2) {</span>
<span class="fc" id="L598">                throw le;</span>
<span class="fc" id="L599">            }</span>
<span class="fc" id="L600">            throw le;</span>
<span class="fc" id="L601">        }</span>
<span class="fc" id="L602">    }</span>

    /**
     * Logout the {@code Subject}.
     *
     * &lt;p&gt; This method invokes the {@code logout} method for each
     * {@code LoginModule} configured for this {@code LoginContext}.
     * Each {@code LoginModule} performs its respective logout procedure
     * which may include removing/destroying
     * {@code Principal} and {@code Credential} information
     * from the {@code Subject} and state cleanup.
     *
     * &lt;p&gt; Note that this method invokes all LoginModules configured for the
     * application regardless of their respective
     * {@code Configuration} flag parameters.  Essentially this means
     * that {@code Requisite} and {@code Sufficient} semantics are
     * ignored for this method.  This guarantees that proper cleanup
     * and state restoration can take place.
     *
     * &lt;p&gt;
     *
     * @exception LoginException if the logout fails.
     */
    public void logout() throws LoginException {
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">        if (subject == null) {</span>
<span class="fc" id="L627">            throw new LoginException(ResourcesMgr.getString</span>
<span class="fc" id="L628">                (&quot;null.subject.logout.called.before.login&quot;));</span>
        }

<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (configProvided) {</span>
            // module invoked in doPrivileged with creatorAcc
<span class="nc" id="L633">            invokeCreatorPriv(LOGOUT_METHOD);</span>
        } else {
            // module invoked in doPrivileged
<span class="nc" id="L636">            invokePriv(LOGOUT_METHOD);</span>
        }
<span class="nc" id="L638">    }</span>

    /**
     * Return the authenticated Subject.
     *
     * &lt;p&gt;
     *
     * @return the authenticated Subject.  If the caller specified a
     *          Subject to this LoginContext's constructor,
     *          this method returns the caller-specified Subject.
     *          If a Subject was not specified and authentication succeeds,
     *          this method returns the Subject instantiated and used for
     *          authentication by this LoginContext.
     *          If a Subject was not specified, and authentication fails or
     *          has not been attempted, this method returns null.
     */
    public Subject getSubject() {
<span class="pc bpc" id="L655" title="1 of 4 branches missed.">        if (!loginSucceeded &amp;&amp; !subjectProvided)</span>
<span class="fc" id="L656">            return null;</span>
<span class="fc" id="L657">        return subject;</span>
    }

    private void clearState() {
<span class="fc" id="L661">        moduleIndex = 0;</span>
<span class="fc" id="L662">        firstError = null;</span>
<span class="fc" id="L663">        firstRequiredError = null;</span>
<span class="fc" id="L664">        success = false;</span>
<span class="fc" id="L665">    }</span>

    private void throwException(LoginException originalError, LoginException le)
    throws LoginException {

        // first clear state
<span class="fc" id="L671">        clearState();</span>

        // throw the exception
<span class="fc bfc" id="L674" title="All 2 branches covered.">        LoginException error = (originalError != null) ? originalError : le;</span>
<span class="fc" id="L675">        throw error;</span>
    }

    /**
     * Invokes the login, commit, and logout methods
     * from a LoginModule inside a doPrivileged block.
     *
     * This version is called if the caller did not instantiate
     * the LoginContext with a Configuration object.
     */
    private void invokePriv(final String methodName) throws LoginException {
        try {
<span class="fc" id="L687">            java.security.AccessController.doPrivileged</span>
<span class="fc" id="L688">                (new java.security.PrivilegedExceptionAction&lt;Void&gt;() {</span>
                public Void run() throws LoginException {
<span class="fc" id="L690">                    invoke(methodName);</span>
<span class="fc" id="L691">                    return null;</span>
                }
            });
<span class="fc" id="L694">        } catch (java.security.PrivilegedActionException pae) {</span>
<span class="fc" id="L695">            throw (LoginException)pae.getException();</span>
<span class="fc" id="L696">        }</span>
<span class="fc" id="L697">    }</span>

    /**
     * Invokes the login, commit, and logout methods
     * from a LoginModule inside a doPrivileged block restricted
     * by creatorAcc
     *
     * This version is called if the caller instantiated
     * the LoginContext with a Configuration object.
     */
    private void invokeCreatorPriv(final String methodName)
                throws LoginException {
        try {
<span class="fc" id="L710">            java.security.AccessController.doPrivileged</span>
<span class="fc" id="L711">                (new java.security.PrivilegedExceptionAction&lt;Void&gt;() {</span>
                public Void run() throws LoginException {
<span class="fc" id="L713">                    invoke(methodName);</span>
<span class="fc" id="L714">                    return null;</span>
                }
            }, creatorAcc);
<span class="fc" id="L717">        } catch (java.security.PrivilegedActionException pae) {</span>
<span class="fc" id="L718">            throw (LoginException)pae.getException();</span>
<span class="fc" id="L719">        }</span>
<span class="fc" id="L720">    }</span>

    private void invoke(String methodName) throws LoginException {

        // start at moduleIndex
        // - this can only be non-zero if methodName is LOGIN_METHOD

<span class="fc bfc" id="L727" title="All 2 branches covered.">        for (int i = moduleIndex; i &lt; moduleStack.length; i++, moduleIndex++) {</span>
            try {

<span class="fc" id="L730">                int mIndex = 0;</span>
<span class="fc" id="L731">                Method[] methods = null;</span>

<span class="fc bfc" id="L733" title="All 2 branches covered.">                if (moduleStack[i].module != null) {</span>
<span class="fc" id="L734">                    methods = moduleStack[i].module.getClass().getMethods();</span>
                } else {

                    // instantiate the LoginModule
<span class="fc" id="L738">                    Class&lt;?&gt; c = Class.forName</span>
<span class="fc" id="L739">                                (moduleStack[i].entry.getLoginModuleName(),</span>
                                true,
                                contextClassLoader);

<span class="fc" id="L743">                    Constructor&lt;?&gt; constructor = c.getConstructor(PARAMS);</span>
<span class="fc" id="L744">                    Object[] args = { };</span>

                    // allow any object to be a LoginModule
                    // as long as it conforms to the interface
<span class="fc" id="L748">                    moduleStack[i].module = constructor.newInstance(args);</span>

<span class="fc" id="L750">                    methods = moduleStack[i].module.getClass().getMethods();</span>

                    // call the LoginModule's initialize method
<span class="pc bpc" id="L753" title="1 of 2 branches missed.">                    for (mIndex = 0; mIndex &lt; methods.length; mIndex++) {</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">                        if (methods[mIndex].getName().equals(INIT_METHOD))</span>
<span class="fc" id="L755">                            break;</span>
                    }

<span class="fc" id="L758">                    Object[] initArgs = {subject,</span>
                                        callbackHandler,
                                        state,
<span class="fc" id="L761">                                        moduleStack[i].entry.getOptions() };</span>
                    // invoke the LoginModule initialize method
<span class="fc" id="L763">                    methods[mIndex].invoke(moduleStack[i].module, initArgs);</span>
                }

                // find the requested method in the LoginModule
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">                for (mIndex = 0; mIndex &lt; methods.length; mIndex++) {</span>
<span class="fc bfc" id="L768" title="All 2 branches covered.">                    if (methods[mIndex].getName().equals(methodName))</span>
<span class="fc" id="L769">                        break;</span>
                }

                // set up the arguments to be passed to the LoginModule method
<span class="fc" id="L773">                Object[] args = { };</span>

                // invoke the LoginModule method
<span class="fc" id="L776">                boolean status = ((Boolean)methods[mIndex].invoke</span>
<span class="fc" id="L777">                                (moduleStack[i].module, args)).booleanValue();</span>

<span class="fc bfc" id="L779" title="All 2 branches covered.">                if (status == true) {</span>

                    // if SUFFICIENT, return if no prior REQUIRED errors
<span class="fc bfc" id="L782" title="All 2 branches covered.">                    if (!methodName.equals(ABORT_METHOD) &amp;&amp;</span>
<span class="pc bpc" id="L783" title="1 of 2 branches missed.">                        !methodName.equals(LOGOUT_METHOD) &amp;&amp;</span>
<span class="pc bpc" id="L784" title="3 of 4 branches missed.">                        moduleStack[i].entry.getControlFlag() ==</span>
                    AppConfigurationEntry.LoginModuleControlFlag.SUFFICIENT &amp;&amp;
                        firstRequiredError == null) {

                        // clear state
<span class="nc" id="L789">                        clearState();</span>

<span class="nc bnc" id="L791" title="All 2 branches missed.">                        if (debug != null)</span>
<span class="nc" id="L792">                            debug.println(methodName + &quot; SUFFICIENT success&quot;);</span>
<span class="nc" id="L793">                        return;</span>
                    }

<span class="pc bpc" id="L796" title="1 of 2 branches missed.">                    if (debug != null)</span>
<span class="nc" id="L797">                        debug.println(methodName + &quot; success&quot;);</span>
<span class="fc" id="L798">                    success = true;</span>
                } else {
<span class="pc bpc" id="L800" title="1 of 2 branches missed.">                    if (debug != null)</span>
<span class="nc" id="L801">                        debug.println(methodName + &quot; ignored&quot;);</span>
                }

<span class="nc" id="L804">            } catch (NoSuchMethodException nsme) {</span>
<span class="nc" id="L805">                MessageFormat form = new MessageFormat(ResourcesMgr.getString</span>
<span class="nc" id="L806">                        (&quot;unable.to.instantiate.LoginModule.module.because.it.does.not.provide.a.no.argument.constructor&quot;));</span>
<span class="nc" id="L807">                Object[] source = {moduleStack[i].entry.getLoginModuleName()};</span>
<span class="nc" id="L808">                throwException(null, new LoginException(form.format(source)));</span>
<span class="nc" id="L809">            } catch (InstantiationException ie) {</span>
<span class="nc" id="L810">                throwException(null, new LoginException(ResourcesMgr.getString</span>
<span class="nc" id="L811">                        (&quot;unable.to.instantiate.LoginModule.&quot;) +</span>
<span class="nc" id="L812">                        ie.getMessage()));</span>
<span class="nc" id="L813">            } catch (ClassNotFoundException cnfe) {</span>
<span class="nc" id="L814">                throwException(null, new LoginException(ResourcesMgr.getString</span>
<span class="nc" id="L815">                        (&quot;unable.to.find.LoginModule.class.&quot;) +</span>
<span class="nc" id="L816">                        cnfe.getMessage()));</span>
<span class="nc" id="L817">            } catch (IllegalAccessException iae) {</span>
<span class="nc" id="L818">                throwException(null, new LoginException(ResourcesMgr.getString</span>
<span class="nc" id="L819">                        (&quot;unable.to.access.LoginModule.&quot;) +</span>
<span class="nc" id="L820">                        iae.getMessage()));</span>
<span class="fc" id="L821">            } catch (InvocationTargetException ite) {</span>

                // failure cases

                LoginException le;

<span class="pc bpc" id="L827" title="1 of 2 branches missed.">                if (ite.getCause() instanceof PendingException &amp;&amp;</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">                    methodName.equals(LOGIN_METHOD)) {</span>

                    // XXX
                    //
                    // if a module's LOGIN_METHOD threw a PendingException
                    // then immediately throw it.
                    //
                    // when LoginContext is called again,
                    // the module that threw the exception is invoked first
                    // (the module list is not invoked from the start).
                    // previously thrown exception state is still present.
                    //
                    // it is assumed that the module which threw
                    // the exception can have its
                    // LOGIN_METHOD invoked twice in a row
                    // without any commit/abort in between.
                    //
                    // in all cases when LoginContext returns
                    // (either via natural return or by throwing an exception)
                    // we need to call clearState before returning.
                    // the only time that is not true is in this case -
                    // do not call throwException here.

<span class="nc" id="L851">                    throw (PendingException)ite.getCause();</span>

<span class="fc bfc" id="L853" title="All 2 branches covered.">                } else if (ite.getCause() instanceof LoginException) {</span>

<span class="fc" id="L855">                    le = (LoginException)ite.getCause();</span>

<span class="pc bpc" id="L857" title="1 of 2 branches missed.">                } else if (ite.getCause() instanceof SecurityException) {</span>

                    // do not want privacy leak
                    // (e.g., sensitive file path in exception msg)

<span class="fc" id="L862">                    le = new LoginException(&quot;Security Exception&quot;);</span>
<span class="fc" id="L863">                    le.initCause(new SecurityException());</span>
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">                    if (debug != null) {</span>
<span class="nc" id="L865">                        debug.println</span>
<span class="nc" id="L866">                            (&quot;original security exception with detail msg &quot; +</span>
                            &quot;replaced by new exception with empty detail msg&quot;);
<span class="nc" id="L868">                        debug.println(&quot;original security exception: &quot; +</span>
<span class="nc" id="L869">                                ite.getCause().toString());</span>
                    }
                } else {

                    // capture an unexpected LoginModule exception
<span class="nc" id="L874">                    java.io.StringWriter sw = new java.io.StringWriter();</span>
<span class="nc" id="L875">                    ite.getCause().printStackTrace</span>
<span class="nc" id="L876">                                                (new java.io.PrintWriter(sw));</span>
<span class="nc" id="L877">                    sw.flush();</span>
<span class="nc" id="L878">                    le = new LoginException(sw.toString());</span>
                }

<span class="pc bpc" id="L881" title="1 of 2 branches missed.">                if (moduleStack[i].entry.getControlFlag() ==</span>
                    AppConfigurationEntry.LoginModuleControlFlag.REQUISITE) {

<span class="nc bnc" id="L884" title="All 2 branches missed.">                    if (debug != null)</span>
<span class="nc" id="L885">                        debug.println(methodName + &quot; REQUISITE failure&quot;);</span>

                    // if REQUISITE, then immediately throw an exception
<span class="nc bnc" id="L888" title="All 2 branches missed.">                    if (methodName.equals(ABORT_METHOD) ||</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">                        methodName.equals(LOGOUT_METHOD)) {</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">                        if (firstRequiredError == null)</span>
<span class="nc" id="L891">                            firstRequiredError = le;</span>
                    } else {
<span class="nc" id="L893">                        throwException(firstRequiredError, le);</span>
                    }

<span class="pc bpc" id="L896" title="1 of 2 branches missed.">                } else if (moduleStack[i].entry.getControlFlag() ==</span>
                    AppConfigurationEntry.LoginModuleControlFlag.REQUIRED) {

<span class="pc bpc" id="L899" title="1 of 2 branches missed.">                    if (debug != null)</span>
<span class="nc" id="L900">                        debug.println(methodName + &quot; REQUIRED failure&quot;);</span>

                    // mark down that a REQUIRED module failed
<span class="fc bfc" id="L903" title="All 2 branches covered.">                    if (firstRequiredError == null)</span>
<span class="fc" id="L904">                        firstRequiredError = le;</span>

                } else {

<span class="nc bnc" id="L908" title="All 2 branches missed.">                    if (debug != null)</span>
<span class="nc" id="L909">                        debug.println(methodName + &quot; OPTIONAL failure&quot;);</span>

                    // mark down that an OPTIONAL module failed
<span class="nc bnc" id="L912" title="All 2 branches missed.">                    if (firstError == null)</span>
<span class="nc" id="L913">                        firstError = le;</span>
                }
<span class="pc" id="L915">            }</span>
        }

        // we went thru all the LoginModules.
<span class="pc bpc" id="L919" title="1 of 2 branches missed.">        if (firstRequiredError != null) {</span>
            // a REQUIRED module failed -- return the error
<span class="nc" id="L921">            throwException(firstRequiredError, null);</span>
<span class="pc bpc" id="L922" title="1 of 4 branches missed.">        } else if (success == false &amp;&amp; firstError != null) {</span>
            // no module succeeded -- return the first error
<span class="nc" id="L924">            throwException(firstError, null);</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">        } else if (success == false) {</span>
            // no module succeeded -- all modules were IGNORED
<span class="nc" id="L927">            throwException(new LoginException</span>
<span class="nc" id="L928">                (ResourcesMgr.getString(&quot;Login.Failure.all.modules.ignored&quot;)),</span>
                null);
        } else {
            // success

<span class="fc" id="L933">            clearState();</span>
<span class="fc" id="L934">            return;</span>
        }
<span class="nc" id="L936">    }</span>

    /**
     * Wrap the caller-specified CallbackHandler in our own
     * and invoke it within a privileged block, constrained by
     * the caller's AccessControlContext.
     */
    private static class SecureCallbackHandler implements CallbackHandler {

        private final java.security.AccessControlContext acc;
        private final CallbackHandler ch;

        SecureCallbackHandler(java.security.AccessControlContext acc,
<span class="fc" id="L949">                        CallbackHandler ch) {</span>
<span class="fc" id="L950">            this.acc = acc;</span>
<span class="fc" id="L951">            this.ch = ch;</span>
<span class="fc" id="L952">        }</span>

        public void handle(final Callback[] callbacks)
                throws java.io.IOException, UnsupportedCallbackException {
            try {
<span class="fc" id="L957">                java.security.AccessController.doPrivileged</span>
<span class="fc" id="L958">                    (new java.security.PrivilegedExceptionAction&lt;Void&gt;() {</span>
                    public Void run() throws java.io.IOException,
                                        UnsupportedCallbackException {
<span class="fc" id="L961">                        ch.handle(callbacks);</span>
<span class="fc" id="L962">                        return null;</span>
                    }
                }, acc);
<span class="nc" id="L965">            } catch (java.security.PrivilegedActionException pae) {</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">                if (pae.getException() instanceof java.io.IOException) {</span>
<span class="nc" id="L967">                    throw (java.io.IOException)pae.getException();</span>
                } else {
<span class="nc" id="L969">                    throw (UnsupportedCallbackException)pae.getException();</span>
                }
<span class="fc" id="L971">            }</span>
<span class="fc" id="L972">        }</span>
    }

    /**
     * LoginModule information -
     *          incapsulates Configuration info and actual module instances
     */
    private static class ModuleInfo {
        AppConfigurationEntry entry;
        Object module;

<span class="fc" id="L983">        ModuleInfo(AppConfigurationEntry newEntry, Object newModule) {</span>
<span class="fc" id="L984">            this.entry = newEntry;</span>
<span class="fc" id="L985">            this.module = newModule;</span>
<span class="fc" id="L986">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>