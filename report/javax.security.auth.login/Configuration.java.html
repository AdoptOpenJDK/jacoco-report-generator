<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Configuration.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.security.auth.login</a> &gt; <span class="el_source">Configuration.java</span></div><h1>Configuration.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.security.auth.login;

import javax.security.auth.AuthPermission;

import java.io.*;
import java.util.*;
import java.net.URI;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedExceptionAction;
import java.security.PrivilegedActionException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Provider;
import java.security.Security;
import java.security.SecurityPermission;

import sun.security.jca.GetInstance;

/**
 * A Configuration object is responsible for specifying which LoginModules
 * should be used for a particular application, and in what order the
 * LoginModules should be invoked.
 *
 * &lt;p&gt; A login configuration contains the following information.
 * Note that this example only represents the default syntax for the
 * {@code Configuration}.  Subclass implementations of this class
 * may implement alternative syntaxes and may retrieve the
 * {@code Configuration} from any source such as files, databases,
 * or servers.
 *
 * &lt;pre&gt;
 *      Name {
 *            ModuleClass  Flag    ModuleOptions;
 *            ModuleClass  Flag    ModuleOptions;
 *            ModuleClass  Flag    ModuleOptions;
 *      };
 *      Name {
 *            ModuleClass  Flag    ModuleOptions;
 *            ModuleClass  Flag    ModuleOptions;
 *      };
 *      other {
 *            ModuleClass  Flag    ModuleOptions;
 *            ModuleClass  Flag    ModuleOptions;
 *      };
 * &lt;/pre&gt;
 *
 * &lt;p&gt; Each entry in the {@code Configuration} is indexed via an
 * application name, &lt;i&gt;Name&lt;/i&gt;, and contains a list of
 * LoginModules configured for that application.  Each {@code LoginModule}
 * is specified via its fully qualified class name.
 * Authentication proceeds down the module list in the exact order specified.
 * If an application does not have a specific entry,
 * it defaults to the specific entry for &quot;&lt;i&gt;other&lt;/i&gt;&quot;.
 *
 * &lt;p&gt; The &lt;i&gt;Flag&lt;/i&gt; value controls the overall behavior as authentication
 * proceeds down the stack.  The following represents a description of the
 * valid values for &lt;i&gt;Flag&lt;/i&gt; and their respective semantics:
 *
 * &lt;pre&gt;
 *      1) Required     - The {@code LoginModule} is required to succeed.
 *                      If it succeeds or fails, authentication still continues
 *                      to proceed down the {@code LoginModule} list.
 *
 *      2) Requisite    - The {@code LoginModule} is required to succeed.
 *                      If it succeeds, authentication continues down the
 *                      {@code LoginModule} list.  If it fails,
 *                      control immediately returns to the application
 *                      (authentication does not proceed down the
 *                      {@code LoginModule} list).
 *
 *      3) Sufficient   - The {@code LoginModule} is not required to
 *                      succeed.  If it does succeed, control immediately
 *                      returns to the application (authentication does not
 *                      proceed down the {@code LoginModule} list).
 *                      If it fails, authentication continues down the
 *                      {@code LoginModule} list.
 *
 *      4) Optional     - The {@code LoginModule} is not required to
 *                      succeed.  If it succeeds or fails,
 *                      authentication still continues to proceed down the
 *                      {@code LoginModule} list.
 * &lt;/pre&gt;
 *
 * &lt;p&gt; The overall authentication succeeds only if all &lt;i&gt;Required&lt;/i&gt; and
 * &lt;i&gt;Requisite&lt;/i&gt; LoginModules succeed.  If a &lt;i&gt;Sufficient&lt;/i&gt;
 * {@code LoginModule} is configured and succeeds,
 * then only the &lt;i&gt;Required&lt;/i&gt; and &lt;i&gt;Requisite&lt;/i&gt; LoginModules prior to
 * that &lt;i&gt;Sufficient&lt;/i&gt; {@code LoginModule} need to have succeeded for
 * the overall authentication to succeed. If no &lt;i&gt;Required&lt;/i&gt; or
 * &lt;i&gt;Requisite&lt;/i&gt; LoginModules are configured for an application,
 * then at least one &lt;i&gt;Sufficient&lt;/i&gt; or &lt;i&gt;Optional&lt;/i&gt;
 * {@code LoginModule} must succeed.
 *
 * &lt;p&gt; &lt;i&gt;ModuleOptions&lt;/i&gt; is a space separated list of
 * {@code LoginModule}-specific values which are passed directly to
 * the underlying LoginModules.  Options are defined by the
 * {@code LoginModule} itself, and control the behavior within it.
 * For example, a {@code LoginModule} may define options to support
 * debugging/testing capabilities.  The correct way to specify options in the
 * {@code Configuration} is by using the following key-value pairing:
 * &lt;i&gt;debug=&quot;true&quot;&lt;/i&gt;.  The key and value should be separated by an
 * 'equals' symbol, and the value should be surrounded by double quotes.
 * If a String in the form, ${system.property}, occurs in the value,
 * it will be expanded to the value of the system property.
 * Note that there is no limit to the number of
 * options a {@code LoginModule} may define.
 *
 * &lt;p&gt; The following represents an example {@code Configuration} entry
 * based on the syntax above:
 *
 * &lt;pre&gt;
 * Login {
 *   com.sun.security.auth.module.UnixLoginModule required;
 *   com.sun.security.auth.module.Krb5LoginModule optional
 *                   useTicketCache=&quot;true&quot;
 *                   ticketCache=&quot;${user.home}${/}tickets&quot;;
 * };
 * &lt;/pre&gt;
 *
 * &lt;p&gt; This {@code Configuration} specifies that an application named,
 * &quot;Login&quot;, requires users to first authenticate to the
 * &lt;i&gt;com.sun.security.auth.module.UnixLoginModule&lt;/i&gt;, which is
 * required to succeed.  Even if the &lt;i&gt;UnixLoginModule&lt;/i&gt;
 * authentication fails, the
 * &lt;i&gt;com.sun.security.auth.module.Krb5LoginModule&lt;/i&gt;
 * still gets invoked.  This helps hide the source of failure.
 * Since the &lt;i&gt;Krb5LoginModule&lt;/i&gt; is &lt;i&gt;Optional&lt;/i&gt;, the overall
 * authentication succeeds only if the &lt;i&gt;UnixLoginModule&lt;/i&gt;
 * (&lt;i&gt;Required&lt;/i&gt;) succeeds.
 *
 * &lt;p&gt; Also note that the LoginModule-specific options,
 * &lt;i&gt;useTicketCache=&quot;true&quot;&lt;/i&gt; and
 * &lt;i&gt;ticketCache=${user.home}${/}tickets&quot;&lt;/i&gt;,
 * are passed to the &lt;i&gt;Krb5LoginModule&lt;/i&gt;.
 * These options instruct the &lt;i&gt;Krb5LoginModule&lt;/i&gt; to
 * use the ticket cache at the specified location.
 * The system properties, &lt;i&gt;user.home&lt;/i&gt; and &lt;i&gt;/&lt;/i&gt;
 * (file.separator), are expanded to their respective values.
 *
 * &lt;p&gt; There is only one Configuration object installed in the runtime at any
 * given time.  A Configuration object can be installed by calling the
 * {@code setConfiguration} method.  The installed Configuration object
 * can be obtained by calling the {@code getConfiguration} method.
 *
 * &lt;p&gt; If no Configuration object has been installed in the runtime, a call to
 * {@code getConfiguration} installs an instance of the default
 * Configuration implementation (a default subclass implementation of this
 * abstract class).
 * The default Configuration implementation can be changed by setting the value
 * of the {@code login.configuration.provider} security property to the fully
 * qualified name of the desired Configuration subclass implementation.
 *
 * &lt;p&gt; Application code can directly subclass Configuration to provide a custom
 * implementation.  In addition, an instance of a Configuration object can be
 * constructed by invoking one of the {@code getInstance} factory methods
 * with a standard type.  The default policy type is &quot;JavaLoginConfig&quot;.
 * See the Configuration section in the &lt;a href=
 * &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Configuration&quot;&gt;
 * Java Cryptography Architecture Standard Algorithm Name Documentation&lt;/a&gt;
 * for a list of standard Configuration types.
 *
 * @see javax.security.auth.login.LoginContext
 * @see java.security.Security security properties
 */
public abstract class Configuration {

    private static Configuration configuration;
    private static ClassLoader contextClassLoader;

    static {
<span class="fc" id="L197">        contextClassLoader = AccessController.doPrivileged</span>
<span class="fc" id="L198">                (new PrivilegedAction&lt;ClassLoader&gt;() {</span>
                public ClassLoader run() {
<span class="fc" id="L200">                    return Thread.currentThread().getContextClassLoader();</span>
                }
        });
<span class="fc" id="L203">    };</span>

    private static void checkPermission(String type) {
<span class="fc" id="L206">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (sm != null) {</span>
<span class="fc" id="L208">            sm.checkPermission(new AuthPermission</span>
                                (&quot;createLoginConfiguration.&quot; + type));
        }
<span class="fc" id="L211">    }</span>

    /**
     * Sole constructor.  (For invocation by subclass constructors, typically
     * implicit.)
     */
<span class="fc" id="L217">    protected Configuration() { }</span>

    /**
     * Get the installed login Configuration.
     *
     * &lt;p&gt;
     *
     * @return the login Configuration.  If a Configuration object was set
     *          via the {@code Configuration.setConfiguration} method,
     *          then that object is returned.  Otherwise, a default
     *          Configuration object is returned.
     *
     * @exception SecurityException if the caller does not have permission
     *                          to retrieve the Configuration.
     *
     * @see #setConfiguration
     */
    public static Configuration getConfiguration() {

<span class="fc" id="L236">        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (sm != null)</span>
<span class="fc" id="L238">            sm.checkPermission(new AuthPermission(&quot;getLoginConfiguration&quot;));</span>

<span class="fc" id="L240">        synchronized (Configuration.class) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">            if (configuration == null) {</span>
<span class="fc" id="L242">                String config_class = null;</span>
<span class="fc" id="L243">                config_class = AccessController.doPrivileged</span>
<span class="fc" id="L244">                    (new PrivilegedAction&lt;String&gt;() {</span>
                    public String run() {
<span class="fc" id="L246">                        return java.security.Security.getProperty</span>
<span class="fc" id="L247">                                    (&quot;login.configuration.provider&quot;);</span>
                    }
                });
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">                if (config_class == null) {</span>
<span class="nc" id="L251">                    config_class = &quot;sun.security.provider.ConfigFile&quot;;</span>
                }

                try {
<span class="fc" id="L255">                    final String finalClass = config_class;</span>
<span class="fc" id="L256">                    configuration = AccessController.doPrivileged</span>
<span class="fc" id="L257">                        (new PrivilegedExceptionAction&lt;Configuration&gt;() {</span>
                        public Configuration run() throws ClassNotFoundException,
                                            InstantiationException,
                                            IllegalAccessException {
<span class="fc" id="L261">                            return (Configuration)Class.forName</span>
<span class="fc" id="L262">                                    (finalClass,</span>
                                    true,
<span class="fc" id="L264">                                    contextClassLoader).newInstance();</span>
                        }
                    });
<span class="nc" id="L267">                } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L268">                    Exception ee = e.getException();</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">                    if (ee instanceof InstantiationException) {</span>
<span class="nc" id="L270">                        throw (SecurityException) new</span>
                            SecurityException
                                    (&quot;Configuration error:&quot; +
<span class="nc" id="L273">                                     ee.getCause().getMessage() +</span>
<span class="nc" id="L274">                                     &quot;\n&quot;).initCause(ee.getCause());</span>
                    } else {
<span class="nc" id="L276">                        throw (SecurityException) new</span>
                            SecurityException
                                    (&quot;Configuration error: &quot; +
<span class="nc" id="L279">                                     ee.toString() +</span>
<span class="nc" id="L280">                                     &quot;\n&quot;).initCause(ee);</span>
                    }
<span class="fc" id="L282">                }</span>
            }
<span class="fc" id="L284">            return configuration;</span>
<span class="fc" id="L285">        }</span>
    }

    /**
     * Set the login {@code Configuration}.
     *
     * &lt;p&gt;
     *
     * @param configuration the new {@code Configuration}
     *
     * @exception SecurityException if the current thread does not have
     *                  Permission to set the {@code Configuration}.
     *
     * @see #getConfiguration
     */
    public static void setConfiguration(Configuration configuration) {
<span class="nc" id="L301">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (sm != null)</span>
<span class="nc" id="L303">            sm.checkPermission(new AuthPermission(&quot;setLoginConfiguration&quot;));</span>
<span class="nc" id="L304">        Configuration.configuration = configuration;</span>
<span class="nc" id="L305">    }</span>

    /**
     * Returns a Configuration object of the specified type.
     *
     * &lt;p&gt; This method traverses the list of registered security providers,
     * starting with the most preferred Provider.
     * A new Configuration object encapsulating the
     * ConfigurationSpi implementation from the first
     * Provider that supports the specified type is returned.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param type the specified Configuration type.  See the Configuration
     *    section in the &lt;a href=
     *    &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Configuration&quot;&gt;
     *    Java Cryptography Architecture Standard Algorithm Name
     *    Documentation&lt;/a&gt; for a list of standard Configuration types.
     *
     * @param params parameters for the Configuration, which may be null.
     *
     * @return the new Configuration object.
     *
     * @exception SecurityException if the caller does not have permission
     *          to get a Configuration instance for the specified type.
     *
     * @exception NullPointerException if the specified type is null.
     *
     * @exception IllegalArgumentException if the specified parameters
     *          are not understood by the ConfigurationSpi implementation
     *          from the selected Provider.
     *
     * @exception NoSuchAlgorithmException if no Provider supports a
     *          ConfigurationSpi implementation for the specified type.
     *
     * @see Provider
     * @since 1.6
     */
    public static Configuration getInstance(String type,
                                Configuration.Parameters params)
                throws NoSuchAlgorithmException {

<span class="fc" id="L348">        checkPermission(type);</span>
        try {
<span class="fc" id="L350">            GetInstance.Instance instance = GetInstance.getInstance</span>
<span class="fc" id="L351">                                                        (&quot;Configuration&quot;,</span>
                                                        ConfigurationSpi.class,
                                                        type,
                                                        params);
<span class="fc" id="L355">            return new ConfigDelegate((ConfigurationSpi)instance.impl,</span>
                                                        instance.provider,
                                                        type,
                                                        params);
<span class="nc" id="L359">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L360">            return handleException (nsae);</span>
        }
    }

    /**
     * Returns a Configuration object of the specified type.
     *
     * &lt;p&gt; A new Configuration object encapsulating the
     * ConfigurationSpi implementation from the specified provider
     * is returned.   The specified provider must be registered
     * in the provider list.
     *
     * &lt;p&gt; Note that the list of registered providers may be retrieved via
     * the {@link Security#getProviders() Security.getProviders()} method.
     *
     * @param type the specified Configuration type.  See the Configuration
     *    section in the &lt;a href=
     *    &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Configuration&quot;&gt;
     *    Java Cryptography Architecture Standard Algorithm Name
     *    Documentation&lt;/a&gt; for a list of standard Configuration types.
     *
     * @param params parameters for the Configuration, which may be null.
     *
     * @param provider the provider.
     *
     * @return the new Configuration object.
     *
     * @exception SecurityException if the caller does not have permission
     *          to get a Configuration instance for the specified type.
     *
     * @exception NullPointerException if the specified type is null.
     *
     * @exception IllegalArgumentException if the specified provider
     *          is null or empty,
     *          or if the specified parameters are not understood by
     *          the ConfigurationSpi implementation from the specified provider.
     *
     * @exception NoSuchProviderException if the specified provider is not
     *          registered in the security provider list.
     *
     * @exception NoSuchAlgorithmException if the specified provider does not
     *          support a ConfigurationSpi implementation for the specified
     *          type.
     *
     * @see Provider
     * @since 1.6
     */
    public static Configuration getInstance(String type,
                                Configuration.Parameters params,
                                String provider)
                throws NoSuchProviderException, NoSuchAlgorithmException {

<span class="pc bpc" id="L412" title="2 of 4 branches missed.">        if (provider == null || provider.length() == 0) {</span>
<span class="nc" id="L413">            throw new IllegalArgumentException(&quot;missing provider&quot;);</span>
        }

<span class="fc" id="L416">        checkPermission(type);</span>
        try {
<span class="fc" id="L418">            GetInstance.Instance instance = GetInstance.getInstance</span>
<span class="fc" id="L419">                                                        (&quot;Configuration&quot;,</span>
                                                        ConfigurationSpi.class,
                                                        type,
                                                        params,
                                                        provider);
<span class="fc" id="L424">            return new ConfigDelegate((ConfigurationSpi)instance.impl,</span>
                                                        instance.provider,
                                                        type,
                                                        params);
<span class="nc" id="L428">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L429">            return handleException (nsae);</span>
        }
    }

    /**
     * Returns a Configuration object of the specified type.
     *
     * &lt;p&gt; A new Configuration object encapsulating the
     * ConfigurationSpi implementation from the specified Provider
     * object is returned.  Note that the specified Provider object
     * does not have to be registered in the provider list.
     *
     * @param type the specified Configuration type.  See the Configuration
     *    section in the &lt;a href=
     *    &quot;{@docRoot}/../technotes/guides/security/StandardNames.html#Configuration&quot;&gt;
     *    Java Cryptography Architecture Standard Algorithm Name
     *    Documentation&lt;/a&gt; for a list of standard Configuration types.
     *
     * @param params parameters for the Configuration, which may be null.
     *
     * @param provider the Provider.
     *
     * @return the new Configuration object.
     *
     * @exception SecurityException if the caller does not have permission
     *          to get a Configuration instance for the specified type.
     *
     * @exception NullPointerException if the specified type is null.
     *
     * @exception IllegalArgumentException if the specified Provider is null,
     *          or if the specified parameters are not understood by
     *          the ConfigurationSpi implementation from the specified Provider.
     *
     * @exception NoSuchAlgorithmException if the specified Provider does not
     *          support a ConfigurationSpi implementation for the specified
     *          type.
     *
     * @see Provider
     * @since 1.6
     */
    public static Configuration getInstance(String type,
                                Configuration.Parameters params,
                                Provider provider)
                throws NoSuchAlgorithmException {

<span class="pc bpc" id="L474" title="1 of 2 branches missed.">        if (provider == null) {</span>
<span class="nc" id="L475">            throw new IllegalArgumentException(&quot;missing provider&quot;);</span>
        }

<span class="fc" id="L478">        checkPermission(type);</span>
        try {
<span class="fc" id="L480">            GetInstance.Instance instance = GetInstance.getInstance</span>
<span class="fc" id="L481">                                                        (&quot;Configuration&quot;,</span>
                                                        ConfigurationSpi.class,
                                                        type,
                                                        params,
                                                        provider);
<span class="fc" id="L486">            return new ConfigDelegate((ConfigurationSpi)instance.impl,</span>
                                                        instance.provider,
                                                        type,
                                                        params);
<span class="nc" id="L490">        } catch (NoSuchAlgorithmException nsae) {</span>
<span class="nc" id="L491">            return handleException (nsae);</span>
        }
    }

    private static Configuration handleException(NoSuchAlgorithmException nsae)
                throws NoSuchAlgorithmException {
<span class="fc" id="L497">        Throwable cause = nsae.getCause();</span>
<span class="fc bfc" id="L498" title="All 2 branches covered.">        if (cause instanceof IllegalArgumentException) {</span>
<span class="fc" id="L499">            throw (IllegalArgumentException)cause;</span>
        }
<span class="fc" id="L501">        throw nsae;</span>
    }

    /**
     * Return the Provider of this Configuration.
     *
     * &lt;p&gt; This Configuration instance will only have a Provider if it
     * was obtained via a call to {@code Configuration.getInstance}.
     * Otherwise this method returns null.
     *
     * @return the Provider of this Configuration, or null.
     *
     * @since 1.6
     */
    public Provider getProvider() {
<span class="nc" id="L516">        return null;</span>
    }

    /**
     * Return the type of this Configuration.
     *
     * &lt;p&gt; This Configuration instance will only have a type if it
     * was obtained via a call to {@code Configuration.getInstance}.
     * Otherwise this method returns null.
     *
     * @return the type of this Configuration, or null.
     *
     * @since 1.6
     */
    public String getType() {
<span class="nc" id="L531">        return null;</span>
    }

    /**
     * Return Configuration parameters.
     *
     * &lt;p&gt; This Configuration instance will only have parameters if it
     * was obtained via a call to {@code Configuration.getInstance}.
     * Otherwise this method returns null.
     *
     * @return Configuration parameters, or null.
     *
     * @since 1.6
     */
    public Configuration.Parameters getParameters() {
<span class="nc" id="L546">        return null;</span>
    }

    /**
     * Retrieve the AppConfigurationEntries for the specified &lt;i&gt;name&lt;/i&gt;
     * from this Configuration.
     *
     * &lt;p&gt;
     *
     * @param name the name used to index the Configuration.
     *
     * @return an array of AppConfigurationEntries for the specified &lt;i&gt;name&lt;/i&gt;
     *          from this Configuration, or null if there are no entries
     *          for the specified &lt;i&gt;name&lt;/i&gt;
     */
    public abstract AppConfigurationEntry[] getAppConfigurationEntry
                                                        (String name);

    /**
     * Refresh and reload the Configuration.
     *
     * &lt;p&gt; This method causes this Configuration object to refresh/reload its
     * contents in an implementation-dependent manner.
     * For example, if this Configuration object stores its entries in a file,
     * calling {@code refresh} may cause the file to be re-read.
     *
     * &lt;p&gt; The default implementation of this method does nothing.
     * This method should be overridden if a refresh operation is supported
     * by the implementation.
     *
     * @exception SecurityException if the caller does not have permission
     *                          to refresh its Configuration.
     */
<span class="nc" id="L579">    public void refresh() { }</span>

    /**
     * This subclass is returned by the getInstance calls.  All Configuration
     * calls are delegated to the underlying ConfigurationSpi.
     */
    private static class ConfigDelegate extends Configuration {

        private ConfigurationSpi spi;
        private Provider p;
        private String type;
        private Configuration.Parameters params;

        private ConfigDelegate(ConfigurationSpi spi, Provider p,
<span class="fc" id="L593">                        String type, Configuration.Parameters params) {</span>
<span class="fc" id="L594">            this.spi = spi;</span>
<span class="fc" id="L595">            this.p = p;</span>
<span class="fc" id="L596">            this.type = type;</span>
<span class="fc" id="L597">            this.params = params;</span>
<span class="fc" id="L598">        }</span>

<span class="fc" id="L600">        public String getType() { return type; }</span>

<span class="fc" id="L602">        public Configuration.Parameters getParameters() { return params; }</span>

<span class="fc" id="L604">        public Provider getProvider() { return p; }</span>

        public AppConfigurationEntry[] getAppConfigurationEntry(String name) {
<span class="fc" id="L607">            return spi.engineGetAppConfigurationEntry(name);</span>
        }

        public void refresh() {
<span class="nc" id="L611">            spi.engineRefresh();</span>
<span class="nc" id="L612">        }</span>
    }

    /**
     * This represents a marker interface for Configuration parameters.
     *
     * @since 1.6
     */
    public static interface Parameters { }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>