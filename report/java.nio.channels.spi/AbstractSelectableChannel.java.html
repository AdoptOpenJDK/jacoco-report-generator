<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractSelectableChannel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.nio.channels.spi</a> &gt; <span class="el_source">AbstractSelectableChannel.java</span></div><h1>AbstractSelectableChannel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.nio.channels.spi;

import java.io.IOException;
import java.nio.channels.*;


/**
 * Base implementation class for selectable channels.
 *
 * &lt;p&gt; This class defines methods that handle the mechanics of channel
 * registration, deregistration, and closing.  It maintains the current
 * blocking mode of this channel as well as its current set of selection keys.
 * It performs all of the synchronization required to implement the {@link
 * java.nio.channels.SelectableChannel} specification.  Implementations of the
 * abstract protected methods defined in this class need not synchronize
 * against other threads that might be engaged in the same operations.  &lt;/p&gt;
 *
 *
 * @author Mark Reinhold
 * @author Mike McCloskey
 * @author JSR-51 Expert Group
 * @since 1.4
 */

<span class="fc bfc" id="L50" title="All 2 branches covered.">public abstract class AbstractSelectableChannel</span>
    extends SelectableChannel
{

    // The provider that created this channel
    private final SelectorProvider provider;

    // Keys that have been created by registering this channel with selectors.
    // They are saved because if this channel is closed the keys must be
    // deregistered.  Protected by keyLock.
    //
<span class="fc" id="L61">    private SelectionKey[] keys = null;</span>
<span class="fc" id="L62">    private int keyCount = 0;</span>

    // Lock for key set and count
<span class="fc" id="L65">    private final Object keyLock = new Object();</span>

    // Lock for registration and configureBlocking operations
<span class="fc" id="L68">    private final Object regLock = new Object();</span>

    // Blocking mode, protected by regLock
<span class="fc" id="L71">    boolean blocking = true;</span>

    /**
     * Initializes a new instance of this class.
     *
     * @param  provider
     *         The provider that created this channel
     */
<span class="fc" id="L79">    protected AbstractSelectableChannel(SelectorProvider provider) {</span>
<span class="fc" id="L80">        this.provider = provider;</span>
<span class="fc" id="L81">    }</span>

    /**
     * Returns the provider that created this channel.
     *
     * @return  The provider that created this channel
     */
    public final SelectorProvider provider() {
<span class="fc" id="L89">        return provider;</span>
    }


    // -- Utility methods for the key set --

    private void addKey(SelectionKey k) {
<span class="pc bpc" id="L96" title="2 of 4 branches missed.">        assert Thread.holdsLock(keyLock);</span>
<span class="fc" id="L97">        int i = 0;</span>
<span class="fc bfc" id="L98" title="All 4 branches covered.">        if ((keys != null) &amp;&amp; (keyCount &lt; keys.length)) {</span>
            // Find empty element of key array
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">            for (i = 0; i &lt; keys.length; i++)</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">                if (keys[i] == null)</span>
<span class="fc" id="L102">                    break;</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        } else if (keys == null) {</span>
<span class="fc" id="L104">            keys =  new SelectionKey[3];</span>
        } else {
            // Grow key array
<span class="fc" id="L107">            int n = keys.length * 2;</span>
<span class="fc" id="L108">            SelectionKey[] ks =  new SelectionKey[n];</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">            for (i = 0; i &lt; keys.length; i++)</span>
<span class="fc" id="L110">                ks[i] = keys[i];</span>
<span class="fc" id="L111">            keys = ks;</span>
<span class="fc" id="L112">            i = keyCount;</span>
        }
<span class="fc" id="L114">        keys[i] = k;</span>
<span class="fc" id="L115">        keyCount++;</span>
<span class="fc" id="L116">    }</span>

    private SelectionKey findKey(Selector sel) {
<span class="fc" id="L119">        synchronized (keyLock) {</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">            if (keys == null)</span>
<span class="fc" id="L121">                return null;</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            for (int i = 0; i &lt; keys.length; i++)</span>
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">                if ((keys[i] != null) &amp;&amp; (keys[i].selector() == sel))</span>
<span class="nc" id="L124">                    return keys[i];</span>
<span class="fc" id="L125">            return null;</span>
<span class="nc" id="L126">        }</span>
    }

    void removeKey(SelectionKey k) {                    // package-private
<span class="fc" id="L130">        synchronized (keyLock) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            for (int i = 0; i &lt; keys.length; i++)</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">                if (keys[i] == k) {</span>
<span class="fc" id="L133">                    keys[i] = null;</span>
<span class="fc" id="L134">                    keyCount--;</span>
                }
<span class="fc" id="L136">            ((AbstractSelectionKey)k).invalidate();</span>
<span class="pc" id="L137">        }</span>
<span class="fc" id="L138">    }</span>

    private boolean haveValidKeys() {
<span class="fc" id="L141">        synchronized (keyLock) {</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">            if (keyCount == 0)</span>
<span class="fc" id="L143">                return false;</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            for (int i = 0; i &lt; keys.length; i++) {</span>
<span class="pc bpc" id="L145" title="1 of 4 branches missed.">                if ((keys[i] != null) &amp;&amp; keys[i].isValid())</span>
<span class="nc" id="L146">                    return true;</span>
            }
<span class="fc" id="L148">            return false;</span>
<span class="nc" id="L149">        }</span>
    }


    // -- Registration --

    public final boolean isRegistered() {
<span class="fc" id="L156">        synchronized (keyLock) {</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            return keyCount != 0;</span>
<span class="nc" id="L158">        }</span>
    }

    public final SelectionKey keyFor(Selector sel) {
<span class="nc" id="L162">        return findKey(sel);</span>
    }

    /**
     * Registers this channel with the given selector, returning a selection key.
     *
     * &lt;p&gt;  This method first verifies that this channel is open and that the
     * given initial interest set is valid.
     *
     * &lt;p&gt; If this channel is already registered with the given selector then
     * the selection key representing that registration is returned after
     * setting its interest set to the given value.
     *
     * &lt;p&gt; Otherwise this channel has not yet been registered with the given
     * selector, so the {@link AbstractSelector#register register} method of
     * the selector is invoked while holding the appropriate locks.  The
     * resulting key is added to this channel's key set before being returned.
     * &lt;/p&gt;
     *
     * @throws  ClosedSelectorException {@inheritDoc}
     *
     * @throws  IllegalBlockingModeException {@inheritDoc}
     *
     * @throws  IllegalSelectorException {@inheritDoc}
     *
     * @throws  CancelledKeyException {@inheritDoc}
     *
     * @throws  IllegalArgumentException {@inheritDoc}
     */
    public final SelectionKey register(Selector sel, int ops,
                                       Object att)
        throws ClosedChannelException
    {
<span class="fc" id="L195">        synchronized (regLock) {</span>
<span class="pc bpc" id="L196" title="1 of 2 branches missed.">            if (!isOpen())</span>
<span class="nc" id="L197">                throw new ClosedChannelException();</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            if ((ops &amp; ~validOps()) != 0)</span>
<span class="nc" id="L199">                throw new IllegalArgumentException();</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            if (blocking)</span>
<span class="nc" id="L201">                throw new IllegalBlockingModeException();</span>
<span class="fc" id="L202">            SelectionKey k = findKey(sel);</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">            if (k != null) {</span>
<span class="nc" id="L204">                k.interestOps(ops);</span>
<span class="nc" id="L205">                k.attach(att);</span>
            }
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">            if (k == null) {</span>
                // New registration
<span class="fc" id="L209">                synchronized (keyLock) {</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">                    if (!isOpen())</span>
<span class="nc" id="L211">                        throw new ClosedChannelException();</span>
<span class="fc" id="L212">                    k = ((AbstractSelector)sel).register(this, ops, att);</span>
<span class="fc" id="L213">                    addKey(k);</span>
<span class="pc" id="L214">                }</span>
            }
<span class="fc" id="L216">            return k;</span>
<span class="nc" id="L217">        }</span>
    }


    // -- Closing --

    /**
     * Closes this channel.
     *
     * &lt;p&gt; This method, which is specified in the {@link
     * AbstractInterruptibleChannel} class and is invoked by the {@link
     * java.nio.channels.Channel#close close} method, in turn invokes the
     * {@link #implCloseSelectableChannel implCloseSelectableChannel} method in
     * order to perform the actual work of closing this channel.  It then
     * cancels all of this channel's keys.  &lt;/p&gt;
     */
    protected final void implCloseChannel() throws IOException {
<span class="fc" id="L234">        implCloseSelectableChannel();</span>
<span class="fc" id="L235">        synchronized (keyLock) {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            int count = (keys == null) ? 0 : keys.length;</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            for (int i = 0; i &lt; count; i++) {</span>
<span class="fc" id="L238">                SelectionKey k = keys[i];</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">                if (k != null)</span>
<span class="fc" id="L240">                    k.cancel();</span>
            }
<span class="pc" id="L242">        }</span>
<span class="fc" id="L243">    }</span>

    /**
     * Closes this selectable channel.
     *
     * &lt;p&gt; This method is invoked by the {@link java.nio.channels.Channel#close
     * close} method in order to perform the actual work of closing the
     * channel.  This method is only invoked if the channel has not yet been
     * closed, and it is never invoked more than once.
     *
     * &lt;p&gt; An implementation of this method must arrange for any other thread
     * that is blocked in an I/O operation upon this channel to return
     * immediately, either by throwing an exception or by returning normally.
     * &lt;/p&gt;
     *
     * @throws  IOException
     *          If an I/O error occurs
     */
    protected abstract void implCloseSelectableChannel() throws IOException;


    // -- Blocking --

    public final boolean isBlocking() {
<span class="fc" id="L267">        synchronized (regLock) {</span>
<span class="fc" id="L268">            return blocking;</span>
<span class="nc" id="L269">        }</span>
    }

    public final Object blockingLock() {
<span class="fc" id="L273">        return regLock;</span>
    }

    /**
     * Adjusts this channel's blocking mode.
     *
     * &lt;p&gt; If the given blocking mode is different from the current blocking
     * mode then this method invokes the {@link #implConfigureBlocking
     * implConfigureBlocking} method, while holding the appropriate locks, in
     * order to change the mode.  &lt;/p&gt;
     */
    public final SelectableChannel configureBlocking(boolean block)
        throws IOException
    {
<span class="fc" id="L287">        synchronized (regLock) {</span>
<span class="pc bpc" id="L288" title="1 of 2 branches missed.">            if (!isOpen())</span>
<span class="nc" id="L289">                throw new ClosedChannelException();</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">            if (blocking == block)</span>
<span class="fc" id="L291">                return this;</span>
<span class="pc bpc" id="L292" title="1 of 4 branches missed.">            if (block &amp;&amp; haveValidKeys())</span>
<span class="nc" id="L293">                throw new IllegalBlockingModeException();</span>
<span class="fc" id="L294">            implConfigureBlocking(block);</span>
<span class="fc" id="L295">            blocking = block;</span>
<span class="pc" id="L296">        }</span>
<span class="fc" id="L297">        return this;</span>
    }

    /**
     * Adjusts this channel's blocking mode.
     *
     * &lt;p&gt; This method is invoked by the {@link #configureBlocking
     * configureBlocking} method in order to perform the actual work of
     * changing the blocking mode.  This method is only invoked if the new mode
     * is different from the current mode.  &lt;/p&gt;
     *
     * @param  block  If &lt;tt&gt;true&lt;/tt&gt; then this channel will be placed in
     *                blocking mode; if &lt;tt&gt;false&lt;/tt&gt; then it will be placed
     *                non-blocking mode
     *
     * @throws IOException
     *         If an I/O error occurs
     */
    protected abstract void implConfigureBlocking(boolean block)
        throws IOException;

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>