<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ICC_Profile.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.color</a> &gt; <span class="el_source">ICC_Profile.java</span></div><h1>ICC_Profile.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/**********************************************************************
 **********************************************************************
 **********************************************************************
 *** COPYRIGHT (c) Eastman Kodak Company, 1997                      ***
 *** As  an unpublished  work pursuant to Title 17 of the United    ***
 *** States Code.  All rights reserved.                             ***
 **********************************************************************
 **********************************************************************
 **********************************************************************/

package java.awt.color;

import sun.java2d.cmm.PCMM;
import sun.java2d.cmm.CMSManager;
import sun.java2d.cmm.Profile;
import sun.java2d.cmm.ProfileDataVerifier;
import sun.java2d.cmm.ProfileDeferralMgr;
import sun.java2d.cmm.ProfileDeferralInfo;
import sun.java2d.cmm.ProfileActivator;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamException;
import java.io.OutputStream;
import java.io.Serializable;

import java.util.StringTokenizer;

import java.security.AccessController;
import java.security.PrivilegedAction;


/**
 * A representation of color profile data for device independent and
 * device dependent color spaces based on the International Color
 * Consortium Specification ICC.1:2001-12, File Format for Color Profiles,
 * (see &lt;A href=&quot;http://www.color.org&quot;&gt; http://www.color.org&lt;/A&gt;).
 * &lt;p&gt;
 * An ICC_ColorSpace object can be constructed from an appropriate
 * ICC_Profile.
 * Typically, an ICC_ColorSpace would be associated with an ICC
 * Profile which is either an input, display, or output profile (see
 * the ICC specification).  There are also device link, abstract,
 * color space conversion, and named color profiles.  These are less
 * useful for tagging a color or image, but are useful for other
 * purposes (in particular device link profiles can provide improved
 * performance for converting from one device's color space to
 * another's).
 * &lt;p&gt;
 * ICC Profiles represent transformations from the color space of
 * the profile (e.g. a monitor) to a Profile Connection Space (PCS).
 * Profiles of interest for tagging images or colors have a PCS
 * which is one of the two specific device independent
 * spaces (one CIEXYZ space and one CIELab space) defined in the
 * ICC Profile Format Specification.  Most profiles of interest
 * either have invertible transformations or explicitly specify
 * transformations going both directions.
 * &lt;p&gt;
 * @see ICC_ColorSpace
 */


public class ICC_Profile implements Serializable {

    private static final long serialVersionUID = -3938515861990936766L;

    private transient Profile cmmProfile;

    private transient ProfileDeferralInfo deferralInfo;
    private transient ProfileActivator profileActivator;

    // Registry of singleton profile objects for specific color spaces
    // defined in the ColorSpace class (e.g. CS_sRGB), see
    // getInstance(int cspace) factory method.
    private static ICC_Profile sRGBprofile;
    private static ICC_Profile XYZprofile;
    private static ICC_Profile PYCCprofile;
    private static ICC_Profile GRAYprofile;
    private static ICC_Profile LINEAR_RGBprofile;


    /**
     * Profile class is input.
     */
    public static final int CLASS_INPUT = 0;

    /**
     * Profile class is display.
     */
    public static final int CLASS_DISPLAY = 1;

    /**
     * Profile class is output.
     */
    public static final int CLASS_OUTPUT = 2;

    /**
     * Profile class is device link.
     */
    public static final int CLASS_DEVICELINK = 3;

    /**
     * Profile class is color space conversion.
     */
    public static final int CLASS_COLORSPACECONVERSION = 4;

    /**
     * Profile class is abstract.
     */
    public static final int CLASS_ABSTRACT = 5;

    /**
     * Profile class is named color.
     */
    public static final int CLASS_NAMEDCOLOR = 6;


    /**
     * ICC Profile Color Space Type Signature: 'XYZ '.
     */
    public static final int icSigXYZData        = 0x58595A20;    /* 'XYZ ' */

    /**
     * ICC Profile Color Space Type Signature: 'Lab '.
     */
    public static final int icSigLabData        = 0x4C616220;    /* 'Lab ' */

    /**
     * ICC Profile Color Space Type Signature: 'Luv '.
     */
    public static final int icSigLuvData        = 0x4C757620;    /* 'Luv ' */

    /**
     * ICC Profile Color Space Type Signature: 'YCbr'.
     */
    public static final int icSigYCbCrData        = 0x59436272;    /* 'YCbr' */

    /**
     * ICC Profile Color Space Type Signature: 'Yxy '.
     */
    public static final int icSigYxyData        = 0x59787920;    /* 'Yxy ' */

    /**
     * ICC Profile Color Space Type Signature: 'RGB '.
     */
    public static final int icSigRgbData        = 0x52474220;    /* 'RGB ' */

    /**
     * ICC Profile Color Space Type Signature: 'GRAY'.
     */
    public static final int icSigGrayData        = 0x47524159;    /* 'GRAY' */

    /**
     * ICC Profile Color Space Type Signature: 'HSV'.
     */
    public static final int icSigHsvData        = 0x48535620;    /* 'HSV ' */

    /**
     * ICC Profile Color Space Type Signature: 'HLS'.
     */
    public static final int icSigHlsData        = 0x484C5320;    /* 'HLS ' */

    /**
     * ICC Profile Color Space Type Signature: 'CMYK'.
     */
    public static final int icSigCmykData        = 0x434D594B;    /* 'CMYK' */

    /**
     * ICC Profile Color Space Type Signature: 'CMY '.
     */
    public static final int icSigCmyData        = 0x434D5920;    /* 'CMY ' */

    /**
     * ICC Profile Color Space Type Signature: '2CLR'.
     */
    public static final int icSigSpace2CLR        = 0x32434C52;    /* '2CLR' */

    /**
     * ICC Profile Color Space Type Signature: '3CLR'.
     */
    public static final int icSigSpace3CLR        = 0x33434C52;    /* '3CLR' */

    /**
     * ICC Profile Color Space Type Signature: '4CLR'.
     */
    public static final int icSigSpace4CLR        = 0x34434C52;    /* '4CLR' */

    /**
     * ICC Profile Color Space Type Signature: '5CLR'.
     */
    public static final int icSigSpace5CLR        = 0x35434C52;    /* '5CLR' */

    /**
     * ICC Profile Color Space Type Signature: '6CLR'.
     */
    public static final int icSigSpace6CLR        = 0x36434C52;    /* '6CLR' */

    /**
     * ICC Profile Color Space Type Signature: '7CLR'.
     */
    public static final int icSigSpace7CLR        = 0x37434C52;    /* '7CLR' */

    /**
     * ICC Profile Color Space Type Signature: '8CLR'.
     */
    public static final int icSigSpace8CLR        = 0x38434C52;    /* '8CLR' */

    /**
     * ICC Profile Color Space Type Signature: '9CLR'.
     */
    public static final int icSigSpace9CLR        = 0x39434C52;    /* '9CLR' */

    /**
     * ICC Profile Color Space Type Signature: 'ACLR'.
     */
    public static final int icSigSpaceACLR        = 0x41434C52;    /* 'ACLR' */

    /**
     * ICC Profile Color Space Type Signature: 'BCLR'.
     */
    public static final int icSigSpaceBCLR        = 0x42434C52;    /* 'BCLR' */

    /**
     * ICC Profile Color Space Type Signature: 'CCLR'.
     */
    public static final int icSigSpaceCCLR        = 0x43434C52;    /* 'CCLR' */

    /**
     * ICC Profile Color Space Type Signature: 'DCLR'.
     */
    public static final int icSigSpaceDCLR        = 0x44434C52;    /* 'DCLR' */

    /**
     * ICC Profile Color Space Type Signature: 'ECLR'.
     */
    public static final int icSigSpaceECLR        = 0x45434C52;    /* 'ECLR' */

    /**
     * ICC Profile Color Space Type Signature: 'FCLR'.
     */
    public static final int icSigSpaceFCLR        = 0x46434C52;    /* 'FCLR' */


    /**
     * ICC Profile Class Signature: 'scnr'.
     */
    public static final int icSigInputClass       = 0x73636E72;    /* 'scnr' */

    /**
     * ICC Profile Class Signature: 'mntr'.
     */
    public static final int icSigDisplayClass     = 0x6D6E7472;    /* 'mntr' */

    /**
     * ICC Profile Class Signature: 'prtr'.
     */
    public static final int icSigOutputClass      = 0x70727472;    /* 'prtr' */

    /**
     * ICC Profile Class Signature: 'link'.
     */
    public static final int icSigLinkClass        = 0x6C696E6B;    /* 'link' */

    /**
     * ICC Profile Class Signature: 'abst'.
     */
    public static final int icSigAbstractClass    = 0x61627374;    /* 'abst' */

    /**
     * ICC Profile Class Signature: 'spac'.
     */
    public static final int icSigColorSpaceClass  = 0x73706163;    /* 'spac' */

    /**
     * ICC Profile Class Signature: 'nmcl'.
     */
    public static final int icSigNamedColorClass  = 0x6e6d636c;    /* 'nmcl' */


    /**
     * ICC Profile Rendering Intent: Perceptual.
     */
    public static final int icPerceptual            = 0;

    /**
     * ICC Profile Rendering Intent: RelativeColorimetric.
     */
    public static final int icRelativeColorimetric    = 1;

    /**
     * ICC Profile Rendering Intent: Media-RelativeColorimetric.
     * @since 1.5
     */
    public static final int icMediaRelativeColorimetric = 1;

    /**
     * ICC Profile Rendering Intent: Saturation.
     */
    public static final int icSaturation            = 2;

    /**
     * ICC Profile Rendering Intent: AbsoluteColorimetric.
     */
    public static final int icAbsoluteColorimetric    = 3;

    /**
     * ICC Profile Rendering Intent: ICC-AbsoluteColorimetric.
     * @since 1.5
     */
    public static final int icICCAbsoluteColorimetric = 3;


    /**
     * ICC Profile Tag Signature: 'head' - special.
     */
    public static final int icSigHead      = 0x68656164; /* 'head' - special */

    /**
     * ICC Profile Tag Signature: 'A2B0'.
     */
    public static final int icSigAToB0Tag         = 0x41324230;    /* 'A2B0' */

    /**
     * ICC Profile Tag Signature: 'A2B1'.
     */
    public static final int icSigAToB1Tag         = 0x41324231;    /* 'A2B1' */

    /**
     * ICC Profile Tag Signature: 'A2B2'.
     */
    public static final int icSigAToB2Tag         = 0x41324232;    /* 'A2B2' */

    /**
     * ICC Profile Tag Signature: 'bXYZ'.
     */
    public static final int icSigBlueColorantTag  = 0x6258595A;    /* 'bXYZ' */

    /**
     * ICC Profile Tag Signature: 'bXYZ'.
     * @since 1.5
     */
    public static final int icSigBlueMatrixColumnTag = 0x6258595A; /* 'bXYZ' */

    /**
     * ICC Profile Tag Signature: 'bTRC'.
     */
    public static final int icSigBlueTRCTag       = 0x62545243;    /* 'bTRC' */

    /**
     * ICC Profile Tag Signature: 'B2A0'.
     */
    public static final int icSigBToA0Tag         = 0x42324130;    /* 'B2A0' */

    /**
     * ICC Profile Tag Signature: 'B2A1'.
     */
    public static final int icSigBToA1Tag         = 0x42324131;    /* 'B2A1' */

    /**
     * ICC Profile Tag Signature: 'B2A2'.
     */
    public static final int icSigBToA2Tag         = 0x42324132;    /* 'B2A2' */

    /**
     * ICC Profile Tag Signature: 'calt'.
     */
    public static final int icSigCalibrationDateTimeTag = 0x63616C74;
                                                                   /* 'calt' */

    /**
     * ICC Profile Tag Signature: 'targ'.
     */
    public static final int icSigCharTargetTag    = 0x74617267;    /* 'targ' */

    /**
     * ICC Profile Tag Signature: 'cprt'.
     */
    public static final int icSigCopyrightTag     = 0x63707274;    /* 'cprt' */

    /**
     * ICC Profile Tag Signature: 'crdi'.
     */
    public static final int icSigCrdInfoTag       = 0x63726469;    /* 'crdi' */

    /**
     * ICC Profile Tag Signature: 'dmnd'.
     */
    public static final int icSigDeviceMfgDescTag = 0x646D6E64;    /* 'dmnd' */

    /**
     * ICC Profile Tag Signature: 'dmdd'.
     */
    public static final int icSigDeviceModelDescTag = 0x646D6464;  /* 'dmdd' */

    /**
     * ICC Profile Tag Signature: 'devs'.
     */
    public static final int icSigDeviceSettingsTag =  0x64657673;  /* 'devs' */

    /**
     * ICC Profile Tag Signature: 'gamt'.
     */
    public static final int icSigGamutTag         = 0x67616D74;    /* 'gamt' */

    /**
     * ICC Profile Tag Signature: 'kTRC'.
     */
    public static final int icSigGrayTRCTag       = 0x6b545243;    /* 'kTRC' */

    /**
     * ICC Profile Tag Signature: 'gXYZ'.
     */
    public static final int icSigGreenColorantTag = 0x6758595A;    /* 'gXYZ' */

    /**
     * ICC Profile Tag Signature: 'gXYZ'.
     * @since 1.5
     */
    public static final int icSigGreenMatrixColumnTag = 0x6758595A;/* 'gXYZ' */

    /**
     * ICC Profile Tag Signature: 'gTRC'.
     */
    public static final int icSigGreenTRCTag      = 0x67545243;    /* 'gTRC' */

    /**
     * ICC Profile Tag Signature: 'lumi'.
     */
    public static final int icSigLuminanceTag     = 0x6C756d69;    /* 'lumi' */

    /**
     * ICC Profile Tag Signature: 'meas'.
     */
    public static final int icSigMeasurementTag   = 0x6D656173;    /* 'meas' */

    /**
     * ICC Profile Tag Signature: 'bkpt'.
     */
    public static final int icSigMediaBlackPointTag = 0x626B7074;  /* 'bkpt' */

    /**
     * ICC Profile Tag Signature: 'wtpt'.
     */
    public static final int icSigMediaWhitePointTag = 0x77747074;  /* 'wtpt' */

    /**
     * ICC Profile Tag Signature: 'ncl2'.
     */
    public static final int icSigNamedColor2Tag   = 0x6E636C32;    /* 'ncl2' */

    /**
     * ICC Profile Tag Signature: 'resp'.
     */
    public static final int icSigOutputResponseTag = 0x72657370;   /* 'resp' */

    /**
     * ICC Profile Tag Signature: 'pre0'.
     */
    public static final int icSigPreview0Tag      = 0x70726530;    /* 'pre0' */

    /**
     * ICC Profile Tag Signature: 'pre1'.
     */
    public static final int icSigPreview1Tag      = 0x70726531;    /* 'pre1' */

    /**
     * ICC Profile Tag Signature: 'pre2'.
     */
    public static final int icSigPreview2Tag      = 0x70726532;    /* 'pre2' */

    /**
     * ICC Profile Tag Signature: 'desc'.
     */
    public static final int icSigProfileDescriptionTag = 0x64657363;
                                                                   /* 'desc' */

    /**
     * ICC Profile Tag Signature: 'pseq'.
     */
    public static final int icSigProfileSequenceDescTag = 0x70736571;
                                                                   /* 'pseq' */

    /**
     * ICC Profile Tag Signature: 'psd0'.
     */
    public static final int icSigPs2CRD0Tag       = 0x70736430;    /* 'psd0' */

    /**
     * ICC Profile Tag Signature: 'psd1'.
     */
    public static final int icSigPs2CRD1Tag       = 0x70736431;    /* 'psd1' */

    /**
     * ICC Profile Tag Signature: 'psd2'.
     */
    public static final int icSigPs2CRD2Tag       = 0x70736432;    /* 'psd2' */

    /**
     * ICC Profile Tag Signature: 'psd3'.
     */
    public static final int icSigPs2CRD3Tag       = 0x70736433;    /* 'psd3' */

    /**
     * ICC Profile Tag Signature: 'ps2s'.
     */
    public static final int icSigPs2CSATag        = 0x70733273;    /* 'ps2s' */

    /**
     * ICC Profile Tag Signature: 'ps2i'.
     */
    public static final int icSigPs2RenderingIntentTag = 0x70733269;
                                                                   /* 'ps2i' */

    /**
     * ICC Profile Tag Signature: 'rXYZ'.
     */
    public static final int icSigRedColorantTag   = 0x7258595A;    /* 'rXYZ' */

    /**
     * ICC Profile Tag Signature: 'rXYZ'.
     * @since 1.5
     */
    public static final int icSigRedMatrixColumnTag = 0x7258595A;  /* 'rXYZ' */

    /**
     * ICC Profile Tag Signature: 'rTRC'.
     */
    public static final int icSigRedTRCTag        = 0x72545243;    /* 'rTRC' */

    /**
     * ICC Profile Tag Signature: 'scrd'.
     */
    public static final int icSigScreeningDescTag = 0x73637264;    /* 'scrd' */

    /**
     * ICC Profile Tag Signature: 'scrn'.
     */
    public static final int icSigScreeningTag     = 0x7363726E;    /* 'scrn' */

    /**
     * ICC Profile Tag Signature: 'tech'.
     */
    public static final int icSigTechnologyTag    = 0x74656368;    /* 'tech' */

    /**
     * ICC Profile Tag Signature: 'bfd '.
     */
    public static final int icSigUcrBgTag         = 0x62666420;    /* 'bfd ' */

    /**
     * ICC Profile Tag Signature: 'vued'.
     */
    public static final int icSigViewingCondDescTag = 0x76756564;  /* 'vued' */

    /**
     * ICC Profile Tag Signature: 'view'.
     */
    public static final int icSigViewingConditionsTag = 0x76696577;/* 'view' */

    /**
     * ICC Profile Tag Signature: 'chrm'.
     */
    public static final int icSigChromaticityTag  = 0x6368726d;    /* 'chrm' */

    /**
     * ICC Profile Tag Signature: 'chad'.
     * @since 1.5
     */
    public static final int icSigChromaticAdaptationTag = 0x63686164;/* 'chad' */

    /**
     * ICC Profile Tag Signature: 'clro'.
     * @since 1.5
     */
    public static final int icSigColorantOrderTag = 0x636C726F;    /* 'clro' */

    /**
     * ICC Profile Tag Signature: 'clrt'.
     * @since 1.5
     */
    public static final int icSigColorantTableTag = 0x636C7274;    /* 'clrt' */


    /**
     * ICC Profile Header Location: profile size in bytes.
     */
    public static final int icHdrSize         = 0;  /* Profile size in bytes */

    /**
     * ICC Profile Header Location: CMM for this profile.
     */
    public static final int icHdrCmmId        = 4;  /* CMM for this profile */

    /**
     * ICC Profile Header Location: format version number.
     */
    public static final int icHdrVersion      = 8;  /* Format version number */

    /**
     * ICC Profile Header Location: type of profile.
     */
    public static final int icHdrDeviceClass  = 12; /* Type of profile */

    /**
     * ICC Profile Header Location: color space of data.
     */
    public static final int icHdrColorSpace   = 16; /* Color space of data */

    /**
     * ICC Profile Header Location: PCS - XYZ or Lab only.
     */
    public static final int icHdrPcs          = 20; /* PCS - XYZ or Lab only */

    /**
     * ICC Profile Header Location: date profile was created.
     */
    public static final int icHdrDate       = 24; /* Date profile was created */

    /**
     * ICC Profile Header Location: icMagicNumber.
     */
    public static final int icHdrMagic        = 36; /* icMagicNumber */

    /**
     * ICC Profile Header Location: primary platform.
     */
    public static final int icHdrPlatform     = 40; /* Primary Platform */

    /**
     * ICC Profile Header Location: various bit settings.
     */
    public static final int icHdrFlags        = 44; /* Various bit settings */

    /**
     * ICC Profile Header Location: device manufacturer.
     */
    public static final int icHdrManufacturer = 48; /* Device manufacturer */

    /**
     * ICC Profile Header Location: device model number.
     */
    public static final int icHdrModel        = 52; /* Device model number */

    /**
     * ICC Profile Header Location: device attributes.
     */
    public static final int icHdrAttributes   = 56; /* Device attributes */

    /**
     * ICC Profile Header Location: rendering intent.
     */
    public static final int icHdrRenderingIntent = 64; /* Rendering intent */

    /**
     * ICC Profile Header Location: profile illuminant.
     */
    public static final int icHdrIlluminant   = 68; /* Profile illuminant */

    /**
     * ICC Profile Header Location: profile creator.
     */
    public static final int icHdrCreator      = 80; /* Profile creator */

    /**
     * ICC Profile Header Location: profile's ID.
     * @since 1.5
     */
    public static final int icHdrProfileID = 84; /* Profile's ID */


    /**
     * ICC Profile Constant: tag type signaturE.
     */
    public static final int icTagType          = 0;    /* tag type signature */

    /**
     * ICC Profile Constant: reserved.
     */
    public static final int icTagReserved      = 4;    /* reserved */

    /**
     * ICC Profile Constant: curveType count.
     */
    public static final int icCurveCount       = 8;    /* curveType count */

    /**
     * ICC Profile Constant: curveType data.
     */
    public static final int icCurveData        = 12;   /* curveType data */

    /**
     * ICC Profile Constant: XYZNumber X.
     */
    public static final int icXYZNumberX       = 8;    /* XYZNumber X */


    /**
     * Constructs an ICC_Profile object with a given ID.
     */
<span class="nc" id="L731">    ICC_Profile(Profile p) {</span>
<span class="nc" id="L732">        this.cmmProfile = p;</span>
<span class="nc" id="L733">    }</span>


    /**
     * Constructs an ICC_Profile object whose loading will be deferred.
     * The ID will be 0 until the profile is loaded.
     */
<span class="nc" id="L740">    ICC_Profile(ProfileDeferralInfo pdi) {</span>
<span class="nc" id="L741">        this.deferralInfo = pdi;</span>
<span class="nc" id="L742">        this.profileActivator = new ProfileActivator() {</span>
            public void activate() throws ProfileDataException {
<span class="nc" id="L744">                activateDeferredProfile();</span>
<span class="nc" id="L745">            }</span>
        };
<span class="nc" id="L747">        ProfileDeferralMgr.registerDeferral(this.profileActivator);</span>
<span class="nc" id="L748">    }</span>


    /**
     * Frees the resources associated with an ICC_Profile object.
     */
    protected void finalize () {
<span class="nc bnc" id="L755" title="All 2 branches missed.">        if (cmmProfile != null) {</span>
<span class="nc" id="L756">            CMSManager.getModule().freeProfile(cmmProfile);</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">        } else if (profileActivator != null) {</span>
<span class="nc" id="L758">            ProfileDeferralMgr.unregisterDeferral(profileActivator);</span>
        }
<span class="nc" id="L760">    }</span>


    /**
     * Constructs an ICC_Profile object corresponding to the data in
     * a byte array.  Throws an IllegalArgumentException if the data
     * does not correspond to a valid ICC Profile.
     * @param data the specified ICC Profile data
     * @return an &lt;code&gt;ICC_Profile&lt;/code&gt; object corresponding to
     *          the data in the specified &lt;code&gt;data&lt;/code&gt; array.
     */
    public static ICC_Profile getInstance(byte[] data) {
    ICC_Profile thisProfile;

<span class="nc" id="L774">        Profile p = null;</span>

<span class="nc bnc" id="L776" title="All 2 branches missed.">        if (ProfileDeferralMgr.deferring) {</span>
<span class="nc" id="L777">            ProfileDeferralMgr.activateProfiles();</span>
        }

<span class="nc" id="L780">        ProfileDataVerifier.verify(data);</span>

        try {
<span class="nc" id="L783">            p = CMSManager.getModule().loadProfile(data);</span>
<span class="nc" id="L784">        } catch (CMMException c) {</span>
<span class="nc" id="L785">            throw new IllegalArgumentException(&quot;Invalid ICC Profile Data&quot;);</span>
<span class="nc" id="L786">        }</span>

        try {
<span class="nc bnc" id="L789" title="All 2 branches missed.">            if ((getColorSpaceType (p) == ColorSpace.TYPE_GRAY) &amp;&amp;</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">                (getData (p, icSigMediaWhitePointTag) != null) &amp;&amp;</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">                (getData (p, icSigGrayTRCTag) != null)) {</span>
<span class="nc" id="L792">                thisProfile = new ICC_ProfileGray (p);</span>
            }
<span class="nc bnc" id="L794" title="All 2 branches missed.">            else if ((getColorSpaceType (p) == ColorSpace.TYPE_RGB) &amp;&amp;</span>
<span class="nc bnc" id="L795" title="All 2 branches missed.">                (getData (p, icSigMediaWhitePointTag) != null) &amp;&amp;</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">                (getData (p, icSigRedColorantTag) != null) &amp;&amp;</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">                (getData (p, icSigGreenColorantTag) != null) &amp;&amp;</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                (getData (p, icSigBlueColorantTag) != null) &amp;&amp;</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">                (getData (p, icSigRedTRCTag) != null) &amp;&amp;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">                (getData (p, icSigGreenTRCTag) != null) &amp;&amp;</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                (getData (p, icSigBlueTRCTag) != null)) {</span>
<span class="nc" id="L802">                thisProfile = new ICC_ProfileRGB (p);</span>
            }
            else {
<span class="nc" id="L805">                thisProfile = new ICC_Profile (p);</span>
            }
<span class="nc" id="L807">        } catch (CMMException c) {</span>
<span class="nc" id="L808">            thisProfile = new ICC_Profile (p);</span>
<span class="nc" id="L809">        }</span>
<span class="nc" id="L810">        return thisProfile;</span>
    }



    /**
     * Constructs an ICC_Profile corresponding to one of the specific color
     * spaces defined by the ColorSpace class (for example CS_sRGB).
     * Throws an IllegalArgumentException if cspace is not one of the
     * defined color spaces.
     *
     * @param cspace the type of color space to create a profile for.
     * The specified type is one of the color
     * space constants defined in the  &lt;CODE&gt;ColorSpace&lt;/CODE&gt; class.
     *
     * @return an &lt;code&gt;ICC_Profile&lt;/code&gt; object corresponding to
     *          the specified &lt;code&gt;ColorSpace&lt;/code&gt; type.
     * @exception IllegalArgumentException If &lt;CODE&gt;cspace&lt;/CODE&gt; is not
     * one of the predefined color space types.
     */
    public static ICC_Profile getInstance (int cspace) {
<span class="nc" id="L831">        ICC_Profile thisProfile = null;</span>
        String fileName;

<span class="nc bnc" id="L834" title="All 6 branches missed.">        switch (cspace) {</span>
        case ColorSpace.CS_sRGB:
<span class="nc" id="L836">            synchronized(ICC_Profile.class) {</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">                if (sRGBprofile == null) {</span>
                    /*
                     * Deferral is only used for standard profiles.
                     * Enabling the appropriate access privileges is handled
                     * at a lower level.
                     */
<span class="nc" id="L843">                    ProfileDeferralInfo pInfo =</span>
                        new ProfileDeferralInfo(&quot;sRGB.pf&quot;,
                                                ColorSpace.TYPE_RGB, 3,
                                                CLASS_DISPLAY);
<span class="nc" id="L847">                    sRGBprofile = getDeferredInstance(pInfo);</span>
                }
<span class="nc" id="L849">                thisProfile = sRGBprofile;</span>
<span class="nc" id="L850">            }</span>

<span class="nc" id="L852">            break;</span>

        case ColorSpace.CS_CIEXYZ:
<span class="nc" id="L855">            synchronized(ICC_Profile.class) {</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                if (XYZprofile == null) {</span>
<span class="nc" id="L857">                    ProfileDeferralInfo pInfo =</span>
                        new ProfileDeferralInfo(&quot;CIEXYZ.pf&quot;,
                                                ColorSpace.TYPE_XYZ, 3,
                                                CLASS_DISPLAY);
<span class="nc" id="L861">                    XYZprofile = getDeferredInstance(pInfo);</span>
                }
<span class="nc" id="L863">                thisProfile = XYZprofile;</span>
<span class="nc" id="L864">            }</span>

<span class="nc" id="L866">            break;</span>

        case ColorSpace.CS_PYCC:
<span class="nc" id="L869">            synchronized(ICC_Profile.class) {</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">                if (PYCCprofile == null) {</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">                    if (standardProfileExists(&quot;PYCC.pf&quot;))</span>
                    {
<span class="nc" id="L873">                        ProfileDeferralInfo pInfo =</span>
                            new ProfileDeferralInfo(&quot;PYCC.pf&quot;,
                                                    ColorSpace.TYPE_3CLR, 3,
                                                    CLASS_DISPLAY);
<span class="nc" id="L877">                        PYCCprofile = getDeferredInstance(pInfo);</span>
<span class="nc" id="L878">                    } else {</span>
<span class="nc" id="L879">                        throw new IllegalArgumentException(</span>
                                &quot;Can't load standard profile: PYCC.pf&quot;);
                    }
                }
<span class="nc" id="L883">                thisProfile = PYCCprofile;</span>
<span class="nc" id="L884">            }</span>

<span class="nc" id="L886">            break;</span>

        case ColorSpace.CS_GRAY:
<span class="nc" id="L889">            synchronized(ICC_Profile.class) {</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">                if (GRAYprofile == null) {</span>
<span class="nc" id="L891">                    ProfileDeferralInfo pInfo =</span>
                        new ProfileDeferralInfo(&quot;GRAY.pf&quot;,
                                                ColorSpace.TYPE_GRAY, 1,
                                                CLASS_DISPLAY);
<span class="nc" id="L895">                    GRAYprofile = getDeferredInstance(pInfo);</span>
                }
<span class="nc" id="L897">                thisProfile = GRAYprofile;</span>
<span class="nc" id="L898">            }</span>

<span class="nc" id="L900">            break;</span>

        case ColorSpace.CS_LINEAR_RGB:
<span class="nc" id="L903">            synchronized(ICC_Profile.class) {</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">                if (LINEAR_RGBprofile == null) {</span>
<span class="nc" id="L905">                    ProfileDeferralInfo pInfo =</span>
                        new ProfileDeferralInfo(&quot;LINEAR_RGB.pf&quot;,
                                                ColorSpace.TYPE_RGB, 3,
                                                CLASS_DISPLAY);
<span class="nc" id="L909">                    LINEAR_RGBprofile = getDeferredInstance(pInfo);</span>
                }
<span class="nc" id="L911">                thisProfile = LINEAR_RGBprofile;</span>
<span class="nc" id="L912">            }</span>

<span class="nc" id="L914">            break;</span>

        default:
<span class="nc" id="L917">            throw new IllegalArgumentException(&quot;Unknown color space&quot;);</span>
        }

<span class="nc" id="L920">        return thisProfile;</span>
    }

    /* This asserts system privileges, so is used only for the
     * standard profiles.
     */
    private static ICC_Profile getStandardProfile(final String name) {

<span class="nc" id="L928">        return AccessController.doPrivileged(</span>
<span class="nc" id="L929">            new PrivilegedAction&lt;ICC_Profile&gt;() {</span>
                 public ICC_Profile run() {
<span class="nc" id="L931">                     ICC_Profile p = null;</span>
                     try {
<span class="nc" id="L933">                         p = getInstance (name);</span>
<span class="nc" id="L934">                     } catch (IOException ex) {</span>
<span class="nc" id="L935">                         throw new IllegalArgumentException(</span>
                               &quot;Can't load standard profile: &quot; + name);
<span class="nc" id="L937">                     }</span>
<span class="nc" id="L938">                     return p;</span>
                 }
             });
    }

    /**
     * Constructs an ICC_Profile corresponding to the data in a file.
     * fileName may be an absolute or a relative file specification.
     * Relative file names are looked for in several places: first, relative
     * to any directories specified by the java.iccprofile.path property;
     * second, relative to any directories specified by the java.class.path
     * property; finally, in a directory used to store profiles always
     * available, such as the profile for sRGB.  Built-in profiles use .pf as
     * the file name extension for profiles, e.g. sRGB.pf.
     * This method throws an IOException if the specified file cannot be
     * opened or if an I/O error occurs while reading the file.  It throws
     * an IllegalArgumentException if the file does not contain valid ICC
     * Profile data.
     * @param fileName The file that contains the data for the profile.
     *
     * @return an &lt;code&gt;ICC_Profile&lt;/code&gt; object corresponding to
     *          the data in the specified file.
     * @exception IOException If the specified file cannot be opened or
     * an I/O error occurs while reading the file.
     *
     * @exception IllegalArgumentException If the file does not
     * contain valid ICC Profile data.
     *
     * @exception SecurityException If a security manager is installed
     * and it does not permit read access to the given file.
     */
    public static ICC_Profile getInstance(String fileName) throws IOException {
        ICC_Profile thisProfile;
<span class="nc" id="L971">        FileInputStream fis = null;</span>


<span class="nc" id="L974">        File f = getProfileFile(fileName);</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">        if (f != null) {</span>
<span class="nc" id="L976">            fis = new FileInputStream(f);</span>
        }
<span class="nc bnc" id="L978" title="All 2 branches missed.">        if (fis == null) {</span>
<span class="nc" id="L979">            throw new IOException(&quot;Cannot open file &quot; + fileName);</span>
        }

<span class="nc" id="L982">        thisProfile = getInstance(fis);</span>

<span class="nc" id="L984">        fis.close();    /* close the file */</span>

<span class="nc" id="L986">        return thisProfile;</span>
    }


    /**
     * Constructs an ICC_Profile corresponding to the data in an InputStream.
     * This method throws an IllegalArgumentException if the stream does not
     * contain valid ICC Profile data.  It throws an IOException if an I/O
     * error occurs while reading the stream.
     * @param s The input stream from which to read the profile data.
     *
     * @return an &lt;CODE&gt;ICC_Profile&lt;/CODE&gt; object corresponding to the
     *     data in the specified &lt;code&gt;InputStream&lt;/code&gt;.
     *
     * @exception IOException If an I/O error occurs while reading the stream.
     *
     * @exception IllegalArgumentException If the stream does not
     * contain valid ICC Profile data.
     */
    public static ICC_Profile getInstance(InputStream s) throws IOException {
    byte profileData[];

<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (s instanceof ProfileDeferralInfo) {</span>
            /* hack to detect profiles whose loading can be deferred */
<span class="nc" id="L1010">            return getDeferredInstance((ProfileDeferralInfo) s);</span>
        }

<span class="nc bnc" id="L1013" title="All 2 branches missed.">        if ((profileData = getProfileDataFromStream(s)) == null) {</span>
<span class="nc" id="L1014">            throw new IllegalArgumentException(&quot;Invalid ICC Profile Data&quot;);</span>
        }

<span class="nc" id="L1017">        return getInstance(profileData);</span>
    }


    static byte[] getProfileDataFromStream(InputStream s) throws IOException {
    byte profileData[];
    int profileSize;

<span class="nc" id="L1025">        byte header[] = new byte[128];</span>
<span class="nc" id="L1026">        int bytestoread = 128;</span>
<span class="nc" id="L1027">        int bytesread = 0;</span>
        int n;

<span class="nc bnc" id="L1030" title="All 2 branches missed.">        while (bytestoread != 0) {</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">            if ((n = s.read(header, bytesread, bytestoread)) &lt; 0) {</span>
<span class="nc" id="L1032">                return null;</span>
            }
<span class="nc" id="L1034">            bytesread += n;</span>
<span class="nc" id="L1035">            bytestoread -= n;</span>
        }
<span class="nc bnc" id="L1037" title="All 8 branches missed.">        if (header[36] != 0x61 || header[37] != 0x63 ||</span>
            header[38] != 0x73 || header[39] != 0x70) {
<span class="nc" id="L1039">            return null;   /* not a valid profile */</span>
        }
<span class="nc" id="L1041">        profileSize = ((header[0] &amp; 0xff) &lt;&lt; 24) |</span>
                      ((header[1] &amp; 0xff) &lt;&lt; 16) |
                      ((header[2] &amp; 0xff) &lt;&lt;  8) |
                       (header[3] &amp; 0xff);
<span class="nc" id="L1045">        profileData = new byte[profileSize];</span>
<span class="nc" id="L1046">        System.arraycopy(header, 0, profileData, 0, 128);</span>
<span class="nc" id="L1047">        bytestoread = profileSize - 128;</span>
<span class="nc" id="L1048">        bytesread = 128;</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">        while (bytestoread != 0) {</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            if ((n = s.read(profileData, bytesread, bytestoread)) &lt; 0) {</span>
<span class="nc" id="L1051">                return null;</span>
            }
<span class="nc" id="L1053">            bytesread += n;</span>
<span class="nc" id="L1054">            bytestoread -= n;</span>
        }

<span class="nc" id="L1057">        return profileData;</span>
    }


    /**
     * Constructs an ICC_Profile for which the actual loading of the
     * profile data from a file and the initialization of the CMM should
     * be deferred as long as possible.
     * Deferral is only used for standard profiles.
     * If deferring is disabled, then getStandardProfile() ensures
     * that all of the appropriate access privileges are granted
     * when loading this profile.
     * If deferring is enabled, then the deferred activation
     * code will take care of access privileges.
     * @see activateDeferredProfile()
     */
    static ICC_Profile getDeferredInstance(ProfileDeferralInfo pdi) {
<span class="nc bnc" id="L1074" title="All 2 branches missed.">        if (!ProfileDeferralMgr.deferring) {</span>
<span class="nc" id="L1075">            return getStandardProfile(pdi.filename);</span>
        }
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        if (pdi.colorSpaceType == ColorSpace.TYPE_RGB) {</span>
<span class="nc" id="L1078">            return new ICC_ProfileRGB(pdi);</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">        } else if (pdi.colorSpaceType == ColorSpace.TYPE_GRAY) {</span>
<span class="nc" id="L1080">            return new ICC_ProfileGray(pdi);</span>
        } else {
<span class="nc" id="L1082">            return new ICC_Profile(pdi);</span>
        }
    }


    void activateDeferredProfile() throws ProfileDataException {
        byte profileData[];
        FileInputStream fis;
<span class="nc" id="L1090">        final String fileName = deferralInfo.filename;</span>

<span class="nc" id="L1092">        profileActivator = null;</span>
<span class="nc" id="L1093">        deferralInfo = null;</span>
<span class="nc" id="L1094">        PrivilegedAction&lt;FileInputStream&gt; pa = new PrivilegedAction&lt;FileInputStream&gt;() {</span>
            public FileInputStream run() {
<span class="nc" id="L1096">                File f = getStandardProfileFile(fileName);</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                if (f != null) {</span>
                    try {
<span class="nc" id="L1099">                        return new FileInputStream(f);</span>
<span class="nc" id="L1100">                    } catch (FileNotFoundException e) {}</span>
                }
<span class="nc" id="L1102">                return null;</span>
            }
        };
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        if ((fis = AccessController.doPrivileged(pa)) == null) {</span>
<span class="nc" id="L1106">            throw new ProfileDataException(&quot;Cannot open file &quot; + fileName);</span>
        }
        try {
<span class="nc" id="L1109">            profileData = getProfileDataFromStream(fis);</span>
<span class="nc" id="L1110">            fis.close();    /* close the file */</span>
        }
<span class="nc" id="L1112">        catch (IOException e) {</span>
<span class="nc" id="L1113">            ProfileDataException pde = new</span>
                ProfileDataException(&quot;Invalid ICC Profile Data&quot; + fileName);
<span class="nc" id="L1115">            pde.initCause(e);</span>
<span class="nc" id="L1116">            throw pde;</span>
<span class="nc" id="L1117">        }</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (profileData == null) {</span>
<span class="nc" id="L1119">            throw new ProfileDataException(&quot;Invalid ICC Profile Data&quot; +</span>
                fileName);
        }
        try {
<span class="nc" id="L1123">            cmmProfile = CMSManager.getModule().loadProfile(profileData);</span>
<span class="nc" id="L1124">        } catch (CMMException c) {</span>
<span class="nc" id="L1125">            ProfileDataException pde = new</span>
                ProfileDataException(&quot;Invalid ICC Profile Data&quot; + fileName);
<span class="nc" id="L1127">            pde.initCause(c);</span>
<span class="nc" id="L1128">            throw pde;</span>
<span class="nc" id="L1129">        }</span>
<span class="nc" id="L1130">    }</span>


    /**
     * Returns profile major version.
     * @return  The major version of the profile.
     */
    public int getMajorVersion() {
    byte[] theHeader;

<span class="nc" id="L1140">        theHeader = getData(icSigHead); /* getData will activate deferred</span>
                                           profiles if necessary */

<span class="nc" id="L1143">        return (int) theHeader[8];</span>
    }

    /**
     * Returns profile minor version.
     * @return The minor version of the profile.
     */
    public int getMinorVersion() {
    byte[] theHeader;

<span class="nc" id="L1153">        theHeader = getData(icSigHead); /* getData will activate deferred</span>
                                           profiles if necessary */

<span class="nc" id="L1156">        return (int) theHeader[9];</span>
    }

    /**
     * Returns the profile class.
     * @return One of the predefined profile class constants.
     */
    public int getProfileClass() {
    byte[] theHeader;
    int theClassSig, theClass;

<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if (deferralInfo != null) {</span>
<span class="nc" id="L1168">            return deferralInfo.profileClass; /* Need to have this info for</span>
                                                 ICC_ColorSpace without
                                                 causing a deferred profile
                                                 to be loaded */
        }

<span class="nc" id="L1174">        theHeader = getData(icSigHead);</span>

<span class="nc" id="L1176">        theClassSig = intFromBigEndian (theHeader, icHdrDeviceClass);</span>

<span class="nc bnc" id="L1178" title="All 8 branches missed.">        switch (theClassSig) {</span>
        case icSigInputClass:
<span class="nc" id="L1180">            theClass = CLASS_INPUT;</span>
<span class="nc" id="L1181">            break;</span>

        case icSigDisplayClass:
<span class="nc" id="L1184">            theClass = CLASS_DISPLAY;</span>
<span class="nc" id="L1185">            break;</span>

        case icSigOutputClass:
<span class="nc" id="L1188">            theClass = CLASS_OUTPUT;</span>
<span class="nc" id="L1189">            break;</span>

        case icSigLinkClass:
<span class="nc" id="L1192">            theClass = CLASS_DEVICELINK;</span>
<span class="nc" id="L1193">            break;</span>

        case icSigColorSpaceClass:
<span class="nc" id="L1196">            theClass = CLASS_COLORSPACECONVERSION;</span>
<span class="nc" id="L1197">            break;</span>

        case icSigAbstractClass:
<span class="nc" id="L1200">            theClass = CLASS_ABSTRACT;</span>
<span class="nc" id="L1201">            break;</span>

        case icSigNamedColorClass:
<span class="nc" id="L1204">            theClass = CLASS_NAMEDCOLOR;</span>
<span class="nc" id="L1205">            break;</span>

        default:
<span class="nc" id="L1208">            throw new IllegalArgumentException(&quot;Unknown profile class&quot;);</span>
        }

<span class="nc" id="L1211">        return theClass;</span>
    }

    /**
     * Returns the color space type.  Returns one of the color space type
     * constants defined by the ColorSpace class.  This is the
     * &quot;input&quot; color space of the profile.  The type defines the
     * number of components of the color space and the interpretation,
     * e.g. TYPE_RGB identifies a color space with three components - red,
     * green, and blue.  It does not define the particular color
     * characteristics of the space, e.g. the chromaticities of the
     * primaries.
     * @return One of the color space type constants defined in the
     * &lt;CODE&gt;ColorSpace&lt;/CODE&gt; class.
     */
    public int getColorSpaceType() {
<span class="nc bnc" id="L1227" title="All 2 branches missed.">        if (deferralInfo != null) {</span>
<span class="nc" id="L1228">            return deferralInfo.colorSpaceType; /* Need to have this info for</span>
                                                   ICC_ColorSpace without
                                                   causing a deferred profile
                                                   to be loaded */
        }
<span class="nc" id="L1233">        return    getColorSpaceType(cmmProfile);</span>
    }

    static int getColorSpaceType(Profile p) {
    byte[] theHeader;
    int theColorSpaceSig, theColorSpace;

<span class="nc" id="L1240">        theHeader = getData(p, icSigHead);</span>
<span class="nc" id="L1241">        theColorSpaceSig = intFromBigEndian(theHeader, icHdrColorSpace);</span>
<span class="nc" id="L1242">        theColorSpace = iccCStoJCS (theColorSpaceSig);</span>
<span class="nc" id="L1243">        return theColorSpace;</span>
    }

    /**
     * Returns the color space type of the Profile Connection Space (PCS).
     * Returns one of the color space type constants defined by the
     * ColorSpace class.  This is the &quot;output&quot; color space of the
     * profile.  For an input, display, or output profile useful
     * for tagging colors or images, this will be either TYPE_XYZ or
     * TYPE_Lab and should be interpreted as the corresponding specific
     * color space defined in the ICC specification.  For a device
     * link profile, this could be any of the color space type constants.
     * @return One of the color space type constants defined in the
     * &lt;CODE&gt;ColorSpace&lt;/CODE&gt; class.
     */
    public int getPCSType() {
<span class="nc bnc" id="L1259" title="All 2 branches missed.">        if (ProfileDeferralMgr.deferring) {</span>
<span class="nc" id="L1260">            ProfileDeferralMgr.activateProfiles();</span>
        }
<span class="nc" id="L1262">        return getPCSType(cmmProfile);</span>
    }


    static int getPCSType(Profile p) {
    byte[] theHeader;
    int thePCSSig, thePCS;

<span class="nc" id="L1270">        theHeader = getData(p, icSigHead);</span>
<span class="nc" id="L1271">        thePCSSig = intFromBigEndian(theHeader, icHdrPcs);</span>
<span class="nc" id="L1272">        thePCS = iccCStoJCS(thePCSSig);</span>
<span class="nc" id="L1273">        return thePCS;</span>
    }


    /**
     * Write this ICC_Profile to a file.
     *
     * @param fileName The file to write the profile data to.
     *
     * @exception IOException If the file cannot be opened for writing
     * or an I/O error occurs while writing to the file.
     */
    public void write(String fileName) throws IOException {
    FileOutputStream outputFile;
    byte profileData[];

<span class="nc" id="L1289">        profileData = getData(); /* this will activate deferred</span>
                                    profiles if necessary */
<span class="nc" id="L1291">        outputFile = new FileOutputStream(fileName);</span>
<span class="nc" id="L1292">        outputFile.write(profileData);</span>
<span class="nc" id="L1293">        outputFile.close ();</span>
<span class="nc" id="L1294">    }</span>


    /**
     * Write this ICC_Profile to an OutputStream.
     *
     * @param s The stream to write the profile data to.
     *
     * @exception IOException If an I/O error occurs while writing to the
     * stream.
     */
    public void write(OutputStream s) throws IOException {
    byte profileData[];

<span class="nc" id="L1308">        profileData = getData(); /* this will activate deferred</span>
                                    profiles if necessary */
<span class="nc" id="L1310">        s.write(profileData);</span>
<span class="nc" id="L1311">    }</span>


    /**
     * Returns a byte array corresponding to the data of this ICC_Profile.
     * @return A byte array that contains the profile data.
     * @see #setData(int, byte[])
     */
    public byte[] getData() {
    int profileSize;
    byte[] profileData;

<span class="nc bnc" id="L1323" title="All 2 branches missed.">        if (ProfileDeferralMgr.deferring) {</span>
<span class="nc" id="L1324">            ProfileDeferralMgr.activateProfiles();</span>
        }

<span class="nc" id="L1327">        PCMM mdl = CMSManager.getModule();</span>

        /* get the number of bytes needed for this profile */
<span class="nc" id="L1330">        profileSize = mdl.getProfileSize(cmmProfile);</span>

<span class="nc" id="L1332">        profileData = new byte [profileSize];</span>

        /* get the data for the profile */
<span class="nc" id="L1335">        mdl.getProfileData(cmmProfile, profileData);</span>

<span class="nc" id="L1337">        return profileData;</span>
    }


    /**
     * Returns a particular tagged data element from the profile as
     * a byte array.  Elements are identified by signatures
     * as defined in the ICC specification.  The signature
     * icSigHead can be used to get the header.  This method is useful
     * for advanced applets or applications which need to access
     * profile data directly.
     *
     * @param tagSignature The ICC tag signature for the data element you
     * want to get.
     *
     * @return A byte array that contains the tagged data element. Returns
     * &lt;code&gt;null&lt;/code&gt; if the specified tag doesn't exist.
     * @see #setData(int, byte[])
     */
    public byte[] getData(int tagSignature) {

<span class="nc bnc" id="L1358" title="All 2 branches missed.">        if (ProfileDeferralMgr.deferring) {</span>
<span class="nc" id="L1359">            ProfileDeferralMgr.activateProfiles();</span>
        }

<span class="nc" id="L1362">        return getData(cmmProfile, tagSignature);</span>
    }


    static byte[] getData(Profile p, int tagSignature) {
    int tagSize;
    byte[] tagData;

        try {
<span class="nc" id="L1371">            PCMM mdl = CMSManager.getModule();</span>

            /* get the number of bytes needed for this tag */
<span class="nc" id="L1374">            tagSize = mdl.getTagSize(p, tagSignature);</span>

<span class="nc" id="L1376">            tagData = new byte[tagSize]; /* get an array for the tag */</span>

            /* get the tag's data */
<span class="nc" id="L1379">            mdl.getTagData(p, tagSignature, tagData);</span>
<span class="nc" id="L1380">        } catch(CMMException c) {</span>
<span class="nc" id="L1381">            tagData = null;</span>
<span class="nc" id="L1382">        }</span>

<span class="nc" id="L1384">        return tagData;</span>
    }

    /**
     * Sets a particular tagged data element in the profile from
     * a byte array. The array should contain data in a format, corresponded
     * to the {@code tagSignature} as defined in the ICC specification, section 10.
     * This method is useful for advanced applets or applications which need to
     * access profile data directly.
     *
     * @param tagSignature The ICC tag signature for the data element
     * you want to set.
     * @param tagData the data to set for the specified tag signature
     * @throws IllegalArgumentException if {@code tagSignature} is not a signature
     *         as defined in the ICC specification.
     * @throws IllegalArgumentException if a content of the {@code tagData}
     *         array can not be interpreted as valid tag data, corresponding
     *         to the {@code tagSignature}.
     * @see #getData
     */
    public void setData(int tagSignature, byte[] tagData) {

<span class="nc bnc" id="L1406" title="All 2 branches missed.">        if (ProfileDeferralMgr.deferring) {</span>
<span class="nc" id="L1407">            ProfileDeferralMgr.activateProfiles();</span>
        }

<span class="nc" id="L1410">        CMSManager.getModule().setTagData(cmmProfile, tagSignature, tagData);</span>
<span class="nc" id="L1411">    }</span>

    /**
     * Sets the rendering intent of the profile.
     * This is used to select the proper transform from a profile that
     * has multiple transforms.
     */
    void setRenderingIntent(int renderingIntent) {
<span class="nc" id="L1419">        byte[] theHeader = getData(icSigHead);/* getData will activate deferred</span>
                                                 profiles if necessary */
<span class="nc" id="L1421">        intToBigEndian (renderingIntent, theHeader, icHdrRenderingIntent);</span>
                                                 /* set the rendering intent */
<span class="nc" id="L1423">        setData (icSigHead, theHeader);</span>
<span class="nc" id="L1424">    }</span>


    /**
     * Returns the rendering intent of the profile.
     * This is used to select the proper transform from a profile that
     * has multiple transforms.  It is typically set in a source profile
     * to select a transform from an output profile.
     */
    int getRenderingIntent() {
<span class="nc" id="L1434">        byte[] theHeader = getData(icSigHead);/* getData will activate deferred</span>
                                                 profiles if necessary */

<span class="nc" id="L1437">        int renderingIntent = intFromBigEndian(theHeader, icHdrRenderingIntent);</span>
                                                 /* set the rendering intent */

        /* According to ICC spec, only the least-significant 16 bits shall be
         * used to encode the rendering intent. The most significant 16 bits
         * shall be set to zero. Thus, we are ignoring two most significant
         * bytes here.
         *
         *  See http://www.color.org/ICC1v42_2006-05.pdf, section 7.2.15.
         */
<span class="nc" id="L1447">        return (0xffff &amp; renderingIntent);</span>
    }


    /**
     * Returns the number of color components in the &quot;input&quot; color
     * space of this profile.  For example if the color space type
     * of this profile is TYPE_RGB, then this method will return 3.
     *
     * @return The number of color components in the profile's input
     * color space.
     *
     * @throws ProfileDataException if color space is in the profile
     *         is invalid
     */
    public int getNumComponents() {
    byte[]    theHeader;
    int    theColorSpaceSig, theNumComponents;

<span class="nc bnc" id="L1466" title="All 2 branches missed.">        if (deferralInfo != null) {</span>
<span class="nc" id="L1467">            return deferralInfo.numComponents; /* Need to have this info for</span>
                                                  ICC_ColorSpace without
                                                  causing a deferred profile
                                                  to be loaded */
        }
<span class="nc" id="L1472">        theHeader = getData(icSigHead);</span>

<span class="nc" id="L1474">        theColorSpaceSig = intFromBigEndian (theHeader, icHdrColorSpace);</span>

<span class="nc bnc" id="L1476" title="All 16 branches missed.">        switch (theColorSpaceSig) {</span>
        case icSigGrayData:
<span class="nc" id="L1478">            theNumComponents = 1;</span>
<span class="nc" id="L1479">            break;</span>

        case icSigSpace2CLR:
<span class="nc" id="L1482">            theNumComponents = 2;</span>
<span class="nc" id="L1483">            break;</span>

        case icSigXYZData:
        case icSigLabData:
        case icSigLuvData:
        case icSigYCbCrData:
        case icSigYxyData:
        case icSigRgbData:
        case icSigHsvData:
        case icSigHlsData:
        case icSigCmyData:
        case icSigSpace3CLR:
<span class="nc" id="L1495">            theNumComponents = 3;</span>
<span class="nc" id="L1496">            break;</span>

        case icSigCmykData:
        case icSigSpace4CLR:
<span class="nc" id="L1500">            theNumComponents = 4;</span>
<span class="nc" id="L1501">            break;</span>

        case icSigSpace5CLR:
<span class="nc" id="L1504">            theNumComponents = 5;</span>
<span class="nc" id="L1505">            break;</span>

        case icSigSpace6CLR:
<span class="nc" id="L1508">            theNumComponents = 6;</span>
<span class="nc" id="L1509">            break;</span>

        case icSigSpace7CLR:
<span class="nc" id="L1512">            theNumComponents = 7;</span>
<span class="nc" id="L1513">            break;</span>

        case icSigSpace8CLR:
<span class="nc" id="L1516">            theNumComponents = 8;</span>
<span class="nc" id="L1517">            break;</span>

        case icSigSpace9CLR:
<span class="nc" id="L1520">            theNumComponents = 9;</span>
<span class="nc" id="L1521">            break;</span>

        case icSigSpaceACLR:
<span class="nc" id="L1524">            theNumComponents = 10;</span>
<span class="nc" id="L1525">            break;</span>

        case icSigSpaceBCLR:
<span class="nc" id="L1528">            theNumComponents = 11;</span>
<span class="nc" id="L1529">            break;</span>

        case icSigSpaceCCLR:
<span class="nc" id="L1532">            theNumComponents = 12;</span>
<span class="nc" id="L1533">            break;</span>

        case icSigSpaceDCLR:
<span class="nc" id="L1536">            theNumComponents = 13;</span>
<span class="nc" id="L1537">            break;</span>

        case icSigSpaceECLR:
<span class="nc" id="L1540">            theNumComponents = 14;</span>
<span class="nc" id="L1541">            break;</span>

        case icSigSpaceFCLR:
<span class="nc" id="L1544">            theNumComponents = 15;</span>
<span class="nc" id="L1545">            break;</span>

        default:
<span class="nc" id="L1548">            throw new ProfileDataException (&quot;invalid ICC color space&quot;);</span>
        }

<span class="nc" id="L1551">        return theNumComponents;</span>
    }


    /**
     * Returns a float array of length 3 containing the X, Y, and Z
     * components of the mediaWhitePointTag in the ICC profile.
     */
    float[] getMediaWhitePoint() {
<span class="nc" id="L1560">        return getXYZTag(icSigMediaWhitePointTag);</span>
                                           /* get the media white point tag */
    }


    /**
     * Returns a float array of length 3 containing the X, Y, and Z
     * components encoded in an XYZType tag.
     */
    float[] getXYZTag(int theTagSignature) {
    byte[] theData;
    float[] theXYZNumber;
    int i1, i2, theS15Fixed16;

<span class="nc" id="L1574">        theData = getData(theTagSignature); /* get the tag data */</span>
                                            /* getData will activate deferred
                                               profiles if necessary */

<span class="nc" id="L1578">        theXYZNumber = new float [3];        /* array to return */</span>

        /* convert s15Fixed16Number to float */
<span class="nc bnc" id="L1581" title="All 2 branches missed.">        for (i1 = 0, i2 = icXYZNumberX; i1 &lt; 3; i1++, i2 += 4) {</span>
<span class="nc" id="L1582">            theS15Fixed16 = intFromBigEndian(theData, i2);</span>
<span class="nc" id="L1583">            theXYZNumber [i1] = ((float) theS15Fixed16) / 65536.0f;</span>
        }
<span class="nc" id="L1585">        return theXYZNumber;</span>
    }


    /**
     * Returns a gamma value representing a tone reproduction
     * curve (TRC).  If the profile represents the TRC as a table rather
     * than a single gamma value, then an exception is thrown.  In this
     * case the actual table can be obtained via getTRC().
     * theTagSignature should be one of icSigGrayTRCTag, icSigRedTRCTag,
     * icSigGreenTRCTag, or icSigBlueTRCTag.
     * @return the gamma value as a float.
     * @exception ProfileDataException if the profile does not specify
     *            the TRC as a single gamma value.
     */
    float getGamma(int theTagSignature) {
    byte[] theTRCData;
    float theGamma;
    int theU8Fixed8;

<span class="nc" id="L1605">        theTRCData = getData(theTagSignature); /* get the TRC */</span>
                                               /* getData will activate deferred
                                                  profiles if necessary */

<span class="nc bnc" id="L1609" title="All 2 branches missed.">        if (intFromBigEndian (theTRCData, icCurveCount) != 1) {</span>
<span class="nc" id="L1610">            throw new ProfileDataException (&quot;TRC is not a gamma&quot;);</span>
        }

        /* convert u8Fixed8 to float */
<span class="nc" id="L1614">        theU8Fixed8 = (shortFromBigEndian(theTRCData, icCurveData)) &amp; 0xffff;</span>

<span class="nc" id="L1616">        theGamma = ((float) theU8Fixed8) / 256.0f;</span>

<span class="nc" id="L1618">        return theGamma;</span>
    }


    /**
     * Returns the TRC as an array of shorts.  If the profile has
     * specified the TRC as linear (gamma = 1.0) or as a simple gamma
     * value, this method throws an exception, and the getGamma() method
     * should be used to get the gamma value.  Otherwise the short array
     * returned here represents a lookup table where the input Gray value
     * is conceptually in the range [0.0, 1.0].  Value 0.0 maps
     * to array index 0 and value 1.0 maps to array index length-1.
     * Interpolation may be used to generate output values for
     * input values which do not map exactly to an index in the
     * array.  Output values also map linearly to the range [0.0, 1.0].
     * Value 0.0 is represented by an array value of 0x0000 and
     * value 1.0 by 0xFFFF, i.e. the values are really unsigned
     * short values, although they are returned in a short array.
     * theTagSignature should be one of icSigGrayTRCTag, icSigRedTRCTag,
     * icSigGreenTRCTag, or icSigBlueTRCTag.
     * @return a short array representing the TRC.
     * @exception ProfileDataException if the profile does not specify
     *            the TRC as a table.
     */
    short[] getTRC(int theTagSignature) {
    byte[] theTRCData;
    short[] theTRC;
    int i1, i2, nElements, theU8Fixed8;

<span class="nc" id="L1647">        theTRCData = getData(theTagSignature); /* get the TRC */</span>
                                               /* getData will activate deferred
                                                  profiles if necessary */

<span class="nc" id="L1651">        nElements = intFromBigEndian(theTRCData, icCurveCount);</span>

<span class="nc bnc" id="L1653" title="All 2 branches missed.">        if (nElements == 1) {</span>
<span class="nc" id="L1654">            throw new ProfileDataException(&quot;TRC is not a table&quot;);</span>
        }

        /* make the short array */
<span class="nc" id="L1658">        theTRC = new short [nElements];</span>

<span class="nc bnc" id="L1660" title="All 2 branches missed.">        for (i1 = 0, i2 = icCurveData; i1 &lt; nElements; i1++, i2 += 2) {</span>
<span class="nc" id="L1661">            theTRC[i1] = shortFromBigEndian(theTRCData, i2);</span>
        }

<span class="nc" id="L1664">        return theTRC;</span>
    }


    /* convert an ICC color space signature into a Java color space type */
    static int iccCStoJCS(int theColorSpaceSig) {
    int theColorSpace;

<span class="nc bnc" id="L1672" title="All 26 branches missed.">        switch (theColorSpaceSig) {</span>
        case icSigXYZData:
<span class="nc" id="L1674">            theColorSpace = ColorSpace.TYPE_XYZ;</span>
<span class="nc" id="L1675">            break;</span>

        case icSigLabData:
<span class="nc" id="L1678">            theColorSpace = ColorSpace.TYPE_Lab;</span>
<span class="nc" id="L1679">            break;</span>

        case icSigLuvData:
<span class="nc" id="L1682">            theColorSpace = ColorSpace.TYPE_Luv;</span>
<span class="nc" id="L1683">            break;</span>

        case icSigYCbCrData:
<span class="nc" id="L1686">            theColorSpace = ColorSpace.TYPE_YCbCr;</span>
<span class="nc" id="L1687">            break;</span>

        case icSigYxyData:
<span class="nc" id="L1690">            theColorSpace = ColorSpace.TYPE_Yxy;</span>
<span class="nc" id="L1691">            break;</span>

        case icSigRgbData:
<span class="nc" id="L1694">            theColorSpace = ColorSpace.TYPE_RGB;</span>
<span class="nc" id="L1695">            break;</span>

        case icSigGrayData:
<span class="nc" id="L1698">            theColorSpace = ColorSpace.TYPE_GRAY;</span>
<span class="nc" id="L1699">            break;</span>

        case icSigHsvData:
<span class="nc" id="L1702">            theColorSpace = ColorSpace.TYPE_HSV;</span>
<span class="nc" id="L1703">            break;</span>

        case icSigHlsData:
<span class="nc" id="L1706">            theColorSpace = ColorSpace.TYPE_HLS;</span>
<span class="nc" id="L1707">            break;</span>

        case icSigCmykData:
<span class="nc" id="L1710">            theColorSpace = ColorSpace.TYPE_CMYK;</span>
<span class="nc" id="L1711">            break;</span>

        case icSigCmyData:
<span class="nc" id="L1714">            theColorSpace = ColorSpace.TYPE_CMY;</span>
<span class="nc" id="L1715">            break;</span>

        case icSigSpace2CLR:
<span class="nc" id="L1718">            theColorSpace = ColorSpace.TYPE_2CLR;</span>
<span class="nc" id="L1719">            break;</span>

        case icSigSpace3CLR:
<span class="nc" id="L1722">            theColorSpace = ColorSpace.TYPE_3CLR;</span>
<span class="nc" id="L1723">            break;</span>

        case icSigSpace4CLR:
<span class="nc" id="L1726">            theColorSpace = ColorSpace.TYPE_4CLR;</span>
<span class="nc" id="L1727">            break;</span>

        case icSigSpace5CLR:
<span class="nc" id="L1730">            theColorSpace = ColorSpace.TYPE_5CLR;</span>
<span class="nc" id="L1731">            break;</span>

        case icSigSpace6CLR:
<span class="nc" id="L1734">            theColorSpace = ColorSpace.TYPE_6CLR;</span>
<span class="nc" id="L1735">            break;</span>

        case icSigSpace7CLR:
<span class="nc" id="L1738">            theColorSpace = ColorSpace.TYPE_7CLR;</span>
<span class="nc" id="L1739">            break;</span>

        case icSigSpace8CLR:
<span class="nc" id="L1742">            theColorSpace = ColorSpace.TYPE_8CLR;</span>
<span class="nc" id="L1743">            break;</span>

        case icSigSpace9CLR:
<span class="nc" id="L1746">            theColorSpace = ColorSpace.TYPE_9CLR;</span>
<span class="nc" id="L1747">            break;</span>

        case icSigSpaceACLR:
<span class="nc" id="L1750">            theColorSpace = ColorSpace.TYPE_ACLR;</span>
<span class="nc" id="L1751">            break;</span>

        case icSigSpaceBCLR:
<span class="nc" id="L1754">            theColorSpace = ColorSpace.TYPE_BCLR;</span>
<span class="nc" id="L1755">            break;</span>

        case icSigSpaceCCLR:
<span class="nc" id="L1758">            theColorSpace = ColorSpace.TYPE_CCLR;</span>
<span class="nc" id="L1759">            break;</span>

        case icSigSpaceDCLR:
<span class="nc" id="L1762">            theColorSpace = ColorSpace.TYPE_DCLR;</span>
<span class="nc" id="L1763">            break;</span>

        case icSigSpaceECLR:
<span class="nc" id="L1766">            theColorSpace = ColorSpace.TYPE_ECLR;</span>
<span class="nc" id="L1767">            break;</span>

        case icSigSpaceFCLR:
<span class="nc" id="L1770">            theColorSpace = ColorSpace.TYPE_FCLR;</span>
<span class="nc" id="L1771">            break;</span>

        default:
<span class="nc" id="L1774">            throw new IllegalArgumentException (&quot;Unknown color space&quot;);</span>
        }

<span class="nc" id="L1777">        return theColorSpace;</span>
    }


    static int intFromBigEndian(byte[] array, int index) {
<span class="nc" id="L1782">        return (((array[index]   &amp; 0xff) &lt;&lt; 24) |</span>
                ((array[index+1] &amp; 0xff) &lt;&lt; 16) |
                ((array[index+2] &amp; 0xff) &lt;&lt;  8) |
                 (array[index+3] &amp; 0xff));
    }


    static void intToBigEndian(int value, byte[] array, int index) {
<span class="nc" id="L1790">            array[index]   = (byte) (value &gt;&gt; 24);</span>
<span class="nc" id="L1791">            array[index+1] = (byte) (value &gt;&gt; 16);</span>
<span class="nc" id="L1792">            array[index+2] = (byte) (value &gt;&gt;  8);</span>
<span class="nc" id="L1793">            array[index+3] = (byte) (value);</span>
<span class="nc" id="L1794">    }</span>


    static short shortFromBigEndian(byte[] array, int index) {
<span class="nc" id="L1798">        return (short) (((array[index]   &amp; 0xff) &lt;&lt; 8) |</span>
                         (array[index+1] &amp; 0xff));
    }


    static void shortToBigEndian(short value, byte[] array, int index) {
<span class="nc" id="L1804">            array[index]   = (byte) (value &gt;&gt; 8);</span>
<span class="nc" id="L1805">            array[index+1] = (byte) (value);</span>
<span class="nc" id="L1806">    }</span>


    /*
     * fileName may be an absolute or a relative file specification.
     * Relative file names are looked for in several places: first, relative
     * to any directories specified by the java.iccprofile.path property;
     * second, relative to any directories specified by the java.class.path
     * property; finally, in a directory used to store profiles always
     * available, such as a profile for sRGB.  Built-in profiles use .pf as
     * the file name extension for profiles, e.g. sRGB.pf.
     */
    private static File getProfileFile(String fileName) {
        String path, dir, fullPath;

<span class="nc" id="L1821">        File f = new File(fileName); /* try absolute file name */</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">        if (f.isAbsolute()) {</span>
            /* Rest of code has little sense for an absolute pathname,
               so return here. */
<span class="nc bnc" id="L1825" title="All 2 branches missed.">            return f.isFile() ? f : null;</span>
        }
<span class="nc bnc" id="L1827" title="All 2 branches missed.">        if ((!f.isFile()) &amp;&amp;</span>
<span class="nc bnc" id="L1828" title="All 2 branches missed.">                ((path = System.getProperty(&quot;java.iccprofile.path&quot;)) != null)){</span>
                                    /* try relative to java.iccprofile.path */
<span class="nc" id="L1830">                StringTokenizer st =</span>
                    new StringTokenizer(path, File.pathSeparator);
<span class="nc bnc" id="L1832" title="All 6 branches missed.">                while (st.hasMoreTokens() &amp;&amp; ((f == null) || (!f.isFile()))) {</span>
<span class="nc" id="L1833">                    dir = st.nextToken();</span>
<span class="nc" id="L1834">                        fullPath = dir + File.separatorChar + fileName;</span>
<span class="nc" id="L1835">                    f = new File(fullPath);</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">                    if (!isChildOf(f, dir)) {</span>
<span class="nc" id="L1837">                        f = null;</span>
                    }
                }
            }

<span class="nc bnc" id="L1842" title="All 4 branches missed.">        if (((f == null) || (!f.isFile())) &amp;&amp;</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">                ((path = System.getProperty(&quot;java.class.path&quot;)) != null)) {</span>
                                    /* try relative to java.class.path */
<span class="nc" id="L1845">                StringTokenizer st =</span>
                    new StringTokenizer(path, File.pathSeparator);
<span class="nc bnc" id="L1847" title="All 6 branches missed.">                while (st.hasMoreTokens() &amp;&amp; ((f == null) || (!f.isFile()))) {</span>
<span class="nc" id="L1848">                    dir = st.nextToken();</span>
<span class="nc" id="L1849">                        fullPath = dir + File.separatorChar + fileName;</span>
<span class="nc" id="L1850">                    f = new File(fullPath);</span>
                }
            }

<span class="nc bnc" id="L1854" title="All 4 branches missed.">        if ((f == null) || (!f.isFile())) {</span>
            /* try the directory of built-in profiles */
<span class="nc" id="L1856">            f = getStandardProfileFile(fileName);</span>
        }
<span class="nc bnc" id="L1858" title="All 4 branches missed.">        if (f != null &amp;&amp; f.isFile()) {</span>
<span class="nc" id="L1859">            return f;</span>
        }
<span class="nc" id="L1861">        return null;</span>
    }

    /**
     * Returns a file object corresponding to a built-in profile
     * specified by fileName.
     * If there is no built-in profile with such name, then the method
     * returns null.
     */
    private static File getStandardProfileFile(String fileName) {
<span class="nc" id="L1871">        String dir = System.getProperty(&quot;java.home&quot;) +</span>
            File.separatorChar + &quot;lib&quot; + File.separatorChar + &quot;cmm&quot;;
<span class="nc" id="L1873">        String fullPath = dir + File.separatorChar + fileName;</span>
<span class="nc" id="L1874">        File f = new File(fullPath);</span>
<span class="nc bnc" id="L1875" title="All 4 branches missed.">        return (f.isFile() &amp;&amp; isChildOf(f, dir)) ? f : null;</span>
    }

    /**
     * Checks whether given file resides inside give directory.
     */
    private static boolean isChildOf(File f, String dirName) {
        try {
<span class="nc" id="L1883">            File dir = new File(dirName);</span>
<span class="nc" id="L1884">            String canonicalDirName = dir.getCanonicalPath();</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">            if (!canonicalDirName.endsWith(File.separator)) {</span>
<span class="nc" id="L1886">                canonicalDirName += File.separator;</span>
            }
<span class="nc" id="L1888">            String canonicalFileName = f.getCanonicalPath();</span>
<span class="nc" id="L1889">            return canonicalFileName.startsWith(canonicalDirName);</span>
<span class="nc" id="L1890">        } catch (IOException e) {</span>
            /* we do not expect the IOException here, because invocation
             * of this function is always preceeded by isFile() call.
             */
<span class="nc" id="L1894">            return false;</span>
        }
    }

    /**
     * Checks whether built-in profile specified by fileName exists.
     */
    private static boolean standardProfileExists(final String fileName) {
<span class="nc" id="L1902">        return AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() {</span>
                public Boolean run() {
<span class="nc bnc" id="L1904" title="All 2 branches missed.">                    return getStandardProfileFile(fileName) != null;</span>
                }
            });
    }


    /*
     * Serialization support.
     *
     * Directly deserialized profiles are useless since they are not
     * registered with CMM.  We don't allow constructor to be called
     * directly and instead have clients to call one of getInstance
     * factory methods that will register the profile with CMM.  For
     * deserialization we implement readResolve method that will
     * resolve the bogus deserialized profile object with one obtained
     * with getInstance as well.
     *
     * There're two primary factory methods for construction of ICC
     * profiles: getInstance(int cspace) and getInstance(byte[] data).
     * This implementation of ICC_Profile uses the former to return a
     * cached singleton profile object, other implementations will
     * likely use this technique too.  To preserve the singleton
     * pattern across serialization we serialize cached singleton
     * profiles in such a way that deserializing VM could call
     * getInstance(int cspace) method that will resolve deserialized
     * object into the corresponding singleton as well.
     *
     * Since the singletons are private to ICC_Profile the readResolve
     * method have to be `protected' instead of `private' so that
     * singletons that are instances of subclasses of ICC_Profile
     * could be correctly deserialized.
     */


    /**
     * Version of the format of additional serialized data in the
     * stream.  Version&amp;nbsp;&lt;code&gt;1&lt;/code&gt; corresponds to Java&amp;nbsp;2
     * Platform,&amp;nbsp;v1.3.
     * @since 1.3
     * @serial
     */
<span class="nc" id="L1945">    private int iccProfileSerializedDataVersion = 1;</span>


    /**
     * Writes default serializable fields to the stream.  Writes a
     * string and an array of bytes to the stream as additional data.
     *
     * @param s stream used for serialization.
     * @throws IOException
     *     thrown by &lt;code&gt;ObjectInputStream&lt;/code&gt;.
     * @serialData
     *     The &lt;code&gt;String&lt;/code&gt; is the name of one of
     *     &lt;code&gt;CS_&lt;var&gt;*&lt;/var&gt;&lt;/code&gt; constants defined in the
     *     {@link ColorSpace} class if the profile object is a profile
     *     for a predefined color space (for example
     *     &lt;code&gt;&quot;CS_sRGB&quot;&lt;/code&gt;).  The string is &lt;code&gt;null&lt;/code&gt;
     *     otherwise.
     *     &lt;p&gt;
     *     The &lt;code&gt;byte[]&lt;/code&gt; array is the profile data for the
     *     profile.  For predefined color spaces &lt;code&gt;null&lt;/code&gt; is
     *     written instead of the profile data.  If in the future
     *     versions of Java API new predefined color spaces will be
     *     added, future versions of this class may choose to write
     *     for new predefined color spaces not only the color space
     *     name, but the profile data as well so that older versions
     *     could still deserialize the object.
     */
    private void writeObject(ObjectOutputStream s)
      throws IOException
    {
<span class="nc" id="L1975">        s.defaultWriteObject();</span>

<span class="nc" id="L1977">        String csName = null;</span>
<span class="nc bnc" id="L1978" title="All 2 branches missed.">        if (this == sRGBprofile) {</span>
<span class="nc" id="L1979">            csName = &quot;CS_sRGB&quot;;</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">        } else if (this == XYZprofile) {</span>
<span class="nc" id="L1981">            csName = &quot;CS_CIEXYZ&quot;;</span>
<span class="nc bnc" id="L1982" title="All 2 branches missed.">        } else if (this == PYCCprofile) {</span>
<span class="nc" id="L1983">            csName = &quot;CS_PYCC&quot;;</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">        } else if (this == GRAYprofile) {</span>
<span class="nc" id="L1985">            csName = &quot;CS_GRAY&quot;;</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">        } else if (this == LINEAR_RGBprofile) {</span>
<span class="nc" id="L1987">            csName = &quot;CS_LINEAR_RGB&quot;;</span>
        }

        // Future versions may choose to write profile data for new
        // predefined color spaces as well, if any will be introduced,
        // so that old versions that don't recognize the new CS name
        // may fall back to constructing profile from the data.
<span class="nc" id="L1994">        byte[] data = null;</span>
<span class="nc bnc" id="L1995" title="All 2 branches missed.">        if (csName == null) {</span>
            // getData will activate deferred profile if necessary
<span class="nc" id="L1997">            data = getData();</span>
        }

<span class="nc" id="L2000">        s.writeObject(csName);</span>
<span class="nc" id="L2001">        s.writeObject(data);</span>
<span class="nc" id="L2002">    }</span>

    // Temporary storage used by readObject to store resolved profile
    // (obtained with getInstance) for readResolve to return.
    private transient ICC_Profile resolvedDeserializedProfile;

    /**
     * Reads default serializable fields from the stream.  Reads from
     * the stream a string and an array of bytes as additional data.
     *
     * @param s stream used for deserialization.
     * @throws IOException
     *     thrown by &lt;code&gt;ObjectInputStream&lt;/code&gt;.
     * @throws ClassNotFoundException
     *     thrown by &lt;code&gt;ObjectInputStream&lt;/code&gt;.
     * @serialData
     *     The &lt;code&gt;String&lt;/code&gt; is the name of one of
     *     &lt;code&gt;CS_&lt;var&gt;*&lt;/var&gt;&lt;/code&gt; constants defined in the
     *     {@link ColorSpace} class if the profile object is a profile
     *     for a predefined color space (for example
     *     &lt;code&gt;&quot;CS_sRGB&quot;&lt;/code&gt;).  The string is &lt;code&gt;null&lt;/code&gt;
     *     otherwise.
     *     &lt;p&gt;
     *     The &lt;code&gt;byte[]&lt;/code&gt; array is the profile data for the
     *     profile.  It will usually be &lt;code&gt;null&lt;/code&gt; for the
     *     predefined profiles.
     *     &lt;p&gt;
     *     If the string is recognized as a constant name for
     *     predefined color space the object will be resolved into
     *     profile obtained with
     *     &lt;code&gt;getInstance(int&amp;nbsp;cspace)&lt;/code&gt; and the profile
     *     data are ignored.  Otherwise the object will be resolved
     *     into profile obtained with
     *     &lt;code&gt;getInstance(byte[]&amp;nbsp;data)&lt;/code&gt;.
     * @see #readResolve()
     * @see #getInstance(int)
     * @see #getInstance(byte[])
     */
    private void readObject(ObjectInputStream s)
      throws IOException, ClassNotFoundException
    {
<span class="nc" id="L2043">        s.defaultReadObject();</span>

<span class="nc" id="L2045">        String csName = (String)s.readObject();</span>
<span class="nc" id="L2046">        byte[] data = (byte[])s.readObject();</span>

<span class="nc" id="L2048">        int cspace = 0;         // ColorSpace.CS_* constant if known</span>
<span class="nc" id="L2049">        boolean isKnownPredefinedCS = false;</span>
<span class="nc bnc" id="L2050" title="All 2 branches missed.">        if (csName != null) {</span>
<span class="nc" id="L2051">            isKnownPredefinedCS = true;</span>
<span class="nc bnc" id="L2052" title="All 2 branches missed.">            if (csName.equals(&quot;CS_sRGB&quot;)) {</span>
<span class="nc" id="L2053">                cspace = ColorSpace.CS_sRGB;</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">            } else if (csName.equals(&quot;CS_CIEXYZ&quot;)) {</span>
<span class="nc" id="L2055">                cspace = ColorSpace.CS_CIEXYZ;</span>
<span class="nc bnc" id="L2056" title="All 2 branches missed.">            } else if (csName.equals(&quot;CS_PYCC&quot;)) {</span>
<span class="nc" id="L2057">                cspace = ColorSpace.CS_PYCC;</span>
<span class="nc bnc" id="L2058" title="All 2 branches missed.">            } else if (csName.equals(&quot;CS_GRAY&quot;)) {</span>
<span class="nc" id="L2059">                cspace = ColorSpace.CS_GRAY;</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">            } else if (csName.equals(&quot;CS_LINEAR_RGB&quot;)) {</span>
<span class="nc" id="L2061">                cspace = ColorSpace.CS_LINEAR_RGB;</span>
            } else {
<span class="nc" id="L2063">                isKnownPredefinedCS = false;</span>
            }
        }

<span class="nc bnc" id="L2067" title="All 2 branches missed.">        if (isKnownPredefinedCS) {</span>
<span class="nc" id="L2068">            resolvedDeserializedProfile = getInstance(cspace);</span>
        } else {
<span class="nc" id="L2070">            resolvedDeserializedProfile = getInstance(data);</span>
        }
<span class="nc" id="L2072">    }</span>

    /**
     * Resolves instances being deserialized into instances registered
     * with CMM.
     * @return ICC_Profile object for profile registered with CMM.
     * @throws ObjectStreamException
     *     never thrown, but mandated by the serialization spec.
     * @since 1.3
     */
    protected Object readResolve() throws ObjectStreamException {
<span class="nc" id="L2083">        return resolvedDeserializedProfile;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>