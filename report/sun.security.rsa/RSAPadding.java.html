<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RSAPadding.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.rsa</a> &gt; <span class="el_source">RSAPadding.java</span></div><h1>RSAPadding.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013 Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.rsa;

import java.math.BigInteger;
import java.util.*;

import java.security.*;
import java.security.interfaces.*;
import java.security.spec.*;

import javax.crypto.BadPaddingException;
import javax.crypto.spec.PSource;
import javax.crypto.spec.OAEPParameterSpec;

import sun.security.jca.JCAUtil;

/**
 * RSA padding and unpadding.
 *
 * Format of PKCS#1 v1.5 padding is:
 *   0x00 | BT | PS...PS | 0x00 | data...data
 * where BT is the blocktype (1 or 2). The length of the entire string
 * must be the same as the size of the modulus (i.e. 128 byte for a 1024 bit
 * key). Per spec, the padding string must be at least 8 bytes long. That
 * leaves up to (length of key in bytes) - 11 bytes for the data.
 *
 * OAEP padding is a bit more complicated and has a number of options.
 * We support:
 *   . arbitrary hash functions ('Hash' in the specification), MessageDigest
 *     implementation must be available
 *   . MGF1 as the mask generation function
 *   . the empty string as the default value for label L and whatever
 *     specified in javax.crypto.spec.OAEPParameterSpec
 *
 * Note: RSA keys should be at least 512 bits long
 *
 * @since   1.5
 * @author  Andreas Sterbenz
 */
public final class RSAPadding {

    // NOTE: the constants below are embedded in the JCE RSACipher class
    // file. Do not change without coordinating the update

    // PKCS#1 v1.5 padding, blocktype 1 (signing)
    public final static int PAD_BLOCKTYPE_1    = 1;
    // PKCS#1 v1.5 padding, blocktype 2 (encryption)
    public final static int PAD_BLOCKTYPE_2    = 2;
    // nopadding. Does not do anything, but allows simpler RSACipher code
    public final static int PAD_NONE           = 3;
    // PKCS#1 v2.1 OAEP padding
    public final static int PAD_OAEP_MGF1 = 4;

    // type, one of PAD_*
    private final int type;

    // size of the padded block (i.e. size of the modulus)
    private final int paddedSize;

    // PRNG used to generate padding bytes (PAD_BLOCKTYPE_2, PAD_OAEP_MGF1)
    private SecureRandom random;

    // maximum size of the data
    private final int maxDataSize;

    // OAEP: main messagedigest
    private MessageDigest md;

    // OAEP: message digest for MGF1
    private MessageDigest mgfMd;

    // OAEP: value of digest of data (user-supplied or zero-length) using md
    private byte[] lHash;

    /**
     * Get a RSAPadding instance of the specified type.
     * Keys used with this padding must be paddedSize bytes long.
     */
    public static RSAPadding getInstance(int type, int paddedSize)
            throws InvalidKeyException, InvalidAlgorithmParameterException {
<span class="fc" id="L105">        return new RSAPadding(type, paddedSize, null, null);</span>
    }

    /**
     * Get a RSAPadding instance of the specified type.
     * Keys used with this padding must be paddedSize bytes long.
     */
    public static RSAPadding getInstance(int type, int paddedSize,
            SecureRandom random) throws InvalidKeyException,
            InvalidAlgorithmParameterException {
<span class="fc" id="L115">        return new RSAPadding(type, paddedSize, random, null);</span>
    }

    /**
     * Get a RSAPadding instance of the specified type, which must be
     * OAEP. Keys used with this padding must be paddedSize bytes long.
     */
    public static RSAPadding getInstance(int type, int paddedSize,
            SecureRandom random, OAEPParameterSpec spec)
        throws InvalidKeyException, InvalidAlgorithmParameterException {
<span class="nc" id="L125">        return new RSAPadding(type, paddedSize, random, spec);</span>
    }

    // internal constructor
    private RSAPadding(int type, int paddedSize, SecureRandom random,
            OAEPParameterSpec spec) throws InvalidKeyException,
<span class="fc" id="L131">            InvalidAlgorithmParameterException {</span>
<span class="fc" id="L132">        this.type = type;</span>
<span class="fc" id="L133">        this.paddedSize = paddedSize;</span>
<span class="fc" id="L134">        this.random = random;</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        if (paddedSize &lt; 64) {</span>
            // sanity check, already verified in RSASignature/RSACipher
<span class="nc" id="L137">            throw new InvalidKeyException(&quot;Padded size must be at least 64&quot;);</span>
        }
<span class="pc bpc" id="L139" title="3 of 4 branches missed.">        switch (type) {</span>
        case PAD_BLOCKTYPE_1:
        case PAD_BLOCKTYPE_2:
<span class="fc" id="L142">            maxDataSize = paddedSize - 11;</span>
<span class="fc" id="L143">            break;</span>
        case PAD_NONE:
<span class="nc" id="L145">            maxDataSize = paddedSize;</span>
<span class="nc" id="L146">            break;</span>
        case PAD_OAEP_MGF1:
<span class="nc" id="L148">            String mdName = &quot;SHA-1&quot;;</span>
<span class="nc" id="L149">            String mgfMdName = &quot;SHA-1&quot;;</span>
<span class="nc" id="L150">            byte[] digestInput = null;</span>
            try {
<span class="nc bnc" id="L152" title="All 2 branches missed.">                if (spec != null) {</span>
<span class="nc" id="L153">                    mdName = spec.getDigestAlgorithm();</span>
<span class="nc" id="L154">                    String mgfName = spec.getMGFAlgorithm();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">                    if (!mgfName.equalsIgnoreCase(&quot;MGF1&quot;)) {</span>
<span class="nc" id="L156">                        throw new InvalidAlgorithmParameterException</span>
                            (&quot;Unsupported MGF algo: &quot; + mgfName);
                    }
<span class="nc" id="L159">                    mgfMdName = ((MGF1ParameterSpec)spec.getMGFParameters()).getDigestAlgorithm();</span>
<span class="nc" id="L160">                    PSource pSrc = spec.getPSource();</span>
<span class="nc" id="L161">                    String pSrcAlgo = pSrc.getAlgorithm();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                    if (!pSrcAlgo.equalsIgnoreCase(&quot;PSpecified&quot;)) {</span>
<span class="nc" id="L163">                        throw new InvalidAlgorithmParameterException</span>
                            (&quot;Unsupported pSource algo: &quot; + pSrcAlgo);
                    }
<span class="nc" id="L166">                    digestInput = ((PSource.PSpecified) pSrc).getValue();</span>
                }
<span class="nc" id="L168">                md = MessageDigest.getInstance(mdName);</span>
<span class="nc" id="L169">                mgfMd = MessageDigest.getInstance(mgfMdName);</span>
<span class="nc" id="L170">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L171">                throw new InvalidKeyException</span>
                        (&quot;Digest &quot; + mdName + &quot; not available&quot;, e);
<span class="nc" id="L173">            }</span>
<span class="nc" id="L174">            lHash = getInitialHash(md, digestInput);</span>
<span class="nc" id="L175">            int digestLen = lHash.length;</span>
<span class="nc" id="L176">            maxDataSize = paddedSize - 2 - 2 * digestLen;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (maxDataSize &lt;= 0) {</span>
<span class="nc" id="L178">                throw new InvalidKeyException</span>
                        (&quot;Key is too short for encryption using OAEPPadding&quot; +
                         &quot; with &quot; + mdName + &quot; and MGF1&quot; + mgfMdName);
            }
            break;
        default:
<span class="nc" id="L184">            throw new InvalidKeyException(&quot;Invalid padding: &quot; + type);</span>
        }
<span class="fc" id="L186">    }</span>

    // cache of hashes of zero length data
<span class="fc" id="L189">    private static final Map&lt;String,byte[]&gt; emptyHashes =</span>
<span class="fc" id="L190">        Collections.synchronizedMap(new HashMap&lt;String,byte[]&gt;());</span>

    /**
     * Return the value of the digest using the specified message digest
     * &lt;code&gt;md&lt;/code&gt; and the digest input &lt;code&gt;digestInput&lt;/code&gt;.
     * if &lt;code&gt;digestInput&lt;/code&gt; is null or 0-length, zero length
     * is used to generate the initial digest.
     * Note: the md object must be in reset state
     */
    private static byte[] getInitialHash(MessageDigest md,
        byte[] digestInput) {
<span class="nc" id="L201">        byte[] result = null;</span>
<span class="nc bnc" id="L202" title="All 4 branches missed.">        if ((digestInput == null) || (digestInput.length == 0)) {</span>
<span class="nc" id="L203">            String digestName = md.getAlgorithm();</span>
<span class="nc" id="L204">            result = emptyHashes.get(digestName);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (result == null) {</span>
<span class="nc" id="L206">                result = md.digest();</span>
<span class="nc" id="L207">                emptyHashes.put(digestName, result);</span>
            }
<span class="nc" id="L209">        } else {</span>
<span class="nc" id="L210">            result = md.digest(digestInput);</span>
        }
<span class="nc" id="L212">        return result;</span>
    }

    /**
     * Return the maximum size of the plaintext data that can be processed using
     * this object.
     */
    public int getMaxDataSize() {
<span class="fc" id="L220">        return maxDataSize;</span>
    }

    /**
     * Pad the data and return the padded block.
     */
    public byte[] pad(byte[] data, int ofs, int len)
            throws BadPaddingException {
<span class="fc" id="L228">        return pad(RSACore.convert(data, ofs, len));</span>
    }

    /**
     * Pad the data and return the padded block.
     */
    public byte[] pad(byte[] data) throws BadPaddingException {
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        if (data.length &gt; maxDataSize) {</span>
<span class="nc" id="L236">            throw new BadPaddingException(&quot;Data must be shorter than &quot;</span>
                + (maxDataSize + 1) + &quot; bytes&quot;);
        }
<span class="pc bpc" id="L239" title="3 of 4 branches missed.">        switch (type) {</span>
        case PAD_NONE:
<span class="nc" id="L241">            return data;</span>
        case PAD_BLOCKTYPE_1:
        case PAD_BLOCKTYPE_2:
<span class="fc" id="L244">            return padV15(data);</span>
        case PAD_OAEP_MGF1:
<span class="nc" id="L246">            return padOAEP(data);</span>
        default:
<span class="nc" id="L248">            throw new AssertionError();</span>
        }
    }

    /**
     * Unpad the padded block and return the data.
     */
    public byte[] unpad(byte[] padded, int ofs, int len)
            throws BadPaddingException {
<span class="nc" id="L257">        return unpad(RSACore.convert(padded, ofs, len));</span>
    }

    /**
     * Unpad the padded block and return the data.
     */
    public byte[] unpad(byte[] padded) throws BadPaddingException {
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (padded.length != paddedSize) {</span>
<span class="nc" id="L265">            throw new BadPaddingException(&quot;Padded length must be &quot; + paddedSize);</span>
        }
<span class="pc bpc" id="L267" title="3 of 4 branches missed.">        switch (type) {</span>
        case PAD_NONE:
<span class="nc" id="L269">            return padded;</span>
        case PAD_BLOCKTYPE_1:
        case PAD_BLOCKTYPE_2:
<span class="fc" id="L272">            return unpadV15(padded);</span>
        case PAD_OAEP_MGF1:
<span class="nc" id="L274">            return unpadOAEP(padded);</span>
        default:
<span class="nc" id="L276">            throw new AssertionError();</span>
        }
    }

    /**
     * PKCS#1 v1.5 padding (blocktype 1 and 2).
     */
    private byte[] padV15(byte[] data) throws BadPaddingException {
<span class="fc" id="L284">        byte[] padded = new byte[paddedSize];</span>
<span class="fc" id="L285">        System.arraycopy(data, 0, padded, paddedSize - data.length, data.length);</span>
<span class="fc" id="L286">        int psSize = paddedSize - 3 - data.length;</span>
<span class="fc" id="L287">        int k = 0;</span>
<span class="fc" id="L288">        padded[k++] = 0;</span>
<span class="fc" id="L289">        padded[k++] = (byte)type;</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (type == PAD_BLOCKTYPE_1) {</span>
            // blocktype 1: all padding bytes are 0xff
<span class="fc bfc" id="L292" title="All 2 branches covered.">            while (psSize-- &gt; 0) {</span>
<span class="fc" id="L293">                padded[k++] = (byte)0xff;</span>
            }
        } else {
            // blocktype 2: padding bytes are random non-zero bytes
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">            if (random == null) {</span>
<span class="nc" id="L298">                random = JCAUtil.getSecureRandom();</span>
            }
            // generate non-zero padding bytes
            // use a buffer to reduce calls to SecureRandom
<span class="fc" id="L302">            byte[] r = new byte[64];</span>
<span class="fc" id="L303">            int i = -1;</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">            while (psSize-- &gt; 0) {</span>
                int b;
                do {
<span class="fc bfc" id="L307" title="All 2 branches covered.">                    if (i &lt; 0) {</span>
<span class="fc" id="L308">                        random.nextBytes(r);</span>
<span class="fc" id="L309">                        i = r.length - 1;</span>
                    }
<span class="fc" id="L311">                    b = r[i--] &amp; 0xff;</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">                } while (b == 0);</span>
<span class="fc" id="L313">                padded[k++] = (byte)b;</span>
<span class="fc" id="L314">            }</span>
        }
<span class="fc" id="L316">        return padded;</span>
    }

    /**
     * PKCS#1 v1.5 unpadding (blocktype 1 and 2).
     */
    private byte[] unpadV15(byte[] padded) throws BadPaddingException {
<span class="fc" id="L323">        int k = 0;</span>
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (padded[k++] != 0) {</span>
<span class="fc" id="L325">            throw new BadPaddingException(&quot;Data must start with zero&quot;);</span>
        }
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        if (padded[k++] != type) {</span>
<span class="nc" id="L328">            throw new BadPaddingException(&quot;Blocktype mismatch: &quot; + padded[1]);</span>
        }
        while (true) {
<span class="fc" id="L331">            int b = padded[k++] &amp; 0xff;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">            if (b == 0) {</span>
<span class="fc" id="L333">                break;</span>
            }
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">            if (k == padded.length) {</span>
<span class="nc" id="L336">                throw new BadPaddingException(&quot;Padding string not terminated&quot;);</span>
            }
<span class="pc bpc" id="L338" title="1 of 4 branches missed.">            if ((type == PAD_BLOCKTYPE_1) &amp;&amp; (b != 0xff)) {</span>
<span class="nc" id="L339">                throw new BadPaddingException(&quot;Padding byte not 0xff: &quot; + b);</span>
            }
<span class="fc" id="L341">        }</span>
<span class="fc" id="L342">        int n = padded.length - k;</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        if (n &gt; maxDataSize) {</span>
<span class="nc" id="L344">            throw new BadPaddingException(&quot;Padding string too short&quot;);</span>
        }
<span class="fc" id="L346">        byte[] data = new byte[n];</span>
<span class="fc" id="L347">        System.arraycopy(padded, padded.length - n, data, 0, n);</span>
<span class="fc" id="L348">        return data;</span>
    }

    /**
     * PKCS#1 v2.0 OAEP padding (MGF1).
     * Paragraph references refer to PKCS#1 v2.1 (June 14, 2002)
     */
    private byte[] padOAEP(byte[] M) throws BadPaddingException {
<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (random == null) {</span>
<span class="nc" id="L357">            random = JCAUtil.getSecureRandom();</span>
        }
<span class="nc" id="L359">        int hLen = lHash.length;</span>

        // 2.d: generate a random octet string seed of length hLen
        // if necessary
<span class="nc" id="L363">        byte[] seed = new byte[hLen];</span>
<span class="nc" id="L364">        random.nextBytes(seed);</span>

        // buffer for encoded message EM
<span class="nc" id="L367">        byte[] EM = new byte[paddedSize];</span>

        // start and length of seed (as index into EM)
<span class="nc" id="L370">        int seedStart = 1;</span>
<span class="nc" id="L371">        int seedLen = hLen;</span>

        // copy seed into EM
<span class="nc" id="L374">        System.arraycopy(seed, 0, EM, seedStart, seedLen);</span>

        // start and length of data block DB in EM
        // we place it inside of EM to reduce copying
<span class="nc" id="L378">        int dbStart = hLen + 1;</span>
<span class="nc" id="L379">        int dbLen = EM.length - dbStart;</span>

        // start of message M in EM
<span class="nc" id="L382">        int mStart = paddedSize - M.length;</span>

        // build DB
        // 2.b: Concatenate lHash, PS, a single octet with hexadecimal value
        // 0x01, and the message M to form a data block DB of length
        // k - hLen -1 octets as DB = lHash || PS || 0x01 || M
        // (note that PS is all zeros)
<span class="nc" id="L389">        System.arraycopy(lHash, 0, EM, dbStart, hLen);</span>
<span class="nc" id="L390">        EM[mStart - 1] = 1;</span>
<span class="nc" id="L391">        System.arraycopy(M, 0, EM, mStart, M.length);</span>

        // produce maskedDB
<span class="nc" id="L394">        mgf1(EM, seedStart, seedLen, EM, dbStart, dbLen);</span>

        // produce maskSeed
<span class="nc" id="L397">        mgf1(EM, dbStart, dbLen, EM, seedStart, seedLen);</span>

<span class="nc" id="L399">        return EM;</span>
    }

    /**
     * PKCS#1 v2.1 OAEP unpadding (MGF1).
     */
    private byte[] unpadOAEP(byte[] padded) throws BadPaddingException {
<span class="nc" id="L406">        byte[] EM = padded;</span>
<span class="nc" id="L407">        int hLen = lHash.length;</span>

<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (EM[0] != 0) {</span>
<span class="nc" id="L410">            throw new BadPaddingException(&quot;Data must start with zero&quot;);</span>
        }

<span class="nc" id="L413">        int seedStart = 1;</span>
<span class="nc" id="L414">        int seedLen = hLen;</span>

<span class="nc" id="L416">        int dbStart = hLen + 1;</span>
<span class="nc" id="L417">        int dbLen = EM.length - dbStart;</span>

<span class="nc" id="L419">        mgf1(EM, dbStart, dbLen, EM, seedStart, seedLen);</span>
<span class="nc" id="L420">        mgf1(EM, seedStart, seedLen, EM, dbStart, dbLen);</span>

        // verify lHash == lHash'
<span class="nc bnc" id="L423" title="All 2 branches missed.">        for (int i = 0; i &lt; hLen; i++) {</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">            if (lHash[i] != EM[dbStart + i]) {</span>
<span class="nc" id="L425">                throw new BadPaddingException(&quot;lHash mismatch&quot;);</span>
            }
        }

        // skip over padding (0x00 bytes)
<span class="nc" id="L430">        int i = dbStart + hLen;</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">        while (EM[i] == 0) {</span>
<span class="nc" id="L432">            i++;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (i &gt;= EM.length) {</span>
<span class="nc" id="L434">                throw new BadPaddingException(&quot;Padding string not terminated&quot;);</span>
            }
        }

<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (EM[i++] != 1) {</span>
<span class="nc" id="L439">            throw new BadPaddingException</span>
                (&quot;Padding string not terminated by 0x01 byte&quot;);
        }

<span class="nc" id="L443">        int mLen = EM.length - i;</span>
<span class="nc" id="L444">        byte[] m = new byte[mLen];</span>
<span class="nc" id="L445">        System.arraycopy(EM, i, m, 0, mLen);</span>

<span class="nc" id="L447">        return m;</span>
    }

    /**
     * Compute MGF1 using mgfMD as the message digest.
     * Note that we combine MGF1 with the XOR operation to reduce data
     * copying.
     *
     * We generate maskLen bytes of MGF1 from the seed and XOR it into
     * out[] starting at outOfs;
     */
    private void mgf1(byte[] seed, int seedOfs, int seedLen,
            byte[] out, int outOfs, int maskLen)  throws BadPaddingException {
<span class="nc" id="L460">        byte[] C = new byte[4]; // 32 bit counter</span>
<span class="nc" id="L461">        byte[] digest = new byte[mgfMd.getDigestLength()];</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        while (maskLen &gt; 0) {</span>
<span class="nc" id="L463">            mgfMd.update(seed, seedOfs, seedLen);</span>
<span class="nc" id="L464">            mgfMd.update(C);</span>
            try {
<span class="nc" id="L466">                mgfMd.digest(digest, 0, digest.length);</span>
<span class="nc" id="L467">            } catch (DigestException e) {</span>
                // should never happen
<span class="nc" id="L469">                throw new BadPaddingException(e.toString());</span>
<span class="nc" id="L470">            }</span>
<span class="nc bnc" id="L471" title="All 4 branches missed.">            for (int i = 0; (i &lt; digest.length) &amp;&amp; (maskLen &gt; 0); maskLen--) {</span>
<span class="nc" id="L472">                out[outOfs++] ^= digest[i++];</span>
            }
<span class="nc bnc" id="L474" title="All 2 branches missed.">            if (maskLen &gt; 0) {</span>
                // increment counter
<span class="nc bnc" id="L476" title="All 4 branches missed.">                for (int i = C.length - 1; (++C[i] == 0) &amp;&amp; (i &gt; 0); i--) {</span>
                    // empty
                }
            }
        }
<span class="nc" id="L481">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>