<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RSAKeyFactory.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.rsa</a> &gt; <span class="el_source">RSAKeyFactory.java</span></div><h1>RSAKeyFactory.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.rsa;

import java.math.BigInteger;

import java.security.*;
import java.security.interfaces.*;
import java.security.spec.*;

import sun.security.action.GetPropertyAction;

/**
 * KeyFactory for RSA keys. Keys must be instances of PublicKey or PrivateKey
 * and getAlgorithm() must return &quot;RSA&quot;. For such keys, it supports conversion
 * between the following:
 *
 * For public keys:
 *  . PublicKey with an X.509 encoding
 *  . RSAPublicKey
 *  . RSAPublicKeySpec
 *  . X509EncodedKeySpec
 *
 * For private keys:
 *  . PrivateKey with a PKCS#8 encoding
 *  . RSAPrivateKey
 *  . RSAPrivateCrtKey
 *  . RSAPrivateKeySpec
 *  . RSAPrivateCrtKeySpec
 *  . PKCS8EncodedKeySpec
 * (of course, CRT variants only for CRT keys)
 *
 * Note: as always, RSA keys should be at least 512 bits long
 *
 * @since   1.5
 * @author  Andreas Sterbenz
 */
public final class RSAKeyFactory extends KeyFactorySpi {

<span class="fc" id="L63">    private final static Class&lt;?&gt; rsaPublicKeySpecClass =</span>
                                                RSAPublicKeySpec.class;
<span class="fc" id="L65">    private final static Class&lt;?&gt; rsaPrivateKeySpecClass =</span>
                                                RSAPrivateKeySpec.class;
<span class="fc" id="L67">    private final static Class&lt;?&gt; rsaPrivateCrtKeySpecClass =</span>
                                                RSAPrivateCrtKeySpec.class;

<span class="fc" id="L70">    private final static Class&lt;?&gt; x509KeySpecClass  = X509EncodedKeySpec.class;</span>
<span class="fc" id="L71">    private final static Class&lt;?&gt; pkcs8KeySpecClass = PKCS8EncodedKeySpec.class;</span>

    public final static int MIN_MODLEN = 512;
    public final static int MAX_MODLEN = 16384;

    /*
     * If the modulus length is above this value, restrict the size of
     * the exponent to something that can be reasonably computed.  We
     * could simply hardcode the exp len to something like 64 bits, but
     * this approach allows flexibility in case impls would like to use
     * larger module and exponent values.
     */
    public final static int MAX_MODLEN_RESTRICT_EXP = 3072;
    public final static int MAX_RESTRICTED_EXPLEN = 64;

<span class="fc" id="L86">    private static final boolean restrictExpLen =</span>
<span class="fc" id="L87">        &quot;true&quot;.equalsIgnoreCase(AccessController.doPrivileged(</span>
            new GetPropertyAction(
                &quot;sun.security.rsa.restrictRSAExponent&quot;, &quot;true&quot;)));

    // instance used for static translateKey();
<span class="fc" id="L92">    private final static RSAKeyFactory INSTANCE = new RSAKeyFactory();</span>

<span class="fc" id="L94">    public RSAKeyFactory() {</span>
        // empty
<span class="fc" id="L96">    }</span>

    /**
     * Static method to convert Key into an instance of RSAPublicKeyImpl
     * or RSAPrivate(Crt)KeyImpl. If the key is not an RSA key or cannot be
     * used, throw an InvalidKeyException.
     *
     * Used by RSASignature and RSACipher.
     */
    public static RSAKey toRSAKey(Key key) throws InvalidKeyException {
<span class="pc bpc" id="L106" title="1 of 6 branches missed.">        if ((key instanceof RSAPrivateKeyImpl) ||</span>
            (key instanceof RSAPrivateCrtKeyImpl) ||
            (key instanceof RSAPublicKeyImpl)) {
<span class="fc" id="L109">            return (RSAKey)key;</span>
        } else {
<span class="nc" id="L111">            return (RSAKey)INSTANCE.engineTranslateKey(key);</span>
        }
    }

    /*
     * Single test entry point for all of the mechanisms in the SunRsaSign
     * provider (RSA*KeyImpls).  All of the tests are the same.
     *
     * For compatibility, we round up to the nearest byte here:
     * some Key impls might pass in a value within a byte of the
     * real value.
     */
    static void checkRSAProviderKeyLengths(int modulusLen, BigInteger exponent)
            throws InvalidKeyException {
<span class="fc" id="L125">        checkKeyLengths(((modulusLen + 7) &amp; ~7), exponent,</span>
            RSAKeyFactory.MIN_MODLEN, Integer.MAX_VALUE);
<span class="fc" id="L127">    }</span>

    /**
     * Check the length of an RSA key modulus/exponent to make sure it
     * is not too short or long.  Some impls have their own min and
     * max key sizes that may or may not match with a system defined value.
     *
     * @param modulusLen the bit length of the RSA modulus.
     * @param exponent the RSA exponent
     * @param minModulusLen if &gt; 0, check to see if modulusLen is at
     *        least this long, otherwise unused.
     * @param maxModulusLen caller will allow this max number of bits.
     *        Allow the smaller of the system-defined maximum and this param.
     *
     * @throws InvalidKeyException if any of the values are unacceptable.
     */
     public static void checkKeyLengths(int modulusLen, BigInteger exponent,
            int minModulusLen, int maxModulusLen) throws InvalidKeyException {

<span class="pc bpc" id="L146" title="1 of 4 branches missed.">        if ((minModulusLen &gt; 0) &amp;&amp; (modulusLen &lt; (minModulusLen))) {</span>
<span class="nc" id="L147">            throw new InvalidKeyException( &quot;RSA keys must be at least &quot; +</span>
                minModulusLen + &quot; bits long&quot;);
        }

        // Even though our policy file may allow this, we don't want
        // either value (mod/exp) to be too big.

<span class="fc" id="L154">        int maxLen = Math.min(maxModulusLen, MAX_MODLEN);</span>

        // If a RSAPrivateKey/RSAPublicKey, make sure the
        // modulus len isn't too big.
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">        if (modulusLen &gt; maxLen) {</span>
<span class="nc" id="L159">            throw new InvalidKeyException(</span>
                &quot;RSA keys must be no longer than &quot; + maxLen + &quot; bits&quot;);
        }

        // If a RSAPublicKey, make sure the exponent isn't too big.
<span class="pc bpc" id="L164" title="1 of 6 branches missed.">        if (restrictExpLen &amp;&amp; (exponent != null) &amp;&amp;</span>
                (modulusLen &gt; MAX_MODLEN_RESTRICT_EXP) &amp;&amp;
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">                (exponent.bitLength() &gt; MAX_RESTRICTED_EXPLEN)) {</span>
<span class="nc" id="L167">            throw new InvalidKeyException(</span>
                &quot;RSA exponents can be no longer than &quot; +
                MAX_RESTRICTED_EXPLEN + &quot; bits &quot; +
                &quot; if modulus is greater than &quot; +
                MAX_MODLEN_RESTRICT_EXP + &quot; bits&quot;);
        }
<span class="fc" id="L173">    }</span>

    /**
     * Translate an RSA key into a SunRsaSign RSA key. If conversion is
     * not possible, throw an InvalidKeyException.
     * See also JCA doc.
     */
    protected Key engineTranslateKey(Key key) throws InvalidKeyException {
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        if (key == null) {</span>
<span class="nc" id="L182">            throw new InvalidKeyException(&quot;Key must not be null&quot;);</span>
        }
<span class="fc" id="L184">        String keyAlg = key.getAlgorithm();</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (keyAlg.equals(&quot;RSA&quot;) == false) {</span>
<span class="fc" id="L186">            throw new InvalidKeyException(&quot;Not an RSA key: &quot; + keyAlg);</span>
        }
<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (key instanceof PublicKey) {</span>
<span class="nc" id="L189">            return translatePublicKey((PublicKey)key);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        } else if (key instanceof PrivateKey) {</span>
<span class="nc" id="L191">            return translatePrivateKey((PrivateKey)key);</span>
        } else {
<span class="nc" id="L193">            throw new InvalidKeyException(&quot;Neither a public nor a private key&quot;);</span>
        }
    }

    // see JCA doc
    protected PublicKey engineGeneratePublic(KeySpec keySpec)
            throws InvalidKeySpecException {
        try {
<span class="fc" id="L201">            return generatePublic(keySpec);</span>
<span class="nc" id="L202">        } catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L203">            throw e;</span>
<span class="nc" id="L204">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L205">            throw new InvalidKeySpecException(e);</span>
        }
    }

    // see JCA doc
    protected PrivateKey engineGeneratePrivate(KeySpec keySpec)
            throws InvalidKeySpecException {
        try {
<span class="fc" id="L213">            return generatePrivate(keySpec);</span>
<span class="nc" id="L214">        } catch (InvalidKeySpecException e) {</span>
<span class="nc" id="L215">            throw e;</span>
<span class="nc" id="L216">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L217">            throw new InvalidKeySpecException(e);</span>
        }
    }

    // internal implementation of translateKey() for public keys. See JCA doc
    private PublicKey translatePublicKey(PublicKey key)
            throws InvalidKeyException {
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (key instanceof RSAPublicKey) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (key instanceof RSAPublicKeyImpl) {</span>
<span class="nc" id="L226">                return key;</span>
            }
<span class="nc" id="L228">            RSAPublicKey rsaKey = (RSAPublicKey)key;</span>
            try {
<span class="nc" id="L230">                return new RSAPublicKeyImpl(</span>
<span class="nc" id="L231">                    rsaKey.getModulus(),</span>
<span class="nc" id="L232">                    rsaKey.getPublicExponent()</span>
                );
<span class="nc" id="L234">            } catch (RuntimeException e) {</span>
                // catch providers that incorrectly implement RSAPublicKey
<span class="nc" id="L236">                throw new InvalidKeyException(&quot;Invalid key&quot;, e);</span>
            }
<span class="nc bnc" id="L238" title="All 2 branches missed.">        } else if (&quot;X.509&quot;.equals(key.getFormat())) {</span>
<span class="nc" id="L239">            byte[] encoded = key.getEncoded();</span>
<span class="nc" id="L240">            return new RSAPublicKeyImpl(encoded);</span>
        } else {
<span class="nc" id="L242">            throw new InvalidKeyException(&quot;Public keys must be instance &quot;</span>
                + &quot;of RSAPublicKey or have X.509 encoding&quot;);
        }
    }

    // internal implementation of translateKey() for private keys. See JCA doc
    private PrivateKey translatePrivateKey(PrivateKey key)
            throws InvalidKeyException {
<span class="pc bpc" id="L250" title="1 of 2 branches missed.">        if (key instanceof RSAPrivateCrtKey) {</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if (key instanceof RSAPrivateCrtKeyImpl) {</span>
<span class="nc" id="L252">                return key;</span>
            }
<span class="nc" id="L254">            RSAPrivateCrtKey rsaKey = (RSAPrivateCrtKey)key;</span>
            try {
<span class="nc" id="L256">                return new RSAPrivateCrtKeyImpl(</span>
<span class="nc" id="L257">                    rsaKey.getModulus(),</span>
<span class="nc" id="L258">                    rsaKey.getPublicExponent(),</span>
<span class="nc" id="L259">                    rsaKey.getPrivateExponent(),</span>
<span class="nc" id="L260">                    rsaKey.getPrimeP(),</span>
<span class="nc" id="L261">                    rsaKey.getPrimeQ(),</span>
<span class="nc" id="L262">                    rsaKey.getPrimeExponentP(),</span>
<span class="nc" id="L263">                    rsaKey.getPrimeExponentQ(),</span>
<span class="nc" id="L264">                    rsaKey.getCrtCoefficient()</span>
                );
<span class="nc" id="L266">            } catch (RuntimeException e) {</span>
                // catch providers that incorrectly implement RSAPrivateCrtKey
<span class="nc" id="L268">                throw new InvalidKeyException(&quot;Invalid key&quot;, e);</span>
            }
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        } else if (key instanceof RSAPrivateKey) {</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">            if (key instanceof RSAPrivateKeyImpl) {</span>
<span class="nc" id="L272">                return key;</span>
            }
<span class="nc" id="L274">            RSAPrivateKey rsaKey = (RSAPrivateKey)key;</span>
            try {
<span class="nc" id="L276">                return new RSAPrivateKeyImpl(</span>
<span class="nc" id="L277">                    rsaKey.getModulus(),</span>
<span class="nc" id="L278">                    rsaKey.getPrivateExponent()</span>
                );
<span class="nc" id="L280">            } catch (RuntimeException e) {</span>
                // catch providers that incorrectly implement RSAPrivateKey
<span class="nc" id="L282">                throw new InvalidKeyException(&quot;Invalid key&quot;, e);</span>
            }
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        } else if (&quot;PKCS#8&quot;.equals(key.getFormat())) {</span>
<span class="nc" id="L285">            byte[] encoded = key.getEncoded();</span>
<span class="nc" id="L286">            return RSAPrivateCrtKeyImpl.newKey(encoded);</span>
        } else {
<span class="fc" id="L288">            throw new InvalidKeyException(&quot;Private keys must be instance &quot;</span>
                + &quot;of RSAPrivate(Crt)Key or have PKCS#8 encoding&quot;);
        }
    }

    // internal implementation of generatePublic. See JCA doc
    private PublicKey generatePublic(KeySpec keySpec)
            throws GeneralSecurityException {
<span class="fc bfc" id="L296" title="All 2 branches covered.">        if (keySpec instanceof X509EncodedKeySpec) {</span>
<span class="fc" id="L297">            X509EncodedKeySpec x509Spec = (X509EncodedKeySpec)keySpec;</span>
<span class="fc" id="L298">            return new RSAPublicKeyImpl(x509Spec.getEncoded());</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        } else if (keySpec instanceof RSAPublicKeySpec) {</span>
<span class="fc" id="L300">            RSAPublicKeySpec rsaSpec = (RSAPublicKeySpec)keySpec;</span>
<span class="fc" id="L301">            return new RSAPublicKeyImpl(</span>
<span class="fc" id="L302">                rsaSpec.getModulus(),</span>
<span class="fc" id="L303">                rsaSpec.getPublicExponent()</span>
            );
        } else {
<span class="nc" id="L306">            throw new InvalidKeySpecException(&quot;Only RSAPublicKeySpec &quot;</span>
                + &quot;and X509EncodedKeySpec supported for RSA public keys&quot;);
        }
    }

    // internal implementation of generatePrivate. See JCA doc
    private PrivateKey generatePrivate(KeySpec keySpec)
            throws GeneralSecurityException {
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (keySpec instanceof PKCS8EncodedKeySpec) {</span>
<span class="fc" id="L315">            PKCS8EncodedKeySpec pkcsSpec = (PKCS8EncodedKeySpec)keySpec;</span>
<span class="fc" id="L316">            return RSAPrivateCrtKeyImpl.newKey(pkcsSpec.getEncoded());</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        } else if (keySpec instanceof RSAPrivateCrtKeySpec) {</span>
<span class="fc" id="L318">            RSAPrivateCrtKeySpec rsaSpec = (RSAPrivateCrtKeySpec)keySpec;</span>
<span class="fc" id="L319">            return new RSAPrivateCrtKeyImpl(</span>
<span class="fc" id="L320">                rsaSpec.getModulus(),</span>
<span class="fc" id="L321">                rsaSpec.getPublicExponent(),</span>
<span class="fc" id="L322">                rsaSpec.getPrivateExponent(),</span>
<span class="fc" id="L323">                rsaSpec.getPrimeP(),</span>
<span class="fc" id="L324">                rsaSpec.getPrimeQ(),</span>
<span class="fc" id="L325">                rsaSpec.getPrimeExponentP(),</span>
<span class="fc" id="L326">                rsaSpec.getPrimeExponentQ(),</span>
<span class="fc" id="L327">                rsaSpec.getCrtCoefficient()</span>
            );
<span class="pc bpc" id="L329" title="1 of 2 branches missed.">        } else if (keySpec instanceof RSAPrivateKeySpec) {</span>
<span class="fc" id="L330">            RSAPrivateKeySpec rsaSpec = (RSAPrivateKeySpec)keySpec;</span>
<span class="fc" id="L331">            return new RSAPrivateKeyImpl(</span>
<span class="fc" id="L332">                rsaSpec.getModulus(),</span>
<span class="fc" id="L333">                rsaSpec.getPrivateExponent()</span>
            );
        } else {
<span class="nc" id="L336">            throw new InvalidKeySpecException(&quot;Only RSAPrivate(Crt)KeySpec &quot;</span>
                + &quot;and PKCS8EncodedKeySpec supported for RSA private keys&quot;);
        }
    }

    protected &lt;T extends KeySpec&gt; T engineGetKeySpec(Key key, Class&lt;T&gt; keySpec)
            throws InvalidKeySpecException {
        try {
            // convert key to one of our keys
            // this also verifies that the key is a valid RSA key and ensures
            // that the encoding is X.509/PKCS#8 for public/private keys
<span class="nc" id="L347">            key = engineTranslateKey(key);</span>
<span class="nc" id="L348">        } catch (InvalidKeyException e) {</span>
<span class="nc" id="L349">            throw new InvalidKeySpecException(e);</span>
<span class="nc" id="L350">        }</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">        if (key instanceof RSAPublicKey) {</span>
<span class="nc" id="L352">            RSAPublicKey rsaKey = (RSAPublicKey)key;</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">            if (rsaPublicKeySpecClass.isAssignableFrom(keySpec)) {</span>
<span class="nc" id="L354">                return keySpec.cast(new RSAPublicKeySpec(</span>
<span class="nc" id="L355">                    rsaKey.getModulus(),</span>
<span class="nc" id="L356">                    rsaKey.getPublicExponent()</span>
                ));
<span class="nc bnc" id="L358" title="All 2 branches missed.">            } else if (x509KeySpecClass.isAssignableFrom(keySpec)) {</span>
<span class="nc" id="L359">                return keySpec.cast(new X509EncodedKeySpec(key.getEncoded()));</span>
            } else {
<span class="nc" id="L361">                throw new InvalidKeySpecException</span>
                        (&quot;KeySpec must be RSAPublicKeySpec or &quot;
                        + &quot;X509EncodedKeySpec for RSA public keys&quot;);
            }
<span class="nc bnc" id="L365" title="All 2 branches missed.">        } else if (key instanceof RSAPrivateKey) {</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">            if (pkcs8KeySpecClass.isAssignableFrom(keySpec)) {</span>
<span class="nc" id="L367">                return keySpec.cast(new PKCS8EncodedKeySpec(key.getEncoded()));</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">            } else if (rsaPrivateCrtKeySpecClass.isAssignableFrom(keySpec)) {</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                if (key instanceof RSAPrivateCrtKey) {</span>
<span class="nc" id="L370">                    RSAPrivateCrtKey crtKey = (RSAPrivateCrtKey)key;</span>
<span class="nc" id="L371">                    return keySpec.cast(new RSAPrivateCrtKeySpec(</span>
<span class="nc" id="L372">                        crtKey.getModulus(),</span>
<span class="nc" id="L373">                        crtKey.getPublicExponent(),</span>
<span class="nc" id="L374">                        crtKey.getPrivateExponent(),</span>
<span class="nc" id="L375">                        crtKey.getPrimeP(),</span>
<span class="nc" id="L376">                        crtKey.getPrimeQ(),</span>
<span class="nc" id="L377">                        crtKey.getPrimeExponentP(),</span>
<span class="nc" id="L378">                        crtKey.getPrimeExponentQ(),</span>
<span class="nc" id="L379">                        crtKey.getCrtCoefficient()</span>
                    ));
                } else {
<span class="nc" id="L382">                    throw new InvalidKeySpecException</span>
                    (&quot;RSAPrivateCrtKeySpec can only be used with CRT keys&quot;);
                }
<span class="nc bnc" id="L385" title="All 2 branches missed.">            } else if (rsaPrivateKeySpecClass.isAssignableFrom(keySpec)) {</span>
<span class="nc" id="L386">                RSAPrivateKey rsaKey = (RSAPrivateKey)key;</span>
<span class="nc" id="L387">                return keySpec.cast(new RSAPrivateKeySpec(</span>
<span class="nc" id="L388">                    rsaKey.getModulus(),</span>
<span class="nc" id="L389">                    rsaKey.getPrivateExponent()</span>
                ));
            } else {
<span class="nc" id="L392">                throw new InvalidKeySpecException</span>
                        (&quot;KeySpec must be RSAPrivate(Crt)KeySpec or &quot;
                        + &quot;PKCS8EncodedKeySpec for RSA private keys&quot;);
            }
        } else {
            // should not occur, caught in engineTranslateKey()
<span class="nc" id="L398">            throw new InvalidKeySpecException(&quot;Neither public nor private key&quot;);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>