<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>LayoutPathImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.font</a> &gt; <span class="el_source">LayoutPathImpl.java</span></div><h1>LayoutPathImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 * (C) Copyright IBM Corp. 2005, All Rights Reserved.
 */
package sun.font;

//
// This is the 'simple' mapping implementation.  It does things the most
// straightforward way even if that is a bit slow.  It won't
// handle complex paths efficiently, and doesn't handle closed paths.
//

import java.awt.Shape;
import java.awt.font.LayoutPath;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.util.Formatter;
import java.util.ArrayList;

import static java.awt.geom.PathIterator.*;
import static java.lang.Math.abs;
import static java.lang.Math.sqrt;

<span class="nc" id="L50">public abstract class LayoutPathImpl extends LayoutPath {</span>

    //
    // Convenience APIs
    //

    public Point2D pointToPath(double x, double y) {
<span class="nc" id="L57">        Point2D.Double pt = new Point2D.Double(x, y);</span>
<span class="nc" id="L58">        pointToPath(pt, pt);</span>
<span class="nc" id="L59">        return pt;</span>
    }

    public Point2D pathToPoint(double a, double o, boolean preceding) {
<span class="nc" id="L63">        Point2D.Double pt = new Point2D.Double(a, o);</span>
<span class="nc" id="L64">        pathToPoint(pt, preceding, pt);</span>
<span class="nc" id="L65">        return pt;</span>
    }

    public void pointToPath(double x, double y, Point2D pt) {
<span class="nc" id="L69">        pt.setLocation(x, y);</span>
<span class="nc" id="L70">        pointToPath(pt, pt);</span>
<span class="nc" id="L71">    }</span>

    public void pathToPoint(double a, double o, boolean preceding, Point2D pt) {
<span class="nc" id="L74">        pt.setLocation(a, o);</span>
<span class="nc" id="L75">        pathToPoint(pt, preceding, pt);</span>
<span class="nc" id="L76">    }</span>

    //
    // extra utility APIs
    //

    public abstract double start();
    public abstract double end();
    public abstract double length();
    public abstract Shape mapShape(Shape s);

    //
    // debugging flags
    //

    private static final boolean LOGMAP = false;
<span class="nc" id="L92">    private static final Formatter LOG = new Formatter(System.out);</span>

    /**
     * Indicate how positions past the start and limit of the
     * path are treated.  PINNED adjusts these positions so
     * as to be within start and limit.  EXTENDED ignores the
     * start and limit and effectively extends the first and
     * last segments of the path 'infinitely'.  CLOSED wraps
     * positions around the ends of the path.
     */
<span class="nc" id="L102">    public static enum EndType {</span>
<span class="nc" id="L103">        PINNED, EXTENDED, CLOSED;</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        public boolean isPinned() { return this == PINNED; }</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">        public boolean isExtended() { return this == EXTENDED; }</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">        public boolean isClosed() { return this == CLOSED; }</span>
    };

    //
    // Top level construction.
    //

    /**
     * Return a path representing the path from the origin through the points in order.
     */
    public static LayoutPathImpl getPath(EndType etype, double ... coords) {
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if ((coords.length &amp; 0x1) != 0) {</span>
<span class="nc" id="L118">            throw new IllegalArgumentException(&quot;odd number of points not allowed&quot;);</span>
        }

<span class="nc" id="L121">        return SegmentPath.get(etype, coords);</span>
    }

    /**
     * Use to build a SegmentPath.  This takes the data and preanalyzes it for
     * information that the SegmentPath needs, then constructs a SegmentPath
     * from that.  Mainly, this lets SegmentPath cache the lengths along
     * the path to each line segment, and so avoid calculating them over and over.
     */
<span class="nc bnc" id="L130" title="All 2 branches missed.">    public static final class SegmentPathBuilder {</span>
        private double[] data;
        private int w;
        private double px;
        private double py;
        private double a;
        private boolean pconnect;

        /**
         * Construct a SegmentPathBuilder.
         */
<span class="nc" id="L141">        public SegmentPathBuilder() {</span>
<span class="nc" id="L142">        }</span>

        /**
         * Reset the builder for a new path.  Datalen is a hint of how many
         * points will be in the path, and the working buffer will be sized
         * to accommodate at least this number of points.  If datalen is zero,
         * the working buffer is freed (it will be allocated on first use).
         */
        public void reset(int datalen) {
<span class="nc bnc" id="L151" title="All 4 branches missed.">            if (data == null || datalen &gt; data.length) {</span>
<span class="nc" id="L152">                data = new double[datalen];</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            } else if (datalen == 0) {</span>
<span class="nc" id="L154">                data = null;</span>
            }
<span class="nc" id="L156">            w = 0;</span>
<span class="nc" id="L157">            px = py = 0;</span>
<span class="nc" id="L158">            pconnect = false;</span>
<span class="nc" id="L159">        }</span>

        /**
         * Automatically build from a list of points represented by pairs of
         * doubles.  Initial advance is zero.
         */
        public SegmentPath build(EndType etype, double... pts) {
<span class="nc bnc" id="L166" title="All 4 branches missed.">            assert(pts.length % 2 == 0);</span>

<span class="nc" id="L168">            reset(pts.length / 2 * 3);</span>

<span class="nc bnc" id="L170" title="All 2 branches missed.">            for (int i = 0; i &lt; pts.length; i += 2) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                nextPoint(pts[i], pts[i+1], i != 0);</span>
            }

<span class="nc" id="L174">            return complete(etype);</span>
        }

        /**
         * Move to a new point.  If there is no data, this will become the
         * first point.  If there is data, and the previous call was a lineTo, this
         * point is checked against the previous point, and if different, this
         * starts a new segment at the same advance as the end of the last
         * segment.  If there is data, and the previous call was a moveTo, this
         * replaces the point used for that previous call.
         *
         * Calling this is optional, lineTo will suffice and the initial point
         * will be set to 0, 0.
         */
        public void moveTo(double x, double y) {
<span class="nc" id="L189">            nextPoint(x, y, false);</span>
<span class="nc" id="L190">        }</span>

        /**
         * Connect to a new point.  If there is no data, the previous point
         * is presumed to be 0, 0.  This point is checked against
         * the previous point, and if different, this point is added to
         * the path and the advance extended.  If this point is the same as the
         * previous point, the path remains unchanged.
         */
        public void lineTo(double x, double y) {
<span class="nc" id="L200">            nextPoint(x, y, true);</span>
<span class="nc" id="L201">        }</span>

        /**
         * Add a new point, and increment advance if connect is true.
         *
         * This automatically rejects duplicate points and multiple disconnected points.
         */
        private void nextPoint(double x, double y, boolean connect) {

            // if zero length move or line, ignore
<span class="nc bnc" id="L211" title="All 4 branches missed.">            if (x == px &amp;&amp; y == py) {</span>
<span class="nc" id="L212">                return;</span>
            }

<span class="nc bnc" id="L215" title="All 2 branches missed.">            if (w == 0) { // this is the first point, make sure we have space</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                if (data == null) {</span>
<span class="nc" id="L217">                    data = new double[6];</span>
                }
<span class="nc bnc" id="L219" title="All 2 branches missed.">                if (connect) {</span>
<span class="nc" id="L220">                    w = 3; // default first point to 0, 0</span>
                }
            }

            // if multiple disconnected move, just update position, leave advance alone
<span class="nc bnc" id="L225" title="All 6 branches missed.">            if (w != 0 &amp;&amp; !connect &amp;&amp; !pconnect) {</span>
<span class="nc" id="L226">                data[w-3] = px = x;</span>
<span class="nc" id="L227">                data[w-2] = py = y;</span>
<span class="nc" id="L228">                return;</span>
            }

            // grow data to deal with new point
<span class="nc bnc" id="L232" title="All 2 branches missed.">            if (w == data.length) {</span>
<span class="nc" id="L233">                double[] t = new double[w * 2];</span>
<span class="nc" id="L234">                System.arraycopy(data, 0, t, 0, w);</span>
<span class="nc" id="L235">                data = t;</span>
            }

<span class="nc bnc" id="L238" title="All 2 branches missed.">            if (connect) {</span>
<span class="nc" id="L239">                double dx = x - px;</span>
<span class="nc" id="L240">                double dy = y - py;</span>
<span class="nc" id="L241">                a += sqrt(dx * dx + dy * dy);</span>
            }

            // update data
<span class="nc" id="L245">            data[w++] = x;</span>
<span class="nc" id="L246">            data[w++] = y;</span>
<span class="nc" id="L247">            data[w++] = a;</span>

            // update state
<span class="nc" id="L250">            px = x;</span>
<span class="nc" id="L251">            py = y;</span>
<span class="nc" id="L252">            pconnect = connect;</span>
<span class="nc" id="L253">        }</span>

        public SegmentPath complete() {
<span class="nc" id="L256">            return complete(EndType.EXTENDED);</span>
        }

        /**
         * Complete building a SegmentPath.  Once this is called, the builder is restored
         * to its initial state and information about the previous path is released.  The
         * end type indicates whether to treat the path as closed, extended, or pinned.
         */
        public SegmentPath complete(EndType etype) {
            SegmentPath result;

<span class="nc bnc" id="L267" title="All 4 branches missed.">            if (data == null || w &lt; 6) {</span>
<span class="nc" id="L268">                return null;</span>
            }

<span class="nc bnc" id="L271" title="All 2 branches missed.">            if (w == data.length) {</span>
<span class="nc" id="L272">                result = new SegmentPath(data, etype);</span>
<span class="nc" id="L273">                reset(0); // releases pointer to data</span>
            } else {
<span class="nc" id="L275">                double[] dataToAdopt = new double[w];</span>
<span class="nc" id="L276">                System.arraycopy(data, 0, dataToAdopt, 0, w);</span>
<span class="nc" id="L277">                result = new SegmentPath(dataToAdopt, etype);</span>
<span class="nc" id="L278">                reset(2); // reuses data, since we held on to it</span>
            }

<span class="nc" id="L281">            return result;</span>
        }
    }

    /**
     * Represents a path built from segments.  Each segment is
     * represented by a triple: x, y, and cumulative advance.
     * These represent the end point of the segment.  The start
     * point of the first segment is represented by the triple
     * at position 0.
     *
     * The path might have breaks in it, e.g. it is not connected.
     * These will be represented by pairs of triplets that share the
     * same advance.
     *
     * The path might be extended, pinned, or closed.  If extended,
     * the initial and final segments are considered to extend
     * 'indefinitely' past the bounds of the advance.  If pinned,
     * they end at the bounds of the advance.  If closed,
     * advances before the start or after the end 'wrap around' the
     * path.
     *
     * The start of the path is the initial triple.  This provides
     * the nominal advance at the given x, y position (typically
     * zero).  The end of the path is the final triple.  This provides
     * the advance at the end, the total length of the path is
     * thus the ending advance minus the starting advance.
     *
     * Note: We might want to cache more auxiliary data than the
     * advance, but this seems adequate for now.
     */
    public static final class SegmentPath extends LayoutPathImpl {
        private double[] data; // triplets x, y, a
        EndType etype;

        public static SegmentPath get(EndType etype, double... pts) {
<span class="nc" id="L317">            return new SegmentPathBuilder().build(etype, pts);</span>
        }

        /**
         * Internal, use SegmentPathBuilder or one of the static
         * helper functions to construct a SegmentPath.
         */
<span class="nc" id="L324">        SegmentPath(double[] data, EndType etype) {</span>
<span class="nc" id="L325">            this.data = data;</span>
<span class="nc" id="L326">            this.etype = etype;</span>
<span class="nc" id="L327">        }</span>

        //
        // LayoutPath API
        //

        public void pathToPoint(Point2D location, boolean preceding, Point2D point) {
<span class="nc" id="L334">            locateAndGetIndex(location, preceding, point);</span>
<span class="nc" id="L335">        }</span>

        // the path consists of line segments, which i'll call
        // 'path vectors'.  call each run of path vectors a 'path segment'.
        // no path vector in a path segment is zero length (in the
        // data, such vectors start a new path segment).
        //
        // for each path segment...
        //
        // for each path vector...
        //
        // we look at the dot product of the path vector and the vector from the
        // origin of the path vector to the test point.  if &lt;0 (case
        // A), the projection of the test point is before the start of
        // the path vector.  if &gt; the square of the length of the path vector
        // (case B), the projection is past the end point of the
        // path vector.  otherwise (case C), it lies on the path vector.
        // determine the closeset point on the path vector.  if case A, it
        // is the start of the path vector.  if case B and this is the last
        // path vector in the path segment, it is the end of the path vector.  If
        // case C, it is the projection onto the path vector.  Otherwise
        // there is no closest point.
        //
        // if we have a closest point, compare the distance from it to
        // the test point against our current closest distance.
        // (culling should be fast, currently i am using distance
        // squared, but there's probably better ways).  if we're
        // closer, save the new point as the current closest point,
        // and record the path vector index so we can determine the final
        // info if this turns out to be the closest point in the end.
        //
        // after we have processed all the segments we will have
        // tested each path vector and each endpoint.  if our point is not on
        // an endpoint, we're done; we can compute the position and
        // offset again, or if we saved it off we can just use it.  if
        // we're on an endpoint we need to see which path vector we should
        // associate with.  if we're at the start or end of a path segment,
        // we're done-- the first or last vector of the segment is the
        // one we associate with.  we project against that vector to
        // get the offset, and pin to that vector to get the length.
        //
        // otherwise, we compute the information as follows.  if the
        // dot product (see above) with the following vector is zero,
        // we associate with that vector.  otherwise, if the dot
        // product with the previous vector is zero, we associate with
        // that vector.  otherwise we're beyond the end of the
        // previous vector and before the start of the current vector.
        // we project against both vectors and get the distance from
        // the test point to the projection (this will be the offset).
        // if they are the same, we take the following vector.
        // otherwise use the vector from which the test point is the
        // _farthest_ (this is because the point lies most clearly in
        // the half of the plane defined by extending that vector).
        //
        // the returned position is the path length to the (possibly
        // pinned) point, the offset is the projection onto the line
        // along the vector, and we have a boolean flag which if false
        // indicates that we associate with the previous vector at a
        // junction (which is necessary when projecting such a
        // location back to a point).

        public boolean pointToPath(Point2D pt, Point2D result) {
<span class="nc" id="L397">            double x = pt.getX();               // test point</span>
<span class="nc" id="L398">            double y = pt.getY();</span>

<span class="nc" id="L400">            double bx = data[0];                // previous point</span>
<span class="nc" id="L401">            double by = data[1];</span>
<span class="nc" id="L402">            double bl = data[2];</span>

            // start with defaults
<span class="nc" id="L405">            double cd2 = Double.MAX_VALUE;       // current best distance from path, squared</span>
<span class="nc" id="L406">            double cx = 0;                       // current best x</span>
<span class="nc" id="L407">            double cy = 0;                       // current best y</span>
<span class="nc" id="L408">            double cl = 0;                       // current best position along path</span>
<span class="nc" id="L409">            int ci = 0;                          // current best index into data</span>

<span class="nc bnc" id="L411" title="All 2 branches missed.">            for (int i = 3; i &lt; data.length; i += 3) {</span>
<span class="nc" id="L412">                double nx = data[i];             // current end point</span>
<span class="nc" id="L413">                double ny = data[i+1];</span>
<span class="nc" id="L414">                double nl = data[i+2];</span>

<span class="nc" id="L416">                double dx = nx - bx;             // vector from previous to current</span>
<span class="nc" id="L417">                double dy = ny - by;</span>
<span class="nc" id="L418">                double dl = nl - bl;</span>

<span class="nc" id="L420">                double px = x - bx;              // vector from previous to test point</span>
<span class="nc" id="L421">                double py = y - by;</span>

                // determine sign of dot product of vectors from bx, by
                // if &lt; 0, we're before the start of this vector

<span class="nc" id="L426">                double dot = dx * px + dy * py;      // dot product</span>
                double vcx, vcy, vcl;                // hold closest point on vector as x, y, l
                int vi;                              // hold index of line, is data.length if last point on path
                do {                                 // use break below, lets us avoid initializing vcx, vcy...
<span class="nc bnc" id="L430" title="All 4 branches missed.">                    if (dl == 0 ||                   // moveto, or</span>
                        (dot &lt; 0 &amp;&amp;                  // before path vector and
<span class="nc bnc" id="L432" title="All 4 branches missed.">                         (!etype.isExtended() ||</span>
                          i != 3))) {                // closest point is start of vector
<span class="nc" id="L434">                        vcx = bx;</span>
<span class="nc" id="L435">                        vcy = by;</span>
<span class="nc" id="L436">                        vcl = bl;</span>
<span class="nc" id="L437">                        vi = i;</span>
                    } else {
<span class="nc" id="L439">                        double l2 = dl * dl;         // aka dx * dx + dy * dy, square of length</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">                        if (dot &lt;= l2 ||             // closest point is not past end of vector, or</span>
<span class="nc bnc" id="L441" title="All 4 branches missed.">                            (etype.isExtended() &amp;&amp;   // we're extended and at the last segment</span>
                             i == data.length - 3)) {
<span class="nc" id="L443">                            double p = dot / l2;     // get parametric along segment</span>
<span class="nc" id="L444">                            vcx = bx + p * dx;       // compute closest point</span>
<span class="nc" id="L445">                            vcy = by + p * dy;</span>
<span class="nc" id="L446">                            vcl = bl + p * dl;</span>
<span class="nc" id="L447">                            vi = i;</span>
<span class="nc" id="L448">                        } else {</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">                            if (i == data.length - 3) {</span>
<span class="nc" id="L450">                                vcx = nx;            // special case, always test last point</span>
<span class="nc" id="L451">                                vcy = ny;</span>
<span class="nc" id="L452">                                vcl = nl;</span>
<span class="nc" id="L453">                                vi = data.length;</span>
                            } else {
                                break;               // typical case, skip point, we'll pick it up next iteration
                            }
                        }
                    }

<span class="nc" id="L460">                    double tdx = x - vcx;        // compute distance from (usually pinned) projection to test point</span>
<span class="nc" id="L461">                    double tdy = y - vcy;</span>
<span class="nc" id="L462">                    double td2 = tdx * tdx + tdy * tdy;</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                    if (td2 &lt;= cd2) {            // new closest point, record info on it</span>
<span class="nc" id="L464">                        cd2 = td2;</span>
<span class="nc" id="L465">                        cx = vcx;</span>
<span class="nc" id="L466">                        cy = vcy;</span>
<span class="nc" id="L467">                        cl = vcl;</span>
<span class="nc" id="L468">                        ci = vi;</span>
                    }
                } while (false);

<span class="nc" id="L472">                bx = nx;</span>
<span class="nc" id="L473">                by = ny;</span>
<span class="nc" id="L474">                bl = nl;</span>
            }

            // we have our closest point, get the info
<span class="nc" id="L478">            bx = data[ci-3];</span>
<span class="nc" id="L479">            by = data[ci-2];</span>
<span class="nc bnc" id="L480" title="All 4 branches missed.">            if (cx != bx || cy != by) {     // not on endpoint, no need to resolve</span>
<span class="nc" id="L481">                double nx = data[ci];</span>
<span class="nc" id="L482">                double ny = data[ci+1];</span>
<span class="nc" id="L483">                double co = sqrt(cd2);     // have a true perpendicular, so can use distance</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if ((x-cx)*(ny-by) &gt; (y-cy)*(nx-bx)) {</span>
<span class="nc" id="L485">                    co = -co;              // determine sign of offset</span>
                }
<span class="nc" id="L487">                result.setLocation(cl, co);</span>
<span class="nc" id="L488">                return false;</span>
            } else {                        // on endpoint, we need to resolve which segment
<span class="nc bnc" id="L490" title="All 4 branches missed.">                boolean havePrev = ci != 3 &amp;&amp; data[ci-1] != data[ci-4];</span>
<span class="nc bnc" id="L491" title="All 4 branches missed.">                boolean haveFoll = ci != data.length &amp;&amp; data[ci-1] != data[ci+2];</span>
<span class="nc bnc" id="L492" title="All 6 branches missed.">                boolean doExtend = etype.isExtended() &amp;&amp; (ci == 3 || ci == data.length);</span>
<span class="nc bnc" id="L493" title="All 4 branches missed.">                if (havePrev &amp;&amp; haveFoll) {</span>
<span class="nc" id="L494">                    Point2D.Double pp = new Point2D.Double(x, y);</span>
<span class="nc" id="L495">                    calcoffset(ci - 3, doExtend, pp);</span>
<span class="nc" id="L496">                    Point2D.Double fp = new Point2D.Double(x, y);</span>
<span class="nc" id="L497">                    calcoffset(ci, doExtend, fp);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                    if (abs(pp.y) &gt; abs(fp.y)) {</span>
<span class="nc" id="L499">                        result.setLocation(pp);</span>
<span class="nc" id="L500">                        return true; // associate with previous</span>
                    } else {
<span class="nc" id="L502">                        result.setLocation(fp);</span>
<span class="nc" id="L503">                        return false; // associate with following</span>
                    }
<span class="nc bnc" id="L505" title="All 2 branches missed.">                } else if (havePrev) {</span>
<span class="nc" id="L506">                    result.setLocation(x, y);</span>
<span class="nc" id="L507">                    calcoffset(ci - 3, doExtend, result);</span>
<span class="nc" id="L508">                    return true;</span>
                } else {
<span class="nc" id="L510">                    result.setLocation(x, y);</span>
<span class="nc" id="L511">                    calcoffset(ci, doExtend, result);</span>
<span class="nc" id="L512">                    return false;</span>
                }
            }
        }

        /**
         * Return the location of the point passed in result as mapped to the
         * line indicated by index.  If doExtend is true, extend the
         * x value without pinning to the ends of the line.
         * this assumes that index is valid and references a line that has
         * non-zero length.
         */
        private void calcoffset(int index, boolean doExtend, Point2D result) {
<span class="nc" id="L525">            double bx = data[index-3];</span>
<span class="nc" id="L526">            double by = data[index-2];</span>
<span class="nc" id="L527">            double px = result.getX() - bx;</span>
<span class="nc" id="L528">            double py = result.getY() - by;</span>
<span class="nc" id="L529">            double dx = data[index] - bx;</span>
<span class="nc" id="L530">            double dy = data[index+1] - by;</span>
<span class="nc" id="L531">            double l = data[index+2] - data[index - 1];</span>

            // rx = A dot B / |B|
            // ry = A dot invB / |B|
<span class="nc" id="L535">            double rx = (px * dx + py * dy) / l;</span>
<span class="nc" id="L536">            double ry = (px * -dy + py * dx) / l;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">            if (!doExtend) {</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">                if (rx &lt; 0) rx = 0;</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                else if (rx &gt; l) rx = l;</span>
            }
<span class="nc" id="L541">            rx += data[index-1];</span>
<span class="nc" id="L542">            result.setLocation(rx, ry);</span>
<span class="nc" id="L543">        }</span>

        //
        // LayoutPathImpl API
        //

        public Shape mapShape(Shape s) {
<span class="nc" id="L550">            return new Mapper().mapShape(s);</span>
        }

        public double start() {
<span class="nc" id="L554">            return data[2];</span>
        }

        public double end() {
<span class="nc" id="L558">            return data[data.length - 1];</span>
        }

        public double length() {
<span class="nc" id="L562">            return data[data.length-1] - data[2];</span>
        }

        //
        // Utilities
        //

        /**
         * Get the 'modulus' of an advance on a closed path.
         */
        private double getClosedAdvance(double a, boolean preceding) {
<span class="nc bnc" id="L573" title="All 2 branches missed.">            if (etype.isClosed()) {</span>
<span class="nc" id="L574">                a -= data[2];</span>
<span class="nc" id="L575">                int count = (int)(a/length());</span>
<span class="nc" id="L576">                a -= count * length();</span>
<span class="nc bnc" id="L577" title="All 6 branches missed.">                if (a &lt; 0 || (a == 0 &amp;&amp; preceding)) {</span>
<span class="nc" id="L578">                    a += length();</span>

                }
<span class="nc" id="L581">                a += data[2];</span>
            }
<span class="nc" id="L583">            return a;</span>
        }

        /**
         * Return the index of the segment associated with advance. This
         * points to the start of the triple and is a multiple of 3 between
         * 3 and data.length-3 inclusive.  It never points to a 'moveto' triple.
         *
         * If the path is closed, 'a' is mapped to
         * a value between the start and end of the path, inclusive.
         * If preceding is true, and 'a' lies on a segment boundary,
         * return the index of the preceding segment, else return the index
         * of the current segment (if it is not a moveto segment) otherwise
         * the following segment (which is never a moveto segment).
         *
         * Note: if the path is not closed, the advance might not actually
         * lie on the returned segment-- it might be before the first, or
         * after the last.  The first or last segment (as appropriate)
         * will be returned in this case.
         */
        private int getSegmentIndexForAdvance(double a, boolean preceding) {
            // must have local advance
<span class="nc" id="L605">            a = getClosedAdvance(a, preceding);</span>

            // note we must avoid 'moveto' segments.  the first segment is
            // always a moveto segment, so we always skip it.
            int i, lim;
<span class="nc bnc" id="L610" title="All 2 branches missed.">            for (i = 5, lim = data.length-1; i &lt; lim; i += 3) {</span>
<span class="nc" id="L611">                double v = data[i];</span>
<span class="nc bnc" id="L612" title="All 6 branches missed.">                if (a &lt; v || (a == v &amp;&amp; preceding)) {</span>
<span class="nc" id="L613">                    break;</span>
                }
            }
<span class="nc" id="L616">            return i-2; // adjust to start of segment</span>
        }

        /**
         * Map a location based on the provided segment, returning in pt.
         * Seg must be a valid 'lineto' segment.  Note: if the path is
         * closed, x must be within the start and end of the path.
         */
        private void map(int seg, double a, double o, Point2D pt) {
<span class="nc" id="L625">            double dx = data[seg] - data[seg-3];</span>
<span class="nc" id="L626">            double dy = data[seg+1] - data[seg-2];</span>
<span class="nc" id="L627">            double dl = data[seg+2] - data[seg-1];</span>

<span class="nc" id="L629">            double ux = dx/dl; // could cache these, but is it worth it?</span>
<span class="nc" id="L630">            double uy = dy/dl;</span>

<span class="nc" id="L632">            a -= data[seg-1];</span>

<span class="nc" id="L634">            pt.setLocation(data[seg-3] + a * ux - o * uy,</span>
                           data[seg-2] + a * uy + o * ux);
<span class="nc" id="L636">        }</span>

        /**
         * Map the point, and return the segment index.
         */
        private int locateAndGetIndex(Point2D loc, boolean preceding, Point2D result) {
<span class="nc" id="L642">            double a = loc.getX();</span>
<span class="nc" id="L643">            double o = loc.getY();</span>
<span class="nc" id="L644">            int seg = getSegmentIndexForAdvance(a, preceding);</span>
<span class="nc" id="L645">            map(seg, a, o, result);</span>

<span class="nc" id="L647">            return seg;</span>
        }

        //
        // Mapping classes.
        // Map the path onto each path segment.
        // Record points where the advance 'enters' and 'exits' the path segment, and connect successive
        // points when appropriate.
        //

        /**
         * This represents a line segment from the iterator.  Each target segment will
         * interpret it, and since this process needs slope along the line
         * segment, this lets us compute it once and pass it around easily.
         */
<span class="nc" id="L662">        class LineInfo {</span>
            double sx, sy; // start
            double lx, ly; // limit
            double m;      // slope dy/dx

            /**
             * Set the lineinfo to this line
             */
            void set(double sx, double sy, double lx, double ly) {
<span class="nc" id="L671">                this.sx = sx;</span>
<span class="nc" id="L672">                this.sy = sy;</span>
<span class="nc" id="L673">                this.lx = lx;</span>
<span class="nc" id="L674">                this.ly = ly;</span>
<span class="nc" id="L675">                double dx = lx - sx;</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">                if (dx == 0) {</span>
<span class="nc" id="L677">                    m = 0; // we'll check for this elsewhere</span>
                } else {
<span class="nc" id="L679">                    double dy = ly - sy;</span>
<span class="nc" id="L680">                    m = dy / dx;</span>
                }
<span class="nc" id="L682">            }</span>

            void set(LineInfo rhs) {
<span class="nc" id="L685">                this.sx = rhs.sx;</span>
<span class="nc" id="L686">                this.sy = rhs.sy;</span>
<span class="nc" id="L687">                this.lx = rhs.lx;</span>
<span class="nc" id="L688">                this.ly = rhs.ly;</span>
<span class="nc" id="L689">                this.m  = rhs.m;</span>
<span class="nc" id="L690">            }</span>

            /**
             * Return true if we intersect the infinitely tall rectangle with
             * lo &lt;= x &lt; hi.  If we do, also return the pinned portion of ourselves in
             * result.
             */
            boolean pin(double lo, double hi, LineInfo result) {
<span class="nc" id="L698">                result.set(this);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">                if (lx &gt;= sx) {</span>
<span class="nc bnc" id="L700" title="All 4 branches missed.">                    if (sx &lt; hi &amp;&amp; lx &gt;= lo) {</span>
<span class="nc bnc" id="L701" title="All 2 branches missed.">                        if (sx &lt; lo) {</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                            if (m != 0) result.sy = sy + m * (lo - sx);</span>
<span class="nc" id="L703">                            result.sx = lo;</span>
                        }
<span class="nc bnc" id="L705" title="All 2 branches missed.">                        if (lx &gt; hi) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">                            if (m != 0) result.ly = ly + m * (hi - lx);</span>
<span class="nc" id="L707">                            result.lx = hi;</span>
                        }
<span class="nc" id="L709">                        return true;</span>
                    }
                } else {
<span class="nc bnc" id="L712" title="All 4 branches missed.">                    if (lx &lt; hi &amp;&amp; sx &gt;= lo) {</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">                        if (lx &lt; lo) {</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">                            if (m != 0) result.ly = ly + m * (lo - lx);</span>
<span class="nc" id="L715">                            result.lx = lo;</span>
                        }
<span class="nc bnc" id="L717" title="All 2 branches missed.">                        if (sx &gt; hi) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">                            if (m != 0) result.sy = sy + m * (hi - sx);</span>
<span class="nc" id="L719">                            result.sx = hi;</span>
                        }
<span class="nc" id="L721">                        return true;</span>
                    }
                }
<span class="nc" id="L724">                return false;</span>
            }

            /**
             * Return true if we intersect the segment at ix.  This takes
             * the path end type into account and computes the relevant
             * parameters to pass to pin(double, double, LineInfo).
             */
            boolean pin(int ix, LineInfo result) {
<span class="nc" id="L733">                double lo = data[ix-1];</span>
<span class="nc" id="L734">                double hi = data[ix+2];</span>
<span class="nc bnc" id="L735" title="All 3 branches missed.">                switch (SegmentPath.this.etype) {</span>
                case PINNED:
<span class="nc" id="L737">                    break;</span>
                case EXTENDED:
<span class="nc bnc" id="L739" title="All 2 branches missed.">                    if (ix == 3) lo = Double.NEGATIVE_INFINITY;</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">                    if (ix == data.length - 3) hi = Double.POSITIVE_INFINITY;</span>
                    break;
                case CLOSED:
                    // not implemented
                    break;
                }

<span class="nc" id="L747">                return pin(lo, hi, result);</span>
            }
        }

        /**
         * Each segment will construct its own general path, mapping the provided lines
         * into its own simple space.
         */
        class Segment {
            final int ix;        // index into data array for this segment
            final double ux, uy; // unit vector

            final LineInfo temp; // working line info

            boolean broken;      // true if a moveto has occurred since we last added to our path
            double cx, cy;       // last point in gp
            GeneralPath gp;      // path built for this segment

<span class="nc" id="L765">            Segment(int ix) {</span>
<span class="nc" id="L766">                this.ix = ix;</span>
<span class="nc" id="L767">                double len = data[ix+2] - data[ix-1];</span>
<span class="nc" id="L768">                this.ux = (data[ix] - data[ix-3]) / len;</span>
<span class="nc" id="L769">                this.uy = (data[ix+1] - data[ix-2]) / len;</span>
<span class="nc" id="L770">                this.temp = new LineInfo();</span>
<span class="nc" id="L771">            }</span>

            void init() {
                if (LOGMAP) LOG.format(&quot;s(%d) init\n&quot;, ix);
<span class="nc" id="L775">                broken = true;</span>
<span class="nc" id="L776">                cx = cy = Double.MIN_VALUE;</span>
<span class="nc" id="L777">                this.gp = new GeneralPath();</span>
<span class="nc" id="L778">            }</span>

            void move() {
                if (LOGMAP) LOG.format(&quot;s(%d) move\n&quot;, ix);
<span class="nc" id="L782">                broken = true;</span>
<span class="nc" id="L783">            }</span>

            void close() {
<span class="nc bnc" id="L786" title="All 2 branches missed.">                if (!broken) {</span>
                    if (LOGMAP) LOG.format(&quot;s(%d) close\n[cp]\n&quot;, ix);
<span class="nc" id="L788">                    gp.closePath();</span>
                }
<span class="nc" id="L790">            }</span>

            void line(LineInfo li) {
                if (LOGMAP) LOG.format(&quot;s(%d) line %g, %g to %g, %g\n&quot;, ix, li.sx, li.sy, li.lx, li.ly);

<span class="nc bnc" id="L795" title="All 2 branches missed.">                if (li.pin(ix, temp)) {</span>
                    if (LOGMAP) LOG.format(&quot;pin: %g, %g to %g, %g\n&quot;, temp.sx, temp.sy, temp.lx, temp.ly);

<span class="nc" id="L798">                    temp.sx -= data[ix-1];</span>
<span class="nc" id="L799">                    double sx = data[ix-3] + temp.sx * ux - temp.sy * uy;</span>
<span class="nc" id="L800">                    double sy = data[ix-2] + temp.sx * uy + temp.sy * ux;</span>
<span class="nc" id="L801">                    temp.lx -= data[ix-1];</span>
<span class="nc" id="L802">                    double lx = data[ix-3] + temp.lx * ux - temp.ly * uy;</span>
<span class="nc" id="L803">                    double ly = data[ix-2] + temp.lx * uy + temp.ly * ux;</span>

                    if (LOGMAP) LOG.format(&quot;points: %g, %g to %g, %g\n&quot;, sx, sy, lx, ly);

<span class="nc bnc" id="L807" title="All 4 branches missed.">                    if (sx != cx || sy != cy) {</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">                        if (broken) {</span>
                            if (LOGMAP) LOG.format(&quot;[mt %g, %g]\n&quot;, sx, sy);
<span class="nc" id="L810">                            gp.moveTo((float)sx, (float)sy);</span>
                        } else {
                            if (LOGMAP) LOG.format(&quot;[lt %g, %g]\n&quot;, sx, sy);
<span class="nc" id="L813">                            gp.lineTo((float)sx, (float)sy);</span>
                        }
                    }
                    if (LOGMAP) LOG.format(&quot;[lt %g, %g]\n&quot;, lx, ly);
<span class="nc" id="L817">                    gp.lineTo((float)lx, (float)ly);</span>

<span class="nc" id="L819">                    broken = false;</span>
<span class="nc" id="L820">                    cx = lx;</span>
<span class="nc" id="L821">                    cy = ly;</span>
                }
<span class="nc" id="L823">            }</span>
        }

        class Mapper {
            final LineInfo li;                 // working line info
            final ArrayList&lt;Segment&gt; segments; // cache additional data on segments, working objects
            final Point2D.Double mpt;          // last moveto source point
            final Point2D.Double cpt;          // current source point
            boolean haveMT;                    // true when last op was a moveto

<span class="nc" id="L833">            Mapper() {</span>
<span class="nc" id="L834">                li = new LineInfo();</span>
<span class="nc" id="L835">                segments = new ArrayList&lt;Segment&gt;();</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                for (int i = 3; i &lt; data.length; i += 3) {</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">                    if (data[i+2] != data[i-1]) { // a new segment</span>
<span class="nc" id="L838">                        segments.add(new Segment(i));</span>
                    }
                }

<span class="nc" id="L842">                mpt = new Point2D.Double();</span>
<span class="nc" id="L843">                cpt = new Point2D.Double();</span>
<span class="nc" id="L844">            }</span>

            void init() {
                if (LOGMAP) LOG.format(&quot;init\n&quot;);
<span class="nc" id="L848">                haveMT = false;</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">                for (Segment s: segments) {</span>
<span class="nc" id="L850">                    s.init();</span>
<span class="nc" id="L851">                }</span>
<span class="nc" id="L852">            }</span>

            void moveTo(double x, double y) {
                if (LOGMAP) LOG.format(&quot;moveto %g, %g\n&quot;, x, y);
<span class="nc" id="L856">                mpt.x = x;</span>
<span class="nc" id="L857">                mpt.y = y;</span>
<span class="nc" id="L858">                haveMT = true;</span>
<span class="nc" id="L859">            }</span>

            void lineTo(double x, double y) {
                if (LOGMAP) LOG.format(&quot;lineto %g, %g\n&quot;, x, y);

<span class="nc bnc" id="L864" title="All 2 branches missed.">                if (haveMT) {</span>
                    // prepare previous point for no-op check
<span class="nc" id="L866">                    cpt.x = mpt.x;</span>
<span class="nc" id="L867">                    cpt.y = mpt.y;</span>
                }

<span class="nc bnc" id="L870" title="All 4 branches missed.">                if (x == cpt.x &amp;&amp; y == cpt.y) {</span>
                    // lineto is a no-op
<span class="nc" id="L872">                    return;</span>
                }

<span class="nc bnc" id="L875" title="All 2 branches missed.">                if (haveMT) {</span>
                    // current point is the most recent moveto point
<span class="nc" id="L877">                    haveMT = false;</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">                    for (Segment s: segments) {</span>
<span class="nc" id="L879">                        s.move();</span>
<span class="nc" id="L880">                    }</span>
                }

<span class="nc" id="L883">                li.set(cpt.x, cpt.y, x, y);</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                for (Segment s: segments) {</span>
<span class="nc" id="L885">                    s.line(li);</span>
<span class="nc" id="L886">                }</span>

<span class="nc" id="L888">                cpt.x = x;</span>
<span class="nc" id="L889">                cpt.y = y;</span>
<span class="nc" id="L890">            }</span>

            void close() {
                if (LOGMAP) LOG.format(&quot;close\n&quot;);
<span class="nc" id="L894">                lineTo(mpt.x, mpt.y);</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">                for (Segment s: segments) {</span>
<span class="nc" id="L896">                    s.close();</span>
<span class="nc" id="L897">                }</span>
<span class="nc" id="L898">            }</span>

            public Shape mapShape(Shape s) {
                if (LOGMAP) LOG.format(&quot;mapshape on path: %s\n&quot;, LayoutPathImpl.SegmentPath.this);
<span class="nc" id="L902">                PathIterator pi = s.getPathIterator(null, 1); // cheap way to handle curves.</span>

                if (LOGMAP) LOG.format(&quot;start\n&quot;);
<span class="nc" id="L905">                init();</span>

<span class="nc" id="L907">                final double[] coords = new double[2];</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">                while (!pi.isDone()) {</span>
<span class="nc bnc" id="L909" title="All 4 branches missed.">                    switch (pi.currentSegment(coords)) {</span>
<span class="nc" id="L910">                    case SEG_CLOSE: close(); break;</span>
<span class="nc" id="L911">                    case SEG_MOVETO: moveTo(coords[0], coords[1]); break;</span>
<span class="nc" id="L912">                    case SEG_LINETO: lineTo(coords[0], coords[1]); break;</span>
                    default: break;
                    }

<span class="nc" id="L916">                    pi.next();</span>
                }
                if (LOGMAP) LOG.format(&quot;finish\n\n&quot;);

<span class="nc" id="L920">                GeneralPath gp = new GeneralPath();</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">                for (Segment seg: segments) {</span>
<span class="nc" id="L922">                    gp.append(seg.gp, false);</span>
<span class="nc" id="L923">                }</span>
<span class="nc" id="L924">                return gp;</span>
            }
        }

        //
        // for debugging
        //

        public String toString() {
<span class="nc" id="L933">            StringBuilder b = new StringBuilder();</span>
<span class="nc" id="L934">            b.append(&quot;{&quot;);</span>
<span class="nc" id="L935">            b.append(etype.toString());</span>
<span class="nc" id="L936">            b.append(&quot; &quot;);</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">            for (int i = 0; i &lt; data.length; i += 3) {</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">                if (i &gt; 0) {</span>
<span class="nc" id="L939">                    b.append(&quot;,&quot;);</span>
                }
<span class="nc" id="L941">                float x = ((int)(data[i] * 100))/100.0f;</span>
<span class="nc" id="L942">                float y = ((int)(data[i+1] * 100))/100.0f;</span>
<span class="nc" id="L943">                float l = ((int)(data[i+2] * 10))/10.0f;</span>
<span class="nc" id="L944">                b.append(&quot;{&quot;);</span>
<span class="nc" id="L945">                b.append(x);</span>
<span class="nc" id="L946">                b.append(&quot;,&quot;);</span>
<span class="nc" id="L947">                b.append(y);</span>
<span class="nc" id="L948">                b.append(&quot;,&quot;);</span>
<span class="nc" id="L949">                b.append(l);</span>
<span class="nc" id="L950">                b.append(&quot;}&quot;);</span>
            }
<span class="nc" id="L952">            b.append(&quot;}&quot;);</span>
<span class="nc" id="L953">            return b.toString();</span>
        }
    }


<span class="nc" id="L958">    public static class EmptyPath extends LayoutPathImpl {</span>
        private AffineTransform tx;

<span class="nc" id="L961">        public EmptyPath(AffineTransform tx) {</span>
<span class="nc" id="L962">            this.tx = tx;</span>
<span class="nc" id="L963">        }</span>

        public void pathToPoint(Point2D location, boolean preceding, Point2D point) {
<span class="nc bnc" id="L966" title="All 2 branches missed.">            if (tx != null) {</span>
<span class="nc" id="L967">                tx.transform(location, point);</span>
            } else {
<span class="nc" id="L969">                point.setLocation(location);</span>
            }
<span class="nc" id="L971">        }</span>

        public boolean pointToPath(Point2D pt, Point2D result) {
<span class="nc" id="L974">            result.setLocation(pt);</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">            if (tx != null) {</span>
                try {
<span class="nc" id="L977">                    tx.inverseTransform(pt, result);</span>
                }
<span class="nc" id="L979">                catch (NoninvertibleTransformException ex) {</span>
<span class="nc" id="L980">                }</span>
            }
<span class="nc bnc" id="L982" title="All 2 branches missed.">            return result.getX() &gt; 0;</span>
        }

<span class="nc" id="L985">        public double start() { return 0; }</span>

<span class="nc" id="L987">        public double end() { return 0; }</span>

<span class="nc" id="L989">        public double length() { return 0; }</span>

        public Shape mapShape(Shape s) {
<span class="nc bnc" id="L992" title="All 2 branches missed.">            if (tx != null) {</span>
<span class="nc" id="L993">                return tx.createTransformedShape(s);</span>
            }
<span class="nc" id="L995">            return s;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>