<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Font2D.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.font</a> &gt; <span class="el_source">Font2D.java</span></div><h1>Font2D.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.font;

import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.geom.AffineTransform;
import java.lang.ref.Reference;
import java.lang.ref.SoftReference;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Locale;

<span class="nc" id="L36">public abstract class Font2D {</span>

    /* Note: JRE and FONT_CONFIG ranks are identical. I don't know of a reason
     * to distingish these. Possibly if a user adds fonts to the JRE font
     * directory that are the same font as the ones specified in the font
     * configuration but that is more likely to be the legitimate intention
     * than a problem. One reason why these should be the same is that on
     * Linux the JRE fonts ARE the font configuration fonts, and although I
     * believe all are assigned FONT_CONFIG rank, it is conceivable that if
     * this were not so, that some JRE font would not be allowed to joint the
     * family of its siblings which were assigned FONT_CONFIG rank. Giving
     * them the same rank is the easy solution for now at least.
     */
    public static final int FONT_CONFIG_RANK   = 2;
    public static final int JRE_RANK     = 2;
    public static final int TTF_RANK     = 3;
    public static final int TYPE1_RANK   = 4;
    public static final int NATIVE_RANK  = 5;
    public static final int UNKNOWN_RANK = 6;
    public static final int DEFAULT_RANK = 4;

<span class="nc" id="L57">    private static final String[] boldNames = {</span>
        &quot;bold&quot;, &quot;demibold&quot;, &quot;demi-bold&quot;, &quot;demi bold&quot;, &quot;negreta&quot;, &quot;demi&quot;, };

<span class="nc" id="L60">    private static final String[] italicNames = {</span>
        &quot;italic&quot;, &quot;cursiva&quot;, &quot;oblique&quot;, &quot;inclined&quot;, };

<span class="nc" id="L63">    private static final String[] boldItalicNames = {</span>
          &quot;bolditalic&quot;, &quot;bold-italic&quot;, &quot;bold italic&quot;,
          &quot;boldoblique&quot;, &quot;bold-oblique&quot;, &quot;bold oblique&quot;,
          &quot;demibold italic&quot;, &quot;negreta cursiva&quot;,&quot;demi oblique&quot;, };

<span class="nc" id="L68">    private static final FontRenderContext DEFAULT_FRC =</span>
        new FontRenderContext(null, false, false);

    public Font2DHandle handle;
    protected String familyName;           /* Family font name (english) */
    protected String fullName;             /* Full font name (english)   */
<span class="nc" id="L74">    protected int style = Font.PLAIN;</span>
    protected FontFamily family;
<span class="nc" id="L76">    protected int fontRank = DEFAULT_RANK;</span>

    /*
     * A mapper can be independent of the strike.
     * Perhaps the reference to the mapper ought to be held on the
     * scaler, as it may be implemented via scaler functionality anyway
     * and so the mapper would be useless if its native portion was
     * freed when the scaler was GC'd.
     */
    protected CharToGlyphMapper mapper;

    /*
     * The strike cache is maintained per &quot;Font2D&quot; as that is the
     * principal object by which you look up fonts.
     * It means more Hashmaps, but look ups can be quicker because
     * the map will have fewer entries, and there's no need to try to
     * make the Font2D part of the key.
     */
<span class="nc" id="L94">    protected ConcurrentHashMap&lt;FontStrikeDesc, Reference&gt;</span>
        strikeCache = new ConcurrentHashMap&lt;FontStrikeDesc, Reference&gt;();

    /* Store the last Strike in a Reference object.
     * Similarly to the strike that was stored on a C++ font object,
     * this is an optimisation which helps if multiple clients (ie
     * typically SunGraphics2D instances) are using the same font, then
     * as may be typical of many UIs, they are probably using it in the
     * same style, so it can be a win to first quickly check if the last
     * strike obtained from this Font2D satifies the needs of the next
     * client too.
     * This pre-supposes that a FontStrike is a shareable object, which
     * it should.
     */
<span class="nc" id="L108">    protected Reference lastFontStrike = new SoftReference(null);</span>

    /*
     * POSSIBLE OPTIMISATION:
     * Array of length 1024 elements of 64 bits indicating if a font
     * contains these. This kind of information can be shared between
     * all point sizes.
     * if corresponding bit in knownBitmaskMap is set then canDisplayBitmaskMap
     * is valid. This is 16Kbytes of data per composite font style.
     * What about UTF-32 and surrogates?
     * REMIND: This is too much storage. Probably can only cache this
     * information for latin range, although possibly OK to store all
     * for just the &quot;logical&quot; fonts.
     * Or instead store arrays of subranges of 1024 bits (128 bytes) in
     * the range below surrogate pairs.
     */
//     protected long[] knownBitmaskMap;
//     protected long[] canDisplayBitmaskMap;

    /* Returns the &quot;real&quot; style of this Font2D. Eg the font face
     * Lucida Sans Bold&quot; has a real style of Font.BOLD, even though
     * it may be able to used to simulate bold italic
     */
    public int getStyle() {
<span class="nc" id="L132">        return style;</span>
    }
    protected void setStyle() {

<span class="nc" id="L136">        String fName = fullName.toLowerCase();</span>

<span class="nc bnc" id="L138" title="All 2 branches missed.">        for (int i=0; i &lt; boldItalicNames.length; i++) {</span>
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (fName.indexOf(boldItalicNames[i]) != -1) {</span>
<span class="nc" id="L140">                style = Font.BOLD|Font.ITALIC;</span>
<span class="nc" id="L141">                return;</span>
            }
        }

<span class="nc bnc" id="L145" title="All 2 branches missed.">        for (int i=0; i &lt; italicNames.length; i++) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">            if (fName.indexOf(italicNames[i]) != -1) {</span>
<span class="nc" id="L147">                style = Font.ITALIC;</span>
<span class="nc" id="L148">                return;</span>
            }
        }

<span class="nc bnc" id="L152" title="All 2 branches missed.">        for (int i=0; i &lt; boldNames.length; i++) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">            if (fName.indexOf(boldNames[i]) != -1 ) {</span>
<span class="nc" id="L154">                style = Font.BOLD;</span>
<span class="nc" id="L155">                return;</span>
            }
        }
<span class="nc" id="L158">    }</span>


    int getRank() {
<span class="nc" id="L162">        return fontRank;</span>
    }

    void setRank(int rank) {
<span class="nc" id="L166">        fontRank = rank;</span>
<span class="nc" id="L167">    }</span>

    abstract CharToGlyphMapper getMapper();



    /* This isn't very efficient but its infrequently used.
     * StandardGlyphVector uses it when the client assigns the glyph codes.
     * These may not be valid. This validates them substituting the missing
     * glyph elsewhere.
     */
    protected int getValidatedGlyphCode(int glyphCode) {
<span class="nc bnc" id="L179" title="All 4 branches missed.">        if (glyphCode &lt; 0 || glyphCode &gt;= getMapper().getNumGlyphs()) {</span>
<span class="nc" id="L180">            glyphCode = getMapper().getMissingGlyphCode();</span>
        }
<span class="nc" id="L182">        return glyphCode;</span>
    }

    /*
     * Creates an appropriate strike for the Font2D subclass
     */
    abstract FontStrike createStrike(FontStrikeDesc desc);

    /* this may be useful for APIs like canDisplay where the answer
     * is dependent on the font and its scaler, but not the strike.
     * If no strike has ever been returned, then create a one that matches
     * this font with the default FRC. It will become the lastStrike and
     * there's a good chance that the next call will be to get exactly that
     * strike.
     */
    public FontStrike getStrike(Font font) {
<span class="nc" id="L198">        FontStrike strike = (FontStrike)lastFontStrike.get();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (strike != null) {</span>
<span class="nc" id="L200">            return strike;</span>
        } else {
<span class="nc" id="L202">            return getStrike(font, DEFAULT_FRC);</span>
        }
    }

    /* SunGraphics2D has font, tx, aa and fm. From this info
     * can get a Strike object from the cache, creating it if necessary.
     * This code is designed for multi-threaded access.
     * For that reason it creates a local FontStrikeDesc rather than filling
     * in a shared one. Up to two AffineTransforms and one FontStrikeDesc will
     * be created by every lookup. This appears to perform more than
     * adequately. But it may make sense to expose FontStrikeDesc
     * as a parameter so a caller can use its own.
     * In such a case if a FontStrikeDesc is stored as a key then
     * we would need to use a private copy.
     *
     * Note that this code doesn't prevent two threads from creating
     * two different FontStrike instances and having one of the threads
     * overwrite the other in the map. This is likely to be a rare
     * occurrence and the only consequence is that these callers will have
     * different instances of the strike, and there'd be some duplication of
     * population of the strikes. However since users of these strikes are
     * transient, then the one that was overwritten would soon be freed.
     * If there is any problem then a small synchronized block would be
     * required with its attendant consequences for MP scaleability.
     */
    public FontStrike getStrike(Font font, AffineTransform devTx,
                                int aa, int fm) {

        /* Create the descriptor which is used to identify a strike
         * in the strike cache/map. A strike is fully described by
         * the attributes of this descriptor.
         */
        /* REMIND: generating garbage and doing computation here in order
         * to include pt size in the tx just for a lookup! Figure out a
         * better way.
         */
<span class="nc" id="L238">        double ptSize = font.getSize2D();</span>
<span class="nc" id="L239">        AffineTransform glyphTx = (AffineTransform)devTx.clone();</span>
<span class="nc" id="L240">        glyphTx.scale(ptSize, ptSize);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (font.isTransformed()) {</span>
<span class="nc" id="L242">            glyphTx.concatenate(font.getTransform());</span>
        }
<span class="nc bnc" id="L244" title="All 4 branches missed.">        if (glyphTx.getTranslateX() != 0 || glyphTx.getTranslateY() != 0) {</span>
<span class="nc" id="L245">            glyphTx.setTransform(glyphTx.getScaleX(),</span>
<span class="nc" id="L246">                                 glyphTx.getShearY(),</span>
<span class="nc" id="L247">                                 glyphTx.getShearX(),</span>
<span class="nc" id="L248">                                 glyphTx.getScaleY(),</span>
                                 0.0, 0.0);
        }
<span class="nc" id="L251">        FontStrikeDesc desc = new FontStrikeDesc(devTx, glyphTx,</span>
<span class="nc" id="L252">                                                 font.getStyle(), aa, fm);</span>
<span class="nc" id="L253">        return getStrike(desc, false);</span>
    }

    public FontStrike getStrike(Font font, AffineTransform devTx,
                                AffineTransform glyphTx,
                                int aa, int fm) {

        /* Create the descriptor which is used to identify a strike
         * in the strike cache/map. A strike is fully described by
         * the attributes of this descriptor.
         */
<span class="nc" id="L264">        FontStrikeDesc desc = new FontStrikeDesc(devTx, glyphTx,</span>
<span class="nc" id="L265">                                                 font.getStyle(), aa, fm);</span>
<span class="nc" id="L266">        return getStrike(desc, false);</span>
    }

    public FontStrike getStrike(Font font, FontRenderContext frc) {

<span class="nc" id="L271">        AffineTransform at = frc.getTransform();</span>
<span class="nc" id="L272">        double ptSize = font.getSize2D();</span>
<span class="nc" id="L273">        at.scale(ptSize, ptSize);</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (font.isTransformed()) {</span>
<span class="nc" id="L275">            at.concatenate(font.getTransform());</span>
<span class="nc bnc" id="L276" title="All 4 branches missed.">            if (at.getTranslateX() != 0 || at.getTranslateY() != 0) {</span>
<span class="nc" id="L277">                at.setTransform(at.getScaleX(),</span>
<span class="nc" id="L278">                                at.getShearY(),</span>
<span class="nc" id="L279">                                at.getShearX(),</span>
<span class="nc" id="L280">                                at.getScaleY(),</span>
                                0.0, 0.0);
            }
        }
<span class="nc" id="L284">        int aa = FontStrikeDesc.getAAHintIntVal(this, font, frc);</span>
<span class="nc" id="L285">        int fm = FontStrikeDesc.getFMHintIntVal(frc.getFractionalMetricsHint());</span>
<span class="nc" id="L286">        FontStrikeDesc desc = new FontStrikeDesc(frc.getTransform(),</span>
<span class="nc" id="L287">                                                 at, font.getStyle(),</span>
                                                 aa, fm);
<span class="nc" id="L289">        return getStrike(desc, false);</span>
    }

    FontStrike getStrike(FontStrikeDesc desc) {
<span class="nc" id="L293">        return getStrike(desc, true);</span>
    }

    private FontStrike getStrike(FontStrikeDesc desc, boolean copy) {
        /* Before looking in the map, see if the descriptor matches the
         * last strike returned from this Font2D. This should often be a win
         * since its common for the same font, in the same size to be
         * used frequently, for example in many parts of a UI.
         *
         * If its not the same then we use the descriptor to locate a
         * Reference to the strike. If it exists and points to a strike,
         * then we update the last strike to refer to that and return it.
         *
         * If the key isn't in the map, or its reference object has been
         * collected, then we create a new strike, put it in the map and
         * set it to be the last strike.
         */
<span class="nc" id="L310">        FontStrike strike = (FontStrike)lastFontStrike.get();</span>
<span class="nc bnc" id="L311" title="All 4 branches missed.">        if (strike != null &amp;&amp; desc.equals(strike.desc)) {</span>
            //strike.lastlookupTime = System.currentTimeMillis();
<span class="nc" id="L313">            return strike;</span>
        } else {
<span class="nc" id="L315">            Reference strikeRef = strikeCache.get(desc);</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">            if (strikeRef != null) {</span>
<span class="nc" id="L317">                strike = (FontStrike)strikeRef.get();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                if (strike != null) {</span>
                    //strike.lastlookupTime = System.currentTimeMillis();
<span class="nc" id="L320">                    lastFontStrike = new SoftReference(strike);</span>
<span class="nc" id="L321">                    StrikeCache.refStrike(strike);</span>
<span class="nc" id="L322">                    return strike;</span>
                }
            }
            /* When we create a new FontStrike instance, we *must*
             * ask the StrikeCache for a reference. We must then ensure
             * this reference remains reachable, by storing it in the
             * Font2D's strikeCache map.
             * So long as the Reference is there (reachable) then if the
             * reference is cleared, it will be enqueued for disposal.
             * If for some reason we explicitly remove this reference, it
             * must only be done when holding a strong reference to the
             * referent (the FontStrike), or if the reference is cleared,
             * then we must explicitly &quot;dispose&quot; of the native resources.
             * The only place this currently happens is in this same method,
             * where we find a cleared reference and need to overwrite it
             * here with a new reference.
             * Clearing the whilst holding a strong reference, should only
             * be done if the
             */
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (copy) {</span>
<span class="nc" id="L342">                desc = new FontStrikeDesc(desc);</span>
            }
<span class="nc" id="L344">            strike = createStrike(desc);</span>
            //StrikeCache.addStrike();
            /* If we are creating many strikes on this font which
             * involve non-quadrant rotations, or more general
             * transforms which include shears, then force the use
             * of weak references rather than soft references.
             * This means that it won't live much beyond the next GC,
             * which is what we want for what is likely a transient strike.
             */
<span class="nc" id="L353">            int txType = desc.glyphTx.getType();</span>
<span class="nc bnc" id="L354" title="All 4 branches missed.">            if (txType == AffineTransform.TYPE_GENERAL_TRANSFORM ||</span>
                (txType &amp; AffineTransform.TYPE_GENERAL_ROTATION) != 0 &amp;&amp;
<span class="nc bnc" id="L356" title="All 2 branches missed.">                strikeCache.size() &gt; 10) {</span>
<span class="nc" id="L357">                strikeRef = StrikeCache.getStrikeRef(strike, true);</span>
            } else {
<span class="nc" id="L359">                strikeRef = StrikeCache.getStrikeRef(strike);</span>
            }
<span class="nc" id="L361">            strikeCache.put(desc, strikeRef);</span>
            //strike.lastlookupTime = System.currentTimeMillis();
<span class="nc" id="L363">            lastFontStrike = new SoftReference(strike);</span>
<span class="nc" id="L364">            StrikeCache.refStrike(strike);</span>
<span class="nc" id="L365">            return strike;</span>
        }
    }

    void removeFromCache(FontStrikeDesc desc) {
<span class="nc" id="L370">        Reference ref = strikeCache.get(desc);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (ref != null) {</span>
<span class="nc" id="L372">            Object o = ref.get();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            if (o == null) {</span>
<span class="nc" id="L374">                strikeCache.remove(desc);</span>
            }
        }
<span class="nc" id="L377">    }</span>

    /**
     * The length of the metrics array must be &gt;= 8.  This method will
     * store the following elements in that array before returning:
     *    metrics[0]: ascent
     *    metrics[1]: descent
     *    metrics[2]: leading
     *    metrics[3]: max advance
     *    metrics[4]: strikethrough offset
     *    metrics[5]: strikethrough thickness
     *    metrics[6]: underline offset
     *    metrics[7]: underline thickness
     */
    public void getFontMetrics(Font font, AffineTransform at,
                               Object aaHint, Object fmHint,
                               float metrics[]) {
        /* This is called in just one place in Font with &quot;at&quot; == identity.
         * Perhaps this can be eliminated.
         */
<span class="nc" id="L397">        int aa = FontStrikeDesc.getAAHintIntVal(aaHint, this, font.getSize());</span>
<span class="nc" id="L398">        int fm = FontStrikeDesc.getFMHintIntVal(fmHint);</span>
<span class="nc" id="L399">        FontStrike strike = getStrike(font, at, aa, fm);</span>
<span class="nc" id="L400">        StrikeMetrics strikeMetrics = strike.getFontMetrics();</span>
<span class="nc" id="L401">        metrics[0] = strikeMetrics.getAscent();</span>
<span class="nc" id="L402">        metrics[1] = strikeMetrics.getDescent();</span>
<span class="nc" id="L403">        metrics[2] = strikeMetrics.getLeading();</span>
<span class="nc" id="L404">        metrics[3] = strikeMetrics.getMaxAdvance();</span>

<span class="nc" id="L406">        getStyleMetrics(font.getSize2D(), metrics, 4);</span>
<span class="nc" id="L407">    }</span>

    /**
     * The length of the metrics array must be &gt;= offset+4, and offset must be
     * &gt;= 0.  Typically offset is 4.  This method will
     * store the following elements in that array before returning:
     *    metrics[off+0]: strikethrough offset
     *    metrics[off+1]: strikethrough thickness
     *    metrics[off+2]: underline offset
     *    metrics[off+3]: underline thickness
     *
     * Note that this implementation simply returns default values;
     * subclasses can override this method to provide more accurate values.
     */
    public void getStyleMetrics(float pointSize, float[] metrics, int offset) {
<span class="nc" id="L422">        metrics[offset] = -metrics[0] / 2.5f;</span>
<span class="nc" id="L423">        metrics[offset+1] = pointSize / 12;</span>
<span class="nc" id="L424">        metrics[offset+2] = metrics[offset+1] / 1.5f;</span>
<span class="nc" id="L425">        metrics[offset+3] = metrics[offset+1];</span>
<span class="nc" id="L426">    }</span>

    /**
     * The length of the metrics array must be &gt;= 4.  This method will
     * store the following elements in that array before returning:
     *    metrics[0]: ascent
     *    metrics[1]: descent
     *    metrics[2]: leading
     *    metrics[3]: max advance
     */
    public void getFontMetrics(Font font, FontRenderContext frc,
                               float metrics[]) {
<span class="nc" id="L438">        StrikeMetrics strikeMetrics = getStrike(font, frc).getFontMetrics();</span>
<span class="nc" id="L439">        metrics[0] = strikeMetrics.getAscent();</span>
<span class="nc" id="L440">        metrics[1] = strikeMetrics.getDescent();</span>
<span class="nc" id="L441">        metrics[2] = strikeMetrics.getLeading();</span>
<span class="nc" id="L442">        metrics[3] = strikeMetrics.getMaxAdvance();</span>
<span class="nc" id="L443">    }</span>

    /* Currently the layout code calls this. May be better for layout code
     * to check the font class before attempting to run, rather than needing
     * to promote this method up from TrueTypeFont
     */
    byte[] getTableBytes(int tag) {
<span class="nc" id="L450">        return null;</span>
    }

    /* for layout code */
    protected long getUnitsPerEm() {
<span class="nc" id="L455">        return 2048;</span>
    }

    boolean supportsEncoding(String encoding) {
<span class="nc" id="L459">        return false;</span>
    }

    public boolean canDoStyle(int style) {
<span class="nc bnc" id="L463" title="All 2 branches missed.">        return (style == this.style);</span>
    }

    /*
     * All the important subclasses override this which is principally for
     * the TrueType 'gasp' table.
     */
    public boolean useAAForPtSize(int ptsize) {
<span class="nc" id="L471">        return true;</span>
    }

    public boolean hasSupplementaryChars() {
<span class="nc" id="L475">        return false;</span>
    }

    /* The following methods implement public methods on java.awt.Font */
    public String getPostscriptName() {
<span class="nc" id="L480">        return fullName;</span>
    }

    public String getFontName(Locale l) {
<span class="nc" id="L484">        return fullName;</span>
    }

    public String getFamilyName(Locale l) {
<span class="nc" id="L488">        return familyName;</span>
    }

    public int getNumGlyphs() {
<span class="nc" id="L492">        return getMapper().getNumGlyphs();</span>
    }

    public int charToGlyph(int wchar) {
<span class="nc" id="L496">        return getMapper().charToGlyph(wchar);</span>
    }

    public int getMissingGlyphCode() {
<span class="nc" id="L500">        return getMapper().getMissingGlyphCode();</span>
    }

    public boolean canDisplay(char c) {
<span class="nc" id="L504">        return getMapper().canDisplay(c);</span>
    }

    public boolean canDisplay(int cp) {
<span class="nc" id="L508">        return getMapper().canDisplay(cp);</span>
    }

    public byte getBaselineFor(char c) {
<span class="nc" id="L512">        return Font.ROMAN_BASELINE;</span>
    }

    public float getItalicAngle(Font font, AffineTransform at,
                                Object aaHint, Object fmHint) {
        /* hardwire psz=12 as that's typical and AA vs non-AA for 'gasp' mode
         * isn't important for the caret slope of this rarely used API.
         */
<span class="nc" id="L520">        int aa = FontStrikeDesc.getAAHintIntVal(aaHint, this, 12);</span>
<span class="nc" id="L521">        int fm = FontStrikeDesc.getFMHintIntVal(fmHint);</span>
<span class="nc" id="L522">        FontStrike strike = getStrike(font, at, aa, fm);</span>
<span class="nc" id="L523">        StrikeMetrics metrics = strike.getFontMetrics();</span>
<span class="nc bnc" id="L524" title="All 4 branches missed.">        if (metrics.ascentY == 0 || metrics.ascentX == 0) {</span>
<span class="nc" id="L525">            return 0f;</span>
        } else {
            /* ascent is &quot;up&quot; from the baseline so its typically
             * a negative value, so we need to compensate
             */
<span class="nc" id="L530">            return metrics.ascentX/-metrics.ascentY;</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>