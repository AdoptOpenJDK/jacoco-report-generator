<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SunFontManager.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.font</a> &gt; <span class="el_source">SunFontManager.java</span></div><h1>SunFontManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.font;

import java.awt.Font;
import java.awt.FontFormatException;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;

import javax.swing.plaf.FontUIResource;
import sun.awt.AppContext;
import sun.awt.FontConfiguration;
import sun.awt.SunToolkit;
import sun.java2d.FontSupport;
import sun.util.logging.PlatformLogger;

/**
 * The base implementation of the {@link FontManager} interface. It implements
 * the platform independent, shared parts of OpenJDK's FontManager
 * implementations. The platform specific parts are declared as abstract
 * methods that have to be implemented by specific implementations.
 */
public abstract class SunFontManager implements FontSupport, FontManagerForSGE {

<span class="nc" id="L66">    private static class TTFilter implements FilenameFilter {</span>
        public boolean accept(File dir,String name) {
            /* all conveniently have the same suffix length */
<span class="nc" id="L69">            int offset = name.length()-4;</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">            if (offset &lt;= 0) { /* must be at least A.ttf */</span>
<span class="nc" id="L71">                return false;</span>
            } else {
<span class="nc bnc" id="L73" title="All 2 branches missed.">                return(name.startsWith(&quot;.ttf&quot;, offset) ||</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">                       name.startsWith(&quot;.TTF&quot;, offset) ||</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">                       name.startsWith(&quot;.ttc&quot;, offset) ||</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">                       name.startsWith(&quot;.TTC&quot;, offset) ||</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">                       name.startsWith(&quot;.otf&quot;, offset) ||</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">                       name.startsWith(&quot;.OTF&quot;, offset));</span>
            }
        }
    }

<span class="nc" id="L83">    private static class T1Filter implements FilenameFilter {</span>
        public boolean accept(File dir,String name) {
<span class="nc bnc" id="L85" title="All 2 branches missed.">            if (noType1Font) {</span>
<span class="nc" id="L86">                return false;</span>
            }
            /* all conveniently have the same suffix length */
<span class="nc" id="L89">            int offset = name.length()-4;</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">            if (offset &lt;= 0) { /* must be at least A.pfa */</span>
<span class="nc" id="L91">                return false;</span>
            } else {
<span class="nc bnc" id="L93" title="All 2 branches missed.">                return(name.startsWith(&quot;.pfa&quot;, offset) ||</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">                       name.startsWith(&quot;.pfb&quot;, offset) ||</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">                       name.startsWith(&quot;.PFA&quot;, offset) ||</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                       name.startsWith(&quot;.PFB&quot;, offset));</span>
            }
        }
    }

<span class="nc" id="L101">     private static class TTorT1Filter implements FilenameFilter {</span>
        public boolean accept(File dir, String name) {

            /* all conveniently have the same suffix length */
<span class="nc" id="L105">            int offset = name.length()-4;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">            if (offset &lt;= 0) { /* must be at least A.ttf or A.pfa */</span>
<span class="nc" id="L107">                return false;</span>
            } else {
<span class="nc" id="L109">                boolean isTT =</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">                    name.startsWith(&quot;.ttf&quot;, offset) ||</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">                    name.startsWith(&quot;.TTF&quot;, offset) ||</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">                    name.startsWith(&quot;.ttc&quot;, offset) ||</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">                    name.startsWith(&quot;.TTC&quot;, offset) ||</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">                    name.startsWith(&quot;.otf&quot;, offset) ||</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">                    name.startsWith(&quot;.OTF&quot;, offset);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">                if (isTT) {</span>
<span class="nc" id="L117">                    return true;</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">                } else if (noType1Font) {</span>
<span class="nc" id="L119">                    return false;</span>
                } else {
<span class="nc bnc" id="L121" title="All 2 branches missed.">                    return(name.startsWith(&quot;.pfa&quot;, offset) ||</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">                           name.startsWith(&quot;.pfb&quot;, offset) ||</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">                           name.startsWith(&quot;.PFA&quot;, offset) ||</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">                           name.startsWith(&quot;.PFB&quot;, offset));</span>
                }
            }
        }
    }

     public static final int FONTFORMAT_NONE = -1;
     public static final int FONTFORMAT_TRUETYPE = 0;
     public static final int FONTFORMAT_TYPE1 = 1;
     public static final int FONTFORMAT_T2K = 2;
     public static final int FONTFORMAT_TTC = 3;
     public static final int FONTFORMAT_COMPOSITE = 4;
     public static final int FONTFORMAT_NATIVE = 5;

     /* Pool of 20 font file channels chosen because some UTF-8 locale
      * composite fonts can use up to 16 platform fonts (including the
      * Lucida fall back). This should prevent channel thrashing when
      * dealing with one of these fonts.
      * The pool array stores the fonts, rather than directly referencing
      * the channels, as the font needs to do the open/close work.
      */
     // MACOSX begin -- need to access these in subclass
     protected static final int CHANNELPOOLSIZE = 20;
<span class="nc" id="L147">     protected FileFont fontFileCache[] = new FileFont[CHANNELPOOLSIZE];</span>
     // MACOSX end
<span class="nc" id="L149">     private int lastPoolIndex = 0;</span>

    /* Need to implement a simple linked list scheme for fast
     * traversal and lookup.
     * Also want to &quot;fast path&quot; dialog so there's minimal overhead.
     */
    /* There are at exactly 20 composite fonts: 5 faces (but some are not
     * usually different), in 4 styles. The array may be auto-expanded
     * later if more are needed, eg for user-defined composites or locale
     * variants.
     */
<span class="nc" id="L160">    private int maxCompFont = 0;</span>
<span class="nc" id="L161">    private CompositeFont [] compFonts = new CompositeFont[20];</span>
<span class="nc" id="L162">    private ConcurrentHashMap&lt;String, CompositeFont&gt;</span>
        compositeFonts = new ConcurrentHashMap&lt;String, CompositeFont&gt;();
<span class="nc" id="L164">    private ConcurrentHashMap&lt;String, PhysicalFont&gt;</span>
        physicalFonts = new ConcurrentHashMap&lt;String, PhysicalFont&gt;();
<span class="nc" id="L166">    private ConcurrentHashMap&lt;String, PhysicalFont&gt;</span>
        registeredFonts = new ConcurrentHashMap&lt;String, PhysicalFont&gt;();

    /* given a full name find the Font. Remind: there's duplication
     * here in that this contains the content of compositeFonts +
     * physicalFonts.
     */
    // MACOSX begin -- need to access this in subclass
<span class="nc" id="L174">    protected ConcurrentHashMap&lt;String, Font2D&gt;</span>
        fullNameToFont = new ConcurrentHashMap&lt;String, Font2D&gt;();
    // MACOSX end

    /* TrueType fonts have localised names. Support searching all
     * of these before giving up on a name.
     */
    private HashMap&lt;String, TrueTypeFont&gt; localeFullNamesToFont;

    private PhysicalFont defaultPhysicalFont;

    static boolean longAddresses;
<span class="nc" id="L186">    private boolean loaded1dot0Fonts = false;</span>
<span class="nc" id="L187">    boolean loadedAllFonts = false;</span>
<span class="nc" id="L188">    boolean loadedAllFontFiles = false;</span>
    HashMap&lt;String,String&gt; jreFontMap;
    HashSet&lt;String&gt; jreLucidaFontFiles;
    String[] jreOtherFontFiles;
<span class="nc" id="L192">    boolean noOtherJREFontFiles = false; // initial assumption.</span>

    public static final String lucidaFontName = &quot;Lucida Sans Regular&quot;;
    public static String jreLibDirName;
    public static String jreFontDirName;
<span class="nc" id="L197">    private static HashSet&lt;String&gt; missingFontFiles = null;</span>
    private String defaultFontName;
    private String defaultFontFileName;
<span class="nc" id="L200">    protected HashSet registeredFontFiles = new HashSet();</span>

    private ArrayList badFonts;
    /* fontPath is the location of all fonts on the system, excluding the
     * JRE's own font directory but including any path specified using the
     * sun.java2d.fontpath property. Together with that property,  it is
     * initialised by the getPlatformFontPath() method
     * This call must be followed by a call to registerFontDirs(fontPath)
     * once any extra debugging path has been appended.
     */
    protected String fontPath;
    private FontConfiguration fontConfig;
    /* discoveredAllFonts is set to true when all fonts on the font path are
     * discovered. This usually also implies opening, validating and
     * registering, but an implementation may be optimized to avold this.
     * So see also &quot;loadedAllFontFiles&quot;
     */
<span class="nc" id="L217">    private boolean discoveredAllFonts = false;</span>

    /* No need to keep consing up new instances - reuse a singleton.
     * The trade-off is that these objects don't get GC'd.
     */
<span class="nc" id="L222">    private static final FilenameFilter ttFilter = new TTFilter();</span>
<span class="nc" id="L223">    private static final FilenameFilter t1Filter = new T1Filter();</span>

    private Font[] allFonts;
    private String[] allFamilies; // cache for default locale only
    private Locale lastDefaultLocale;

    public static boolean noType1Font;

    /* Used to indicate required return type from toArray(..); */
<span class="nc" id="L232">    private static String[] STR_ARRAY = new String[0];</span>

    /**
     * Deprecated, unsupported hack - actually invokes a bug!
     * Left in for a customer, don't remove.
     */
<span class="nc" id="L238">    private boolean usePlatformFontMetrics = false;</span>

    /**
     * Returns the global SunFontManager instance. This is similar to
     * {@link FontManagerFactory#getInstance()} but it returns a
     * SunFontManager instance instead. This is only used in internal classes
     * where we can safely assume that a SunFontManager is to be used.
     *
     * @return the global SunFontManager instance
     */
    public static SunFontManager getInstance() {
<span class="nc" id="L249">        FontManager fm = FontManagerFactory.getInstance();</span>
<span class="nc" id="L250">        return (SunFontManager) fm;</span>
    }

    public FilenameFilter getTrueTypeFilter() {
<span class="nc" id="L254">        return ttFilter;</span>
    }

    public FilenameFilter getType1Filter() {
<span class="nc" id="L258">        return t1Filter;</span>
    }

    @Override
    public boolean usingPerAppContextComposites() {
<span class="nc" id="L263">        return _usingPerAppContextComposites;</span>
    }

    private void initJREFontMap() {

        /* Key is familyname+style value as an int.
         * Value is filename containing the font.
         * If no mapping exists, it means there is no font file for the style
         * If the mapping exists but the file doesn't exist in the deferred
         * list then it means its not installed.
         * This looks like a lot of code and strings but if it saves even
         * a single file being opened at JRE start-up there's a big payoff.
         * Lucida Sans is probably the only important case as the others
         * are rarely used. Consider removing the other mappings if there's
         * no evidence they are useful in practice.
         */
<span class="nc" id="L279">        jreFontMap = new HashMap&lt;String,String&gt;();</span>
<span class="nc" id="L280">        jreLucidaFontFiles = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (isOpenJDK()) {</span>
<span class="nc" id="L282">            return;</span>
        }
        /* Lucida Sans Family */
<span class="nc" id="L285">        jreFontMap.put(&quot;lucida sans0&quot;,   &quot;LucidaSansRegular.ttf&quot;);</span>
<span class="nc" id="L286">        jreFontMap.put(&quot;lucida sans1&quot;,   &quot;LucidaSansDemiBold.ttf&quot;);</span>
        /* Lucida Sans full names (map Bold and DemiBold to same file) */
<span class="nc" id="L288">        jreFontMap.put(&quot;lucida sans regular0&quot;, &quot;LucidaSansRegular.ttf&quot;);</span>
<span class="nc" id="L289">        jreFontMap.put(&quot;lucida sans regular1&quot;, &quot;LucidaSansDemiBold.ttf&quot;);</span>
<span class="nc" id="L290">        jreFontMap.put(&quot;lucida sans bold1&quot;, &quot;LucidaSansDemiBold.ttf&quot;);</span>
<span class="nc" id="L291">        jreFontMap.put(&quot;lucida sans demibold1&quot;, &quot;LucidaSansDemiBold.ttf&quot;);</span>

        /* Lucida Sans Typewriter Family */
<span class="nc" id="L294">        jreFontMap.put(&quot;lucida sans typewriter0&quot;,</span>
                       &quot;LucidaTypewriterRegular.ttf&quot;);
<span class="nc" id="L296">        jreFontMap.put(&quot;lucida sans typewriter1&quot;, &quot;LucidaTypewriterBold.ttf&quot;);</span>
        /* Typewriter full names (map Bold and DemiBold to same file) */
<span class="nc" id="L298">        jreFontMap.put(&quot;lucida sans typewriter regular0&quot;,</span>
                       &quot;LucidaTypewriter.ttf&quot;);
<span class="nc" id="L300">        jreFontMap.put(&quot;lucida sans typewriter regular1&quot;,</span>
                       &quot;LucidaTypewriterBold.ttf&quot;);
<span class="nc" id="L302">        jreFontMap.put(&quot;lucida sans typewriter bold1&quot;,</span>
                       &quot;LucidaTypewriterBold.ttf&quot;);
<span class="nc" id="L304">        jreFontMap.put(&quot;lucida sans typewriter demibold1&quot;,</span>
                       &quot;LucidaTypewriterBold.ttf&quot;);

        /* Lucida Bright Family */
<span class="nc" id="L308">        jreFontMap.put(&quot;lucida bright0&quot;, &quot;LucidaBrightRegular.ttf&quot;);</span>
<span class="nc" id="L309">        jreFontMap.put(&quot;lucida bright1&quot;, &quot;LucidaBrightDemiBold.ttf&quot;);</span>
<span class="nc" id="L310">        jreFontMap.put(&quot;lucida bright2&quot;, &quot;LucidaBrightItalic.ttf&quot;);</span>
<span class="nc" id="L311">        jreFontMap.put(&quot;lucida bright3&quot;, &quot;LucidaBrightDemiItalic.ttf&quot;);</span>
        /* Lucida Bright full names (map Bold and DemiBold to same file) */
<span class="nc" id="L313">        jreFontMap.put(&quot;lucida bright regular0&quot;, &quot;LucidaBrightRegular.ttf&quot;);</span>
<span class="nc" id="L314">        jreFontMap.put(&quot;lucida bright regular1&quot;, &quot;LucidaBrightDemiBold.ttf&quot;);</span>
<span class="nc" id="L315">        jreFontMap.put(&quot;lucida bright regular2&quot;, &quot;LucidaBrightItalic.ttf&quot;);</span>
<span class="nc" id="L316">        jreFontMap.put(&quot;lucida bright regular3&quot;, &quot;LucidaBrightDemiItalic.ttf&quot;);</span>
<span class="nc" id="L317">        jreFontMap.put(&quot;lucida bright bold1&quot;, &quot;LucidaBrightDemiBold.ttf&quot;);</span>
<span class="nc" id="L318">        jreFontMap.put(&quot;lucida bright bold3&quot;, &quot;LucidaBrightDemiItalic.ttf&quot;);</span>
<span class="nc" id="L319">        jreFontMap.put(&quot;lucida bright demibold1&quot;, &quot;LucidaBrightDemiBold.ttf&quot;);</span>
<span class="nc" id="L320">        jreFontMap.put(&quot;lucida bright demibold3&quot;,&quot;LucidaBrightDemiItalic.ttf&quot;);</span>
<span class="nc" id="L321">        jreFontMap.put(&quot;lucida bright italic2&quot;, &quot;LucidaBrightItalic.ttf&quot;);</span>
<span class="nc" id="L322">        jreFontMap.put(&quot;lucida bright italic3&quot;, &quot;LucidaBrightDemiItalic.ttf&quot;);</span>
<span class="nc" id="L323">        jreFontMap.put(&quot;lucida bright bold italic3&quot;,</span>
                       &quot;LucidaBrightDemiItalic.ttf&quot;);
<span class="nc" id="L325">        jreFontMap.put(&quot;lucida bright demibold italic3&quot;,</span>
                       &quot;LucidaBrightDemiItalic.ttf&quot;);
<span class="nc bnc" id="L327" title="All 2 branches missed.">        for (String ffile : jreFontMap.values()) {</span>
<span class="nc" id="L328">            jreLucidaFontFiles.add(ffile);</span>
<span class="nc" id="L329">        }</span>
<span class="nc" id="L330">    }</span>

    static {

<span class="nc" id="L334">        java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L335">                                    new java.security.PrivilegedAction() {</span>

           public Object run() {
<span class="nc" id="L338">               FontManagerNativeLibrary.load();</span>

               // JNI throws an exception if a class/method/field is not found,
               // so there's no need to do anything explicit here.
<span class="nc" id="L342">               initIDs();</span>

<span class="nc bnc" id="L344" title="All 3 branches missed.">               switch (StrikeCache.nativeAddressSize) {</span>
<span class="nc" id="L345">               case 8: longAddresses = true; break;</span>
<span class="nc" id="L346">               case 4: longAddresses = false; break;</span>
<span class="nc" id="L347">               default: throw new RuntimeException(&quot;Unexpected address size&quot;);</span>
               }

<span class="nc" id="L350">               noType1Font =</span>
<span class="nc" id="L351">                   &quot;true&quot;.equals(System.getProperty(&quot;sun.java2d.noType1Font&quot;));</span>
<span class="nc" id="L352">               jreLibDirName =</span>
<span class="nc" id="L353">                   System.getProperty(&quot;java.home&quot;,&quot;&quot;) + File.separator + &quot;lib&quot;;</span>
<span class="nc" id="L354">               jreFontDirName = jreLibDirName + File.separator + &quot;fonts&quot;;</span>
<span class="nc" id="L355">               File lucidaFile =</span>
                   new File(jreFontDirName + File.separator + FontUtilities.LUCIDA_FILE_NAME);

<span class="nc" id="L358">               return null;</span>
           }
        });
    }

    public TrueTypeFont getEUDCFont() {
        // Overridden in Windows.
<span class="nc" id="L365">        return null;</span>
    }

    /* Initialise ptrs used by JNI methods */
    private static native void initIDs();

    @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L372">    protected SunFontManager() {</span>

<span class="nc" id="L374">        initJREFontMap();</span>
<span class="nc" id="L375">        java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L376">                new java.security.PrivilegedAction() {</span>
                    public Object run() {
<span class="nc" id="L378">                        File badFontFile =</span>
                            new File(jreFontDirName + File.separator +
                                     &quot;badfonts.txt&quot;);
<span class="nc bnc" id="L381" title="All 2 branches missed.">                        if (badFontFile.exists()) {</span>
<span class="nc" id="L382">                            FileInputStream fis = null;</span>
                            try {
<span class="nc" id="L384">                                badFonts = new ArrayList();</span>
<span class="nc" id="L385">                                fis = new FileInputStream(badFontFile);</span>
<span class="nc" id="L386">                                InputStreamReader isr = new InputStreamReader(fis);</span>
<span class="nc" id="L387">                                BufferedReader br = new BufferedReader(isr);</span>
                                while (true) {
<span class="nc" id="L389">                                    String name = br.readLine();</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                                    if (name == null) {</span>
<span class="nc" id="L391">                                        break;</span>
                                    } else {
<span class="nc bnc" id="L393" title="All 2 branches missed.">                                        if (FontUtilities.debugFonts()) {</span>
<span class="nc" id="L394">                                            FontUtilities.getLogger().warning(&quot;read bad font: &quot; +</span>
                                                           name);
                                        }
<span class="nc" id="L397">                                        badFonts.add(name);</span>
                                    }
<span class="nc" id="L399">                                }</span>
<span class="nc" id="L400">                            } catch (IOException e) {</span>
                                try {
<span class="nc bnc" id="L402" title="All 2 branches missed.">                                    if (fis != null) {</span>
<span class="nc" id="L403">                                        fis.close();</span>
                                    }
<span class="nc" id="L405">                                } catch (IOException ioe) {</span>
<span class="nc" id="L406">                                }</span>
<span class="nc" id="L407">                            }</span>
                        }

                        /* Here we get the fonts in jre/lib/fonts and register
                         * them so they are always available and preferred over
                         * other fonts. This needs to be registered before the
                         * composite fonts as otherwise some native font that
                         * corresponds may be found as we don't have a way to
                         * handle two fonts of the same name, so the JRE one
                         * must be the first one registered. Pass &quot;true&quot; to
                         * registerFonts method as on-screen these JRE fonts
                         * always go through the T2K rasteriser.
                         */
<span class="nc bnc" id="L420" title="All 2 branches missed.">                        if (FontUtilities.isLinux) {</span>
                            /* Linux font configuration uses these fonts */
<span class="nc" id="L422">                            registerFontDir(jreFontDirName);</span>
                        }
<span class="nc" id="L424">                        registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,</span>
                                           true, false);

                        /* Create the font configuration and get any font path
                         * that might be specified.
                         */
<span class="nc" id="L430">                        fontConfig = createFontConfiguration();</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                        if (isOpenJDK()) {</span>
<span class="nc" id="L432">                            String[] fontInfo = getDefaultPlatformFont();</span>
<span class="nc" id="L433">                            defaultFontName = fontInfo[0];</span>
<span class="nc" id="L434">                            defaultFontFileName = fontInfo[1];</span>
                        }

<span class="nc" id="L437">                        String extraFontPath = fontConfig.getExtraFontPath();</span>

                        /* In prior releases the debugging font path replaced
                         * all normally located font directories except for the
                         * JRE fonts dir. This directory is still always located
                         * and placed at the head of the path but as an
                         * augmentation to the previous behaviour the
                         * changes below allow you to additionally append to
                         * the font path by starting with append: or prepend by
                         * starting with a prepend: sign. Eg: to append
                         * -Dsun.java2d.fontpath=append:/usr/local/myfonts
                         * and to prepend
                         * -Dsun.java2d.fontpath=prepend:/usr/local/myfonts Disp
                         *
                         * If there is an appendedfontpath it in the font
                         * configuration it is used instead of searching the
                         * system for dirs.
                         * The behaviour of append and prepend is then similar
                         * to the normal case. ie it goes after what
                         * you prepend and * before what you append. If the
                         * sun.java2d.fontpath property is used, but it
                         * neither the append or prepend syntaxes is used then
                         * as except for the JRE dir the path is replaced and it
                         * is up to you to make sure that all the right
                         * directories are located. This is platform and
                         * locale-specific so its almost impossible to get
                         * right, so it should be used with caution.
                         */
<span class="nc" id="L465">                        boolean prependToPath = false;</span>
<span class="nc" id="L466">                        boolean appendToPath = false;</span>
<span class="nc" id="L467">                        String dbgFontPath =</span>
<span class="nc" id="L468">                            System.getProperty(&quot;sun.java2d.fontpath&quot;);</span>

<span class="nc bnc" id="L470" title="All 2 branches missed.">                        if (dbgFontPath != null) {</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">                            if (dbgFontPath.startsWith(&quot;prepend:&quot;)) {</span>
<span class="nc" id="L472">                                prependToPath = true;</span>
<span class="nc" id="L473">                                dbgFontPath =</span>
<span class="nc" id="L474">                                    dbgFontPath.substring(&quot;prepend:&quot;.length());</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">                            } else if (dbgFontPath.startsWith(&quot;append:&quot;)) {</span>
<span class="nc" id="L476">                                appendToPath = true;</span>
<span class="nc" id="L477">                                dbgFontPath =</span>
<span class="nc" id="L478">                                    dbgFontPath.substring(&quot;append:&quot;.length());</span>
                            }
                        }

<span class="nc bnc" id="L482" title="All 2 branches missed.">                        if (FontUtilities.debugFonts()) {</span>
<span class="nc" id="L483">                            PlatformLogger logger = FontUtilities.getLogger();</span>
<span class="nc" id="L484">                            logger.info(&quot;JRE font directory: &quot; + jreFontDirName);</span>
<span class="nc" id="L485">                            logger.info(&quot;Extra font path: &quot; + extraFontPath);</span>
<span class="nc" id="L486">                            logger.info(&quot;Debug font path: &quot; + dbgFontPath);</span>
                        }

<span class="nc bnc" id="L489" title="All 2 branches missed.">                        if (dbgFontPath != null) {</span>
                            /* In debugging mode we register all the paths
                             * Caution: this is a very expensive call on Solaris:-
                             */
<span class="nc" id="L493">                            fontPath = getPlatformFontPath(noType1Font);</span>

<span class="nc bnc" id="L495" title="All 2 branches missed.">                            if (extraFontPath != null) {</span>
<span class="nc" id="L496">                                fontPath =</span>
                                    extraFontPath + File.pathSeparator + fontPath;
                            }
<span class="nc bnc" id="L499" title="All 2 branches missed.">                            if (appendToPath) {</span>
<span class="nc" id="L500">                                fontPath =</span>
                                    fontPath + File.pathSeparator + dbgFontPath;
<span class="nc bnc" id="L502" title="All 2 branches missed.">                            } else if (prependToPath) {</span>
<span class="nc" id="L503">                                fontPath =</span>
                                    dbgFontPath + File.pathSeparator + fontPath;
                            } else {
<span class="nc" id="L506">                                fontPath = dbgFontPath;</span>
                            }
<span class="nc" id="L508">                            registerFontDirs(fontPath);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">                        } else if (extraFontPath != null) {</span>
                            /* If the font configuration contains an
                             * &quot;appendedfontpath&quot; entry, it is interpreted as a
                             * set of locations that should always be registered.
                             * It may be additional to locations normally found
                             * for that place, or it may be locations that need
                             * to have all their paths registered to locate all
                             * the needed platform names.
                             * This is typically when the same .TTF file is
                             * referenced from multiple font.dir files and all
                             * of these must be read to find all the native
                             * (XLFD) names for the font, so that X11 font APIs
                             * can be used for as many code points as possible.
                             */
<span class="nc" id="L523">                            registerFontDirs(extraFontPath);</span>
                        }

                        /* On Solaris, we need to register the Japanese TrueType
                         * directory so that we can find the corresponding
                         * bitmap fonts. This could be done by listing the
                         * directory in the font configuration file, but we
                         * don't want to confuse users with this quirk. There
                         * are no bitmap fonts for other writing systems that
                         * correspond to TrueType fonts and have matching XLFDs.
                         * We need to register the bitmap fonts only in
                         * environments where they're on the X font path, i.e.,
                         * in the Japanese locale. Note that if the X Toolkit
                         * is in use the font path isn't set up by JDK, but
                         * users of a JA locale should have it
                         * set up already by their login environment.
                         */
<span class="nc bnc" id="L540" title="All 4 branches missed.">                        if (FontUtilities.isSolaris &amp;&amp; Locale.JAPAN.equals(Locale.getDefault())) {</span>
<span class="nc" id="L541">                            registerFontDir(&quot;/usr/openwin/lib/locale/ja/X11/fonts/TT&quot;);</span>
                        }

<span class="nc" id="L544">                        initCompositeFonts(fontConfig, null);</span>

<span class="nc" id="L546">                        return null;</span>
                    }
                });

<span class="nc" id="L550">        boolean platformFont = AccessController.doPrivileged(</span>
<span class="nc" id="L551">                        new PrivilegedAction&lt;Boolean&gt;() {</span>
                                public Boolean run() {
<span class="nc" id="L553">                                        String prop =</span>
<span class="nc" id="L554">                                                System.getProperty(&quot;java2d.font.usePlatformFont&quot;);</span>
<span class="nc" id="L555">                                        String env = System.getenv(&quot;JAVA2D_USEPLATFORMFONT&quot;);</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">                                        return &quot;true&quot;.equals(prop) || env != null;</span>
                                }
                        });

<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (platformFont) {</span>
<span class="nc" id="L561">            usePlatformFontMetrics = true;</span>
<span class="nc" id="L562">            System.out.println(&quot;Enabling platform font metrics for win32. This is an unsupported option.&quot;);</span>
<span class="nc" id="L563">            System.out.println(&quot;This yields incorrect composite font metrics as reported by 1.1.x releases.&quot;);</span>
<span class="nc" id="L564">            System.out.println(&quot;It is appropriate only for use by applications which do not use any Java 2&quot;);</span>
<span class="nc" id="L565">            System.out.println(&quot;functionality. This property will be removed in a later release.&quot;);</span>
        }
<span class="nc" id="L567">    }</span>

    /**
     * This method is provided for internal and exclusive use by Swing.
     *
     * @param font representing a physical font.
     * @return true if the underlying font is a TrueType or OpenType font
     * that claims to support the Microsoft Windows encoding corresponding to
     * the default file.encoding property of this JRE instance.
     * This narrow value is useful for Swing to decide if the font is useful
     * for the the Windows Look and Feel, or, if a  composite font should be
     * used instead.
     * The information used to make the decision is obtained from
     * the ulCodePageRange fields in the font.
     * A caller can use isLogicalFont(Font) in this class before calling
     * this method and would not need to call this method if that
     * returns true.
     */
//     static boolean fontSupportsDefaultEncoding(Font font) {
//      String encoding =
//          (String) java.security.AccessController.doPrivileged(
//                new sun.security.action.GetPropertyAction(&quot;file.encoding&quot;));

//      if (encoding == null || font == null) {
//          return false;
//      }

//      encoding = encoding.toLowerCase(Locale.ENGLISH);

//      return FontManager.fontSupportsEncoding(font, encoding);
//     }

    public Font2DHandle getNewComposite(String family, int style,
                                        Font2DHandle handle) {

<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (!(handle.font2D instanceof CompositeFont)) {</span>
<span class="nc" id="L603">            return handle;</span>
        }

<span class="nc" id="L606">        CompositeFont oldComp = (CompositeFont)handle.font2D;</span>
<span class="nc" id="L607">        PhysicalFont oldFont = oldComp.getSlotFont(0);</span>

<span class="nc bnc" id="L609" title="All 2 branches missed.">        if (family == null) {</span>
<span class="nc" id="L610">            family = oldFont.getFamilyName(null);</span>
        }
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (style == -1) {</span>
<span class="nc" id="L613">            style = oldComp.getStyle();</span>
        }

<span class="nc" id="L616">        Font2D newFont = findFont2D(family, style, NO_FALLBACK);</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (!(newFont instanceof PhysicalFont)) {</span>
<span class="nc" id="L618">            newFont = oldFont;</span>
        }
<span class="nc" id="L620">        PhysicalFont physicalFont = (PhysicalFont)newFont;</span>
<span class="nc" id="L621">        CompositeFont dialog2D =</span>
<span class="nc" id="L622">            (CompositeFont)findFont2D(&quot;dialog&quot;, style, NO_FALLBACK);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">        if (dialog2D == null) { /* shouldn't happen */</span>
<span class="nc" id="L624">            return handle;</span>
        }
<span class="nc" id="L626">        CompositeFont compFont = new CompositeFont(physicalFont, dialog2D);</span>
<span class="nc" id="L627">        Font2DHandle newHandle = new Font2DHandle(compFont);</span>
<span class="nc" id="L628">        return newHandle;</span>
    }

    protected void registerCompositeFont(String compositeName,
                                      String[] componentFileNames,
                                      String[] componentNames,
                                      int numMetricsSlots,
                                      int[] exclusionRanges,
                                      int[] exclusionMaxIndex,
                                      boolean defer) {

<span class="nc" id="L639">        CompositeFont cf = new CompositeFont(compositeName,</span>
                                             componentFileNames,
                                             componentNames,
                                             numMetricsSlots,
                                             exclusionRanges,
                                             exclusionMaxIndex, defer, this);
<span class="nc" id="L645">        addCompositeToFontList(cf, Font2D.FONT_CONFIG_RANK);</span>
<span class="nc" id="L646">        synchronized (compFonts) {</span>
<span class="nc" id="L647">            compFonts[maxCompFont++] = cf;</span>
<span class="nc" id="L648">        }</span>
<span class="nc" id="L649">    }</span>

    /* This variant is used only when the application specifies
     * a variant of composite fonts which prefers locale specific or
     * proportional fonts.
     */
    protected static void registerCompositeFont(String compositeName,
                                                String[] componentFileNames,
                                                String[] componentNames,
                                                int numMetricsSlots,
                                                int[] exclusionRanges,
                                                int[] exclusionMaxIndex,
                                                boolean defer,
                                                ConcurrentHashMap&lt;String, Font2D&gt;
                                                altNameCache) {

<span class="nc" id="L665">        CompositeFont cf = new CompositeFont(compositeName,</span>
                                             componentFileNames,
                                             componentNames,
                                             numMetricsSlots,
                                             exclusionRanges,
                                             exclusionMaxIndex, defer,
<span class="nc" id="L671">                                             SunFontManager.getInstance());</span>

        /* if the cache has an existing composite for this case, make
         * its handle point to this new font.
         * This ensures that when the altNameCache that is passed in
         * is the global mapNameCache - ie we are running as an application -
         * that any statically created java.awt.Font instances which already
         * have a Font2D instance will have that re-directed to the new Font
         * on subsequent uses. This is particularly important for &quot;the&quot;
         * default font instance, or similar cases where a UI toolkit (eg
         * Swing) has cached a java.awt.Font. Note that if Swing is using
         * a custom composite APIs which update the standard composites have
         * no effect - this is typically the case only when using the Windows
         * L&amp;F where these APIs would conflict with that L&amp;F anyway.
         */
<span class="nc" id="L686">        Font2D oldFont = (Font2D)</span>
<span class="nc" id="L687">            altNameCache.get(compositeName.toLowerCase(Locale.ENGLISH));</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        if (oldFont instanceof CompositeFont) {</span>
<span class="nc" id="L689">            oldFont.handle.font2D = cf;</span>
        }
<span class="nc" id="L691">        altNameCache.put(compositeName.toLowerCase(Locale.ENGLISH), cf);</span>
<span class="nc" id="L692">    }</span>

    private void addCompositeToFontList(CompositeFont f, int rank) {

<span class="nc bnc" id="L696" title="All 2 branches missed.">        if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L697">            FontUtilities.getLogger().info(&quot;Add to Family &quot;+ f.familyName +</span>
                        &quot;, Font &quot; + f.fullName + &quot; rank=&quot;+rank);
        }
<span class="nc" id="L700">        f.setRank(rank);</span>
<span class="nc" id="L701">        compositeFonts.put(f.fullName, f);</span>
<span class="nc" id="L702">        fullNameToFont.put(f.fullName.toLowerCase(Locale.ENGLISH), f);</span>

<span class="nc" id="L704">        FontFamily family = FontFamily.getFamily(f.familyName);</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">        if (family == null) {</span>
<span class="nc" id="L706">            family = new FontFamily(f.familyName, true, rank);</span>
        }
<span class="nc" id="L708">        family.setFont(f, f.style);</span>
<span class="nc" id="L709">    }</span>

    /*
     * Systems may have fonts with the same name.
     * We want to register only one of such fonts (at least until
     * such time as there might be APIs which can accommodate &gt; 1).
     * Rank is 1) font configuration fonts, 2) JRE fonts, 3) OT/TT fonts,
     * 4) Type1 fonts, 5) native fonts.
     *
     * If the new font has the same name as the old font, the higher
     * ranked font gets added, replacing the lower ranked one.
     * If the fonts are of equal rank, then make a special case of
     * font configuration rank fonts, which are on closer inspection,
     * OT/TT fonts such that the larger font is registered. This is
     * a heuristic since a font may be &quot;larger&quot; in the sense of more
     * code points, or be a larger &quot;file&quot; because it has more bitmaps.
     * So it is possible that using filesize may lead to less glyphs, and
     * using glyphs may lead to lower quality display. Probably number
     * of glyphs is the ideal, but filesize is information we already
     * have and is good enough for the known cases.
     * Also don't want to register fonts that match JRE font families
     * but are coming from a source other than the JRE.
     * This will ensure that we will algorithmically style the JRE
     * plain font and get the same set of glyphs for all styles.
     *
     * Note that this method returns a value
     * if it returns the same object as its argument that means this
     * font was newly registered.
     * If it returns a different object it means this font already exists,
     * and you should use that one.
     * If it returns null means this font was not registered and none
     * in that name is registered. The caller must find a substitute
     */
    // MACOSX begin -- need to access this in subclass
    protected PhysicalFont addToFontList(PhysicalFont f, int rank) {
    // MACOSX end

<span class="nc" id="L746">        String fontName = f.fullName;</span>
<span class="nc" id="L747">        String familyName = f.familyName;</span>
<span class="nc bnc" id="L748" title="All 4 branches missed.">        if (fontName == null || &quot;&quot;.equals(fontName)) {</span>
<span class="nc" id="L749">            return null;</span>
        }
<span class="nc bnc" id="L751" title="All 2 branches missed.">        if (compositeFonts.containsKey(fontName)) {</span>
            /* Don't register any font that has the same name as a composite */
<span class="nc" id="L753">            return null;</span>
        }
<span class="nc" id="L755">        f.setRank(rank);</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if (!physicalFonts.containsKey(fontName)) {</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L758">                FontUtilities.getLogger().info(&quot;Add to Family &quot;+familyName +</span>
                            &quot;, Font &quot; + fontName + &quot; rank=&quot;+rank);
            }
<span class="nc" id="L761">            physicalFonts.put(fontName, f);</span>
<span class="nc" id="L762">            FontFamily family = FontFamily.getFamily(familyName);</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">            if (family == null) {</span>
<span class="nc" id="L764">                family = new FontFamily(familyName, false, rank);</span>
<span class="nc" id="L765">                family.setFont(f, f.style);</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">            } else if (family.getRank() &gt;= rank) {</span>
<span class="nc" id="L767">                family.setFont(f, f.style);</span>
            }
<span class="nc" id="L769">            fullNameToFont.put(fontName.toLowerCase(Locale.ENGLISH), f);</span>
<span class="nc" id="L770">            return f;</span>
        } else {
<span class="nc" id="L772">            PhysicalFont newFont = f;</span>
<span class="nc" id="L773">            PhysicalFont oldFont = physicalFonts.get(fontName);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">            if (oldFont == null) {</span>
<span class="nc" id="L775">                return null;</span>
            }
            /* If the new font is of an equal or higher rank, it is a
             * candidate to replace the current one, subject to further tests.
             */
<span class="nc bnc" id="L780" title="All 2 branches missed.">            if (oldFont.getRank() &gt;= rank) {</span>

                /* All fonts initialise their mapper when first
                 * used. If the mapper is non-null then this font
                 * has been accessed at least once. In that case
                 * do not replace it. This may be overly stringent,
                 * but its probably better not to replace a font that
                 * someone is already using without a compelling reason.
                 * Additionally the primary case where it is known
                 * this behaviour is important is in certain composite
                 * fonts, and since all the components of a given
                 * composite are usually initialised together this
                 * is unlikely. For this to be a problem, there would
                 * have to be a case where two different composites used
                 * different versions of the same-named font, and they
                 * were initialised and used at separate times.
                 * In that case we continue on and allow the new font to
                 * be installed, but replaceFont will continue to allow
                 * the original font to be used in Composite fonts.
                 */
<span class="nc bnc" id="L800" title="All 4 branches missed.">                if (oldFont.mapper != null &amp;&amp; rank &gt; Font2D.FONT_CONFIG_RANK) {</span>
<span class="nc" id="L801">                    return oldFont;</span>
                }

                /* Normally we require a higher rank to replace a font,
                 * but as a special case, if the two fonts are the same rank,
                 * and are instances of TrueTypeFont we want the
                 * more complete (larger) one.
                 */
<span class="nc bnc" id="L809" title="All 2 branches missed.">                if (oldFont.getRank() == rank) {</span>
<span class="nc bnc" id="L810" title="All 4 branches missed.">                    if (oldFont instanceof TrueTypeFont &amp;&amp;</span>
                        newFont instanceof TrueTypeFont) {
<span class="nc" id="L812">                        TrueTypeFont oldTTFont = (TrueTypeFont)oldFont;</span>
<span class="nc" id="L813">                        TrueTypeFont newTTFont = (TrueTypeFont)newFont;</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">                        if (oldTTFont.fileSize &gt;= newTTFont.fileSize) {</span>
<span class="nc" id="L815">                            return oldFont;</span>
                        }
<span class="nc" id="L817">                    } else {</span>
<span class="nc" id="L818">                        return oldFont;</span>
                    }
                }
                /* Don't replace ever JRE fonts.
                 * This test is in case a font configuration references
                 * a Lucida font, which has been mapped to a Lucida
                 * from the host O/S. The assumption here is that any
                 * such font configuration file is probably incorrect, or
                 * the host O/S version is for the use of AWT.
                 * In other words if we reach here, there's a possible
                 * problem with our choice of font configuration fonts.
                 */
<span class="nc bnc" id="L830" title="All 2 branches missed.">                if (oldFont.platName.startsWith(jreFontDirName)) {</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">                    if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L832">                        FontUtilities.getLogger()</span>
<span class="nc" id="L833">                              .warning(&quot;Unexpected attempt to replace a JRE &quot; +</span>
                                       &quot; font &quot; + fontName + &quot; from &quot; +
                                        oldFont.platName +
                                       &quot; with &quot; + newFont.platName);
                    }
<span class="nc" id="L838">                    return oldFont;</span>
                }

<span class="nc bnc" id="L841" title="All 2 branches missed.">                if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L842">                    FontUtilities.getLogger()</span>
<span class="nc" id="L843">                          .info(&quot;Replace in Family &quot; + familyName +</span>
                                &quot;,Font &quot; + fontName + &quot; new rank=&quot;+rank +
                                &quot; from &quot; + oldFont.platName +
                                &quot; with &quot; + newFont.platName);
                }
<span class="nc" id="L848">                replaceFont(oldFont, newFont);</span>
<span class="nc" id="L849">                physicalFonts.put(fontName, newFont);</span>
<span class="nc" id="L850">                fullNameToFont.put(fontName.toLowerCase(Locale.ENGLISH),</span>
                                   newFont);

<span class="nc" id="L853">                FontFamily family = FontFamily.getFamily(familyName);</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                if (family == null) {</span>
<span class="nc" id="L855">                    family = new FontFamily(familyName, false, rank);</span>
<span class="nc" id="L856">                    family.setFont(newFont, newFont.style);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">                } else if (family.getRank() &gt;= rank) {</span>
<span class="nc" id="L858">                    family.setFont(newFont, newFont.style);</span>
                }
<span class="nc" id="L860">                return newFont;</span>
            } else {
<span class="nc" id="L862">                return oldFont;</span>
            }
        }
    }

    public Font2D[] getRegisteredFonts() {
<span class="nc" id="L868">        PhysicalFont[] physFonts = getPhysicalFonts();</span>
<span class="nc" id="L869">        int mcf = maxCompFont; /* for MT-safety */</span>
<span class="nc" id="L870">        Font2D[] regFonts = new Font2D[physFonts.length+mcf];</span>
<span class="nc" id="L871">        System.arraycopy(compFonts, 0, regFonts, 0, mcf);</span>
<span class="nc" id="L872">        System.arraycopy(physFonts, 0, regFonts, mcf, physFonts.length);</span>
<span class="nc" id="L873">        return regFonts;</span>
    }

    protected PhysicalFont[] getPhysicalFonts() {
<span class="nc" id="L877">        return physicalFonts.values().toArray(new PhysicalFont[0]);</span>
    }


    /* The class FontRegistrationInfo is used when a client says not
     * to register a font immediately. This mechanism is used to defer
     * initialisation of all the components of composite fonts at JRE
     * start-up. The CompositeFont class is &quot;aware&quot; of this and when it
     * is first used it asks for the registration of its components.
     * Also in the event that any physical font is requested the
     * deferred fonts are initialised before triggering a search of the
     * system.
     * Two maps are used. One to track the deferred fonts. The
     * other to track the fonts that have been initialised through this
     * mechanism.
     */

    private static final class FontRegistrationInfo {

        String fontFilePath;
        String[] nativeNames;
        int fontFormat;
        boolean javaRasterizer;
        int fontRank;

        FontRegistrationInfo(String fontPath, String[] names, int format,
<span class="nc" id="L903">                             boolean useJavaRasterizer, int rank) {</span>
<span class="nc" id="L904">            this.fontFilePath = fontPath;</span>
<span class="nc" id="L905">            this.nativeNames = names;</span>
<span class="nc" id="L906">            this.fontFormat = format;</span>
<span class="nc" id="L907">            this.javaRasterizer = useJavaRasterizer;</span>
<span class="nc" id="L908">            this.fontRank = rank;</span>
<span class="nc" id="L909">        }</span>
    }

<span class="nc" id="L912">    private final ConcurrentHashMap&lt;String, FontRegistrationInfo&gt;</span>
        deferredFontFiles =
        new ConcurrentHashMap&lt;String, FontRegistrationInfo&gt;();
<span class="nc" id="L915">    private final ConcurrentHashMap&lt;String, Font2DHandle&gt;</span>
        initialisedFonts = new ConcurrentHashMap&lt;String, Font2DHandle&gt;();

    /* Remind: possibly enhance initialiseDeferredFonts() to be
     * optionally given a name and a style and it could stop when it
     * finds that font - but this would be a problem if two of the
     * fonts reference the same font face name (cf the Solaris
     * euro fonts).
     */
    protected synchronized void initialiseDeferredFonts() {
<span class="nc bnc" id="L925" title="All 2 branches missed.">        for (String fileName : deferredFontFiles.keySet()) {</span>
<span class="nc" id="L926">            initialiseDeferredFont(fileName);</span>
<span class="nc" id="L927">        }</span>
<span class="nc" id="L928">    }</span>

    protected synchronized void registerDeferredJREFonts(String jreDir) {
<span class="nc bnc" id="L931" title="All 2 branches missed.">        for (FontRegistrationInfo info : deferredFontFiles.values()) {</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (info.fontFilePath != null &amp;&amp;</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">                info.fontFilePath.startsWith(jreDir)) {</span>
<span class="nc" id="L934">                initialiseDeferredFont(info.fontFilePath);</span>
            }
<span class="nc" id="L936">        }</span>
<span class="nc" id="L937">    }</span>

    public boolean isDeferredFont(String fileName) {
<span class="nc" id="L940">        return deferredFontFiles.containsKey(fileName);</span>
    }

    /* We keep a map of the files which contain the Lucida fonts so we
     * don't need to search for them.
     * But since we know what fonts these files contain, we can also avoid
     * opening them to look for a font name we don't recognise - see
     * findDeferredFont().
     * For typical cases where the font isn't a JRE one the overhead is
     * this method call, HashMap.get() and null reference test, then
     * a boolean test of noOtherJREFontFiles.
     */
    public
    /*private*/ PhysicalFont findJREDeferredFont(String name, int style) {

        PhysicalFont physicalFont;
<span class="nc" id="L956">        String nameAndStyle = name.toLowerCase(Locale.ENGLISH) + style;</span>
<span class="nc" id="L957">        String fileName = jreFontMap.get(nameAndStyle);</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">        if (fileName != null) {</span>
<span class="nc" id="L959">            fileName = jreFontDirName + File.separator + fileName;</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">            if (deferredFontFiles.get(fileName) != null) {</span>
<span class="nc" id="L961">                physicalFont = initialiseDeferredFont(fileName);</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                if (physicalFont != null &amp;&amp;</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">                    (physicalFont.getFontName(null).equalsIgnoreCase(name) ||</span>
<span class="nc bnc" id="L964" title="All 4 branches missed.">                     physicalFont.getFamilyName(null).equalsIgnoreCase(name))</span>
                    &amp;&amp; physicalFont.style == style) {
<span class="nc" id="L966">                    return physicalFont;</span>
                }
            }
        }

        /* Iterate over the deferred font files looking for any in the
         * jre directory that we didn't recognise, open each of these.
         * In almost all installations this will quickly fall through
         * because only the Lucidas will be present and jreOtherFontFiles
         * will be empty.
         * noOtherJREFontFiles is used so we can skip this block as soon
         * as its determined that its not needed - almost always after the
         * very first time through.
         */
<span class="nc bnc" id="L980" title="All 2 branches missed.">        if (noOtherJREFontFiles) {</span>
<span class="nc" id="L981">            return null;</span>
        }
<span class="nc" id="L983">        synchronized (jreLucidaFontFiles) {</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">            if (jreOtherFontFiles == null) {</span>
<span class="nc" id="L985">                HashSet&lt;String&gt; otherFontFiles = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">                for (String deferredFile : deferredFontFiles.keySet()) {</span>
<span class="nc" id="L987">                    File file = new File(deferredFile);</span>
<span class="nc" id="L988">                    String dir = file.getParent();</span>
<span class="nc" id="L989">                    String fname = file.getName();</span>
                    /* skip names which aren't absolute, aren't in the JRE
                     * directory, or are known Lucida fonts.
                     */
<span class="nc bnc" id="L993" title="All 2 branches missed.">                    if (dir == null ||</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">                        !dir.equals(jreFontDirName) ||</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">                        jreLucidaFontFiles.contains(fname)) {</span>
<span class="nc" id="L996">                        continue;</span>
                    }
<span class="nc" id="L998">                    otherFontFiles.add(deferredFile);</span>
<span class="nc" id="L999">                }</span>
<span class="nc" id="L1000">                jreOtherFontFiles = otherFontFiles.toArray(STR_ARRAY);</span>
<span class="nc bnc" id="L1001" title="All 2 branches missed.">                if (jreOtherFontFiles.length == 0) {</span>
<span class="nc" id="L1002">                    noOtherJREFontFiles = true;</span>
                }
            }

<span class="nc bnc" id="L1006" title="All 2 branches missed.">            for (int i=0; i&lt;jreOtherFontFiles.length;i++) {</span>
<span class="nc" id="L1007">                fileName = jreOtherFontFiles[i];</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                if (fileName == null) {</span>
<span class="nc" id="L1009">                    continue;</span>
                }
<span class="nc" id="L1011">                jreOtherFontFiles[i] = null;</span>
<span class="nc" id="L1012">                physicalFont = initialiseDeferredFont(fileName);</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">                if (physicalFont != null &amp;&amp;</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">                    (physicalFont.getFontName(null).equalsIgnoreCase(name) ||</span>
<span class="nc bnc" id="L1015" title="All 4 branches missed.">                     physicalFont.getFamilyName(null).equalsIgnoreCase(name))</span>
                    &amp;&amp; physicalFont.style == style) {
<span class="nc" id="L1017">                    return physicalFont;</span>
                }
            }
<span class="nc" id="L1020">        }</span>

<span class="nc" id="L1022">        return null;</span>
    }

    /* This skips JRE installed fonts. */
    private PhysicalFont findOtherDeferredFont(String name, int style) {
<span class="nc bnc" id="L1027" title="All 2 branches missed.">        for (String fileName : deferredFontFiles.keySet()) {</span>
<span class="nc" id="L1028">            File file = new File(fileName);</span>
<span class="nc" id="L1029">            String dir = file.getParent();</span>
<span class="nc" id="L1030">            String fname = file.getName();</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">            if (dir != null &amp;&amp;</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                dir.equals(jreFontDirName) &amp;&amp;</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">                jreLucidaFontFiles.contains(fname)) {</span>
<span class="nc" id="L1034">                continue;</span>
            }
<span class="nc" id="L1036">            PhysicalFont physicalFont = initialiseDeferredFont(fileName);</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            if (physicalFont != null &amp;&amp;</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">                (physicalFont.getFontName(null).equalsIgnoreCase(name) ||</span>
<span class="nc bnc" id="L1039" title="All 4 branches missed.">                physicalFont.getFamilyName(null).equalsIgnoreCase(name)) &amp;&amp;</span>
                physicalFont.style == style) {
<span class="nc" id="L1041">                return physicalFont;</span>
            }
<span class="nc" id="L1043">        }</span>
<span class="nc" id="L1044">        return null;</span>
    }

    private PhysicalFont findDeferredFont(String name, int style) {

<span class="nc" id="L1049">        PhysicalFont physicalFont = findJREDeferredFont(name, style);</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">        if (physicalFont != null) {</span>
<span class="nc" id="L1051">            return physicalFont;</span>
        } else {
<span class="nc" id="L1053">            return findOtherDeferredFont(name, style);</span>
        }
    }

    public void registerDeferredFont(String fileNameKey,
                                     String fullPathName,
                                     String[] nativeNames,
                                     int fontFormat,
                                     boolean useJavaRasterizer,
                                     int fontRank) {
<span class="nc" id="L1063">        FontRegistrationInfo regInfo =</span>
            new FontRegistrationInfo(fullPathName, nativeNames, fontFormat,
                                     useJavaRasterizer, fontRank);
<span class="nc" id="L1066">        deferredFontFiles.put(fileNameKey, regInfo);</span>
<span class="nc" id="L1067">    }</span>


    public synchronized
         PhysicalFont initialiseDeferredFont(String fileNameKey) {

<span class="nc bnc" id="L1073" title="All 2 branches missed.">        if (fileNameKey == null) {</span>
<span class="nc" id="L1074">            return null;</span>
        }
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L1077">            FontUtilities.getLogger()</span>
<span class="nc" id="L1078">                            .info(&quot;Opening deferred font file &quot; + fileNameKey);</span>
        }

        PhysicalFont physicalFont;
<span class="nc" id="L1082">        FontRegistrationInfo regInfo = deferredFontFiles.get(fileNameKey);</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (regInfo != null) {</span>
<span class="nc" id="L1084">            deferredFontFiles.remove(fileNameKey);</span>
<span class="nc" id="L1085">            physicalFont = registerFontFile(regInfo.fontFilePath,</span>
                                            regInfo.nativeNames,
                                            regInfo.fontFormat,
                                            regInfo.javaRasterizer,
                                            regInfo.fontRank);


<span class="nc bnc" id="L1092" title="All 2 branches missed.">            if (physicalFont != null) {</span>
                /* Store the handle, so that if a font is bad, we
                 * retrieve the substituted font.
                 */
<span class="nc" id="L1096">                initialisedFonts.put(fileNameKey, physicalFont.handle);</span>
            } else {
<span class="nc" id="L1098">                initialisedFonts.put(fileNameKey,</span>
<span class="nc" id="L1099">                                     getDefaultPhysicalFont().handle);</span>
            }
        } else {
<span class="nc" id="L1102">            Font2DHandle handle = initialisedFonts.get(fileNameKey);</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">            if (handle == null) {</span>
                /* Probably shouldn't happen, but just in case */
<span class="nc" id="L1105">                physicalFont = getDefaultPhysicalFont();</span>
            } else {
<span class="nc" id="L1107">                physicalFont = (PhysicalFont)(handle.font2D);</span>
            }
        }
<span class="nc" id="L1110">        return physicalFont;</span>
    }

    public boolean isRegisteredFontFile(String name) {
<span class="nc" id="L1114">        return registeredFonts.containsKey(name);</span>
    }

    public PhysicalFont getRegisteredFontFile(String name) {
<span class="nc" id="L1118">        return registeredFonts.get(name);</span>
    }

    /* Note that the return value from this method is not always
     * derived from this file, and may be null. See addToFontList for
     * some explanation of this.
     */
    public PhysicalFont registerFontFile(String fileName,
                                         String[] nativeNames,
                                         int fontFormat,
                                         boolean useJavaRasterizer,
                                         int fontRank) {

<span class="nc" id="L1131">        PhysicalFont regFont = registeredFonts.get(fileName);</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">        if (regFont != null) {</span>
<span class="nc" id="L1133">            return regFont;</span>
        }

<span class="nc" id="L1136">        PhysicalFont physicalFont = null;</span>
        try {
            String name;

<span class="nc bnc" id="L1140" title="All 4 branches missed.">            switch (fontFormat) {</span>

            case FONTFORMAT_TRUETYPE:
<span class="nc" id="L1143">                int fn = 0;</span>
                TrueTypeFont ttf;
                do {
<span class="nc" id="L1146">                    ttf = new TrueTypeFont(fileName, nativeNames, fn++,</span>
                                           useJavaRasterizer);
<span class="nc" id="L1148">                    PhysicalFont pf = addToFontList(ttf, fontRank);</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">                    if (physicalFont == null) {</span>
<span class="nc" id="L1150">                        physicalFont = pf;</span>
                    }
                }
<span class="nc bnc" id="L1153" title="All 2 branches missed.">                while (fn &lt; ttf.getFontCount());</span>
<span class="nc" id="L1154">                break;</span>

            case FONTFORMAT_TYPE1:
<span class="nc" id="L1157">                Type1Font t1f = new Type1Font(fileName, nativeNames);</span>
<span class="nc" id="L1158">                physicalFont = addToFontList(t1f, fontRank);</span>
<span class="nc" id="L1159">                break;</span>

            case FONTFORMAT_NATIVE:
<span class="nc" id="L1162">                NativeFont nf = new NativeFont(fileName, false);</span>
<span class="nc" id="L1163">                physicalFont = addToFontList(nf, fontRank);</span>
            default:

            }
<span class="nc bnc" id="L1167" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L1168">                FontUtilities.getLogger()</span>
<span class="nc" id="L1169">                      .info(&quot;Registered file &quot; + fileName + &quot; as font &quot; +</span>
                            physicalFont + &quot; rank=&quot;  + fontRank);
            }
<span class="nc" id="L1172">        } catch (FontFormatException ffe) {</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L1174">                FontUtilities.getLogger().warning(&quot;Unusable font: &quot; +</span>
<span class="nc" id="L1175">                               fileName + &quot; &quot; + ffe.toString());</span>
            }
<span class="nc" id="L1177">        }</span>
<span class="nc bnc" id="L1178" title="All 4 branches missed.">        if (physicalFont != null &amp;&amp;</span>
            fontFormat != FONTFORMAT_NATIVE) {
<span class="nc" id="L1180">            registeredFonts.put(fileName, physicalFont);</span>
        }
<span class="nc" id="L1182">        return physicalFont;</span>
    }

    public void registerFonts(String[] fileNames,
                              String[][] nativeNames,
                              int fontCount,
                              int fontFormat,
                              boolean useJavaRasterizer,
                              int fontRank, boolean defer) {

<span class="nc bnc" id="L1192" title="All 2 branches missed.">        for (int i=0; i &lt; fontCount; i++) {</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            if (defer) {</span>
<span class="nc" id="L1194">                registerDeferredFont(fileNames[i],fileNames[i], nativeNames[i],</span>
                                     fontFormat, useJavaRasterizer, fontRank);
            } else {
<span class="nc" id="L1197">                registerFontFile(fileNames[i], nativeNames[i],</span>
                                 fontFormat, useJavaRasterizer, fontRank);
            }
        }
<span class="nc" id="L1201">    }</span>

    /*
     * This is the Physical font used when some other font on the system
     * can't be located. There has to be at least one font or the font
     * system is not useful and the graphics environment cannot sustain
     * the Java platform.
     */
    public PhysicalFont getDefaultPhysicalFont() {
<span class="nc bnc" id="L1210" title="All 2 branches missed.">        if (defaultPhysicalFont == null) {</span>
            /* findFont2D will load all fonts before giving up the search.
             * If the JRE Lucida isn't found (eg because the JRE fonts
             * directory is missing), it could find another version of Lucida
             * from the host system. This is OK because at that point we are
             * trying to gracefully handle/recover from a system
             * misconfiguration and this is probably a reasonable substitution.
             */
<span class="nc" id="L1218">            defaultPhysicalFont = (PhysicalFont)</span>
<span class="nc" id="L1219">                findFont2D(&quot;Lucida Sans Regular&quot;, Font.PLAIN, NO_FALLBACK);</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">            if (defaultPhysicalFont == null) {</span>
<span class="nc" id="L1221">                defaultPhysicalFont = (PhysicalFont)</span>
<span class="nc" id="L1222">                    findFont2D(&quot;Arial&quot;, Font.PLAIN, NO_FALLBACK);</span>
            }
<span class="nc bnc" id="L1224" title="All 2 branches missed.">            if (defaultPhysicalFont == null) {</span>
                /* Because of the findFont2D call above, if we reach here, we
                 * know all fonts have already been loaded, just accept any
                 * match at this point. If this fails we are in real trouble
                 * and I don't know how to recover from there being absolutely
                 * no fonts anywhere on the system.
                 */
<span class="nc" id="L1231">                Iterator i = physicalFonts.values().iterator();</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">                if (i.hasNext()) {</span>
<span class="nc" id="L1233">                    defaultPhysicalFont = (PhysicalFont)i.next();</span>
                } else {
<span class="nc" id="L1235">                    throw new Error(&quot;Probable fatal error:No fonts found.&quot;);</span>
                }
            }
        }
<span class="nc" id="L1239">        return defaultPhysicalFont;</span>
    }

    public Font2D getDefaultLogicalFont(int style) {
<span class="nc" id="L1243">        return findFont2D(&quot;dialog&quot;, style, NO_FALLBACK);</span>
    }

    /*
     * return String representation of style prepended with &quot;.&quot;
     * This is useful for performance to avoid unnecessary string operations.
     */
    private static String dotStyleStr(int num) {
<span class="nc bnc" id="L1251" title="All 4 branches missed.">        switch(num){</span>
          case Font.BOLD:
<span class="nc" id="L1253">            return &quot;.bold&quot;;</span>
          case Font.ITALIC:
<span class="nc" id="L1255">            return &quot;.italic&quot;;</span>
          case Font.ITALIC | Font.BOLD:
<span class="nc" id="L1257">            return &quot;.bolditalic&quot;;</span>
          default:
<span class="nc" id="L1259">            return &quot;.plain&quot;;</span>
        }
    }

    /* This is implemented only on windows and is called from code that
     * executes only on windows. This isn't pretty but its not a precedent
     * in this file. This very probably should be cleaned up at some point.
     */
    protected void
        populateFontFileNameMap(HashMap&lt;String,String&gt; fontToFileMap,
                                HashMap&lt;String,String&gt; fontToFamilyNameMap,
                                HashMap&lt;String,ArrayList&lt;String&gt;&gt;
                                familyToFontListMap,
                                Locale locale) {
<span class="nc" id="L1273">    }</span>

    /* Obtained from Platform APIs (windows only)
     * Map from lower-case font full name to basename of font file.
     * Eg &quot;arial bold&quot; -&gt; ARIALBD.TTF.
     * For TTC files, there is a mapping for each font in the file.
     */
<span class="nc" id="L1280">    private HashMap&lt;String,String&gt; fontToFileMap = null;</span>

    /* Obtained from Platform APIs (windows only)
     * Map from lower-case font full name to the name of its font family
     * Eg &quot;arial bold&quot; -&gt; &quot;Arial&quot;
     */
<span class="nc" id="L1286">    private HashMap&lt;String,String&gt; fontToFamilyNameMap = null;</span>

    /* Obtained from Platform APIs (windows only)
     * Map from a lower-case family name to a list of full names of
     * the member fonts, eg:
     * &quot;arial&quot; -&gt; [&quot;Arial&quot;, &quot;Arial Bold&quot;, &quot;Arial Italic&quot;,&quot;Arial Bold Italic&quot;]
     */
<span class="nc" id="L1293">    private HashMap&lt;String,ArrayList&lt;String&gt;&gt; familyToFontListMap= null;</span>

    /* The directories which contain platform fonts */
<span class="nc" id="L1296">    private String[] pathDirs = null;</span>

    private boolean haveCheckedUnreferencedFontFiles;

    private String[] getFontFilesFromPath(boolean noType1) {
        final FilenameFilter filter;
<span class="nc bnc" id="L1302" title="All 2 branches missed.">        if (noType1) {</span>
<span class="nc" id="L1303">            filter = ttFilter;</span>
        } else {
<span class="nc" id="L1305">            filter = new TTorT1Filter();</span>
        }
<span class="nc" id="L1307">        return (String[])AccessController.doPrivileged(new PrivilegedAction() {</span>
            public Object run() {
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                if (pathDirs.length == 1) {</span>
<span class="nc" id="L1310">                    File dir = new File(pathDirs[0]);</span>
<span class="nc" id="L1311">                    String[] files = dir.list(filter);</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">                    if (files == null) {</span>
<span class="nc" id="L1313">                        return new String[0];</span>
                    }
<span class="nc bnc" id="L1315" title="All 2 branches missed.">                    for (int f=0; f&lt;files.length; f++) {</span>
<span class="nc" id="L1316">                        files[f] = files[f].toLowerCase();</span>
                    }
<span class="nc" id="L1318">                    return files;</span>
                } else {
<span class="nc" id="L1320">                    ArrayList&lt;String&gt; fileList = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">                    for (int i = 0; i&lt; pathDirs.length; i++) {</span>
<span class="nc" id="L1322">                        File dir = new File(pathDirs[i]);</span>
<span class="nc" id="L1323">                        String[] files = dir.list(filter);</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">                        if (files == null) {</span>
<span class="nc" id="L1325">                            continue;</span>
                        }
<span class="nc bnc" id="L1327" title="All 2 branches missed.">                        for (int f=0; f&lt;files.length ; f++) {</span>
<span class="nc" id="L1328">                            fileList.add(files[f].toLowerCase());</span>
                        }
                    }
<span class="nc" id="L1331">                    return fileList.toArray(STR_ARRAY);</span>
                }
            }
        });
    }

    /* This is needed since some windows registry names don't match
     * the font names.
     * - UPC styled font names have a double space, but the
     * registry entry mapping to a file doesn't.
     * - Marlett is in a hidden file not listed in the registry
     * - The registry advertises that the file david.ttf contains a
     * font with the full name &quot;David Regular&quot; when in fact its
     * just &quot;David&quot;.
     * Directly fix up these known cases as this is faster.
     * If a font which doesn't match these known cases has no file,
     * it may be a font that has been temporarily added to the known set
     * or it may be an installed font with a missing registry entry.
     * Installed fonts are those in the windows font directories.
     * Make a best effort attempt to locate these.
     * We obtain the list of TrueType fonts in these directories and
     * filter out all the font files we already know about from the registry.
     * What remains may be &quot;bad&quot; fonts, duplicate fonts, or perhaps the
     * missing font(s) we are looking for.
     * Open each of these files to find out.
     */
    private void resolveWindowsFonts() {

<span class="nc" id="L1359">        ArrayList&lt;String&gt; unmappedFontNames = null;</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">        for (String font : fontToFamilyNameMap.keySet()) {</span>
<span class="nc" id="L1361">            String file = fontToFileMap.get(font);</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">            if (file == null) {</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">                if (font.indexOf(&quot;  &quot;) &gt; 0) {</span>
<span class="nc" id="L1364">                    String newName = font.replaceFirst(&quot;  &quot;, &quot; &quot;);</span>
<span class="nc" id="L1365">                    file = fontToFileMap.get(newName);</span>
                    /* If this name exists and isn't for a valid name
                     * replace the mapping to the file with this font
                     */
<span class="nc bnc" id="L1369" title="All 2 branches missed.">                    if (file != null &amp;&amp;</span>
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                        !fontToFamilyNameMap.containsKey(newName)) {</span>
<span class="nc" id="L1371">                        fontToFileMap.remove(newName);</span>
<span class="nc" id="L1372">                        fontToFileMap.put(font, file);</span>
                    }
<span class="nc bnc" id="L1374" title="All 2 branches missed.">                } else if (font.equals(&quot;marlett&quot;)) {</span>
<span class="nc" id="L1375">                    fontToFileMap.put(font, &quot;marlett.ttf&quot;);</span>
<span class="nc bnc" id="L1376" title="All 2 branches missed.">                } else if (font.equals(&quot;david&quot;)) {</span>
<span class="nc" id="L1377">                    file = fontToFileMap.get(&quot;david regular&quot;);</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">                    if (file != null) {</span>
<span class="nc" id="L1379">                        fontToFileMap.remove(&quot;david regular&quot;);</span>
<span class="nc" id="L1380">                        fontToFileMap.put(&quot;david&quot;, file);</span>
                    }
                } else {
<span class="nc bnc" id="L1383" title="All 2 branches missed.">                    if (unmappedFontNames == null) {</span>
<span class="nc" id="L1384">                        unmappedFontNames = new ArrayList&lt;String&gt;();</span>
                    }
<span class="nc" id="L1386">                    unmappedFontNames.add(font);</span>
                }
            }
<span class="nc" id="L1389">        }</span>

<span class="nc bnc" id="L1391" title="All 2 branches missed.">        if (unmappedFontNames != null) {</span>
<span class="nc" id="L1392">            HashSet&lt;String&gt; unmappedFontFiles = new HashSet&lt;String&gt;();</span>

            /* Every font key in fontToFileMap ought to correspond to a
             * font key in fontToFamilyNameMap. Entries that don't seem
             * to correspond are likely fonts that were named differently
             * by GDI than in the registry. One known cause of this is when
             * Windows has had its regional settings changed so that from
             * GDI we get a localised (eg Chinese or Japanese) name for the
             * font, but the registry retains the English version of the name
             * that corresponded to the &quot;install&quot; locale for windows.
             * Since we are in this code block because there are unmapped
             * font names, we can look to find unused font-&gt;file mappings
             * and then open the files to read the names. We don't generally
             * want to open font files, as its a performance hit, but this
             * occurs only for a small number of fonts on specific system
             * configs - ie is believed that a &quot;true&quot; Japanese windows would
             * have JA names in the registry too.
             * Clone fontToFileMap and remove from the clone all keys which
             * match a fontToFamilyNameMap key. What remains maps to the
             * files we want to open to find the fonts GDI returned.
             * A font in such a file is added to the fontToFileMap after
             * checking its one of the unmappedFontNames we are looking for.
             * The original name that didn't map is removed from fontToFileMap
             * so essentially this &quot;fixes up&quot; fontToFileMap to use the same
             * name as GDI.
             * Also note that typically the fonts for which this occurs in
             * CJK locales are TTC fonts and not all fonts in a TTC may have
             * localised names. Eg MSGOTHIC.TTC contains 3 fonts and one of
             * them &quot;MS UI Gothic&quot; has no JA name whereas the other two do.
             * So not every font in these files is unmapped or new.
             */
<span class="nc" id="L1423">            HashMap&lt;String,String&gt; ffmapCopy =</span>
<span class="nc" id="L1424">                (HashMap&lt;String,String&gt;)(fontToFileMap.clone());</span>
<span class="nc bnc" id="L1425" title="All 2 branches missed.">            for (String key : fontToFamilyNameMap.keySet()) {</span>
<span class="nc" id="L1426">                ffmapCopy.remove(key);</span>
<span class="nc" id="L1427">            }</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">            for (String key : ffmapCopy.keySet()) {</span>
<span class="nc" id="L1429">                unmappedFontFiles.add(ffmapCopy.get(key));</span>
<span class="nc" id="L1430">                fontToFileMap.remove(key);</span>
<span class="nc" id="L1431">            }</span>

<span class="nc" id="L1433">            resolveFontFiles(unmappedFontFiles, unmappedFontNames);</span>

            /* If there are still unmapped font names, this means there's
             * something that wasn't in the registry. We need to get all
             * the font files directly and look at the ones that weren't
             * found in the registry.
             */
<span class="nc bnc" id="L1440" title="All 2 branches missed.">            if (unmappedFontNames.size() &gt; 0) {</span>

                /* getFontFilesFromPath() returns all lower case names.
                 * To compare we also need lower case
                 * versions of the names from the registry.
                 */
<span class="nc" id="L1446">                ArrayList&lt;String&gt; registryFiles = new ArrayList&lt;String&gt;();</span>

<span class="nc bnc" id="L1448" title="All 2 branches missed.">                for (String regFile : fontToFileMap.values()) {</span>
<span class="nc" id="L1449">                    registryFiles.add(regFile.toLowerCase());</span>
<span class="nc" id="L1450">                }</span>
                /* We don't look for Type1 files here as windows will
                 * not enumerate these, so aren't useful in reconciling
                 * GDI's unmapped files. We do find these later when
                 * we enumerate all fonts.
                 */
<span class="nc bnc" id="L1456" title="All 2 branches missed.">                for (String pathFile : getFontFilesFromPath(true)) {</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">                    if (!registryFiles.contains(pathFile)) {</span>
<span class="nc" id="L1458">                        unmappedFontFiles.add(pathFile);</span>
                    }
                }

<span class="nc" id="L1462">                resolveFontFiles(unmappedFontFiles, unmappedFontNames);</span>
            }

            /* remove from the set of names that will be returned to the
             * user any fonts that can't be mapped to files.
             */
<span class="nc bnc" id="L1468" title="All 2 branches missed.">            if (unmappedFontNames.size() &gt; 0) {</span>
<span class="nc" id="L1469">                int sz = unmappedFontNames.size();</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">                for (int i=0; i&lt;sz; i++) {</span>
<span class="nc" id="L1471">                    String name = unmappedFontNames.get(i);</span>
<span class="nc" id="L1472">                    String familyName = fontToFamilyNameMap.get(name);</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">                    if (familyName != null) {</span>
<span class="nc" id="L1474">                        ArrayList family = familyToFontListMap.get(familyName);</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">                        if (family != null) {</span>
<span class="nc bnc" id="L1476" title="All 2 branches missed.">                            if (family.size() &lt;= 1) {</span>
<span class="nc" id="L1477">                                familyToFontListMap.remove(familyName);</span>
                            }
                        }
                    }
<span class="nc" id="L1481">                    fontToFamilyNameMap.remove(name);</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">                    if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L1483">                        FontUtilities.getLogger()</span>
<span class="nc" id="L1484">                                             .info(&quot;No file for font:&quot; + name);</span>
                    }
                }
            }
        }
<span class="nc" id="L1489">    }</span>

    /**
     * In some cases windows may have fonts in the fonts folder that
     * don't show up in the registry or in the GDI calls to enumerate fonts.
     * The only way to find these is to list the directory. We invoke this
     * only in getAllFonts/Families, so most searches for a specific
     * font that is satisfied by the GDI/registry calls don't take the
     * additional hit of listing the directory. This hit is small enough
     * that its not significant in these 'enumerate all the fonts' cases.
     * The basic approach is to cross-reference the files windows found
     * with the ones in the directory listing approach, and for each
     * in the latter list that is missing from the former list, register it.
     */
    private synchronized void checkForUnreferencedFontFiles() {
<span class="nc bnc" id="L1504" title="All 2 branches missed.">        if (haveCheckedUnreferencedFontFiles) {</span>
<span class="nc" id="L1505">            return;</span>
        }
<span class="nc" id="L1507">        haveCheckedUnreferencedFontFiles = true;</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">        if (!FontUtilities.isWindows) {</span>
<span class="nc" id="L1509">            return;</span>
        }
        /* getFontFilesFromPath() returns all lower case names.
         * To compare we also need lower case
         * versions of the names from the registry.
         */
<span class="nc" id="L1515">        ArrayList&lt;String&gt; registryFiles = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">        for (String regFile : fontToFileMap.values()) {</span>
<span class="nc" id="L1517">            registryFiles.add(regFile.toLowerCase());</span>
<span class="nc" id="L1518">        }</span>

        /* To avoid any issues with concurrent modification, create
         * copies of the existing maps, add the new fonts into these
         * and then replace the references to the old ones with the
         * new maps. ConcurrentHashmap is another option but its a lot
         * more changes and with this exception, these maps are intended
         * to be static.
         */
<span class="nc" id="L1527">        HashMap&lt;String,String&gt; fontToFileMap2 = null;</span>
<span class="nc" id="L1528">        HashMap&lt;String,String&gt; fontToFamilyNameMap2 = null;</span>
<span class="nc" id="L1529">        HashMap&lt;String,ArrayList&lt;String&gt;&gt; familyToFontListMap2 = null;;</span>

<span class="nc bnc" id="L1531" title="All 2 branches missed.">        for (String pathFile : getFontFilesFromPath(false)) {</span>
<span class="nc bnc" id="L1532" title="All 2 branches missed.">            if (!registryFiles.contains(pathFile)) {</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">                if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L1534">                    FontUtilities.getLogger()</span>
<span class="nc" id="L1535">                                 .info(&quot;Found non-registry file : &quot; + pathFile);</span>
                }
<span class="nc" id="L1537">                PhysicalFont f = registerFontFile(getPathName(pathFile));</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">                if (f == null) {</span>
<span class="nc" id="L1539">                    continue;</span>
                }
<span class="nc bnc" id="L1541" title="All 2 branches missed.">                if (fontToFileMap2 == null) {</span>
<span class="nc" id="L1542">                    fontToFileMap2 = new HashMap&lt;String,String&gt;(fontToFileMap);</span>
<span class="nc" id="L1543">                    fontToFamilyNameMap2 =</span>
                        new HashMap&lt;String,String&gt;(fontToFamilyNameMap);
<span class="nc" id="L1545">                    familyToFontListMap2 = new</span>
                        HashMap&lt;String,ArrayList&lt;String&gt;&gt;(familyToFontListMap);
                }
<span class="nc" id="L1548">                String fontName = f.getFontName(null);</span>
<span class="nc" id="L1549">                String family = f.getFamilyName(null);</span>
<span class="nc" id="L1550">                String familyLC = family.toLowerCase();</span>
<span class="nc" id="L1551">                fontToFamilyNameMap2.put(fontName, family);</span>
<span class="nc" id="L1552">                fontToFileMap2.put(fontName, pathFile);</span>
<span class="nc" id="L1553">                ArrayList&lt;String&gt; fonts = familyToFontListMap2.get(familyLC);</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">                if (fonts == null) {</span>
<span class="nc" id="L1555">                    fonts = new ArrayList&lt;String&gt;();</span>
                } else {
<span class="nc" id="L1557">                    fonts = new ArrayList&lt;String&gt;(fonts);</span>
                }
<span class="nc" id="L1559">                fonts.add(fontName);</span>
<span class="nc" id="L1560">                familyToFontListMap2.put(familyLC, fonts);</span>
            }
        }
<span class="nc bnc" id="L1563" title="All 2 branches missed.">        if (fontToFileMap2 != null) {</span>
<span class="nc" id="L1564">            fontToFileMap = fontToFileMap2;</span>
<span class="nc" id="L1565">            familyToFontListMap = familyToFontListMap2;</span>
<span class="nc" id="L1566">            fontToFamilyNameMap = fontToFamilyNameMap2;</span>
        }
<span class="nc" id="L1568">    }</span>

    private void resolveFontFiles(HashSet&lt;String&gt; unmappedFiles,
                                  ArrayList&lt;String&gt; unmappedFonts) {

<span class="nc" id="L1573">        Locale l = SunToolkit.getStartupLocale();</span>

<span class="nc bnc" id="L1575" title="All 2 branches missed.">        for (String file : unmappedFiles) {</span>
            try {
<span class="nc" id="L1577">                int fn = 0;</span>
                TrueTypeFont ttf;
<span class="nc" id="L1579">                String fullPath = getPathName(file);</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">                if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L1581">                    FontUtilities.getLogger()</span>
<span class="nc" id="L1582">                                   .info(&quot;Trying to resolve file &quot; + fullPath);</span>
                }
                do {
<span class="nc" id="L1585">                    ttf = new TrueTypeFont(fullPath, null, fn++, false);</span>
                    //  prefer the font's locale name.
<span class="nc" id="L1587">                    String fontName = ttf.getFontName(l).toLowerCase();</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">                    if (unmappedFonts.contains(fontName)) {</span>
<span class="nc" id="L1589">                        fontToFileMap.put(fontName, file);</span>
<span class="nc" id="L1590">                        unmappedFonts.remove(fontName);</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">                        if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L1592">                            FontUtilities.getLogger()</span>
<span class="nc" id="L1593">                                  .info(&quot;Resolved absent registry entry for &quot; +</span>
                                        fontName + &quot; located in &quot; + fullPath);
                        }
                    }
                }
<span class="nc bnc" id="L1598" title="All 2 branches missed.">                while (fn &lt; ttf.getFontCount());</span>
<span class="nc" id="L1599">            } catch (Exception e) {</span>
<span class="nc" id="L1600">            }</span>
<span class="nc" id="L1601">        }</span>
<span class="nc" id="L1602">    }</span>

    /* Hardwire the English names and expected file names of fonts
     * commonly used at start up. Avoiding until later even the small
     * cost of calling platform APIs to locate these can help.
     * The code that registers these fonts needs to &quot;bail&quot; if any
     * of the files do not exist, so it will verify the existence of
     * all non-null file names first.
     * They are added in to a map with nominally the first
     * word in the name of the family as the key. In all the cases
     * we are using the the family name is a single word, and as is
     * more or less required the family name is the initial sequence
     * in a full name. So lookup first finds the matching description,
     * then registers the whole family, returning the right font.
     */
<span class="nc" id="L1617">    public static class FamilyDescription {</span>
        public String familyName;
        public String plainFullName;
        public String boldFullName;
        public String italicFullName;
        public String boldItalicFullName;
        public String plainFileName;
        public String boldFileName;
        public String italicFileName;
        public String boldItalicFileName;
    }

    static HashMap&lt;String, FamilyDescription&gt; platformFontMap;

    /**
     * default implementation does nothing.
     */
    public HashMap&lt;String, FamilyDescription&gt; populateHardcodedFileNameMap() {
<span class="nc" id="L1635">        return new HashMap&lt;String, FamilyDescription&gt;(0);</span>
    }

    Font2D findFontFromPlatformMap(String lcName, int style) {
<span class="nc bnc" id="L1639" title="All 2 branches missed.">        if (platformFontMap == null) {</span>
<span class="nc" id="L1640">            platformFontMap = populateHardcodedFileNameMap();</span>
        }

<span class="nc bnc" id="L1643" title="All 4 branches missed.">        if (platformFontMap == null || platformFontMap.size() == 0) {</span>
<span class="nc" id="L1644">            return null;</span>
        }

<span class="nc" id="L1647">        int spaceIndex = lcName.indexOf(' ');</span>
<span class="nc" id="L1648">        String firstWord = lcName;</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">        if (spaceIndex &gt; 0) {</span>
<span class="nc" id="L1650">            firstWord = lcName.substring(0, spaceIndex);</span>
        }

<span class="nc" id="L1653">        FamilyDescription fd = platformFontMap.get(firstWord);</span>
<span class="nc bnc" id="L1654" title="All 2 branches missed.">        if (fd == null) {</span>
<span class="nc" id="L1655">            return null;</span>
        }
        /* Once we've established that its at least the first word,
         * we need to dig deeper to make sure its a match for either
         * a full name, or the family name, to make sure its not
         * a request for some other font that just happens to start
         * with the same first word.
         */
<span class="nc" id="L1663">        int styleIndex = -1;</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">        if (lcName.equalsIgnoreCase(fd.plainFullName)) {</span>
<span class="nc" id="L1665">            styleIndex = 0;</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">        } else if (lcName.equalsIgnoreCase(fd.boldFullName)) {</span>
<span class="nc" id="L1667">            styleIndex = 1;</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">        } else if (lcName.equalsIgnoreCase(fd.italicFullName)) {</span>
<span class="nc" id="L1669">            styleIndex = 2;</span>
<span class="nc bnc" id="L1670" title="All 2 branches missed.">        } else if (lcName.equalsIgnoreCase(fd.boldItalicFullName)) {</span>
<span class="nc" id="L1671">            styleIndex = 3;</span>
        }
<span class="nc bnc" id="L1673" title="All 4 branches missed.">        if (styleIndex == -1 &amp;&amp; !lcName.equalsIgnoreCase(fd.familyName)) {</span>
<span class="nc" id="L1674">            return null;</span>
        }

<span class="nc" id="L1677">        String plainFile = null, boldFile = null,</span>
<span class="nc" id="L1678">            italicFile = null, boldItalicFile = null;</span>

<span class="nc" id="L1680">        boolean failure = false;</span>
        /* In a terminal server config, its possible that getPathName()
         * will return null, if the file doesn't exist, hence the null
         * checks on return. But in the normal client config we need to
         * follow this up with a check to see if all the files really
         * exist for the non-null paths.
         */
<span class="nc" id="L1687">         getPlatformFontDirs(noType1Font);</span>

<span class="nc bnc" id="L1689" title="All 2 branches missed.">        if (fd.plainFileName != null) {</span>
<span class="nc" id="L1690">            plainFile = getPathName(fd.plainFileName);</span>
<span class="nc bnc" id="L1691" title="All 2 branches missed.">            if (plainFile == null) {</span>
<span class="nc" id="L1692">                failure = true;</span>
            }
        }

<span class="nc bnc" id="L1696" title="All 2 branches missed.">        if (fd.boldFileName != null) {</span>
<span class="nc" id="L1697">            boldFile = getPathName(fd.boldFileName);</span>
<span class="nc bnc" id="L1698" title="All 2 branches missed.">            if (boldFile == null) {</span>
<span class="nc" id="L1699">                failure = true;</span>
            }
        }

<span class="nc bnc" id="L1703" title="All 2 branches missed.">        if (fd.italicFileName != null) {</span>
<span class="nc" id="L1704">            italicFile = getPathName(fd.italicFileName);</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">            if (italicFile == null) {</span>
<span class="nc" id="L1706">                failure = true;</span>
            }
        }

<span class="nc bnc" id="L1710" title="All 2 branches missed.">        if (fd.boldItalicFileName != null) {</span>
<span class="nc" id="L1711">            boldItalicFile = getPathName(fd.boldItalicFileName);</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">            if (boldItalicFile == null) {</span>
<span class="nc" id="L1713">                failure = true;</span>
            }
        }

<span class="nc bnc" id="L1717" title="All 2 branches missed.">        if (failure) {</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L1719">                FontUtilities.getLogger().</span>
<span class="nc" id="L1720">                    info(&quot;Hardcoded file missing looking for &quot; + lcName);</span>
            }
<span class="nc" id="L1722">            platformFontMap.remove(firstWord);</span>
<span class="nc" id="L1723">            return null;</span>
        }

        /* Some of these may be null,as not all styles have to exist */
<span class="nc" id="L1727">        final String[] files = {</span>
            plainFile, boldFile, italicFile, boldItalicFile } ;

<span class="nc" id="L1730">        failure = java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L1731">                 new java.security.PrivilegedAction&lt;Boolean&gt;() {</span>
                     public Boolean run() {
<span class="nc bnc" id="L1733" title="All 2 branches missed.">                         for (int i=0; i&lt;files.length; i++) {</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">                             if (files[i] == null) {</span>
<span class="nc" id="L1735">                                 continue;</span>
                             }
<span class="nc" id="L1737">                             File f = new File(files[i]);</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">                             if (!f.exists()) {</span>
<span class="nc" id="L1739">                                 return Boolean.TRUE;</span>
                             }
                         }
<span class="nc" id="L1742">                         return Boolean.FALSE;</span>
                     }
                 });

<span class="nc bnc" id="L1746" title="All 2 branches missed.">        if (failure) {</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L1748">                FontUtilities.getLogger().</span>
<span class="nc" id="L1749">                    info(&quot;Hardcoded file missing looking for &quot; + lcName);</span>
            }
<span class="nc" id="L1751">            platformFontMap.remove(firstWord);</span>
<span class="nc" id="L1752">            return null;</span>
        }

        /* If we reach here we know that we have all the files we
         * expect, so all should be fine so long as the contents
         * are what we'd expect. Now on to registering the fonts.
         * Currently this code only looks for TrueType fonts, so format
         * and rank can be specified without looking at the filename.
         */
<span class="nc" id="L1761">        Font2D font = null;</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">        for (int f=0;f&lt;files.length;f++) {</span>
<span class="nc bnc" id="L1763" title="All 2 branches missed.">            if (files[f] == null) {</span>
<span class="nc" id="L1764">                continue;</span>
            }
<span class="nc" id="L1766">            PhysicalFont pf =</span>
<span class="nc" id="L1767">                registerFontFile(files[f], null,</span>
                                 FONTFORMAT_TRUETYPE, false, Font2D.TTF_RANK);
<span class="nc bnc" id="L1769" title="All 2 branches missed.">            if (f == styleIndex) {</span>
<span class="nc" id="L1770">                font = pf;</span>
            }
        }


        /* Two general cases need a bit more work here.
         * 1) If font is null, then it was perhaps a request for a
         * non-existent font, such as &quot;Tahoma Italic&quot;, or a family name -
         * where family and full name of the plain font differ.
         * Fall back to finding the closest one in the family.
         * This could still fail if a client specified &quot;Segoe&quot; instead of
         * &quot;Segoe UI&quot;.
         * 2) The request is of the form &quot;MyFont Bold&quot;, style=Font.ITALIC,
         * and so we want to see if there's a Bold Italic font, or
         * &quot;MyFamily&quot;, style=Font.BOLD, and we may have matched the plain,
         * but now need to revise that to the BOLD font.
         */
<span class="nc" id="L1787">        FontFamily fontFamily = FontFamily.getFamily(fd.familyName);</span>
<span class="nc bnc" id="L1788" title="All 2 branches missed.">        if (fontFamily != null) {</span>
<span class="nc bnc" id="L1789" title="All 2 branches missed.">            if (font == null) {</span>
<span class="nc" id="L1790">                font = fontFamily.getFont(style);</span>
<span class="nc bnc" id="L1791" title="All 2 branches missed.">                if (font == null) {</span>
<span class="nc" id="L1792">                    font = fontFamily.getClosestStyle(style);</span>
                }
<span class="nc bnc" id="L1794" title="All 4 branches missed.">            } else if (style &gt; 0 &amp;&amp; style != font.style) {</span>
<span class="nc" id="L1795">                style |= font.style;</span>
<span class="nc" id="L1796">                font = fontFamily.getFont(style);</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">                if (font == null) {</span>
<span class="nc" id="L1798">                    font = fontFamily.getClosestStyle(style);</span>
                }
            }
        }

<span class="nc" id="L1803">        return font;</span>
    }
    private synchronized HashMap&lt;String,String&gt; getFullNameToFileMap() {
<span class="nc bnc" id="L1806" title="All 2 branches missed.">        if (fontToFileMap == null) {</span>

<span class="nc" id="L1808">            pathDirs = getPlatformFontDirs(noType1Font);</span>

<span class="nc" id="L1810">            fontToFileMap = new HashMap&lt;String,String&gt;(100);</span>
<span class="nc" id="L1811">            fontToFamilyNameMap = new HashMap&lt;String,String&gt;(100);</span>
<span class="nc" id="L1812">            familyToFontListMap = new HashMap&lt;String,ArrayList&lt;String&gt;&gt;(50);</span>
<span class="nc" id="L1813">            populateFontFileNameMap(fontToFileMap,</span>
                                    fontToFamilyNameMap,
                                    familyToFontListMap,
                                    Locale.ENGLISH);
<span class="nc bnc" id="L1817" title="All 2 branches missed.">            if (FontUtilities.isWindows) {</span>
<span class="nc" id="L1818">                resolveWindowsFonts();</span>
            }
<span class="nc bnc" id="L1820" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L1821">                logPlatformFontInfo();</span>
            }
        }
<span class="nc" id="L1824">        return fontToFileMap;</span>
    }

    private void logPlatformFontInfo() {
<span class="nc" id="L1828">        PlatformLogger logger = FontUtilities.getLogger();</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">        for (int i=0; i&lt; pathDirs.length;i++) {</span>
<span class="nc" id="L1830">            logger.info(&quot;fontdir=&quot;+pathDirs[i]);</span>
        }
<span class="nc bnc" id="L1832" title="All 2 branches missed.">        for (String keyName : fontToFileMap.keySet()) {</span>
<span class="nc" id="L1833">            logger.info(&quot;font=&quot;+keyName+&quot; file=&quot;+ fontToFileMap.get(keyName));</span>
<span class="nc" id="L1834">        }</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">        for (String keyName : fontToFamilyNameMap.keySet()) {</span>
<span class="nc" id="L1836">            logger.info(&quot;font=&quot;+keyName+&quot; family=&quot;+</span>
<span class="nc" id="L1837">                        fontToFamilyNameMap.get(keyName));</span>
<span class="nc" id="L1838">        }</span>
<span class="nc bnc" id="L1839" title="All 2 branches missed.">        for (String keyName : familyToFontListMap.keySet()) {</span>
<span class="nc" id="L1840">            logger.info(&quot;family=&quot;+keyName+ &quot; fonts=&quot;+</span>
<span class="nc" id="L1841">                        familyToFontListMap.get(keyName));</span>
<span class="nc" id="L1842">        }</span>
<span class="nc" id="L1843">    }</span>

    /* Note this return list excludes logical fonts and JRE fonts */
    protected String[] getFontNamesFromPlatform() {
<span class="nc bnc" id="L1847" title="All 2 branches missed.">        if (getFullNameToFileMap().size() == 0) {</span>
<span class="nc" id="L1848">            return null;</span>
        }
<span class="nc" id="L1850">        checkForUnreferencedFontFiles();</span>
        /* This odd code with TreeMap is used to preserve a historical
         * behaviour wrt the sorting order .. */
<span class="nc" id="L1853">        ArrayList&lt;String&gt; fontNames = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L1854" title="All 2 branches missed.">        for (ArrayList&lt;String&gt; a : familyToFontListMap.values()) {</span>
<span class="nc bnc" id="L1855" title="All 2 branches missed.">            for (String s : a) {</span>
<span class="nc" id="L1856">                fontNames.add(s);</span>
<span class="nc" id="L1857">            }</span>
<span class="nc" id="L1858">        }</span>
<span class="nc" id="L1859">        return fontNames.toArray(STR_ARRAY);</span>
    }

    public boolean gotFontsFromPlatform() {
<span class="nc bnc" id="L1863" title="All 2 branches missed.">        return getFullNameToFileMap().size() != 0;</span>
    }

    public String getFileNameForFontName(String fontName) {
<span class="nc" id="L1867">        String fontNameLC = fontName.toLowerCase(Locale.ENGLISH);</span>
<span class="nc" id="L1868">        return fontToFileMap.get(fontNameLC);</span>
    }

    private PhysicalFont registerFontFile(String file) {
<span class="nc bnc" id="L1872" title="All 2 branches missed.">        if (new File(file).isAbsolute() &amp;&amp;</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">            !registeredFonts.contains(file)) {</span>
<span class="nc" id="L1874">            int fontFormat = FONTFORMAT_NONE;</span>
<span class="nc" id="L1875">            int fontRank = Font2D.UNKNOWN_RANK;</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">            if (ttFilter.accept(null, file)) {</span>
<span class="nc" id="L1877">                fontFormat = FONTFORMAT_TRUETYPE;</span>
<span class="nc" id="L1878">                fontRank = Font2D.TTF_RANK;</span>
<span class="nc" id="L1879">            } else if</span>
<span class="nc bnc" id="L1880" title="All 2 branches missed.">                (t1Filter.accept(null, file)) {</span>
<span class="nc" id="L1881">                fontFormat = FONTFORMAT_TYPE1;</span>
<span class="nc" id="L1882">                fontRank = Font2D.TYPE1_RANK;</span>
            }
<span class="nc bnc" id="L1884" title="All 2 branches missed.">            if (fontFormat == FONTFORMAT_NONE) {</span>
<span class="nc" id="L1885">                return null;</span>
            }
<span class="nc" id="L1887">            return registerFontFile(file, null, fontFormat, false, fontRank);</span>
        }
<span class="nc" id="L1889">        return null;</span>
    }

    /* Used to register any font files that are found by platform APIs
     * that weren't previously found in the standard font locations.
     * the isAbsolute() check is needed since that's whats stored in the
     * set, and on windows, the fonts in the system font directory that
     * are in the fontToFileMap are just basenames. We don't want to try
     * to register those again, but we do want to register other registry
     * installed fonts.
     */
    protected void registerOtherFontFiles(HashSet registeredFontFiles) {
<span class="nc bnc" id="L1901" title="All 2 branches missed.">        if (getFullNameToFileMap().size() == 0) {</span>
<span class="nc" id="L1902">            return;</span>
        }
<span class="nc bnc" id="L1904" title="All 2 branches missed.">        for (String file : fontToFileMap.values()) {</span>
<span class="nc" id="L1905">            registerFontFile(file);</span>
<span class="nc" id="L1906">        }</span>
<span class="nc" id="L1907">    }</span>

    public boolean
        getFamilyNamesFromPlatform(TreeMap&lt;String,String&gt; familyNames,
                                   Locale requestedLocale) {
<span class="nc bnc" id="L1912" title="All 2 branches missed.">        if (getFullNameToFileMap().size() == 0) {</span>
<span class="nc" id="L1913">            return false;</span>
        }
<span class="nc" id="L1915">        checkForUnreferencedFontFiles();</span>
<span class="nc bnc" id="L1916" title="All 2 branches missed.">        for (String name : fontToFamilyNameMap.values()) {</span>
<span class="nc" id="L1917">            familyNames.put(name.toLowerCase(requestedLocale), name);</span>
<span class="nc" id="L1918">        }</span>
<span class="nc" id="L1919">        return true;</span>
    }

    /* Path may be absolute or a base file name relative to one of
     * the platform font directories
     */
    private String getPathName(final String s) {
<span class="nc" id="L1926">        File f = new File(s);</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">        if (f.isAbsolute()) {</span>
<span class="nc" id="L1928">            return s;</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">        } else if (pathDirs.length==1) {</span>
<span class="nc" id="L1930">            return pathDirs[0] + File.separator + s;</span>
        } else {
<span class="nc" id="L1932">            String path = java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L1933">                 new java.security.PrivilegedAction&lt;String&gt;() {</span>
                     public String run() {
<span class="nc bnc" id="L1935" title="All 2 branches missed.">                         for (int p=0; p&lt;pathDirs.length; p++) {</span>
<span class="nc" id="L1936">                             File f = new File(pathDirs[p] +File.separator+ s);</span>
<span class="nc bnc" id="L1937" title="All 2 branches missed.">                             if (f.exists()) {</span>
<span class="nc" id="L1938">                                 return f.getAbsolutePath();</span>
                             }
                         }
<span class="nc" id="L1941">                         return null;</span>
                     }
                });
<span class="nc bnc" id="L1944" title="All 2 branches missed.">            if (path != null) {</span>
<span class="nc" id="L1945">                return path;</span>
            }
        }
<span class="nc" id="L1948">        return s; // shouldn't happen, but harmless</span>
    }

    /* lcName is required to be lower case for use as a key.
     * lcName may be a full name, or a family name, and style may
     * be specified in addition to either of these. So be sure to
     * get the right one. Since an app *could* ask for &quot;Foo Regular&quot;
     * and later ask for &quot;Foo Italic&quot;, if we don't register all the
     * styles, then logic in findFont2D may try to style the original
     * so we register the entire family if we get a match here.
     * This is still a big win because this code is invoked where
     * otherwise we would register all fonts.
     * It's also useful for the case where &quot;Foo Bold&quot; was specified with
     * style Font.ITALIC, as we would want in that case to try to return
     * &quot;Foo Bold Italic&quot; if it exists, and it is only by locating &quot;Foo Bold&quot;
     * and opening it that we really &quot;know&quot; it's Bold, and can look for
     * a font that supports that and the italic style.
     * The code in here is not overtly windows-specific but in fact it
     * is unlikely to be useful as is on other platforms. It is maintained
     * in this shared source file to be close to its sole client and
     * because so much of the logic is intertwined with the logic in
     * findFont2D.
     */
    private Font2D findFontFromPlatform(String lcName, int style) {
<span class="nc bnc" id="L1972" title="All 2 branches missed.">        if (getFullNameToFileMap().size() == 0) {</span>
<span class="nc" id="L1973">            return null;</span>
        }

<span class="nc" id="L1976">        ArrayList&lt;String&gt; family = null;</span>
<span class="nc" id="L1977">        String fontFile = null;</span>
<span class="nc" id="L1978">        String familyName = fontToFamilyNameMap.get(lcName);</span>
<span class="nc bnc" id="L1979" title="All 2 branches missed.">        if (familyName != null) {</span>
<span class="nc" id="L1980">            fontFile = fontToFileMap.get(lcName);</span>
<span class="nc" id="L1981">            family = familyToFontListMap.get</span>
<span class="nc" id="L1982">                (familyName.toLowerCase(Locale.ENGLISH));</span>
        } else {
<span class="nc" id="L1984">            family = familyToFontListMap.get(lcName); // is lcName is a family?</span>
<span class="nc bnc" id="L1985" title="All 4 branches missed.">            if (family != null &amp;&amp; family.size() &gt; 0) {</span>
<span class="nc" id="L1986">                String lcFontName = family.get(0).toLowerCase(Locale.ENGLISH);</span>
<span class="nc bnc" id="L1987" title="All 2 branches missed.">                if (lcFontName != null) {</span>
<span class="nc" id="L1988">                    familyName = fontToFamilyNameMap.get(lcFontName);</span>
                }
            }
        }
<span class="nc bnc" id="L1992" title="All 4 branches missed.">        if (family == null || familyName == null) {</span>
<span class="nc" id="L1993">            return null;</span>
        }
<span class="nc" id="L1995">        String [] fontList = (String[])family.toArray(STR_ARRAY);</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">        if (fontList.length == 0) {</span>
<span class="nc" id="L1997">            return null;</span>
        }

        /* first check that for every font in this family we can find
         * a font file. The specific reason for doing this is that
         * in at least one case on Windows a font has the face name &quot;David&quot;
         * but the registry entry is &quot;David Regular&quot;. That is the &quot;unique&quot;
         * name of the font but in other cases the registry contains the
         * &quot;full&quot; name. See the specifications of name ids 3 and 4 in the
         * TrueType 'name' table.
         * In general this could cause a problem that we fail to register
         * if we all members of a family that we may end up mapping to
         * the wrong font member: eg return Bold when Plain is needed.
         */
<span class="nc bnc" id="L2011" title="All 2 branches missed.">        for (int f=0;f&lt;fontList.length;f++) {</span>
<span class="nc" id="L2012">            String fontNameLC = fontList[f].toLowerCase(Locale.ENGLISH);</span>
<span class="nc" id="L2013">            String fileName = fontToFileMap.get(fontNameLC);</span>
<span class="nc bnc" id="L2014" title="All 2 branches missed.">            if (fileName == null) {</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">                if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2016">                    FontUtilities.getLogger()</span>
<span class="nc" id="L2017">                          .info(&quot;Platform lookup : No file for font &quot; +</span>
                                fontList[f] + &quot; in family &quot; +familyName);
                }
<span class="nc" id="L2020">                return null;</span>
            }
        }

        /* Currently this code only looks for TrueType fonts, so format
         * and rank can be specified without looking at the filename.
         */
<span class="nc" id="L2027">        PhysicalFont physicalFont = null;</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">        if (fontFile != null) {</span>
<span class="nc" id="L2029">            physicalFont = registerFontFile(getPathName(fontFile), null,</span>
                                            FONTFORMAT_TRUETYPE, false,
                                            Font2D.TTF_RANK);
        }
        /* Register all fonts in this family. */
<span class="nc bnc" id="L2034" title="All 2 branches missed.">        for (int f=0;f&lt;fontList.length;f++) {</span>
<span class="nc" id="L2035">            String fontNameLC = fontList[f].toLowerCase(Locale.ENGLISH);</span>
<span class="nc" id="L2036">            String fileName = fontToFileMap.get(fontNameLC);</span>
<span class="nc bnc" id="L2037" title="All 4 branches missed.">            if (fontFile != null &amp;&amp; fontFile.equals(fileName)) {</span>
<span class="nc" id="L2038">                continue;</span>
            }
            /* Currently this code only looks for TrueType fonts, so format
             * and rank can be specified without looking at the filename.
             */
<span class="nc" id="L2043">            registerFontFile(getPathName(fileName), null,</span>
                             FONTFORMAT_TRUETYPE, false, Font2D.TTF_RANK);
        }

<span class="nc" id="L2047">        Font2D font = null;</span>
<span class="nc" id="L2048">        FontFamily fontFamily = FontFamily.getFamily(familyName);</span>
        /* Handle case where request &quot;MyFont Bold&quot;, style=Font.ITALIC */
<span class="nc bnc" id="L2050" title="All 2 branches missed.">        if (physicalFont != null) {</span>
<span class="nc" id="L2051">            style |= physicalFont.style;</span>
        }
<span class="nc bnc" id="L2053" title="All 2 branches missed.">        if (fontFamily != null) {</span>
<span class="nc" id="L2054">            font = fontFamily.getFont(style);</span>
<span class="nc bnc" id="L2055" title="All 2 branches missed.">            if (font == null) {</span>
<span class="nc" id="L2056">                font = fontFamily.getClosestStyle(style);</span>
            }
        }
<span class="nc" id="L2059">        return font;</span>
    }

<span class="nc" id="L2062">    private ConcurrentHashMap&lt;String, Font2D&gt; fontNameCache =</span>
        new ConcurrentHashMap&lt;String, Font2D&gt;();

    /*
     * The client supplies a name and a style.
     * The name could be a family name, or a full name.
     * A font may exist with the specified style, or it may
     * exist only in some other style. For non-native fonts the scaler
     * may be able to emulate the required style.
     */
    public Font2D findFont2D(String name, int style, int fallback) {
<span class="nc" id="L2073">        String lowerCaseName = name.toLowerCase(Locale.ENGLISH);</span>
<span class="nc" id="L2074">        String mapName = lowerCaseName + dotStyleStr(style);</span>
        Font2D font;

        /* If preferLocaleFonts() or preferProportionalFonts() has been
         * called we may be using an alternate set of composite fonts in this
         * app context. The presence of a pre-built name map indicates whether
         * this is so, and gives access to the alternate composite for the
         * name.
         */
<span class="nc bnc" id="L2083" title="All 2 branches missed.">        if (_usingPerAppContextComposites) {</span>
            ConcurrentHashMap&lt;String, Font2D&gt; altNameCache =
                (ConcurrentHashMap&lt;String, Font2D&gt;)
<span class="nc" id="L2086">                AppContext.getAppContext().get(CompositeFont.class);</span>
<span class="nc bnc" id="L2087" title="All 2 branches missed.">            if (altNameCache != null) {</span>
<span class="nc" id="L2088">                font = (Font2D)altNameCache.get(mapName);</span>
            } else {
<span class="nc" id="L2090">                font = null;</span>
            }
<span class="nc" id="L2092">        } else {</span>
<span class="nc" id="L2093">            font = fontNameCache.get(mapName);</span>
        }
<span class="nc bnc" id="L2095" title="All 2 branches missed.">        if (font != null) {</span>
<span class="nc" id="L2096">            return font;</span>
        }

<span class="nc bnc" id="L2099" title="All 2 branches missed.">        if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2100">            FontUtilities.getLogger().info(&quot;Search for font: &quot; + name);</span>
        }

        // The check below is just so that the bitmap fonts being set by
        // AWT and Swing thru the desktop properties do not trigger the
        // the load fonts case. The two bitmap fonts are now mapped to
        // appropriate equivalents for serif and sansserif.
        // Note that the cost of this comparison is only for the first
        // call until the map is filled.
<span class="nc bnc" id="L2109" title="All 2 branches missed.">        if (FontUtilities.isWindows) {</span>
<span class="nc bnc" id="L2110" title="All 2 branches missed.">            if (lowerCaseName.equals(&quot;ms sans serif&quot;)) {</span>
<span class="nc" id="L2111">                name = &quot;sansserif&quot;;</span>
<span class="nc bnc" id="L2112" title="All 2 branches missed.">            } else if (lowerCaseName.equals(&quot;ms serif&quot;)) {</span>
<span class="nc" id="L2113">                name = &quot;serif&quot;;</span>
            }
        }

        /* This isn't intended to support a client passing in the
         * string default, but if a client passes in null for the name
         * the java.awt.Font class internally substitutes this name.
         * So we need to recognise it here to prevent a loadFonts
         * on the unrecognised name. The only potential problem with
         * this is it would hide any real font called &quot;default&quot;!
         * But that seems like a potential problem we can ignore for now.
         */
<span class="nc bnc" id="L2125" title="All 2 branches missed.">        if (lowerCaseName.equals(&quot;default&quot;)) {</span>
<span class="nc" id="L2126">            name = &quot;dialog&quot;;</span>
        }

        /* First see if its a family name. */
<span class="nc" id="L2130">        FontFamily family = FontFamily.getFamily(name);</span>
<span class="nc bnc" id="L2131" title="All 2 branches missed.">        if (family != null) {</span>
<span class="nc" id="L2132">            font = family.getFontWithExactStyleMatch(style);</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">            if (font == null) {</span>
<span class="nc" id="L2134">                font = findDeferredFont(name, style);</span>
            }
<span class="nc bnc" id="L2136" title="All 2 branches missed.">            if (font == null) {</span>
<span class="nc" id="L2137">                font = family.getFont(style);</span>
            }
<span class="nc bnc" id="L2139" title="All 2 branches missed.">            if (font == null) {</span>
<span class="nc" id="L2140">                font = family.getClosestStyle(style);</span>
            }
<span class="nc bnc" id="L2142" title="All 2 branches missed.">            if (font != null) {</span>
<span class="nc" id="L2143">                fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2144">                return font;</span>
            }
        }

        /* If it wasn't a family name, it should be a full name of
         * either a composite, or a physical font
         */
<span class="nc" id="L2151">        font = fullNameToFont.get(lowerCaseName);</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">        if (font != null) {</span>
            /* Check that the requested style matches the matched font's style.
             * But also match style automatically if the requested style is
             * &quot;plain&quot;. This because the existing behaviour is that the fonts
             * listed via getAllFonts etc always list their style as PLAIN.
             * This does lead to non-commutative behaviours where you might
             * start with &quot;Lucida Sans Regular&quot; and ask for a BOLD version
             * and get &quot;Lucida Sans DemiBold&quot; but if you ask for the PLAIN
             * style of &quot;Lucida Sans DemiBold&quot; you get &quot;Lucida Sans DemiBold&quot;.
             * This consistent however with what happens if you have a bold
             * version of a font and no plain version exists - alg. styling
             * doesn't &quot;unbolden&quot; the font.
             */
<span class="nc bnc" id="L2165" title="All 4 branches missed.">            if (font.style == style || style == Font.PLAIN) {</span>
<span class="nc" id="L2166">                fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2167">                return font;</span>
            } else {
                /* If it was a full name like &quot;Lucida Sans Regular&quot;, but
                 * the style requested is &quot;bold&quot;, then we want to see if
                 * there's the appropriate match against another font in
                 * that family before trying to load all fonts, or applying a
                 * algorithmic styling
                 */
<span class="nc" id="L2175">                family = FontFamily.getFamily(font.getFamilyName(null));</span>
<span class="nc bnc" id="L2176" title="All 2 branches missed.">                if (family != null) {</span>
<span class="nc" id="L2177">                    Font2D familyFont = family.getFont(style|font.style);</span>
                    /* We exactly matched the requested style, use it! */
<span class="nc bnc" id="L2179" title="All 2 branches missed.">                    if (familyFont != null) {</span>
<span class="nc" id="L2180">                        fontNameCache.put(mapName, familyFont);</span>
<span class="nc" id="L2181">                        return familyFont;</span>
                    } else {
                        /* This next call is designed to support the case
                         * where bold italic is requested, and if we must
                         * style, then base it on either bold or italic -
                         * not on plain!
                         */
<span class="nc" id="L2188">                        familyFont = family.getClosestStyle(style|font.style);</span>
<span class="nc bnc" id="L2189" title="All 2 branches missed.">                        if (familyFont != null) {</span>
                            /* The next check is perhaps one
                             * that shouldn't be done. ie if we get this
                             * far we have probably as close a match as we
                             * are going to get. We could load all fonts to
                             * see if somehow some parts of the family are
                             * loaded but not all of it.
                             */
<span class="nc bnc" id="L2197" title="All 2 branches missed.">                            if (familyFont.canDoStyle(style|font.style)) {</span>
<span class="nc" id="L2198">                                fontNameCache.put(mapName, familyFont);</span>
<span class="nc" id="L2199">                                return familyFont;</span>
                            }
                        }
                    }
                }
            }
        }

<span class="nc bnc" id="L2207" title="All 2 branches missed.">        if (FontUtilities.isWindows) {</span>

<span class="nc" id="L2209">            font = findFontFromPlatformMap(lowerCaseName, style);</span>
<span class="nc bnc" id="L2210" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2211">                FontUtilities.getLogger()</span>
<span class="nc" id="L2212">                    .info(&quot;findFontFromPlatformMap returned &quot; + font);</span>
            }
<span class="nc bnc" id="L2214" title="All 2 branches missed.">            if (font != null) {</span>
<span class="nc" id="L2215">                fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2216">                return font;</span>
            }

            /* Don't want Windows to return a Lucida Sans font from
             * C:\Windows\Fonts
             */
<span class="nc bnc" id="L2222" title="All 2 branches missed.">            if (deferredFontFiles.size() &gt; 0) {</span>
<span class="nc" id="L2223">                font = findJREDeferredFont(lowerCaseName, style);</span>
<span class="nc bnc" id="L2224" title="All 2 branches missed.">                if (font != null) {</span>
<span class="nc" id="L2225">                    fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2226">                    return font;</span>
                }
            }
<span class="nc" id="L2229">            font = findFontFromPlatform(lowerCaseName, style);</span>
<span class="nc bnc" id="L2230" title="All 2 branches missed.">            if (font != null) {</span>
<span class="nc bnc" id="L2231" title="All 2 branches missed.">                if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2232">                    FontUtilities.getLogger()</span>
<span class="nc" id="L2233">                          .info(&quot;Found font via platform API for request:\&quot;&quot; +</span>
                                name + &quot;\&quot;:, style=&quot;+style+
                                &quot; found font: &quot; + font);
                }
<span class="nc" id="L2237">                fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2238">                return font;</span>
            }
        }

        /* If reach here and no match has been located, then if there are
         * uninitialised deferred fonts, load as many of those as needed
         * to find the deferred font. If none is found through that
         * search continue on.
         * There is possibly a minor issue when more than one
         * deferred font implements the same font face. Since deferred
         * fonts are only those in font configuration files, this is a
         * controlled situation, the known case being Solaris euro_fonts
         * versions of Arial, Times New Roman, Courier New. However
         * the larger font will transparently replace the smaller one
         *  - see addToFontList() - when it is needed by the composite font.
         */
<span class="nc bnc" id="L2254" title="All 2 branches missed.">        if (deferredFontFiles.size() &gt; 0) {</span>
<span class="nc" id="L2255">            font = findDeferredFont(name, style);</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">            if (font != null) {</span>
<span class="nc" id="L2257">                fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2258">                return font;</span>
            }
        }

        /* Some apps use deprecated 1.0 names such as helvetica and courier. On
         * Solaris these are Type1 fonts in /usr/openwin/lib/X11/fonts/Type1.
         * If running on Solaris will register all the fonts in this
         * directory.
         * May as well register the whole directory without actually testing
         * the font name is one of the deprecated names as the next step would
         * load all fonts which are in this directory anyway.
         * In the event that this lookup is successful it potentially &quot;hides&quot;
         * TrueType versions of such fonts that are elsewhere but since they
         * do not exist on Solaris this is not a problem.
         * Set a flag to indicate we've done this registration to avoid
         * repetition and more seriously, to avoid recursion.
         */
<span class="nc bnc" id="L2275" title="All 4 branches missed.">        if (FontUtilities.isSolaris &amp;&amp;!loaded1dot0Fonts) {</span>
            /* &quot;timesroman&quot; is a special case since that's not the
             * name of any known font on Solaris or elsewhere.
             */
<span class="nc bnc" id="L2279" title="All 2 branches missed.">            if (lowerCaseName.equals(&quot;timesroman&quot;)) {</span>
<span class="nc" id="L2280">                font = findFont2D(&quot;serif&quot;, style, fallback);</span>
<span class="nc" id="L2281">                fontNameCache.put(mapName, font);</span>
            }
<span class="nc" id="L2283">            register1dot0Fonts();</span>
<span class="nc" id="L2284">            loaded1dot0Fonts = true;</span>
<span class="nc" id="L2285">            Font2D ff = findFont2D(name, style, fallback);</span>
<span class="nc" id="L2286">            return ff;</span>
        }

        /* We check for application registered fonts before
         * explicitly loading all fonts as if necessary the registration
         * code will have done so anyway. And we don't want to needlessly
         * load the actual files for all fonts.
         * Just as for installed fonts we check for family before fullname.
         * We do not add these fonts to fontNameCache for the
         * app context case which eliminates the overhead of a per context
         * cache for these.
         */

<span class="nc bnc" id="L2299" title="All 4 branches missed.">        if (fontsAreRegistered || fontsAreRegisteredPerAppContext) {</span>
<span class="nc" id="L2300">            Hashtable&lt;String, FontFamily&gt; familyTable = null;</span>
            Hashtable&lt;String, Font2D&gt; nameTable;

<span class="nc bnc" id="L2303" title="All 2 branches missed.">            if (fontsAreRegistered) {</span>
<span class="nc" id="L2304">                familyTable = createdByFamilyName;</span>
<span class="nc" id="L2305">                nameTable = createdByFullName;</span>
            } else {
<span class="nc" id="L2307">                AppContext appContext = AppContext.getAppContext();</span>
<span class="nc" id="L2308">                familyTable =</span>
<span class="nc" id="L2309">                    (Hashtable&lt;String,FontFamily&gt;)appContext.get(regFamilyKey);</span>
<span class="nc" id="L2310">                nameTable =</span>
<span class="nc" id="L2311">                    (Hashtable&lt;String,Font2D&gt;)appContext.get(regFullNameKey);</span>
            }

<span class="nc" id="L2314">            family = familyTable.get(lowerCaseName);</span>
<span class="nc bnc" id="L2315" title="All 2 branches missed.">            if (family != null) {</span>
<span class="nc" id="L2316">                font = family.getFontWithExactStyleMatch(style);</span>
<span class="nc bnc" id="L2317" title="All 2 branches missed.">                if (font == null) {</span>
<span class="nc" id="L2318">                    font = family.getFont(style);</span>
                }
<span class="nc bnc" id="L2320" title="All 2 branches missed.">                if (font == null) {</span>
<span class="nc" id="L2321">                    font = family.getClosestStyle(style);</span>
                }
<span class="nc bnc" id="L2323" title="All 2 branches missed.">                if (font != null) {</span>
<span class="nc bnc" id="L2324" title="All 2 branches missed.">                    if (fontsAreRegistered) {</span>
<span class="nc" id="L2325">                        fontNameCache.put(mapName, font);</span>
                    }
<span class="nc" id="L2327">                    return font;</span>
                }
            }
<span class="nc" id="L2330">            font = nameTable.get(lowerCaseName);</span>
<span class="nc bnc" id="L2331" title="All 2 branches missed.">            if (font != null) {</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">                if (fontsAreRegistered) {</span>
<span class="nc" id="L2333">                    fontNameCache.put(mapName, font);</span>
                }
<span class="nc" id="L2335">                return font;</span>
            }
        }

        /* If reach here and no match has been located, then if all fonts
         * are not yet loaded, do so, and then recurse.
         */
<span class="nc bnc" id="L2342" title="All 2 branches missed.">        if (!loadedAllFonts) {</span>
<span class="nc bnc" id="L2343" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2344">                FontUtilities.getLogger()</span>
<span class="nc" id="L2345">                                       .info(&quot;Load fonts looking for:&quot; + name);</span>
            }
<span class="nc" id="L2347">            loadFonts();</span>
<span class="nc" id="L2348">            loadedAllFonts = true;</span>
<span class="nc" id="L2349">            return findFont2D(name, style, fallback);</span>
        }

<span class="nc bnc" id="L2352" title="All 2 branches missed.">        if (!loadedAllFontFiles) {</span>
<span class="nc bnc" id="L2353" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2354">                FontUtilities.getLogger()</span>
<span class="nc" id="L2355">                                  .info(&quot;Load font files looking for:&quot; + name);</span>
            }
<span class="nc" id="L2357">            loadFontFiles();</span>
<span class="nc" id="L2358">            loadedAllFontFiles = true;</span>
<span class="nc" id="L2359">            return findFont2D(name, style, fallback);</span>
        }

        /* The primary name is the locale default - ie not US/English but
         * whatever is the default in this locale. This is the way it always
         * has been but may be surprising to some developers if &quot;Arial Regular&quot;
         * were hard-coded in their app and yet &quot;Arial Regular&quot; was not the
         * default name. Fortunately for them, as a consequence of the JDK
         * supporting returning names and family names for arbitrary locales,
         * we also need to support searching all localised names for a match.
         * But because this case of the name used to reference a font is not
         * the same as the default for this locale is rare, it makes sense to
         * search a much shorter list of default locale names and only go to
         * a longer list of names in the event that no match was found.
         * So add here code which searches localised names too.
         * As in 1.4.x this happens only after loading all fonts, which
         * is probably the right order.
         */
<span class="nc bnc" id="L2377" title="All 2 branches missed.">        if ((font = findFont2DAllLocales(name, style)) != null) {</span>
<span class="nc" id="L2378">            fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2379">            return font;</span>
        }

        /* Perhaps its a &quot;compatibility&quot; name - timesroman, helvetica,
         * or courier, which 1.0 apps used for logical fonts.
         * We look for these &quot;late&quot; after a loadFonts as we must not
         * hide real fonts of these names.
         * Map these appropriately:
         * On windows this means according to the rules specified by the
         * FontConfiguration : do it only for encoding==Cp1252
         *
         * REMIND: this is something we plan to remove.
         */
<span class="nc bnc" id="L2392" title="All 2 branches missed.">        if (FontUtilities.isWindows) {</span>
<span class="nc" id="L2393">            String compatName =</span>
<span class="nc" id="L2394">                getFontConfiguration().getFallbackFamilyName(name, null);</span>
<span class="nc bnc" id="L2395" title="All 2 branches missed.">            if (compatName != null) {</span>
<span class="nc" id="L2396">                font = findFont2D(compatName, style, fallback);</span>
<span class="nc" id="L2397">                fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2398">                return font;</span>
            }
<span class="nc bnc" id="L2400" title="All 2 branches missed.">        } else if (lowerCaseName.equals(&quot;timesroman&quot;)) {</span>
<span class="nc" id="L2401">            font = findFont2D(&quot;serif&quot;, style, fallback);</span>
<span class="nc" id="L2402">            fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2403">            return font;</span>
<span class="nc bnc" id="L2404" title="All 2 branches missed.">        } else if (lowerCaseName.equals(&quot;helvetica&quot;)) {</span>
<span class="nc" id="L2405">            font = findFont2D(&quot;sansserif&quot;, style, fallback);</span>
<span class="nc" id="L2406">            fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2407">            return font;</span>
<span class="nc bnc" id="L2408" title="All 2 branches missed.">        } else if (lowerCaseName.equals(&quot;courier&quot;)) {</span>
<span class="nc" id="L2409">            font = findFont2D(&quot;monospaced&quot;, style, fallback);</span>
<span class="nc" id="L2410">            fontNameCache.put(mapName, font);</span>
<span class="nc" id="L2411">            return font;</span>
        }

<span class="nc bnc" id="L2414" title="All 2 branches missed.">        if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2415">            FontUtilities.getLogger().info(&quot;No font found for:&quot; + name);</span>
        }

<span class="nc bnc" id="L2418" title="All 3 branches missed.">        switch (fallback) {</span>
<span class="nc" id="L2419">        case PHYSICAL_FALLBACK: return getDefaultPhysicalFont();</span>
<span class="nc" id="L2420">        case LOGICAL_FALLBACK: return getDefaultLogicalFont(style);</span>
<span class="nc" id="L2421">        default: return null;</span>
        }
    }

    /*
     * Workaround for apps which are dependent on a font metrics bug
     * in JDK 1.1. This is an unsupported win32 private setting.
     * Left in for a customer - do not remove.
     */
    public boolean usePlatformFontMetrics() {
<span class="nc" id="L2431">        return usePlatformFontMetrics;</span>
    }

    public int getNumFonts() {
<span class="nc" id="L2435">        return physicalFonts.size()+maxCompFont;</span>
    }

    private static boolean fontSupportsEncoding(Font font, String encoding) {
<span class="nc" id="L2439">        return FontUtilities.getFont2D(font).supportsEncoding(encoding);</span>
    }

    protected abstract String getFontPath(boolean noType1Fonts);

    // MACOSX begin -- need to access this in subclass
<span class="nc" id="L2445">    protected Thread fileCloser = null;</span>
    // MACOSX end
<span class="nc" id="L2447">    Vector&lt;File&gt; tmpFontFiles = null;</span>

    public Font2D createFont2D(File fontFile, int fontFormat,
                               boolean isCopy, CreatedFontTracker tracker)
    throws FontFormatException {

<span class="nc" id="L2453">        String fontFilePath = fontFile.getPath();</span>
<span class="nc" id="L2454">        FileFont font2D = null;</span>
<span class="nc" id="L2455">        final File fFile = fontFile;</span>
<span class="nc" id="L2456">        final CreatedFontTracker _tracker = tracker;</span>
        try {
<span class="nc bnc" id="L2458" title="All 3 branches missed.">            switch (fontFormat) {</span>
            case Font.TRUETYPE_FONT:
<span class="nc" id="L2460">                font2D = new TrueTypeFont(fontFilePath, null, 0, true);</span>
<span class="nc" id="L2461">                break;</span>
            case Font.TYPE1_FONT:
<span class="nc" id="L2463">                font2D = new Type1Font(fontFilePath, null, isCopy);</span>
<span class="nc" id="L2464">                break;</span>
            default:
<span class="nc" id="L2466">                throw new FontFormatException(&quot;Unrecognised Font Format&quot;);</span>
            }
<span class="nc" id="L2468">        } catch (FontFormatException e) {</span>
<span class="nc bnc" id="L2469" title="All 2 branches missed.">            if (isCopy) {</span>
<span class="nc" id="L2470">                java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L2471">                     new java.security.PrivilegedAction() {</span>
                          public Object run() {
<span class="nc bnc" id="L2473" title="All 2 branches missed.">                              if (_tracker != null) {</span>
<span class="nc" id="L2474">                                  _tracker.subBytes((int)fFile.length());</span>
                              }
<span class="nc" id="L2476">                              fFile.delete();</span>
<span class="nc" id="L2477">                              return null;</span>
                          }
                });
            }
<span class="nc" id="L2481">            throw(e);</span>
<span class="nc" id="L2482">        }</span>
<span class="nc bnc" id="L2483" title="All 2 branches missed.">        if (isCopy) {</span>
<span class="nc" id="L2484">            font2D.setFileToRemove(fontFile, tracker);</span>
<span class="nc" id="L2485">            synchronized (FontManager.class) {</span>

<span class="nc bnc" id="L2487" title="All 2 branches missed.">                if (tmpFontFiles == null) {</span>
<span class="nc" id="L2488">                    tmpFontFiles = new Vector&lt;File&gt;();</span>
                }
<span class="nc" id="L2490">                tmpFontFiles.add(fontFile);</span>

<span class="nc bnc" id="L2492" title="All 2 branches missed.">                if (fileCloser == null) {</span>
<span class="nc" id="L2493">                    final Runnable fileCloserRunnable = new Runnable() {</span>
                      public void run() {
<span class="nc" id="L2495">                         java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L2496">                         new java.security.PrivilegedAction() {</span>
                         public Object run() {

<span class="nc bnc" id="L2499" title="All 2 branches missed.">                            for (int i=0;i&lt;CHANNELPOOLSIZE;i++) {</span>
<span class="nc bnc" id="L2500" title="All 2 branches missed.">                                if (fontFileCache[i] != null) {</span>
                                    try {
<span class="nc" id="L2502">                                        fontFileCache[i].close();</span>
<span class="nc" id="L2503">                                    } catch (Exception e) {</span>
<span class="nc" id="L2504">                                    }</span>
                                }
                            }
<span class="nc bnc" id="L2507" title="All 2 branches missed.">                            if (tmpFontFiles != null) {</span>
<span class="nc" id="L2508">                                File[] files = new File[tmpFontFiles.size()];</span>
<span class="nc" id="L2509">                                files = tmpFontFiles.toArray(files);</span>
<span class="nc bnc" id="L2510" title="All 2 branches missed.">                                for (int f=0; f&lt;files.length;f++) {</span>
                                    try {
<span class="nc" id="L2512">                                        files[f].delete();</span>
<span class="nc" id="L2513">                                    } catch (Exception e) {</span>
<span class="nc" id="L2514">                                    }</span>
                                }
                            }

<span class="nc" id="L2518">                            return null;</span>
                          }

                          });
<span class="nc" id="L2522">                      }</span>
                    };
<span class="nc" id="L2524">                    java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L2525">                       new java.security.PrivilegedAction() {</span>
                          public Object run() {
                              /* The thread must be a member of a thread group
                               * which will not get GCed before VM exit.
                               * Make its parent the top-level thread group.
                               */
                              ThreadGroup tg =
<span class="nc" id="L2532">                                  Thread.currentThread().getThreadGroup();</span>
<span class="nc" id="L2533">                              for (ThreadGroup tgn = tg;</span>
<span class="nc bnc" id="L2534" title="All 2 branches missed.">                                   tgn != null;</span>
<span class="nc" id="L2535">                                   tg = tgn, tgn = tg.getParent());</span>
<span class="nc" id="L2536">                              fileCloser = new Thread(tg, fileCloserRunnable);</span>
<span class="nc" id="L2537">                              fileCloser.setContextClassLoader(null);</span>
<span class="nc" id="L2538">                              Runtime.getRuntime().addShutdownHook(fileCloser);</span>
<span class="nc" id="L2539">                              return null;</span>
                          }
                    });
                }
<span class="nc" id="L2543">            }</span>
        }
<span class="nc" id="L2545">        return font2D;</span>
    }

    /* remind: used in X11GraphicsEnvironment and called often enough
     * that we ought to obsolete this code
     */
    public synchronized String getFullNameByFileName(String fileName) {
<span class="nc" id="L2552">        PhysicalFont[] physFonts = getPhysicalFonts();</span>
<span class="nc bnc" id="L2553" title="All 2 branches missed.">        for (int i=0;i&lt;physFonts.length;i++) {</span>
<span class="nc bnc" id="L2554" title="All 2 branches missed.">            if (physFonts[i].platName.equals(fileName)) {</span>
<span class="nc" id="L2555">                return (physFonts[i].getFontName(null));</span>
            }
        }
<span class="nc" id="L2558">        return null;</span>
    }

    /*
     * This is called when font is determined to be invalid/bad.
     * It designed to be called (for example) by the font scaler
     * when in processing a font file it is discovered to be incorrect.
     * This is different than the case where fonts are discovered to
     * be incorrect during initial verification, as such fonts are
     * never registered.
     * Handles to this font held are re-directed to a default font.
     * This default may not be an ideal substitute buts it better than
     * crashing This code assumes a PhysicalFont parameter as it doesn't
     * make sense for a Composite to be &quot;bad&quot;.
     */
    public synchronized void deRegisterBadFont(Font2D font2D) {
<span class="nc bnc" id="L2574" title="All 2 branches missed.">        if (!(font2D instanceof PhysicalFont)) {</span>
            /* We should never reach here, but just in case */
<span class="nc" id="L2576">            return;</span>
        } else {
<span class="nc bnc" id="L2578" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2579">                FontUtilities.getLogger()</span>
<span class="nc" id="L2580">                                     .severe(&quot;Deregister bad font: &quot; + font2D);</span>
            }
<span class="nc" id="L2582">            replaceFont((PhysicalFont)font2D, getDefaultPhysicalFont());</span>
        }
<span class="nc" id="L2584">    }</span>

    /*
     * This encapsulates all the work that needs to be done when a
     * Font2D is replaced by a different Font2D.
     */
    public synchronized void replaceFont(PhysicalFont oldFont,
                                         PhysicalFont newFont) {

<span class="nc bnc" id="L2593" title="All 2 branches missed.">        if (oldFont.handle.font2D != oldFont) {</span>
            /* already done */
<span class="nc" id="L2595">            return;</span>
        }

        /* If we try to replace the font with itself, that won't work,
         * so pick any alternative physical font
         */
<span class="nc bnc" id="L2601" title="All 2 branches missed.">        if (oldFont == newFont) {</span>
<span class="nc bnc" id="L2602" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2603">                FontUtilities.getLogger()</span>
<span class="nc" id="L2604">                      .severe(&quot;Can't replace bad font with itself &quot; + oldFont);</span>
            }
<span class="nc" id="L2606">            PhysicalFont[] physFonts = getPhysicalFonts();</span>
<span class="nc bnc" id="L2607" title="All 2 branches missed.">            for (int i=0; i&lt;physFonts.length;i++) {</span>
<span class="nc bnc" id="L2608" title="All 2 branches missed.">                if (physFonts[i] != newFont) {</span>
<span class="nc" id="L2609">                    newFont = physFonts[i];</span>
<span class="nc" id="L2610">                    break;</span>
                }
            }
<span class="nc bnc" id="L2613" title="All 2 branches missed.">            if (oldFont == newFont) {</span>
<span class="nc bnc" id="L2614" title="All 2 branches missed.">                if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2615">                    FontUtilities.getLogger()</span>
<span class="nc" id="L2616">                           .severe(&quot;This is bad. No good physicalFonts found.&quot;);</span>
                }
<span class="nc" id="L2618">                return;</span>
            }
        }

        /* eliminate references to this font, so it won't be located
         * by future callers, and will be eligible for GC when all
         * references are removed
         */
<span class="nc" id="L2626">        oldFont.handle.font2D = newFont;</span>
<span class="nc" id="L2627">        physicalFonts.remove(oldFont.fullName);</span>
<span class="nc" id="L2628">        fullNameToFont.remove(oldFont.fullName.toLowerCase(Locale.ENGLISH));</span>
<span class="nc" id="L2629">        FontFamily.remove(oldFont);</span>
<span class="nc bnc" id="L2630" title="All 2 branches missed.">        if (localeFullNamesToFont != null) {</span>
<span class="nc" id="L2631">            Map.Entry[] mapEntries =</span>
<span class="nc" id="L2632">                (Map.Entry[])localeFullNamesToFont.entrySet().</span>
<span class="nc" id="L2633">                toArray(new Map.Entry[0]);</span>
            /* Should I be replacing these, or just I just remove
             * the names from the map?
             */
<span class="nc bnc" id="L2637" title="All 2 branches missed.">            for (int i=0; i&lt;mapEntries.length;i++) {</span>
<span class="nc bnc" id="L2638" title="All 2 branches missed.">                if (mapEntries[i].getValue() == oldFont) {</span>
                    try {
<span class="nc" id="L2640">                        mapEntries[i].setValue(newFont);</span>
<span class="nc" id="L2641">                    } catch (Exception e) {</span>
                        /* some maps don't support this operation.
                         * In this case just give up and remove the entry.
                         */
<span class="nc" id="L2645">                        localeFullNamesToFont.remove(mapEntries[i].getKey());</span>
<span class="nc" id="L2646">                    }</span>
                }
            }
        }

<span class="nc bnc" id="L2651" title="All 2 branches missed.">        for (int i=0; i&lt;maxCompFont; i++) {</span>
            /* Deferred initialization of composites shouldn't be
             * a problem for this case, since a font must have been
             * initialised to be discovered to be bad.
             * Some JRE composites on Solaris use two versions of the same
             * font. The replaced font isn't bad, just &quot;smaller&quot; so there's
             * no need to make the slot point to the new font.
             * Since composites have a direct reference to the Font2D (not
             * via a handle) making this substitution is not safe and could
             * cause an additional problem and so this substitution is
             * warranted only when a font is truly &quot;bad&quot; and could cause
             * a crash. So we now replace it only if its being substituted
             * with some font other than a fontconfig rank font
             * Since in practice a substitution will have the same rank
             * this may never happen, but the code is safer even if its
             * also now a no-op.
             * The only obvious &quot;glitch&quot; from this stems from the current
             * implementation that when asked for the number of glyphs in a
             * composite it lies and returns the number in slot 0 because
             * composite glyphs aren't contiguous. Since we live with that
             * we can live with the glitch that depending on how it was
             * initialised a composite may return different values for this.
             * Fixing the issues with composite glyph ids is tricky as
             * there are exclusion ranges and unlike other fonts even the
             * true &quot;numGlyphs&quot; isn't a contiguous range. Likely the only
             * solution is an API that returns an array of glyph ranges
             * which takes precedence over the existing API. That might
             * also need to address excluding ranges which represent a
             * code point supported by an earlier component.
             */
<span class="nc bnc" id="L2681" title="All 2 branches missed.">            if (newFont.getRank() &gt; Font2D.FONT_CONFIG_RANK) {</span>
<span class="nc" id="L2682">                compFonts[i].replaceComponentFont(oldFont, newFont);</span>
            }
        }
<span class="nc" id="L2685">    }</span>

    private synchronized void loadLocaleNames() {
<span class="nc bnc" id="L2688" title="All 2 branches missed.">        if (localeFullNamesToFont != null) {</span>
<span class="nc" id="L2689">            return;</span>
        }
<span class="nc" id="L2691">        localeFullNamesToFont = new HashMap&lt;String, TrueTypeFont&gt;();</span>
<span class="nc" id="L2692">        Font2D[] fonts = getRegisteredFonts();</span>
<span class="nc bnc" id="L2693" title="All 2 branches missed.">        for (int i=0; i&lt;fonts.length; i++) {</span>
<span class="nc bnc" id="L2694" title="All 2 branches missed.">            if (fonts[i] instanceof TrueTypeFont) {</span>
<span class="nc" id="L2695">                TrueTypeFont ttf = (TrueTypeFont)fonts[i];</span>
<span class="nc" id="L2696">                String[] fullNames = ttf.getAllFullNames();</span>
<span class="nc bnc" id="L2697" title="All 2 branches missed.">                for (int n=0; n&lt;fullNames.length; n++) {</span>
<span class="nc" id="L2698">                    localeFullNamesToFont.put(fullNames[n], ttf);</span>
                }
<span class="nc" id="L2700">                FontFamily family = FontFamily.getFamily(ttf.familyName);</span>
<span class="nc bnc" id="L2701" title="All 2 branches missed.">                if (family != null) {</span>
<span class="nc" id="L2702">                    FontFamily.addLocaleNames(family, ttf.getAllFamilyNames());</span>
                }
            }
        }
<span class="nc" id="L2706">    }</span>

    /* This replicate the core logic of findFont2D but operates on
     * all the locale names. This hasn't been merged into findFont2D to
     * keep the logic simpler and reduce overhead, since this case is
     * almost never used. The main case in which it is called is when
     * a bogus font name is used and we need to check all possible names
     * before returning the default case.
     */
    private Font2D findFont2DAllLocales(String name, int style) {

<span class="nc bnc" id="L2717" title="All 2 branches missed.">        if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2718">            FontUtilities.getLogger()</span>
<span class="nc" id="L2719">                           .info(&quot;Searching localised font names for:&quot; + name);</span>
        }

        /* If reach here and no match has been located, then if we have
         * not yet built the map of localeFullNamesToFont for TT fonts, do so
         * now. This method must be called after all fonts have been loaded.
         */
<span class="nc bnc" id="L2726" title="All 2 branches missed.">        if (localeFullNamesToFont == null) {</span>
<span class="nc" id="L2727">            loadLocaleNames();</span>
        }
<span class="nc" id="L2729">        String lowerCaseName = name.toLowerCase();</span>
<span class="nc" id="L2730">        Font2D font = null;</span>

        /* First see if its a family name. */
<span class="nc" id="L2733">        FontFamily family = FontFamily.getLocaleFamily(lowerCaseName);</span>
<span class="nc bnc" id="L2734" title="All 2 branches missed.">        if (family != null) {</span>
<span class="nc" id="L2735">          font = family.getFont(style);</span>
<span class="nc bnc" id="L2736" title="All 2 branches missed.">          if (font == null) {</span>
<span class="nc" id="L2737">            font = family.getClosestStyle(style);</span>
          }
<span class="nc bnc" id="L2739" title="All 2 branches missed.">          if (font != null) {</span>
<span class="nc" id="L2740">              return font;</span>
          }
        }

        /* If it wasn't a family name, it should be a full name. */
<span class="nc" id="L2745">        synchronized (this) {</span>
<span class="nc" id="L2746">            font = localeFullNamesToFont.get(name);</span>
<span class="nc" id="L2747">        }</span>
<span class="nc bnc" id="L2748" title="All 2 branches missed.">        if (font != null) {</span>
<span class="nc bnc" id="L2749" title="All 4 branches missed.">            if (font.style == style || style == Font.PLAIN) {</span>
<span class="nc" id="L2750">                return font;</span>
            } else {
<span class="nc" id="L2752">                family = FontFamily.getFamily(font.getFamilyName(null));</span>
<span class="nc bnc" id="L2753" title="All 2 branches missed.">                if (family != null) {</span>
<span class="nc" id="L2754">                    Font2D familyFont = family.getFont(style);</span>
                    /* We exactly matched the requested style, use it! */
<span class="nc bnc" id="L2756" title="All 2 branches missed.">                    if (familyFont != null) {</span>
<span class="nc" id="L2757">                        return familyFont;</span>
                    } else {
<span class="nc" id="L2759">                        familyFont = family.getClosestStyle(style);</span>
<span class="nc bnc" id="L2760" title="All 2 branches missed.">                        if (familyFont != null) {</span>
                            /* The next check is perhaps one
                             * that shouldn't be done. ie if we get this
                             * far we have probably as close a match as we
                             * are going to get. We could load all fonts to
                             * see if somehow some parts of the family are
                             * loaded but not all of it.
                             * This check is commented out for now.
                             */
<span class="nc bnc" id="L2769" title="All 2 branches missed.">                            if (!familyFont.canDoStyle(style)) {</span>
<span class="nc" id="L2770">                                familyFont = null;</span>
                            }
<span class="nc" id="L2772">                            return familyFont;</span>
                        }
                    }
                }
            }
        }
<span class="nc" id="L2778">        return font;</span>
    }

    /* Supporting &quot;alternate&quot; composite fonts on 2D graphics objects
     * is accessed by the application by calling methods on the local
     * GraphicsEnvironment. The overall implementation is described
     * in one place, here, since otherwise the implementation is spread
     * around it may be difficult to track.
     * The methods below call into SunGraphicsEnvironment which creates a
     * new FontConfiguration instance. The FontConfiguration class,
     * and its platform sub-classes are updated to take parameters requesting
     * these behaviours. This is then used to create new composite font
     * instances. Since this calls the initCompositeFont method in
     * SunGraphicsEnvironment it performs the same initialization as is
     * performed normally. There may be some duplication of effort, but
     * that code is already written to be able to perform properly if called
     * to duplicate work. The main difference is that if we detect we are
     * running in an applet/browser/Java plugin environment these new fonts
     * are not placed in the &quot;default&quot; maps but into an AppContext instance.
     * The font lookup mechanism in java.awt.Font.getFont2D() is also updated
     * so that look-up for composite fonts will in that case always
     * do a lookup rather than returning a cached result.
     * This is inefficient but necessary else singleton java.awt.Font
     * instances would not retrieve the correct Font2D for the appcontext.
     * sun.font.FontManager.findFont2D is also updated to that it uses
     * a name map cache specific to that appcontext.
     *
     * Getting an AppContext is expensive, so there is a global variable
     * that records whether these methods have ever been called and can
     * avoid the expense for almost all applications. Once the correct
     * CompositeFont is associated with the Font, everything should work
     * through existing mechanisms.
     * A special case is that GraphicsEnvironment.getAllFonts() must
     * return an AppContext specific list.
     *
     * Calling the methods below is &quot;heavyweight&quot; but it is expected that
     * these methods will be called very rarely.
     *
     * If _usingPerAppContextComposites is true, we are in &quot;applet&quot;
     * (eg browser) environment and at least one context has selected
     * an alternate composite font behaviour.
     * If _usingAlternateComposites is true, we are not in an &quot;applet&quot;
     * environment and the (single) application has selected
     * an alternate composite font behaviour.
     *
     * - Printing: The implementation delegates logical fonts to an AWT
     * mechanism which cannot use these alternate configurations.
     * We can detect that alternate fonts are in use and back-off to 2D, but
     * that uses outlines. Much of this can be fixed with additional work
     * but that may have to wait. The results should be correct, just not
     * optimal.
     */
<span class="nc" id="L2830">    private static final Object altJAFontKey       = new Object();</span>
<span class="nc" id="L2831">    private static final Object localeFontKey       = new Object();</span>
<span class="nc" id="L2832">    private static final Object proportionalFontKey = new Object();</span>
<span class="nc" id="L2833">    private boolean _usingPerAppContextComposites = false;</span>
<span class="nc" id="L2834">    private boolean _usingAlternateComposites = false;</span>

    /* These values are used only if we are running as a standalone
     * application, as determined by maybeMultiAppContext();
     */
<span class="nc" id="L2839">    private static boolean gAltJAFont = false;</span>
<span class="nc" id="L2840">    private boolean gLocalePref = false;</span>
<span class="nc" id="L2841">    private boolean gPropPref = false;</span>

    /* This method doesn't check if alternates are selected in this app
     * context. Its used by the FontMetrics caching code which in such
     * a case cannot retrieve a cached metrics solely on the basis of
     * the Font.equals() method since it needs to also check if the Font2D
     * is the same.
     * We also use non-standard composites for Swing native L&amp;F fonts on
     * Windows. In that case the policy is that the metrics reported are
     * based solely on the physical font in the first slot which is the
     * visible java.awt.Font. So in that case the metrics cache which tests
     * the Font does what we want. In the near future when we expand the GTK
     * logical font definitions we may need to revisit this if GTK reports
     * combined metrics instead. For now though this test can be simple.
     */
    public boolean maybeUsingAlternateCompositeFonts() {
<span class="nc bnc" id="L2857" title="All 4 branches missed.">       return _usingAlternateComposites || _usingPerAppContextComposites;</span>
    }

    public boolean usingAlternateCompositeFonts() {
<span class="nc bnc" id="L2861" title="All 4 branches missed.">        return (_usingAlternateComposites ||</span>
                (_usingPerAppContextComposites &amp;&amp;
<span class="nc bnc" id="L2863" title="All 2 branches missed.">                AppContext.getAppContext().get(CompositeFont.class) != null));</span>
    }

    private static boolean maybeMultiAppContext() {
<span class="nc" id="L2867">        Boolean appletSM = (Boolean)</span>
<span class="nc" id="L2868">            java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L2869">                new java.security.PrivilegedAction() {</span>
                        public Object run() {
<span class="nc" id="L2871">                            SecurityManager sm = System.getSecurityManager();</span>
<span class="nc" id="L2872">                            return new Boolean</span>
                                (sm instanceof sun.applet.AppletSecurity);
                        }
                    });
<span class="nc" id="L2876">        return appletSM.booleanValue();</span>
    }

    /* Modifies the behaviour of a subsequent call to preferLocaleFonts()
     * to use Mincho instead of Gothic for dialoginput in JA locales
     * on windows. Not needed on other platforms.
     */
    public synchronized void useAlternateFontforJALocales() {
<span class="nc bnc" id="L2884" title="All 2 branches missed.">        if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2885">            FontUtilities.getLogger()</span>
<span class="nc" id="L2886">                .info(&quot;Entered useAlternateFontforJALocales().&quot;);</span>
        }
<span class="nc bnc" id="L2888" title="All 2 branches missed.">        if (!FontUtilities.isWindows) {</span>
<span class="nc" id="L2889">            return;</span>
        }

<span class="nc bnc" id="L2892" title="All 2 branches missed.">        if (!maybeMultiAppContext()) {</span>
<span class="nc" id="L2893">            gAltJAFont = true;</span>
        } else {
<span class="nc" id="L2895">            AppContext appContext = AppContext.getAppContext();</span>
<span class="nc" id="L2896">            appContext.put(altJAFontKey, altJAFontKey);</span>
        }
<span class="nc" id="L2898">    }</span>

    public boolean usingAlternateFontforJALocales() {
<span class="nc bnc" id="L2901" title="All 2 branches missed.">        if (!maybeMultiAppContext()) {</span>
<span class="nc" id="L2902">            return gAltJAFont;</span>
        } else {
<span class="nc" id="L2904">            AppContext appContext = AppContext.getAppContext();</span>
<span class="nc bnc" id="L2905" title="All 2 branches missed.">            return appContext.get(altJAFontKey) == altJAFontKey;</span>
        }
    }

    public synchronized void preferLocaleFonts() {
<span class="nc bnc" id="L2910" title="All 2 branches missed.">        if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2911">            FontUtilities.getLogger().info(&quot;Entered preferLocaleFonts().&quot;);</span>
        }
        /* Test if re-ordering will have any effect */
<span class="nc bnc" id="L2914" title="All 2 branches missed.">        if (!FontConfiguration.willReorderForStartupLocale()) {</span>
<span class="nc" id="L2915">            return;</span>
        }

<span class="nc bnc" id="L2918" title="All 2 branches missed.">        if (!maybeMultiAppContext()) {</span>
<span class="nc bnc" id="L2919" title="All 2 branches missed.">            if (gLocalePref == true) {</span>
<span class="nc" id="L2920">                return;</span>
            }
<span class="nc" id="L2922">            gLocalePref = true;</span>
<span class="nc" id="L2923">            createCompositeFonts(fontNameCache, gLocalePref, gPropPref);</span>
<span class="nc" id="L2924">            _usingAlternateComposites = true;</span>
        } else {
<span class="nc" id="L2926">            AppContext appContext = AppContext.getAppContext();</span>
<span class="nc bnc" id="L2927" title="All 2 branches missed.">            if (appContext.get(localeFontKey) == localeFontKey) {</span>
<span class="nc" id="L2928">                return;</span>
            }
<span class="nc" id="L2930">            appContext.put(localeFontKey, localeFontKey);</span>
<span class="nc" id="L2931">            boolean acPropPref =</span>
<span class="nc bnc" id="L2932" title="All 2 branches missed.">                appContext.get(proportionalFontKey) == proportionalFontKey;</span>
            ConcurrentHashMap&lt;String, Font2D&gt;
<span class="nc" id="L2934">                altNameCache = new ConcurrentHashMap&lt;String, Font2D&gt; ();</span>
            /* If there is an existing hashtable, we can drop it. */
<span class="nc" id="L2936">            appContext.put(CompositeFont.class, altNameCache);</span>
<span class="nc" id="L2937">            _usingPerAppContextComposites = true;</span>
<span class="nc" id="L2938">            createCompositeFonts(altNameCache, true, acPropPref);</span>
        }
<span class="nc" id="L2940">    }</span>

    public synchronized void preferProportionalFonts() {
<span class="nc bnc" id="L2943" title="All 2 branches missed.">        if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L2944">            FontUtilities.getLogger()</span>
<span class="nc" id="L2945">                .info(&quot;Entered preferProportionalFonts().&quot;);</span>
        }
        /* If no proportional fonts are configured, there's no need
         * to take any action.
         */
<span class="nc bnc" id="L2950" title="All 2 branches missed.">        if (!FontConfiguration.hasMonoToPropMap()) {</span>
<span class="nc" id="L2951">            return;</span>
        }

<span class="nc bnc" id="L2954" title="All 2 branches missed.">        if (!maybeMultiAppContext()) {</span>
<span class="nc bnc" id="L2955" title="All 2 branches missed.">            if (gPropPref == true) {</span>
<span class="nc" id="L2956">                return;</span>
            }
<span class="nc" id="L2958">            gPropPref = true;</span>
<span class="nc" id="L2959">            createCompositeFonts(fontNameCache, gLocalePref, gPropPref);</span>
<span class="nc" id="L2960">            _usingAlternateComposites = true;</span>
        } else {
<span class="nc" id="L2962">            AppContext appContext = AppContext.getAppContext();</span>
<span class="nc bnc" id="L2963" title="All 2 branches missed.">            if (appContext.get(proportionalFontKey) == proportionalFontKey) {</span>
<span class="nc" id="L2964">                return;</span>
            }
<span class="nc" id="L2966">            appContext.put(proportionalFontKey, proportionalFontKey);</span>
<span class="nc" id="L2967">            boolean acLocalePref =</span>
<span class="nc bnc" id="L2968" title="All 2 branches missed.">                appContext.get(localeFontKey) == localeFontKey;</span>
            ConcurrentHashMap&lt;String, Font2D&gt;
<span class="nc" id="L2970">                altNameCache = new ConcurrentHashMap&lt;String, Font2D&gt; ();</span>
            /* If there is an existing hashtable, we can drop it. */
<span class="nc" id="L2972">            appContext.put(CompositeFont.class, altNameCache);</span>
<span class="nc" id="L2973">            _usingPerAppContextComposites = true;</span>
<span class="nc" id="L2974">            createCompositeFonts(altNameCache, acLocalePref, true);</span>
        }
<span class="nc" id="L2976">    }</span>

<span class="nc" id="L2978">    private static HashSet&lt;String&gt; installedNames = null;</span>
    private static HashSet&lt;String&gt; getInstalledNames() {
<span class="nc bnc" id="L2980" title="All 2 branches missed.">        if (installedNames == null) {</span>
<span class="nc" id="L2981">           Locale l = getSystemStartupLocale();</span>
<span class="nc" id="L2982">           SunFontManager fontManager = SunFontManager.getInstance();</span>
<span class="nc" id="L2983">           String[] installedFamilies =</span>
<span class="nc" id="L2984">               fontManager.getInstalledFontFamilyNames(l);</span>
<span class="nc" id="L2985">           Font[] installedFonts = fontManager.getAllInstalledFonts();</span>
<span class="nc" id="L2986">           HashSet&lt;String&gt; names = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L2987" title="All 2 branches missed.">           for (int i=0; i&lt;installedFamilies.length; i++) {</span>
<span class="nc" id="L2988">               names.add(installedFamilies[i].toLowerCase(l));</span>
           }
<span class="nc bnc" id="L2990" title="All 2 branches missed.">           for (int i=0; i&lt;installedFonts.length; i++) {</span>
<span class="nc" id="L2991">               names.add(installedFonts[i].getFontName(l).toLowerCase(l));</span>
           }
<span class="nc" id="L2993">           installedNames = names;</span>
        }
<span class="nc" id="L2995">        return installedNames;</span>
    }

    /* Keys are used to lookup per-AppContext Hashtables */
<span class="nc" id="L2999">    private static final Object regFamilyKey  = new Object();</span>
<span class="nc" id="L3000">    private static final Object regFullNameKey = new Object();</span>
    private Hashtable&lt;String,FontFamily&gt; createdByFamilyName;
    private Hashtable&lt;String,Font2D&gt;     createdByFullName;
<span class="nc" id="L3003">    private boolean fontsAreRegistered = false;</span>
<span class="nc" id="L3004">    private boolean fontsAreRegisteredPerAppContext = false;</span>

    public boolean registerFont(Font font) {
        /* This method should not be called with &quot;null&quot;.
         * It is the caller's responsibility to ensure that.
         */
<span class="nc bnc" id="L3010" title="All 2 branches missed.">        if (font == null) {</span>
<span class="nc" id="L3011">            return false;</span>
        }

        /* Initialise these objects only once we start to use this API */
<span class="nc" id="L3015">        synchronized (regFamilyKey) {</span>
<span class="nc bnc" id="L3016" title="All 2 branches missed.">            if (createdByFamilyName == null) {</span>
<span class="nc" id="L3017">                createdByFamilyName = new Hashtable&lt;String,FontFamily&gt;();</span>
<span class="nc" id="L3018">                createdByFullName = new Hashtable&lt;String,Font2D&gt;();</span>
            }
<span class="nc" id="L3020">        }</span>

<span class="nc bnc" id="L3022" title="All 2 branches missed.">        if (! FontAccess.getFontAccess().isCreatedFont(font)) {</span>
<span class="nc" id="L3023">            return false;</span>
        }
        /* We want to ensure that this font cannot override existing
         * installed fonts. Check these conditions :
         * - family name is not that of an installed font
         * - full name is not that of an installed font
         * - family name is not the same as the full name of an installed font
         * - full name is not the same as the family name of an installed font
         * The last two of these may initially look odd but the reason is
         * that (unfortunately) Font constructors do not distinuguish these.
         * An extreme example of such a problem would be a font which has
         * family name &quot;Dialog.Plain&quot; and full name of &quot;Dialog&quot;.
         * The one arguably overly stringent restriction here is that if an
         * application wants to supply a new member of an existing family
         * It will get rejected. But since the JRE can perform synthetic
         * styling in many cases its not necessary.
         * We don't apply the same logic to registered fonts. If apps want
         * to do this lets assume they have a reason. It won't cause problems
         * except for themselves.
         */
<span class="nc" id="L3043">        HashSet&lt;String&gt; names = getInstalledNames();</span>
<span class="nc" id="L3044">        Locale l = getSystemStartupLocale();</span>
<span class="nc" id="L3045">        String familyName = font.getFamily(l).toLowerCase();</span>
<span class="nc" id="L3046">        String fullName = font.getFontName(l).toLowerCase();</span>
<span class="nc bnc" id="L3047" title="All 4 branches missed.">        if (names.contains(familyName) || names.contains(fullName)) {</span>
<span class="nc" id="L3048">            return false;</span>
        }

        /* Checks passed, now register the font */
        Hashtable&lt;String,FontFamily&gt; familyTable;
        Hashtable&lt;String,Font2D&gt; fullNameTable;
<span class="nc bnc" id="L3054" title="All 2 branches missed.">        if (!maybeMultiAppContext()) {</span>
<span class="nc" id="L3055">            familyTable = createdByFamilyName;</span>
<span class="nc" id="L3056">            fullNameTable = createdByFullName;</span>
<span class="nc" id="L3057">            fontsAreRegistered = true;</span>
        } else {
<span class="nc" id="L3059">            AppContext appContext = AppContext.getAppContext();</span>
<span class="nc" id="L3060">            familyTable =</span>
<span class="nc" id="L3061">                (Hashtable&lt;String,FontFamily&gt;)appContext.get(regFamilyKey);</span>
<span class="nc" id="L3062">            fullNameTable =</span>
<span class="nc" id="L3063">                (Hashtable&lt;String,Font2D&gt;)appContext.get(regFullNameKey);</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">            if (familyTable == null) {</span>
<span class="nc" id="L3065">                familyTable = new Hashtable&lt;String,FontFamily&gt;();</span>
<span class="nc" id="L3066">                fullNameTable = new Hashtable&lt;String,Font2D&gt;();</span>
<span class="nc" id="L3067">                appContext.put(regFamilyKey, familyTable);</span>
<span class="nc" id="L3068">                appContext.put(regFullNameKey, fullNameTable);</span>
            }
<span class="nc" id="L3070">            fontsAreRegisteredPerAppContext = true;</span>
        }
        /* Create the FontFamily and add font to the tables */
<span class="nc" id="L3073">        Font2D font2D = FontUtilities.getFont2D(font);</span>
<span class="nc" id="L3074">        int style = font2D.getStyle();</span>
<span class="nc" id="L3075">        FontFamily family = familyTable.get(familyName);</span>
<span class="nc bnc" id="L3076" title="All 2 branches missed.">        if (family == null) {</span>
<span class="nc" id="L3077">            family = new FontFamily(font.getFamily(l));</span>
<span class="nc" id="L3078">            familyTable.put(familyName, family);</span>
        }
        /* Remove name cache entries if not using app contexts.
         * To accommodate a case where code may have registered first a plain
         * family member and then used it and is now registering a bold family
         * member, we need to remove all members of the family, so that the
         * new style can get picked up rather than continuing to synthesise.
         */
<span class="nc bnc" id="L3086" title="All 2 branches missed.">        if (fontsAreRegistered) {</span>
<span class="nc" id="L3087">            removeFromCache(family.getFont(Font.PLAIN));</span>
<span class="nc" id="L3088">            removeFromCache(family.getFont(Font.BOLD));</span>
<span class="nc" id="L3089">            removeFromCache(family.getFont(Font.ITALIC));</span>
<span class="nc" id="L3090">            removeFromCache(family.getFont(Font.BOLD|Font.ITALIC));</span>
<span class="nc" id="L3091">            removeFromCache(fullNameTable.get(fullName));</span>
        }
<span class="nc" id="L3093">        family.setFont(font2D, style);</span>
<span class="nc" id="L3094">        fullNameTable.put(fullName, font2D);</span>
<span class="nc" id="L3095">        return true;</span>
    }

    /* Remove from the name cache all references to the Font2D */
    private void removeFromCache(Font2D font) {
<span class="nc bnc" id="L3100" title="All 2 branches missed.">        if (font == null) {</span>
<span class="nc" id="L3101">            return;</span>
        }
<span class="nc" id="L3103">        String[] keys = (String[])(fontNameCache.keySet().toArray(STR_ARRAY));</span>
<span class="nc bnc" id="L3104" title="All 2 branches missed.">        for (int k=0; k&lt;keys.length;k++) {</span>
<span class="nc bnc" id="L3105" title="All 2 branches missed.">            if (fontNameCache.get(keys[k]) == font) {</span>
<span class="nc" id="L3106">                fontNameCache.remove(keys[k]);</span>
            }
        }
<span class="nc" id="L3109">    }</span>

    // It may look odd to use TreeMap but its more convenient to the caller.
    public TreeMap&lt;String, String&gt; getCreatedFontFamilyNames() {

        Hashtable&lt;String,FontFamily&gt; familyTable;
<span class="nc bnc" id="L3115" title="All 2 branches missed.">        if (fontsAreRegistered) {</span>
<span class="nc" id="L3116">            familyTable = createdByFamilyName;</span>
<span class="nc bnc" id="L3117" title="All 2 branches missed.">        } else if (fontsAreRegisteredPerAppContext) {</span>
<span class="nc" id="L3118">            AppContext appContext = AppContext.getAppContext();</span>
<span class="nc" id="L3119">            familyTable =</span>
<span class="nc" id="L3120">                (Hashtable&lt;String,FontFamily&gt;)appContext.get(regFamilyKey);</span>
<span class="nc" id="L3121">        } else {</span>
<span class="nc" id="L3122">            return null;</span>
        }

<span class="nc" id="L3125">        Locale l = getSystemStartupLocale();</span>
<span class="nc" id="L3126">        synchronized (familyTable) {</span>
<span class="nc" id="L3127">            TreeMap&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;();</span>
<span class="nc bnc" id="L3128" title="All 2 branches missed.">            for (FontFamily f : familyTable.values()) {</span>
<span class="nc" id="L3129">                Font2D font2D = f.getFont(Font.PLAIN);</span>
<span class="nc bnc" id="L3130" title="All 2 branches missed.">                if (font2D == null) {</span>
<span class="nc" id="L3131">                    font2D = f.getClosestStyle(Font.PLAIN);</span>
                }
<span class="nc" id="L3133">                String name = font2D.getFamilyName(l);</span>
<span class="nc" id="L3134">                map.put(name.toLowerCase(l), name);</span>
<span class="nc" id="L3135">            }</span>
<span class="nc" id="L3136">            return map;</span>
<span class="nc" id="L3137">        }</span>
    }

    public Font[] getCreatedFonts() {

        Hashtable&lt;String,Font2D&gt; nameTable;
<span class="nc bnc" id="L3143" title="All 2 branches missed.">        if (fontsAreRegistered) {</span>
<span class="nc" id="L3144">            nameTable = createdByFullName;</span>
<span class="nc bnc" id="L3145" title="All 2 branches missed.">        } else if (fontsAreRegisteredPerAppContext) {</span>
<span class="nc" id="L3146">            AppContext appContext = AppContext.getAppContext();</span>
<span class="nc" id="L3147">            nameTable =</span>
<span class="nc" id="L3148">                (Hashtable&lt;String,Font2D&gt;)appContext.get(regFullNameKey);</span>
<span class="nc" id="L3149">        } else {</span>
<span class="nc" id="L3150">            return null;</span>
        }

<span class="nc" id="L3153">        Locale l = getSystemStartupLocale();</span>
<span class="nc" id="L3154">        synchronized (nameTable) {</span>
<span class="nc" id="L3155">            Font[] fonts = new Font[nameTable.size()];</span>
<span class="nc" id="L3156">            int i=0;</span>
<span class="nc bnc" id="L3157" title="All 2 branches missed.">            for (Font2D font2D : nameTable.values()) {</span>
<span class="nc" id="L3158">                fonts[i++] = new Font(font2D.getFontName(l), Font.PLAIN, 1);</span>
<span class="nc" id="L3159">            }</span>
<span class="nc" id="L3160">            return fonts;</span>
<span class="nc" id="L3161">        }</span>
    }


    protected String[] getPlatformFontDirs(boolean noType1Fonts) {

        /* First check if we already initialised path dirs */
<span class="nc bnc" id="L3168" title="All 2 branches missed.">        if (pathDirs != null) {</span>
<span class="nc" id="L3169">            return pathDirs;</span>
        }

<span class="nc" id="L3172">        String path = getPlatformFontPath(noType1Fonts);</span>
<span class="nc" id="L3173">        StringTokenizer parser =</span>
            new StringTokenizer(path, File.pathSeparator);
<span class="nc" id="L3175">        ArrayList&lt;String&gt; pathList = new ArrayList&lt;String&gt;();</span>
        try {
<span class="nc bnc" id="L3177" title="All 2 branches missed.">            while (parser.hasMoreTokens()) {</span>
<span class="nc" id="L3178">                pathList.add(parser.nextToken());</span>
            }
<span class="nc" id="L3180">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L3181">        }</span>
<span class="nc" id="L3182">        pathDirs = pathList.toArray(new String[0]);</span>
<span class="nc" id="L3183">        return pathDirs;</span>
    }

    /**
     * Returns an array of two strings. The first element is the
     * name of the font. The second element is the file name.
     */
    public abstract String[] getDefaultPlatformFont();

    // Begin: Refactored from SunGraphicsEnviroment.

    /*
     * helper function for registerFonts
     */
    private void addDirFonts(String dirName, File dirFile,
                             FilenameFilter filter,
                             int fontFormat, boolean useJavaRasterizer,
                             int fontRank,
                             boolean defer, boolean resolveSymLinks) {
<span class="nc" id="L3202">        String[] ls = dirFile.list(filter);</span>
<span class="nc bnc" id="L3203" title="All 4 branches missed.">        if (ls == null || ls.length == 0) {</span>
<span class="nc" id="L3204">            return;</span>
        }
<span class="nc" id="L3206">        String[] fontNames = new String[ls.length];</span>
<span class="nc" id="L3207">        String[][] nativeNames = new String[ls.length][];</span>
<span class="nc" id="L3208">        int fontCount = 0;</span>

<span class="nc bnc" id="L3210" title="All 2 branches missed.">        for (int i=0; i &lt; ls.length; i++ ) {</span>
<span class="nc" id="L3211">            File theFile = new File(dirFile, ls[i]);</span>
<span class="nc" id="L3212">            String fullName = null;</span>
<span class="nc bnc" id="L3213" title="All 2 branches missed.">            if (resolveSymLinks) {</span>
                try {
<span class="nc" id="L3215">                    fullName = theFile.getCanonicalPath();</span>
<span class="nc" id="L3216">                } catch (IOException e) {</span>
<span class="nc" id="L3217">                }</span>
            }
<span class="nc bnc" id="L3219" title="All 2 branches missed.">            if (fullName == null) {</span>
<span class="nc" id="L3220">                fullName = dirName + File.separator + ls[i];</span>
            }

            // REMIND: case compare depends on platform
<span class="nc bnc" id="L3224" title="All 2 branches missed.">            if (registeredFontFiles.contains(fullName)) {</span>
<span class="nc" id="L3225">                continue;</span>
            }

<span class="nc bnc" id="L3228" title="All 4 branches missed.">            if (badFonts != null &amp;&amp; badFonts.contains(fullName)) {</span>
<span class="nc bnc" id="L3229" title="All 2 branches missed.">                if (FontUtilities.debugFonts()) {</span>
<span class="nc" id="L3230">                    FontUtilities.getLogger()</span>
<span class="nc" id="L3231">                                         .warning(&quot;skip bad font &quot; + fullName);</span>
                }
                continue; // skip this font file.
            }

<span class="nc" id="L3236">            registeredFontFiles.add(fullName);</span>

<span class="nc bnc" id="L3238" title="All 2 branches missed.">            if (FontUtilities.debugFonts()</span>
<span class="nc bnc" id="L3239" title="All 2 branches missed.">                &amp;&amp; FontUtilities.getLogger().isLoggable(PlatformLogger.Level.INFO)) {</span>
<span class="nc" id="L3240">                String message = &quot;Registering font &quot; + fullName;</span>
<span class="nc" id="L3241">                String[] natNames = getNativeNames(fullName, null);</span>
<span class="nc bnc" id="L3242" title="All 2 branches missed.">                if (natNames == null) {</span>
<span class="nc" id="L3243">                    message += &quot; with no native name&quot;;</span>
                } else {
<span class="nc" id="L3245">                    message += &quot; with native name(s) &quot; + natNames[0];</span>
<span class="nc bnc" id="L3246" title="All 2 branches missed.">                    for (int nn = 1; nn &lt; natNames.length; nn++) {</span>
<span class="nc" id="L3247">                        message += &quot;, &quot; + natNames[nn];</span>
                    }
                }
<span class="nc" id="L3250">                FontUtilities.getLogger().info(message);</span>
            }
<span class="nc" id="L3252">            fontNames[fontCount] = fullName;</span>
<span class="nc" id="L3253">            nativeNames[fontCount++] = getNativeNames(fullName, null);</span>
        }
<span class="nc" id="L3255">        registerFonts(fontNames, nativeNames, fontCount, fontFormat,</span>
                         useJavaRasterizer, fontRank, defer);
<span class="nc" id="L3257">        return;</span>
    }

    protected String[] getNativeNames(String fontFileName,
                                      String platformName) {
<span class="nc" id="L3262">        return null;</span>
    }

    /**
     * Returns a file name for the physical font represented by this platform
     * font name. The default implementation tries to obtain the file name
     * from the font configuration.
     * Subclasses may override to provide information from other sources.
     */
    protected String getFileNameFromPlatformName(String platformFontName) {
<span class="nc" id="L3272">        return fontConfig.getFileNameFromPlatformName(platformFontName);</span>
    }

    /**
     * Return the default font configuration.
     */
    public FontConfiguration getFontConfiguration() {
<span class="nc" id="L3279">        return fontConfig;</span>
    }

    /* A call to this method should be followed by a call to
     * registerFontDirs(..)
     */
    public String getPlatformFontPath(boolean noType1Font) {
<span class="nc bnc" id="L3286" title="All 2 branches missed.">        if (fontPath == null) {</span>
<span class="nc" id="L3287">            fontPath = getFontPath(noType1Font);</span>
        }
<span class="nc" id="L3289">        return fontPath;</span>
    }

    public static boolean isOpenJDK() {
<span class="nc" id="L3293">        return FontUtilities.isOpenJDK;</span>
    }

    protected void loadFonts() {
<span class="nc bnc" id="L3297" title="All 2 branches missed.">        if (discoveredAllFonts) {</span>
<span class="nc" id="L3298">            return;</span>
        }
        /* Use lock specific to the font system */
<span class="nc" id="L3301">        synchronized (this) {</span>
<span class="nc bnc" id="L3302" title="All 2 branches missed.">            if (FontUtilities.debugFonts()) {</span>
<span class="nc" id="L3303">                Thread.dumpStack();</span>
<span class="nc" id="L3304">                FontUtilities.getLogger()</span>
<span class="nc" id="L3305">                            .info(&quot;SunGraphicsEnvironment.loadFonts() called&quot;);</span>
            }
<span class="nc" id="L3307">            initialiseDeferredFonts();</span>

<span class="nc" id="L3309">            java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L3310">                                    new java.security.PrivilegedAction() {</span>
                public Object run() {
<span class="nc bnc" id="L3312" title="All 2 branches missed.">                    if (fontPath == null) {</span>
<span class="nc" id="L3313">                        fontPath = getPlatformFontPath(noType1Font);</span>
<span class="nc" id="L3314">                        registerFontDirs(fontPath);</span>
                    }
<span class="nc bnc" id="L3316" title="All 2 branches missed.">                    if (fontPath != null) {</span>
                        // this will find all fonts including those already
                        // registered. But we have checks in place to prevent
                        // double registration.
<span class="nc bnc" id="L3320" title="All 2 branches missed.">                        if (! gotFontsFromPlatform()) {</span>
<span class="nc" id="L3321">                            registerFontsOnPath(fontPath, false,</span>
                                                Font2D.UNKNOWN_RANK,
                                                false, true);
<span class="nc" id="L3324">                            loadedAllFontFiles = true;</span>
                        }
                    }
<span class="nc" id="L3327">                    registerOtherFontFiles(registeredFontFiles);</span>
<span class="nc" id="L3328">                    discoveredAllFonts = true;</span>
<span class="nc" id="L3329">                    return null;</span>
                }
            });
<span class="nc" id="L3332">        }</span>
<span class="nc" id="L3333">    }</span>

    protected void registerFontDirs(String pathName) {
<span class="nc" id="L3336">        return;</span>
    }

    private void registerFontsOnPath(String pathName,
                                     boolean useJavaRasterizer, int fontRank,
                                     boolean defer, boolean resolveSymLinks) {

<span class="nc" id="L3343">        StringTokenizer parser = new StringTokenizer(pathName,</span>
                File.pathSeparator);
        try {
<span class="nc bnc" id="L3346" title="All 2 branches missed.">            while (parser.hasMoreTokens()) {</span>
<span class="nc" id="L3347">                registerFontsInDir(parser.nextToken(),</span>
                        useJavaRasterizer, fontRank,
                        defer, resolveSymLinks);
            }
<span class="nc" id="L3351">        } catch (NoSuchElementException e) {</span>
<span class="nc" id="L3352">        }</span>
<span class="nc" id="L3353">    }</span>

    /* Called to register fall back fonts */
    public void registerFontsInDir(String dirName) {
<span class="nc" id="L3357">        registerFontsInDir(dirName, true, Font2D.JRE_RANK, true, false);</span>
<span class="nc" id="L3358">    }</span>

    // MACOSX begin -- need to access this in subclass
    protected void registerFontsInDir(String dirName, boolean useJavaRasterizer,
    // MACOSX end
                                    int fontRank,
                                    boolean defer, boolean resolveSymLinks) {
<span class="nc" id="L3365">        File pathFile = new File(dirName);</span>
<span class="nc bnc" id="L3366" title="All 2 branches missed.">        addDirFonts(dirName, pathFile, ttFilter,</span>
                    FONTFORMAT_TRUETYPE, useJavaRasterizer,
                    fontRank==Font2D.UNKNOWN_RANK ?
                    Font2D.TTF_RANK : fontRank,
                    defer, resolveSymLinks);
<span class="nc bnc" id="L3371" title="All 2 branches missed.">        addDirFonts(dirName, pathFile, t1Filter,</span>
                    FONTFORMAT_TYPE1, useJavaRasterizer,
                    fontRank==Font2D.UNKNOWN_RANK ?
                    Font2D.TYPE1_RANK : fontRank,
                    defer, resolveSymLinks);
<span class="nc" id="L3376">    }</span>

    protected void registerFontDir(String path) {
<span class="nc" id="L3379">    }</span>

    /**
     * Returns file name for default font, either absolute
     * or relative as needed by registerFontFile.
     */
    public synchronized String getDefaultFontFile() {
<span class="nc bnc" id="L3386" title="All 2 branches missed.">        if (defaultFontFileName == null) {</span>
<span class="nc" id="L3387">            initDefaultFonts();</span>
        }
<span class="nc" id="L3389">        return defaultFontFileName;</span>
    }

    private void initDefaultFonts() {
<span class="nc bnc" id="L3393" title="All 2 branches missed.">        if (!isOpenJDK()) {</span>
<span class="nc" id="L3394">            defaultFontName = lucidaFontName;</span>
<span class="nc bnc" id="L3395" title="All 2 branches missed.">            if (useAbsoluteFontFileNames()) {</span>
<span class="nc" id="L3396">                defaultFontFileName =</span>
                    jreFontDirName + File.separator + FontUtilities.LUCIDA_FILE_NAME;
            } else {
<span class="nc" id="L3399">                defaultFontFileName = FontUtilities.LUCIDA_FILE_NAME;</span>
            }
        }
<span class="nc" id="L3402">    }</span>

    /**
     * Whether registerFontFile expects absolute or relative
     * font file names.
     */
    protected boolean useAbsoluteFontFileNames() {
<span class="nc" id="L3409">        return true;</span>
    }

    /**
     * Creates this environment's FontConfiguration.
     */
    protected abstract FontConfiguration createFontConfiguration();

    public abstract FontConfiguration
    createFontConfiguration(boolean preferLocaleFonts,
                            boolean preferPropFonts);

    /**
     * Returns face name for default font, or null if
     * no face names are used for CompositeFontDescriptors
     * for this platform.
     */
    public synchronized String getDefaultFontFaceName() {
<span class="nc bnc" id="L3427" title="All 2 branches missed.">        if (defaultFontName == null) {</span>
<span class="nc" id="L3428">            initDefaultFonts();</span>
        }
<span class="nc" id="L3430">        return defaultFontName;</span>
    }

    public void loadFontFiles() {
<span class="nc" id="L3434">        loadFonts();</span>
<span class="nc bnc" id="L3435" title="All 2 branches missed.">        if (loadedAllFontFiles) {</span>
<span class="nc" id="L3436">            return;</span>
        }
        /* Use lock specific to the font system */
<span class="nc" id="L3439">        synchronized (this) {</span>
<span class="nc bnc" id="L3440" title="All 2 branches missed.">            if (FontUtilities.debugFonts()) {</span>
<span class="nc" id="L3441">                Thread.dumpStack();</span>
<span class="nc" id="L3442">                FontUtilities.getLogger().info(&quot;loadAllFontFiles() called&quot;);</span>
            }
<span class="nc" id="L3444">            java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L3445">                                    new java.security.PrivilegedAction() {</span>
                public Object run() {
<span class="nc bnc" id="L3447" title="All 2 branches missed.">                    if (fontPath == null) {</span>
<span class="nc" id="L3448">                        fontPath = getPlatformFontPath(noType1Font);</span>
                    }
<span class="nc bnc" id="L3450" title="All 2 branches missed.">                    if (fontPath != null) {</span>
                        // this will find all fonts including those already
                        // registered. But we have checks in place to prevent
                        // double registration.
<span class="nc" id="L3454">                        registerFontsOnPath(fontPath, false,</span>
                                            Font2D.UNKNOWN_RANK,
                                            false, true);
                    }
<span class="nc" id="L3458">                    loadedAllFontFiles = true;</span>
<span class="nc" id="L3459">                    return null;</span>
                }
            });
<span class="nc" id="L3462">        }</span>
<span class="nc" id="L3463">    }</span>

    /*
     * This method asks the font configuration API for all platform names
     * used as components of composite/logical fonts and iterates over these
     * looking up their corresponding file name and registers these fonts.
     * It also ensures that the fonts are accessible via platform APIs.
     * The composites themselves are then registered.
     */
    private void
        initCompositeFonts(FontConfiguration fontConfig,
                           ConcurrentHashMap&lt;String, Font2D&gt;  altNameCache) {

<span class="nc bnc" id="L3476" title="All 2 branches missed.">        if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L3477">            FontUtilities.getLogger()</span>
<span class="nc" id="L3478">                            .info(&quot;Initialising composite fonts&quot;);</span>
        }

<span class="nc" id="L3481">        int numCoreFonts = fontConfig.getNumberCoreFonts();</span>
<span class="nc" id="L3482">        String[] fcFonts = fontConfig.getPlatformFontNames();</span>
<span class="nc bnc" id="L3483" title="All 2 branches missed.">        for (int f=0; f&lt;fcFonts.length; f++) {</span>
<span class="nc" id="L3484">            String platformFontName = fcFonts[f];</span>
<span class="nc" id="L3485">            String fontFileName =</span>
<span class="nc" id="L3486">                getFileNameFromPlatformName(platformFontName);</span>
<span class="nc" id="L3487">            String[] nativeNames = null;</span>
<span class="nc bnc" id="L3488" title="All 2 branches missed.">            if (fontFileName == null</span>
<span class="nc bnc" id="L3489" title="All 2 branches missed.">                || fontFileName.equals(platformFontName)) {</span>
                /* No file located, so register using the platform name,
                 * i.e. as a native font.
                 */
<span class="nc" id="L3493">                fontFileName = platformFontName;</span>
            } else {
<span class="nc bnc" id="L3495" title="All 2 branches missed.">                if (f &lt; numCoreFonts) {</span>
                    /* If platform APIs also need to access the font, add it
                     * to a set to be registered with the platform too.
                     * This may be used to add the parent directory to the X11
                     * font path if its not already there. See the docs for the
                     * subclass implementation.
                     * This is now mainly for the benefit of X11-based AWT
                     * But for historical reasons, 2D initialisation code
                     * makes these calls.
                     * If the fontconfiguration file is properly set up
                     * so that all fonts are mapped to files and all their
                     * appropriate directories are specified, then this
                     * method will be low cost as it will return after
                     * a test that finds a null lookup map.
                     */
<span class="nc" id="L3510">                    addFontToPlatformFontPath(platformFontName);</span>
                }
<span class="nc" id="L3512">                nativeNames = getNativeNames(fontFileName, platformFontName);</span>
            }
            /* Uncomment these two lines to &quot;generate&quot; the XLFD-&gt;filename
             * mappings needed to speed start-up on Solaris.
             * Augment this with the appendedpathname and the mappings
             * for native (F3) fonts
             */
            //String platName = platformFontName.replaceAll(&quot; &quot;, &quot;_&quot;);
            //System.out.println(&quot;filename.&quot;+platName+&quot;=&quot;+fontFileName);
<span class="nc" id="L3521">            registerFontFile(fontFileName, nativeNames,</span>
                             Font2D.FONT_CONFIG_RANK, true);


        }
        /* This registers accumulated paths from the calls to
         * addFontToPlatformFontPath(..) and any specified by
         * the font configuration. Rather than registering
         * the fonts it puts them in a place and form suitable for
         * the Toolkit to pick up and use if a toolkit is initialised,
         * and if it uses X11 fonts.
         */
<span class="nc" id="L3533">        registerPlatformFontsUsedByFontConfiguration();</span>

<span class="nc" id="L3535">        CompositeFontDescriptor[] compositeFontInfo</span>
<span class="nc" id="L3536">                = fontConfig.get2DCompositeFontInfo();</span>
<span class="nc bnc" id="L3537" title="All 2 branches missed.">        for (int i = 0; i &lt; compositeFontInfo.length; i++) {</span>
<span class="nc" id="L3538">            CompositeFontDescriptor descriptor = compositeFontInfo[i];</span>
<span class="nc" id="L3539">            String[] componentFileNames = descriptor.getComponentFileNames();</span>
<span class="nc" id="L3540">            String[] componentFaceNames = descriptor.getComponentFaceNames();</span>

            /* It would be better eventually to handle this in the
             * FontConfiguration code which should also remove duplicate slots
             */
<span class="nc bnc" id="L3545" title="All 2 branches missed.">            if (missingFontFiles != null) {</span>
<span class="nc bnc" id="L3546" title="All 2 branches missed.">                for (int ii=0; ii&lt;componentFileNames.length; ii++) {</span>
<span class="nc bnc" id="L3547" title="All 2 branches missed.">                    if (missingFontFiles.contains(componentFileNames[ii])) {</span>
<span class="nc" id="L3548">                        componentFileNames[ii] = getDefaultFontFile();</span>
<span class="nc" id="L3549">                        componentFaceNames[ii] = getDefaultFontFaceName();</span>
                    }
                }
            }

            /* FontConfiguration needs to convey how many fonts it has added
             * as fallback component fonts which should not affect metrics.
             * The core component count will be the number of metrics slots.
             * This does not preclude other mechanisms for adding
             * fall back component fonts to the composite.
             */
<span class="nc bnc" id="L3560" title="All 2 branches missed.">            if (altNameCache != null) {</span>
<span class="nc" id="L3561">                SunFontManager.registerCompositeFont(</span>
<span class="nc" id="L3562">                    descriptor.getFaceName(),</span>
                    componentFileNames, componentFaceNames,
<span class="nc" id="L3564">                    descriptor.getCoreComponentCount(),</span>
<span class="nc" id="L3565">                    descriptor.getExclusionRanges(),</span>
<span class="nc" id="L3566">                    descriptor.getExclusionRangeLimits(),</span>
                    true,
                    altNameCache);
            } else {
<span class="nc" id="L3570">                registerCompositeFont(descriptor.getFaceName(),</span>
                                      componentFileNames, componentFaceNames,
<span class="nc" id="L3572">                                      descriptor.getCoreComponentCount(),</span>
<span class="nc" id="L3573">                                      descriptor.getExclusionRanges(),</span>
<span class="nc" id="L3574">                                      descriptor.getExclusionRangeLimits(),</span>
                                      true);
            }
<span class="nc bnc" id="L3577" title="All 2 branches missed.">            if (FontUtilities.debugFonts()) {</span>
<span class="nc" id="L3578">                FontUtilities.getLogger()</span>
<span class="nc" id="L3579">                               .info(&quot;registered &quot; + descriptor.getFaceName());</span>
            }
        }
<span class="nc" id="L3582">    }</span>

    /**
     * Notifies graphics environment that the logical font configuration
     * uses the given platform font name. The graphics environment may
     * use this for platform specific initialization.
     */
    protected void addFontToPlatformFontPath(String platformFontName) {
<span class="nc" id="L3590">    }</span>

    protected void registerFontFile(String fontFileName, String[] nativeNames,
                                    int fontRank, boolean defer) {
//      REMIND: case compare depends on platform
<span class="nc bnc" id="L3595" title="All 2 branches missed.">        if (registeredFontFiles.contains(fontFileName)) {</span>
<span class="nc" id="L3596">            return;</span>
        }
        int fontFormat;
<span class="nc bnc" id="L3599" title="All 2 branches missed.">        if (ttFilter.accept(null, fontFileName)) {</span>
<span class="nc" id="L3600">            fontFormat = FONTFORMAT_TRUETYPE;</span>
<span class="nc bnc" id="L3601" title="All 2 branches missed.">        } else if (t1Filter.accept(null, fontFileName)) {</span>
<span class="nc" id="L3602">            fontFormat = FONTFORMAT_TYPE1;</span>
        } else {
<span class="nc" id="L3604">            fontFormat = FONTFORMAT_NATIVE;</span>
        }
<span class="nc" id="L3606">        registeredFontFiles.add(fontFileName);</span>
<span class="nc bnc" id="L3607" title="All 2 branches missed.">        if (defer) {</span>
<span class="nc" id="L3608">            registerDeferredFont(fontFileName, fontFileName, nativeNames,</span>
                                 fontFormat, false, fontRank);
        } else {
<span class="nc" id="L3611">            registerFontFile(fontFileName, nativeNames, fontFormat, false,</span>
                             fontRank);
        }
<span class="nc" id="L3614">    }</span>

    protected void registerPlatformFontsUsedByFontConfiguration() {
<span class="nc" id="L3617">    }</span>

    /*
     * A GE may verify whether a font file used in a fontconfiguration
     * exists. If it doesn't then either we may substitute the default
     * font, or perhaps elide it altogether from the composite font.
     * This makes some sense on windows where the font file is only
     * likely to be in one place. But on other OSes, eg Linux, the file
     * can move around depending. So there we probably don't want to assume
     * its missing and so won't add it to this list.
     * If this list - missingFontFiles - is non-null then the composite
     * font initialisation logic tests to see if a font file is in that
     * set.
     * Only one thread should be able to add to this set so we don't
     * synchronize.
     */
    protected void addToMissingFontFileList(String fileName) {
<span class="nc bnc" id="L3634" title="All 2 branches missed.">        if (missingFontFiles == null) {</span>
<span class="nc" id="L3635">            missingFontFiles = new HashSet&lt;String&gt;();</span>
        }
<span class="nc" id="L3637">        missingFontFiles.add(fileName);</span>
<span class="nc" id="L3638">    }</span>

    /*
     * This is for use only within getAllFonts().
     * Fonts listed in the fontconfig files for windows were all
     * on the &quot;deferred&quot; initialisation list. They were registered
     * either in the course of the application, or in the call to
     * loadFonts() within getAllFonts(). The fontconfig file specifies
     * the names of the fonts using the English names. If there's a
     * different name in the execution locale, then the platform will
     * report that, and we will construct the font with both names, and
     * thereby enumerate it twice. This happens for Japanese fonts listed
     * in the windows fontconfig, when run in the JA locale. The solution
     * is to rely (in this case) on the platform's font-&gt;file mapping to
     * determine that this name corresponds to a file we already registered.
     * This works because
     * - we know when we get here all deferred fonts are already initialised
     * - when we register a font file, we register all fonts in it.
     * - we know the fontconfig fonts are all in the windows registry
     */
    private boolean isNameForRegisteredFile(String fontName) {
<span class="nc" id="L3659">        String fileName = getFileNameForFontName(fontName);</span>
<span class="nc bnc" id="L3660" title="All 2 branches missed.">        if (fileName == null) {</span>
<span class="nc" id="L3661">            return false;</span>
        }
<span class="nc" id="L3663">        return registeredFontFiles.contains(fileName);</span>
    }

    /*
     * This invocation is not in a privileged block because
     * all privileged operations (reading files and properties)
     * was conducted on the creation of the GE
     */
    public void
        createCompositeFonts(ConcurrentHashMap&lt;String, Font2D&gt; altNameCache,
                             boolean preferLocale,
                             boolean preferProportional) {

<span class="nc" id="L3676">        FontConfiguration fontConfig =</span>
<span class="nc" id="L3677">            createFontConfiguration(preferLocale, preferProportional);</span>
<span class="nc" id="L3678">        initCompositeFonts(fontConfig, altNameCache);</span>
<span class="nc" id="L3679">    }</span>

    /**
     * Returns all fonts installed in this environment.
     */
    public Font[] getAllInstalledFonts() {
<span class="nc bnc" id="L3685" title="All 2 branches missed.">        if (allFonts == null) {</span>
<span class="nc" id="L3686">            loadFonts();</span>
<span class="nc" id="L3687">            TreeMap fontMapNames = new TreeMap();</span>
            /* warning: the number of composite fonts could change dynamically
             * if applications are allowed to create them. &quot;allfonts&quot; could
             * then be stale.
             */
<span class="nc" id="L3692">            Font2D[] allfonts = getRegisteredFonts();</span>
<span class="nc bnc" id="L3693" title="All 2 branches missed.">            for (int i=0; i &lt; allfonts.length; i++) {</span>
<span class="nc bnc" id="L3694" title="All 2 branches missed.">                if (!(allfonts[i] instanceof NativeFont)) {</span>
<span class="nc" id="L3695">                    fontMapNames.put(allfonts[i].getFontName(null),</span>
                                     allfonts[i]);
                }
            }

<span class="nc" id="L3700">            String[] platformNames = getFontNamesFromPlatform();</span>
<span class="nc bnc" id="L3701" title="All 2 branches missed.">            if (platformNames != null) {</span>
<span class="nc bnc" id="L3702" title="All 2 branches missed.">                for (int i=0; i&lt;platformNames.length; i++) {</span>
<span class="nc bnc" id="L3703" title="All 2 branches missed.">                    if (!isNameForRegisteredFile(platformNames[i])) {</span>
<span class="nc" id="L3704">                        fontMapNames.put(platformNames[i], null);</span>
                    }
                }
            }

<span class="nc" id="L3709">            String[] fontNames = null;</span>
<span class="nc bnc" id="L3710" title="All 2 branches missed.">            if (fontMapNames.size() &gt; 0) {</span>
<span class="nc" id="L3711">                fontNames = new String[fontMapNames.size()];</span>
<span class="nc" id="L3712">                Object [] keyNames = fontMapNames.keySet().toArray();</span>
<span class="nc bnc" id="L3713" title="All 2 branches missed.">                for (int i=0; i &lt; keyNames.length; i++) {</span>
<span class="nc" id="L3714">                    fontNames[i] = (String)keyNames[i];</span>
                }
            }
<span class="nc" id="L3717">            Font[] fonts = new Font[fontNames.length];</span>
<span class="nc bnc" id="L3718" title="All 2 branches missed.">            for (int i=0; i &lt; fontNames.length; i++) {</span>
<span class="nc" id="L3719">                fonts[i] = new Font(fontNames[i], Font.PLAIN, 1);</span>
<span class="nc" id="L3720">                Font2D f2d = (Font2D)fontMapNames.get(fontNames[i]);</span>
<span class="nc bnc" id="L3721" title="All 2 branches missed.">                if (f2d  != null) {</span>
<span class="nc" id="L3722">                    FontAccess.getFontAccess().setFont2D(fonts[i], f2d.handle);</span>
                }
            }
<span class="nc" id="L3725">            allFonts = fonts;</span>
        }

<span class="nc" id="L3728">        Font []copyFonts = new Font[allFonts.length];</span>
<span class="nc" id="L3729">        System.arraycopy(allFonts, 0, copyFonts, 0, allFonts.length);</span>
<span class="nc" id="L3730">        return copyFonts;</span>
    }

    /**
     * Get a list of installed fonts in the requested {@link Locale}.
     * The list contains the fonts Family Names.
     * If Locale is null, the default locale is used.
     *
     * @param requestedLocale, if null the default locale is used.
     * @return list of installed fonts in the system.
     */
    public String[] getInstalledFontFamilyNames(Locale requestedLocale) {
<span class="nc bnc" id="L3742" title="All 2 branches missed.">        if (requestedLocale == null) {</span>
<span class="nc" id="L3743">            requestedLocale = Locale.getDefault();</span>
        }
<span class="nc bnc" id="L3745" title="All 4 branches missed.">        if (allFamilies != null &amp;&amp; lastDefaultLocale != null &amp;&amp;</span>
<span class="nc bnc" id="L3746" title="All 2 branches missed.">            requestedLocale.equals(lastDefaultLocale)) {</span>
<span class="nc" id="L3747">                String[] copyFamilies = new String[allFamilies.length];</span>
<span class="nc" id="L3748">                System.arraycopy(allFamilies, 0, copyFamilies,</span>
                                 0, allFamilies.length);
<span class="nc" id="L3750">                return copyFamilies;</span>
        }

<span class="nc" id="L3753">        TreeMap&lt;String,String&gt; familyNames = new TreeMap&lt;String,String&gt;();</span>
        //  these names are always there and aren't localised
        String str;
<span class="nc" id="L3756">        str = Font.SERIF;         familyNames.put(str.toLowerCase(), str);</span>
<span class="nc" id="L3757">        str = Font.SANS_SERIF;    familyNames.put(str.toLowerCase(), str);</span>
<span class="nc" id="L3758">        str = Font.MONOSPACED;    familyNames.put(str.toLowerCase(), str);</span>
<span class="nc" id="L3759">        str = Font.DIALOG;        familyNames.put(str.toLowerCase(), str);</span>
<span class="nc" id="L3760">        str = Font.DIALOG_INPUT;  familyNames.put(str.toLowerCase(), str);</span>

        /* Platform APIs may be used to get the set of available family
         * names for the current default locale so long as it is the same
         * as the start-up system locale, rather than loading all fonts.
         */
<span class="nc bnc" id="L3766" title="All 2 branches missed.">        if (requestedLocale.equals(getSystemStartupLocale()) &amp;&amp;</span>
<span class="nc bnc" id="L3767" title="All 2 branches missed.">            getFamilyNamesFromPlatform(familyNames, requestedLocale)) {</span>
            /* Augment platform names with JRE font family names */
<span class="nc" id="L3769">            getJREFontFamilyNames(familyNames, requestedLocale);</span>
        } else {
<span class="nc" id="L3771">            loadFontFiles();</span>
<span class="nc" id="L3772">            Font2D[] physicalfonts = getPhysicalFonts();</span>
<span class="nc bnc" id="L3773" title="All 2 branches missed.">            for (int i=0; i &lt; physicalfonts.length; i++) {</span>
<span class="nc bnc" id="L3774" title="All 2 branches missed.">                if (!(physicalfonts[i] instanceof NativeFont)) {</span>
<span class="nc" id="L3775">                    String name =</span>
<span class="nc" id="L3776">                        physicalfonts[i].getFamilyName(requestedLocale);</span>
<span class="nc" id="L3777">                    familyNames.put(name.toLowerCase(requestedLocale), name);</span>
                }
            }
        }

        // Add any native font family names here
<span class="nc" id="L3783">        addNativeFontFamilyNames(familyNames, requestedLocale);</span>

<span class="nc" id="L3785">        String[] retval =  new String[familyNames.size()];</span>
<span class="nc" id="L3786">        Object [] keyNames = familyNames.keySet().toArray();</span>
<span class="nc bnc" id="L3787" title="All 2 branches missed.">        for (int i=0; i &lt; keyNames.length; i++) {</span>
<span class="nc" id="L3788">            retval[i] = (String)familyNames.get(keyNames[i]);</span>
        }
<span class="nc bnc" id="L3790" title="All 2 branches missed.">        if (requestedLocale.equals(Locale.getDefault())) {</span>
<span class="nc" id="L3791">            lastDefaultLocale = requestedLocale;</span>
<span class="nc" id="L3792">            allFamilies = new String[retval.length];</span>
<span class="nc" id="L3793">            System.arraycopy(retval, 0, allFamilies, 0, allFamilies.length);</span>
        }
<span class="nc" id="L3795">        return retval;</span>
    }

    // Provides an aperture to add native font family names to the map
<span class="nc" id="L3799">    protected void addNativeFontFamilyNames(TreeMap&lt;String, String&gt; familyNames, Locale requestedLocale) { }</span>

    public void register1dot0Fonts() {
<span class="nc" id="L3802">        java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L3803">                            new java.security.PrivilegedAction() {</span>
            public Object run() {
<span class="nc" id="L3805">                String type1Dir = &quot;/usr/openwin/lib/X11/fonts/Type1&quot;;</span>
<span class="nc" id="L3806">                registerFontsInDir(type1Dir, true, Font2D.TYPE1_RANK,</span>
                                   false, false);
<span class="nc" id="L3808">                return null;</span>
            }
        });
<span class="nc" id="L3811">    }</span>

    /* Really we need only the JRE fonts family names, but there's little
     * overhead in doing this the easy way by adding all the currently
     * known fonts.
     */
    protected void getJREFontFamilyNames(TreeMap&lt;String,String&gt; familyNames,
                                         Locale requestedLocale) {
<span class="nc" id="L3819">        registerDeferredJREFonts(jreFontDirName);</span>
<span class="nc" id="L3820">        Font2D[] physicalfonts = getPhysicalFonts();</span>
<span class="nc bnc" id="L3821" title="All 2 branches missed.">        for (int i=0; i &lt; physicalfonts.length; i++) {</span>
<span class="nc bnc" id="L3822" title="All 2 branches missed.">            if (!(physicalfonts[i] instanceof NativeFont)) {</span>
<span class="nc" id="L3823">                String name =</span>
<span class="nc" id="L3824">                    physicalfonts[i].getFamilyName(requestedLocale);</span>
<span class="nc" id="L3825">                familyNames.put(name.toLowerCase(requestedLocale), name);</span>
            }
        }
<span class="nc" id="L3828">    }</span>

    /**
     * Default locale can be changed but we need to know the initial locale
     * as that is what is used by native code. Changing Java default locale
     * doesn't affect that.
     * Returns the locale in use when using native code to communicate
     * with platform APIs. On windows this is known as the &quot;system&quot; locale,
     * and it is usually the same as the platform locale, but not always,
     * so this method also checks an implementation property used only
     * on windows and uses that if set.
     */
<span class="nc" id="L3840">    private static Locale systemLocale = null;</span>
    private static Locale getSystemStartupLocale() {
<span class="nc bnc" id="L3842" title="All 2 branches missed.">        if (systemLocale == null) {</span>
<span class="nc" id="L3843">            systemLocale = (Locale)</span>
<span class="nc" id="L3844">                java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L3845">                                    new java.security.PrivilegedAction() {</span>
            public Object run() {
                /* On windows the system locale may be different than the
                 * user locale. This is an unsupported configuration, but
                 * in that case we want to return a dummy locale that will
                 * never cause a match in the usage of this API. This is
                 * important because Windows documents that the family
                 * names of fonts are enumerated using the language of
                 * the system locale. BY returning a dummy locale in that
                 * case we do not use the platform API which would not
                 * return us the names we want.
                 */
<span class="nc" id="L3857">                String fileEncoding = System.getProperty(&quot;file.encoding&quot;, &quot;&quot;);</span>
<span class="nc" id="L3858">                String sysEncoding = System.getProperty(&quot;sun.jnu.encoding&quot;);</span>
<span class="nc bnc" id="L3859" title="All 4 branches missed.">                if (sysEncoding != null &amp;&amp; !sysEncoding.equals(fileEncoding)) {</span>
<span class="nc" id="L3860">                    return Locale.ROOT;</span>
                }

<span class="nc" id="L3863">                String language = System.getProperty(&quot;user.language&quot;, &quot;en&quot;);</span>
<span class="nc" id="L3864">                String country  = System.getProperty(&quot;user.country&quot;,&quot;&quot;);</span>
<span class="nc" id="L3865">                String variant  = System.getProperty(&quot;user.variant&quot;,&quot;&quot;);</span>
<span class="nc" id="L3866">                return new Locale(language, country, variant);</span>
            }
        });
        }
<span class="nc" id="L3870">        return systemLocale;</span>
    }

    void addToPool(FileFont font) {

<span class="nc" id="L3875">        FileFont fontFileToClose = null;</span>
<span class="nc" id="L3876">        int freeSlot = -1;</span>

<span class="nc" id="L3878">        synchronized (fontFileCache) {</span>
            /* Avoid duplicate entries in the pool, and don't close() it,
             * since this method is called only from within open().
             * Seeing a duplicate is most likely to happen if the thread
             * was interrupted during a read, forcing perhaps repeated
             * close and open calls and it eventually it ends up pointing
             * at the same slot.
             */
<span class="nc bnc" id="L3886" title="All 2 branches missed.">            for (int i=0;i&lt;CHANNELPOOLSIZE;i++) {</span>
<span class="nc bnc" id="L3887" title="All 2 branches missed.">                if (fontFileCache[i] == font) {</span>
<span class="nc" id="L3888">                    return;</span>
                }
<span class="nc bnc" id="L3890" title="All 4 branches missed.">                if (fontFileCache[i] == null &amp;&amp; freeSlot &lt; 0) {</span>
<span class="nc" id="L3891">                    freeSlot = i;</span>
                }
            }
<span class="nc bnc" id="L3894" title="All 2 branches missed.">            if (freeSlot &gt;= 0) {</span>
<span class="nc" id="L3895">                fontFileCache[freeSlot] = font;</span>
<span class="nc" id="L3896">                return;</span>
            } else {
                /* replace with new font. */
<span class="nc" id="L3899">                fontFileToClose = fontFileCache[lastPoolIndex];</span>
<span class="nc" id="L3900">                fontFileCache[lastPoolIndex] = font;</span>
                /* lastPoolIndex is updated so that the least recently opened
                 * file will be closed next.
                 */
<span class="nc" id="L3904">                lastPoolIndex = (lastPoolIndex+1) % CHANNELPOOLSIZE;</span>
            }
<span class="nc" id="L3906">        }</span>
        /* Need to close the font file outside of the synchronized block,
         * since its possible some other thread is in an open() call on
         * this font file, and could be holding its lock and the pool lock.
         * Releasing the pool lock allows that thread to continue, so it can
         * then release the lock on this font, allowing the close() call
         * below to proceed.
         * Also, calling close() is safe because any other thread using
         * the font we are closing() synchronizes all reading, so we
         * will not close the file while its in use.
         */
<span class="nc bnc" id="L3917" title="All 2 branches missed.">        if (fontFileToClose != null) {</span>
<span class="nc" id="L3918">            fontFileToClose.close();</span>
        }
<span class="nc" id="L3920">    }</span>

    protected FontUIResource getFontConfigFUIR(String family, int style,
                                               int size)
    {
<span class="nc" id="L3925">        return new FontUIResource(family, style, size);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>