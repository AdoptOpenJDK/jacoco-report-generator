<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FileFontStrike.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.font</a> &gt; <span class="el_source">FileFontStrike.java</span></div><h1>FileFontStrike.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.font;

import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.geom.AffineTransform;
import java.awt.geom.GeneralPath;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.concurrent.ConcurrentHashMap;
import static sun.awt.SunHints.*;


public class FileFontStrike extends PhysicalStrike {

    /* fffe and ffff are values we specially interpret as meaning
     * invisible glyphs.
     */
    static final int INVISIBLE_GLYPHS = 0x0fffe;

    private FileFont fileFont;

    /* REMIND: replace this scheme with one that installs a cache
     * instance of the appropriate type. It will require changes in
     * FontStrikeDisposer and NativeStrike etc.
     */
    private static final int UNINITIALISED = 0;
    private static final int INTARRAY      = 1;
    private static final int LONGARRAY     = 2;
    private static final int SEGINTARRAY   = 3;
    private static final int SEGLONGARRAY  = 4;

<span class="nc" id="L61">    private volatile int glyphCacheFormat = UNINITIALISED;</span>

    /* segmented arrays are blocks of 32 */
    private static final int SEGSHIFT = 5;
    private static final int SEGSIZE  = 1 &lt;&lt; SEGSHIFT;

    private boolean segmentedCache;
    private int[][] segIntGlyphImages;
    private long[][] segLongGlyphImages;

    /* The &quot;metrics&quot; information requested by clients is usually nothing
     * more than the horizontal advance of the character.
     * In most cases this advance and other metrics information is stored
     * in the glyph image cache.
     * But in some cases we do not automatically retrieve the glyph
     * image when the advance is requested. In those cases we want to
     * cache the advances since this has been shown to be important for
     * performance.
     * The segmented cache is used in cases when the single array
     * would be too large.
     */
    private float[] horizontalAdvances;
    private float[][] segHorizontalAdvances;

    /* Outline bounds are used when printing and when drawing outlines
     * to the screen. On balance the relative rarity of these cases
     * and the fact that getting this requires generating a path at
     * the scaler level means that its probably OK to store these
     * in a Java-level hashmap as the trade-off between time and space.
     * Later can revisit whether to cache these at all, or elsewhere.
     * Should also profile whether subsequent to getting the bounds, the
     * outline itself is also requested. The 1.4 implementation doesn't
     * cache outlines so you could generate the path twice - once to get
     * the bounds and again to return the outline to the client.
     * If the two uses are coincident then also look into caching outlines.
     * One simple optimisation is that we could store the last single
     * outline retrieved. This assumes that bounds then outline will always
     * be retrieved for a glyph rather than retrieving bounds for all glyphs
     * then outlines for all glyphs.
     */
    ConcurrentHashMap&lt;Integer, Rectangle2D.Float&gt; boundsMap;
    SoftReference&lt;ConcurrentHashMap&lt;Integer, Point2D.Float&gt;&gt;
        glyphMetricsMapRef;

    AffineTransform invertDevTx;

    boolean useNatives;
    NativeStrike[] nativeStrikes;

    /* Used only for communication to native layer */
    private int intPtSize;

    /* Perform global initialisation needed for Windows native rasterizer */
    private static native boolean initNative();
<span class="nc" id="L115">    private static boolean isXPorLater = false;</span>
    static {
<span class="nc bnc" id="L117" title="All 4 branches missed.">        if (FontUtilities.isWindows &amp;&amp; !FontUtilities.useT2K &amp;&amp;</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            !GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L119">            isXPorLater = initNative();</span>
        }
<span class="nc" id="L121">    }</span>

    FileFontStrike(FileFont fileFont, FontStrikeDesc desc) {
<span class="nc" id="L124">        super(fileFont, desc);</span>
<span class="nc" id="L125">        this.fileFont = fileFont;</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (desc.style != fileFont.style) {</span>
          /* If using algorithmic styling, the base values are
           * boldness = 1.0, italic = 0.0. The superclass constructor
           * initialises these.
           */
<span class="nc bnc" id="L132" title="All 4 branches missed.">            if ((desc.style &amp; Font.ITALIC) == Font.ITALIC &amp;&amp;</span>
                (fileFont.style &amp; Font.ITALIC) == 0) {
<span class="nc" id="L134">                algoStyle = true;</span>
<span class="nc" id="L135">                italic = 0.7f;</span>
            }
<span class="nc bnc" id="L137" title="All 4 branches missed.">            if ((desc.style &amp; Font.BOLD) == Font.BOLD &amp;&amp;</span>
                ((fileFont.style &amp; Font.BOLD) == 0)) {
<span class="nc" id="L139">                algoStyle = true;</span>
<span class="nc" id="L140">                boldness = 1.33f;</span>
            }
        }
<span class="nc" id="L143">        double[] matrix = new double[4];</span>
<span class="nc" id="L144">        AffineTransform at = desc.glyphTx;</span>
<span class="nc" id="L145">        at.getMatrix(matrix);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (!desc.devTx.isIdentity() &amp;&amp;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            desc.devTx.getType() != AffineTransform.TYPE_TRANSLATION) {</span>
            try {
<span class="nc" id="L149">                invertDevTx = desc.devTx.createInverse();</span>
<span class="nc" id="L150">            } catch (NoninvertibleTransformException e) {</span>
<span class="nc" id="L151">            }</span>
        }

        /* Amble fonts are better rendered unhinted although there's the
         * inevitable fuzziness that accompanies this due to no longer
         * snapping stems to the pixel grid. The exception is that in B&amp;W
         * mode they are worse without hinting. The down side to that is that
         * B&amp;W metrics will differ which normally isn't the case, although
         * since AA mode is part of the measuring context that should be OK.
         * We don't expect Amble to be installed in the Windows fonts folder.
         * If we were to, then we'd also might want to disable using the
         * native rasteriser path which is used for LCD mode for platform
         * fonts. since we have no way to disable hinting by GDI.
         * In the case of Amble, since its 'gasp' table says to disable
         * hinting, I'd expect GDI to follow that, so likely it should
         * all be consistent even if GDI used.
         */
<span class="nc bnc" id="L168" title="All 2 branches missed.">        boolean disableHinting = desc.aaHint != INTVAL_TEXT_ANTIALIAS_OFF &amp;&amp;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">                                 fileFont.familyName.startsWith(&quot;Amble&quot;);</span>

        /* If any of the values is NaN then substitute the null scaler context.
         * This will return null images, zero advance, and empty outlines
         * as no rendering need take place in this case.
         * We pass in the null scaler as the singleton null context
         * requires it. However
         */
<span class="nc bnc" id="L177" title="All 4 branches missed.">        if (Double.isNaN(matrix[0]) || Double.isNaN(matrix[1]) ||</span>
<span class="nc bnc" id="L178" title="All 4 branches missed.">            Double.isNaN(matrix[2]) || Double.isNaN(matrix[3]) ||</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">            fileFont.getScaler() == null) {</span>
<span class="nc" id="L180">            pScalerContext = NullFontScaler.getNullScalerContext();</span>
        } else {
<span class="nc" id="L182">            pScalerContext = fileFont.getScaler().createScalerContext(matrix,</span>
                                    desc.aaHint, desc.fmHint,
                                    boldness, italic, disableHinting);
        }

<span class="nc" id="L187">        mapper = fileFont.getMapper();</span>
<span class="nc" id="L188">        int numGlyphs = mapper.getNumGlyphs();</span>

        /* Always segment for fonts with &gt; 256 glyphs, but also for smaller
         * fonts with non-typical sizes and transforms.
         * Segmenting for all non-typical pt sizes helps to minimize memory
         * usage when very many distinct strikes are created.
         * The size range of 0-&gt;5 and 37-&gt;INF for segmenting is arbitrary
         * but the intention is that typical GUI integer point sizes (6-&gt;36)
         * should not segment unless there's another reason to do so.
         */
<span class="nc" id="L198">        float ptSize = (float)matrix[3]; // interpreted only when meaningful.</span>
<span class="nc" id="L199">        int iSize = intPtSize = (int)ptSize;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">        boolean isSimpleTx = (at.getType() &amp; complexTX) == 0;</span>
<span class="nc bnc" id="L201" title="All 12 branches missed.">        segmentedCache =</span>
            (numGlyphs &gt; SEGSIZE &lt;&lt; 3) ||
            ((numGlyphs &gt; SEGSIZE &lt;&lt; 1) &amp;&amp;
             (!isSimpleTx || ptSize != iSize || iSize &lt; 6 || iSize &gt; 36));

        /* This can only happen if we failed to allocate memory for context.
         * NB: in such case we may still have some memory in java heap
         *     but subsequent attempt to allocate null scaler context
         *     may fail too (cause it is allocate in the native heap).
         *     It is not clear how to make this more robust but on the
         *     other hand getting NULL here seems to be extremely unlikely.
         */
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (pScalerContext == 0L) {</span>
            /* REMIND: when the code is updated to install cache objects
             * rather than using a switch this will be more efficient.
             */
<span class="nc" id="L217">            this.disposer = new FontStrikeDisposer(fileFont, desc);</span>
<span class="nc" id="L218">            initGlyphCache();</span>
<span class="nc" id="L219">            pScalerContext = NullFontScaler.getNullScalerContext();</span>
<span class="nc" id="L220">            SunFontManager.getInstance().deRegisterBadFont(fileFont);</span>
<span class="nc" id="L221">            return;</span>
        }
        /* First, see if native code should be used to create the glyph.
         * GDI will return the integer metrics, not fractional metrics, which
         * may be requested for this strike, so we would require here that :
         * desc.fmHint != INTVAL_FRACTIONALMETRICS_ON
         * except that the advance returned by GDI is always overwritten by
         * the JDK rasteriser supplied one (see getGlyphImageFromWindows()).
         */
<span class="nc bnc" id="L230" title="All 6 branches missed.">        if (FontUtilities.isWindows &amp;&amp; isXPorLater &amp;&amp;</span>
            !FontUtilities.useT2K &amp;&amp;
<span class="nc bnc" id="L232" title="All 18 branches missed.">            !GraphicsEnvironment.isHeadless() &amp;&amp;</span>
            !fileFont.useJavaRasterizer &amp;&amp;
            (desc.aaHint == INTVAL_TEXT_ANTIALIAS_LCD_HRGB ||
             desc.aaHint == INTVAL_TEXT_ANTIALIAS_LCD_HBGR) &amp;&amp;
            (matrix[1] == 0.0 &amp;&amp; matrix[2] == 0.0 &amp;&amp;
             matrix[0] == matrix[3] &amp;&amp;
             matrix[0] &gt;= 3.0 &amp;&amp; matrix[0] &lt;= 100.0) &amp;&amp;
<span class="nc bnc" id="L239" title="All 2 branches missed.">            !((TrueTypeFont)fileFont).useEmbeddedBitmapsForSize(intPtSize)) {</span>
<span class="nc" id="L240">            useNatives = true;</span>
        }
<span class="nc bnc" id="L242" title="All 6 branches missed.">        else if (fileFont.checkUseNatives() &amp;&amp; desc.aaHint==0 &amp;&amp; !algoStyle) {</span>
            /* Check its a simple scale of a pt size in the range
             * where native bitmaps typically exist (6-36 pts) */
<span class="nc bnc" id="L245" title="All 10 branches missed.">            if (matrix[1] == 0.0 &amp;&amp; matrix[2] == 0.0 &amp;&amp;</span>
                matrix[0] &gt;= 6.0 &amp;&amp; matrix[0] &lt;= 36.0 &amp;&amp;
                matrix[0] == matrix[3]) {
<span class="nc" id="L248">                useNatives = true;</span>
<span class="nc" id="L249">                int numNatives = fileFont.nativeFonts.length;</span>
<span class="nc" id="L250">                nativeStrikes = new NativeStrike[numNatives];</span>
                /* Maybe initialise these strikes lazily?. But we
                 * know we need at least one
                 */
<span class="nc bnc" id="L254" title="All 2 branches missed.">                for (int i=0; i&lt;numNatives; i++) {</span>
<span class="nc" id="L255">                    nativeStrikes[i] =</span>
                        new NativeStrike(fileFont.nativeFonts[i], desc, false);
                }
            }
        }
<span class="nc bnc" id="L260" title="All 4 branches missed.">        if (FontUtilities.isLogging() &amp;&amp; FontUtilities.isWindows) {</span>
<span class="nc" id="L261">            FontUtilities.getLogger().info</span>
<span class="nc" id="L262">                (&quot;Strike for &quot; + fileFont + &quot; at size = &quot; + intPtSize +</span>
                 &quot; use natives = &quot; + useNatives +
                 &quot; useJavaRasteriser = &quot; + fileFont.useJavaRasterizer +
                 &quot; AAHint = &quot; + desc.aaHint +
                 &quot; Has Embedded bitmaps = &quot; +
                 ((TrueTypeFont)fileFont).
<span class="nc" id="L268">                 useEmbeddedBitmapsForSize(intPtSize));</span>
        }
<span class="nc" id="L270">        this.disposer = new FontStrikeDisposer(fileFont, desc, pScalerContext);</span>

        /* Always get the image and the advance together for smaller sizes
         * that are likely to be important to rendering performance.
         * The pixel size of 48.0 can be thought of as
         * &quot;maximumSizeForGetImageWithAdvance&quot;.
         * This should be no greater than OutlineTextRender.THRESHOLD.
         */
<span class="nc" id="L278">        double maxSz = 48.0;</span>
<span class="nc" id="L279">        getImageWithAdvance =</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            Math.abs(at.getScaleX()) &lt;= maxSz &amp;&amp;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            Math.abs(at.getScaleY()) &lt;= maxSz &amp;&amp;</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">            Math.abs(at.getShearX()) &lt;= maxSz &amp;&amp;</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">            Math.abs(at.getShearY()) &lt;= maxSz;</span>

        /* Some applications request advance frequently during layout.
         * If we are not getting and caching the image with the advance,
         * there is a potentially significant performance penalty if the
         * advance is repeatedly requested before requesting the image.
         * We should at least cache the horizontal advance.
         * REMIND: could use info in the font, eg hmtx, to retrieve some
         * advances. But still want to cache it here.
         */

<span class="nc bnc" id="L294" title="All 2 branches missed.">        if (!getImageWithAdvance) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">            if (!segmentedCache) {</span>
<span class="nc" id="L296">                horizontalAdvances = new float[numGlyphs];</span>
                /* use max float as uninitialised advance */
<span class="nc bnc" id="L298" title="All 2 branches missed.">                for (int i=0; i&lt;numGlyphs; i++) {</span>
<span class="nc" id="L299">                    horizontalAdvances[i] = Float.MAX_VALUE;</span>
                }
            } else {
<span class="nc" id="L302">                int numSegments = (numGlyphs + SEGSIZE-1)/SEGSIZE;</span>
<span class="nc" id="L303">                segHorizontalAdvances = new float[numSegments][];</span>
            }
        }
<span class="nc" id="L306">    }</span>

    /* A number of methods are delegated by the strike to the scaler
     * context which is a shared resource on a physical font.
     */

    public int getNumGlyphs() {
<span class="nc" id="L313">        return fileFont.getNumGlyphs();</span>
    }

    long getGlyphImageFromNative(int glyphCode) {
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (FontUtilities.isWindows) {</span>
<span class="nc" id="L318">            return getGlyphImageFromWindows(glyphCode);</span>
        } else {
<span class="nc" id="L320">            return getGlyphImageFromX11(glyphCode);</span>
        }
    }

    /* There's no global state conflicts, so this method is not
     * presently synchronized.
     */
    private native long _getGlyphImageFromWindows(String family,
                                                  int style,
                                                  int size,
                                                  int glyphCode,
                                                  boolean fracMetrics);

    long getGlyphImageFromWindows(int glyphCode) {
<span class="nc" id="L334">        String family = fileFont.getFamilyName(null);</span>
<span class="nc" id="L335">        int style = desc.style &amp; Font.BOLD | desc.style &amp; Font.ITALIC</span>
<span class="nc" id="L336">            | fileFont.getStyle();</span>
<span class="nc" id="L337">        int size = intPtSize;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        long ptr = _getGlyphImageFromWindows</span>
<span class="nc" id="L339">            (family, style, size, glyphCode,</span>
             desc.fmHint == INTVAL_FRACTIONALMETRICS_ON);
<span class="nc bnc" id="L341" title="All 2 branches missed.">        if (ptr != 0) {</span>
            /* Get the advance from the JDK rasterizer. This is mostly
             * necessary for the fractional metrics case, but there are
             * also some very small number (&lt;0.25%) of marginal cases where
             * there is some rounding difference between windows and JDK.
             * After these are resolved, we can restrict this extra
             * work to the FM case.
             */
<span class="nc" id="L349">            float advance = getGlyphAdvance(glyphCode, false);</span>
<span class="nc" id="L350">            StrikeCache.unsafe.putFloat(ptr + StrikeCache.xAdvanceOffset,</span>
                                        advance);
<span class="nc" id="L352">            return ptr;</span>
        } else {
<span class="nc" id="L354">            return fileFont.getGlyphImage(pScalerContext, glyphCode);</span>
        }
    }

    /* Try the native strikes first, then try the fileFont strike */
    long getGlyphImageFromX11(int glyphCode) {
        long glyphPtr;
<span class="nc" id="L361">        char charCode = fileFont.glyphToCharMap[glyphCode];</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">        for (int i=0;i&lt;nativeStrikes.length;i++) {</span>
<span class="nc" id="L363">            CharToGlyphMapper mapper = fileFont.nativeFonts[i].getMapper();</span>
<span class="nc" id="L364">            int gc = mapper.charToGlyph(charCode)&amp;0xffff;</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">            if (gc != mapper.getMissingGlyphCode()) {</span>
<span class="nc" id="L366">                glyphPtr = nativeStrikes[i].getGlyphImagePtrNoCache(gc);</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                if (glyphPtr != 0L) {</span>
<span class="nc" id="L368">                    return glyphPtr;</span>
                }
            }
        }
<span class="nc" id="L372">        return fileFont.getGlyphImage(pScalerContext, glyphCode);</span>
    }

    long getGlyphImagePtr(int glyphCode) {
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (glyphCode &gt;= INVISIBLE_GLYPHS) {</span>
<span class="nc" id="L377">            return StrikeCache.invisibleGlyphPtr;</span>
        }
<span class="nc" id="L379">        long glyphPtr = 0L;</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">        if ((glyphPtr = getCachedGlyphPtr(glyphCode)) != 0L) {</span>
<span class="nc" id="L381">            return glyphPtr;</span>
        } else {
<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (useNatives) {</span>
<span class="nc" id="L384">                glyphPtr = getGlyphImageFromNative(glyphCode);</span>
<span class="nc bnc" id="L385" title="All 4 branches missed.">                if (glyphPtr == 0L &amp;&amp; FontUtilities.isLogging()) {</span>
<span class="nc" id="L386">                    FontUtilities.getLogger().info</span>
<span class="nc" id="L387">                        (&quot;Strike for &quot; + fileFont +</span>
                         &quot; at size = &quot; + intPtSize +
                         &quot; couldn't get native glyph for code = &quot; + glyphCode);
                 }
<span class="nc bnc" id="L391" title="All 2 branches missed.">            } if (glyphPtr == 0L) {</span>
<span class="nc" id="L392">                glyphPtr = fileFont.getGlyphImage(pScalerContext,</span>
                                                  glyphCode);
            }
<span class="nc" id="L395">            return setCachedGlyphPtr(glyphCode, glyphPtr);</span>
        }
    }

    void getGlyphImagePtrs(int[] glyphCodes, long[] images, int  len) {

<span class="nc bnc" id="L401" title="All 2 branches missed.">        for (int i=0; i&lt;len; i++) {</span>
<span class="nc" id="L402">            int glyphCode = glyphCodes[i];</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (glyphCode &gt;= INVISIBLE_GLYPHS) {</span>
<span class="nc" id="L404">                images[i] = StrikeCache.invisibleGlyphPtr;</span>
<span class="nc" id="L405">                continue;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">            } else if ((images[i] = getCachedGlyphPtr(glyphCode)) != 0L) {</span>
<span class="nc" id="L407">                continue;</span>
            } else {
<span class="nc" id="L409">                long glyphPtr = 0L;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">                if (useNatives) {</span>
<span class="nc" id="L411">                    glyphPtr = getGlyphImageFromNative(glyphCode);</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                } if (glyphPtr == 0L) {</span>
<span class="nc" id="L413">                    glyphPtr = fileFont.getGlyphImage(pScalerContext,</span>
                                                      glyphCode);
                }
<span class="nc" id="L416">                images[i] = setCachedGlyphPtr(glyphCode, glyphPtr);</span>
            }
        }
<span class="nc" id="L419">    }</span>

    /* The following method is called from CompositeStrike as a special case.
     */
    private static final int SLOTZEROMAX = 0xffffff;
    int getSlot0GlyphImagePtrs(int[] glyphCodes, long[] images, int len) {

<span class="nc" id="L426">        int convertedCnt = 0;</span>

<span class="nc bnc" id="L428" title="All 2 branches missed.">        for (int i=0; i&lt;len; i++) {</span>
<span class="nc" id="L429">            int glyphCode = glyphCodes[i];</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">            if (glyphCode &gt;= SLOTZEROMAX) {</span>
<span class="nc" id="L431">                return convertedCnt;</span>
            } else {
<span class="nc" id="L433">                convertedCnt++;</span>
            }
<span class="nc bnc" id="L435" title="All 2 branches missed.">            if (glyphCode &gt;= INVISIBLE_GLYPHS) {</span>
<span class="nc" id="L436">                images[i] = StrikeCache.invisibleGlyphPtr;</span>
<span class="nc" id="L437">                continue;</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            } else if ((images[i] = getCachedGlyphPtr(glyphCode)) != 0L) {</span>
<span class="nc" id="L439">                continue;</span>
            } else {
<span class="nc" id="L441">                long glyphPtr = 0L;</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">                if (useNatives) {</span>
<span class="nc" id="L443">                    glyphPtr = getGlyphImageFromNative(glyphCode);</span>
                }
<span class="nc bnc" id="L445" title="All 2 branches missed.">                if (glyphPtr == 0L) {</span>
<span class="nc" id="L446">                    glyphPtr = fileFont.getGlyphImage(pScalerContext,</span>
                                                      glyphCode);
                }
<span class="nc" id="L449">                images[i] = setCachedGlyphPtr(glyphCode, glyphPtr);</span>
            }
        }
<span class="nc" id="L452">        return convertedCnt;</span>
    }

    /* Only look in the cache */
    long getCachedGlyphPtr(int glyphCode) {
<span class="nc bnc" id="L457" title="All 5 branches missed.">        switch (glyphCacheFormat) {</span>
            case INTARRAY:
<span class="nc" id="L459">                return intGlyphImages[glyphCode] &amp; INTMASK;</span>
            case SEGINTARRAY:
<span class="nc" id="L461">                int segIndex = glyphCode &gt;&gt; SEGSHIFT;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                if (segIntGlyphImages[segIndex] != null) {</span>
<span class="nc" id="L463">                    int subIndex = glyphCode % SEGSIZE;</span>
<span class="nc" id="L464">                    return segIntGlyphImages[segIndex][subIndex] &amp; INTMASK;</span>
                } else {
<span class="nc" id="L466">                    return 0L;</span>
                }
            case LONGARRAY:
<span class="nc" id="L469">                return longGlyphImages[glyphCode];</span>
            case SEGLONGARRAY:
<span class="nc" id="L471">                segIndex = glyphCode &gt;&gt; SEGSHIFT;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (segLongGlyphImages[segIndex] != null) {</span>
<span class="nc" id="L473">                    int subIndex = glyphCode % SEGSIZE;</span>
<span class="nc" id="L474">                    return segLongGlyphImages[segIndex][subIndex];</span>
                } else {
<span class="nc" id="L476">                    return 0L;</span>
                }
        }
        /* If reach here cache is UNINITIALISED. */
<span class="nc" id="L480">        return 0L;</span>
    }

    private synchronized long setCachedGlyphPtr(int glyphCode, long glyphPtr) {
<span class="nc bnc" id="L484" title="All 5 branches missed.">        switch (glyphCacheFormat) {</span>
            case INTARRAY:
<span class="nc bnc" id="L486" title="All 2 branches missed.">                if (intGlyphImages[glyphCode] == 0) {</span>
<span class="nc" id="L487">                    intGlyphImages[glyphCode] = (int)glyphPtr;</span>
<span class="nc" id="L488">                    return glyphPtr;</span>
                } else {
<span class="nc" id="L490">                    StrikeCache.freeIntPointer((int)glyphPtr);</span>
<span class="nc" id="L491">                    return intGlyphImages[glyphCode] &amp; INTMASK;</span>
                }

            case SEGINTARRAY:
<span class="nc" id="L495">                int segIndex = glyphCode &gt;&gt; SEGSHIFT;</span>
<span class="nc" id="L496">                int subIndex = glyphCode % SEGSIZE;</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                if (segIntGlyphImages[segIndex] == null) {</span>
<span class="nc" id="L498">                    segIntGlyphImages[segIndex] = new int[SEGSIZE];</span>
                }
<span class="nc bnc" id="L500" title="All 2 branches missed.">                if (segIntGlyphImages[segIndex][subIndex] == 0) {</span>
<span class="nc" id="L501">                    segIntGlyphImages[segIndex][subIndex] = (int)glyphPtr;</span>
<span class="nc" id="L502">                    return glyphPtr;</span>
                } else {
<span class="nc" id="L504">                    StrikeCache.freeIntPointer((int)glyphPtr);</span>
<span class="nc" id="L505">                    return segIntGlyphImages[segIndex][subIndex] &amp; INTMASK;</span>
                }

            case LONGARRAY:
<span class="nc bnc" id="L509" title="All 2 branches missed.">                if (longGlyphImages[glyphCode] == 0L) {</span>
<span class="nc" id="L510">                    longGlyphImages[glyphCode] = glyphPtr;</span>
<span class="nc" id="L511">                    return glyphPtr;</span>
                } else {
<span class="nc" id="L513">                    StrikeCache.freeLongPointer(glyphPtr);</span>
<span class="nc" id="L514">                    return longGlyphImages[glyphCode];</span>
                }

           case SEGLONGARRAY:
<span class="nc" id="L518">                segIndex = glyphCode &gt;&gt; SEGSHIFT;</span>
<span class="nc" id="L519">                subIndex = glyphCode % SEGSIZE;</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">                if (segLongGlyphImages[segIndex] == null) {</span>
<span class="nc" id="L521">                    segLongGlyphImages[segIndex] = new long[SEGSIZE];</span>
                }
<span class="nc bnc" id="L523" title="All 2 branches missed.">                if (segLongGlyphImages[segIndex][subIndex] == 0L) {</span>
<span class="nc" id="L524">                    segLongGlyphImages[segIndex][subIndex] = glyphPtr;</span>
<span class="nc" id="L525">                    return glyphPtr;</span>
                } else {
<span class="nc" id="L527">                    StrikeCache.freeLongPointer(glyphPtr);</span>
<span class="nc" id="L528">                    return segLongGlyphImages[segIndex][subIndex];</span>
                }
        }

        /* Reach here only when the cache is not initialised which is only
         * for the first glyph to be initialised in the strike.
         * Initialise it and recurse. Note that we are already synchronized.
         */
<span class="nc" id="L536">        initGlyphCache();</span>
<span class="nc" id="L537">        return setCachedGlyphPtr(glyphCode, glyphPtr);</span>
    }

    /* Called only from synchronized code or constructor */
    private synchronized void initGlyphCache() {

<span class="nc" id="L543">        int numGlyphs = mapper.getNumGlyphs();</span>
<span class="nc" id="L544">        int tmpFormat = UNINITIALISED;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">        if (segmentedCache) {</span>
<span class="nc" id="L546">            int numSegments = (numGlyphs + SEGSIZE-1)/SEGSIZE;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">            if (longAddresses) {</span>
<span class="nc" id="L548">                tmpFormat = SEGLONGARRAY;</span>
<span class="nc" id="L549">                segLongGlyphImages = new long[numSegments][];</span>
<span class="nc" id="L550">                this.disposer.segLongGlyphImages = segLongGlyphImages;</span>
             } else {
<span class="nc" id="L552">                 tmpFormat = SEGINTARRAY;</span>
<span class="nc" id="L553">                 segIntGlyphImages = new int[numSegments][];</span>
<span class="nc" id="L554">                 this.disposer.segIntGlyphImages = segIntGlyphImages;</span>
             }
<span class="nc" id="L556">        } else {</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            if (longAddresses) {</span>
<span class="nc" id="L558">                tmpFormat = LONGARRAY;</span>
<span class="nc" id="L559">                longGlyphImages = new long[numGlyphs];</span>
<span class="nc" id="L560">                this.disposer.longGlyphImages = longGlyphImages;</span>
            } else {
<span class="nc" id="L562">                tmpFormat = INTARRAY;</span>
<span class="nc" id="L563">                intGlyphImages = new int[numGlyphs];</span>
<span class="nc" id="L564">                this.disposer.intGlyphImages = intGlyphImages;</span>
            }
        }
<span class="nc" id="L567">        glyphCacheFormat = tmpFormat;</span>
<span class="nc" id="L568">    }</span>

    float getGlyphAdvance(int glyphCode) {
<span class="nc" id="L571">        return getGlyphAdvance(glyphCode, true);</span>
    }

    /* Metrics info is always retrieved. If the GlyphInfo address is non-zero
     * then metrics info there is valid and can just be copied.
     * This is in user space coordinates unless getUserAdv == false.
     * Device space advance should not be propagated out of this class.
     */
    private float getGlyphAdvance(int glyphCode, boolean getUserAdv) {
        float advance;

<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (glyphCode &gt;= INVISIBLE_GLYPHS) {</span>
<span class="nc" id="L583">            return 0f;</span>
        }

        /* Notes on the (getUserAdv == false) case.
         *
         * Setting getUserAdv == false is internal to this class.
         * If there's no graphics transform we can let
         * getGlyphAdvance take its course, and potentially caching in
         * advances arrays, except for signalling that
         * getUserAdv == false means there is no need to create an image.
         * It is possible that code already calculated the user advance,
         * and it is desirable to take advantage of that work.
         * But, if there's a transform and we want device advance, we
         * can't use any values cached in the advances arrays - unless
         * first re-transform them into device space using 'desc.devTx'.
         * invertDevTx is null if the graphics transform is identity,
         * a translate, or non-invertible. The latter case should
         * not ever occur in the getUserAdv == false path.
         * In other words its either null, or the inversion of a
         * simple uniform scale. If its null, we can populate and
         * use the advance caches as normal.
         *
         * If we don't find a cached value, obtain the device advance and
         * return it. This will get stashed on the image by the caller and any
         * subsequent metrics calls will be able to use it as is the case
         * whenever an image is what is initially requested.
         *
         * Don't query if there's a value cached on the image, since this
         * getUserAdv==false code path is entered solely when none exists.
         */
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (horizontalAdvances != null) {</span>
<span class="nc" id="L614">            advance = horizontalAdvances[glyphCode];</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">            if (advance != Float.MAX_VALUE) {</span>
<span class="nc bnc" id="L616" title="All 4 branches missed.">                if (!getUserAdv &amp;&amp; invertDevTx != null) {</span>
<span class="nc" id="L617">                    Point2D.Float metrics = new Point2D.Float(advance, 0f);</span>
<span class="nc" id="L618">                    desc.devTx.deltaTransform(metrics, metrics);</span>
<span class="nc" id="L619">                    return metrics.x;</span>
                } else {
<span class="nc" id="L621">                    return advance;</span>
                }
            }
<span class="nc bnc" id="L624" title="All 4 branches missed.">        } else if (segmentedCache &amp;&amp; segHorizontalAdvances != null) {</span>
<span class="nc" id="L625">            int segIndex = glyphCode &gt;&gt; SEGSHIFT;</span>
<span class="nc" id="L626">            float[] subArray = segHorizontalAdvances[segIndex];</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">            if (subArray != null) {</span>
<span class="nc" id="L628">                advance = subArray[glyphCode % SEGSIZE];</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">                if (advance != Float.MAX_VALUE) {</span>
<span class="nc bnc" id="L630" title="All 4 branches missed.">                    if (!getUserAdv &amp;&amp; invertDevTx != null) {</span>
<span class="nc" id="L631">                        Point2D.Float metrics = new Point2D.Float(advance, 0f);</span>
<span class="nc" id="L632">                        desc.devTx.deltaTransform(metrics, metrics);</span>
<span class="nc" id="L633">                        return metrics.x;</span>
                    } else {
<span class="nc" id="L635">                        return advance;</span>
                    }
                }
            }
        }

<span class="nc bnc" id="L641" title="All 4 branches missed.">        if (!getUserAdv &amp;&amp; invertDevTx != null) {</span>
<span class="nc" id="L642">            Point2D.Float metrics = new Point2D.Float();</span>
<span class="nc" id="L643">            fileFont.getGlyphMetrics(pScalerContext, glyphCode, metrics);</span>
<span class="nc" id="L644">            return metrics.x;</span>
        }

<span class="nc bnc" id="L647" title="All 4 branches missed.">        if (invertDevTx != null || !getUserAdv) {</span>
            /* If there is a device transform need x &amp; y advance to
             * transform back into user space.
             */
<span class="nc" id="L651">            advance = getGlyphMetrics(glyphCode, getUserAdv).x;</span>
        } else {
            long glyphPtr;
<span class="nc bnc" id="L654" title="All 2 branches missed.">            if (getImageWithAdvance) {</span>
                /* A heuristic optimisation says that for most cases its
                 * worthwhile retrieving the image at the same time as the
                 * advance. So here we get the image data even if its not
                 * already cached.
                 */
<span class="nc" id="L660">                glyphPtr = getGlyphImagePtr(glyphCode);</span>
            } else {
<span class="nc" id="L662">                glyphPtr = getCachedGlyphPtr(glyphCode);</span>
            }
<span class="nc bnc" id="L664" title="All 2 branches missed.">            if (glyphPtr != 0L) {</span>
<span class="nc" id="L665">                advance = StrikeCache.unsafe.getFloat</span>
<span class="nc" id="L666">                    (glyphPtr + StrikeCache.xAdvanceOffset);</span>

            } else {
<span class="nc" id="L669">                advance = fileFont.getGlyphAdvance(pScalerContext, glyphCode);</span>
            }
        }

<span class="nc bnc" id="L673" title="All 2 branches missed.">        if (horizontalAdvances != null) {</span>
<span class="nc" id="L674">            horizontalAdvances[glyphCode] = advance;</span>
<span class="nc bnc" id="L675" title="All 4 branches missed.">        } else if (segmentedCache &amp;&amp; segHorizontalAdvances != null) {</span>
<span class="nc" id="L676">            int segIndex = glyphCode &gt;&gt; SEGSHIFT;</span>
<span class="nc" id="L677">            int subIndex = glyphCode % SEGSIZE;</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">            if (segHorizontalAdvances[segIndex] == null) {</span>
<span class="nc" id="L679">                segHorizontalAdvances[segIndex] = new float[SEGSIZE];</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                for (int i=0; i&lt;SEGSIZE; i++) {</span>
<span class="nc" id="L681">                     segHorizontalAdvances[segIndex][i] = Float.MAX_VALUE;</span>
                }
            }
<span class="nc" id="L684">            segHorizontalAdvances[segIndex][subIndex] = advance;</span>
        }
<span class="nc" id="L686">        return advance;</span>
    }

    float getCodePointAdvance(int cp) {
<span class="nc" id="L690">        return getGlyphAdvance(mapper.charToGlyph(cp));</span>
    }

    /**
     * Result and pt are both in device space.
     */
    void getGlyphImageBounds(int glyphCode, Point2D.Float pt,
                             Rectangle result) {

<span class="nc" id="L699">        long ptr = getGlyphImagePtr(glyphCode);</span>
        float topLeftX, topLeftY;

        /* With our current design NULL ptr is not possible
           but if we eventually allow scalers to return NULL pointers
           this check might be actually useful. */
<span class="nc bnc" id="L705" title="All 2 branches missed.">        if (ptr == 0L) {</span>
<span class="nc" id="L706">            result.x = (int) Math.floor(pt.x);</span>
<span class="nc" id="L707">            result.y = (int) Math.floor(pt.y);</span>
<span class="nc" id="L708">            result.width = result.height = 0;</span>
<span class="nc" id="L709">            return;</span>
        }

<span class="nc" id="L712">        topLeftX = StrikeCache.unsafe.getFloat(ptr+StrikeCache.topLeftXOffset);</span>
<span class="nc" id="L713">        topLeftY = StrikeCache.unsafe.getFloat(ptr+StrikeCache.topLeftYOffset);</span>

<span class="nc" id="L715">        result.x = (int)Math.floor(pt.x + topLeftX);</span>
<span class="nc" id="L716">        result.y = (int)Math.floor(pt.y + topLeftY);</span>
<span class="nc" id="L717">        result.width =</span>
<span class="nc" id="L718">            StrikeCache.unsafe.getShort(ptr+StrikeCache.widthOffset)  &amp;0x0ffff;</span>
<span class="nc" id="L719">        result.height =</span>
<span class="nc" id="L720">            StrikeCache.unsafe.getShort(ptr+StrikeCache.heightOffset) &amp;0x0ffff;</span>

        /* HRGB LCD text may have padding that is empty. This is almost always
         * going to be when topLeftX is -2 or less.
         * Try to return a tighter bounding box in that case.
         * If the first three bytes of every row are all zero, then
         * add 1 to &quot;x&quot; and reduce &quot;width&quot; by 1.
         */
<span class="nc bnc" id="L728" title="All 6 branches missed.">        if ((desc.aaHint == INTVAL_TEXT_ANTIALIAS_LCD_HRGB ||</span>
             desc.aaHint == INTVAL_TEXT_ANTIALIAS_LCD_HBGR)
            &amp;&amp; topLeftX &lt;= -2.0f) {
<span class="nc" id="L731">            int minx = getGlyphImageMinX(ptr, (int)result.x);</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">            if (minx &gt; result.x) {</span>
<span class="nc" id="L733">                result.x += 1;</span>
<span class="nc" id="L734">                result.width -=1;</span>
            }
        }
<span class="nc" id="L737">    }</span>

    private int getGlyphImageMinX(long ptr, int origMinX) {

<span class="nc" id="L741">        int width = StrikeCache.unsafe.getChar(ptr+StrikeCache.widthOffset);</span>
<span class="nc" id="L742">        int height = StrikeCache.unsafe.getChar(ptr+StrikeCache.heightOffset);</span>
<span class="nc" id="L743">        int rowBytes =</span>
<span class="nc" id="L744">            StrikeCache.unsafe.getChar(ptr+StrikeCache.rowBytesOffset);</span>

<span class="nc bnc" id="L746" title="All 2 branches missed.">        if (rowBytes == width) {</span>
<span class="nc" id="L747">            return origMinX;</span>
        }

<span class="nc" id="L750">        long pixelData =</span>
<span class="nc" id="L751">            StrikeCache.unsafe.getAddress(ptr + StrikeCache.pixelDataOffset);</span>

<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (pixelData == 0L) {</span>
<span class="nc" id="L754">            return origMinX;</span>
        }

<span class="nc bnc" id="L757" title="All 2 branches missed.">        for (int y=0;y&lt;height;y++) {</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">            for (int x=0;x&lt;3;x++) {</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                if (StrikeCache.unsafe.getByte(pixelData+y*rowBytes+x) != 0) {</span>
<span class="nc" id="L760">                    return origMinX;</span>
                }
            }
        }
<span class="nc" id="L764">        return origMinX+1;</span>
    }

    /* These 3 metrics methods below should be implemented to return
     * values in user space.
     */
    StrikeMetrics getFontMetrics() {
<span class="nc bnc" id="L771" title="All 2 branches missed.">        if (strikeMetrics == null) {</span>
<span class="nc" id="L772">            strikeMetrics =</span>
<span class="nc" id="L773">                fileFont.getFontMetrics(pScalerContext);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">            if (invertDevTx != null) {</span>
<span class="nc" id="L775">                strikeMetrics.convertToUserSpace(invertDevTx);</span>
            }
        }
<span class="nc" id="L778">        return strikeMetrics;</span>
    }

    Point2D.Float getGlyphMetrics(int glyphCode) {
<span class="nc" id="L782">        return getGlyphMetrics(glyphCode, true);</span>
    }

    private Point2D.Float getGlyphMetrics(int glyphCode, boolean getImage) {
<span class="nc" id="L786">        Point2D.Float metrics = new Point2D.Float();</span>

        // !!! or do we force sgv user glyphs?
<span class="nc bnc" id="L789" title="All 2 branches missed.">        if (glyphCode &gt;= INVISIBLE_GLYPHS) {</span>
<span class="nc" id="L790">            return metrics;</span>
        }
        long glyphPtr;
<span class="nc bnc" id="L793" title="All 4 branches missed.">        if (getImageWithAdvance &amp;&amp; getImage) {</span>
            /* A heuristic optimisation says that for most cases its
             * worthwhile retrieving the image at the same time as the
             * metrics. So here we get the image data even if its not
             * already cached.
             */
<span class="nc" id="L799">            glyphPtr = getGlyphImagePtr(glyphCode);</span>
        } else {
<span class="nc" id="L801">             glyphPtr = getCachedGlyphPtr(glyphCode);</span>
        }
<span class="nc bnc" id="L803" title="All 2 branches missed.">        if (glyphPtr != 0L) {</span>
<span class="nc" id="L804">            metrics = new Point2D.Float();</span>
<span class="nc" id="L805">            metrics.x = StrikeCache.unsafe.getFloat</span>
<span class="nc" id="L806">                (glyphPtr + StrikeCache.xAdvanceOffset);</span>
<span class="nc" id="L807">            metrics.y = StrikeCache.unsafe.getFloat</span>
<span class="nc" id="L808">                (glyphPtr + StrikeCache.yAdvanceOffset);</span>
            /* advance is currently in device space, need to convert back
             * into user space.
             * This must not include the translation component. */
<span class="nc bnc" id="L812" title="All 2 branches missed.">            if (invertDevTx != null) {</span>
<span class="nc" id="L813">                invertDevTx.deltaTransform(metrics, metrics);</span>
            }
        } else {
            /* We sometimes cache these metrics as they are expensive to
             * generate for large glyphs.
             * We never reach this path if we obtain images with advances.
             * But if we do not obtain images with advances its possible that
             * we first obtain this information, then the image, and never
             * will access this value again.
             */
<span class="nc" id="L823">            Integer key = Integer.valueOf(glyphCode);</span>
<span class="nc" id="L824">            Point2D.Float value = null;</span>
<span class="nc" id="L825">            ConcurrentHashMap&lt;Integer, Point2D.Float&gt; glyphMetricsMap = null;</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">            if (glyphMetricsMapRef != null) {</span>
<span class="nc" id="L827">                glyphMetricsMap = glyphMetricsMapRef.get();</span>
            }
<span class="nc bnc" id="L829" title="All 2 branches missed.">            if (glyphMetricsMap != null) {</span>
<span class="nc" id="L830">                value = glyphMetricsMap.get(key);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">                if (value != null) {</span>
<span class="nc" id="L832">                    metrics.x = value.x;</span>
<span class="nc" id="L833">                    metrics.y = value.y;</span>
                    /* already in user space */
<span class="nc" id="L835">                    return metrics;</span>
                }
            }
<span class="nc bnc" id="L838" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L839">                fileFont.getGlyphMetrics(pScalerContext, glyphCode, metrics);</span>
                /* advance is currently in device space, need to convert back
                 * into user space.
                 */
<span class="nc bnc" id="L843" title="All 2 branches missed.">                if (invertDevTx != null) {</span>
<span class="nc" id="L844">                    invertDevTx.deltaTransform(metrics, metrics);</span>
                }
<span class="nc" id="L846">                value = new Point2D.Float(metrics.x, metrics.y);</span>
                /* We aren't synchronizing here so it is possible to
                 * overwrite the map with another one but this is harmless.
                 */
<span class="nc bnc" id="L850" title="All 2 branches missed.">                if (glyphMetricsMap == null) {</span>
<span class="nc" id="L851">                    glyphMetricsMap =</span>
                        new ConcurrentHashMap&lt;Integer, Point2D.Float&gt;();
<span class="nc" id="L853">                    glyphMetricsMapRef =</span>
                        new SoftReference&lt;ConcurrentHashMap&lt;Integer,
                        Point2D.Float&gt;&gt;(glyphMetricsMap);
                }
<span class="nc" id="L857">                glyphMetricsMap.put(key, value);</span>
            }
        }
<span class="nc" id="L860">        return metrics;</span>
    }

    Point2D.Float getCharMetrics(char ch) {
<span class="nc" id="L864">        return getGlyphMetrics(mapper.charToGlyph(ch));</span>
    }

    /* The caller of this can be trusted to return a copy of this
     * return value rectangle to public API. In fact frequently it
     * can't use use this return value directly anyway.
     * This returns bounds in device space. Currently the only
     * caller is SGV and it converts back to user space.
     * We could change things so that this code does the conversion so
     * that all coords coming out of the font system are converted back
     * into user space even if they were measured in device space.
     * The same applies to the other methods that return outlines (below)
     * But it may make particular sense for this method that caches its
     * results.
     * There'd be plenty of exceptions, to this too, eg getGlyphPoint needs
     * device coords as its called from native layout and getGlyphImageBounds
     * is used by GlyphVector.getGlyphPixelBounds which is specified to
     * return device coordinates, the image pointers aren't really used
     * up in Java code either.
     */
    Rectangle2D.Float getGlyphOutlineBounds(int glyphCode) {

<span class="nc bnc" id="L886" title="All 2 branches missed.">        if (boundsMap == null) {</span>
<span class="nc" id="L887">            boundsMap = new ConcurrentHashMap&lt;Integer, Rectangle2D.Float&gt;();</span>
        }

<span class="nc" id="L890">        Integer key = Integer.valueOf(glyphCode);</span>
<span class="nc" id="L891">        Rectangle2D.Float bounds = boundsMap.get(key);</span>

<span class="nc bnc" id="L893" title="All 2 branches missed.">        if (bounds == null) {</span>
<span class="nc" id="L894">            bounds = fileFont.getGlyphOutlineBounds(pScalerContext, glyphCode);</span>
<span class="nc" id="L895">            boundsMap.put(key, bounds);</span>
        }
<span class="nc" id="L897">        return bounds;</span>
    }

    public Rectangle2D getOutlineBounds(int glyphCode) {
<span class="nc" id="L901">        return fileFont.getGlyphOutlineBounds(pScalerContext, glyphCode);</span>
    }

    private
        WeakReference&lt;ConcurrentHashMap&lt;Integer,GeneralPath&gt;&gt; outlineMapRef;

    GeneralPath getGlyphOutline(int glyphCode, float x, float y) {

<span class="nc" id="L909">        GeneralPath gp = null;</span>
<span class="nc" id="L910">        ConcurrentHashMap&lt;Integer, GeneralPath&gt; outlineMap = null;</span>

<span class="nc bnc" id="L912" title="All 2 branches missed.">        if (outlineMapRef != null) {</span>
<span class="nc" id="L913">            outlineMap = outlineMapRef.get();</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">            if (outlineMap != null) {</span>
<span class="nc" id="L915">                gp = (GeneralPath)outlineMap.get(glyphCode);</span>
            }
        }

<span class="nc bnc" id="L919" title="All 2 branches missed.">        if (gp == null) {</span>
<span class="nc" id="L920">            gp = fileFont.getGlyphOutline(pScalerContext, glyphCode, 0, 0);</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">            if (outlineMap == null) {</span>
<span class="nc" id="L922">                outlineMap = new ConcurrentHashMap&lt;Integer, GeneralPath&gt;();</span>
<span class="nc" id="L923">                outlineMapRef =</span>
                   new WeakReference
                       &lt;ConcurrentHashMap&lt;Integer,GeneralPath&gt;&gt;(outlineMap);
            }
<span class="nc" id="L927">            outlineMap.put(glyphCode, gp);</span>
        }
<span class="nc" id="L929">        gp = (GeneralPath)gp.clone(); // mutable!</span>
<span class="nc bnc" id="L930" title="All 4 branches missed.">        if (x != 0f || y != 0f) {</span>
<span class="nc" id="L931">            gp.transform(AffineTransform.getTranslateInstance(x, y));</span>
        }
<span class="nc" id="L933">        return gp;</span>
    }

    GeneralPath getGlyphVectorOutline(int[] glyphs, float x, float y) {
<span class="nc" id="L937">        return fileFont.getGlyphVectorOutline(pScalerContext,</span>
                                              glyphs, glyphs.length, x, y);
    }

    protected void adjustPoint(Point2D.Float pt) {
<span class="nc bnc" id="L942" title="All 2 branches missed.">        if (invertDevTx != null) {</span>
<span class="nc" id="L943">            invertDevTx.deltaTransform(pt, pt);</span>
        }
<span class="nc" id="L945">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>