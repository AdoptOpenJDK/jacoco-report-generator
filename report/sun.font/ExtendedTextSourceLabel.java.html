<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ExtendedTextSourceLabel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.font</a> &gt; <span class="el_source">ExtendedTextSourceLabel.java</span></div><h1>ExtendedTextSourceLabel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
/*
 *
 * (C) Copyright IBM Corp. 1998-2003 - All Rights Reserved
 */

package sun.font;

import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Shape;

import java.awt.font.FontRenderContext;
import java.awt.font.GlyphJustificationInfo;
import java.awt.font.GlyphMetrics;
import java.awt.font.LineMetrics;
import java.awt.font.TextAttribute;

import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

import java.util.Map;

/**
 * Default implementation of ExtendedTextLabel.
 */

// {jbr} I made this class package-private to keep the
// Decoration.Label API package-private.

/* public */
class ExtendedTextSourceLabel extends ExtendedTextLabel implements Decoration.Label {

  TextSource source;
  private Decoration decorator;

  // caches
  private Font font;
  private AffineTransform baseTX;
  private CoreMetrics cm;

  Rectangle2D lb;
  Rectangle2D ab;
  Rectangle2D vb;
  Rectangle2D ib;
  StandardGlyphVector gv;
  float[] charinfo;

  /**
   * Create from a TextSource.
   */
<span class="nc" id="L77">  public ExtendedTextSourceLabel(TextSource source, Decoration decorator) {</span>
<span class="nc" id="L78">    this.source = source;</span>
<span class="nc" id="L79">    this.decorator = decorator;</span>
<span class="nc" id="L80">    finishInit();</span>
<span class="nc" id="L81">  }</span>

  /**
   * Create from a TextSource, optionally using cached data from oldLabel starting at the offset.
   * If present oldLabel must have been created from a run of text that includes the text used in
   * the new label.  Start in source corresponds to logical character offset in oldLabel.
   */
<span class="nc" id="L88">  public ExtendedTextSourceLabel(TextSource source, ExtendedTextSourceLabel oldLabel, int offset) {</span>
    // currently no optimization.
<span class="nc" id="L90">    this.source = source;</span>
<span class="nc" id="L91">    this.decorator = oldLabel.decorator;</span>
<span class="nc" id="L92">    finishInit();</span>
<span class="nc" id="L93">  }</span>

  private void finishInit() {
<span class="nc" id="L96">    font = source.getFont();</span>

<span class="nc" id="L98">    Map&lt;TextAttribute, ?&gt; atts = font.getAttributes();</span>
<span class="nc" id="L99">    baseTX = AttributeValues.getBaselineTransform(atts);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">    if (baseTX == null){</span>
<span class="nc" id="L101">        cm = source.getCoreMetrics();</span>
    } else {
<span class="nc" id="L103">      AffineTransform charTX = AttributeValues.getCharTransform(atts);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">      if (charTX == null) {</span>
<span class="nc" id="L105">          charTX = new AffineTransform();</span>
      }
<span class="nc" id="L107">      font = font.deriveFont(charTX);</span>

<span class="nc" id="L109">      LineMetrics lm = font.getLineMetrics(source.getChars(), source.getStart(),</span>
<span class="nc" id="L110">          source.getStart() + source.getLength(), source.getFRC());</span>
<span class="nc" id="L111">      cm = CoreMetrics.get(lm);</span>
    }
<span class="nc" id="L113">  }</span>


  // TextLabel API

  public Rectangle2D getLogicalBounds() {
<span class="nc" id="L119">    return getLogicalBounds(0, 0);</span>
  }

  public Rectangle2D getLogicalBounds(float x, float y) {
<span class="nc bnc" id="L123" title="All 2 branches missed.">    if (lb == null) {</span>
<span class="nc" id="L124">      lb = createLogicalBounds();</span>
    }
<span class="nc" id="L126">    return new Rectangle2D.Float((float)(lb.getX() + x),</span>
<span class="nc" id="L127">                                 (float)(lb.getY() + y),</span>
<span class="nc" id="L128">                                 (float)lb.getWidth(),</span>
<span class="nc" id="L129">                                 (float)lb.getHeight());</span>
  }

    public float getAdvance() {
<span class="nc bnc" id="L133" title="All 2 branches missed.">        if (lb == null) {</span>
<span class="nc" id="L134">            lb = createLogicalBounds();</span>
        }
<span class="nc" id="L136">        return (float)lb.getWidth();</span>
    }

  public Rectangle2D getVisualBounds(float x, float y) {
<span class="nc bnc" id="L140" title="All 2 branches missed.">    if (vb == null) {</span>
<span class="nc" id="L141">      vb = decorator.getVisualBounds(this);</span>
    }
<span class="nc" id="L143">    return new Rectangle2D.Float((float)(vb.getX() + x),</span>
<span class="nc" id="L144">                                 (float)(vb.getY() + y),</span>
<span class="nc" id="L145">                                 (float)vb.getWidth(),</span>
<span class="nc" id="L146">                                 (float)vb.getHeight());</span>
  }

  public Rectangle2D getAlignBounds(float x, float y) {
<span class="nc bnc" id="L150" title="All 2 branches missed.">    if (ab == null) {</span>
<span class="nc" id="L151">      ab = createAlignBounds();</span>
    }
<span class="nc" id="L153">    return new Rectangle2D.Float((float)(ab.getX() + x),</span>
<span class="nc" id="L154">                                 (float)(ab.getY() + y),</span>
<span class="nc" id="L155">                                 (float)ab.getWidth(),</span>
<span class="nc" id="L156">                                 (float)ab.getHeight());</span>

  }

  public Rectangle2D getItalicBounds(float x, float y) {
<span class="nc bnc" id="L161" title="All 2 branches missed.">    if (ib == null) {</span>
<span class="nc" id="L162">      ib = createItalicBounds();</span>
    }
<span class="nc" id="L164">    return new Rectangle2D.Float((float)(ib.getX() + x),</span>
<span class="nc" id="L165">                                 (float)(ib.getY() + y),</span>
<span class="nc" id="L166">                                 (float)ib.getWidth(),</span>
<span class="nc" id="L167">                                 (float)ib.getHeight());</span>

  }

  public Rectangle getPixelBounds(FontRenderContext frc, float x, float y) {
<span class="nc" id="L172">      return getGV().getPixelBounds(frc, x, y);</span>
  }

  public boolean isSimple() {
<span class="nc bnc" id="L176" title="All 4 branches missed.">      return decorator == Decoration.getPlainDecoration() &amp;&amp;</span>
             baseTX == null;
  }

  public AffineTransform getBaselineTransform() {
<span class="nc" id="L181">      return baseTX; // passing internal object, caller must not modify!</span>
  }

  public Shape handleGetOutline(float x, float y) {
<span class="nc" id="L185">    return getGV().getOutline(x, y);</span>
  }

  public Shape getOutline(float x, float y) {
<span class="nc" id="L189">    return decorator.getOutline(this, x, y);</span>
  }

  public void handleDraw(Graphics2D g, float x, float y) {
<span class="nc" id="L193">    g.drawGlyphVector(getGV(), x, y);</span>
<span class="nc" id="L194">  }</span>

  public void draw(Graphics2D g, float x, float y) {
<span class="nc" id="L197">    decorator.drawTextAndDecorations(this, g, x, y);</span>
<span class="nc" id="L198">  }</span>

  /**
   * The logical bounds extends from the origin of the glyphvector to the
   * position at which a following glyphvector's origin should be placed.
   * We always assume glyph vectors are rendered from left to right, so
   * the origin is always to the left.
   * &lt;p&gt; On a left-to-right run, combining marks and 'ligatured away'
   * characters are to the right of their base characters.  The charinfo
   * array will record the character positions for these 'missing' characters
   * as being at the origin+advance of the base glyph, with zero advance.
   * (This is not necessarily the same as the glyph position, for example,
   * an umlaut glyph may have a position to the left of this point, it depends
   * on whether the font was designed so that such glyphs overhang to the left
   * of their origin, or whether it presumes some kind of kerning to position
   * the glyphs).  Anyway, the left of the bounds is the origin of the first
   * logical (leftmost) character, and the right is the origin + advance of the
   * last logical (rightmost) character.
   * &lt;p&gt; On a right-to-left run, these special characters are to the left
   * of their base characters.  Again, since 'glyph position' has been abstracted
   * away, we can use the origin of the leftmost character, and the origin +
   * advance of the rightmost character.
   * &lt;p&gt; On a mixed run (hindi) we can't rely on the first logical character
   * being the leftmost character.  However we can again rely on the leftmost
   * character origin and the rightmost character + advance.
   */
  protected Rectangle2D createLogicalBounds() {
<span class="nc" id="L225">    return getGV().getLogicalBounds();</span>
  }

  public Rectangle2D handleGetVisualBounds() {
<span class="nc" id="L229">    return getGV().getVisualBounds();</span>
  }

  /**
   * Like createLogicalBounds except ignore leading and logically trailing white space.
   * this assumes logically trailing whitespace is also visually trailing.
   * Whitespace is anything that has a zero visual width, regardless of its advance.
   * &lt;p&gt; We make the same simplifying assumptions as in createLogicalBounds, namely
   * that we can rely on the charinfo to shield us from any glyph positioning oddities
   * in the font that place the glyph for a character at other than the pos + advance
   * of the character to its left.  So we no longer need to skip chars with zero
   * advance, as their bounds (right and left) are already correct.
   */
  protected Rectangle2D createAlignBounds() {
<span class="nc" id="L243">    float[] info = getCharinfo();</span>

<span class="nc" id="L245">    float al = 0f;</span>
<span class="nc" id="L246">    float at = -cm.ascent;</span>
<span class="nc" id="L247">    float aw = 0f;</span>
<span class="nc" id="L248">    float ah = cm.ascent + cm.descent;</span>

<span class="nc bnc" id="L250" title="All 4 branches missed.">    if (charinfo == null || charinfo.length == 0) {</span>
<span class="nc" id="L251">        return new Rectangle2D.Float(al, at, aw, ah);</span>
    }

<span class="nc bnc" id="L254" title="All 2 branches missed.">    boolean lineIsLTR = (source.getLayoutFlags() &amp; 0x8) == 0;</span>
<span class="nc" id="L255">    int rn = info.length - numvals;</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">    if (lineIsLTR) {</span>
<span class="nc bnc" id="L257" title="All 4 branches missed.">      while (rn &gt; 0 &amp;&amp; info[rn+visw] == 0) {</span>
<span class="nc" id="L258">        rn -= numvals;</span>
      }
    }

<span class="nc bnc" id="L262" title="All 2 branches missed.">    if (rn &gt;= 0) {</span>
<span class="nc" id="L263">      int ln = 0;</span>
<span class="nc bnc" id="L264" title="All 8 branches missed.">      while (ln &lt; rn &amp;&amp; ((info[ln+advx] == 0) || (!lineIsLTR &amp;&amp; info[ln+visw] == 0))) {</span>
<span class="nc" id="L265">        ln += numvals;</span>
      }

<span class="nc" id="L268">      al = Math.max(0f, info[ln+posx]);</span>
<span class="nc" id="L269">      aw = info[rn+posx] + info[rn+advx] - al;</span>
    }

    /*
      boolean lineIsLTR = source.lineIsLTR();
      int rn = info.length - numvals;
      while (rn &gt; 0 &amp;&amp; ((info[rn+advx] == 0) || (lineIsLTR &amp;&amp; info[rn+visw] == 0))) {
      rn -= numvals;
      }

      if (rn &gt;= 0) {
      int ln = 0;
      while (ln &lt; rn &amp;&amp; ((info[ln+advx] == 0) || (!lineIsLTR &amp;&amp; info[ln+visw] == 0))) {
      ln += numvals;
      }

      al = Math.max(0f, info[ln+posx]);
      aw = info[rn+posx] + info[rn+advx] - al;
      }
      */

<span class="nc" id="L290">    return new Rectangle2D.Float(al, at, aw, ah);</span>
  }

  public Rectangle2D createItalicBounds() {
<span class="nc" id="L294">    float ia = cm.italicAngle;</span>

<span class="nc" id="L296">    Rectangle2D lb = getLogicalBounds();</span>
<span class="nc" id="L297">    float l = (float)lb.getMinX();</span>
<span class="nc" id="L298">    float t = -cm.ascent;</span>
<span class="nc" id="L299">    float r = (float)lb.getMaxX();</span>
<span class="nc" id="L300">    float b = cm.descent;</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">    if (ia != 0) {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (ia &gt; 0) {</span>
<span class="nc" id="L303">            l -= ia * (b - cm.ssOffset);</span>
<span class="nc" id="L304">            r -= ia * (t - cm.ssOffset);</span>
        } else {
<span class="nc" id="L306">            l -= ia * (t - cm.ssOffset);</span>
<span class="nc" id="L307">            r -= ia * (b - cm.ssOffset);</span>
        }
    }
<span class="nc" id="L310">    return new Rectangle2D.Float(l, t, r - l, b - t);</span>
  }

  private final StandardGlyphVector getGV() {
<span class="nc bnc" id="L314" title="All 2 branches missed.">    if (gv == null) {</span>
<span class="nc" id="L315">      gv = createGV();</span>
    }

<span class="nc" id="L318">    return gv;</span>
  }

  protected StandardGlyphVector createGV() {
<span class="nc" id="L322">    FontRenderContext frc = source.getFRC();</span>
<span class="nc" id="L323">    int flags = source.getLayoutFlags();</span>
<span class="nc" id="L324">    char[] context = source.getChars();</span>
<span class="nc" id="L325">    int start = source.getStart();</span>
<span class="nc" id="L326">    int length = source.getLength();</span>

<span class="nc" id="L328">    GlyphLayout gl = GlyphLayout.get(null); // !!! no custom layout engines</span>
<span class="nc" id="L329">    gv = gl.layout(font, frc, context, start, length, flags, null); // ??? use textsource</span>
<span class="nc" id="L330">    GlyphLayout.done(gl);</span>

<span class="nc" id="L332">    return gv;</span>
  }

  // ExtendedTextLabel API

  private static final int posx = 0,
    posy = 1,
    advx = 2,
    advy = 3,
    visx = 4,
    visy = 5,
    visw = 6,
    vish = 7;
  private static final int numvals = 8;

  public int getNumCharacters() {
<span class="nc" id="L348">    return source.getLength();</span>
  }

  public CoreMetrics getCoreMetrics() {
<span class="nc" id="L352">    return cm;</span>
  }

  public float getCharX(int index) {
<span class="nc" id="L356">    validate(index);</span>
<span class="nc" id="L357">    float[] charinfo = getCharinfo();</span>
<span class="nc" id="L358">    int idx = l2v(index) * numvals + posx;</span>
<span class="nc bnc" id="L359" title="All 4 branches missed.">    if (charinfo == null || idx &gt;= charinfo.length) {</span>
<span class="nc" id="L360">        return 0f;</span>
    } else {
<span class="nc" id="L362">        return charinfo[idx];</span>
    }
  }

  public float getCharY(int index) {
<span class="nc" id="L367">    validate(index);</span>
<span class="nc" id="L368">    float[] charinfo = getCharinfo();</span>
<span class="nc" id="L369">    int idx = l2v(index) * numvals + posy;</span>
<span class="nc bnc" id="L370" title="All 4 branches missed.">    if (charinfo == null || idx &gt;= charinfo.length) {</span>
<span class="nc" id="L371">        return 0f;</span>
    } else {
<span class="nc" id="L373">        return charinfo[idx];</span>
    }
  }

  public float getCharAdvance(int index) {
<span class="nc" id="L378">    validate(index);</span>
<span class="nc" id="L379">    float[] charinfo = getCharinfo();</span>
<span class="nc" id="L380">    int idx = l2v(index) * numvals + advx;</span>
<span class="nc bnc" id="L381" title="All 4 branches missed.">    if (charinfo == null || idx &gt;= charinfo.length) {</span>
<span class="nc" id="L382">        return 0f;</span>
    } else {
<span class="nc" id="L384">        return charinfo[idx];</span>
    }
  }

  public Rectangle2D handleGetCharVisualBounds(int index) {
<span class="nc" id="L389">    validate(index);</span>
<span class="nc" id="L390">    float[] charinfo = getCharinfo();</span>
<span class="nc" id="L391">    index = l2v(index) * numvals;</span>
<span class="nc bnc" id="L392" title="All 4 branches missed.">    if (charinfo == null || (index+vish) &gt;= charinfo.length) {</span>
<span class="nc" id="L393">        return new Rectangle2D.Float();</span>
    }
<span class="nc" id="L395">    return new Rectangle2D.Float(</span>
                                 charinfo[index + visx],
                                 charinfo[index + visy],
                                 charinfo[index + visw],
                                 charinfo[index + vish]);
  }

  public Rectangle2D getCharVisualBounds(int index, float x, float y) {

<span class="nc" id="L404">    Rectangle2D bounds = decorator.getCharVisualBounds(this, index);</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">    if (x != 0 || y != 0) {</span>
<span class="nc" id="L406">        bounds.setRect(bounds.getX()+x,</span>
<span class="nc" id="L407">                       bounds.getY()+y,</span>
<span class="nc" id="L408">                       bounds.getWidth(),</span>
<span class="nc" id="L409">                       bounds.getHeight());</span>
    }
<span class="nc" id="L411">    return bounds;</span>
  }

  private void validate(int index) {
<span class="nc bnc" id="L415" title="All 2 branches missed.">    if (index &lt; 0) {</span>
<span class="nc" id="L416">      throw new IllegalArgumentException(&quot;index &quot; + index + &quot; &lt; 0&quot;);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">    } else if (index &gt;= source.getLength()) {</span>
<span class="nc" id="L418">      throw new IllegalArgumentException(&quot;index &quot; + index + &quot; &lt; &quot; + source.getLength());</span>
    }
<span class="nc" id="L420">  }</span>

  /*
    public int hitTestChar(float x, float y) {
    // !!! return index of char hit, for swing
    // result is negative for trailing-edge hits
    // no italics so no problem at margins.
    // for now, ignore y since we assume horizontal text

    // find non-combining char origin to right of x
    float[] charinfo = getCharinfo();

    int n = 0;
    int e = source.getLength();
    while (n &lt; e &amp;&amp; charinfo[n + advx] != 0 &amp;&amp; charinfo[n + posx] &gt; x) {
    n += numvals;
    }
    float rightx = n &lt; e ? charinfo[n+posx] : charinfo[e - numvals + posx] + charinfo[e - numvals + advx];

    // find non-combining char to left of that char
    n -= numvals;
    while (n &gt;= 0 &amp;&amp; charinfo[n+advx] == 0) {
    n -= numvals;
    }
    float leftx = n &gt;= 0 ? charinfo[n+posx] : 0;
    float lefta = n &gt;= 0 ? charinfo[n+advx] : 0;

    n /= numvals;

    boolean left = true;
    if (x &lt; leftx + lefta / 2f) {
    // left of prev char
    } else if (x &lt; (leftx + lefta + rightx) / 2f) {
    // right of prev char
    left = false;
    } else {
    // left of follow char
    n += 1;
    }

    if ((source.getLayoutFlags() &amp; 0x1) != 0) {
    n = getNumCharacters() - 1 - n;
    left = !left;
    }

    return left ? n : -n;
    }
    */

  public int logicalToVisual(int logicalIndex) {
<span class="nc" id="L470">    validate(logicalIndex);</span>
<span class="nc" id="L471">    return l2v(logicalIndex);</span>
  }

  public int visualToLogical(int visualIndex) {
<span class="nc" id="L475">    validate(visualIndex);</span>
<span class="nc" id="L476">    return v2l(visualIndex);</span>
  }

  public int getLineBreakIndex(int start, float width) {
<span class="nc" id="L480">    float[] charinfo = getCharinfo();</span>
<span class="nc" id="L481">    int length = source.getLength();</span>
<span class="nc" id="L482">    --start;</span>
<span class="nc bnc" id="L483" title="All 4 branches missed.">    while (width &gt;= 0 &amp;&amp; ++start &lt; length) {</span>
<span class="nc" id="L484">      int cidx = l2v(start) * numvals + advx;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">      if (cidx &gt;= charinfo.length) {</span>
<span class="nc" id="L486">          break; // layout bailed for some reason</span>
      }
<span class="nc" id="L488">      float adv = charinfo[cidx];</span>
<span class="nc" id="L489">      width -= adv;</span>
<span class="nc" id="L490">    }</span>

<span class="nc" id="L492">    return start;</span>
  }

  public float getAdvanceBetween(int start, int limit) {
<span class="nc" id="L496">    float a = 0f;</span>

<span class="nc" id="L498">    float[] charinfo = getCharinfo();</span>
<span class="nc" id="L499">    --start;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">    while (++start &lt; limit) {</span>
<span class="nc" id="L501">      int cidx = l2v(start) * numvals + advx;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">      if (cidx &gt;= charinfo.length) {</span>
<span class="nc" id="L503">          break; // layout bailed for some reason</span>
      }
<span class="nc" id="L505">      a += charinfo[cidx];</span>
<span class="nc" id="L506">    }</span>

<span class="nc" id="L508">    return a;</span>
  }

  public boolean caretAtOffsetIsValid(int offset) {
      // REMIND: improve this implementation

      // Ligature formation can either be done in logical order,
      // with the ligature glyph logically preceding the null
      // chars;  or in visual order, with the ligature glyph to
      // the left of the null chars.  This method's implementation
      // must reflect which strategy is used.

<span class="nc bnc" id="L520" title="All 4 branches missed.">      if (offset == 0 || offset == source.getLength()) {</span>
<span class="nc" id="L521">          return true;</span>
      }
<span class="nc" id="L523">      char c = source.getChars()[source.getStart() + offset];</span>
<span class="nc bnc" id="L524" title="All 6 branches missed.">      if (c == '\t' || c == '\n' || c == '\r') { // hack</span>
<span class="nc" id="L525">          return true;</span>
      }
<span class="nc" id="L527">      int v = l2v(offset);</span>

      // If ligatures are always to the left, do this stuff:
      //if (!(source.getLayoutFlags() &amp; 0x1) == 0) {
      //    v += 1;
      //    if (v == source.getLength()) {
      //        return true;
      //    }
      //}

<span class="nc" id="L537">      int idx = v * numvals + advx;</span>
<span class="nc" id="L538">      float[] charinfo = getCharinfo();</span>
<span class="nc bnc" id="L539" title="All 4 branches missed.">      if (charinfo == null || idx &gt;= charinfo.length) {</span>
<span class="nc" id="L540">          return false;</span>
      } else {
<span class="nc bnc" id="L542" title="All 2 branches missed.">          return charinfo[idx] != 0;</span>
      }
  }

  private final float[] getCharinfo() {
<span class="nc bnc" id="L547" title="All 2 branches missed.">    if (charinfo == null) {</span>
<span class="nc" id="L548">      charinfo = createCharinfo();</span>
    }
<span class="nc" id="L550">    return charinfo;</span>
  }

/*
* This takes the glyph info record obtained from the glyph vector and converts it into a similar record
* adjusted to represent character data instead.  For economy we don't use glyph info records in this processing.
*
* Here are some constraints:
* - there can be more glyphs than characters (glyph insertion, perhaps based on normalization, has taken place)
* - there can not be fewer glyphs than characters (0xffff glyphs are inserted for characters ligaturized away)
* - each glyph maps to a single character, when multiple glyphs exist for a character they all map to it, but
*   no two characters map to the same glyph
* - multiple glyphs mapping to the same character need not be in sequence (thai, tamil have split characters)
* - glyphs may be arbitrarily reordered (Indic reorders glyphs)
* - all glyphs share the same bidi level
* - all glyphs share the same horizontal (or vertical) baseline
* - combining marks visually follow their base character in the glyph array-- i.e. in an rtl gv they are
*   to the left of their base character-- and have zero advance.
*
* The output maps this to character positions, and therefore caret positions, via the following assumptions:
* - zero-advance glyphs do not contribute to the advance of their character (i.e. position is ignored), conversely
*   if a glyph is to contribute to the advance of its character it must have a non-zero (float) advance
* - no carets can appear between a zero width character and its preceding character, where 'preceding' is
*   defined logically.
* - no carets can appear within a split character
* - no carets can appear within a local reordering (i.e. Indic reordering, or non-adjacent split characters)
* - all characters lie on the same baseline, and it is either horizontal or vertical
* - the charinfo is in uniform ltr or rtl order (visual order), since local reorderings and split characters are removed
*
* The algorithm works in the following way:
* 1) we scan the glyphs ltr or rtl based on the bidi run direction
* 2) we can work in place, since we always consume a glyph for each char we write
*    a) if the line is ltr, we start writing at position 0 until we finish, there may be leftver space
*    b) if the line is rtl and 1-1, we start writing at position numChars/glyphs - 1 until we finish at 0
*    c) otherwise if we don't finish at 0, we have to copy the data down
* 3) we consume clusters in the following way:
*    a) the first element is always consumed
*    b) subsequent elements are consumed if:
*       i) their advance is zero
*       ii) their character index &lt;= the character index of any character seen in this cluster
*       iii) the minimum character index seen in this cluster isn't adjacent to the previous cluster
*    c) character data is written as follows for horizontal lines (x/y and w/h are exchanged on vertical lines)
*       i) the x position is the position of the leftmost glyph whose advance is not zero
*       ii)the y position is the baseline
*       iii) the x advance is the distance to the maximum x + adv of all glyphs whose advance is not zero
*       iv) the y advance is the baseline
*       v) vis x,y,w,h tightly encloses the vis x,y,w,h of all the glyphs with nonzero w and h
* 4) we can make some simple optimizations if we know some things:
*    a) if the mapping is 1-1, unidirectional, and there are no zero-adv glyphs, we just return the glyphinfo
*    b) if the mapping is 1-1, unidirectional, we just adjust the remaining glyphs to originate at right/left of the base
*    c) if the mapping is 1-1, we compute the base position and advance as we go, then go back to adjust the remaining glyphs
*    d) otherwise we keep separate track of the write position as we do (c) since no glyph in the cluster may be in the
*    position we are writing.
*    e) most clusters are simply the single base glyph in the same position as its character, so we try to avoid
*    copying its data unnecessarily.
* 5) the glyph vector ought to provide access to these 'global' attributes to enable these optimizations.  A single
*    int with flags set is probably ok, we could also provide accessors for each attribute.  This doesn't map to
*    the GlyphMetrics flags very well, so I won't attempt to keep them similar.  It might be useful to add those
*    in addition to these.
*    int FLAG_HAS_ZERO_ADVANCE_GLYPHS = 1; // set if there are zero-advance glyphs
*    int FLAG_HAS_NONUNIFORM_ORDER = 2; // set if some glyphs are rearranged out of character visual order
*    int FLAG_HAS_SPLIT_CHARACTERS = 4; // set if multiple glyphs per character
*    int getDescriptionFlags(); // return an int containing the above flags
*    boolean hasZeroAdvanceGlyphs();
*    boolean hasNonuniformOrder();
*    boolean hasSplitCharacters();
*    The optimized cases in (4) correspond to values 0, 1, 3, and 7 returned by getDescriptionFlags().
*/
  protected float[] createCharinfo() {
<span class="nc" id="L619">    StandardGlyphVector gv = getGV();</span>
<span class="nc" id="L620">    float[] glyphinfo = null;</span>
    try {
<span class="nc" id="L622">        glyphinfo = gv.getGlyphInfo();</span>
    }
<span class="nc" id="L624">    catch (Exception e) {</span>
<span class="nc" id="L625">        System.out.println(source);</span>
<span class="nc" id="L626">    }</span>

    /*
    if ((gv.getDescriptionFlags() &amp; 0x7) == 0) {
        return glyphinfo;
    }
    */

<span class="nc" id="L634">    int numGlyphs = gv.getNumGlyphs();</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">    if (numGlyphs == 0) {</span>
<span class="nc" id="L636">        return glyphinfo;</span>
    }
<span class="nc" id="L638">    int[] indices = gv.getGlyphCharIndices(0, numGlyphs, null);</span>

<span class="nc" id="L640">    boolean DEBUG = false;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L642">      System.err.println(&quot;number of glyphs: &quot; + numGlyphs);</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">      for (int i = 0; i &lt; numGlyphs; ++i) {</span>
<span class="nc" id="L644">        System.err.println(&quot;g: &quot; + i +</span>
            &quot;, x: &quot; + glyphinfo[i*numvals+posx] +
            &quot;, a: &quot; + glyphinfo[i*numvals+advx] +
            &quot;, n: &quot; + indices[i]);
      }
    }

<span class="nc" id="L651">    int minIndex = indices[0];  // smallest index seen this cluster</span>
<span class="nc" id="L652">    int maxIndex = minIndex;    // largest index seen this cluster</span>
<span class="nc" id="L653">    int nextMin = 0;            // expected smallest index for this cluster</span>
<span class="nc" id="L654">    int cp = 0;                 // character position</span>
<span class="nc" id="L655">    int cx = 0;                 // character index (logical)</span>
<span class="nc" id="L656">    int gp = 0;                 // glyph position</span>
<span class="nc" id="L657">    int gx = 0;                 // glyph index (visual)</span>
<span class="nc" id="L658">    int gxlimit = numGlyphs;    // limit of gx, when we reach this we're done</span>
<span class="nc" id="L659">    int pdelta = numvals;       // delta for incrementing positions</span>
<span class="nc" id="L660">    int xdelta = 1;             // delta for incrementing indices</span>

<span class="nc bnc" id="L662" title="All 2 branches missed.">    boolean ltr = (source.getLayoutFlags() &amp; 0x1) == 0;</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">    if (!ltr) {</span>
<span class="nc" id="L664">        minIndex = indices[numGlyphs - 1];</span>
<span class="nc" id="L665">        maxIndex = minIndex;</span>
<span class="nc" id="L666">        nextMin  = 0; // still logical</span>
<span class="nc" id="L667">        cp = glyphinfo.length - numvals;</span>
<span class="nc" id="L668">        cx = 0; // still logical</span>
<span class="nc" id="L669">        gp = glyphinfo.length - numvals;</span>
<span class="nc" id="L670">        gx = numGlyphs - 1;</span>
<span class="nc" id="L671">        gxlimit = -1;</span>
<span class="nc" id="L672">        pdelta = -numvals;</span>
<span class="nc" id="L673">        xdelta = -1;</span>
    }

    /*
    // to support vertical, use 'ixxxx' indices and swap horiz and vertical components
    if (source.isVertical()) {
        iposx = posy;
        iposy = posx;
        iadvx = advy;
        iadvy = advx;
        ivisx = visy;
        ivisy = visx;
        ivish = visw;
        ivisw = vish;
    } else {
        // use standard values
    }
    */

    // use intermediates to reduce array access when we need to
<span class="nc" id="L693">    float cposl = 0, cposr = 0, cvisl = 0, cvist = 0, cvisr = 0, cvisb = 0;</span>
<span class="nc" id="L694">    float baseline = 0;</span>

    // record if we have to copy data even when no cluster
<span class="nc" id="L697">    boolean mustCopy = false;</span>

<span class="nc bnc" id="L699" title="All 2 branches missed.">    while (gx != gxlimit) {</span>
        // start of new cluster
<span class="nc" id="L701">        boolean haveCopy = false;</span>
<span class="nc" id="L702">        int clusterExtraGlyphs = 0;</span>

<span class="nc" id="L704">        minIndex = indices[gx];</span>
<span class="nc" id="L705">        maxIndex = minIndex;</span>

        // advance to next glyph
<span class="nc" id="L708">        gx += xdelta;</span>
<span class="nc" id="L709">        gp += pdelta;</span>

 /*
        while (gx != gxlimit &amp;&amp; (glyphinfo[gp + advx] == 0 ||
                           minIndex != nextMin || indices[gx] &lt;= maxIndex)) {
  */
<span class="nc bnc" id="L715" title="All 10 branches missed.">        while (gx != gxlimit &amp;&amp;</span>
               ((glyphinfo[gp + advx] == 0) ||
               (minIndex != nextMin) ||
               (indices[gx] &lt;= maxIndex) ||
               (maxIndex - minIndex &gt; clusterExtraGlyphs))) {
            // initialize base data first time through, using base glyph
<span class="nc bnc" id="L721" title="All 2 branches missed.">            if (!haveCopy) {</span>
<span class="nc" id="L722">                int gps = gp - pdelta;</span>

<span class="nc" id="L724">                cposl = glyphinfo[gps + posx];</span>
<span class="nc" id="L725">                cposr = cposl + glyphinfo[gps + advx];</span>
<span class="nc" id="L726">                cvisl = glyphinfo[gps + visx];</span>
<span class="nc" id="L727">                cvist = glyphinfo[gps + visy];</span>
<span class="nc" id="L728">                cvisr = cvisl + glyphinfo[gps + visw];</span>
<span class="nc" id="L729">                cvisb = cvist + glyphinfo[gps + vish];</span>

<span class="nc" id="L731">                haveCopy = true;</span>
            }

            // have an extra glyph in this cluster
<span class="nc" id="L735">            ++clusterExtraGlyphs;</span>

            // adjust advance only if new glyph has non-zero advance
<span class="nc" id="L738">            float radvx = glyphinfo[gp + advx];</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">            if (radvx != 0) {</span>
<span class="nc" id="L740">                float rposx = glyphinfo[gp + posx];</span>
<span class="nc" id="L741">                cposl = Math.min(cposl, rposx);</span>
<span class="nc" id="L742">                cposr = Math.max(cposr, rposx + radvx);</span>
            }

            // adjust visible bounds only if new glyph has non-empty bounds
<span class="nc" id="L746">            float rvisw = glyphinfo[gp + visw];</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            if (rvisw != 0) {</span>
<span class="nc" id="L748">                float rvisx = glyphinfo[gp + visx];</span>
<span class="nc" id="L749">                float rvisy = glyphinfo[gp + visy];</span>
<span class="nc" id="L750">                cvisl = Math.min(cvisl, rvisx);</span>
<span class="nc" id="L751">                cvist = Math.min(cvist, rvisy);</span>
<span class="nc" id="L752">                cvisr = Math.max(cvisr, rvisx + rvisw);</span>
<span class="nc" id="L753">                cvisb = Math.max(cvisb, rvisy + glyphinfo[gp + vish]);</span>
            }

            // adjust min, max index
<span class="nc" id="L757">            minIndex = Math.min(minIndex, indices[gx]);</span>
<span class="nc" id="L758">            maxIndex = Math.max(maxIndex, indices[gx]);</span>

            // get ready to examine next glyph
<span class="nc" id="L761">            gx += xdelta;</span>
<span class="nc" id="L762">            gp += pdelta;</span>
<span class="nc" id="L763">        }</span>
        // done with cluster, gx and gp are set for next glyph

<span class="nc bnc" id="L766" title="All 2 branches missed.">        if (DEBUG) {</span>
<span class="nc" id="L767">            System.out.println(&quot;minIndex = &quot; + minIndex + &quot;, maxIndex = &quot; + maxIndex);</span>
        }

<span class="nc" id="L770">        nextMin = maxIndex + 1;</span>

        // do common character adjustments
<span class="nc" id="L773">        glyphinfo[cp + posy] = baseline;</span>
<span class="nc" id="L774">        glyphinfo[cp + advy] = 0;</span>

<span class="nc bnc" id="L776" title="All 2 branches missed.">        if (haveCopy) {</span>
            // save adjustments to the base character
<span class="nc" id="L778">            glyphinfo[cp + posx] = cposl;</span>
<span class="nc" id="L779">            glyphinfo[cp + advx] = cposr - cposl;</span>
<span class="nc" id="L780">            glyphinfo[cp + visx] = cvisl;</span>
<span class="nc" id="L781">            glyphinfo[cp + visy] = cvist;</span>
<span class="nc" id="L782">            glyphinfo[cp + visw] = cvisr - cvisl;</span>
<span class="nc" id="L783">            glyphinfo[cp + vish] = cvisb - cvist;</span>

            // compare number of chars read with number of glyphs read.
            // if more glyphs than chars, set mustCopy to true, as we'll always have
            // to copy the data from here on out.
<span class="nc bnc" id="L788" title="All 2 branches missed.">            if (maxIndex - minIndex &lt; clusterExtraGlyphs) {</span>
<span class="nc" id="L789">                mustCopy = true;</span>
            }

            // Fix the characters that follow the base character.
            // New values are all the same.  Note we fix the number of characters
            // we saw, not the number of glyphs we saw.
<span class="nc bnc" id="L795" title="All 2 branches missed.">            if (minIndex &lt; maxIndex) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">                if (!ltr) {</span>
                    // if rtl, characters to left of base, else to right.  reuse cposr.
<span class="nc" id="L798">                    cposr = cposl;</span>
                }
<span class="nc" id="L800">                cvisr -= cvisl; // reuse, convert to deltas.</span>
<span class="nc" id="L801">                cvisb -= cvist;</span>

<span class="nc" id="L803">                int iMinIndex = minIndex, icp = cp / 8;</span>

<span class="nc bnc" id="L805" title="All 2 branches missed.">                while (minIndex &lt; maxIndex) {</span>
<span class="nc" id="L806">                    ++minIndex;</span>
<span class="nc" id="L807">                    cx += xdelta;</span>
<span class="nc" id="L808">                    cp += pdelta;</span>

<span class="nc bnc" id="L810" title="All 4 branches missed.">                    if (cp &lt; 0 || cp &gt;= glyphinfo.length) {</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">                        if (DEBUG) System.out.println(&quot;minIndex = &quot; + iMinIndex + &quot;, maxIndex = &quot; + maxIndex + &quot;, cp = &quot; + icp);</span>
                    }

<span class="nc" id="L814">                    glyphinfo[cp + posx] = cposr;</span>
<span class="nc" id="L815">                    glyphinfo[cp + posy] = baseline;</span>
<span class="nc" id="L816">                    glyphinfo[cp + advx] = 0;</span>
<span class="nc" id="L817">                    glyphinfo[cp + advy] = 0;</span>
<span class="nc" id="L818">                    glyphinfo[cp + visx] = cvisl;</span>
<span class="nc" id="L819">                    glyphinfo[cp + visy] = cvist;</span>
<span class="nc" id="L820">                    glyphinfo[cp + visw] = cvisr;</span>
<span class="nc" id="L821">                    glyphinfo[cp + vish] = cvisb;</span>
                }
            }

            // no longer using this copy
<span class="nc" id="L826">            haveCopy = false;</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">        } else if (mustCopy) {</span>
            // out of synch, so we have to copy all the time now
<span class="nc" id="L829">            int gpr = gp - pdelta;</span>

<span class="nc" id="L831">            glyphinfo[cp + posx] = glyphinfo[gpr + posx];</span>
<span class="nc" id="L832">            glyphinfo[cp + advx] = glyphinfo[gpr + advx];</span>
<span class="nc" id="L833">            glyphinfo[cp + visx] = glyphinfo[gpr + visx];</span>
<span class="nc" id="L834">            glyphinfo[cp + visy] = glyphinfo[gpr + visy];</span>
<span class="nc" id="L835">            glyphinfo[cp + visw] = glyphinfo[gpr + visw];</span>
<span class="nc" id="L836">            glyphinfo[cp + vish] = glyphinfo[gpr + vish];</span>
        }
        // else glyphinfo is already at the correct character position, and is unchanged, so just leave it

        // reset for new cluster
<span class="nc" id="L841">        cp += pdelta;</span>
<span class="nc" id="L842">        cx += xdelta;</span>
<span class="nc" id="L843">    }</span>

<span class="nc bnc" id="L845" title="All 4 branches missed.">    if (mustCopy &amp;&amp; !ltr) {</span>
        // data written to wrong end of array, need to shift down

<span class="nc" id="L848">        cp -= pdelta; // undo last increment, get start of valid character data in array</span>
<span class="nc" id="L849">        System.arraycopy(glyphinfo, cp, glyphinfo, 0, glyphinfo.length - cp);</span>
    }

<span class="nc bnc" id="L852" title="All 2 branches missed.">    if (DEBUG) {</span>
<span class="nc" id="L853">      char[] chars = source.getChars();</span>
<span class="nc" id="L854">      int start = source.getStart();</span>
<span class="nc" id="L855">      int length = source.getLength();</span>
<span class="nc" id="L856">      System.out.println(&quot;char info for &quot; + length + &quot; characters&quot;);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">      for(int i = 0; i &lt; length * numvals;) {</span>
<span class="nc" id="L858">        System.out.println(&quot; ch: &quot; + Integer.toHexString(chars[start + v2l(i / numvals)]) +</span>
                           &quot; x: &quot; + glyphinfo[i++] +
                           &quot; y: &quot; + glyphinfo[i++] +
                           &quot; xa: &quot; + glyphinfo[i++] +
                           &quot; ya: &quot; + glyphinfo[i++] +
                           &quot; l: &quot; + glyphinfo[i++] +
                           &quot; t: &quot; + glyphinfo[i++] +
                           &quot; w: &quot; + glyphinfo[i++] +
                           &quot; h: &quot; + glyphinfo[i++]);
      }
    }

<span class="nc" id="L870">    return glyphinfo;</span>
  }

  /**
   * Map logical character index to visual character index.
   * &lt;p&gt;
   * This ignores hindi reordering.  @see createCharinfo
   */
  protected int l2v(int index) {
<span class="nc bnc" id="L879" title="All 2 branches missed.">    return (source.getLayoutFlags() &amp; 0x1) == 0 ? index : source.getLength() - 1 - index;</span>
  }

  /**
   * Map visual character index to logical character index.
   * &lt;p&gt;
   * This ignores hindi reordering.  @see createCharinfo
   */
  protected int v2l(int index) {
<span class="nc bnc" id="L888" title="All 2 branches missed.">    return (source.getLayoutFlags() &amp; 0x1) == 0 ? index : source.getLength() - 1 - index;</span>
  }

  public TextLineComponent getSubset(int start, int limit, int dir) {
<span class="nc" id="L892">    return new ExtendedTextSourceLabel(source.getSubSource(start, limit-start, dir), decorator);</span>
  }

  public String toString() {
    if (true) {
<span class="nc" id="L897">        return source.toString(source.WITHOUT_CONTEXT);</span>
    }
    StringBuffer buf = new StringBuffer();
    buf.append(super.toString());
    buf.append(&quot;[source:&quot;);
    buf.append(source.toString(source.WITHOUT_CONTEXT));
    buf.append(&quot;, lb:&quot;);
    buf.append(lb);
    buf.append(&quot;, ab:&quot;);
    buf.append(ab);
    buf.append(&quot;, vb:&quot;);
    buf.append(vb);
    buf.append(&quot;, gv:&quot;);
    buf.append(gv);
    buf.append(&quot;, ci: &quot;);
    if (charinfo == null) {
      buf.append(&quot;null&quot;);
    } else {
      buf.append(charinfo[0]);
      for (int i = 1; i &lt; charinfo.length;) {
        buf.append(i % numvals == 0 ? &quot;; &quot; : &quot;, &quot;);
        buf.append(charinfo[i]);
      }
    }
    buf.append(&quot;]&quot;);

    return buf.toString();
  }

  //public static ExtendedTextLabel create(TextSource source) {
  //  return new ExtendedTextSourceLabel(source);
  //}

  public int getNumJustificationInfos() {
<span class="nc" id="L931">    return getGV().getNumGlyphs();</span>
  }


  public void getJustificationInfos(GlyphJustificationInfo[] infos, int infoStart, int charStart, int charLimit) {
    // This simple implementation only uses spaces for justification.
    // Since regular characters aren't justified, we don't need to deal with
    // special infos for combining marks or ligature substitution glyphs.
    // added character justification for kanjii only 2/22/98

<span class="nc" id="L941">    StandardGlyphVector gv = getGV();</span>

<span class="nc" id="L943">    float[] charinfo = getCharinfo();</span>

<span class="nc" id="L945">    float size = gv.getFont().getSize2D();</span>

<span class="nc" id="L947">    GlyphJustificationInfo nullInfo =</span>
      new GlyphJustificationInfo(0,
                                 false, GlyphJustificationInfo.PRIORITY_NONE, 0, 0,
                                 false, GlyphJustificationInfo.PRIORITY_NONE, 0, 0);

<span class="nc" id="L952">    GlyphJustificationInfo spaceInfo =</span>
      new GlyphJustificationInfo(size,
                                 true, GlyphJustificationInfo.PRIORITY_WHITESPACE, 0, size,
                                 true, GlyphJustificationInfo.PRIORITY_WHITESPACE, 0, size / 4f);

<span class="nc" id="L957">    GlyphJustificationInfo kanjiInfo =</span>
      new GlyphJustificationInfo(size,
                                 true, GlyphJustificationInfo.PRIORITY_INTERCHAR, size, size,
                                 false, GlyphJustificationInfo.PRIORITY_NONE, 0, 0);

<span class="nc" id="L962">    char[] chars = source.getChars();</span>
<span class="nc" id="L963">    int offset = source.getStart();</span>

    // assume data is 1-1 and either all rtl or all ltr, for now

<span class="nc" id="L967">    int numGlyphs = gv.getNumGlyphs();</span>
<span class="nc" id="L968">    int minGlyph = 0;</span>
<span class="nc" id="L969">    int maxGlyph = numGlyphs;</span>
<span class="nc bnc" id="L970" title="All 2 branches missed.">    boolean ltr = (source.getLayoutFlags() &amp; 0x1) == 0;</span>
<span class="nc bnc" id="L971" title="All 4 branches missed.">    if (charStart != 0 || charLimit != source.getLength()) {</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">      if (ltr) {</span>
<span class="nc" id="L973">        minGlyph = charStart;</span>
<span class="nc" id="L974">        maxGlyph = charLimit;</span>
      } else {
<span class="nc" id="L976">        minGlyph = numGlyphs - charLimit;</span>
<span class="nc" id="L977">        maxGlyph = numGlyphs - charStart;</span>
      }
    }

<span class="nc bnc" id="L981" title="All 2 branches missed.">    for (int i = 0; i &lt; numGlyphs; ++i) {</span>
<span class="nc" id="L982">      GlyphJustificationInfo info = null;</span>
<span class="nc bnc" id="L983" title="All 4 branches missed.">      if (i &gt;= minGlyph &amp;&amp; i &lt; maxGlyph) {</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">        if (charinfo[i * numvals + advx] == 0) { // combining marks don't justify</span>
<span class="nc" id="L985">          info = nullInfo;</span>
        } else {
<span class="nc" id="L987">          int ci = v2l(i); // 1-1 assumption again</span>
<span class="nc" id="L988">          char c = chars[offset + ci];</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">          if (Character.isWhitespace(c)) {</span>
<span class="nc" id="L990">            info = spaceInfo;</span>
            // CJK, Hangul, CJK Compatibility areas
<span class="nc bnc" id="L992" title="All 12 branches missed.">          } else if (c &gt;= 0x4e00 &amp;&amp;</span>
                     (c &lt; 0xa000) ||
                     (c &gt;= 0xac00 &amp;&amp; c &lt; 0xd7b0) ||
                     (c &gt;= 0xf900 &amp;&amp; c &lt; 0xfb00)) {
<span class="nc" id="L996">            info = kanjiInfo;</span>
          } else {
<span class="nc" id="L998">            info = nullInfo;</span>
          }
        }
      }
<span class="nc" id="L1002">      infos[infoStart + i] = info;</span>
    }
<span class="nc" id="L1004">  }</span>

  public TextLineComponent applyJustificationDeltas(float[] deltas, int deltaStart, boolean[] flags) {

    // when we justify, we need to adjust the charinfo since spaces
    // change their advances.  preserve the existing charinfo.

<span class="nc" id="L1011">    float[] newCharinfo = (float[])getCharinfo().clone();</span>

    // we only push spaces, so never need to rejustify
<span class="nc" id="L1014">    flags[0] = false;</span>

    // preserve the existing gv.

<span class="nc" id="L1018">    StandardGlyphVector newgv = (StandardGlyphVector)getGV().clone();</span>
<span class="nc" id="L1019">    float[] newPositions = newgv.getGlyphPositions(null);</span>
<span class="nc" id="L1020">    int numGlyphs = newgv.getNumGlyphs();</span>

    /*
    System.out.println(&quot;oldgv: &quot; + getGV() + &quot;, newgv: &quot; + newgv);
    System.out.println(&quot;newpositions: &quot; + newPositions);
    for (int i = 0; i &lt; newPositions.length; i += 2) {
      System.out.println(&quot;[&quot; + (i/2) + &quot;] &quot; + newPositions[i] + &quot;, &quot; + newPositions[i+1]);
    }

    System.out.println(&quot;deltas: &quot; + deltas + &quot; start: &quot; + deltaStart);
    for (int i = deltaStart; i &lt; deltaStart + numGlyphs; i += 2) {
      System.out.println(&quot;[&quot; + (i/2) + &quot;] &quot; + deltas[i] + &quot;, &quot; + deltas[i+1]);
    }
    */

<span class="nc" id="L1035">    char[] chars = source.getChars();</span>
<span class="nc" id="L1036">    int offset = source.getStart();</span>

    // accumulate the deltas to adjust positions and advances.
    // handle whitespace by modifying advance,
    // handle everything else by modifying position before and after

<span class="nc" id="L1042">    float deltaPos = 0;</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">    for (int i = 0; i &lt; numGlyphs; ++i) {</span>
<span class="nc bnc" id="L1044" title="All 2 branches missed.">      if (Character.isWhitespace(chars[offset + v2l(i)])) {</span>
<span class="nc" id="L1045">        newPositions[i*2] += deltaPos;</span>

<span class="nc" id="L1047">        float deltaAdv = deltas[deltaStart + i*2] + deltas[deltaStart + i*2 + 1];</span>

<span class="nc" id="L1049">        newCharinfo[i * numvals + posx] += deltaPos;</span>
<span class="nc" id="L1050">        newCharinfo[i * numvals + visx] += deltaPos;</span>
<span class="nc" id="L1051">        newCharinfo[i * numvals + advx] += deltaAdv;</span>

<span class="nc" id="L1053">        deltaPos += deltaAdv;</span>
<span class="nc" id="L1054">      } else {</span>
<span class="nc" id="L1055">        deltaPos += deltas[deltaStart + i*2];</span>

<span class="nc" id="L1057">        newPositions[i*2] += deltaPos;</span>
<span class="nc" id="L1058">        newCharinfo[i * numvals + posx] += deltaPos;</span>
<span class="nc" id="L1059">        newCharinfo[i * numvals + visx] += deltaPos;</span>

<span class="nc" id="L1061">        deltaPos += deltas[deltaStart + i*2 + 1];</span>
      }
    }
<span class="nc" id="L1064">    newPositions[numGlyphs * 2] += deltaPos;</span>

<span class="nc" id="L1066">    newgv.setGlyphPositions(newPositions);</span>

    /*
    newPositions = newgv.getGlyphPositions(null);
    System.out.println(&quot;&gt;&gt; newpositions: &quot; + newPositions);
    for (int i = 0; i &lt; newPositions.length; i += 2) {
      System.out.println(&quot;[&quot; + (i/2) + &quot;] &quot; + newPositions[i] + &quot;, &quot; + newPositions[i+1]);
    }
    */

<span class="nc" id="L1076">    ExtendedTextSourceLabel result = new ExtendedTextSourceLabel(source, decorator);</span>
<span class="nc" id="L1077">    result.gv = newgv;</span>
<span class="nc" id="L1078">    result.charinfo = newCharinfo;</span>

<span class="nc" id="L1080">    return result;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>