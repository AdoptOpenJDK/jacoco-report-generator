<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CMap.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.font</a> &gt; <span class="el_source">CMap.java</span></div><h1>CMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.font;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.IntBuffer;
import java.util.Locale;
import java.nio.charset.*;

/*
 * A tt font has a CMAP table which is in turn made up of sub-tables which
 * describe the char to glyph mapping in (possibly) multiple ways.
 * CMAP subtables are described by 3 values.
 * 1. Platform ID (eg 3=Microsoft, which is the id we look for in JDK)
 * 2. Encoding (eg 0=symbol, 1=unicode)
 * 3. TrueType subtable format (how the char-&gt;glyph mapping for the encoding
 * is stored in the subtable). See the TrueType spec. Format 4 is required
 * by MS in fonts for windows. Its uses segmented mapping to delta values.
 * Most typically we see are (3,1,4) :
 * CMAP Platform ID=3 is what we use.
 * Encodings that are used in practice by JDK on Solaris are
 *  symbol (3,0)
 *  unicode (3,1)
 *  GBK (3,5) (note that solaris zh fonts report 3,4 but are really 3,5)
 * The format for almost all subtables is 4. However the solaris (3,5)
 * encodings are typically in format 2.
 */
<span class="nc" id="L52">abstract class CMap {</span>

//     static char WingDings_b2c[] = {
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0x2702, 0x2701, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0x2706, 0x2709, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2707, 0x270d,
//         0xfffd, 0x270c, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0x2708, 0xfffd, 0xfffd, 0x2744, 0xfffd, 0x271e, 0xfffd,
//         0x2720, 0x2721, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0x2751, 0x2752, 0xfffd, 0xfffd, 0x2756, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0x2740, 0x273f, 0x275d, 0x275e, 0xfffd,
//         0xfffd, 0x2780, 0x2781, 0x2782, 0x2783, 0x2784, 0x2785, 0x2786,
//         0x2787, 0x2788, 0x2789, 0xfffd, 0x278a, 0x278b, 0x278c, 0x278d,
//         0x278e, 0x278f, 0x2790, 0x2791, 0x2792, 0x2793, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x274d, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2736, 0x2734, 0xfffd, 0x2735,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x272a, 0x2730, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x27a5, 0xfffd, 0x27a6, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x27a2, 0xfffd, 0xfffd, 0xfffd, 0x27b3, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x27a1, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x27a9, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0x2717, 0x2713, 0xfffd, 0xfffd, 0xfffd,
//    };

//     static char Symbols_b2c[] = {
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0x2200, 0xfffd, 0x2203, 0xfffd, 0xfffd, 0x220d,
//         0xfffd, 0xfffd, 0x2217, 0xfffd, 0xfffd, 0x2212, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x2245, 0x0391, 0x0392, 0x03a7, 0x0394, 0x0395, 0x03a6, 0x0393,
//         0x0397, 0x0399, 0x03d1, 0x039a, 0x039b, 0x039c, 0x039d, 0x039f,
//         0x03a0, 0x0398, 0x03a1, 0x03a3, 0x03a4, 0x03a5, 0x03c2, 0x03a9,
//         0x039e, 0x03a8, 0x0396, 0xfffd, 0x2234, 0xfffd, 0x22a5, 0xfffd,
//         0xfffd, 0x03b1, 0x03b2, 0x03c7, 0x03b4, 0x03b5, 0x03c6, 0x03b3,
//         0x03b7, 0x03b9, 0x03d5, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03bf,
//         0x03c0, 0x03b8, 0x03c1, 0x03c3, 0x03c4, 0x03c5, 0x03d6, 0x03c9,
//         0x03be, 0x03c8, 0x03b6, 0xfffd, 0xfffd, 0xfffd, 0x223c, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0x03d2, 0xfffd, 0x2264, 0x2215, 0x221e, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x2218, 0xfffd, 0xfffd, 0x2265, 0xfffd, 0x221d, 0xfffd, 0x2219,
//         0xfffd, 0x2260, 0x2261, 0x2248, 0x22ef, 0x2223, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2297, 0x2295, 0x2205, 0x2229,
//         0x222a, 0x2283, 0x2287, 0x2284, 0x2282, 0x2286, 0x2208, 0x2209,
//         0xfffd, 0x2207, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x221a, 0x22c5,
//         0xfffd, 0x2227, 0x2228, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0x22c4, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0x2211, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0x222b, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//         0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
//     };

    static final short ShiftJISEncoding = 2;
    static final short GBKEncoding      = 3;
    static final short Big5Encoding     = 4;
    static final short WansungEncoding  = 5;
    static final short JohabEncoding    = 6;
    static final short MSUnicodeSurrogateEncoding = 10;

    static final char noSuchChar = (char)0xfffd;
    static final int SHORTMASK = 0x0000ffff;
    static final int INTMASK   = 0xffffffff;

<span class="nc" id="L135">    static final char[][] converterMaps = new char[7][];</span>

    /*
     * Unicode-&gt;other encoding translation array. A pre-computed look up
     * which can be shared across all fonts using that encoding.
     * Using this saves running character coverters repeatedly.
     */
    char[] xlat;

    static CMap initialize(TrueTypeFont font) {

<span class="nc" id="L146">        CMap cmap = null;</span>

<span class="nc" id="L148">        int offset, platformID, encodingID=-1;</span>

<span class="nc" id="L150">        int three0=0, three1=0, three2=0, three3=0, three4=0, three5=0,</span>
<span class="nc" id="L151">            three6=0, three10=0;</span>
<span class="nc" id="L152">        boolean threeStar = false;</span>

<span class="nc" id="L154">        ByteBuffer cmapBuffer = font.getTableBuffer(TrueTypeFont.cmapTag);</span>
<span class="nc" id="L155">        int cmapTableOffset = font.getTableSize(TrueTypeFont.cmapTag);</span>
<span class="nc" id="L156">        short numberSubTables = cmapBuffer.getShort(2);</span>

        /* locate the offsets of all 3,*  (ie Microsoft platform) encodings */
<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (int i=0; i&lt;numberSubTables; i++) {</span>
<span class="nc" id="L160">            cmapBuffer.position(i * 8 + 4);</span>
<span class="nc" id="L161">            platformID = cmapBuffer.getShort();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (platformID == 3) {</span>
<span class="nc" id="L163">                threeStar = true;</span>
<span class="nc" id="L164">                encodingID = cmapBuffer.getShort();</span>
<span class="nc" id="L165">                offset     = cmapBuffer.getInt();</span>
<span class="nc bnc" id="L166" title="All 9 branches missed.">                switch (encodingID) {</span>
<span class="nc" id="L167">                case 0:  three0  = offset; break; // MS Symbol encoding</span>
<span class="nc" id="L168">                case 1:  three1  = offset; break; // MS Unicode cmap</span>
<span class="nc" id="L169">                case 2:  three2  = offset; break; // ShiftJIS cmap.</span>
<span class="nc" id="L170">                case 3:  three3  = offset; break; // GBK cmap</span>
<span class="nc" id="L171">                case 4:  three4  = offset; break; // Big 5 cmap</span>
<span class="nc" id="L172">                case 5:  three5  = offset; break; // Wansung</span>
<span class="nc" id="L173">                case 6:  three6  = offset; break; // Johab</span>
<span class="nc" id="L174">                case 10: three10 = offset; break; // MS Unicode surrogates</span>
                }
            }
        }

        /* This defines the preference order for cmap subtables */
<span class="nc bnc" id="L180" title="All 2 branches missed.">        if (threeStar) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">            if (three10 != 0) {</span>
<span class="nc" id="L182">                cmap = createCMap(cmapBuffer, three10, null);</span>
            }
<span class="nc bnc" id="L184" title="All 2 branches missed.">            else if  (three0 != 0) {</span>
                /* The special case treatment of these fonts leads to
                 * anomalies where a user can view &quot;wingdings&quot; and &quot;wingdings2&quot;
                 * and the latter shows all its code points in the unicode
                 * private use area at 0xF000-&gt;0XF0FF and the former shows
                 * a scattered subset of its glyphs that are known mappings to
                 * unicode code points.
                 * The primary purpose of these mappings was to facilitate
                 * display of symbol chars etc in composite fonts, however
                 * this is not needed as all these code points are covered
                 * by Lucida Sans Regular.
                 * Commenting this out reduces the role of these two files
                 * (assuming that they continue to be used in font.properties)
                 * to just one of contributing to the overall composite
                 * font metrics, and also AWT can still access the fonts.
                 * Clients which explicitly accessed these fonts as names
                 * &quot;Symbol&quot; and &quot;Wingdings&quot; (ie as physical fonts) and
                 * expected to see a scattering of these characters will
                 * see them now as missing. How much of a problem is this?
                 * Perhaps we could still support this mapping just for
                 * &quot;Symbol.ttf&quot; but I suspect some users would prefer it
                 * to be mapped in to the Latin range as that is how
                 * the &quot;symbol&quot; font is used in native apps.
                 */
//              String name = font.platName.toLowerCase(Locale.ENGLISH);
//              if (name.endsWith(&quot;symbol.ttf&quot;)) {
//                  cmap = createSymbolCMap(cmapBuffer, three0, Symbols_b2c);
//              } else if (name.endsWith(&quot;wingding.ttf&quot;)) {
//                  cmap = createSymbolCMap(cmapBuffer, three0, WingDings_b2c);
//              } else {
<span class="nc" id="L214">                    cmap = createCMap(cmapBuffer, three0, null);</span>
//              }
            }
<span class="nc bnc" id="L217" title="All 2 branches missed.">            else if (three1 != 0) {</span>
<span class="nc" id="L218">                cmap = createCMap(cmapBuffer, three1, null);</span>
            }
<span class="nc bnc" id="L220" title="All 2 branches missed.">            else if (three2 != 0) {</span>
<span class="nc" id="L221">                cmap = createCMap(cmapBuffer, three2,</span>
<span class="nc" id="L222">                                  getConverterMap(ShiftJISEncoding));</span>
            }
<span class="nc bnc" id="L224" title="All 2 branches missed.">            else if (three3 != 0) {</span>
<span class="nc" id="L225">                cmap = createCMap(cmapBuffer, three3,</span>
<span class="nc" id="L226">                                  getConverterMap(GBKEncoding));</span>
            }
<span class="nc bnc" id="L228" title="All 2 branches missed.">            else if (three4 != 0) {</span>
                /* GB2312 TrueType fonts on Solaris have wrong encoding ID for
                 * cmap table, these fonts have EncodingID 4 which is Big5
                 * encoding according the TrueType spec, but actually the
                 * fonts are using gb2312 encoding, have to use this
                 * workaround to make Solaris zh_CN locale work.  -sherman
                 */
<span class="nc bnc" id="L235" title="All 4 branches missed.">                if (FontUtilities.isSolaris &amp;&amp; font.platName != null &amp;&amp;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">                    (font.platName.startsWith(</span>
                     &quot;/usr/openwin/lib/locale/zh_CN.EUC/X11/fonts/TrueType&quot;) ||
<span class="nc bnc" id="L238" title="All 2 branches missed.">                     font.platName.startsWith(</span>
                     &quot;/usr/openwin/lib/locale/zh_CN/X11/fonts/TrueType&quot;) ||
<span class="nc bnc" id="L240" title="All 2 branches missed.">                     font.platName.startsWith(</span>
                     &quot;/usr/openwin/lib/locale/zh/X11/fonts/TrueType&quot;))) {
<span class="nc" id="L242">                    cmap = createCMap(cmapBuffer, three4,</span>
<span class="nc" id="L243">                                       getConverterMap(GBKEncoding));</span>
                }
                else {
<span class="nc" id="L246">                    cmap = createCMap(cmapBuffer, three4,</span>
<span class="nc" id="L247">                                      getConverterMap(Big5Encoding));</span>
                }
            }
<span class="nc bnc" id="L250" title="All 2 branches missed.">            else if (three5 != 0) {</span>
<span class="nc" id="L251">                cmap = createCMap(cmapBuffer, three5,</span>
<span class="nc" id="L252">                                  getConverterMap(WansungEncoding));</span>
            }
<span class="nc bnc" id="L254" title="All 2 branches missed.">            else if (three6 != 0) {</span>
<span class="nc" id="L255">                cmap = createCMap(cmapBuffer, three6,</span>
<span class="nc" id="L256">                                  getConverterMap(JohabEncoding));</span>
            }
        } else {
            /* No 3,* subtable was found. Just use whatever is the first
             * table listed. Not very useful but maybe better than
             * rejecting the font entirely?
             */
<span class="nc" id="L263">            cmap = createCMap(cmapBuffer, cmapBuffer.getInt(8), null);</span>
        }
<span class="nc" id="L265">        return cmap;</span>
    }

    /* speed up the converting by setting the range for double
     * byte characters;
     */
    static char[] getConverter(short encodingID) {
<span class="nc" id="L272">        int dBegin = 0x8000;</span>
<span class="nc" id="L273">        int dEnd   = 0xffff;</span>
        String encoding;

<span class="nc bnc" id="L276" title="All 6 branches missed.">        switch (encodingID) {</span>
        case ShiftJISEncoding:
<span class="nc" id="L278">            dBegin = 0x8140;</span>
<span class="nc" id="L279">            dEnd   = 0xfcfc;</span>
<span class="nc" id="L280">            encoding = &quot;SJIS&quot;;</span>
<span class="nc" id="L281">            break;</span>
        case GBKEncoding:
<span class="nc" id="L283">            dBegin = 0x8140;</span>
<span class="nc" id="L284">            dEnd   = 0xfea0;</span>
<span class="nc" id="L285">            encoding = &quot;GBK&quot;;</span>
<span class="nc" id="L286">            break;</span>
        case Big5Encoding:
<span class="nc" id="L288">            dBegin = 0xa140;</span>
<span class="nc" id="L289">            dEnd   = 0xfefe;</span>
<span class="nc" id="L290">            encoding = &quot;Big5&quot;;</span>
<span class="nc" id="L291">            break;</span>
        case WansungEncoding:
<span class="nc" id="L293">            dBegin = 0xa1a1;</span>
<span class="nc" id="L294">            dEnd   = 0xfede;</span>
<span class="nc" id="L295">            encoding = &quot;EUC_KR&quot;;</span>
<span class="nc" id="L296">            break;</span>
        case JohabEncoding:
<span class="nc" id="L298">            dBegin = 0x8141;</span>
<span class="nc" id="L299">            dEnd   = 0xfdfe;</span>
<span class="nc" id="L300">            encoding = &quot;Johab&quot;;</span>
<span class="nc" id="L301">            break;</span>
        default:
<span class="nc" id="L303">            return null;</span>
        }

        try {
<span class="nc" id="L307">            char[] convertedChars = new char[65536];</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">            for (int i=0; i&lt;65536; i++) {</span>
<span class="nc" id="L309">                convertedChars[i] = noSuchChar;</span>
            }

<span class="nc" id="L312">            byte[] inputBytes = new byte[(dEnd-dBegin+1)*2];</span>
<span class="nc" id="L313">            char[] outputChars = new char[(dEnd-dBegin+1)];</span>

<span class="nc" id="L315">            int j = 0;</span>
            int firstByte;
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (encodingID == ShiftJISEncoding) {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                for (int i = dBegin; i &lt;= dEnd; i++) {</span>
<span class="nc" id="L319">                    firstByte = (i &gt;&gt; 8 &amp; 0xff);</span>
<span class="nc bnc" id="L320" title="All 4 branches missed.">                    if (firstByte &gt;= 0xa1 &amp;&amp; firstByte &lt;= 0xdf) {</span>
                        //sjis halfwidth katakana
<span class="nc" id="L322">                        inputBytes[j++] = (byte)0xff;</span>
<span class="nc" id="L323">                        inputBytes[j++] = (byte)0xff;</span>
                    } else {
<span class="nc" id="L325">                        inputBytes[j++] = (byte)firstByte;</span>
<span class="nc" id="L326">                        inputBytes[j++] = (byte)(i &amp; 0xff);</span>
                    }
                }
            } else {
<span class="nc bnc" id="L330" title="All 2 branches missed.">                for (int i = dBegin; i &lt;= dEnd; i++) {</span>
<span class="nc" id="L331">                    inputBytes[j++] = (byte)(i&gt;&gt;8 &amp; 0xff);</span>
<span class="nc" id="L332">                    inputBytes[j++] = (byte)(i &amp; 0xff);</span>
                }
            }

<span class="nc" id="L336">            Charset.forName(encoding).newDecoder()</span>
<span class="nc" id="L337">            .onMalformedInput(CodingErrorAction.REPLACE)</span>
<span class="nc" id="L338">            .onUnmappableCharacter(CodingErrorAction.REPLACE)</span>
<span class="nc" id="L339">            .replaceWith(&quot;\u0000&quot;)</span>
<span class="nc" id="L340">            .decode(ByteBuffer.wrap(inputBytes, 0, inputBytes.length),</span>
<span class="nc" id="L341">                    CharBuffer.wrap(outputChars, 0, outputChars.length),</span>
                    true);

            // ensure single byte ascii
<span class="nc bnc" id="L345" title="All 2 branches missed.">            for (int i = 0x20; i &lt;= 0x7e; i++) {</span>
<span class="nc" id="L346">                convertedChars[i] = (char)i;</span>
            }

            //sjis halfwidth katakana
<span class="nc bnc" id="L350" title="All 2 branches missed.">            if (encodingID == ShiftJISEncoding) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                for (int i = 0xa1; i &lt;= 0xdf; i++) {</span>
<span class="nc" id="L352">                    convertedChars[i] = (char)(i - 0xa1 + 0xff61);</span>
                }
            }

            /* It would save heap space (approx 60Kbytes for each of these
             * converters) if stored only valid ranges (ie returned
             * outputChars directly. But this is tricky since want to
             * include the ASCII range too.
             */
//          System.err.println(&quot;oc.len=&quot;+outputChars.length);
//          System.err.println(&quot;cc.len=&quot;+convertedChars.length);
//          System.err.println(&quot;dbegin=&quot;+dBegin);
<span class="nc" id="L364">            System.arraycopy(outputChars, 0, convertedChars, dBegin,</span>
                             outputChars.length);

            //return convertedChars;
            /* invert this map as now want it to map from Unicode
             * to other encoding.
             */
<span class="nc" id="L371">            char [] invertedChars = new char[65536];</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            for (int i=0;i&lt;65536;i++) {</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">                if (convertedChars[i] != noSuchChar) {</span>
<span class="nc" id="L374">                    invertedChars[convertedChars[i]] = (char)i;</span>
                }
            }
<span class="nc" id="L377">            return invertedChars;</span>

<span class="nc" id="L379">        } catch (Exception e) {</span>
<span class="nc" id="L380">            e.printStackTrace();</span>
        }
<span class="nc" id="L382">        return null;</span>
    }

    /*
     * The returned array maps to unicode from some other 2 byte encoding
     * eg for a 2byte index which represents a SJIS char, the indexed
     * value is the corresponding unicode char.
     */
    static char[] getConverterMap(short encodingID) {
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (converterMaps[encodingID] == null) {</span>
<span class="nc" id="L392">           converterMaps[encodingID] = getConverter(encodingID);</span>
        }
<span class="nc" id="L394">        return converterMaps[encodingID];</span>
    }


    static CMap createCMap(ByteBuffer buffer, int offset, char[] xlat) {
        /* First do a sanity check that this cmap subtable is contained
         * within the cmap table.
         */
<span class="nc" id="L402">        int subtableFormat = buffer.getChar(offset);</span>
        long subtableLength;
<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (subtableFormat &lt; 8) {</span>
<span class="nc" id="L405">            subtableLength = buffer.getChar(offset+2);</span>
        } else {
<span class="nc" id="L407">            subtableLength = buffer.getInt(offset+4) &amp; INTMASK;</span>
        }
<span class="nc bnc" id="L409" title="All 2 branches missed.">        if (offset+subtableLength &gt; buffer.capacity()) {</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">            if (FontUtilities.isLogging()) {</span>
<span class="nc" id="L411">                FontUtilities.getLogger().warning(&quot;Cmap subtable overflows buffer.&quot;);</span>
            }
        }
<span class="nc bnc" id="L414" title="All 8 branches missed.">        switch (subtableFormat) {</span>
<span class="nc" id="L415">        case 0:  return new CMapFormat0(buffer, offset);</span>
<span class="nc" id="L416">        case 2:  return new CMapFormat2(buffer, offset, xlat);</span>
<span class="nc" id="L417">        case 4:  return new CMapFormat4(buffer, offset, xlat);</span>
<span class="nc" id="L418">        case 6:  return new CMapFormat6(buffer, offset, xlat);</span>
<span class="nc" id="L419">        case 8:  return new CMapFormat8(buffer, offset, xlat);</span>
<span class="nc" id="L420">        case 10: return new CMapFormat10(buffer, offset, xlat);</span>
<span class="nc" id="L421">        case 12: return new CMapFormat12(buffer, offset, xlat);</span>
<span class="nc" id="L422">        default: throw new RuntimeException(&quot;Cmap format unimplemented: &quot; +</span>
<span class="nc" id="L423">                                            (int)buffer.getChar(offset));</span>
        }
    }

/*
    final char charVal(byte[] cmap, int index) {
        return (char)(((0xff &amp; cmap[index]) &lt;&lt; 8)+(0xff &amp; cmap[index+1]));
    }

    final short shortVal(byte[] cmap, int index) {
        return (short)(((0xff &amp; cmap[index]) &lt;&lt; 8)+(0xff &amp; cmap[index+1]));
    }
*/
    abstract char getGlyph(int charCode);

    /* Format 4 Header is
     * ushort format (off=0)
     * ushort length (off=2)
     * ushort language (off=4)
     * ushort segCountX2 (off=6)
     * ushort searchRange (off=8)
     * ushort entrySelector (off=10)
     * ushort rangeShift (off=12)
     * ushort endCount[segCount] (off=14)
     * ushort reservedPad
     * ushort startCount[segCount]
     * short idDelta[segCount]
     * idRangeOFfset[segCount]
     * ushort glyphIdArray[]
     */
    static class CMapFormat4 extends CMap {
        int segCount;
        int entrySelector;
        int rangeShift;
        char[] endCount;
        char[] startCount;
        short[] idDelta;
        char[] idRangeOffset;
        char[] glyphIds;

<span class="nc" id="L463">        CMapFormat4(ByteBuffer bbuffer, int offset, char[] xlat) {</span>

<span class="nc" id="L465">            this.xlat = xlat;</span>

<span class="nc" id="L467">            bbuffer.position(offset);</span>
<span class="nc" id="L468">            CharBuffer buffer = bbuffer.asCharBuffer();</span>
<span class="nc" id="L469">            buffer.get(); // skip, we already know format=4</span>
<span class="nc" id="L470">            int subtableLength = buffer.get();</span>
            /* Try to recover from some bad fonts which specify a subtable
             * length that would overflow the byte buffer holding the whole
             * cmap table. If this isn't a recoverable situation an exception
             * may be thrown which is caught higher up the call stack.
             * Whilst this may seem lenient, in practice, unless the &quot;bad&quot;
             * subtable we are using is the last one in the cmap table we
             * would have no way of knowing about this problem anyway.
             */
<span class="nc bnc" id="L479" title="All 2 branches missed.">            if (offset+subtableLength &gt; bbuffer.capacity()) {</span>
<span class="nc" id="L480">                subtableLength = bbuffer.capacity() - offset;</span>
            }
<span class="nc" id="L482">            buffer.get(); // skip language</span>
<span class="nc" id="L483">            segCount = buffer.get()/2;</span>
<span class="nc" id="L484">            int searchRange = buffer.get();</span>
<span class="nc" id="L485">            entrySelector = buffer.get();</span>
<span class="nc" id="L486">            rangeShift    = buffer.get()/2;</span>
<span class="nc" id="L487">            startCount = new char[segCount];</span>
<span class="nc" id="L488">            endCount = new char[segCount];</span>
<span class="nc" id="L489">            idDelta = new short[segCount];</span>
<span class="nc" id="L490">            idRangeOffset = new char[segCount];</span>

<span class="nc bnc" id="L492" title="All 2 branches missed.">            for (int i=0; i&lt;segCount; i++) {</span>
<span class="nc" id="L493">                endCount[i] = buffer.get();</span>
            }
<span class="nc" id="L495">            buffer.get(); // 2 bytes for reserved pad</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">            for (int i=0; i&lt;segCount; i++) {</span>
<span class="nc" id="L497">                startCount[i] = buffer.get();</span>
            }

<span class="nc bnc" id="L500" title="All 2 branches missed.">            for (int i=0; i&lt;segCount; i++) {</span>
<span class="nc" id="L501">                idDelta[i] = (short)buffer.get();</span>
            }

<span class="nc bnc" id="L504" title="All 2 branches missed.">            for (int i=0; i&lt;segCount; i++) {</span>
<span class="nc" id="L505">                char ctmp = buffer.get();</span>
<span class="nc" id="L506">                idRangeOffset[i] = (char)((ctmp&gt;&gt;1)&amp;0xffff);</span>
            }
            /* Can calculate the number of glyph IDs by subtracting
             * &quot;pos&quot; from the length of the cmap
             */
<span class="nc" id="L511">            int pos = (segCount*8+16)/2;</span>
<span class="nc" id="L512">            buffer.position(pos);</span>
<span class="nc" id="L513">            int numGlyphIds = (subtableLength/2 - pos);</span>
<span class="nc" id="L514">            glyphIds = new char[numGlyphIds];</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            for (int i=0;i&lt;numGlyphIds;i++) {</span>
<span class="nc" id="L516">                glyphIds[i] = buffer.get();</span>
            }
/*
            System.err.println(&quot;segcount=&quot;+segCount);
            System.err.println(&quot;entrySelector=&quot;+entrySelector);
            System.err.println(&quot;rangeShift=&quot;+rangeShift);
            for (int j=0;j&lt;segCount;j++) {
              System.err.println(&quot;j=&quot;+j+ &quot; sc=&quot;+(int)(startCount[j]&amp;0xffff)+
                                 &quot; ec=&quot;+(int)(endCount[j]&amp;0xffff)+
                                 &quot; delta=&quot;+idDelta[j] +
                                 &quot; ro=&quot;+(int)idRangeOffset[j]);
            }

            //System.err.println(&quot;numglyphs=&quot;+glyphIds.length);
            for (int i=0;i&lt;numGlyphIds;i++) {
                  System.err.println(&quot;gid[&quot;+i+&quot;]=&quot;+(int)glyphIds[i]);
            }
*/
<span class="nc" id="L534">        }</span>

        char getGlyph(int charCode) {

<span class="nc" id="L538">            int index = 0;</span>
<span class="nc" id="L539">            char glyphCode = 0;</span>

<span class="nc" id="L541">            int controlGlyph = getControlCodeGlyph(charCode, true);</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (controlGlyph &gt;= 0) {</span>
<span class="nc" id="L543">                return (char)controlGlyph;</span>
            }

            /* presence of translation array indicates that this
             * cmap is in some other (non-unicode encoding).
             * In order to look-up a char-&gt;glyph mapping we need to
             * translate the unicode code point to the encoding of
             * the cmap.
             * REMIND: VALID CHARCODES??
             */
<span class="nc bnc" id="L553" title="All 2 branches missed.">            if (xlat != null) {</span>
<span class="nc" id="L554">                charCode = xlat[charCode];</span>
            }

            /*
             * Citation from the TrueType (and OpenType) spec:
             *   The segments are sorted in order of increasing endCode
             *   values, and the segment values are specified in four parallel
             *   arrays. You search for the first endCode that is greater than
             *   or equal to the character code you want to map. If the
             *   corresponding startCode is less than or equal to the
             *   character code, then you use the corresponding idDelta and
             *   idRangeOffset to map the character code to a glyph index
             *   (otherwise, the missingGlyph is returned).
             */

            /*
             * CMAP format4 defines several fields for optimized search of
             * the segment list (entrySelector, searchRange, rangeShift).
             * However, benefits are neglible and some fonts have incorrect
             * data - so we use straightforward binary search (see bug 6247425)
             */
<span class="nc" id="L575">            int left = 0, right = startCount.length;</span>
<span class="nc" id="L576">            index = startCount.length &gt;&gt; 1;</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">            while (left &lt; right) {</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">                if (endCount[index] &lt; charCode) {</span>
<span class="nc" id="L579">                    left = index + 1;</span>
                } else {
<span class="nc" id="L581">                    right = index;</span>
                }
<span class="nc" id="L583">                index = (left + right) &gt;&gt; 1;</span>
            }

<span class="nc bnc" id="L586" title="All 4 branches missed.">            if (charCode &gt;= startCount[index] &amp;&amp; charCode &lt;= endCount[index]) {</span>
<span class="nc" id="L587">                int rangeOffset = idRangeOffset[index];</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">                if (rangeOffset == 0) {</span>
<span class="nc" id="L590">                    glyphCode = (char)(charCode + idDelta[index]);</span>
                } else {
                    /* Calculate an index into the glyphIds array */

/*
                    System.err.println(&quot;rangeoffset=&quot;+rangeOffset+
                                       &quot; charCode=&quot; + charCode +
                                       &quot; scnt[&quot;+index+&quot;]=&quot;+(int)startCount[index] +
                                       &quot; segCnt=&quot;+segCount);
*/

<span class="nc" id="L601">                    int glyphIDIndex = rangeOffset - segCount + index</span>
                                         + (charCode - startCount[index]);
<span class="nc" id="L603">                    glyphCode = glyphIds[glyphIDIndex];</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">                    if (glyphCode != 0) {</span>
<span class="nc" id="L605">                        glyphCode = (char)(glyphCode + idDelta[index]);</span>
                    }
                }
            }
<span class="nc bnc" id="L609" title="All 2 branches missed.">            if (glyphCode != 0) {</span>
            //System.err.println(&quot;cc=&quot;+Integer.toHexString((int)charCode) + &quot; gc=&quot;+(int)glyphCode);
            }
<span class="nc" id="L612">            return glyphCode;</span>
        }
    }

    // Format 0: Byte Encoding table
    static class CMapFormat0 extends CMap {
        byte [] cmap;

<span class="nc" id="L620">        CMapFormat0(ByteBuffer buffer, int offset) {</span>

            /* skip 6 bytes of format, length, and version */
<span class="nc" id="L623">            int len = buffer.getChar(offset+2);</span>
<span class="nc" id="L624">            cmap = new byte[len-6];</span>
<span class="nc" id="L625">            buffer.position(offset+6);</span>
<span class="nc" id="L626">            buffer.get(cmap);</span>
<span class="nc" id="L627">        }</span>

        char getGlyph(int charCode) {
<span class="nc bnc" id="L630" title="All 2 branches missed.">            if (charCode &lt; 256) {</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                if (charCode &lt; 0x0010) {</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">                    switch (charCode) {</span>
                    case 0x0009:
                    case 0x000a:
<span class="nc" id="L635">                    case 0x000d: return CharToGlyphMapper.INVISIBLE_GLYPH_ID;</span>
                    }
                }
<span class="nc" id="L638">                return (char)(0xff &amp; cmap[charCode]);</span>
            } else {
<span class="nc" id="L640">                return 0;</span>
            }
        }
    }

//     static CMap createSymbolCMap(ByteBuffer buffer, int offset, char[] syms) {

//      CMap cmap = createCMap(buffer, offset, null);
//      if (cmap == null) {
//          return null;
//      } else {
//          return new CMapFormatSymbol(cmap, syms);
//      }
//     }

//     static class CMapFormatSymbol extends CMap {

//      CMap cmap;
//      static final int NUM_BUCKETS = 128;
//      Bucket[] buckets = new Bucket[NUM_BUCKETS];

//      class Bucket {
//          char unicode;
//          char glyph;
//          Bucket next;

//          Bucket(char u, char g) {
//              unicode = u;
//              glyph = g;
//          }
//      }

//      CMapFormatSymbol(CMap cmap, char[] syms) {

//          this.cmap = cmap;

//          for (int i=0;i&lt;syms.length;i++) {
//              char unicode = syms[i];
//              if (unicode != noSuchChar) {
//                  char glyph = cmap.getGlyph(i + 0xf000);
//                  int hash = unicode % NUM_BUCKETS;
//                  Bucket bucket = new Bucket(unicode, glyph);
//                  if (buckets[hash] == null) {
//                      buckets[hash] = bucket;
//                  } else {
//                      Bucket b = buckets[hash];
//                      while (b.next != null) {
//                          b = b.next;
//                      }
//                      b.next = bucket;
//                  }
//              }
//          }
//      }

//      char getGlyph(int unicode) {
//          if (unicode &gt;= 0x1000) {
//              return 0;
//          }
//          else if (unicode &gt;=0xf000 &amp;&amp; unicode &lt; 0xf100) {
//              return cmap.getGlyph(unicode);
//          } else {
//              Bucket b = buckets[unicode % NUM_BUCKETS];
//              while (b != null) {
//                  if (b.unicode == unicode) {
//                      return b.glyph;
//                  } else {
//                      b = b.next;
//                  }
//              }
//              return 0;
//          }
//      }
//     }

    // Format 2: High-byte mapping through table
    static class CMapFormat2 extends CMap {

<span class="nc" id="L718">        char[] subHeaderKey = new char[256];</span>
         /* Store subheaders in individual arrays
          * A SubHeader entry theortically looks like {
          *   char firstCode;
          *   char entryCount;
          *   short idDelta;
          *   char idRangeOffset;
          * }
          */
        char[] firstCodeArray;
        char[] entryCountArray;
        short[] idDeltaArray;
        char[] idRangeOffSetArray;

        char[] glyphIndexArray;

<span class="nc" id="L734">        CMapFormat2(ByteBuffer buffer, int offset, char[] xlat) {</span>

<span class="nc" id="L736">            this.xlat = xlat;</span>

<span class="nc" id="L738">            int tableLen = buffer.getChar(offset+2);</span>
<span class="nc" id="L739">            buffer.position(offset+6);</span>
<span class="nc" id="L740">            CharBuffer cBuffer = buffer.asCharBuffer();</span>
<span class="nc" id="L741">            char maxSubHeader = 0;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            for (int i=0;i&lt;256;i++) {</span>
<span class="nc" id="L743">                subHeaderKey[i] = cBuffer.get();</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">                if (subHeaderKey[i] &gt; maxSubHeader) {</span>
<span class="nc" id="L745">                    maxSubHeader = subHeaderKey[i];</span>
                }
            }
            /* The value of the subHeaderKey is 8 * the subHeader index,
             * so the number of subHeaders can be obtained by dividing
             * this value bv 8 and adding 1.
             */
<span class="nc" id="L752">            int numSubHeaders = (maxSubHeader &gt;&gt; 3) +1;</span>
<span class="nc" id="L753">            firstCodeArray = new char[numSubHeaders];</span>
<span class="nc" id="L754">            entryCountArray = new char[numSubHeaders];</span>
<span class="nc" id="L755">            idDeltaArray  = new short[numSubHeaders];</span>
<span class="nc" id="L756">            idRangeOffSetArray  = new char[numSubHeaders];</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            for (int i=0; i&lt;numSubHeaders; i++) {</span>
<span class="nc" id="L758">                firstCodeArray[i] = cBuffer.get();</span>
<span class="nc" id="L759">                entryCountArray[i] = cBuffer.get();</span>
<span class="nc" id="L760">                idDeltaArray[i] = (short)cBuffer.get();</span>
<span class="nc" id="L761">                idRangeOffSetArray[i] = cBuffer.get();</span>
//              System.out.println(&quot;sh[&quot;+i+&quot;]:fc=&quot;+(int)firstCodeArray[i]+
//                                 &quot; ec=&quot;+(int)entryCountArray[i]+
//                                 &quot; delta=&quot;+(int)idDeltaArray[i]+
//                                 &quot; offset=&quot;+(int)idRangeOffSetArray[i]);
            }

<span class="nc" id="L768">            int glyphIndexArrSize = (tableLen-518-numSubHeaders*8)/2;</span>
<span class="nc" id="L769">            glyphIndexArray = new char[glyphIndexArrSize];</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            for (int i=0; i&lt;glyphIndexArrSize;i++) {</span>
<span class="nc" id="L771">                glyphIndexArray[i] = cBuffer.get();</span>
            }
<span class="nc" id="L773">        }</span>

        char getGlyph(int charCode) {
<span class="nc" id="L776">            int controlGlyph = getControlCodeGlyph(charCode, true);</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">            if (controlGlyph &gt;= 0) {</span>
<span class="nc" id="L778">                return (char)controlGlyph;</span>
            }

<span class="nc bnc" id="L781" title="All 2 branches missed.">            if (xlat != null) {</span>
<span class="nc" id="L782">                charCode = xlat[charCode];</span>
            }

<span class="nc" id="L785">            char highByte = (char)(charCode &gt;&gt; 8);</span>
<span class="nc" id="L786">            char lowByte = (char)(charCode &amp; 0xff);</span>
<span class="nc" id="L787">            int key = subHeaderKey[highByte]&gt;&gt;3; // index into subHeaders</span>
            char mapMe;

<span class="nc bnc" id="L790" title="All 2 branches missed.">            if (key != 0) {</span>
<span class="nc" id="L791">                mapMe = lowByte;</span>
            } else {
<span class="nc" id="L793">                mapMe = highByte;</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">                if (mapMe == 0) {</span>
<span class="nc" id="L795">                    mapMe = lowByte;</span>
                }
            }

//          System.err.println(&quot;charCode=&quot;+Integer.toHexString(charCode)+
//                             &quot; key=&quot;+key+ &quot; mapMe=&quot;+Integer.toHexString(mapMe));
<span class="nc" id="L801">            char firstCode = firstCodeArray[key];</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if (mapMe &lt; firstCode) {</span>
<span class="nc" id="L803">                return 0;</span>
            } else {
<span class="nc" id="L805">                mapMe -= firstCode;</span>
            }

<span class="nc bnc" id="L808" title="All 2 branches missed.">            if (mapMe &lt; entryCountArray[key]) {</span>
                /* &quot;address&quot; arithmetic is needed to calculate the offset
                 * into glyphIndexArray. &quot;idRangeOffSetArray[key]&quot; specifies
                 * the number of bytes from that location in the table where
                 * the subarray of glyphIndexes starting at &quot;firstCode&quot; begins.
                 * Each entry in the subHeader table is 8 bytes, and the
                 * idRangeOffSetArray field is at offset 6 in the entry.
                 * The glyphIndexArray immediately follows the subHeaders.
                 * So if there are &quot;N&quot; entries then the number of bytes to the
                 * start of glyphIndexArray is (N-key)*8-6.
                 * Subtract this from the idRangeOffSetArray value to get
                 * the number of bytes into glyphIndexArray and divide by 2 to
                 * get the (char) array index.
                 */
<span class="nc" id="L822">                int glyphArrayOffset = ((idRangeOffSetArray.length-key)*8)-6;</span>
<span class="nc" id="L823">                int glyphSubArrayStart =</span>
                        (idRangeOffSetArray[key] - glyphArrayOffset)/2;
<span class="nc" id="L825">                char glyphCode = glyphIndexArray[glyphSubArrayStart+mapMe];</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                if (glyphCode != 0) {</span>
<span class="nc" id="L827">                    glyphCode += idDeltaArray[key]; //idDelta</span>
<span class="nc" id="L828">                    return glyphCode;</span>
                }
            }
<span class="nc" id="L831">            return 0;</span>
        }
    }

    // Format 6: Trimmed table mapping
    static class CMapFormat6 extends CMap {

        char firstCode;
        char entryCount;
        char[] glyphIdArray;

<span class="nc" id="L842">        CMapFormat6(ByteBuffer bbuffer, int offset, char[] xlat) {</span>

<span class="nc" id="L844">             bbuffer.position(offset+6);</span>
<span class="nc" id="L845">             CharBuffer buffer = bbuffer.asCharBuffer();</span>
<span class="nc" id="L846">             firstCode = buffer.get();</span>
<span class="nc" id="L847">             entryCount = buffer.get();</span>
<span class="nc" id="L848">             glyphIdArray = new char[entryCount];</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">             for (int i=0; i&lt; entryCount; i++) {</span>
<span class="nc" id="L850">                 glyphIdArray[i] = buffer.get();</span>
             }
<span class="nc" id="L852">         }</span>

         char getGlyph(int charCode) {
<span class="nc" id="L855">            int controlGlyph = getControlCodeGlyph(charCode, true);</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">            if (controlGlyph &gt;= 0) {</span>
<span class="nc" id="L857">                return (char)controlGlyph;</span>
            }

<span class="nc bnc" id="L860" title="All 2 branches missed.">             if (xlat != null) {</span>
<span class="nc" id="L861">                 charCode = xlat[charCode];</span>
             }

<span class="nc" id="L864">             charCode -= firstCode;</span>
<span class="nc bnc" id="L865" title="All 4 branches missed.">             if (charCode &lt; 0 || charCode &gt;= entryCount) {</span>
<span class="nc" id="L866">                  return 0;</span>
             } else {
<span class="nc" id="L868">                  return glyphIdArray[charCode];</span>
             }
         }
    }

    // Format 8: mixed 16-bit and 32-bit coverage
    // Seems unlikely this code will ever get tested as we look for
    // MS platform Cmaps and MS states (in the Opentype spec on their website)
    // that MS doesn't support this format
    static class CMapFormat8 extends CMap {
<span class="nc" id="L878">         byte[] is32 = new byte[8192];</span>
         int nGroups;
         int[] startCharCode;
         int[] endCharCode;
         int[] startGlyphID;

<span class="nc" id="L884">         CMapFormat8(ByteBuffer bbuffer, int offset, char[] xlat) {</span>

<span class="nc" id="L886">             bbuffer.position(12);</span>
<span class="nc" id="L887">             bbuffer.get(is32);</span>
<span class="nc" id="L888">             nGroups = bbuffer.getInt();</span>
<span class="nc" id="L889">             startCharCode = new int[nGroups];</span>
<span class="nc" id="L890">             endCharCode   = new int[nGroups];</span>
<span class="nc" id="L891">             startGlyphID  = new int[nGroups];</span>
<span class="nc" id="L892">         }</span>

        char getGlyph(int charCode) {
<span class="nc bnc" id="L895" title="All 2 branches missed.">            if (xlat != null) {</span>
<span class="nc" id="L896">                throw new RuntimeException(&quot;xlat array for cmap fmt=8&quot;);</span>
            }
<span class="nc" id="L898">            return 0;</span>
        }

    }


    // Format 4-byte 10: Trimmed table mapping
    // Seems unlikely this code will ever get tested as we look for
    // MS platform Cmaps and MS states (in the Opentype spec on their website)
    // that MS doesn't support this format
    static class CMapFormat10 extends CMap {

         long firstCode;
         int entryCount;
         char[] glyphIdArray;

<span class="nc" id="L914">         CMapFormat10(ByteBuffer bbuffer, int offset, char[] xlat) {</span>

<span class="nc" id="L916">             firstCode = bbuffer.getInt() &amp; INTMASK;</span>
<span class="nc" id="L917">             entryCount = bbuffer.getInt() &amp; INTMASK;</span>
<span class="nc" id="L918">             bbuffer.position(offset+20);</span>
<span class="nc" id="L919">             CharBuffer buffer = bbuffer.asCharBuffer();</span>
<span class="nc" id="L920">             glyphIdArray = new char[entryCount];</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">             for (int i=0; i&lt; entryCount; i++) {</span>
<span class="nc" id="L922">                 glyphIdArray[i] = buffer.get();</span>
             }
<span class="nc" id="L924">         }</span>

         char getGlyph(int charCode) {

<span class="nc bnc" id="L928" title="All 2 branches missed.">             if (xlat != null) {</span>
<span class="nc" id="L929">                 throw new RuntimeException(&quot;xlat array for cmap fmt=10&quot;);</span>
             }

<span class="nc" id="L932">             int code = (int)(charCode - firstCode);</span>
<span class="nc bnc" id="L933" title="All 4 branches missed.">             if (code &lt; 0 || code &gt;= entryCount) {</span>
<span class="nc" id="L934">                 return 0;</span>
             } else {
<span class="nc" id="L936">                 return glyphIdArray[code];</span>
             }
         }
    }

    // Format 12: Segmented coverage for UCS-4 (fonts supporting
    // surrogate pairs)
    static class CMapFormat12 extends CMap {

        int numGroups;
<span class="nc" id="L946">        int highBit =0;</span>
        int power;
        int extra;
        long[] startCharCode;
        long[] endCharCode;
        int[] startGlyphID;

<span class="nc" id="L953">        CMapFormat12(ByteBuffer buffer, int offset, char[] xlat) {</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">            if (xlat != null) {</span>
<span class="nc" id="L955">                throw new RuntimeException(&quot;xlat array for cmap fmt=12&quot;);</span>
            }

<span class="nc" id="L958">            numGroups = buffer.getInt(offset+12);</span>
<span class="nc" id="L959">            startCharCode = new long[numGroups];</span>
<span class="nc" id="L960">            endCharCode = new long[numGroups];</span>
<span class="nc" id="L961">            startGlyphID = new int[numGroups];</span>
<span class="nc" id="L962">            buffer.position(offset+16);</span>
<span class="nc" id="L963">            buffer = buffer.slice();</span>
<span class="nc" id="L964">            IntBuffer ibuffer = buffer.asIntBuffer();</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">            for (int i=0; i&lt;numGroups; i++) {</span>
<span class="nc" id="L966">                startCharCode[i] = ibuffer.get() &amp; INTMASK;</span>
<span class="nc" id="L967">                endCharCode[i] = ibuffer.get() &amp; INTMASK;</span>
<span class="nc" id="L968">                startGlyphID[i] = ibuffer.get() &amp; INTMASK;</span>
            }

            /* Finds the high bit by binary searching through the bits */
<span class="nc" id="L972">            int value = numGroups;</span>

<span class="nc bnc" id="L974" title="All 2 branches missed.">            if (value &gt;= 1 &lt;&lt; 16) {</span>
<span class="nc" id="L975">                value &gt;&gt;= 16;</span>
<span class="nc" id="L976">                highBit += 16;</span>
            }

<span class="nc bnc" id="L979" title="All 2 branches missed.">            if (value &gt;= 1 &lt;&lt; 8) {</span>
<span class="nc" id="L980">                value &gt;&gt;= 8;</span>
<span class="nc" id="L981">                highBit += 8;</span>
            }

<span class="nc bnc" id="L984" title="All 2 branches missed.">            if (value &gt;= 1 &lt;&lt; 4) {</span>
<span class="nc" id="L985">                value &gt;&gt;= 4;</span>
<span class="nc" id="L986">                highBit += 4;</span>
            }

<span class="nc bnc" id="L989" title="All 2 branches missed.">            if (value &gt;= 1 &lt;&lt; 2) {</span>
<span class="nc" id="L990">                value &gt;&gt;= 2;</span>
<span class="nc" id="L991">                highBit += 2;</span>
            }

<span class="nc bnc" id="L994" title="All 2 branches missed.">            if (value &gt;= 1 &lt;&lt; 1) {</span>
<span class="nc" id="L995">                value &gt;&gt;= 1;</span>
<span class="nc" id="L996">                highBit += 1;</span>
            }

<span class="nc" id="L999">            power = 1 &lt;&lt; highBit;</span>
<span class="nc" id="L1000">            extra = numGroups - power;</span>
<span class="nc" id="L1001">        }</span>

        char getGlyph(int charCode) {
<span class="nc" id="L1004">            int controlGlyph = getControlCodeGlyph(charCode, false);</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">            if (controlGlyph &gt;= 0) {</span>
<span class="nc" id="L1006">                return (char)controlGlyph;</span>
            }
<span class="nc" id="L1008">            int probe = power;</span>
<span class="nc" id="L1009">            int range = 0;</span>

<span class="nc bnc" id="L1011" title="All 2 branches missed.">            if (startCharCode[extra] &lt;= charCode) {</span>
<span class="nc" id="L1012">                range = extra;</span>
            }

<span class="nc bnc" id="L1015" title="All 2 branches missed.">            while (probe &gt; 1) {</span>
<span class="nc" id="L1016">                probe &gt;&gt;= 1;</span>

<span class="nc bnc" id="L1018" title="All 2 branches missed.">                if (startCharCode[range+probe] &lt;= charCode) {</span>
<span class="nc" id="L1019">                    range += probe;</span>
                }
            }

<span class="nc bnc" id="L1023" title="All 4 branches missed.">            if (startCharCode[range] &lt;= charCode &amp;&amp;</span>
                  endCharCode[range] &gt;= charCode) {
<span class="nc" id="L1025">                return (char)</span>
                    (startGlyphID[range] + (charCode - startCharCode[range]));
            }

<span class="nc" id="L1029">            return 0;</span>
        }

    }

    /* Used to substitute for bad Cmaps. */
<span class="nc" id="L1035">    static class NullCMapClass extends CMap {</span>

        char getGlyph(int charCode) {
<span class="nc" id="L1038">            return 0;</span>
        }
    }

<span class="nc" id="L1042">    public static final NullCMapClass theNullCmap = new NullCMapClass();</span>

    final int getControlCodeGlyph(int charCode, boolean noSurrogates) {
<span class="nc bnc" id="L1045" title="All 2 branches missed.">        if (charCode &lt; 0x0010) {</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            switch (charCode) {</span>
            case 0x0009:
            case 0x000a:
<span class="nc" id="L1049">            case 0x000d: return CharToGlyphMapper.INVISIBLE_GLYPH_ID;</span>
            }
<span class="nc bnc" id="L1051" title="All 2 branches missed.">        } else if (charCode &gt;= 0x200c) {</span>
<span class="nc bnc" id="L1052" title="All 10 branches missed.">            if ((charCode &lt;= 0x200f) ||</span>
                (charCode &gt;= 0x2028 &amp;&amp; charCode &lt;= 0x202e) ||
                (charCode &gt;= 0x206a &amp;&amp; charCode &lt;= 0x206f)) {
<span class="nc" id="L1055">                return CharToGlyphMapper.INVISIBLE_GLYPH_ID;</span>
<span class="nc bnc" id="L1056" title="All 4 branches missed.">            } else if (noSurrogates &amp;&amp; charCode &gt;= 0xFFFF) {</span>
<span class="nc" id="L1057">                return 0;</span>
            }
        }
<span class="nc" id="L1060">        return -1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>