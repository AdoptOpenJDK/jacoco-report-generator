<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScriptRun.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.font</a> &gt; <span class="el_source">ScriptRun.java</span></div><h1>ScriptRun.java</h1><pre class="source lang-java linenums">/*
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */

/*
 *******************************************************************************
 *
 *   Copyright (C) 1999-2003, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *
 *******************************************************************************
 */

package sun.font;

/**
 * &lt;code&gt;ScriptRun&lt;/code&gt; is used to find runs of characters in
 * the same script, as defined in the &lt;code&gt;Script&lt;/code&gt; class.
 * It implements a simple iterator over an array of characters.
 * The iterator will assign &lt;code&gt;COMMON&lt;/code&gt; and &lt;code&gt;INHERITED&lt;/code&gt;
 * characters to the same script as the preceding characters. If the
 * COMMON and INHERITED characters are first, they will be assigned to
 * the same script as the following characters.
 *
 * The iterator will try to match paired punctuation. If it sees an
 * opening punctuation character, it will remember the script that
 * was assigned to that character, and assign the same script to the
 * matching closing punctuation.
 *
 * No attempt is made to combine related scripts into a single run. In
 * particular, Hiragana, Katakana, and Han characters will appear in seperate
 * runs.

 * Here is an example of how to iterate over script runs:
 * &lt;pre&gt;
 * void printScriptRuns(char[] text)
 * {
 *     ScriptRun scriptRun = new ScriptRun(text, 0, text.length);
 *
 *     while (scriptRun.next()) {
 *         int start  = scriptRun.getScriptStart();
 *         int limit  = scriptRun.getScriptLimit();
 *         int script = scriptRun.getScriptCode();
 *
 *         System.out.println(&quot;Script \&quot;&quot; + Script.getName(script) + &quot;\&quot; from &quot; +
 *                            start + &quot; to &quot; + limit + &quot;.&quot;);
 *     }
 *  }
 * &lt;/pre&gt;
 *
 */
public final class ScriptRun
{
    private char[] text;   // fixed once set by constructor
    private int textStart;
    private int textLimit;

    private int scriptStart;     // change during iteration
    private int scriptLimit;
    private int scriptCode;

    private int stack[];         // stack used to handle paired punctuation if encountered
    private int parenSP;

<span class="nc" id="L86">    public ScriptRun() {</span>
        // must call init later or we die.
<span class="nc" id="L88">    }</span>

    /**
     * Construct a &lt;code&gt;ScriptRun&lt;/code&gt; object which iterates over a subrange
     * of the given characetrs.
     *
     * @param chars the array of characters over which to iterate.
     * @param start the index of the first character over which to iterate
     * @param count the number of characters over which to iterate
     */
    public ScriptRun(char[] chars, int start, int count)
<span class="nc" id="L99">    {</span>
<span class="nc" id="L100">        init(chars, start, count);</span>
<span class="nc" id="L101">    }</span>

    public void init(char[] chars, int start, int count)
    {
<span class="nc bnc" id="L105" title="All 8 branches missed.">        if (chars == null || start &lt; 0 || count &lt; 0 || count &gt; chars.length - start) {</span>
<span class="nc" id="L106">            throw new IllegalArgumentException();</span>
        }

<span class="nc" id="L109">        text = chars;</span>
<span class="nc" id="L110">        textStart = start;</span>
<span class="nc" id="L111">        textLimit = start + count;</span>

<span class="nc" id="L113">        scriptStart = textStart;</span>
<span class="nc" id="L114">        scriptLimit = textStart;</span>
<span class="nc" id="L115">        scriptCode = Script.INVALID_CODE;</span>
<span class="nc" id="L116">        parenSP = 0;</span>
<span class="nc" id="L117">    }</span>

    /**
     * Get the starting index of the current script run.
     *
     * @return the index of the first character in the current script run.
     */
    public final int getScriptStart() {
<span class="nc" id="L125">        return scriptStart;</span>
    }

    /**
     * Get the index of the first character after the current script run.
     *
     * @return the index of the first character after the current script run.
     */
    public final int getScriptLimit() {
<span class="nc" id="L134">        return scriptLimit;</span>
    }

    /**
     * Get the script code for the script of the current script run.
     *
     * @return the script code for the script of the current script run.
     * @see #Script
     */
    public final int getScriptCode() {
<span class="nc" id="L144">        return scriptCode;</span>
    }

    /**
     * Find the next script run. Returns &lt;code&gt;false&lt;/code&gt; if there
     * isn't another run, returns &lt;code&gt;true&lt;/code&gt; if there is.
     *
     * @return &lt;code&gt;false&lt;/code&gt; if there isn't another run, &lt;code&gt;true&lt;/code&gt; if there is.
     */
    public final boolean next() {
<span class="nc" id="L154">        int startSP  = parenSP;  // used to find the first new open character</span>

        // if we've fallen off the end of the text, we're done
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (scriptLimit &gt;= textLimit) {</span>
<span class="nc" id="L158">            return false;</span>
        }

<span class="nc" id="L161">        scriptCode  = Script.COMMON;</span>
<span class="nc" id="L162">        scriptStart = scriptLimit;</span>

        int ch;

<span class="nc bnc" id="L166" title="All 2 branches missed.">        while ((ch = nextCodePoint()) != DONE) {</span>
<span class="nc" id="L167">            int sc = ScriptRunData.getScript(ch);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            int pairIndex = sc == Script.COMMON ? getPairIndex(ch) : -1;</span>

            // Paired character handling:
            //
            // if it's an open character, push it onto the stack.
            // if it's a close character, find the matching open on the
            // stack, and use that script code. Any non-matching open
            // characters above it on the stack will be popped.
<span class="nc bnc" id="L176" title="All 2 branches missed.">            if (pairIndex &gt;= 0) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                if ((pairIndex &amp; 1) == 0) {</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                    if (stack == null) {</span>
<span class="nc" id="L179">                        stack = new int[32];</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                    } else if (parenSP == stack.length) {</span>
<span class="nc" id="L181">                        int[] newstack = new int[stack.length + 32];</span>
<span class="nc" id="L182">                        System.arraycopy(stack, 0, newstack, 0, stack.length);</span>
<span class="nc" id="L183">                        stack = newstack;</span>
                    }

<span class="nc" id="L186">                    stack[parenSP++] = pairIndex;</span>
<span class="nc" id="L187">                    stack[parenSP++] = scriptCode;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                } else if (parenSP &gt; 0) {</span>
<span class="nc" id="L189">                    int pi = pairIndex &amp; ~1;</span>

<span class="nc bnc" id="L191" title="All 4 branches missed.">                    while ((parenSP -= 2) &gt;= 0 &amp;&amp; stack[parenSP] != pi);</span>

<span class="nc bnc" id="L193" title="All 2 branches missed.">                    if (parenSP &gt;= 0) {</span>
<span class="nc" id="L194">                        sc = stack[parenSP+1];</span>
                    } else {
<span class="nc" id="L196">                      parenSP = 0;</span>
                    }
<span class="nc bnc" id="L198" title="All 2 branches missed.">                    if (parenSP &lt; startSP) {</span>
<span class="nc" id="L199">                        startSP = parenSP;</span>
                    }
               }
            }

<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (sameScript(scriptCode, sc)) {</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">                if (scriptCode &lt;= Script.INHERITED &amp;&amp; sc &gt; Script.INHERITED) {</span>
<span class="nc" id="L206">                    scriptCode = sc;</span>

                    // now that we have a final script code, fix any open
                    // characters we pushed before we knew the script code.
<span class="nc bnc" id="L210" title="All 2 branches missed.">                    while (startSP &lt; parenSP) {</span>
<span class="nc" id="L211">                        stack[startSP+1] = scriptCode;</span>
<span class="nc" id="L212">                        startSP += 2;</span>
                    }
                }

                // if this character is a close paired character,
                // pop it from the stack
<span class="nc bnc" id="L218" title="All 6 branches missed.">                if (pairIndex &gt; 0 &amp;&amp; (pairIndex &amp; 1) != 0 &amp;&amp; parenSP &gt; 0) {</span>
<span class="nc" id="L219">                    parenSP -= 2;</span>
                }
            } else {
                // We've just seen the first character of
                // the next run. Back over it so we'll see
                // it again the next time.
<span class="nc" id="L225">                pushback(ch);</span>

                // we're outta here
<span class="nc" id="L228">                break;</span>
            }
<span class="nc" id="L230">        }</span>

<span class="nc" id="L232">        return true;</span>
    }

    static final int SURROGATE_START = 0x10000;
    static final int LEAD_START = 0xd800;
    static final int LEAD_LIMIT = 0xdc00;
    static final int TAIL_START = 0xdc00;
    static final int TAIL_LIMIT = 0xe000;
    static final int LEAD_SURROGATE_SHIFT = 10;
    static final int SURROGATE_OFFSET = SURROGATE_START - (LEAD_START &lt;&lt; LEAD_SURROGATE_SHIFT) - TAIL_START;

    static final int DONE = -1;

    private final int nextCodePoint() {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        if (scriptLimit &gt;= textLimit) {</span>
<span class="nc" id="L247">            return DONE;</span>
        }
<span class="nc" id="L249">        int ch = text[scriptLimit++];</span>
<span class="nc bnc" id="L250" title="All 6 branches missed.">        if (ch &gt;= LEAD_START &amp;&amp; ch &lt; LEAD_LIMIT &amp;&amp; scriptLimit &lt; textLimit) {</span>
<span class="nc" id="L251">            int nch = text[scriptLimit];</span>
<span class="nc bnc" id="L252" title="All 4 branches missed.">            if (nch &gt;= TAIL_START &amp;&amp; nch &lt; TAIL_LIMIT) {</span>
<span class="nc" id="L253">                ++scriptLimit;</span>
<span class="nc" id="L254">                ch = (ch &lt;&lt; LEAD_SURROGATE_SHIFT) + nch + SURROGATE_OFFSET;</span>
            }
        }
<span class="nc" id="L257">        return ch;</span>
    }

    private final void pushback(int ch) {
<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (ch &gt;= 0) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">            if (ch &gt;= 0x10000) {</span>
<span class="nc" id="L263">                scriptLimit -= 2;</span>
            } else {
<span class="nc" id="L265">                scriptLimit -= 1;</span>
            }
        }
<span class="nc" id="L268">    }</span>

    /**
     * Compare two script codes to see if they are in the same script. If one script is
     * a strong script, and the other is INHERITED or COMMON, it will compare equal.
     *
     * @param scriptOne one of the script codes.
     * @param scriptTwo the other script code.
     * @return &lt;code&gt;true&lt;/code&gt; if the two scripts are the same.
     * @see com.ibm.icu.lang.Script
     */
    private static boolean sameScript(int scriptOne, int scriptTwo) {
<span class="nc bnc" id="L280" title="All 6 branches missed.">        return scriptOne == scriptTwo || scriptOne &lt;= Script.INHERITED || scriptTwo &lt;= Script.INHERITED;</span>
    }

    /**
     * Find the highest bit that's set in a word. Uses a binary search through
     * the bits.
     *
     * @param n the word in which to find the highest bit that's set.
     * @return the bit number (counting from the low order bit) of the highest bit.
     */
    private static final byte highBit(int n)
    {
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (n &lt;= 0) {</span>
<span class="nc" id="L293">            return -32;</span>
        }

<span class="nc" id="L296">        byte bit = 0;</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (n &gt;= 1 &lt;&lt; 16) {</span>
<span class="nc" id="L299">            n &gt;&gt;= 16;</span>
<span class="nc" id="L300">            bit += 16;</span>
        }

<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (n &gt;= 1 &lt;&lt; 8) {</span>
<span class="nc" id="L304">            n &gt;&gt;= 8;</span>
<span class="nc" id="L305">            bit += 8;</span>
        }

<span class="nc bnc" id="L308" title="All 2 branches missed.">        if (n &gt;= 1 &lt;&lt; 4) {</span>
<span class="nc" id="L309">            n &gt;&gt;= 4;</span>
<span class="nc" id="L310">            bit += 4;</span>
        }

<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (n &gt;= 1 &lt;&lt; 2) {</span>
<span class="nc" id="L314">            n &gt;&gt;= 2;</span>
<span class="nc" id="L315">            bit += 2;</span>
        }

<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (n &gt;= 1 &lt;&lt; 1) {</span>
<span class="nc" id="L319">            n &gt;&gt;= 1;</span>
<span class="nc" id="L320">            bit += 1;</span>
        }

<span class="nc" id="L323">        return bit;</span>
    }

    /**
     * Search the pairedChars array for the given character.
     *
     * @param ch the character for which to search.
     * @return the index of the character in the table, or -1 if it's not there.
     */
    private static int getPairIndex(int ch)
    {
<span class="nc" id="L334">        int probe = pairedCharPower;</span>
<span class="nc" id="L335">        int index = 0;</span>

<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (ch &gt;= pairedChars[pairedCharExtra]) {</span>
<span class="nc" id="L338">            index = pairedCharExtra;</span>
        }

<span class="nc bnc" id="L341" title="All 2 branches missed.">        while (probe &gt; (1 &lt;&lt; 0)) {</span>
<span class="nc" id="L342">            probe &gt;&gt;= 1;</span>

<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (ch &gt;= pairedChars[index + probe]) {</span>
<span class="nc" id="L345">                index += probe;</span>
            }
        }

<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (pairedChars[index] != ch) {</span>
<span class="nc" id="L350">            index = -1;</span>
        }

<span class="nc" id="L353">        return index;</span>
    }

    // all common
<span class="nc" id="L357">    private static int pairedChars[] = {</span>
        0x0028, 0x0029, // ascii paired punctuation  // common
        0x003c, 0x003e, // common
        0x005b, 0x005d, // common
        0x007b, 0x007d, // common
        0x00ab, 0x00bb, // guillemets // common
        0x2018, 0x2019, // general punctuation // common
        0x201c, 0x201d, // common
        0x2039, 0x203a, // common
        0x3008, 0x3009, // chinese paired punctuation // common
        0x300a, 0x300b,
        0x300c, 0x300d,
        0x300e, 0x300f,
        0x3010, 0x3011,
        0x3014, 0x3015,
        0x3016, 0x3017,
        0x3018, 0x3019,
        0x301a, 0x301b
    };

<span class="nc" id="L377">    private static final int pairedCharPower = 1 &lt;&lt; highBit(pairedChars.length);</span>
<span class="nc" id="L378">    private static final int pairedCharExtra = pairedChars.length - pairedCharPower;</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>