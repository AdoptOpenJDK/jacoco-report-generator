<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BidiUtils.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.font</a> &gt; <span class="el_source">BidiUtils.java</span></div><h1>BidiUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * (C) Copyright IBM Corp. 1999-2000 - All Rights Reserved
 *
 * The original version of this source code and documentation is
 * copyrighted and owned by IBM. These materials are provided
 * under terms of a License Agreement between IBM and Sun.
 * This technology is protected by multiple US and International
 * patents. This notice and attribution to IBM may not be removed.
 */

package sun.font;

import java.text.Bidi;

<span class="nc" id="L40">public final class BidiUtils {</span>



    /**
     * Return the level of each character into the levels array starting at start.
     * This is a convenience method for clients who prefer to use an explicit levels
     * array instead of iterating over the runs.
     *
     * @param levels the array to receive the character levels
     * @param start the starting offset into the the array
     * @throws IndexOutOfBoundsException if &lt;code&gt;start&lt;/code&gt; is less than 0 or
     * &lt;code&gt;start + getLength()&lt;/code&gt; is greater than &lt;code&gt;levels.length&lt;/code&gt;.
     */
    public static void getLevels(Bidi bidi, byte[] levels, int start) {
<span class="nc" id="L55">        int limit = start + bidi.getLength();</span>

<span class="nc bnc" id="L57" title="All 4 branches missed.">        if (start &lt; 0 || limit &gt; levels.length) {</span>
<span class="nc" id="L58">            throw new IndexOutOfBoundsException(&quot;levels.length = &quot; + levels.length +</span>
                &quot; start: &quot; + start + &quot; limit: &quot; + limit);
        }

<span class="nc" id="L62">        int runCount = bidi.getRunCount();</span>
<span class="nc" id="L63">        int p = start;</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">        for (int i = 0; i &lt; runCount; ++i) {</span>
<span class="nc" id="L65">            int rlimit = start + bidi.getRunLimit(i);</span>
<span class="nc" id="L66">            byte rlevel = (byte)bidi.getRunLevel(i);</span>

<span class="nc bnc" id="L68" title="All 2 branches missed.">            while (p &lt; rlimit) {</span>
<span class="nc" id="L69">                levels[p++] = rlevel;</span>
            }
        }
<span class="nc" id="L72">    }</span>

    /**
     * Return an array containing the resolved bidi level of each character, in logical order.
     * @return an array containing the level of each character, in logical order.
     */
    public static byte[] getLevels(Bidi bidi) {
<span class="nc" id="L79">        byte[] levels = new byte[bidi.getLength()];</span>
<span class="nc" id="L80">        getLevels(bidi, levels, 0);</span>
<span class="nc" id="L81">        return levels;</span>
    }

    static final char NUMLEVELS = 62;

    /**
     * Given level data, compute a a visual to logical mapping.
     * The leftmost (or topmost) character is at visual index zero.  The
     * logical index of the character is derived from the visual index
     * by the expression &lt;code&gt;li = map[vi];&lt;/code&gt;.
     * @param levels the levels array
     * @return the mapping array from visual to logical
     */
    public static int[] createVisualToLogicalMap(byte[] levels) {
<span class="nc" id="L95">        int len = levels.length;</span>
<span class="nc" id="L96">        int[] mapping = new int[len];</span>

<span class="nc" id="L98">        byte lowestOddLevel = (byte)(NUMLEVELS + 1);</span>
<span class="nc" id="L99">        byte highestLevel = 0;</span>

        // initialize mapping and levels

<span class="nc bnc" id="L103" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L104">            mapping[i] = i;</span>

<span class="nc" id="L106">            byte level = levels[i];</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (level &gt; highestLevel) {</span>
<span class="nc" id="L108">                highestLevel = level;</span>
            }

<span class="nc bnc" id="L111" title="All 4 branches missed.">            if ((level &amp; 0x01) != 0 &amp;&amp; level &lt; lowestOddLevel) {</span>
<span class="nc" id="L112">                lowestOddLevel = level;</span>
            }
        }

<span class="nc bnc" id="L116" title="All 2 branches missed.">        while (highestLevel &gt;= lowestOddLevel) {</span>
<span class="nc" id="L117">            int i = 0;</span>
            for (;;) {
<span class="nc bnc" id="L119" title="All 4 branches missed.">                while (i &lt; len &amp;&amp; levels[i] &lt; highestLevel) {</span>
<span class="nc" id="L120">                    i++;</span>
                }
<span class="nc" id="L122">                int begin = i++;</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">                if (begin == levels.length) {</span>
<span class="nc" id="L125">                    break; // no more runs at this level</span>
                }

<span class="nc bnc" id="L128" title="All 4 branches missed.">                while (i &lt; len &amp;&amp; levels[i] &gt;= highestLevel) {</span>
<span class="nc" id="L129">                    i++;</span>
                }
<span class="nc" id="L131">                int end = i - 1;</span>

<span class="nc bnc" id="L133" title="All 2 branches missed.">                while (begin &lt; end) {</span>
<span class="nc" id="L134">                    int temp = mapping[begin];</span>
<span class="nc" id="L135">                    mapping[begin] = mapping[end];</span>
<span class="nc" id="L136">                    mapping[end] = temp;</span>
<span class="nc" id="L137">                    ++begin;</span>
<span class="nc" id="L138">                    --end;</span>
<span class="nc" id="L139">                }</span>
<span class="nc" id="L140">            }</span>

<span class="nc" id="L142">            --highestLevel;</span>
<span class="nc" id="L143">        }</span>

<span class="nc" id="L145">        return mapping;</span>
    }

    /**
     * Return the inverse position map.  The source array must map one-to-one (each value
     * is distinct and the values run from zero to the length of the array minus one).
     * For example, if &lt;code&gt;values[i] = j&lt;/code&gt;, then &lt;code&gt;inverse[j] = i&lt;/code&gt;.
     * @param values the source ordering array
     * @return the inverse array
     */
    public static int[] createInverseMap(int[] values) {
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (values == null) {</span>
<span class="nc" id="L157">            return null;</span>
        }

<span class="nc" id="L160">        int[] result = new int[values.length];</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        for (int i = 0; i &lt; values.length; i++) {</span>
<span class="nc" id="L162">            result[values[i]] = i;</span>
        }

<span class="nc" id="L165">        return result;</span>
    }


    /**
     * Return an array containing contiguous values from 0 to length
     * having the same ordering as the source array. If this would be
     * a canonical ltr ordering, return null.  The data in values[] is NOT
     * required to be a permutation, but elements in values are required
     * to be distinct.
     * @param values an array containing the discontiguous values
     * @return the contiguous values
     */
    public static int[] createContiguousOrder(int[] values) {
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (values != null) {</span>
<span class="nc" id="L180">            return computeContiguousOrder(values, 0, values.length);</span>
        }

<span class="nc" id="L183">        return null;</span>
    }

    /**
     * Compute a contiguous order for the range start, limit.
     */
    private static int[] computeContiguousOrder(int[] values, int start,
                                                int limit) {

<span class="nc" id="L192">        int[] result = new int[limit-start];</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        for (int i=0; i &lt; result.length; i++) {</span>
<span class="nc" id="L194">            result[i] = i + start;</span>
        }

        // now we'll sort result[], with the following comparison:
        // result[i] lessthan result[j] iff values[result[i]] &lt; values[result[j]]

        // selection sort for now;  use more elaborate sorts if desired
<span class="nc bnc" id="L201" title="All 2 branches missed.">        for (int i=0; i &lt; result.length-1; i++) {</span>
<span class="nc" id="L202">            int minIndex = i;</span>
<span class="nc" id="L203">            int currentValue = values[result[minIndex]];</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            for (int j=i; j &lt; result.length; j++) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                if (values[result[j]] &lt; currentValue) {</span>
<span class="nc" id="L206">                    minIndex = j;</span>
<span class="nc" id="L207">                    currentValue = values[result[minIndex]];</span>
                }
            }
<span class="nc" id="L210">            int temp = result[i];</span>
<span class="nc" id="L211">            result[i] = result[minIndex];</span>
<span class="nc" id="L212">            result[minIndex] = temp;</span>
        }

        // shift result by start:
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (start != 0) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            for (int i=0; i &lt; result.length; i++) {</span>
<span class="nc" id="L218">                result[i] -= start;</span>
            }
        }

        // next, check for canonical order:
        int k;
<span class="nc bnc" id="L224" title="All 2 branches missed.">        for (k=0; k &lt; result.length; k++) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            if (result[k] != k) {</span>
<span class="nc" id="L226">                break;</span>
            }
        }

<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (k == result.length) {</span>
<span class="nc" id="L231">            return null;</span>
        }

        // now return inverse of result:
<span class="nc" id="L235">        return createInverseMap(result);</span>
    }

    /**
     * Return an array containing the data in the values array from start up to limit,
     * normalized to fall within the range from 0 up to limit - start.
     * If this would be a canonical ltr ordering, return null.
     * NOTE: This method assumes that values[] is a logical to visual map
     * generated from levels[].
     * @param values the source mapping
     * @param levels the levels corresponding to the values
     * @param start the starting offset in the values and levels arrays
     * @param limit the limiting offset in the values and levels arrays
     * @return the normlized map
     */
    public static int[] createNormalizedMap(int[] values, byte[] levels,
                                           int start, int limit) {

<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (values != null) {</span>
<span class="nc bnc" id="L254" title="All 4 branches missed.">            if (start != 0 || limit != values.length) {</span>
                // levels optimization
                boolean copyRange, canonical;
                byte primaryLevel;

<span class="nc bnc" id="L259" title="All 2 branches missed.">                if (levels == null) {</span>
<span class="nc" id="L260">                    primaryLevel = (byte) 0x0;</span>
<span class="nc" id="L261">                    copyRange = true;</span>
<span class="nc" id="L262">                    canonical = true;</span>
                }
                else {
<span class="nc bnc" id="L265" title="All 2 branches missed.">                    if (levels[start] == levels[limit-1]) {</span>
<span class="nc" id="L266">                        primaryLevel = levels[start];</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">                        canonical = (primaryLevel &amp; (byte)0x1) == 0;</span>

                        // scan for levels below primary
                        int i;
<span class="nc bnc" id="L271" title="All 2 branches missed.">                        for (i=start; i &lt; limit; i++) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">                            if (levels[i] &lt; primaryLevel) {</span>
<span class="nc" id="L273">                                break;</span>
                            }
<span class="nc bnc" id="L275" title="All 2 branches missed.">                            if (canonical) {</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">                                canonical = levels[i] == primaryLevel;</span>
                            }
                        }

<span class="nc bnc" id="L280" title="All 2 branches missed.">                        copyRange = (i == limit);</span>
<span class="nc" id="L281">                    }</span>
                    else {
<span class="nc" id="L283">                        copyRange = false;</span>

                        // these don't matter;  but the compiler cares:
<span class="nc" id="L286">                        primaryLevel = (byte) 0x0;</span>
<span class="nc" id="L287">                        canonical = false;</span>
                    }
                }

<span class="nc bnc" id="L291" title="All 2 branches missed.">                if (copyRange) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                    if (canonical) {</span>
<span class="nc" id="L293">                        return null;</span>
                    }

<span class="nc" id="L296">                    int[] result = new int[limit-start];</span>
                    int baseValue;

<span class="nc bnc" id="L299" title="All 2 branches missed.">                    if ((primaryLevel &amp; (byte)0x1) != 0) {</span>
<span class="nc" id="L300">                        baseValue = values[limit-1];</span>
                    } else {
<span class="nc" id="L302">                        baseValue = values[start];</span>
                    }

<span class="nc bnc" id="L305" title="All 2 branches missed.">                    if (baseValue == 0) {</span>
<span class="nc" id="L306">                        System.arraycopy(values, start, result, 0, limit-start);</span>
                    }
                    else {
<span class="nc bnc" id="L309" title="All 2 branches missed.">                        for (int j=0; j &lt; result.length; j++) {</span>
<span class="nc" id="L310">                            result[j] = values[j+start] - baseValue;</span>
                        }
                    }

<span class="nc" id="L314">                    return result;</span>
                }
                else {
<span class="nc" id="L317">                    return computeContiguousOrder(values, start, limit);</span>
                }
            }
            else {
<span class="nc" id="L321">                return values;</span>
            }
        }

<span class="nc" id="L325">        return null;</span>
    }

    /**
     * Reorder the objects in the array into visual order based on their levels.
     * This is a utility function to use when you have a collection of objects
     * representing runs of text in logical order, each run containing text
     * at a single level.  The elements in the objects array will be reordered
     * into visual order assuming each run of text has the level provided
     * by the corresponding element in the levels array.
     * @param levels an array representing the bidi level of each object
     * @param objects the array of objects to be reordered into visual order
     */
    public static void reorderVisually(byte[] levels, Object[] objects) {
<span class="nc" id="L339">        int len = levels.length;</span>

<span class="nc" id="L341">        byte lowestOddLevel = (byte)(NUMLEVELS + 1);</span>
<span class="nc" id="L342">        byte highestLevel = 0;</span>

        // initialize mapping and levels

<span class="nc bnc" id="L346" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc" id="L347">            byte level = levels[i];</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">            if (level &gt; highestLevel) {</span>
<span class="nc" id="L349">                highestLevel = level;</span>
            }

<span class="nc bnc" id="L352" title="All 4 branches missed.">            if ((level &amp; 0x01) != 0 &amp;&amp; level &lt; lowestOddLevel) {</span>
<span class="nc" id="L353">                lowestOddLevel = level;</span>
            }
        }

<span class="nc bnc" id="L357" title="All 2 branches missed.">        while (highestLevel &gt;= lowestOddLevel) {</span>
<span class="nc" id="L358">            int i = 0;</span>
            for (;;) {
<span class="nc bnc" id="L360" title="All 4 branches missed.">                while (i &lt; len &amp;&amp; levels[i] &lt; highestLevel) {</span>
<span class="nc" id="L361">                    i++;</span>
                }
<span class="nc" id="L363">                int begin = i++;</span>

<span class="nc bnc" id="L365" title="All 2 branches missed.">                if (begin == levels.length) {</span>
<span class="nc" id="L366">                    break; // no more runs at this level</span>
                }

<span class="nc bnc" id="L369" title="All 4 branches missed.">                while (i &lt; len &amp;&amp; levels[i] &gt;= highestLevel) {</span>
<span class="nc" id="L370">                    i++;</span>
                }
<span class="nc" id="L372">                int end = i - 1;</span>

<span class="nc bnc" id="L374" title="All 2 branches missed.">                while (begin &lt; end) {</span>
<span class="nc" id="L375">                    Object temp = objects[begin];</span>
<span class="nc" id="L376">                    objects[begin] = objects[end];</span>
<span class="nc" id="L377">                    objects[end] = temp;</span>
<span class="nc" id="L378">                    ++begin;</span>
<span class="nc" id="L379">                    --end;</span>
<span class="nc" id="L380">                }</span>
<span class="nc" id="L381">            }</span>

<span class="nc" id="L383">            --highestLevel;</span>
<span class="nc" id="L384">        }</span>
<span class="nc" id="L385">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>