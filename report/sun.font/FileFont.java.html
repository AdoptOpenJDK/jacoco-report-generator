<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>FileFont.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.font</a> &gt; <span class="el_source">FileFont.java</span></div><h1>FileFont.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.font;

import java.lang.ref.Reference;
import java.awt.FontFormatException;
import java.awt.geom.GeneralPath;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.io.File;
import java.nio.ByteBuffer;
import sun.java2d.Disposer;
import sun.java2d.DisposerRecord;

import java.io.IOException;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;

public abstract class FileFont extends PhysicalFont {

<span class="nc" id="L45">    protected boolean useJavaRasterizer = true;</span>

    /* I/O and file operations are always synchronized on the font
     * object. Two threads can be accessing the font and retrieving
     * information, and synchronized only to the extent that filesystem
     * operations require.
     * A limited number of files can be open at a time, to limit the
     * absorption of file descriptors. If a file needs to be opened
     * when there are none free, then the synchronization of all I/O
     * ensures that any in progress operation will complete before some
     * other thread closes the descriptor in order to allocate another one.
     */
    // NB consider using a RAF. FIS has finalize method so may take a
    // little longer to be GC'd. We don't use this stream at all anyway.
    // In fact why increase the size of a FileFont object if the stream
    // isn't needed ..
    //protected FileInputStream stream;
    //protected FileChannel channel;
    protected int fileSize;

    protected FontScaler scaler;

    /* The following variables are used, (and in the case of the arrays,
     * only initialised) for select fonts where a native scaler may be
     * used to get glyph images and metrics.
     * glyphToCharMap is filled in on the fly and used to do a reverse
     * lookup when a FileFont needs to get the charcode back from a glyph
     * code so it can re-map via a NativeGlyphMapper to get a native glyph.
     * This isn't a big hit in time, since a boolean test is sufficient
     * to choose the usual default path, nor in memory for fonts which take
     * the native path, since fonts have contiguous zero-based glyph indexes,
     * and these obviously do all exist in the font.
     */
    protected boolean checkedNatives;
    protected boolean useNatives;
    protected NativeFont[] nativeFonts;
    protected char[] glyphToCharMap;
    /*
     * @throws FontFormatException - if the font can't be opened
     */
    FileFont(String platname, Object nativeNames)
        throws FontFormatException {

<span class="nc" id="L88">        super(platname, nativeNames);</span>
<span class="nc" id="L89">    }</span>

    FontStrike createStrike(FontStrikeDesc desc) {
<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (!checkedNatives) {</span>
<span class="nc" id="L93">           checkUseNatives();</span>
        }
<span class="nc" id="L95">        return new FileFontStrike(this, desc);</span>
    }

    protected boolean checkUseNatives() {
<span class="nc" id="L99">        checkedNatives = true;</span>
<span class="nc" id="L100">        return useNatives;</span>
    }

    /* This method needs to be accessible to FontManager if there is
     * file pool management. It may be a no-op.
     */
    protected abstract void close();


    /*
     * This is the public interface. The subclasses need to implement
     * this. The returned block may be longer than the requested length.
     */
    abstract ByteBuffer readBlock(int offset, int length);

    public boolean canDoStyle(int style) {
<span class="nc" id="L116">        return true;</span>
    }

    void setFileToRemove(File file, CreatedFontTracker tracker) {
<span class="nc" id="L120">        Disposer.addObjectRecord(this,</span>
                         new CreatedFontFileDisposerRecord(file, tracker));
<span class="nc" id="L122">    }</span>

    // MACOSX begin -- Make this static so that we can pass in CFont
    static void setFileToRemove(Object font, File file, CreatedFontTracker tracker) {
<span class="nc" id="L126">        Disposer.addObjectRecord(font,</span>
                         new CreatedFontFileDisposerRecord(file, tracker));
<span class="nc" id="L128">    }</span>
    // MACOSX - end

    /* This is called when a font scaler is determined to
     * be unusable (ie bad).
     * We want to replace current scaler with NullFontScaler, so
     * we never try to use same font scaler again.
     * Scaler native resources could have already been disposed
     * or they will be eventually by Java2D disposer.
     * However, it should be safe to call dispose() explicitly here.
     *
     * For safety we also invalidate all strike's scaler context.
     * So, in case they cache pointer to native scaler
     * it will not ever be used.
     *
     * It also appears desirable to remove all the entries from the
     * cache so no other code will pick them up. But we can't just
     * 'delete' them as code may be using them. And simply dropping
     * the reference to the cache will make the reference objects
     * unreachable and so they will not get disposed.
     * Since a strike may hold (via java arrays) native pointers to many
     * rasterised glyphs, this would be a memory leak.
     * The solution is :
     * - to move all the entries to another map where they
     *   are no longer locatable
     * - update FontStrikeDisposer to be able to distinguish which
     * map they are held in via a boolean flag
     * Since this isn't expected to be anything other than an extremely
     * rare maybe it is not worth doing this last part.
     */
    synchronized void deregisterFontAndClearStrikeCache() {
<span class="nc" id="L159">        SunFontManager fm = SunFontManager.getInstance();</span>
<span class="nc" id="L160">        fm.deRegisterBadFont(this);</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">        for (Reference strikeRef : strikeCache.values()) {</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (strikeRef != null) {</span>
                /* NB we know these are all FileFontStrike instances
                 * because the cache is on this FileFont
                 */
<span class="nc" id="L167">                FileFontStrike strike = (FileFontStrike)strikeRef.get();</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">                if (strike != null &amp;&amp; strike.pScalerContext != 0L) {</span>
<span class="nc" id="L169">                    scaler.invalidateScalerContext(strike.pScalerContext);</span>
                }
            }
<span class="nc" id="L172">        }</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (scaler != null) {</span>
<span class="nc" id="L174">            scaler.dispose();</span>
        }
<span class="nc" id="L176">        scaler = FontScaler.getNullScaler();</span>
<span class="nc" id="L177">    }</span>

    StrikeMetrics getFontMetrics(long pScalerContext) {
        try {
<span class="nc" id="L181">            return getScaler().getFontMetrics(pScalerContext);</span>
<span class="nc" id="L182">        } catch (FontScalerException fe) {</span>
<span class="nc" id="L183">            scaler = FontScaler.getNullScaler();</span>
<span class="nc" id="L184">            return getFontMetrics(pScalerContext);</span>
        }
    }

    float getGlyphAdvance(long pScalerContext, int glyphCode) {
        try {
<span class="nc" id="L190">            return getScaler().getGlyphAdvance(pScalerContext, glyphCode);</span>
<span class="nc" id="L191">        } catch (FontScalerException fe) {</span>
<span class="nc" id="L192">            scaler = FontScaler.getNullScaler();</span>
<span class="nc" id="L193">            return getGlyphAdvance(pScalerContext, glyphCode);</span>
        }
    }

    void getGlyphMetrics(long pScalerContext, int glyphCode, Point2D.Float metrics) {
        try {
<span class="nc" id="L199">            getScaler().getGlyphMetrics(pScalerContext, glyphCode, metrics);</span>
<span class="nc" id="L200">        } catch (FontScalerException fe) {</span>
<span class="nc" id="L201">            scaler = FontScaler.getNullScaler();</span>
<span class="nc" id="L202">            getGlyphMetrics(pScalerContext, glyphCode, metrics);</span>
<span class="nc" id="L203">        }</span>
<span class="nc" id="L204">    }</span>

    long getGlyphImage(long pScalerContext, int glyphCode) {
        try {
<span class="nc" id="L208">            return getScaler().getGlyphImage(pScalerContext, glyphCode);</span>
<span class="nc" id="L209">        } catch (FontScalerException fe) {</span>
<span class="nc" id="L210">            scaler = FontScaler.getNullScaler();</span>
<span class="nc" id="L211">            return getGlyphImage(pScalerContext, glyphCode);</span>
        }
    }

    Rectangle2D.Float getGlyphOutlineBounds(long pScalerContext, int glyphCode) {
        try {
<span class="nc" id="L217">            return getScaler().getGlyphOutlineBounds(pScalerContext, glyphCode);</span>
<span class="nc" id="L218">        } catch (FontScalerException fe) {</span>
<span class="nc" id="L219">            scaler = FontScaler.getNullScaler();</span>
<span class="nc" id="L220">            return getGlyphOutlineBounds(pScalerContext, glyphCode);</span>
        }
    }

    GeneralPath getGlyphOutline(long pScalerContext, int glyphCode, float x, float y) {
        try {
<span class="nc" id="L226">            return getScaler().getGlyphOutline(pScalerContext, glyphCode, x, y);</span>
<span class="nc" id="L227">        } catch (FontScalerException fe) {</span>
<span class="nc" id="L228">            scaler = FontScaler.getNullScaler();</span>
<span class="nc" id="L229">            return getGlyphOutline(pScalerContext, glyphCode, x, y);</span>
        }
    }

    GeneralPath getGlyphVectorOutline(long pScalerContext, int[] glyphs, int numGlyphs, float x, float y) {
        try {
<span class="nc" id="L235">            return getScaler().getGlyphVectorOutline(pScalerContext, glyphs, numGlyphs, x, y);</span>
<span class="nc" id="L236">        } catch (FontScalerException fe) {</span>
<span class="nc" id="L237">            scaler = FontScaler.getNullScaler();</span>
<span class="nc" id="L238">            return getGlyphVectorOutline(pScalerContext, glyphs, numGlyphs, x, y);</span>
        }
    }

    /* T1 &amp; TT implementation differ so this method is abstract.
       NB: null should not be returned here! */
    protected abstract FontScaler getScaler();

    protected long getUnitsPerEm() {
<span class="nc" id="L247">        return getScaler().getUnitsPerEm();</span>
    }

    private static class CreatedFontFileDisposerRecord
        implements DisposerRecord {

<span class="nc" id="L253">        File fontFile = null;</span>
        CreatedFontTracker tracker;

        private CreatedFontFileDisposerRecord(File file,
<span class="nc" id="L257">                                              CreatedFontTracker tracker) {</span>
<span class="nc" id="L258">            fontFile = file;</span>
<span class="nc" id="L259">            this.tracker = tracker;</span>
<span class="nc" id="L260">        }</span>

        public void dispose() {
<span class="nc" id="L263">            java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L264">                 new java.security.PrivilegedAction() {</span>
                      public Object run() {
<span class="nc bnc" id="L266" title="All 2 branches missed.">                          if (fontFile != null) {</span>
                              try {
<span class="nc bnc" id="L268" title="All 2 branches missed.">                                  if (tracker != null) {</span>
<span class="nc" id="L269">                                      tracker.subBytes((int)fontFile.length());</span>
                                  }
                                  /* REMIND: is it possible that the file is
                                   * still open? It will be closed when the
                                   * font2D is disposed but could this code
                                   * execute first? If so the file would not
                                   * be deleted on MS-windows.
                                   */
<span class="nc" id="L277">                                  fontFile.delete();</span>
                                  /* remove from delete on exit hook list : */
                                  // FIXME: still need to be refactored
<span class="nc" id="L280">                                  SunFontManager.getInstance().tmpFontFiles.remove(fontFile);</span>
<span class="nc" id="L281">                              } catch (Exception e) {</span>
<span class="nc" id="L282">                              }</span>
                          }
<span class="nc" id="L284">                          return null;</span>
                      }
            });
<span class="nc" id="L287">        }</span>
    }

    protected String getPublicFileName() {
<span class="nc" id="L291">        SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (sm == null) {</span>
<span class="nc" id="L293">            return platName;</span>
        }
<span class="nc" id="L295">        boolean canReadProperty = true;</span>

        try {
<span class="nc" id="L298">            sm.checkPropertyAccess(&quot;java.io.tmpdir&quot;);</span>
<span class="nc" id="L299">        } catch (SecurityException e) {</span>
<span class="nc" id="L300">            canReadProperty = false;</span>
<span class="nc" id="L301">        }</span>

<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (canReadProperty) {</span>
<span class="nc" id="L304">            return platName;</span>
        }

<span class="nc" id="L307">        final File f = new File(platName);</span>

<span class="nc" id="L309">        Boolean isTmpFile = Boolean.FALSE;</span>
        try {
<span class="nc" id="L311">            isTmpFile = AccessController.doPrivileged(</span>
<span class="nc" id="L312">                new PrivilegedExceptionAction&lt;Boolean&gt;() {</span>
                    public Boolean run() {
<span class="nc" id="L314">                        File tmp = new File(System.getProperty(&quot;java.io.tmpdir&quot;));</span>
                        try {
<span class="nc" id="L316">                            String tpath = tmp.getCanonicalPath();</span>
<span class="nc" id="L317">                            String fpath = f.getCanonicalPath();</span>

<span class="nc bnc" id="L319" title="All 4 branches missed.">                            return (fpath == null) || fpath.startsWith(tpath);</span>
<span class="nc" id="L320">                        } catch (IOException e) {</span>
<span class="nc" id="L321">                            return Boolean.TRUE;</span>
                        }
                    }
                }
            );
<span class="nc" id="L326">        } catch (PrivilegedActionException e) {</span>
            // unable to verify whether value of java.io.tempdir will be
            // exposed, so return only a name of the font file.
<span class="nc" id="L329">            isTmpFile = Boolean.TRUE;</span>
<span class="nc" id="L330">        }</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">        return  isTmpFile ? &quot;temp file&quot; : platName;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>