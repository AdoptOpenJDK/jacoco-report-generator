<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EnvHelp.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.jmx.remote.util</a> &gt; <span class="el_source">EnvHelp.java</span></div><h1>EnvHelp.java</h1><pre class="source lang-java linenums">
/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.jmx.remote.util;

import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.StringTokenizer;
import java.util.TreeMap;
import java.util.TreeSet;

import java.security.AccessController;

import javax.management.ObjectName;
import javax.management.MBeanServer;
import javax.management.InstanceNotFoundException;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXConnectorServerFactory;
import com.sun.jmx.mbeanserver.GetPropertyAction;
import com.sun.jmx.remote.security.NotificationAccessController;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorServer;

<span class="nc" id="L55">public class EnvHelp {</span>

    /**
     * &lt;p&gt;Name of the attribute that specifies a default class loader
     * object.
     * The value associated with this attribute is a ClassLoader object&lt;/p&gt;
     */
    private static final String DEFAULT_CLASS_LOADER =
        JMXConnectorFactory.DEFAULT_CLASS_LOADER;

    /**
     * &lt;p&gt;Name of the attribute that specifies a default class loader
     *    ObjectName.
     * The value associated with this attribute is an ObjectName object&lt;/p&gt;
     */
    private static final String DEFAULT_CLASS_LOADER_NAME =
        JMXConnectorServerFactory.DEFAULT_CLASS_LOADER_NAME;

    /**
     * Get the Connector Server default class loader.
     * &lt;p&gt;
     * Returns:
     * &lt;p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;
     *     The ClassLoader object found in &lt;var&gt;env&lt;/var&gt; for
     *     &lt;code&gt;jmx.remote.default.class.loader&lt;/code&gt;, if any.
     * &lt;/li&gt;
     * &lt;li&gt;
     *     The ClassLoader pointed to by the ObjectName found in
     *     &lt;var&gt;env&lt;/var&gt; for &lt;code&gt;jmx.remote.default.class.loader.name&lt;/code&gt;,
     *     and registered in &lt;var&gt;mbs&lt;/var&gt; if any.
     * &lt;/li&gt;
     * &lt;li&gt;
     *     The current thread's context classloader otherwise.
     * &lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param env Environment attributes.
     * @param mbs The MBeanServer for which the connector server provides
     * remote access.
     *
     * @return the connector server's default class loader.
     *
     * @exception IllegalArgumentException if one of the following is true:
     * &lt;ul&gt;
     * &lt;li&gt;both
     *     &lt;code&gt;jmx.remote.default.class.loader&lt;/code&gt; and
     *     &lt;code&gt;jmx.remote.default.class.loader.name&lt;/code&gt; are specified,
     * &lt;/li&gt;
     * &lt;li&gt;or
     *     &lt;code&gt;jmx.remote.default.class.loader&lt;/code&gt; is not
     *     an instance of {@link ClassLoader},
     * &lt;/li&gt;
     * &lt;li&gt;or
     *     &lt;code&gt;jmx.remote.default.class.loader.name&lt;/code&gt; is not
     *     an instance of {@link ObjectName},
     * &lt;/li&gt;
     * &lt;li&gt;or
     *     &lt;code&gt;jmx.remote.default.class.loader.name&lt;/code&gt; is specified
     *     but &lt;var&gt;mbs&lt;/var&gt; is null.
     * &lt;/li&gt;
     * @exception InstanceNotFoundException if
     * &lt;code&gt;jmx.remote.default.class.loader.name&lt;/code&gt; is specified
     * and the ClassLoader MBean is not found in &lt;var&gt;mbs&lt;/var&gt;.
     */
    public static ClassLoader resolveServerClassLoader(Map&lt;String, ?&gt; env,
                                                       MBeanServer mbs)
        throws InstanceNotFoundException {

<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (env == null)</span>
<span class="nc" id="L126">            return Thread.currentThread().getContextClassLoader();</span>

<span class="nc" id="L128">        Object loader = env.get(DEFAULT_CLASS_LOADER);</span>
<span class="nc" id="L129">        Object name   = env.get(DEFAULT_CLASS_LOADER_NAME);</span>

<span class="nc bnc" id="L131" title="All 4 branches missed.">        if (loader != null &amp;&amp; name != null) {</span>
            final String msg = &quot;Only one of &quot; +
                DEFAULT_CLASS_LOADER + &quot; or &quot; +
                DEFAULT_CLASS_LOADER_NAME +
                &quot; should be specified.&quot;;
<span class="nc" id="L136">            throw new IllegalArgumentException(msg);</span>
        }

<span class="nc bnc" id="L139" title="All 4 branches missed.">        if (loader == null &amp;&amp; name == null)</span>
<span class="nc" id="L140">            return Thread.currentThread().getContextClassLoader();</span>

<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (loader != null) {</span>
<span class="nc bnc" id="L143" title="All 2 branches missed.">            if (loader instanceof ClassLoader) {</span>
<span class="nc" id="L144">                return (ClassLoader) loader;</span>
            } else {
<span class="nc" id="L146">                final String msg =</span>
                    &quot;ClassLoader object is not an instance of &quot; +
<span class="nc" id="L148">                    ClassLoader.class.getName() + &quot; : &quot; +</span>
<span class="nc" id="L149">                    loader.getClass().getName();</span>
<span class="nc" id="L150">                throw new IllegalArgumentException(msg);</span>
            }
        }

        ObjectName on;
<span class="nc bnc" id="L155" title="All 2 branches missed.">        if (name instanceof ObjectName) {</span>
<span class="nc" id="L156">            on = (ObjectName) name;</span>
        } else {
<span class="nc" id="L158">            final String msg =</span>
                &quot;ClassLoader name is not an instance of &quot; +
<span class="nc" id="L160">                ObjectName.class.getName() + &quot; : &quot; +</span>
<span class="nc" id="L161">                name.getClass().getName();</span>
<span class="nc" id="L162">            throw new IllegalArgumentException(msg);</span>
        }

<span class="nc bnc" id="L165" title="All 2 branches missed.">        if (mbs == null)</span>
<span class="nc" id="L166">            throw new IllegalArgumentException(&quot;Null MBeanServer object&quot;);</span>

<span class="nc" id="L168">        return mbs.getClassLoader(on);</span>
    }

    /**
     * Get the Connector Client default class loader.
     * &lt;p&gt;
     * Returns:
     * &lt;p&gt;
     * &lt;ul&gt;
     * &lt;li&gt;
     *     The ClassLoader object found in &lt;var&gt;env&lt;/var&gt; for
     *     &lt;code&gt;jmx.remote.default.class.loader&lt;/code&gt;, if any.
     * &lt;/li&gt;
     * &lt;li&gt;The &lt;tt&gt;Thread.currentThread().getContextClassLoader()&lt;/tt&gt;
     *     otherwise.
     * &lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;p&gt;
     * Usually a Connector Client will call
     * &lt;pre&gt;
     * ClassLoader dcl = EnvHelp.resolveClientClassLoader(env);
     * &lt;/pre&gt;
     * in its &lt;code&gt;connect(Map env)&lt;/code&gt; method.
     *
     * @return The connector client default class loader.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;jmx.remote.default.class.loader&lt;/code&gt; is specified
     * and is not an instance of {@link ClassLoader}.
     */
    public static ClassLoader resolveClientClassLoader(Map&lt;String, ?&gt; env) {

<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (env == null)</span>
<span class="nc" id="L201">            return Thread.currentThread().getContextClassLoader();</span>

<span class="nc" id="L203">        Object loader = env.get(DEFAULT_CLASS_LOADER);</span>

<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (loader == null)</span>
<span class="nc" id="L206">            return Thread.currentThread().getContextClassLoader();</span>

<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (loader instanceof ClassLoader) {</span>
<span class="nc" id="L209">            return (ClassLoader) loader;</span>
        } else {
<span class="nc" id="L211">            final String msg =</span>
                &quot;ClassLoader object is not an instance of &quot; +
<span class="nc" id="L213">                ClassLoader.class.getName() + &quot; : &quot; +</span>
<span class="nc" id="L214">                loader.getClass().getName();</span>
<span class="nc" id="L215">            throw new IllegalArgumentException(msg);</span>
        }
    }

    /**
     * Initialize the cause field of a {@code Throwable} object.
     *
     * @param throwable The {@code Throwable} on which the cause is set.
     * @param cause The cause to set on the supplied {@code Throwable}.
     * @return the {@code Throwable} with the cause field initialized.
     */
    public static &lt;T extends Throwable&gt; T initCause(T throwable,
                                                    Throwable cause) {
<span class="nc" id="L228">        throwable.initCause(cause);</span>
<span class="nc" id="L229">        return throwable;</span>
    }

    /**
     * Returns the cause field of a {@code Throwable} object.
     * The cause field can be got only if &lt;var&gt;t&lt;/var&gt; has an
     * {@link Throwable#getCause()} method (JDK Version &gt;= 1.4)
     * @param t {@code Throwable} on which the cause must be set.
     * @return the cause if getCause() succeeded and the got value is not
     * null, otherwise return the &lt;var&gt;t&lt;/var&gt;.
     */
    public static Throwable getCause(Throwable t) {
<span class="nc" id="L241">        Throwable ret = t;</span>

        try {
<span class="nc" id="L244">            java.lang.reflect.Method getCause =</span>
<span class="nc" id="L245">                t.getClass().getMethod(&quot;getCause&quot;, (Class&lt;?&gt;[]) null);</span>
<span class="nc" id="L246">            ret = (Throwable)getCause.invoke(t, (Object[]) null);</span>

<span class="nc" id="L248">        } catch (Exception e) {</span>
            // OK.
            // it must be older than 1.4.
<span class="nc" id="L251">        }</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">        return (ret != null) ? ret: t;</span>
    }


    /**
     * &lt;p&gt;Name of the attribute that specifies the size of a notification
     * buffer for a connector server. The default value is 1000.
     */
    public static final String BUFFER_SIZE_PROPERTY =
        &quot;jmx.remote.x.notification.buffer.size&quot;;


    /**
     * Returns the size of a notification buffer for a connector server.
     * The default value is 1000.
     */
    public static int getNotifBufferSize(Map&lt;String, ?&gt; env) {
<span class="nc" id="L269">        int defaultQueueSize = 1000; // default value</span>

        // keep it for the compability for the fix:
        // 6174229: Environment parameter should be notification.buffer.size
        // instead of buffer.size
        final String oldP = &quot;jmx.remote.x.buffer.size&quot;;

        // the default value re-specified in the system
        try {
<span class="nc" id="L278">            GetPropertyAction act = new GetPropertyAction(BUFFER_SIZE_PROPERTY);</span>
<span class="nc" id="L279">            String s = AccessController.doPrivileged(act);</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            if (s != null) {</span>
<span class="nc" id="L281">                defaultQueueSize = Integer.parseInt(s);</span>
            } else { // try the old one
<span class="nc" id="L283">                act = new GetPropertyAction(oldP);</span>
<span class="nc" id="L284">                s = AccessController.doPrivileged(act);</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                if (s != null) {</span>
<span class="nc" id="L286">                    defaultQueueSize = Integer.parseInt(s);</span>
                }
            }
<span class="nc" id="L289">        } catch (RuntimeException e) {</span>
<span class="nc" id="L290">            logger.warning(&quot;getNotifBufferSize&quot;,</span>
                           &quot;Can't use System property &quot;+
                           BUFFER_SIZE_PROPERTY+ &quot;: &quot; + e);
<span class="nc" id="L293">              logger.debug(&quot;getNotifBufferSize&quot;, e);</span>
<span class="nc" id="L294">        }</span>

<span class="nc" id="L296">        int queueSize = defaultQueueSize;</span>

        try {
<span class="nc bnc" id="L299" title="All 2 branches missed.">            if (env.containsKey(BUFFER_SIZE_PROPERTY)) {</span>
<span class="nc" id="L300">                queueSize = (int)EnvHelp.getIntegerAttribute(env,BUFFER_SIZE_PROPERTY,</span>
                                            defaultQueueSize,0,
                                            Integer.MAX_VALUE);
            } else { // try the old one
<span class="nc" id="L304">                queueSize = (int)EnvHelp.getIntegerAttribute(env,oldP,</span>
                                            defaultQueueSize,0,
                                            Integer.MAX_VALUE);
            }
<span class="nc" id="L308">        } catch (RuntimeException e) {</span>
<span class="nc" id="L309">            logger.warning(&quot;getNotifBufferSize&quot;,</span>
                           &quot;Can't determine queuesize (using default): &quot;+
                           e);
<span class="nc" id="L312">            logger.debug(&quot;getNotifBufferSize&quot;, e);</span>
<span class="nc" id="L313">        }</span>

<span class="nc" id="L315">        return queueSize;</span>
    }

    /**
     * &lt;p&gt;Name of the attribute that specifies the maximum number of
     * notifications that a client will fetch from its server.. The
     * value associated with this attribute should be an
     * &lt;code&gt;Integer&lt;/code&gt; object.  The default value is 1000.&lt;/p&gt;
     */
    public static final String MAX_FETCH_NOTIFS =
        &quot;jmx.remote.x.notification.fetch.max&quot;;

    /**
     * Returns the maximum notification number which a client will
     * fetch every time.
     */
    public static int getMaxFetchNotifNumber(Map&lt;String, ?&gt; env) {
<span class="nc" id="L332">        return (int) getIntegerAttribute(env, MAX_FETCH_NOTIFS, 1000, 1,</span>
                                         Integer.MAX_VALUE);
    }

    /**
     * &lt;p&gt;Name of the attribute that specifies the timeout for a
     * client to fetch notifications from its server. The value
     * associated with this attribute should be a &lt;code&gt;Long&lt;/code&gt;
     * object.  The default value is 60000 milliseconds.&lt;/p&gt;
     */
    public static final String FETCH_TIMEOUT =
        &quot;jmx.remote.x.notification.fetch.timeout&quot;;

    /**
     * Returns the timeout for a client to fetch notifications.
     */
    public static long getFetchTimeout(Map&lt;String, ?&gt; env) {
<span class="nc" id="L349">        return getIntegerAttribute(env, FETCH_TIMEOUT, 60000L, 0,</span>
                Long.MAX_VALUE);
    }

    /**
     * &lt;p&gt;Name of the attribute that specifies an object that will check
     * accesses to add/removeNotificationListener and also attempts to
     * receive notifications.  The value associated with this attribute
     * should be a &lt;code&gt;NotificationAccessController&lt;/code&gt; object.
     * The default value is null.&lt;/p&gt;
     * This field is not public because of its com.sun dependency.
     */
    public static final String NOTIF_ACCESS_CONTROLLER =
            &quot;com.sun.jmx.remote.notification.access.controller&quot;;

    public static NotificationAccessController getNotificationAccessController(
            Map&lt;String, ?&gt; env) {
<span class="nc bnc" id="L366" title="All 2 branches missed.">        return (env == null) ? null :</span>
<span class="nc" id="L367">            (NotificationAccessController) env.get(NOTIF_ACCESS_CONTROLLER);</span>
    }

    /**
     * Get an integer-valued attribute with name &lt;code&gt;name&lt;/code&gt;
     * from &lt;code&gt;env&lt;/code&gt;.  If &lt;code&gt;env&lt;/code&gt; is null, or does
     * not contain an entry for &lt;code&gt;name&lt;/code&gt;, return
     * &lt;code&gt;defaultValue&lt;/code&gt;.  The value may be a Number, or it
     * may be a String that is parsable as a long.  It must be at
     * least &lt;code&gt;minValue&lt;/code&gt; and at most&lt;code&gt;maxValue&lt;/code&gt;.
     *
     * @throws IllegalArgumentException if &lt;code&gt;env&lt;/code&gt; contains
     * an entry for &lt;code&gt;name&lt;/code&gt; but it does not meet the
     * constraints above.
     */
    public static long getIntegerAttribute(Map&lt;String, ?&gt; env, String name,
                                           long defaultValue, long minValue,
                                           long maxValue) {
        final Object o;

<span class="nc bnc" id="L387" title="All 4 branches missed.">        if (env == null || (o = env.get(name)) == null)</span>
<span class="nc" id="L388">            return defaultValue;</span>

        final long result;

<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (o instanceof Number)</span>
<span class="nc" id="L393">            result = ((Number) o).longValue();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">        else if (o instanceof String) {</span>
<span class="nc" id="L395">            result = Long.parseLong((String) o);</span>
            /* May throw a NumberFormatException, which is an
               IllegalArgumentException.  */
        } else {
<span class="nc" id="L399">            final String msg =</span>
                &quot;Attribute &quot; + name + &quot; value must be Integer or String: &quot; + o;
<span class="nc" id="L401">            throw new IllegalArgumentException(msg);</span>
        }

<span class="nc bnc" id="L404" title="All 2 branches missed.">        if (result &lt; minValue) {</span>
<span class="nc" id="L405">            final String msg =</span>
                &quot;Attribute &quot; + name + &quot; value must be at least &quot; + minValue +
                &quot;: &quot; + result;
<span class="nc" id="L408">            throw new IllegalArgumentException(msg);</span>
        }

<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (result &gt; maxValue) {</span>
<span class="nc" id="L412">            final String msg =</span>
                &quot;Attribute &quot; + name + &quot; value must be at most &quot; + maxValue +
                &quot;: &quot; + result;
<span class="nc" id="L415">            throw new IllegalArgumentException(msg);</span>
        }

<span class="nc" id="L418">        return result;</span>
    }

    public static final String DEFAULT_ORB=&quot;java.naming.corba.orb&quot;;

    /* Check that all attributes have a key that is a String.
       Could make further checks, e.g. appropriate types for attributes.  */
    public static void checkAttributes(Map&lt;?, ?&gt; attributes) {
<span class="nc bnc" id="L426" title="All 2 branches missed.">        for (Object key : attributes.keySet()) {</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">            if (!(key instanceof String)) {</span>
<span class="nc" id="L428">                final String msg =</span>
                    &quot;Attributes contain key that is not a string: &quot; + key;
<span class="nc" id="L430">                throw new IllegalArgumentException(msg);</span>
            }
<span class="nc" id="L432">        }</span>
<span class="nc" id="L433">    }</span>

    /* Return a writable map containing only those attributes that are
       serializable, and that are not hidden by
       jmx.remote.x.hidden.attributes or the default list of hidden
       attributes.  */
    public static &lt;V&gt; Map&lt;String, V&gt; filterAttributes(Map&lt;String, V&gt; attributes) {
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (logger.traceOn()) {</span>
<span class="nc" id="L441">            logger.trace(&quot;filterAttributes&quot;, &quot;starts&quot;);</span>
        }

<span class="nc" id="L444">        SortedMap&lt;String, V&gt; map = new TreeMap&lt;String, V&gt;(attributes);</span>
<span class="nc" id="L445">        purgeUnserializable(map.values());</span>
<span class="nc" id="L446">        hideAttributes(map);</span>
<span class="nc" id="L447">        return map;</span>
    }

    /**
     * Remove from the given Collection any element that is not a
     * serializable object.
     */
    private static void purgeUnserializable(Collection&lt;?&gt; objects) {
<span class="nc" id="L455">        logger.trace(&quot;purgeUnserializable&quot;, &quot;starts&quot;);</span>
<span class="nc" id="L456">        ObjectOutputStream oos = null;</span>
<span class="nc" id="L457">        int i = 0;</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        for (Iterator&lt;?&gt; it = objects.iterator(); it.hasNext(); i++) {</span>
<span class="nc" id="L459">            Object v = it.next();</span>

<span class="nc bnc" id="L461" title="All 4 branches missed.">            if (v == null || v instanceof String) {</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                if (logger.traceOn()) {</span>
<span class="nc" id="L463">                    logger.trace(&quot;purgeUnserializable&quot;,</span>
                                 &quot;Value trivially serializable: &quot; + v);
                }
                continue;
            }

            try {
<span class="nc bnc" id="L470" title="All 2 branches missed.">                if (oos == null)</span>
<span class="nc" id="L471">                    oos = new ObjectOutputStream(new SinkOutputStream());</span>
<span class="nc" id="L472">                oos.writeObject(v);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                if (logger.traceOn()) {</span>
<span class="nc" id="L474">                    logger.trace(&quot;purgeUnserializable&quot;,</span>
                                 &quot;Value serializable: &quot; + v);
                }
<span class="nc" id="L477">            } catch (IOException e) {</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">                if (logger.traceOn()) {</span>
<span class="nc" id="L479">                    logger.trace(&quot;purgeUnserializable&quot;,</span>
                                 &quot;Value not serializable: &quot; + v + &quot;: &quot; +
                                 e);
                }
<span class="nc" id="L483">                it.remove();</span>
<span class="nc" id="L484">                oos = null; // ObjectOutputStream invalid after exception</span>
<span class="nc" id="L485">            }</span>
        }
<span class="nc" id="L487">    }</span>

    /**
     * The value of this attribute, if present, is a string specifying
     * what other attributes should not appear in
     * JMXConnectorServer.getAttributes().  It is a space-separated
     * list of attribute patterns, where each pattern is either an
     * attribute name, or an attribute prefix followed by a &quot;*&quot;
     * character.  The &quot;*&quot; has no special significance anywhere except
     * at the end of a pattern.  By default, this list is added to the
     * list defined by {@link #DEFAULT_HIDDEN_ATTRIBUTES} (which
     * uses the same format).  If the value of this attribute begins
     * with an &quot;=&quot;, then the remainder of the string defines the
     * complete list of attribute patterns.
     */
    public static final String HIDDEN_ATTRIBUTES =
        &quot;jmx.remote.x.hidden.attributes&quot;;

    /**
     * Default list of attributes not to show.
     * @see #HIDDEN_ATTRIBUTES
     */
    /* This list is copied directly from the spec, plus
       java.naming.security.*.  Most of the attributes here would have
       been eliminated from the map anyway because they are typically
       not serializable.  But just in case they are, we list them here
       to conform to the spec.  */
    public static final String DEFAULT_HIDDEN_ATTRIBUTES =
        &quot;java.naming.security.* &quot; +
        &quot;jmx.remote.authenticator &quot; +
        &quot;jmx.remote.context &quot; +
        &quot;jmx.remote.default.class.loader &quot; +
        &quot;jmx.remote.message.connection.server &quot; +
        &quot;jmx.remote.object.wrapping &quot; +
        &quot;jmx.remote.rmi.client.socket.factory &quot; +
        &quot;jmx.remote.rmi.server.socket.factory &quot; +
        &quot;jmx.remote.sasl.callback.handler &quot; +
        &quot;jmx.remote.tls.socket.factory &quot; +
        &quot;jmx.remote.x.access.file &quot; +
        &quot;jmx.remote.x.password.file &quot;;

<span class="nc" id="L528">    private static final SortedSet&lt;String&gt; defaultHiddenStrings =</span>
            new TreeSet&lt;String&gt;();
<span class="nc" id="L530">    private static final SortedSet&lt;String&gt; defaultHiddenPrefixes =</span>
            new TreeSet&lt;String&gt;();

    private static void hideAttributes(SortedMap&lt;String, ?&gt; map) {
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (map.isEmpty())</span>
<span class="nc" id="L535">            return;</span>

        final SortedSet&lt;String&gt; hiddenStrings;
        final SortedSet&lt;String&gt; hiddenPrefixes;

<span class="nc" id="L540">        String hide = (String) map.get(HIDDEN_ATTRIBUTES);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (hide != null) {</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (hide.startsWith(&quot;=&quot;))</span>
<span class="nc" id="L543">                hide = hide.substring(1);</span>
            else
<span class="nc" id="L545">                hide += &quot; &quot; + DEFAULT_HIDDEN_ATTRIBUTES;</span>
<span class="nc" id="L546">            hiddenStrings = new TreeSet&lt;String&gt;();</span>
<span class="nc" id="L547">            hiddenPrefixes = new TreeSet&lt;String&gt;();</span>
<span class="nc" id="L548">            parseHiddenAttributes(hide, hiddenStrings, hiddenPrefixes);</span>
        } else {
<span class="nc" id="L550">            hide = DEFAULT_HIDDEN_ATTRIBUTES;</span>
<span class="nc" id="L551">            synchronized (defaultHiddenStrings) {</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">                if (defaultHiddenStrings.isEmpty()) {</span>
<span class="nc" id="L553">                    parseHiddenAttributes(hide,</span>
                                          defaultHiddenStrings,
                                          defaultHiddenPrefixes);
                }
<span class="nc" id="L557">                hiddenStrings = defaultHiddenStrings;</span>
<span class="nc" id="L558">                hiddenPrefixes = defaultHiddenPrefixes;</span>
<span class="nc" id="L559">            }</span>
        }

        /* Construct a string that is greater than any key in the map.
           Setting a string-to-match or a prefix-to-match to this string
           guarantees that we will never call next() on the corresponding
           iterator.  */
<span class="nc" id="L566">        String sentinelKey = map.lastKey() + &quot;X&quot;;</span>
<span class="nc" id="L567">        Iterator&lt;String&gt; keyIterator = map.keySet().iterator();</span>
<span class="nc" id="L568">        Iterator&lt;String&gt; stringIterator = hiddenStrings.iterator();</span>
<span class="nc" id="L569">        Iterator&lt;String&gt; prefixIterator = hiddenPrefixes.iterator();</span>

        String nextString;
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (stringIterator.hasNext())</span>
<span class="nc" id="L573">            nextString = stringIterator.next();</span>
        else
<span class="nc" id="L575">            nextString = sentinelKey;</span>
        String nextPrefix;
<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (prefixIterator.hasNext())</span>
<span class="nc" id="L578">            nextPrefix = prefixIterator.next();</span>
        else
<span class="nc" id="L580">            nextPrefix = sentinelKey;</span>

        /* Read each key in sorted order and, if it matches a string
           or prefix, remove it. */
    keys:
<span class="nc bnc" id="L585" title="All 2 branches missed.">        while (keyIterator.hasNext()) {</span>
<span class="nc" id="L586">            String key = keyIterator.next();</span>

            /* Continue through string-match values until we find one
               that is either greater than the current key, or equal
               to it.  In the latter case, remove the key.  */
<span class="nc" id="L591">            int cmp = +1;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">            while ((cmp = nextString.compareTo(key)) &lt; 0) {</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                if (stringIterator.hasNext())</span>
<span class="nc" id="L594">                    nextString = stringIterator.next();</span>
                else
<span class="nc" id="L596">                    nextString = sentinelKey;</span>
            }
<span class="nc bnc" id="L598" title="All 2 branches missed.">            if (cmp == 0) {</span>
<span class="nc" id="L599">                keyIterator.remove();</span>
<span class="nc" id="L600">                continue keys;</span>
            }

            /* Continue through the prefix values until we find one
               that is either greater than the current key, or a
               prefix of it.  In the latter case, remove the key.  */
<span class="nc bnc" id="L606" title="All 2 branches missed.">            while (nextPrefix.compareTo(key) &lt;= 0) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">                if (key.startsWith(nextPrefix)) {</span>
<span class="nc" id="L608">                    keyIterator.remove();</span>
<span class="nc" id="L609">                    continue keys;</span>
                }
<span class="nc bnc" id="L611" title="All 2 branches missed.">                if (prefixIterator.hasNext())</span>
<span class="nc" id="L612">                    nextPrefix = prefixIterator.next();</span>
                else
<span class="nc" id="L614">                    nextPrefix = sentinelKey;</span>
            }
<span class="nc" id="L616">        }</span>
<span class="nc" id="L617">    }</span>

    private static void parseHiddenAttributes(String hide,
                                              SortedSet&lt;String&gt; hiddenStrings,
                                              SortedSet&lt;String&gt; hiddenPrefixes) {
<span class="nc" id="L622">        final StringTokenizer tok = new StringTokenizer(hide);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">        while (tok.hasMoreTokens()) {</span>
<span class="nc" id="L624">            String s = tok.nextToken();</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (s.endsWith(&quot;*&quot;))</span>
<span class="nc" id="L626">                hiddenPrefixes.add(s.substring(0, s.length() - 1));</span>
            else
<span class="nc" id="L628">                hiddenStrings.add(s);</span>
<span class="nc" id="L629">        }</span>
<span class="nc" id="L630">    }</span>

    /**
     * &lt;p&gt;Name of the attribute that specifies the timeout to keep a
     * server side connection after answering last client request.
     * The default value is 120000 milliseconds.&lt;/p&gt;
     */
    public static final String SERVER_CONNECTION_TIMEOUT =
        &quot;jmx.remote.x.server.connection.timeout&quot;;

    /**
     * Returns the server side connection timeout.
     */
    public static long getServerConnectionTimeout(Map&lt;String, ?&gt; env) {
<span class="nc" id="L644">        return getIntegerAttribute(env, SERVER_CONNECTION_TIMEOUT, 120000L,</span>
                                   0, Long.MAX_VALUE);
    }

    /**
     * &lt;p&gt;Name of the attribute that specifies the period in
     * millisecond for a client to check its connection.  The default
     * value is 60000 milliseconds.&lt;/p&gt;
     */
    public static final String CLIENT_CONNECTION_CHECK_PERIOD =
        &quot;jmx.remote.x.client.connection.check.period&quot;;

    /**
     * Returns the client connection check period.
     */
    public static long getConnectionCheckPeriod(Map&lt;String, ?&gt; env) {
<span class="nc" id="L660">        return getIntegerAttribute(env, CLIENT_CONNECTION_CHECK_PERIOD, 60000L,</span>
                                   0, Long.MAX_VALUE);
    }

    /**
     * Computes a boolean value from a string value retrieved from a
     * property in the given map.
     *
     * @param stringBoolean the string value that must be converted
     * into a boolean value.
     *
     * @return
     *   &lt;ul&gt;
     *   &lt;li&gt;{@code false} if {@code stringBoolean} is {@code null}&lt;/li&gt;
     *   &lt;li&gt;{@code false} if
     *       {@code stringBoolean.equalsIgnoreCase(&quot;false&quot;)}
     *       is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@code true} if
     *       {@code stringBoolean.equalsIgnoreCase(&quot;true&quot;)}
     *       is {@code true}&lt;/li&gt;
     *   &lt;/ul&gt;
     *
     * @throws IllegalArgumentException if
     * {@code ((String)env.get(prop)).equalsIgnoreCase(&quot;false&quot;)} and
     * {@code ((String)env.get(prop)).equalsIgnoreCase(&quot;true&quot;)} are
     * {@code false}.
     */
    public static boolean computeBooleanFromString(String stringBoolean) {
        // returns a default value of 'false' if no property is found...
<span class="nc" id="L689">        return computeBooleanFromString(stringBoolean,false);</span>
    }

    /**
     * Computes a boolean value from a string value retrieved from a
     * property in the given map.
     *
     * @param stringBoolean the string value that must be converted
     * into a boolean value.
     * @param defaultValue a default value to return in case no property
     *        was defined.
     *
     * @return
     *   &lt;ul&gt;
     *   &lt;li&gt;{@code defaultValue} if {@code stringBoolean}
     *   is {@code null}&lt;/li&gt;
     *   &lt;li&gt;{@code false} if
     *       {@code stringBoolean.equalsIgnoreCase(&quot;false&quot;)}
     *       is {@code true}&lt;/li&gt;
     *   &lt;li&gt;{@code true} if
     *       {@code stringBoolean.equalsIgnoreCase(&quot;true&quot;)}
     *       is {@code true}&lt;/li&gt;
     *   &lt;/ul&gt;
     *
     * @throws IllegalArgumentException if
     * {@code ((String)env.get(prop)).equalsIgnoreCase(&quot;false&quot;)} and
     * {@code ((String)env.get(prop)).equalsIgnoreCase(&quot;true&quot;)} are
     * {@code false}.
     */
    public static boolean computeBooleanFromString( String stringBoolean, boolean defaultValue) {
<span class="nc bnc" id="L719" title="All 2 branches missed.">        if (stringBoolean == null)</span>
<span class="nc" id="L720">            return defaultValue;</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">        else if (stringBoolean.equalsIgnoreCase(&quot;true&quot;))</span>
<span class="nc" id="L722">            return true;</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">        else if (stringBoolean.equalsIgnoreCase(&quot;false&quot;))</span>
<span class="nc" id="L724">            return false;</span>
        else
<span class="nc" id="L726">            throw new IllegalArgumentException(</span>
                &quot;Property value must be \&quot;true\&quot; or \&quot;false\&quot; instead of \&quot;&quot; +
                stringBoolean + &quot;\&quot;&quot;);
    }

    /**
     * Converts a map into a valid hash table, i.e.
     * it removes all the 'null' values from the map.
     */
    public static &lt;K, V&gt; Hashtable&lt;K, V&gt; mapToHashtable(Map&lt;K, V&gt; map) {
<span class="nc" id="L736">        HashMap&lt;K, V&gt; m = new HashMap&lt;K, V&gt;(map);</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (m.containsKey(null)) m.remove(null);</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        for (Iterator&lt;?&gt; i = m.values().iterator(); i.hasNext(); )</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">            if (i.next() == null) i.remove();</span>
<span class="nc" id="L740">        return new Hashtable&lt;K, V&gt;(m);</span>
    }

    /**
     * &lt;p&gt;Name of the attribute that specifies whether a connector server
     * should not prevent the VM from exiting
     */
    public static final String JMX_SERVER_DAEMON = &quot;jmx.remote.x.daemon&quot;;

    /**
     * Returns true if {@value SERVER_DAEMON} is specified in the {@code env}
     * as a key and its value is a String and it is equal to true ignoring case.
     *
     * @param env
     * @return
     */
    public static boolean isServerDaemon(Map&lt;String, ?&gt; env) {
<span class="nc bnc" id="L757" title="All 2 branches missed.">        return (env != null) &amp;&amp;</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">                (&quot;true&quot;.equalsIgnoreCase((String)env.get(JMX_SERVER_DAEMON)));</span>
    }

<span class="nc" id="L761">    private static final class SinkOutputStream extends OutputStream {</span>
<span class="nc" id="L762">        public void write(byte[] b, int off, int len) {}</span>
<span class="nc" id="L763">        public void write(int b) {}</span>
    }

<span class="nc" id="L766">    private static final ClassLogger logger =</span>
        new ClassLogger(&quot;javax.management.remote.misc&quot;, &quot;EnvHelp&quot;);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>