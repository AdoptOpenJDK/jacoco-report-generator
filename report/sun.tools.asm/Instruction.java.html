<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Instruction.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.tools.asm</a> &gt; <span class="el_source">Instruction.java</span></div><h1>Instruction.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.tools.asm;

import sun.tools.java.*;
import java.util.Enumeration;
import java.io.IOException;
import java.io.DataOutputStream;

/**
 * An Java instruction
 *
 * WARNING: The contents of this source file are not part of any
 * supported API.  Code that depends on them does so at its own risk:
 * they are subject to change or removal without notice.
 */
public
class Instruction implements Constants {
    long where;
    int pc;
    int opc;
    Object value;
    Instruction next;
//JCOV
    boolean flagCondInverted;        /* if true, the condition  is reversed
                                   relatively of source code */
<span class="nc" id="L50">    boolean flagNoCovered = false; /* if true, the command will</span>
                                   ignored for coverage */


    /**
     * Constructor
     */
<span class="nc" id="L57">    public Instruction(long where, int opc, Object value, boolean flagCondInverted) {</span>
<span class="nc" id="L58">        this.where = where;</span>
<span class="nc" id="L59">        this.opc = opc;</span>
<span class="nc" id="L60">        this.value = value;</span>
<span class="nc" id="L61">        this.flagCondInverted = flagCondInverted;</span>
<span class="nc" id="L62">    }</span>

    /**
     * Constructor
     */
<span class="nc" id="L67">    public Instruction(boolean flagNoCovered, long where, int opc, Object value) {</span>
<span class="nc" id="L68">        this.where = where;</span>
<span class="nc" id="L69">        this.opc = opc;</span>
<span class="nc" id="L70">        this.value = value;</span>
<span class="nc" id="L71">        this.flagNoCovered = flagNoCovered;</span>
<span class="nc" id="L72">    }</span>

    /**
     * Constructor
     */
<span class="nc" id="L77">    public Instruction(long where, int opc, boolean flagNoCovered) {</span>
<span class="nc" id="L78">        this.where = where;</span>
<span class="nc" id="L79">        this.opc = opc;</span>
<span class="nc" id="L80">        this.flagNoCovered = flagNoCovered;</span>
<span class="nc" id="L81">    }</span>
//end JCOV

    /**
     * Constructor
     */
<span class="nc" id="L87">    public Instruction(long where, int opc, Object value) {</span>
<span class="nc" id="L88">        this.where = where;</span>
<span class="nc" id="L89">        this.opc = opc;</span>
<span class="nc" id="L90">        this.value = value;</span>
<span class="nc" id="L91">    }</span>

    /**
     * When deciding between a lookupswitch and a tableswitch, this
     * value is used in determining how much size increase is
     * acceptable.
     */
    public static final double SWITCHRATIO;

    static {
        // Set SWITCHRATIO from the property javac.switchratio
        // if it exists and is reasonable.  Otherwise, set
        // SWITCHRATIO to 1.5, meaning that we will accept a 1.5x
        // blowup (for the instruction) to use a tableswitch instead
        // of a lookupswitch.
<span class="nc" id="L106">        double ratio = 1.5;</span>
<span class="nc" id="L107">        String valStr = System.getProperty(&quot;javac.switchratio&quot;);</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (valStr != null) {</span>
            try {
<span class="nc" id="L110">                double temp = Double.valueOf(valStr).doubleValue();</span>
<span class="nc bnc" id="L111" title="All 4 branches missed.">                if (!(Double.isNaN(temp) || temp &lt; 0.0)) {</span>
<span class="nc" id="L112">                    ratio = temp;</span>
                }
<span class="nc" id="L114">            } catch (NumberFormatException ee) {}</span>
        }
<span class="nc" id="L116">        SWITCHRATIO = ratio;</span>
<span class="nc" id="L117">    }</span>

    /**
     * Accessor
     */
    public int getOpcode() {
<span class="nc" id="L123">        return pc;</span>
     }

    public Object getValue() {
<span class="nc" id="L127">        return value;</span>
     }

    public void setValue(Object value) {
<span class="nc" id="L131">        this.value = value;</span>
<span class="nc" id="L132">     }</span>


    /**
     * Optimize
     */
    void optimize(Environment env) {
<span class="nc bnc" id="L139" title="All 6 branches missed.">        switch (opc) {</span>
          case opc_istore: case opc_lstore: case opc_fstore:
          case opc_dstore: case opc_astore:
            // Don't keep the LocalVariable info around, unless we
            // are actually going to generate a local variable table.
<span class="nc bnc" id="L144" title="All 4 branches missed.">            if ((value instanceof LocalVariable) &amp;&amp; !env.debug_vars()) {</span>
<span class="nc" id="L145">                value = new Integer(((LocalVariable)value).slot);</span>
            }
            break;

          case opc_goto: {
<span class="nc" id="L150">            Label lbl = (Label)value;</span>
<span class="nc" id="L151">            value = lbl = lbl.getDestination();</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (lbl == next) {</span>
                // goto to the next instruction, obsolete
<span class="nc" id="L154">                opc = opc_dead;</span>
<span class="nc" id="L155">                break;</span>
            }

            // We optimize
            //
            //          goto Tag
            //          ...
            //    Tag:
            //          return
            //
            // except when we're generating debuggable code.  When
            // we're generating debuggable code, we leave it alone,
            // in order to provide better stepping behavior.  Consider
            // a method the end of which looks like this:
            //
            //          ...
            //          break;
            //      }   // end of loop
            //  }   // end of method
            //
            // If we optimize the goto away, we'll be left with a
            // single instruction (return) and the need to ascribe that
            // instruction to two source lines (the break statement and
            // the method's right curly).  Can't get there from here.
            // Depending on which line-number ascription we choose, the
            // stepping user will step directly from the break statement
            // back into the caller of the method (case 1) or from the
            // statement that precedes the break statement to the method's
            // right curly (case 2).  Similarly, he'll be able to set a
            // breakpoint on the break statement (case 1) or the method's
            // right curly (case 2), but not on both.  Neither case 1 nor
            // case 2 is desirable.  .We want him to see both the break
            // statement and the method's right curly when stepping,
            // and we want him to be able to set a breakpoint on either or
            // both.  So we suppress the optimization when generating
            // debuggable code.
            // (Above notes from brucek@eng in JDK1.0.2, copied here
            //  by kelly.ohair@eng for JDK1.1)
            //
            // With the changes to allow -O and -g at the same time,
            // I've changed the condition to be whether optimization is
            // on instead of the debugging flag being off.
            //     - david.stoutamire@eng for 1.2

<span class="nc bnc" id="L199" title="All 4 branches missed.">            if (lbl.next != null &amp;&amp; env.opt()) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">                switch (lbl.next.opc) {</span>
                  case opc_return:  case opc_ireturn: case opc_lreturn:
                  case opc_freturn: case opc_dreturn: case opc_areturn:
                    // goto to return
<span class="nc" id="L204">                    opc = lbl.next.opc;</span>
<span class="nc" id="L205">                    value = lbl.next.value;</span>
<span class="nc" id="L206">                    break;</span>
                }
            }
            break;
          }

          case opc_ifeq:   case opc_ifne:   case opc_ifgt:
          case opc_ifge:   case opc_iflt:   case opc_ifle:
          case opc_ifnull: case opc_ifnonnull:
<span class="nc" id="L215">            value = ((Label)value).getDestination();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if (value == next) {</span>
                // branch to next instruction, obsolete
<span class="nc" id="L218">                opc = opc_pop;</span>
<span class="nc" id="L219">                break;</span>
            }
<span class="nc bnc" id="L221" title="All 4 branches missed.">            if ((next.opc == opc_goto) &amp;&amp; (value == next.next)) {</span>
                // Conditional branch over goto, invert
                // Note that you can't invert all conditions, condition
                // results for float/double compares are not invertable.
<span class="nc bnc" id="L225" title="All 9 branches missed.">                switch (opc) {</span>
<span class="nc" id="L226">                  case opc_ifeq:      opc = opc_ifne; break;</span>
<span class="nc" id="L227">                  case opc_ifne:      opc = opc_ifeq; break;</span>
<span class="nc" id="L228">                  case opc_iflt:      opc = opc_ifge; break;</span>
<span class="nc" id="L229">                  case opc_ifle:      opc = opc_ifgt; break;</span>
<span class="nc" id="L230">                  case opc_ifgt:      opc = opc_ifle; break;</span>
<span class="nc" id="L231">                  case opc_ifge:      opc = opc_iflt; break;</span>
<span class="nc" id="L232">                  case opc_ifnull:    opc = opc_ifnonnull; break;</span>
<span class="nc" id="L233">                  case opc_ifnonnull: opc = opc_ifnull; break;</span>
                }
//JCOV
<span class="nc bnc" id="L236" title="All 2 branches missed.">                flagCondInverted = !flagCondInverted;</span>
//end JCOV
<span class="nc" id="L238">                value = next.value;</span>
<span class="nc" id="L239">                next.opc = opc_dead;</span>
            }
            break;

          case opc_if_acmpeq:   case opc_if_acmpne:
          case opc_if_icmpeq:   case opc_if_icmpne:
          case opc_if_icmpgt:   case opc_if_icmpge:
          case opc_if_icmplt:   case opc_if_icmple:
<span class="nc" id="L247">            value = ((Label)value).getDestination();</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">            if (value == next) {</span>
                // branch to next instruction, obsolete
<span class="nc" id="L250">                opc = opc_pop2;</span>
<span class="nc" id="L251">                break;</span>
            }
<span class="nc bnc" id="L253" title="All 4 branches missed.">            if ((next.opc == opc_goto) &amp;&amp; (value == next.next)) {</span>
                // Conditional branch over goto, invert
<span class="nc bnc" id="L255" title="All 9 branches missed.">                switch (opc) {</span>
<span class="nc" id="L256">                  case opc_if_acmpeq: opc = opc_if_acmpne; break;</span>
<span class="nc" id="L257">                  case opc_if_acmpne: opc = opc_if_acmpeq; break;</span>
<span class="nc" id="L258">                  case opc_if_icmpeq: opc = opc_if_icmpne; break;</span>
<span class="nc" id="L259">                  case opc_if_icmpne: opc = opc_if_icmpeq; break;</span>
<span class="nc" id="L260">                  case opc_if_icmpgt: opc = opc_if_icmple; break;</span>
<span class="nc" id="L261">                  case opc_if_icmpge: opc = opc_if_icmplt; break;</span>
<span class="nc" id="L262">                  case opc_if_icmplt: opc = opc_if_icmpge; break;</span>
<span class="nc" id="L263">                  case opc_if_icmple: opc = opc_if_icmpgt; break;</span>
                }
//JCOV
<span class="nc bnc" id="L266" title="All 2 branches missed.">                flagCondInverted = !flagCondInverted;</span>
//end JCOV
<span class="nc" id="L268">                value = next.value;</span>
<span class="nc" id="L269">                next.opc = opc_dead;</span>
            }
            break;

          case opc_tableswitch:
          case opc_lookupswitch: {
<span class="nc" id="L275">            SwitchData sw = (SwitchData)value;</span>
<span class="nc" id="L276">            sw.defaultLabel = sw.defaultLabel.getDestination();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            for (Enumeration&lt;Integer&gt; e = sw.tab.keys() ; e.hasMoreElements() ; ) {</span>
<span class="nc" id="L278">                Integer k = e.nextElement();</span>
<span class="nc" id="L279">                Label lbl = sw.tab.get(k);</span>
<span class="nc" id="L280">                sw.tab.put(k, lbl.getDestination());</span>
<span class="nc" id="L281">            }</span>

            // Compute the approximate sizes of a tableswitch and a
            // lookupswitch.  Decide which one we want to generate.

<span class="nc" id="L286">            long range = (long)sw.maxValue - (long)sw.minValue + 1;</span>
<span class="nc" id="L287">            long entries = sw.tab.size();</span>

<span class="nc" id="L289">            long tableSize = 4 + range;</span>
<span class="nc" id="L290">            long lookupSize = 3 + 2 * entries;</span>

<span class="nc bnc" id="L292" title="All 2 branches missed.">            if (tableSize &lt;= lookupSize * SWITCHRATIO) {</span>
<span class="nc" id="L293">                opc = opc_tableswitch;</span>
            } else {
<span class="nc" id="L295">                opc = opc_lookupswitch;</span>
            }
<span class="nc" id="L297">            break;</span>
          }

        }
<span class="nc" id="L301">    }</span>

    /**
     * Collect constants into the constant table
     */
    void collect(ConstantPool tab) {
<span class="nc bnc" id="L307" title="All 9 branches missed.">        switch (opc) {</span>
          case opc_istore:      case opc_lstore:        case opc_fstore:
          case opc_dstore:      case opc_astore:
<span class="nc bnc" id="L310" title="All 2 branches missed.">            if (value instanceof LocalVariable) {</span>
<span class="nc" id="L311">                MemberDefinition field = ((LocalVariable)value).field;</span>
<span class="nc" id="L312">                tab.put(field.getName().toString());</span>
<span class="nc" id="L313">                tab.put(field.getType().getTypeSignature());</span>
            }
<span class="nc" id="L315">            return;</span>

          case opc_new:                 case opc_putfield:
          case opc_putstatic:           case opc_getfield:
          case opc_getstatic:           case opc_invokevirtual:
          case opc_invokespecial:       case opc_invokestatic:
          case opc_invokeinterface:     case opc_instanceof:
          case opc_checkcast:
<span class="nc" id="L323">            tab.put(value);</span>
<span class="nc" id="L324">            return;</span>

          case opc_anewarray:
<span class="nc" id="L327">            tab.put(value);</span>
<span class="nc" id="L328">            return;</span>

          case opc_multianewarray:
<span class="nc" id="L331">            tab.put(((ArrayData)value).type);</span>
<span class="nc" id="L332">            return;</span>

          case opc_ldc:
          case opc_ldc_w:
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (value instanceof Integer) {</span>
<span class="nc" id="L337">                int v = ((Integer)value).intValue();</span>
<span class="nc bnc" id="L338" title="All 4 branches missed.">                if ((v &gt;= -1) &amp;&amp; (v &lt;= 5)) {</span>
<span class="nc" id="L339">                    opc = opc_iconst_0 + v;</span>
<span class="nc" id="L340">                    return;</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">                } else if ((v &gt;= -(1 &lt;&lt; 7)) &amp;&amp; (v &lt; (1 &lt;&lt; 7))) {</span>
<span class="nc" id="L342">                    opc = opc_bipush;</span>
<span class="nc" id="L343">                    return;</span>
<span class="nc bnc" id="L344" title="All 4 branches missed.">                } else if ((v &gt;= -(1 &lt;&lt; 15)) &amp;&amp; (v &lt; (1 &lt;&lt; 15))) {</span>
<span class="nc" id="L345">                    opc = opc_sipush;</span>
<span class="nc" id="L346">                    return;</span>
                }
<span class="nc bnc" id="L348" title="All 2 branches missed.">            } else if (value instanceof Float) {</span>
<span class="nc" id="L349">                float v = ((Float)value).floatValue();</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                if (v == 0) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                    if (Float.floatToIntBits(v) == 0) {</span>
<span class="nc" id="L352">                        opc = opc_fconst_0;</span>
<span class="nc" id="L353">                        return;</span>
                    }
<span class="nc bnc" id="L355" title="All 2 branches missed.">                } else if (v == 1) {</span>
<span class="nc" id="L356">                    opc = opc_fconst_1;</span>
<span class="nc" id="L357">                    return;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">                } else if (v == 2) {</span>
<span class="nc" id="L359">                    opc = opc_fconst_2;</span>
<span class="nc" id="L360">                    return;</span>
                }
            }
<span class="nc" id="L363">            tab.put(value);</span>
<span class="nc" id="L364">            return;</span>

          case opc_ldc2_w:
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (value instanceof Long) {</span>
<span class="nc" id="L368">                long v = ((Long)value).longValue();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">                if (v == 0) {</span>
<span class="nc" id="L370">                    opc = opc_lconst_0;</span>
<span class="nc" id="L371">                    return;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                } else if (v == 1) {</span>
<span class="nc" id="L373">                    opc = opc_lconst_1;</span>
<span class="nc" id="L374">                    return;</span>
                }
<span class="nc bnc" id="L376" title="All 2 branches missed.">            } else if (value instanceof Double) {</span>
<span class="nc" id="L377">                double v = ((Double)value).doubleValue();</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">                if (v == 0) {</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">                    if (Double.doubleToLongBits(v) == 0) {</span>
<span class="nc" id="L380">                        opc = opc_dconst_0;</span>
<span class="nc" id="L381">                        return;</span>
                    }
<span class="nc bnc" id="L383" title="All 2 branches missed.">                } else if (v == 1) {</span>
<span class="nc" id="L384">                    opc = opc_dconst_1;</span>
<span class="nc" id="L385">                    return;</span>
                }
            }
<span class="nc" id="L388">            tab.put(value);</span>
<span class="nc" id="L389">            return;</span>

          case opc_try:
<span class="nc bnc" id="L392" title="All 2 branches missed.">            for (Enumeration&lt;CatchData&gt; e = ((TryData)value).catches.elements() ; e.hasMoreElements() ;) {</span>
<span class="nc" id="L393">                CatchData cd = e.nextElement();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                if (cd.getType() != null) {</span>
<span class="nc" id="L395">                    tab.put(cd.getType());</span>
                }
<span class="nc" id="L397">            }</span>
<span class="nc" id="L398">            return;</span>

          case opc_nop:
<span class="nc bnc" id="L401" title="All 4 branches missed.">            if ((value != null) &amp;&amp; (value instanceof ClassDeclaration))</span>
<span class="nc" id="L402">                tab.put(value);</span>
<span class="nc" id="L403">                return;</span>
        }
<span class="nc" id="L405">    }</span>

    /**
     * Balance the stack
     */
    int balance() {
<span class="nc bnc" id="L411" title="All 15 branches missed.">        switch (opc) {</span>
          case opc_dead:        case opc_label:         case opc_iinc:
          case opc_arraylength: case opc_laload:        case opc_daload:
          case opc_nop:         case opc_ineg:          case opc_fneg:
          case opc_lneg:        case opc_dneg:          case opc_i2f:
          case opc_f2i:         case opc_l2d:           case opc_d2l:
          case opc_i2b:         case opc_i2c:           case opc_i2s:
          case opc_jsr:         case opc_goto:          case opc_jsr_w:
          case opc_goto_w:      case opc_return:        case opc_ret:
          case opc_instanceof:  case opc_checkcast:     case opc_newarray:
          case opc_anewarray:   case opc_try:           case opc_swap:
<span class="nc" id="L422">            return 0;</span>

          case opc_ldc:         case opc_ldc_w:         case opc_bipush:
          case opc_sipush:      case opc_aconst_null:   case opc_iconst_m1:
          case opc_iconst_0:    case opc_iconst_1:      case opc_iconst_2:
          case opc_iconst_3:    case opc_iconst_4:      case opc_iconst_5:
          case opc_fconst_0:    case opc_fconst_1:      case opc_fconst_2:
          case opc_iload:       case opc_fload:         case opc_aload:
          case opc_dup:         case opc_dup_x1:        case opc_dup_x2:
          case opc_i2l:         case opc_i2d:           case opc_f2l:
          case opc_f2d:         case opc_new:
<span class="nc" id="L433">            return 1;</span>

          case opc_lload:       case opc_dload:         case opc_dup2:
          case opc_dup2_x1:     case opc_dup2_x2:       case opc_ldc2_w:
          case opc_lconst_0:    case opc_lconst_1:      case opc_dconst_0:
          case opc_dconst_1:
<span class="nc" id="L439">            return 2;</span>

          case opc_istore:      case opc_fstore:        case opc_astore:
          case opc_iaload:      case opc_faload:        case opc_aaload:
          case opc_baload:      case opc_caload:        case opc_saload:
          case opc_pop:         case opc_iadd:          case opc_fadd:
          case opc_isub:        case opc_fsub:          case opc_imul:
          case opc_fmul:        case opc_idiv:          case opc_fdiv:
          case opc_irem:        case opc_frem:          case opc_ishl:
          case opc_ishr:        case opc_iushr:         case opc_lshl:
          case opc_lshr:        case opc_lushr:         case opc_iand:
          case opc_ior:         case opc_ixor:          case opc_l2i:
          case opc_l2f:         case opc_d2i:           case opc_d2f:
          case opc_ifeq:        case opc_ifne:          case opc_iflt:
          case opc_ifle:        case opc_ifgt:          case opc_ifge:
          case opc_ifnull:      case opc_ifnonnull:     case opc_fcmpl:
          case opc_fcmpg:       case opc_ireturn:       case opc_freturn:
          case opc_areturn:     case opc_tableswitch:   case opc_lookupswitch:
          case opc_athrow:      case opc_monitorenter:  case opc_monitorexit:
<span class="nc" id="L458">            return -1;</span>

          case opc_lstore:      case opc_dstore:        case opc_pop2:
          case opc_ladd:        case opc_dadd:          case opc_lsub:
          case opc_dsub:        case opc_lmul:          case opc_dmul:
          case opc_ldiv:        case opc_ddiv:          case opc_lrem:
          case opc_drem:        case opc_land:          case opc_lor:
          case opc_lxor:        case opc_if_acmpeq:     case opc_if_acmpne:
          case opc_if_icmpeq:   case opc_if_icmpne:     case opc_if_icmplt:
          case opc_if_icmple:   case opc_if_icmpgt:     case opc_if_icmpge:
          case opc_lreturn:     case opc_dreturn:
<span class="nc" id="L469">            return -2;</span>

          case opc_iastore:     case opc_fastore:       case opc_aastore:
          case opc_bastore:     case opc_castore:       case opc_sastore:
          case opc_lcmp:        case opc_dcmpl:         case opc_dcmpg:
<span class="nc" id="L474">            return -3;</span>

          case opc_lastore:     case opc_dastore:
<span class="nc" id="L477">            return -4;</span>

          case opc_multianewarray:
<span class="nc" id="L480">            return 1 - ((ArrayData)value).nargs;</span>

          case opc_getfield:
<span class="nc" id="L483">            return ((MemberDefinition)value).getType().stackSize() - 1;</span>

          case opc_putfield:
<span class="nc" id="L486">            return -1 - ((MemberDefinition)value).getType().stackSize();</span>

          case opc_getstatic:
<span class="nc" id="L489">            return ((MemberDefinition)value).getType().stackSize();</span>

          case opc_putstatic:
<span class="nc" id="L492">            return -((MemberDefinition)value).getType().stackSize();</span>

          case opc_invokevirtual:
          case opc_invokespecial:
          case opc_invokeinterface:
<span class="nc" id="L497">            return ((MemberDefinition)value).getType().getReturnType().stackSize() -</span>
<span class="nc" id="L498">                   (((MemberDefinition)value).getType().stackSize() + 1);</span>

          case opc_invokestatic:
<span class="nc" id="L501">            return ((MemberDefinition)value).getType().getReturnType().stackSize() -</span>
<span class="nc" id="L502">                   (((MemberDefinition)value).getType().stackSize());</span>
        }
<span class="nc" id="L504">        throw new CompilerError(&quot;invalid opcode: &quot; + toString());</span>
    }

    /**
     * Return the size of the instruction
     */
    int size(ConstantPool tab) {
<span class="nc bnc" id="L511" title="All 15 branches missed.">        switch (opc) {</span>
          case opc_try:         case opc_label:         case opc_dead:
<span class="nc" id="L513">            return 0;</span>

          case opc_bipush:      case opc_newarray:
<span class="nc" id="L516">            return 2;</span>

          case opc_sipush:      case opc_goto:          case opc_jsr:
          case opc_ifeq:        case opc_ifne:          case opc_ifgt:
          case opc_ifge:        case opc_iflt:          case opc_ifle:
          case opc_ifnull:      case opc_ifnonnull:     case opc_if_acmpeq:
          case opc_if_acmpne:   case opc_if_icmpeq:     case opc_if_icmpne:
          case opc_if_icmpgt:   case opc_if_icmpge:     case opc_if_icmplt:
          case opc_if_icmple:
<span class="nc" id="L525">            return 3;</span>

          case opc_ldc:
          case opc_ldc_w:
<span class="nc bnc" id="L529" title="All 2 branches missed.">            if (tab.index(value) &lt; 256) {</span>
<span class="nc" id="L530">                opc = opc_ldc;</span>
<span class="nc" id="L531">                return 2;</span>
            } else {
<span class="nc" id="L533">                opc = opc_ldc_w;</span>
<span class="nc" id="L534">                return 3;</span>
            }

          case opc_iload:       case opc_lload:         case opc_fload:
          case opc_dload:       case opc_aload: {
<span class="nc" id="L539">            int v = ((Number)value).intValue();</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            if (v &lt; 4) {</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">                if (v &lt; 0) {</span>
<span class="nc" id="L542">                    throw new CompilerError(&quot;invalid slot: &quot; + toString()</span>
                        + &quot;\nThis error possibly resulted from poorly constructed class paths.&quot;);
                }
<span class="nc" id="L545">                opc = opc_iload_0 + (opc - opc_iload) * 4 + v;</span>
<span class="nc" id="L546">                return 1;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">            } else if (v &lt;= 255) {</span>
<span class="nc" id="L548">                return 2;</span>
            } else {
<span class="nc" id="L550">                opc += 256;     // indicate wide variant</span>
<span class="nc" id="L551">                return 4;</span>
            }
          }

           case opc_iinc: {
<span class="nc" id="L556">               int register = ((int[])value)[0];</span>
<span class="nc" id="L557">               int increment = ((int[])value)[1];</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">               if (register &lt; 0) {</span>
<span class="nc" id="L559">                   throw new CompilerError(&quot;invalid slot: &quot; + toString());</span>
               }
<span class="nc bnc" id="L561" title="All 4 branches missed.">               if (register &lt;= 255 &amp;&amp; (((byte)increment) == increment)) {</span>
<span class="nc" id="L562">                   return 3;</span>
               } else {
<span class="nc" id="L564">                   opc += 256;          // indicate wide variant</span>
<span class="nc" id="L565">                   return 6;</span>
               }
           }

          case opc_istore:      case opc_lstore:        case opc_fstore:
          case opc_dstore:      case opc_astore: {
<span class="nc bnc" id="L571" title="All 2 branches missed.">            int v = (value instanceof Number) ?</span>
<span class="nc" id="L572">                ((Number)value).intValue() : ((LocalVariable)value).slot;</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">            if (v &lt; 4) {</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">                if (v &lt; 0) {</span>
<span class="nc" id="L575">                    throw new CompilerError(&quot;invalid slot: &quot; + toString());</span>
                }
<span class="nc" id="L577">                opc = opc_istore_0 + (opc - opc_istore) * 4 + v;</span>
<span class="nc" id="L578">                return 1;</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">            } else if (v &lt;= 255) {</span>
<span class="nc" id="L580">                return 2;</span>
            } else {
<span class="nc" id="L582">                opc += 256;     // indicate wide variant</span>
<span class="nc" id="L583">                return 4;</span>
            }
          }

          case opc_ret: {
<span class="nc" id="L588">              int v = ((Number)value).intValue();</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">              if (v &lt;= 255) {</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">                  if (v &lt; 0) {</span>
<span class="nc" id="L591">                      throw new CompilerError(&quot;invalid slot: &quot; + toString());</span>
                  }
<span class="nc" id="L593">                  return 2;</span>
              } else {
<span class="nc" id="L595">                  opc += 256;   // indicate wide variant</span>
<span class="nc" id="L596">                  return 4;</span>
              }
          }

          case opc_ldc2_w:              case opc_new:
          case opc_putstatic:           case opc_getstatic:
          case opc_putfield:            case opc_getfield:
          case opc_invokevirtual:       case opc_invokespecial:
          case opc_invokestatic:        case opc_instanceof:
          case opc_checkcast:           case opc_anewarray:
<span class="nc" id="L606">            return 3;</span>

          case opc_multianewarray:
<span class="nc" id="L609">            return 4;</span>

          case opc_invokeinterface:
          case opc_goto_w:
          case opc_jsr_w:
<span class="nc" id="L614">            return 5;</span>

          case opc_tableswitch: {
<span class="nc" id="L617">            SwitchData sw = (SwitchData)value;</span>
<span class="nc" id="L618">            int n = 1;</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            for(; ((pc + n) % 4) != 0 ; n++);</span>
<span class="nc" id="L620">            return n + 16 + (sw.maxValue - sw.minValue) * 4;</span>
          }

          case opc_lookupswitch: {
<span class="nc" id="L624">            SwitchData sw = (SwitchData)value;</span>
<span class="nc" id="L625">            int n = 1;</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">            for(; ((pc + n) % 4) != 0 ; n++);</span>
<span class="nc" id="L627">            return n + 8 + sw.tab.size() * 8;</span>
          }

          case opc_nop:
<span class="nc bnc" id="L631" title="All 4 branches missed.">            if ((value != null) &amp;&amp; !(value instanceof Integer))</span>
<span class="nc" id="L632">                return 2;</span>
            else
<span class="nc" id="L634">                return 1;</span>
        }

        // most opcodes are only 1 byte long
<span class="nc" id="L638">        return 1;</span>
    }

    /**
     * Generate code
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    void write(DataOutputStream out, ConstantPool tab) throws IOException {
<span class="nc bnc" id="L646" title="All 19 branches missed.">        switch (opc) {</span>
          case opc_try:         case opc_label:         case opc_dead:
<span class="nc" id="L648">            break;</span>

          case opc_bipush:      case opc_newarray:
          case opc_iload:       case opc_lload:         case opc_fload:
          case opc_dload:       case opc_aload:         case opc_ret:
<span class="nc" id="L653">            out.writeByte(opc);</span>
<span class="nc" id="L654">            out.writeByte(((Number)value).intValue());</span>
<span class="nc" id="L655">            break;</span>

          case opc_iload + 256:         case opc_lload + 256:
          case opc_fload + 256:         case opc_dload + 256:
          case opc_aload + 256:         case opc_ret   + 256:
<span class="nc" id="L660">            out.writeByte(opc_wide);</span>
<span class="nc" id="L661">            out.writeByte(opc - 256);</span>
<span class="nc" id="L662">            out.writeShort(((Number)value).intValue());</span>
<span class="nc" id="L663">            break;</span>

          case opc_istore:      case opc_lstore:        case opc_fstore:
          case opc_dstore:      case opc_astore:
<span class="nc" id="L667">            out.writeByte(opc);</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">            out.writeByte((value instanceof Number) ?</span>
<span class="nc" id="L669">                          ((Number)value).intValue() : ((LocalVariable)value).slot);</span>
<span class="nc" id="L670">            break;</span>

          case opc_istore + 256:        case opc_lstore + 256:
          case opc_fstore + 256:        case opc_dstore + 256:
          case opc_astore + 256:
<span class="nc" id="L675">            out.writeByte(opc_wide);</span>
<span class="nc" id="L676">            out.writeByte(opc - 256);</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">            out.writeShort((value instanceof Number) ?</span>
<span class="nc" id="L678">                      ((Number)value).intValue() : ((LocalVariable)value).slot);</span>
<span class="nc" id="L679">            break;</span>

          case opc_sipush:
<span class="nc" id="L682">            out.writeByte(opc);</span>
<span class="nc" id="L683">            out.writeShort(((Number)value).intValue());</span>
<span class="nc" id="L684">            break;</span>

          case opc_ldc:
<span class="nc" id="L687">            out.writeByte(opc);</span>
<span class="nc" id="L688">            out.writeByte(tab.index(value));</span>
<span class="nc" id="L689">            break;</span>

          case opc_ldc_w:               case opc_ldc2_w:
          case opc_new:                 case opc_putstatic:
          case opc_getstatic:           case opc_putfield:
          case opc_getfield:            case opc_invokevirtual:
          case opc_invokespecial:       case opc_invokestatic:
          case opc_instanceof:          case opc_checkcast:
<span class="nc" id="L697">            out.writeByte(opc);</span>
<span class="nc" id="L698">            out.writeShort(tab.index(value));</span>
<span class="nc" id="L699">            break;</span>

          case opc_iinc:
<span class="nc" id="L702">            out.writeByte(opc);</span>
<span class="nc" id="L703">            out.writeByte(((int[])value)[0]); // register</span>
<span class="nc" id="L704">            out.writeByte(((int[])value)[1]); // increment</span>
<span class="nc" id="L705">            break;</span>

          case opc_iinc + 256:
<span class="nc" id="L708">            out.writeByte(opc_wide);</span>
<span class="nc" id="L709">            out.writeByte(opc - 256);</span>
<span class="nc" id="L710">            out.writeShort(((int[])value)[0]); // register</span>
<span class="nc" id="L711">            out.writeShort(((int[])value)[1]); // increment</span>
<span class="nc" id="L712">            break;</span>

          case opc_anewarray:
<span class="nc" id="L715">            out.writeByte(opc);</span>
<span class="nc" id="L716">            out.writeShort(tab.index(value));</span>
<span class="nc" id="L717">            break;</span>

          case opc_multianewarray:
<span class="nc" id="L720">            out.writeByte(opc);</span>
<span class="nc" id="L721">            out.writeShort(tab.index(((ArrayData)value).type));</span>
<span class="nc" id="L722">            out.writeByte(((ArrayData)value).nargs);</span>
<span class="nc" id="L723">            break;</span>

          case opc_invokeinterface:
<span class="nc" id="L726">            out.writeByte(opc);</span>
<span class="nc" id="L727">            out.writeShort(tab.index(value));</span>
<span class="nc" id="L728">            out.writeByte(((MemberDefinition)value).getType().stackSize() + 1);</span>
<span class="nc" id="L729">            out.writeByte(0);</span>
<span class="nc" id="L730">            break;</span>

          case opc_goto:        case opc_jsr:           case opc_ifeq:
          case opc_ifne:        case opc_ifgt:          case opc_ifge:
          case opc_iflt:        case opc_ifle:          case opc_ifnull:
          case opc_ifnonnull:   case opc_if_acmpeq:     case opc_if_acmpne:
          case opc_if_icmpeq:   case opc_if_icmpne:     case opc_if_icmpgt:
          case opc_if_icmpge:   case opc_if_icmplt:     case opc_if_icmple:
<span class="nc" id="L738">            out.writeByte(opc);</span>
<span class="nc" id="L739">            out.writeShort(((Instruction)value).pc - pc);</span>
<span class="nc" id="L740">            break;</span>

          case opc_goto_w:
          case opc_jsr_w:
<span class="nc" id="L744">            out.writeByte(opc);</span>
<span class="nc" id="L745">            out.writeLong(((Instruction)value).pc - pc);</span>
<span class="nc" id="L746">            break;</span>

          case opc_tableswitch: {
<span class="nc" id="L749">            SwitchData sw = (SwitchData)value;</span>
<span class="nc" id="L750">            out.writeByte(opc);</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">            for(int n = 1 ; ((pc + n) % 4) != 0 ; n++) {</span>
<span class="nc" id="L752">                out.writeByte(0);</span>
            }
<span class="nc" id="L754">            out.writeInt(sw.defaultLabel.pc - pc);</span>
<span class="nc" id="L755">            out.writeInt(sw.minValue);</span>
<span class="nc" id="L756">            out.writeInt(sw.maxValue);</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">            for (int n = sw.minValue ; n &lt;= sw.maxValue ; n++) {</span>
<span class="nc" id="L758">                Label lbl = sw.get(n);</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">                int target_pc = (lbl != null) ? lbl.pc : sw.defaultLabel.pc;</span>
<span class="nc" id="L760">                out.writeInt(target_pc - pc);</span>
            }
<span class="nc" id="L762">            break;</span>
          }

          case opc_lookupswitch: {
<span class="nc" id="L766">            SwitchData sw = (SwitchData)value;</span>
<span class="nc" id="L767">            out.writeByte(opc);</span>
<span class="nc" id="L768">            int n = pc + 1;</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">            for(; (n % 4) != 0 ; n++) {</span>
<span class="nc" id="L770">                out.writeByte(0);</span>
            }
<span class="nc" id="L772">            out.writeInt(sw.defaultLabel.pc - pc);</span>
<span class="nc" id="L773">            out.writeInt(sw.tab.size());</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">            for (Enumeration&lt;Integer&gt; e = sw.sortedKeys(); e.hasMoreElements() ; ) {</span>
<span class="nc" id="L775">                Integer v = e.nextElement();</span>
<span class="nc" id="L776">                out.writeInt(v.intValue());</span>
<span class="nc" id="L777">                out.writeInt(sw.get(v).pc - pc);</span>
<span class="nc" id="L778">            }</span>
<span class="nc" id="L779">            break;</span>
          }

          case opc_nop:
<span class="nc bnc" id="L783" title="All 2 branches missed.">            if (value != null) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">                if (value instanceof Integer)</span>
<span class="nc" id="L785">                    out.writeByte(((Integer)value).intValue());</span>
                else
<span class="nc" id="L787">                    out.writeShort(tab.index(value));</span>
<span class="nc" id="L788">                return;</span>
            }
            // fall through

          default:
<span class="nc" id="L793">            out.writeByte(opc);</span>
            break;
        }
<span class="nc" id="L796">    }</span>

    /**
     * toString
     */
    public String toString() {
<span class="nc" id="L802">        String prefix = (where &gt;&gt; WHEREOFFSETBITS) + &quot;:\t&quot;;</span>
<span class="nc bnc" id="L803" title="All 4 branches missed.">        switch (opc) {</span>
          case opc_try:
<span class="nc" id="L805">            return prefix + &quot;try &quot; + ((TryData)value).getEndLabel().hashCode();</span>

          case opc_dead:
<span class="nc" id="L808">            return prefix + &quot;dead&quot;;</span>

          case opc_iinc: {
<span class="nc" id="L811">            int register = ((int[])value)[0];</span>
<span class="nc" id="L812">            int increment = ((int[])value)[1];</span>
<span class="nc" id="L813">            return prefix + opcNames[opc] + &quot; &quot; + register + &quot;, &quot; + increment;</span>
          }

          default:
<span class="nc bnc" id="L817" title="All 2 branches missed.">            if (value != null) {</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                if (value instanceof Label) {</span>
<span class="nc" id="L819">                    return prefix + opcNames[opc] + &quot; &quot; + value.toString();</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">                } else if (value instanceof Instruction) {</span>
<span class="nc" id="L821">                    return prefix + opcNames[opc] + &quot; &quot; + value.hashCode();</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">                } else if (value instanceof String) {</span>
<span class="nc" id="L823">                    return prefix + opcNames[opc] + &quot; \&quot;&quot; + value + &quot;\&quot;&quot;;</span>
                } else {
<span class="nc" id="L825">                    return prefix + opcNames[opc] + &quot; &quot; + value;</span>
                }
            } else {
<span class="nc" id="L828">              return prefix + opcNames[opc];</span>
            }
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>