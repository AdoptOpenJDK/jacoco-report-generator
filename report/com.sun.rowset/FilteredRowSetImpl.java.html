<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>FilteredRowSetImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.rowset</a> &gt; <span class="el_source">FilteredRowSetImpl.java</span></div><h1>FilteredRowSetImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.rowset;

import java.io.*;
import java.util.*;
import java.sql.*;
import javax.sql.*;
import java.math.*;

import javax.sql.rowset.*;
import javax.sql.rowset.spi.*;
import javax.sql.rowset.serial.*;
import com.sun.rowset.providers.*;
import com.sun.rowset.internal.*;

/**
 * The standard implementation of the &lt;code&gt;FilteredRowSet&lt;/code&gt; interface. See the interface
 * definition for full behavior and implementation requirements.
 *
 * @see javax.sql.rowset.Predicate
 * @author Jonathan Bruce, Amit Handa
 */

public class FilteredRowSetImpl extends WebRowSetImpl implements Serializable, Cloneable, FilteredRowSet {

    private Predicate p;

<span class="nc" id="L52">    private boolean onInsertRow = false;</span>


    /**
     * Construct a &lt;code&gt;FilteredRowSet&lt;/code&gt;
     */
    public FilteredRowSetImpl() throws SQLException {
<span class="nc" id="L59">        super();</span>
<span class="nc" id="L60">    }</span>

    /**
     * Construct a &lt;code&gt;FilteredRowSet&lt;/code&gt; with a specified synchronization
     * provider.
     *
     * @param env a Hashtable containing a desired synchconizatation provider
     * name-value pair.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public FilteredRowSetImpl(Hashtable env) throws SQLException {
<span class="nc" id="L71">        super(env);</span>
<span class="nc" id="L72">    }</span>

    /**
     * Apply the predicate for this filter
     *
     * @param p an implementation of the predicate interface
     */
    public void setFilter(Predicate p) throws SQLException {
<span class="nc" id="L80">        this.p = p;</span>
<span class="nc" id="L81">    }</span>

    /**
     * Retrieve the filter active for this &lt;code&gt;FilteredRowSet&lt;/code&gt;
     *
     * @return a &lt;code&gt;Predicate&lt;/code&gt; object instance
     */
    public Predicate getFilter() {
<span class="nc" id="L89">        return this.p;</span>
    }

    /**
     * Over-riding &lt;code&gt;internalNext()&lt;/code&gt; implementation. This method
     * applies the filter on the &lt;code&gt;RowSet&lt;/code&gt; each time the cursor is advanced or
     * manipulated. It moves the cursor to the next row according to the set
     * predicate and returns &lt;code&gt;true&lt;/code&gt; if the cursor is still within the rowset or
     * &lt;code&gt;false&lt;/code&gt; if the cursor position is over the last row
     *
     * @return true if over the valid row in the rowset; false if over the last
     * row
     */
    protected boolean internalNext() throws SQLException {
        // CachedRowSetImpl.next() internally calls
        // this(crs).internalNext() NOTE: this holds crs object
        // So when frs.next() is called,
        // internally this(frs).internalNext() will be called
        // which will be nothing but this method.
        // because this holds frs object

        // keep on doing super.internalNext()
        // rather than doing it once.


         // p.evaluate will help us in changing the cursor
         // and checking the next value by returning true or false.
         // to fit the filter

         // So while() loop will have a &quot;random combination&quot; of
         // true and false returned depending upon the records
         // are in or out of filter.
         // We need to traverse from present cursorPos till end,
         // whether true or false and check each row for &quot;filter&quot;
         // &quot;till we get a &quot;true&quot;


<span class="nc" id="L126">         boolean bool = false;</span>

<span class="nc bnc" id="L128" title="All 2 branches missed.">         for(int rows=this.getRow(); rows&lt;=this.size();rows++) {</span>
<span class="nc" id="L129">             bool = super.internalNext();</span>

<span class="nc bnc" id="L131" title="All 4 branches missed.">             if( !bool || p == null) {</span>
<span class="nc" id="L132">               return bool;</span>
             }
<span class="nc bnc" id="L134" title="All 2 branches missed.">             if(p.evaluate(this)){</span>
<span class="nc" id="L135">                   break;</span>
             }

         }

<span class="nc" id="L140">       return bool;</span>
    }


    /**
     * Over-riding &lt;code&gt;internalPrevious()&lt;/code&gt; implementation. This method
     * applies the filter on the &lt;code&gt;RowSet&lt;/code&gt; each time the cursor is moved backward or
     * manipulated. It moves the cursor to the previous row according to the set
     * predicate and returns &lt;code&gt;true&lt;/code&gt; if the cursor is still within the rowset or
     * &lt;code&gt;false&lt;/code&gt; if the cursor position is over the last row
     *
     * @return true if over the valid row in the rowset; false if over the last
     * row
     */
    protected boolean internalPrevious() throws SQLException {
<span class="nc" id="L155">         boolean bool = false;</span>
         // with previous move backwards,
         // i.e. from any record towards first record

<span class="nc bnc" id="L159" title="All 2 branches missed.">         for(int rows=this.getRow(); rows&gt;0;rows--) {</span>

<span class="nc" id="L161">             bool = super.internalPrevious();</span>

<span class="nc bnc" id="L163" title="All 2 branches missed.">             if( p == null) {</span>
<span class="nc" id="L164">               return bool;</span>
             }

<span class="nc bnc" id="L167" title="All 2 branches missed.">             if(p.evaluate(this)){</span>
<span class="nc" id="L168">                   break;</span>
             }

         }

<span class="nc" id="L173">       return bool;</span>
    }


    /**
     * Over-riding &lt;code&gt;internalFirst()&lt;/code&gt; implementation. This method
     * applies the filter on the &lt;code&gt;RowSet&lt;/code&gt; each time the cursor is moved to first
     * row. It moves the cursor to the first row according to the set
     * predicate and returns &lt;code&gt;true&lt;/code&gt; if the cursor is still within the rowset or
     * &lt;code&gt;false&lt;/code&gt; if the cursor position is over the last row
     *
     * @return true if over the valid row in the rowset; false if over the last
     * row
     */
    protected boolean internalFirst() throws SQLException {

        // from first till present cursor position(go forward),
        // find the actual first which matches the filter.

<span class="nc" id="L192">         boolean bool = super.internalFirst();</span>

<span class="nc bnc" id="L194" title="All 2 branches missed.">         if( p == null) {</span>
<span class="nc" id="L195">               return bool;</span>
             }

<span class="nc bnc" id="L198" title="All 2 branches missed.">         while(bool) {</span>

<span class="nc bnc" id="L200" title="All 2 branches missed.">             if(p.evaluate(this)){</span>
<span class="nc" id="L201">                   break;</span>
             }
<span class="nc" id="L203">        bool = super.internalNext();</span>
        }
<span class="nc" id="L205">     return bool;</span>
    }


    /**
     * Over-riding &lt;code&gt;internalLast()&lt;/code&gt; implementation. This method
     * applies the filter on the &lt;code&gt;RowSet&lt;/code&gt; each time the cursor is moved to
     * last row. It moves the cursor to the last row according to the set
     * predicate and returns &lt;code&gt;true&lt;/code&gt; if the cursor is still within the rowset or
     * &lt;code&gt;false&lt;/code&gt; if the cursor position is over the last row
     *
     * @return true if over the valid row in the rowset; false if over the last
     * row
     */
    protected boolean internalLast() throws SQLException {
        // from last to the present cursor position(go backward),
        // find the actual last which matches the filter.

<span class="nc" id="L223">         boolean bool = super.internalLast();</span>

<span class="nc bnc" id="L225" title="All 2 branches missed.">         if( p == null) {</span>
<span class="nc" id="L226">               return bool;</span>
             }

<span class="nc bnc" id="L229" title="All 2 branches missed.">         while(bool) {</span>

<span class="nc bnc" id="L231" title="All 2 branches missed.">             if(p.evaluate(this)){</span>
<span class="nc" id="L232">                   break;</span>
             }

<span class="nc" id="L235">        bool = super.internalPrevious();</span>

        }
<span class="nc" id="L238">     return bool;</span>

   } // end internalLast()
   /**
     * Moves the cursor the specified number of rows from the current
     * position, with a positive number moving it forward and a
     * negative number moving it backward.
     * &lt;P&gt;
     * If the number is positive, the cursor moves the specified number of
     * rows toward the end of the rowset, starting at the current row.
     * For example, the following command, in which
     * &lt;code&gt;crs&lt;/code&gt; is a &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with 100 rows,
     * moves the cursor forward four rows from the current row.  If the
     * current row is 50, the cursor would move to row 54.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.relative(4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     * &lt;P&gt;
     * If the number is negative, the cursor moves back toward the beginning
     * the specified number of rows, starting at the current row.
     * For example, calling the method
     * &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row,
     * &lt;code&gt;absolute(-2)&lt;/code&gt; moves it on the next-to-last row, and so on.
     * If the &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt; has five rows,
     * the following command moves the cursor to the fourth-to-last row, which
     * in the case of a  rowset with five rows, is also the second row
     * from the beginning.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.absolute(-4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     *
     * If the number specified is larger than the number of rows, the cursor
     * will move to the position after the last row. If the number specified
     * would move the cursor one or more rows before the first row, the cursor
     * moves to the position before the first row. In both cases, this method
     * throws an &lt;code&gt;SQLException&lt;/code&gt;.
     * &lt;P&gt;
     * Note: Calling &lt;code&gt;absolute(1)&lt;/code&gt; is the same as calling the
     * method &lt;code&gt;first()&lt;/code&gt;.  Calling &lt;code&gt;absolute(-1)&lt;/code&gt; is the
     * same as calling &lt;code&gt;last()&lt;/code&gt;.  Calling &lt;code&gt;relative(0)&lt;/code&gt;
     * is valid, but it does not change the cursor position.
     *
     * @param rows an &lt;code&gt;int&lt;/code&gt; indicating the number of rows to move
     *             the cursor, starting at the current row; a positive number
     *             moves the cursor forward; a negative number moves the cursor
     *             backward; must not move the cursor past the valid
     *             rows
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a row in this
     *         &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object; &lt;code&gt;false&lt;/code&gt;
     *         otherwise
     * @throws SQLException if the rowset is type &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
   public boolean relative(int rows) throws SQLException {

      boolean retval;
<span class="nc" id="L297">      boolean bool = false;</span>
<span class="nc" id="L298">      boolean boolval = false;</span>

<span class="nc bnc" id="L300" title="All 2 branches missed.">      if(getType() == ResultSet.TYPE_FORWARD_ONLY) {</span>
<span class="nc" id="L301">         throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.relative&quot;).toString());</span>
      }

<span class="nc bnc" id="L304" title="All 2 branches missed.">      if( rows &gt; 0 ) {</span>

<span class="nc" id="L306">         int i = 0;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">         while( i &lt; (rows)) {</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">            if( isAfterLast() ) {</span>
<span class="nc" id="L310">               return false;</span>
            }
<span class="nc" id="L312">            bool = internalNext();</span>
<span class="nc" id="L313">            i++;</span>
         }

<span class="nc" id="L316">         retval = bool;</span>
<span class="nc" id="L317">      } else {</span>
<span class="nc" id="L318">         int j = rows;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">         while( (j) &lt; 0 ) {</span>

<span class="nc bnc" id="L321" title="All 2 branches missed.">           if( isBeforeFirst() ) {</span>
<span class="nc" id="L322">              return false;</span>
           }
<span class="nc" id="L324">           boolval = internalPrevious();</span>
<span class="nc" id="L325">           j++;</span>
         }
<span class="nc" id="L327">         retval = boolval;</span>
      }
<span class="nc bnc" id="L329" title="All 2 branches missed.">      if(rows != 0)</span>
<span class="nc" id="L330">          notifyCursorMoved();</span>
<span class="nc" id="L331">      return retval;</span>
   }

   /**
     * Moves this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object's cursor to the row number
     * specified.
     *
     * &lt;p&gt;If the number is positive, the cursor moves to an absolute row with
     * respect to the beginning of the rowset.  The first row is row 1, the second
     * is row 2, and so on.  For example, the following command, in which
     * &lt;code&gt;crs&lt;/code&gt; is a &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object, moves the cursor
     * to the fourth row, starting from the beginning of the rowset.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.absolute(4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     * &lt;P&gt;
     * If the number is negative, the cursor moves to an absolute row position
     * with respect to the end of the rowset.  For example, calling
     * &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row,
     * &lt;code&gt;absolute(-2)&lt;/code&gt; moves it on the next-to-last row, and so on.
     * If the &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt; has five rows,
     * the following command moves the cursor to the fourth-to-last row, which
     * in the case of a  rowset with five rows, is also the second row, counting
     * from the beginning.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.absolute(-4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     *
     * If the number specified is larger than the number of rows, the cursor
     * will move to the position after the last row. If the number specified
     * would move the cursor one or more rows before the first row, the cursor
     * moves to the position before the first row.
     * &lt;P&gt;
     * Note: Calling &lt;code&gt;absolute(1)&lt;/code&gt; is the same as calling the
     * method &lt;code&gt;first()&lt;/code&gt;.  Calling &lt;code&gt;absolute(-1)&lt;/code&gt; is the
     * same as calling &lt;code&gt;last()&lt;/code&gt;.
     *
     * @param rows a positive number to indicate the row, starting row numbering from
     *        the first row, which is &lt;code&gt;1&lt;/code&gt;; a negative number to indicate
     *        the row, starting row numbering from the last row, which is
     *        &lt;code&gt;-1&lt;/code&gt;; it must not be &lt;code&gt;0&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on the rowset; &lt;code&gt;false&lt;/code&gt;
     *         otherwise
     * @throws SQLException if the given cursor position is &lt;code&gt;0&lt;/code&gt; or the
     *            type of this rowset is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean absolute(int rows) throws SQLException {

      boolean retval;
<span class="nc" id="L384">      boolean bool = false;</span>

<span class="nc bnc" id="L386" title="All 4 branches missed.">      if(rows == 0 || getType() == ResultSet.TYPE_FORWARD_ONLY) {</span>
<span class="nc" id="L387">         throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.absolute&quot;).toString());</span>
      }

<span class="nc bnc" id="L390" title="All 2 branches missed.">      if (rows &gt; 0) {</span>
<span class="nc" id="L391">         bool = internalFirst();</span>

<span class="nc" id="L393">         int i = 0;</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">         while(i &lt; (rows-1)) {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">            if( isAfterLast() ) {</span>
<span class="nc" id="L396">               return false;</span>
            }
<span class="nc" id="L398">            bool = internalNext();</span>
<span class="nc" id="L399">            i++;</span>
         }
<span class="nc" id="L401">         retval = bool;</span>
<span class="nc" id="L402">      } else {</span>
<span class="nc" id="L403">         bool = internalLast();</span>

<span class="nc" id="L405">         int j = rows;</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">         while((j+1) &lt; 0 ) {</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">            if( isBeforeFirst() ) {</span>
<span class="nc" id="L408">               return false;</span>
            }
<span class="nc" id="L410">            bool = internalPrevious();</span>
<span class="nc" id="L411">            j++;</span>
         }
<span class="nc" id="L413">         retval = bool;</span>
      }
<span class="nc" id="L415">      notifyCursorMoved();</span>
<span class="nc" id="L416">      return retval;</span>
   }

   /**
     * Moves the cursor for this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object
     * to the insert row.  The current row in the rowset is remembered
     * while the cursor is on the insert row.
     * &lt;P&gt;
     * The insert row is a special row associated with an updatable
     * rowset.  It is essentially a buffer where a new row may
     * be constructed by calling the appropriate &lt;code&gt;updateXXX&lt;/code&gt;
     * methods to assign a value to each column in the row.  A complete
     * row must be constructed; that is, every column that is not nullable
     * must be assigned a value.  In order for the new row to become part
     * of this rowset, the method &lt;code&gt;insertRow&lt;/code&gt; must be called
     * before the cursor is moved back to the rowset.
     * &lt;P&gt;
     * Only certain methods may be invoked while the cursor is on the insert
     * row; many methods throw an exception if they are called while the
     * cursor is there.  In addition to the &lt;code&gt;updateXXX&lt;/code&gt;
     * and &lt;code&gt;insertRow&lt;/code&gt; methods, only the &lt;code&gt;getXXX&lt;/code&gt; methods
     * may be called when the cursor is on the insert row.  A &lt;code&gt;getXXX&lt;/code&gt;
     * method should be called on a column only after an &lt;code&gt;updateXXX&lt;/code&gt;
     * method has been called on that column; otherwise, the value returned is
     * undetermined.
     *
     * @throws SQLException if this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void moveToInsertRow() throws SQLException {

<span class="nc" id="L447">      onInsertRow = true;</span>
<span class="nc" id="L448">      super.moveToInsertRow();</span>
<span class="nc" id="L449">   }</span>

   /**
     * This is explanation for the overriding of the updateXXX functions.
     * These functions have been overriden to ensure that only correct
     * values that pass the criteria for the filter are actaully inserted.
     * The evaluation of whether a particular value passes the criteria
     * of the filter is done using the evaluate function in the Predicate
     * interface.
     *
     * The checking can will done in the evaluate function which is implemented
     * in the class that implements the Predicate interface. So the checking
     * can vary from one implementation to another.
     *
     * Some additional points here on the following:
     * 1. updateBytes()     - since the evaluate function takes Object as parameter
     *                        a String is constructed from the byte array and would
     *                        passed to the evaluate function.
     * 2. updateXXXstream() - here it would suffice to pass the stream handle
     *                        to the evaluate function and the implementation
     *                        of the evaluate function can do the comparision
     *                        based on the stream and also type of data.
     */


   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;int&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateInt(int columnIndex , int x) throws SQLException {

     boolean bool;

<span class="nc bnc" id="L501" title="All 2 branches missed.">     if(onInsertRow) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if(p != null) {</span>
<span class="nc" id="L503">           bool = p.evaluate(Integer.valueOf(x),columnIndex);</span>

<span class="nc bnc" id="L505" title="All 2 branches missed.">           if(!bool) {</span>
<span class="nc" id="L506">              throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
           }
        }
     }

<span class="nc" id="L511">     super.updateInt(columnIndex,x);</span>
<span class="nc" id="L512">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;int&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateInt(String columnName , int x) throws SQLException {

<span class="nc" id="L538">       this.updateInt(findColumn(columnName), x);</span>
<span class="nc" id="L539">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;boolean&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateBoolean(int columnIndex, boolean x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L568" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L570">            bool = p.evaluate(Boolean.valueOf(x) , columnIndex);</span>

<span class="nc bnc" id="L572" title="All 2 branches missed.">            if(!bool) {</span>
<span class="nc" id="L573">               throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
            }
         }
      }

<span class="nc" id="L578">      super.updateBoolean(columnIndex,x);</span>
<span class="nc" id="L579">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;boolean&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateBoolean(String columnName , boolean x) throws SQLException {

<span class="nc" id="L605">      this.updateBoolean(findColumn(columnName),x);</span>
<span class="nc" id="L606">   }</span>



    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateByte(int columnIndex , byte x) throws SQLException {
      boolean bool;

<span class="nc bnc" id="L636" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L638">            bool = p.evaluate(Byte.valueOf(x),columnIndex);</span>

<span class="nc bnc" id="L640" title="All 2 branches missed.">            if(!bool) {</span>
<span class="nc" id="L641">                throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
            }
          }
      }

<span class="nc" id="L646">      super.updateByte(columnIndex,x);</span>
<span class="nc" id="L647">   }</span>


   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateByte(String columnName , byte x) throws SQLException {

<span class="nc" id="L674">      this.updateByte(findColumn(columnName),x);</span>
<span class="nc" id="L675">   }</span>


   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;short&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateShort( int columnIndex , short x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L705" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L707">            bool = p.evaluate(Short.valueOf(x), columnIndex);</span>

<span class="nc bnc" id="L709" title="All 2 branches missed.">            if(!bool) {</span>
<span class="nc" id="L710">               throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
            }
          }
      }

<span class="nc" id="L715">      super.updateShort(columnIndex,x);</span>
<span class="nc" id="L716">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;short&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateShort( String columnName , short x) throws SQLException {

<span class="nc" id="L742">      this.updateShort(findColumn(columnName),x);</span>
<span class="nc" id="L743">   }</span>


   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;long&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateLong(int columnIndex , long x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L773" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L775">            bool = p.evaluate(Long.valueOf(x), columnIndex);</span>

<span class="nc bnc" id="L777" title="All 2 branches missed.">            if(!bool) {</span>
<span class="nc" id="L778">               throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
            }
          }
      }

<span class="nc" id="L783">      super.updateLong(columnIndex,x);</span>
<span class="nc" id="L784">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;long&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateLong( String columnName , long x) throws SQLException {

<span class="nc" id="L810">      this.updateLong(findColumn(columnName) , x);</span>
<span class="nc" id="L811">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;float&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateFloat(int columnIndex , float x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L840" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L842">            bool = p.evaluate(Float.valueOf(x), columnIndex);</span>

<span class="nc bnc" id="L844" title="All 2 branches missed.">            if(!bool) {</span>
<span class="nc" id="L845">               throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
            }
          }
      }

<span class="nc" id="L850">      super.updateFloat(columnIndex,x);</span>
<span class="nc" id="L851">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;float&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateFloat(String columnName , float x) throws SQLException {

<span class="nc" id="L877">      this.updateFloat(findColumn(columnName),x);</span>
<span class="nc" id="L878">   }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;double&lt;/code&gt; value.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateDouble(int columnIndex , double x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L907" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L908" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L909">            bool = p.evaluate(Double.valueOf(x) , columnIndex);</span>

<span class="nc bnc" id="L911" title="All 2 branches missed.">            if(!bool) {</span>
<span class="nc" id="L912">               throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
            }
          }
      }

<span class="nc" id="L917">      super.updateDouble(columnIndex,x);</span>
<span class="nc" id="L918">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;double&lt;/code&gt; value.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateDouble(String columnName , double x) throws SQLException {

<span class="nc" id="L944">      this.updateDouble(findColumn(columnName),x);</span>
<span class="nc" id="L945">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateBigDecimal(int columnIndex , BigDecimal x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L974" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L976">            bool = p.evaluate(x,columnIndex);</span>

<span class="nc bnc" id="L978" title="All 2 branches missed.">            if(!bool) {</span>
<span class="nc" id="L979">               throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
            }
          }
      }

<span class="nc" id="L984">      super.updateBigDecimal(columnIndex,x);</span>
<span class="nc" id="L985">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateBigDecimal(String columnName , BigDecimal x) throws SQLException {

<span class="nc" id="L1011">      this.updateBigDecimal(findColumn(columnName),x);</span>
<span class="nc" id="L1012">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;String&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to mark the row as updated.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called to insert the new row into this rowset and mark it
     * as inserted. Both of these methods must be called before the
     * cursor moves to another row.
     * &lt;P&gt;
     * The method &lt;code&gt;acceptChanges&lt;/code&gt; must be called if the
     * updated values are to be written back to the underlying database.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateString(int columnIndex , String x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L1044" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L1046">           bool = p.evaluate(x,columnIndex);</span>

<span class="nc bnc" id="L1048" title="All 2 branches missed.">           if(!bool) {</span>
<span class="nc" id="L1049">              throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
           }
         }
      }

<span class="nc" id="L1054">      super.updateString(columnIndex,x);</span>
<span class="nc" id="L1055">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;String&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateString(String columnName , String x) throws SQLException {

<span class="nc" id="L1081">      this.updateString(findColumn(columnName),x);</span>
<span class="nc" id="L1082">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; array.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateBytes(int columnIndex , byte []x) throws SQLException {

      boolean bool;
<span class="nc" id="L1110">      String val = &quot;&quot;;</span>

<span class="nc" id="L1112">      Byte [] obj_arr = new Byte[x.length];</span>

<span class="nc bnc" id="L1114" title="All 2 branches missed.">      for(int i = 0; i &lt; x.length; i++) {</span>
<span class="nc" id="L1115">         obj_arr[i] = Byte.valueOf(x[i]);</span>
<span class="nc" id="L1116">         val = val.concat(obj_arr[i].toString());</span>
     }


<span class="nc bnc" id="L1120" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L1122">             bool = p.evaluate(val,columnIndex);</span>

<span class="nc bnc" id="L1124" title="All 2 branches missed.">             if(!bool) {</span>
<span class="nc" id="L1125">                 throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
             }
         }
      }

<span class="nc" id="L1130">      super.updateBytes(columnIndex,x);</span>
<span class="nc" id="L1131">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; array.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateBytes(String columnName , byte []x) throws SQLException {

<span class="nc" id="L1157">      this.updateBytes(findColumn(columnName),x);</span>
<span class="nc" id="L1158">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Date&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the type of the designated column is not
     *            an SQL &lt;code&gt;DATE&lt;/code&gt; or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or
     *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateDate(int columnIndex , java.sql.Date x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L1188" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L1190">             bool = p.evaluate(x,columnIndex);</span>

<span class="nc bnc" id="L1192" title="All 2 branches missed.">             if(!bool) {</span>
<span class="nc" id="L1193">                 throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
             }
         }
      }

<span class="nc" id="L1198">      super.updateDate(columnIndex,x);</span>
<span class="nc" id="L1199">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Date&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the type
     *            of the designated column is not an SQL &lt;code&gt;DATE&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateDate(String columnName , java.sql.Date x) throws SQLException {

<span class="nc" id="L1227">      this.updateDate(findColumn(columnName),x);</span>
<span class="nc" id="L1228">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Time&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the type of the designated column is not
     *            an SQL &lt;code&gt;TIME&lt;/code&gt; or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or
     *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateTime(int columnIndex , Time x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L1258" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L1259" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L1260">             bool = p.evaluate(x, columnIndex);</span>

<span class="nc bnc" id="L1262" title="All 2 branches missed.">             if(!bool) {</span>
<span class="nc" id="L1263">                 throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
             }
         }
      }

<span class="nc" id="L1268">      super.updateTime(columnIndex,x);</span>
<span class="nc" id="L1269">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Time&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the type
     *            of the designated column is not an SQL &lt;code&gt;TIME&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateTime(String columnName , Time x) throws SQLException {

<span class="nc" id="L1297">      this.updateTime(findColumn(columnName),x);</span>
<span class="nc" id="L1298">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the type of the designated column is not
     *            an SQL &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;TIME&lt;/code&gt;, or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateTimestamp(int columnIndex , Timestamp x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L1329" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L1331">             bool = p.evaluate(x,columnIndex);</span>

<span class="nc bnc" id="L1333" title="All 2 branches missed.">             if(!bool) {</span>
<span class="nc" id="L1334">                 throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
             }
         }
      }

<span class="nc" id="L1339">      super.updateTimestamp(columnIndex,x);</span>
<span class="nc" id="L1340">   }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if the given column index is out of bounds or
     *            the cursor is not on one of this rowset's rows or its
     *            insert row
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the type
     *            of the designated column is not an SQL &lt;code&gt;DATE&lt;/code&gt;,
     *            &lt;code&gt;TIME&lt;/code&gt;, or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateTimestamp(String columnName , Timestamp x) throws SQLException {

<span class="nc" id="L1371">      this.updateTimestamp(findColumn(columnName),x);</span>
<span class="nc" id="L1372">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * ASCII stream value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @param length the number of one-byte ASCII characters in the stream
     * @throws SQLException if this method is invoked
     */
   public void updateAsciiStream(int columnIndex , java.io.InputStream x ,int length) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L1399" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L1401">             bool = p.evaluate(x,columnIndex);</span>

<span class="nc bnc" id="L1403" title="All 2 branches missed.">             if(!bool) {</span>
<span class="nc" id="L1404">                 throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
             }
         }
      }

<span class="nc" id="L1409">      super.updateAsciiStream(columnIndex,x,length);</span>
<span class="nc" id="L1410">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * ASCII stream value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @param length the number of one-byte ASCII characters in the stream
     */
   public void updateAsciiStream(String columnName , java.io.InputStream x , int length) throws SQLException {

<span class="nc" id="L1433">      this.updateAsciiStream(findColumn(columnName),x,length);</span>
<span class="nc" id="L1434">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.Reader&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value; must be a &lt;code&gt;java.io.Reader&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
     *          or &lt;code&gt;LONGVARCHAR&lt;/code&gt; data
     * @param length the length of the stream in characters
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the data in the stream is not a binary or
     *            character type, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateCharacterStream(int columnIndex , java.io.Reader x , int length) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L1468" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L1470">             bool = p.evaluate(x,columnIndex);</span>

<span class="nc bnc" id="L1472" title="All 2 branches missed.">             if(!bool) {</span>
<span class="nc" id="L1473">                 throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
             }
         }
      }

<span class="nc" id="L1478">      super.updateCharacterStream(columnIndex,x,length);</span>
<span class="nc" id="L1479">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.Reader&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param reader the new column value; must be a
     * &lt;code&gt;java.io.Reader&lt;/code&gt; containing &lt;code&gt;BINARY&lt;/code&gt;,
     * &lt;code&gt;VARBINARY&lt;/code&gt;, &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;,
     * &lt;code&gt;VARCHAR&lt;/code&gt;, or &lt;code&gt;LONGVARCHAR&lt;/code&gt; data
     * @param length the length of the stream in characters
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the data
     *            in the stream is not a binary or character type, or (4) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateCharacterStream(String columnName , java.io.Reader reader, int length) throws SQLException {
<span class="nc" id="L1509">      this.updateCharacterStream(findColumn(columnName), reader, length);</span>
<span class="nc" id="L1510">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value; must be a &lt;code&gt;java.io.InputStream&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;, or
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt; data
     * @param length the length of the stream in bytes
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the data in the stream is not binary, or
     *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateBinaryStream(int columnIndex , java.io.InputStream x , int length) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L1542" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L1544">             bool = p.evaluate(x,columnIndex);</span>

<span class="nc bnc" id="L1546" title="All 2 branches missed.">             if(!bool) {</span>
<span class="nc" id="L1547">                 throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
             }
         }
      }

<span class="nc" id="L1552">      super.updateBinaryStream(columnIndex,x,length);</span>
<span class="nc" id="L1553">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value; must be a &lt;code&gt;java.io.InputStream&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;, or
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt; data
     * @param length the length of the stream in bytes
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the data
     *            in the stream is not binary, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateBinaryStream(String columnName , java.io.InputStream x, int length) throws SQLException {

<span class="nc" id="L1583">      this.updateBinaryStream(findColumn(columnName),x,length);</span>
<span class="nc" id="L1584">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateObject(int columnIndex , Object x) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L1613" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L1615">             bool = p.evaluate(x,columnIndex);</span>

<span class="nc bnc" id="L1617" title="All 2 branches missed.">             if(!bool) {</span>
<span class="nc" id="L1618">                 throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
             }
         }
      }

<span class="nc" id="L1623">      super.updateObject(columnIndex,x);</span>
<span class="nc" id="L1624">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateObject(String columnName , Object x) throws SQLException {

<span class="nc" id="L1650">      this.updateObject(findColumn(columnName),x);</span>
<span class="nc" id="L1651">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.  The &lt;code&gt;scale&lt;/code&gt; parameter indicates
     * the number of digits to the right of the decimal point and is ignored
     * if the new column value is not a type that will be mapped to an SQL
     * &lt;code&gt;DECIMAL&lt;/code&gt; or &lt;code&gt;NUMERIC&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @param scale the number of digits to the right of the decimal point (for
     *              &lt;code&gt;DECIMAL&lt;/code&gt; and &lt;code&gt;NUMERIC&lt;/code&gt; types only)
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateObject(int columnIndex , Object x , int scale) throws SQLException {

      boolean bool;

<span class="nc bnc" id="L1685" title="All 2 branches missed.">      if(onInsertRow) {</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">         if(p != null) {</span>
<span class="nc" id="L1687">             bool = p.evaluate(x,columnIndex);</span>

<span class="nc bnc" id="L1689" title="All 2 branches missed.">             if(!bool) {</span>
<span class="nc" id="L1690">                 throw new SQLException(resBundle.handleGetObject(&quot;filteredrowsetimpl.notallowed&quot;).toString());</span>
             }
         }
      }

<span class="nc" id="L1695">      super.updateObject(columnIndex,x,scale);</span>
<span class="nc" id="L1696">   }</span>

   /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.  The &lt;code&gt;scale&lt;/code&gt; parameter
     * indicates the number of digits to the right of the decimal point
     * and is ignored if the new column value is not a type that will be
     *  mapped to an SQL &lt;code&gt;DECIMAL&lt;/code&gt; or &lt;code&gt;NUMERIC&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @param scale the number of digits to the right of the decimal point (for
     *              &lt;code&gt;DECIMAL&lt;/code&gt; and &lt;code&gt;NUMERIC&lt;/code&gt; types only)
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void updateObject(String columnName , Object x, int scale) throws SQLException {

<span class="nc" id="L1727">      this.updateObject(findColumn(columnName),x,scale);</span>
<span class="nc" id="L1728">   }</span>

   /**
     * Inserts the contents of this &lt;code&gt;CachedRowSetImpl&lt;/code&gt; object's insert
     * row into this rowset immediately following the current row.
     * If the current row is the
     * position after the last row or before the first row, the new row will
     * be inserted at the end of the rowset.  This method also notifies
     * listeners registered with this rowset that the row has changed.
     * &lt;P&gt;
     * The cursor must be on the insert row when this method is called.
     *
     * @throws SQLException if (1) the cursor is not on the insert row,
     *            (2) one or more of the non-nullable columns in the insert
     *            row has not been given a value, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
   public void insertRow() throws SQLException {

<span class="nc" id="L1747">      onInsertRow = false;</span>
<span class="nc" id="L1748">      super.insertRow();</span>
<span class="nc" id="L1749">   }</span>

   /**
    * This method re populates the resBundle
    * during the deserialization process
    *
    */
   private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
       // Default state initialization happens here
<span class="nc" id="L1758">       ois.defaultReadObject();</span>
       // Initialization of transient Res Bundle happens here .
       try {
<span class="nc" id="L1761">          resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();</span>
<span class="nc" id="L1762">       } catch(IOException ioe) {</span>
<span class="nc" id="L1763">           throw new RuntimeException(ioe);</span>
<span class="nc" id="L1764">       }</span>

<span class="nc" id="L1766">   }</span>

   static final long serialVersionUID = 6178454588413509360L;
} // end FilteredRowSetImpl class
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>