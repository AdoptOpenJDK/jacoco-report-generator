<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JoinRowSetImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.rowset</a> &gt; <span class="el_source">JoinRowSetImpl.java</span></div><h1>JoinRowSetImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.rowset;

import java.sql.*;
import javax.sql.*;
import javax.naming.*;
import java.io.*;
import java.math.*;
import java.util.*;

import javax.sql.rowset.*;
import javax.sql.rowset.spi.SyncProvider;
import javax.sql.rowset.spi.SyncProviderException;

/**
 * The standard implementation of the &lt;code&gt;JoinRowSet&lt;/code&gt;
 * interface providing an SQL &lt;code&gt;JOIN&lt;/code&gt; between &lt;code&gt;RowSet&lt;/code&gt;
 * objects.
 * &lt;P&gt;
 * The implementation provides an ANSI-style &lt;code&gt;JOIN&lt;/code&gt; providing an
 * inner join between two tables. Any unmatched rows in either table of the
 * join are  discarded.
 * &lt;p&gt;
 * Typically, a &lt;code&gt;JoinRowSet&lt;/code&gt; implementation is leveraged by
 * &lt;code&gt;RowSet&lt;/code&gt; instances that are in a disconnected environment and
 * thus do not have the luxury of an open connection to the data source to
 * establish logical relationships between themselves. In other words, it is
 * largely &lt;code&gt;CachedRowSet&lt;/code&gt; objects and implementations derived from
 * the &lt;code&gt;CachedRowSet&lt;/code&gt; interface that will use the &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
 * implementation.
 *
 * @author Amit Handa, Jonathan Bruce
 */
public class JoinRowSetImpl extends WebRowSetImpl implements JoinRowSet {
    /**
     * A &lt;code&gt;Vector&lt;/code&gt; object that contains the &lt;code&gt;RowSet&lt;/code&gt; objects
     * that have been added to this &lt;code&gt;JoinRowSet&lt;/code&gt; object.
     */
    private Vector&lt;CachedRowSetImpl&gt; vecRowSetsInJOIN;

    /**
     * The &lt;code&gt;CachedRowSet&lt;/code&gt; object that encapsulates this
     * &lt;code&gt;JoinRowSet&lt;/code&gt; object.
     * When &lt;code&gt;RowSet&lt;/code&gt; objects are added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, they are also added to &lt;i&gt;crsInternal&lt;/i&gt; to form the same kind of
     * SQL &lt;code&gt;JOIN&lt;/code&gt;.  As a result, methods for making updates to this
     * &lt;code&gt;JoinRowSet&lt;/code&gt; object can use &lt;i&gt;crsInternal&lt;/i&gt; methods in their
     * implementations.
     */
    private CachedRowSetImpl crsInternal;

    /**
     * A &lt;code&gt;Vector&lt;/code&gt; object containing the types of join that have been set
     * for this &lt;code&gt;JoinRowSet&lt;/code&gt; object.
     * The last join type set forms the basis of succeeding joins.
     */
    private Vector&lt;Integer&gt; vecJoinType;

    /**
     * A &lt;code&gt;Vector&lt;/code&gt; object containing the names of all the tables entering
     * the join.
     */
    private Vector&lt;String&gt; vecTableNames;

    /**
     * An &lt;code&gt;int&lt;/code&gt; that indicates the column index of the match column.
     */
    private int iMatchKey;

    /**
     * A &lt;code&gt;String&lt;/code&gt; object that stores the name of the match column.
     */
    private String strMatchKey ;

    /**
     * An array of &lt;code&gt;boolean&lt;/code&gt; values indicating the types of joins supported
     * by this &lt;code&gt;JoinRowSet&lt;/code&gt; implementation.
     */
    boolean[] supportedJOINs;

    /**
     * The &lt;code&gt;WebRowSet&lt;/code&gt; object that encapsulates this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object. This &lt;code&gt;WebRowSet&lt;/code&gt; object allows this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object to leverage the properties and methods of a &lt;code&gt;WebRowSet&lt;/code&gt;
     * object.
     */
    private WebRowSet wrs;


    /**
     * Constructor for &lt;code&gt;JoinRowSetImpl&lt;/code&gt; class. Configures various internal data
     * structures to provide mechanisms required for &lt;code&gt;JoinRowSet&lt;/code&gt; interface
     * implementation.
     *
     * @throws SQLException if an error occurs in instantiating an instance of
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     */
<span class="nc" id="L122">    public JoinRowSetImpl() throws SQLException {</span>

<span class="nc" id="L124">        vecRowSetsInJOIN = new Vector&lt;CachedRowSetImpl&gt;();</span>
<span class="nc" id="L125">        crsInternal = new CachedRowSetImpl();</span>
<span class="nc" id="L126">        vecJoinType = new Vector&lt;Integer&gt;();</span>
<span class="nc" id="L127">        vecTableNames = new Vector&lt;String&gt;();</span>
<span class="nc" id="L128">        iMatchKey = -1;</span>
<span class="nc" id="L129">        strMatchKey = null;</span>
<span class="nc" id="L130">        supportedJOINs =</span>
              new boolean[] {false, true, false, false, false};
       try {
<span class="nc" id="L133">           resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();</span>
<span class="nc" id="L134">        } catch(IOException ioe) {</span>
<span class="nc" id="L135">            throw new RuntimeException(ioe);</span>
<span class="nc" id="L136">        }</span>

<span class="nc" id="L138">    }</span>

    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; object to this
     * &lt;code&gt;JoinRowSet&lt;/code&gt; object.  If this
     * rowset is the first to be added to the &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis for the &lt;code&gt;JOIN&lt;/code&gt;
     * relationships to be formed.
     * &lt;p&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; object
     * already has a match column set.
     *
     * @param rowset the &lt;code&gt;RowSet&lt;/code&gt; object that implements the
     *         &lt;code&gt;Joinable&lt;/code&gt; interface and is to be added
     *         to this &lt;code&gt;JoinRowSet&lt;/code&gt; object
     * @throws SQLException if an empty &lt;code&gt;RowSet&lt;/code&gt; is added to the to the
     *         &lt;code&gt;JoinRowSet&lt;/code&gt;; if a match column is not set; or if an
     *         additional &lt;code&gt;RowSet&lt;/code&gt; violates the active &lt;code&gt;JOIN&lt;/code&gt;
     * @see CachedRowSet#setMatchColumn
     */
    public void addRowSet(Joinable rowset) throws SQLException {
        boolean boolColId, boolColName;

<span class="nc" id="L161">        boolColId = false;</span>
<span class="nc" id="L162">        boolColName = false;</span>
        CachedRowSetImpl cRowset;

<span class="nc bnc" id="L165" title="All 2 branches missed.">        if(!(rowset instanceof RowSet)) {</span>
<span class="nc" id="L166">            throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.notinstance&quot;).toString());</span>
        }

<span class="nc bnc" id="L169" title="All 2 branches missed.">        if(rowset instanceof JdbcRowSetImpl ) {</span>
<span class="nc" id="L170">            cRowset = new CachedRowSetImpl();</span>
<span class="nc" id="L171">            cRowset.populate((RowSet)rowset);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">            if(cRowset.size() == 0){</span>
<span class="nc" id="L173">                throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.emptyrowset&quot;).toString());</span>
            }


            try {
<span class="nc" id="L178">                int matchColumnCount = 0;</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                for(int i=0; i&lt; rowset.getMatchColumnIndexes().length; i++) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                    if(rowset.getMatchColumnIndexes()[i] != -1)</span>
<span class="nc" id="L181">                        ++ matchColumnCount;</span>
                    else
                        break;
                }
<span class="nc" id="L185">                int[] pCol = new int[matchColumnCount];</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                for(int i=0; i&lt;matchColumnCount; i++)</span>
<span class="nc" id="L187">                   pCol[i] = rowset.getMatchColumnIndexes()[i];</span>
<span class="nc" id="L188">                cRowset.setMatchColumn(pCol);</span>
<span class="nc" id="L189">            } catch(SQLException sqle) {</span>

<span class="nc" id="L191">            }</span>

        } else {
<span class="nc" id="L194">             cRowset = (CachedRowSetImpl)rowset;</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">             if(cRowset.size() == 0){</span>
<span class="nc" id="L196">                 throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.emptyrowset&quot;).toString());</span>
             }
        }

        // Either column id or column name will be set
        // If both not set throw exception.

        try {
<span class="nc" id="L204">             iMatchKey = (cRowset.getMatchColumnIndexes())[0];</span>
<span class="nc" id="L205">        } catch(SQLException sqle) {</span>
           //if not set catch the exception but do nothing now.
<span class="nc" id="L207">             boolColId = true;</span>
<span class="nc" id="L208">        }</span>

        try {
<span class="nc" id="L211">             strMatchKey = (cRowset.getMatchColumnNames())[0];</span>
<span class="nc" id="L212">        } catch(SQLException sqle) {</span>
           //if not set catch the exception but do nothing now.
<span class="nc" id="L214">           boolColName = true;</span>
<span class="nc" id="L215">        }</span>

<span class="nc bnc" id="L217" title="All 4 branches missed.">        if(boolColId &amp;&amp; boolColName) {</span>
           // neither setter methods have been used to set
<span class="nc" id="L219">           throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.matchnotset&quot;).toString());</span>
        } else {
           //if(boolColId || boolColName)
           // either of the setter methods have been set.
<span class="nc bnc" id="L223" title="All 2 branches missed.">           if(boolColId){</span>
              //
<span class="nc" id="L225">              ArrayList&lt;Integer&gt; indices = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">              for(int i=0;i&lt;cRowset.getMatchColumnNames().length;i++) {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">                  if( (strMatchKey = (cRowset.getMatchColumnNames())[i]) != null) {</span>
<span class="nc" id="L228">                      iMatchKey = cRowset.findColumn(strMatchKey);</span>
<span class="nc" id="L229">                      indices.add(iMatchKey);</span>
                  }
                  else
                      break;
              }
<span class="nc" id="L234">              int[] indexes = new int[indices.size()];</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">              for(int i=0; i&lt;indices.size();i++)</span>
<span class="nc" id="L236">                  indexes[i] = indices.get(i);</span>
<span class="nc" id="L237">              cRowset.setMatchColumn(indexes);</span>
              // Set the match column here because join will be
              // based on columnId,
              // (nested for loop in initJOIN() checks for equality
              //  based on columnIndex)
           } else {
              //do nothing, iMatchKey is set.
           }
           // Now both iMatchKey and strMatchKey have been set pointing
           // to the same column
        }

        // Till first rowset setJoinType may not be set because
        // default type is JoinRowSet.INNER_JOIN which should
        // be set and for subsequent additions of rowset, if not set
        // keep on adding join type as JoinRowSet.INNER_JOIN
        // to vecJoinType.

<span class="nc" id="L255">        initJOIN(cRowset);</span>
<span class="nc" id="L256">    }</span>

    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; object to the &lt;code&gt;JOIN&lt;/code&gt; relation
     * and sets the designated column as the match column.
     * If the given &lt;code&gt;RowSet&lt;/code&gt;
     * object is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis of the &lt;code&gt;JOIN&lt;/code&gt; relationship to be formed
     * when other &lt;code&gt;RowSet&lt;/code&gt; objects are added .
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; object
     * does not already have a match column set.
     *
     * @param rowset a &lt;code&gt;RowSet&lt;/code&gt; object to be added to
     *         the &lt;code&gt;JOIN&lt;/code&gt; relation; must implement the &lt;code&gt;Joinable&lt;/code&gt;
     *         interface
     * @param columnIdx an &lt;code&gt;int&lt;/code&gt; giving the index of the column to be set as
     *         the match column
     * @throws SQLException if (1) an empty &lt;code&gt;RowSet&lt;/code&gt; object is added to this
     *         &lt;code&gt;JoinRowSet&lt;/code&gt; object, (2) a match column has not been set,
     *         or (3) the &lt;code&gt;RowSet&lt;/code&gt; object being added violates the active
     *         &lt;code&gt;JOIN&lt;/code&gt;
     * @see CachedRowSet#unsetMatchColumn
     */
    public void addRowSet(RowSet rowset, int columnIdx) throws SQLException {
        //passing the rowset as well as the columnIdx to form the joinrowset.

<span class="nc" id="L283">        ((CachedRowSetImpl)rowset).setMatchColumn(columnIdx);</span>

<span class="nc" id="L285">        addRowSet((Joinable)rowset);</span>
<span class="nc" id="L286">    }</span>

    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; object to the &lt;code&gt;JOIN&lt;/code&gt; relationship
     * and sets the designated column as the match column. If the given
     * &lt;code&gt;RowSet&lt;/code&gt;
     * object is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis of the &lt;code&gt;JOIN&lt;/code&gt; relationship to be formed
     * when other &lt;code&gt;RowSet&lt;/code&gt; objects are added .
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; object
     * does not already have a match column set.
     *
     * @param rowset a &lt;code&gt;RowSet&lt;/code&gt; object to be added to
     *         the &lt;code&gt;JOIN&lt;/code&gt; relation
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the column
     *        to be set as the match column; must implement the &lt;code&gt;Joinable&lt;/code&gt;
     *        interface
     * @throws SQLException if (1) an empty &lt;code&gt;RowSet&lt;/code&gt; object is added to this
     *         &lt;code&gt;JoinRowSet&lt;/code&gt; object, (2) a match column has not been set,
     *         or (3) the &lt;code&gt;RowSet&lt;/code&gt; object being added violates the active
     *         &lt;code&gt;JOIN&lt;/code&gt;
     */
    public void addRowSet(RowSet rowset, String columnName) throws SQLException {
        //passing the rowset as well as the columnIdx to form the joinrowset.
<span class="nc" id="L311">        ((CachedRowSetImpl)rowset).setMatchColumn(columnName);</span>
<span class="nc" id="L312">        addRowSet((Joinable)rowset);</span>
<span class="nc" id="L313">    }</span>

    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; objects to the &lt;code&gt;JOIN&lt;/code&gt; relationship
     * and sets the designated columns as the match columns. If the first
     * &lt;code&gt;RowSet&lt;/code&gt; object in the array of &lt;code&gt;RowSet&lt;/code&gt; objects
     * is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis of the &lt;code&gt;JOIN&lt;/code&gt; relationship to be formed
     * when other &lt;code&gt;RowSet&lt;/code&gt; objects are added.
     * &lt;P&gt;
     * The first &lt;code&gt;int&lt;/code&gt;
     * in &lt;i&gt;columnIdx&lt;/i&gt; is used to set the match column for the first
     * &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, the second &lt;code&gt;int&lt;/code&gt;
     * in &lt;i&gt;columnIdx&lt;/i&gt; is used to set the match column for the second
     * &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, and so on.
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; objects
     * do not already have match columns set.
     *
     * @param rowset an array of &lt;code&gt;RowSet&lt;/code&gt; objects to be added to
     *         the &lt;code&gt;JOIN&lt;/code&gt; relation; each &lt;code&gt;RowSet&lt;/code&gt; object must
     *         implement the &lt;code&gt;Joinable&lt;/code&gt; interface
     * @param columnIdx an array of &lt;code&gt;int&lt;/code&gt; values designating the columns
     *        to be set as the
     *        match columns for the &lt;code&gt;RowSet&lt;/code&gt; objects in &lt;i&gt;rowset&lt;/i&gt;
     * @throws SQLException if the number of &lt;code&gt;RowSet&lt;/code&gt; objects in
     *         &lt;i&gt;rowset&lt;/i&gt; is not equal to the number of &lt;code&gt;int&lt;/code&gt; values
     *         in &lt;i&gt;columnIdx&lt;/i&gt;
     */
    public void addRowSet(RowSet[] rowset,
                          int[] columnIdx) throws SQLException {
    //validate if length of rowset array is same as length of int array.
<span class="nc bnc" id="L345" title="All 2 branches missed.">     if(rowset.length != columnIdx.length) {</span>
<span class="nc" id="L346">        throw new SQLException</span>
<span class="nc" id="L347">             (resBundle.handleGetObject(&quot;joinrowsetimpl.numnotequal&quot;).toString());</span>
     } else {
<span class="nc bnc" id="L349" title="All 2 branches missed.">        for(int i=0; i&lt; rowset.length; i++) {</span>
<span class="nc" id="L350">           ((CachedRowSetImpl)rowset[i]).setMatchColumn(columnIdx[i]);</span>
<span class="nc" id="L351">           addRowSet((Joinable)rowset[i]);</span>
        } //end for
     } //end if

<span class="nc" id="L355">   }</span>


    /**
     * Adds the given &lt;code&gt;RowSet&lt;/code&gt; objects to the &lt;code&gt;JOIN&lt;/code&gt; relationship
     * and sets the designated columns as the match columns. If the first
     * &lt;code&gt;RowSet&lt;/code&gt; object in the array of &lt;code&gt;RowSet&lt;/code&gt; objects
     * is the first to be added to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, it forms the basis of the &lt;code&gt;JOIN&lt;/code&gt; relationship to be formed
     * when other &lt;code&gt;RowSet&lt;/code&gt; objects are added.
     * &lt;P&gt;
     * The first &lt;code&gt;String&lt;/code&gt; object
     * in &lt;i&gt;columnName&lt;/i&gt; is used to set the match column for the first
     * &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, the second &lt;code&gt;String&lt;/code&gt;
     * object in &lt;i&gt;columnName&lt;/i&gt; is used to set the match column for the second
     * &lt;code&gt;RowSet&lt;/code&gt; object in &lt;i&gt;rowset&lt;/i&gt;, and so on.
     * &lt;P&gt;
     * This method should be used when the given &lt;code&gt;RowSet&lt;/code&gt; objects
     * do not already have match columns set.
     *
     * @param rowset an array of &lt;code&gt;RowSet&lt;/code&gt; objects to be added to
     *         the &lt;code&gt;JOIN&lt;/code&gt; relation; each &lt;code&gt;RowSet&lt;/code&gt; object must
     *         implement the &lt;code&gt;Joinable&lt;/code&gt; interface
     * @param columnName an array of &lt;code&gt;String&lt;/code&gt; objects designating the columns
     *        to be set as the
     *        match columns for the &lt;code&gt;RowSet&lt;/code&gt; objects in &lt;i&gt;rowset&lt;/i&gt;
     * @throws SQLException if the number of &lt;code&gt;RowSet&lt;/code&gt; objects in
     *         &lt;i&gt;rowset&lt;/i&gt; is not equal to the number of &lt;code&gt;String&lt;/code&gt; objects
     *         in &lt;i&gt;columnName&lt;/i&gt;, an empty &lt;code&gt;JdbcRowSet&lt;/code&gt; is added to the
     *         &lt;code&gt;JoinRowSet&lt;/code&gt;, if a match column is not set,
     *         or one or the &lt;code&gt;RowSet&lt;/code&gt; objects in &lt;i&gt;rowset&lt;/i&gt; violates the
     *         active &lt;code&gt;JOIN&lt;/code&gt;
     */
    public void addRowSet(RowSet[] rowset,
                          String[] columnName) throws SQLException {
    //validate if length of rowset array is same as length of int array.

<span class="nc bnc" id="L392" title="All 2 branches missed.">     if(rowset.length != columnName.length) {</span>
<span class="nc" id="L393">        throw new SQLException</span>
<span class="nc" id="L394">                 (resBundle.handleGetObject(&quot;joinrowsetimpl.numnotequal&quot;).toString());</span>
     } else {
<span class="nc bnc" id="L396" title="All 2 branches missed.">        for(int i=0; i&lt; rowset.length; i++) {</span>
<span class="nc" id="L397">           ((CachedRowSetImpl)rowset[i]).setMatchColumn(columnName[i]);</span>
<span class="nc" id="L398">           addRowSet((Joinable)rowset[i]);</span>
        } //end for
     } //end if

<span class="nc" id="L402">    }</span>

    /**
     * Returns a Collection of the &lt;code&gt;RowSet&lt;/code&gt; object instances
     * currently residing with the instance of the &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object instance. This should return the 'n' number of RowSet contained
     * within the JOIN and maintain any updates that have occoured while in
     * this union.
     *
     * @return A &lt;code&gt;Collection&lt;/code&gt; of the added &lt;code&gt;RowSet&lt;/code&gt;
     * object instances
     * @throws SQLException if an error occours generating a collection
     * of the originating RowSets contained within the JOIN.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public Collection getRowSets() throws SQLException {
<span class="nc" id="L418">        return vecRowSetsInJOIN;</span>
    }

    /**
     * Returns a string array of the RowSet names currently residing
     * with the &lt;code&gt;JoinRowSet&lt;/code&gt; object instance.
     *
     * @return a string array of the RowSet names
     * @throws SQLException if an error occours retrieving the RowSet names
     * @see CachedRowSet#setTableName
     */
    public String[] getRowSetNames() throws SQLException {
<span class="nc" id="L430">        Object [] arr = vecTableNames.toArray();</span>
<span class="nc" id="L431">        String []strArr = new String[arr.length];</span>

<span class="nc bnc" id="L433" title="All 2 branches missed.">        for( int i = 0;i &lt; arr.length; i++) {</span>
<span class="nc" id="L434">           strArr[i] = arr[i].toString();</span>
        }

<span class="nc" id="L437">        return strArr;</span>
    }

    /**
     * Creates a separate &lt;code&gt;CachedRowSet&lt;/code&gt; object that contains the data
     * in this &lt;code&gt;JoinRowSet&lt;/code&gt; object.
     * &lt;P&gt;
     * If any updates or modifications have been applied to this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object, the &lt;code&gt;CachedRowSet&lt;/code&gt; object returned by this method will
     * not be able to persist
     * the changes back to the originating rows and tables in the
     * data source because the data may be from different tables. The
     * &lt;code&gt;CachedRowSet&lt;/code&gt; instance returned should not
     * contain modification data, such as whether a row has been updated or what the
     * original values are.  Also, the &lt;code&gt;CachedRowSet&lt;/code&gt; object should clear
     * its  properties pertaining to
     * its originating SQL statement. An application should reset the
     * SQL statement using the &lt;code&gt;RowSet.setCommand&lt;/code&gt; method.
     * &lt;p&gt;
     * To persist changes back to the data source, the &lt;code&gt;JoinRowSet&lt;/code&gt; object
     * calls the method &lt;code&gt;acceptChanges&lt;/code&gt;. Implementations
     * can leverage the internal data and update tracking in their
     * implementations to interact with the &lt;code&gt;SyncProvider&lt;/code&gt; to persist any
     * changes.
     *
     * @return a &lt;code&gt;CachedRowSet&lt;/code&gt; object containing the contents of this
     *         &lt;code&gt;JoinRowSet&lt;/code&gt; object
     * @throws SQLException if an error occurs assembling the &lt;code&gt;CachedRowSet&lt;/code&gt;
     *         object
     * @see javax.sql.RowSet
     * @see javax.sql.rowset.CachedRowSet
     * @see javax.sql.rowset.spi.SyncProvider
     */
    public CachedRowSet toCachedRowSet() throws SQLException {
<span class="nc" id="L471">        return crsInternal;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JoinRowSet&lt;/code&gt; object supports
     * an SQL &lt;code&gt;CROSS_JOIN&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it does not.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the CROSS_JOIN is supported; &lt;code&gt;false&lt;/code&gt;
     *         otherwise
     */
    public boolean supportsCrossJoin() {
<span class="nc" id="L482">        return supportedJOINs[JoinRowSet.CROSS_JOIN];</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JoinRowSet&lt;/code&gt; object supports
     * an SQL &lt;code&gt;INNER_JOIN&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it does not.
     *
     * @return true is the INNER_JOIN is supported; false otherwise
     */
    public boolean supportsInnerJoin() {
<span class="nc" id="L492">        return supportedJOINs[JoinRowSet.INNER_JOIN];</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JoinRowSet&lt;/code&gt; object supports
     * an SQL &lt;code&gt;LEFT_OUTER_JOIN&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it does not.
     *
     * @return true is the LEFT_OUTER_JOIN is supported; false otherwise
     */
    public boolean supportsLeftOuterJoin() {
<span class="nc" id="L502">        return supportedJOINs[JoinRowSet.LEFT_OUTER_JOIN];</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JoinRowSet&lt;/code&gt; object supports
     * an SQL &lt;code&gt;RIGHT_OUTER_JOIN&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it does not.
     *
     * @return true is the RIGHT_OUTER_JOIN is supported; false otherwise
     */
    public boolean supportsRightOuterJoin() {
<span class="nc" id="L512">        return supportedJOINs[JoinRowSet.RIGHT_OUTER_JOIN];</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JoinRowSet&lt;/code&gt; object supports
     * an SQL &lt;code&gt;FULL_JOIN&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it does not.
     *
     * @return true is the FULL_JOIN is supported; false otherwise
     */
    public boolean supportsFullJoin() {
<span class="nc" id="L522">        return supportedJOINs[JoinRowSet.FULL_JOIN];</span>

    }

    /**
     * Sets the type of SQL &lt;code&gt;JOIN&lt;/code&gt; that this &lt;code&gt;JoinRowSet&lt;/code&gt;
     * object will use. This method
     * allows an application to adjust the type of &lt;code&gt;JOIN&lt;/code&gt; imposed
     * on tables contained within this &lt;code&gt;JoinRowSet&lt;/code&gt; object and to do it
     * on the fly. The last &lt;code&gt;JOIN&lt;/code&gt; type set determines the type of
     * &lt;code&gt;JOIN&lt;/code&gt; to be performed.
     * &lt;P&gt;
     * Implementations should throw an &lt;code&gt;SQLException&lt;/code&gt; if they do
     * not support the given &lt;code&gt;JOIN&lt;/code&gt; type.
     *
     * @param type one of the standard &lt;code&gt;JoinRowSet&lt;/code&gt; constants
     *        indicating the type of &lt;code&gt;JOIN&lt;/code&gt;.  Must be one of the
     *        following:
     *            &lt;code&gt;JoinRowSet.CROSS_JOIN&lt;/code&gt;
     *            &lt;code&gt;JoinRowSet.INNER_JOIN&lt;/code&gt;
     *            &lt;code&gt;JoinRowSet.LEFT_OUTER_JOIN&lt;/code&gt;
     *            &lt;code&gt;JoinRowSet.RIGHT_OUTER_JOIN&lt;/code&gt;, or
     *            &lt;code&gt;JoinRowSet.FULL_JOIN&lt;/code&gt;
     * @throws SQLException if an unsupported &lt;code&gt;JOIN&lt;/code&gt; type is set
     */
    public void setJoinType(int type) throws SQLException {
        // The join which governs the join of two rowsets is the last
        // join set, using setJoinType

<span class="nc bnc" id="L551" title="All 4 branches missed.">       if (type &gt;= JoinRowSet.CROSS_JOIN &amp;&amp; type &lt;= JoinRowSet.FULL_JOIN) {</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">           if (type != JoinRowSet.INNER_JOIN) {</span>
               // This 'if' will be removed after all joins are implemented.
<span class="nc" id="L554">               throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.notsupported&quot;).toString());</span>
           } else {
<span class="nc" id="L556">              Integer Intgr = Integer.valueOf(JoinRowSet.INNER_JOIN);</span>
<span class="nc" id="L557">              vecJoinType.add(Intgr);</span>
<span class="nc" id="L558">           }</span>
       } else {
<span class="nc" id="L560">          throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.notdefined&quot;).toString());</span>
       }  //end if
<span class="nc" id="L562">    }</span>


    /**
     * This checks for a match column for
     * whether it exists or not.
     *
     * @param &lt;code&gt;CachedRowSet&lt;/code&gt; object whose match column needs to be checked.
     * @throws SQLException if MatchColumn is not set.
     */
    private boolean checkforMatchColumn(Joinable rs) throws SQLException {
<span class="nc" id="L573">        int[] i = rs.getMatchColumnIndexes();</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (i.length &lt;= 0) {</span>
<span class="nc" id="L575">            return false;</span>
        }
<span class="nc" id="L577">        return true;</span>
    }

    /**
     * Internal initialization of &lt;code&gt;JoinRowSet&lt;/code&gt;.
     */
    private void initJOIN(CachedRowSet rowset) throws SQLException {
        try {

<span class="nc" id="L586">            CachedRowSetImpl cRowset = (CachedRowSetImpl)rowset;</span>
            // Create a new CachedRowSet object local to this function.
<span class="nc" id="L588">            CachedRowSetImpl crsTemp = new CachedRowSetImpl();</span>
<span class="nc" id="L589">            RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();</span>

            /* The following 'if block' seems to be always going true.
               commenting this out for present

            if (!supportedJOINs[1]) {
                throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.notsupported&quot;).toString());
            }

            */

<span class="nc bnc" id="L600" title="All 2 branches missed.">            if (vecRowSetsInJOIN.isEmpty() ) {</span>

                // implies first cRowset to be added to the Join
                // simply add this as a CachedRowSet.
                // Also add it to the class variable of type vector
                // do not need to check &quot;type&quot; of Join but it should be set.
<span class="nc" id="L606">                crsInternal = (CachedRowSetImpl)rowset.createCopy();</span>
<span class="nc" id="L607">                crsInternal.setMetaData((RowSetMetaDataImpl)cRowset.getMetaData());</span>
                // metadata will also set the MatchColumn.

<span class="nc" id="L610">                vecRowSetsInJOIN.add(cRowset);</span>

            } else {
                // At this point we are ready to add another rowset to 'this' object
                // Check the size of vecJoinType and vecRowSetsInJoin

                // If nothing is being set, internally call setJoinType()
                // to set to JoinRowSet.INNER_JOIN.

                // For two rowsets one (valid) entry should be there in vecJoinType
                // For three rowsets two (valid) entries should be there in vecJoinType

                // Maintain vecRowSetsInJoin = vecJoinType + 1


<span class="nc bnc" id="L625" title="All 2 branches missed.">                if( (vecRowSetsInJOIN.size() - vecJoinType.size() ) == 2 ) {</span>
                   // we are going to add next rowset and setJoinType has not been set
                   // recently, so set it to setJoinType() to JoinRowSet.INNER_JOIN.
                   // the default join type

<span class="nc" id="L630">                        setJoinType(JoinRowSet.INNER_JOIN);</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">                } else if( (vecRowSetsInJOIN.size() - vecJoinType.size() ) == 1  ) {</span>
                   // do nothing setjoinType() has been set by programmer
                }

                // Add the table names to the class variable of type vector.
<span class="nc" id="L636">                vecTableNames.add(crsInternal.getTableName());</span>
<span class="nc" id="L637">                vecTableNames.add(cRowset.getTableName());</span>
                // Now we have two rowsets crsInternal and cRowset which need
                // to be INNER JOIN'ED to form a new rowset
                // Compare table1.MatchColumn1.value1 == { table2.MatchColumn2.value1
                //                              ... upto table2.MatchColumn2.valueN }
                //     ...
                // Compare table1.MatchColumn1.valueM == { table2.MatchColumn2.value1
                //                              ... upto table2.MatchColumn2.valueN }
                //
                // Assuming first rowset has M rows and second N rows.

<span class="nc" id="L648">                int rowCount2 = cRowset.size();</span>
<span class="nc" id="L649">                int rowCount1 = crsInternal.size();</span>

                // total columns in the new CachedRowSet will be sum of both -1
                // (common column)
<span class="nc" id="L653">                int matchColumnCount = 0;</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">                for(int i=0; i&lt; crsInternal.getMatchColumnIndexes().length; i++) {</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">                    if(crsInternal.getMatchColumnIndexes()[i] != -1)</span>
<span class="nc" id="L656">                        ++ matchColumnCount;</span>
                    else
                        break;
                }

<span class="nc" id="L661">                rsmd.setColumnCount</span>
<span class="nc" id="L662">                    (crsInternal.getMetaData().getColumnCount() +</span>
<span class="nc" id="L663">                     cRowset.getMetaData().getColumnCount() - matchColumnCount);</span>

<span class="nc" id="L665">                crsTemp.setMetaData(rsmd);</span>
<span class="nc" id="L666">                crsInternal.beforeFirst();</span>
<span class="nc" id="L667">                cRowset.beforeFirst();</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">                for (int i = 1 ; i &lt;= rowCount1 ; i++) {</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">                  if(crsInternal.isAfterLast() ) {</span>
<span class="nc" id="L670">                    break;</span>
                  }
<span class="nc bnc" id="L672" title="All 2 branches missed.">                  if(crsInternal.next()) {</span>
<span class="nc" id="L673">                    cRowset.beforeFirst();</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                    for(int j = 1 ; j &lt;= rowCount2 ; j++) {</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">                         if( cRowset.isAfterLast()) {</span>
<span class="nc" id="L676">                            break;</span>
                         }
<span class="nc bnc" id="L678" title="All 2 branches missed.">                         if(cRowset.next()) {</span>
<span class="nc" id="L679">                             boolean match = true;</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                             for(int k=0; k&lt;matchColumnCount; k++) {</span>
<span class="nc" id="L681">                                 if (!crsInternal.getObject( crsInternal.getMatchColumnIndexes()[k]).equals</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                                         (cRowset.getObject(cRowset.getMatchColumnIndexes()[k]))) {</span>
<span class="nc" id="L683">                                     match = false;</span>
<span class="nc" id="L684">                                     break;</span>
                                 }
                             }
<span class="nc bnc" id="L687" title="All 2 branches missed.">                             if (match) {</span>

                                int p;
<span class="nc" id="L690">                                int colc = 0;   // reset this variable everytime you loop</span>
                                // re create a JoinRowSet in crsTemp object
<span class="nc" id="L692">                                crsTemp.moveToInsertRow();</span>

                                // create a new rowset crsTemp with data from first rowset
<span class="nc" id="L695">                            for( p=1;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">                                p&lt;=crsInternal.getMetaData().getColumnCount();p++) {</span>

<span class="nc" id="L698">                                match = false;</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">                                for(int k=0; k&lt;matchColumnCount; k++) {</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">                                 if (p == crsInternal.getMatchColumnIndexes()[k] ) {</span>
<span class="nc" id="L701">                                     match = true;</span>
<span class="nc" id="L702">                                     break;</span>
                                 }
                                }
<span class="nc bnc" id="L705" title="All 2 branches missed.">                                    if ( !match ) {</span>

<span class="nc" id="L707">                                    crsTemp.updateObject(++colc, crsInternal.getObject(p));</span>
                                    // column type also needs to be passed.

<span class="nc" id="L710">                                    rsmd.setColumnName</span>
<span class="nc" id="L711">                                        (colc, crsInternal.getMetaData().getColumnName(p));</span>
<span class="nc" id="L712">                                    rsmd.setTableName(colc, crsInternal.getTableName());</span>

<span class="nc" id="L714">                                    rsmd.setColumnType(p, crsInternal.getMetaData().getColumnType(p));</span>
<span class="nc" id="L715">                                    rsmd.setAutoIncrement(p, crsInternal.getMetaData().isAutoIncrement(p));</span>
<span class="nc" id="L716">                                    rsmd.setCaseSensitive(p, crsInternal.getMetaData().isCaseSensitive(p));</span>
<span class="nc" id="L717">                                    rsmd.setCatalogName(p, crsInternal.getMetaData().getCatalogName(p));</span>
<span class="nc" id="L718">                                    rsmd.setColumnDisplaySize(p, crsInternal.getMetaData().getColumnDisplaySize(p));</span>
<span class="nc" id="L719">                                    rsmd.setColumnLabel(p, crsInternal.getMetaData().getColumnLabel(p));</span>
<span class="nc" id="L720">                                    rsmd.setColumnType(p, crsInternal.getMetaData().getColumnType(p));</span>
<span class="nc" id="L721">                                    rsmd.setColumnTypeName(p, crsInternal.getMetaData().getColumnTypeName(p));</span>
<span class="nc" id="L722">                                    rsmd.setCurrency(p,crsInternal.getMetaData().isCurrency(p) );</span>
<span class="nc" id="L723">                                    rsmd.setNullable(p, crsInternal.getMetaData().isNullable(p));</span>
<span class="nc" id="L724">                                    rsmd.setPrecision(p, crsInternal.getMetaData().getPrecision(p));</span>
<span class="nc" id="L725">                                    rsmd.setScale(p, crsInternal.getMetaData().getScale(p));</span>
<span class="nc" id="L726">                                    rsmd.setSchemaName(p, crsInternal.getMetaData().getSchemaName(p));</span>
<span class="nc" id="L727">                                    rsmd.setSearchable(p, crsInternal.getMetaData().isSearchable(p));</span>
<span class="nc" id="L728">                                    rsmd.setSigned(p, crsInternal.getMetaData().isSigned(p));</span>

                                } else {
                                    // will happen only once, for that  merged column pass
                                    // the types as OBJECT, if types not equal

<span class="nc" id="L734">                                    crsTemp.updateObject(++colc, crsInternal.getObject(p));</span>

<span class="nc" id="L736">                                    rsmd.setColumnName(colc, crsInternal.getMetaData().getColumnName(p));</span>
<span class="nc" id="L737">                                    rsmd.setTableName</span>
<span class="nc" id="L738">                                        (colc, crsInternal.getTableName()+</span>
                                         &quot;#&quot;+
<span class="nc" id="L740">                                         cRowset.getTableName());</span>


<span class="nc" id="L743">                                    rsmd.setColumnType(p, crsInternal.getMetaData().getColumnType(p));</span>
<span class="nc" id="L744">                                    rsmd.setAutoIncrement(p, crsInternal.getMetaData().isAutoIncrement(p));</span>
<span class="nc" id="L745">                                    rsmd.setCaseSensitive(p, crsInternal.getMetaData().isCaseSensitive(p));</span>
<span class="nc" id="L746">                                    rsmd.setCatalogName(p, crsInternal.getMetaData().getCatalogName(p));</span>
<span class="nc" id="L747">                                    rsmd.setColumnDisplaySize(p, crsInternal.getMetaData().getColumnDisplaySize(p));</span>
<span class="nc" id="L748">                                    rsmd.setColumnLabel(p, crsInternal.getMetaData().getColumnLabel(p));</span>
<span class="nc" id="L749">                                    rsmd.setColumnType(p, crsInternal.getMetaData().getColumnType(p));</span>
<span class="nc" id="L750">                                    rsmd.setColumnTypeName(p, crsInternal.getMetaData().getColumnTypeName(p));</span>
<span class="nc" id="L751">                                    rsmd.setCurrency(p,crsInternal.getMetaData().isCurrency(p) );</span>
<span class="nc" id="L752">                                    rsmd.setNullable(p, crsInternal.getMetaData().isNullable(p));</span>
<span class="nc" id="L753">                                    rsmd.setPrecision(p, crsInternal.getMetaData().getPrecision(p));</span>
<span class="nc" id="L754">                                    rsmd.setScale(p, crsInternal.getMetaData().getScale(p));</span>
<span class="nc" id="L755">                                    rsmd.setSchemaName(p, crsInternal.getMetaData().getSchemaName(p));</span>
<span class="nc" id="L756">                                    rsmd.setSearchable(p, crsInternal.getMetaData().isSearchable(p));</span>
<span class="nc" id="L757">                                    rsmd.setSigned(p, crsInternal.getMetaData().isSigned(p));</span>

                                    //don't do ++colc in the above statement
                                } //end if
                            } //end for


                            // append the rowset crsTemp, with data from second rowset
<span class="nc" id="L765">                            for(int q=1;</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">                                q&lt;= cRowset.getMetaData().getColumnCount();q++) {</span>

<span class="nc" id="L768">                                match = false;</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                                for(int k=0; k&lt;matchColumnCount; k++) {</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">                                 if (q == cRowset.getMatchColumnIndexes()[k] ) {</span>
<span class="nc" id="L771">                                     match = true;</span>
<span class="nc" id="L772">                                     break;</span>
                                 }
                                }
<span class="nc bnc" id="L775" title="All 2 branches missed.">                                    if ( !match ) {</span>

<span class="nc" id="L777">                                    crsTemp.updateObject(++colc, cRowset.getObject(q));</span>

<span class="nc" id="L779">                                    rsmd.setColumnName</span>
<span class="nc" id="L780">                                        (colc, cRowset.getMetaData().getColumnName(q));</span>
<span class="nc" id="L781">                                    rsmd.setTableName(colc, cRowset.getTableName());</span>

                                    /**
                                      * This will happen for a special case scenario. The value of 'p'
                                      * will always be one more than the number of columns in the first
                                      * rowset in the join. So, for a value of 'q' which is the number of
                                      * columns in the second rowset that participates in the join.
                                      * So decrement value of 'p' by 1 else `p+q-1` will be out of range.
                                      **/

                                    //if((p+q-1) &gt; ((crsInternal.getMetaData().getColumnCount()) +
                                      //            (cRowset.getMetaData().getColumnCount())     - 1)) {
                                      // --p;
                                    //}
<span class="nc" id="L795">                                    rsmd.setColumnType(p+q-1, cRowset.getMetaData().getColumnType(q));</span>
<span class="nc" id="L796">                                    rsmd.setAutoIncrement(p+q-1, cRowset.getMetaData().isAutoIncrement(q));</span>
<span class="nc" id="L797">                                    rsmd.setCaseSensitive(p+q-1, cRowset.getMetaData().isCaseSensitive(q));</span>
<span class="nc" id="L798">                                    rsmd.setCatalogName(p+q-1, cRowset.getMetaData().getCatalogName(q));</span>
<span class="nc" id="L799">                                    rsmd.setColumnDisplaySize(p+q-1, cRowset.getMetaData().getColumnDisplaySize(q));</span>
<span class="nc" id="L800">                                    rsmd.setColumnLabel(p+q-1, cRowset.getMetaData().getColumnLabel(q));</span>
<span class="nc" id="L801">                                    rsmd.setColumnType(p+q-1, cRowset.getMetaData().getColumnType(q));</span>
<span class="nc" id="L802">                                    rsmd.setColumnTypeName(p+q-1, cRowset.getMetaData().getColumnTypeName(q));</span>
<span class="nc" id="L803">                                    rsmd.setCurrency(p+q-1,cRowset.getMetaData().isCurrency(q) );</span>
<span class="nc" id="L804">                                    rsmd.setNullable(p+q-1, cRowset.getMetaData().isNullable(q));</span>
<span class="nc" id="L805">                                    rsmd.setPrecision(p+q-1, cRowset.getMetaData().getPrecision(q));</span>
<span class="nc" id="L806">                                    rsmd.setScale(p+q-1, cRowset.getMetaData().getScale(q));</span>
<span class="nc" id="L807">                                    rsmd.setSchemaName(p+q-1, cRowset.getMetaData().getSchemaName(q));</span>
<span class="nc" id="L808">                                    rsmd.setSearchable(p+q-1, cRowset.getMetaData().isSearchable(q));</span>
<span class="nc" id="L809">                                    rsmd.setSigned(p+q-1, cRowset.getMetaData().isSigned(q));</span>
                                }
                                else {
<span class="nc" id="L812">                                    --p;</span>
                                }
                            }
<span class="nc" id="L815">                            crsTemp.insertRow();</span>
<span class="nc" id="L816">                            crsTemp.moveToCurrentRow();</span>

                        } else {
                            // since not equa12
                            // so do nothing
                        } //end if
                         // bool1 = cRowset.next();
                         }

                    } // end inner for
                     //bool2 = crsInternal.next();
                   }

                } //end outer for
<span class="nc" id="L830">                crsTemp.setMetaData(rsmd);</span>
<span class="nc" id="L831">                crsTemp.setOriginal();</span>

                // Now the join is done.
               // Make crsInternal = crsTemp, to be ready for next merge, if at all.

<span class="nc" id="L836">                int[] pCol = new int[matchColumnCount];</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">                for(int i=0; i&lt;matchColumnCount; i++)</span>
<span class="nc" id="L838">                   pCol[i] = crsInternal.getMatchColumnIndexes()[i];</span>

<span class="nc" id="L840">                crsInternal = (CachedRowSetImpl)crsTemp.createCopy();</span>

                // Because we add the first rowset as crsInternal to the
                // merged rowset, so pCol will point to the Match column.
                // until reset, am not sure we should set this or not(?)
                // if this is not set next inner join won't happen
                // if we explicitly do not set a set MatchColumn of
                // the new crsInternal.

<span class="nc" id="L849">                crsInternal.setMatchColumn(pCol);</span>
                // Add the merged rowset to the class variable of type vector.
<span class="nc" id="L851">                crsInternal.setMetaData(rsmd);</span>
<span class="nc" id="L852">                vecRowSetsInJOIN.add(cRowset);</span>
            } //end if
<span class="nc" id="L854">        } catch(SQLException sqle) {</span>
            // %%% Exception should not dump here:
<span class="nc" id="L856">            sqle.printStackTrace();</span>
<span class="nc" id="L857">            throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.initerror&quot;).toString() + sqle);</span>
<span class="nc" id="L858">        } catch (Exception e) {</span>
<span class="nc" id="L859">            e.printStackTrace();</span>
<span class="nc" id="L860">            throw new SQLException(resBundle.handleGetObject(&quot;joinrowsetimpl.genericerr&quot;).toString() + e);</span>
<span class="nc" id="L861">        }</span>
<span class="nc" id="L862">    }</span>

    /**
     * Return a SQL-like description of the &lt;code&gt;WHERE&lt;/code&gt; clause being used
     * in a &lt;code&gt;JoinRowSet&lt;/code&gt; object instance. An implementation can describe
     * the &lt;code&gt;WHERE&lt;/code&gt; clause of the SQL &lt;code&gt;JOIN&lt;/code&gt; by supplying a &lt;code&gt;SQL&lt;/code&gt;
     * strings description of &lt;code&gt;JOIN&lt;/code&gt; or provide a textual description to assist
     * applications using a &lt;code&gt;JoinRowSet&lt;/code&gt;.
     *
     * @return whereClause a textual or SQL descripition of the logical
     * &lt;code&gt;WHERE&lt;/code&gt; cluase used in the &lt;code&gt;JoinRowSet&lt;/code&gt; instance
     * @throws SQLException if an error occurs in generating a representation
     * of the &lt;code&gt;WHERE&lt;/code&gt; clause.
     */
    public String getWhereClause() throws SQLException {

<span class="nc" id="L878">       String strWhereClause = &quot;Select &quot;;</span>
       String whereClause;
<span class="nc" id="L880">       String tabName= &quot;&quot;;</span>
<span class="nc" id="L881">       String strTabName = &quot;&quot;;</span>
       int sz,cols;
       int j;
       CachedRowSetImpl crs;

       // get all the column(s) names from each rowset.
       // append them with their tablenames i.e. tableName.columnName
       // Select tableName1.columnName1,..., tableNameX.columnNameY
       // from tableName1,...tableNameX where
       // tableName1.(rowset1.getMatchColumnName()) ==
       // tableName2.(rowset2.getMatchColumnName()) + &quot;and&quot; +
       // tableNameX.(rowsetX.getMatchColumnName()) ==
       // tableNameZ.(rowsetZ.getMatchColumnName()));

<span class="nc" id="L895">       sz = vecRowSetsInJOIN.size();</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">       for(int i=0;i&lt;sz; i++) {</span>
<span class="nc" id="L897">          crs = vecRowSetsInJOIN.get(i);</span>
<span class="nc" id="L898">          cols = crs.getMetaData().getColumnCount();</span>
<span class="nc" id="L899">          tabName = tabName.concat(crs.getTableName());</span>
<span class="nc" id="L900">          strTabName = strTabName.concat(tabName+&quot;, &quot;);</span>
<span class="nc" id="L901">          j = 1;</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">          while(j&lt;cols) {</span>

<span class="nc" id="L904">            strWhereClause = strWhereClause.concat</span>
<span class="nc" id="L905">                (tabName+&quot;.&quot;+crs.getMetaData().getColumnName(j++));</span>
<span class="nc" id="L906">            strWhereClause = strWhereClause.concat(&quot;, &quot;);</span>
          } //end while
        } //end for


        // now remove the last &quot;,&quot;
<span class="nc" id="L912">        strWhereClause = strWhereClause.substring</span>
<span class="nc" id="L913">             (0, strWhereClause.lastIndexOf(&quot;,&quot;));</span>

        // Add from clause
<span class="nc" id="L916">        strWhereClause = strWhereClause.concat(&quot; from &quot;);</span>

        // Add the table names.
<span class="nc" id="L919">        strWhereClause = strWhereClause.concat(strTabName);</span>

        //Remove the last &quot;,&quot;
<span class="nc" id="L922">        strWhereClause = strWhereClause.substring</span>
<span class="nc" id="L923">             (0, strWhereClause.lastIndexOf(&quot;,&quot;));</span>

        // Add the where clause
<span class="nc" id="L926">        strWhereClause = strWhereClause.concat(&quot; where &quot;);</span>

        // Get the match columns
        // rowset1.getMatchColumnName() == rowset2.getMatchColumnName()
<span class="nc bnc" id="L930" title="All 2 branches missed.">         for(int i=0;i&lt;sz; i++) {</span>
<span class="nc" id="L931">             strWhereClause = strWhereClause.concat(</span>
<span class="nc" id="L932">               vecRowSetsInJOIN.get(i).getMatchColumnNames()[0]);</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">             if(i%2!=0) {</span>
<span class="nc" id="L934">               strWhereClause = strWhereClause.concat(&quot;=&quot;);</span>
             }  else {
<span class="nc" id="L936">               strWhereClause = strWhereClause.concat(&quot; and&quot;);</span>
             }
<span class="nc" id="L938">          strWhereClause = strWhereClause.concat(&quot; &quot;);</span>
         }

<span class="nc" id="L941">        return strWhereClause;</span>
    }


    /**
     * Moves the cursor down one row from its current position and
     * returns &lt;code&gt;true&lt;/code&gt; if the new cursor position is a
     * valid row.
     * The cursor for a new &lt;code&gt;ResultSet&lt;/code&gt; object is initially
     * positioned before the first row. The first call to the method
     * &lt;code&gt;next&lt;/code&gt; moves the cursor to the first row, making it
     * the current row; the second call makes the second row the
     * current row, and so on.
     *
     * &lt;P&gt;If an input stream from the previous row is open, it is
     * implicitly closed. The &lt;code&gt;ResultSet&lt;/code&gt; object's warning
     * chain is cleared when a new row is read.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the new current row is valid;
     *         &lt;code&gt;false&lt;/code&gt; if there are no more rows
     * @throws SQLException if an error occurs or
     *            the cursor is not positioned in the rowset, before
     *            the first row, or after the last row
     */
    public boolean next() throws SQLException {
<span class="nc" id="L966">        return crsInternal.next();</span>
    }


    /**
     * Releases the current contents of this rowset, discarding  outstanding
     * updates.  The rowset contains no rows after the method
     * &lt;code&gt;release&lt;/code&gt; is called. This method sends a
     * &lt;code&gt;RowSetChangedEvent&lt;/code&gt; object to all registered listeners prior
     * to returning.
     *
     * @throws SQLException if an error occurs
     */
    public void close() throws SQLException {
<span class="nc" id="L980">        crsInternal.close();</span>
<span class="nc" id="L981">    }</span>


    /**
     * Reports whether the last column read was SQL &lt;code&gt;NULL&lt;/code&gt;.
     * Note that you must first call the method &lt;code&gt;getXXX&lt;/code&gt;
     * on a column to try to read its value and then call the method
     * &lt;code&gt;wasNull&lt;/code&gt; to determine whether the value was
     * SQL &lt;code&gt;NULL&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the value in the last column read
     *         was SQL &lt;code&gt;NULL&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if an error occurs
     */
    public boolean wasNull() throws SQLException {
<span class="nc" id="L996">        return crsInternal.wasNull();</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;String&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds or
     *            the cursor is not on a valid row
     */
    public String getString(int columnIndex) throws SQLException {
<span class="nc" id="L1013">        return crsInternal.getString(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;boolean&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;false&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public boolean getBoolean(int columnIndex) throws SQLException {
<span class="nc" id="L1030">        return crsInternal.getBoolean(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;byte&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public byte getByte(int columnIndex) throws SQLException {
<span class="nc" id="L1047">        return crsInternal.getByte(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
             * &lt;code&gt;short&lt;/code&gt; value.
             *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public short getShort(int columnIndex) throws SQLException {
<span class="nc" id="L1064">        return crsInternal.getShort(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;short&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public int getInt(int columnIndex) throws SQLException {
<span class="nc" id="L1081">        return crsInternal.getInt(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;long&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public long getLong(int columnIndex) throws SQLException {
<span class="nc" id="L1098">        return crsInternal.getLong(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;float&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public float getFloat(int columnIndex) throws SQLException {
<span class="nc" id="L1115">        return crsInternal.getFloat(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;double&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public double getDouble(int columnIndex) throws SQLException {
<span class="nc" id="L1132">        return crsInternal.getDouble(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     * &lt;P&gt;
     * This method is deprecated; use the version of &lt;code&gt;getBigDecimal&lt;/code&gt;
     * that does not take a scale parameter and returns a value with full
     * precision.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @param scale the number of digits to the right of the decimal point in the
     *        value returned
     * @return the column value with the specified number of digits to the right
     *         of the decimal point; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     * @deprecated
     */
    @Deprecated
    public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {
<span class="nc" id="L1158">        return crsInternal.getBigDecimal(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;byte array&lt;/code&gt; value.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or the the value to be
     *            retrieved is not binary
     */
    public byte[] getBytes(int columnIndex) throws SQLException {
<span class="nc" id="L1176">        return crsInternal.getBytes(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.sql.Date&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public java.sql.Date getDate(int columnIndex) throws SQLException {
<span class="nc" id="L1193">        return crsInternal.getDate(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.sql.Time&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public java.sql.Time getTime(int columnIndex) throws SQLException {
<span class="nc" id="L1210">        return crsInternal.getTime(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public java.sql.Timestamp getTimestamp(int columnIndex) throws SQLException {
<span class="nc" id="L1227">        return crsInternal.getTimestamp(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the
     *         result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public java.io.InputStream getAsciiStream(int columnIndex) throws SQLException {
<span class="nc" id="L1244">        return crsInternal.getAsciiStream(columnIndex);</span>
    }

    /**
     * A column value can be retrieved as a stream of Unicode characters
     * and then read in chunks from the stream.  This method is particularly
     * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
     * do any necessary conversion from the database format into Unicode.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
     * read prior to getting the value of any other column. The next
     * call to a get method implicitly closes the stream. . Also, a
     * stream may return 0 for available() whether there is data
     * available or not.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @return a Java input stream that delivers the database column value
     * as a stream of two byte Unicode characters.  If the value is SQL NULL
     * then the result is null.
     * @throws SQLException if an error occurs
     * @deprecated
     */
    @Deprecated
    public java.io.InputStream getUnicodeStream(int columnIndex) throws SQLException {
<span class="nc" id="L1270">        return crsInternal.getUnicodeStream(columnIndex);</span>
    }

    /**
     * A column value can be retrieved as a stream of uninterpreted bytes
     * and then read in chunks from the stream.  This method is particularly
     * suitable for retrieving large LONGVARBINARY values.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must be
     * read prior to getting the value of any other column. The next
     * call to a get method implicitly closes the stream. Also, a
     * stream may return 0 for available() whether there is data
     * available or not.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return a Java input stream that delivers the database column value
     * as a stream of uninterpreted bytes.  If the value is SQL NULL
     * then the result is null.
     * @throws SQLException if an error occurs
     */
    public java.io.InputStream getBinaryStream(int columnIndex) throws SQLException {
<span class="nc" id="L1293">        return crsInternal.getBinaryStream(columnIndex);</span>
    }

    // ColumnName methods

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;String&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public String getString(String columnName) throws SQLException {
<span class="nc" id="L1311">        return crsInternal.getString(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;boolean&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;false&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public boolean getBoolean(String columnName) throws SQLException {
<span class="nc" id="L1327">        return crsInternal.getBoolean(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;byte&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public byte getByte(String columnName) throws SQLException {
<span class="nc" id="L1343">        return crsInternal.getByte(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;short&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public short getShort(String columnName) throws SQLException {
<span class="nc" id="L1359">        return crsInternal.getShort(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as an &lt;code&gt;int&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public int getInt(String columnName) throws SQLException {
<span class="nc" id="L1375">        return crsInternal.getInt(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;long&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public long getLong(String columnName) throws SQLException {
<span class="nc" id="L1391">        return crsInternal.getLong(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;float&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public float getFloat(String columnName) throws SQLException {
<span class="nc" id="L1407">        return crsInternal.getFloat(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;double&lt;/code&gt; value.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;0&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public double getDouble(String columnName) throws SQLException {
<span class="nc" id="L1423">        return crsInternal.getDouble(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @param scale the number of digits to the right of the decimal point
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     * @deprecated use the method &lt;code&gt;getBigDecimal(String columnName)&lt;/code&gt;
     *             instead
     */
    @Deprecated
    public BigDecimal getBigDecimal(String columnName, int scale) throws SQLException {
<span class="nc" id="L1443">        return crsInternal.getBigDecimal(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a byte array.
     * The bytes represent the raw values returned by the driver.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public byte[] getBytes(String columnName) throws SQLException {
<span class="nc" id="L1460">        return crsInternal.getBytes(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.sql.Date&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public java.sql.Date getDate(String columnName) throws SQLException {
<span class="nc" id="L1476">        return crsInternal.getDate(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.sql.Time&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public java.sql.Time getTime(String columnName) throws SQLException {
<span class="nc" id="L1492">        return crsInternal.getTime(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public java.sql.Timestamp getTimestamp(String columnName) throws SQLException {
<span class="nc" id="L1508">        return crsInternal.getTimestamp(columnName);</span>
    }

    /**
     * This method is not supported, and it will throw an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if it is called.
     * &lt;P&gt;
     * A column value can be retrieved as a stream of ASCII characters
     * and then read in chunks from the stream.  This method is particularly
     * suitable for retrieving large LONGVARCHAR values.  The JDBC driver will
     * do any necessary conversion from the database format into ASCII format.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
     * be read prior to getting the value of any other column. The
     * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return a Java input stream that delivers the database column value
     *         as a stream of one-byte ASCII characters.  If the value is SQL
     *         &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
     * @throws UnsupportedOperationException if this method is called
     */
    public java.io.InputStream getAsciiStream(String columnName) throws SQLException {
<span class="nc" id="L1532">        return crsInternal.getAsciiStream(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
     * A column value can be retrieved as a stream of Unicode characters
     * and then read in chunks from the stream.  This method is particularly
     * suitable for retrieving large &lt;code&gt;LONGVARCHAR&lt;/code&gt; values.
     * The JDBC driver will do any necessary conversion from the database
     * format into Unicode.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
     * be read prior to getting the value of any other column. The
     * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return a Java input stream that delivers the database column value
     *         as a stream of two-byte Unicode characters.  If the value is
     *         SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     * @deprecated use the method &lt;code&gt;getCharacterStream&lt;/code&gt; instead
     */
    @Deprecated
    public java.io.InputStream getUnicodeStream(String columnName) throws SQLException {
<span class="nc" id="L1560">        return crsInternal.getUnicodeStream(columnName);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
     * A column value can be retrieved as a stream of uninterpreted bytes
     * and then read in chunks from the stream.  This method is particularly
     * suitable for retrieving large &lt;code&gt;LONGVARBINARY&lt;/code&gt; values.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
     * be read prior to getting the value of any other column. The
     * next call to a get method implicitly closes the stream.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return a Java input stream that delivers the database column value
     *         as a stream of uninterpreted bytes.  If the value is SQL
     *         &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
     * @throws SQLException if the given column name does not match one of
     *            this rowset's column names or the cursor is not on one of
     *            this rowset's rows or its insert row
     */
    public java.io.InputStream getBinaryStream(String columnName) throws SQLException {
<span class="nc" id="L1584">        return crsInternal.getBinaryStream(columnName);</span>
    }

    /* The first warning reported by calls on this &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     * object is returned. Subsequent &lt;code&gt;JoinRowSetImpl&lt;/code&gt; warnings will
     * be chained to this &lt;code&gt;SQLWarning&lt;/code&gt;.
     *
     * &lt;P&gt;The warning chain is automatically cleared each time a new
     * row is read.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; This warning chain only covers warnings caused
     * by &lt;code&gt;ResultSet&lt;/code&gt; methods.  Any warning caused by statement
     * methods (such as reading OUT parameters) will be chained on the
     * &lt;code&gt;Statement&lt;/code&gt; object.
     *
     * @return the first SQLWarning or null
     * @throws UnsupportedOperationException if this method is called
     */
    public SQLWarning getWarnings() {
<span class="nc" id="L1603">        return crsInternal.getWarnings();</span>
    }

    /**
     * Throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if called.
     * &lt;P&gt;
     * After a call to this method, the &lt;code&gt;getWarnings&lt;/code&gt; method
     * returns &lt;code&gt;null&lt;/code&gt; until a new warning is reported for this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * @throws UnsupportedOperationException if this method is called
     */
     public void clearWarnings() {
<span class="nc" id="L1616">        crsInternal.clearWarnings();</span>
<span class="nc" id="L1617">    }</span>

    /**
     * Retrieves the name of the SQL cursor used by this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * &lt;P&gt;In SQL, a result table is retrieved through a cursor that is
     * named. The current row of a result can be updated or deleted
     * using a positioned update/delete statement that references the
     * cursor name. To insure that the cursor has the proper isolation
     * level to support an update operation, the cursor's &lt;code&gt;SELECT&lt;/code&gt;
     * statement should be of the form 'select for update'. If the 'for update'
     * clause is omitted, positioned updates may fail.
     *
     * &lt;P&gt;JDBC supports this SQL feature by providing the name of the
     * SQL cursor used by a &lt;code&gt;ResultSet&lt;/code&gt; object. The current row
     * of a result set is also the current row of this SQL cursor.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; If positioned updates are not supported, an
     * &lt;code&gt;SQLException&lt;/code&gt; is thrown.
     *
     * @return the SQL cursor name for this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's
     *         cursor
     * @throws SQLException if an error occurs
     */
    public String getCursorName() throws SQLException {
<span class="nc" id="L1643">        return crsInternal.getCursorName();</span>
    }

    /**
     * Retrieves the &lt;code&gt;ResultSetMetaData&lt;/code&gt; object that contains
     * information about this &lt;code&gt;CachedRowsSet&lt;/code&gt; object. The
     * information includes the number of columns, the data type for each
     * column, and other properties for each column.
     *
     * @return the &lt;code&gt;ResultSetMetaData&lt;/code&gt; object that describes this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's columns
     * @throws SQLException if an error occurs
     */
    public ResultSetMetaData getMetaData() throws SQLException {
<span class="nc" id="L1657">        return crsInternal.getMetaData();</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * The type of the &lt;code&gt;Object&lt;/code&gt; will be the default
     * Java object type corresponding to the column's SQL type,
     * following the mapping for built-in types specified in the JDBC
     * specification.
     * &lt;P&gt;
     * This method may also be used to read datatabase-specific
     * abstract data types.
     * &lt;P&gt;
     * This implementation of the method &lt;code&gt;getObject&lt;/code&gt; extends its
     * behavior so that it gets the attributes of an SQL structured type as
     * as an array of &lt;code&gt;Object&lt;/code&gt; values.  This method also custom
     * maps SQL user-defined types to classes in the Java programming language.
     * When the specified column contains
     * a structured or distinct value, the behavior of this method is as
     * if it were a call to the method &lt;code&gt;getObject(columnIndex,
     * this.getStatement().getConnection().getTypeMap())&lt;/code&gt;.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return a &lt;code&gt;java.lang.Object&lt;/code&gt; holding the column value;
     *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or there is a problem getting
     *            the &lt;code&gt;Class&lt;/code&gt; object for a custom mapping
     * @since 1.2
     */
    public Object getObject(int columnIndex) throws SQLException {
<span class="nc" id="L1693">        return crsInternal.getObject(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * The type of the &lt;code&gt;Object&lt;/code&gt; will be the default
     * Java object type corresponding to the column's SQL type,
     * following the mapping for built-in types specified in the JDBC
     * specification.
     * &lt;P&gt;
     * This method may also be used to read datatabase-specific
     * abstract data types.
     * &lt;P&gt;
     * This implementation of the method &lt;code&gt;getObject&lt;/code&gt; extends its
     * behavior so that it gets the attributes of an SQL structured type as
     * as an array of &lt;code&gt;Object&lt;/code&gt; values.  This method also custom
     * maps SQL user-defined types to classes
     * in the Java programming language. When the specified column contains
     * a structured or distinct value, the behavior of this method is as
     * if it were a call to the method &lt;code&gt;getObject(columnIndex,
     * this.getStatement().getConnection().getTypeMap())&lt;/code&gt;.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *         is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *         and equal to or less than the number of columns in the rowset
     * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object showing the mapping
     *         from SQL type names to classes in the Java programming
     *         language
     * @return a &lt;code&gt;java.lang.Object&lt;/code&gt; holding the column value;
     *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is
     *         &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name does not match
     *         one of this rowset's column names, (2) the cursor is not
     *         on a valid row, or (3) there is a problem getting
     *         the &lt;code&gt;Class&lt;/code&gt; object for a custom mapping
     */
    public Object getObject(int columnIndex,
                            java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
    throws SQLException {
<span class="nc" id="L1735">        return crsInternal.getObject(columnIndex, map);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * The type of the &lt;code&gt;Object&lt;/code&gt; will be the default
     * Java object type corresponding to the column's SQL type,
     * following the mapping for built-in types specified in the JDBC
     * specification.
     * &lt;P&gt;
     * This method may also be used to read datatabase-specific
     * abstract data types.
     * &lt;P&gt;
     * This implementation of the method &lt;code&gt;getObject&lt;/code&gt; extends its
     * behavior so that it gets the attributes of an SQL structured type as
     * as an array of &lt;code&gt;Object&lt;/code&gt; values.  This method also custom
     * maps SQL user-defined types to classes
     * in the Java programming language. When the specified column contains
     * a structured or distinct value, the behavior of this method is as
     * if it were a call to the method &lt;code&gt;getObject(columnIndex,
     * this.getStatement().getConnection().getTypeMap())&lt;/code&gt;.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return a &lt;code&gt;java.lang.Object&lt;/code&gt; holding the column value;
     *        if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is
     *        &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name does not match
     *        one of this rowset's column names, (2) the cursor is not
     *        on a valid row, or (3) there is a problem getting
     *        the &lt;code&gt;Class&lt;/code&gt; object for a custom mapping
     */
    public Object getObject(String columnName) throws SQLException {
<span class="nc" id="L1771">        return crsInternal.getObject(columnName);</span>
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an &lt;code&gt;Object&lt;/code&gt; in
     * the Java programming lanugage, using the given
     * &lt;code&gt;java.util.Map&lt;/code&gt; object to custom map the value if
     * appropriate.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param map a &lt;code&gt;java.util.Map&lt;/code&gt; object showing the mapping
     *            from SQL type names to classes in the Java programming
     *            language
     * @return an &lt;code&gt;Object&lt;/code&gt; representing the SQL value
     * @throws SQLException if the given column index is out of bounds or
     *            the cursor is not on one of this rowset's rows or its
     *            insert row
     */
    public Object getObject(String columnName,
                            java.util.Map&lt;String,Class&lt;?&gt;&gt; map)
        throws SQLException {
<span class="nc" id="L1794">        return crsInternal.getObject(columnName, map);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.io.Reader&lt;/code&gt; object.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
     * be read prior to getting the value of any other column. The
     * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return a Java character stream that delivers the database column value
     *         as a &lt;code&gt;java.io.Reader&lt;/code&gt; object.  If the value is
     *         SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or there is a type mismatch
     */
    public java.io.Reader getCharacterStream(int columnIndex) throws SQLException {
<span class="nc" id="L1815">        return crsInternal.getCharacterStream(columnIndex);</span>
    }

    /**
     * Retrieves the value stored in the designated column
     * of the current row as a &lt;code&gt;java.io.Reader&lt;/code&gt; object.
     *
     * &lt;P&gt;&lt;B&gt;Note:&lt;/B&gt; All the data in the returned stream must
     * be read prior to getting the value of any other column. The
     * next call to a &lt;code&gt;getXXX&lt;/code&gt; method implicitly closes the stream.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the SQL name of
     *        a column in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @return a Java input stream that delivers the database column value
     *         as a stream of two-byte Unicode characters.  If the value is
     *         SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;.
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or there is a type mismatch
     */
    public java.io.Reader getCharacterStream(String columnName) throws SQLException {
<span class="nc" id="L1835">        return crsInternal.getCharacterStream(columnName);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @return a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; value with full precision;
     *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
<span class="nc" id="L1852">       return crsInternal.getBigDecimal(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return a &lt;code&gt;java.math.BigDecimal&lt;/code&gt; value with full precision;
     *         if the value is SQL &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if the given column index is out of bounds,
     *            the cursor is not on a valid row, or this method fails
     */
    public BigDecimal getBigDecimal(String columnName) throws SQLException {
<span class="nc" id="L1868">       return crsInternal.getBigDecimal(columnName);</span>
    }

    /**
     * Returns the number of rows in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * @return number of rows in the rowset
     */
    public int size() {
<span class="nc" id="L1877">        return crsInternal.size();</span>
    }

    /**
     * Indicates whether the cursor is before the first row in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is before the first row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if the rowset contains no rows
     * @throws SQLException if an error occurs
     */
    public boolean isBeforeFirst() throws SQLException {
<span class="nc" id="L1889">        return crsInternal.isBeforeFirst();</span>
    }

    /**
     * Indicates whether the cursor is after the last row in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is after the last row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if the rowset contains no rows
     * @throws SQLException if an error occurs
     */
    public boolean isAfterLast() throws SQLException {
<span class="nc" id="L1901">        return crsInternal.isAfterLast();</span>
    }

    /**
     * Indicates whether the cursor is on the first row in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on the first row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if the rowset contains no rows
     * @throws SQLException if an error occurs
     */
    public boolean isFirst() throws SQLException {
<span class="nc" id="L1913">        return crsInternal.isFirst();</span>
    }

    /**
     * Indicates whether the cursor is on the last row in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
     * &lt;P&gt;
     * Note: Calling the method &lt;code&gt;isLast&lt;/code&gt; may be expensive
     * because the JDBC driver might need to fetch ahead one row in order
     * to determine whether the current row is the last row in this rowset.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on the last row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if this rowset contains no rows
     * @throws SQLException if an error occurs
     */
    public boolean isLast() throws SQLException {
<span class="nc" id="L1929">        return crsInternal.isLast();</span>
    }

    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the front of
     * the rowset, just before the first row. This method has no effect if
     * this rowset contains no rows.
     *
     * @throws SQLException if an error occurs or the type of this rowset
     *            is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public void beforeFirst() throws SQLException {
<span class="nc" id="L1941">        crsInternal.beforeFirst();</span>
<span class="nc" id="L1942">    }</span>

    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the end of
     * the rowset, just after the last row. This method has no effect if
     * this rowset contains no rows.
     *
     * @throws SQLException if an error occurs
     */
    public void afterLast() throws SQLException {
<span class="nc" id="L1952">        crsInternal.afterLast();</span>
<span class="nc" id="L1953">    }</span>

    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the first row
     * and returns &lt;code&gt;true&lt;/code&gt; if the operation was successful.  This
     * method also notifies registered listeners that the cursor has moved.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a valid row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if there are no rows in this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @throws SQLException if the type of this rowset
     *            is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean first() throws SQLException {
<span class="nc" id="L1967">        return crsInternal.first();</span>
    }


    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the last row
     * and returns &lt;code&gt;true&lt;/code&gt; if the operation was successful.  This
     * method also notifies registered listeners that the cursor has moved.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a valid row;
     *         &lt;code&gt;false&lt;/code&gt; otherwise or if there are no rows in this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @throws SQLException if the type of this rowset
     *            is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean last() throws SQLException {
<span class="nc" id="L1983">        return crsInternal.last();</span>
    }

    /**
     * Returns the number of the current row in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     * object. The first row is number 1, the second number 2, and so on.
     *
     * @return the number of the current row;  &lt;code&gt;0&lt;/code&gt; if there is no
     *         current row
     * @throws SQLException if an error occurs
     */
    public int getRow() throws SQLException {
<span class="nc" id="L1995">        return crsInternal.getRow();</span>
    }

    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the row number
     * specified.
     *
     * &lt;p&gt;If the number is positive, the cursor moves to an absolute row with
     * respect to the beginning of the rowset.  The first row is row 1, the second
     * is row 2, and so on.  For example, the following command, in which
     * &lt;code&gt;crs&lt;/code&gt; is a &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object, moves the cursor
     * to the fourth row, starting from the beginning of the rowset.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.absolute(4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     * &lt;P&gt;
     * If the number is negative, the cursor moves to an absolute row position
     * with respect to the end of the rowset.  For example, calling
     * &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row,
     * &lt;code&gt;absolute(-2)&lt;/code&gt; moves it on the next-to-last row, and so on.
     * If the &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt; has five rows,
     * the following command moves the cursor to the fourth-to-last row, which
     * in the case of a  rowset with five rows, is also the second row, counting
     * from the beginning.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.absolute(-4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     *
     * If the number specified is larger than the number of rows, the cursor
     * will move to the position after the last row. If the number specified
     * would move the cursor one or more rows before the first row, the cursor
     * moves to the position before the first row.
     * &lt;P&gt;
     * Note: Calling &lt;code&gt;absolute(1)&lt;/code&gt; is the same as calling the
     * method &lt;code&gt;first()&lt;/code&gt;.  Calling &lt;code&gt;absolute(-1)&lt;/code&gt; is the
     * same as calling &lt;code&gt;last()&lt;/code&gt;.
     *
     * @param row a positive number to indicate the row, starting row numbering from
     *        the first row, which is &lt;code&gt;1&lt;/code&gt;; a negative number to indicate
     *        the row, starting row numbering from the last row, which is
     *        &lt;code&gt;-1&lt;/code&gt;; must not be &lt;code&gt;0&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on the rowset; &lt;code&gt;false&lt;/code&gt;
     *         otherwise
     * @throws SQLException if the given cursor position is &lt;code&gt;0&lt;/code&gt; or the
     *            type of this rowset is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean absolute(int row) throws SQLException {
<span class="nc" id="L2046">        return crsInternal.absolute(row);</span>
    }

    /**
     * Moves the cursor the specified number of rows from the current
     * position, with a positive number moving it forward and a
     * negative number moving it backward.
     * &lt;P&gt;
     * If the number is positive, the cursor moves the specified number of
     * rows toward the end of the rowset, starting at the current row.
     * For example, the following command, in which
     * &lt;code&gt;crs&lt;/code&gt; is a &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with 100 rows,
     * moves the cursor forward four rows from the current row.  If the
     * current row is 50, the cursor would move to row 54.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.relative(4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     * &lt;P&gt;
     * If the number is negative, the cursor moves back toward the beginning
     * the specified number of rows, starting at the current row.
     * For example, calling the method
     * &lt;code&gt;absolute(-1)&lt;/code&gt; positions the cursor on the last row,
     * &lt;code&gt;absolute(-2)&lt;/code&gt; moves it on the next-to-last row, and so on.
     * If the &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt; has five rows,
     * the following command moves the cursor to the fourth-to-last row, which
     * in the case of a  rowset with five rows, is also the second row
     * from the beginning.
     * &lt;PRE&gt;&lt;code&gt;
     *
     *    crs.absolute(-4);
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     *
     * If the number specified is larger than the number of rows, the cursor
     * will move to the position after the last row. If the number specified
     * would move the cursor one or more rows before the first row, the cursor
     * moves to the position before the first row. In both cases, this method
     * throws an &lt;code&gt;SQLException&lt;/code&gt;.
     * &lt;P&gt;
     * Note: Calling &lt;code&gt;absolute(1)&lt;/code&gt; is the same as calling the
     * method &lt;code&gt;first()&lt;/code&gt;.  Calling &lt;code&gt;absolute(-1)&lt;/code&gt; is the
     * same as calling &lt;code&gt;last()&lt;/code&gt;.  Calling &lt;code&gt;relative(0)&lt;/code&gt;
     * is valid, but it does not change the cursor position.
     *
     * @param rows an &lt;code&gt;int&lt;/code&gt; indicating the number of rows to move
     *             the cursor, starting at the current row; a positive number
     *             moves the cursor forward; a negative number moves the cursor
     *             backward; must not move the cursor past the valid
     *             rows
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a row in this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object; &lt;code&gt;false&lt;/code&gt;
     *         otherwise
     * @throws SQLException if there are no rows in this rowset, the cursor is
     *         positioned either before the first row or after the last row, or
     *         the rowset is type &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean relative(int rows) throws SQLException {
<span class="nc" id="L2105">        return crsInternal.relative(rows);</span>
    }

    /**
     * Moves this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's cursor to the
     * previous row and returns &lt;code&gt;true&lt;/code&gt; if the cursor is on
     * a valid row or &lt;code&gt;false&lt;/code&gt; if it is not.
     * This method also notifies all listeners registered with this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object that its cursor has moved.
     * &lt;P&gt;
     * Note: calling the method &lt;code&gt;previous()&lt;/code&gt; is not the same
     * as calling the method &lt;code&gt;relative(-1)&lt;/code&gt;.  This is true
     * because it is possible to call &lt;code&gt;previous()&lt;/code&gt; from the insert
     * row, from after the last row, or from the current row, whereas
     * &lt;code&gt;relative&lt;/code&gt; may only be called from the current row.
     * &lt;P&gt;
     * The method &lt;code&gt;previous&lt;/code&gt; may used in a &lt;code&gt;while&lt;/code&gt;
     * loop to iterate through a rowset starting after the last row
     * and moving toward the beginning. The loop ends when &lt;code&gt;previous&lt;/code&gt;
     * returns &lt;code&gt;false&lt;/code&gt;, meaning that there are no more rows.
     * For example, the following code fragment retrieves all the data in
     * the &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object &lt;code&gt;crs&lt;/code&gt;, which has
     * three columns.  Note that the cursor must initially be positioned
     * after the last row so that the first call to the method
     * &lt;code&gt;previous&lt;/code&gt; places the cursor on the last line.
     * &lt;PRE&gt; &lt;code&gt;
     *
     *     crs.afterLast();
     *     while (previous()) {
     *         String name = crs.getString(1);
     *         int age = crs.getInt(2);
     *         short ssn = crs.getShort(3);
     *         System.out.println(name + &quot;   &quot; + age + &quot;   &quot; + ssn);
     *     }
     *
     * &lt;/code&gt; &lt;/PRE&gt;
     * This method throws an &lt;code&gt;SQLException&lt;/code&gt; if the cursor is not
     * on a row in the rowset, before the first row, or after the last row.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the cursor is on a valid row;
     *         &lt;code&gt;false&lt;/code&gt; if it is before the first row or after the
     *         last row
     * @throws SQLException if the cursor is not on a valid position or the
     *           type of this rowset is &lt;code&gt;ResultSet.TYPE_FORWARD_ONLY&lt;/code&gt;
     */
    public boolean previous() throws SQLException {
<span class="nc" id="L2151">        return crsInternal.previous();</span>
    }

    /**
     * Returns the index of the column whose name is &lt;i&gt;columnName&lt;/i&gt;.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the
     *        column for which the index will be returned; the name must
     *        match the SQL name of a column in this &lt;code&gt;JoinRowSet&lt;/code&gt;
     *        object, ignoring case
     * @throws SQLException if the given column name does not match one of the
     *         column names for this &lt;code&gt;JoinRowSet&lt;/code&gt; object
     */
    public int findColumn(String columnName) throws SQLException {
<span class="nc" id="L2165">        return crsInternal.findColumn(columnName);</span>
    }

    /**
     * Indicates whether the current row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     * object has been updated.  The value returned
     * depends on whether this rowset can detect updates: &lt;code&gt;false&lt;/code&gt;
     * will always be returned if it does not detect updates.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the row has been visibly updated
     *         by the owner or another and updates are detected;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if the cursor is on the insert row or not
     *            on a valid row
     *
     * @see DatabaseMetaData#updatesAreDetected
     */
    public boolean rowUpdated() throws SQLException {
<span class="nc" id="L2183">        return crsInternal.rowUpdated();</span>
    }

    /**
     * Indicates whether the designated column of the current row of
     * this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object has been updated. The
     * value returned depends on whether this rowset can detcted updates:
     * &lt;code&gt;false&lt;/code&gt; will always be returned if it does not detect updates.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the column updated
     *          &lt;code&gt;false&lt;/code&gt; otherwse
     * @throws SQLException if the cursor is on the insert row or not
     *          on a valid row
     * @see DatabaseMetaData#updatesAreDetected
     */
    public boolean columnUpdated(int indexColumn) throws SQLException {
<span class="nc" id="L2199">        return crsInternal.columnUpdated(indexColumn);</span>
    }

    /**
     * Indicates whether the current row has been inserted.  The value returned
     * depends on whether or not the rowset can detect visible inserts.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if a row has been inserted and inserts are detected;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if the cursor is on the insert row or not
     *            not on a valid row
     *
     * @see DatabaseMetaData#insertsAreDetected
     */
    public boolean rowInserted() throws SQLException {
<span class="nc" id="L2214">        return crsInternal.rowInserted();</span>
    }

    /**
     * Indicates whether the current row has been deleted.  A deleted row
     * may leave a visible &quot;hole&quot; in a rowset.  This method can be used to
     * detect such holes if the rowset can detect deletions. This method
     * will always return &lt;code&gt;false&lt;/code&gt; if this rowset cannot detect
     * deletions.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if (1)the current row is blank, indicating that
     *         the row has been deleted, and (2)deletions are detected;
     *         &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if the cursor is on a valid row in this rowset
     * @see DatabaseMetaData#deletesAreDetected
     */
    public boolean rowDeleted() throws SQLException {
<span class="nc" id="L2231">        return crsInternal.rowDeleted();</span>
    }

    /**
     * Sets the designated nullable column in the current row or the
     * insert row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with
     * &lt;code&gt;null&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset; however, another method must be called to complete
     * the update process. If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to mark the row as updated
     * and to notify listeners that the row has changed.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called to insert the new row into this rowset and to notify
     * listeners that a row has changed.
     * &lt;P&gt;
     * In order to propagate updates in this rowset to the underlying
     * data source, an application must call the method acceptChanges
     * after it calls either &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;insertRow&lt;/code&gt;.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateNull(int columnIndex) throws SQLException {
<span class="nc" id="L2261">        crsInternal.updateNull(columnIndex);</span>
<span class="nc" id="L2262">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;boolean&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBoolean(int columnIndex, boolean x) throws SQLException {
<span class="nc" id="L2288">        crsInternal.updateBoolean(columnIndex, x);</span>
<span class="nc" id="L2289">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateByte(int columnIndex, byte x) throws SQLException {
<span class="nc" id="L2315">        crsInternal.updateByte(columnIndex, x);</span>
<span class="nc" id="L2316">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;short&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateShort(int columnIndex, short x) throws SQLException {
<span class="nc" id="L2342">        crsInternal.updateShort(columnIndex, x);</span>
<span class="nc" id="L2343">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;int&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateInt(int columnIndex, int x) throws SQLException {
<span class="nc" id="L2369">        crsInternal.updateInt(columnIndex, x);</span>
<span class="nc" id="L2370">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;long&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateLong(int columnIndex, long x) throws SQLException {
<span class="nc" id="L2396">        crsInternal.updateLong(columnIndex, x);</span>
<span class="nc" id="L2397">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;float&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateFloat(int columnIndex, float x) throws SQLException {
<span class="nc" id="L2423">        crsInternal.updateFloat(columnIndex, x);</span>
<span class="nc" id="L2424">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;double&lt;/code&gt; value.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateDouble(int columnIndex, double x) throws SQLException {
<span class="nc" id="L2450">        crsInternal.updateDouble(columnIndex, x);</span>
<span class="nc" id="L2451">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
<span class="nc" id="L2477">        crsInternal.updateBigDecimal(columnIndex, x);</span>
<span class="nc" id="L2478">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;String&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to mark the row as updated.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called to insert the new row into this rowset and mark it
     * as inserted. Both of these methods must be called before the
     * cursor moves to another row.
     * &lt;P&gt;
     * The method &lt;code&gt;acceptChanges&lt;/code&gt; must be called if the
     * updated values are to be written back to the underlying database.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateString(int columnIndex, String x) throws SQLException {
<span class="nc" id="L2507">        crsInternal.updateString(columnIndex, x);</span>
<span class="nc" id="L2508">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; array.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBytes(int columnIndex, byte x[]) throws SQLException {
<span class="nc" id="L2534">        crsInternal.updateBytes(columnIndex, x);</span>
<span class="nc" id="L2535">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Date&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the type of the designated column is not
     *            an SQL &lt;code&gt;DATE&lt;/code&gt; or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or
     *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateDate(int columnIndex, java.sql.Date x) throws SQLException {
<span class="nc" id="L2562">        crsInternal.updateDate(columnIndex, x);</span>
<span class="nc" id="L2563">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Time&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the type of the designated column is not
     *            an SQL &lt;code&gt;TIME&lt;/code&gt; or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or
     *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateTime(int columnIndex, java.sql.Time x) throws SQLException {
<span class="nc" id="L2590">        crsInternal.updateTime(columnIndex, x);</span>
<span class="nc" id="L2591">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the type of the designated column is not
     *            an SQL &lt;code&gt;DATE&lt;/code&gt;, &lt;code&gt;TIME&lt;/code&gt;, or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateTimestamp(int columnIndex, java.sql.Timestamp x) throws SQLException {
<span class="nc" id="L2619">        crsInternal.updateTimestamp(columnIndex, x);</span>
<span class="nc" id="L2620">    }</span>

    /*
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * ASCII stream value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @param length the number of one-byte ASCII characters in the stream
     * @throws UnsupportedOperationException if this method is invoked
     */
    public void updateAsciiStream(int columnIndex, java.io.InputStream x, int length) throws SQLException {
<span class="nc" id="L2644">        crsInternal.updateAsciiStream(columnIndex, x, length);</span>
<span class="nc" id="L2645">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value; must be a &lt;code&gt;java.io.InputStream&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;, or
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt; data
     * @param length the length of the stream in bytes
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the data in the stream is not binary, or
     *            (4) this rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBinaryStream(int columnIndex, java.io.InputStream x, int length) throws SQLException {
<span class="nc" id="L2674">        crsInternal.updateBinaryStream(columnIndex, x, length);</span>
<span class="nc" id="L2675">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.Reader&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value; must be a &lt;code&gt;java.io.Reader&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
     *          or &lt;code&gt;LONGVARCHAR&lt;/code&gt; data
     * @param length the length of the stream in characters
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, (3) the data in the stream is not a binary or
     *            character type, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateCharacterStream(int columnIndex, java.io.Reader x, int length) throws SQLException {
<span class="nc" id="L2706">        crsInternal.updateCharacterStream(columnIndex, x, length);</span>
<span class="nc" id="L2707">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.  The &lt;code&gt;scale&lt;/code&gt; parameter indicates
     * the number of digits to the right of the decimal point and is ignored
     * if the new column value is not a type that will be mapped to an SQL
     * &lt;code&gt;DECIMAL&lt;/code&gt; or &lt;code&gt;NUMERIC&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @param scale the number of digits to the right of the decimal point (for
     *              &lt;code&gt;DECIMAL&lt;/code&gt; and &lt;code&gt;NUMERIC&lt;/code&gt; types only)
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
<span class="nc" id="L2738">        crsInternal.updateObject(columnIndex, x, scale);</span>
<span class="nc" id="L2739">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param x the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateObject(int columnIndex, Object x) throws SQLException {
<span class="nc" id="L2765">        crsInternal.updateObject(columnIndex, x);</span>
<span class="nc" id="L2766">    }</span>

    // columnName updates

    /**
     * Sets the designated nullable column in the current row or the
     * insert row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with
     * &lt;code&gt;null&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateNull(String columnName) throws SQLException {
<span class="nc" id="L2791">        crsInternal.updateNull(columnName);</span>
<span class="nc" id="L2792">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;boolean&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBoolean(String columnName, boolean x) throws SQLException {
<span class="nc" id="L2817">        crsInternal.updateBoolean(columnName, x);</span>
<span class="nc" id="L2818">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateByte(String columnName, byte x) throws SQLException {
<span class="nc" id="L2843">        crsInternal.updateByte(columnName, x);</span>
<span class="nc" id="L2844">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;short&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateShort(String columnName, short x) throws SQLException {
<span class="nc" id="L2869">        crsInternal.updateShort(columnName, x);</span>
<span class="nc" id="L2870">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;int&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateInt(String columnName, int x) throws SQLException {
<span class="nc" id="L2895">        crsInternal.updateInt(columnName, x);</span>
<span class="nc" id="L2896">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;long&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateLong(String columnName, long x) throws SQLException {
<span class="nc" id="L2921">        crsInternal.updateLong(columnName, x);</span>
<span class="nc" id="L2922">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;float&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateFloat(String columnName, float x) throws SQLException {
<span class="nc" id="L2947">        crsInternal.updateFloat(columnName, x);</span>
<span class="nc" id="L2948">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;double&lt;/code&gt; value.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateDouble(String columnName, double x) throws SQLException {
<span class="nc" id="L2973">        crsInternal.updateDouble(columnName, x);</span>
<span class="nc" id="L2974">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.math.BigDecimal&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException {
<span class="nc" id="L2999">        crsInternal.updateBigDecimal(columnName, x);</span>
<span class="nc" id="L3000">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;String&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateString(String columnName, String x) throws SQLException {
<span class="nc" id="L3025">        crsInternal.updateString(columnName, x);</span>
<span class="nc" id="L3026">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;byte&lt;/code&gt; array.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBytes(String columnName, byte x[]) throws SQLException {
<span class="nc" id="L3051">        crsInternal.updateBytes(columnName, x);</span>
<span class="nc" id="L3052">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Date&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the type
     *            of the designated column is not an SQL &lt;code&gt;DATE&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateDate(String columnName, java.sql.Date x) throws SQLException {
<span class="nc" id="L3079">        crsInternal.updateDate(columnName, x);</span>
<span class="nc" id="L3080">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Time&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the type
     *            of the designated column is not an SQL &lt;code&gt;TIME&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateTime(String columnName, java.sql.Time x) throws SQLException {
<span class="nc" id="L3107">        crsInternal.updateTime(columnName, x);</span>
<span class="nc" id="L3108">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Timestamp&lt;/code&gt; object.
     *
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if the given column index is out of bounds or
     *            the cursor is not on one of this rowset's rows or its
     *            insert row
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the type
     *            of the designated column is not an SQL &lt;code&gt;DATE&lt;/code&gt;,
     *            &lt;code&gt;TIME&lt;/code&gt;, or &lt;code&gt;TIMESTAMP&lt;/code&gt;, or (4) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateTimestamp(String columnName, java.sql.Timestamp x) throws SQLException {
<span class="nc" id="L3138">        crsInternal.updateTimestamp(columnName, x);</span>
<span class="nc" id="L3139">    }</span>

    /**
     * Unsupported; throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;
     * if called.
     * &lt;P&gt;
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * ASCII stream value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @param length the number of one-byte ASCII characters in the stream
     * @throws UnsupportedOperationException if this method is invoked
     */
    public void updateAsciiStream(String columnName, java.io.InputStream x, int length) throws SQLException {
<span class="nc" id="L3165">        crsInternal.updateAsciiStream(columnName, x, length);</span>
<span class="nc" id="L3166">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.InputStream&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value; must be a &lt;code&gt;java.io.InputStream&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;, or
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt; data
     * @param length the length of the stream in bytes
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the data
     *            in the stream is not binary, or (4) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBinaryStream(String columnName, java.io.InputStream x, int length) throws SQLException {
<span class="nc" id="L3195">        crsInternal.updateBinaryStream(columnName, x, length);</span>
<span class="nc" id="L3196">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;java.io.Reader&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value; must be a &lt;code&gt;java.io.Reader&lt;/code&gt;
     *          containing &lt;code&gt;BINARY&lt;/code&gt;, &lt;code&gt;VARBINARY&lt;/code&gt;,
     *          &lt;code&gt;LONGVARBINARY&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt;, &lt;code&gt;VARCHAR&lt;/code&gt;,
     *          or &lt;code&gt;LONGVARCHAR&lt;/code&gt; data
     * @param length the length of the stream in characters
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, (3) the data
     *            in the stream is not a binary or character type, or (4) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateCharacterStream(String columnName, java.io.Reader x, int length) throws SQLException {
<span class="nc" id="L3226">        crsInternal.updateCharacterStream(columnName, x, length);</span>
<span class="nc" id="L3227">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.  The &lt;code&gt;scale&lt;/code&gt; parameter
     * indicates the number of digits to the right of the decimal point
     * and is ignored if the new column value is not a type that will be
     *  mapped to an SQL &lt;code&gt;DECIMAL&lt;/code&gt; or &lt;code&gt;NUMERIC&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @param scale the number of digits to the right of the decimal point (for
     *              &lt;code&gt;DECIMAL&lt;/code&gt; and &lt;code&gt;NUMERIC&lt;/code&gt; types only)
     * @throws SQLException if the given column index is out of bounds or
     *            the cursor is not on one of this rowset's rows or its
     *            insert row
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateObject(String columnName, Object x, int scale) throws SQLException {
<span class="nc" id="L3260">        crsInternal.updateObject(columnName, x, scale);</span>
<span class="nc" id="L3261">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Object&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in either the current row or
     * the insert row of this rowset, but it does not update the
     * database.  If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Both of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param x the new column value
     * @throws SQLException if (1) the given column name does not match the
     *            name of a column in this rowset, (2) the cursor is not on
     *            one of this rowset's rows or its insert row, or (3) this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateObject(String columnName, Object x) throws SQLException {
<span class="nc" id="L3286">        crsInternal.updateObject(columnName, x);</span>
<span class="nc" id="L3287">    }</span>

    /**
     * Inserts the contents of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's insert
     * row into this rowset immediately following the current row.
     * If the current row is the
     * position after the last row or before the first row, the new row will
     * be inserted at the end of the rowset.  This method also notifies
     * listeners registered with this rowset that the row has changed.
     * &lt;P&gt;
     * The cursor must be on the insert row when this method is called.
     *
     * @throws SQLException if (1) the cursor is not on the insert row,
     *            (2) one or more of the non-nullable columns in the insert
     *            row has not been given a value, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void insertRow() throws SQLException {
<span class="nc" id="L3305">        crsInternal.insertRow();</span>
<span class="nc" id="L3306">    }</span>

    /**
     * Marks the current row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as
     * updated and notifies listeners registered with this rowset that the
     * row has changed.
     * &lt;P&gt;
     * This method  cannot be called when the cursor is on the insert row, and
     * it should be called before the cursor moves to another row.  If it is
     * called after the cursor moves to another row, this method has no effect,
     * and the updates made before the cursor moved will be lost.
     *
     * @throws SQLException if the cursor is on the insert row or this
     *            rowset is &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateRow() throws SQLException {
<span class="nc" id="L3322">        crsInternal.updateRow();</span>
<span class="nc" id="L3323">    }</span>

    /**
     * Deletes the current row from this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object and
     * notifies listeners registered with this rowset that a row has changed.
     * This method cannot be called when the cursor is on the insert row.
     * &lt;P&gt;
     * This method marks the current row as deleted, but it does not delete
     * the row from the underlying data source.  The method
     * &lt;code&gt;acceptChanges&lt;/code&gt; must be called to delete the row in
     * the data source.
     *
     * @throws SQLException if (1) this method is called when the cursor
     *            is on the insert row, before the first row, or after the
     *            last row or (2) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void deleteRow() throws SQLException {
<span class="nc" id="L3341">        crsInternal.deleteRow();</span>
<span class="nc" id="L3342">    }</span>

    /**
     * Sets the current row with its original value and marks the row as
     * not updated, thus undoing any changes made to the row since the
     * last call to the methods &lt;code&gt;updateRow&lt;/code&gt; or &lt;code&gt;deleteRow&lt;/code&gt;.
     * This method should be called only when the cursor is on a row in
     * this rowset.
     *
     * @throws SQLException if the cursor is on the insert row, before the
     *            first row, or after the last row
     */
    public void refreshRow() throws SQLException {
<span class="nc" id="L3355">        crsInternal.refreshRow();</span>
<span class="nc" id="L3356">    }</span>

    /**
     * Rolls back any updates made to the current row of this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object and notifies listeners that
     * a row has changed.  To have an effect, this method
     * must be called after an &lt;code&gt;updateXXX&lt;/code&gt; method has been
     * called and before the method &lt;code&gt;updateRow&lt;/code&gt; has been called.
     * If no updates have been made or the method &lt;code&gt;updateRow&lt;/code&gt;
     * has already been called, this method has no effect.
     * &lt;P&gt;
     * After &lt;code&gt;updateRow&lt;/code&gt; is called it is the
     * &lt;code&gt;cancelRowUpdates&lt;/code&gt; has no affect on the newly
     * inserted values. The method &lt;code&gt;cancelRowInsert&lt;/code&gt; can
     * be used to remove any rows inserted into the RowSet.
     *
     * @throws SQLException if the cursor is on the insert row, before the
     *            first row, or after the last row
     */
    public void cancelRowUpdates() throws SQLException {
<span class="nc" id="L3376">        crsInternal.cancelRowUpdates();</span>
<span class="nc" id="L3377">    }</span>

    /**
     * Moves the cursor for this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * to the insert row.  The current row in the rowset is remembered
     * while the cursor is on the insert row.
     * &lt;P&gt;
     * The insert row is a special row associated with an updatable
     * rowset.  It is essentially a buffer where a new row may
     * be constructed by calling the appropriate &lt;code&gt;updateXXX&lt;/code&gt;
     * methods to assign a value to each column in the row.  A complete
     * row must be constructed; that is, every column that is not nullable
     * must be assigned a value.  In order for the new row to become part
     * of this rowset, the method &lt;code&gt;insertRow&lt;/code&gt; must be called
     * before the cursor is moved back to the rowset.
     * &lt;P&gt;
     * Only certain methods may be invoked while the cursor is on the insert
     * row; many methods throw an exception if they are called while the
     * cursor is there.  In addition to the &lt;code&gt;updateXXX&lt;/code&gt;
     * and &lt;code&gt;insertRow&lt;/code&gt; methods, only the &lt;code&gt;getXXX&lt;/code&gt; methods
     * may be called when the cursor is on the insert row.  A &lt;code&gt;getXXX&lt;/code&gt;
     * method should be called on a column only after an &lt;code&gt;updateXXX&lt;/code&gt;
     * method has been called on that column; otherwise, the value returned is
     * undetermined.
     *
     * @throws SQLException if this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void moveToInsertRow() throws SQLException {
<span class="nc" id="L3406">        crsInternal.moveToInsertRow();</span>
<span class="nc" id="L3407">    }</span>

    /**
     * Moves the cursor for this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object to
     * the current row.  The current row is the row the cursor was on
     * when the method &lt;code&gt;moveToInsertRow&lt;/code&gt; was called.
     * &lt;P&gt;
     * Calling this method has no effect unless it is called while the
     * cursor is on the insert row.
     *
     * @throws SQLException if an error occurs
     */
    public void moveToCurrentRow() throws SQLException {
<span class="nc" id="L3420">        crsInternal.moveToCurrentRow();</span>
<span class="nc" id="L3421">    }</span>

    /**
     * Returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if an error occurs
     */
    public Statement getStatement() throws SQLException {
<span class="nc" id="L3430">        return crsInternal.getStatement();</span>
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Ref&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @return a &lt;code&gt;Ref&lt;/code&gt; object representing an SQL&lt;code&gt; REF&lt;/code&gt; value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) the designated column does not store an
     *            SQL &lt;code&gt;REF&lt;/code&gt; value
     */
    public Ref getRef(int columnIndex) throws SQLException {
<span class="nc" id="L3448">        return crsInternal.getRef(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Blob&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @return a &lt;code&gt;Blob&lt;/code&gt; object representing an SQL &lt;code&gt;BLOB&lt;/code&gt; value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) the designated column does not store an
     *            SQL &lt;code&gt;BLOB&lt;/code&gt; value
     */
    public Blob getBlob(int columnIndex) throws SQLException {
<span class="nc" id="L3466">        return crsInternal.getBlob(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Clob&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @return a &lt;code&gt;Clob&lt;/code&gt; object representing an SQL &lt;code&gt;CLOB&lt;/code&gt; value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) the designated column does not store an
     *            SQL &lt;code&gt;CLOB&lt;/code&gt; value
     */
    public Clob getClob(int columnIndex) throws SQLException {
<span class="nc" id="L3484">        return crsInternal.getClob(columnIndex);</span>
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an &lt;code&gt;Array&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @return an &lt;code&gt;Array&lt;/code&gt; object representing an SQL
     *         &lt;code&gt;ARRAY&lt;/code&gt; value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) the designated column does not store an
     *            SQL &lt;code&gt;ARRAY&lt;/code&gt; value
     */
     public Array getArray(int columnIndex) throws SQLException {
<span class="nc" id="L3503">        return crsInternal.getArray(columnIndex);</span>
    }

    // ColumnName

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Ref&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return a &lt;code&gt;Ref&lt;/code&gt; object representing an SQL&lt;code&gt; REF&lt;/code&gt; value
     * @throws SQLException  if (1) the given column name is not the name
     *         of a column in this rowset, (2) the cursor is not on one of
     *         this rowset's rows or its insert row, or (3) the column value
     *         is not an SQL &lt;code&gt;REF&lt;/code&gt; value
     */
    public Ref getRef(String columnName) throws SQLException {
<span class="nc" id="L3522">        return crsInternal.getRef(columnName);</span>
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Blob&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return a &lt;code&gt;Blob&lt;/code&gt; object representing an SQL
     *        &lt;code&gt;BLOB&lt;/code&gt; value
     * @throws SQLException if (1) the given column name is not the name of
     *        a column in this rowset, (2) the cursor is not on one of
     *        this rowset's rows or its insert row, or (3) the designated
     *        column does not store an SQL &lt;code&gt;BLOB&lt;/code&gt; value
     */
    public Blob getBlob(String columnName) throws SQLException {
<span class="nc" id="L3540">        return crsInternal.getBlob(columnName);</span>
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;Clob&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return a &lt;code&gt;Clob&lt;/code&gt; object representing an SQL
     *         &lt;code&gt;CLOB&lt;/code&gt; value
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;CLOB&lt;/code&gt; value
     */
    public Clob getClob(String columnName) throws SQLException {
<span class="nc" id="L3558">        return crsInternal.getClob(columnName);</span>
    }

    /**
     * Retrieves the value of the designated column in this
     * &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as an &lt;code&gt;Array&lt;/code&gt; object
     * in the Java programming lanugage.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @return an &lt;code&gt;Array&lt;/code&gt; object representing an SQL
     *        &lt;code&gt;ARRAY&lt;/code&gt; value
     * @throws SQLException if (1) the given column name is not the name of
     *        a column in this rowset, (2) the cursor is not on one of
     *        this rowset's rows or its insert row, or (3) the designated
     *        column does not store an SQL &lt;code&gt;ARRAY&lt;/code&gt; value
     */
    public Array getArray(String columnName) throws SQLException {
<span class="nc" id="L3576">        return crsInternal.getArray(columnName);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Date&lt;/code&gt;
     * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
     * appropriate millisecond value for the date.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;DATE&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Date getDate(int columnIndex, Calendar cal) throws SQLException {
<span class="nc" id="L3599">        return crsInternal.getDate(columnIndex, cal);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Date&lt;/code&gt;
     * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
     * appropriate millisecond value for the date.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;DATE&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Date getDate(String columnName, Calendar cal) throws SQLException {
<span class="nc" id="L3621">        return crsInternal.getDate(columnName, cal);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Time&lt;/code&gt;
     * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
     * appropriate millisecond value for the date.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;TIME&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Time getTime(int columnIndex, Calendar cal) throws SQLException {
<span class="nc" id="L3644">        return crsInternal.getTime(columnIndex, cal);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Time&lt;/code&gt;
     * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
     * appropriate millisecond value for the date.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;TIME&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Time getTime(String columnName, Calendar cal) throws SQLException {
<span class="nc" id="L3666">        return crsInternal.getTime(columnName, cal);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a &lt;code&gt;java.sql.Timestamp&lt;/code&gt;
     * object, using the given &lt;code&gt;Calendar&lt;/code&gt; object to construct an
     * appropriate millisecond value for the date.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in the rowset
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;TIME&lt;/code&gt; or
     *            &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLException {
<span class="nc" id="L3689">        return crsInternal.getTimestamp(columnIndex, cal);</span>
    }

    /**
     * Retrieves the value of the designated column in the current row
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object as a
     * &lt;code&gt;java.sql.Timestamp&lt;/code&gt; object, using the given
     * &lt;code&gt;Calendar&lt;/code&gt; object to construct an appropriate
     * millisecond value for the date.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object that must match the
     *        SQL name of a column in this rowset, ignoring case
     * @param cal the &lt;code&gt;java.util.Calendar&lt;/code&gt; object to use in
     *            constructing the date
     * @return the column value; if the value is SQL &lt;code&gt;NULL&lt;/code&gt;,
     *         the result is &lt;code&gt;null&lt;/code&gt;
     * @throws SQLException if (1) the given column name is not the name of
     *            a column in this rowset, (2) the cursor is not on one of
     *            this rowset's rows or its insert row, or (3) the designated
     *            column does not store an SQL &lt;code&gt;DATE&lt;/code&gt;,
     *            &lt;code&gt;TIME&lt;/code&gt;, or &lt;code&gt;TIMESTAMP&lt;/code&gt; value
     */
    public java.sql.Timestamp getTimestamp(String columnName, Calendar cal) throws SQLException {
<span class="nc" id="L3712">        return crsInternal.getTimestamp(columnName, cal);</span>
    }

   /**
    * Sets the metadata for this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
    * with the given &lt;code&gt;RowSetMetaData&lt;/code&gt; object.
    *
    * @param md a &lt;code&gt;RowSetMetaData&lt;/code&gt; object instance containing
    *            metadata about the columsn in the rowset
    * @throws SQLException if invalid meta data is supplied to the
    *            rowset
    */
    public void setMetaData(RowSetMetaData md) throws SQLException {
<span class="nc" id="L3725">        crsInternal.setMetaData(md);</span>
<span class="nc" id="L3726">    }</span>

    public ResultSet getOriginal() throws SQLException {
<span class="nc" id="L3729">        return crsInternal.getOriginal();</span>
    }

   /**
    * Returns a result set containing the original value of the rowset.
    * The cursor is positioned before the first row in the result set.
    * Only rows contained in the result set returned by getOriginal()
    * are said to have an original value.
    *
    * @return the original result set of the rowset
    * @throws SQLException if an error occurs produce the
    *           &lt;code&gt;ResultSet&lt;/code&gt; object
    */
    public ResultSet getOriginalRow() throws SQLException {
<span class="nc" id="L3743">        return crsInternal.getOriginalRow();</span>
    }

   /**
    * Returns a result set containing the original value of the current
    * row only.
    *
    * @throws SQLException if there is no current row
    * @see #setOriginalRow
    */
    public void setOriginalRow() throws SQLException {
<span class="nc" id="L3754">        crsInternal.setOriginalRow();</span>
<span class="nc" id="L3755">    }</span>

   /**
    * Returns the columns that make a key to uniquely identify a
    * row in this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object.
    *
    * @return an array of column number that constites a primary
    *           key for this rowset. This array should be empty
    *           if no columns is representitive of a primary key
    * @throws SQLException if the rowset is empty or no columns
    *           are designated as primary keys
    * @see #setKeyColumns
    */
    public int[] getKeyColumns() throws SQLException {
<span class="nc" id="L3769">        return crsInternal.getKeyColumns();</span>
    }

    /**
     * Sets this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's
     * &lt;code&gt;keyCols&lt;/code&gt; field with the given array of column
     * numbers, which forms a key for uniquely identifying a row
     * in this rowset.
     *
     * @param cols an array of &lt;code&gt;int&lt;/code&gt; indicating the
     *        columns that form a primary key for this
     *        &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object; every
     *        element in the array must be greater than
     *        &lt;code&gt;0&lt;/code&gt; and less than or equal to the number
     *        of columns in this rowset
     * @throws SQLException if any of the numbers in the
     *            given array is not valid for this rowset
     * @see #getKeyColumns
     */
    public void setKeyColumns(int[] cols) throws SQLException {
<span class="nc" id="L3789">        crsInternal.setKeyColumns(cols);</span>
<span class="nc" id="L3790">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Ref&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param ref the &lt;code&gt;java.sql.Ref&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateRef(int columnIndex, java.sql.Ref ref) throws SQLException {
<span class="nc" id="L3817">        crsInternal.updateRef(columnIndex, ref);</span>
<span class="nc" id="L3818">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Ref&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the column
     *        to be updated; must match one of the column names in this
     *        &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @param ref the &lt;code&gt;java.sql.Ref&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column name is not valid,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateRef(String columnName, java.sql.Ref ref) throws SQLException {
<span class="nc" id="L3845">        crsInternal.updateRef(columnName, ref);</span>
<span class="nc" id="L3846">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Clob&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param c the &lt;code&gt;java.sql.Clob&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateClob(int columnIndex, Clob c) throws SQLException {
<span class="nc" id="L3873">        crsInternal.updateClob(columnIndex, c);</span>
<span class="nc" id="L3874">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Clob&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the column
     *        to be updated; must match one of the column names in this
     *        &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @param c the &lt;code&gt;java.sql.Clob&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column name is not valid,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateClob(String columnName, Clob c) throws SQLException {
<span class="nc" id="L3901">        crsInternal.updateClob(columnName, c);</span>
<span class="nc" id="L3902">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Blob&lt;/code&gt; value.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param b the &lt;code&gt;java.sql.Blob&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBlob(int columnIndex, Blob b) throws SQLException {
<span class="nc" id="L3929">         crsInternal.updateBlob(columnIndex, b);</span>
<span class="nc" id="L3930">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Blob&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the column
     *        to be updated; must match one of the column names in this
     *        &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @param b the &lt;code&gt;java.sql.Blob&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column name is not valid,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateBlob(String columnName, Blob b) throws SQLException {
<span class="nc" id="L3957">         crsInternal.updateBlob(columnName, b);</span>
<span class="nc" id="L3958">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Array&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnIndex the first column is &lt;code&gt;1&lt;/code&gt;, the second
     *        is &lt;code&gt;2&lt;/code&gt;, and so on; must be &lt;code&gt;1&lt;/code&gt; or larger
     *        and equal to or less than the number of columns in this rowset
     * @param a the &lt;code&gt;java.sql.Array&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column index is out of bounds,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateArray(int columnIndex, Array a) throws SQLException {
<span class="nc" id="L3985">         crsInternal.updateArray(columnIndex, a);</span>
<span class="nc" id="L3986">    }</span>

    /**
     * Sets the designated column in either the current row or the insert
     * row of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with the given
     * &lt;code&gt;Array&lt;/code&gt; object.
     * &lt;P&gt;
     * This method updates a column value in the current row or the insert
     * row of this rowset, but it does not update the database.
     * If the cursor is on a row in the rowset, the
     * method {@link #updateRow} must be called to update the database.
     * If the cursor is on the insert row, the method {@link #insertRow}
     * must be called, which will insert the new row into both this rowset
     * and the database. Either of these methods must be called before the
     * cursor moves to another row.
     *
     * @param columnName a &lt;code&gt;String&lt;/code&gt; object giving the name of the column
     *        to be updated; must match one of the column names in this
     *        &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @param a the &lt;code&gt;java.sql.Array&lt;/code&gt; object that will be set as
     *         the new column value
     * @throws SQLException if (1) the given column name is not valid,
     *            (2) the cursor is not on one of this rowset's rows or its
     *            insert row, or (3) this rowset is
     *            &lt;code&gt;ResultSet.CONCUR_READ_ONLY&lt;/code&gt;
     */
    public void updateArray(String columnName, Array a) throws SQLException {
<span class="nc" id="L4013">         crsInternal.updateArray(columnName, a);</span>
<span class="nc" id="L4014">    }</span>

    /**
     * Populates this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with data.
     * This form of the method uses the rowset's user, password, and url or
     * data source name properties to create a database
     * connection.  If properties that are needed
     * have not been set, this method will throw an exception.
     * &lt;P&gt;
     * Another form of this method uses an existing JDBC &lt;code&gt;Connection&lt;/code&gt;
     * object instead of creating a new one; therefore, it ignores the
     * properties used for establishing a new connection.
     * &lt;P&gt;
     * The query specified by the command property is executed to create a
     * &lt;code&gt;ResultSet&lt;/code&gt; object from which to retrieve data.
     * The current contents of the rowset are discarded, and the
     * rowset's metadata is also (re)set.  If there are outstanding updates,
     * they are also ignored.
     * &lt;P&gt;
     * The method &lt;code&gt;execute&lt;/code&gt; closes any database connections that it
     * creates.
     *
     * @throws SQLException if an error occurs or the
     *                         necessary properties have not been set
     */
    public void execute() throws SQLException {
<span class="nc" id="L4040">        crsInternal.execute();</span>
<span class="nc" id="L4041">    }</span>

    /**
     * Populates this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object with data,
     * using the given connection to produce the result set from
     * which data will be read.  A second form of this method,
     * which takes no arguments, uses the values from this rowset's
     * user, password, and either url or data source properties to
     * create a new database connection. The form of &lt;code&gt;execute&lt;/code&gt;
     * that is given a connection ignores these properties.
     *
     *  @param conn A standard JDBC &lt;code&gt;Connection&lt;/code&gt; object with valid
     *           properties that the &lt;code&gt;JoinRowSet&lt;/code&gt; implementation
     *           can pass to a synchronization provider to establish a
     *           connection to the datasource
     * @throws SQLException if an invalid &lt;code&gt;Connection&lt;/code&gt; is supplied
     *           or an error occurs in establishing the connection to the
     *           data soure
     * @see java.sql.Connection
     */
    public void execute(Connection conn) throws SQLException {
<span class="nc" id="L4062">        crsInternal.execute(conn);</span>
<span class="nc" id="L4063">    }</span>

    /**
     * Provide interface coverage for getURL(int) in ResultSet-&gt;RowSet
     */
    public java.net.URL getURL(int columnIndex) throws SQLException {
<span class="nc" id="L4069">        return crsInternal.getURL(columnIndex);</span>
    }

    /**
     * Provide interface coverage for getURL(String) in ResultSet-&gt;RowSet
     */
    public java.net.URL getURL(String columnName) throws SQLException {
<span class="nc" id="L4076">        return crsInternal.getURL(columnName);</span>
    }

   /**
    * Creates a new &lt;code&gt;WebRowSet&lt;/code&gt; object, populates it with the
    * data in the given &lt;code&gt;ResultSet&lt;/code&gt; object, and writes it
    * to the given &lt;code&gt;java.io.Writer&lt;/code&gt; object in XML format.
    *
    * @throws SQLException if an error occurs writing out the rowset
    *          contents to XML
    */
    public void writeXml(ResultSet rs, java.io.Writer writer)
        throws SQLException {
<span class="nc" id="L4089">             wrs = new WebRowSetImpl();</span>
<span class="nc" id="L4090">             wrs.populate(rs);</span>
<span class="nc" id="L4091">             wrs.writeXml(writer);</span>
<span class="nc" id="L4092">    }</span>

    /**
     * Writes this &lt;code&gt;JoinRowSet&lt;/code&gt; object to the given
     * &lt;code&gt;java.io.Writer&lt;/code&gt; object in XML format. In
     * addition to the rowset's data, its properties and metadata
     * are also included.
     *
     * @throws SQLException if an error occurs writing out the rowset
     *          contents to XML
     */
    public void writeXml(java.io.Writer writer) throws SQLException {
<span class="nc" id="L4104">        createWebRowSet().writeXml(writer);</span>
<span class="nc" id="L4105">}</span>

    /**
     * Reads this &lt;code&gt;JoinRowSet&lt;/code&gt; object in its XML format.
     *
     * @throws SQLException if a database access error occurs
     */
    public void readXml(java.io.Reader reader) throws SQLException {
<span class="nc" id="L4113">        wrs = new WebRowSetImpl();</span>
<span class="nc" id="L4114">        wrs.readXml(reader);</span>
<span class="nc" id="L4115">        crsInternal = (CachedRowSetImpl)wrs;</span>
<span class="nc" id="L4116">    }</span>

    // Stream based methods
    /**
     * Reads a stream based XML input to populate an &lt;code&gt;WebRowSet&lt;/code&gt;
     *
     * @throws SQLException if a data source access occurs
     * @throws IOException if a IO exception occurs
     */
    public void readXml(java.io.InputStream iStream) throws SQLException, IOException {
<span class="nc" id="L4126">         wrs = new WebRowSetImpl();</span>
<span class="nc" id="L4127">         wrs.readXml(iStream);</span>
<span class="nc" id="L4128">         crsInternal = (CachedRowSetImpl)wrs;</span>
<span class="nc" id="L4129">    }</span>

    /**
     * Creates an an output stream of the internal state and contents of a
     * &lt;code&gt;WebRowSet&lt;/code&gt; for XML proceessing
     *
     * @throws SQLException if a datasource access occurs
     * @throws IOException if an IO exception occurs
     */
    public void writeXml(java.io.OutputStream oStream) throws SQLException, IOException {
<span class="nc" id="L4139">         createWebRowSet().writeXml(oStream);</span>
<span class="nc" id="L4140">    }</span>

    /**
     * Creates a new &lt;code&gt;WebRowSet&lt;/code&gt; object, populates it with
     * the contents of the &lt;code&gt;ResultSet&lt;/code&gt; and creates an output
     * streams the internal state and contents of the rowset for XML processing.
     *
     * @throws SQLException if a datasource access occurs
     * @throws IOException if an IO exception occurs
     */
    public void writeXml(ResultSet rs, java.io.OutputStream oStream) throws SQLException, IOException {
<span class="nc" id="L4151">             wrs = new WebRowSetImpl();</span>
<span class="nc" id="L4152">             wrs.populate(rs);</span>
<span class="nc" id="L4153">             wrs.writeXml(oStream);</span>
<span class="nc" id="L4154">    }</span>

    /**
     * %%% Javadoc comments to be added here
     */
    private WebRowSet createWebRowSet() throws SQLException {
<span class="nc bnc" id="L4160" title="All 2 branches missed.">       if(wrs != null) {</span>
           // check if it has already been initialized.
<span class="nc" id="L4162">           return wrs;</span>
       } else {
<span class="nc" id="L4164">         wrs = new WebRowSetImpl();</span>
<span class="nc" id="L4165">          crsInternal.beforeFirst();</span>
<span class="nc" id="L4166">          wrs.populate(crsInternal);</span>
<span class="nc" id="L4167">          return wrs;</span>
       }
    }

    /**
     * Returns the last set SQL &lt;code&gt;JOIN&lt;/code&gt; type in this JoinRowSetImpl
     * object
     *
     * @return joinType One of the standard JoinRowSet static field JOIN types
     * @throws SQLException if an error occurs determining the current join type
     */
    public int getJoinType() throws SQLException {
<span class="nc bnc" id="L4179" title="All 2 branches missed.">        if (vecJoinType == null) {</span>
            // Default JoinRowSet type
<span class="nc" id="L4181">            this.setJoinType(JoinRowSet.INNER_JOIN);</span>
        }
<span class="nc" id="L4183">        Integer i = vecJoinType.get(vecJoinType.size()-1);</span>
<span class="nc" id="L4184">        return i.intValue();</span>
    }

    /**
    * The listener will be notified whenever an event occurs on this &lt;code&gt;JoinRowSet&lt;/code&gt;
    * object.
    * &lt;P&gt;
    * A listener might, for example, be a table or graph that needs to
    * be updated in order to accurately reflect the current state of
    * the &lt;code&gt;RowSet&lt;/code&gt; object.
    * &lt;p&gt;
    * &lt;b&gt;Note&lt;/b&gt;: if the &lt;code&gt;RowSetListener&lt;/code&gt; object is
    * &lt;code&gt;null&lt;/code&gt;, this method silently discards the &lt;code&gt;null&lt;/code&gt;
    * value and does not add a null reference to the set of listeners.
    * &lt;p&gt;
    * &lt;b&gt;Note&lt;/b&gt;: if the listener is already set, and the new &lt;code&gt;RowSetListerner&lt;/code&gt;
    * instance is added to the set of listeners already registered to receive
    * event notifications from this &lt;code&gt;RowSet&lt;/code&gt;.
    *
    * @param listener an object that has implemented the
    *     &lt;code&gt;javax.sql.RowSetListener&lt;/code&gt; interface and wants to be notified
    *     of any events that occur on this &lt;code&gt;JoinRowSet&lt;/code&gt; object; May be
    *     null.
    * @see #removeRowSetListener
    */
    public void addRowSetListener(RowSetListener listener) {
<span class="nc" id="L4210">        crsInternal.addRowSetListener(listener);</span>
<span class="nc" id="L4211">    }</span>

    /**
    * Removes the designated object from this &lt;code&gt;JoinRowSet&lt;/code&gt; object's list of listeners.
    * If the given argument is not a registered listener, this method
    * does nothing.
    *
    *  &lt;b&gt;Note&lt;/b&gt;: if the &lt;code&gt;RowSetListener&lt;/code&gt; object is
    * &lt;code&gt;null&lt;/code&gt;, this method silently discards the &lt;code&gt;null&lt;/code&gt;
    * value.
    *
    * @param listener a &lt;code&gt;RowSetListener&lt;/code&gt; object that is on the list
    *        of listeners for this &lt;code&gt;JoinRowSet&lt;/code&gt; object
    * @see #addRowSetListener
    */
     public void removeRowSetListener(RowSetListener listener) {
<span class="nc" id="L4227">        crsInternal.removeRowSetListener(listener);</span>
<span class="nc" id="L4228">    }</span>

    /**
     * Converts this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object to a collection
     * of tables. The sample implementation utilitizes the &lt;code&gt;TreeMap&lt;/code&gt;
     * collection type.
     * This class guarantees that the map will be in ascending key order,
     * sorted according to the natural order for the key's class.
     *
     * @return a &lt;code&gt;Collection&lt;/code&gt; object consisting of tables,
     *         each of which is a copy of a row in this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * @throws SQLException if an error occurs in generating the collection
     * @see #toCollection(int)
     * @see #toCollection(String)
     * @see java.util.TreeMap
     */
     public Collection&lt;?&gt; toCollection() throws SQLException {
<span class="nc" id="L4246">        return crsInternal.toCollection();</span>
    }

    /**
     * Returns the specified column of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * as a &lt;code&gt;Collection&lt;/code&gt; object.  This method makes a copy of the
     * column's data and utilitizes the &lt;code&gt;Vector&lt;/code&gt; to establish the
     * collection. The &lt;code&gt;Vector&lt;/code&gt; class implements a growable array
     * objects allowing the individual components to be accessed using an
     * an integer index similar to that of an array.
     *
     * @return a &lt;code&gt;Collection&lt;/code&gt; object that contains the value(s)
     *         stored in the specified column of this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     *         object
     * @throws SQLException if an error occurs generated the collection; or
     *          an invalid column is provided.
     * @see #toCollection()
     * @see #toCollection(String)
     * @see java.util.Vector
     */
    public Collection&lt;?&gt; toCollection(int column) throws SQLException {
<span class="nc" id="L4268">        return crsInternal.toCollection(column);</span>
    }

    /**
     * Returns the specified column of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object
     * as a &lt;code&gt;Collection&lt;/code&gt; object.  This method makes a copy of the
     * column's data and utilitizes the &lt;code&gt;Vector&lt;/code&gt; to establish the
     * collection. The &lt;code&gt;Vector&lt;/code&gt; class implements a growable array
     * objects allowing the individual components to be accessed using an
     * an integer index similar to that of an array.
     *
     * @return a &lt;code&gt;Collection&lt;/code&gt; object that contains the value(s)
     *         stored in the specified column of this
     *         &lt;code&gt;JoinRowSetImpl&lt;/code&gt;
     *         object
     * @throws SQLException if an error occurs generated the collection; or
     *          an invalid column is provided.
     * @see #toCollection()
     * @see #toCollection(int)
     * @see java.util.Vector
     */
    public Collection&lt;?&gt; toCollection(String column) throws SQLException {
<span class="nc" id="L4290">        return crsInternal.toCollection(column);</span>
    }

    /**
     * Creates a &lt;code&gt;RowSet&lt;/code&gt; object that is a copy of
     * this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's table structure
     * and the constraints only.
     * There will be no data in the object being returned.
     * Updates made on a copy are not visible to the original rowset.
     * &lt;P&gt;
     * This helps in getting the underlying XML schema which can
     * be used as the basis for populating a &lt;code&gt;WebRowSet&lt;/code&gt;.
     *
     * @return a new &lt;code&gt;CachedRowSet&lt;/code&gt; object that is a copy
     * of this &lt;code&gt;JoinRowSetImpl&lt;/code&gt; object's schema and
     * retains all the constraints on the original rowset but contains
     * no data
     * @throws SQLException if an error occurs in generating the copy
     * of the &lt;code&gt;CachedRowSet&lt;/code&gt; object
     * @see #createShared
     * @see #createCopy
     * @see #createCopyNoConstraints
     * @see javax.sql.RowSetEvent
     * @see javax.sql.RowSetListener
     */
     public CachedRowSet createCopySchema() throws SQLException {
<span class="nc" id="L4316">         return crsInternal.createCopySchema();</span>
     }

     /**
      * {@inheritDoc}
      */
     public void setSyncProvider(String providerStr) throws SQLException {
<span class="nc" id="L4323">         crsInternal.setSyncProvider(providerStr);</span>
<span class="nc" id="L4324">     }</span>

     /**
      * {@inheritDoc}
      */
     public void acceptChanges() throws SyncProviderException {
<span class="nc" id="L4330">         crsInternal.acceptChanges();</span>
<span class="nc" id="L4331">     }</span>

     /**
      * {@inheritDoc}
      */
     public SyncProvider getSyncProvider() throws SQLException {
<span class="nc" id="L4337">        return crsInternal.getSyncProvider();</span>
     }

    /**
     * This method re populates the resBundle
     * during the deserialization process
     *
     */
     private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        // Default state initialization happens here
<span class="nc" id="L4347">        ois.defaultReadObject();</span>
        // Initialization of transient Res Bundle happens here .
        try {
<span class="nc" id="L4350">           resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();</span>
<span class="nc" id="L4351">        } catch(IOException ioe) {</span>
<span class="nc" id="L4352">            throw new RuntimeException(ioe);</span>
<span class="nc" id="L4353">        }</span>

<span class="nc" id="L4355">     }</span>

     static final long serialVersionUID = -5590501621560008453L;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>