<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Subject.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.security.auth</a> &gt; <span class="el_source">Subject.java</span></div><h1>Subject.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.security.auth;

import java.util.*;
import java.io.*;
import java.lang.reflect.*;
import java.text.MessageFormat;
import java.security.AccessController;
import java.security.AccessControlContext;
import java.security.DomainCombiner;
import java.security.Permission;
import java.security.PermissionCollection;
import java.security.Principal;
import java.security.PrivilegedAction;
import java.security.PrivilegedExceptionAction;
import java.security.PrivilegedActionException;
import java.security.ProtectionDomain;
import sun.security.util.ResourcesMgr;

/**
 * &lt;p&gt; A {@code Subject} represents a grouping of related information
 * for a single entity, such as a person.
 * Such information includes the Subject's identities as well as
 * its security-related attributes
 * (passwords and cryptographic keys, for example).
 *
 * &lt;p&gt; Subjects may potentially have multiple identities.
 * Each identity is represented as a {@code Principal}
 * within the {@code Subject}.  Principals simply bind names to a
 * {@code Subject}.  For example, a {@code Subject} that happens
 * to be a person, Alice, might have two Principals:
 * one which binds &quot;Alice Bar&quot;, the name on her driver license,
 * to the {@code Subject}, and another which binds,
 * &quot;999-99-9999&quot;, the number on her student identification card,
 * to the {@code Subject}.  Both Principals refer to the same
 * {@code Subject} even though each has a different name.
 *
 * &lt;p&gt; A {@code Subject} may also own security-related attributes,
 * which are referred to as credentials.
 * Sensitive credentials that require special protection, such as
 * private cryptographic keys, are stored within a private credential
 * {@code Set}.  Credentials intended to be shared, such as
 * public key certificates or Kerberos server tickets are stored
 * within a public credential {@code Set}.  Different permissions
 * are required to access and modify the different credential Sets.
 *
 * &lt;p&gt; To retrieve all the Principals associated with a {@code Subject},
 * invoke the {@code getPrincipals} method.  To retrieve
 * all the public or private credentials belonging to a {@code Subject},
 * invoke the {@code getPublicCredentials} method or
 * {@code getPrivateCredentials} method, respectively.
 * To modify the returned {@code Set} of Principals and credentials,
 * use the methods defined in the {@code Set} class.
 * For example:
 * &lt;pre&gt;
 *      Subject subject;
 *      Principal principal;
 *      Object credential;
 *
 *      // add a Principal and credential to the Subject
 *      subject.getPrincipals().add(principal);
 *      subject.getPublicCredentials().add(credential);
 * &lt;/pre&gt;
 *
 * &lt;p&gt; This {@code Subject} class implements {@code Serializable}.
 * While the Principals associated with the {@code Subject} are serialized,
 * the credentials associated with the {@code Subject} are not.
 * Note that the {@code java.security.Principal} class
 * does not implement {@code Serializable}.  Therefore all concrete
 * {@code Principal} implementations associated with Subjects
 * must implement {@code Serializable}.
 *
 * @see java.security.Principal
 * @see java.security.DomainCombiner
 */
public final class Subject implements java.io.Serializable {

    private static final long serialVersionUID = -8308522755600156056L;

    /**
     * A {@code Set} that provides a view of all of this
     * Subject's Principals
     *
     * &lt;p&gt;
     *
     * @serial Each element in this set is a
     *          {@code java.security.Principal}.
     *          The set is a {@code Subject.SecureSet}.
     */
    Set&lt;Principal&gt; principals;

    /**
     * Sets that provide a view of all of this
     * Subject's Credentials
     */
    transient Set&lt;Object&gt; pubCredentials;
    transient Set&lt;Object&gt; privCredentials;

    /**
     * Whether this Subject is read-only
     *
     * @serial
     */
<span class="fc" id="L128">    private volatile boolean readOnly = false;</span>

    private static final int PRINCIPAL_SET = 1;
    private static final int PUB_CREDENTIAL_SET = 2;
    private static final int PRIV_CREDENTIAL_SET = 3;

<span class="fc" id="L134">    private static final ProtectionDomain[] NULL_PD_ARRAY</span>
        = new ProtectionDomain[0];

    /**
     * Create an instance of a {@code Subject}
     * with an empty {@code Set} of Principals and empty
     * Sets of public and private credentials.
     *
     * &lt;p&gt; The newly constructed Sets check whether this {@code Subject}
     * has been set read-only before permitting subsequent modifications.
     * The newly created Sets also prevent illegal modifications
     * by ensuring that callers have sufficient permissions.
     *
     * &lt;p&gt; To modify the Principals Set, the caller must have
     * {@code AuthPermission(&quot;modifyPrincipals&quot;)}.
     * To modify the public credential Set, the caller must have
     * {@code AuthPermission(&quot;modifyPublicCredentials&quot;)}.
     * To modify the private credential Set, the caller must have
     * {@code AuthPermission(&quot;modifyPrivateCredentials&quot;)}.
     */
<span class="fc" id="L154">    public Subject() {</span>

<span class="fc" id="L156">        this.principals = Collections.synchronizedSet</span>
<span class="fc" id="L157">                        (new SecureSet&lt;Principal&gt;(this, PRINCIPAL_SET));</span>
<span class="fc" id="L158">        this.pubCredentials = Collections.synchronizedSet</span>
<span class="fc" id="L159">                        (new SecureSet&lt;Object&gt;(this, PUB_CREDENTIAL_SET));</span>
<span class="fc" id="L160">        this.privCredentials = Collections.synchronizedSet</span>
<span class="fc" id="L161">                        (new SecureSet&lt;Object&gt;(this, PRIV_CREDENTIAL_SET));</span>
<span class="fc" id="L162">    }</span>

    /**
     * Create an instance of a {@code Subject} with
     * Principals and credentials.
     *
     * &lt;p&gt; The Principals and credentials from the specified Sets
     * are copied into newly constructed Sets.
     * These newly created Sets check whether this {@code Subject}
     * has been set read-only before permitting subsequent modifications.
     * The newly created Sets also prevent illegal modifications
     * by ensuring that callers have sufficient permissions.
     *
     * &lt;p&gt; To modify the Principals Set, the caller must have
     * {@code AuthPermission(&quot;modifyPrincipals&quot;)}.
     * To modify the public credential Set, the caller must have
     * {@code AuthPermission(&quot;modifyPublicCredentials&quot;)}.
     * To modify the private credential Set, the caller must have
     * {@code AuthPermission(&quot;modifyPrivateCredentials&quot;)}.
     * &lt;p&gt;
     *
     * @param readOnly true if the {@code Subject} is to be read-only,
     *          and false otherwise. &lt;p&gt;
     *
     * @param principals the {@code Set} of Principals
     *          to be associated with this {@code Subject}. &lt;p&gt;
     *
     * @param pubCredentials the {@code Set} of public credentials
     *          to be associated with this {@code Subject}. &lt;p&gt;
     *
     * @param privCredentials the {@code Set} of private credentials
     *          to be associated with this {@code Subject}.
     *
     * @exception NullPointerException if the specified
     *          {@code principals}, {@code pubCredentials},
     *          or {@code privCredentials} are {@code null}.
     */
    public Subject(boolean readOnly, Set&lt;? extends Principal&gt; principals,
                   Set&lt;?&gt; pubCredentials, Set&lt;?&gt; privCredentials)
<span class="fc" id="L201">    {</span>

<span class="pc bpc" id="L203" title="2 of 6 branches missed.">        if (principals == null ||</span>
            pubCredentials == null ||
            privCredentials == null)
<span class="fc" id="L206">            throw new NullPointerException</span>
<span class="fc" id="L207">                (ResourcesMgr.getString(&quot;invalid.null.input.s.&quot;));</span>

<span class="fc" id="L209">        this.principals = Collections.synchronizedSet(new SecureSet&lt;Principal&gt;</span>
                                (this, PRINCIPAL_SET, principals));
<span class="fc" id="L211">        this.pubCredentials = Collections.synchronizedSet(new SecureSet&lt;Object&gt;</span>
                                (this, PUB_CREDENTIAL_SET, pubCredentials));
<span class="fc" id="L213">        this.privCredentials = Collections.synchronizedSet(new SecureSet&lt;Object&gt;</span>
                                (this, PRIV_CREDENTIAL_SET, privCredentials));
<span class="fc" id="L215">        this.readOnly = readOnly;</span>
<span class="fc" id="L216">    }</span>

    /**
     * Set this {@code Subject} to be read-only.
     *
     * &lt;p&gt; Modifications (additions and removals) to this Subject's
     * {@code Principal} {@code Set} and
     * credential Sets will be disallowed.
     * The {@code destroy} operation on this Subject's credentials will
     * still be permitted.
     *
     * &lt;p&gt; Subsequent attempts to modify the Subject's {@code Principal}
     * and credential Sets will result in an
     * {@code IllegalStateException} being thrown.
     * Also, once a {@code Subject} is read-only,
     * it can not be reset to being writable again.
     *
     * &lt;p&gt;
     *
     * @exception SecurityException if the caller does not have permission
     *          to set this {@code Subject} to be read-only.
     */
    public void setReadOnly() {
<span class="fc" id="L239">        java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">        if (sm != null) {</span>
<span class="fc" id="L241">            sm.checkPermission(AuthPermissionHolder.SET_READ_ONLY_PERMISSION);</span>
        }

<span class="fc" id="L244">        this.readOnly = true;</span>
<span class="fc" id="L245">    }</span>

    /**
     * Query whether this {@code Subject} is read-only.
     *
     * &lt;p&gt;
     *
     * @return true if this {@code Subject} is read-only, false otherwise.
     */
    public boolean isReadOnly() {
<span class="fc" id="L255">        return this.readOnly;</span>
    }

    /**
     * Get the {@code Subject} associated with the provided
     * {@code AccessControlContext}.
     *
     * &lt;p&gt; The {@code AccessControlContext} may contain many
     * Subjects (from nested {@code doAs} calls).
     * In this situation, the most recent {@code Subject} associated
     * with the {@code AccessControlContext} is returned.
     *
     * &lt;p&gt;
     *
     * @param  acc the {@code AccessControlContext} from which to retrieve
     *          the {@code Subject}.
     *
     * @return  the {@code Subject} associated with the provided
     *          {@code AccessControlContext}, or {@code null}
     *          if no {@code Subject} is associated
     *          with the provided {@code AccessControlContext}.
     *
     * @exception SecurityException if the caller does not have permission
     *          to get the {@code Subject}. &lt;p&gt;
     *
     * @exception NullPointerException if the provided
     *          {@code AccessControlContext} is {@code null}.
     */
    public static Subject getSubject(final AccessControlContext acc) {

<span class="fc" id="L285">        java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (sm != null) {</span>
<span class="fc" id="L287">            sm.checkPermission(AuthPermissionHolder.GET_SUBJECT_PERMISSION);</span>
        }

<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (acc == null) {</span>
<span class="fc" id="L291">            throw new NullPointerException(ResourcesMgr.getString</span>
<span class="fc" id="L292">                (&quot;invalid.null.AccessControlContext.provided&quot;));</span>
        }

        // return the Subject from the DomainCombiner of the provided context
<span class="fc" id="L296">        return AccessController.doPrivileged</span>
<span class="fc" id="L297">            (new java.security.PrivilegedAction&lt;Subject&gt;() {</span>
            public Subject run() {
<span class="fc" id="L299">                DomainCombiner dc = acc.getDomainCombiner();</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                if (!(dc instanceof SubjectDomainCombiner))</span>
<span class="fc" id="L301">                    return null;</span>
<span class="fc" id="L302">                SubjectDomainCombiner sdc = (SubjectDomainCombiner)dc;</span>
<span class="fc" id="L303">                return sdc.getSubject();</span>
            }
        });
    }

    /**
     * Perform work as a particular {@code Subject}.
     *
     * &lt;p&gt; This method first retrieves the current Thread's
     * {@code AccessControlContext} via
     * {@code AccessController.getContext},
     * and then instantiates a new {@code AccessControlContext}
     * using the retrieved context along with a new
     * {@code SubjectDomainCombiner} (constructed using
     * the provided {@code Subject}).
     * Finally, this method invokes {@code AccessController.doPrivileged},
     * passing it the provided {@code PrivilegedAction},
     * as well as the newly constructed {@code AccessControlContext}.
     *
     * &lt;p&gt;
     *
     * @param subject the {@code Subject} that the specified
     *                  {@code action} will run as.  This parameter
     *                  may be {@code null}. &lt;p&gt;
     *
     * @param &lt;T&gt; the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     *
     * @param action the code to be run as the specified
     *                  {@code Subject}. &lt;p&gt;
     *
     * @return the value returned by the PrivilegedAction's
     *                  {@code run} method.
     *
     * @exception NullPointerException if the {@code PrivilegedAction}
     *                  is {@code null}. &lt;p&gt;
     *
     * @exception SecurityException if the caller does not have permission
     *                  to invoke this method.
     */
    public static &lt;T&gt; T doAs(final Subject subject,
                        final java.security.PrivilegedAction&lt;T&gt; action) {

<span class="fc" id="L346">        java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">        if (sm != null) {</span>
<span class="fc" id="L348">            sm.checkPermission(AuthPermissionHolder.DO_AS_PERMISSION);</span>
        }
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (action == null)</span>
<span class="fc" id="L351">            throw new NullPointerException</span>
<span class="fc" id="L352">                (ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));</span>

        // set up the new Subject-based AccessControlContext
        // for doPrivileged
<span class="fc" id="L356">        final AccessControlContext currentAcc = AccessController.getContext();</span>

        // call doPrivileged and push this new context on the stack
<span class="fc" id="L359">        return java.security.AccessController.doPrivileged</span>
<span class="fc" id="L360">                                        (action,</span>
<span class="fc" id="L361">                                        createContext(subject, currentAcc));</span>
    }

    /**
     * Perform work as a particular {@code Subject}.
     *
     * &lt;p&gt; This method first retrieves the current Thread's
     * {@code AccessControlContext} via
     * {@code AccessController.getContext},
     * and then instantiates a new {@code AccessControlContext}
     * using the retrieved context along with a new
     * {@code SubjectDomainCombiner} (constructed using
     * the provided {@code Subject}).
     * Finally, this method invokes {@code AccessController.doPrivileged},
     * passing it the provided {@code PrivilegedExceptionAction},
     * as well as the newly constructed {@code AccessControlContext}.
     *
     * &lt;p&gt;
     *
     * @param subject the {@code Subject} that the specified
     *                  {@code action} will run as.  This parameter
     *                  may be {@code null}. &lt;p&gt;
     *
     * @param &lt;T&gt; the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     *
     * @param action the code to be run as the specified
     *                  {@code Subject}. &lt;p&gt;
     *
     * @return the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     *
     * @exception PrivilegedActionException if the
     *                  {@code PrivilegedExceptionAction.run}
     *                  method throws a checked exception. &lt;p&gt;
     *
     * @exception NullPointerException if the specified
     *                  {@code PrivilegedExceptionAction} is
     *                  {@code null}. &lt;p&gt;
     *
     * @exception SecurityException if the caller does not have permission
     *                  to invoke this method.
     */
    public static &lt;T&gt; T doAs(final Subject subject,
                        final java.security.PrivilegedExceptionAction&lt;T&gt; action)
                        throws java.security.PrivilegedActionException {

<span class="fc" id="L408">        java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">        if (sm != null) {</span>
<span class="fc" id="L410">            sm.checkPermission(AuthPermissionHolder.DO_AS_PERMISSION);</span>
        }

<span class="pc bpc" id="L413" title="1 of 2 branches missed.">        if (action == null)</span>
<span class="nc" id="L414">            throw new NullPointerException</span>
<span class="nc" id="L415">                (ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));</span>

        // set up the new Subject-based AccessControlContext for doPrivileged
<span class="fc" id="L418">        final AccessControlContext currentAcc = AccessController.getContext();</span>

        // call doPrivileged and push this new context on the stack
<span class="fc" id="L421">        return java.security.AccessController.doPrivileged</span>
<span class="fc" id="L422">                                        (action,</span>
<span class="fc" id="L423">                                        createContext(subject, currentAcc));</span>
    }

    /**
     * Perform privileged work as a particular {@code Subject}.
     *
     * &lt;p&gt; This method behaves exactly as {@code Subject.doAs},
     * except that instead of retrieving the current Thread's
     * {@code AccessControlContext}, it uses the provided
     * {@code AccessControlContext}.  If the provided
     * {@code AccessControlContext} is {@code null},
     * this method instantiates a new {@code AccessControlContext}
     * with an empty collection of ProtectionDomains.
     *
     * &lt;p&gt;
     *
     * @param subject the {@code Subject} that the specified
     *                  {@code action} will run as.  This parameter
     *                  may be {@code null}. &lt;p&gt;
     *
     * @param &lt;T&gt; the type of the value returned by the PrivilegedAction's
     *                  {@code run} method.
     *
     * @param action the code to be run as the specified
     *                  {@code Subject}. &lt;p&gt;
     *
     * @param acc the {@code AccessControlContext} to be tied to the
     *                  specified &lt;i&gt;subject&lt;/i&gt; and &lt;i&gt;action&lt;/i&gt;. &lt;p&gt;
     *
     * @return the value returned by the PrivilegedAction's
     *                  {@code run} method.
     *
     * @exception NullPointerException if the {@code PrivilegedAction}
     *                  is {@code null}. &lt;p&gt;
     *
     * @exception SecurityException if the caller does not have permission
     *                  to invoke this method.
     */
    public static &lt;T&gt; T doAsPrivileged(final Subject subject,
                        final java.security.PrivilegedAction&lt;T&gt; action,
                        final java.security.AccessControlContext acc) {

<span class="fc" id="L465">        java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (sm != null) {</span>
<span class="fc" id="L467">            sm.checkPermission(AuthPermissionHolder.DO_AS_PRIVILEGED_PERMISSION);</span>
        }

<span class="pc bpc" id="L470" title="1 of 2 branches missed.">        if (action == null)</span>
<span class="nc" id="L471">            throw new NullPointerException</span>
<span class="nc" id="L472">                (ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));</span>

        // set up the new Subject-based AccessControlContext
        // for doPrivileged
<span class="pc bpc" id="L476" title="1 of 2 branches missed.">        final AccessControlContext callerAcc =</span>
                (acc == null ?
                new AccessControlContext(NULL_PD_ARRAY) :
                acc);

        // call doPrivileged and push this new context on the stack
<span class="fc" id="L482">        return java.security.AccessController.doPrivileged</span>
<span class="fc" id="L483">                                        (action,</span>
<span class="fc" id="L484">                                        createContext(subject, callerAcc));</span>
    }

    /**
     * Perform privileged work as a particular {@code Subject}.
     *
     * &lt;p&gt; This method behaves exactly as {@code Subject.doAs},
     * except that instead of retrieving the current Thread's
     * {@code AccessControlContext}, it uses the provided
     * {@code AccessControlContext}.  If the provided
     * {@code AccessControlContext} is {@code null},
     * this method instantiates a new {@code AccessControlContext}
     * with an empty collection of ProtectionDomains.
     *
     * &lt;p&gt;
     *
     * @param subject the {@code Subject} that the specified
     *                  {@code action} will run as.  This parameter
     *                  may be {@code null}. &lt;p&gt;
     *
     * @param &lt;T&gt; the type of the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     *
     * @param action the code to be run as the specified
     *                  {@code Subject}. &lt;p&gt;
     *
     * @param acc the {@code AccessControlContext} to be tied to the
     *                  specified &lt;i&gt;subject&lt;/i&gt; and &lt;i&gt;action&lt;/i&gt;. &lt;p&gt;
     *
     * @return the value returned by the
     *                  PrivilegedExceptionAction's {@code run} method.
     *
     * @exception PrivilegedActionException if the
     *                  {@code PrivilegedExceptionAction.run}
     *                  method throws a checked exception. &lt;p&gt;
     *
     * @exception NullPointerException if the specified
     *                  {@code PrivilegedExceptionAction} is
     *                  {@code null}. &lt;p&gt;
     *
     * @exception SecurityException if the caller does not have permission
     *                  to invoke this method.
     */
    public static &lt;T&gt; T doAsPrivileged(final Subject subject,
                        final java.security.PrivilegedExceptionAction&lt;T&gt; action,
                        final java.security.AccessControlContext acc)
                        throws java.security.PrivilegedActionException {

<span class="nc" id="L532">        java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">        if (sm != null) {</span>
<span class="nc" id="L534">            sm.checkPermission(AuthPermissionHolder.DO_AS_PRIVILEGED_PERMISSION);</span>
        }

<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (action == null)</span>
<span class="nc" id="L538">            throw new NullPointerException</span>
<span class="nc" id="L539">                (ResourcesMgr.getString(&quot;invalid.null.action.provided&quot;));</span>

        // set up the new Subject-based AccessControlContext for doPrivileged
<span class="nc bnc" id="L542" title="All 2 branches missed.">        final AccessControlContext callerAcc =</span>
                (acc == null ?
                new AccessControlContext(NULL_PD_ARRAY) :
                acc);

        // call doPrivileged and push this new context on the stack
<span class="nc" id="L548">        return java.security.AccessController.doPrivileged</span>
<span class="nc" id="L549">                                        (action,</span>
<span class="nc" id="L550">                                        createContext(subject, callerAcc));</span>
    }

    private static AccessControlContext createContext(final Subject subject,
                                        final AccessControlContext acc) {


<span class="fc" id="L557">        return java.security.AccessController.doPrivileged</span>
<span class="fc" id="L558">            (new java.security.PrivilegedAction&lt;AccessControlContext&gt;() {</span>
            public AccessControlContext run() {
<span class="fc bfc" id="L560" title="All 2 branches covered.">                if (subject == null)</span>
<span class="fc" id="L561">                    return new AccessControlContext(acc, null);</span>
                else
<span class="fc" id="L563">                    return new AccessControlContext</span>
                                        (acc,
                                        new SubjectDomainCombiner(subject));
            }
        });
    }

    /**
     * Return the {@code Set} of Principals associated with this
     * {@code Subject}.  Each {@code Principal} represents
     * an identity for this {@code Subject}.
     *
     * &lt;p&gt; The returned {@code Set} is backed by this Subject's
     * internal {@code Principal} {@code Set}.  Any modification
     * to the returned {@code Set} affects the internal
     * {@code Principal} {@code Set} as well.
     *
     * &lt;p&gt;
     *
     * @return  The {@code Set} of Principals associated with this
     *          {@code Subject}.
     */
    public Set&lt;Principal&gt; getPrincipals() {

        // always return an empty Set instead of null
        // so LoginModules can add to the Set if necessary
<span class="fc" id="L589">        return principals;</span>
    }

    /**
     * Return a {@code Set} of Principals associated with this
     * {@code Subject} that are instances or subclasses of the specified
     * {@code Class}.
     *
     * &lt;p&gt; The returned {@code Set} is not backed by this Subject's
     * internal {@code Principal} {@code Set}.  A new
     * {@code Set} is created and returned for each method invocation.
     * Modifications to the returned {@code Set}
     * will not affect the internal {@code Principal} {@code Set}.
     *
     * &lt;p&gt;
     *
     * @param &lt;T&gt; the type of the class modeled by {@code c}
     *
     * @param c the returned {@code Set} of Principals will all be
     *          instances of this class.
     *
     * @return a {@code Set} of Principals that are instances of the
     *          specified {@code Class}.
     *
     * @exception NullPointerException if the specified {@code Class}
     *                  is {@code null}.
     */
    public &lt;T extends Principal&gt; Set&lt;T&gt; getPrincipals(Class&lt;T&gt; c) {

<span class="fc bfc" id="L618" title="All 2 branches covered.">        if (c == null)</span>
<span class="fc" id="L619">            throw new NullPointerException</span>
<span class="fc" id="L620">                (ResourcesMgr.getString(&quot;invalid.null.Class.provided&quot;));</span>

        // always return an empty Set instead of null
        // so LoginModules can add to the Set if necessary
<span class="fc" id="L624">        return new ClassSet&lt;T&gt;(PRINCIPAL_SET, c);</span>
    }

    /**
     * Return the {@code Set} of public credentials held by this
     * {@code Subject}.
     *
     * &lt;p&gt; The returned {@code Set} is backed by this Subject's
     * internal public Credential {@code Set}.  Any modification
     * to the returned {@code Set} affects the internal public
     * Credential {@code Set} as well.
     *
     * &lt;p&gt;
     *
     * @return  A {@code Set} of public credentials held by this
     *          {@code Subject}.
     */
    public Set&lt;Object&gt; getPublicCredentials() {

        // always return an empty Set instead of null
        // so LoginModules can add to the Set if necessary
<span class="fc" id="L645">        return pubCredentials;</span>
    }

    /**
     * Return the {@code Set} of private credentials held by this
     * {@code Subject}.
     *
     * &lt;p&gt; The returned {@code Set} is backed by this Subject's
     * internal private Credential {@code Set}.  Any modification
     * to the returned {@code Set} affects the internal private
     * Credential {@code Set} as well.
     *
     * &lt;p&gt; A caller requires permissions to access the Credentials
     * in the returned {@code Set}, or to modify the
     * {@code Set} itself.  A {@code SecurityException}
     * is thrown if the caller does not have the proper permissions.
     *
     * &lt;p&gt; While iterating through the {@code Set},
     * a {@code SecurityException} is thrown
     * if the caller does not have permission to access a
     * particular Credential.  The {@code Iterator}
     * is nevertheless advanced to next element in the {@code Set}.
     *
     * &lt;p&gt;
     *
     * @return  A {@code Set} of private credentials held by this
     *          {@code Subject}.
     */
    public Set&lt;Object&gt; getPrivateCredentials() {

        // XXX
        // we do not need a security check for
        // AuthPermission(getPrivateCredentials)
        // because we already restrict access to private credentials
        // via the PrivateCredentialPermission.  all the extra AuthPermission
        // would do is protect the set operations themselves
        // (like size()), which don't seem security-sensitive.

        // always return an empty Set instead of null
        // so LoginModules can add to the Set if necessary
<span class="fc" id="L685">        return privCredentials;</span>
    }

    /**
     * Return a {@code Set} of public credentials associated with this
     * {@code Subject} that are instances or subclasses of the specified
     * {@code Class}.
     *
     * &lt;p&gt; The returned {@code Set} is not backed by this Subject's
     * internal public Credential {@code Set}.  A new
     * {@code Set} is created and returned for each method invocation.
     * Modifications to the returned {@code Set}
     * will not affect the internal public Credential {@code Set}.
     *
     * &lt;p&gt;
     *
     * @param &lt;T&gt; the type of the class modeled by {@code c}
     *
     * @param c the returned {@code Set} of public credentials will all be
     *          instances of this class.
     *
     * @return a {@code Set} of public credentials that are instances
     *          of the  specified {@code Class}.
     *
     * @exception NullPointerException if the specified {@code Class}
     *          is {@code null}.
     */
    public &lt;T&gt; Set&lt;T&gt; getPublicCredentials(Class&lt;T&gt; c) {

<span class="nc bnc" id="L714" title="All 2 branches missed.">        if (c == null)</span>
<span class="nc" id="L715">            throw new NullPointerException</span>
<span class="nc" id="L716">                (ResourcesMgr.getString(&quot;invalid.null.Class.provided&quot;));</span>

        // always return an empty Set instead of null
        // so LoginModules can add to the Set if necessary
<span class="nc" id="L720">        return new ClassSet&lt;T&gt;(PUB_CREDENTIAL_SET, c);</span>
    }

    /**
     * Return a {@code Set} of private credentials associated with this
     * {@code Subject} that are instances or subclasses of the specified
     * {@code Class}.
     *
     * &lt;p&gt; The caller must have permission to access all of the
     * requested Credentials, or a {@code SecurityException}
     * will be thrown.
     *
     * &lt;p&gt; The returned {@code Set} is not backed by this Subject's
     * internal private Credential {@code Set}.  A new
     * {@code Set} is created and returned for each method invocation.
     * Modifications to the returned {@code Set}
     * will not affect the internal private Credential {@code Set}.
     *
     * &lt;p&gt;
     *
     * @param &lt;T&gt; the type of the class modeled by {@code c}
     *
     * @param c the returned {@code Set} of private credentials will all be
     *          instances of this class.
     *
     * @return a {@code Set} of private credentials that are instances
     *          of the  specified {@code Class}.
     *
     * @exception NullPointerException if the specified {@code Class}
     *          is {@code null}.
     */
    public &lt;T&gt; Set&lt;T&gt; getPrivateCredentials(Class&lt;T&gt; c) {

        // XXX
        // we do not need a security check for
        // AuthPermission(getPrivateCredentials)
        // because we already restrict access to private credentials
        // via the PrivateCredentialPermission.  all the extra AuthPermission
        // would do is protect the set operations themselves
        // (like size()), which don't seem security-sensitive.

<span class="pc bpc" id="L761" title="1 of 2 branches missed.">        if (c == null)</span>
<span class="nc" id="L762">            throw new NullPointerException</span>
<span class="nc" id="L763">                (ResourcesMgr.getString(&quot;invalid.null.Class.provided&quot;));</span>

        // always return an empty Set instead of null
        // so LoginModules can add to the Set if necessary
<span class="fc" id="L767">        return new ClassSet&lt;T&gt;(PRIV_CREDENTIAL_SET, c);</span>
    }

    /**
     * Compares the specified Object with this {@code Subject}
     * for equality.  Returns true if the given object is also a Subject
     * and the two {@code Subject} instances are equivalent.
     * More formally, two {@code Subject} instances are
     * equal if their {@code Principal} and {@code Credential}
     * Sets are equal.
     *
     * &lt;p&gt;
     *
     * @param o Object to be compared for equality with this
     *          {@code Subject}.
     *
     * @return true if the specified Object is equal to this
     *          {@code Subject}.
     *
     * @exception SecurityException if the caller does not have permission
     *          to access the private credentials for this {@code Subject},
     *          or if the caller does not have permission to access the
     *          private credentials for the provided {@code Subject}.
     */
    public boolean equals(Object o) {

<span class="pc bpc" id="L793" title="1 of 2 branches missed.">        if (o == null)</span>
<span class="nc" id="L794">            return false;</span>

<span class="pc bpc" id="L796" title="1 of 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L797">            return true;</span>

<span class="pc bpc" id="L799" title="1 of 2 branches missed.">        if (o instanceof Subject) {</span>

<span class="fc" id="L801">            final Subject that = (Subject)o;</span>

            // check the principal and credential sets
            Set&lt;Principal&gt; thatPrincipals;
<span class="fc" id="L805">            synchronized(that.principals) {</span>
                // avoid deadlock from dual locks
<span class="fc" id="L807">                thatPrincipals = new HashSet&lt;Principal&gt;(that.principals);</span>
<span class="pc" id="L808">            }</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">            if (!principals.equals(thatPrincipals)) {</span>
<span class="nc" id="L810">                return false;</span>
            }

            Set&lt;Object&gt; thatPubCredentials;
<span class="fc" id="L814">            synchronized(that.pubCredentials) {</span>
                // avoid deadlock from dual locks
<span class="fc" id="L816">                thatPubCredentials = new HashSet&lt;Object&gt;(that.pubCredentials);</span>
<span class="pc" id="L817">            }</span>
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">            if (!pubCredentials.equals(thatPubCredentials)) {</span>
<span class="nc" id="L819">                return false;</span>
            }

            Set&lt;Object&gt; thatPrivCredentials;
<span class="fc" id="L823">            synchronized(that.privCredentials) {</span>
                // avoid deadlock from dual locks
<span class="fc" id="L825">                thatPrivCredentials = new HashSet&lt;Object&gt;(that.privCredentials);</span>
<span class="pc" id="L826">            }</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">            if (!privCredentials.equals(thatPrivCredentials)) {</span>
<span class="nc" id="L828">                return false;</span>
            }
<span class="fc" id="L830">            return true;</span>
        }
<span class="nc" id="L832">        return false;</span>
    }

    /**
     * Return the String representation of this {@code Subject}.
     *
     * &lt;p&gt;
     *
     * @return the String representation of this {@code Subject}.
     */
    public String toString() {
<span class="fc" id="L843">        return toString(true);</span>
    }

    /**
     * package private convenience method to print out the Subject
     * without firing off a security check when trying to access
     * the Private Credentials
     */
    String toString(boolean includePrivateCredentials) {

<span class="fc" id="L853">        String s = ResourcesMgr.getString(&quot;Subject.&quot;);</span>
<span class="fc" id="L854">        String suffix = &quot;&quot;;</span>

<span class="fc" id="L856">        synchronized(principals) {</span>
<span class="fc" id="L857">            Iterator&lt;Principal&gt; pI = principals.iterator();</span>
<span class="fc bfc" id="L858" title="All 2 branches covered.">            while (pI.hasNext()) {</span>
<span class="fc" id="L859">                Principal p = pI.next();</span>
<span class="fc" id="L860">                suffix = suffix + ResourcesMgr.getString(&quot;.Principal.&quot;) +</span>
<span class="fc" id="L861">                        p.toString() + ResourcesMgr.getString(&quot;NEWLINE&quot;);</span>
<span class="fc" id="L862">            }</span>
<span class="pc" id="L863">        }</span>

<span class="fc" id="L865">        synchronized(pubCredentials) {</span>
<span class="fc" id="L866">            Iterator&lt;Object&gt; pI = pubCredentials.iterator();</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">            while (pI.hasNext()) {</span>
<span class="fc" id="L868">                Object o = pI.next();</span>
<span class="fc" id="L869">                suffix = suffix +</span>
<span class="fc" id="L870">                        ResourcesMgr.getString(&quot;.Public.Credential.&quot;) +</span>
<span class="fc" id="L871">                        o.toString() + ResourcesMgr.getString(&quot;NEWLINE&quot;);</span>
<span class="fc" id="L872">            }</span>
<span class="pc" id="L873">        }</span>

<span class="pc bpc" id="L875" title="1 of 2 branches missed.">        if (includePrivateCredentials) {</span>
<span class="fc" id="L876">            synchronized(privCredentials) {</span>
<span class="fc" id="L877">                Iterator&lt;Object&gt; pI = privCredentials.iterator();</span>
<span class="fc bfc" id="L878" title="All 2 branches covered.">                while (pI.hasNext()) {</span>
                    try {
<span class="fc" id="L880">                        Object o = pI.next();</span>
<span class="fc" id="L881">                        suffix += ResourcesMgr.getString</span>
<span class="fc" id="L882">                                        (&quot;.Private.Credential.&quot;) +</span>
<span class="fc" id="L883">                                        o.toString() +</span>
<span class="fc" id="L884">                                        ResourcesMgr.getString(&quot;NEWLINE&quot;);</span>
<span class="nc" id="L885">                    } catch (SecurityException se) {</span>
<span class="nc" id="L886">                        suffix += ResourcesMgr.getString</span>
<span class="nc" id="L887">                                (&quot;.Private.Credential.inaccessible.&quot;);</span>
<span class="nc" id="L888">                        break;</span>
<span class="fc" id="L889">                    }</span>
                }
<span class="pc" id="L891">            }</span>
        }
<span class="fc" id="L893">        return s + suffix;</span>
    }

    /**
     * Returns a hashcode for this {@code Subject}.
     *
     * &lt;p&gt;
     *
     * @return a hashcode for this {@code Subject}.
     *
     * @exception SecurityException if the caller does not have permission
     *          to access this Subject's private credentials.
     */
    public int hashCode() {

        /**
         * The hashcode is derived exclusive or-ing the
         * hashcodes of this Subject's Principals and credentials.
         *
         * If a particular credential was destroyed
         * ({@code credential.hashCode()} throws an
         * {@code IllegalStateException}),
         * the hashcode for that credential is derived via:
         * {@code credential.getClass().toString().hashCode()}.
         */

<span class="nc" id="L919">        int hashCode = 0;</span>

<span class="nc" id="L921">        synchronized(principals) {</span>
<span class="nc" id="L922">            Iterator&lt;Principal&gt; pIterator = principals.iterator();</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">            while (pIterator.hasNext()) {</span>
<span class="nc" id="L924">                Principal p = pIterator.next();</span>
<span class="nc" id="L925">                hashCode ^= p.hashCode();</span>
<span class="nc" id="L926">            }</span>
<span class="nc" id="L927">        }</span>

<span class="nc" id="L929">        synchronized(pubCredentials) {</span>
<span class="nc" id="L930">            Iterator&lt;Object&gt; pubCIterator = pubCredentials.iterator();</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">            while (pubCIterator.hasNext()) {</span>
<span class="nc" id="L932">                hashCode ^= getCredHashCode(pubCIterator.next());</span>
            }
<span class="nc" id="L934">        }</span>
<span class="nc" id="L935">        return hashCode;</span>
    }

    /**
     * get a credential's hashcode
     */
    private int getCredHashCode(Object o) {
        try {
<span class="nc" id="L943">            return o.hashCode();</span>
<span class="nc" id="L944">        } catch (IllegalStateException ise) {</span>
<span class="nc" id="L945">            return o.getClass().toString().hashCode();</span>
        }
    }

    /**
     * Writes this object out to a stream (i.e., serializes it).
     */
    private void writeObject(java.io.ObjectOutputStream oos)
                throws java.io.IOException {
<span class="fc" id="L954">        synchronized(principals) {</span>
<span class="fc" id="L955">            oos.defaultWriteObject();</span>
<span class="pc" id="L956">        }</span>
<span class="fc" id="L957">    }</span>

    /**
     * Reads this object from a stream (i.e., deserializes it)
     */
    private void readObject(java.io.ObjectInputStream s)
                throws java.io.IOException, ClassNotFoundException {

<span class="fc" id="L965">        s.defaultReadObject();</span>

        // The Credential {@code Set} is not serialized, but we do not
        // want the default deserialization routine to set it to null.
<span class="fc" id="L969">        this.pubCredentials = Collections.synchronizedSet</span>
<span class="fc" id="L970">                        (new SecureSet&lt;Object&gt;(this, PUB_CREDENTIAL_SET));</span>
<span class="fc" id="L971">        this.privCredentials = Collections.synchronizedSet</span>
<span class="fc" id="L972">                        (new SecureSet&lt;Object&gt;(this, PRIV_CREDENTIAL_SET));</span>
<span class="fc" id="L973">    }</span>

    /**
     * Prevent modifications unless caller has permission.
     *
     * @serial include
     */
    private static class SecureSet&lt;E&gt;
        extends AbstractSet&lt;E&gt;
        implements java.io.Serializable {

        private static final long serialVersionUID = 7911754171111800359L;

        /**
         * @serialField this$0 Subject The outer Subject instance.
         * @serialField elements LinkedList The elements in this set.
         */
<span class="fc" id="L990">        private static final ObjectStreamField[] serialPersistentFields = {</span>
            new ObjectStreamField(&quot;this$0&quot;, Subject.class),
            new ObjectStreamField(&quot;elements&quot;, LinkedList.class),
            new ObjectStreamField(&quot;which&quot;, int.class)
        };

        Subject subject;
        LinkedList&lt;E&gt; elements;

        /**
         * @serial An integer identifying the type of objects contained
         *      in this set.  If {@code which == 1},
         *      this is a Principal set and all the elements are
         *      of type {@code java.security.Principal}.
         *      If {@code which == 2}, this is a public credential
         *      set and all the elements are of type {@code Object}.
         *      If {@code which == 3}, this is a private credential
         *      set and all the elements are of type {@code Object}.
         */
        private int which;

<span class="fc" id="L1011">        SecureSet(Subject subject, int which) {</span>
<span class="fc" id="L1012">            this.subject = subject;</span>
<span class="fc" id="L1013">            this.which = which;</span>
<span class="fc" id="L1014">            this.elements = new LinkedList&lt;E&gt;();</span>
<span class="fc" id="L1015">        }</span>

<span class="fc" id="L1017">        SecureSet(Subject subject, int which, Set&lt;? extends E&gt; set) {</span>
<span class="fc" id="L1018">            this.subject = subject;</span>
<span class="fc" id="L1019">            this.which = which;</span>
<span class="fc" id="L1020">            this.elements = new LinkedList&lt;E&gt;(set);</span>
<span class="fc" id="L1021">        }</span>

        public int size() {
<span class="fc" id="L1024">            return elements.size();</span>
        }

        public Iterator&lt;E&gt; iterator() {
<span class="fc" id="L1028">            final LinkedList&lt;E&gt; list = elements;</span>
<span class="fc" id="L1029">            return new Iterator&lt;E&gt;() {</span>
<span class="fc" id="L1030">                ListIterator&lt;E&gt; i = list.listIterator(0);</span>

<span class="fc" id="L1032">                public boolean hasNext() {return i.hasNext();}</span>

                public E next() {
<span class="fc bfc" id="L1035" title="All 2 branches covered.">                    if (which != Subject.PRIV_CREDENTIAL_SET) {</span>
<span class="fc" id="L1036">                        return i.next();</span>
                    }

<span class="fc" id="L1039">                    SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L1040" title="All 2 branches covered.">                    if (sm != null) {</span>
                        try {
<span class="fc" id="L1042">                            sm.checkPermission(new PrivateCredentialPermission</span>
<span class="fc" id="L1043">                                (list.get(i.nextIndex()).getClass().getName(),</span>
<span class="fc" id="L1044">                                subject.getPrincipals()));</span>
<span class="fc" id="L1045">                        } catch (SecurityException se) {</span>
<span class="fc" id="L1046">                            i.next();</span>
<span class="fc" id="L1047">                            throw (se);</span>
<span class="fc" id="L1048">                        }</span>
                    }
<span class="fc" id="L1050">                    return i.next();</span>
                }

                public void remove() {

<span class="fc bfc" id="L1055" title="All 2 branches covered.">                    if (subject.isReadOnly()) {</span>
<span class="fc" id="L1056">                        throw new IllegalStateException(ResourcesMgr.getString</span>
<span class="fc" id="L1057">                                (&quot;Subject.is.read.only&quot;));</span>
                    }

<span class="fc" id="L1060">                    java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L1061" title="1 of 2 branches missed.">                    if (sm != null) {</span>
<span class="pc bpc" id="L1062" title="1 of 3 branches missed.">                        switch (which) {</span>
                        case Subject.PRINCIPAL_SET:
<span class="fc" id="L1064">                            sm.checkPermission(AuthPermissionHolder.MODIFY_PRINCIPALS_PERMISSION);</span>
<span class="fc" id="L1065">                            break;</span>
                        case Subject.PUB_CREDENTIAL_SET:
<span class="nc" id="L1067">                            sm.checkPermission(AuthPermissionHolder.MODIFY_PUBLIC_CREDENTIALS_PERMISSION);</span>
<span class="nc" id="L1068">                            break;</span>
                        default:
<span class="fc" id="L1070">                            sm.checkPermission(AuthPermissionHolder.MODIFY_PRIVATE_CREDENTIALS_PERMISSION);</span>
                            break;
                        }
                    }
<span class="fc" id="L1074">                    i.remove();</span>
<span class="fc" id="L1075">                }</span>
            };
        }

        public boolean add(E o) {

<span class="pc bpc" id="L1081" title="1 of 2 branches missed.">            if (subject.isReadOnly()) {</span>
<span class="nc" id="L1082">                throw new IllegalStateException</span>
<span class="nc" id="L1083">                        (ResourcesMgr.getString(&quot;Subject.is.read.only&quot;));</span>
            }

<span class="fc" id="L1086">            java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L1087" title="All 2 branches covered.">            if (sm != null) {</span>
<span class="fc bfc" id="L1088" title="All 3 branches covered.">                switch (which) {</span>
                case Subject.PRINCIPAL_SET:
<span class="fc" id="L1090">                    sm.checkPermission(AuthPermissionHolder.MODIFY_PRINCIPALS_PERMISSION);</span>
<span class="fc" id="L1091">                    break;</span>
                case Subject.PUB_CREDENTIAL_SET:
<span class="fc" id="L1093">                    sm.checkPermission(AuthPermissionHolder.MODIFY_PUBLIC_CREDENTIALS_PERMISSION);</span>
<span class="fc" id="L1094">                    break;</span>
                default:
<span class="fc" id="L1096">                    sm.checkPermission(AuthPermissionHolder.MODIFY_PRIVATE_CREDENTIALS_PERMISSION);</span>
                    break;
                }
            }

<span class="fc bfc" id="L1101" title="All 2 branches covered.">            switch (which) {</span>
            case Subject.PRINCIPAL_SET:
<span class="pc bpc" id="L1103" title="1 of 2 branches missed.">                if (!(o instanceof Principal)) {</span>
<span class="nc" id="L1104">                    throw new SecurityException(ResourcesMgr.getString</span>
<span class="nc" id="L1105">                        (&quot;attempting.to.add.an.object.which.is.not.an.instance.of.java.security.Principal.to.a.Subject.s.Principal.Set&quot;));</span>
                }
                break;
            default:
                // ok to add Objects of any kind to credential sets
                break;
            }

            // check for duplicates
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">            if (!elements.contains(o))</span>
<span class="fc" id="L1115">                return elements.add(o);</span>
            else
<span class="nc" id="L1117">                return false;</span>
        }

        public boolean remove(Object o) {

<span class="fc" id="L1122">            final Iterator&lt;E&gt; e = iterator();</span>
<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">            while (e.hasNext()) {</span>
                E next;
<span class="fc bfc" id="L1125" title="All 2 branches covered.">                if (which != Subject.PRIV_CREDENTIAL_SET) {</span>
<span class="fc" id="L1126">                    next = e.next();</span>
                } else {
<span class="fc" id="L1128">                    next = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L1129">                        (new java.security.PrivilegedAction&lt;E&gt;() {</span>
                        public E run() {
<span class="fc" id="L1131">                            return e.next();</span>
                        }
                    });
                }

<span class="pc bpc" id="L1136" title="1 of 2 branches missed.">                if (next == null) {</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">                    if (o == null) {</span>
<span class="nc" id="L1138">                        e.remove();</span>
<span class="nc" id="L1139">                        return true;</span>
                    }
<span class="fc bfc" id="L1141" title="All 2 branches covered.">                } else if (next.equals(o)) {</span>
<span class="fc" id="L1142">                    e.remove();</span>
<span class="fc" id="L1143">                    return true;</span>
                }
<span class="fc" id="L1145">            }</span>
<span class="nc" id="L1146">            return false;</span>
        }

        public boolean contains(Object o) {
<span class="fc" id="L1150">            final Iterator&lt;E&gt; e = iterator();</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">            while (e.hasNext()) {</span>
                E next;
<span class="fc bfc" id="L1153" title="All 2 branches covered.">                if (which != Subject.PRIV_CREDENTIAL_SET) {</span>
<span class="fc" id="L1154">                    next = e.next();</span>
                } else {

                    // For private credentials:
                    // If the caller does not have read permission for
                    // for o.getClass(), we throw a SecurityException.
                    // Otherwise we check the private cred set to see whether
                    // it contains the Object

<span class="fc" id="L1163">                    SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">                    if (sm != null) {</span>
<span class="fc" id="L1165">                        sm.checkPermission(new PrivateCredentialPermission</span>
<span class="fc" id="L1166">                                                (o.getClass().getName(),</span>
<span class="fc" id="L1167">                                                subject.getPrincipals()));</span>
                    }
<span class="fc" id="L1169">                    next = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L1170">                        (new java.security.PrivilegedAction&lt;E&gt;() {</span>
                        public E run() {
<span class="fc" id="L1172">                            return e.next();</span>
                        }
                    });
                }

<span class="pc bpc" id="L1177" title="1 of 2 branches missed.">                if (next == null) {</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">                    if (o == null) {</span>
<span class="nc" id="L1179">                        return true;</span>
                    }
<span class="fc bfc" id="L1181" title="All 2 branches covered.">                } else if (next.equals(o)) {</span>
<span class="fc" id="L1182">                    return true;</span>
                }
<span class="fc" id="L1184">            }</span>
<span class="fc" id="L1185">            return false;</span>
        }

        public boolean removeAll(Collection&lt;?&gt; c) {
<span class="fc" id="L1189">            Objects.requireNonNull(c);</span>
<span class="fc" id="L1190">            boolean modified = false;</span>
<span class="fc" id="L1191">            final Iterator&lt;E&gt; e = iterator();</span>
<span class="fc bfc" id="L1192" title="All 2 branches covered.">            while (e.hasNext()) {</span>
                E next;
<span class="pc bpc" id="L1194" title="1 of 2 branches missed.">                if (which != Subject.PRIV_CREDENTIAL_SET) {</span>
<span class="nc" id="L1195">                    next = e.next();</span>
                } else {
<span class="fc" id="L1197">                    next = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L1198">                        (new java.security.PrivilegedAction&lt;E&gt;() {</span>
                        public E run() {
<span class="fc" id="L1200">                            return e.next();</span>
                        }
                    });
                }

<span class="fc" id="L1205">                Iterator&lt;?&gt; ce = c.iterator();</span>
<span class="fc bfc" id="L1206" title="All 2 branches covered.">                while (ce.hasNext()) {</span>
<span class="fc" id="L1207">                    Object o = ce.next();</span>
<span class="pc bpc" id="L1208" title="1 of 2 branches missed.">                    if (next == null) {</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">                        if (o == null) {</span>
<span class="nc" id="L1210">                            e.remove();</span>
<span class="nc" id="L1211">                            modified = true;</span>
<span class="nc" id="L1212">                            break;</span>
                        }
<span class="fc bfc" id="L1214" title="All 2 branches covered.">                    } else if (next.equals(o)) {</span>
<span class="fc" id="L1215">                        e.remove();</span>
<span class="fc" id="L1216">                        modified = true;</span>
<span class="fc" id="L1217">                        break;</span>
                    }
<span class="fc" id="L1219">                }</span>
<span class="fc" id="L1220">            }</span>
<span class="fc" id="L1221">            return modified;</span>
        }

        public boolean retainAll(Collection&lt;?&gt; c) {
<span class="fc" id="L1225">            Objects.requireNonNull(c);</span>
<span class="fc" id="L1226">            boolean modified = false;</span>
<span class="fc" id="L1227">            boolean retain = false;</span>
<span class="fc" id="L1228">            final Iterator&lt;E&gt; e = iterator();</span>
<span class="fc bfc" id="L1229" title="All 2 branches covered.">            while (e.hasNext()) {</span>
<span class="fc" id="L1230">                retain = false;</span>
                E next;
<span class="pc bpc" id="L1232" title="1 of 2 branches missed.">                if (which != Subject.PRIV_CREDENTIAL_SET) {</span>
<span class="nc" id="L1233">                    next = e.next();</span>
                } else {
<span class="fc" id="L1235">                    next = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L1236">                        (new java.security.PrivilegedAction&lt;E&gt;() {</span>
                        public E run() {
<span class="fc" id="L1238">                            return e.next();</span>
                        }
                    });
                }

<span class="fc" id="L1243">                Iterator&lt;?&gt; ce = c.iterator();</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">                while (ce.hasNext()) {</span>
<span class="fc" id="L1245">                    Object o = ce.next();</span>
<span class="pc bpc" id="L1246" title="1 of 2 branches missed.">                    if (next == null) {</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">                        if (o == null) {</span>
<span class="nc" id="L1248">                            retain = true;</span>
<span class="nc" id="L1249">                            break;</span>
                        }
<span class="fc bfc" id="L1251" title="All 2 branches covered.">                    } else if (next.equals(o)) {</span>
<span class="fc" id="L1252">                        retain = true;</span>
<span class="fc" id="L1253">                        break;</span>
                    }
<span class="fc" id="L1255">                }</span>

<span class="fc bfc" id="L1257" title="All 2 branches covered.">                if (!retain) {</span>
<span class="fc" id="L1258">                    e.remove();</span>
<span class="fc" id="L1259">                    retain = false;</span>
<span class="fc" id="L1260">                    modified = true;</span>
                }
<span class="fc" id="L1262">            }</span>
<span class="fc" id="L1263">            return modified;</span>
        }

        public void clear() {
<span class="fc" id="L1267">            final Iterator&lt;E&gt; e = iterator();</span>
<span class="fc bfc" id="L1268" title="All 2 branches covered.">            while (e.hasNext()) {</span>
                E next;
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">                if (which != Subject.PRIV_CREDENTIAL_SET) {</span>
<span class="nc" id="L1271">                    next = e.next();</span>
                } else {
<span class="fc" id="L1273">                    next = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L1274">                        (new java.security.PrivilegedAction&lt;E&gt;() {</span>
                        public E run() {
<span class="fc" id="L1276">                            return e.next();</span>
                        }
                    });
                }
<span class="fc" id="L1280">                e.remove();</span>
<span class="fc" id="L1281">            }</span>
<span class="fc" id="L1282">        }</span>

        /**
         * Writes this object out to a stream (i.e., serializes it).
         *
         * &lt;p&gt;
         *
         * @serialData If this is a private credential set,
         *      a security check is performed to ensure that
         *      the caller has permission to access each credential
         *      in the set.  If the security check passes,
         *      the set is serialized.
         */
        private void writeObject(java.io.ObjectOutputStream oos)
                throws java.io.IOException {

<span class="fc bfc" id="L1298" title="All 2 branches covered.">            if (which == Subject.PRIV_CREDENTIAL_SET) {</span>
                // check permissions before serializing
<span class="fc" id="L1300">                Iterator&lt;E&gt; i = iterator();</span>
<span class="nc bnc" id="L1301" title="All 2 branches missed.">                while (i.hasNext()) {</span>
<span class="nc" id="L1302">                    i.next();</span>
                }
            }
<span class="fc" id="L1305">            ObjectOutputStream.PutField fields = oos.putFields();</span>
<span class="fc" id="L1306">            fields.put(&quot;this$0&quot;, subject);</span>
<span class="fc" id="L1307">            fields.put(&quot;elements&quot;, elements);</span>
<span class="fc" id="L1308">            fields.put(&quot;which&quot;, which);</span>
<span class="fc" id="L1309">            oos.writeFields();</span>
<span class="fc" id="L1310">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)
        private void readObject(ObjectInputStream ois)
            throws IOException, ClassNotFoundException
        {
<span class="fc" id="L1316">            ObjectInputStream.GetField fields = ois.readFields();</span>
<span class="fc" id="L1317">            subject = (Subject) fields.get(&quot;this$0&quot;, null);</span>
<span class="fc" id="L1318">            which = fields.get(&quot;which&quot;, 0);</span>

<span class="fc" id="L1320">            LinkedList&lt;E&gt; tmp = (LinkedList&lt;E&gt;) fields.get(&quot;elements&quot;, null);</span>
<span class="pc bpc" id="L1321" title="1 of 2 branches missed.">            if (tmp.getClass() != LinkedList.class) {</span>
<span class="nc" id="L1322">                elements = new LinkedList&lt;E&gt;(tmp);</span>
            } else {
<span class="fc" id="L1324">                elements = tmp;</span>
            }
<span class="fc" id="L1326">        }</span>
    }

    /**
     * This class implements a {@code Set} which returns only
     * members that are an instance of a specified Class.
     */
    private class ClassSet&lt;T&gt; extends AbstractSet&lt;T&gt; {

        private int which;
        private Class&lt;T&gt; c;
        private Set&lt;T&gt; set;

<span class="fc" id="L1339">        ClassSet(int which, Class&lt;T&gt; c) {</span>
<span class="fc" id="L1340">            this.which = which;</span>
<span class="fc" id="L1341">            this.c = c;</span>
<span class="fc" id="L1342">            set = new HashSet&lt;T&gt;();</span>

<span class="pc bpc" id="L1344" title="1 of 3 branches missed.">            switch (which) {</span>
            case Subject.PRINCIPAL_SET:
<span class="pc" id="L1346">                synchronized(principals) { populateSet(); }</span>
<span class="fc" id="L1347">                break;</span>
            case Subject.PUB_CREDENTIAL_SET:
<span class="nc" id="L1349">                synchronized(pubCredentials) { populateSet(); }</span>
<span class="nc" id="L1350">                break;</span>
            default:
<span class="fc" id="L1352">                synchronized(privCredentials) { populateSet(); }</span>
                break;
            }
<span class="fc" id="L1355">        }</span>

        @SuppressWarnings(&quot;unchecked&quot;)     /*To suppress warning from line 1374*/
        private void populateSet() {
            final Iterator&lt;?&gt; iterator;
<span class="pc bpc" id="L1360" title="1 of 3 branches missed.">            switch(which) {</span>
            case Subject.PRINCIPAL_SET:
<span class="fc" id="L1362">                iterator = Subject.this.principals.iterator();</span>
<span class="fc" id="L1363">                break;</span>
            case Subject.PUB_CREDENTIAL_SET:
<span class="nc" id="L1365">                iterator = Subject.this.pubCredentials.iterator();</span>
<span class="nc" id="L1366">                break;</span>
            default:
<span class="fc" id="L1368">                iterator = Subject.this.privCredentials.iterator();</span>
                break;
            }

            // Check whether the caller has permisson to get
            // credentials of Class c

<span class="fc bfc" id="L1375" title="All 2 branches covered.">            while (iterator.hasNext()) {</span>
                Object next;
<span class="fc bfc" id="L1377" title="All 2 branches covered.">                if (which == Subject.PRIV_CREDENTIAL_SET) {</span>
<span class="fc" id="L1378">                    next = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L1379">                        (new java.security.PrivilegedAction&lt;Object&gt;() {</span>
                        public Object run() {
<span class="fc" id="L1381">                            return iterator.next();</span>
                        }
                    });
                } else {
<span class="fc" id="L1385">                    next = iterator.next();</span>
                }
<span class="fc bfc" id="L1387" title="All 2 branches covered.">                if (c.isAssignableFrom(next.getClass())) {</span>
<span class="fc bfc" id="L1388" title="All 2 branches covered.">                    if (which != Subject.PRIV_CREDENTIAL_SET) {</span>
<span class="fc" id="L1389">                        set.add((T)next);</span>
                    } else {
                        // Check permission for private creds
<span class="fc" id="L1392">                        SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L1393" title="All 2 branches covered.">                        if (sm != null) {</span>
<span class="fc" id="L1394">                            sm.checkPermission(new PrivateCredentialPermission</span>
<span class="fc" id="L1395">                                                (next.getClass().getName(),</span>
<span class="fc" id="L1396">                                                Subject.this.getPrincipals()));</span>
                        }
<span class="fc" id="L1398">                        set.add((T)next);</span>
                    }
                }
<span class="fc" id="L1401">            }</span>
<span class="fc" id="L1402">        }</span>

        public int size() {
<span class="fc" id="L1405">            return set.size();</span>
        }

        public Iterator&lt;T&gt; iterator() {
<span class="fc" id="L1409">            return set.iterator();</span>
        }

        public boolean add(T o) {

<span class="fc bfc" id="L1414" title="All 2 branches covered.">            if (!o.getClass().isAssignableFrom(c)) {</span>
<span class="fc" id="L1415">                MessageFormat form = new MessageFormat(ResourcesMgr.getString</span>
<span class="fc" id="L1416">                        (&quot;attempting.to.add.an.object.which.is.not.an.instance.of.class&quot;));</span>
<span class="fc" id="L1417">                Object[] source = {c.toString()};</span>
<span class="fc" id="L1418">                throw new SecurityException(form.format(source));</span>
            }

<span class="fc" id="L1421">            return set.add(o);</span>
        }
    }

<span class="nc" id="L1425">    static class AuthPermissionHolder {</span>
<span class="fc" id="L1426">        static final AuthPermission DO_AS_PERMISSION =</span>
            new AuthPermission(&quot;doAs&quot;);

<span class="fc" id="L1429">        static final AuthPermission DO_AS_PRIVILEGED_PERMISSION =</span>
            new AuthPermission(&quot;doAsPrivileged&quot;);

<span class="fc" id="L1432">        static final AuthPermission SET_READ_ONLY_PERMISSION =</span>
            new AuthPermission(&quot;setReadOnly&quot;);

<span class="fc" id="L1435">        static final AuthPermission GET_SUBJECT_PERMISSION =</span>
            new AuthPermission(&quot;getSubject&quot;);

<span class="fc" id="L1438">        static final AuthPermission MODIFY_PRINCIPALS_PERMISSION =</span>
            new AuthPermission(&quot;modifyPrincipals&quot;);

<span class="fc" id="L1441">        static final AuthPermission MODIFY_PUBLIC_CREDENTIALS_PERMISSION =</span>
            new AuthPermission(&quot;modifyPublicCredentials&quot;);

<span class="fc" id="L1444">        static final AuthPermission MODIFY_PRIVATE_CREDENTIALS_PERMISSION =</span>
            new AuthPermission(&quot;modifyPrivateCredentials&quot;);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>