<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PrivateCredentialPermission.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.security.auth</a> &gt; <span class="el_source">PrivateCredentialPermission.java</span></div><h1>PrivateCredentialPermission.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.security.auth;

import java.util.*;
import java.text.MessageFormat;
import java.security.Permission;
import java.security.PermissionCollection;
import java.security.Principal;
import sun.security.util.ResourcesMgr;

/**
 * This class is used to protect access to private Credentials
 * belonging to a particular {@code Subject}.  The {@code Subject}
 * is represented by a Set of Principals.
 *
 * &lt;p&gt; The target name of this {@code Permission} specifies
 * a Credential class name, and a Set of Principals.
 * The only valid value for this Permission's actions is, &quot;read&quot;.
 * The target name must abide by the following syntax:
 *
 * &lt;pre&gt;
 *      CredentialClass {PrincipalClass &quot;PrincipalName&quot;}*
 * &lt;/pre&gt;
 *
 * For example, the following permission grants access to the
 * com.sun.PrivateCredential owned by Subjects which have
 * a com.sun.Principal with the name, &quot;duke&quot;.  Note that although
 * this example, as well as all the examples below, do not contain
 * Codebase, SignedBy, or Principal information in the grant statement
 * (for simplicity reasons), actual policy configurations should
 * specify that information when appropriate.
 *
 * &lt;pre&gt;
 *
 *    grant {
 *      permission javax.security.auth.PrivateCredentialPermission
 *              &quot;com.sun.PrivateCredential com.sun.Principal \&quot;duke\&quot;&quot;,
 *              &quot;read&quot;;
 *    };
 * &lt;/pre&gt;
 *
 * If CredentialClass is &quot;*&quot;, then access is granted to
 * all private Credentials belonging to the specified
 * {@code Subject}.
 * If &quot;PrincipalName&quot; is &quot;*&quot;, then access is granted to the
 * specified Credential owned by any {@code Subject} that has the
 * specified {@code Principal} (the actual PrincipalName doesn't matter).
 * For example, the following grants access to the
 * a.b.Credential owned by any {@code Subject} that has
 * an a.b.Principal.
 *
 * &lt;pre&gt;
 *    grant {
 *      permission javax.security.auth.PrivateCredentialPermission
 *              &quot;a.b.Credential a.b.Principal &quot;*&quot;&quot;,
 *              &quot;read&quot;;
 *    };
 * &lt;/pre&gt;
 *
 * If both the PrincipalClass and &quot;PrincipalName&quot; are &quot;*&quot;,
 * then access is granted to the specified Credential owned by
 * any {@code Subject}.
 *
 * &lt;p&gt; In addition, the PrincipalClass/PrincipalName pairing may be repeated:
 *
 * &lt;pre&gt;
 *    grant {
 *      permission javax.security.auth.PrivateCredentialPermission
 *              &quot;a.b.Credential a.b.Principal &quot;duke&quot; c.d.Principal &quot;dukette&quot;&quot;,
 *              &quot;read&quot;;
 *    };
 * &lt;/pre&gt;
 *
 * The above grants access to the private Credential, &quot;a.b.Credential&quot;,
 * belonging to a {@code Subject} with at least two associated Principals:
 * &quot;a.b.Principal&quot; with the name, &quot;duke&quot;, and &quot;c.d.Principal&quot;, with the name,
 * &quot;dukette&quot;.
 *
 */
public final class PrivateCredentialPermission extends Permission {

    private static final long serialVersionUID = 5284372143517237068L;

<span class="fc" id="L108">    private static final CredOwner[] EMPTY_PRINCIPALS = new CredOwner[0];</span>

    /**
     * @serial
     */
    private String credentialClass;

    /**
     * @serial The Principals associated with this permission.
     *          The set contains elements of type,
     *          {@code PrivateCredentialPermission.CredOwner}.
     */
    private Set&lt;Principal&gt; principals;  // ignored - kept around for compatibility
    private transient CredOwner[] credOwners;

    /**
     * @serial
     */
<span class="fc" id="L126">    private boolean testing = false;</span>

    /**
     * Create a new {@code PrivateCredentialPermission}
     * with the specified {@code credentialClass} and Principals.
     */
    PrivateCredentialPermission(String credentialClass,
                        Set&lt;Principal&gt; principals) {

<span class="fc" id="L135">        super(credentialClass);</span>
<span class="fc" id="L136">        this.credentialClass = credentialClass;</span>

<span class="fc" id="L138">        synchronized(principals) {</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">            if (principals.size() == 0) {</span>
<span class="nc" id="L140">                this.credOwners = EMPTY_PRINCIPALS;</span>
            } else {
<span class="fc" id="L142">                this.credOwners = new CredOwner[principals.size()];</span>
<span class="fc" id="L143">                int index = 0;</span>
<span class="fc" id="L144">                Iterator&lt;Principal&gt; i = principals.iterator();</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                while (i.hasNext()) {</span>
<span class="fc" id="L146">                    Principal p = i.next();</span>
<span class="fc" id="L147">                    this.credOwners[index++] = new CredOwner</span>
<span class="fc" id="L148">                                                (p.getClass().getName(),</span>
<span class="fc" id="L149">                                                p.getName());</span>
<span class="fc" id="L150">                }</span>
            }
<span class="pc" id="L152">        }</span>
<span class="fc" id="L153">    }</span>

    /**
     * Creates a new {@code PrivateCredentialPermission}
     * with the specified {@code name}.  The {@code name}
     * specifies both a Credential class and a {@code Principal} Set.
     *
     * &lt;p&gt;
     *
     * @param name the name specifying the Credential class and
     *          {@code Principal} Set. &lt;p&gt;
     *
     * @param actions the actions specifying that the Credential can be read.
     *
     * @throws IllegalArgumentException if {@code name} does not conform
     *          to the correct syntax or if {@code actions} is not &quot;read&quot;.
     */
    public PrivateCredentialPermission(String name, String actions) {
<span class="fc" id="L171">        super(name);</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (!&quot;read&quot;.equalsIgnoreCase(actions))</span>
<span class="fc" id="L174">            throw new IllegalArgumentException</span>
<span class="fc" id="L175">                (ResourcesMgr.getString(&quot;actions.can.only.be.read.&quot;));</span>
<span class="fc" id="L176">        init(name);</span>
<span class="fc" id="L177">    }</span>

    /**
     * Returns the Class name of the Credential associated with this
     * {@code PrivateCredentialPermission}.
     *
     * &lt;p&gt;
     *
     * @return the Class name of the Credential associated with this
     *          {@code PrivateCredentialPermission}.
     */
    public String getCredentialClass() {
<span class="nc" id="L189">        return credentialClass;</span>
    }

    /**
     * Returns the {@code Principal} classes and names
     * associated with this {@code PrivateCredentialPermission}.
     * The information is returned as a two-dimensional array (array[x][y]).
     * The 'x' value corresponds to the number of {@code Principal}
     * class and name pairs.  When (y==0), it corresponds to
     * the {@code Principal} class value, and when (y==1),
     * it corresponds to the {@code Principal} name value.
     * For example, array[0][0] corresponds to the class name of
     * the first {@code Principal} in the array.  array[0][1]
     * corresponds to the {@code Principal} name of the
     * first {@code Principal} in the array.
     *
     * &lt;p&gt;
     *
     * @return the {@code Principal} class and names associated
     *          with this {@code PrivateCredentialPermission}.
     */
    public String[][] getPrincipals() {

<span class="pc bpc" id="L212" title="2 of 4 branches missed.">        if (credOwners == null || credOwners.length == 0) {</span>
<span class="nc" id="L213">            return new String[0][0];</span>
        }

<span class="fc" id="L216">        String[][] pArray = new String[credOwners.length][2];</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (int i = 0; i &lt; credOwners.length; i++) {</span>
<span class="fc" id="L218">            pArray[i][0] = credOwners[i].principalClass;</span>
<span class="fc" id="L219">            pArray[i][1] = credOwners[i].principalName;</span>
        }
<span class="fc" id="L221">        return pArray;</span>
    }

    /**
     * Checks if this {@code PrivateCredentialPermission} implies
     * the specified {@code Permission}.
     *
     * &lt;p&gt;
     *
     * This method returns true if:
     * &lt;p&gt;&lt;ul&gt;
     * &lt;li&gt; &lt;i&gt;p&lt;/i&gt; is an instanceof PrivateCredentialPermission and &lt;p&gt;
     * &lt;li&gt; the target name for &lt;i&gt;p&lt;/i&gt; is implied by this object's
     *          target name.  For example:
     * &lt;pre&gt;
     *  [* P1 &quot;duke&quot;] implies [a.b.Credential P1 &quot;duke&quot;].
     *  [C1 P1 &quot;duke&quot;] implies [C1 P1 &quot;duke&quot; P2 &quot;dukette&quot;].
     *  [C1 P2 &quot;dukette&quot;] implies [C1 P1 &quot;duke&quot; P2 &quot;dukette&quot;].
     * &lt;/pre&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;
     *
     * @param p the {@code Permission} to check against.
     *
     * @return true if this {@code PrivateCredentialPermission} implies
     * the specified {@code Permission}, false if not.
     */
    public boolean implies(Permission p) {

<span class="pc bpc" id="L251" title="2 of 4 branches missed.">        if (p == null || !(p instanceof PrivateCredentialPermission))</span>
<span class="nc" id="L252">            return false;</span>

<span class="fc" id="L254">        PrivateCredentialPermission that = (PrivateCredentialPermission)p;</span>

<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (!impliesCredentialClass(credentialClass, that.credentialClass))</span>
<span class="fc" id="L257">            return false;</span>

<span class="fc" id="L259">        return impliesPrincipalSet(credOwners, that.credOwners);</span>
    }

    /**
     * Checks two {@code PrivateCredentialPermission} objects for
     * equality.  Checks that &lt;i&gt;obj&lt;/i&gt; is a
     * {@code PrivateCredentialPermission},
     * and has the same credential class as this object,
     * as well as the same Principals as this object.
     * The order of the Principals in the respective Permission's
     * target names is not relevant.
     *
     * &lt;p&gt;
     *
     * @param obj the object we are testing for equality with this object.
     *
     * @return true if obj is a {@code PrivateCredentialPermission},
     *          has the same credential class as this object,
     *          and has the same Principals as this object.
     */
    public boolean equals(Object obj) {
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (obj == this)</span>
<span class="nc" id="L281">            return true;</span>

<span class="pc bpc" id="L283" title="1 of 2 branches missed.">        if (! (obj instanceof PrivateCredentialPermission))</span>
<span class="nc" id="L284">            return false;</span>

<span class="fc" id="L286">        PrivateCredentialPermission that = (PrivateCredentialPermission)obj;</span>

<span class="pc bpc" id="L288" title="2 of 4 branches missed.">        return (this.implies(that) &amp;&amp; that.implies(this));</span>
    }

    /**
     * Returns the hash code value for this object.
     *
     * @return a hash code value for this object.
     */
    public int hashCode() {
<span class="fc" id="L297">        return this.credentialClass.hashCode();</span>
    }

    /**
     * Returns the &quot;canonical string representation&quot; of the actions.
     * This method always returns the String, &quot;read&quot;.
     *
     * &lt;p&gt;
     *
     * @return the actions (always returns &quot;read&quot;).
     */
    public String getActions() {
<span class="fc" id="L309">        return &quot;read&quot;;</span>
    }

    /**
     * Return a homogeneous collection of PrivateCredentialPermissions
     * in a {@code PermissionCollection}.
     * No such {@code PermissionCollection} is defined,
     * so this method always returns {@code null}.
     *
     * &lt;p&gt;
     *
     * @return null in all cases.
     */
    public PermissionCollection newPermissionCollection() {
<span class="fc" id="L323">        return null;</span>
    }

    private void init(String name) {

<span class="pc bpc" id="L328" title="2 of 4 branches missed.">        if (name == null || name.trim().length() == 0) {</span>
<span class="nc" id="L329">            throw new IllegalArgumentException(&quot;invalid empty name&quot;);</span>
        }

<span class="fc" id="L332">        ArrayList&lt;CredOwner&gt; pList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L333">        StringTokenizer tokenizer = new StringTokenizer(name, &quot; &quot;, true);</span>
<span class="fc" id="L334">        String principalClass = null;</span>
<span class="fc" id="L335">        String principalName = null;</span>

<span class="pc bpc" id="L337" title="1 of 2 branches missed.">        if (testing)</span>
<span class="nc" id="L338">            System.out.println(&quot;whole name = &quot; + name);</span>

        // get the Credential Class
<span class="fc" id="L341">        credentialClass = tokenizer.nextToken();</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        if (testing)</span>
<span class="nc" id="L343">            System.out.println(&quot;Credential Class = &quot; + credentialClass);</span>

<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (tokenizer.hasMoreTokens() == false) {</span>
<span class="fc" id="L346">            MessageFormat form = new MessageFormat(ResourcesMgr.getString</span>
<span class="fc" id="L347">                (&quot;permission.name.name.syntax.invalid.&quot;));</span>
<span class="fc" id="L348">            Object[] source = {name};</span>
<span class="fc" id="L349">            throw new IllegalArgumentException</span>
<span class="fc" id="L350">                (form.format(source) + ResourcesMgr.getString</span>
<span class="fc" id="L351">                        (&quot;Credential.Class.not.followed.by.a.Principal.Class.and.Name&quot;));</span>
        }

<span class="fc bfc" id="L354" title="All 2 branches covered.">        while (tokenizer.hasMoreTokens()) {</span>

            // skip delimiter
<span class="fc" id="L357">            tokenizer.nextToken();</span>

            // get the Principal Class
<span class="fc" id="L360">            principalClass = tokenizer.nextToken();</span>
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">            if (testing)</span>
<span class="nc" id="L362">                System.out.println(&quot;    Principal Class = &quot; + principalClass);</span>

<span class="fc bfc" id="L364" title="All 2 branches covered.">            if (tokenizer.hasMoreTokens() == false) {</span>
<span class="fc" id="L365">                MessageFormat form = new MessageFormat(ResourcesMgr.getString</span>
<span class="fc" id="L366">                        (&quot;permission.name.name.syntax.invalid.&quot;));</span>
<span class="fc" id="L367">                Object[] source = {name};</span>
<span class="fc" id="L368">                throw new IllegalArgumentException</span>
<span class="fc" id="L369">                        (form.format(source) + ResourcesMgr.getString</span>
<span class="fc" id="L370">                        (&quot;Principal.Class.not.followed.by.a.Principal.Name&quot;));</span>
            }

            // skip delimiter
<span class="fc" id="L374">            tokenizer.nextToken();</span>

            // get the Principal Name
<span class="fc" id="L377">            principalName = tokenizer.nextToken();</span>

<span class="fc bfc" id="L379" title="All 2 branches covered.">            if (!principalName.startsWith(&quot;\&quot;&quot;)) {</span>
<span class="fc" id="L380">                MessageFormat form = new MessageFormat(ResourcesMgr.getString</span>
<span class="fc" id="L381">                        (&quot;permission.name.name.syntax.invalid.&quot;));</span>
<span class="fc" id="L382">                Object[] source = {name};</span>
<span class="fc" id="L383">                throw new IllegalArgumentException</span>
<span class="fc" id="L384">                        (form.format(source) + ResourcesMgr.getString</span>
<span class="fc" id="L385">                        (&quot;Principal.Name.must.be.surrounded.by.quotes&quot;));</span>
            }

<span class="fc bfc" id="L388" title="All 2 branches covered.">            if (!principalName.endsWith(&quot;\&quot;&quot;)) {</span>

                // we have a name with spaces in it --
                // keep parsing until we find the end quote,
                // and keep the spaces in the name

<span class="pc bpc" id="L394" title="1 of 2 branches missed.">                while (tokenizer.hasMoreTokens()) {</span>
<span class="nc" id="L395">                    principalName = principalName + tokenizer.nextToken();</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">                    if (principalName.endsWith(&quot;\&quot;&quot;))</span>
<span class="nc" id="L397">                        break;</span>
                }

<span class="pc bpc" id="L400" title="1 of 2 branches missed.">                if (!principalName.endsWith(&quot;\&quot;&quot;)) {</span>
<span class="fc" id="L401">                    MessageFormat form = new MessageFormat</span>
                        (ResourcesMgr.getString
<span class="fc" id="L403">                        (&quot;permission.name.name.syntax.invalid.&quot;));</span>
<span class="fc" id="L404">                    Object[] source = {name};</span>
<span class="fc" id="L405">                    throw new IllegalArgumentException</span>
<span class="fc" id="L406">                        (form.format(source) + ResourcesMgr.getString</span>
<span class="fc" id="L407">                                (&quot;Principal.Name.missing.end.quote&quot;));</span>
                }
            }

<span class="pc bpc" id="L411" title="1 of 2 branches missed.">            if (testing)</span>
<span class="nc" id="L412">                System.out.println(&quot;\tprincipalName = '&quot; + principalName + &quot;'&quot;);</span>

<span class="fc" id="L414">            principalName = principalName.substring</span>
<span class="fc" id="L415">                                        (1, principalName.length() - 1);</span>

<span class="fc bfc" id="L417" title="All 2 branches covered.">            if (principalClass.equals(&quot;*&quot;) &amp;&amp;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                !principalName.equals(&quot;*&quot;)) {</span>
<span class="fc" id="L419">                    throw new IllegalArgumentException(ResourcesMgr.getString</span>
<span class="fc" id="L420">                        (&quot;PrivateCredentialPermission.Principal.Class.can.not.be.a.wildcard.value.if.Principal.Name.is.not.a.wildcard.value&quot;));</span>
            }

<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            if (testing)</span>
<span class="nc" id="L424">                System.out.println(&quot;\tprincipalName = '&quot; + principalName + &quot;'&quot;);</span>

<span class="fc" id="L426">            pList.add(new CredOwner(principalClass, principalName));</span>
        }

<span class="fc" id="L429">        this.credOwners = new CredOwner[pList.size()];</span>
<span class="fc" id="L430">        pList.toArray(this.credOwners);</span>
<span class="fc" id="L431">    }</span>

    private boolean impliesCredentialClass(String thisC, String thatC) {

        // this should never happen
<span class="pc bpc" id="L436" title="2 of 4 branches missed.">        if (thisC == null || thatC == null)</span>
<span class="nc" id="L437">            return false;</span>

<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (testing)</span>
<span class="nc" id="L440">            System.out.println(&quot;credential class comparison: &quot; +</span>
                                thisC + &quot;/&quot; + thatC);

<span class="pc bpc" id="L443" title="1 of 2 branches missed.">        if (thisC.equals(&quot;*&quot;))</span>
<span class="nc" id="L444">            return true;</span>

        /**
         * XXX let's not enable this for now --
         *      if people want it, we'll enable it later
         */
        /*
        if (thisC.endsWith(&quot;*&quot;)) {
            String cClass = thisC.substring(0, thisC.length() - 2);
            return thatC.startsWith(cClass);
        }
        */

<span class="fc" id="L457">        return thisC.equals(thatC);</span>
    }

    private boolean impliesPrincipalSet(CredOwner[] thisP, CredOwner[] thatP) {

        // this should never happen
<span class="pc bpc" id="L463" title="2 of 4 branches missed.">        if (thisP == null || thatP == null)</span>
<span class="nc" id="L464">            return false;</span>

<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (thatP.length == 0)</span>
<span class="nc" id="L467">            return true;</span>

<span class="pc bpc" id="L469" title="1 of 2 branches missed.">        if (thisP.length == 0)</span>
<span class="nc" id="L470">            return false;</span>

<span class="fc bfc" id="L472" title="All 2 branches covered.">        for (int i = 0; i &lt; thisP.length; i++) {</span>
<span class="fc" id="L473">            boolean foundMatch = false;</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            for (int j = 0; j &lt; thatP.length; j++) {</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">                if (thisP[i].implies(thatP[j])) {</span>
<span class="fc" id="L476">                    foundMatch = true;</span>
<span class="fc" id="L477">                    break;</span>
                }
            }
<span class="pc bpc" id="L480" title="1 of 2 branches missed.">            if (!foundMatch) {</span>
<span class="nc" id="L481">                return false;</span>
            }
        }
<span class="fc" id="L484">        return true;</span>
    }

    /**
     * Reads this object from a stream (i.e., deserializes it)
     */
    private void readObject(java.io.ObjectInputStream s) throws
                                        java.io.IOException,
                                        ClassNotFoundException {

<span class="fc" id="L494">        s.defaultReadObject();</span>

        // perform new initialization from the permission name

<span class="pc bpc" id="L498" title="3 of 4 branches missed.">        if (getName().indexOf(&quot; &quot;) == -1 &amp;&amp; getName().indexOf(&quot;\&quot;&quot;) == -1) {</span>

            // name only has a credential class specified
<span class="nc" id="L501">            credentialClass = getName();</span>
<span class="nc" id="L502">            credOwners = EMPTY_PRINCIPALS;</span>

        } else {

            // perform regular initialization
<span class="fc" id="L507">            init(getName());</span>
        }
<span class="fc" id="L509">    }</span>

    /**
     * @serial include
     */
    static class CredOwner implements java.io.Serializable {

        private static final long serialVersionUID = -5607449830436408266L;

        /**
         * @serial
         */
        String principalClass;
        /**
         * @serial
         */
        String principalName;

<span class="fc" id="L527">        CredOwner(String principalClass, String principalName) {</span>
<span class="fc" id="L528">            this.principalClass = principalClass;</span>
<span class="fc" id="L529">            this.principalName = principalName;</span>
<span class="fc" id="L530">        }</span>

        public boolean implies(Object obj) {
<span class="pc bpc" id="L533" title="2 of 4 branches missed.">            if (obj == null || !(obj instanceof CredOwner))</span>
<span class="nc" id="L534">                return false;</span>

<span class="fc" id="L536">            CredOwner that = (CredOwner)obj;</span>

<span class="pc bpc" id="L538" title="1 of 2 branches missed.">            if (principalClass.equals(&quot;*&quot;) ||</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">                principalClass.equals(that.principalClass)) {</span>

<span class="pc bpc" id="L541" title="1 of 2 branches missed.">                if (principalName.equals(&quot;*&quot;) ||</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">                    principalName.equals(that.principalName)) {</span>
<span class="fc" id="L543">                    return true;</span>
                }
            }

            /**
             * XXX no code yet to support a.b.*
             */

<span class="fc" id="L551">            return false;</span>
        }

        public String toString() {
<span class="nc" id="L555">            MessageFormat form = new MessageFormat(ResourcesMgr.getString</span>
<span class="nc" id="L556">                (&quot;CredOwner.Principal.Class.class.Principal.Name.name&quot;));</span>
<span class="nc" id="L557">            Object[] source = {principalClass, principalName};</span>
<span class="nc" id="L558">            return (form.format(source));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>