<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Policy.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.security.auth</a> &gt; <span class="el_source">Policy.java</span></div><h1>Policy.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.security.auth;

import java.security.Security;
import sun.security.util.Debug;

/**
 * &lt;p&gt; This is an abstract class for representing the system policy for
 * Subject-based authorization.  A subclass implementation
 * of this class provides a means to specify a Subject-based
 * access control {@code Policy}.
 *
 * &lt;p&gt; A {@code Policy} object can be queried for the set of
 * Permissions granted to code running as a
 * {@code Principal} in the following manner:
 *
 * &lt;pre&gt;
 *      policy = Policy.getPolicy();
 *      PermissionCollection perms = policy.getPermissions(subject,
 *                                                      codeSource);
 * &lt;/pre&gt;
 *
 * The {@code Policy} object consults the local policy and returns
 * and appropriate {@code Permissions} object with the
 * Permissions granted to the Principals associated with the
 * provided &lt;i&gt;subject&lt;/i&gt;, and granted to the code specified
 * by the provided &lt;i&gt;codeSource&lt;/i&gt;.
 *
 * &lt;p&gt; A {@code Policy} contains the following information.
 * Note that this example only represents the syntax for the default
 * {@code Policy} implementation. Subclass implementations of this class
 * may implement alternative syntaxes and may retrieve the
 * {@code Policy} from any source such as files, databases,
 * or servers.
 *
 * &lt;p&gt; Each entry in the {@code Policy} is represented as
 * a &lt;b&gt;&lt;i&gt;grant&lt;/i&gt;&lt;/b&gt; entry.  Each &lt;b&gt;&lt;i&gt;grant&lt;/i&gt;&lt;/b&gt; entry
 * specifies a codebase, code signers, and Principals triplet,
 * as well as the Permissions granted to that triplet.
 *
 * &lt;pre&gt;
 *      grant CodeBase [&quot;URL&quot;], Signedby [&quot;signers&quot;],
 *            Principal [Principal_Class] &quot;Principal_Name&quot; {
 *          Permission Permission_Class [&quot;Target_Name&quot;]
 *                                      [, &quot;Permission_Actions&quot;]
 *                                      [, signedBy &quot;SignerName&quot;];
 *      };
 * &lt;/pre&gt;
 *
 * The CodeBase and Signedby components of the triplet name/value pairs
 * are optional.  If they are not present, then any any codebase will match,
 * and any signer (including unsigned code) will match.
 * For Example,
 *
 * &lt;pre&gt;
 *      grant CodeBase &quot;foo.com&quot;, Signedby &quot;foo&quot;,
 *            Principal com.sun.security.auth.SolarisPrincipal &quot;duke&quot; {
 *          permission java.io.FilePermission &quot;/home/duke&quot;, &quot;read, write&quot;;
 *      };
 * &lt;/pre&gt;
 *
 * This &lt;b&gt;&lt;i&gt;grant&lt;/i&gt;&lt;/b&gt; entry specifies that code from &quot;foo.com&quot;,
 * signed by &quot;foo', and running as a {@code SolarisPrincipal} with the
 * name, duke, has one {@code Permission}.  This {@code Permission}
 * permits the executing code to read and write files in the directory,
 * &quot;/home/duke&quot;.
 *
 * &lt;p&gt; To &quot;run&quot; as a particular {@code Principal},
 * code invokes the {@code Subject.doAs(subject, ...)} method.
 * After invoking that method, the code runs as all the Principals
 * associated with the specified {@code Subject}.
 * Note that this {@code Policy} (and the Permissions
 * granted in this {@code Policy}) only become effective
 * after the call to {@code Subject.doAs} has occurred.
 *
 * &lt;p&gt; Multiple Principals may be listed within one &lt;b&gt;&lt;i&gt;grant&lt;/i&gt;&lt;/b&gt; entry.
 * All the Principals in the grant entry must be associated with
 * the {@code Subject} provided to {@code Subject.doAs}
 * for that {@code Subject} to be granted the specified Permissions.
 *
 * &lt;pre&gt;
 *      grant Principal com.sun.security.auth.SolarisPrincipal &quot;duke&quot;,
 *            Principal com.sun.security.auth.SolarisNumericUserPrincipal &quot;0&quot; {
 *          permission java.io.FilePermission &quot;/home/duke&quot;, &quot;read, write&quot;;
 *          permission java.net.SocketPermission &quot;duke.com&quot;, &quot;connect&quot;;
 *      };
 * &lt;/pre&gt;
 *
 * This entry grants any code running as both &quot;duke&quot; and &quot;0&quot;
 * permission to read and write files in duke's home directory,
 * as well as permission to make socket connections to &quot;duke.com&quot;.
 *
 * &lt;p&gt; Note that non Principal-based grant entries are not permitted
 * in this {@code Policy}.  Therefore, grant entries such as:
 *
 * &lt;pre&gt;
 *      grant CodeBase &quot;foo.com&quot;, Signedby &quot;foo&quot; {
 *          permission java.io.FilePermission &quot;/tmp/scratch&quot;, &quot;read, write&quot;;
 *      };
 * &lt;/pre&gt;
 *
 * are rejected.  Such permission must be listed in the
 * {@code java.security.Policy}.
 *
 * &lt;p&gt; The default {@code Policy} implementation can be changed by
 * setting the value of the {@code auth.policy.provider} security property to
 * the fully qualified name of the desired {@code Policy} implementation class.
 *
 * @deprecated  as of JDK version 1.4 -- Replaced by java.security.Policy.
 *              java.security.Policy has a method:
 * &lt;pre&gt;
 *      public PermissionCollection getPermissions
 *          (java.security.ProtectionDomain pd)
 *
 * &lt;/pre&gt;
 * and ProtectionDomain has a constructor:
 * &lt;pre&gt;
 *      public ProtectionDomain
 *          (CodeSource cs,
 *           PermissionCollection permissions,
 *           ClassLoader loader,
 *           Principal[] principals)
 * &lt;/pre&gt;
 *
 * These two APIs provide callers the means to query the
 * Policy for Principal-based Permission entries.
 *
 * @see java.security.Security security properties
 */
@Deprecated
public abstract class Policy {

    private static Policy policy;
    private static ClassLoader contextClassLoader;
    private final static String AUTH_POLICY =
        &quot;sun.security.provider.AuthPolicyFile&quot;;

    // true if a custom (not AUTH_POLICY) system-wide policy object is set
    private static boolean isCustomPolicy;

    static {
<span class="fc" id="L166">        contextClassLoader = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L167">                (new java.security.PrivilegedAction&lt;ClassLoader&gt;() {</span>
                public ClassLoader run() {
<span class="fc" id="L169">                    return Thread.currentThread().getContextClassLoader();</span>
                }
        });
<span class="fc" id="L172">    };</span>

    /**
     * Sole constructor.  (For invocation by subclass constructors, typically
     * implicit.)
     */
<span class="nc" id="L178">    protected Policy() { }</span>

    /**
     * Returns the installed Policy object.
     * This method first calls
     * {@code SecurityManager.checkPermission} with the
     * {@code AuthPermission(&quot;getPolicy&quot;)} permission
     * to ensure the caller has permission to get the Policy object.
     *
     * &lt;p&gt;
     *
     * @return the installed Policy.  The return value cannot be
     *          {@code null}.
     *
     * @exception java.lang.SecurityException if the current thread does not
     *      have permission to get the Policy object.
     *
     * @see #setPolicy
     */
    public static Policy getPolicy() {
<span class="nc" id="L198">        java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (sm != null) sm.checkPermission(new AuthPermission(&quot;getPolicy&quot;));</span>
<span class="nc" id="L200">        return getPolicyNoCheck();</span>
    }

    /**
     * Returns the installed Policy object, skipping the security check.
     *
     * @return the installed Policy.
     *
     */
    static Policy getPolicyNoCheck() {
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if (policy == null) {</span>

<span class="nc" id="L212">            synchronized(Policy.class) {</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">                if (policy == null) {</span>
<span class="nc" id="L215">                    String policy_class = null;</span>
<span class="nc" id="L216">                    policy_class = java.security.AccessController.doPrivileged</span>
<span class="nc" id="L217">                        (new java.security.PrivilegedAction&lt;String&gt;() {</span>
                        public String run() {
<span class="nc" id="L219">                            return java.security.Security.getProperty</span>
<span class="nc" id="L220">                                (&quot;auth.policy.provider&quot;);</span>
                        }
                    });
<span class="nc bnc" id="L223" title="All 2 branches missed.">                    if (policy_class == null) {</span>
<span class="nc" id="L224">                        policy_class = AUTH_POLICY;</span>
                    }

                    try {
<span class="nc" id="L228">                        final String finalClass = policy_class;</span>
<span class="nc" id="L229">                        policy = java.security.AccessController.doPrivileged</span>
<span class="nc" id="L230">                            (new java.security.PrivilegedExceptionAction&lt;Policy&gt;() {</span>
                            public Policy run() throws ClassNotFoundException,
                                                InstantiationException,
                                                IllegalAccessException {
<span class="nc" id="L234">                                return (Policy) Class.forName</span>
<span class="nc" id="L235">                                        (finalClass,</span>
                                        true,
<span class="nc" id="L237">                                        contextClassLoader).newInstance();</span>
                            }
                        });
<span class="nc bnc" id="L240" title="All 2 branches missed.">                        isCustomPolicy = !finalClass.equals(AUTH_POLICY);</span>
<span class="nc" id="L241">                    } catch (Exception e) {</span>
<span class="nc" id="L242">                        throw new SecurityException</span>
                                (sun.security.util.ResourcesMgr.getString
<span class="nc" id="L244">                                (&quot;unable.to.instantiate.Subject.based.policy&quot;));</span>
<span class="nc" id="L245">                    }</span>
                }
<span class="nc" id="L247">            }</span>
        }
<span class="nc" id="L249">        return policy;</span>
    }


    /**
     * Sets the system-wide Policy object. This method first calls
     * {@code SecurityManager.checkPermission} with the
     * {@code AuthPermission(&quot;setPolicy&quot;)}
     * permission to ensure the caller has permission to set the Policy.
     *
     * &lt;p&gt;
     *
     * @param policy the new system Policy object.
     *
     * @exception java.lang.SecurityException if the current thread does not
     *          have permission to set the Policy.
     *
     * @see #getPolicy
     */
    public static void setPolicy(Policy policy) {
<span class="nc" id="L269">        java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        if (sm != null) sm.checkPermission(new AuthPermission(&quot;setPolicy&quot;));</span>
<span class="nc" id="L271">        Policy.policy = policy;</span>
        // all non-null policy objects are assumed to be custom
<span class="nc bnc" id="L273" title="All 2 branches missed.">        isCustomPolicy = policy != null ? true : false;</span>
<span class="nc" id="L274">    }</span>

    /**
     * Returns true if a custom (not AUTH_POLICY) system-wide policy object
     * has been set or installed. This method is called by
     * SubjectDomainCombiner to provide backwards compatibility for
     * developers that provide their own javax.security.auth.Policy
     * implementations.
     *
     * @return true if a custom (not AUTH_POLICY) system-wide policy object
     * has been set; false otherwise
     */
    static boolean isCustomPolicySet(Debug debug) {
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if (policy != null) {</span>
<span class="nc bnc" id="L288" title="All 4 branches missed.">            if (debug != null &amp;&amp; isCustomPolicy) {</span>
<span class="nc" id="L289">                debug.println(&quot;Providing backwards compatibility for &quot; +</span>
                              &quot;javax.security.auth.policy implementation: &quot; +
<span class="nc" id="L291">                              policy.toString());</span>
            }
<span class="nc" id="L293">            return isCustomPolicy;</span>
        }
        // check if custom policy has been set using auth.policy.provider prop
<span class="fc" id="L296">        String policyClass = java.security.AccessController.doPrivileged</span>
<span class="fc" id="L297">            (new java.security.PrivilegedAction&lt;String&gt;() {</span>
                public String run() {
<span class="fc" id="L299">                    return Security.getProperty(&quot;auth.policy.provider&quot;);</span>
                }
        });
<span class="pc bpc" id="L302" title="3 of 4 branches missed.">        if (policyClass != null &amp;&amp; !policyClass.equals(AUTH_POLICY)) {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">            if (debug != null) {</span>
<span class="nc" id="L304">                debug.println(&quot;Providing backwards compatibility for &quot; +</span>
                              &quot;javax.security.auth.policy implementation: &quot; +
                              policyClass);
            }
<span class="nc" id="L308">            return true;</span>
        }
<span class="fc" id="L310">        return false;</span>
    }

    /**
     * Retrieve the Permissions granted to the Principals associated with
     * the specified {@code CodeSource}.
     *
     * &lt;p&gt;
     *
     * @param subject the {@code Subject}
     *                  whose associated Principals,
     *                  in conjunction with the provided
     *                  {@code CodeSource}, determines the Permissions
     *                  returned by this method.  This parameter
     *                  may be {@code null}. &lt;p&gt;
     *
     * @param cs the code specified by its {@code CodeSource}
     *                  that determines, in conjunction with the provided
     *                  {@code Subject}, the Permissions
     *                  returned by this method.  This parameter may be
     *                  {@code null}.
     *
     * @return the Collection of Permissions granted to all the
     *                  {@code Subject} and code specified in
     *                  the provided &lt;i&gt;subject&lt;/i&gt; and &lt;i&gt;cs&lt;/i&gt;
     *                  parameters.
     */
    public abstract java.security.PermissionCollection getPermissions
                                        (Subject subject,
                                        java.security.CodeSource cs);

    /**
     * Refresh and reload the Policy.
     *
     * &lt;p&gt;This method causes this object to refresh/reload its current
     * Policy. This is implementation-dependent.
     * For example, if the Policy object is stored in
     * a file, calling {@code refresh} will cause the file to be re-read.
     *
     * &lt;p&gt;
     *
     * @exception SecurityException if the caller does not have permission
     *                          to refresh the Policy.
     */
    public abstract void refresh();
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>