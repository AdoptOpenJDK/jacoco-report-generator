<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SubjectDomainCombiner.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.security.auth</a> &gt; <span class="el_source">SubjectDomainCombiner.java</span></div><h1>SubjectDomainCombiner.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.security.auth;

import java.security.AccessController;
import java.security.Permission;
import java.security.Permissions;
import java.security.PermissionCollection;
import java.security.Policy;
import java.security.Principal;
import java.security.PrivilegedAction;
import java.security.ProtectionDomain;
import java.security.Security;
import java.util.Set;
import java.util.WeakHashMap;
import java.lang.ref.WeakReference;

/**
 * A {@code SubjectDomainCombiner} updates ProtectionDomains
 * with Principals from the {@code Subject} associated with this
 * {@code SubjectDomainCombiner}.
 *
 */
public class SubjectDomainCombiner implements java.security.DomainCombiner {

    private Subject subject;
<span class="fc" id="L50">    private WeakKeyValueMap&lt;ProtectionDomain, ProtectionDomain&gt; cachedPDs =</span>
                new WeakKeyValueMap&lt;&gt;();
    private Set&lt;Principal&gt; principalSet;
    private Principal[] principals;

<span class="fc" id="L55">    private static final sun.security.util.Debug debug =</span>
<span class="fc" id="L56">        sun.security.util.Debug.getInstance(&quot;combiner&quot;,</span>
                                        &quot;\t[SubjectDomainCombiner]&quot;);

    @SuppressWarnings(&quot;deprecation&quot;)
    // Note: check only at classloading time, not dynamically during combine()
<span class="fc" id="L61">    private static final boolean useJavaxPolicy =</span>
<span class="fc" id="L62">        javax.security.auth.Policy.isCustomPolicySet(debug);</span>

    // Relevant only when useJavaxPolicy is true
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">    private static final boolean allowCaching =</span>
<span class="pc bnc" id="L66" title="All 2 branches missed.">                                        (useJavaxPolicy &amp;&amp; cachePolicy());</span>

    /**
     * Associate the provided {@code Subject} with this
     * {@code SubjectDomainCombiner}.
     *
     * &lt;p&gt;
     *
     * @param subject the {@code Subject} to be associated with
     *          with this {@code SubjectDomainCombiner}.
     */
<span class="fc" id="L77">    public SubjectDomainCombiner(Subject subject) {</span>
<span class="fc" id="L78">        this.subject = subject;</span>

<span class="fc bfc" id="L80" title="All 2 branches covered.">        if (subject.isReadOnly()) {</span>
<span class="fc" id="L81">            principalSet = subject.getPrincipals();</span>
<span class="fc" id="L82">            principals = principalSet.toArray</span>
<span class="fc" id="L83">                        (new Principal[principalSet.size()]);</span>
        }
<span class="fc" id="L85">    }</span>

    /**
     * Get the {@code Subject} associated with this
     * {@code SubjectDomainCombiner}.
     *
     * &lt;p&gt;
     *
     * @return the {@code Subject} associated with this
     *          {@code SubjectDomainCombiner}, or {@code null}
     *          if no {@code Subject} is associated with this
     *          {@code SubjectDomainCombiner}.
     *
     * @exception SecurityException if the caller does not have permission
     *          to get the {@code Subject} associated with this
     *          {@code SubjectDomainCombiner}.
     */
    public Subject getSubject() {
<span class="fc" id="L103">        java.lang.SecurityManager sm = System.getSecurityManager();</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (sm != null) {</span>
<span class="fc" id="L105">            sm.checkPermission(new AuthPermission</span>
                (&quot;getSubjectFromDomainCombiner&quot;));
        }
<span class="fc" id="L108">        return subject;</span>
    }

    /**
     * Update the relevant ProtectionDomains with the Principals
     * from the {@code Subject} associated with this
     * {@code SubjectDomainCombiner}.
     *
     * &lt;p&gt; A new {@code ProtectionDomain} instance is created
     * for each {@code ProtectionDomain} in the
     * &lt;i&gt;currentDomains&lt;/i&gt; array.  Each new {@code ProtectionDomain}
     * instance is created using the {@code CodeSource},
     * {@code Permission}s and {@code ClassLoader}
     * from the corresponding {@code ProtectionDomain} in
     * &lt;i&gt;currentDomains&lt;/i&gt;, as well as with the Principals from
     * the {@code Subject} associated with this
     * {@code SubjectDomainCombiner}.
     *
     * &lt;p&gt; All of the newly instantiated ProtectionDomains are
     * combined into a new array.  The ProtectionDomains from the
     * &lt;i&gt;assignedDomains&lt;/i&gt; array are appended to this new array,
     * and the result is returned.
     *
     * &lt;p&gt; Note that optimizations such as the removal of duplicate
     * ProtectionDomains may have occurred.
     * In addition, caching of ProtectionDomains may be permitted.
     *
     * &lt;p&gt;
     *
     * @param currentDomains the ProtectionDomains associated with the
     *          current execution Thread, up to the most recent
     *          privileged {@code ProtectionDomain}.
     *          The ProtectionDomains are are listed in order of execution,
     *          with the most recently executing {@code ProtectionDomain}
     *          residing at the beginning of the array. This parameter may
     *          be {@code null} if the current execution Thread
     *          has no associated ProtectionDomains.&lt;p&gt;
     *
     * @param assignedDomains the ProtectionDomains inherited from the
     *          parent Thread, or the ProtectionDomains from the
     *          privileged &lt;i&gt;context&lt;/i&gt;, if a call to
     *          AccessController.doPrivileged(..., &lt;i&gt;context&lt;/i&gt;)
     *          had occurred  This parameter may be {@code null}
     *          if there were no ProtectionDomains inherited from the
     *          parent Thread, or from the privileged &lt;i&gt;context&lt;/i&gt;.
     *
     * @return a new array consisting of the updated ProtectionDomains,
     *          or {@code null}.
     */
    public ProtectionDomain[] combine(ProtectionDomain[] currentDomains,
                                ProtectionDomain[] assignedDomains) {
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (debug != null) {</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">            if (subject == null) {</span>
<span class="nc" id="L161">                debug.println(&quot;null subject&quot;);</span>
            } else {
<span class="fc" id="L163">                final Subject s = subject;</span>
<span class="fc" id="L164">                AccessController.doPrivileged</span>
<span class="fc" id="L165">                    (new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                    public Void run() {
<span class="fc" id="L167">                        debug.println(s.toString());</span>
<span class="fc" id="L168">                        return null;</span>
                    }
                });
            }
<span class="fc" id="L172">            printInputDomains(currentDomains, assignedDomains);</span>
        }

<span class="pc bpc" id="L175" title="2 of 4 branches missed.">        if (currentDomains == null || currentDomains.length == 0) {</span>
            // No need to optimize assignedDomains because it should
            // have been previously optimized (when it was set).

            // Note that we are returning a direct reference
            // to the input array - since ACC does not clone
            // the arrays when it calls combiner.combine,
            // multiple ACC instances may share the same
            // array instance in this case

<span class="nc" id="L185">            return assignedDomains;</span>
        }

        // optimize currentDomains
        //
        // No need to optimize assignedDomains because it should
        // have been previously optimized (when it was set).

<span class="fc" id="L193">        currentDomains = optimize(currentDomains);</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">        if (debug != null) {</span>
<span class="fc" id="L195">            debug.println(&quot;after optimize&quot;);</span>
<span class="fc" id="L196">            printInputDomains(currentDomains, assignedDomains);</span>
        }

<span class="pc bpc" id="L199" title="3 of 4 branches missed.">        if (currentDomains == null &amp;&amp; assignedDomains == null) {</span>
<span class="nc" id="L200">            return null;</span>
        }

        // maintain backwards compatibility for developers who provide
        // their own custom javax.security.auth.Policy implementations
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        if (useJavaxPolicy) {</span>
<span class="nc" id="L206">            return combineJavaxPolicy(currentDomains, assignedDomains);</span>
        }

<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        int cLen = (currentDomains == null ? 0 : currentDomains.length);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">        int aLen = (assignedDomains == null ? 0 : assignedDomains.length);</span>

        // the ProtectionDomains for the new AccessControlContext
        // that we will return
<span class="fc" id="L214">        ProtectionDomain[] newDomains = new ProtectionDomain[cLen + aLen];</span>

<span class="fc" id="L216">        boolean allNew = true;</span>
<span class="fc" id="L217">        synchronized(cachedPDs) {</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            if (!subject.isReadOnly() &amp;&amp;</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                !subject.getPrincipals().equals(principalSet)) {</span>

                // if the Subject was mutated, clear the PD cache
<span class="fc" id="L222">                Set&lt;Principal&gt; newSet = subject.getPrincipals();</span>
<span class="fc" id="L223">                synchronized(newSet) {</span>
<span class="fc" id="L224">                    principalSet = new java.util.HashSet&lt;Principal&gt;(newSet);</span>
<span class="pc" id="L225">                }</span>
<span class="fc" id="L226">                principals = principalSet.toArray</span>
<span class="fc" id="L227">                        (new Principal[principalSet.size()]);</span>
<span class="fc" id="L228">                cachedPDs.clear();</span>

<span class="fc bfc" id="L230" title="All 2 branches covered.">                if (debug != null) {</span>
<span class="fc" id="L231">                    debug.println(&quot;Subject mutated - clearing cache&quot;);</span>
                }
            }

            ProtectionDomain subjectPd;
<span class="fc bfc" id="L236" title="All 2 branches covered.">            for (int i = 0; i &lt; cLen; i++) {</span>
<span class="fc" id="L237">                ProtectionDomain pd = currentDomains[i];</span>

<span class="fc" id="L239">                subjectPd = cachedPDs.getValue(pd);</span>

<span class="fc bfc" id="L241" title="All 2 branches covered.">                if (subjectPd == null) {</span>
<span class="fc" id="L242">                    subjectPd = new ProtectionDomain(pd.getCodeSource(),</span>
<span class="fc" id="L243">                                                pd.getPermissions(),</span>
<span class="fc" id="L244">                                                pd.getClassLoader(),</span>
                                                principals);
<span class="fc" id="L246">                    cachedPDs.putValue(pd, subjectPd);</span>
                } else {
<span class="fc" id="L248">                    allNew = false;</span>
                }
<span class="fc" id="L250">                newDomains[i] = subjectPd;</span>
            }
<span class="pc" id="L252">        }</span>

<span class="fc bfc" id="L254" title="All 2 branches covered.">        if (debug != null) {</span>
<span class="fc" id="L255">            debug.println(&quot;updated current: &quot;);</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">            for (int i = 0; i &lt; cLen; i++) {</span>
<span class="fc" id="L257">                debug.println(&quot;\tupdated[&quot; + i + &quot;] = &quot; +</span>
<span class="fc" id="L258">                                printDomain(newDomains[i]));</span>
            }
        }

        // now add on the assigned domains
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (aLen &gt; 0) {</span>
<span class="fc" id="L264">            System.arraycopy(assignedDomains, 0, newDomains, cLen, aLen);</span>

            // optimize the result (cached PDs might exist in assignedDomains)
<span class="fc bfc" id="L267" title="All 2 branches covered.">            if (!allNew) {</span>
<span class="fc" id="L268">                newDomains = optimize(newDomains);</span>
            }
        }

        // if aLen == 0 || allNew, no need to further optimize newDomains

<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (debug != null) {</span>
<span class="pc bpc" id="L275" title="2 of 4 branches missed.">            if (newDomains == null || newDomains.length == 0) {</span>
<span class="nc" id="L276">                debug.println(&quot;returning null&quot;);</span>
            } else {
<span class="fc" id="L278">                debug.println(&quot;combinedDomains: &quot;);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">                for (int i = 0; i &lt; newDomains.length; i++) {</span>
<span class="fc" id="L280">                    debug.println(&quot;newDomain &quot; + i + &quot;: &quot; +</span>
<span class="fc" id="L281">                                  printDomain(newDomains[i]));</span>
                }
            }
        }

        // return the new ProtectionDomains
<span class="pc bpc" id="L287" title="2 of 4 branches missed.">        if (newDomains == null || newDomains.length == 0) {</span>
<span class="nc" id="L288">            return null;</span>
        } else {
<span class="fc" id="L290">            return newDomains;</span>
        }
    }

    /**
     * Use the javax.security.auth.Policy implementation
     */
    private ProtectionDomain[] combineJavaxPolicy(
        ProtectionDomain[] currentDomains,
        ProtectionDomain[] assignedDomains) {

<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (!allowCaching) {</span>
<span class="nc" id="L302">            java.security.AccessController.doPrivileged</span>
<span class="nc" id="L303">                (new PrivilegedAction&lt;Void&gt;() {</span>
                    @SuppressWarnings(&quot;deprecation&quot;)
                    public Void run() {
                        // Call refresh only caching is disallowed
<span class="nc" id="L307">                        javax.security.auth.Policy.getPolicy().refresh();</span>
<span class="nc" id="L308">                        return null;</span>
                    }
                });
        }


<span class="nc bnc" id="L314" title="All 2 branches missed.">        int cLen = (currentDomains == null ? 0 : currentDomains.length);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        int aLen = (assignedDomains == null ? 0 : assignedDomains.length);</span>

        // the ProtectionDomains for the new AccessControlContext
        // that we will return
<span class="nc" id="L319">        ProtectionDomain[] newDomains = new ProtectionDomain[cLen + aLen];</span>

<span class="nc" id="L321">        synchronized(cachedPDs) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (!subject.isReadOnly() &amp;&amp;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                !subject.getPrincipals().equals(principalSet)) {</span>

                // if the Subject was mutated, clear the PD cache
<span class="nc" id="L326">                Set&lt;Principal&gt; newSet = subject.getPrincipals();</span>
<span class="nc" id="L327">                synchronized(newSet) {</span>
<span class="nc" id="L328">                    principalSet = new java.util.HashSet&lt;Principal&gt;(newSet);</span>
<span class="nc" id="L329">                }</span>
<span class="nc" id="L330">                principals = principalSet.toArray</span>
<span class="nc" id="L331">                        (new Principal[principalSet.size()]);</span>
<span class="nc" id="L332">                cachedPDs.clear();</span>

<span class="nc bnc" id="L334" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc" id="L335">                    debug.println(&quot;Subject mutated - clearing cache&quot;);</span>
                }
            }

<span class="nc bnc" id="L339" title="All 2 branches missed.">            for (int i = 0; i &lt; cLen; i++) {</span>
<span class="nc" id="L340">                ProtectionDomain pd = currentDomains[i];</span>
<span class="nc" id="L341">                ProtectionDomain subjectPd = cachedPDs.getValue(pd);</span>

<span class="nc bnc" id="L343" title="All 2 branches missed.">                if (subjectPd == null) {</span>

                    // XXX
                    // we must first add the original permissions.
                    // that way when we later add the new JAAS permissions,
                    // any unresolved JAAS-related permissions will
                    // automatically get resolved.

                    // get the original perms
<span class="nc" id="L352">                    Permissions perms = new Permissions();</span>
<span class="nc" id="L353">                    PermissionCollection coll = pd.getPermissions();</span>
                    java.util.Enumeration&lt;Permission&gt; e;
<span class="nc bnc" id="L355" title="All 2 branches missed.">                    if (coll != null) {</span>
<span class="nc" id="L356">                        synchronized (coll) {</span>
<span class="nc" id="L357">                            e = coll.elements();</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">                            while (e.hasMoreElements()) {</span>
<span class="nc" id="L359">                                Permission newPerm =</span>
<span class="nc" id="L360">                                        e.nextElement();</span>
<span class="nc" id="L361">                                 perms.add(newPerm);</span>
<span class="nc" id="L362">                            }</span>
<span class="nc" id="L363">                        }</span>
                    }

                    // get perms from the policy

<span class="nc" id="L368">                    final java.security.CodeSource finalCs = pd.getCodeSource();</span>
<span class="nc" id="L369">                    final Subject finalS = subject;</span>
<span class="nc" id="L370">                    PermissionCollection newPerms =</span>
                        java.security.AccessController.doPrivileged
<span class="nc" id="L372">                        (new PrivilegedAction&lt;PermissionCollection&gt;() {</span>
                        @SuppressWarnings(&quot;deprecation&quot;)
                        public PermissionCollection run() {
                          return
<span class="nc" id="L376">                          javax.security.auth.Policy.getPolicy().getPermissions</span>
<span class="nc" id="L377">                                (finalS, finalCs);</span>
                        }
                    });

                    // add the newly granted perms,
                    // avoiding duplicates
<span class="nc" id="L383">                    synchronized (newPerms) {</span>
<span class="nc" id="L384">                        e = newPerms.elements();</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">                        while (e.hasMoreElements()) {</span>
<span class="nc" id="L386">                            Permission newPerm = e.nextElement();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                            if (!perms.implies(newPerm)) {</span>
<span class="nc" id="L388">                                perms.add(newPerm);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">                                if (debug != null)</span>
<span class="nc" id="L390">                                    debug.println (</span>
                                        &quot;Adding perm &quot; + newPerm + &quot;\n&quot;);
                            }
<span class="nc" id="L393">                        }</span>
<span class="nc" id="L394">                    }</span>
<span class="nc" id="L395">                    subjectPd = new ProtectionDomain</span>
<span class="nc" id="L396">                        (finalCs, perms, pd.getClassLoader(), principals);</span>

<span class="nc bnc" id="L398" title="All 2 branches missed.">                    if (allowCaching)</span>
<span class="nc" id="L399">                        cachedPDs.putValue(pd, subjectPd);</span>
                }
<span class="nc" id="L401">                newDomains[i] = subjectPd;</span>
            }
<span class="nc" id="L403">        }</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc" id="L406">            debug.println(&quot;updated current: &quot;);</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">            for (int i = 0; i &lt; cLen; i++) {</span>
<span class="nc" id="L408">                debug.println(&quot;\tupdated[&quot; + i + &quot;] = &quot; + newDomains[i]);</span>
            }
        }

        // now add on the assigned domains
<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (aLen &gt; 0) {</span>
<span class="nc" id="L414">            System.arraycopy(assignedDomains, 0, newDomains, cLen, aLen);</span>
        }

<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (debug != null) {</span>
<span class="nc bnc" id="L418" title="All 4 branches missed.">            if (newDomains == null || newDomains.length == 0) {</span>
<span class="nc" id="L419">                debug.println(&quot;returning null&quot;);</span>
            } else {
<span class="nc" id="L421">                debug.println(&quot;combinedDomains: &quot;);</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                for (int i = 0; i &lt; newDomains.length; i++) {</span>
<span class="nc" id="L423">                    debug.println(&quot;newDomain &quot; + i + &quot;: &quot; +</span>
<span class="nc" id="L424">                        newDomains[i].toString());</span>
                }
            }
        }

        // return the new ProtectionDomains
<span class="nc bnc" id="L430" title="All 4 branches missed.">        if (newDomains == null || newDomains.length == 0) {</span>
<span class="nc" id="L431">            return null;</span>
        } else {
<span class="nc" id="L433">            return newDomains;</span>
        }
    }

    private static ProtectionDomain[] optimize(ProtectionDomain[] domains) {
<span class="pc bpc" id="L438" title="2 of 4 branches missed.">        if (domains == null || domains.length == 0)</span>
<span class="nc" id="L439">            return null;</span>

<span class="fc" id="L441">        ProtectionDomain[] optimized = new ProtectionDomain[domains.length];</span>
        ProtectionDomain pd;
<span class="fc" id="L443">        int num = 0;</span>
<span class="fc bfc" id="L444" title="All 2 branches covered.">        for (int i = 0; i &lt; domains.length; i++) {</span>

            // skip domains with AllPermission
            // XXX
            //
            //  if (domains[i].implies(ALL_PERMISSION))
            //  continue;

            // skip System Domains
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">            if ((pd = domains[i]) != null) {</span>

                // remove duplicates
<span class="fc" id="L456">                boolean found = false;</span>
<span class="pc bpc" id="L457" title="1 of 4 branches missed.">                for (int j = 0; j &lt; num &amp;&amp; !found; j++) {</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">                    found = (optimized[j] == pd);</span>
                }
<span class="fc bfc" id="L460" title="All 2 branches covered.">                if (!found) {</span>
<span class="fc" id="L461">                    optimized[num++] = pd;</span>
                }
            }
        }

        // resize the array if necessary
<span class="pc bpc" id="L467" title="1 of 4 branches missed.">        if (num &gt; 0 &amp;&amp; num &lt; domains.length) {</span>
<span class="fc" id="L468">            ProtectionDomain[] downSize = new ProtectionDomain[num];</span>
<span class="fc" id="L469">            System.arraycopy(optimized, 0, downSize, 0, downSize.length);</span>
<span class="fc" id="L470">            optimized = downSize;</span>
        }

<span class="pc bpc" id="L473" title="2 of 4 branches missed.">        return ((num == 0 || optimized.length == 0) ? null : optimized);</span>
    }

    private static boolean cachePolicy() {
<span class="nc" id="L477">        String s = AccessController.doPrivileged</span>
<span class="nc" id="L478">            (new PrivilegedAction&lt;String&gt;() {</span>
            public String run() {
<span class="nc" id="L480">                return Security.getProperty(&quot;cache.auth.policy&quot;);</span>
            }
        });
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (s != null) {</span>
<span class="nc" id="L484">            return Boolean.parseBoolean(s);</span>
        }

        // cache by default
<span class="nc" id="L488">        return true;</span>
    }

    private static void printInputDomains(ProtectionDomain[] currentDomains,
                                ProtectionDomain[] assignedDomains) {
<span class="pc bpc" id="L493" title="2 of 4 branches missed.">        if (currentDomains == null || currentDomains.length == 0) {</span>
<span class="nc" id="L494">            debug.println(&quot;currentDomains null or 0 length&quot;);</span>
        } else {
<span class="pc bpc" id="L496" title="1 of 4 branches missed.">            for (int i = 0; currentDomains != null &amp;&amp;</span>
<span class="fc" id="L497">                        i &lt; currentDomains.length; i++) {</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">                if (currentDomains[i] == null) {</span>
<span class="nc" id="L499">                    debug.println(&quot;currentDomain &quot; + i + &quot;: SystemDomain&quot;);</span>
                } else {
<span class="fc" id="L501">                    debug.println(&quot;currentDomain &quot; + i + &quot;: &quot; +</span>
<span class="fc" id="L502">                                printDomain(currentDomains[i]));</span>
                }
            }
        }

<span class="pc bpc" id="L507" title="2 of 4 branches missed.">        if (assignedDomains == null || assignedDomains.length == 0) {</span>
<span class="nc" id="L508">            debug.println(&quot;assignedDomains null or 0 length&quot;);</span>
        } else {
<span class="fc" id="L510">            debug.println(&quot;assignedDomains = &quot;);</span>
<span class="pc bpc" id="L511" title="1 of 4 branches missed.">            for (int i = 0; assignedDomains != null &amp;&amp;</span>
<span class="fc" id="L512">                        i &lt; assignedDomains.length; i++) {</span>
<span class="pc bpc" id="L513" title="1 of 2 branches missed.">                if (assignedDomains[i] == null) {</span>
<span class="nc" id="L514">                    debug.println(&quot;assignedDomain &quot; + i + &quot;: SystemDomain&quot;);</span>
                } else {
<span class="fc" id="L516">                    debug.println(&quot;assignedDomain &quot; + i + &quot;: &quot; +</span>
<span class="fc" id="L517">                                printDomain(assignedDomains[i]));</span>
                }
            }
        }
<span class="fc" id="L521">    }</span>

    private static String printDomain(final ProtectionDomain pd) {
<span class="pc bpc" id="L524" title="1 of 2 branches missed.">        if (pd == null) {</span>
<span class="nc" id="L525">            return &quot;null&quot;;</span>
        }
<span class="fc" id="L527">        return AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() {</span>
            public String run() {
<span class="fc" id="L529">                return pd.toString();</span>
            }
        });
    }

    /**
     * A HashMap that has weak keys and values.
     *
     * Key objects in this map are the &quot;current&quot; ProtectionDomain instances
     * received via the combine method.  Each &quot;current&quot; PD is mapped to a
     * new PD instance that holds both the contents of the &quot;current&quot; PD,
     * as well as the principals from the Subject associated with this combiner.
     *
     * The newly created &quot;principal-based&quot; PD values must be stored as
     * WeakReferences since they contain strong references to the
     * corresponding key object (the &quot;current&quot; non-principal-based PD),
     * which will prevent the key from being GC'd.  Specifically,
     * a &quot;principal-based&quot; PD contains strong references to the CodeSource,
     * signer certs, PermissionCollection and ClassLoader objects
     * in the &quot;current PD&quot;.
     */
<span class="fc" id="L550">    private static class WeakKeyValueMap&lt;K,V&gt; extends</span>
                                        WeakHashMap&lt;K,WeakReference&lt;V&gt;&gt; {

        public V getValue(K key) {
<span class="fc" id="L554">            WeakReference&lt;V&gt; wr = super.get(key);</span>
<span class="fc bfc" id="L555" title="All 2 branches covered.">            if (wr != null) {</span>
<span class="fc" id="L556">                return wr.get();</span>
            }
<span class="fc" id="L558">            return null;</span>
        }

        public V putValue(K key, V value) {
<span class="fc" id="L562">            WeakReference&lt;V&gt; wr = super.put(key, new WeakReference&lt;V&gt;(value));</span>
<span class="pc bpc" id="L563" title="1 of 2 branches missed.">            if (wr != null) {</span>
<span class="nc" id="L564">                return wr.get();</span>
            }
<span class="fc" id="L566">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>