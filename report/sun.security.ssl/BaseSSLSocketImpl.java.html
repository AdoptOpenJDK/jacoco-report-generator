<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BaseSSLSocketImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">BaseSSLSocketImpl.java</span></div><h1>BaseSSLSocketImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.ssl;

import java.io.*;
import java.nio.channels.SocketChannel;
import java.net.*;

import javax.net.ssl.*;

/**
 * Abstract base class for SSLSocketImpl. Its purpose is to house code with
 * no SSL related logic (or no logic at all). This makes SSLSocketImpl shorter
 * and easier to read. It contains a few constants and static methods plus
 * overridden java.net.Socket methods.
 *
 * Methods are defined final to ensure that they are not accidentally
 * overridden in SSLSocketImpl.
 *
 * @see javax.net.ssl.SSLSocket
 * @see SSLSocketImpl
 *
 */
abstract class BaseSSLSocketImpl extends SSLSocket {

    /*
     * Normally &quot;self&quot; is &quot;this&quot; ... but not when this connection is
     * layered over a preexisting socket.  If we're using an existing
     * socket, we delegate some actions to it.  Else, we delegate
     * instead to &quot;super&quot;.  This is important to ensure that we don't
     * recurse infinitely ... e.g. close() calling itself, or doing
     * I/O in terms of our own streams.
     */
    final private Socket self;
    final private InputStream consumedInput;

    BaseSSLSocketImpl() {
<span class="nc" id="L61">        super();</span>
<span class="nc" id="L62">        this.self = this;</span>
<span class="nc" id="L63">        this.consumedInput = null;</span>
<span class="nc" id="L64">    }</span>

    BaseSSLSocketImpl(Socket socket) {
<span class="nc" id="L67">        super();</span>
<span class="nc" id="L68">        this.self = socket;</span>
<span class="nc" id="L69">        this.consumedInput = null;</span>
<span class="nc" id="L70">    }</span>

    BaseSSLSocketImpl(Socket socket, InputStream consumed) {
<span class="nc" id="L73">        super();</span>
<span class="nc" id="L74">        this.self = socket;</span>
<span class="nc" id="L75">        this.consumedInput = consumed;</span>
<span class="nc" id="L76">    }</span>

    //
    // CONSTANTS AND STATIC METHODS
    //

    /**
     * TLS requires that a close_notify warning alert is sent before the
     * connection is closed in order to avoid truncation attacks. Some
     * implementations (MS IIS and others) don't do that. The property
     * below controls whether we accept that or treat it as an error.
     *
     * The default is &quot;false&quot;, i.e. tolerate the broken behavior.
     */
    private final static String PROP_NAME =
                                &quot;com.sun.net.ssl.requireCloseNotify&quot;;

<span class="nc" id="L93">    final static boolean requireCloseNotify =</span>
<span class="nc" id="L94">                                Debug.getBooleanProperty(PROP_NAME, false);</span>

    //
    // MISC SOCKET METHODS
    //

    /**
     * Returns the unique {@link java.nio.SocketChannel SocketChannel} object
     * associated with this socket, if any.
     * @see java.net.Socket#getChannel
     */
    @Override
    public final SocketChannel getChannel() {
<span class="nc bnc" id="L107" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L108">            return super.getChannel();</span>
        } else {
<span class="nc" id="L110">            return self.getChannel();</span>
        }
    }

    /**
     * Binds the address to the socket.
     * @see java.net.Socket#bind
     */
    @Override
    public void bind(SocketAddress bindpoint) throws IOException {
        /*
         * Bind to this socket
         */
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L124">            super.bind(bindpoint);</span>
        } else {
            // If we're binding on a layered socket...
<span class="nc" id="L127">            throw new IOException(</span>
                &quot;Underlying socket should already be connected&quot;);
        }
<span class="nc" id="L130">    }</span>

    /**
     * Returns the address of the endpoint this socket is connected to
     * @see java.net.Socket#getLocalSocketAddress
     */
    @Override
    public SocketAddress getLocalSocketAddress() {
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L139">            return super.getLocalSocketAddress();</span>
        } else {
<span class="nc" id="L141">            return self.getLocalSocketAddress();</span>
        }
    }

    /**
     * Returns the address of the endpoint this socket is connected to
     * @see java.net.Socket#getRemoteSocketAddress
     */
    @Override
    public SocketAddress getRemoteSocketAddress() {
<span class="nc bnc" id="L151" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L152">            return super.getRemoteSocketAddress();</span>
        } else {
<span class="nc" id="L154">            return self.getRemoteSocketAddress();</span>
        }
    }

    /**
     * Connects this socket to the server.
     *
     * This method is either called on an unconnected SSLSocketImpl by the
     * application, or it is called in the constructor of a regular
     * SSLSocketImpl. If we are layering on top on another socket, then
     * this method should not be called, because we assume that the
     * underlying socket is already connected by the time it is passed to
     * us.
     *
     * @param   endpoint the &lt;code&gt;SocketAddress&lt;/code&gt;
     * @throws  IOException if an error occurs during the connection
     */
    @Override
    public final void connect(SocketAddress endpoint) throws IOException {
<span class="nc" id="L173">        connect(endpoint, 0);</span>
<span class="nc" id="L174">    }</span>

    /**
     * Returns the connection state of the socket.
     * @see java.net.Socket#isConnected
     */
    @Override
    public final boolean isConnected() {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L183">            return super.isConnected();</span>
        } else {
<span class="nc" id="L185">            return self.isConnected();</span>
        }
    }

    /**
     * Returns the binding state of the socket.
     * @see java.net.Socket#isBound
     */
    @Override
    public final boolean isBound() {
<span class="nc bnc" id="L195" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L196">            return super.isBound();</span>
        } else {
<span class="nc" id="L198">            return self.isBound();</span>
        }
    }

    //
    // CLOSE RELATED METHODS
    //

    /**
     * The semantics of shutdownInput is not supported in TLS 1.0
     * spec. Thus when the method is called on an SSL socket, an
     * UnsupportedOperationException will be thrown.
     *
     * @throws UnsupportedOperationException
     */
    @Override
    public final void shutdownInput() throws IOException {
<span class="nc" id="L215">        throw new UnsupportedOperationException(&quot;The method shutdownInput()&quot; +</span>
                   &quot; is not supported in SSLSocket&quot;);
    }

    /**
     * The semantics of shutdownOutput is not supported in TLS 1.0
     * spec. Thus when the method is called on an SSL socket, an
     * UnsupportedOperationException will be thrown.
     *
     * @throws UnsupportedOperationException
     */
    @Override
    public final void shutdownOutput() throws IOException {
<span class="nc" id="L228">        throw new UnsupportedOperationException(&quot;The method shutdownOutput()&quot; +</span>
                   &quot; is not supported in SSLSocket&quot;);

    }

    /**
     * Returns the input state of the socket
     * @see java.net.Socket#isInputShutdown
     */
    @Override
    public final boolean isInputShutdown() {
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L240">            return super.isInputShutdown();</span>
        } else {
<span class="nc" id="L242">            return self.isInputShutdown();</span>
        }
    }

    /**
     * Returns the output state of the socket
     * @see java.net.Socket#isOutputShutdown
     */
    @Override
    public final boolean isOutputShutdown() {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L253">            return super.isOutputShutdown();</span>
        } else {
<span class="nc" id="L255">            return self.isOutputShutdown();</span>
        }
    }

    /**
     * Ensures that the SSL connection is closed down as cleanly
     * as possible, in case the application forgets to do so.
     * This allows SSL connections to be implicitly reclaimed,
     * rather than forcing them to be explicitly reclaimed at
     * the penalty of prematurly killing SSL sessions.
     */
    @Override
    protected final void finalize() throws Throwable {
        try {
<span class="nc" id="L269">            close();</span>
<span class="nc" id="L270">        } catch (IOException e1) {</span>
            try {
<span class="nc bnc" id="L272" title="All 2 branches missed.">                if (self == this) {</span>
<span class="nc" id="L273">                    super.close();</span>
                }
<span class="nc" id="L275">            } catch (IOException e2) {</span>
                // ignore
<span class="nc" id="L277">            }</span>
        } finally {
            // We called close on the underlying socket above to
            // make doubly sure all resources got released.  We
            // don't finalize self in the case of overlain sockets,
            // that's a different object which the GC will finalize
            // separately.

<span class="nc" id="L285">            super.finalize();</span>
<span class="nc" id="L286">        }</span>
<span class="nc" id="L287">    }</span>

    //
    // GET ADDRESS METHODS
    //

    /**
     * Returns the address of the remote peer for this connection.
     */
    @Override
    public final InetAddress getInetAddress() {
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L299">            return super.getInetAddress();</span>
        } else {
<span class="nc" id="L301">            return self.getInetAddress();</span>
        }
    }

    /**
     * Gets the local address to which the socket is bound.
     *
     * @return the local address to which the socket is bound.
     * @since   JDK1.1
     */
    @Override
    public final InetAddress getLocalAddress() {
<span class="nc bnc" id="L313" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L314">            return super.getLocalAddress();</span>
        } else {
<span class="nc" id="L316">            return self.getLocalAddress();</span>
        }
    }

    /**
     * Returns the number of the remote port that this connection uses.
     */
    @Override
    public final int getPort() {
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L326">            return super.getPort();</span>
        } else {
<span class="nc" id="L328">            return self.getPort();</span>
        }
    }

    /**
     * Returns the number of the local port that this connection uses.
     */
    @Override
    public final int getLocalPort() {
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L338">            return super.getLocalPort();</span>
        } else {
<span class="nc" id="L340">            return self.getLocalPort();</span>
        }
    }

    //
    // SOCKET OPTION METHODS
    //

    /**
     * Enables or disables the Nagle optimization.
     * @see java.net.Socket#setTcpNoDelay
     */
    @Override
    public final void setTcpNoDelay(boolean value) throws SocketException {
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L355">            super.setTcpNoDelay(value);</span>
        } else {
<span class="nc" id="L357">            self.setTcpNoDelay(value);</span>
        }
<span class="nc" id="L359">    }</span>

    /**
     * Returns true if the Nagle optimization is disabled.  This
     * relates to low-level buffering of TCP traffic, delaying the
     * traffic to promote better throughput.
     *
     * @see java.net.Socket#getTcpNoDelay
     */
    @Override
    public final boolean getTcpNoDelay() throws SocketException {
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L371">            return super.getTcpNoDelay();</span>
        } else {
<span class="nc" id="L373">            return self.getTcpNoDelay();</span>
        }
    }

    /**
     * Assigns the socket's linger timeout.
     * @see java.net.Socket#setSoLinger
     */
    @Override
    public final void setSoLinger(boolean flag, int linger)
            throws SocketException {
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L385">            super.setSoLinger(flag, linger);</span>
        } else {
<span class="nc" id="L387">            self.setSoLinger(flag, linger);</span>
        }
<span class="nc" id="L389">    }</span>

    /**
     * Returns the socket's linger timeout.
     * @see java.net.Socket#getSoLinger
     */
    @Override
    public final int getSoLinger() throws SocketException {
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L398">            return super.getSoLinger();</span>
        } else {
<span class="nc" id="L400">            return self.getSoLinger();</span>
        }
    }

    /**
     * Send one byte of urgent data on the socket.
     * @see java.net.Socket#sendUrgentData
     * At this point, there seems to be no specific requirement to support
     * this for an SSLSocket. An implementation can be provided if a need
     * arises in future.
     */
    @Override
    public final void sendUrgentData(int data) throws SocketException {
<span class="nc" id="L413">        throw new SocketException(&quot;This method is not supported &quot;</span>
                        + &quot;by SSLSockets&quot;);
    }

    /**
     * Enable/disable OOBINLINE (receipt of TCP urgent data) By default, this
     * option is disabled and TCP urgent data received on a socket is silently
     * discarded.
     * @see java.net.Socket#setOOBInline
     * Setting OOBInline does not have any effect on SSLSocket,
     * since currently we don't support sending urgent data.
     */
    @Override
    public final void setOOBInline(boolean on) throws SocketException {
<span class="nc" id="L427">        throw new SocketException(&quot;This method is ineffective, since&quot;</span>
                + &quot; sending urgent data is not supported by SSLSockets&quot;);
    }

    /**
     * Tests if OOBINLINE is enabled.
     * @see java.net.Socket#getOOBInline
     */
    @Override
    public final boolean getOOBInline() throws SocketException {
<span class="nc" id="L437">        throw new SocketException(&quot;This method is ineffective, since&quot;</span>
                + &quot; sending urgent data is not supported by SSLSockets&quot;);
    }

    /**
     * Returns the socket timeout.
     * @see java.net.Socket#getSoTimeout
     */
    @Override
    public final int getSoTimeout() throws SocketException {
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L448">            return super.getSoTimeout();</span>
        } else {
<span class="nc" id="L450">            return self.getSoTimeout();</span>
        }
    }

    @Override
    public final void setSendBufferSize(int size) throws SocketException {
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L457">            super.setSendBufferSize(size);</span>
        } else {
<span class="nc" id="L459">            self.setSendBufferSize(size);</span>
        }
<span class="nc" id="L461">    }</span>

    @Override
    public final int getSendBufferSize() throws SocketException {
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L466">            return super.getSendBufferSize();</span>
        } else {
<span class="nc" id="L468">            return self.getSendBufferSize();</span>
        }
    }

    @Override
    public final void setReceiveBufferSize(int size) throws SocketException {
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L475">            super.setReceiveBufferSize(size);</span>
        } else {
<span class="nc" id="L477">            self.setReceiveBufferSize(size);</span>
        }
<span class="nc" id="L479">    }</span>

    @Override
    public final int getReceiveBufferSize() throws SocketException {
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L484">            return super.getReceiveBufferSize();</span>
        } else {
<span class="nc" id="L486">            return self.getReceiveBufferSize();</span>
        }
    }

    /**
     * Enable/disable SO_KEEPALIVE.
     * @see java.net.Socket#setKeepAlive
     */
    @Override
    public final void setKeepAlive(boolean on) throws SocketException {
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L497">            super.setKeepAlive(on);</span>
        } else {
<span class="nc" id="L499">            self.setKeepAlive(on);</span>
        }
<span class="nc" id="L501">    }</span>

    /**
     * Tests if SO_KEEPALIVE is enabled.
     * @see java.net.Socket#getKeepAlive
     */
    @Override
    public final boolean getKeepAlive() throws SocketException {
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L510">            return super.getKeepAlive();</span>
        } else {
<span class="nc" id="L512">            return self.getKeepAlive();</span>
        }
    }

    /**
     * Sets traffic class or type-of-service octet in the IP header for
     * packets sent from this Socket.
     * @see java.net.Socket#setTrafficClass
     */
    @Override
    public final void setTrafficClass(int tc) throws SocketException {
<span class="nc bnc" id="L523" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L524">            super.setTrafficClass(tc);</span>
        } else {
<span class="nc" id="L526">            self.setTrafficClass(tc);</span>
        }
<span class="nc" id="L528">    }</span>

    /**
     * Gets traffic class or type-of-service in the IP header for packets
     * sent from this Socket.
     * @see java.net.Socket#getTrafficClass
     */
    @Override
    public final int getTrafficClass() throws SocketException {
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L538">            return super.getTrafficClass();</span>
        } else {
<span class="nc" id="L540">            return self.getTrafficClass();</span>
        }
    }

    /**
     * Enable/disable SO_REUSEADDR.
     * @see java.net.Socket#setReuseAddress
     */
    @Override
    public final void setReuseAddress(boolean on) throws SocketException {
<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L551">            super.setReuseAddress(on);</span>
        } else {
<span class="nc" id="L553">            self.setReuseAddress(on);</span>
        }
<span class="nc" id="L555">    }</span>

    /**
     * Tests if SO_REUSEADDR is enabled.
     * @see java.net.Socket#getReuseAddress
     */
    @Override
    public final boolean getReuseAddress() throws SocketException {
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L564">            return super.getReuseAddress();</span>
        } else {
<span class="nc" id="L566">            return self.getReuseAddress();</span>
        }
    }

    /**
     * Sets performance preferences for this socket.
     *
     * @see java.net.Socket#setPerformancePreferences(int, int, int)
     */
    @Override
    public void setPerformancePreferences(int connectionTime,
            int latency, int bandwidth) {
<span class="nc bnc" id="L578" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L579">            super.setPerformancePreferences(</span>
                connectionTime, latency, bandwidth);
        } else {
<span class="nc" id="L582">            self.setPerformancePreferences(</span>
                connectionTime, latency, bandwidth);
        }
<span class="nc" id="L585">    }</span>

    @Override
    public String toString() {
<span class="nc bnc" id="L589" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L590">            return super.toString();</span>
        }

<span class="nc" id="L593">        return self.toString();</span>
    }

    @Override
    public InputStream getInputStream() throws IOException {
<span class="nc bnc" id="L598" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L599">            return super.getInputStream();</span>
        }

<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (consumedInput != null) {</span>
<span class="nc" id="L603">            return new SequenceInputStream(consumedInput,</span>
<span class="nc" id="L604">                                                self.getInputStream());</span>
        }

<span class="nc" id="L607">        return self.getInputStream();</span>
    }

    @Override
    public OutputStream getOutputStream() throws IOException {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L613">            return super.getOutputStream();</span>
        }

<span class="nc" id="L616">        return self.getOutputStream();</span>
    }

    @Override
    public synchronized void close() throws IOException {
<span class="nc bnc" id="L621" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L622">            super.close();</span>
        } else {
<span class="nc" id="L624">            self.close();</span>
        }
<span class="nc" id="L626">    }</span>

    @Override
    public synchronized void setSoTimeout(int timeout) throws SocketException {
<span class="nc bnc" id="L630" title="All 2 branches missed.">        if (self == this) {</span>
<span class="nc" id="L631">            super.setSoTimeout(timeout);</span>
        } else {
<span class="nc" id="L633">            self.setSoTimeout(timeout);</span>
        }
<span class="nc" id="L635">    }</span>

    boolean isLayered() {
<span class="nc bnc" id="L638" title="All 2 branches missed.">        return (self != this);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>