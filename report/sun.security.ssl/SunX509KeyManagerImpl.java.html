<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SunX509KeyManagerImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">SunX509KeyManagerImpl.java</span></div><h1>SunX509KeyManagerImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.ssl;

import javax.net.ssl.*;
import java.security.*;
import java.security.cert.*;
import java.security.cert.Certificate;
import java.util.*;
import java.net.Socket;

import javax.security.auth.x500.X500Principal;


/**
 * An implementation of X509KeyManager backed by a KeyStore.
 *
 * The backing KeyStore is inspected when this object is constructed.
 * All key entries containing a PrivateKey and a non-empty chain of
 * X509Certificate are then copied into an internal store. This means
 * that subsequent modifications of the KeyStore have no effect on the
 * X509KeyManagerImpl object.
 *
 * Note that this class assumes that all keys are protected by the same
 * password.
 *
 * The JSSE handshake code currently calls into this class via
 * chooseClientAlias() and chooseServerAlias() to find the certificates to
 * use. As implemented here, both always return the first alias returned by
 * getClientAliases() and getServerAliases(). In turn, these methods are
 * implemented by calling getAliases(), which performs the actual lookup.
 *
 * Note that this class currently implements no checking of the local
 * certificates. In particular, it is *not* guaranteed that:
 *  . the certificates are within their validity period and not revoked
 *  . the signatures verify
 *  . they form a PKIX compliant chain.
 *  . the certificate extensions allow the certificate to be used for
 *    the desired purpose.
 *
 * Chains that fail any of these criteria will probably be rejected by
 * the remote peer.
 *
 */
final class SunX509KeyManagerImpl extends X509ExtendedKeyManager {

<span class="nc" id="L70">    private static final Debug debug = Debug.getInstance(&quot;ssl&quot;);</span>

<span class="nc" id="L72">    private static final String[] STRING0 = new String[0];</span>

    /*
     * The credentials from the KeyStore as
     * Map: String(alias) -&gt; X509Credentials(credentials)
     */
    private Map&lt;String,X509Credentials&gt; credentialsMap;

    /*
     * Cached server aliases for the case issuers == null.
     * (in the current JSSE implementation, issuers are always null for
     * server certs). See chooseServerAlias() for details.
     *
     * Map: String(keyType) -&gt; String[](alias)
     */
    private final Map&lt;String,String[]&gt; serverAliasCache;

    /*
     * Basic container for credentials implemented as an inner class.
     */
    private static class X509Credentials {
        PrivateKey privateKey;
        X509Certificate[] certificates;
        private Set&lt;X500Principal&gt; issuerX500Principals;

<span class="nc" id="L97">        X509Credentials(PrivateKey privateKey, X509Certificate[] certificates) {</span>
            // assert privateKey and certificates != null
<span class="nc" id="L99">            this.privateKey = privateKey;</span>
<span class="nc" id="L100">            this.certificates = certificates;</span>
<span class="nc" id="L101">        }</span>

        synchronized Set&lt;X500Principal&gt; getIssuerX500Principals() {
            // lazy initialization
<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (issuerX500Principals == null) {</span>
<span class="nc" id="L106">                issuerX500Principals = new HashSet&lt;X500Principal&gt;();</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">                for (int i = 0; i &lt; certificates.length; i++) {</span>
<span class="nc" id="L108">                    issuerX500Principals.add(</span>
<span class="nc" id="L109">                                certificates[i].getIssuerX500Principal());</span>
                }
            }
<span class="nc" id="L112">            return issuerX500Principals;</span>
        }
    }

    SunX509KeyManagerImpl(KeyStore ks, char[] password)
            throws KeyStoreException,
<span class="nc" id="L118">            NoSuchAlgorithmException, UnrecoverableKeyException {</span>

<span class="nc" id="L120">        credentialsMap = new HashMap&lt;String,X509Credentials&gt;();</span>
<span class="nc" id="L121">        serverAliasCache = Collections.synchronizedMap(</span>
                            new HashMap&lt;String,String[]&gt;());
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (ks == null) {</span>
<span class="nc" id="L124">            return;</span>
        }

<span class="nc" id="L127">        for (Enumeration&lt;String&gt; aliases = ks.aliases();</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">                                        aliases.hasMoreElements(); ) {</span>
<span class="nc" id="L129">            String alias = aliases.nextElement();</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">            if (!ks.isKeyEntry(alias)) {</span>
<span class="nc" id="L131">                continue;</span>
            }
<span class="nc" id="L133">            Key key = ks.getKey(alias, password);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">            if (key instanceof PrivateKey == false) {</span>
<span class="nc" id="L135">                continue;</span>
            }
<span class="nc" id="L137">            Certificate[] certs = ks.getCertificateChain(alias);</span>
<span class="nc bnc" id="L138" title="All 6 branches missed.">            if ((certs == null) || (certs.length == 0) ||</span>
                    !(certs[0] instanceof X509Certificate)) {
<span class="nc" id="L140">                continue;</span>
            }
<span class="nc bnc" id="L142" title="All 2 branches missed.">            if (!(certs instanceof X509Certificate[])) {</span>
<span class="nc" id="L143">                Certificate[] tmp = new X509Certificate[certs.length];</span>
<span class="nc" id="L144">                System.arraycopy(certs, 0, tmp, 0, certs.length);</span>
<span class="nc" id="L145">                certs = tmp;</span>
            }

<span class="nc" id="L148">            X509Credentials cred = new X509Credentials((PrivateKey)key,</span>
                (X509Certificate[])certs);
<span class="nc" id="L150">            credentialsMap.put(alias, cred);</span>
<span class="nc bnc" id="L151" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;keymanager&quot;)) {</span>
<span class="nc" id="L152">                System.out.println(&quot;***&quot;);</span>
<span class="nc" id="L153">                System.out.println(&quot;found key for : &quot; + alias);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">                for (int i = 0; i &lt; certs.length; i++) {</span>
<span class="nc" id="L155">                    System.out.println(&quot;chain [&quot; + i + &quot;] = &quot;</span>
                    + certs[i]);
                }
<span class="nc" id="L158">                System.out.println(&quot;***&quot;);</span>
            }
<span class="nc" id="L160">        }</span>
<span class="nc" id="L161">    }</span>

    /*
     * Returns the certificate chain associated with the given alias.
     *
     * @return the certificate chain (ordered with the user's certificate first
     * and the root certificate authority last)
     */
    @Override
    public X509Certificate[] getCertificateChain(String alias) {
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (alias == null) {</span>
<span class="nc" id="L172">            return null;</span>
        }
<span class="nc" id="L174">        X509Credentials cred = credentialsMap.get(alias);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (cred == null) {</span>
<span class="nc" id="L176">            return null;</span>
        } else {
<span class="nc" id="L178">            return cred.certificates.clone();</span>
        }
    }

    /*
     * Returns the key associated with the given alias
     */
    @Override
    public PrivateKey getPrivateKey(String alias) {
<span class="nc bnc" id="L187" title="All 2 branches missed.">        if (alias == null) {</span>
<span class="nc" id="L188">            return null;</span>
        }
<span class="nc" id="L190">        X509Credentials cred = credentialsMap.get(alias);</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (cred == null) {</span>
<span class="nc" id="L192">            return null;</span>
        } else {
<span class="nc" id="L194">            return cred.privateKey;</span>
        }
    }

    /*
     * Choose an alias to authenticate the client side of a secure
     * socket given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     */
    @Override
    public String chooseClientAlias(String[] keyTypes, Principal[] issuers,
            Socket socket) {
        /*
         * We currently don't do anything with socket, but
         * someday we might.  It might be a useful hint for
         * selecting one of the aliases we get back from
         * getClientAliases().
         */

<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (keyTypes == null) {</span>
<span class="nc" id="L214">            return null;</span>
        }

<span class="nc bnc" id="L217" title="All 2 branches missed.">        for (int i = 0; i &lt; keyTypes.length; i++) {</span>
<span class="nc" id="L218">            String[] aliases = getClientAliases(keyTypes[i], issuers);</span>
<span class="nc bnc" id="L219" title="All 4 branches missed.">            if ((aliases != null) &amp;&amp; (aliases.length &gt; 0)) {</span>
<span class="nc" id="L220">                return aliases[0];</span>
            }
        }
<span class="nc" id="L223">        return null;</span>
    }

    /*
     * Choose an alias to authenticate the client side of an
     * &lt;code&gt;SSLEngine&lt;/code&gt; connection given the public key type
     * and the list of certificate issuer authorities recognized by
     * the peer (if any).
     *
     * @since 1.5
     */
    @Override
    public String chooseEngineClientAlias(String[] keyType,
            Principal[] issuers, SSLEngine engine) {
        /*
         * If we ever start using socket as a selection criteria,
         * we'll need to adjust this.
         */
<span class="nc" id="L241">        return chooseClientAlias(keyType, issuers, null);</span>
    }

    /*
     * Choose an alias to authenticate the server side of a secure
     * socket given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     */
    @Override
    public String chooseServerAlias(String keyType,
            Principal[] issuers, Socket socket) {
        /*
         * We currently don't do anything with socket, but
         * someday we might.  It might be a useful hint for
         * selecting one of the aliases we get back from
         * getServerAliases().
         */
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (keyType == null) {</span>
<span class="nc" id="L259">            return null;</span>
        }

        String[] aliases;

<span class="nc bnc" id="L264" title="All 4 branches missed.">        if (issuers == null || issuers.length == 0) {</span>
<span class="nc" id="L265">            aliases = serverAliasCache.get(keyType);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (aliases == null) {</span>
<span class="nc" id="L267">                aliases = getServerAliases(keyType, issuers);</span>
                // Cache the result (positive and negative lookups)
<span class="nc bnc" id="L269" title="All 2 branches missed.">                if (aliases == null) {</span>
<span class="nc" id="L270">                    aliases = STRING0;</span>
                }
<span class="nc" id="L272">                serverAliasCache.put(keyType, aliases);</span>
            }
        } else {
<span class="nc" id="L275">            aliases = getServerAliases(keyType, issuers);</span>
        }
<span class="nc bnc" id="L277" title="All 4 branches missed.">        if ((aliases != null) &amp;&amp; (aliases.length &gt; 0)) {</span>
<span class="nc" id="L278">            return aliases[0];</span>
        }
<span class="nc" id="L280">        return null;</span>
    }

    /*
     * Choose an alias to authenticate the server side of an
     * &lt;code&gt;SSLEngine&lt;/code&gt; connection given the public key type
     * and the list of certificate issuer authorities recognized by
     * the peer (if any).
     *
     * @since 1.5
     */
    @Override
    public String chooseEngineServerAlias(String keyType,
            Principal[] issuers, SSLEngine engine) {
        /*
         * If we ever start using socket as a selection criteria,
         * we'll need to adjust this.
         */
<span class="nc" id="L298">        return chooseServerAlias(keyType, issuers, null);</span>
    }

    /*
     * Get the matching aliases for authenticating the client side of a secure
     * socket given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     */
    @Override
    public String[] getClientAliases(String keyType, Principal[] issuers) {
<span class="nc" id="L308">        return getAliases(keyType, issuers);</span>
    }

    /*
     * Get the matching aliases for authenticating the server side of a secure
     * socket given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     */
    @Override
    public String[] getServerAliases(String keyType, Principal[] issuers) {
<span class="nc" id="L318">        return getAliases(keyType, issuers);</span>
    }

    /*
     * Get the matching aliases for authenticating the either side of a secure
     * socket given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     *
     * Issuers comes to us in the form of X500Principal[].
     */
    private String[] getAliases(String keyType, Principal[] issuers) {
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if (keyType == null) {</span>
<span class="nc" id="L330">            return null;</span>
        }
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (issuers == null) {</span>
<span class="nc" id="L333">            issuers = new X500Principal[0];</span>
        }
<span class="nc bnc" id="L335" title="All 2 branches missed.">        if (issuers instanceof X500Principal[] == false) {</span>
            // normally, this will never happen but try to recover if it does
<span class="nc" id="L337">            issuers = convertPrincipals(issuers);</span>
        }
        String sigType;
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (keyType.contains(&quot;_&quot;)) {</span>
<span class="nc" id="L341">            int k = keyType.indexOf(&quot;_&quot;);</span>
<span class="nc" id="L342">            sigType = keyType.substring(k + 1);</span>
<span class="nc" id="L343">            keyType = keyType.substring(0, k);</span>
<span class="nc" id="L344">        } else {</span>
<span class="nc" id="L345">            sigType = null;</span>
        }

<span class="nc" id="L348">        X500Principal[] x500Issuers = (X500Principal[])issuers;</span>
        // the algorithm below does not produce duplicates, so avoid Set
<span class="nc" id="L350">        List&lt;String&gt; aliases = new ArrayList&lt;&gt;();</span>

        for (Map.Entry&lt;String,X509Credentials&gt; entry :
<span class="nc bnc" id="L353" title="All 2 branches missed.">                                                credentialsMap.entrySet()) {</span>

<span class="nc" id="L355">            String alias = entry.getKey();</span>
<span class="nc" id="L356">            X509Credentials credentials = entry.getValue();</span>
<span class="nc" id="L357">            X509Certificate[] certs = credentials.certificates;</span>

<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (!keyType.equals(certs[0].getPublicKey().getAlgorithm())) {</span>
<span class="nc" id="L360">                continue;</span>
            }
<span class="nc bnc" id="L362" title="All 2 branches missed.">            if (sigType != null) {</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">                if (certs.length &gt; 1) {</span>
                    // if possible, check the public key in the issuer cert
<span class="nc bnc" id="L365" title="All 2 branches missed.">                    if (!sigType.equals(</span>
<span class="nc" id="L366">                            certs[1].getPublicKey().getAlgorithm())) {</span>
<span class="nc" id="L367">                        continue;</span>
                    }
                } else {
                    // Check the signature algorithm of the certificate itself.
                    // Look for the &quot;withRSA&quot; in &quot;SHA1withRSA&quot;, etc.
<span class="nc" id="L372">                    String sigAlgName =</span>
<span class="nc" id="L373">                        certs[0].getSigAlgName().toUpperCase(Locale.ENGLISH);</span>
<span class="nc" id="L374">                    String pattern = &quot;WITH&quot; +</span>
<span class="nc" id="L375">                        sigType.toUpperCase(Locale.ENGLISH);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                    if (sigAlgName.contains(pattern) == false) {</span>
<span class="nc" id="L377">                        continue;</span>
                    }
                }
            }

<span class="nc bnc" id="L382" title="All 2 branches missed.">            if (issuers.length == 0) {</span>
                // no issuer specified, match all
<span class="nc" id="L384">                aliases.add(alias);</span>
<span class="nc bnc" id="L385" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;keymanager&quot;)) {</span>
<span class="nc" id="L386">                    System.out.println(&quot;matching alias: &quot; + alias);</span>
                }
            } else {
<span class="nc" id="L389">                Set&lt;X500Principal&gt; certIssuers =</span>
<span class="nc" id="L390">                                        credentials.getIssuerX500Principals();</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">                for (int i = 0; i &lt; x500Issuers.length; i++) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                    if (certIssuers.contains(issuers[i])) {</span>
<span class="nc" id="L393">                        aliases.add(alias);</span>
<span class="nc bnc" id="L394" title="All 4 branches missed.">                        if (debug != null &amp;&amp; Debug.isOn(&quot;keymanager&quot;)) {</span>
<span class="nc" id="L395">                            System.out.println(&quot;matching alias: &quot; + alias);</span>
                        }
                        break;
                    }
                }
            }
<span class="nc" id="L401">        }</span>

<span class="nc" id="L403">        String[] aliasStrings = aliases.toArray(STRING0);</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">        return ((aliasStrings.length == 0) ? null : aliasStrings);</span>
    }

    /*
     * Convert an array of Principals to an array of X500Principals, if
     * possible. Principals that cannot be converted are ignored.
     */
    private static X500Principal[] convertPrincipals(Principal[] principals) {
<span class="nc" id="L412">        List&lt;X500Principal&gt; list = new ArrayList&lt;&gt;(principals.length);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">        for (int i = 0; i &lt; principals.length; i++) {</span>
<span class="nc" id="L414">            Principal p = principals[i];</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (p instanceof X500Principal) {</span>
<span class="nc" id="L416">                list.add((X500Principal)p);</span>
            } else {
                try {
<span class="nc" id="L419">                    list.add(new X500Principal(p.getName()));</span>
<span class="nc" id="L420">                } catch (IllegalArgumentException e) {</span>
                    // ignore
<span class="nc" id="L422">                }</span>
            }
        }
<span class="nc" id="L425">        return list.toArray(new X500Principal[list.size()]);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>