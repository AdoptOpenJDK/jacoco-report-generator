<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>OutputRecord.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">OutputRecord.java</span></div><h1>OutputRecord.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package sun.security.ssl;

import java.io.*;
import java.nio.*;
import java.util.Arrays;

import javax.net.ssl.SSLException;
import sun.misc.HexDumpEncoder;


/**
 * SSL 3.0 records, as written to a TCP stream.
 *
 * Each record has a message area that starts out with data supplied by the
 * application.  It may grow/shrink due to compression and will be modified
 * in place for mac-ing and encryption.
 *
 * Handshake records have additional needs, notably accumulation of a set
 * of hashes which are used to establish that handshaking was done right.
 * Handshake records usually have several handshake messages each, and we
 * need message-level control over what's hashed.
 *
 * @author David Brownell
 */
<span class="nc bnc" id="L51" title="All 2 branches missed.">class OutputRecord extends ByteArrayOutputStream implements Record {</span>

    private HandshakeHash       handshakeHash;
    private int                 lastHashed;
    private boolean             firstMessage;
    final private byte          contentType;
    private int                 headerOffset;

    // current protocol version, sent as record version
    ProtocolVersion     protocolVersion;

    // version for the ClientHello message. Only relevant if this is a
    // client handshake record. If set to ProtocolVersion.SSL20Hello,
    // the V3 client hello is converted to V2 format.
    private ProtocolVersion     helloVersion;

    /* Class and subclass dynamic debugging support */
<span class="nc" id="L68">    static final Debug debug = Debug.getInstance(&quot;ssl&quot;);</span>

    /*
     * Default constructor makes a record supporting the maximum
     * SSL record size.  It allocates the header bytes directly.
     *
     * The structure of the byte buffer looks like:
     *
     *     |---------+--------+-------+---------------------------------|
     *     | unused  | header |  IV   | content, MAC/TAG, padding, etc. |
     *     |    headerPlusMaxIVSize   |
     *
     * unused: unused part of the buffer of size
     *
     *             headerPlusMaxIVSize - header size - IV size
     *
     *         When this object is created, we don't know the protocol
     *         version number, IV length, etc., so reserve space in front
     *         to avoid extra data movement (copies).
     * header: the header of an SSL record
     * IV:     the optional IV/nonce field, it is only required for block
     *         (TLS 1.1 or later) and AEAD cipher suites.
     *
     * @param type the content type for the record
     */
    OutputRecord(byte type, int size) {
<span class="nc" id="L94">        super(size);</span>
<span class="nc" id="L95">        this.protocolVersion = ProtocolVersion.DEFAULT;</span>
<span class="nc" id="L96">        this.helloVersion = ProtocolVersion.DEFAULT_HELLO;</span>
<span class="nc" id="L97">        firstMessage = true;</span>
<span class="nc" id="L98">        count = headerPlusMaxIVSize;</span>
<span class="nc" id="L99">        contentType = type;</span>
<span class="nc" id="L100">        lastHashed = count;</span>
<span class="nc" id="L101">        headerOffset = headerPlusMaxIVSize - headerSize;</span>
<span class="nc" id="L102">    }</span>

    OutputRecord(byte type) {
<span class="nc" id="L105">        this(type, recordSize(type));</span>
<span class="nc" id="L106">    }</span>

    /**
     * Get the size of the buffer we need for records of the specified
     * type.
     */
    private static int recordSize(byte type) {
<span class="nc bnc" id="L113" title="All 4 branches missed.">        if ((type == ct_change_cipher_spec) || (type == ct_alert)) {</span>
<span class="nc" id="L114">            return maxAlertRecordSize;</span>
        } else {
<span class="nc" id="L116">            return maxRecordSize;</span>
        }
    }

    /*
     * Updates the SSL version of this record.
     */
    synchronized void setVersion(ProtocolVersion protocolVersion) {
<span class="nc" id="L124">        this.protocolVersion = protocolVersion;</span>
<span class="nc" id="L125">    }</span>

    /*
     * Updates helloVersion of this record.
     */
    synchronized void setHelloVersion(ProtocolVersion helloVersion) {
<span class="nc" id="L131">        this.helloVersion = helloVersion;</span>
<span class="nc" id="L132">    }</span>

    /*
     * Reset the record so that it can be refilled, starting
     * immediately after the header.
     */
    @Override
    public synchronized void reset() {
<span class="nc" id="L140">        super.reset();</span>
<span class="nc" id="L141">        count = headerPlusMaxIVSize;</span>
<span class="nc" id="L142">        lastHashed = count;</span>
<span class="nc" id="L143">        headerOffset = headerPlusMaxIVSize - headerSize;</span>
<span class="nc" id="L144">    }</span>

    /*
     * For handshaking, we need to be able to hash every byte above the
     * record marking layer.  This is where we're guaranteed to see those
     * bytes, so this is where we can hash them.
     */
    void setHandshakeHash(HandshakeHash handshakeHash) {
<span class="nc bnc" id="L152" title="All 4 branches missed.">        assert(contentType == ct_handshake);</span>
<span class="nc" id="L153">        this.handshakeHash = handshakeHash;</span>
<span class="nc" id="L154">    }</span>

    /*
     * We hash (the plaintext) on demand.  There is one place where
     * we want to access the hash in the middle of a record:  client
     * cert message gets hashed, and part of the same record is the
     * client cert verify message which uses that hash.  So we track
     * how much of each record we've hashed so far.
     */
    void doHashes() {
<span class="nc" id="L164">        int len = count - lastHashed;</span>

<span class="nc bnc" id="L166" title="All 2 branches missed.">        if (len &gt; 0) {</span>
<span class="nc" id="L167">            hashInternal(buf, lastHashed, len);</span>
<span class="nc" id="L168">            lastHashed = count;</span>
        }
<span class="nc" id="L170">    }</span>

    /*
     * Need a helper function so we can hash the V2 hello correctly
     */
    private void hashInternal(byte buf [], int offset, int len) {
<span class="nc bnc" id="L176" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;data&quot;)) {</span>
            try {
<span class="nc" id="L178">                HexDumpEncoder hd = new HexDumpEncoder();</span>

<span class="nc" id="L180">                System.out.println(&quot;[write] MD5 and SHA1 hashes:  len = &quot;</span>
                    + len);
<span class="nc" id="L182">                hd.encodeBuffer(new ByteArrayInputStream(buf,</span>
                    lastHashed, len), System.out);
<span class="nc" id="L184">            } catch (IOException e) { }</span>
        }

<span class="nc" id="L187">        handshakeHash.update(buf, lastHashed, len);</span>
<span class="nc" id="L188">        lastHashed = count;</span>
<span class="nc" id="L189">    }</span>

    /*
     * Return true iff the record is empty -- to avoid doing the work
     * of sending empty records over the network.
     */
    boolean isEmpty() {
<span class="nc bnc" id="L196" title="All 2 branches missed.">        return count == headerPlusMaxIVSize;</span>
    }

    /*
     * Return true if the record is of an alert of the given description.
     *
     * Per SSL/TLS specifications, alert messages convey the severity of the
     * message (warning or fatal) and a description of the alert. An alert
     * is defined with a two bytes struct, {byte level, byte description},
     * following after the header bytes.
     */
    boolean isAlert(byte description) {
<span class="nc bnc" id="L208" title="All 4 branches missed.">        if ((count &gt; (headerPlusMaxIVSize + 1)) &amp;&amp; (contentType == ct_alert)) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">            return buf[headerPlusMaxIVSize + 1] == description;</span>
        }

<span class="nc" id="L212">        return false;</span>
    }

    /*
     * Encrypt ... length may grow due to block cipher padding, or
     * message authentication code or tag.
     */
    void encrypt(Authenticator authenticator, CipherBox box)
            throws IOException {

        // In case we are automatically flushing a handshake stream, make
        // sure we have hashed the message first.
        //
        // when we support compression, hashing can't go here
        // since it'll need to be done on the uncompressed data,
        // and the MAC applies to the compressed data.
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (contentType == ct_handshake) {</span>
<span class="nc" id="L229">            doHashes();</span>
        }

        // Requires message authentication code for stream and block
        // cipher suites.
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (authenticator instanceof MAC) {</span>
<span class="nc" id="L235">            MAC signer = (MAC)authenticator;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (signer.MAClen() != 0) {</span>
<span class="nc" id="L237">                byte[] hash = signer.compute(contentType, buf,</span>
                    headerPlusMaxIVSize, count - headerPlusMaxIVSize, false);
<span class="nc" id="L239">                write(hash);</span>
            }
        }

<span class="nc bnc" id="L243" title="All 2 branches missed.">        if (!box.isNullCipher()) {</span>
            // Requires explicit IV/nonce for CBC/AEAD cipher suites for
            // TLS 1.1 or later.
<span class="nc bnc" id="L246" title="All 2 branches missed.">            if ((protocolVersion.v &gt;= ProtocolVersion.TLS11.v) &amp;&amp;</span>
<span class="nc bnc" id="L247" title="All 4 branches missed.">                                    (box.isCBCMode() || box.isAEADMode())) {</span>
<span class="nc" id="L248">                byte[] nonce = box.createExplicitNonce(authenticator,</span>
                                    contentType, count - headerPlusMaxIVSize);
<span class="nc" id="L250">                int offset = headerPlusMaxIVSize - nonce.length;</span>
<span class="nc" id="L251">                System.arraycopy(nonce, 0, buf, offset, nonce.length);</span>
<span class="nc" id="L252">                headerOffset = offset - headerSize;</span>
<span class="nc" id="L253">            } else {</span>
<span class="nc" id="L254">                headerOffset = headerPlusMaxIVSize - headerSize;</span>
            }

            // encrypt the content
<span class="nc" id="L258">            int offset = headerPlusMaxIVSize;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (!box.isAEADMode()) {</span>
                // The explicit IV can be encrypted.
<span class="nc" id="L261">                offset = headerOffset + headerSize;</span>
            }   // Otherwise, DON'T encrypt the nonce_explicit for AEAD mode

<span class="nc" id="L264">            count = offset + box.encrypt(buf, offset, count - offset);</span>
        }
<span class="nc" id="L266">    }</span>

    /*
     * Tell how full the buffer is ... for filling it with application or
     * handshake data.
     */
    final int availableDataBytes() {
<span class="nc" id="L273">        int dataSize = count - headerPlusMaxIVSize;</span>
<span class="nc" id="L274">        return maxDataSize - dataSize;</span>
    }

    /*
     * Increases the capacity if necessary to ensure that it can hold
     * at least the number of elements specified by the minimum
     * capacity argument.
     *
     * Note that the increased capacity is only can be used for held
     * record buffer. Please DO NOT update the availableDataBytes()
     * according to the expended buffer capacity.
     *
     * @see availableDataBytes()
     */
    private void ensureCapacity(int minCapacity) {
        // overflow-conscious code
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (minCapacity &gt; buf.length) {</span>
<span class="nc" id="L291">            buf = Arrays.copyOf(buf, minCapacity);</span>
        }
<span class="nc" id="L293">    }</span>

    /*
     * Return the type of SSL record that's buffered here.
     */
    final byte contentType() {
<span class="nc" id="L299">        return contentType;</span>
    }

    /*
     * Write the record out on the stream.  Note that you must have (in
     * order) compressed the data, appended the MAC, and encrypted it in
     * order for the record to be understood by the other end.  (Some of
     * those steps will be null early in handshaking.)
     *
     * Note that this does no locking for the connection, it's required
     * that synchronization be done elsewhere.  Also, this does its work
     * in a single low level write, for efficiency.
     */
    void write(OutputStream s, boolean holdRecord,
            ByteArrayOutputStream heldRecordBuffer) throws IOException {

        /*
         * Don't emit content-free records.  (Even change cipher spec
         * messages have a byte of data!)
         */
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (count == headerPlusMaxIVSize) {</span>
<span class="nc" id="L320">            return;</span>
        }

<span class="nc" id="L323">        int length = count - headerOffset - headerSize;</span>
        // &quot;should&quot; really never write more than about 14 Kb...
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (length &lt; 0) {</span>
<span class="nc" id="L326">            throw new SSLException(&quot;output record size too small: &quot;</span>
                + length);
        }

<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (debug != null</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">                &amp;&amp; (Debug.isOn(&quot;record&quot;) || Debug.isOn(&quot;handshake&quot;))) {</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">            if ((debug != null &amp;&amp; Debug.isOn(&quot;record&quot;))</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">                    || contentType() == ct_change_cipher_spec)</span>
<span class="nc" id="L334">                System.out.println(Thread.currentThread().getName()</span>
                    // v3.0/v3.1 ...
                    + &quot;, WRITE: &quot; + protocolVersion
<span class="nc" id="L337">                    + &quot; &quot; + InputRecord.contentName(contentType())</span>
                    + &quot;, length = &quot; + length);
        }

        /*
         * If this is the initial ClientHello on this connection and
         * we're not trying to resume a (V3) session then send a V2
         * ClientHello instead so we can detect V2 servers cleanly.
         */
<span class="nc bnc" id="L346" title="All 4 branches missed.">         if (firstMessage &amp;&amp; useV2Hello()) {</span>
<span class="nc" id="L347">            byte[] v3Msg = new byte[length - 4];</span>
<span class="nc" id="L348">            System.arraycopy(buf, headerPlusMaxIVSize + 4,</span>
                                        v3Msg, 0, v3Msg.length);
<span class="nc" id="L350">            headerOffset = 0;   // reset the header offset</span>
<span class="nc" id="L351">            V3toV2ClientHello(v3Msg);</span>
<span class="nc" id="L352">            handshakeHash.reset();</span>
<span class="nc" id="L353">            lastHashed = 2;</span>
<span class="nc" id="L354">            doHashes();</span>
<span class="nc bnc" id="L355" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;record&quot;))  {</span>
<span class="nc" id="L356">                System.out.println(</span>
<span class="nc" id="L357">                    Thread.currentThread().getName()</span>
                    + &quot;, WRITE: SSLv2 client hello message&quot;
                    + &quot;, length = &quot; + (count - 2)); // 2 byte SSLv2 header
            }
<span class="nc" id="L361">        } else {</span>
            /*
             * Fill out the header, write it and the message.
             */
<span class="nc" id="L365">            buf[headerOffset + 0] = contentType;</span>
<span class="nc" id="L366">            buf[headerOffset + 1] = protocolVersion.major;</span>
<span class="nc" id="L367">            buf[headerOffset + 2] = protocolVersion.minor;</span>
<span class="nc" id="L368">            buf[headerOffset + 3] = (byte)(length &gt;&gt; 8);</span>
<span class="nc" id="L369">            buf[headerOffset + 4] = (byte)(length);</span>
        }
<span class="nc" id="L371">        firstMessage = false;</span>

        /*
         * The upper levels may want us to delay sending this packet so
         * multiple TLS Records can be sent in one (or more) TCP packets.
         * If so, add this packet to the heldRecordBuffer.
         *
         * NOTE:  all writes have been synchronized by upper levels.
         */
<span class="nc" id="L380">        int debugOffset = 0;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (holdRecord) {</span>
            /*
             * If holdRecord is true, we must have a heldRecordBuffer.
             *
             * Don't worry about the override of writeBuffer(), because
             * when holdRecord is true, the implementation in this class
             * will be used.
             */
<span class="nc" id="L389">            writeBuffer(heldRecordBuffer,</span>
                        buf, headerOffset, count - headerOffset, debugOffset);
        } else {
            // It's time to send, do we have buffered data?
            // May or may not have a heldRecordBuffer.
<span class="nc bnc" id="L394" title="All 4 branches missed.">            if (heldRecordBuffer != null &amp;&amp; heldRecordBuffer.size() &gt; 0) {</span>
<span class="nc" id="L395">                int heldLen = heldRecordBuffer.size();</span>

                // Ensure the capacity of this buffer.
<span class="nc" id="L398">                int newCount = count + heldLen - headerOffset;</span>
<span class="nc" id="L399">                ensureCapacity(newCount);</span>

                // Slide everything in the buffer to the right.
<span class="nc" id="L402">                System.arraycopy(buf, headerOffset,</span>
                                    buf, heldLen, count - headerOffset);

                // Prepend the held record to the buffer.
<span class="nc" id="L406">                System.arraycopy(</span>
<span class="nc" id="L407">                    heldRecordBuffer.toByteArray(), 0, buf, 0, heldLen);</span>
<span class="nc" id="L408">                count = newCount;</span>
<span class="nc" id="L409">                headerOffset = 0;</span>

                // Clear the held buffer.
<span class="nc" id="L412">                heldRecordBuffer.reset();</span>

                // The held buffer has been dumped, set the debug dump offset.
<span class="nc" id="L415">                debugOffset = heldLen;</span>
            }
<span class="nc" id="L417">            writeBuffer(s, buf, headerOffset,</span>
                        count - headerOffset, debugOffset);
        }

<span class="nc" id="L421">        reset();</span>
<span class="nc" id="L422">    }</span>

    /*
     * Actually do the write here.  For SSLEngine's HS data,
     * we'll override this method and let it take the appropriate
     * action.
     */
    void writeBuffer(OutputStream s, byte [] buf, int off, int len,
            int debugOffset) throws IOException {
<span class="nc" id="L431">        s.write(buf, off, len);</span>
<span class="nc" id="L432">        s.flush();</span>

        // Output only the record from the specified debug offset.
<span class="nc bnc" id="L435" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;packet&quot;)) {</span>
            try {
<span class="nc" id="L437">                HexDumpEncoder hd = new HexDumpEncoder();</span>

<span class="nc" id="L439">                System.out.println(&quot;[Raw write]: length = &quot; +</span>
                                                    (len - debugOffset));
<span class="nc" id="L441">                hd.encodeBuffer(new ByteArrayInputStream(buf,</span>
                    off + debugOffset, len - debugOffset), System.out);
<span class="nc" id="L443">            } catch (IOException e) { }</span>
        }
<span class="nc" id="L445">    }</span>

    /*
     * Return whether the buffer contains a ClientHello message that should
     * be converted to V2 format.
     */
    private boolean useV2Hello() {
<span class="nc bnc" id="L452" title="All 10 branches missed.">        return firstMessage</span>
            &amp;&amp; (helloVersion == ProtocolVersion.SSL20Hello)
            &amp;&amp; (contentType == ct_handshake)
            &amp;&amp; (buf[headerOffset + 5] == HandshakeMessage.ht_client_hello)
                                            //  5: recode header size
            &amp;&amp; (buf[headerPlusMaxIVSize + 4 + 2 + 32] == 0);
                                            // V3 session ID is empty
                                            //  4: handshake header size
                                            //  2: client_version in ClientHello
                                            // 32: random in ClientHello
    }

    /*
     * Detect &quot;old&quot; servers which are capable of SSL V2.0 protocol ... for
     * example, Netscape Commerce 1.0 servers.  The V3 message is in the
     * header and the bytes passed as parameter.  This routine translates
     * the V3 message into an equivalent V2 one.
     *
     * Note that the translation will strip off all hello extensions as
     * SSL V2.0 does not support hello extension.
     */
    private void V3toV2ClientHello(byte v3Msg []) throws SSLException {
<span class="nc" id="L474">        int v3SessionIdLenOffset = 2 + 32; // version + nonce</span>
<span class="nc" id="L475">        int v3SessionIdLen = v3Msg[v3SessionIdLenOffset];</span>
<span class="nc" id="L476">        int v3CipherSpecLenOffset = v3SessionIdLenOffset + 1 + v3SessionIdLen;</span>
<span class="nc" id="L477">        int v3CipherSpecLen = ((v3Msg[v3CipherSpecLenOffset] &amp; 0xff) &lt;&lt; 8) +</span>
          (v3Msg[v3CipherSpecLenOffset + 1] &amp; 0xff);
<span class="nc" id="L479">        int cipherSpecs = v3CipherSpecLen / 2; // 2 bytes each in V3</span>

        /*
         * Copy over the cipher specs. We don't care about actually translating
         * them for use with an actual V2 server since we only talk V3.
         * Therefore, just copy over the V3 cipher spec values with a leading
         * 0.
         */
<span class="nc" id="L487">        int v3CipherSpecOffset = v3CipherSpecLenOffset + 2; // skip length</span>
<span class="nc" id="L488">        int v2CipherSpecLen = 0;</span>
<span class="nc" id="L489">        count = 11;</span>
<span class="nc" id="L490">        boolean containsRenegoInfoSCSV = false;</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">        for (int i = 0; i &lt; cipherSpecs; i++) {</span>
            byte byte1, byte2;

<span class="nc" id="L494">            byte1 = v3Msg[v3CipherSpecOffset++];</span>
<span class="nc" id="L495">            byte2 = v3Msg[v3CipherSpecOffset++];</span>
<span class="nc" id="L496">            v2CipherSpecLen += V3toV2CipherSuite(byte1, byte2);</span>
<span class="nc bnc" id="L497" title="All 6 branches missed.">            if (!containsRenegoInfoSCSV &amp;&amp;</span>
                        byte1 == (byte)0x00 &amp;&amp; byte2 == (byte)0xFF) {
<span class="nc" id="L499">                containsRenegoInfoSCSV = true;</span>
            }
        }

<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (!containsRenegoInfoSCSV) {</span>
<span class="nc" id="L504">            v2CipherSpecLen += V3toV2CipherSuite((byte)0x00, (byte)0xFF);</span>
        }

        /*
         * Build the first part of the V3 record header from the V2 one
         * that's now buffered up.  (Lengths are fixed up later).
         */
<span class="nc" id="L511">        buf[2] = HandshakeMessage.ht_client_hello;</span>
<span class="nc" id="L512">        buf[3] = v3Msg[0];      // major version</span>
<span class="nc" id="L513">        buf[4] = v3Msg[1];      // minor version</span>
<span class="nc" id="L514">        buf[5] = (byte)(v2CipherSpecLen &gt;&gt;&gt; 8);</span>
<span class="nc" id="L515">        buf[6] = (byte)v2CipherSpecLen;</span>
<span class="nc" id="L516">        buf[7] = 0;</span>
<span class="nc" id="L517">        buf[8] = 0;             // always no session</span>
<span class="nc" id="L518">        buf[9] = 0;</span>
<span class="nc" id="L519">        buf[10] = 32;           // nonce length (always 32 in V3)</span>

        /*
         * Copy in the nonce.
         */
<span class="nc" id="L524">        System.arraycopy(v3Msg, 2, buf, count, 32);</span>
<span class="nc" id="L525">        count += 32;</span>

        /*
         * Set the length of the message.
         */
<span class="nc" id="L530">        count -= 2; // don't include length field itself</span>
<span class="nc" id="L531">        buf[0] = (byte)(count &gt;&gt;&gt; 8);</span>
<span class="nc" id="L532">        buf[0] |= 0x80;</span>
<span class="nc" id="L533">        buf[1] = (byte)(count);</span>
<span class="nc" id="L534">        count += 2;</span>
<span class="nc" id="L535">    }</span>

    /*
     * Mappings from V3 cipher suite encodings to their pure V2 equivalents.
     * This is taken from the SSL V3 specification, Appendix E.
     */
<span class="nc" id="L541">    private static int[] V3toV2CipherMap1 =</span>
        {-1, -1, -1, 0x02, 0x01, -1, 0x04, 0x05, -1, 0x06, 0x07};
<span class="nc" id="L543">    private static int[] V3toV2CipherMap3 =</span>
        {-1, -1, -1, 0x80, 0x80, -1, 0x80, 0x80, -1, 0x40, 0xC0};

    /*
     * See which matching pure-V2 cipher specs we need to include.
     * We are including these not because we are actually prepared
     * to talk V2 but because the Oracle Web Server insists on receiving
     * at least 1 &quot;pure V2&quot; cipher suite that it supports and returns an
     * illegal_parameter alert unless one is present. Rather than mindlessly
     * claiming to implement all documented pure V2 cipher suites the code below
     * just claims to implement the V2 cipher suite that is &quot;equivalent&quot;
     * in terms of cipher algorithm &amp; exportability with the actual V3 cipher
     * suite that we do support.
     */
    private int V3toV2CipherSuite(byte byte1, byte byte2) {
<span class="nc" id="L558">        buf[count++] = 0;</span>
<span class="nc" id="L559">        buf[count++] = byte1;</span>
<span class="nc" id="L560">        buf[count++] = byte2;</span>

<span class="nc bnc" id="L562" title="All 4 branches missed.">        if (((byte2 &amp; 0xff) &gt; 0xA) ||</span>
                (V3toV2CipherMap1[byte2] == -1)) {
<span class="nc" id="L564">            return 3;</span>
        }

<span class="nc" id="L567">        buf[count++] = (byte)V3toV2CipherMap1[byte2];</span>
<span class="nc" id="L568">        buf[count++] = 0;</span>
<span class="nc" id="L569">        buf[count++] = (byte)V3toV2CipherMap3[byte2];</span>

<span class="nc" id="L571">        return 6;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>