<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RSAClientKeyExchange.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">RSAClientKeyExchange.java</span></div><h1>RSAClientKeyExchange.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package sun.security.ssl;

import java.io.*;
import java.security.*;

import javax.crypto.*;

import javax.net.ssl.*;

import sun.security.internal.spec.TlsRsaPremasterSecretParameterSpec;
import sun.security.util.KeyUtil;

/**
 * This is the client key exchange message (CLIENT --&gt; SERVER) used with
 * all RSA key exchanges; it holds the RSA-encrypted pre-master secret.
 *
 * The message is encrypted using PKCS #1 block type 02 encryption with the
 * server's public key.  The padding and resulting message size is a function
 * of this server's public key modulus size, but the pre-master secret is
 * always exactly 48 bytes.
 *
 */
final class RSAClientKeyExchange extends HandshakeMessage {

    /**
     * The TLS spec says that the version in the RSA premaster secret must
     * be the maximum version supported by the client (i.e. the version it
     * requested in its client hello version). However, we (and other
     * implementations) used to send the active negotiated version. The
     * system property below allows to toggle the behavior.
     */
    private final static String PROP_NAME =
                                &quot;com.sun.net.ssl.rsaPreMasterSecretFix&quot;;

    /*
     * Default is &quot;false&quot; (old behavior) for compatibility reasons in
     * SSLv3/TLSv1.  Later protocols (TLSv1.1+) do not use this property.
     */
<span class="nc" id="L65">    private final static boolean rsaPreMasterSecretFix =</span>
<span class="nc" id="L66">                                Debug.getBooleanProperty(PROP_NAME, false);</span>

    /*
     * The following field values were encrypted with the server's public
     * key (or temp key from server key exchange msg) and are presented
     * here in DECRYPTED form.
     */
    private ProtocolVersion protocolVersion; // preMaster [0,1]
    SecretKey preMaster;
    private byte[] encrypted;           // same size as public modulus

    /*
     * Client randomly creates a pre-master secret and encrypts it
     * using the server's RSA public key; only the server can decrypt
     * it, using its RSA private key.  Result is the same size as the
     * server's public key, and uses PKCS #1 block format 02.
     */
    RSAClientKeyExchange(ProtocolVersion protocolVersion,
            ProtocolVersion maxVersion,
<span class="nc" id="L85">            SecureRandom generator, PublicKey publicKey) throws IOException {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (publicKey.getAlgorithm().equals(&quot;RSA&quot;) == false) {</span>
<span class="nc" id="L87">            throw new SSLKeyException(&quot;Public key not of type RSA&quot;);</span>
        }
<span class="nc" id="L89">        this.protocolVersion = protocolVersion;</span>

        int major, minor;

<span class="nc bnc" id="L93" title="All 4 branches missed.">        if (rsaPreMasterSecretFix || maxVersion.v &gt;= ProtocolVersion.TLS11.v) {</span>
<span class="nc" id="L94">            major = maxVersion.major;</span>
<span class="nc" id="L95">            minor = maxVersion.minor;</span>
        } else {
<span class="nc" id="L97">            major = protocolVersion.major;</span>
<span class="nc" id="L98">            minor = protocolVersion.minor;</span>
        }

        try {
<span class="nc bnc" id="L102" title="All 2 branches missed.">            String s = ((protocolVersion.v &gt;= ProtocolVersion.TLS12.v) ?</span>
                &quot;SunTls12RsaPremasterSecret&quot; : &quot;SunTlsRsaPremasterSecret&quot;);
<span class="nc" id="L104">            KeyGenerator kg = JsseJce.getKeyGenerator(s);</span>
<span class="nc" id="L105">            kg.init(new TlsRsaPremasterSecretParameterSpec(major, minor),</span>
                    generator);
<span class="nc" id="L107">            preMaster = kg.generateKey();</span>

<span class="nc" id="L109">            Cipher cipher = JsseJce.getCipher(JsseJce.CIPHER_RSA_PKCS1);</span>
<span class="nc" id="L110">            cipher.init(Cipher.WRAP_MODE, publicKey, generator);</span>
<span class="nc" id="L111">            encrypted = cipher.wrap(preMaster);</span>
<span class="nc" id="L112">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L113">            throw (SSLKeyException)new SSLKeyException</span>
<span class="nc" id="L114">                                (&quot;RSA premaster secret error&quot;).initCause(e);</span>
<span class="nc" id="L115">        }</span>
<span class="nc" id="L116">    }</span>

    /*
     * Server gets the PKCS #1 (block format 02) data, decrypts
     * it with its private key.
     */
    RSAClientKeyExchange(ProtocolVersion currentVersion,
            ProtocolVersion maxVersion,
            SecureRandom generator, HandshakeInStream input,
<span class="nc" id="L125">            int messageSize, PrivateKey privateKey) throws IOException {</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (privateKey.getAlgorithm().equals(&quot;RSA&quot;) == false) {</span>
<span class="nc" id="L128">            throw new SSLKeyException(&quot;Private key not of type RSA&quot;);</span>
        }

<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (currentVersion.v &gt;= ProtocolVersion.TLS10.v) {</span>
<span class="nc" id="L132">            encrypted = input.getBytes16();</span>
        } else {
<span class="nc" id="L134">            encrypted = new byte [messageSize];</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">            if (input.read(encrypted) != messageSize) {</span>
<span class="nc" id="L136">                throw new SSLProtocolException</span>
                        (&quot;SSL: read PreMasterSecret: short read&quot;);
            }
        }

        try {
<span class="nc" id="L142">            Cipher cipher = JsseJce.getCipher(JsseJce.CIPHER_RSA_PKCS1);</span>
<span class="nc" id="L143">            cipher.init(Cipher.UNWRAP_MODE, privateKey);</span>
<span class="nc" id="L144">            preMaster = (SecretKey)cipher.unwrap(encrypted,</span>
                                &quot;TlsRsaPremasterSecret&quot;, Cipher.SECRET_KEY);

            // polish the premaster secret
<span class="nc" id="L148">            preMaster = polishPreMasterSecretKey(currentVersion, maxVersion,</span>
                                                generator, preMaster, null);
<span class="nc" id="L150">        } catch (Exception e) {</span>
            // polish the premaster secret
<span class="nc" id="L152">            preMaster =</span>
<span class="nc" id="L153">                    polishPreMasterSecretKey(currentVersion, maxVersion,</span>
                                                generator, null, e);
<span class="nc" id="L155">        }</span>
<span class="nc" id="L156">    }</span>

    /**
     * To avoid vulnerabilities described by section 7.4.7.1, RFC 5246,
     * treating incorrectly formatted message blocks and/or mismatched
     * version numbers in a manner indistinguishable from correctly
     * formatted RSA blocks.
     *
     * RFC 5246 describes the approach as :
     *
     *  1. Generate a string R of 46 random bytes
     *
     *  2. Decrypt the message to recover the plaintext M
     *
     *  3. If the PKCS#1 padding is not correct, or the length of message
     *     M is not exactly 48 bytes:
     *        pre_master_secret = ClientHello.client_version || R
     *     else If ClientHello.client_version &lt;= TLS 1.0, and version
     *     number check is explicitly disabled:
     *        pre_master_secret = M
     *     else:
     *        pre_master_secret = ClientHello.client_version || M[2..47]
     */
    private SecretKey polishPreMasterSecretKey(ProtocolVersion currentVersion,
            ProtocolVersion clientHelloVersion, SecureRandom generator,
            SecretKey secretKey, Exception failoverException) {

<span class="nc" id="L183">        this.protocolVersion = clientHelloVersion;</span>

<span class="nc bnc" id="L185" title="All 4 branches missed.">        if (failoverException == null &amp;&amp; secretKey != null) {</span>
            // check the length
<span class="nc" id="L187">            byte[] encoded = secretKey.getEncoded();</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            if (encoded == null) {      // unable to get the encoded key</span>
<span class="nc bnc" id="L189" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L190">                    System.out.println(</span>
                        &quot;unable to get the plaintext of the premaster secret&quot;);
                }

<span class="nc" id="L194">                int keySize = KeyUtil.getKeySize(secretKey);</span>
<span class="nc bnc" id="L195" title="All 4 branches missed.">                if (keySize &gt; 0 &amp;&amp; keySize != 384) {       // 384 = 48 * 8</span>
<span class="nc bnc" id="L196" title="All 4 branches missed.">                    if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L197">                        System.out.println(</span>
                            &quot;incorrect length of premaster secret: &quot; +
                            (keySize/8));
                    }

<span class="nc" id="L202">                    return generateDummySecret(clientHelloVersion);</span>
                }

                // The key size is exactly 48 bytes or not accessible.
                //
                // Conservatively, pass the checking to master secret
                // calculation.
<span class="nc" id="L209">                return secretKey;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">            } else if (encoded.length == 48) {</span>
                // check the version
<span class="nc bnc" id="L212" title="All 4 branches missed.">                if (clientHelloVersion.major == encoded[0] &amp;&amp;</span>
                    clientHelloVersion.minor == encoded[1]) {

<span class="nc" id="L215">                    return secretKey;</span>
<span class="nc bnc" id="L216" title="All 6 branches missed.">                } else if (clientHelloVersion.v &lt;= ProtocolVersion.TLS10.v &amp;&amp;</span>
                           currentVersion.major == encoded[0] &amp;&amp;
                           currentVersion.minor == encoded[1]) {
                    /*
                     * For compatibility, we maintain the behavior that the
                     * version in pre_master_secret can be the negotiated
                     * version for TLS v1.0 and SSL v3.0.
                     */
<span class="nc" id="L224">                    this.protocolVersion = currentVersion;</span>
<span class="nc" id="L225">                    return secretKey;</span>
                }

<span class="nc bnc" id="L228" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L229">                    System.out.println(&quot;Mismatching Protocol Versions, &quot; +</span>
                        &quot;ClientHello.client_version is &quot; + clientHelloVersion +
                        &quot;, while PreMasterSecret.client_version is &quot; +
<span class="nc" id="L232">                        ProtocolVersion.valueOf(encoded[0], encoded[1]));</span>
                }

<span class="nc" id="L235">                return generateDummySecret(clientHelloVersion);</span>
            } else {
<span class="nc bnc" id="L237" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L238">                    System.out.println(</span>
                        &quot;incorrect length of premaster secret: &quot; +
                        encoded.length);
                }

<span class="nc" id="L243">                return generateDummySecret(clientHelloVersion);</span>
            }
        }

<span class="nc bnc" id="L247" title="All 6 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;) &amp;&amp;</span>
                        failoverException != null) {
<span class="nc" id="L249">            System.out.println(&quot;Error decrypting premaster secret:&quot;);</span>
<span class="nc" id="L250">            failoverException.printStackTrace(System.out);</span>
        }

<span class="nc" id="L253">        return generateDummySecret(clientHelloVersion);</span>
    }

    // generate a premaster secret with the specified version number
    static SecretKey generateDummySecret(ProtocolVersion version) {
<span class="nc bnc" id="L258" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L259">            System.out.println(&quot;Generating a random fake premaster secret&quot;);</span>
        }

        try {
<span class="nc bnc" id="L263" title="All 2 branches missed.">            String s = ((version.v &gt;= ProtocolVersion.TLS12.v) ?</span>
                &quot;SunTls12RsaPremasterSecret&quot; : &quot;SunTlsRsaPremasterSecret&quot;);
<span class="nc" id="L265">            KeyGenerator kg = JsseJce.getKeyGenerator(s);</span>
<span class="nc" id="L266">            kg.init(new TlsRsaPremasterSecretParameterSpec</span>
                    (version.major, version.minor));
<span class="nc" id="L268">            return kg.generateKey();</span>
<span class="nc" id="L269">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L270">            throw new RuntimeException(&quot;Could not generate dummy secret&quot;, e);</span>
        }
    }

    @Override
    int messageType() {
<span class="nc" id="L276">        return ht_client_key_exchange;</span>
    }

    @Override
    int messageLength() {
<span class="nc bnc" id="L281" title="All 2 branches missed.">        if (protocolVersion.v &gt;= ProtocolVersion.TLS10.v) {</span>
<span class="nc" id="L282">            return encrypted.length + 2;</span>
        } else {
<span class="nc" id="L284">            return encrypted.length;</span>
        }
    }

    @Override
    void send(HandshakeOutStream s) throws IOException {
<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (protocolVersion.v &gt;= ProtocolVersion.TLS10.v) {</span>
<span class="nc" id="L291">            s.putBytes16(encrypted);</span>
        } else {
<span class="nc" id="L293">            s.write(encrypted);</span>
        }
<span class="nc" id="L295">    }</span>

    @Override
    void print(PrintStream s) throws IOException {
<span class="nc" id="L299">        s.println(&quot;*** ClientKeyExchange, RSA PreMasterSecret, &quot; +</span>
                                                        protocolVersion);
<span class="nc" id="L301">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>