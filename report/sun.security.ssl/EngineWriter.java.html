<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>EngineWriter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">EngineWriter.java</span></div><h1>EngineWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.ssl;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.LinkedList;
import javax.net.ssl.SSLEngineResult.HandshakeStatus;
import sun.misc.HexDumpEncoder;

/**
 * A class to help abstract away SSLEngine writing synchronization.
 */
<span class="nc bnc" id="L37" title="All 2 branches missed.">final class EngineWriter {</span>

    /*
     * Outgoing handshake Data waiting for a ride is stored here.
     * Normal application data is written directly into the outbound
     * buffer, but handshake data can be written out at any time,
     * so we have buffer it somewhere.
     *
     * When wrap is called, we first check to see if there is
     * any data waiting, then if we're in a data transfer state,
     * we try to write app data.
     *
     * This will contain either ByteBuffers, or the marker
     * HandshakeStatus.FINISHED to signify that a handshake just completed.
     */
    private LinkedList&lt;Object&gt; outboundList;

<span class="nc" id="L54">    private boolean outboundClosed = false;</span>

    /* Class and subclass dynamic debugging support */
<span class="nc" id="L57">    private static final Debug debug = Debug.getInstance(&quot;ssl&quot;);</span>

<span class="nc" id="L59">    EngineWriter() {</span>
<span class="nc" id="L60">        outboundList = new LinkedList&lt;Object&gt;();</span>
<span class="nc" id="L61">    }</span>

    /*
     * Upper levels assured us we had room for at least one packet of data.
     * As per the SSLEngine spec, we only return one SSL packets worth of
     * data.
     */
    private HandshakeStatus getOutboundData(ByteBuffer dstBB) {

<span class="nc" id="L70">        Object msg = outboundList.removeFirst();</span>
<span class="nc bnc" id="L71" title="All 4 branches missed.">        assert(msg instanceof ByteBuffer);</span>

<span class="nc" id="L73">        ByteBuffer bbIn = (ByteBuffer) msg;</span>
<span class="nc bnc" id="L74" title="All 4 branches missed.">        assert(dstBB.remaining() &gt;= bbIn.remaining());</span>

<span class="nc" id="L76">        dstBB.put(bbIn);</span>

        /*
         * If we have more data in the queue, it's either
         * a finished message, or an indication that we need
         * to call wrap again.
         */
<span class="nc bnc" id="L83" title="All 2 branches missed.">        if (hasOutboundDataInternal()) {</span>
<span class="nc" id="L84">            msg = outboundList.getFirst();</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">            if (msg == HandshakeStatus.FINISHED) {</span>
<span class="nc" id="L86">                outboundList.removeFirst();     // consume the message</span>
<span class="nc" id="L87">                return HandshakeStatus.FINISHED;</span>
            } else {
<span class="nc" id="L89">                return HandshakeStatus.NEED_WRAP;</span>
            }
        } else {
<span class="nc" id="L92">            return null;</span>
        }
    }

    /*
     * Properly orders the output of the data written to the wrap call.
     * This is only handshake data, application data goes through the
     * other writeRecord.
     */
    synchronized void writeRecord(EngineOutputRecord outputRecord,
            Authenticator authenticator,
            CipherBox writeCipher) throws IOException {

        /*
         * Only output if we're still open.
         */
<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (outboundClosed) {</span>
<span class="nc" id="L109">            throw new IOException(&quot;writer side was already closed.&quot;);</span>
        }

<span class="nc" id="L112">        outputRecord.write(authenticator, writeCipher);</span>

        /*
         * Did our handshakers notify that we just sent the
         * Finished message?
         *
         * Add an &quot;I'm finished&quot; message to the queue.
         */
<span class="nc bnc" id="L120" title="All 2 branches missed.">        if (outputRecord.isFinishedMsg()) {</span>
<span class="nc" id="L121">            outboundList.addLast(HandshakeStatus.FINISHED);</span>
        }
<span class="nc" id="L123">    }</span>

    /*
     * Output the packet info.
     */
    private void dumpPacket(EngineArgs ea, boolean hsData) {
        try {
<span class="nc" id="L130">            HexDumpEncoder hd = new HexDumpEncoder();</span>

<span class="nc" id="L132">            ByteBuffer bb = ea.netData.duplicate();</span>

<span class="nc" id="L134">            int pos = bb.position();</span>
<span class="nc" id="L135">            bb.position(pos - ea.deltaNet());</span>
<span class="nc" id="L136">            bb.limit(pos);</span>

<span class="nc bnc" id="L138" title="All 2 branches missed.">            System.out.println(&quot;[Raw write&quot; +</span>
                (hsData ? &quot;&quot; : &quot; (bb)&quot;) + &quot;]: length = &quot; +
<span class="nc" id="L140">                bb.remaining());</span>
<span class="nc" id="L141">            hd.encodeBuffer(bb, System.out);</span>
<span class="nc" id="L142">        } catch (IOException e) { }</span>
<span class="nc" id="L143">    }</span>

    /*
     * Properly orders the output of the data written to the wrap call.
     * Only app data goes through here, handshake data goes through
     * the other writeRecord.
     *
     * Shouldn't expect to have an IOException here.
     *
     * Return any determined status.
     */
    synchronized HandshakeStatus writeRecord(
            EngineOutputRecord outputRecord, EngineArgs ea,
            Authenticator authenticator,
            CipherBox writeCipher) throws IOException {

        /*
         * If we have data ready to go, output this first before
         * trying to consume app data.
         */
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (hasOutboundDataInternal()) {</span>
<span class="nc" id="L164">            HandshakeStatus hss = getOutboundData(ea.netData);</span>

<span class="nc bnc" id="L166" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;packet&quot;)) {</span>
                /*
                 * We could have put the dump in
                 * OutputRecord.write(OutputStream), but let's actually
                 * output when it's actually output by the SSLEngine.
                 */
<span class="nc" id="L172">                dumpPacket(ea, true);</span>
            }

<span class="nc" id="L175">            return hss;</span>
        }

        /*
         * If we are closed, no more app data can be output.
         * Only existing handshake data (above) can be obtained.
         */
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (outboundClosed) {</span>
<span class="nc" id="L183">            throw new IOException(&quot;The write side was already closed&quot;);</span>
        }

<span class="nc" id="L186">        outputRecord.write(ea, authenticator, writeCipher);</span>

<span class="nc bnc" id="L188" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;packet&quot;)) {</span>
<span class="nc" id="L189">            dumpPacket(ea, false);</span>
        }

        /*
         * No way new outbound handshake data got here if we're
         * locked properly.
         *
         * We don't have any status we can return.
         */
<span class="nc" id="L198">        return null;</span>
    }

    /*
     * We already hold &quot;this&quot; lock, this is the callback from the
     * outputRecord.write() above.  We already know this
     * writer can accept more data (outboundClosed == false),
     * and the closure is sync'd.
     */
    void putOutboundData(ByteBuffer bytes) {
<span class="nc" id="L208">        outboundList.addLast(bytes);</span>
<span class="nc" id="L209">    }</span>

    /*
     * This is for the really rare case that someone is writing from
     * the *InputRecord* before we know what to do with it.
     */
    synchronized void putOutboundDataSync(ByteBuffer bytes)
            throws IOException {

<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (outboundClosed) {</span>
<span class="nc" id="L219">            throw new IOException(&quot;Write side already closed&quot;);</span>
        }

<span class="nc" id="L222">        outboundList.addLast(bytes);</span>
<span class="nc" id="L223">    }</span>

    /*
     * Non-synch'd version of this method, called by internals
     */
    private boolean hasOutboundDataInternal() {
<span class="nc bnc" id="L229" title="All 2 branches missed.">        return (outboundList.size() != 0);</span>
    }

    synchronized boolean hasOutboundData() {
<span class="nc" id="L233">        return hasOutboundDataInternal();</span>
    }

    synchronized boolean isOutboundDone() {
<span class="nc bnc" id="L237" title="All 4 branches missed.">        return outboundClosed &amp;&amp; !hasOutboundDataInternal();</span>
    }

    synchronized void closeOutbound() {
<span class="nc" id="L241">        outboundClosed = true;</span>
<span class="nc" id="L242">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>