<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SSLSessionContextImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">SSLSessionContextImpl.java</span></div><h1>SSLSessionContextImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package sun.security.ssl;

import java.util.Enumeration;
import java.util.Vector;
import java.util.Locale;

import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSessionContext;

import sun.security.util.Cache;


final class SSLSessionContextImpl implements SSLSessionContext {
    private Cache&lt;SessionId, SSLSessionImpl&gt; sessionCache;
                                        // session cache, session id as key
    private Cache&lt;String, SSLSessionImpl&gt; sessionHostPortCache;
                                        // session cache, &quot;host:port&quot; as key
    private int cacheLimit;             // the max cache size
    private int timeout;                // timeout in seconds

    // package private
<span class="nc" id="L48">    SSLSessionContextImpl() {</span>
<span class="nc" id="L49">        cacheLimit = getDefaultCacheLimit();    // default cache size</span>
<span class="nc" id="L50">        timeout = 86400;                        // default, 24 hours</span>

        // use soft reference
<span class="nc" id="L53">        sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);</span>
<span class="nc" id="L54">        sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);</span>
<span class="nc" id="L55">    }</span>

    /**
     * Returns the &lt;code&gt;SSLSession&lt;/code&gt; bound to the specified session id.
     */
    @Override
    public SSLSession getSession(byte[] sessionId) {
<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (sessionId == null) {</span>
<span class="nc" id="L63">            throw new NullPointerException(&quot;session id cannot be null&quot;);</span>
        }

<span class="nc" id="L66">        SSLSessionImpl sess = sessionCache.get(new SessionId(sessionId));</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">        if (!isTimedout(sess)) {</span>
<span class="nc" id="L68">            return sess;</span>
        }

<span class="nc" id="L71">        return null;</span>
    }

    /**
     * Returns an enumeration of the active SSL sessions.
     */
    @Override
    public Enumeration&lt;byte[]&gt; getIds() {
<span class="nc" id="L79">        SessionCacheVisitor scVisitor = new SessionCacheVisitor();</span>
<span class="nc" id="L80">        sessionCache.accept(scVisitor);</span>

<span class="nc" id="L82">        return scVisitor.getSessionIds();</span>
    }

    /**
     * Sets the timeout limit for cached &lt;code&gt;SSLSession&lt;/code&gt; objects
     *
     * Note that after reset the timeout, the cached session before
     * should be timed within the shorter one of the old timeout and the
     * new timeout.
     */
    @Override
    public void setSessionTimeout(int seconds)
                 throws IllegalArgumentException {
<span class="nc bnc" id="L95" title="All 2 branches missed.">        if (seconds &lt; 0) {</span>
<span class="nc" id="L96">            throw new IllegalArgumentException();</span>
        }

<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (timeout != seconds) {</span>
<span class="nc" id="L100">            sessionCache.setTimeout(seconds);</span>
<span class="nc" id="L101">            sessionHostPortCache.setTimeout(seconds);</span>
<span class="nc" id="L102">            timeout = seconds;</span>
        }
<span class="nc" id="L104">    }</span>

    /**
     * Gets the timeout limit for cached &lt;code&gt;SSLSession&lt;/code&gt; objects
     */
    @Override
    public int getSessionTimeout() {
<span class="nc" id="L111">        return timeout;</span>
    }

    /**
     * Sets the size of the cache used for storing
     * &lt;code&gt;SSLSession&lt;/code&gt; objects.
     */
    @Override
    public void setSessionCacheSize(int size)
                 throws IllegalArgumentException {
<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (size &lt; 0)</span>
<span class="nc" id="L122">            throw new IllegalArgumentException();</span>

<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (cacheLimit != size) {</span>
<span class="nc" id="L125">            sessionCache.setCapacity(size);</span>
<span class="nc" id="L126">            sessionHostPortCache.setCapacity(size);</span>
<span class="nc" id="L127">            cacheLimit = size;</span>
        }
<span class="nc" id="L129">    }</span>

    /**
     * Gets the size of the cache used for storing
     * &lt;code&gt;SSLSession&lt;/code&gt; objects.
     */
    @Override
    public int getSessionCacheSize() {
<span class="nc" id="L137">        return cacheLimit;</span>
    }


    // package-private method, used ONLY by ServerHandshaker
    SSLSessionImpl get(byte[] id) {
<span class="nc" id="L143">        return (SSLSessionImpl)getSession(id);</span>
    }

    // package-private method, used ONLY by ClientHandshaker
    SSLSessionImpl get(String hostname, int port) {
        /*
         * If no session caching info is available, we won't
         * get one, so exit before doing a lookup.
         */
<span class="nc bnc" id="L152" title="All 4 branches missed.">        if (hostname == null &amp;&amp; port == -1) {</span>
<span class="nc" id="L153">            return null;</span>
        }

<span class="nc" id="L156">        SSLSessionImpl sess = sessionHostPortCache.get(getKey(hostname, port));</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (!isTimedout(sess)) {</span>
<span class="nc" id="L158">            return sess;</span>
        }

<span class="nc" id="L161">        return null;</span>
    }

    private String getKey(String hostname, int port) {
<span class="nc" id="L165">        return (hostname + &quot;:&quot; +</span>
<span class="nc" id="L166">            String.valueOf(port)).toLowerCase(Locale.ENGLISH);</span>
    }

    // cache a SSLSession
    //
    // In SunJSSE implementation, a session is created while getting a
    // client hello or a server hello message, and cached while the
    // handshaking finished.
    // Here we time the session from the time it cached instead of the
    // time it created, which is a little longer than the expected. So
    // please do check isTimedout() while getting entry from the cache.
    void put(SSLSessionImpl s) {
<span class="nc" id="L178">        sessionCache.put(s.getSessionId(), s);</span>

        // If no hostname/port info is available, don't add this one.
<span class="nc bnc" id="L181" title="All 4 branches missed.">        if ((s.getPeerHost() != null) &amp;&amp; (s.getPeerPort() != -1)) {</span>
<span class="nc" id="L182">            sessionHostPortCache.put(</span>
<span class="nc" id="L183">                getKey(s.getPeerHost(), s.getPeerPort()), s);</span>
        }

<span class="nc" id="L186">        s.setContext(this);</span>
<span class="nc" id="L187">    }</span>

    // package-private method, remove a cached SSLSession
    void remove(SessionId key) {
<span class="nc" id="L191">        SSLSessionImpl s = sessionCache.get(key);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (s != null) {</span>
<span class="nc" id="L193">            sessionCache.remove(key);</span>
<span class="nc" id="L194">            sessionHostPortCache.remove(</span>
<span class="nc" id="L195">                        getKey(s.getPeerHost(), s.getPeerPort()));</span>
        }
<span class="nc" id="L197">    }</span>

    private int getDefaultCacheLimit() {
<span class="nc" id="L200">        int cacheLimit = 0;</span>
        try {
<span class="nc" id="L202">        String s = java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L203">                new java.security.PrivilegedAction&lt;String&gt;() {</span>
                @Override
                public String run() {
<span class="nc" id="L206">                    return System.getProperty(</span>
                        &quot;javax.net.ssl.sessionCacheSize&quot;);
                }
            });
<span class="nc bnc" id="L210" title="All 2 branches missed.">            cacheLimit = (s != null) ? Integer.valueOf(s).intValue() : 0;</span>
<span class="nc" id="L211">        } catch (Exception e) {</span>
<span class="nc" id="L212">        }</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">        return (cacheLimit &gt; 0) ? cacheLimit : 0;</span>
    }

    boolean isTimedout(SSLSession sess) {
<span class="nc bnc" id="L218" title="All 2 branches missed.">        if (timeout == 0) {</span>
<span class="nc" id="L219">            return false;</span>
        }

<span class="nc bnc" id="L222" title="All 2 branches missed.">        if ((sess != null) &amp;&amp; ((sess.getCreationTime() + timeout * 1000L)</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">                                        &lt;= (System.currentTimeMillis()))) {</span>
<span class="nc" id="L224">            sess.invalidate();</span>
<span class="nc" id="L225">            return true;</span>
        }

<span class="nc" id="L228">        return false;</span>
    }

<span class="nc" id="L231">    final class SessionCacheVisitor</span>
            implements Cache.CacheVisitor&lt;SessionId, SSLSessionImpl&gt; {
<span class="nc" id="L233">        Vector&lt;byte[]&gt; ids = null;</span>

        // public void visit(java.util.Map&lt;K,V&gt; map) {}
        @Override
        public void visit(java.util.Map&lt;SessionId, SSLSessionImpl&gt; map) {
<span class="nc" id="L238">            ids = new Vector&lt;&gt;(map.size());</span>

<span class="nc bnc" id="L240" title="All 2 branches missed.">            for (SessionId key : map.keySet()) {</span>
<span class="nc" id="L241">                SSLSessionImpl value = map.get(key);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                if (!isTimedout(value)) {</span>
<span class="nc" id="L243">                    ids.addElement(key.getId());</span>
                }
<span class="nc" id="L245">            }</span>
<span class="nc" id="L246">        }</span>

        public Enumeration&lt;byte[]&gt; getSessionIds() {
<span class="nc bnc" id="L249" title="All 2 branches missed.">            return  ids != null ? ids.elements() :</span>
<span class="nc" id="L250">                                  new Vector&lt;byte[]&gt;().elements();</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>