<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ClientHandshaker.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">ClientHandshaker.java</span></div><h1>ClientHandshaker.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.ssl;

import java.io.*;
import java.math.BigInteger;
import java.security.*;
import java.util.*;

import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.ECParameterSpec;

import java.security.cert.X509Certificate;
import java.security.cert.CertificateException;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import javax.net.ssl.*;

import javax.security.auth.Subject;

import sun.security.ssl.HandshakeMessage.*;
import static sun.security.ssl.CipherSuite.KeyExchange.*;

/**
 * ClientHandshaker does the protocol handshaking from the point
 * of view of a client.  It is driven asychronously by handshake messages
 * as delivered by the parent Handshaker class, and also uses
 * common functionality (e.g. key generation) that is provided there.
 *
 * @author David Brownell
 */
final class ClientHandshaker extends Handshaker {

    // the server's public key from its certificate.
    private PublicKey serverKey;

    // the server's ephemeral public key from the server key exchange message
    // for ECDHE/ECDH_anon and RSA_EXPORT.
    private PublicKey ephemeralServerKey;

    // server's ephemeral public value for DHE/DH_anon key exchanges
    private BigInteger          serverDH;

    private DHCrypt             dh;

    private ECDHCrypt ecdh;

    private CertificateRequest  certRequest;

    private boolean serverKeyExchangeReceived;

    /*
     * The RSA PreMasterSecret needs to know the version of
     * ClientHello that was used on this handshake.  This represents
     * the &quot;max version&quot; this client is supporting.  In the
     * case of an initial handshake, it's the max version enabled,
     * but in the case of a resumption attempt, it's the version
     * of the session we're trying to resume.
     */
    private ProtocolVersion maxProtocolVersion;

    // To switch off the SNI extension.
<span class="nc" id="L89">    private final static boolean enableSNIExtension =</span>
<span class="nc" id="L90">            Debug.getBooleanProperty(&quot;jsse.enableSNIExtension&quot;, true);</span>

<span class="nc" id="L92">    private List&lt;SNIServerName&gt; requestedServerNames =</span>
<span class="nc" id="L93">            Collections.&lt;SNIServerName&gt;emptyList();</span>

<span class="nc" id="L95">    private boolean serverNamesAccepted = false;</span>

    /*
     * Constructors
     */
    ClientHandshaker(SSLSocketImpl socket, SSLContextImpl context,
            ProtocolList enabledProtocols,
            ProtocolVersion activeProtocolVersion,
            boolean isInitialHandshake, boolean secureRenegotiation,
            byte[] clientVerifyData, byte[] serverVerifyData) {

<span class="nc" id="L106">        super(socket, context, enabledProtocols, true, true,</span>
            activeProtocolVersion, isInitialHandshake, secureRenegotiation,
            clientVerifyData, serverVerifyData);
<span class="nc" id="L109">    }</span>

    ClientHandshaker(SSLEngineImpl engine, SSLContextImpl context,
            ProtocolList enabledProtocols,
            ProtocolVersion activeProtocolVersion,
            boolean isInitialHandshake, boolean secureRenegotiation,
            byte[] clientVerifyData, byte[] serverVerifyData) {

<span class="nc" id="L117">        super(engine, context, enabledProtocols, true, true,</span>
            activeProtocolVersion, isInitialHandshake, secureRenegotiation,
            clientVerifyData, serverVerifyData);
<span class="nc" id="L120">    }</span>

    /*
     * This routine handles all the client side handshake messages, one at
     * a time.  Given the message type (and in some cases the pending cipher
     * spec) it parses the type-specific message.  Then it calls a function
     * that handles that specific message.
     *
     * It updates the state machine (need to verify it) as each message
     * is processed, and writes responses as needed using the connection
     * in the constructor.
     */
    @Override
    void processMessage(byte type, int messageLen) throws IOException {
<span class="nc bnc" id="L134" title="All 4 branches missed.">        if (state &gt;= type</span>
                &amp;&amp; (type != HandshakeMessage.ht_hello_request)) {
<span class="nc" id="L136">            throw new SSLProtocolException(</span>
                    &quot;Handshake message sequence violation, &quot; + type);
        }

<span class="nc bnc" id="L140" title="All 8 branches missed.">        switch (type) {</span>
        case HandshakeMessage.ht_hello_request:
<span class="nc" id="L142">            this.serverHelloRequest(new HelloRequest(input));</span>
<span class="nc" id="L143">            break;</span>

        case HandshakeMessage.ht_server_hello:
<span class="nc" id="L146">            this.serverHello(new ServerHello(input, messageLen));</span>
<span class="nc" id="L147">            break;</span>

        case HandshakeMessage.ht_certificate:
<span class="nc bnc" id="L150" title="All 8 branches missed.">            if (keyExchange == K_DH_ANON || keyExchange == K_ECDH_ANON</span>
                    || keyExchange == K_KRB5 || keyExchange == K_KRB5_EXPORT) {
<span class="nc" id="L152">                fatalSE(Alerts.alert_unexpected_message,</span>
                    &quot;unexpected server cert chain&quot;);
                // NOTREACHED
            }
<span class="nc" id="L156">            this.serverCertificate(new CertificateMsg(input));</span>
<span class="nc" id="L157">            serverKey =</span>
<span class="nc" id="L158">                session.getPeerCertificates()[0].getPublicKey();</span>
<span class="nc" id="L159">            break;</span>

        case HandshakeMessage.ht_server_key_exchange:
<span class="nc" id="L162">            serverKeyExchangeReceived = true;</span>
<span class="nc bnc" id="L163" title="All 7 branches missed.">            switch (keyExchange) {</span>
            case K_RSA_EXPORT:
                /**
                 * The server key exchange message is sent by the server only
                 * when the server certificate message does not contain the
                 * proper amount of data to allow the client to exchange a
                 * premaster secret, such as when RSA_EXPORT is used and the
                 * public key in the server certificate is longer than 512 bits.
                 */
<span class="nc bnc" id="L172" title="All 2 branches missed.">                if (serverKey == null) {</span>
<span class="nc" id="L173">                    throw new SSLProtocolException</span>
                        (&quot;Server did not send certificate message&quot;);
                }

<span class="nc bnc" id="L177" title="All 2 branches missed.">                if (!(serverKey instanceof RSAPublicKey)) {</span>
<span class="nc" id="L178">                    throw new SSLProtocolException(&quot;Protocol violation:&quot; +</span>
                        &quot; the certificate type must be appropriate for the&quot; +
                        &quot; selected cipher suite's key exchange algorithm&quot;);
                }

<span class="nc bnc" id="L183" title="All 2 branches missed.">                if (JsseJce.getRSAKeyLength(serverKey) &lt;= 512) {</span>
<span class="nc" id="L184">                    throw new SSLProtocolException(&quot;Protocol violation:&quot; +</span>
                        &quot; server sent a server key exchange message for&quot; +
                        &quot; key exchange &quot; + keyExchange +
                        &quot; when the public key in the server certificate&quot; +
                        &quot; is less than or equal to 512 bits in length&quot;);
                }

                try {
<span class="nc" id="L192">                    this.serverKeyExchange(new RSA_ServerKeyExchange(input));</span>
<span class="nc" id="L193">                } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L194">                    throwSSLException(&quot;Server key&quot;, e);</span>
<span class="nc" id="L195">                }</span>
<span class="nc" id="L196">                break;</span>
            case K_DH_ANON:
                try {
<span class="nc" id="L199">                    this.serverKeyExchange(new DH_ServerKeyExchange(</span>
                                                input, protocolVersion));
<span class="nc" id="L201">                } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L202">                    throwSSLException(&quot;Server key&quot;, e);</span>
<span class="nc" id="L203">                }</span>
<span class="nc" id="L204">                break;</span>
            case K_DHE_DSS:
            case K_DHE_RSA:
                try {
<span class="nc" id="L208">                    this.serverKeyExchange(new DH_ServerKeyExchange(</span>
                        input, serverKey,
                        clnt_random.random_bytes, svr_random.random_bytes,
                        messageLen,
                        localSupportedSignAlgs, protocolVersion));
<span class="nc" id="L213">                } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L214">                    throwSSLException(&quot;Server key&quot;, e);</span>
<span class="nc" id="L215">                }</span>
<span class="nc" id="L216">                break;</span>
            case K_ECDHE_ECDSA:
            case K_ECDHE_RSA:
            case K_ECDH_ANON:
                try {
<span class="nc" id="L221">                    this.serverKeyExchange(new ECDH_ServerKeyExchange</span>
                        (input, serverKey, clnt_random.random_bytes,
                        svr_random.random_bytes,
                        localSupportedSignAlgs, protocolVersion));
<span class="nc" id="L225">                } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L226">                    throwSSLException(&quot;Server key&quot;, e);</span>
<span class="nc" id="L227">                }</span>
<span class="nc" id="L228">                break;</span>
            case K_RSA:
            case K_DH_RSA:
            case K_DH_DSS:
            case K_ECDH_ECDSA:
            case K_ECDH_RSA:
<span class="nc" id="L234">                throw new SSLProtocolException(</span>
                    &quot;Protocol violation: server sent a server key exchange&quot;
                    + &quot;message for key exchange &quot; + keyExchange);
            case K_KRB5:
            case K_KRB5_EXPORT:
<span class="nc" id="L239">                throw new SSLProtocolException(</span>
                    &quot;unexpected receipt of server key exchange algorithm&quot;);
            default:
<span class="nc" id="L242">                throw new SSLProtocolException(</span>
                    &quot;unsupported key exchange algorithm = &quot;
                    + keyExchange);
            }
            break;

        case HandshakeMessage.ht_certificate_request:
            // save for later, it's handled by serverHelloDone
<span class="nc bnc" id="L250" title="All 4 branches missed.">            if ((keyExchange == K_DH_ANON) || (keyExchange == K_ECDH_ANON)) {</span>
<span class="nc" id="L251">                throw new SSLHandshakeException(</span>
                    &quot;Client authentication requested for &quot;+
                    &quot;anonymous cipher suite.&quot;);
<span class="nc bnc" id="L254" title="All 4 branches missed.">            } else if (keyExchange == K_KRB5 || keyExchange == K_KRB5_EXPORT) {</span>
<span class="nc" id="L255">                throw new SSLHandshakeException(</span>
                    &quot;Client certificate requested for &quot;+
                    &quot;kerberos cipher suite.&quot;);
            }
<span class="nc" id="L259">            certRequest = new CertificateRequest(input, protocolVersion);</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L261">                certRequest.print(System.out);</span>
            }

<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (protocolVersion.v &gt;= ProtocolVersion.TLS12.v) {</span>
<span class="nc" id="L265">                Collection&lt;SignatureAndHashAlgorithm&gt; peerSignAlgs =</span>
<span class="nc" id="L266">                                        certRequest.getSignAlgorithms();</span>
<span class="nc bnc" id="L267" title="All 4 branches missed.">                if (peerSignAlgs == null || peerSignAlgs.isEmpty()) {</span>
<span class="nc" id="L268">                    throw new SSLHandshakeException(</span>
                        &quot;No peer supported signature algorithms&quot;);
                }

<span class="nc" id="L272">                Collection&lt;SignatureAndHashAlgorithm&gt; supportedPeerSignAlgs =</span>
<span class="nc" id="L273">                    SignatureAndHashAlgorithm.getSupportedAlgorithms(</span>
                                                            peerSignAlgs);
<span class="nc bnc" id="L275" title="All 2 branches missed.">                if (supportedPeerSignAlgs.isEmpty()) {</span>
<span class="nc" id="L276">                    throw new SSLHandshakeException(</span>
                        &quot;No supported signature and hash algorithm in common&quot;);
                }

<span class="nc" id="L280">                setPeerSupportedSignAlgs(supportedPeerSignAlgs);</span>
<span class="nc" id="L281">                session.setPeerSupportedSignatureAlgorithms(</span>
                                                supportedPeerSignAlgs);
<span class="nc" id="L283">            }</span>

            break;

        case HandshakeMessage.ht_server_hello_done:
<span class="nc" id="L288">            this.serverHelloDone(new ServerHelloDone(input));</span>
<span class="nc" id="L289">            break;</span>

        case HandshakeMessage.ht_finished:
<span class="nc" id="L292">            this.serverFinished(</span>
                new Finished(protocolVersion, input, cipherSuite));
<span class="nc" id="L294">            break;</span>

        default:
<span class="nc" id="L297">            throw new SSLProtocolException(</span>
                &quot;Illegal client handshake msg, &quot; + type);
        }

        //
        // Move state machine forward if the message handling
        // code didn't already do so
        //
<span class="nc bnc" id="L305" title="All 2 branches missed.">        if (state &lt; type) {</span>
<span class="nc" id="L306">            state = type;</span>
        }
<span class="nc" id="L308">    }</span>

    /*
     * Used by the server to kickstart negotiations -- this requests a
     * &quot;client hello&quot; to renegotiate current cipher specs (e.g. maybe lots
     * of data has been encrypted with the same keys, or the server needs
     * the client to present a certificate).
     */
    private void serverHelloRequest(HelloRequest mesg) throws IOException {
<span class="nc bnc" id="L317" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L318">            mesg.print(System.out);</span>
        }

        //
        // Could be (e.g. at connection setup) that we already
        // sent the &quot;client hello&quot; but the server's not seen it.
        //
<span class="nc bnc" id="L325" title="All 2 branches missed.">        if (state &lt; HandshakeMessage.ht_client_hello) {</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">            if (!secureRenegotiation &amp;&amp; !allowUnsafeRenegotiation) {</span>
                // renegotiation is not allowed.
<span class="nc bnc" id="L328" title="All 2 branches missed.">                if (activeProtocolVersion.v &gt;= ProtocolVersion.TLS10.v) {</span>
                    // response with a no_renegotiation warning,
<span class="nc" id="L330">                    warningSE(Alerts.alert_no_renegotiation);</span>

                    // invalidate the handshake so that the caller can
                    // dispose this object.
<span class="nc" id="L334">                    invalidated = true;</span>

                    // If there is still unread block in the handshake
                    // input stream, it would be truncated with the disposal
                    // and the next handshake message will become incomplete.
                    //
                    // However, according to SSL/TLS specifications, no more
                    // handshake message should immediately follow ClientHello
                    // or HelloRequest. So just let it be.
                } else {
                    // For SSLv3, send the handshake_failure fatal error.
                    // Note that SSLv3 does not define a no_renegotiation
                    // alert like TLSv1. However we cannot ignore the message
                    // simply, otherwise the other side was waiting for a
                    // response that would never come.
<span class="nc" id="L349">                    fatalSE(Alerts.alert_handshake_failure,</span>
                        &quot;Renegotiation is not allowed&quot;);
                }
            } else {
<span class="nc bnc" id="L353" title="All 2 branches missed.">                if (!secureRenegotiation) {</span>
<span class="nc bnc" id="L354" title="All 4 branches missed.">                    if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L355">                        System.out.println(</span>
                            &quot;Warning: continue with insecure renegotiation&quot;);
                    }
                }
<span class="nc" id="L359">                kickstart();</span>
            }
        }
<span class="nc" id="L362">    }</span>


    /*
     * Server chooses session parameters given options created by the
     * client -- basically, cipher options, session id, and someday a
     * set of compression options.
     *
     * There are two branches of the state machine, decided by the
     * details of this message.  One is the &quot;fast&quot; handshake, where we
     * can resume the pre-existing session we asked resume.  The other
     * is a more expensive &quot;full&quot; handshake, with key exchange and
     * probably authentication getting done.
     */
    private void serverHello(ServerHello mesg) throws IOException {
<span class="nc" id="L377">        serverKeyExchangeReceived = false;</span>
<span class="nc bnc" id="L378" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L379">            mesg.print(System.out);</span>
        }

        // check if the server selected protocol version is OK for us
<span class="nc" id="L383">        ProtocolVersion mesgVersion = mesg.protocolVersion;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (!isNegotiable(mesgVersion)) {</span>
<span class="nc" id="L385">            throw new SSLHandshakeException(</span>
                &quot;Server chose &quot; + mesgVersion +
                &quot;, but that protocol version is not enabled or not supported &quot; +
                &quot;by the client.&quot;);
        }

<span class="nc" id="L391">        handshakeHash.protocolDetermined(mesgVersion);</span>

        // Set protocolVersion and propagate to SSLSocket and the
        // Handshake streams
<span class="nc" id="L395">        setVersion(mesgVersion);</span>

        // check the &quot;renegotiation_info&quot; extension
<span class="nc" id="L398">        RenegotiationInfoExtension serverHelloRI = (RenegotiationInfoExtension)</span>
<span class="nc" id="L399">                    mesg.extensions.get(ExtensionType.EXT_RENEGOTIATION_INFO);</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (serverHelloRI != null) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">            if (isInitialHandshake) {</span>
                // verify the length of the &quot;renegotiated_connection&quot; field
<span class="nc bnc" id="L403" title="All 2 branches missed.">                if (!serverHelloRI.isEmpty()) {</span>
                    // abort the handshake with a fatal handshake_failure alert
<span class="nc" id="L405">                    fatalSE(Alerts.alert_handshake_failure,</span>
                        &quot;The renegotiation_info field is not empty&quot;);
                }

<span class="nc" id="L409">                secureRenegotiation = true;</span>
            } else {
                // For a legacy renegotiation, the client MUST verify that
                // it does not contain the &quot;renegotiation_info&quot; extension.
<span class="nc bnc" id="L413" title="All 2 branches missed.">                if (!secureRenegotiation) {</span>
<span class="nc" id="L414">                    fatalSE(Alerts.alert_handshake_failure,</span>
                        &quot;Unexpected renegotiation indication extension&quot;);
                }

                // verify the client_verify_data and server_verify_data values
<span class="nc" id="L419">                byte[] verifyData =</span>
                    new byte[clientVerifyData.length + serverVerifyData.length];
<span class="nc" id="L421">                System.arraycopy(clientVerifyData, 0, verifyData,</span>
                        0, clientVerifyData.length);
<span class="nc" id="L423">                System.arraycopy(serverVerifyData, 0, verifyData,</span>
                        clientVerifyData.length, serverVerifyData.length);
<span class="nc bnc" id="L425" title="All 2 branches missed.">                if (!Arrays.equals(verifyData,</span>
<span class="nc" id="L426">                                serverHelloRI.getRenegotiatedConnection())) {</span>
<span class="nc" id="L427">                    fatalSE(Alerts.alert_handshake_failure,</span>
                        &quot;Incorrect verify data in ServerHello &quot; +
                        &quot;renegotiation_info message&quot;);
                }
<span class="nc" id="L431">            }</span>
        } else {
            // no renegotiation indication extension
<span class="nc bnc" id="L434" title="All 2 branches missed.">            if (isInitialHandshake) {</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                if (!allowLegacyHelloMessages) {</span>
                    // abort the handshake with a fatal handshake_failure alert
<span class="nc" id="L437">                    fatalSE(Alerts.alert_handshake_failure,</span>
                        &quot;Failed to negotiate the use of secure renegotiation&quot;);
                }

<span class="nc" id="L441">                secureRenegotiation = false;</span>
<span class="nc bnc" id="L442" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L443">                    System.out.println(&quot;Warning: No renegotiation &quot; +</span>
                                    &quot;indication extension in ServerHello&quot;);
                }
            } else {
                // For a secure renegotiation, the client must abort the
                // handshake if no &quot;renegotiation_info&quot; extension is present.
<span class="nc bnc" id="L449" title="All 2 branches missed.">                if (secureRenegotiation) {</span>
<span class="nc" id="L450">                    fatalSE(Alerts.alert_handshake_failure,</span>
                        &quot;No renegotiation indication extension&quot;);
                }

                // we have already allowed unsafe renegotation before request
                // the renegotiation.
            }
        }

        //
        // Save server nonce, we always use it to compute connection
        // keys and it's also used to create the master secret if we're
        // creating a new session (i.e. in the full handshake).
        //
<span class="nc" id="L464">        svr_random = mesg.svr_random;</span>

<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (isNegotiable(mesg.cipherSuite) == false) {</span>
<span class="nc" id="L467">            fatalSE(Alerts.alert_illegal_parameter,</span>
                &quot;Server selected improper ciphersuite &quot; + mesg.cipherSuite);
        }

<span class="nc" id="L471">        setCipherSuite(mesg.cipherSuite);</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (protocolVersion.v &gt;= ProtocolVersion.TLS12.v) {</span>
<span class="nc" id="L473">            handshakeHash.setFinishedAlg(cipherSuite.prfAlg.getPRFHashAlg());</span>
        }

<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (mesg.compression_method != 0) {</span>
<span class="nc" id="L477">            fatalSE(Alerts.alert_illegal_parameter,</span>
                &quot;compression type not supported, &quot;
                + mesg.compression_method);
            // NOTREACHED
        }

        // so far so good, let's look at the session
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (session != null) {</span>
            // we tried to resume, let's see what the server decided
<span class="nc bnc" id="L486" title="All 2 branches missed.">            if (session.getSessionId().equals(mesg.sessionId)) {</span>
                // server resumed the session, let's make sure everything
                // checks out

                // Verify that the session ciphers are unchanged.
<span class="nc" id="L491">                CipherSuite sessionSuite = session.getSuite();</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                if (cipherSuite != sessionSuite) {</span>
<span class="nc" id="L493">                    throw new SSLProtocolException</span>
                        (&quot;Server returned wrong cipher suite for session&quot;);
                }

                // verify protocol version match
<span class="nc" id="L498">                ProtocolVersion sessionVersion = session.getProtocolVersion();</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                if (protocolVersion != sessionVersion) {</span>
<span class="nc" id="L500">                    throw new SSLProtocolException</span>
                        (&quot;Server resumed session with wrong protocol version&quot;);
                }

                // validate subject identity
<span class="nc bnc" id="L505" title="All 4 branches missed.">                if (sessionSuite.keyExchange == K_KRB5 ||</span>
                    sessionSuite.keyExchange == K_KRB5_EXPORT) {
<span class="nc" id="L507">                    Principal localPrincipal = session.getLocalPrincipal();</span>

<span class="nc" id="L509">                    Subject subject = null;</span>
                    try {
<span class="nc" id="L511">                        subject = AccessController.doPrivileged(</span>
<span class="nc" id="L512">                            new PrivilegedExceptionAction&lt;Subject&gt;() {</span>
                            @Override
                            public Subject run() throws Exception {
<span class="nc" id="L515">                                return Krb5Helper.getClientSubject(getAccSE());</span>
                            }});
<span class="nc" id="L517">                    } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L518">                        subject = null;</span>
<span class="nc bnc" id="L519" title="All 4 branches missed.">                        if (debug != null &amp;&amp; Debug.isOn(&quot;session&quot;)) {</span>
<span class="nc" id="L520">                            System.out.println(&quot;Attempt to obtain&quot; +</span>
                                        &quot; subject failed!&quot;);
                        }
<span class="nc" id="L523">                    }</span>

<span class="nc bnc" id="L525" title="All 2 branches missed.">                    if (subject != null) {</span>
                        // Eliminate dependency on KerberosPrincipal
<span class="nc" id="L527">                        Set&lt;Principal&gt; principals =</span>
<span class="nc" id="L528">                            subject.getPrincipals(Principal.class);</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">                        if (!principals.contains(localPrincipal)) {</span>
<span class="nc" id="L530">                            throw new SSLProtocolException(&quot;Server resumed&quot; +</span>
                                &quot; session with wrong subject identity&quot;);
                        } else {
<span class="nc bnc" id="L533" title="All 4 branches missed.">                            if (debug != null &amp;&amp; Debug.isOn(&quot;session&quot;))</span>
<span class="nc" id="L534">                                System.out.println(&quot;Subject identity is same&quot;);</span>
                        }
<span class="nc" id="L536">                    } else {</span>
<span class="nc bnc" id="L537" title="All 4 branches missed.">                        if (debug != null &amp;&amp; Debug.isOn(&quot;session&quot;))</span>
<span class="nc" id="L538">                            System.out.println(&quot;Kerberos credentials are not&quot; +</span>
                                &quot; present in the current Subject; check if &quot; +
                                &quot; javax.security.auth.useSubjectAsCreds&quot; +
                                &quot; system property has been set to false&quot;);
<span class="nc" id="L542">                        throw new SSLProtocolException</span>
                            (&quot;Server resumed session with no subject&quot;);
                    }
                }

                // looks fine; resume it, and update the state machine.
<span class="nc" id="L548">                resumingSession = true;</span>
<span class="nc" id="L549">                state = HandshakeMessage.ht_finished - 1;</span>
<span class="nc" id="L550">                calculateConnectionKeys(session.getMasterSecret());</span>
<span class="nc bnc" id="L551" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;session&quot;)) {</span>
<span class="nc" id="L552">                    System.out.println(&quot;%% Server resumed &quot; + session);</span>
                }
<span class="nc" id="L554">            } else {</span>
                // we wanted to resume, but the server refused
<span class="nc" id="L556">                session = null;</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                if (!enableNewSession) {</span>
<span class="nc" id="L558">                    throw new SSLException</span>
                        (&quot;New session creation is disabled&quot;);
                }
            }
        }

<span class="nc bnc" id="L564" title="All 4 branches missed.">        if (resumingSession &amp;&amp; session != null) {</span>
<span class="nc" id="L565">            setHandshakeSessionSE(session);</span>
<span class="nc" id="L566">            return;</span>
        }

        // check extensions
<span class="nc bnc" id="L570" title="All 2 branches missed.">        for (HelloExtension ext : mesg.extensions.list()) {</span>
<span class="nc" id="L571">            ExtensionType type = ext.type;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (type == ExtensionType.EXT_SERVER_NAME) {</span>
<span class="nc" id="L573">                serverNamesAccepted = true;</span>
<span class="nc bnc" id="L574" title="All 8 branches missed.">            } else if ((type != ExtensionType.EXT_ELLIPTIC_CURVES)</span>
                    &amp;&amp; (type != ExtensionType.EXT_EC_POINT_FORMATS)
                    &amp;&amp; (type != ExtensionType.EXT_SERVER_NAME)
                    &amp;&amp; (type != ExtensionType.EXT_RENEGOTIATION_INFO)) {
<span class="nc" id="L578">                fatalSE(Alerts.alert_unsupported_extension,</span>
                    &quot;Server sent an unsupported extension: &quot; + type);
            }
<span class="nc" id="L581">        }</span>

        // Create a new session, we need to do the full handshake
<span class="nc" id="L584">        session = new SSLSessionImpl(protocolVersion, cipherSuite,</span>
<span class="nc" id="L585">                            getLocalSupportedSignAlgs(),</span>
<span class="nc" id="L586">                            mesg.sessionId, getHostSE(), getPortSE());</span>
<span class="nc" id="L587">        session.setRequestedServerNames(requestedServerNames);</span>
<span class="nc" id="L588">        setHandshakeSessionSE(session);</span>
<span class="nc bnc" id="L589" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L590">            System.out.println(&quot;** &quot; + cipherSuite);</span>
        }
<span class="nc" id="L592">    }</span>

    /*
     * Server's own key was either a signing-only key, or was too
     * large for export rules ... this message holds an ephemeral
     * RSA key to use for key exchange.
     */
    private void serverKeyExchange(RSA_ServerKeyExchange mesg)
            throws IOException, GeneralSecurityException {
<span class="nc bnc" id="L601" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L602">            mesg.print(System.out);</span>
        }
<span class="nc bnc" id="L604" title="All 2 branches missed.">        if (!mesg.verify(serverKey, clnt_random, svr_random)) {</span>
<span class="nc" id="L605">            fatalSE(Alerts.alert_handshake_failure,</span>
                &quot;server key exchange invalid&quot;);
            // NOTREACHED
        }
<span class="nc" id="L609">        ephemeralServerKey = mesg.getPublicKey();</span>
<span class="nc" id="L610">    }</span>


    /*
     * Diffie-Hellman key exchange.  We save the server public key and
     * our own D-H algorithm object so we can defer key calculations
     * until after we've sent the client key exchange message (which
     * gives client and server some useful parallelism).
     */
    private void serverKeyExchange(DH_ServerKeyExchange mesg)
            throws IOException {
<span class="nc bnc" id="L621" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L622">            mesg.print(System.out);</span>
        }
<span class="nc" id="L624">        dh = new DHCrypt(mesg.getModulus(), mesg.getBase(),</span>
<span class="nc" id="L625">                                            sslContext.getSecureRandom());</span>
<span class="nc" id="L626">        serverDH = mesg.getServerPublicKey();</span>
<span class="nc" id="L627">    }</span>

    private void serverKeyExchange(ECDH_ServerKeyExchange mesg)
            throws IOException {
<span class="nc bnc" id="L631" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L632">            mesg.print(System.out);</span>
        }
<span class="nc" id="L634">        ECPublicKey key = mesg.getPublicKey();</span>
<span class="nc" id="L635">        ecdh = new ECDHCrypt(key.getParams(), sslContext.getSecureRandom());</span>
<span class="nc" id="L636">        ephemeralServerKey = key;</span>
<span class="nc" id="L637">    }</span>

    /*
     * The server's &quot;Hello Done&quot; message is the client's sign that
     * it's time to do all the hard work.
     */
    private void serverHelloDone(ServerHelloDone mesg) throws IOException {
<span class="nc bnc" id="L644" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L645">            mesg.print(System.out);</span>
        }
        /*
         * Always make sure the input has been digested before we
         * start emitting data, to ensure the hashes are correctly
         * computed for the Finished and CertificateVerify messages
         * which we send (here).
         */
<span class="nc" id="L653">        input.digestNow();</span>

        /*
         * FIRST ... if requested, send an appropriate Certificate chain
         * to authenticate the client, and remember the associated private
         * key to sign the CertificateVerify message.
         */
<span class="nc" id="L660">        PrivateKey signingKey = null;</span>

<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (certRequest != null) {</span>
<span class="nc" id="L663">            X509ExtendedKeyManager km = sslContext.getX509KeyManager();</span>

<span class="nc" id="L665">            ArrayList&lt;String&gt; keytypesTmp = new ArrayList&lt;&gt;(4);</span>

<span class="nc bnc" id="L667" title="All 2 branches missed.">            for (int i = 0; i &lt; certRequest.types.length; i++) {</span>
                String typeName;

<span class="nc bnc" id="L670" title="All 4 branches missed.">                switch (certRequest.types[i]) {</span>
                case CertificateRequest.cct_rsa_sign:
<span class="nc" id="L672">                    typeName = &quot;RSA&quot;;</span>
<span class="nc" id="L673">                    break;</span>

                case CertificateRequest.cct_dss_sign:
<span class="nc" id="L676">                    typeName = &quot;DSA&quot;;</span>
<span class="nc" id="L677">                    break;</span>

                case CertificateRequest.cct_ecdsa_sign:
                    // ignore if we do not have EC crypto available
<span class="nc bnc" id="L681" title="All 2 branches missed.">                    typeName = JsseJce.isEcAvailable() ? &quot;EC&quot; : null;</span>
<span class="nc" id="L682">                    break;</span>

                // Fixed DH/ECDH client authentication not supported
                case CertificateRequest.cct_rsa_fixed_dh:
                case CertificateRequest.cct_dss_fixed_dh:
                case CertificateRequest.cct_rsa_fixed_ecdh:
                case CertificateRequest.cct_ecdsa_fixed_ecdh:
                // Any other values (currently not used in TLS)
                case CertificateRequest.cct_rsa_ephemeral_dh:
                case CertificateRequest.cct_dss_ephemeral_dh:
                default:
<span class="nc" id="L693">                    typeName = null;</span>
                    break;
                }

<span class="nc bnc" id="L697" title="All 4 branches missed.">                if ((typeName != null) &amp;&amp; (!keytypesTmp.contains(typeName))) {</span>
<span class="nc" id="L698">                    keytypesTmp.add(typeName);</span>
                }
            }

<span class="nc" id="L702">            String alias = null;</span>
<span class="nc" id="L703">            int keytypesTmpSize = keytypesTmp.size();</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (keytypesTmpSize != 0) {</span>
<span class="nc" id="L705">                String keytypes[] =</span>
<span class="nc" id="L706">                        keytypesTmp.toArray(new String[keytypesTmpSize]);</span>

<span class="nc bnc" id="L708" title="All 2 branches missed.">                if (conn != null) {</span>
<span class="nc" id="L709">                    alias = km.chooseClientAlias(keytypes,</span>
<span class="nc" id="L710">                        certRequest.getAuthorities(), conn);</span>
                } else {
<span class="nc" id="L712">                    alias = km.chooseEngineClientAlias(keytypes,</span>
<span class="nc" id="L713">                        certRequest.getAuthorities(), engine);</span>
                }
            }

<span class="nc" id="L717">            CertificateMsg m1 = null;</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (alias != null) {</span>
<span class="nc" id="L719">                X509Certificate[] certs = km.getCertificateChain(alias);</span>
<span class="nc bnc" id="L720" title="All 4 branches missed.">                if ((certs != null) &amp;&amp; (certs.length != 0)) {</span>
<span class="nc" id="L721">                    PublicKey publicKey = certs[0].getPublicKey();</span>
                    // for EC, make sure we use a supported named curve
<span class="nc bnc" id="L723" title="All 2 branches missed.">                    if (publicKey instanceof ECPublicKey) {</span>
<span class="nc" id="L724">                        ECParameterSpec params =</span>
<span class="nc" id="L725">                            ((ECPublicKey)publicKey).getParams();</span>
<span class="nc" id="L726">                        int index =</span>
<span class="nc" id="L727">                            SupportedEllipticCurvesExtension.getCurveIndex(</span>
                                params);
<span class="nc bnc" id="L729" title="All 2 branches missed.">                        if (!SupportedEllipticCurvesExtension.isSupported(</span>
                                index)) {
<span class="nc" id="L731">                            publicKey = null;</span>
                        }
                    }
<span class="nc bnc" id="L734" title="All 2 branches missed.">                    if (publicKey != null) {</span>
<span class="nc" id="L735">                        m1 = new CertificateMsg(certs);</span>
<span class="nc" id="L736">                        signingKey = km.getPrivateKey(alias);</span>
<span class="nc" id="L737">                        session.setLocalPrivateKey(signingKey);</span>
<span class="nc" id="L738">                        session.setLocalCertificates(certs);</span>
                    }
                }
            }
<span class="nc bnc" id="L742" title="All 2 branches missed.">            if (m1 == null) {</span>
                //
                // No appropriate cert was found ... report this to the
                // server.  For SSLv3, send the no_certificate alert;
                // TLS uses an empty cert chain instead.
                //
<span class="nc bnc" id="L748" title="All 2 branches missed.">                if (protocolVersion.v &gt;= ProtocolVersion.TLS10.v) {</span>
<span class="nc" id="L749">                    m1 = new CertificateMsg(new X509Certificate [0]);</span>
                } else {
<span class="nc" id="L751">                    warningSE(Alerts.alert_no_certificate);</span>
                }
            }

            //
            // At last ... send any client certificate chain.
            //
<span class="nc bnc" id="L758" title="All 2 branches missed.">            if (m1 != null) {</span>
<span class="nc bnc" id="L759" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L760">                    m1.print(System.out);</span>
                }
<span class="nc" id="L762">                m1.write(output);</span>
            }
        }

        /*
         * SECOND ... send the client key exchange message.  The
         * procedure used is a function of the cipher suite selected;
         * one is always needed.
         */
        HandshakeMessage m2;

<span class="nc bnc" id="L773" title="All 7 branches missed.">        switch (keyExchange) {</span>

        case K_RSA:
        case K_RSA_EXPORT:
<span class="nc bnc" id="L777" title="All 2 branches missed.">            if (serverKey == null) {</span>
<span class="nc" id="L778">                throw new SSLProtocolException</span>
                        (&quot;Server did not send certificate message&quot;);
            }

<span class="nc bnc" id="L782" title="All 2 branches missed.">            if (!(serverKey instanceof RSAPublicKey)) {</span>
<span class="nc" id="L783">                throw new SSLProtocolException</span>
                        (&quot;Server certificate does not include an RSA key&quot;);
            }

            /*
             * For RSA key exchange, we randomly generate a new
             * pre-master secret and encrypt it with the server's
             * public key.  Then we save that pre-master secret
             * so that we can calculate the keying data later;
             * it's a performance speedup not to do that until
             * the client's waiting for the server response, but
             * more of a speedup for the D-H case.
             *
             * If the RSA_EXPORT scheme is active, when the public
             * key in the server certificate is less than or equal
             * to 512 bits in length, use the cert's public key,
             * otherwise, the ephemeral one.
             */
            PublicKey key;
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if (keyExchange == K_RSA) {</span>
<span class="nc" id="L803">                key = serverKey;</span>
            } else {    // K_RSA_EXPORT
<span class="nc bnc" id="L805" title="All 2 branches missed.">                if (JsseJce.getRSAKeyLength(serverKey) &lt;= 512) {</span>
                    // extraneous ephemeralServerKey check done
                    // above in processMessage()
<span class="nc" id="L808">                    key = serverKey;</span>
                } else {
<span class="nc bnc" id="L810" title="All 2 branches missed.">                    if (ephemeralServerKey == null) {</span>
<span class="nc" id="L811">                        throw new SSLProtocolException(&quot;Server did not send&quot; +</span>
                            &quot; a RSA_EXPORT Server Key Exchange message&quot;);
                    }
<span class="nc" id="L814">                    key = ephemeralServerKey;</span>
                }
            }

<span class="nc" id="L818">            m2 = new RSAClientKeyExchange(protocolVersion, maxProtocolVersion,</span>
<span class="nc" id="L819">                                sslContext.getSecureRandom(), key);</span>
<span class="nc" id="L820">            break;</span>
        case K_DH_RSA:
        case K_DH_DSS:
            /*
             * For DH Key exchange, we only need to make sure the server
             * knows our public key, so we calculate the same pre-master
             * secret.
             *
             * For certs that had DH keys in them, we send an empty
             * handshake message (no key) ... we flag this case by
             * passing a null &quot;dhPublic&quot; value.
             *
             * Otherwise we send ephemeral DH keys, unsigned.
             */
            // if (useDH_RSA || useDH_DSS)
<span class="nc" id="L835">            m2 = new DHClientKeyExchange();</span>
<span class="nc" id="L836">            break;</span>
        case K_DHE_RSA:
        case K_DHE_DSS:
        case K_DH_ANON:
<span class="nc bnc" id="L840" title="All 2 branches missed.">            if (dh == null) {</span>
<span class="nc" id="L841">                throw new SSLProtocolException</span>
                    (&quot;Server did not send a DH Server Key Exchange message&quot;);
            }
<span class="nc" id="L844">            m2 = new DHClientKeyExchange(dh.getPublicKey());</span>
<span class="nc" id="L845">            break;</span>
        case K_ECDHE_RSA:
        case K_ECDHE_ECDSA:
        case K_ECDH_ANON:
<span class="nc bnc" id="L849" title="All 2 branches missed.">            if (ecdh == null) {</span>
<span class="nc" id="L850">                throw new SSLProtocolException</span>
                    (&quot;Server did not send a ECDH Server Key Exchange message&quot;);
            }
<span class="nc" id="L853">            m2 = new ECDHClientKeyExchange(ecdh.getPublicKey());</span>
<span class="nc" id="L854">            break;</span>
        case K_ECDH_RSA:
        case K_ECDH_ECDSA:
<span class="nc bnc" id="L857" title="All 2 branches missed.">            if (serverKey == null) {</span>
<span class="nc" id="L858">                throw new SSLProtocolException</span>
                        (&quot;Server did not send certificate message&quot;);
            }
<span class="nc bnc" id="L861" title="All 2 branches missed.">            if (serverKey instanceof ECPublicKey == false) {</span>
<span class="nc" id="L862">                throw new SSLProtocolException</span>
                        (&quot;Server certificate does not include an EC key&quot;);
            }
<span class="nc" id="L865">            ECParameterSpec params = ((ECPublicKey)serverKey).getParams();</span>
<span class="nc" id="L866">            ecdh = new ECDHCrypt(params, sslContext.getSecureRandom());</span>
<span class="nc" id="L867">            m2 = new ECDHClientKeyExchange(ecdh.getPublicKey());</span>
<span class="nc" id="L868">            break;</span>
        case K_KRB5:
        case K_KRB5_EXPORT:
<span class="nc" id="L871">            String sniHostname = null;</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">            for (SNIServerName serverName : requestedServerNames) {</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">                if (serverName instanceof SNIHostName) {</span>
<span class="nc" id="L874">                    sniHostname = ((SNIHostName) serverName).getAsciiName();</span>
<span class="nc" id="L875">                    break;</span>
                }
<span class="nc" id="L877">            }</span>

<span class="nc" id="L879">            KerberosClientKeyExchange kerberosMsg = null;</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">            if (sniHostname != null) {</span>
                // use first requested SNI hostname
                try {
<span class="nc" id="L883">                    kerberosMsg = new KerberosClientKeyExchange(</span>
<span class="nc" id="L884">                        sniHostname, getAccSE(), protocolVersion,</span>
<span class="nc" id="L885">                        sslContext.getSecureRandom());</span>
<span class="nc" id="L886">                } catch(IOException e) {</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">                    if (serverNamesAccepted) {</span>
                        // server accepted requested SNI hostname,
                        // so it must be used
<span class="nc" id="L890">                        throw e;</span>
                    }
                    // fallback to using hostname
<span class="nc bnc" id="L893" title="All 4 branches missed.">                    if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L894">                        System.out.println(</span>
                            &quot;Warning, cannot use Server Name Indication: &quot;
<span class="nc" id="L896">                                + e.getMessage());</span>
                    }
<span class="nc" id="L898">                }</span>
            }

<span class="nc bnc" id="L901" title="All 2 branches missed.">            if (kerberosMsg == null) {</span>
<span class="nc" id="L902">                String hostname = getHostSE();</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">                if (hostname == null) {</span>
<span class="nc" id="L904">                    throw new IOException(&quot;Hostname is required&quot; +</span>
                        &quot; to use Kerberos cipher suites&quot;);
                }
<span class="nc" id="L907">                kerberosMsg = new KerberosClientKeyExchange(</span>
<span class="nc" id="L908">                     hostname, getAccSE(), protocolVersion,</span>
<span class="nc" id="L909">                     sslContext.getSecureRandom());</span>
            }

            // Record the principals involved in exchange
<span class="nc" id="L913">            session.setPeerPrincipal(kerberosMsg.getPeerPrincipal());</span>
<span class="nc" id="L914">            session.setLocalPrincipal(kerberosMsg.getLocalPrincipal());</span>
<span class="nc" id="L915">            m2 = kerberosMsg;</span>
<span class="nc" id="L916">            break;</span>
        default:
            // somethings very wrong
<span class="nc" id="L919">            throw new RuntimeException</span>
                                (&quot;Unsupported key exchange: &quot; + keyExchange);
        }
<span class="nc bnc" id="L922" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L923">            m2.print(System.out);</span>
        }
<span class="nc" id="L925">        m2.write(output);</span>


        /*
         * THIRD, send a &quot;change_cipher_spec&quot; record followed by the
         * &quot;Finished&quot; message.  We flush the messages we've queued up, to
         * get concurrency between client and server.  The concurrency is
         * useful as we calculate the master secret, which is needed both
         * to compute the &quot;Finished&quot; message, and to compute the keys used
         * to protect all records following the change_cipher_spec.
         */

<span class="nc" id="L937">        output.doHashes();</span>
<span class="nc" id="L938">        output.flush();</span>

        /*
         * We deferred calculating the master secret and this connection's
         * keying data; we do it now.  Deferring this calculation is good
         * from a performance point of view, since it lets us do it during
         * some time that network delays and the server's own calculations
         * would otherwise cause to be &quot;dead&quot; in the critical path.
         */
        SecretKey preMasterSecret;
<span class="nc bnc" id="L948" title="All 6 branches missed.">        switch (keyExchange) {</span>
        case K_RSA:
        case K_RSA_EXPORT:
<span class="nc" id="L951">            preMasterSecret = ((RSAClientKeyExchange)m2).preMaster;</span>
<span class="nc" id="L952">            break;</span>
        case K_KRB5:
        case K_KRB5_EXPORT:
<span class="nc" id="L955">            byte[] secretBytes =</span>
<span class="nc" id="L956">                ((KerberosClientKeyExchange)m2).getUnencryptedPreMasterSecret();</span>
<span class="nc" id="L957">            preMasterSecret = new SecretKeySpec(secretBytes,</span>
                &quot;TlsPremasterSecret&quot;);
<span class="nc" id="L959">            break;</span>
        case K_DHE_RSA:
        case K_DHE_DSS:
        case K_DH_ANON:
<span class="nc" id="L963">            preMasterSecret = dh.getAgreedSecret(serverDH, true);</span>
<span class="nc" id="L964">            break;</span>
        case K_ECDHE_RSA:
        case K_ECDHE_ECDSA:
        case K_ECDH_ANON:
<span class="nc" id="L968">            preMasterSecret = ecdh.getAgreedSecret(ephemeralServerKey);</span>
<span class="nc" id="L969">            break;</span>
        case K_ECDH_RSA:
        case K_ECDH_ECDSA:
<span class="nc" id="L972">            preMasterSecret = ecdh.getAgreedSecret(serverKey);</span>
<span class="nc" id="L973">            break;</span>
        default:
<span class="nc" id="L975">            throw new IOException(&quot;Internal error: unknown key exchange &quot;</span>
                + keyExchange);
        }

<span class="nc" id="L979">        calculateKeys(preMasterSecret, null);</span>

        /*
         * FOURTH, if we sent a Certificate, we need to send a signed
         * CertificateVerify (unless the key in the client's certificate
         * was a Diffie-Hellman key).).
         *
         * This uses a hash of the previous handshake messages ... either
         * a nonfinal one (if the particular implementation supports it)
         * or else using the third element in the arrays of hashes being
         * computed.
         */
<span class="nc bnc" id="L991" title="All 2 branches missed.">        if (signingKey != null) {</span>
            CertificateVerify m3;
            try {
<span class="nc" id="L994">                SignatureAndHashAlgorithm preferableSignatureAlgorithm = null;</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">                if (protocolVersion.v &gt;= ProtocolVersion.TLS12.v) {</span>
<span class="nc" id="L996">                    preferableSignatureAlgorithm =</span>
<span class="nc" id="L997">                        SignatureAndHashAlgorithm.getPreferableAlgorithm(</span>
<span class="nc" id="L998">                            peerSupportedSignAlgs, signingKey.getAlgorithm(),</span>
                            signingKey);

<span class="nc bnc" id="L1001" title="All 2 branches missed.">                    if (preferableSignatureAlgorithm == null) {</span>
<span class="nc" id="L1002">                        throw new SSLHandshakeException(</span>
                            &quot;No supported signature algorithm&quot;);
                    }

<span class="nc" id="L1006">                    String hashAlg =</span>
<span class="nc" id="L1007">                        SignatureAndHashAlgorithm.getHashAlgorithmName(</span>
                                preferableSignatureAlgorithm);
<span class="nc bnc" id="L1009" title="All 4 branches missed.">                    if (hashAlg == null || hashAlg.length() == 0) {</span>
<span class="nc" id="L1010">                        throw new SSLHandshakeException(</span>
                                &quot;No supported hash algorithm&quot;);
                    }
                }

<span class="nc" id="L1015">                m3 = new CertificateVerify(protocolVersion, handshakeHash,</span>
<span class="nc" id="L1016">                    signingKey, session.getMasterSecret(),</span>
<span class="nc" id="L1017">                    sslContext.getSecureRandom(),</span>
                    preferableSignatureAlgorithm);
<span class="nc" id="L1019">            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L1020">                fatalSE(Alerts.alert_handshake_failure,</span>
                    &quot;Error signing certificate verify&quot;, e);
                // NOTREACHED, make compiler happy
<span class="nc" id="L1023">                m3 = null;</span>
<span class="nc" id="L1024">            }</span>
<span class="nc bnc" id="L1025" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L1026">                m3.print(System.out);</span>
            }
<span class="nc" id="L1028">            m3.write(output);</span>
<span class="nc" id="L1029">            output.doHashes();</span>
        }

        /*
         * OK, that's that!
         */
<span class="nc" id="L1035">        sendChangeCipherAndFinish(false);</span>
<span class="nc" id="L1036">    }</span>


    /*
     * &quot;Finished&quot; is the last handshake message sent.  If we got this
     * far, the MAC has been validated post-decryption.  We validate
     * the two hashes here as an additional sanity check, protecting
     * the handshake against various active attacks.
     */
    private void serverFinished(Finished mesg) throws IOException {
<span class="nc bnc" id="L1046" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L1047">            mesg.print(System.out);</span>
        }

<span class="nc" id="L1050">        boolean verified = mesg.verify(handshakeHash, Finished.SERVER,</span>
<span class="nc" id="L1051">            session.getMasterSecret());</span>

<span class="nc bnc" id="L1053" title="All 2 branches missed.">        if (!verified) {</span>
<span class="nc" id="L1054">            fatalSE(Alerts.alert_illegal_parameter,</span>
                       &quot;server 'finished' message doesn't verify&quot;);
            // NOTREACHED
        }

        /*
         * save server verify data for secure renegotiation
         */
<span class="nc bnc" id="L1062" title="All 2 branches missed.">        if (secureRenegotiation) {</span>
<span class="nc" id="L1063">            serverVerifyData = mesg.getVerifyData();</span>
        }

        /*
         * OK, it verified.  If we're doing the fast handshake, add that
         * &quot;Finished&quot; message to the hash of handshake messages, then send
         * our own change_cipher_spec and Finished message for the server
         * to verify in turn.  These are the last handshake messages.
         *
         * In any case, update the session cache.  We're done handshaking,
         * so there are no threats any more associated with partially
         * completed handshakes.
         */
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        if (resumingSession) {</span>
<span class="nc" id="L1077">            input.digestNow();</span>
<span class="nc" id="L1078">            sendChangeCipherAndFinish(true);</span>
        }
<span class="nc" id="L1080">        session.setLastAccessedTime(System.currentTimeMillis());</span>

<span class="nc bnc" id="L1082" title="All 2 branches missed.">        if (!resumingSession) {</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">            if (session.isRejoinable()) {</span>
<span class="nc" id="L1084">                ((SSLSessionContextImpl) sslContext</span>
<span class="nc" id="L1085">                        .engineGetClientSessionContext())</span>
<span class="nc" id="L1086">                        .put(session);</span>
<span class="nc bnc" id="L1087" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;session&quot;)) {</span>
<span class="nc" id="L1088">                    System.out.println(&quot;%% Cached client session: &quot; + session);</span>
                }
<span class="nc bnc" id="L1090" title="All 4 branches missed.">            } else if (debug != null &amp;&amp; Debug.isOn(&quot;session&quot;)) {</span>
<span class="nc" id="L1091">                System.out.println(</span>
                    &quot;%% Didn't cache non-resumable client session: &quot;
                    + session);
            }
        }
<span class="nc" id="L1096">    }</span>


    /*
     * Send my change-cipher-spec and Finished message ... done as the
     * last handshake act in either the short or long sequences.  In
     * the short one, we've already seen the server's Finished; in the
     * long one, we wait for it now.
     */
    private void sendChangeCipherAndFinish(boolean finishedTag)
            throws IOException {
<span class="nc" id="L1107">        Finished mesg = new Finished(protocolVersion, handshakeHash,</span>
<span class="nc" id="L1108">            Finished.CLIENT, session.getMasterSecret(), cipherSuite);</span>

        /*
         * Send the change_cipher_spec message, then the Finished message
         * which we just calculated (and protected using the keys we just
         * calculated).  Server responds with its Finished message, except
         * in the &quot;fast handshake&quot; (resume session) case.
         */
<span class="nc" id="L1116">        sendChangeCipherSpec(mesg, finishedTag);</span>

        /*
         * save client verify data for secure renegotiation
         */
<span class="nc bnc" id="L1121" title="All 2 branches missed.">        if (secureRenegotiation) {</span>
<span class="nc" id="L1122">            clientVerifyData = mesg.getVerifyData();</span>
        }

        /*
         * Update state machine so server MUST send 'finished' next.
         * (In &quot;long&quot; handshake case; in short case, we're responding
         * to its message.)
         */
<span class="nc" id="L1130">        state = HandshakeMessage.ht_finished - 1;</span>
<span class="nc" id="L1131">    }</span>


    /*
     * Returns a ClientHello message to kickstart renegotiations
     */
    @Override
    HandshakeMessage getKickstartMessage() throws SSLException {
        // session ID of the ClientHello message
<span class="nc" id="L1140">        SessionId sessionId = SSLSessionImpl.nullSession.getSessionId();</span>

        // a list of cipher suites sent by the client
<span class="nc" id="L1143">        CipherSuiteList cipherSuites = getActiveCipherSuites();</span>

        // set the max protocol version this client is supporting.
<span class="nc" id="L1146">        maxProtocolVersion = protocolVersion;</span>

        //
        // Try to resume an existing session.  This might be mandatory,
        // given certain API options.
        //
<span class="nc" id="L1152">        session = ((SSLSessionContextImpl)sslContext</span>
<span class="nc" id="L1153">                        .engineGetClientSessionContext())</span>
<span class="nc" id="L1154">                        .get(getHostSE(), getPortSE());</span>
<span class="nc bnc" id="L1155" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;session&quot;)) {</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">            if (session != null) {</span>
<span class="nc" id="L1157">                System.out.println(&quot;%% Client cached &quot;</span>
                    + session
<span class="nc bnc" id="L1159" title="All 2 branches missed.">                    + (session.isRejoinable() ? &quot;&quot; : &quot; (not rejoinable)&quot;));</span>
            } else {
<span class="nc" id="L1161">                System.out.println(&quot;%% No cached client session&quot;);</span>
            }
        }
<span class="nc bnc" id="L1164" title="All 4 branches missed.">        if ((session != null) &amp;&amp; (session.isRejoinable() == false)) {</span>
<span class="nc" id="L1165">            session = null;</span>
        }

<span class="nc bnc" id="L1168" title="All 2 branches missed.">        if (session != null) {</span>
<span class="nc" id="L1169">            CipherSuite sessionSuite = session.getSuite();</span>
<span class="nc" id="L1170">            ProtocolVersion sessionVersion = session.getProtocolVersion();</span>
<span class="nc bnc" id="L1171" title="All 2 branches missed.">            if (isNegotiable(sessionSuite) == false) {</span>
<span class="nc bnc" id="L1172" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;session&quot;)) {</span>
<span class="nc" id="L1173">                    System.out.println(&quot;%% can't resume, unavailable cipher&quot;);</span>
                }
<span class="nc" id="L1175">                session = null;</span>
            }

<span class="nc bnc" id="L1178" title="All 4 branches missed.">            if ((session != null) &amp;&amp; !isNegotiable(sessionVersion)) {</span>
<span class="nc bnc" id="L1179" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;session&quot;)) {</span>
<span class="nc" id="L1180">                    System.out.println(&quot;%% can't resume, protocol disabled&quot;);</span>
                }
<span class="nc" id="L1182">                session = null;</span>
            }

<span class="nc bnc" id="L1185" title="All 2 branches missed.">            if (session != null) {</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">                if (debug != null) {</span>
<span class="nc bnc" id="L1187" title="All 4 branches missed.">                    if (Debug.isOn(&quot;handshake&quot;) || Debug.isOn(&quot;session&quot;)) {</span>
<span class="nc" id="L1188">                        System.out.println(&quot;%% Try resuming &quot; + session</span>
<span class="nc" id="L1189">                            + &quot; from port &quot; + getLocalPortSE());</span>
                    }
                }

<span class="nc" id="L1193">                sessionId = session.getSessionId();</span>
<span class="nc" id="L1194">                maxProtocolVersion = sessionVersion;</span>

                // Update SSL version number in underlying SSL socket and
                // handshake output stream, so that the output records (at the
                // record layer) have the correct version
<span class="nc" id="L1199">                setVersion(sessionVersion);</span>
            }

            /*
             * Force use of the previous session ciphersuite, and
             * add the SCSV if enabled.
             */
<span class="nc bnc" id="L1206" title="All 2 branches missed.">            if (!enableNewSession) {</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">                if (session == null) {</span>
<span class="nc" id="L1208">                    throw new SSLHandshakeException(</span>
                        &quot;Can't reuse existing SSL client session&quot;);
                }

<span class="nc" id="L1212">                Collection&lt;CipherSuite&gt; cipherList = new ArrayList&lt;&gt;(2);</span>
<span class="nc" id="L1213">                cipherList.add(sessionSuite);</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">                if (!secureRenegotiation &amp;&amp;</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">                        cipherSuites.contains(CipherSuite.C_SCSV)) {</span>
<span class="nc" id="L1216">                    cipherList.add(CipherSuite.C_SCSV);</span>
                }   // otherwise, renegotiation_info extension will be used

<span class="nc" id="L1219">                cipherSuites = new CipherSuiteList(cipherList);</span>
            }
        }

<span class="nc bnc" id="L1223" title="All 4 branches missed.">        if (session == null &amp;&amp; !enableNewSession) {</span>
<span class="nc" id="L1224">            throw new SSLHandshakeException(&quot;No existing session to resume&quot;);</span>
        }

        // exclude SCSV for secure renegotiation
<span class="nc bnc" id="L1228" title="All 4 branches missed.">        if (secureRenegotiation &amp;&amp; cipherSuites.contains(CipherSuite.C_SCSV)) {</span>
<span class="nc" id="L1229">            Collection&lt;CipherSuite&gt; cipherList =</span>
<span class="nc" id="L1230">                        new ArrayList&lt;&gt;(cipherSuites.size() - 1);</span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">            for (CipherSuite suite : cipherSuites.collection()) {</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">                if (suite != CipherSuite.C_SCSV) {</span>
<span class="nc" id="L1233">                    cipherList.add(suite);</span>
                }
<span class="nc" id="L1235">            }</span>

<span class="nc" id="L1237">            cipherSuites = new CipherSuiteList(cipherList);</span>
        }

        // make sure there is a negotiable cipher suite.
<span class="nc" id="L1241">        boolean negotiable = false;</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">        for (CipherSuite suite : cipherSuites.collection()) {</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">            if (isNegotiable(suite)) {</span>
<span class="nc" id="L1244">                negotiable = true;</span>
<span class="nc" id="L1245">                break;</span>
            }
<span class="nc" id="L1247">        }</span>

<span class="nc bnc" id="L1249" title="All 2 branches missed.">        if (!negotiable) {</span>
<span class="nc" id="L1250">            throw new SSLHandshakeException(&quot;No negotiable cipher suite&quot;);</span>
        }

        // Not a TLS1.2+ handshake
        // For SSLv2Hello, HandshakeHash.reset() will be called, so we
        // cannot call HandshakeHash.protocolDetermined() here. As it does
        // not follow the spec that HandshakeHash.reset() can be only be
        // called before protocolDetermined.
        // if (maxProtocolVersion.v &lt; ProtocolVersion.TLS12.v) {
        //     handshakeHash.protocolDetermined(maxProtocolVersion);
        // }

        // create the ClientHello message
<span class="nc" id="L1263">        ClientHello clientHelloMessage = new ClientHello(</span>
<span class="nc" id="L1264">                sslContext.getSecureRandom(), maxProtocolVersion,</span>
                sessionId, cipherSuites);

        // add signature_algorithm extension
<span class="nc bnc" id="L1268" title="All 2 branches missed.">        if (maxProtocolVersion.v &gt;= ProtocolVersion.TLS12.v) {</span>
            // we will always send the signature_algorithm extension
<span class="nc" id="L1270">            Collection&lt;SignatureAndHashAlgorithm&gt; localSignAlgs =</span>
<span class="nc" id="L1271">                                                getLocalSupportedSignAlgs();</span>
<span class="nc bnc" id="L1272" title="All 2 branches missed.">            if (localSignAlgs.isEmpty()) {</span>
<span class="nc" id="L1273">                throw new SSLHandshakeException(</span>
                            &quot;No supported signature algorithm&quot;);
            }

<span class="nc" id="L1277">            clientHelloMessage.addSignatureAlgorithmsExtension(localSignAlgs);</span>
        }

        // add server_name extension
<span class="nc bnc" id="L1281" title="All 2 branches missed.">        if (enableSNIExtension) {</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">            if (session != null) {</span>
<span class="nc" id="L1283">                requestedServerNames = session.getRequestedServerNames();</span>
            } else {
<span class="nc" id="L1285">                requestedServerNames = serverNames;</span>
            }

<span class="nc bnc" id="L1288" title="All 2 branches missed.">            if (!requestedServerNames.isEmpty()) {</span>
<span class="nc" id="L1289">                clientHelloMessage.addSNIExtension(requestedServerNames);</span>
            }
        }

        // reset the client random cookie
<span class="nc" id="L1294">        clnt_random = clientHelloMessage.clnt_random;</span>

        /*
         * need to set the renegotiation_info extension for:
         * 1: secure renegotiation
         * 2: initial handshake and no SCSV in the ClientHello
         * 3: insecure renegotiation and no SCSV in the ClientHello
         */
<span class="nc bnc" id="L1302" title="All 2 branches missed.">        if (secureRenegotiation ||</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">                !cipherSuites.contains(CipherSuite.C_SCSV)) {</span>
<span class="nc" id="L1304">            clientHelloMessage.addRenegotiationInfoExtension(clientVerifyData);</span>
        }

<span class="nc" id="L1307">        return clientHelloMessage;</span>
    }

    /*
     * Fault detected during handshake.
     */
    @Override
    void handshakeAlert(byte description) throws SSLProtocolException {
<span class="nc" id="L1315">        String message = Alerts.alertDescription(description);</span>

<span class="nc bnc" id="L1317" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L1318">            System.out.println(&quot;SSL - handshake alert: &quot; + message);</span>
        }
<span class="nc" id="L1320">        throw new SSLProtocolException(&quot;handshake alert:  &quot; + message);</span>
    }

    /*
     * Unless we are using an anonymous ciphersuite, the server always
     * sends a certificate message (for the CipherSuites we currently
     * support). The trust manager verifies the chain for us.
     */
    private void serverCertificate(CertificateMsg mesg) throws IOException {
<span class="nc bnc" id="L1329" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L1330">            mesg.print(System.out);</span>
        }
<span class="nc" id="L1332">        X509Certificate[] peerCerts = mesg.getCertificateChain();</span>
<span class="nc bnc" id="L1333" title="All 2 branches missed.">        if (peerCerts.length == 0) {</span>
<span class="nc" id="L1334">            fatalSE(Alerts.alert_bad_certificate,</span>
                &quot;empty certificate chain&quot;);
        }
        // ask the trust manager to verify the chain
<span class="nc" id="L1338">        X509TrustManager tm = sslContext.getX509TrustManager();</span>
        try {
            // find out the key exchange algorithm used
            // use &quot;RSA&quot; for non-ephemeral &quot;RSA_EXPORT&quot;
            String keyExchangeString;
<span class="nc bnc" id="L1343" title="All 4 branches missed.">            if (keyExchange == K_RSA_EXPORT &amp;&amp; !serverKeyExchangeReceived) {</span>
<span class="nc" id="L1344">                keyExchangeString = K_RSA.name;</span>
            } else {
<span class="nc" id="L1346">                keyExchangeString = keyExchange.name;</span>
            }

<span class="nc bnc" id="L1349" title="All 2 branches missed.">            if (tm instanceof X509ExtendedTrustManager) {</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">                if (conn != null) {</span>
<span class="nc" id="L1351">                    ((X509ExtendedTrustManager)tm).checkServerTrusted(</span>
<span class="nc" id="L1352">                        peerCerts.clone(),</span>
                        keyExchangeString,
                        conn);
                } else {
<span class="nc" id="L1356">                    ((X509ExtendedTrustManager)tm).checkServerTrusted(</span>
<span class="nc" id="L1357">                        peerCerts.clone(),</span>
                        keyExchangeString,
                        engine);
                }
            } else {
                // Unlikely to happen, because we have wrapped the old
                // X509TrustManager with the new X509ExtendedTrustManager.
<span class="nc" id="L1364">                throw new CertificateException(</span>
                    &quot;Improper X509TrustManager implementation&quot;);
            }
<span class="nc" id="L1367">        } catch (CertificateException e) {</span>
            // This will throw an exception, so include the original error.
<span class="nc" id="L1369">            fatalSE(Alerts.alert_certificate_unknown, e);</span>
<span class="nc" id="L1370">        }</span>
<span class="nc" id="L1371">        session.setPeerCertificates(peerCerts);</span>
<span class="nc" id="L1372">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>