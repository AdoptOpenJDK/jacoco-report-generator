<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SSLContextImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">SSLContextImpl.java</span></div><h1>SSLContextImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.ssl;

import java.net.Socket;

import java.io.*;
import java.util.*;
import java.security.*;
import java.security.cert.*;
import java.security.cert.Certificate;

import javax.net.ssl.*;

import sun.security.provider.certpath.AlgorithmChecker;

public abstract class SSLContextImpl extends SSLContextSpi {

<span class="nc" id="L42">    private static final Debug debug = Debug.getInstance(&quot;ssl&quot;);</span>

    private final EphemeralKeyManager ephemeralKeyManager;
    private final SSLSessionContextImpl clientCache;
    private final SSLSessionContextImpl serverCache;

    private boolean isInitialized;

    private X509ExtendedKeyManager keyManager;
    private X509TrustManager trustManager;
    private SecureRandom secureRandom;

    // The default algrithm constraints
<span class="nc" id="L55">    private AlgorithmConstraints defaultAlgorithmConstraints =</span>
                                 new SSLAlgorithmConstraints(null);

    // supported and default protocols
    private ProtocolList defaultServerProtocolList;
    private ProtocolList defaultClientProtocolList;
    private ProtocolList supportedProtocolList;

    // supported and default cipher suites
    private CipherSuiteList defaultServerCipherSuiteList;
    private CipherSuiteList defaultClientCipherSuiteList;
    private CipherSuiteList supportedCipherSuiteList;

<span class="nc" id="L68">    SSLContextImpl() {</span>
<span class="nc" id="L69">        ephemeralKeyManager = new EphemeralKeyManager();</span>
<span class="nc" id="L70">        clientCache = new SSLSessionContextImpl();</span>
<span class="nc" id="L71">        serverCache = new SSLSessionContextImpl();</span>
<span class="nc" id="L72">    }</span>

    @Override
    protected void engineInit(KeyManager[] km, TrustManager[] tm,
                                SecureRandom sr) throws KeyManagementException {
<span class="nc" id="L77">        isInitialized = false;</span>
<span class="nc" id="L78">        keyManager = chooseKeyManager(km);</span>

<span class="nc bnc" id="L80" title="All 2 branches missed.">        if (tm == null) {</span>
            try {
<span class="nc" id="L82">                TrustManagerFactory tmf = TrustManagerFactory.getInstance(</span>
<span class="nc" id="L83">                        TrustManagerFactory.getDefaultAlgorithm());</span>
<span class="nc" id="L84">                tmf.init((KeyStore)null);</span>
<span class="nc" id="L85">                tm = tmf.getTrustManagers();</span>
<span class="nc" id="L86">            } catch (Exception e) {</span>
                // eat
<span class="nc" id="L88">            }</span>
        }
<span class="nc" id="L90">        trustManager = chooseTrustManager(tm);</span>

<span class="nc bnc" id="L92" title="All 2 branches missed.">        if (sr == null) {</span>
<span class="nc" id="L93">            secureRandom = JsseJce.getSecureRandom();</span>
        } else {
<span class="nc bnc" id="L95" title="All 2 branches missed.">            if (SunJSSE.isFIPS() &amp;&amp;</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                        (sr.getProvider() != SunJSSE.cryptoProvider)) {</span>
<span class="nc" id="L97">                throw new KeyManagementException</span>
                    (&quot;FIPS mode: SecureRandom must be from provider &quot;
<span class="nc" id="L99">                    + SunJSSE.cryptoProvider.getName());</span>
            }
<span class="nc" id="L101">            secureRandom = sr;</span>
        }

        /*
         * The initial delay of seeding the random number generator
         * could be long enough to cause the initial handshake on our
         * first connection to timeout and fail. Make sure it is
         * primed and ready by getting some initial output from it.
         */
<span class="nc bnc" id="L110" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;sslctx&quot;)) {</span>
<span class="nc" id="L111">            System.out.println(&quot;trigger seeding of SecureRandom&quot;);</span>
        }
<span class="nc" id="L113">        secureRandom.nextInt();</span>
<span class="nc bnc" id="L114" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;sslctx&quot;)) {</span>
<span class="nc" id="L115">            System.out.println(&quot;done seeding SecureRandom&quot;);</span>
        }
<span class="nc" id="L117">        isInitialized = true;</span>
<span class="nc" id="L118">    }</span>

    private X509TrustManager chooseTrustManager(TrustManager[] tm)
            throws KeyManagementException {
        // We only use the first instance of X509TrustManager passed to us.
<span class="nc bnc" id="L123" title="All 4 branches missed.">        for (int i = 0; tm != null &amp;&amp; i &lt; tm.length; i++) {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">            if (tm[i] instanceof X509TrustManager) {</span>
<span class="nc bnc" id="L125" title="All 4 branches missed.">                if (SunJSSE.isFIPS() &amp;&amp;</span>
                        !(tm[i] instanceof X509TrustManagerImpl)) {
<span class="nc" id="L127">                    throw new KeyManagementException</span>
                        (&quot;FIPS mode: only SunJSSE TrustManagers may be used&quot;);
                }

<span class="nc bnc" id="L131" title="All 2 branches missed.">                if (tm[i] instanceof X509ExtendedTrustManager) {</span>
<span class="nc" id="L132">                    return (X509TrustManager)tm[i];</span>
                } else {
<span class="nc" id="L134">                    return new AbstractTrustManagerWrapper(</span>
                                        (X509TrustManager)tm[i]);
                }
            }
        }

        // nothing found, return a dummy X509TrustManager.
<span class="nc" id="L141">        return DummyX509TrustManager.INSTANCE;</span>
    }

    private X509ExtendedKeyManager chooseKeyManager(KeyManager[] kms)
            throws KeyManagementException {
<span class="nc bnc" id="L146" title="All 4 branches missed.">        for (int i = 0; kms != null &amp;&amp; i &lt; kms.length; i++) {</span>
<span class="nc" id="L147">            KeyManager km = kms[i];</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (!(km instanceof X509KeyManager)) {</span>
<span class="nc" id="L149">                continue;</span>
            }
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (SunJSSE.isFIPS()) {</span>
                // In FIPS mode, require that one of SunJSSE's own keymanagers
                // is used. Otherwise, we cannot be sure that only keys from
                // the FIPS token are used.
<span class="nc bnc" id="L155" title="All 4 branches missed.">                if ((km instanceof X509KeyManagerImpl)</span>
                            || (km instanceof SunX509KeyManagerImpl)) {
<span class="nc" id="L157">                    return (X509ExtendedKeyManager)km;</span>
                } else {
                    // throw exception, we don't want to silently use the
                    // dummy keymanager without telling the user.
<span class="nc" id="L161">                    throw new KeyManagementException</span>
                        (&quot;FIPS mode: only SunJSSE KeyManagers may be used&quot;);
                }
            }
<span class="nc bnc" id="L165" title="All 2 branches missed.">            if (km instanceof X509ExtendedKeyManager) {</span>
<span class="nc" id="L166">                return (X509ExtendedKeyManager)km;</span>
            }
<span class="nc bnc" id="L168" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;sslctx&quot;)) {</span>
<span class="nc" id="L169">                System.out.println(</span>
                    &quot;X509KeyManager passed to &quot; +
                    &quot;SSLContext.init():  need an &quot; +
                    &quot;X509ExtendedKeyManager for SSLEngine use&quot;);
            }
<span class="nc" id="L174">            return new AbstractKeyManagerWrapper((X509KeyManager)km);</span>
        }

        // nothing found, return a dummy X509ExtendedKeyManager
<span class="nc" id="L178">        return DummyX509KeyManager.INSTANCE;</span>
    }

    @Override
    protected SSLSocketFactory engineGetSocketFactory() {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (!isInitialized) {</span>
<span class="nc" id="L184">            throw new IllegalStateException(</span>
                &quot;SSLContextImpl is not initialized&quot;);
        }
<span class="nc" id="L187">       return new SSLSocketFactoryImpl(this);</span>
    }

    @Override
    protected SSLServerSocketFactory engineGetServerSocketFactory() {
<span class="nc bnc" id="L192" title="All 2 branches missed.">        if (!isInitialized) {</span>
<span class="nc" id="L193">            throw new IllegalStateException(&quot;SSLContext is not initialized&quot;);</span>
        }
<span class="nc" id="L195">        return new SSLServerSocketFactoryImpl(this);</span>
    }

    @Override
    protected SSLEngine engineCreateSSLEngine() {
<span class="nc bnc" id="L200" title="All 2 branches missed.">        if (!isInitialized) {</span>
<span class="nc" id="L201">            throw new IllegalStateException(</span>
                &quot;SSLContextImpl is not initialized&quot;);
        }
<span class="nc" id="L204">        return new SSLEngineImpl(this);</span>
    }

    @Override
    protected SSLEngine engineCreateSSLEngine(String host, int port) {
<span class="nc bnc" id="L209" title="All 2 branches missed.">        if (!isInitialized) {</span>
<span class="nc" id="L210">            throw new IllegalStateException(</span>
                &quot;SSLContextImpl is not initialized&quot;);
        }
<span class="nc" id="L213">        return new SSLEngineImpl(this, host, port);</span>
    }

    @Override
    protected SSLSessionContext engineGetClientSessionContext() {
<span class="nc" id="L218">        return clientCache;</span>
    }

    @Override
    protected SSLSessionContext engineGetServerSessionContext() {
<span class="nc" id="L223">        return serverCache;</span>
    }

    SecureRandom getSecureRandom() {
<span class="nc" id="L227">        return secureRandom;</span>
    }

    X509ExtendedKeyManager getX509KeyManager() {
<span class="nc" id="L231">        return keyManager;</span>
    }

    X509TrustManager getX509TrustManager() {
<span class="nc" id="L235">        return trustManager;</span>
    }

    EphemeralKeyManager getEphemeralKeyManager() {
<span class="nc" id="L239">        return ephemeralKeyManager;</span>
    }

    abstract SSLParameters getDefaultServerSSLParams();
    abstract SSLParameters getDefaultClientSSLParams();
    abstract SSLParameters getSupportedSSLParams();

    // Get supported ProtocolList.
    ProtocolList getSuportedProtocolList() {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (supportedProtocolList == null) {</span>
<span class="nc" id="L249">            supportedProtocolList =</span>
<span class="nc" id="L250">                new ProtocolList(getSupportedSSLParams().getProtocols());</span>
        }

<span class="nc" id="L253">        return supportedProtocolList;</span>
    }

    // Get default ProtocolList.
    ProtocolList getDefaultProtocolList(boolean roleIsServer) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (roleIsServer) {</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (defaultServerProtocolList == null) {</span>
<span class="nc" id="L260">                defaultServerProtocolList = new ProtocolList(</span>
<span class="nc" id="L261">                        getDefaultServerSSLParams().getProtocols());</span>
            }

<span class="nc" id="L264">            return defaultServerProtocolList;</span>
        } else {
<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (defaultClientProtocolList == null) {</span>
<span class="nc" id="L267">                defaultClientProtocolList = new ProtocolList(</span>
<span class="nc" id="L268">                        getDefaultClientSSLParams().getProtocols());</span>
            }

<span class="nc" id="L271">            return defaultClientProtocolList;</span>
        }
    }

    // Get supported CipherSuiteList.
    CipherSuiteList getSupportedCipherSuiteList() {
        // The maintenance of cipher suites needs to be synchronized.
<span class="nc" id="L278">        synchronized (this) {</span>
            // Clear cache of available ciphersuites.
<span class="nc" id="L280">            clearAvailableCache();</span>

<span class="nc bnc" id="L282" title="All 2 branches missed.">            if (supportedCipherSuiteList == null) {</span>
<span class="nc" id="L283">                supportedCipherSuiteList = getApplicableCipherSuiteList(</span>
<span class="nc" id="L284">                        getSuportedProtocolList(), false);</span>
            }

<span class="nc" id="L287">            return supportedCipherSuiteList;</span>
<span class="nc" id="L288">        }</span>
    }

    // Get default CipherSuiteList.
    CipherSuiteList getDefaultCipherSuiteList(boolean roleIsServer) {
        // The maintenance of cipher suites needs to be synchronized.
<span class="nc" id="L294">        synchronized (this) {</span>
            // Clear cache of available ciphersuites.
<span class="nc" id="L296">            clearAvailableCache();</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (roleIsServer) {</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">                if (defaultServerCipherSuiteList == null) {</span>
<span class="nc" id="L300">                    defaultServerCipherSuiteList = getApplicableCipherSuiteList(</span>
<span class="nc" id="L301">                        getDefaultProtocolList(true), true);</span>
                }

<span class="nc" id="L304">                return defaultServerCipherSuiteList;</span>
            } else {
<span class="nc bnc" id="L306" title="All 2 branches missed.">                if (defaultClientCipherSuiteList == null) {</span>
<span class="nc" id="L307">                    defaultClientCipherSuiteList = getApplicableCipherSuiteList(</span>
<span class="nc" id="L308">                        getDefaultProtocolList(false), true);</span>
                }

<span class="nc" id="L311">                return defaultClientCipherSuiteList;</span>
            }
<span class="nc" id="L313">        }</span>
    }

    /**
     * Return whether a protocol list is the original default enabled
     * protocols.  See: SSLSocket/SSLEngine.setEnabledProtocols()
     */
    boolean isDefaultProtocolList(ProtocolList protocols) {
<span class="nc bnc" id="L321" title="All 4 branches missed.">        return (protocols == defaultServerProtocolList) ||</span>
               (protocols == defaultClientProtocolList);
    }


    /*
     * Return the list of all available CipherSuites with a priority of
     * minPriority or above.
     */
    private CipherSuiteList getApplicableCipherSuiteList(
            ProtocolList protocols, boolean onlyEnabled) {

<span class="nc" id="L333">        int minPriority = CipherSuite.SUPPORTED_SUITES_PRIORITY;</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (onlyEnabled) {</span>
<span class="nc" id="L335">            minPriority = CipherSuite.DEFAULT_SUITES_PRIORITY;</span>
        }

        Collection&lt;CipherSuite&gt; allowedCipherSuites =
<span class="nc" id="L339">                                    CipherSuite.allowedCipherSuites();</span>

<span class="nc" id="L341">        TreeSet&lt;CipherSuite&gt; suites = new TreeSet&lt;&gt;();</span>
<span class="nc bnc" id="L342" title="All 4 branches missed.">        if (!(protocols.collection().isEmpty()) &amp;&amp;</span>
                protocols.min.v != ProtocolVersion.NONE.v) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">            for (CipherSuite suite : allowedCipherSuites) {</span>
<span class="nc bnc" id="L345" title="All 4 branches missed.">                if (!suite.allowed || suite.priority &lt; minPriority) {</span>
<span class="nc" id="L346">                    continue;</span>
                }

<span class="nc bnc" id="L349" title="All 6 branches missed.">                if (suite.isAvailable() &amp;&amp;</span>
                        suite.obsoleted &gt; protocols.min.v &amp;&amp;
                        suite.supported &lt;= protocols.max.v) {
<span class="nc bnc" id="L352" title="All 2 branches missed.">                    if (defaultAlgorithmConstraints.permits(</span>
<span class="nc" id="L353">                            EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),</span>
                            suite.name, null)) {
<span class="nc" id="L355">                        suites.add(suite);</span>
                    }
<span class="nc bnc" id="L357" title="All 2 branches missed.">                } else if (debug != null &amp;&amp;</span>
<span class="nc bnc" id="L358" title="All 4 branches missed.">                        Debug.isOn(&quot;sslctx&quot;) &amp;&amp; Debug.isOn(&quot;verbose&quot;)) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                    if (suite.obsoleted &lt;= protocols.min.v) {</span>
<span class="nc" id="L360">                        System.out.println(</span>
                            &quot;Ignoring obsoleted cipher suite: &quot; + suite);
<span class="nc bnc" id="L362" title="All 2 branches missed.">                    } else if (suite.supported &gt; protocols.max.v) {</span>
<span class="nc" id="L363">                        System.out.println(</span>
                            &quot;Ignoring unsupported cipher suite: &quot; + suite);
                    } else {
<span class="nc" id="L366">                        System.out.println(</span>
                            &quot;Ignoring unavailable cipher suite: &quot; + suite);
                    }
                }
<span class="nc" id="L370">            }</span>
        }

<span class="nc" id="L373">        return new CipherSuiteList(suites);</span>
    }

    /**
     * Clear cache of available ciphersuites. If we support all ciphers
     * internally, there is no need to clear the cache and calling this
     * method has no effect.
     *
     * Note that every call to clearAvailableCache() and the maintenance of
     * cipher suites need to be synchronized with this instance.
     */
    private void clearAvailableCache() {
        if (CipherSuite.DYNAMIC_AVAILABILITY) {
<span class="nc" id="L386">            supportedCipherSuiteList = null;</span>
<span class="nc" id="L387">            defaultServerCipherSuiteList = null;</span>
<span class="nc" id="L388">            defaultClientCipherSuiteList = null;</span>
<span class="nc" id="L389">            CipherSuite.BulkCipher.clearAvailableCache();</span>
<span class="nc" id="L390">            JsseJce.clearEcAvailable();</span>
        }
<span class="nc" id="L392">    }</span>

    /*
     * The SSLContext implementation for TLS/SSL algorithm
     *
     * SSL/TLS protocols specify the forward compatibility and version
     * roll-back attack protections, however, a number of SSL/TLS server
     * vendors did not implement these aspects properly, and some current
     * SSL/TLS servers may refuse to talk to a TLS 1.1 or later client.
     *
     * Considering above interoperability issues, SunJSSE will not set
     * TLS 1.1 and TLS 1.2 as the enabled protocols for client by default.
     *
     * For SSL/TLS servers, there is no such interoperability issues as
     * SSL/TLS clients. In SunJSSE, TLS 1.1 or later version will be the
     * enabled protocols for server by default.
     *
     * We may change the behavior when popular TLS/SSL vendors support TLS
     * forward compatibility properly.
     *
     * SSLv2Hello is no longer necessary.  This interoperability option was
     * put in place in the late 90's when SSLv3/TLS1.0 were relatively new
     * and there were a fair number of SSLv2-only servers deployed.  Because
     * of the security issues in SSLv2, it is rarely (if ever) used, as
     * deployments should now be using SSLv3 and TLSv1.
     *
     * Considering the issues of SSLv2Hello, we should not enable SSLv2Hello
     * by default. Applications still can use it by enabling SSLv2Hello with
     * the series of setEnabledProtocols APIs.
     */

    /*
     * The conservative SSLContext implementation for TLS, SSL, SSLv3 and
     * TLS10 algorithm.
     *
     * This is a super class of DefaultSSLContext and TLS10Context.
     *
     * @see SSLContext
     */
<span class="nc" id="L431">    private static class ConservativeSSLContext extends SSLContextImpl {</span>
        // parameters
        private static SSLParameters defaultServerSSLParams;
        private static SSLParameters defaultClientSSLParams;
        private static SSLParameters supportedSSLParams;

        static {
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (SunJSSE.isFIPS()) {</span>
<span class="nc" id="L439">                supportedSSLParams = new SSLParameters();</span>
<span class="nc" id="L440">                supportedSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.TLS10.name,
                    ProtocolVersion.TLS11.name,
                    ProtocolVersion.TLS12.name
                });

<span class="nc" id="L446">                defaultServerSSLParams = supportedSSLParams;</span>

<span class="nc" id="L448">                defaultClientSSLParams = new SSLParameters();</span>
<span class="nc" id="L449">                defaultClientSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.TLS10.name
                });

            } else {
<span class="nc" id="L454">                supportedSSLParams = new SSLParameters();</span>
<span class="nc" id="L455">                supportedSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.SSL20Hello.name,
                    ProtocolVersion.SSL30.name,
                    ProtocolVersion.TLS10.name,
                    ProtocolVersion.TLS11.name,
                    ProtocolVersion.TLS12.name
                });

<span class="nc" id="L463">                defaultServerSSLParams = supportedSSLParams;</span>

<span class="nc" id="L465">                defaultClientSSLParams = new SSLParameters();</span>
<span class="nc" id="L466">                defaultClientSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.SSL30.name,
                    ProtocolVersion.TLS10.name
                });
            }
<span class="nc" id="L471">        }</span>

        @Override
        SSLParameters getDefaultServerSSLParams() {
<span class="nc" id="L475">            return defaultServerSSLParams;</span>
        }

        @Override
        SSLParameters getDefaultClientSSLParams() {
<span class="nc" id="L480">            return defaultClientSSLParams;</span>
        }

        @Override
        SSLParameters getSupportedSSLParams() {
<span class="nc" id="L485">            return supportedSSLParams;</span>
        }
    }

    /*
     * The SSLContext implementation for default algorithm
     *
     * @see SSLContext
     */
    public static final class DefaultSSLContext extends ConservativeSSLContext {
        private static final String NONE = &quot;NONE&quot;;
        private static final String P11KEYSTORE = &quot;PKCS11&quot;;

        private static volatile SSLContextImpl defaultImpl;

        private static TrustManager[] defaultTrustManagers;
        private static KeyManager[] defaultKeyManagers;

<span class="nc" id="L503">        public DefaultSSLContext() throws Exception {</span>
            try {
<span class="nc" id="L505">                super.engineInit(getDefaultKeyManager(),</span>
<span class="nc" id="L506">                        getDefaultTrustManager(), null);</span>
<span class="nc" id="L507">            } catch (Exception e) {</span>
<span class="nc bnc" id="L508" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;defaultctx&quot;)) {</span>
<span class="nc" id="L509">                    System.out.println(&quot;default context init failed: &quot; + e);</span>
                }
<span class="nc" id="L511">                throw e;</span>
<span class="nc" id="L512">            }</span>

<span class="nc bnc" id="L514" title="All 2 branches missed.">            if (defaultImpl == null) {</span>
<span class="nc" id="L515">                defaultImpl = this;</span>
            }
<span class="nc" id="L517">        }</span>

        @Override
        protected void engineInit(KeyManager[] km, TrustManager[] tm,
            SecureRandom sr) throws KeyManagementException {
<span class="nc" id="L522">            throw new KeyManagementException</span>
                (&quot;Default SSLContext is initialized automatically&quot;);
        }

        static synchronized SSLContextImpl getDefaultImpl() throws Exception {
<span class="nc bnc" id="L527" title="All 2 branches missed.">            if (defaultImpl == null) {</span>
<span class="nc" id="L528">                new DefaultSSLContext();</span>
            }
<span class="nc" id="L530">            return defaultImpl;</span>
        }

        private static synchronized TrustManager[] getDefaultTrustManager()
                throws Exception {
<span class="nc bnc" id="L535" title="All 2 branches missed.">            if (defaultTrustManagers != null) {</span>
<span class="nc" id="L536">                return defaultTrustManagers;</span>
            }

<span class="nc" id="L539">            KeyStore ks =</span>
<span class="nc" id="L540">                TrustManagerFactoryImpl.getCacertsKeyStore(&quot;defaultctx&quot;);</span>

<span class="nc" id="L542">            TrustManagerFactory tmf = TrustManagerFactory.getInstance(</span>
<span class="nc" id="L543">                TrustManagerFactory.getDefaultAlgorithm());</span>
<span class="nc" id="L544">            tmf.init(ks);</span>
<span class="nc" id="L545">            defaultTrustManagers = tmf.getTrustManagers();</span>
<span class="nc" id="L546">            return defaultTrustManagers;</span>
        }

        private static synchronized KeyManager[] getDefaultKeyManager()
                throws Exception {
<span class="nc bnc" id="L551" title="All 2 branches missed.">            if (defaultKeyManagers != null) {</span>
<span class="nc" id="L552">                return defaultKeyManagers;</span>
            }

<span class="nc" id="L555">            final Map&lt;String,String&gt; props = new HashMap&lt;&gt;();</span>
<span class="nc" id="L556">            AccessController.doPrivileged(</span>
<span class="nc" id="L557">                        new PrivilegedExceptionAction&lt;Object&gt;() {</span>
                @Override
                public Object run() throws Exception {
<span class="nc" id="L560">                    props.put(&quot;keyStore&quot;,  System.getProperty(</span>
                                &quot;javax.net.ssl.keyStore&quot;, &quot;&quot;));
<span class="nc" id="L562">                    props.put(&quot;keyStoreType&quot;, System.getProperty(</span>
                                &quot;javax.net.ssl.keyStoreType&quot;,
<span class="nc" id="L564">                                KeyStore.getDefaultType()));</span>
<span class="nc" id="L565">                    props.put(&quot;keyStoreProvider&quot;, System.getProperty(</span>
                                &quot;javax.net.ssl.keyStoreProvider&quot;, &quot;&quot;));
<span class="nc" id="L567">                    props.put(&quot;keyStorePasswd&quot;, System.getProperty(</span>
                                &quot;javax.net.ssl.keyStorePassword&quot;, &quot;&quot;));
<span class="nc" id="L569">                    return null;</span>
                }
            });

<span class="nc" id="L573">            final String defaultKeyStore = props.get(&quot;keyStore&quot;);</span>
<span class="nc" id="L574">            String defaultKeyStoreType = props.get(&quot;keyStoreType&quot;);</span>
<span class="nc" id="L575">            String defaultKeyStoreProvider = props.get(&quot;keyStoreProvider&quot;);</span>
<span class="nc bnc" id="L576" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;defaultctx&quot;)) {</span>
<span class="nc" id="L577">                System.out.println(&quot;keyStore is : &quot; + defaultKeyStore);</span>
<span class="nc" id="L578">                System.out.println(&quot;keyStore type is : &quot; +</span>
                                        defaultKeyStoreType);
<span class="nc" id="L580">                System.out.println(&quot;keyStore provider is : &quot; +</span>
                                        defaultKeyStoreProvider);
            }

<span class="nc bnc" id="L584" title="All 2 branches missed.">            if (P11KEYSTORE.equals(defaultKeyStoreType) &amp;&amp;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">                    !NONE.equals(defaultKeyStore)) {</span>
<span class="nc" id="L586">                throw new IllegalArgumentException(&quot;if keyStoreType is &quot;</span>
                    + P11KEYSTORE + &quot;, then keyStore must be &quot; + NONE);
            }

<span class="nc" id="L590">            FileInputStream fs = null;</span>
<span class="nc" id="L591">            KeyStore ks = null;</span>
<span class="nc" id="L592">            char[] passwd = null;</span>
            try {
<span class="nc bnc" id="L594" title="All 2 branches missed.">                if (defaultKeyStore.length() != 0 &amp;&amp;</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                        !NONE.equals(defaultKeyStore)) {</span>
<span class="nc" id="L596">                    fs = AccessController.doPrivileged(</span>
<span class="nc" id="L597">                            new PrivilegedExceptionAction&lt;FileInputStream&gt;() {</span>
                        @Override
                        public FileInputStream run() throws Exception {
<span class="nc" id="L600">                            return new FileInputStream(defaultKeyStore);</span>
                        }
                    });
                }

<span class="nc" id="L605">                String defaultKeyStorePassword = props.get(&quot;keyStorePasswd&quot;);</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">                if (defaultKeyStorePassword.length() != 0) {</span>
<span class="nc" id="L607">                    passwd = defaultKeyStorePassword.toCharArray();</span>
                }

                /**
                 * Try to initialize key store.
                 */
<span class="nc bnc" id="L613" title="All 2 branches missed.">                if ((defaultKeyStoreType.length()) != 0) {</span>
<span class="nc bnc" id="L614" title="All 4 branches missed.">                    if (debug != null &amp;&amp; Debug.isOn(&quot;defaultctx&quot;)) {</span>
<span class="nc" id="L615">                        System.out.println(&quot;init keystore&quot;);</span>
                    }
<span class="nc bnc" id="L617" title="All 2 branches missed.">                    if (defaultKeyStoreProvider.length() == 0) {</span>
<span class="nc" id="L618">                        ks = KeyStore.getInstance(defaultKeyStoreType);</span>
                    } else {
<span class="nc" id="L620">                        ks = KeyStore.getInstance(defaultKeyStoreType,</span>
                                            defaultKeyStoreProvider);
                    }

                    // if defaultKeyStore is NONE, fs will be null
<span class="nc" id="L625">                    ks.load(fs, passwd);</span>
                }
            } finally {
<span class="nc bnc" id="L628" title="All 4 branches missed.">                if (fs != null) {</span>
<span class="nc" id="L629">                    fs.close();</span>
<span class="nc" id="L630">                    fs = null;</span>
                }
            }

            /*
             * Try to initialize key manager.
             */
<span class="nc bnc" id="L637" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;defaultctx&quot;)) {</span>
<span class="nc" id="L638">                System.out.println(&quot;init keymanager of type &quot; +</span>
<span class="nc" id="L639">                    KeyManagerFactory.getDefaultAlgorithm());</span>
            }
<span class="nc" id="L641">            KeyManagerFactory kmf = KeyManagerFactory.getInstance(</span>
<span class="nc" id="L642">                KeyManagerFactory.getDefaultAlgorithm());</span>

<span class="nc bnc" id="L644" title="All 2 branches missed.">            if (P11KEYSTORE.equals(defaultKeyStoreType)) {</span>
<span class="nc" id="L645">                kmf.init(ks, null); // do not pass key passwd if using token</span>
            } else {
<span class="nc" id="L647">                kmf.init(ks, passwd);</span>
            }

<span class="nc" id="L650">            defaultKeyManagers = kmf.getKeyManagers();</span>
<span class="nc" id="L651">            return defaultKeyManagers;</span>
        }
    }

    /*
     * The SSLContext implementation for TLS, SSL, SSLv3 and TLS10 algorithm
     *
     * @see SSLContext
     */
<span class="nc" id="L660">    public static final class TLS10Context extends ConservativeSSLContext {</span>
        // use the default constructor and methods
    }

    /*
     * The SSLContext implementation for TLS11 algorithm
     *
     * @see SSLContext
     */
<span class="nc" id="L669">    public static final class TLS11Context extends SSLContextImpl {</span>
        // parameters
        private static SSLParameters defaultServerSSLParams;
        private static SSLParameters defaultClientSSLParams;
        private static SSLParameters supportedSSLParams;

        static {
<span class="nc bnc" id="L676" title="All 2 branches missed.">            if (SunJSSE.isFIPS()) {</span>
<span class="nc" id="L677">                supportedSSLParams = new SSLParameters();</span>
<span class="nc" id="L678">                supportedSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.TLS10.name,
                    ProtocolVersion.TLS11.name,
                    ProtocolVersion.TLS12.name
                });

<span class="nc" id="L684">                defaultServerSSLParams = supportedSSLParams;</span>

<span class="nc" id="L686">                defaultClientSSLParams = new SSLParameters();</span>
<span class="nc" id="L687">                defaultClientSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.TLS10.name,
                    ProtocolVersion.TLS11.name
                });

            } else {
<span class="nc" id="L693">                supportedSSLParams = new SSLParameters();</span>
<span class="nc" id="L694">                supportedSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.SSL20Hello.name,
                    ProtocolVersion.SSL30.name,
                    ProtocolVersion.TLS10.name,
                    ProtocolVersion.TLS11.name,
                    ProtocolVersion.TLS12.name
                });

<span class="nc" id="L702">                defaultServerSSLParams = supportedSSLParams;</span>

<span class="nc" id="L704">                defaultClientSSLParams = new SSLParameters();</span>
<span class="nc" id="L705">                defaultClientSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.SSL30.name,
                    ProtocolVersion.TLS10.name,
                    ProtocolVersion.TLS11.name
                });
            }
<span class="nc" id="L711">        }</span>

        @Override
        SSLParameters getDefaultServerSSLParams() {
<span class="nc" id="L715">            return defaultServerSSLParams;</span>
        }

        @Override
        SSLParameters getDefaultClientSSLParams() {
<span class="nc" id="L720">            return defaultClientSSLParams;</span>
        }

        @Override
        SSLParameters getSupportedSSLParams() {
<span class="nc" id="L725">            return supportedSSLParams;</span>
        }
    }

    /*
     * The SSLContext implementation for TLS12 algorithm
     *
     * @see SSLContext
     */
<span class="nc" id="L734">    public static final class TLS12Context extends SSLContextImpl {</span>
        // parameters
        private static SSLParameters defaultServerSSLParams;
        private static SSLParameters defaultClientSSLParams;
        private static SSLParameters supportedSSLParams;

        static {
<span class="nc bnc" id="L741" title="All 2 branches missed.">            if (SunJSSE.isFIPS()) {</span>
<span class="nc" id="L742">                supportedSSLParams = new SSLParameters();</span>
<span class="nc" id="L743">                supportedSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.TLS10.name,
                    ProtocolVersion.TLS11.name,
                    ProtocolVersion.TLS12.name
                });

<span class="nc" id="L749">                defaultServerSSLParams = supportedSSLParams;</span>

<span class="nc" id="L751">                defaultClientSSLParams = new SSLParameters();</span>
<span class="nc" id="L752">                defaultClientSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.TLS10.name,
                    ProtocolVersion.TLS11.name,
                    ProtocolVersion.TLS12.name
                });

            } else {
<span class="nc" id="L759">                supportedSSLParams = new SSLParameters();</span>
<span class="nc" id="L760">                supportedSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.SSL20Hello.name,
                    ProtocolVersion.SSL30.name,
                    ProtocolVersion.TLS10.name,
                    ProtocolVersion.TLS11.name,
                    ProtocolVersion.TLS12.name
                });

<span class="nc" id="L768">                defaultServerSSLParams = supportedSSLParams;</span>

<span class="nc" id="L770">                defaultClientSSLParams = new SSLParameters();</span>
<span class="nc" id="L771">                defaultClientSSLParams.setProtocols(new String[] {</span>
                    ProtocolVersion.SSL30.name,
                    ProtocolVersion.TLS10.name,
                    ProtocolVersion.TLS11.name,
                    ProtocolVersion.TLS12.name
                });
            }
<span class="nc" id="L778">        }</span>

        @Override
        SSLParameters getDefaultServerSSLParams() {
<span class="nc" id="L782">            return defaultServerSSLParams;</span>
        }

        @Override
        SSLParameters getDefaultClientSSLParams() {
<span class="nc" id="L787">            return defaultClientSSLParams;</span>
        }

        @Override
        SSLParameters getSupportedSSLParams() {
<span class="nc" id="L792">            return supportedSSLParams;</span>
        }
    }

}


final class AbstractTrustManagerWrapper extends X509ExtendedTrustManager
            implements X509TrustManager {

    // the delegated trust manager
    private final X509TrustManager tm;

<span class="nc" id="L805">    AbstractTrustManagerWrapper(X509TrustManager tm) {</span>
<span class="nc" id="L806">        this.tm = tm;</span>
<span class="nc" id="L807">    }</span>

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
<span class="nc" id="L812">        tm.checkClientTrusted(chain, authType);</span>
<span class="nc" id="L813">    }</span>

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
<span class="nc" id="L818">        tm.checkServerTrusted(chain, authType);</span>
<span class="nc" id="L819">    }</span>

    @Override
    public X509Certificate[] getAcceptedIssuers() {
<span class="nc" id="L823">        return tm.getAcceptedIssuers();</span>
    }

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType,
                Socket socket) throws CertificateException {
<span class="nc" id="L829">        tm.checkClientTrusted(chain, authType);</span>
<span class="nc" id="L830">        checkAdditionalTrust(chain, authType, socket, true);</span>
<span class="nc" id="L831">    }</span>

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType,
            Socket socket) throws CertificateException {
<span class="nc" id="L836">        tm.checkServerTrusted(chain, authType);</span>
<span class="nc" id="L837">        checkAdditionalTrust(chain, authType, socket, false);</span>
<span class="nc" id="L838">    }</span>

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType,
            SSLEngine engine) throws CertificateException {
<span class="nc" id="L843">        tm.checkClientTrusted(chain, authType);</span>
<span class="nc" id="L844">        checkAdditionalTrust(chain, authType, engine, true);</span>
<span class="nc" id="L845">    }</span>

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType,
            SSLEngine engine) throws CertificateException {
<span class="nc" id="L850">        tm.checkServerTrusted(chain, authType);</span>
<span class="nc" id="L851">        checkAdditionalTrust(chain, authType, engine, false);</span>
<span class="nc" id="L852">    }</span>

    private void checkAdditionalTrust(X509Certificate[] chain, String authType,
                Socket socket, boolean isClient) throws CertificateException {
<span class="nc bnc" id="L856" title="All 6 branches missed.">        if (socket != null &amp;&amp; socket.isConnected() &amp;&amp;</span>
                                    socket instanceof SSLSocket) {

<span class="nc" id="L859">            SSLSocket sslSocket = (SSLSocket)socket;</span>
<span class="nc" id="L860">            SSLSession session = sslSocket.getHandshakeSession();</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">            if (session == null) {</span>
<span class="nc" id="L862">                throw new CertificateException(&quot;No handshake session&quot;);</span>
            }

            // check endpoint identity
<span class="nc" id="L866">            String identityAlg = sslSocket.getSSLParameters().</span>
<span class="nc" id="L867">                                        getEndpointIdentificationAlgorithm();</span>
<span class="nc bnc" id="L868" title="All 4 branches missed.">            if (identityAlg != null &amp;&amp; identityAlg.length() != 0) {</span>
<span class="nc" id="L869">                String hostname = session.getPeerHost();</span>
<span class="nc" id="L870">                X509TrustManagerImpl.checkIdentity(</span>
                                    hostname, chain[0], identityAlg);
            }

            // try the best to check the algorithm constraints
<span class="nc" id="L875">            ProtocolVersion protocolVersion =</span>
<span class="nc" id="L876">                ProtocolVersion.valueOf(session.getProtocol());</span>
<span class="nc" id="L877">            AlgorithmConstraints constraints = null;</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">            if (protocolVersion.v &gt;= ProtocolVersion.TLS12.v) {</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">                if (session instanceof ExtendedSSLSession) {</span>
<span class="nc" id="L880">                    ExtendedSSLSession extSession =</span>
                                    (ExtendedSSLSession)session;
<span class="nc" id="L882">                    String[] peerSupportedSignAlgs =</span>
<span class="nc" id="L883">                            extSession.getLocalSupportedSignatureAlgorithms();</span>

<span class="nc" id="L885">                    constraints = new SSLAlgorithmConstraints(</span>
                                    sslSocket, peerSupportedSignAlgs, true);
<span class="nc" id="L887">                } else {</span>
<span class="nc" id="L888">                    constraints =</span>
                            new SSLAlgorithmConstraints(sslSocket, true);
                }
            } else {
<span class="nc" id="L892">                constraints = new SSLAlgorithmConstraints(sslSocket, true);</span>
            }

<span class="nc" id="L895">            checkAlgorithmConstraints(chain, constraints);</span>
        }
<span class="nc" id="L897">    }</span>

    private void checkAdditionalTrust(X509Certificate[] chain, String authType,
            SSLEngine engine, boolean isClient) throws CertificateException {
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if (engine != null) {</span>
<span class="nc" id="L902">            SSLSession session = engine.getHandshakeSession();</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">            if (session == null) {</span>
<span class="nc" id="L904">                throw new CertificateException(&quot;No handshake session&quot;);</span>
            }

            // check endpoint identity
<span class="nc" id="L908">            String identityAlg = engine.getSSLParameters().</span>
<span class="nc" id="L909">                                        getEndpointIdentificationAlgorithm();</span>
<span class="nc bnc" id="L910" title="All 4 branches missed.">            if (identityAlg != null &amp;&amp; identityAlg.length() != 0) {</span>
<span class="nc" id="L911">                String hostname = session.getPeerHost();</span>
<span class="nc" id="L912">                X509TrustManagerImpl.checkIdentity(</span>
                                    hostname, chain[0], identityAlg);
            }

            // try the best to check the algorithm constraints
<span class="nc" id="L917">            ProtocolVersion protocolVersion =</span>
<span class="nc" id="L918">                ProtocolVersion.valueOf(session.getProtocol());</span>
<span class="nc" id="L919">            AlgorithmConstraints constraints = null;</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">            if (protocolVersion.v &gt;= ProtocolVersion.TLS12.v) {</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">                if (session instanceof ExtendedSSLSession) {</span>
<span class="nc" id="L922">                    ExtendedSSLSession extSession =</span>
                                    (ExtendedSSLSession)session;
<span class="nc" id="L924">                    String[] peerSupportedSignAlgs =</span>
<span class="nc" id="L925">                            extSession.getLocalSupportedSignatureAlgorithms();</span>

<span class="nc" id="L927">                    constraints = new SSLAlgorithmConstraints(</span>
                                    engine, peerSupportedSignAlgs, true);
<span class="nc" id="L929">                } else {</span>
<span class="nc" id="L930">                    constraints =</span>
                            new SSLAlgorithmConstraints(engine, true);
                }
            } else {
<span class="nc" id="L934">                constraints = new SSLAlgorithmConstraints(engine, true);</span>
            }

<span class="nc" id="L937">            checkAlgorithmConstraints(chain, constraints);</span>
        }
<span class="nc" id="L939">    }</span>

    private void checkAlgorithmConstraints(X509Certificate[] chain,
            AlgorithmConstraints constraints) throws CertificateException {

        try {
            // Does the certificate chain end with a trusted certificate?
<span class="nc" id="L946">            int checkedLength = chain.length - 1;</span>

<span class="nc" id="L948">            Collection&lt;X509Certificate&gt; trustedCerts = new HashSet&lt;&gt;();</span>
<span class="nc" id="L949">            X509Certificate[] certs = tm.getAcceptedIssuers();</span>
<span class="nc bnc" id="L950" title="All 4 branches missed.">            if ((certs != null) &amp;&amp; (certs.length &gt; 0)){</span>
<span class="nc" id="L951">                Collections.addAll(trustedCerts, certs);</span>
            }

<span class="nc bnc" id="L954" title="All 2 branches missed.">            if (trustedCerts.contains(chain[checkedLength])) {</span>
<span class="nc" id="L955">                    checkedLength--;</span>
            }

            // A forward checker, need to check from trust to target
<span class="nc bnc" id="L959" title="All 2 branches missed.">            if (checkedLength &gt;= 0) {</span>
<span class="nc" id="L960">                AlgorithmChecker checker = new AlgorithmChecker(constraints);</span>
<span class="nc" id="L961">                checker.init(false);</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                for (int i = checkedLength; i &gt;= 0; i--) {</span>
<span class="nc" id="L963">                    Certificate cert = chain[i];</span>
                    // We don't care about the unresolved critical extensions.
<span class="nc" id="L965">                    checker.check(cert, Collections.&lt;String&gt;emptySet());</span>
                }
            }
<span class="nc" id="L968">        } catch (CertPathValidatorException cpve) {</span>
<span class="nc" id="L969">            throw new CertificateException(</span>
                &quot;Certificates does not conform to algorithm constraints&quot;);
<span class="nc" id="L971">        }</span>
<span class="nc" id="L972">    }</span>
}

// Dummy X509TrustManager implementation, rejects all peer certificates.
// Used if the application did not specify a proper X509TrustManager.
final class DummyX509TrustManager extends X509ExtendedTrustManager
            implements X509TrustManager {

<span class="nc" id="L980">    static final X509TrustManager INSTANCE = new DummyX509TrustManager();</span>

<span class="nc" id="L982">    private DummyX509TrustManager() {</span>
        // empty
<span class="nc" id="L984">    }</span>

    /*
     * Given the partial or complete certificate chain
     * provided by the peer, build a certificate path
     * to a trusted root and return if it can be
     * validated and is trusted for client SSL authentication.
     * If not, it throws an exception.
     */
    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
<span class="nc" id="L996">        throw new CertificateException(</span>
            &quot;No X509TrustManager implementation avaiable&quot;);
    }

    /*
     * Given the partial or complete certificate chain
     * provided by the peer, build a certificate path
     * to a trusted root and return if it can be
     * validated and is trusted for server SSL authentication.
     * If not, it throws an exception.
     */
    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
<span class="nc" id="L1010">        throw new CertificateException(</span>
            &quot;No X509TrustManager implementation available&quot;);
    }

    /*
     * Return an array of issuer certificates which are trusted
     * for authenticating peers.
     */
    @Override
    public X509Certificate[] getAcceptedIssuers() {
<span class="nc" id="L1020">        return new X509Certificate[0];</span>
    }

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType,
                Socket socket) throws CertificateException {
<span class="nc" id="L1026">        throw new CertificateException(</span>
            &quot;No X509TrustManager implementation available&quot;);
    }

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType,
            Socket socket) throws CertificateException {
<span class="nc" id="L1033">        throw new CertificateException(</span>
            &quot;No X509TrustManager implementation available&quot;);
    }

    @Override
    public void checkClientTrusted(X509Certificate[] chain, String authType,
            SSLEngine engine) throws CertificateException {
<span class="nc" id="L1040">        throw new CertificateException(</span>
            &quot;No X509TrustManager implementation available&quot;);
    }

    @Override
    public void checkServerTrusted(X509Certificate[] chain, String authType,
            SSLEngine engine) throws CertificateException {
<span class="nc" id="L1047">        throw new CertificateException(</span>
            &quot;No X509TrustManager implementation available&quot;);
    }
}

/*
 * A wrapper class to turn a X509KeyManager into an X509ExtendedKeyManager
 */
final class AbstractKeyManagerWrapper extends X509ExtendedKeyManager {

    private final X509KeyManager km;

<span class="nc" id="L1059">    AbstractKeyManagerWrapper(X509KeyManager km) {</span>
<span class="nc" id="L1060">        this.km = km;</span>
<span class="nc" id="L1061">    }</span>

    @Override
    public String[] getClientAliases(String keyType, Principal[] issuers) {
<span class="nc" id="L1065">        return km.getClientAliases(keyType, issuers);</span>
    }

    @Override
    public String chooseClientAlias(String[] keyType, Principal[] issuers,
            Socket socket) {
<span class="nc" id="L1071">        return km.chooseClientAlias(keyType, issuers, socket);</span>
    }

    @Override
    public String[] getServerAliases(String keyType, Principal[] issuers) {
<span class="nc" id="L1076">        return km.getServerAliases(keyType, issuers);</span>
    }

    @Override
    public String chooseServerAlias(String keyType, Principal[] issuers,
            Socket socket) {
<span class="nc" id="L1082">        return km.chooseServerAlias(keyType, issuers, socket);</span>
    }

    @Override
    public X509Certificate[] getCertificateChain(String alias) {
<span class="nc" id="L1087">        return km.getCertificateChain(alias);</span>
    }

    @Override
    public PrivateKey getPrivateKey(String alias) {
<span class="nc" id="L1092">        return km.getPrivateKey(alias);</span>
    }

    // Inherit chooseEngineClientAlias() and chooseEngineServerAlias() from
    // X509ExtendedKeymanager. It defines them to return null;
}


// Dummy X509KeyManager implementation, never returns any certificates/keys.
// Used if the application did not specify a proper X509TrustManager.
final class DummyX509KeyManager extends X509ExtendedKeyManager {

<span class="nc" id="L1104">    static final X509ExtendedKeyManager INSTANCE = new DummyX509KeyManager();</span>

<span class="nc" id="L1106">    private DummyX509KeyManager() {</span>
        // empty
<span class="nc" id="L1108">    }</span>

    /*
     * Get the matching aliases for authenticating the client side of a secure
     * socket given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     */
    @Override
    public String[] getClientAliases(String keyType, Principal[] issuers) {
<span class="nc" id="L1117">        return null;</span>
    }

    /*
     * Choose an alias to authenticate the client side of a secure
     * socket given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     */
    @Override
    public String chooseClientAlias(String[] keyTypes, Principal[] issuers,
            Socket socket) {
<span class="nc" id="L1128">        return null;</span>
    }

    /*
     * Choose an alias to authenticate the client side of an
     * engine given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     */
    @Override
    public String chooseEngineClientAlias(
            String[] keyTypes, Principal[] issuers, SSLEngine engine) {
<span class="nc" id="L1139">        return null;</span>
    }

    /*
     * Get the matching aliases for authenticating the server side of a secure
     * socket given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     */
    @Override
    public String[] getServerAliases(String keyType, Principal[] issuers) {
<span class="nc" id="L1149">        return null;</span>
    }

    /*
     * Choose an alias to authenticate the server side of a secure
     * socket given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     */
    @Override
    public String chooseServerAlias(String keyType, Principal[] issuers,
            Socket socket) {
<span class="nc" id="L1160">        return null;</span>
    }

    /*
     * Choose an alias to authenticate the server side of an engine
     * given the public key type and the list of
     * certificate issuer authorities recognized by the peer (if any).
     */
    @Override
    public String chooseEngineServerAlias(
            String keyType, Principal[] issuers, SSLEngine engine) {
<span class="nc" id="L1171">        return null;</span>
    }

    /**
     * Returns the certificate chain associated with the given alias.
     *
     * @param alias the alias name
     *
     * @return the certificate chain (ordered with the user's certificate first
     * and the root certificate authority last)
     */
    @Override
    public X509Certificate[] getCertificateChain(String alias) {
<span class="nc" id="L1184">        return null;</span>
    }

    /*
     * Returns the key associated with the given alias, using the given
     * password to recover it.
     *
     * @param alias the alias name
     *
     * @return the requested key
     */
    @Override
    public PrivateKey getPrivateKey(String alias) {
<span class="nc" id="L1197">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>