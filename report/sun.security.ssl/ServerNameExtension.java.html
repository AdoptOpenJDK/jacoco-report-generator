<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ServerNameExtension.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">ServerNameExtension.java</span></div><h1>ServerNameExtension.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.ssl;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.LinkedHashMap;
import java.util.Map;

import javax.net.ssl.SNIHostName;
import javax.net.ssl.SNIMatcher;
import javax.net.ssl.SNIServerName;
import javax.net.ssl.SSLProtocolException;
import javax.net.ssl.StandardConstants;

/*
 * [RFC 4366/6066] To facilitate secure connections to servers that host
 * multiple 'virtual' servers at a single underlying network address, clients
 * MAY include an extension of type &quot;server_name&quot; in the (extended) client
 * hello.  The &quot;extension_data&quot; field of this extension SHALL contain
 * &quot;ServerNameList&quot; where:
 *
 *     struct {
 *         NameType name_type;
 *         select (name_type) {
 *             case host_name: HostName;
 *         } name;
 *     } ServerName;
 *
 *     enum {
 *         host_name(0), (255)
 *     } NameType;
 *
 *     opaque HostName&lt;1..2^16-1&gt;;
 *
 *     struct {
 *         ServerName server_name_list&lt;1..2^16-1&gt;
 *     } ServerNameList;
 */
final class ServerNameExtension extends HelloExtension {

    // For backward compatibility, all future data structures associated with
    // new NameTypes MUST begin with a 16-bit length field.
    final static int NAME_HEADER_LENGTH = 3;    // NameType: 1 byte
                                                // Name length: 2 bytes
    private Map&lt;Integer, SNIServerName&gt; sniMap;
    private int listLength;     // ServerNameList length

    // constructor for ServerHello
    ServerNameExtension() throws IOException {
<span class="nc" id="L78">        super(ExtensionType.EXT_SERVER_NAME);</span>

<span class="nc" id="L80">        listLength = 0;</span>
<span class="nc" id="L81">        sniMap = Collections.&lt;Integer, SNIServerName&gt;emptyMap();</span>
<span class="nc" id="L82">    }</span>

    // constructor for ClientHello
    ServerNameExtension(List&lt;SNIServerName&gt; serverNames)
            throws IOException {
<span class="nc" id="L87">        super(ExtensionType.EXT_SERVER_NAME);</span>

<span class="nc" id="L89">        listLength = 0;</span>
<span class="nc" id="L90">        sniMap = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">        for (SNIServerName serverName : serverNames) {</span>
            // check for duplicated server name type
<span class="nc bnc" id="L93" title="All 2 branches missed.">            if (sniMap.put(serverName.getType(), serverName) != null) {</span>
                // unlikely to happen, but in case ...
<span class="nc" id="L95">                throw new RuntimeException(</span>
<span class="nc" id="L96">                    &quot;Duplicated server name of type &quot; + serverName.getType());</span>
            }

<span class="nc" id="L99">            listLength += serverName.getEncoded().length + NAME_HEADER_LENGTH;</span>
<span class="nc" id="L100">        }</span>

        // This constructor is used for ClientHello only.  Empty list is
        // not allowed in client mode.
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (listLength == 0) {</span>
<span class="nc" id="L105">            throw new RuntimeException(&quot;The ServerNameList cannot be empty&quot;);</span>
        }
<span class="nc" id="L107">    }</span>

    // constructor for ServerHello for parsing SNI extension
    ServerNameExtension(HandshakeInStream s, int len)
            throws IOException {
<span class="nc" id="L112">        super(ExtensionType.EXT_SERVER_NAME);</span>

<span class="nc" id="L114">        int remains = len;</span>
<span class="nc bnc" id="L115" title="All 2 branches missed.">        if (len &gt;= 2) {    // &quot;server_name&quot; extension in ClientHello</span>
<span class="nc" id="L116">            listLength = s.getInt16();     // ServerNameList length</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">            if (listLength == 0 || listLength + 2 != len) {</span>
<span class="nc" id="L118">                throw new SSLProtocolException(</span>
                        &quot;Invalid &quot; + type + &quot; extension&quot;);
            }

<span class="nc" id="L122">            remains -= 2;</span>
<span class="nc" id="L123">            sniMap = new LinkedHashMap&lt;&gt;();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">            while (remains &gt; 0) {</span>
<span class="nc" id="L125">                int code = s.getInt8();       // NameType</span>

                // HostName (length read in getBytes16);
<span class="nc" id="L128">                byte[] encoded = s.getBytes16();</span>
                SNIServerName serverName;
<span class="nc bnc" id="L130" title="All 2 branches missed.">                switch (code) {</span>
                    case StandardConstants.SNI_HOST_NAME:
<span class="nc bnc" id="L132" title="All 2 branches missed.">                        if (encoded.length == 0) {</span>
<span class="nc" id="L133">                            throw new SSLProtocolException(</span>
                                &quot;Empty HostName in server name indication&quot;);
                        }
                        try {
<span class="nc" id="L137">                            serverName = new SNIHostName(encoded);</span>
<span class="nc" id="L138">                        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L139">                            SSLProtocolException spe = new SSLProtocolException(</span>
                                &quot;Illegal server name, type=host_name(&quot; +
                                code + &quot;), name=&quot; +
                                (new String(encoded, StandardCharsets.UTF_8)) +
<span class="nc" id="L143">                                &quot;, value=&quot; + Debug.toString(encoded));</span>
<span class="nc" id="L144">                            spe.initCause(iae);</span>
<span class="nc" id="L145">                            throw spe;</span>
<span class="nc" id="L146">                        }</span>
                        break;
                    default:
                        try {
<span class="nc" id="L150">                            serverName = new UnknownServerName(code, encoded);</span>
<span class="nc" id="L151">                        } catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L152">                            SSLProtocolException spe = new SSLProtocolException(</span>
                                &quot;Illegal server name, type=(&quot; + code +
<span class="nc" id="L154">                                &quot;), value=&quot; + Debug.toString(encoded));</span>
<span class="nc" id="L155">                            spe.initCause(iae);</span>
<span class="nc" id="L156">                            throw spe;</span>
<span class="nc" id="L157">                        }</span>
                }
                // check for duplicated server name type
<span class="nc bnc" id="L160" title="All 2 branches missed.">                if (sniMap.put(serverName.getType(), serverName) != null) {</span>
<span class="nc" id="L161">                    throw new SSLProtocolException(</span>
                            &quot;Duplicated server name of type &quot; +
<span class="nc" id="L163">                            serverName.getType());</span>
                }

<span class="nc" id="L166">                remains -= encoded.length + NAME_HEADER_LENGTH;</span>
<span class="nc" id="L167">            }</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">        } else if (len == 0) {     // &quot;server_name&quot; extension in ServerHello</span>
<span class="nc" id="L169">            listLength = 0;</span>
<span class="nc" id="L170">            sniMap = Collections.&lt;Integer, SNIServerName&gt;emptyMap();</span>
        }

<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (remains != 0) {</span>
<span class="nc" id="L174">            throw new SSLProtocolException(&quot;Invalid server_name extension&quot;);</span>
        }
<span class="nc" id="L176">    }</span>

    List&lt;SNIServerName&gt; getServerNames() {
<span class="nc bnc" id="L179" title="All 4 branches missed.">        if (sniMap != null &amp;&amp; !sniMap.isEmpty()) {</span>
<span class="nc" id="L180">            return Collections.&lt;SNIServerName&gt;unmodifiableList(</span>
<span class="nc" id="L181">                                        new ArrayList&lt;&gt;(sniMap.values()));</span>
        }

<span class="nc" id="L184">        return Collections.&lt;SNIServerName&gt;emptyList();</span>
    }

    /*
     * Is the extension recognized by the corresponding matcher?
     *
     * This method is used to check whether the server name indication can
     * be recognized by the server name matchers.
     *
     * Per RFC 6066, if the server understood the ClientHello extension but
     * does not recognize the server name, the server SHOULD take one of two
     * actions: either abort the handshake by sending a fatal-level
     * unrecognized_name(112) alert or continue the handshake.
     *
     * If there is an instance of SNIMatcher defined for a particular name
     * type, it must be used to perform match operations on the server name.
     */
    boolean isMatched(Collection&lt;SNIMatcher&gt; matchers) {
<span class="nc bnc" id="L202" title="All 4 branches missed.">        if (sniMap != null &amp;&amp; !sniMap.isEmpty()) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">            for (SNIMatcher matcher : matchers) {</span>
<span class="nc" id="L204">                SNIServerName sniName = sniMap.get(matcher.getType());</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">                if (sniName != null &amp;&amp; (!matcher.matches(sniName))) {</span>
<span class="nc" id="L206">                    return false;</span>
                }
<span class="nc" id="L208">            }</span>
        }

<span class="nc" id="L211">        return true;</span>
    }

    /*
     * Is the extension is identical to a server name list?
     *
     * This method is used to check the server name indication during session
     * resumption.
     *
     * Per RFC 6066, when the server is deciding whether or not to accept a
     * request to resume a session, the contents of a server_name extension
     * MAY be used in the lookup of the session in the session cache.  The
     * client SHOULD include the same server_name extension in the session
     * resumption request as it did in the full handshake that established
     * the session.  A server that implements this extension MUST NOT accept
     * the request to resume the session if the server_name extension contains
     * a different name.  Instead, it proceeds with a full handshake to
     * establish a new session.  When resuming a session, the server MUST NOT
     * include a server_name extension in the server hello.
     */
    boolean isIdentical(List&lt;SNIServerName&gt; other) {
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (other.size() == sniMap.size()) {</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            for(SNIServerName sniInOther : other) {</span>
<span class="nc" id="L234">                SNIServerName sniName = sniMap.get(sniInOther.getType());</span>
<span class="nc bnc" id="L235" title="All 4 branches missed.">                if (sniName == null || !sniInOther.equals(sniName)) {</span>
<span class="nc" id="L236">                    return false;</span>
                }
<span class="nc" id="L238">            }</span>

<span class="nc" id="L240">            return true;</span>
        }

<span class="nc" id="L243">        return false;</span>
    }

    @Override
    int length() {
<span class="nc bnc" id="L248" title="All 2 branches missed.">        return listLength == 0 ? 4 : 6 + listLength;</span>
    }

    @Override
    void send(HandshakeOutStream s) throws IOException {
<span class="nc" id="L253">        s.putInt16(type.id);</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">        if (listLength == 0) {</span>
<span class="nc" id="L255">            s.putInt16(listLength);     // in ServerHello, empty extension_data</span>
        } else {
<span class="nc" id="L257">            s.putInt16(listLength + 2); // length of extension_data</span>
<span class="nc" id="L258">            s.putInt16(listLength);     // length of ServerNameList</span>

<span class="nc bnc" id="L260" title="All 2 branches missed.">            for (SNIServerName sniName : sniMap.values()) {</span>
<span class="nc" id="L261">                s.putInt8(sniName.getType());         // server name type</span>
<span class="nc" id="L262">                s.putBytes16(sniName.getEncoded());   // server name value</span>
<span class="nc" id="L263">            }</span>
        }
<span class="nc" id="L265">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L269">        StringBuffer buffer = new StringBuffer();</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">        for (SNIServerName sniName : sniMap.values()) {</span>
<span class="nc" id="L271">            buffer.append(&quot;[&quot; + sniName + &quot;]&quot;);</span>
<span class="nc" id="L272">        }</span>

<span class="nc" id="L274">        return &quot;Extension &quot; + type + &quot;, server_name: &quot; + buffer;</span>
    }

    private static class UnknownServerName extends SNIServerName {
        UnknownServerName(int code, byte[] encoded) {
<span class="nc" id="L279">            super(code, encoded);</span>
<span class="nc" id="L280">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>