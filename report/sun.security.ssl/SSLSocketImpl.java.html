<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SSLSocketImpl.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">SSLSocketImpl.java</span></div><h1>SSLSocketImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package sun.security.ssl;

import java.io.*;
import java.net.*;
import java.security.GeneralSecurityException;
import java.security.AccessController;
import java.security.AccessControlContext;
import java.security.PrivilegedAction;
import java.security.AlgorithmConstraints;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

import javax.crypto.BadPaddingException;
import javax.net.ssl.*;

/**
 * Implementation of an SSL socket.  This is a normal connection type
 * socket, implementing SSL over some lower level socket, such as TCP.
 * Because it is layered over some lower level socket, it MUST override
 * all default socket methods.
 *
 * &lt;P&gt; This API offers a non-traditional option for establishing SSL
 * connections.  You may first establish the connection directly, then pass
 * that connection to the SSL socket constructor with a flag saying which
 * role should be taken in the handshake protocol.  (The two ends of the
 * connection must not choose the same role!)  This allows setup of SSL
 * proxying or tunneling, and also allows the kind of &quot;role reversal&quot;
 * that is required for most FTP data transfers.
 *
 * @see javax.net.ssl.SSLSocket
 * @see SSLServerSocket
 *
 * @author David Brownell
 */
<span class="nc bnc" id="L62" title="All 2 branches missed.">final public class SSLSocketImpl extends BaseSSLSocketImpl {</span>

    /*
     * ERROR HANDLING GUIDELINES
     * (which exceptions to throw and catch and which not to throw and catch)
     *
     * . if there is an IOException (SocketException) when accessing the
     *   underlying Socket, pass it through
     *
     * . do not throw IOExceptions, throw SSLExceptions (or a subclass)
     *
     * . for internal errors (things that indicate a bug in JSSE or a
     *   grossly misconfigured J2RE), throw either an SSLException or
     *   a RuntimeException at your convenience.
     *
     * . handshaking code (Handshaker or HandshakeMessage) should generally
     *   pass through exceptions, but can handle them if they know what to
     *   do.
     *
     * . exception chaining should be used for all new code. If you happen
     *   to touch old code that does not use chaining, you should change it.
     *
     * . there is a top level exception handler that sits at all entry
     *   points from application code to SSLSocket read/write code. It
     *   makes sure that all errors are handled (see handleException()).
     *
     * . JSSE internal code should generally not call close(), call
     *   closeInternal().
     */

    /*
     * There's a state machine associated with each connection, which
     * among other roles serves to negotiate session changes.
     *
     * - START with constructor, until the TCP connection's around.
     * - HANDSHAKE picks session parameters before allowing traffic.
     *          There are many substates due to sequencing requirements
     *          for handshake messages.
     * - DATA may be transmitted.
     * - RENEGOTIATE state allows concurrent data and handshaking
     *          traffic (&quot;same&quot; substates as HANDSHAKE), and terminates
     *          in selection of new session (and connection) parameters
     * - ERROR state immediately precedes abortive disconnect.
     * - SENT_CLOSE sent a close_notify to the peer. For layered,
     *          non-autoclose socket, must now read close_notify
     *          from peer before closing the connection. For nonlayered or
     *          non-autoclose socket, close connection and go onto
     *          cs_CLOSED state.
     * - CLOSED after sending close_notify alert, &amp; socket is closed.
     *          SSL connection objects are not reused.
     * - APP_CLOSED once the application calls close(). Then it behaves like
     *          a closed socket, e.g.. getInputStream() throws an Exception.
     *
     * State affects what SSL record types may legally be sent:
     *
     * - Handshake ... only in HANDSHAKE and RENEGOTIATE states
     * - App Data ... only in DATA and RENEGOTIATE states
     * - Alert ... in HANDSHAKE, DATA, RENEGOTIATE
     *
     * Re what may be received:  same as what may be sent, except that
     * HandshakeRequest handshaking messages can come from servers even
     * in the application data state, to request entry to RENEGOTIATE.
     *
     * The state machine within HANDSHAKE and RENEGOTIATE states controls
     * the pending session, not the connection state, until the change
     * cipher spec and &quot;Finished&quot; handshake messages are processed and
     * make the &quot;new&quot; session become the current one.
     *
     * NOTE: details of the SMs always need to be nailed down better.
     * The text above illustrates the core ideas.
     *
     *                +----&gt;-------+------&gt;---------&gt;-------+
     *                |            |                        |
     *     &lt;-----&lt;    ^            ^  &lt;-----&lt;               v
     *START&gt;-----&gt;HANDSHAKE&gt;-----&gt;DATA&gt;-----&gt;RENEGOTIATE  SENT_CLOSE
     *                v            v               v        |   |
     *                |            |               |        |   v
     *                +------------+---------------+        v ERROR
     *                |                                     |   |
     *                v                                     |   |
     *               ERROR&gt;------&gt;-----&gt;CLOSED&lt;--------&lt;----+-- +
     *                                     |
     *                                     v
     *                                 APP_CLOSED
     *
     * ALSO, note that the the purpose of handshaking (renegotiation is
     * included) is to assign a different, and perhaps new, session to
     * the connection.  The SSLv3 spec is a bit confusing on that new
     * protocol feature.
     */
    private static final int    cs_START = 0;
    private static final int    cs_HANDSHAKE = 1;
    private static final int    cs_DATA = 2;
    private static final int    cs_RENEGOTIATE = 3;
    private static final int    cs_ERROR = 4;
    private static final int   cs_SENT_CLOSE = 5;
    private static final int    cs_CLOSED = 6;
    private static final int    cs_APP_CLOSED = 7;


    /*
     * Client authentication be off, requested, or required.
     *
     * Migrated to SSLEngineImpl:
     *    clauth_none/cl_auth_requested/clauth_required
     */

    /*
     * Drives the protocol state machine.
     */
    private volatile int        connectionState;

    /*
     * Flag indicating if the next record we receive MUST be a Finished
     * message. Temporarily set during the handshake to ensure that
     * a change cipher spec message is followed by a finished message.
     */
    private boolean             expectingFinished;

    /*
     * For improved diagnostics, we detail connection closure
     * If the socket is closed (connectionState &gt;= cs_ERROR),
     * closeReason != null indicates if the socket was closed
     * because of an error or because or normal shutdown.
     */
    private SSLException        closeReason;

    /*
     * Per-connection private state that doesn't change when the
     * session is changed.
     */
    private byte                doClientAuth;
    private boolean             roleIsServer;
<span class="nc" id="L195">    private boolean             enableSessionCreation = true;</span>
    private String              host;
<span class="nc" id="L197">    private boolean             autoClose = true;</span>
    private AccessControlContext acc;

    // The cipher suites enabled for use on this connection.
    private CipherSuiteList     enabledCipherSuites;

    // The endpoint identification protocol
<span class="nc" id="L204">    private String              identificationProtocol = null;</span>

    // The cryptographic algorithm constraints
<span class="nc" id="L207">    private AlgorithmConstraints    algorithmConstraints = null;</span>

    // The server name indication and matchers
<span class="nc" id="L210">    List&lt;SNIServerName&gt;         serverNames =</span>
<span class="nc" id="L211">                                    Collections.&lt;SNIServerName&gt;emptyList();</span>
<span class="nc" id="L212">    Collection&lt;SNIMatcher&gt;      sniMatchers =</span>
<span class="nc" id="L213">                                    Collections.&lt;SNIMatcher&gt;emptyList();</span>

    /*
     * READ ME * READ ME * READ ME * READ ME * READ ME * READ ME *
     * IMPORTANT STUFF TO UNDERSTANDING THE SYNCHRONIZATION ISSUES.
     * READ ME * READ ME * READ ME * READ ME * READ ME * READ ME *
     *
     * There are several locks here.
     *
     * The primary lock is the per-instance lock used by
     * synchronized(this) and the synchronized methods.  It controls all
     * access to things such as the connection state and variables which
     * affect handshaking.  If we are inside a synchronized method, we
     * can access the state directly, otherwise, we must use the
     * synchronized equivalents.
     *
     * The handshakeLock is used to ensure that only one thread performs
     * the *complete initial* handshake.  If someone is handshaking, any
     * stray application or startHandshake() requests who find the
     * connection state is cs_HANDSHAKE will stall on handshakeLock
     * until handshaking is done.  Once the handshake is done, we either
     * succeeded or failed, but we can never go back to the cs_HANDSHAKE
     * or cs_START state again.
     *
     * Note that the read/write() calls here in SSLSocketImpl are not
     * obviously synchronized.  In fact, it's very nonintuitive, and
     * requires careful examination of code paths.  Grab some coffee,
     * and be careful with any code changes.
     *
     * There can be only three threads active at a time in the I/O
     * subsection of this class.
     *    1.  startHandshake
     *    2.  AppInputStream
     *    3.  AppOutputStream
     * One thread could call startHandshake().
     * AppInputStream/AppOutputStream read() and write() calls are each
     * synchronized on 'this' in their respective classes, so only one
     * app. thread will be doing a SSLSocketImpl.read() or .write()'s at
     * a time.
     *
     * If handshaking is required (state cs_HANDSHAKE), and
     * getConnectionState() for some/all threads returns cs_HANDSHAKE,
     * only one can grab the handshakeLock, and the rest will stall
     * either on getConnectionState(), or on the handshakeLock if they
     * happen to successfully race through the getConnectionState().
     *
     * If a writer is doing the initial handshaking, it must create a
     * temporary reader to read the responses from the other side.  As a
     * side-effect, the writer's reader will have priority over any
     * other reader.  However, the writer's reader is not allowed to
     * consume any application data.  When handshakeLock is finally
     * released, we either have a cs_DATA connection, or a
     * cs_CLOSED/cs_ERROR socket.
     *
     * The writeLock is held while writing on a socket connection and
     * also to protect the MAC and cipher for their direction.  The
     * writeLock is package private for Handshaker which holds it while
     * writing the ChangeCipherSpec message.
     *
     * To avoid the problem of a thread trying to change operational
     * modes on a socket while handshaking is going on, we synchronize
     * on 'this'.  If handshaking has not started yet, we tell the
     * handshaker to change its mode.  If handshaking has started,
     * we simply store that request until the next pending session
     * is created, at which time the new handshaker's state is set.
     *
     * The readLock is held during readRecord(), which is responsible
     * for reading an InputRecord, decrypting it, and processing it.
     * The readLock ensures that these three steps are done atomically
     * and that once started, no other thread can block on InputRecord.read.
     * This is necessary so that processing of close_notify alerts
     * from the peer are handled properly.
     */
<span class="nc" id="L286">    final private Object        handshakeLock = new Object();</span>
<span class="nc" id="L287">    final ReentrantLock         writeLock = new ReentrantLock();</span>
<span class="nc" id="L288">    final private Object        readLock = new Object();</span>

    private InputRecord         inrec;

    /*
     * Crypto state that's reinitialized when the session changes.
     */
    private Authenticator       readAuthenticator, writeAuthenticator;
    private CipherBox           readCipher, writeCipher;
    // NOTE: compression state would be saved here

    /*
     * security parameters for secure renegotiation.
     */
    private boolean             secureRenegotiation;
    private byte[]              clientVerifyData;
    private byte[]              serverVerifyData;

    /*
     * The authentication context holds all information used to establish
     * who this end of the connection is (certificate chains, private keys,
     * etc) and who is trusted (e.g. as CAs or websites).
     */
    private SSLContextImpl      sslContext;


    /*
     * This connection is one of (potentially) many associated with
     * any given session.  The output of the handshake protocol is a
     * new session ... although all the protocol description talks
     * about changing the cipher spec (and it does change), in fact
     * that's incidental since it's done by changing everything that
     * is associated with a session at the same time.  (TLS/IETF may
     * change that to add client authentication w/o new key exchg.)
     */
    private Handshaker                  handshaker;
    private SSLSessionImpl              sess;
    private volatile SSLSessionImpl     handshakeSession;


    /*
     * If anyone wants to get notified about handshake completions,
     * they'll show up on this list.
     */
    private HashMap&lt;HandshakeCompletedListener, AccessControlContext&gt;
                                                        handshakeListeners;

    /*
     * Reuse the same internal input/output streams.
     */
    private InputStream         sockInput;
    private OutputStream        sockOutput;


    /*
     * These input and output streams block their data in SSL records,
     * and usually arrange integrity and privacy protection for those
     * records.  The guts of the SSL protocol are wrapped up in these
     * streams, and in the handshaking that establishes the details of
     * that integrity and privacy protection.
     */
    private AppInputStream      input;
    private AppOutputStream     output;

    /*
     * The protocol versions enabled for use on this connection.
     *
     * Note: we support a pseudo protocol called SSLv2Hello which when
     * set will result in an SSL v2 Hello being sent with SSL (version 3.0)
     * or TLS (version 3.1, 3.2, etc.) version info.
     */
    private ProtocolList enabledProtocols;

    /*
     * The SSL version associated with this connection.
     */
<span class="nc" id="L364">    private ProtocolVersion     protocolVersion = ProtocolVersion.DEFAULT;</span>

    /* Class and subclass dynamic debugging support */
<span class="nc" id="L367">    private static final Debug debug = Debug.getInstance(&quot;ssl&quot;);</span>

    /*
     * Is it the first application record to write?
     */
<span class="nc" id="L372">    private boolean isFirstAppOutputRecord = true;</span>

    /*
     * If AppOutputStream needs to delay writes of small packets, we
     * will use this to store the data until we actually do the write.
     */
<span class="nc" id="L378">    private ByteArrayOutputStream heldRecordBuffer = null;</span>

    /*
     * Whether local cipher suites preference in server side should be
     * honored during handshaking?
     */
<span class="nc" id="L384">    private boolean preferLocalCipherSuites = false;</span>

    //
    // CONSTRUCTORS AND INITIALIZATION CODE
    //

    /**
     * Constructs an SSL connection to a named host at a specified port,
     * using the authentication context provided.  This endpoint acts as
     * the client, and may rejoin an existing SSL session if appropriate.
     *
     * @param context authentication context to use
     * @param host name of the host with which to connect
     * @param port number of the server's port
     */
    SSLSocketImpl(SSLContextImpl context, String host, int port)
            throws IOException, UnknownHostException {
<span class="nc" id="L401">        super();</span>
<span class="nc" id="L402">        this.host = host;</span>
<span class="nc" id="L403">        this.serverNames =</span>
<span class="nc" id="L404">            Utilities.addToSNIServerNameList(this.serverNames, this.host);</span>
<span class="nc" id="L405">        init(context, false);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        SocketAddress socketAddress =</span>
               host != null ? new InetSocketAddress(host, port) :
<span class="nc" id="L408">               new InetSocketAddress(InetAddress.getByName(null), port);</span>
<span class="nc" id="L409">        connect(socketAddress, 0);</span>
<span class="nc" id="L410">    }</span>


    /**
     * Constructs an SSL connection to a server at a specified address.
     * and TCP port, using the authentication context provided.  This
     * endpoint acts as the client, and may rejoin an existing SSL session
     * if appropriate.
     *
     * @param context authentication context to use
     * @param address the server's host
     * @param port its port
     */
    SSLSocketImpl(SSLContextImpl context, InetAddress host, int port)
            throws IOException {
<span class="nc" id="L425">        super();</span>
<span class="nc" id="L426">        init(context, false);</span>
<span class="nc" id="L427">        SocketAddress socketAddress = new InetSocketAddress(host, port);</span>
<span class="nc" id="L428">        connect(socketAddress, 0);</span>
<span class="nc" id="L429">    }</span>

    /**
     * Constructs an SSL connection to a named host at a specified port,
     * using the authentication context provided.  This endpoint acts as
     * the client, and may rejoin an existing SSL session if appropriate.
     *
     * @param context authentication context to use
     * @param host name of the host with which to connect
     * @param port number of the server's port
     * @param localAddr the local address the socket is bound to
     * @param localPort the local port the socket is bound to
     */
    SSLSocketImpl(SSLContextImpl context, String host, int port,
            InetAddress localAddr, int localPort)
            throws IOException, UnknownHostException {
<span class="nc" id="L445">        super();</span>
<span class="nc" id="L446">        this.host = host;</span>
<span class="nc" id="L447">        this.serverNames =</span>
<span class="nc" id="L448">            Utilities.addToSNIServerNameList(this.serverNames, this.host);</span>
<span class="nc" id="L449">        init(context, false);</span>
<span class="nc" id="L450">        bind(new InetSocketAddress(localAddr, localPort));</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">        SocketAddress socketAddress =</span>
               host != null ? new InetSocketAddress(host, port) :
<span class="nc" id="L453">               new InetSocketAddress(InetAddress.getByName(null), port);</span>
<span class="nc" id="L454">        connect(socketAddress, 0);</span>
<span class="nc" id="L455">    }</span>


    /**
     * Constructs an SSL connection to a server at a specified address.
     * and TCP port, using the authentication context provided.  This
     * endpoint acts as the client, and may rejoin an existing SSL session
     * if appropriate.
     *
     * @param context authentication context to use
     * @param address the server's host
     * @param port its port
     * @param localAddr the local address the socket is bound to
     * @param localPort the local port the socket is bound to
     */
    SSLSocketImpl(SSLContextImpl context, InetAddress host, int port,
            InetAddress localAddr, int localPort)
            throws IOException {
<span class="nc" id="L473">        super();</span>
<span class="nc" id="L474">        init(context, false);</span>
<span class="nc" id="L475">        bind(new InetSocketAddress(localAddr, localPort));</span>
<span class="nc" id="L476">        SocketAddress socketAddress = new InetSocketAddress(host, port);</span>
<span class="nc" id="L477">        connect(socketAddress, 0);</span>
<span class="nc" id="L478">    }</span>

    /*
     * Package-private constructor used ONLY by SSLServerSocket.  The
     * java.net package accepts the TCP connection after this call is
     * made.  This just initializes handshake state to use &quot;server mode&quot;,
     * giving control over the use of SSL client authentication.
     */
    SSLSocketImpl(SSLContextImpl context, boolean serverMode,
            CipherSuiteList suites, byte clientAuth,
            boolean sessionCreation, ProtocolList protocols,
            String identificationProtocol,
            AlgorithmConstraints algorithmConstraints,
            Collection&lt;SNIMatcher&gt; sniMatchers,
            boolean preferLocalCipherSuites) throws IOException {

<span class="nc" id="L494">        super();</span>
<span class="nc" id="L495">        doClientAuth = clientAuth;</span>
<span class="nc" id="L496">        enableSessionCreation = sessionCreation;</span>
<span class="nc" id="L497">        this.identificationProtocol = identificationProtocol;</span>
<span class="nc" id="L498">        this.algorithmConstraints = algorithmConstraints;</span>
<span class="nc" id="L499">        this.sniMatchers = sniMatchers;</span>
<span class="nc" id="L500">        this.preferLocalCipherSuites = preferLocalCipherSuites;</span>
<span class="nc" id="L501">        init(context, serverMode);</span>

        /*
         * Override what was picked out for us.
         */
<span class="nc" id="L506">        enabledCipherSuites = suites;</span>
<span class="nc" id="L507">        enabledProtocols = protocols;</span>
<span class="nc" id="L508">    }</span>


    /**
     * Package-private constructor used to instantiate an unconnected
     * socket. The java.net package will connect it, either when the
     * connect() call is made by the application.  This instance is
     * meant to set handshake state to use &quot;client mode&quot;.
     */
    SSLSocketImpl(SSLContextImpl context) {
<span class="nc" id="L518">        super();</span>
<span class="nc" id="L519">        init(context, false);</span>
<span class="nc" id="L520">    }</span>


    /**
     * Layer SSL traffic over an existing connection, rather than creating
     * a new connection.  The existing connection may be used only for SSL
     * traffic (using this SSLSocket) until the SSLSocket.close() call
     * returns. However, if a protocol error is detected, that existing
     * connection is automatically closed.
     *
     * &lt;P&gt; This particular constructor always uses the socket in the
     * role of an SSL client. It may be useful in cases which start
     * using SSL after some initial data transfers, for example in some
     * SSL tunneling applications or as part of some kinds of application
     * protocols which negotiate use of a SSL based security.
     *
     * @param sock the existing connection
     * @param context the authentication context to use
     */
    SSLSocketImpl(SSLContextImpl context, Socket sock, String host,
            int port, boolean autoClose) throws IOException {
<span class="nc" id="L541">        super(sock);</span>
        // We always layer over a connected socket
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (!sock.isConnected()) {</span>
<span class="nc" id="L544">            throw new SocketException(&quot;Underlying socket is not connected&quot;);</span>
        }
<span class="nc" id="L546">        this.host = host;</span>
<span class="nc" id="L547">        this.serverNames =</span>
<span class="nc" id="L548">            Utilities.addToSNIServerNameList(this.serverNames, this.host);</span>
<span class="nc" id="L549">        init(context, false);</span>
<span class="nc" id="L550">        this.autoClose = autoClose;</span>
<span class="nc" id="L551">        doneConnect();</span>
<span class="nc" id="L552">    }</span>

    /**
     * Creates a server mode {@link Socket} layered over an
     * existing connected socket, and is able to read data which has
     * already been consumed/removed from the {@link Socket}'s
     * underlying {@link InputStream}.
     */
    SSLSocketImpl(SSLContextImpl context, Socket sock,
            InputStream consumed, boolean autoClose) throws IOException {
<span class="nc" id="L562">        super(sock, consumed);</span>
        // We always layer over a connected socket
<span class="nc bnc" id="L564" title="All 2 branches missed.">        if (!sock.isConnected()) {</span>
<span class="nc" id="L565">            throw new SocketException(&quot;Underlying socket is not connected&quot;);</span>
        }

        // In server mode, it is not necessary to set host and serverNames.
        // Otherwise, would require a reverse DNS lookup to get the hostname.

<span class="nc" id="L571">        init(context, true);</span>
<span class="nc" id="L572">        this.autoClose = autoClose;</span>
<span class="nc" id="L573">        doneConnect();</span>
<span class="nc" id="L574">    }</span>

    /**
     * Initializes the client socket.
     */
    private void init(SSLContextImpl context, boolean isServer) {
<span class="nc" id="L580">        sslContext = context;</span>
<span class="nc" id="L581">        sess = SSLSessionImpl.nullSession;</span>
<span class="nc" id="L582">        handshakeSession = null;</span>

        /*
         * role is as specified, state is START until after
         * the low level connection's established.
         */
<span class="nc" id="L588">        roleIsServer = isServer;</span>
<span class="nc" id="L589">        connectionState = cs_START;</span>

        /*
         * default read and write side cipher and MAC support
         *
         * Note:  compression support would go here too
         */
<span class="nc" id="L596">        readCipher = CipherBox.NULL;</span>
<span class="nc" id="L597">        readAuthenticator = MAC.NULL;</span>
<span class="nc" id="L598">        writeCipher = CipherBox.NULL;</span>
<span class="nc" id="L599">        writeAuthenticator = MAC.NULL;</span>

        // initial security parameters for secure renegotiation
<span class="nc" id="L602">        secureRenegotiation = false;</span>
<span class="nc" id="L603">        clientVerifyData = new byte[0];</span>
<span class="nc" id="L604">        serverVerifyData = new byte[0];</span>

<span class="nc" id="L606">        enabledCipherSuites =</span>
<span class="nc" id="L607">                sslContext.getDefaultCipherSuiteList(roleIsServer);</span>
<span class="nc" id="L608">        enabledProtocols =</span>
<span class="nc" id="L609">                sslContext.getDefaultProtocolList(roleIsServer);</span>

<span class="nc" id="L611">        inrec = null;</span>

        // save the acc
<span class="nc" id="L614">        acc = AccessController.getContext();</span>

<span class="nc" id="L616">        input = new AppInputStream(this);</span>
<span class="nc" id="L617">        output = new AppOutputStream(this);</span>
<span class="nc" id="L618">    }</span>

    /**
     * Connects this socket to the server with a specified timeout
     * value.
     *
     * This method is either called on an unconnected SSLSocketImpl by the
     * application, or it is called in the constructor of a regular
     * SSLSocketImpl. If we are layering on top on another socket, then
     * this method should not be called, because we assume that the
     * underlying socket is already connected by the time it is passed to
     * us.
     *
     * @param   endpoint the &lt;code&gt;SocketAddress&lt;/code&gt;
     * @param   timeout  the timeout value to be used, 0 is no timeout
     * @throws  IOException if an error occurs during the connection
     * @throws  SocketTimeoutException if timeout expires before connecting
     */
    @Override
    public void connect(SocketAddress endpoint, int timeout)
            throws IOException {

<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (isLayered()) {</span>
<span class="nc" id="L641">            throw new SocketException(&quot;Already connected&quot;);</span>
        }

<span class="nc bnc" id="L644" title="All 2 branches missed.">        if (!(endpoint instanceof InetSocketAddress)) {</span>
<span class="nc" id="L645">            throw new SocketException(</span>
                                  &quot;Cannot handle non-Inet socket addresses.&quot;);
        }

<span class="nc" id="L649">        super.connect(endpoint, timeout);</span>
<span class="nc" id="L650">        doneConnect();</span>
<span class="nc" id="L651">    }</span>

    /**
     * Initialize the handshaker and socket streams.
     *
     * Called by connect, the layered constructor, and SSLServerSocket.
     */
    void doneConnect() throws IOException {
        /*
         * Save the input and output streams.  May be done only after
         * java.net actually connects using the socket &quot;self&quot;, else
         * we get some pretty bizarre failure modes.
         */
<span class="nc" id="L664">        sockInput = super.getInputStream();</span>
<span class="nc" id="L665">        sockOutput = super.getOutputStream();</span>

        /*
         * Move to handshaking state, with pending session initialized
         * to defaults and the appropriate kind of handshaker set up.
         */
<span class="nc" id="L671">        initHandshaker();</span>
<span class="nc" id="L672">    }</span>

    synchronized private int getConnectionState() {
<span class="nc" id="L675">        return connectionState;</span>
    }

    synchronized private void setConnectionState(int state) {
<span class="nc" id="L679">        connectionState = state;</span>
<span class="nc" id="L680">    }</span>

    AccessControlContext getAcc() {
<span class="nc" id="L683">        return acc;</span>
    }

    //
    // READING AND WRITING RECORDS
    //

    /*
     * AppOutputStream calls may need to buffer multiple outbound
     * application packets.
     *
     * All other writeRecord() calls will not buffer, so do not hold
     * these records.
     */
    void writeRecord(OutputRecord r) throws IOException {
<span class="nc" id="L698">        writeRecord(r, false);</span>
<span class="nc" id="L699">    }</span>

    /*
     * Record Output. Application data can't be sent until the first
     * handshake establishes a session.
     *
     * NOTE:  we let empty records be written as a hook to force some
     * TCP-level activity, notably handshaking, to occur.
     */
    void writeRecord(OutputRecord r, boolean holdRecord) throws IOException {
        /*
         * The loop is in case of HANDSHAKE --&gt; ERROR transitions, etc
         */
    loop:
<span class="nc bnc" id="L713" title="All 2 branches missed.">        while (r.contentType() == Record.ct_application_data) {</span>
            /*
             * Not all states support passing application data.  We
             * synchronize access to the connection state, so that
             * synchronous handshakes can complete cleanly.
             */
<span class="nc bnc" id="L719" title="All 5 branches missed.">            switch (getConnectionState()) {</span>

            /*
             * We've deferred the initial handshaking till just now,
             * when presumably a thread's decided it's OK to block for
             * longish periods of time for I/O purposes (as well as
             * configured the cipher suites it wants to use).
             */
            case cs_HANDSHAKE:
<span class="nc" id="L728">                performInitialHandshake();</span>
<span class="nc" id="L729">                break;</span>

            case cs_DATA:
            case cs_RENEGOTIATE:
<span class="nc" id="L733">                break loop;</span>

            case cs_ERROR:
<span class="nc" id="L736">                fatal(Alerts.alert_close_notify,</span>
                    &quot;error while writing to socket&quot;);
<span class="nc" id="L738">                break; // dummy</span>

            case cs_SENT_CLOSE:
            case cs_CLOSED:
            case cs_APP_CLOSED:
                // we should never get here (check in AppOutputStream)
                // this is just a fallback
<span class="nc bnc" id="L745" title="All 2 branches missed.">                if (closeReason != null) {</span>
<span class="nc" id="L746">                    throw closeReason;</span>
                } else {
<span class="nc" id="L748">                    throw new SocketException(&quot;Socket closed&quot;);</span>
                }

            /*
             * Else something's goofy in this state machine's use.
             */
            default:
<span class="nc" id="L755">                throw new SSLProtocolException(&quot;State error, send app data&quot;);</span>
            }
        }

        //
        // Don't bother to really write empty records.  We went this
        // far to drive the handshake machinery, for correctness; not
        // writing empty records improves performance by cutting CPU
        // time and network resource usage.  However, some protocol
        // implementations are fragile and don't like to see empty
        // records, so this also increases robustness.
        //
<span class="nc bnc" id="L767" title="All 2 branches missed.">        if (!r.isEmpty()) {</span>

            // If the record is a close notify alert, we need to honor
            // socket option SO_LINGER. Note that we will try to send
            // the close notify even if the SO_LINGER set to zero.
<span class="nc bnc" id="L772" title="All 4 branches missed.">            if (r.isAlert(Alerts.alert_close_notify) &amp;&amp; getSoLinger() &gt;= 0) {</span>

                // keep and clear the current thread interruption status.
<span class="nc" id="L775">                boolean interrupted = Thread.interrupted();</span>
                try {
<span class="nc bnc" id="L777" title="All 2 branches missed.">                    if (writeLock.tryLock(getSoLinger(), TimeUnit.SECONDS)) {</span>
                        try {
<span class="nc" id="L779">                            writeRecordInternal(r, holdRecord);</span>
                        } finally {
<span class="nc" id="L781">                            writeLock.unlock();</span>
<span class="nc" id="L782">                        }</span>
                    } else {
<span class="nc" id="L784">                        SSLException ssle = new SSLException(</span>
                                &quot;SO_LINGER timeout,&quot; +
                                &quot; close_notify message cannot be sent.&quot;);


                        // For layered, non-autoclose sockets, we are not
                        // able to bring them into a usable state, so we
                        // treat it as fatal error.
<span class="nc bnc" id="L792" title="All 4 branches missed.">                        if (isLayered() &amp;&amp; !autoClose) {</span>
                            // Note that the alert description is
                            // specified as -1, so no message will be send
                            // to peer anymore.
<span class="nc" id="L796">                            fatal((byte)(-1), ssle);</span>
<span class="nc bnc" id="L797" title="All 4 branches missed.">                        } else if ((debug != null) &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L798">                            System.out.println(</span>
<span class="nc" id="L799">                                Thread.currentThread().getName() +</span>
                                &quot;, received Exception: &quot; + ssle);
                        }

                        // RFC2246 requires that the session becomes
                        // unresumable if any connection is terminated
                        // without proper close_notify messages with
                        // level equal to warning.
                        //
                        // RFC4346 no longer requires that a session not be
                        // resumed if failure to properly close a connection.
                        //
                        // We choose to make the session unresumable if
                        // failed to send the close_notify message.
                        //
<span class="nc" id="L814">                        sess.invalidate();</span>
                    }
<span class="nc" id="L816">                } catch (InterruptedException ie) {</span>
                    // keep interrupted status
<span class="nc" id="L818">                    interrupted = true;</span>
<span class="nc" id="L819">                }</span>

                // restore the interrupted status
<span class="nc bnc" id="L822" title="All 2 branches missed.">                if (interrupted) {</span>
<span class="nc" id="L823">                    Thread.currentThread().interrupt();</span>
                }
<span class="nc" id="L825">            } else {</span>
<span class="nc" id="L826">                writeLock.lock();</span>
                try {
<span class="nc" id="L828">                    writeRecordInternal(r, holdRecord);</span>
                } finally {
<span class="nc" id="L830">                    writeLock.unlock();</span>
<span class="nc" id="L831">                }</span>
            }
        }
<span class="nc" id="L834">    }</span>

    private void writeRecordInternal(OutputRecord r,
            boolean holdRecord) throws IOException {

        // r.compress(c);
<span class="nc" id="L840">        r.encrypt(writeAuthenticator, writeCipher);</span>

<span class="nc bnc" id="L842" title="All 2 branches missed.">        if (holdRecord) {</span>
            // If we were requested to delay the record due to possibility
            // of Nagle's being active when finally got to writing, and
            // it's actually not, we don't really need to delay it.
<span class="nc bnc" id="L846" title="All 2 branches missed.">            if (getTcpNoDelay()) {</span>
<span class="nc" id="L847">                holdRecord = false;</span>
            } else {
                // We need to hold the record, so let's provide
                // a per-socket place to do it.
<span class="nc bnc" id="L851" title="All 2 branches missed.">                if (heldRecordBuffer == null) {</span>
                    // Likely only need 37 bytes.
<span class="nc" id="L853">                    heldRecordBuffer = new ByteArrayOutputStream(40);</span>
                }
            }
        }
<span class="nc" id="L857">        r.write(sockOutput, holdRecord, heldRecordBuffer);</span>

        /*
         * Check the sequence number state
         *
         * Note that in order to maintain the connection I/O
         * properly, we check the sequence number after the last
         * record writing process. As we request renegotiation
         * or close the connection for wrapped sequence number
         * when there is enough sequence number space left to
         * handle a few more records, so the sequence number
         * of the last record cannot be wrapped.
         */
<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (connectionState &lt; cs_ERROR) {</span>
<span class="nc" id="L871">            checkSequenceNumber(writeAuthenticator, r.contentType());</span>
        }

        // turn off the flag of the first application record
<span class="nc bnc" id="L875" title="All 2 branches missed.">        if (isFirstAppOutputRecord &amp;&amp;</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">                r.contentType() == Record.ct_application_data) {</span>
<span class="nc" id="L877">            isFirstAppOutputRecord = false;</span>
        }
<span class="nc" id="L879">    }</span>

    /*
     * Need to split the payload except the following cases:
     *
     * 1. protocol version is TLS 1.1 or later;
     * 2. bulk cipher does not use CBC mode, including null bulk cipher suites.
     * 3. the payload is the first application record of a freshly
     *    negotiated TLS session.
     * 4. the CBC protection is disabled;
     *
     * More details, please refer to AppOutputStream.write(byte[], int, int).
     */
    boolean needToSplitPayload() {
<span class="nc" id="L893">        writeLock.lock();</span>
        try {
<span class="nc bnc" id="L895" title="All 2 branches missed.">            return (protocolVersion.v &lt;= ProtocolVersion.TLS10.v) &amp;&amp;</span>
<span class="nc bnc" id="L896" title="All 6 branches missed.">                    writeCipher.isCBCMode() &amp;&amp; !isFirstAppOutputRecord &amp;&amp;</span>
                    Record.enableCBCProtection;
        } finally {
<span class="nc" id="L899">            writeLock.unlock();</span>
        }
    }

    /*
     * Read an application data record.  Alerts and handshake
     * messages are handled directly.
     */
    void readDataRecord(InputRecord r) throws IOException {
<span class="nc bnc" id="L908" title="All 2 branches missed.">        if (getConnectionState() == cs_HANDSHAKE) {</span>
<span class="nc" id="L909">            performInitialHandshake();</span>
        }
<span class="nc" id="L911">        readRecord(r, true);</span>
<span class="nc" id="L912">    }</span>


    /*
     * Clear the pipeline of records from the peer, optionally returning
     * application data.   Caller is responsible for knowing that it's
     * possible to do this kind of clearing, if they don't want app
     * data -- e.g. since it's the initial SSL handshake.
     *
     * Don't synchronize (this) during a blocking read() since it
     * protects data which is accessed on the write side as well.
     */
    private void readRecord(InputRecord r, boolean needAppData)
            throws IOException {
        int state;

        // readLock protects reading and processing of an InputRecord.
        // It keeps the reading from sockInput and processing of the record
        // atomic so that no two threads can be blocked on the
        // read from the same input stream at the same time.
        // This is required for example when a reader thread is
        // blocked on the read and another thread is trying to
        // close the socket. For a non-autoclose, layered socket,
        // the thread performing the close needs to read the close_notify.
        //
        // Use readLock instead of 'this' for locking because
        // 'this' also protects data accessed during writing.
<span class="nc" id="L939">      synchronized (readLock) {</span>
        /*
         * Read and handle records ... return application data
         * ONLY if it's needed.
         */

<span class="nc bnc" id="L945" title="All 6 branches missed.">        while (((state = getConnectionState()) != cs_CLOSED) &amp;&amp;</span>
                (state != cs_ERROR) &amp;&amp; (state != cs_APP_CLOSED)) {
            /*
             * Read a record ... maybe emitting an alert if we get a
             * comprehensible but unsupported &quot;hello&quot; message during
             * format checking (e.g. V2).
             */
            try {
<span class="nc" id="L953">                r.setAppDataValid(false);</span>
<span class="nc" id="L954">                r.read(sockInput, sockOutput);</span>
<span class="nc" id="L955">            } catch (SSLProtocolException e) {</span>
                try {
<span class="nc" id="L957">                    fatal(Alerts.alert_unexpected_message, e);</span>
<span class="nc" id="L958">                } catch (IOException x) {</span>
                    // discard this exception
<span class="nc" id="L960">                }</span>
<span class="nc" id="L961">                throw e;</span>
<span class="nc" id="L962">            } catch (EOFException eof) {</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">                boolean handshaking = (getConnectionState() &lt;= cs_HANDSHAKE);</span>
<span class="nc bnc" id="L964" title="All 4 branches missed.">                boolean rethrow = requireCloseNotify || handshaking;</span>
<span class="nc bnc" id="L965" title="All 4 branches missed.">                if ((debug != null) &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">                    System.out.println(Thread.currentThread().getName() +</span>
                        &quot;, received EOFException: &quot;
                        + (rethrow ? &quot;error&quot; : &quot;ignored&quot;));
                }
<span class="nc bnc" id="L970" title="All 2 branches missed.">                if (rethrow) {</span>
                    SSLException e;
<span class="nc bnc" id="L972" title="All 2 branches missed.">                    if (handshaking) {</span>
<span class="nc" id="L973">                        e = new SSLHandshakeException</span>
                            (&quot;Remote host closed connection during handshake&quot;);
                    } else {
<span class="nc" id="L976">                        e = new SSLProtocolException</span>
                            (&quot;Remote host closed connection incorrectly&quot;);
                    }
<span class="nc" id="L979">                    e.initCause(eof);</span>
<span class="nc" id="L980">                    throw e;</span>
                } else {
                    // treat as if we had received a close_notify
<span class="nc" id="L983">                    closeInternal(false);</span>
<span class="nc" id="L984">                    continue;</span>
                }
<span class="nc" id="L986">            }</span>


            /*
             * The basic SSLv3 record protection involves (optional)
             * encryption for privacy, and an integrity check ensuring
             * data origin authentication.  We do them both here, and
             * throw a fatal alert if the integrity check fails.
             */
            try {
<span class="nc" id="L996">                r.decrypt(readAuthenticator, readCipher);</span>
<span class="nc" id="L997">            } catch (BadPaddingException e) {</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">                byte alertType = (r.contentType() == Record.ct_handshake)</span>
                                        ? Alerts.alert_handshake_failure
                                        : Alerts.alert_bad_record_mac;
<span class="nc" id="L1001">                fatal(alertType, e.getMessage(), e);</span>
<span class="nc" id="L1002">            }</span>

            // if (!r.decompress(c))
            //     fatal(Alerts.alert_decompression_failure,
            //         &quot;decompression failure&quot;);

            /*
             * Process the record.
             */
<span class="nc" id="L1011">            synchronized (this) {</span>
<span class="nc bnc" id="L1012" title="All 5 branches missed.">              switch (r.contentType()) {</span>
                case Record.ct_handshake:
                    /*
                     * Handshake messages always go to a pending session
                     * handshaker ... if there isn't one, create one.  This
                     * must work asynchronously, for renegotiation.
                     *
                     * NOTE that handshaking will either resume a session
                     * which was in the cache (and which might have other
                     * connections in it already), or else will start a new
                     * session (new keys exchanged) with just this connection
                     * in it.
                     */
<span class="nc" id="L1025">                    initHandshaker();</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">                    if (!handshaker.activated()) {</span>
                        // prior to handshaking, activate the handshake
<span class="nc bnc" id="L1028" title="All 2 branches missed.">                        if (connectionState == cs_RENEGOTIATE) {</span>
                            // don't use SSLv2Hello when renegotiating
<span class="nc" id="L1030">                            handshaker.activate(protocolVersion);</span>
                        } else {
<span class="nc" id="L1032">                            handshaker.activate(null);</span>
                        }
                    }

                    /*
                     * process the handshake record ... may contain just
                     * a partial handshake message or multiple messages.
                     *
                     * The handshaker state machine will ensure that it's
                     * a finished message.
                     */
<span class="nc" id="L1043">                    handshaker.process_record(r, expectingFinished);</span>
<span class="nc" id="L1044">                    expectingFinished = false;</span>

<span class="nc bnc" id="L1046" title="All 2 branches missed.">                    if (handshaker.invalidated) {</span>
<span class="nc" id="L1047">                        handshaker = null;</span>
                        // if state is cs_RENEGOTIATE, revert it to cs_DATA
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                        if (connectionState == cs_RENEGOTIATE) {</span>
<span class="nc" id="L1050">                            connectionState = cs_DATA;</span>
                        }
<span class="nc bnc" id="L1052" title="All 2 branches missed.">                    } else if (handshaker.isDone()) {</span>
                        // reset the parameters for secure renegotiation.
<span class="nc" id="L1054">                        secureRenegotiation =</span>
<span class="nc" id="L1055">                                        handshaker.isSecureRenegotiation();</span>
<span class="nc" id="L1056">                        clientVerifyData = handshaker.getClientVerifyData();</span>
<span class="nc" id="L1057">                        serverVerifyData = handshaker.getServerVerifyData();</span>

<span class="nc" id="L1059">                        sess = handshaker.getSession();</span>
<span class="nc" id="L1060">                        handshakeSession = null;</span>
<span class="nc" id="L1061">                        handshaker = null;</span>
<span class="nc" id="L1062">                        connectionState = cs_DATA;</span>

                        //
                        // Tell folk about handshake completion, but do
                        // it in a separate thread.
                        //
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                        if (handshakeListeners != null) {</span>
<span class="nc" id="L1069">                            HandshakeCompletedEvent event =</span>
                                new HandshakeCompletedEvent(this, sess);

<span class="nc" id="L1072">                            Thread t = new NotifyHandshakeThread(</span>
<span class="nc" id="L1073">                                handshakeListeners.entrySet(), event);</span>
<span class="nc" id="L1074">                            t.start();</span>
                        }
                    }

<span class="nc bnc" id="L1078" title="All 4 branches missed.">                    if (needAppData || connectionState != cs_DATA) {</span>
<span class="nc" id="L1079">                        continue;</span>
                    }
                    break;

                case Record.ct_application_data:
                    // Pass this right back up to the application.
<span class="nc bnc" id="L1085" title="All 6 branches missed.">                    if (connectionState != cs_DATA</span>
                            &amp;&amp; connectionState != cs_RENEGOTIATE
                            &amp;&amp; connectionState != cs_SENT_CLOSE) {
<span class="nc" id="L1088">                        throw new SSLProtocolException(</span>
                            &quot;Data received in non-data state: &quot; +
                            connectionState);
                    }
<span class="nc bnc" id="L1092" title="All 2 branches missed.">                    if (expectingFinished) {</span>
<span class="nc" id="L1093">                        throw new SSLProtocolException</span>
                                (&quot;Expecting finished message, received data&quot;);
                    }
<span class="nc bnc" id="L1096" title="All 2 branches missed.">                    if (!needAppData) {</span>
<span class="nc" id="L1097">                        throw new SSLException(&quot;Discarding app data&quot;);</span>
                    }

<span class="nc" id="L1100">                    r.setAppDataValid(true);</span>
<span class="nc" id="L1101">                    break;</span>

                case Record.ct_alert:
<span class="nc" id="L1104">                    recvAlert(r);</span>
<span class="nc" id="L1105">                    continue;</span>

                case Record.ct_change_cipher_spec:
<span class="nc bnc" id="L1108" title="All 4 branches missed.">                    if ((connectionState != cs_HANDSHAKE</span>
                                &amp;&amp; connectionState != cs_RENEGOTIATE)
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                            || r.available() != 1</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">                            || r.read() != 1) {</span>
<span class="nc" id="L1112">                        fatal(Alerts.alert_unexpected_message,</span>
                            &quot;illegal change cipher spec msg, state = &quot;
                            + connectionState);
                    }

                    //
                    // The first message after a change_cipher_spec
                    // record MUST be a &quot;Finished&quot; handshake record,
                    // else it's a protocol violation.  We force this
                    // to be checked by a minor tweak to the state
                    // machine.
                    //
<span class="nc" id="L1124">                    changeReadCiphers();</span>
                    // next message MUST be a finished message
<span class="nc" id="L1126">                    expectingFinished = true;</span>
<span class="nc" id="L1127">                    continue;</span>

                default:
                    //
                    // TLS requires that unrecognized records be ignored.
                    //
<span class="nc bnc" id="L1133" title="All 4 branches missed.">                    if (debug != null &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1134">                        System.out.println(Thread.currentThread().getName() +</span>
                            &quot;, Received record type: &quot;
<span class="nc" id="L1136">                            + r.contentType());</span>
                    }
<span class="nc" id="L1138">                    continue;</span>
              } // switch

              /*
               * Check the sequence number state
               *
               * Note that in order to maintain the connection I/O
               * properly, we check the sequence number after the last
               * record reading process. As we request renegotiation
               * or close the connection for wrapped sequence number
               * when there is enough sequence number space left to
               * handle a few more records, so the sequence number
               * of the last record cannot be wrapped.
               */
<span class="nc bnc" id="L1152" title="All 2 branches missed.">              if (connectionState &lt; cs_ERROR) {</span>
<span class="nc" id="L1153">                  checkSequenceNumber(readAuthenticator, r.contentType());</span>
              }

<span class="nc" id="L1156">              return;</span>
<span class="nc" id="L1157">            } // synchronized (this)</span>
        }

        //
        // couldn't read, due to some kind of error
        //
<span class="nc" id="L1163">        r.close();</span>
<span class="nc" id="L1164">        return;</span>
<span class="nc" id="L1165">      }  // synchronized (readLock)</span>
    }

    /**
     * Check the sequence number state
     *
     * RFC 4346 states that, &quot;Sequence numbers are of type uint64 and
     * may not exceed 2^64-1.  Sequence numbers do not wrap. If a TLS
     * implementation would need to wrap a sequence number, it must
     * renegotiate instead.&quot;
     */
    private void checkSequenceNumber(Authenticator authenticator, byte type)
            throws IOException {

        /*
         * Don't bother to check the sequence number for error or
         * closed connections, or NULL MAC.
         */
<span class="nc bnc" id="L1183" title="All 4 branches missed.">        if (connectionState &gt;= cs_ERROR || authenticator == MAC.NULL) {</span>
<span class="nc" id="L1184">            return;</span>
        }

        /*
         * Conservatively, close the connection immediately when the
         * sequence number is close to overflow
         */
<span class="nc bnc" id="L1191" title="All 2 branches missed.">        if (authenticator.seqNumOverflow()) {</span>
            /*
             * TLS protocols do not define a error alert for sequence
             * number overflow. We use handshake_failure error alert
             * for handshaking and bad_record_mac for other records.
             */
<span class="nc bnc" id="L1197" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1198">                System.out.println(Thread.currentThread().getName() +</span>
                    &quot;, sequence number extremely close to overflow &quot; +
                    &quot;(2^64-1 packets). Closing connection.&quot;);

            }

<span class="nc" id="L1204">            fatal(Alerts.alert_handshake_failure, &quot;sequence number overflow&quot;);</span>
        }

        /*
         * Ask for renegotiation when need to renew sequence number.
         *
         * Don't bother to kickstart the renegotiation when the local is
         * asking for it.
         */
<span class="nc bnc" id="L1213" title="All 4 branches missed.">        if ((type != Record.ct_handshake) &amp;&amp; authenticator.seqNumIsHuge()) {</span>
<span class="nc bnc" id="L1214" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1215">                System.out.println(Thread.currentThread().getName() +</span>
                        &quot;, request renegotiation &quot; +
                        &quot;to avoid sequence number overflow&quot;);
            }

<span class="nc" id="L1220">            startHandshake();</span>
        }
<span class="nc" id="L1222">    }</span>

    //
    // HANDSHAKE RELATED CODE
    //

    /**
     * Return the AppInputStream. For use by Handshaker only.
     */
    AppInputStream getAppInputStream() {
<span class="nc" id="L1232">        return input;</span>
    }

    /**
     * Return the AppOutputStream. For use by Handshaker only.
     */
    AppOutputStream getAppOutputStream() {
<span class="nc" id="L1239">        return output;</span>
    }

    /**
     * Initialize the handshaker object. This means:
     *
     *  . if a handshake is already in progress (state is cs_HANDSHAKE
     *    or cs_RENEGOTIATE), do nothing and return
     *
     *  . if the socket is already closed, throw an Exception (internal error)
     *
     *  . otherwise (cs_START or cs_DATA), create the appropriate handshaker
     *    object, and advance the connection state (to cs_HANDSHAKE or
     *    cs_RENEGOTIATE, respectively).
     *
     * This method is called right after a new socket is created, when
     * starting renegotiation, or when changing client/ server mode of the
     * socket.
     */
    private void initHandshaker() {
<span class="nc bnc" id="L1259" title="All 3 branches missed.">        switch (connectionState) {</span>

        //
        // Starting a new handshake.
        //
        case cs_START:
        case cs_DATA:
<span class="nc" id="L1266">            break;</span>

        //
        // We're already in the middle of a handshake.
        //
        case cs_HANDSHAKE:
        case cs_RENEGOTIATE:
<span class="nc" id="L1273">            return;</span>

        //
        // Anyone allowed to call this routine is required to
        // do so ONLY if the connection state is reasonable...
        //
        default:
<span class="nc" id="L1280">            throw new IllegalStateException(&quot;Internal error&quot;);</span>
        }

        // state is either cs_START or cs_DATA
<span class="nc bnc" id="L1284" title="All 2 branches missed.">        if (connectionState == cs_START) {</span>
<span class="nc" id="L1285">            connectionState = cs_HANDSHAKE;</span>
        } else { // cs_DATA
<span class="nc" id="L1287">            connectionState = cs_RENEGOTIATE;</span>
        }
<span class="nc bnc" id="L1289" title="All 2 branches missed.">        if (roleIsServer) {</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">            handshaker = new ServerHandshaker(this, sslContext,</span>
                    enabledProtocols, doClientAuth,
                    protocolVersion, connectionState == cs_HANDSHAKE,
                    secureRenegotiation, clientVerifyData, serverVerifyData);
<span class="nc" id="L1294">            handshaker.setSNIMatchers(sniMatchers);</span>
<span class="nc" id="L1295">            handshaker.setUseCipherSuitesOrder(preferLocalCipherSuites);</span>
        } else {
<span class="nc bnc" id="L1297" title="All 2 branches missed.">            handshaker = new ClientHandshaker(this, sslContext,</span>
                    enabledProtocols,
                    protocolVersion, connectionState == cs_HANDSHAKE,
                    secureRenegotiation, clientVerifyData, serverVerifyData);
<span class="nc" id="L1301">            handshaker.setSNIServerNames(serverNames);</span>
        }
<span class="nc" id="L1303">        handshaker.setEnabledCipherSuites(enabledCipherSuites);</span>
<span class="nc" id="L1304">        handshaker.setEnableSessionCreation(enableSessionCreation);</span>
<span class="nc" id="L1305">    }</span>

    /**
     * Synchronously perform the initial handshake.
     *
     * If the handshake is already in progress, this method blocks until it
     * is completed. If the initial handshake has already been completed,
     * it returns immediately.
     */
    private void performInitialHandshake() throws IOException {
        // use handshakeLock and the state check to make sure only
        // one thread performs the handshake
<span class="nc" id="L1317">        synchronized (handshakeLock) {</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">            if (getConnectionState() == cs_HANDSHAKE) {</span>
<span class="nc" id="L1319">                kickstartHandshake();</span>

                /*
                 * All initial handshaking goes through this
                 * InputRecord until we have a valid SSL connection.
                 * Once initial handshaking is finished, AppInputStream's
                 * InputRecord can handle any future renegotiation.
                 *
                 * Keep this local so that it goes out of scope and is
                 * eventually GC'd.
                 */
<span class="nc bnc" id="L1330" title="All 2 branches missed.">                if (inrec == null) {</span>
<span class="nc" id="L1331">                    inrec = new InputRecord();</span>

                    /*
                     * Grab the characteristics already assigned to
                     * AppInputStream's InputRecord.  Enable checking for
                     * SSLv2 hellos on this first handshake.
                     */
<span class="nc" id="L1338">                    inrec.setHandshakeHash(input.r.getHandshakeHash());</span>
<span class="nc" id="L1339">                    inrec.setHelloVersion(input.r.getHelloVersion());</span>
<span class="nc" id="L1340">                    inrec.enableFormatChecks();</span>
                }

<span class="nc" id="L1343">                readRecord(inrec, false);</span>
<span class="nc" id="L1344">                inrec = null;</span>
            }
<span class="nc" id="L1346">        }</span>
<span class="nc" id="L1347">    }</span>

    /**
     * Starts an SSL handshake on this connection.
     */
    @Override
    public void startHandshake() throws IOException {
        // start an ssl handshake that could be resumed from timeout exception
<span class="nc" id="L1355">        startHandshake(true);</span>
<span class="nc" id="L1356">    }</span>

    /**
     * Starts an ssl handshake on this connection.
     *
     * @param resumable indicates the handshake process is resumable from a
     *          certain exception. If &lt;code&gt;resumable&lt;/code&gt;, the socket will
     *          be reserved for exceptions like timeout; otherwise, the socket
     *          will be closed, no further communications could be done.
     */
    private void startHandshake(boolean resumable) throws IOException {
<span class="nc" id="L1367">        checkWrite();</span>
        try {
<span class="nc bnc" id="L1369" title="All 2 branches missed.">            if (getConnectionState() == cs_HANDSHAKE) {</span>
                // do initial handshake
<span class="nc" id="L1371">                performInitialHandshake();</span>
            } else {
                // start renegotiation
<span class="nc" id="L1374">                kickstartHandshake();</span>
            }
<span class="nc" id="L1376">        } catch (Exception e) {</span>
            // shutdown and rethrow (wrapped) exception as appropriate
<span class="nc" id="L1378">            handleException(e, resumable);</span>
<span class="nc" id="L1379">        }</span>
<span class="nc" id="L1380">    }</span>

    /**
     * Kickstart the handshake if it is not already in progress.
     * This means:
     *
     *  . if handshaking is already underway, do nothing and return
     *
     *  . if the socket is not connected or already closed, throw an
     *    Exception.
     *
     *  . otherwise, call initHandshake() to initialize the handshaker
     *    object and progress the state. Then, send the initial
     *    handshaking message if appropriate (always on clients and
     *    on servers when renegotiating).
     */
    private synchronized void kickstartHandshake() throws IOException {

<span class="nc bnc" id="L1398" title="All 5 branches missed.">        switch (connectionState) {</span>

        case cs_HANDSHAKE:
            // handshaker already setup, proceed
<span class="nc" id="L1402">            break;</span>

        case cs_DATA:
<span class="nc bnc" id="L1405" title="All 4 branches missed.">            if (!secureRenegotiation &amp;&amp; !Handshaker.allowUnsafeRenegotiation) {</span>
<span class="nc" id="L1406">                throw new SSLHandshakeException(</span>
                        &quot;Insecure renegotiation is not allowed&quot;);
            }

<span class="nc bnc" id="L1410" title="All 2 branches missed.">            if (!secureRenegotiation) {</span>
<span class="nc bnc" id="L1411" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L1412">                    System.out.println(</span>
                        &quot;Warning: Using insecure renegotiation&quot;);
                }
            }

            // initialize the handshaker, move to cs_RENEGOTIATE
<span class="nc" id="L1418">            initHandshaker();</span>
<span class="nc" id="L1419">            break;</span>

        case cs_RENEGOTIATE:
            // handshaking already in progress, return
<span class="nc" id="L1423">            return;</span>

        /*
         * The only way to get a socket in the state is when
         * you have an unconnected socket.
         */
        case cs_START:
<span class="nc" id="L1430">            throw new SocketException(</span>
                &quot;handshaking attempted on unconnected socket&quot;);

        default:
<span class="nc" id="L1434">            throw new SocketException(&quot;connection is closed&quot;);</span>
        }

        //
        // Kickstart handshake state machine if we need to ...
        //
        // Note that handshaker.kickstart() writes the message
        // to its HandshakeOutStream, which calls back into
        // SSLSocketImpl.writeRecord() to send it.
        //
<span class="nc bnc" id="L1444" title="All 2 branches missed.">        if (!handshaker.activated()) {</span>
             // prior to handshaking, activate the handshake
<span class="nc bnc" id="L1446" title="All 2 branches missed.">            if (connectionState == cs_RENEGOTIATE) {</span>
                // don't use SSLv2Hello when renegotiating
<span class="nc" id="L1448">                handshaker.activate(protocolVersion);</span>
            } else {
<span class="nc" id="L1450">                handshaker.activate(null);</span>
            }

<span class="nc bnc" id="L1453" title="All 2 branches missed.">            if (handshaker instanceof ClientHandshaker) {</span>
                // send client hello
<span class="nc" id="L1455">                handshaker.kickstart();</span>
            } else {
<span class="nc bnc" id="L1457" title="All 2 branches missed.">                if (connectionState == cs_HANDSHAKE) {</span>
                    // initial handshake, no kickstart message to send
                } else {
                    // we want to renegotiate, send hello request
<span class="nc" id="L1461">                    handshaker.kickstart();</span>
                    // hello request is not included in the handshake
                    // hashes, reset them
<span class="nc" id="L1464">                    handshaker.handshakeHash.reset();</span>
                }
            }
        }
<span class="nc" id="L1468">    }</span>

    //
    // CLOSURE RELATED CALLS
    //

    /**
     * Return whether the socket has been explicitly closed by the application.
     */
    @Override
    public boolean isClosed() {
<span class="nc bnc" id="L1479" title="All 2 branches missed.">        return connectionState == cs_APP_CLOSED;</span>
    }

    /**
     * Return whether we have reached end-of-file.
     *
     * If the socket is not connected, has been shutdown because of an error
     * or has been closed, throw an Exception.
     */
    boolean checkEOF() throws IOException {
<span class="nc bnc" id="L1489" title="All 4 branches missed.">        switch (getConnectionState()) {</span>
        case cs_START:
<span class="nc" id="L1491">            throw new SocketException(&quot;Socket is not connected&quot;);</span>

        case cs_HANDSHAKE:
        case cs_DATA:
        case cs_RENEGOTIATE:
        case cs_SENT_CLOSE:
<span class="nc" id="L1497">            return false;</span>

        case cs_APP_CLOSED:
<span class="nc" id="L1500">            throw new SocketException(&quot;Socket is closed&quot;);</span>

        case cs_ERROR:
        case cs_CLOSED:
        default:
            // either closed because of error, or normal EOF
<span class="nc bnc" id="L1506" title="All 2 branches missed.">            if (closeReason == null) {</span>
<span class="nc" id="L1507">                return true;</span>
            }
<span class="nc" id="L1509">            IOException e = new SSLException</span>
                        (&quot;Connection has been shutdown: &quot; + closeReason);
<span class="nc" id="L1511">            e.initCause(closeReason);</span>
<span class="nc" id="L1512">            throw e;</span>

        }
    }

    /**
     * Check if we can write data to this socket. If not, throw an IOException.
     */
    void checkWrite() throws IOException {
<span class="nc bnc" id="L1521" title="All 4 branches missed.">        if (checkEOF() || (getConnectionState() == cs_SENT_CLOSE)) {</span>
            // we are at EOF, write must throw Exception
<span class="nc" id="L1523">            throw new SocketException(&quot;Connection closed by remote host&quot;);</span>
        }
<span class="nc" id="L1525">    }</span>

    protected void closeSocket() throws IOException {

<span class="nc bnc" id="L1529" title="All 4 branches missed.">        if ((debug != null) &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1530">            System.out.println(Thread.currentThread().getName() +</span>
                                                &quot;, called closeSocket()&quot;);
        }

<span class="nc" id="L1534">        super.close();</span>
<span class="nc" id="L1535">    }</span>

    private void closeSocket(boolean selfInitiated) throws IOException {
<span class="nc bnc" id="L1538" title="All 4 branches missed.">        if ((debug != null) &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1539">            System.out.println(Thread.currentThread().getName() +</span>
                &quot;, called closeSocket(&quot; + selfInitiated + &quot;)&quot;);
        }
<span class="nc bnc" id="L1542" title="All 4 branches missed.">        if (!isLayered() || autoClose) {</span>
<span class="nc" id="L1543">            super.close();</span>
<span class="nc bnc" id="L1544" title="All 2 branches missed.">        } else if (selfInitiated) {</span>
            // layered &amp;&amp; non-autoclose
            // read close_notify alert to clear input stream
<span class="nc" id="L1547">            waitForClose(false);</span>
        }
<span class="nc" id="L1549">    }</span>

    /*
     * Closing the connection is tricky ... we can't officially close the
     * connection until we know the other end is ready to go away too,
     * and if ever the connection gets aborted we must forget session
     * state (it becomes invalid).
     */

    /**
     * Closes the SSL connection.  SSL includes an application level
     * shutdown handshake; you should close SSL sockets explicitly
     * rather than leaving it for finalization, so that your remote
     * peer does not experience a protocol error.
     */
    @Override
    public void close() throws IOException {
<span class="nc bnc" id="L1566" title="All 4 branches missed.">        if ((debug != null) &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1567">            System.out.println(Thread.currentThread().getName() +</span>
                                                    &quot;, called close()&quot;);
        }
<span class="nc" id="L1570">        closeInternal(true);  // caller is initiating close</span>
<span class="nc" id="L1571">        setConnectionState(cs_APP_CLOSED);</span>
<span class="nc" id="L1572">    }</span>

    /**
     * Don't synchronize the whole method because waitForClose()
     * (which calls readRecord()) might be called.
     *
     * @param selfInitiated Indicates which party initiated the close.
     * If selfInitiated, this side is initiating a close; for layered and
     * non-autoclose socket, wait for close_notify response.
     * If !selfInitiated, peer sent close_notify; we reciprocate but
     * no need to wait for response.
     */
    private void closeInternal(boolean selfInitiated) throws IOException {
<span class="nc bnc" id="L1585" title="All 4 branches missed.">        if ((debug != null) &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1586">            System.out.println(Thread.currentThread().getName() +</span>
                        &quot;, called closeInternal(&quot; + selfInitiated + &quot;)&quot;);
        }

<span class="nc" id="L1590">        int state = getConnectionState();</span>
<span class="nc" id="L1591">        boolean closeSocketCalled = false;</span>
<span class="nc" id="L1592">        Throwable cachedThrowable = null;</span>
        try {
<span class="nc bnc" id="L1594" title="All 4 branches missed.">            switch (state) {</span>
            case cs_START:
                // unconnected socket or handshaking has not been initialized
<span class="nc" id="L1597">                closeSocket(selfInitiated);</span>
<span class="nc" id="L1598">                break;</span>

            /*
             * If we're closing down due to error, we already sent (or else
             * received) the fatal alert ... no niceties, blow the connection
             * away as quickly as possible (even if we didn't allocate the
             * socket ourselves; it's unusable, regardless).
             */
            case cs_ERROR:
<span class="nc" id="L1607">                closeSocket();</span>
<span class="nc" id="L1608">                break;</span>

            /*
             * Sometimes close() gets called more than once.
             */
            case cs_CLOSED:
            case cs_APP_CLOSED:
<span class="nc" id="L1615">                 break;</span>

            /*
             * Otherwise we indicate clean termination.
             */
            // case cs_HANDSHAKE:
            // case cs_DATA:
            // case cs_RENEGOTIATE:
            // case cs_SENT_CLOSE:
            default:
<span class="nc" id="L1625">                synchronized (this) {</span>
<span class="nc bnc" id="L1626" title="All 6 branches missed.">                    if (((state = getConnectionState()) == cs_CLOSED) ||</span>
                       (state == cs_ERROR) || (state == cs_APP_CLOSED)) {
<span class="nc" id="L1628">                        return;  // connection was closed while we waited</span>
                    }
<span class="nc bnc" id="L1630" title="All 2 branches missed.">                    if (state != cs_SENT_CLOSE) {</span>
                        try {
<span class="nc" id="L1632">                            warning(Alerts.alert_close_notify);</span>
<span class="nc" id="L1633">                            connectionState = cs_SENT_CLOSE;</span>
<span class="nc" id="L1634">                        } catch (Throwable th) {</span>
                            // we need to ensure socket is closed out
                            // if we encounter any errors.
<span class="nc" id="L1637">                            connectionState = cs_ERROR;</span>
                            // cache this for later use
<span class="nc" id="L1639">                            cachedThrowable = th;</span>
<span class="nc" id="L1640">                            closeSocketCalled = true;</span>
<span class="nc" id="L1641">                            closeSocket(selfInitiated);</span>
<span class="nc" id="L1642">                        }</span>
                    }
<span class="nc" id="L1644">                }</span>
                // If state was cs_SENT_CLOSE before, we don't do the actual
                // closing since it is already in progress.
<span class="nc bnc" id="L1647" title="All 2 branches missed.">                if (state == cs_SENT_CLOSE) {</span>
<span class="nc bnc" id="L1648" title="All 4 branches missed.">                    if (debug != null &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1649">                        System.out.println(Thread.currentThread().getName() +</span>
                            &quot;, close invoked again; state = &quot; +
<span class="nc" id="L1651">                            getConnectionState());</span>
                    }
<span class="nc bnc" id="L1653" title="All 2 branches missed.">                    if (selfInitiated == false) {</span>
                        // We were called because a close_notify message was
                        // received. This may be due to another thread calling
                        // read() or due to our call to waitForClose() below.
                        // In either case, just return.
<span class="nc" id="L1658">                        return;</span>
                    }
                    // Another thread explicitly called close(). We need to
                    // wait for the closing to complete before returning.
<span class="nc" id="L1662">                    synchronized (this) {</span>
<span class="nc bnc" id="L1663" title="All 2 branches missed.">                        while (connectionState &lt; cs_CLOSED) {</span>
                            try {
<span class="nc" id="L1665">                                this.wait();</span>
<span class="nc" id="L1666">                            } catch (InterruptedException e) {</span>
                                // ignore
<span class="nc" id="L1668">                            }</span>
                        }
<span class="nc" id="L1670">                    }</span>
<span class="nc bnc" id="L1671" title="All 4 branches missed.">                    if ((debug != null) &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1672">                        System.out.println(Thread.currentThread().getName() +</span>
                            &quot;, after primary close; state = &quot; +
<span class="nc" id="L1674">                            getConnectionState());</span>
                    }
<span class="nc" id="L1676">                    return;</span>
                }

<span class="nc bnc" id="L1679" title="All 2 branches missed.">                if (!closeSocketCalled)  {</span>
<span class="nc" id="L1680">                    closeSocketCalled = true;</span>
<span class="nc" id="L1681">                    closeSocket(selfInitiated);</span>
                }

                break;
            }
        } finally {
<span class="nc" id="L1687">            synchronized (this) {</span>
                // Upon exit from this method, the state is always &gt;= cs_CLOSED
<span class="nc bnc" id="L1689" title="All 10 branches missed.">                connectionState = (connectionState == cs_APP_CLOSED)</span>
                                ? cs_APP_CLOSED : cs_CLOSED;
                // notify any threads waiting for the closing to finish
<span class="nc" id="L1692">                this.notifyAll();</span>
<span class="nc" id="L1693">            }</span>
<span class="nc bnc" id="L1694" title="All 10 branches missed.">            if (closeSocketCalled) {</span>
                // Dispose of ciphers since we've closed socket
<span class="nc" id="L1696">                disposeCiphers();</span>
            }
<span class="nc bnc" id="L1698" title="All 10 branches missed.">            if (cachedThrowable != null) {</span>
               /*
                * Rethrow the error to the calling method
                * The Throwable caught can only be an Error or RuntimeException
                */
<span class="nc bnc" id="L1703" title="All 10 branches missed.">                if (cachedThrowable instanceof Error)</span>
<span class="nc" id="L1704">                    throw (Error) cachedThrowable;</span>
<span class="nc bnc" id="L1705" title="All 10 branches missed.">                if (cachedThrowable instanceof RuntimeException)</span>
<span class="nc" id="L1706">                    throw (RuntimeException) cachedThrowable;</span>
            }
        }
<span class="nc" id="L1709">    }</span>

    /**
     * Reads a close_notify or a fatal alert from the input stream.
     * Keep reading records until we get a close_notify or until
     * the connection is otherwise closed.  The close_notify or alert
     * might be read by another reader,
     * which will then process the close and set the connection state.
     */
    void waitForClose(boolean rethrow) throws IOException {
<span class="nc bnc" id="L1719" title="All 4 branches missed.">        if (debug != null &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1720">            System.out.println(Thread.currentThread().getName() +</span>
                &quot;, waiting for close_notify or alert: state &quot;
<span class="nc" id="L1722">                + getConnectionState());</span>
        }

        try {
            int state;

<span class="nc bnc" id="L1728" title="All 6 branches missed.">            while (((state = getConnectionState()) != cs_CLOSED) &amp;&amp;</span>
                   (state != cs_ERROR) &amp;&amp; (state != cs_APP_CLOSED)) {
                // create the InputRecord if it isn't initialized.
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                if (inrec == null) {</span>
<span class="nc" id="L1732">                    inrec = new InputRecord();</span>
                }

                // Ask for app data and then throw it away
                try {
<span class="nc" id="L1737">                    readRecord(inrec, true);</span>
<span class="nc" id="L1738">                } catch (SocketTimeoutException e) {</span>
                    // if time out, ignore the exception and continue
<span class="nc" id="L1740">                }</span>
            }
<span class="nc" id="L1742">            inrec = null;</span>
<span class="nc" id="L1743">        } catch (IOException e) {</span>
<span class="nc bnc" id="L1744" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1745">                System.out.println(Thread.currentThread().getName() +</span>
                    &quot;, Exception while waiting for close &quot; +e);
            }
<span class="nc bnc" id="L1748" title="All 2 branches missed.">            if (rethrow) {</span>
<span class="nc" id="L1749">                throw e; // pass exception up</span>
            }
<span class="nc" id="L1751">        }</span>
<span class="nc" id="L1752">    }</span>

    /**
     * Called by closeInternal() only. Be sure to consider the
     * synchronization locks carefully before calling it elsewhere.
     */
    private void disposeCiphers() {
        // See comment in changeReadCiphers()
<span class="nc" id="L1760">        synchronized (readLock) {</span>
<span class="nc" id="L1761">            readCipher.dispose();</span>
<span class="nc" id="L1762">        }</span>
        // See comment in changeReadCiphers()
<span class="nc" id="L1764">        writeLock.lock();</span>
        try {
<span class="nc" id="L1766">            writeCipher.dispose();</span>
        } finally {
<span class="nc" id="L1768">            writeLock.unlock();</span>
<span class="nc" id="L1769">        }</span>
<span class="nc" id="L1770">    }</span>

    //
    // EXCEPTION AND ALERT HANDLING
    //

    /**
     * Handle an exception. This method is called by top level exception
     * handlers (in read(), write()) to make sure we always shutdown the
     * connection correctly and do not pass runtime exception to the
     * application.
     */
    void handleException(Exception e) throws IOException {
<span class="nc" id="L1783">        handleException(e, true);</span>
<span class="nc" id="L1784">    }</span>

    /**
     * Handle an exception. This method is called by top level exception
     * handlers (in read(), write(), startHandshake()) to make sure we
     * always shutdown the connection correctly and do not pass runtime
     * exception to the application.
     *
     * This method never returns normally, it always throws an IOException.
     *
     * We first check if the socket has already been shutdown because of an
     * error. If so, we just rethrow the exception. If the socket has not
     * been shutdown, we sent a fatal alert and remember the exception.
     *
     * @param e the Exception
     * @param resumable indicates the caller process is resumable from the
     *          exception. If &lt;code&gt;resumable&lt;/code&gt;, the socket will be
     *          reserved for exceptions like timeout; otherwise, the socket
     *          will be closed, no further communications could be done.
     */
    synchronized private void handleException(Exception e, boolean resumable)
        throws IOException {
<span class="nc bnc" id="L1806" title="All 4 branches missed.">        if ((debug != null) &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L1807">            System.out.println(Thread.currentThread().getName() +</span>
<span class="nc" id="L1808">                        &quot;, handling exception: &quot; + e.toString());</span>
        }

        // don't close the Socket in case of timeouts or interrupts if
        // the process is resumable.
<span class="nc bnc" id="L1813" title="All 4 branches missed.">        if (e instanceof InterruptedIOException &amp;&amp; resumable) {</span>
<span class="nc" id="L1814">            throw (IOException)e;</span>
        }

        // if we've already shutdown because of an error,
        // there is nothing to do except rethrow the exception
<span class="nc bnc" id="L1819" title="All 2 branches missed.">        if (closeReason != null) {</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">            if (e instanceof IOException) { // includes SSLException</span>
<span class="nc" id="L1821">                throw (IOException)e;</span>
            } else {
                // this is odd, not an IOException.
                // normally, this should not happen
                // if closeReason has been already been set
<span class="nc" id="L1826">                throw Alerts.getSSLException(Alerts.alert_internal_error, e,</span>
                                      &quot;Unexpected exception&quot;);
            }
        }

        // need to perform error shutdown
<span class="nc" id="L1832">        boolean isSSLException = (e instanceof SSLException);</span>
<span class="nc bnc" id="L1833" title="All 4 branches missed.">        if ((isSSLException == false) &amp;&amp; (e instanceof IOException)) {</span>
            // IOException from the socket
            // this means the TCP connection is already dead
            // we call fatal just to set the error status
            try {
<span class="nc" id="L1838">                fatal(Alerts.alert_unexpected_message, e);</span>
<span class="nc" id="L1839">            } catch (IOException ee) {</span>
                // ignore (IOException wrapped in SSLException)
<span class="nc" id="L1841">            }</span>
            // rethrow original IOException
<span class="nc" id="L1843">            throw (IOException)e;</span>
        }

        // must be SSLException or RuntimeException
        byte alertType;
<span class="nc bnc" id="L1848" title="All 2 branches missed.">        if (isSSLException) {</span>
<span class="nc bnc" id="L1849" title="All 2 branches missed.">            if (e instanceof SSLHandshakeException) {</span>
<span class="nc" id="L1850">                alertType = Alerts.alert_handshake_failure;</span>
            } else {
<span class="nc" id="L1852">                alertType = Alerts.alert_unexpected_message;</span>
            }
        } else {
<span class="nc" id="L1855">            alertType = Alerts.alert_internal_error;</span>
        }
<span class="nc" id="L1857">        fatal(alertType, e);</span>
<span class="nc" id="L1858">    }</span>

    /*
     * Send a warning alert.
     */
    void warning(byte description) {
<span class="nc" id="L1864">        sendAlert(Alerts.alert_warning, description);</span>
<span class="nc" id="L1865">    }</span>

    synchronized void fatal(byte description, String diagnostic)
            throws IOException {
<span class="nc" id="L1869">        fatal(description, diagnostic, null);</span>
<span class="nc" id="L1870">    }</span>

    synchronized void fatal(byte description, Throwable cause)
            throws IOException {
<span class="nc" id="L1874">        fatal(description, null, cause);</span>
<span class="nc" id="L1875">    }</span>

    /*
     * Send a fatal alert, and throw an exception so that callers will
     * need to stand on their heads to accidentally continue processing.
     */
    synchronized void fatal(byte description, String diagnostic,
            Throwable cause) throws IOException {
<span class="nc bnc" id="L1883" title="All 4 branches missed.">        if ((input != null) &amp;&amp; (input.r != null)) {</span>
<span class="nc" id="L1884">            input.r.close();</span>
        }
<span class="nc" id="L1886">        sess.invalidate();</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">        if (handshakeSession != null) {</span>
<span class="nc" id="L1888">            handshakeSession.invalidate();</span>
        }

<span class="nc" id="L1891">        int oldState = connectionState;</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">        if (connectionState &lt; cs_ERROR) {</span>
<span class="nc" id="L1893">            connectionState = cs_ERROR;</span>
        }

        /*
         * Has there been an error received yet?  If not, remember it.
         * By RFC 2246, we don't bother waiting for a response.
         * Fatal errors require immediate shutdown.
         */
<span class="nc bnc" id="L1901" title="All 2 branches missed.">        if (closeReason == null) {</span>
            /*
             * Try to clear the kernel buffer to avoid TCP connection resets.
             */
<span class="nc bnc" id="L1905" title="All 2 branches missed.">            if (oldState == cs_HANDSHAKE) {</span>
<span class="nc" id="L1906">                sockInput.skip(sockInput.available());</span>
            }

            // If the description equals -1, the alert won't be sent to peer.
<span class="nc bnc" id="L1910" title="All 2 branches missed.">            if (description != -1) {</span>
<span class="nc" id="L1911">                sendAlert(Alerts.alert_fatal, description);</span>
            }
<span class="nc bnc" id="L1913" title="All 2 branches missed.">            if (cause instanceof SSLException) { // only true if != null</span>
<span class="nc" id="L1914">                closeReason = (SSLException)cause;</span>
            } else {
<span class="nc" id="L1916">                closeReason =</span>
<span class="nc" id="L1917">                    Alerts.getSSLException(description, cause, diagnostic);</span>
            }
        }

        /*
         * Clean up our side.
         */
<span class="nc" id="L1924">        closeSocket();</span>
        // Another thread may have disposed the ciphers during closing
<span class="nc bnc" id="L1926" title="All 2 branches missed.">        if (connectionState &lt; cs_CLOSED) {</span>
<span class="nc bnc" id="L1927" title="All 2 branches missed.">            connectionState = (oldState == cs_APP_CLOSED) ? cs_APP_CLOSED</span>
                                                              : cs_CLOSED;

            // We should lock readLock and writeLock if no deadlock risks.
            // See comment in changeReadCiphers()
<span class="nc" id="L1932">            readCipher.dispose();</span>
<span class="nc" id="L1933">            writeCipher.dispose();</span>
        }

<span class="nc" id="L1936">        throw closeReason;</span>
    }


    /*
     * Process an incoming alert ... caller must already have synchronized
     * access to &quot;this&quot;.
     */
    private void recvAlert(InputRecord r) throws IOException {
<span class="nc" id="L1945">        byte level = (byte)r.read();</span>
<span class="nc" id="L1946">        byte description = (byte)r.read();</span>
<span class="nc bnc" id="L1947" title="All 2 branches missed.">        if (description == -1) { // check for short message</span>
<span class="nc" id="L1948">            fatal(Alerts.alert_illegal_parameter, &quot;Short alert message&quot;);</span>
        }

<span class="nc bnc" id="L1951" title="All 4 branches missed.">        if (debug != null &amp;&amp; (Debug.isOn(&quot;record&quot;) ||</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">                Debug.isOn(&quot;handshake&quot;))) {</span>
<span class="nc" id="L1953">            synchronized (System.out) {</span>
<span class="nc" id="L1954">                System.out.print(Thread.currentThread().getName());</span>
<span class="nc" id="L1955">                System.out.print(&quot;, RECV &quot; + protocolVersion + &quot; ALERT:  &quot;);</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">                if (level == Alerts.alert_fatal) {</span>
<span class="nc" id="L1957">                    System.out.print(&quot;fatal, &quot;);</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">                } else if (level == Alerts.alert_warning) {</span>
<span class="nc" id="L1959">                    System.out.print(&quot;warning, &quot;);</span>
                } else {
<span class="nc" id="L1961">                    System.out.print(&quot;&lt;level &quot; + (0x0ff &amp; level) + &quot;&gt;, &quot;);</span>
                }
<span class="nc" id="L1963">                System.out.println(Alerts.alertDescription(description));</span>
<span class="nc" id="L1964">            }</span>
        }

<span class="nc bnc" id="L1967" title="All 2 branches missed.">        if (level == Alerts.alert_warning) {</span>
<span class="nc bnc" id="L1968" title="All 2 branches missed.">            if (description == Alerts.alert_close_notify) {</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">                if (connectionState == cs_HANDSHAKE) {</span>
<span class="nc" id="L1970">                    fatal(Alerts.alert_unexpected_message,</span>
                                &quot;Received close_notify during handshake&quot;);
                } else {
<span class="nc" id="L1973">                    closeInternal(false);  // reply to close</span>
                }
            } else {

                //
                // The other legal warnings relate to certificates,
                // e.g. no_certificate, bad_certificate, etc; these
                // are important to the handshaking code, which can
                // also handle illegal protocol alerts if needed.
                //
<span class="nc bnc" id="L1983" title="All 2 branches missed.">                if (handshaker != null) {</span>
<span class="nc" id="L1984">                    handshaker.handshakeAlert(description);</span>
                }
            }
        } else { // fatal or unknown level
<span class="nc" id="L1988">            String reason = &quot;Received fatal alert: &quot;</span>
<span class="nc" id="L1989">                + Alerts.alertDescription(description);</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">            if (closeReason == null) {</span>
<span class="nc" id="L1991">                closeReason = Alerts.getSSLException(description, reason);</span>
            }
<span class="nc" id="L1993">            fatal(Alerts.alert_unexpected_message, reason);</span>
        }
<span class="nc" id="L1995">    }</span>


    /*
     * Emit alerts.  Caller must have synchronized with &quot;this&quot;.
     */
    private void sendAlert(byte level, byte description) {
        // the connectionState cannot be cs_START
<span class="nc bnc" id="L2003" title="All 2 branches missed.">        if (connectionState &gt;= cs_SENT_CLOSE) {</span>
<span class="nc" id="L2004">            return;</span>
        }

        // For initial handshaking, don't send alert message to peer if
        // handshaker has not started.
<span class="nc bnc" id="L2009" title="All 4 branches missed.">        if (connectionState == cs_HANDSHAKE &amp;&amp;</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">            (handshaker == null || !handshaker.started())) {</span>
<span class="nc" id="L2011">            return;</span>
        }

<span class="nc" id="L2014">        OutputRecord r = new OutputRecord(Record.ct_alert);</span>
<span class="nc" id="L2015">        r.setVersion(protocolVersion);</span>

<span class="nc bnc" id="L2017" title="All 4 branches missed.">        boolean useDebug = debug != null &amp;&amp; Debug.isOn(&quot;ssl&quot;);</span>
<span class="nc bnc" id="L2018" title="All 2 branches missed.">        if (useDebug) {</span>
<span class="nc" id="L2019">            synchronized (System.out) {</span>
<span class="nc" id="L2020">                System.out.print(Thread.currentThread().getName());</span>
<span class="nc" id="L2021">                System.out.print(&quot;, SEND &quot; + protocolVersion + &quot; ALERT:  &quot;);</span>
<span class="nc bnc" id="L2022" title="All 2 branches missed.">                if (level == Alerts.alert_fatal) {</span>
<span class="nc" id="L2023">                    System.out.print(&quot;fatal, &quot;);</span>
<span class="nc bnc" id="L2024" title="All 2 branches missed.">                } else if (level == Alerts.alert_warning) {</span>
<span class="nc" id="L2025">                    System.out.print(&quot;warning, &quot;);</span>
                } else {
<span class="nc" id="L2027">                    System.out.print(&quot;&lt;level = &quot; + (0x0ff &amp; level) + &quot;&gt;, &quot;);</span>
                }
<span class="nc" id="L2029">                System.out.println(&quot;description = &quot;</span>
<span class="nc" id="L2030">                        + Alerts.alertDescription(description));</span>
<span class="nc" id="L2031">            }</span>
        }

<span class="nc" id="L2034">        r.write(level);</span>
<span class="nc" id="L2035">        r.write(description);</span>
        try {
<span class="nc" id="L2037">            writeRecord(r);</span>
<span class="nc" id="L2038">        } catch (IOException e) {</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">            if (useDebug) {</span>
<span class="nc" id="L2040">                System.out.println(Thread.currentThread().getName() +</span>
                    &quot;, Exception sending alert: &quot; + e);
            }
<span class="nc" id="L2043">        }</span>
<span class="nc" id="L2044">    }</span>

    //
    // VARIOUS OTHER METHODS
    //

    /*
     * When a connection finishes handshaking by enabling use of a newly
     * negotiated session, each end learns about it in two halves (read,
     * and write).  When both read and write ciphers have changed, and the
     * last handshake message has been read, the connection has joined
     * (rejoined) the new session.
     *
     * NOTE:  The SSLv3 spec is rather unclear on the concepts here.
     * Sessions don't change once they're established (including cipher
     * suite and master secret) but connections can join them (and leave
     * them).  They're created by handshaking, though sometime handshaking
     * causes connections to join up with pre-established sessions.
     */
    private void changeReadCiphers() throws SSLException {
<span class="nc bnc" id="L2064" title="All 4 branches missed.">        if (connectionState != cs_HANDSHAKE</span>
                &amp;&amp; connectionState != cs_RENEGOTIATE) {
<span class="nc" id="L2066">            throw new SSLProtocolException(</span>
                &quot;State error, change cipher specs&quot;);
        }

        // ... create decompressor

<span class="nc" id="L2072">        CipherBox oldCipher = readCipher;</span>

        try {
<span class="nc" id="L2075">            readCipher = handshaker.newReadCipher();</span>
<span class="nc" id="L2076">            readAuthenticator = handshaker.newReadAuthenticator();</span>
<span class="nc" id="L2077">        } catch (GeneralSecurityException e) {</span>
            // &quot;can't happen&quot;
<span class="nc" id="L2079">            throw new SSLException(&quot;Algorithm missing:  &quot;, e);</span>
<span class="nc" id="L2080">        }</span>

        /*
         * Dispose of any intermediate state in the underlying cipher.
         * For PKCS11 ciphers, this will release any attached sessions,
         * and thus make finalization faster.
         *
         * Since MAC's doFinal() is called for every SSL/TLS packet, it's
         * not necessary to do the same with MAC's.
         */
<span class="nc" id="L2090">        oldCipher.dispose();</span>
<span class="nc" id="L2091">    }</span>

    // used by Handshaker
    void changeWriteCiphers() throws SSLException {
<span class="nc bnc" id="L2095" title="All 4 branches missed.">        if (connectionState != cs_HANDSHAKE</span>
                &amp;&amp; connectionState != cs_RENEGOTIATE) {
<span class="nc" id="L2097">            throw new SSLProtocolException(</span>
                &quot;State error, change cipher specs&quot;);
        }

        // ... create compressor

<span class="nc" id="L2103">        CipherBox oldCipher = writeCipher;</span>

        try {
<span class="nc" id="L2106">            writeCipher = handshaker.newWriteCipher();</span>
<span class="nc" id="L2107">            writeAuthenticator = handshaker.newWriteAuthenticator();</span>
<span class="nc" id="L2108">        } catch (GeneralSecurityException e) {</span>
            // &quot;can't happen&quot;
<span class="nc" id="L2110">            throw new SSLException(&quot;Algorithm missing:  &quot;, e);</span>
<span class="nc" id="L2111">        }</span>

        // See comment above.
<span class="nc" id="L2114">        oldCipher.dispose();</span>

        // reset the flag of the first application record
<span class="nc" id="L2117">        isFirstAppOutputRecord = true;</span>
<span class="nc" id="L2118">    }</span>

    /*
     * Updates the SSL version associated with this connection.
     * Called from Handshaker once it has determined the negotiated version.
     */
    synchronized void setVersion(ProtocolVersion protocolVersion) {
<span class="nc" id="L2125">        this.protocolVersion = protocolVersion;</span>
<span class="nc" id="L2126">        output.r.setVersion(protocolVersion);</span>
<span class="nc" id="L2127">    }</span>

    synchronized String getHost() {
        // Note that the host may be null or empty for localhost.
<span class="nc bnc" id="L2131" title="All 4 branches missed.">        if (host == null || host.length() == 0) {</span>
<span class="nc" id="L2132">            host = getInetAddress().getHostName();</span>
        }
<span class="nc" id="L2134">        return host;</span>
    }

    // ONLY used by HttpsClient to setup the URI specified hostname
    //
    // Please NOTE that this method MUST be called before calling to
    // SSLSocket.setSSLParameters(). Otherwise, the {@code host} parameter
    // may override SNIHostName in the customized server name indication.
    synchronized public void setHost(String host) {
<span class="nc" id="L2143">        this.host = host;</span>
<span class="nc" id="L2144">        this.serverNames =</span>
<span class="nc" id="L2145">            Utilities.addToSNIServerNameList(this.serverNames, this.host);</span>
<span class="nc" id="L2146">    }</span>

    /**
     * Gets an input stream to read from the peer on the other side.
     * Data read from this stream was always integrity protected in
     * transit, and will usually have been confidentiality protected.
     */
    @Override
    synchronized public InputStream getInputStream() throws IOException {
<span class="nc bnc" id="L2155" title="All 2 branches missed.">        if (isClosed()) {</span>
<span class="nc" id="L2156">            throw new SocketException(&quot;Socket is closed&quot;);</span>
        }

        /*
         * Can't call isConnected() here, because the Handshakers
         * do some initialization before we actually connect.
         */
<span class="nc bnc" id="L2163" title="All 2 branches missed.">        if (connectionState == cs_START) {</span>
<span class="nc" id="L2164">            throw new SocketException(&quot;Socket is not connected&quot;);</span>
        }

<span class="nc" id="L2167">        return input;</span>
    }

    /**
     * Gets an output stream to write to the peer on the other side.
     * Data written on this stream is always integrity protected, and
     * will usually be confidentiality protected.
     */
    @Override
    synchronized public OutputStream getOutputStream() throws IOException {
<span class="nc bnc" id="L2177" title="All 2 branches missed.">        if (isClosed()) {</span>
<span class="nc" id="L2178">            throw new SocketException(&quot;Socket is closed&quot;);</span>
        }

        /*
         * Can't call isConnected() here, because the Handshakers
         * do some initialization before we actually connect.
         */
<span class="nc bnc" id="L2185" title="All 2 branches missed.">        if (connectionState == cs_START) {</span>
<span class="nc" id="L2186">            throw new SocketException(&quot;Socket is not connected&quot;);</span>
        }

<span class="nc" id="L2189">        return output;</span>
    }

    /**
     * Returns the the SSL Session in use by this connection.  These can
     * be long lived, and frequently correspond to an entire login session
     * for some user.
     */
    @Override
    public SSLSession getSession() {
        /*
         * Force a synchronous handshake, if appropriate.
         */
<span class="nc bnc" id="L2202" title="All 2 branches missed.">        if (getConnectionState() == cs_HANDSHAKE) {</span>
            try {
                // start handshaking, if failed, the connection will be closed.
<span class="nc" id="L2205">                startHandshake(false);</span>
<span class="nc" id="L2206">            } catch (IOException e) {</span>
                // handshake failed. log and return a nullSession
<span class="nc bnc" id="L2208" title="All 4 branches missed.">                if (debug != null &amp;&amp; Debug.isOn(&quot;handshake&quot;)) {</span>
<span class="nc" id="L2209">                      System.out.println(Thread.currentThread().getName() +</span>
                          &quot;, IOException in getSession():  &quot; + e);
                }
<span class="nc" id="L2212">            }</span>
        }
<span class="nc" id="L2214">        synchronized (this) {</span>
<span class="nc" id="L2215">            return sess;</span>
<span class="nc" id="L2216">        }</span>
    }

    @Override
    synchronized public SSLSession getHandshakeSession() {
<span class="nc" id="L2221">        return handshakeSession;</span>
    }

    synchronized void setHandshakeSession(SSLSessionImpl session) {
<span class="nc" id="L2225">        handshakeSession = session;</span>
<span class="nc" id="L2226">    }</span>

    /**
     * Controls whether new connections may cause creation of new SSL
     * sessions.
     *
     * As long as handshaking has not started, we can change
     * whether we enable session creations.  Otherwise,
     * we will need to wait for the next handshake.
     */
    @Override
    synchronized public void setEnableSessionCreation(boolean flag) {
<span class="nc" id="L2238">        enableSessionCreation = flag;</span>

<span class="nc bnc" id="L2240" title="All 4 branches missed.">        if ((handshaker != null) &amp;&amp; !handshaker.activated()) {</span>
<span class="nc" id="L2241">            handshaker.setEnableSessionCreation(enableSessionCreation);</span>
        }
<span class="nc" id="L2243">    }</span>

    /**
     * Returns true if new connections may cause creation of new SSL
     * sessions.
     */
    @Override
    synchronized public boolean getEnableSessionCreation() {
<span class="nc" id="L2251">        return enableSessionCreation;</span>
    }


    /**
     * Sets the flag controlling whether a server mode socket
     * *REQUIRES* SSL client authentication.
     *
     * As long as handshaking has not started, we can change
     * whether client authentication is needed.  Otherwise,
     * we will need to wait for the next handshake.
     */
    @Override
    synchronized public void setNeedClientAuth(boolean flag) {
<span class="nc bnc" id="L2265" title="All 2 branches missed.">        doClientAuth = (flag ?</span>
            SSLEngineImpl.clauth_required : SSLEngineImpl.clauth_none);

<span class="nc bnc" id="L2268" title="All 4 branches missed.">        if ((handshaker != null) &amp;&amp;</span>
                (handshaker instanceof ServerHandshaker) &amp;&amp;
<span class="nc bnc" id="L2270" title="All 2 branches missed.">                !handshaker.activated()) {</span>
<span class="nc" id="L2271">            ((ServerHandshaker) handshaker).setClientAuth(doClientAuth);</span>
        }
<span class="nc" id="L2273">    }</span>

    @Override
    synchronized public boolean getNeedClientAuth() {
<span class="nc bnc" id="L2277" title="All 2 branches missed.">        return (doClientAuth == SSLEngineImpl.clauth_required);</span>
    }

    /**
     * Sets the flag controlling whether a server mode socket
     * *REQUESTS* SSL client authentication.
     *
     * As long as handshaking has not started, we can change
     * whether client authentication is requested.  Otherwise,
     * we will need to wait for the next handshake.
     */
    @Override
    synchronized public void setWantClientAuth(boolean flag) {
<span class="nc bnc" id="L2290" title="All 2 branches missed.">        doClientAuth = (flag ?</span>
            SSLEngineImpl.clauth_requested : SSLEngineImpl.clauth_none);

<span class="nc bnc" id="L2293" title="All 4 branches missed.">        if ((handshaker != null) &amp;&amp;</span>
                (handshaker instanceof ServerHandshaker) &amp;&amp;
<span class="nc bnc" id="L2295" title="All 2 branches missed.">                !handshaker.activated()) {</span>
<span class="nc" id="L2296">            ((ServerHandshaker) handshaker).setClientAuth(doClientAuth);</span>
        }
<span class="nc" id="L2298">    }</span>

    @Override
    synchronized public boolean getWantClientAuth() {
<span class="nc bnc" id="L2302" title="All 2 branches missed.">        return (doClientAuth == SSLEngineImpl.clauth_requested);</span>
    }


    /**
     * Sets the flag controlling whether the socket is in SSL
     * client or server mode.  Must be called before any SSL
     * traffic has started.
     */
    @Override
    @SuppressWarnings(&quot;fallthrough&quot;)
    synchronized public void setUseClientMode(boolean flag) {
<span class="nc bnc" id="L2314" title="All 3 branches missed.">        switch (connectionState) {</span>

        case cs_START:
            /*
             * If we need to change the socket mode and the enabled
             * protocols haven't specifically been set by the user,
             * change them to the corresponding default ones.
             */
<span class="nc bnc" id="L2322" title="All 4 branches missed.">            if (roleIsServer != (!flag) &amp;&amp;</span>
<span class="nc bnc" id="L2323" title="All 2 branches missed.">                    sslContext.isDefaultProtocolList(enabledProtocols)) {</span>
<span class="nc bnc" id="L2324" title="All 2 branches missed.">                enabledProtocols = sslContext.getDefaultProtocolList(!flag);</span>
            }
<span class="nc bnc" id="L2326" title="All 2 branches missed.">            roleIsServer = !flag;</span>
<span class="nc" id="L2327">            break;</span>

        case cs_HANDSHAKE:
            /*
             * If we have a handshaker, but haven't started
             * SSL traffic, we can throw away our current
             * handshaker, and start from scratch.  Don't
             * need to call doneConnect() again, we already
             * have the streams.
             */
<span class="nc bnc" id="L2337" title="All 4 branches missed.">            assert(handshaker != null);</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">            if (!handshaker.activated()) {</span>
                /*
                 * If we need to change the socket mode and the enabled
                 * protocols haven't specifically been set by the user,
                 * change them to the corresponding default ones.
                 */
<span class="nc bnc" id="L2344" title="All 4 branches missed.">                if (roleIsServer != (!flag) &amp;&amp;</span>
<span class="nc bnc" id="L2345" title="All 2 branches missed.">                        sslContext.isDefaultProtocolList(enabledProtocols)) {</span>
<span class="nc bnc" id="L2346" title="All 2 branches missed.">                    enabledProtocols = sslContext.getDefaultProtocolList(!flag);</span>
                }
<span class="nc bnc" id="L2348" title="All 2 branches missed.">                roleIsServer = !flag;</span>
<span class="nc" id="L2349">                connectionState = cs_START;</span>
<span class="nc" id="L2350">                initHandshaker();</span>
<span class="nc" id="L2351">                break;</span>
            }

            // If handshake has started, that's an error.  Fall through...

        default:
<span class="nc bnc" id="L2357" title="All 4 branches missed.">            if (debug != null &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L2358">                System.out.println(Thread.currentThread().getName() +</span>
                    &quot;, setUseClientMode() invoked in state = &quot; +
                    connectionState);
            }
<span class="nc" id="L2362">            throw new IllegalArgumentException(</span>
                &quot;Cannot change mode after SSL traffic has started&quot;);
        }
<span class="nc" id="L2365">    }</span>

    @Override
    synchronized public boolean getUseClientMode() {
<span class="nc bnc" id="L2369" title="All 2 branches missed.">        return !roleIsServer;</span>
    }


    /**
     * Returns the names of the cipher suites which could be enabled for use
     * on an SSL connection.  Normally, only a subset of these will actually
     * be enabled by default, since this list may include cipher suites which
     * do not support the mutual authentication of servers and clients, or
     * which do not protect data confidentiality.  Servers may also need
     * certain kinds of certificates to use certain cipher suites.
     *
     * @return an array of cipher suite names
     */
    @Override
    public String[] getSupportedCipherSuites() {
<span class="nc" id="L2385">        return sslContext.getSupportedCipherSuiteList().toStringArray();</span>
    }

    /**
     * Controls which particular cipher suites are enabled for use on
     * this connection.  The cipher suites must have been listed by
     * getCipherSuites() as being supported.  Even if a suite has been
     * enabled, it might never be used if no peer supports it or the
     * requisite certificates (and private keys) are not available.
     *
     * @param suites Names of all the cipher suites to enable.
     */
    @Override
    synchronized public void setEnabledCipherSuites(String[] suites) {
<span class="nc" id="L2399">        enabledCipherSuites = new CipherSuiteList(suites);</span>
<span class="nc bnc" id="L2400" title="All 4 branches missed.">        if ((handshaker != null) &amp;&amp; !handshaker.activated()) {</span>
<span class="nc" id="L2401">            handshaker.setEnabledCipherSuites(enabledCipherSuites);</span>
        }
<span class="nc" id="L2403">    }</span>

    /**
     * Returns the names of the SSL cipher suites which are currently enabled
     * for use on this connection.  When an SSL socket is first created,
     * all enabled cipher suites &lt;em&gt;(a)&lt;/em&gt; protect data confidentiality,
     * by traffic encryption, and &lt;em&gt;(b)&lt;/em&gt; can mutually authenticate
     * both clients and servers.  Thus, in some environments, this value
     * might be empty.
     *
     * @return an array of cipher suite names
     */
    @Override
    synchronized public String[] getEnabledCipherSuites() {
<span class="nc" id="L2417">        return enabledCipherSuites.toStringArray();</span>
    }


    /**
     * Returns the protocols that are supported by this implementation.
     * A subset of the supported protocols may be enabled for this connection
     * @return an array of protocol names.
     */
    @Override
    public String[] getSupportedProtocols() {
<span class="nc" id="L2428">        return sslContext.getSuportedProtocolList().toStringArray();</span>
    }

    /**
     * Controls which protocols are enabled for use on
     * this connection.  The protocols must have been listed by
     * getSupportedProtocols() as being supported.
     *
     * @param protocols protocols to enable.
     * @exception IllegalArgumentException when one of the protocols
     *  named by the parameter is not supported.
     */
    @Override
    synchronized public void setEnabledProtocols(String[] protocols) {
<span class="nc" id="L2442">        enabledProtocols = new ProtocolList(protocols);</span>
<span class="nc bnc" id="L2443" title="All 4 branches missed.">        if ((handshaker != null) &amp;&amp; !handshaker.activated()) {</span>
<span class="nc" id="L2444">            handshaker.setEnabledProtocols(enabledProtocols);</span>
        }
<span class="nc" id="L2446">    }</span>

    @Override
    synchronized public String[] getEnabledProtocols() {
<span class="nc" id="L2450">        return enabledProtocols.toStringArray();</span>
    }

    /**
     * Assigns the socket timeout.
     * @see java.net.Socket#setSoTimeout
     */
    @Override
    public void setSoTimeout(int timeout) throws SocketException {
<span class="nc bnc" id="L2459" title="All 4 branches missed.">        if ((debug != null) &amp;&amp; Debug.isOn(&quot;ssl&quot;)) {</span>
<span class="nc" id="L2460">            System.out.println(Thread.currentThread().getName() +</span>
                &quot;, setSoTimeout(&quot; + timeout + &quot;) called&quot;);
        }

<span class="nc" id="L2464">        super.setSoTimeout(timeout);</span>
<span class="nc" id="L2465">    }</span>

    /**
     * Registers an event listener to receive notifications that an
     * SSL handshake has completed on this connection.
     */
    @Override
    public synchronized void addHandshakeCompletedListener(
            HandshakeCompletedListener listener) {
<span class="nc bnc" id="L2474" title="All 2 branches missed.">        if (listener == null) {</span>
<span class="nc" id="L2475">            throw new IllegalArgumentException(&quot;listener is null&quot;);</span>
        }
<span class="nc bnc" id="L2477" title="All 2 branches missed.">        if (handshakeListeners == null) {</span>
<span class="nc" id="L2478">            handshakeListeners = new</span>
                HashMap&lt;HandshakeCompletedListener, AccessControlContext&gt;(4);
        }
<span class="nc" id="L2481">        handshakeListeners.put(listener, AccessController.getContext());</span>
<span class="nc" id="L2482">    }</span>


    /**
     * Removes a previously registered handshake completion listener.
     */
    @Override
    public synchronized void removeHandshakeCompletedListener(
            HandshakeCompletedListener listener) {
<span class="nc bnc" id="L2491" title="All 2 branches missed.">        if (handshakeListeners == null) {</span>
<span class="nc" id="L2492">            throw new IllegalArgumentException(&quot;no listeners&quot;);</span>
        }
<span class="nc bnc" id="L2494" title="All 2 branches missed.">        if (handshakeListeners.remove(listener) == null) {</span>
<span class="nc" id="L2495">            throw new IllegalArgumentException(&quot;listener not registered&quot;);</span>
        }
<span class="nc bnc" id="L2497" title="All 2 branches missed.">        if (handshakeListeners.isEmpty()) {</span>
<span class="nc" id="L2498">            handshakeListeners = null;</span>
        }
<span class="nc" id="L2500">    }</span>

    /**
     * Returns the SSLParameters in effect for this SSLSocket.
     */
    @Override
    synchronized public SSLParameters getSSLParameters() {
<span class="nc" id="L2507">        SSLParameters params = super.getSSLParameters();</span>

        // the super implementation does not handle the following parameters
<span class="nc" id="L2510">        params.setEndpointIdentificationAlgorithm(identificationProtocol);</span>
<span class="nc" id="L2511">        params.setAlgorithmConstraints(algorithmConstraints);</span>
<span class="nc" id="L2512">        params.setSNIMatchers(sniMatchers);</span>
<span class="nc" id="L2513">        params.setServerNames(serverNames);</span>
<span class="nc" id="L2514">        params.setUseCipherSuitesOrder(preferLocalCipherSuites);</span>

<span class="nc" id="L2516">        return params;</span>
    }

    /**
     * Applies SSLParameters to this socket.
     */
    @Override
    synchronized public void setSSLParameters(SSLParameters params) {
<span class="nc" id="L2524">        super.setSSLParameters(params);</span>

        // the super implementation does not handle the following parameters
<span class="nc" id="L2527">        identificationProtocol = params.getEndpointIdentificationAlgorithm();</span>
<span class="nc" id="L2528">        algorithmConstraints = params.getAlgorithmConstraints();</span>
<span class="nc" id="L2529">        preferLocalCipherSuites = params.getUseCipherSuitesOrder();</span>

<span class="nc" id="L2531">        List&lt;SNIServerName&gt; sniNames = params.getServerNames();</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">        if (sniNames != null) {</span>
<span class="nc" id="L2533">            serverNames = sniNames;</span>
        }

<span class="nc" id="L2536">        Collection&lt;SNIMatcher&gt; matchers = params.getSNIMatchers();</span>
<span class="nc bnc" id="L2537" title="All 2 branches missed.">        if (matchers != null) {</span>
<span class="nc" id="L2538">            sniMatchers = matchers;</span>
        }

<span class="nc bnc" id="L2541" title="All 4 branches missed.">        if ((handshaker != null) &amp;&amp; !handshaker.started()) {</span>
<span class="nc" id="L2542">            handshaker.setIdentificationProtocol(identificationProtocol);</span>
<span class="nc" id="L2543">            handshaker.setAlgorithmConstraints(algorithmConstraints);</span>
<span class="nc bnc" id="L2544" title="All 2 branches missed.">            if (roleIsServer) {</span>
<span class="nc" id="L2545">                handshaker.setSNIMatchers(sniMatchers);</span>
<span class="nc" id="L2546">                handshaker.setUseCipherSuitesOrder(preferLocalCipherSuites);</span>
            } else {
<span class="nc" id="L2548">                handshaker.setSNIServerNames(serverNames);</span>
            }
        }
<span class="nc" id="L2551">    }</span>

    //
    // We allocate a separate thread to deliver handshake completion
    // events.  This ensures that the notifications don't block the
    // protocol state machine.
    //
    private static class NotifyHandshakeThread extends Thread {

        private Set&lt;Map.Entry&lt;HandshakeCompletedListener,AccessControlContext&gt;&gt;
                targets;        // who gets notified
        private HandshakeCompletedEvent event;          // the notification

        NotifyHandshakeThread(
            Set&lt;Map.Entry&lt;HandshakeCompletedListener,AccessControlContext&gt;&gt;
            entrySet, HandshakeCompletedEvent e) {

<span class="nc" id="L2568">            super(&quot;HandshakeCompletedNotify-Thread&quot;);</span>
<span class="nc" id="L2569">            targets = new HashSet&lt;&gt;(entrySet);          // clone the entry set</span>
<span class="nc" id="L2570">            event = e;</span>
<span class="nc" id="L2571">        }</span>

        @Override
        public void run() {
            // Don't need to synchronize, as it only runs in one thread.
            for (Map.Entry&lt;HandshakeCompletedListener,AccessControlContext&gt;
<span class="nc bnc" id="L2577" title="All 2 branches missed.">                entry : targets) {</span>

<span class="nc" id="L2579">                final HandshakeCompletedListener l = entry.getKey();</span>
<span class="nc" id="L2580">                AccessControlContext acc = entry.getValue();</span>
<span class="nc" id="L2581">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {</span>
                    @Override
                    public Void run() {
<span class="nc" id="L2584">                        l.handshakeCompleted(event);</span>
<span class="nc" id="L2585">                        return null;</span>
                    }
                }, acc);
<span class="nc" id="L2588">            }</span>
<span class="nc" id="L2589">        }</span>
    }

    /**
     * Returns a printable representation of this end of the connection.
     */
    @Override
    public String toString() {
<span class="nc" id="L2597">        StringBuffer retval = new StringBuffer(80);</span>

<span class="nc" id="L2599">        retval.append(Integer.toHexString(hashCode()));</span>
<span class="nc" id="L2600">        retval.append(&quot;[&quot;);</span>
<span class="nc" id="L2601">        retval.append(sess.getCipherSuite());</span>
<span class="nc" id="L2602">        retval.append(&quot;: &quot;);</span>

<span class="nc" id="L2604">        retval.append(super.toString());</span>
<span class="nc" id="L2605">        retval.append(&quot;]&quot;);</span>

<span class="nc" id="L2607">        return retval.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>