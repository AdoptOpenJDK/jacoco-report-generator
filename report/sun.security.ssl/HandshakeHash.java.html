<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>HandshakeHash.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.ssl</a> &gt; <span class="el_source">HandshakeHash.java</span></div><h1>HandshakeHash.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package sun.security.ssl;

import java.io.ByteArrayOutputStream;
import java.security.*;
import java.util.Locale;

/**
 * Abstraction for the SSL/TLS hash of all handshake messages that is
 * maintained to verify the integrity of the negotiation. Internally,
 * it consists of an MD5 and an SHA1 digest. They are used in the client
 * and server finished messages and in certificate verify messages (if sent).
 *
 * This class transparently deals with cloneable and non-cloneable digests.
 *
 * This class now supports TLS 1.2 also. The key difference for TLS 1.2
 * is that you cannot determine the hash algorithms for CertificateVerify
 * at a early stage. On the other hand, it's simpler than TLS 1.1 (and earlier)
 * that there is no messy MD5+SHA1 digests.
 *
 * You need to obey these conventions when using this class:
 *
 * 1. protocolDetermined(version) should be called when the negotiated
 * protocol version is determined.
 *
 * 2. Before protocolDetermined() is called, only update(), and reset()
 * and setFinishedAlg() can be called.
 *
 * 3. After protocolDetermined() is called, reset() cannot be called.
 *
 * 4. After protocolDetermined() is called, if the version is pre-TLS 1.2,
 * getFinishedHash() cannot be called. Otherwise,
 * getMD5Clone() and getSHAClone() cannot be called.
 *
 * 5. getMD5Clone() and getSHAClone() can only be called after
 * protocolDetermined() is called and version is pre-TLS 1.2.
 *
 * 6. getFinishedHash() can only be called after protocolDetermined()
 * and setFinishedAlg() have been called and the version is TLS 1.2.
 *
 * Suggestion: Call protocolDetermined() and setFinishedAlg()
 * as early as possible.
 *
 * Example:
 * &lt;pre&gt;
 * HandshakeHash hh = new HandshakeHash(...)
 * hh.protocolDetermined(ProtocolVersion.TLS12);
 * hh.update(clientHelloBytes);
 * hh.setFinishedAlg(&quot;SHA-256&quot;);
 * hh.update(serverHelloBytes);
 * ...
 * hh.update(CertificateVerifyBytes);
 * ...
 * hh.update(finished1);
 * byte[] finDigest1 = hh.getFinishedHash();
 * hh.update(finished2);
 * byte[] finDigest2 = hh.getFinishedHash();
 * &lt;/pre&gt;
 */
final class HandshakeHash {

    // Common

    // -1:  unknown
    //  1:  &lt;=TLS 1.1
    //  2:  TLS 1.2
<span class="nc" id="L92">    private int version = -1;</span>
<span class="nc" id="L93">    private ByteArrayOutputStream data = new ByteArrayOutputStream();</span>

    // For TLS 1.1
    private MessageDigest md5, sha;
    private final int clonesNeeded;    // needs to be saved for later use

    // For TLS 1.2
    private MessageDigest finMD;

    /**
     * Create a new HandshakeHash. needCertificateVerify indicates whether
     * a hash for the certificate verify message is required.
     */
<span class="nc" id="L106">    HandshakeHash(boolean needCertificateVerify) {</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">        clonesNeeded = needCertificateVerify ? 3 : 2;</span>
<span class="nc" id="L108">    }</span>

    void update(byte[] b, int offset, int len) {
<span class="nc bnc" id="L111" title="All 2 branches missed.">        switch (version) {</span>
            case 1:
<span class="nc" id="L113">                md5.update(b, offset, len);</span>
<span class="nc" id="L114">                sha.update(b, offset, len);</span>
<span class="nc" id="L115">                break;</span>
            default:
<span class="nc bnc" id="L117" title="All 2 branches missed.">                if (finMD != null) {</span>
<span class="nc" id="L118">                    finMD.update(b, offset, len);</span>
                }
<span class="nc" id="L120">                data.write(b, offset, len);</span>
                break;
        }
<span class="nc" id="L123">    }</span>

    /**
     * Reset the remaining digests. Note this does *not* reset the number of
     * digest clones that can be obtained. Digests that have already been
     * cloned and are gone remain gone.
     */
    void reset() {
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (version != -1) {</span>
<span class="nc" id="L132">            throw new RuntimeException(</span>
                    &quot;reset() can be only be called before protocolDetermined&quot;);
        }
<span class="nc" id="L135">        data.reset();</span>
<span class="nc" id="L136">    }</span>


    void protocolDetermined(ProtocolVersion pv) {

        // Do not set again, will ignore
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (version != -1) return;</span>

<span class="nc bnc" id="L144" title="All 2 branches missed.">        version = pv.compareTo(ProtocolVersion.TLS12) &gt;= 0 ? 2 : 1;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        switch (version) {</span>
            case 1:
                // initiate md5, sha and call update on saved array
                try {
<span class="nc" id="L149">                    md5 = CloneableDigest.getDigest(&quot;MD5&quot;, clonesNeeded);</span>
<span class="nc" id="L150">                    sha = CloneableDigest.getDigest(&quot;SHA&quot;, clonesNeeded);</span>
<span class="nc" id="L151">                } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L152">                    throw new RuntimeException</span>
                                (&quot;Algorithm MD5 or SHA not available&quot;, e);
<span class="nc" id="L154">                }</span>
<span class="nc" id="L155">                byte[] bytes = data.toByteArray();</span>
<span class="nc" id="L156">                update(bytes, 0, bytes.length);</span>
<span class="nc" id="L157">                break;</span>
            case 2:
                break;
        }
<span class="nc" id="L161">    }</span>

    /////////////////////////////////////////////////////////////
    // Below are old methods for pre-TLS 1.1
    /////////////////////////////////////////////////////////////

    /**
     * Return a new MD5 digest updated with all data hashed so far.
     */
    MessageDigest getMD5Clone() {
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (version != 1) {</span>
<span class="nc" id="L172">            throw new RuntimeException(</span>
                    &quot;getMD5Clone() can be only be called for TLS 1.1&quot;);
        }
<span class="nc" id="L175">        return cloneDigest(md5);</span>
    }

    /**
     * Return a new SHA digest updated with all data hashed so far.
     */
    MessageDigest getSHAClone() {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (version != 1) {</span>
<span class="nc" id="L183">            throw new RuntimeException(</span>
                    &quot;getSHAClone() can be only be called for TLS 1.1&quot;);
        }
<span class="nc" id="L186">        return cloneDigest(sha);</span>
    }

    private static MessageDigest cloneDigest(MessageDigest digest) {
        try {
<span class="nc" id="L191">            return (MessageDigest)digest.clone();</span>
<span class="nc" id="L192">        } catch (CloneNotSupportedException e) {</span>
            // cannot occur for digests generated via CloneableDigest
<span class="nc" id="L194">            throw new RuntimeException(&quot;Could not clone digest&quot;, e);</span>
        }
    }

    /////////////////////////////////////////////////////////////
    // Below are new methods for TLS 1.2
    /////////////////////////////////////////////////////////////

    private static String normalizeAlgName(String alg) {
<span class="nc" id="L203">        alg = alg.toUpperCase(Locale.US);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (alg.startsWith(&quot;SHA&quot;)) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            if (alg.length() == 3) {</span>
<span class="nc" id="L206">                return &quot;SHA-1&quot;;</span>
            }
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if (alg.charAt(3) != '-') {</span>
<span class="nc" id="L209">                return &quot;SHA-&quot; + alg.substring(3);</span>
            }
        }
<span class="nc" id="L212">        return alg;</span>
    }
    /**
     * Specifies the hash algorithm used in Finished. This should be called
     * based in info in ServerHello.
     * Can be called multiple times.
     */
    void setFinishedAlg(String s) {
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (s == null) {</span>
<span class="nc" id="L221">            throw new RuntimeException(</span>
                    &quot;setFinishedAlg's argument cannot be null&quot;);
        }

        // Can be called multiple times, but only set once
<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (finMD != null) return;</span>

        try {
<span class="nc" id="L229">            finMD = CloneableDigest.getDigest(normalizeAlgName(s), 2);</span>
<span class="nc" id="L230">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L231">            throw new Error(e);</span>
<span class="nc" id="L232">        }</span>
<span class="nc" id="L233">        finMD.update(data.toByteArray());</span>
<span class="nc" id="L234">    }</span>

    byte[] getAllHandshakeMessages() {
<span class="nc" id="L237">        return data.toByteArray();</span>
    }

    /**
     * Calculates the hash in Finished. Must be called after setFinishedAlg().
     * This method can be called twice, for Finished messages of the server
     * side and client side respectively.
     */
    byte[] getFinishedHash() {
        try {
<span class="nc" id="L247">            return cloneDigest(finMD).digest();</span>
<span class="nc" id="L248">        } catch (Exception e) {</span>
<span class="nc" id="L249">            throw new Error(&quot;BAD&quot;);</span>
        }
    }
}

/**
 * A wrapper for MessageDigests that simulates cloning of non-cloneable
 * digests. It uses the standard MessageDigest API and therefore can be used
 * transparently in place of a regular digest.
 *
 * Note that we extend the MessageDigest class directly rather than
 * MessageDigestSpi. This works because MessageDigest was originally designed
 * this way in the JDK 1.1 days which allows us to avoid creating an internal
 * provider.
 *
 * It can be &quot;cloned&quot; a limited number of times, which is specified at
 * construction time. This is achieved by internally maintaining n digests
 * in parallel. Consequently, it is only 1/n-th times as fast as the original
 * digest.
 *
 * Example:
 *   MessageDigest md = CloneableDigest.getDigest(&quot;SHA&quot;, 2);
 *   md.update(data1);
 *   MessageDigest md2 = (MessageDigest)md.clone();
 *   md2.update(data2);
 *   byte[] d1 = md2.digest(); // digest of data1 || data2
 *   md.update(data3);
 *   byte[] d2 = md.digest();  // digest of data1 || data3
 *
 * This class is not thread safe.
 *
 */
final class CloneableDigest extends MessageDigest implements Cloneable {

    /**
     * The individual MessageDigests. Initially, all elements are non-null.
     * When clone() is called, the non-null element with the maximum index is
     * returned and the array element set to null.
     *
     * All non-null element are always in the same state.
     */
    private final MessageDigest[] digests;

    private CloneableDigest(MessageDigest digest, int n, String algorithm)
            throws NoSuchAlgorithmException {
<span class="nc" id="L294">        super(algorithm);</span>
<span class="nc" id="L295">        digests = new MessageDigest[n];</span>
<span class="nc" id="L296">        digests[0] = digest;</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        for (int i = 1; i &lt; n; i++) {</span>
<span class="nc" id="L298">            digests[i] = JsseJce.getMessageDigest(algorithm);</span>
        }
<span class="nc" id="L300">    }</span>

    /**
     * Return a MessageDigest for the given algorithm that can be cloned the
     * specified number of times. If the default implementation supports
     * cloning, it is returned. Otherwise, an instance of this class is
     * returned.
     */
    static MessageDigest getDigest(String algorithm, int n)
            throws NoSuchAlgorithmException {
<span class="nc" id="L310">        MessageDigest digest = JsseJce.getMessageDigest(algorithm);</span>
        try {
<span class="nc" id="L312">            digest.clone();</span>
            // already cloneable, use it
<span class="nc" id="L314">            return digest;</span>
<span class="nc" id="L315">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L316">            return new CloneableDigest(digest, n, algorithm);</span>
        }
    }

    /**
     * Check if this object is still usable. If it has already been cloned the
     * maximum number of times, there are no digests left and this object can no
     * longer be used.
     */
    private void checkState() {
        // XXX handshaking currently doesn't stop updating hashes...
        // if (digests[0] == null) {
        //     throw new IllegalStateException(&quot;no digests left&quot;);
        // }
<span class="nc" id="L330">    }</span>

    @Override
    protected int engineGetDigestLength() {
<span class="nc" id="L334">        checkState();</span>
<span class="nc" id="L335">        return digests[0].getDigestLength();</span>
    }

    @Override
    protected void engineUpdate(byte b) {
<span class="nc" id="L340">        checkState();</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">        for (int i = 0; (i &lt; digests.length) &amp;&amp; (digests[i] != null); i++) {</span>
<span class="nc" id="L342">            digests[i].update(b);</span>
        }
<span class="nc" id="L344">    }</span>

    @Override
    protected void engineUpdate(byte[] b, int offset, int len) {
<span class="nc" id="L348">        checkState();</span>
<span class="nc bnc" id="L349" title="All 4 branches missed.">        for (int i = 0; (i &lt; digests.length) &amp;&amp; (digests[i] != null); i++) {</span>
<span class="nc" id="L350">            digests[i].update(b, offset, len);</span>
        }
<span class="nc" id="L352">    }</span>

    @Override
    protected byte[] engineDigest() {
<span class="nc" id="L356">        checkState();</span>
<span class="nc" id="L357">        byte[] digest = digests[0].digest();</span>
<span class="nc" id="L358">        digestReset();</span>
<span class="nc" id="L359">        return digest;</span>
    }

    @Override
    protected int engineDigest(byte[] buf, int offset, int len)
            throws DigestException {
<span class="nc" id="L365">        checkState();</span>
<span class="nc" id="L366">        int n = digests[0].digest(buf, offset, len);</span>
<span class="nc" id="L367">        digestReset();</span>
<span class="nc" id="L368">        return n;</span>
    }

    /**
     * Reset all digests after a digest() call. digests[0] has already been
     * implicitly reset by the digest() call and does not need to be reset
     * again.
     */
    private void digestReset() {
<span class="nc bnc" id="L377" title="All 4 branches missed.">        for (int i = 1; (i &lt; digests.length) &amp;&amp; (digests[i] != null); i++) {</span>
<span class="nc" id="L378">            digests[i].reset();</span>
        }
<span class="nc" id="L380">    }</span>

    @Override
    protected void engineReset() {
<span class="nc" id="L384">        checkState();</span>
<span class="nc bnc" id="L385" title="All 4 branches missed.">        for (int i = 0; (i &lt; digests.length) &amp;&amp; (digests[i] != null); i++) {</span>
<span class="nc" id="L386">            digests[i].reset();</span>
        }
<span class="nc" id="L388">    }</span>

    @Override
    public Object clone() {
<span class="nc" id="L392">        checkState();</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">        for (int i = digests.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (digests[i] != null) {</span>
<span class="nc" id="L395">                MessageDigest digest = digests[i];</span>
<span class="nc" id="L396">                digests[i] = null;</span>
<span class="nc" id="L397">                return digest;</span>
            }
        }
        // cannot occur
<span class="nc" id="L401">        throw new InternalError();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>