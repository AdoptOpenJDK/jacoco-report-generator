<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CachedRowSetReader.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">com.sun.rowset.internal</a> &gt; <span class="el_source">CachedRowSetReader.java</span></div><h1>CachedRowSetReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.rowset.internal;

import java.sql.*;
import javax.sql.*;
import javax.naming.*;
import java.io.*;
import java.lang.reflect.*;

import com.sun.rowset.*;
import javax.sql.rowset.*;
import javax.sql.rowset.spi.*;

/**
 * The facility called by the &lt;code&gt;RIOptimisticProvider&lt;/code&gt; object
 * internally to read data into it.  The calling &lt;code&gt;RowSet&lt;/code&gt; object
 * must have implemented the &lt;code&gt;RowSetInternal&lt;/code&gt; interface
 * and have the standard &lt;code&gt;CachedRowSetReader&lt;/code&gt; object set as its
 * reader.
 * &lt;P&gt;
 * This implementation always reads all rows of the data source,
 * and it assumes that the &lt;code&gt;command&lt;/code&gt; property for the caller
 * is set with a query that is appropriate for execution by a
 * &lt;code&gt;PreparedStatement&lt;/code&gt; object.
 * &lt;P&gt;
 * Typically the &lt;code&gt;SyncFactory&lt;/code&gt; manages the &lt;code&gt;RowSetReader&lt;/code&gt; and
 * the &lt;code&gt;RowSetWriter&lt;/code&gt; implementations using &lt;code&gt;SyncProvider&lt;/code&gt; objects.
 * Standard JDBC RowSet implementations provide an object instance of this
 * reader by invoking the &lt;code&gt;SyncProvider.getRowSetReader()&lt;/code&gt; method.
 *
 * @author Jonathan Bruce
 * @see javax.sql.rowset.spi.SyncProvider
 * @see javax.sql.rowset.spi.SyncFactory
 * @see javax.sql.rowset.spi.SyncFactoryException
 */
public class CachedRowSetReader implements RowSetReader, Serializable {

    /**
     * The field that keeps track of whether the writer associated with
     * this &lt;code&gt;CachedRowSetReader&lt;/code&gt; object's rowset has been called since
     * the rowset was populated.
     * &lt;P&gt;
     * When this &lt;code&gt;CachedRowSetReader&lt;/code&gt; object reads data into
     * its rowset, it sets the field &lt;code&gt;writerCalls&lt;/code&gt; to 0.
     * When the writer associated with the rowset is called to write
     * data back to the underlying data source, its &lt;code&gt;writeData&lt;/code&gt;
     * method calls the method &lt;code&gt;CachedRowSetReader.reset&lt;/code&gt;,
     * which increments &lt;code&gt;writerCalls&lt;/code&gt; and returns &lt;code&gt;true&lt;/code&gt;
     * if &lt;code&gt;writerCalls&lt;/code&gt; is 1. Thus, &lt;code&gt;writerCalls&lt;/code&gt; equals
     * 1 after the first call to &lt;code&gt;writeData&lt;/code&gt; that occurs
     * after the rowset has had data read into it.
     *
     * @serial
     */
<span class="nc" id="L79">    private int writerCalls = 0;</span>

<span class="nc" id="L81">    private boolean userCon = false;</span>

    private int startPosition;

    private JdbcRowSetResourceBundle resBundle;

<span class="nc" id="L87">    public CachedRowSetReader() {</span>
        try {
<span class="nc" id="L89">                resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();</span>
<span class="nc" id="L90">        } catch(IOException ioe) {</span>
<span class="nc" id="L91">            throw new RuntimeException(ioe);</span>
<span class="nc" id="L92">        }</span>
<span class="nc" id="L93">    }</span>


    /**
     * Reads data from a data source and populates the given
     * &lt;code&gt;RowSet&lt;/code&gt; object with that data.
     * This method is called by the rowset internally when
     * the application invokes the method &lt;code&gt;execute&lt;/code&gt;
     * to read a new set of rows.
     * &lt;P&gt;
     * After clearing the rowset of its contents, if any, and setting
     * the number of writer calls to &lt;code&gt;0&lt;/code&gt;, this reader calls
     * its &lt;code&gt;connect&lt;/code&gt; method to make
     * a connection to the rowset's data source. Depending on which
     * of the rowset's properties have been set, the &lt;code&gt;connect&lt;/code&gt;
     * method will use a &lt;code&gt;DataSource&lt;/code&gt; object or the
     * &lt;code&gt;DriverManager&lt;/code&gt; facility to make a connection to the
     * data source.
     * &lt;P&gt;
     * Once the connection to the data source is made, this reader
     * executes the query in the calling &lt;code&gt;CachedRowSet&lt;/code&gt; object's
     * &lt;code&gt;command&lt;/code&gt; property. Then it calls the rowset's
     * &lt;code&gt;populate&lt;/code&gt; method, which reads data from the
     * &lt;code&gt;ResultSet&lt;/code&gt; object produced by executing the rowset's
     * command. The rowset is then populated with this data.
     * &lt;P&gt;
     * This method's final act is to close the connection it made, thus
     * leaving the rowset disconnected from its data source.
     *
     * @param caller a &lt;code&gt;RowSet&lt;/code&gt; object that has implemented
     *               the &lt;code&gt;RowSetInternal&lt;/code&gt; interface and had
     *               this &lt;code&gt;CachedRowSetReader&lt;/code&gt; object set as
     *               its reader
     * @throws SQLException if there is a database access error, there is a
     *         problem making the connection, or the command property has not
     *         been set
     */
    public void readData(RowSetInternal caller) throws SQLException
    {
<span class="nc" id="L132">        Connection con = null;</span>
        try {
<span class="nc" id="L134">            CachedRowSet crs = (CachedRowSet)caller;</span>

            // Get rid of the current contents of the rowset.

            /**
             * Checking added to verify whether page size has been set or not.
             * If set then do not close the object as certain parameters need
             * to be maintained.
             */

<span class="nc bnc" id="L144" title="All 4 branches missed.">            if(crs.getPageSize() == 0 &amp;&amp; crs.size() &gt;0 ) {</span>
               // When page size is not set,
               // crs.size() will show the total no of rows.
<span class="nc" id="L147">               crs.close();</span>
            }

<span class="nc" id="L150">            writerCalls = 0;</span>

            // Get a connection.  This reader assumes that the necessary
            // properties have been set on the caller to let it supply a
            // connection.
<span class="nc" id="L155">            userCon = false;</span>

<span class="nc" id="L157">            con = this.connect(caller);</span>

            // Check our assumptions.
<span class="nc bnc" id="L160" title="All 4 branches missed.">            if (con == null || crs.getCommand() == null)</span>
<span class="nc" id="L161">                throw new SQLException(resBundle.handleGetObject(&quot;crsreader.connecterr&quot;).toString());</span>

            try {
<span class="nc" id="L164">                con.setTransactionIsolation(crs.getTransactionIsolation());</span>
<span class="nc" id="L165">            } catch (Exception ex) {</span>
                ;
<span class="nc" id="L167">            }</span>
            // Use JDBC to read the data.
<span class="nc" id="L169">            PreparedStatement pstmt = con.prepareStatement(crs.getCommand());</span>
            // Pass any input parameters to JDBC.

<span class="nc" id="L172">            decodeParams(caller.getParams(), pstmt);</span>
            try {
<span class="nc" id="L174">                pstmt.setMaxRows(crs.getMaxRows());</span>
<span class="nc" id="L175">                pstmt.setMaxFieldSize(crs.getMaxFieldSize());</span>
<span class="nc" id="L176">                pstmt.setEscapeProcessing(crs.getEscapeProcessing());</span>
<span class="nc" id="L177">                pstmt.setQueryTimeout(crs.getQueryTimeout());</span>
<span class="nc" id="L178">            } catch (Exception ex) {</span>
                /*
                 * drivers may not support the above - esp. older
                 * drivers being used by the bridge..
                 */
<span class="nc" id="L183">                throw new SQLException(ex.getMessage());</span>
<span class="nc" id="L184">            }</span>

<span class="nc bnc" id="L186" title="All 2 branches missed.">            if(crs.getCommand().toLowerCase().indexOf(&quot;select&quot;) != -1) {</span>
                // can be (crs.getCommand()).indexOf(&quot;select&quot;)) == 0
                // because we will be getting resultset when
                // it may be the case that some false select query with
                // select coming in between instead of first.

                // if ((crs.getCommand()).indexOf(&quot;?&quot;)) does not return -1
                // implies a Prepared Statement like query exists.

<span class="nc" id="L195">                ResultSet rs = pstmt.executeQuery();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">               if(crs.getPageSize() == 0){</span>
<span class="nc" id="L197">                      crs.populate(rs);</span>
               }
               else {
                       /**
                        * If page size has been set then create a ResultSet object that is scrollable using a
                        * PreparedStatement handle.Also call the populate(ResultSet,int) function to populate
                        * a page of data as specified by the page size.
                        */
<span class="nc" id="L205">                       pstmt = con.prepareStatement(crs.getCommand(),ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);</span>
<span class="nc" id="L206">                       decodeParams(caller.getParams(), pstmt);</span>
                       try {
<span class="nc" id="L208">                               pstmt.setMaxRows(crs.getMaxRows());</span>
<span class="nc" id="L209">                               pstmt.setMaxFieldSize(crs.getMaxFieldSize());</span>
<span class="nc" id="L210">                               pstmt.setEscapeProcessing(crs.getEscapeProcessing());</span>
<span class="nc" id="L211">                               pstmt.setQueryTimeout(crs.getQueryTimeout());</span>
<span class="nc" id="L212">                           } catch (Exception ex) {</span>
                          /*
                           * drivers may not support the above - esp. older
                           * drivers being used by the bridge..
                           */
<span class="nc" id="L217">                            throw new SQLException(ex.getMessage());</span>
<span class="nc" id="L218">                          }</span>
<span class="nc" id="L219">                       rs = pstmt.executeQuery();</span>
<span class="nc" id="L220">                       crs.populate(rs,startPosition);</span>
               }
<span class="nc" id="L222">                rs.close();</span>
<span class="nc" id="L223">            } else  {</span>
<span class="nc" id="L224">                pstmt.executeUpdate();</span>
            }

            // Get the data.
<span class="nc" id="L228">            pstmt.close();</span>
            try {
<span class="nc" id="L230">                con.commit();</span>
<span class="nc" id="L231">            } catch (SQLException ex) {</span>
                ;
<span class="nc" id="L233">            }</span>
            // only close connections we created...
<span class="nc bnc" id="L235" title="All 2 branches missed.">            if (getCloseConnection() == true)</span>
<span class="nc" id="L236">                con.close();</span>
        }
<span class="nc" id="L238">        catch (SQLException ex) {</span>
            // Throw an exception if reading fails for any reason.
<span class="nc" id="L240">            throw ex;</span>
        } finally {
<span class="nc" id="L242">            try {</span>
                // only close connections we created...
<span class="nc bnc" id="L244" title="All 8 branches missed.">                if (con != null &amp;&amp; getCloseConnection() == true) {</span>
                    try {
<span class="nc bnc" id="L246" title="All 4 branches missed.">                        if (!con.getAutoCommit()) {</span>
<span class="nc" id="L247">                            con.rollback();</span>
                        }
<span class="nc" id="L249">                    } catch (Exception dummy) {</span>
                        /*
                         * not an error condition, we're closing anyway, but
                         * we'd like to clean up any locks if we can since
                         * it is not clear the connection pool will clean
                         * these connections in a timely manner
                         */
<span class="nc" id="L256">                    }</span>
<span class="nc" id="L257">                    con.close();</span>
<span class="nc" id="L258">                    con = null;</span>
                }
<span class="nc" id="L260">            } catch (SQLException e) {</span>
                // will get exception if something already went wrong, but don't
                // override that exception with this one
<span class="nc" id="L263">            }</span>
<span class="nc" id="L264">        }</span>
<span class="nc" id="L265">    }</span>

    /**
     * Checks to see if the writer associated with this reader needs
     * to reset its state.  The writer will need to initialize its state
     * if new contents have been read since the writer was last called.
     * This method is called by the writer that was registered with
     * this reader when components were being wired together.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if writer associated with this reader needs
     *         to reset the values of its fields; &lt;code&gt;false&lt;/code&gt; otherwise
     * @throws SQLException if an access error occurs
     */
    public boolean reset() throws SQLException {
<span class="nc" id="L279">        writerCalls++;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        return writerCalls == 1;</span>
    }

    /**
     * Establishes a connection with the data source for the given
     * &lt;code&gt;RowSet&lt;/code&gt; object.  If the rowset's &lt;code&gt;dataSourceName&lt;/code&gt;
     * property has been set, this method uses the JNDI API to retrieve the
     * &lt;code&gt;DataSource&lt;/code&gt; object that it can use to make the connection.
     * If the url, username, and password properties have been set, this
     * method uses the &lt;code&gt;DriverManager.getConnection&lt;/code&gt; method to
     * make the connection.
     * &lt;P&gt;
     * This method is used internally by the reader and writer associated with
     * the calling &lt;code&gt;RowSet&lt;/code&gt; object; an application never calls it
     * directly.
     *
     * @param caller a &lt;code&gt;RowSet&lt;/code&gt; object that has implemented
     *               the &lt;code&gt;RowSetInternal&lt;/code&gt; interface and had
     *               this &lt;code&gt;CachedRowSetReader&lt;/code&gt; object set as
     *               its reader
     * @return a &lt;code&gt;Connection&lt;/code&gt; object that represents a connection
     *         to the caller's data source
     * @throws SQLException if an access error occurs
     */
    public Connection connect(RowSetInternal caller) throws SQLException {

        // Get a JDBC connection.
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (caller.getConnection() != null) {</span>
            // A connection was passed to execute(), so use it.
            // As we are using a connection the user gave us we
            // won't close it.
<span class="nc" id="L311">            userCon = true;</span>
<span class="nc" id="L312">            return caller.getConnection();</span>
        }
<span class="nc bnc" id="L314" title="All 2 branches missed.">        else if (((RowSet)caller).getDataSourceName() != null) {</span>
            // Connect using JNDI.
            try {
<span class="nc" id="L317">                Context ctx = new InitialContext();</span>
<span class="nc" id="L318">                DataSource ds = (DataSource)ctx.lookup</span>
<span class="nc" id="L319">                    (((RowSet)caller).getDataSourceName());</span>

                // Check for username, password,
                // if it exists try getting a Connection handle through them
                // else try without these
                // else throw SQLException

<span class="nc bnc" id="L326" title="All 2 branches missed.">                if(((RowSet)caller).getUsername() != null) {</span>
<span class="nc" id="L327">                     return ds.getConnection(((RowSet)caller).getUsername(),</span>
<span class="nc" id="L328">                                            ((RowSet)caller).getPassword());</span>
                } else {
<span class="nc" id="L330">                     return ds.getConnection();</span>
                }
            }
<span class="nc" id="L333">            catch (javax.naming.NamingException ex) {</span>
<span class="nc" id="L334">                SQLException sqlEx = new SQLException(resBundle.handleGetObject(&quot;crsreader.connect&quot;).toString());</span>
<span class="nc" id="L335">                sqlEx.initCause(ex);</span>
<span class="nc" id="L336">                throw sqlEx;</span>
            }
<span class="nc bnc" id="L338" title="All 2 branches missed.">        } else if (((RowSet)caller).getUrl() != null) {</span>
            // Connect using the driver manager.
<span class="nc" id="L340">            return DriverManager.getConnection(((RowSet)caller).getUrl(),</span>
<span class="nc" id="L341">                                               ((RowSet)caller).getUsername(),</span>
<span class="nc" id="L342">                                               ((RowSet)caller).getPassword());</span>
        }
        else {
<span class="nc" id="L345">            return null;</span>
        }
    }

    /**
     * Sets the parameter placeholders
     * in the rowset's command (the given &lt;code&gt;PreparedStatement&lt;/code&gt;
     * object) with the parameters in the given array.
     * This method, called internally by the method
     * &lt;code&gt;CachedRowSetReader.readData&lt;/code&gt;, reads each parameter, and
     * based on its type, determines the correct
     * &lt;code&gt;PreparedStatement.setXXX&lt;/code&gt; method to use for setting
     * that parameter.
     *
     * @param params an array of parameters to be used with the given
     *               &lt;code&gt;PreparedStatement&lt;/code&gt; object
     * @param pstmt  the &lt;code&gt;PreparedStatement&lt;/code&gt; object that is the
     *               command for the calling rowset and into which
     *               the given parameters are to be set
     * @throws SQLException if an access error occurs
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    private void decodeParams(Object[] params,
                              PreparedStatement pstmt) throws SQLException {
    // There is a corresponding decodeParams in JdbcRowSetImpl
    // which does the same as this method. This is a design flaw.
    // Update the JdbcRowSetImpl.decodeParams when you update
    // this method.

    // Adding the same comments to JdbcRowSetImpl.decodeParams.

        int arraySize;
<span class="nc" id="L377">        Object[] param = null;</span>

<span class="nc bnc" id="L379" title="All 2 branches missed.">        for (int i=0; i &lt; params.length; i++) {</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            if (params[i] instanceof Object[]) {</span>
<span class="nc" id="L381">                param = (Object[])params[i];</span>

<span class="nc bnc" id="L383" title="All 2 branches missed.">                if (param.length == 2) {</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">                    if (param[0] == null) {</span>
<span class="nc" id="L385">                        pstmt.setNull(i + 1, ((Integer)param[1]).intValue());</span>
<span class="nc" id="L386">                        continue;</span>
                    }

<span class="nc bnc" id="L389" title="All 6 branches missed.">                    if (param[0] instanceof java.sql.Date ||</span>
                        param[0] instanceof java.sql.Time ||
                        param[0] instanceof java.sql.Timestamp) {
<span class="nc" id="L392">                        System.err.println(resBundle.handleGetObject(&quot;crsreader.datedetected&quot;).toString());</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">                        if (param[1] instanceof java.util.Calendar) {</span>
<span class="nc" id="L394">                            System.err.println(resBundle.handleGetObject(&quot;crsreader.caldetected&quot;).toString());</span>
<span class="nc" id="L395">                            pstmt.setDate(i + 1, (java.sql.Date)param[0],</span>
                                       (java.util.Calendar)param[1]);
<span class="nc" id="L397">                            continue;</span>
                        }
                        else {
<span class="nc" id="L400">                            throw new SQLException(resBundle.handleGetObject(&quot;crsreader.paramtype&quot;).toString());</span>
                        }
                    }

<span class="nc bnc" id="L404" title="All 2 branches missed.">                    if (param[0] instanceof Reader) {</span>
<span class="nc" id="L405">                        pstmt.setCharacterStream(i + 1, (Reader)param[0],</span>
<span class="nc" id="L406">                                              ((Integer)param[1]).intValue());</span>
<span class="nc" id="L407">                        continue;</span>
                    }

                    /*
                     * What's left should be setObject(int, Object, scale)
                     */
<span class="nc bnc" id="L413" title="All 2 branches missed.">                    if (param[1] instanceof Integer) {</span>
<span class="nc" id="L414">                        pstmt.setObject(i + 1, param[0], ((Integer)param[1]).intValue());</span>
<span class="nc" id="L415">                        continue;</span>
                    }

<span class="nc bnc" id="L418" title="All 2 branches missed.">                } else if (param.length == 3) {</span>

<span class="nc bnc" id="L420" title="All 2 branches missed.">                    if (param[0] == null) {</span>
<span class="nc" id="L421">                        pstmt.setNull(i + 1, ((Integer)param[1]).intValue(),</span>
                                   (String)param[2]);
<span class="nc" id="L423">                        continue;</span>
                    }

<span class="nc bnc" id="L426" title="All 2 branches missed.">                    if (param[0] instanceof java.io.InputStream) {</span>
<span class="nc bnc" id="L427" title="All 4 branches missed.">                        switch (((Integer)param[2]).intValue()) {</span>
                        case CachedRowSetImpl.UNICODE_STREAM_PARAM:
<span class="nc" id="L429">                            pstmt.setUnicodeStream(i + 1,</span>
                                                (java.io.InputStream)param[0],
<span class="nc" id="L431">                                                ((Integer)param[1]).intValue());</span>
<span class="nc" id="L432">                            break;</span>
                        case CachedRowSetImpl.BINARY_STREAM_PARAM:
<span class="nc" id="L434">                            pstmt.setBinaryStream(i + 1,</span>
                                               (java.io.InputStream)param[0],
<span class="nc" id="L436">                                               ((Integer)param[1]).intValue());</span>
<span class="nc" id="L437">                            break;</span>
                        case CachedRowSetImpl.ASCII_STREAM_PARAM:
<span class="nc" id="L439">                            pstmt.setAsciiStream(i + 1,</span>
                                              (java.io.InputStream)param[0],
<span class="nc" id="L441">                                              ((Integer)param[1]).intValue());</span>
<span class="nc" id="L442">                            break;</span>
                        default:
<span class="nc" id="L444">                            throw new SQLException(resBundle.handleGetObject(&quot;crsreader.paramtype&quot;).toString());</span>
                        }
                    }

                    /*
                     * no point at looking at the first element now;
                     * what's left must be the setObject() cases.
                     */
<span class="nc bnc" id="L452" title="All 4 branches missed.">                    if (param[1] instanceof Integer &amp;&amp; param[2] instanceof Integer) {</span>
<span class="nc" id="L453">                        pstmt.setObject(i + 1, param[0], ((Integer)param[1]).intValue(),</span>
<span class="nc" id="L454">                                     ((Integer)param[2]).intValue());</span>
<span class="nc" id="L455">                        continue;</span>
                    }

<span class="nc" id="L458">                    throw new SQLException(resBundle.handleGetObject(&quot;crsreader.paramtype&quot;).toString());</span>

                } else {
                    // common case - this catches all SQL92 types
<span class="nc" id="L462">                    pstmt.setObject(i + 1, params[i]);</span>
<span class="nc" id="L463">                    continue;</span>
                }
            }  else {
               // Try to get all the params to be set here
<span class="nc" id="L467">               pstmt.setObject(i + 1, params[i]);</span>

            }
        }
<span class="nc" id="L471">    }</span>

    /**
     * Assists in determining whether the current connection was created by this
     * CachedRowSet to ensure incorrect connections are not prematurely terminated.
     *
     * @return a boolean giving the status of whether the connection has been closed.
     */
    protected boolean getCloseConnection() {
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (userCon == true)</span>
<span class="nc" id="L481">            return false;</span>

<span class="nc" id="L483">        return true;</span>
    }

    /**
     *  This sets the start position in the ResultSet from where to begin. This is
     * called by the Reader in the CachedRowSetImpl to set the position on the page
     * to begin populating from.
     * @param pos integer indicating the position in the &lt;code&gt;ResultSet&lt;/code&gt; to begin
     *        populating from.
     */
    public void setStartPosition(int pos){
<span class="nc" id="L494">        startPosition = pos;</span>
<span class="nc" id="L495">    }</span>

    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        // Default state initialization happens here
<span class="nc" id="L499">        ois.defaultReadObject();</span>
        // Initialization of  Res Bundle happens here .
        try {
<span class="nc" id="L502">           resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();</span>
<span class="nc" id="L503">        } catch(IOException ioe) {</span>
<span class="nc" id="L504">            throw new RuntimeException(ioe);</span>
<span class="nc" id="L505">        }</span>

<span class="nc" id="L507">    }</span>

    static final long serialVersionUID =5049738185801363801L;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>