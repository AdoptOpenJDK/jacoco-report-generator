<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>XmlReaderContentHandler.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.rowset.internal</a> &gt; <span class="el_source">XmlReaderContentHandler.java</span></div><h1>XmlReaderContentHandler.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.rowset.internal;

import java.util.*;

import org.xml.sax.*;
import org.xml.sax.helpers.*;

import java.sql.*;
import javax.sql.*;

import javax.sql.rowset.*;
import com.sun.rowset.*;
import java.io.IOException;
import java.text.MessageFormat;

/**
 * The document handler that receives parse events that an XML parser sends while it
 * is parsing an XML document representing a &lt;code&gt;WebRowSet&lt;/code&gt; object. The
 * parser sends strings to this &lt;code&gt;XmlReaderContentHandler&lt;/code&gt; and then uses
 * these strings as arguments for the &lt;code&gt;XmlReaderContentHandler&lt;/code&gt; methods
 * it invokes. The final goal of the SAX parser working with an
 * &lt;code&gt;XmlReaderContentHandler&lt;/code&gt; object is to read an XML document that represents
 * a &lt;code&gt;RowSet&lt;/code&gt; object.
 * &lt;P&gt;
 * A rowset consists of its properties, metadata, and data values. An XML document
 * representating a rowset includes the values in these three categories along with
 * appropriate XML tags to identify them.  It also includes a top-level XML tag for
 * the rowset and three section tags identifying the three categories of values.
 * &lt;P&gt;
 * The tags in an XML document are hierarchical.
 * This means that the top-level tag, &lt;code&gt;RowSet&lt;/code&gt;, is
 * followed by the three sections with appropriate tags, which are in turn each
 * followed by their constituent elements. For example, the &lt;code&gt;properties&lt;/code&gt;
 * element will be followed by an element for each of the properties listed in
 * in this &lt;code&gt;XmlReaderContentHandler&lt;/code&gt; object's &lt;code&gt;properties&lt;/code&gt;
 * field.  The content of the other two fields, &lt;code&gt;colDef&lt;/code&gt;, which lists
 * the rowset's metadata elements, and &lt;code&gt;data&lt;/code&gt;, which lists the rowset's data
 * elements, are handled similarly .
 * &lt;P&gt;
 * This implementation of &lt;code&gt;XmlReaderContentHandler&lt;/code&gt; provides the means for the
 * parser to determine which elements need to have a value set and then to set
 * those values. The methods in this class are all called by the parser; an
 * application programmer never calls them directly.
 *
 */

public class XmlReaderContentHandler extends DefaultHandler {

    private HashMap &lt;String, Integer&gt; propMap;
    private HashMap &lt;String, Integer&gt; colDefMap;
    private HashMap &lt;String, Integer&gt; dataMap;

    private HashMap&lt;String,Class&lt;?&gt;&gt; typeMap;

    private Vector&lt;Object[]&gt; updates;
    private Vector&lt;String&gt; keyCols;

    private String columnValue;
    private String propertyValue;
    private String metaDataValue;

    private int tag;
    private int state;

    private WebRowSetImpl rs;
    private boolean nullVal;
    private boolean emptyStringVal;
    private RowSetMetaData md;
    private int idx;
    private String lastval;
    private String Key_map;
    private String Value_map;
    private String tempStr;
    private String tempUpdate;
    private String tempCommand;
    private Object [] upd;

    /**
     * A list of the properties for a rowset. There is a constant defined to
     * correspond to each of these properties so that a &lt;code&gt;HashMap&lt;/code&gt;
     * object can be created to map the properties, which are strings, to
     * the constants, which are integers.
     */
<span class="nc" id="L109">    private String [] properties = {&quot;command&quot;, &quot;concurrency&quot;, &quot;datasource&quot;,</span>
                            &quot;escape-processing&quot;, &quot;fetch-direction&quot;, &quot;fetch-size&quot;,
                            &quot;isolation-level&quot;, &quot;key-columns&quot;, &quot;map&quot;,
                            &quot;max-field-size&quot;, &quot;max-rows&quot;, &quot;query-timeout&quot;,
                            &quot;read-only&quot;, &quot;rowset-type&quot;, &quot;show-deleted&quot;,
                            &quot;table-name&quot;, &quot;url&quot;, &quot;null&quot;, &quot;column&quot;, &quot;type&quot;,
                            &quot;class&quot;, &quot;sync-provider&quot;, &quot;sync-provider-name&quot;,
                             &quot;sync-provider-vendor&quot;, &quot;sync-provider-version&quot;,
                             &quot;sync-provider-grade&quot;,&quot;data-source-lock&quot;};

    /**
     * A constant representing the tag for the command property.
     */
    private final static int CommandTag = 0;

    /**
     * A constant representing the tag for the concurrency property.
     */
    private final static int ConcurrencyTag = 1;

    /**
     * A constant representing the tag for the datasource property.
     */
    private final static int DatasourceTag = 2;

    /**
     * A constant representing the tag for the escape-processing property.
     */
    private final static int EscapeProcessingTag = 3;

    /**
     * A constant representing the tag for the fetch-direction property.
     */
    private final static int FetchDirectionTag = 4;

    /**
     * A constant representing the tag for the fetch-size property.
     */
    private final static int FetchSizeTag = 5;

    /**
     * A constant representing the tag for the isolation-level property
     */
    private final static int IsolationLevelTag = 6;

    /**
     * A constant representing the tag for the key-columns property.
     */
    private final static int KeycolsTag = 7;

    /**
     * A constant representing the tag for the map property.
     * This map is the type map that specifies the custom mapping
     * for an SQL user-defined type.
     */
    private final static int MapTag = 8;

    /**
     * A constant representing the tag for the max-field-size property.
     */
    private final static int MaxFieldSizeTag = 9;

    /**
     * A constant representing the tag for the max-rows property.
     */
    private final static int MaxRowsTag = 10;

    /**
     * A constant representing the tag for the query-timeout property.
     */
    private final static int QueryTimeoutTag = 11;

    /**
     * A constant representing the tag for the read-only property.
     */
    private final static int ReadOnlyTag = 12;

    /**
     * A constant representing the tag for the rowset-type property.
     */
    private final static int RowsetTypeTag = 13;

    /**
     * A constant representing the tag for the show-deleted property.
     */
    private final static int ShowDeletedTag = 14;

    /**
     * A constant representing the tag for the table-name property.
     */
    private final static int TableNameTag = 15;

    /**
     * A constant representing the tag for the URL property.
     */
    private final static int UrlTag = 16;

    /**
     * A constant representing the tag for the null property.
     */
    private final static int PropNullTag = 17;

    /**
     * A constant representing the tag for the column property.
     */
    private final static int PropColumnTag = 18;

    /**
     * A constant representing the tag for the type property.
     */
    private final static int PropTypeTag = 19;

    /**
     * A constant representing the tag for the class property.
     */
    private final static int PropClassTag = 20;

    /**
     * A constant representing the tag for the sync-provider.
     */
    private final static int SyncProviderTag = 21;

    /**
     * A constant representing the tag for the sync-provider
     * name
     */
    private final static int SyncProviderNameTag = 22;

    /**
     * A constant representing the tag for the sync-provider
     * vendor tag.
     */
    private final static int SyncProviderVendorTag = 23;

    /**
     * A constant representing the tag for the sync-provider
     * version tag.
     */
    private final static int SyncProviderVersionTag = 24;

    /**
     * A constant representing the tag for the sync-provider
     * grade tag.
     */
    private final static int SyncProviderGradeTag = 25;

    /**
     * A constant representing the tag for the data source lock.
     */
    private final static int DataSourceLock = 26;

    /**
     * A listing of the kinds of metadata information available about
     * the columns in a &lt;code&gt;WebRowSet&lt;/code&gt; object.
     */
<span class="nc" id="L264">    private String [] colDef = {&quot;column-count&quot;, &quot;column-definition&quot;, &quot;column-index&quot;,</span>
                        &quot;auto-increment&quot;, &quot;case-sensitive&quot;, &quot;currency&quot;,
                        &quot;nullable&quot;, &quot;signed&quot;, &quot;searchable&quot;,
                        &quot;column-display-size&quot;, &quot;column-label&quot;, &quot;column-name&quot;,
                        &quot;schema-name&quot;, &quot;column-precision&quot;, &quot;column-scale&quot;,
                        &quot;table-name&quot;, &quot;catalog-name&quot;, &quot;column-type&quot;,
                        &quot;column-type-name&quot;, &quot;null&quot;};


    /**
     * A constant representing the tag for column-count.
     */
    private final static int ColumnCountTag = 0;

    /**
     * A constant representing the tag for column-definition.
     */
    private final static int ColumnDefinitionTag = 1;

    /**
     * A constant representing the tag for column-index.
     */
    private final static int ColumnIndexTag = 2;

    /**
     * A constant representing the tag for auto-increment.
     */
    private final static int AutoIncrementTag = 3;

    /**
     * A constant representing the tag for case-sensitive.
     */
    private final static int CaseSensitiveTag = 4;

    /**
     * A constant representing the tag for currency.
     */
    private final static int CurrencyTag = 5;

    /**
     * A constant representing the tag for nullable.
     */
    private final static int NullableTag = 6;

    /**
     * A constant representing the tag for signed.
     */
    private final static int SignedTag = 7;

    /**
     * A constant representing the tag for searchable.
     */
    private final static int SearchableTag = 8;

    /**
     * A constant representing the tag for column-display-size.
     */
    private final static int ColumnDisplaySizeTag = 9;

    /**
     * A constant representing the tag for column-label.
     */
    private final static int ColumnLabelTag = 10;

    /**
     * A constant representing the tag for column-name.
     */
    private final static int ColumnNameTag = 11;

    /**
     * A constant representing the tag for schema-name.
     */
    private final static int SchemaNameTag = 12;

    /**
     * A constant representing the tag for column-precision.
     */
    private final static int ColumnPrecisionTag = 13;

    /**
     * A constant representing the tag for column-scale.
     */
    private final static int ColumnScaleTag = 14;

    /**
     * A constant representing the tag for table-name.
     */
    private final static int MetaTableNameTag = 15;

    /**
     * A constant representing the tag for catalog-name.
     */
    private final static int CatalogNameTag = 16;

    /**
     * A constant representing the tag for column-type.
     */
    private final static int ColumnTypeTag = 17;

    /**
     * A constant representing the tag for column-type-name.
     */
    private final static int ColumnTypeNameTag = 18;

    /**
     * A constant representing the tag for null.
     */
    private final static int MetaNullTag = 19;

<span class="nc" id="L373">    private String [] data = {&quot;currentRow&quot;, &quot;columnValue&quot;, &quot;insertRow&quot;, &quot;deleteRow&quot;, &quot;insdel&quot;, &quot;updateRow&quot;, &quot;null&quot; , &quot;emptyString&quot;};</span>

    private final static int RowTag = 0;
    private final static int ColTag = 1;
    private final static int InsTag = 2;
    private final static int DelTag = 3;
    private final static int InsDelTag = 4;
    private final static int UpdTag = 5;
    private final static int NullTag = 6;
    private final static int EmptyStringTag = 7;

    /**
     * A constant indicating the state of this &lt;code&gt;XmlReaderContentHandler&lt;/code&gt;
     * object in which it has not yet been called by the SAX parser and therefore
     * has no indication of what type of input to expect from the parser next.
     * &lt;P&gt;
     * The state is set to &lt;code&gt;INITIAL&lt;/code&gt; at the end of each
     * section, which allows the sections to appear in any order and
     * still be parsed correctly (except that metadata must be
     * set before data values can be set).
     */
    private final static int INITIAL = 0;

    /**
     * A constant indicating the state in which this &lt;code&gt;XmlReaderContentHandler&lt;/code&gt;
     * object expects the next input received from the
     * SAX parser to be a string corresponding to one of the elements in
     * &lt;code&gt;properties&lt;/code&gt;.
     */
    private final static int PROPERTIES = 1;

    /**
     * A constant indicating the state in which this &lt;code&gt;XmlReaderContentHandler&lt;/code&gt;
     * object expects the next input received from the
     * SAX parser to be a string corresponding to one of the elements in
     * &lt;code&gt;colDef&lt;/code&gt;.
     */
    private final static int METADATA = 2;

    /**
     * A constant indicating the state in which this &lt;code&gt;XmlReaderContentHandler&lt;/code&gt;
     * object expects the next input received from the
     * SAX parser to be a string corresponding to one of the elements in
     * &lt;code&gt;data&lt;/code&gt;.
     */
    private final static int DATA = 3;

    private  JdbcRowSetResourceBundle resBundle;

    /**
     * Constructs a new &lt;code&gt;XmlReaderContentHandler&lt;/code&gt; object that will
     * assist the SAX parser in reading a &lt;code&gt;WebRowSet&lt;/code&gt; object in the
     * format of an XML document. In addition to setting some default values,
     * this constructor creates three &lt;code&gt;HashMap&lt;/code&gt; objects, one for
     * properties, one for metadata, and one for data.  These hash maps map the
     * strings sent by the SAX parser to integer constants so that they can be
     * compared more efficiently in &lt;code&gt;switch&lt;/code&gt; statements.
     *
     * @param r the &lt;code&gt;RowSet&lt;/code&gt; object in XML format that will be read
     */
<span class="nc" id="L433">    public XmlReaderContentHandler(RowSet r) {</span>
        // keep the rowset we've been given
<span class="nc" id="L435">        rs = (WebRowSetImpl)r;</span>

        // set-up the token maps
<span class="nc" id="L438">        initMaps();</span>

        // allocate the collection for the updates
<span class="nc" id="L441">        updates = new Vector&lt;&gt;();</span>

        // start out with the empty string
<span class="nc" id="L444">        columnValue = &quot;&quot;;</span>
<span class="nc" id="L445">        propertyValue = &quot;&quot;;</span>
<span class="nc" id="L446">        metaDataValue = &quot;&quot;;</span>

<span class="nc" id="L448">        nullVal = false;</span>
<span class="nc" id="L449">        idx = 0;</span>
<span class="nc" id="L450">        tempStr = &quot;&quot;;</span>
<span class="nc" id="L451">        tempUpdate = &quot;&quot;;</span>
<span class="nc" id="L452">        tempCommand = &quot;&quot;;</span>

        try {
<span class="nc" id="L455">           resBundle = JdbcRowSetResourceBundle.getJdbcRowSetResourceBundle();</span>
<span class="nc" id="L456">        } catch(IOException ioe) {</span>
<span class="nc" id="L457">            throw new RuntimeException(ioe);</span>
<span class="nc" id="L458">        }</span>
<span class="nc" id="L459">    }</span>

    /**
     * Creates and initializes three new &lt;code&gt;HashMap&lt;/code&gt; objects that map
     * the strings returned by the SAX parser to &lt;code&gt;Integer&lt;/code&gt;
     * objects.  The strings returned by the parser will match the strings that
     * are array elements in this &lt;code&gt;XmlReaderContentHandler&lt;/code&gt; object's
     * &lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;colDef&lt;/code&gt;, or &lt;code&gt;data&lt;/code&gt;
     * fields. For each array element in these fields, there is a corresponding
     * constant defined. It is to these constants that the strings are mapped.
     * In the &lt;code&gt;HashMap&lt;/code&gt; objects, the string is the key, and the
     * integer is the value.
     * &lt;P&gt;
     * The purpose of the mapping is to make comparisons faster.  Because comparing
     * numbers is more efficient than comparing strings, the strings returned
     * by the parser are mapped to integers, which can then be used in a
     * &lt;code&gt;switch&lt;/code&gt; statement.
     */
    private void initMaps() {
        int items, i;

<span class="nc" id="L480">        propMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L481">        items = properties.length;</span>

<span class="nc bnc" id="L483" title="All 2 branches missed.">        for (i=0;i&lt;items;i++) {</span>
<span class="nc" id="L484">            propMap.put(properties[i], Integer.valueOf(i));</span>
        }

<span class="nc" id="L487">        colDefMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L488">        items = colDef.length;</span>

<span class="nc bnc" id="L490" title="All 2 branches missed.">        for (i=0;i&lt;items;i++) {</span>
<span class="nc" id="L491">            colDefMap.put(colDef[i], Integer.valueOf(i));</span>
        }

<span class="nc" id="L494">        dataMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L495">        items = data.length;</span>

<span class="nc bnc" id="L497" title="All 2 branches missed.">        for (i=0;i&lt;items;i++) {</span>
<span class="nc" id="L498">            dataMap.put(data[i], Integer.valueOf(i));</span>
        }

        //Initialize connection map here
<span class="nc" id="L502">        typeMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L503">    }</span>

    public void startDocument() throws SAXException {
<span class="nc" id="L506">    }</span>

    public void endDocument() throws SAXException {
<span class="nc" id="L509">    }</span>


    /**
     * Sets this &lt;code&gt;XmlReaderContentHandler&lt;/code&gt; object's &lt;code&gt;tag&lt;/code&gt;
     * field if the given name is the key for a tag and this object's state
     * is not &lt;code&gt;INITIAL&lt;/code&gt;.  The field is set
     * to the constant that corresponds to the given element name.
     * If the state is &lt;code&gt;INITIAL&lt;/code&gt;, the state is set to the given
     * name, which will be one of the sections &lt;code&gt;PROPERTIES&lt;/code&gt;,
     * &lt;code&gt;METADATA&lt;/code&gt;, or &lt;code&gt;DATA&lt;/code&gt;.  In either case, this
     * method puts this document handler in the proper state for calling
     * the method &lt;code&gt;endElement&lt;/code&gt;.
     * &lt;P&gt;
     * If the state is &lt;code&gt;DATA&lt;/code&gt; and the tag is &lt;code&gt;RowTag&lt;/code&gt;,
     * &lt;code&gt;DelTag&lt;/code&gt;, or &lt;code&gt;InsTag&lt;/code&gt;, this method moves the
     * rowset's cursor to the insert row and sets this
     * &lt;code&gt;XmlReaderContentHandler&lt;/code&gt; object's &lt;code&gt;idx&lt;/code&gt;
     * field to &lt;code&gt;0&lt;/code&gt; so that it will be in the proper
     * state when the parser calls the method &lt;code&gt;endElement&lt;/code&gt;.
     *
     * @param lName the name of the element; either (1) one of the array
     *        elements in the fields &lt;code&gt;properties&lt;/code&gt;,
     *        &lt;code&gt;colDef&lt;/code&gt;, or &lt;code&gt;data&lt;/code&gt; or
     *        (2) one of the &lt;code&gt;RowSet&lt;/code&gt; elements
     *        &lt;code&gt;&quot;properties&quot;&lt;/code&gt;, &lt;code&gt;&quot;metadata&quot;&lt;/code&gt;, or
     *        &lt;code&gt;&quot;data&quot;&lt;/code&gt;
     * @param attributes &lt;code&gt;org.xml.sax.AttributeList&lt;/code&gt; objects that are
     *             attributes of the named section element; may be &lt;code&gt;null&lt;/code&gt;
     *             if there are no attributes, which is the case for
     *             &lt;code&gt;WebRowSet&lt;/code&gt; objects
     * @exception SAXException if a general SAX error occurs
     */
    public void startElement(String uri, String lName, String qName, Attributes attributes) throws SAXException {
        int tag;
<span class="nc" id="L544">        String name = &quot;&quot;;</span>

<span class="nc" id="L546">        name = lName;</span>

<span class="nc bnc" id="L548" title="All 4 branches missed.">        switch (getState()) {</span>
        case PROPERTIES:

<span class="nc" id="L551">            tempCommand = &quot;&quot;;</span>
<span class="nc" id="L552">            tag = propMap.get(name);</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">            if (tag == PropNullTag)</span>
<span class="nc" id="L554">               setNullValue(true);</span>
            else
<span class="nc" id="L556">                setTag(tag);</span>
<span class="nc" id="L557">            break;</span>
        case METADATA:
<span class="nc" id="L559">            tag = colDefMap.get(name);</span>

<span class="nc bnc" id="L561" title="All 2 branches missed.">            if (tag == MetaNullTag)</span>
<span class="nc" id="L562">                setNullValue(true);</span>
            else
<span class="nc" id="L564">                setTag(tag);</span>
<span class="nc" id="L565">            break;</span>
        case DATA:

            /**
              * This has been added to clear out the values of the previous read
              * so that we should not add up values of data between different tags
              */
<span class="nc" id="L572">            tempStr = &quot;&quot;;</span>
<span class="nc" id="L573">            tempUpdate = &quot;&quot;;</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            if(dataMap.get(name) == null) {</span>
<span class="nc" id="L575">                tag = NullTag;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">            } else if(dataMap.get(name) == EmptyStringTag) {</span>
<span class="nc" id="L577">                tag = EmptyStringTag;</span>
            } else {
<span class="nc" id="L579">                 tag = dataMap.get(name);</span>
            }

<span class="nc bnc" id="L582" title="All 2 branches missed.">            if (tag == NullTag) {</span>
<span class="nc" id="L583">                setNullValue(true);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            } else if(tag == EmptyStringTag) {</span>
<span class="nc" id="L585">                setEmptyStringValue(true);</span>
            } else {
<span class="nc" id="L587">                setTag(tag);</span>

<span class="nc bnc" id="L589" title="All 6 branches missed.">                if (tag == RowTag || tag == DelTag || tag == InsTag) {</span>
<span class="nc" id="L590">                    idx = 0;</span>
                    try {
<span class="nc" id="L592">                        rs.moveToInsertRow();</span>
<span class="nc" id="L593">                    } catch (SQLException ex) {</span>
                        ;
<span class="nc" id="L595">                    }</span>
                }
            }

            break;
        default:
<span class="nc" id="L601">            setState(name);</span>
        }

<span class="nc" id="L604">    }</span>

    /**
     * Sets the value for the given element if &lt;code&gt;name&lt;/code&gt; is one of
     * the array elements in the fields &lt;code&gt;properties&lt;/code&gt;,
     * &lt;code&gt;colDef&lt;/code&gt;, or &lt;code&gt;data&lt;/code&gt; and this
     * &lt;code&gt;XmlReaderContentHandler&lt;/code&gt; object's state is not
     * &lt;code&gt;INITIAL&lt;/code&gt;. If the state is &lt;code&gt;INITIAL&lt;/code&gt;,
     * this method does nothing.
     * &lt;P&gt;
     * If the state is &lt;code&gt;METADATA&lt;/code&gt; and
     * the argument supplied is &lt;code&gt;&quot;metadata&quot;&lt;/code&gt;, the rowset's
     * metadata is set. If the state is &lt;code&gt;PROPERTIES&lt;/code&gt;, the
     * appropriate property is set using the given name to determine
     * the appropriate value. If the state is &lt;code&gt;DATA&lt;/code&gt; and
     * the argument supplied is &lt;code&gt;&quot;data&quot;&lt;/code&gt;, this method sets
     * the state to &lt;code&gt;INITIAL&lt;/code&gt; and returns.  If the argument
     * supplied is one of the elements in the field &lt;code&gt;data&lt;/code&gt;,
     * this method makes the appropriate changes to the rowset's data.
     *
     * @param lName the name of the element; either (1) one of the array
     *        elements in the fields &lt;code&gt;properties&lt;/code&gt;,
     *        &lt;code&gt;colDef&lt;/code&gt;, or &lt;code&gt;data&lt;/code&gt; or
     *        (2) one of the &lt;code&gt;RowSet&lt;/code&gt; elements
     *        &lt;code&gt;&quot;properties&quot;&lt;/code&gt;, &lt;code&gt;&quot;metadata&quot;&lt;/code&gt;, or
     *        &lt;code&gt;&quot;data&quot;&lt;/code&gt;
     *
     * @exception SAXException if a general SAX error occurs
     */
    @SuppressWarnings(&quot;fallthrough&quot;)
    public void endElement(String uri, String lName, String qName) throws SAXException {
        int tag;

<span class="nc" id="L637">        String name = &quot;&quot;;</span>
<span class="nc" id="L638">        name = lName;</span>

<span class="nc bnc" id="L640" title="All 4 branches missed.">        switch (getState()) {</span>
        case PROPERTIES:
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (name.equals(&quot;properties&quot;)) {</span>
<span class="nc" id="L643">                state = INITIAL;</span>
<span class="nc" id="L644">                break;</span>
            }

            try {
<span class="nc" id="L648">                tag = propMap.get(name);</span>
<span class="nc bnc" id="L649" title="All 4 branches missed.">                switch (tag) {</span>
                case KeycolsTag:
<span class="nc bnc" id="L651" title="All 2 branches missed.">                    if (keyCols != null) {</span>
<span class="nc" id="L652">                        int i[] = new int[keyCols.size()];</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">                        for (int j = 0; j &lt; i.length; j++)</span>
<span class="nc" id="L654">                            i[j] = Integer.parseInt(keyCols.elementAt(j));</span>
<span class="nc" id="L655">                        rs.setKeyColumns(i);</span>
<span class="nc" id="L656">                    }</span>
                    break;

                 case PropClassTag:
                     //Added the handling for Class tags to take care of maps
                     //Makes an entry into the map upon end of class tag
                     try{
<span class="nc" id="L663">                          typeMap.put(Key_map,Class.forName(Value_map));</span>

<span class="nc" id="L665">                        }catch(ClassNotFoundException ex) {</span>
<span class="nc" id="L666">                          throw new SAXException(MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.errmap&quot;).toString(), ex.getMessage()));</span>
<span class="nc" id="L667">                        }</span>
                      break;

                 case MapTag:
                      //Added the handling for Map to take set the typeMap
<span class="nc" id="L672">                      rs.setTypeMap(typeMap);</span>
<span class="nc" id="L673">                      break;</span>

                default:
                    break;
                }

<span class="nc bnc" id="L679" title="All 2 branches missed.">                if (getNullValue()) {</span>
<span class="nc" id="L680">                    setPropertyValue(null);</span>
<span class="nc" id="L681">                    setNullValue(false);</span>
                } else {
<span class="nc" id="L683">                    setPropertyValue(propertyValue);</span>
                }
<span class="nc" id="L685">            } catch (SQLException ex) {</span>
<span class="nc" id="L686">                throw new SAXException(ex.getMessage());</span>
<span class="nc" id="L687">            }</span>

            // propertyValue need to be reset to an empty string
<span class="nc" id="L690">            propertyValue = &quot;&quot;;</span>
<span class="nc" id="L691">            setTag(-1);</span>
<span class="nc" id="L692">            break;</span>
        case METADATA:
<span class="nc bnc" id="L694" title="All 2 branches missed.">            if (name.equals(&quot;metadata&quot;)) {</span>
                try {
<span class="nc" id="L696">                    rs.setMetaData(md);</span>
<span class="nc" id="L697">                    state = INITIAL;</span>
<span class="nc" id="L698">                } catch (SQLException ex) {</span>
<span class="nc" id="L699">                    throw new SAXException(MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.errmetadata&quot;).toString(), ex.getMessage()));</span>
<span class="nc" id="L700">                }</span>
            } else {
                try {
<span class="nc bnc" id="L703" title="All 2 branches missed.">                    if (getNullValue()) {</span>
<span class="nc" id="L704">                        setMetaDataValue(null);</span>
<span class="nc" id="L705">                        setNullValue(false);</span>
                    } else {
<span class="nc" id="L707">                        setMetaDataValue(metaDataValue);</span>
                    }
<span class="nc" id="L709">                } catch (SQLException ex) {</span>
<span class="nc" id="L710">                    throw new SAXException(MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.errmetadata&quot;).toString(), ex.getMessage()));</span>

<span class="nc" id="L712">                }</span>
                // metaDataValue needs to be reset to an empty string
<span class="nc" id="L714">                metaDataValue = &quot;&quot;;</span>
            }
<span class="nc" id="L716">            setTag(-1);</span>
<span class="nc" id="L717">            break;</span>
        case DATA:
<span class="nc bnc" id="L719" title="All 2 branches missed.">            if (name.equals(&quot;data&quot;)) {</span>
<span class="nc" id="L720">                state = INITIAL;</span>
<span class="nc" id="L721">                return;</span>
            }

<span class="nc bnc" id="L724" title="All 2 branches missed.">            if(dataMap.get(name) == null) {</span>
<span class="nc" id="L725">                tag = NullTag;</span>
            } else {
<span class="nc" id="L727">                 tag = dataMap.get(name);</span>
            }
<span class="nc bnc" id="L729" title="All 7 branches missed.">            switch (tag) {</span>
            case ColTag:
                try {
<span class="nc" id="L732">                    idx++;</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                    if (getNullValue()) {</span>
<span class="nc" id="L734">                        insertValue(null);</span>
<span class="nc" id="L735">                        setNullValue(false);</span>
                    } else {
<span class="nc" id="L737">                        insertValue(tempStr);</span>
                    }
                    // columnValue now need to be reset to the empty string
<span class="nc" id="L740">                    columnValue = &quot;&quot;;</span>
<span class="nc" id="L741">                } catch (SQLException ex) {</span>
<span class="nc" id="L742">                    throw new SAXException(MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.errinsertval&quot;).toString(), ex.getMessage()));</span>
<span class="nc" id="L743">                }</span>
                break;
            case RowTag:
                try {
<span class="nc" id="L747">                    rs.insertRow();</span>
<span class="nc" id="L748">                    rs.moveToCurrentRow();</span>
<span class="nc" id="L749">                    rs.next();</span>

                    // Making this as the original to turn off the
                    // rowInserted flagging
<span class="nc" id="L753">                    rs.setOriginalRow();</span>

<span class="nc" id="L755">                    applyUpdates();</span>
<span class="nc" id="L756">                } catch (SQLException ex) {</span>
<span class="nc" id="L757">                    throw new SAXException(MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.errconstr&quot;).toString(), ex.getMessage()));</span>
<span class="nc" id="L758">                }</span>
                break;
            case DelTag:
                try {
<span class="nc" id="L762">                    rs.insertRow();</span>
<span class="nc" id="L763">                    rs.moveToCurrentRow();</span>
<span class="nc" id="L764">                    rs.next();</span>
<span class="nc" id="L765">                    rs.setOriginalRow();</span>
<span class="nc" id="L766">                    applyUpdates();</span>
<span class="nc" id="L767">                    rs.deleteRow();</span>
<span class="nc" id="L768">                } catch (SQLException ex) {</span>
<span class="nc" id="L769">                    throw new SAXException(MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.errdel&quot;).toString() , ex.getMessage()));</span>
<span class="nc" id="L770">                }</span>
                break;
            case InsTag:
                try {
<span class="nc" id="L774">                    rs.insertRow();</span>
<span class="nc" id="L775">                    rs.moveToCurrentRow();</span>
<span class="nc" id="L776">                    rs.next();</span>
<span class="nc" id="L777">                    applyUpdates();</span>
<span class="nc" id="L778">                } catch (SQLException ex) {</span>
<span class="nc" id="L779">                    throw new SAXException(MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.errinsert&quot;).toString() , ex.getMessage()));</span>
<span class="nc" id="L780">                }</span>
                break;

            case InsDelTag:
                try {
<span class="nc" id="L785">                    rs.insertRow();</span>
<span class="nc" id="L786">                    rs.moveToCurrentRow();</span>
<span class="nc" id="L787">                    rs.next();</span>
<span class="nc" id="L788">                    rs.setOriginalRow();</span>
<span class="nc" id="L789">                    applyUpdates();</span>
<span class="nc" id="L790">                } catch (SQLException ex) {</span>
<span class="nc" id="L791">                    throw new SAXException(MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.errinsdel&quot;).toString() , ex.getMessage()));</span>
<span class="nc" id="L792">                }</span>
                break;

             case UpdTag:
                 try {
<span class="nc bnc" id="L797" title="All 2 branches missed.">                        if(getNullValue())</span>
                         {
<span class="nc" id="L799">                          insertValue(null);</span>
<span class="nc" id="L800">                          setNullValue(false);</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                         } else if(getEmptyStringValue()) {</span>
<span class="nc" id="L802">                               insertValue(&quot;&quot;);</span>
<span class="nc" id="L803">                               setEmptyStringValue(false);</span>
                         } else {
<span class="nc" id="L805">                            updates.add(upd);</span>
                         }
<span class="nc" id="L807">                 }  catch(SQLException ex) {</span>
<span class="nc" id="L808">                        throw new SAXException(MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.errupdate&quot;).toString() , ex.getMessage()));</span>
<span class="nc" id="L809">                 }</span>
                break;

            default:
                break;
            }
        default:
            break;
        }
<span class="nc" id="L818">    }</span>

    private void applyUpdates() throws SAXException {
        // now handle any updates
<span class="nc bnc" id="L822" title="All 2 branches missed.">        if (updates.size() &gt; 0) {</span>
            try {
                Object upd[];
<span class="nc" id="L825">                Iterator&lt;?&gt; i = updates.iterator();</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">                while (i.hasNext()) {</span>
<span class="nc" id="L827">                    upd = (Object [])i.next();</span>
<span class="nc" id="L828">                    idx = ((Integer)upd[0]).intValue();</span>

<span class="nc bnc" id="L830" title="All 2 branches missed.">                   if(!(lastval.equals(upd[1]))){</span>
<span class="nc" id="L831">                       insertValue((String)(upd[1]));</span>
                    }
                }

<span class="nc" id="L835">                rs.updateRow();</span>
<span class="nc" id="L836">                } catch (SQLException ex) {</span>
<span class="nc" id="L837">                    throw new SAXException(MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.errupdrow&quot;).toString() , ex.getMessage()));</span>
<span class="nc" id="L838">                }</span>
<span class="nc" id="L839">            updates.removeAllElements();</span>
        }


<span class="nc" id="L843">    }</span>

    /**
     * Sets a property, metadata, or data value with the characters in
     * the given array of characters, starting with the array element
     * indicated by &lt;code&gt;start&lt;/code&gt; and continuing for &lt;code&gt;length&lt;/code&gt;
     * number of characters.
     * &lt;P&gt;
     * The SAX parser invokes this method and supplies
     * the character array, start position, and length parameter values it
     * got from parsing the XML document.  An application programmer never
     * invokes this method directly.
     *
     * @param ch an array of characters supplied by the SAX parser, all or part of
     *         which will be used to set a value
     * @param start the position in the given array at which to start
     * @param length the number of consecutive characters to use
     */
    public void characters(char[] ch, int start, int length) throws SAXException {
        try {
<span class="nc bnc" id="L863" title="All 4 branches missed.">            switch (getState()) {</span>
            case PROPERTIES:
<span class="nc" id="L865">                propertyValue = new String(ch, start, length);</span>

                /**
                  * This has been added for handling of special characters. When special
                  * characters are encountered the characters function gets called for
                  * each of the characters so we need to append the value got in the
                  * previous call as it is the same data present between the start and
                  * the end tag.
                  **/
<span class="nc" id="L874">                tempCommand = tempCommand.concat(propertyValue);</span>
<span class="nc" id="L875">                propertyValue = tempCommand;</span>

                // Added the following check for handling of type tags in maps
<span class="nc bnc" id="L878" title="All 2 branches missed.">                if(tag == PropTypeTag)</span>
                {
<span class="nc" id="L880">                        Key_map = propertyValue;</span>
                }

                // Added the following check for handling of class tags in maps
<span class="nc bnc" id="L884" title="All 2 branches missed.">                else if(tag == PropClassTag)</span>
                {
<span class="nc" id="L886">                        Value_map = propertyValue;</span>
                }
                break;

            case METADATA:

                // The parser will come here after the endElement as there is
                // &quot;\n&quot; in the after endTag is printed. This will cause a problem
                // when the data between the tags is an empty string so adding
                // below condition to take care of that situation.

<span class="nc bnc" id="L897" title="All 2 branches missed.">                if (tag == -1)</span>
                {
<span class="nc" id="L899">                        break;</span>
                }

<span class="nc" id="L902">                metaDataValue = new String(ch, start, length);</span>
<span class="nc" id="L903">                break;</span>
            case DATA:
<span class="nc" id="L905">                setDataValue(ch, start, length);</span>
<span class="nc" id="L906">                break;</span>
            default:
                ;
            }
<span class="nc" id="L910">        } catch (SQLException ex) {</span>
<span class="nc" id="L911">            throw new SAXException(resBundle.handleGetObject(&quot;xmlrch.chars&quot;).toString() + ex.getMessage());</span>
<span class="nc" id="L912">        }</span>
<span class="nc" id="L913">    }</span>

    private void setState(String s) throws SAXException {
<span class="nc bnc" id="L916" title="All 2 branches missed.">        if (s.equals(&quot;webRowSet&quot;)) {</span>
<span class="nc" id="L917">            state = INITIAL;</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">        } else if (s.equals(&quot;properties&quot;)) {</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">            if (state != PROPERTIES)</span>
<span class="nc" id="L920">                state = PROPERTIES;</span>
            else
<span class="nc" id="L922">                state = INITIAL;</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">        } else if (s.equals(&quot;metadata&quot;)) {</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">            if (state != METADATA)</span>
<span class="nc" id="L925">                state = METADATA;</span>
            else
<span class="nc" id="L927">                state = INITIAL;</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">        } else if (s.equals(&quot;data&quot;)) {</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">            if (state != DATA)</span>
<span class="nc" id="L930">                state = DATA;</span>
            else
<span class="nc" id="L932">                state = INITIAL;</span>
        }

<span class="nc" id="L935">    }</span>

    /**
     * Retrieves the current state of this &lt;code&gt;XmlReaderContentHandler&lt;/code&gt;
     * object's rowset, which is stored in the document handler's
     * &lt;code&gt;state&lt;/code&gt; field.
     *
     * @return one of the following constants:
     *         &lt;code&gt;XmlReaderContentHandler.PROPERTIES&lt;/code&gt;
     *         &lt;code&gt;XmlReaderContentHandler.METADATA&lt;/code&gt;
     *         &lt;code&gt;XmlReaderContentHandler.DATA&lt;/code&gt;
     *         &lt;code&gt;XmlReaderContentHandler.INITIAL&lt;/code&gt;
     */
    private int getState() {
<span class="nc" id="L949">        return state;</span>
    }

    private void setTag(int t) {
<span class="nc" id="L953">        tag = t;</span>
<span class="nc" id="L954">    }</span>

    private int getTag() {
<span class="nc" id="L957">        return tag;</span>
    }

    private void setNullValue(boolean n) {
<span class="nc" id="L961">        nullVal = n;</span>
<span class="nc" id="L962">    }</span>

    private boolean getNullValue() {
<span class="nc" id="L965">        return nullVal;</span>
    }

    private void setEmptyStringValue(boolean e) {
<span class="nc" id="L969">        emptyStringVal = e;</span>
<span class="nc" id="L970">    }</span>

    private boolean getEmptyStringValue() {
<span class="nc" id="L973">        return emptyStringVal;</span>
    }

    private String getStringValue(String s) {
<span class="nc" id="L977">         return s;</span>
    }

    private int getIntegerValue(String s) {
<span class="nc" id="L981">        return Integer.parseInt(s);</span>
    }

    private boolean getBooleanValue(String s) {

<span class="nc" id="L986">        return Boolean.valueOf(s).booleanValue();</span>
    }

    private java.math.BigDecimal getBigDecimalValue(String s) {
<span class="nc" id="L990">        return new java.math.BigDecimal(s);</span>
    }

    private byte getByteValue(String s) {
<span class="nc" id="L994">        return Byte.parseByte(s);</span>
    }

    private short getShortValue(String s) {
<span class="nc" id="L998">        return Short.parseShort(s);</span>
    }

    private long getLongValue(String s) {
<span class="nc" id="L1002">        return Long.parseLong(s);</span>
    }

    private float getFloatValue(String s) {
<span class="nc" id="L1006">        return Float.parseFloat(s);</span>
    }

    private double getDoubleValue(String s) {
<span class="nc" id="L1010">        return Double.parseDouble(s);</span>
    }

    private byte[] getBinaryValue(String s) {
<span class="nc" id="L1014">        return s.getBytes();</span>
    }

    private java.sql.Date getDateValue(String s) {
<span class="nc" id="L1018">        return new java.sql.Date(getLongValue(s));</span>
    }

    private java.sql.Time getTimeValue(String s) {
<span class="nc" id="L1022">        return new java.sql.Time(getLongValue(s));</span>
    }

    private java.sql.Timestamp getTimestampValue(String s) {
<span class="nc" id="L1026">        return new java.sql.Timestamp(getLongValue(s));</span>
    }

    private void setPropertyValue(String s) throws SQLException {
        // find out if we are going to be dealing with a null
<span class="nc" id="L1031">        boolean nullValue = getNullValue();</span>

<span class="nc bnc" id="L1033" title="All 24 branches missed.">        switch(getTag()) {</span>
        case CommandTag:
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1036">               ; //rs.setCommand(null);</span>
            else
<span class="nc" id="L1038">                rs.setCommand(s);</span>
<span class="nc" id="L1039">            break;</span>
        case ConcurrencyTag:
<span class="nc bnc" id="L1041" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1042">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            else
<span class="nc" id="L1044">                rs.setConcurrency(getIntegerValue(s));</span>
<span class="nc" id="L1045">            break;</span>
        case DatasourceTag:
<span class="nc bnc" id="L1047" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1048">                rs.setDataSourceName(null);</span>
            else
<span class="nc" id="L1050">                rs.setDataSourceName(s);</span>
<span class="nc" id="L1051">            break;</span>
        case EscapeProcessingTag:
<span class="nc bnc" id="L1053" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1054">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            else
<span class="nc" id="L1056">                rs.setEscapeProcessing(getBooleanValue(s));</span>
<span class="nc" id="L1057">            break;</span>
        case FetchDirectionTag:
<span class="nc bnc" id="L1059" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1060">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            else
<span class="nc" id="L1062">                rs.setFetchDirection(getIntegerValue(s));</span>
<span class="nc" id="L1063">            break;</span>
        case FetchSizeTag:
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1066">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            else
<span class="nc" id="L1068">                rs.setFetchSize(getIntegerValue(s));</span>
<span class="nc" id="L1069">            break;</span>
        case IsolationLevelTag:
<span class="nc bnc" id="L1071" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1072">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            else
<span class="nc" id="L1074">                rs.setTransactionIsolation(getIntegerValue(s));</span>
<span class="nc" id="L1075">            break;</span>
        case KeycolsTag:
<span class="nc" id="L1077">            break;</span>
        case PropColumnTag:
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            if (keyCols == null)</span>
<span class="nc" id="L1080">                keyCols = new Vector&lt;&gt;();</span>
<span class="nc" id="L1081">            keyCols.add(s);</span>
<span class="nc" id="L1082">            break;</span>
        case MapTag:
<span class="nc" id="L1084">            break;</span>
        case MaxFieldSizeTag:
<span class="nc bnc" id="L1086" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1087">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            else
<span class="nc" id="L1089">                rs.setMaxFieldSize(getIntegerValue(s));</span>
<span class="nc" id="L1090">            break;</span>
        case MaxRowsTag:
<span class="nc bnc" id="L1092" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1093">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            else
<span class="nc" id="L1095">                rs.setMaxRows(getIntegerValue(s));</span>
<span class="nc" id="L1096">            break;</span>
        case QueryTimeoutTag:
<span class="nc bnc" id="L1098" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1099">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            else
<span class="nc" id="L1101">                rs.setQueryTimeout(getIntegerValue(s));</span>
<span class="nc" id="L1102">            break;</span>
        case ReadOnlyTag:
<span class="nc bnc" id="L1104" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1105">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            else
<span class="nc" id="L1107">                rs.setReadOnly(getBooleanValue(s));</span>
<span class="nc" id="L1108">            break;</span>
        case RowsetTypeTag:
<span class="nc bnc" id="L1110" title="All 2 branches missed.">            if (nullValue) {</span>
<span class="nc" id="L1111">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            } else {
                //rs.setType(getIntegerValue(s));
<span class="nc" id="L1114">                String strType = getStringValue(s);</span>
<span class="nc" id="L1115">                int iType = 0;</span>

<span class="nc bnc" id="L1117" title="All 2 branches missed.">                if(strType.trim().equals(&quot;ResultSet.TYPE_SCROLL_INSENSITIVE&quot;)) {</span>
<span class="nc" id="L1118">                   iType = 1004;</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">                } else if(strType.trim().equals(&quot;ResultSet.TYPE_SCROLL_SENSITIVE&quot;))   {</span>
<span class="nc" id="L1120">                   iType = 1005;</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">                } else if(strType.trim().equals(&quot;ResultSet.TYPE_FORWARD_ONLY&quot;)) {</span>
<span class="nc" id="L1122">                   iType = 1003;</span>
                }
<span class="nc" id="L1124">                rs.setType(iType);</span>
            }
<span class="nc" id="L1126">            break;</span>
        case ShowDeletedTag:
<span class="nc bnc" id="L1128" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1129">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue&quot;).toString());</span>
            else
<span class="nc" id="L1131">                rs.setShowDeleted(getBooleanValue(s));</span>
<span class="nc" id="L1132">            break;</span>
        case TableNameTag:
<span class="nc bnc" id="L1134" title="All 2 branches missed.">            if (nullValue)</span>
                //rs.setTableName(null);
<span class="nc" id="L1136">                ;</span>
            else
<span class="nc" id="L1138">                rs.setTableName(s);</span>
<span class="nc" id="L1139">            break;</span>
        case UrlTag:
<span class="nc bnc" id="L1141" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1142">                rs.setUrl(null);</span>
            else
<span class="nc" id="L1144">                rs.setUrl(s);</span>
<span class="nc" id="L1145">            break;</span>
        case SyncProviderNameTag:
<span class="nc bnc" id="L1147" title="All 2 branches missed.">            if (nullValue) {</span>
<span class="nc" id="L1148">                rs.setSyncProvider(null);</span>
            } else {
<span class="nc" id="L1150">                String str = s.substring(0,s.indexOf(&quot;@&quot;)+1);</span>
<span class="nc" id="L1151">                rs.setSyncProvider(str);</span>
            }
<span class="nc" id="L1153">            break;</span>
        case SyncProviderVendorTag:
            // to be implemented
<span class="nc" id="L1156">            break;</span>
        case SyncProviderVersionTag:
            // to be implemented
<span class="nc" id="L1159">            break;</span>
        case SyncProviderGradeTag:
            // to be implemented
<span class="nc" id="L1162">            break;</span>
        case DataSourceLock:
            // to be implemented
<span class="nc" id="L1165">            break;</span>
        default:
            break;
        }

<span class="nc" id="L1170">    }</span>

    private void setMetaDataValue(String s) throws SQLException {
        // find out if we are going to be dealing with a null
<span class="nc" id="L1174">        boolean nullValue = getNullValue();</span>

<span class="nc bnc" id="L1176" title="All 20 branches missed.">        switch (getTag()) {</span>
        case ColumnCountTag:
<span class="nc" id="L1178">            md = new RowSetMetaDataImpl();</span>
<span class="nc" id="L1179">            idx = 0;</span>

<span class="nc bnc" id="L1181" title="All 2 branches missed.">            if (nullValue) {</span>
<span class="nc" id="L1182">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            } else {
<span class="nc" id="L1184">                md.setColumnCount(getIntegerValue(s));</span>
            }
<span class="nc" id="L1186">            break;</span>
        case ColumnDefinitionTag:
<span class="nc" id="L1188">            break;</span>
        case ColumnIndexTag:
<span class="nc" id="L1190">            idx++;</span>
<span class="nc" id="L1191">            break;</span>
        case AutoIncrementTag:
<span class="nc bnc" id="L1193" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1194">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            else
<span class="nc" id="L1196">                md.setAutoIncrement(idx, getBooleanValue(s));</span>
<span class="nc" id="L1197">            break;</span>
        case CaseSensitiveTag:
<span class="nc bnc" id="L1199" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1200">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            else
<span class="nc" id="L1202">                md.setCaseSensitive(idx, getBooleanValue(s));</span>
<span class="nc" id="L1203">            break;</span>
        case CurrencyTag:
<span class="nc bnc" id="L1205" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1206">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            else
<span class="nc" id="L1208">                md.setCurrency(idx, getBooleanValue(s));</span>
<span class="nc" id="L1209">            break;</span>
        case NullableTag:
<span class="nc bnc" id="L1211" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1212">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            else
<span class="nc" id="L1214">                md.setNullable(idx, getIntegerValue(s));</span>
<span class="nc" id="L1215">            break;</span>
        case SignedTag:
<span class="nc bnc" id="L1217" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1218">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            else
<span class="nc" id="L1220">                md.setSigned(idx, getBooleanValue(s));</span>
<span class="nc" id="L1221">            break;</span>
        case SearchableTag:
<span class="nc bnc" id="L1223" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1224">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            else
<span class="nc" id="L1226">                md.setSearchable(idx, getBooleanValue(s));</span>
<span class="nc" id="L1227">            break;</span>
        case ColumnDisplaySizeTag:
<span class="nc bnc" id="L1229" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1230">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            else
<span class="nc" id="L1232">                md.setColumnDisplaySize(idx, getIntegerValue(s));</span>
<span class="nc" id="L1233">            break;</span>
        case ColumnLabelTag:
<span class="nc bnc" id="L1235" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1236">                md.setColumnLabel(idx, null);</span>
            else
<span class="nc" id="L1238">                md.setColumnLabel(idx, s);</span>
<span class="nc" id="L1239">            break;</span>
        case ColumnNameTag:
<span class="nc bnc" id="L1241" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1242">                md.setColumnName(idx, null);</span>
            else
<span class="nc" id="L1244">                md.setColumnName(idx, s);</span>

<span class="nc" id="L1246">            break;</span>
        case SchemaNameTag:
<span class="nc bnc" id="L1248" title="All 2 branches missed.">            if (nullValue) {</span>
<span class="nc" id="L1249">                md.setSchemaName(idx, null); }</span>
            else
<span class="nc" id="L1251">                md.setSchemaName(idx, s);</span>
<span class="nc" id="L1252">            break;</span>
        case ColumnPrecisionTag:
<span class="nc bnc" id="L1254" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1255">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            else
<span class="nc" id="L1257">                md.setPrecision(idx, getIntegerValue(s));</span>
<span class="nc" id="L1258">            break;</span>
        case ColumnScaleTag:
<span class="nc bnc" id="L1260" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1261">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            else
<span class="nc" id="L1263">                md.setScale(idx, getIntegerValue(s));</span>
<span class="nc" id="L1264">            break;</span>
        case MetaTableNameTag:
<span class="nc bnc" id="L1266" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1267">                md.setTableName(idx, null);</span>
            else
<span class="nc" id="L1269">                md.setTableName(idx, s);</span>
<span class="nc" id="L1270">            break;</span>
        case CatalogNameTag:
<span class="nc bnc" id="L1272" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1273">                md.setCatalogName(idx, null);</span>
            else
<span class="nc" id="L1275">                md.setCatalogName(idx, s);</span>
<span class="nc" id="L1276">            break;</span>
        case ColumnTypeTag:
<span class="nc bnc" id="L1278" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1279">                throw new SQLException(resBundle.handleGetObject(&quot;xmlrch.badvalue1&quot;).toString());</span>
            else
<span class="nc" id="L1281">                md.setColumnType(idx, getIntegerValue(s));</span>
<span class="nc" id="L1282">            break;</span>
        case ColumnTypeNameTag:
<span class="nc bnc" id="L1284" title="All 2 branches missed.">            if (nullValue)</span>
<span class="nc" id="L1285">                md.setColumnTypeName(idx, null);</span>
            else
<span class="nc" id="L1287">                md.setColumnTypeName(idx, s);</span>
<span class="nc" id="L1288">            break;</span>
        default:
            //System.out.println(&quot;MetaData: Unknown Tag: (&quot; + getTag() + &quot;)&quot;);
            break;

        }
<span class="nc" id="L1294">    }</span>

    private void setDataValue(char[] ch, int start, int len) throws SQLException {
<span class="nc bnc" id="L1297" title="All 3 branches missed.">        switch (getTag()) {</span>
        case ColTag:
<span class="nc" id="L1299">            columnValue = new String(ch, start, len);</span>
            /**
              * This has been added for handling of special characters. When special
              * characters are encountered the characters function gets called for
              * each of the characters so we need to append the value got in the
              * previous call as it is the same data present between the start and
              * the end tag.
              **/
<span class="nc" id="L1307">            tempStr = tempStr.concat(columnValue);</span>
<span class="nc" id="L1308">            break;</span>
        case UpdTag:
<span class="nc" id="L1310">            upd = new Object[2];</span>

            /**
              * This has been added for handling of special characters. When special
              * characters are encountered the characters function gets called for
              * each of the characters so we need to append the value got in the
              * previous call as it is the same data present between the start and
              * the end tag.
              **/

<span class="nc" id="L1320">            tempUpdate = tempUpdate.concat(new String(ch,start,len));</span>
<span class="nc" id="L1321">            upd[0] = Integer.valueOf(idx);</span>
<span class="nc" id="L1322">            upd[1] = tempUpdate;</span>
            //updates.add(upd);

<span class="nc" id="L1325">            lastval = (String)upd[1];</span>
            //insertValue(ch, start, len);
<span class="nc" id="L1327">            break;</span>
        case InsTag:

        }
<span class="nc" id="L1331">    }</span>

    private void insertValue(String s) throws SQLException {

<span class="nc bnc" id="L1335" title="All 2 branches missed.">        if (getNullValue()) {</span>
<span class="nc" id="L1336">            rs.updateNull(idx);</span>
<span class="nc" id="L1337">            return;</span>
        }

        // no longer have to deal with those pesky nulls.
<span class="nc" id="L1341">        int type = rs.getMetaData().getColumnType(idx);</span>
<span class="nc bnc" id="L1342" title="All 14 branches missed.">        switch (type) {</span>
        case java.sql.Types.BIT:
<span class="nc" id="L1344">            rs.updateBoolean(idx, getBooleanValue(s));</span>
<span class="nc" id="L1345">            break;</span>
        case java.sql.Types.BOOLEAN:
<span class="nc" id="L1347">            rs.updateBoolean(idx, getBooleanValue(s));</span>
<span class="nc" id="L1348">            break;</span>
        case java.sql.Types.SMALLINT:
        case java.sql.Types.TINYINT:
<span class="nc" id="L1351">            rs.updateShort(idx, getShortValue(s));</span>
<span class="nc" id="L1352">            break;</span>
        case java.sql.Types.INTEGER:
<span class="nc" id="L1354">            rs.updateInt(idx, getIntegerValue(s));</span>
<span class="nc" id="L1355">            break;</span>
        case java.sql.Types.BIGINT:
<span class="nc" id="L1357">            rs.updateLong(idx, getLongValue(s));</span>
<span class="nc" id="L1358">            break;</span>
        case java.sql.Types.REAL:
        case java.sql.Types.FLOAT:
<span class="nc" id="L1361">            rs.updateFloat(idx, getFloatValue(s));</span>
<span class="nc" id="L1362">            break;</span>
        case java.sql.Types.DOUBLE:
<span class="nc" id="L1364">            rs.updateDouble(idx, getDoubleValue(s));</span>
<span class="nc" id="L1365">            break;</span>
        case java.sql.Types.NUMERIC:
        case java.sql.Types.DECIMAL:
<span class="nc" id="L1368">            rs.updateObject(idx, getBigDecimalValue(s));</span>
<span class="nc" id="L1369">            break;</span>
        case java.sql.Types.BINARY:
        case java.sql.Types.VARBINARY:
        case java.sql.Types.LONGVARBINARY:
<span class="nc" id="L1373">            rs.updateBytes(idx, getBinaryValue(s));</span>
<span class="nc" id="L1374">            break;</span>
        case java.sql.Types.DATE:
<span class="nc" id="L1376">            rs.updateDate(idx,  getDateValue(s));</span>
<span class="nc" id="L1377">            break;</span>
        case java.sql.Types.TIME:
<span class="nc" id="L1379">            rs.updateTime(idx, getTimeValue(s));</span>
<span class="nc" id="L1380">            break;</span>
        case java.sql.Types.TIMESTAMP:
<span class="nc" id="L1382">            rs.updateTimestamp(idx, getTimestampValue(s));</span>
<span class="nc" id="L1383">            break;</span>
        case java.sql.Types.CHAR:
        case java.sql.Types.VARCHAR:
        case java.sql.Types.LONGVARCHAR:
<span class="nc" id="L1387">            rs.updateString(idx, getStringValue(s));</span>
<span class="nc" id="L1388">            break;</span>
        default:

        }

<span class="nc" id="L1393">    }</span>

    /**
     * Throws the given &lt;code&gt;SAXParseException&lt;/code&gt; object. This
     * exception was originally thrown by the SAX parser and is passed
     * to the method &lt;code&gt;error&lt;/code&gt; when the SAX parser invokes it.
     *
     * @param e the &lt;code&gt;SAXParseException&lt;/code&gt; object to throw
     */
    public void error (SAXParseException e) throws SAXParseException {
<span class="nc" id="L1403">            throw e;</span>
    }

    // dump warnings too
    /**
     * Prints a warning message to &lt;code&gt;System.out&lt;/code&gt; giving the line
     * number and uri for what caused the warning plus a message explaining
     * the reason for the warning. This method is invoked by the SAX parser.
     *
     * @param err a warning generated by the SAX parser
     */
    public void warning (SAXParseException err) throws SAXParseException {
<span class="nc" id="L1415">        System.out.println (MessageFormat.format(resBundle.handleGetObject(&quot;xmlrch.warning&quot;).toString(), new Object[] { err.getMessage(), err.getLineNumber(), err.getSystemId() }));</span>
<span class="nc" id="L1416">    }</span>

    /**
     *
     */
    public void notationDecl(String name, String publicId, String systemId) {

<span class="nc" id="L1423">    }</span>

    /**
     *
     */
    public void unparsedEntityDecl(String name, String publicId, String systemId, String notationName) {

<span class="nc" id="L1430">    }</span>

   /**
    * Returns the current row of this &lt;code&gt;Rowset&lt;/code&gt;object.
    * The ResultSet's cursor is positioned at the Row which is needed
    *
    * @return the &lt;code&gt;Row&lt;/code&gt; object on which the &lt;code&gt;RowSet&lt;/code&gt;
    *           implementation objects's cursor is positioned
    */
    private Row getPresentRow(WebRowSetImpl rs) throws SQLException {
         //rs.setOriginalRow();
         // ResultSetMetaData rsmd = rs.getMetaData();
         // int numCols = rsmd.getColumnCount();
         // Object vals[] = new Object[numCols];
         // for(int j = 1; j&lt;= numCols ; j++){
         //     vals[j-1] = rs.getObject(j);
         // }
         // return(new Row(numCols, vals));
<span class="nc" id="L1448">         return null;</span>
   }




}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>