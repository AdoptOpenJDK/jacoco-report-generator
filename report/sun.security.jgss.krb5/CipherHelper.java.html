<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CipherHelper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.jgss.krb5</a> &gt; <span class="el_source">CipherHelper.java</span></div><h1>CipherHelper.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.jgss.krb5;

import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.CipherInputStream;
import javax.crypto.CipherOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import org.ietf.jgss.*;

import java.security.MessageDigest;
import java.security.GeneralSecurityException;
import java.security.NoSuchAlgorithmException;
import sun.security.krb5.*;
import sun.security.krb5.internal.crypto.Des3;
import sun.security.krb5.internal.crypto.Aes128;
import sun.security.krb5.internal.crypto.Aes256;
import sun.security.krb5.internal.crypto.ArcFourHmac;

class CipherHelper {

    // From draft-raeburn-cat-gssapi-krb5-3des-00
    // Key usage values when deriving keys
    private static final int KG_USAGE_SEAL = 22;
    private static final int KG_USAGE_SIGN = 23;
    private static final int KG_USAGE_SEQ = 24;

    private static final int DES_CHECKSUM_SIZE = 8;
    private static final int DES_IV_SIZE = 8;
    private static final int AES_IV_SIZE = 16;

    // ARCFOUR-HMAC
    // Save first 8 octets of HMAC Sgn_Cksum
    private static final int HMAC_CHECKSUM_SIZE = 8;
    // key usage for MIC tokens used by MS
    private static final int KG_USAGE_SIGN_MS = 15;

    // debug flag
<span class="fc" id="L67">    private static final boolean DEBUG = Krb5Util.DEBUG;</span>

    /**
     * A zero initial vector to be used for checksum calculation and for
     * DesCbc application data encryption/decryption.
     */
<span class="fc" id="L73">    private static final byte[] ZERO_IV = new byte[DES_IV_SIZE];</span>
<span class="fc" id="L74">    private static final byte[] ZERO_IV_AES = new byte[AES_IV_SIZE];</span>

    private int etype;
    private int sgnAlg, sealAlg;
    private byte[] keybytes;

    // new token format from draft-ietf-krb-wg-gssapi-cfx-07
    // proto is used to determine new GSS token format for &quot;newer&quot; etypes
<span class="fc" id="L82">    private int proto = 0;</span>

<span class="fc" id="L84">    CipherHelper(EncryptionKey key) throws GSSException {</span>
<span class="fc" id="L85">        etype = key.getEType();</span>
<span class="fc" id="L86">        keybytes = key.getBytes();</span>

<span class="pc bpc" id="L88" title="4 of 5 branches missed.">        switch (etype) {</span>
        case EncryptedData.ETYPE_DES_CBC_CRC:
        case EncryptedData.ETYPE_DES_CBC_MD5:
<span class="nc" id="L91">            sgnAlg = MessageToken.SGN_ALG_DES_MAC_MD5;</span>
<span class="nc" id="L92">            sealAlg = MessageToken.SEAL_ALG_DES;</span>
<span class="nc" id="L93">            break;</span>

        case EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD:
<span class="nc" id="L96">            sgnAlg = MessageToken.SGN_ALG_HMAC_SHA1_DES3_KD;</span>
<span class="nc" id="L97">            sealAlg = MessageToken.SEAL_ALG_DES3_KD;</span>
<span class="nc" id="L98">            break;</span>

        case EncryptedData.ETYPE_ARCFOUR_HMAC:
<span class="nc" id="L101">            sgnAlg = MessageToken.SGN_ALG_HMAC_MD5_ARCFOUR;</span>
<span class="nc" id="L102">            sealAlg = MessageToken.SEAL_ALG_ARCFOUR_HMAC;</span>
<span class="nc" id="L103">            break;</span>

        case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96:
        case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96:
<span class="fc" id="L107">            sgnAlg = -1;</span>
<span class="fc" id="L108">            sealAlg = -1;</span>
<span class="fc" id="L109">            proto = 1;</span>
<span class="fc" id="L110">            break;</span>

        default:
<span class="nc" id="L113">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;Unsupported encryption type: &quot; + etype);
        }
<span class="fc" id="L116">    }</span>

    int getSgnAlg() {
<span class="nc" id="L119">        return sgnAlg;</span>
    }

    int getSealAlg() {
<span class="nc" id="L123">        return sealAlg;</span>
    }

    int getProto() {
<span class="fc" id="L127">        return proto;</span>
    }

    int getEType() {
<span class="nc" id="L131">        return etype;</span>
    }

    boolean isArcFour() {
<span class="nc" id="L135">        boolean flag = false;</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (etype == EncryptedData.ETYPE_ARCFOUR_HMAC) {</span>
<span class="nc" id="L137">            flag = true;</span>
        }
<span class="nc" id="L139">        return flag;</span>
    }

    @SuppressWarnings(&quot;fallthrough&quot;)
    byte[] calculateChecksum(int alg, byte[] header, byte[] trailer,
        byte[] data, int start, int len, int tokenId) throws GSSException {

<span class="nc bnc" id="L146" title="All 5 branches missed.">        switch (alg) {</span>
        case MessageToken.SGN_ALG_DES_MAC_MD5:
            /*
             * With this sign algorithm, first an MD5 hash is computed on the
             * application data. The 16 byte hash is then DesCbc encrypted.
             */
            try {
<span class="nc" id="L153">                MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span>

                // debug(&quot;\t\tdata=[&quot;);

                // debug(getHexBytes(checksumDataHeader,
                //                      checksumDataHeader.length) + &quot; &quot;);
<span class="nc" id="L159">                md5.update(header);</span>

                // debug(getHexBytes(data, start, len));
<span class="nc" id="L162">                md5.update(data, start, len);</span>

<span class="nc bnc" id="L164" title="All 2 branches missed.">                if (trailer != null) {</span>
                    // debug(&quot; &quot; +
                    //       getHexBytes(trailer,
                    //                     optionalTrailer.length));
<span class="nc" id="L168">                    md5.update(trailer);</span>
                }
                //          debug(&quot;]\n&quot;);

<span class="nc" id="L172">                data = md5.digest();</span>
<span class="nc" id="L173">                start = 0;</span>
<span class="nc" id="L174">                len = data.length;</span>
                //          System.out.println(&quot;\tMD5 Checksum is [&quot; +
                //                             getHexBytes(data) + &quot;]\n&quot;);
<span class="nc" id="L177">                header = null;</span>
<span class="nc" id="L178">                trailer = null;</span>
<span class="nc" id="L179">            } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L180">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L181">                    &quot;Could not get MD5 Message Digest - &quot; + e.getMessage());</span>
<span class="nc" id="L182">                ge.initCause(e);</span>
<span class="nc" id="L183">                throw ge;</span>
<span class="nc" id="L184">            }</span>
            // fall through to encrypt checksum

        case MessageToken.SGN_ALG_DES_MAC:
<span class="nc" id="L188">            return getDesCbcChecksum(keybytes, header, data, start, len);</span>

        case MessageToken.SGN_ALG_HMAC_SHA1_DES3_KD:
            byte[] buf;
            int offset, total;
<span class="nc bnc" id="L193" title="All 4 branches missed.">            if (header == null &amp;&amp; trailer == null) {</span>
<span class="nc" id="L194">                buf = data;</span>
<span class="nc" id="L195">                total = len;</span>
<span class="nc" id="L196">                offset = start;</span>
            } else {
<span class="nc bnc" id="L198" title="All 4 branches missed.">                total = ((header != null ? header.length : 0) + len +</span>
                    (trailer != null ? trailer.length : 0));

<span class="nc" id="L201">                buf = new byte[total];</span>
<span class="nc" id="L202">                int pos = 0;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">                if (header != null) {</span>
<span class="nc" id="L204">                    System.arraycopy(header, 0, buf, 0, header.length);</span>
<span class="nc" id="L205">                    pos = header.length;</span>
                }
<span class="nc" id="L207">                System.arraycopy(data, start, buf, pos, len);</span>
<span class="nc" id="L208">                pos += len;</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (trailer != null) {</span>
<span class="nc" id="L210">                    System.arraycopy(trailer, 0, buf, pos, trailer.length);</span>
                }

<span class="nc" id="L213">                offset = 0;</span>
            }

            try {

                /*
                Krb5Token.debug(&quot;\nkeybytes: &quot; +
                    Krb5Token.getHexBytes(keybytes));
                Krb5Token.debug(&quot;\nheader: &quot; + (header == null ? &quot;NONE&quot; :
                    Krb5Token.getHexBytes(header)));
                Krb5Token.debug(&quot;\ntrailer: &quot; + (trailer == null ? &quot;NONE&quot; :
                    Krb5Token.getHexBytes(trailer)));
                Krb5Token.debug(&quot;\ndata: &quot; +
                    Krb5Token.getHexBytes(data, start, len));
                Krb5Token.debug(&quot;\nbuf: &quot; + Krb5Token.getHexBytes(buf, offset,
                    total));
                */

<span class="nc" id="L231">                byte[] answer = Des3.calculateChecksum(keybytes,</span>
                    KG_USAGE_SIGN, buf, offset, total);
                // Krb5Token.debug(&quot;\nanswer: &quot; +
                //              Krb5Token.getHexBytes(answer));
<span class="nc" id="L235">                return answer;</span>
<span class="nc" id="L236">            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L237">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Could not use HMAC-SHA1-DES3-KD signing algorithm - &quot; +
<span class="nc" id="L239">                    e.getMessage());</span>
<span class="nc" id="L240">                ge.initCause(e);</span>
<span class="nc" id="L241">                throw ge;</span>
            }

        case MessageToken.SGN_ALG_HMAC_MD5_ARCFOUR:
            byte[] buffer;
            int off, tot;
<span class="nc bnc" id="L247" title="All 4 branches missed.">            if (header == null &amp;&amp; trailer == null) {</span>
<span class="nc" id="L248">                buffer = data;</span>
<span class="nc" id="L249">                tot = len;</span>
<span class="nc" id="L250">                off = start;</span>
            } else {
<span class="nc bnc" id="L252" title="All 4 branches missed.">                tot = ((header != null ? header.length : 0) + len +</span>
                      (trailer != null ? trailer.length : 0));

<span class="nc" id="L255">                buffer = new byte[tot];</span>
<span class="nc" id="L256">                int pos = 0;</span>

<span class="nc bnc" id="L258" title="All 2 branches missed.">                if (header != null) {</span>
<span class="nc" id="L259">                    System.arraycopy(header, 0, buffer, 0, header.length);</span>
<span class="nc" id="L260">                    pos = header.length;</span>
                }
<span class="nc" id="L262">                System.arraycopy(data, start, buffer, pos, len);</span>
<span class="nc" id="L263">                pos += len;</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                if (trailer != null) {</span>
<span class="nc" id="L265">                    System.arraycopy(trailer, 0, buffer, pos, trailer.length);</span>
                }

<span class="nc" id="L268">                off = 0;</span>
            }

            try {

                /*
                Krb5Token.debug(&quot;\nkeybytes: &quot; +
                    Krb5Token.getHexBytes(keybytes));
                Krb5Token.debug(&quot;\nheader: &quot; + (header == null ? &quot;NONE&quot; :
                    Krb5Token.getHexBytes(header)));
                Krb5Token.debug(&quot;\ntrailer: &quot; + (trailer == null ? &quot;NONE&quot; :
                    Krb5Token.getHexBytes(trailer)));
                Krb5Token.debug(&quot;\ndata: &quot; +
                    Krb5Token.getHexBytes(data, start, len));
                Krb5Token.debug(&quot;\nbuffer: &quot; +
                    Krb5Token.getHexBytes(buffer, off, tot));
                */

                // for MIC tokens, key derivation salt is 15
                // NOTE: Required for interoperability. The RC4-HMAC spec
                // defines key_usage of 23, however all Kerberos impl.
                // MS/Solaris/MIT all use key_usage of 15 for MIC tokens
<span class="nc" id="L290">                int key_usage = KG_USAGE_SIGN;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                if (tokenId == Krb5Token.MIC_ID) {</span>
<span class="nc" id="L292">                        key_usage = KG_USAGE_SIGN_MS;</span>
                }
<span class="nc" id="L294">                byte[] answer = ArcFourHmac.calculateChecksum(keybytes,</span>
                    key_usage, buffer, off, tot);
                // Krb5Token.debug(&quot;\nanswer: &quot; +
                //      Krb5Token.getHexBytes(answer));

                // Save first 8 octets of HMAC Sgn_Cksum
<span class="nc" id="L300">                byte[] output = new byte[getChecksumLength()];</span>
<span class="nc" id="L301">                System.arraycopy(answer, 0, output, 0, output.length);</span>
                // Krb5Token.debug(&quot;\nanswer (trimmed): &quot; +
                //              Krb5Token.getHexBytes(output));
<span class="nc" id="L304">                return output;</span>
<span class="nc" id="L305">            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L306">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Could not use HMAC_MD5_ARCFOUR signing algorithm - &quot; +
<span class="nc" id="L308">                    e.getMessage());</span>
<span class="nc" id="L309">                ge.initCause(e);</span>
<span class="nc" id="L310">                throw ge;</span>
            }

        default:
<span class="nc" id="L314">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;Unsupported signing algorithm: &quot; + sgnAlg);
        }
    }

    // calculate Checksum for the new GSS tokens
    byte[] calculateChecksum(byte[] header, byte[] data, int start, int len,
        int key_usage) throws GSSException {

        // total length
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        int total = ((header != null ? header.length : 0) + len);</span>

        // get_mic(&quot;plaintext-data&quot; | &quot;header&quot;)
<span class="fc" id="L327">        byte[] buf = new byte[total];</span>

        // data
<span class="fc" id="L330">        System.arraycopy(data, start, buf, 0, len);</span>

        // token header
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">        if (header != null) {</span>
<span class="fc" id="L334">            System.arraycopy(header, 0, buf, len, header.length);</span>
        }

        // Krb5Token.debug(&quot;\nAES calculate checksum on: &quot; +
        //              Krb5Token.getHexBytes(buf));
<span class="pc bpc" id="L339" title="2 of 3 branches missed.">        switch (etype) {</span>
        case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96:
            try {
<span class="fc" id="L342">                byte[] answer = Aes128.calculateChecksum(keybytes, key_usage,</span>
                                        buf, 0, total);
                // Krb5Token.debug(&quot;\nAES128 checksum: &quot; +
                //                      Krb5Token.getHexBytes(answer));
<span class="fc" id="L346">                return answer;</span>
<span class="nc" id="L347">            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L348">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Could not use AES128 signing algorithm - &quot; +
<span class="nc" id="L350">                    e.getMessage());</span>
<span class="nc" id="L351">                ge.initCause(e);</span>
<span class="nc" id="L352">                throw ge;</span>
            }

        case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96:
            try {
<span class="nc" id="L357">                byte[] answer = Aes256.calculateChecksum(keybytes, key_usage,</span>
                                        buf, 0, total);
                // Krb5Token.debug(&quot;\nAES256 checksum: &quot; +
                //              Krb5Token.getHexBytes(answer));
<span class="nc" id="L361">                return answer;</span>
<span class="nc" id="L362">            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L363">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Could not use AES256 signing algorithm - &quot; +
<span class="nc" id="L365">                    e.getMessage());</span>
<span class="nc" id="L366">                ge.initCause(e);</span>
<span class="nc" id="L367">                throw ge;</span>
            }

        default:
<span class="nc" id="L371">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;Unsupported encryption type: &quot; + etype);
        }
    }

    byte[] encryptSeq(byte[] ivec, byte[] plaintext, int start, int len)
    throws GSSException {

<span class="nc bnc" id="L379" title="All 4 branches missed.">        switch (sgnAlg) {</span>
        case MessageToken.SGN_ALG_DES_MAC_MD5:
        case MessageToken.SGN_ALG_DES_MAC:
            try {
<span class="nc" id="L383">                Cipher des = getInitializedDes(true, keybytes, ivec);</span>
<span class="nc" id="L384">                return des.doFinal(plaintext, start, len);</span>

<span class="nc" id="L386">            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L387">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Could not encrypt sequence number using DES - &quot; +
<span class="nc" id="L389">                    e.getMessage());</span>
<span class="nc" id="L390">                ge.initCause(e);</span>
<span class="nc" id="L391">                throw ge;</span>
            }

        case MessageToken.SGN_ALG_HMAC_SHA1_DES3_KD:
            byte[] iv;
<span class="nc bnc" id="L396" title="All 2 branches missed.">            if (ivec.length == DES_IV_SIZE) {</span>
<span class="nc" id="L397">                iv = ivec;</span>
            } else {
<span class="nc" id="L399">                iv = new byte[DES_IV_SIZE];</span>
<span class="nc" id="L400">                System.arraycopy(ivec, 0, iv, 0, DES_IV_SIZE);</span>
            }
            try {
<span class="nc" id="L403">                return Des3.encryptRaw(keybytes, KG_USAGE_SEQ, iv,</span>
                    plaintext, start, len);
<span class="nc" id="L405">            } catch (Exception e) {</span>
                // GeneralSecurityException, KrbCryptoException
<span class="nc" id="L407">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Could not encrypt sequence number using DES3-KD - &quot; +
<span class="nc" id="L409">                    e.getMessage());</span>
<span class="nc" id="L410">                ge.initCause(e);</span>
<span class="nc" id="L411">                throw ge;</span>
            }

        case MessageToken.SGN_ALG_HMAC_MD5_ARCFOUR:
            // ivec passed is the checksum
            byte[] checksum;
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (ivec.length == HMAC_CHECKSUM_SIZE) {</span>
<span class="nc" id="L418">                checksum = ivec;</span>
            } else {
<span class="nc" id="L420">                checksum = new byte[HMAC_CHECKSUM_SIZE];</span>
<span class="nc" id="L421">                System.arraycopy(ivec, 0, checksum, 0, HMAC_CHECKSUM_SIZE);</span>
            }

            try {
<span class="nc" id="L425">                return ArcFourHmac.encryptSeq(keybytes, KG_USAGE_SEQ, checksum,</span>
                    plaintext, start, len);
<span class="nc" id="L427">            } catch (Exception e) {</span>
                // GeneralSecurityException, KrbCryptoException
<span class="nc" id="L429">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Could not encrypt sequence number using RC4-HMAC - &quot; +
<span class="nc" id="L431">                    e.getMessage());</span>
<span class="nc" id="L432">                ge.initCause(e);</span>
<span class="nc" id="L433">                throw ge;</span>
            }

        default:
<span class="nc" id="L437">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;Unsupported signing algorithm: &quot; + sgnAlg);
        }
    }

    byte[] decryptSeq(byte[] ivec, byte[] ciphertext, int start, int len)
        throws GSSException {

<span class="nc bnc" id="L445" title="All 4 branches missed.">        switch (sgnAlg) {</span>
        case MessageToken.SGN_ALG_DES_MAC_MD5:
        case MessageToken.SGN_ALG_DES_MAC:
            try {
<span class="nc" id="L449">                Cipher des = getInitializedDes(false, keybytes, ivec);</span>
<span class="nc" id="L450">                return des.doFinal(ciphertext, start, len);</span>
<span class="nc" id="L451">            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L452">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Could not decrypt sequence number using DES - &quot; +
<span class="nc" id="L454">                    e.getMessage());</span>
<span class="nc" id="L455">                ge.initCause(e);</span>
<span class="nc" id="L456">                throw ge;</span>
            }

        case MessageToken.SGN_ALG_HMAC_SHA1_DES3_KD:
            byte[] iv;
<span class="nc bnc" id="L461" title="All 2 branches missed.">            if (ivec.length == DES_IV_SIZE) {</span>
<span class="nc" id="L462">                iv = ivec;</span>
            } else {
<span class="nc" id="L464">                iv = new byte[8];</span>
<span class="nc" id="L465">                System.arraycopy(ivec, 0, iv, 0, DES_IV_SIZE);</span>
            }

            try {
<span class="nc" id="L469">                return Des3.decryptRaw(keybytes, KG_USAGE_SEQ, iv,</span>
                    ciphertext, start, len);
<span class="nc" id="L471">            } catch (Exception e) {</span>
                // GeneralSecurityException, KrbCryptoException
<span class="nc" id="L473">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Could not decrypt sequence number using DES3-KD - &quot; +
<span class="nc" id="L475">                    e.getMessage());</span>
<span class="nc" id="L476">                ge.initCause(e);</span>
<span class="nc" id="L477">                throw ge;</span>
            }

        case MessageToken.SGN_ALG_HMAC_MD5_ARCFOUR:
            // ivec passed is the checksum
            byte[] checksum;
<span class="nc bnc" id="L483" title="All 2 branches missed.">            if (ivec.length == HMAC_CHECKSUM_SIZE) {</span>
<span class="nc" id="L484">                checksum = ivec;</span>
            } else {
<span class="nc" id="L486">                checksum = new byte[HMAC_CHECKSUM_SIZE];</span>
<span class="nc" id="L487">                System.arraycopy(ivec, 0, checksum, 0, HMAC_CHECKSUM_SIZE);</span>
            }

            try {
<span class="nc" id="L491">                return ArcFourHmac.decryptSeq(keybytes, KG_USAGE_SEQ, checksum,</span>
                    ciphertext, start, len);
<span class="nc" id="L493">            } catch (Exception e) {</span>
                // GeneralSecurityException, KrbCryptoException
<span class="nc" id="L495">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Could not decrypt sequence number using RC4-HMAC - &quot; +
<span class="nc" id="L497">                    e.getMessage());</span>
<span class="nc" id="L498">                ge.initCause(e);</span>
<span class="nc" id="L499">                throw ge;</span>
            }

        default:
<span class="nc" id="L503">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;Unsupported signing algorithm: &quot; + sgnAlg);
        }
    }

    int getChecksumLength() throws GSSException {
<span class="pc bpc" id="L509" title="5 of 6 branches missed.">        switch (etype) {</span>
        case EncryptedData.ETYPE_DES_CBC_CRC:
        case EncryptedData.ETYPE_DES_CBC_MD5:
<span class="nc" id="L512">            return DES_CHECKSUM_SIZE;</span>

        case EncryptedData.ETYPE_DES3_CBC_HMAC_SHA1_KD:
<span class="nc" id="L515">            return Des3.getChecksumLength();</span>

        case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96:
<span class="fc" id="L518">            return Aes128.getChecksumLength();</span>
        case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96:
<span class="nc" id="L520">            return Aes256.getChecksumLength();</span>

        case EncryptedData.ETYPE_ARCFOUR_HMAC:
            // only first 8 octets of HMAC Sgn_Cksum are used
<span class="nc" id="L524">            return HMAC_CHECKSUM_SIZE;</span>

        default:
<span class="nc" id="L527">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;Unsupported encryption type: &quot; + etype);
        }
    }

    void decryptData(WrapToken token, byte[] ciphertext, int cStart, int cLen,
        byte[] plaintext, int pStart) throws GSSException {

        /*
        Krb5Token.debug(&quot;decryptData : ciphertext =  &quot; +
                Krb5Token.getHexBytes(ciphertext));
        */

<span class="nc bnc" id="L540" title="All 4 branches missed.">        switch (sealAlg) {</span>
        case MessageToken.SEAL_ALG_DES:
<span class="nc" id="L542">            desCbcDecrypt(token, getDesEncryptionKey(keybytes),</span>
                ciphertext, cStart, cLen, plaintext, pStart);
<span class="nc" id="L544">            break;</span>

        case MessageToken.SEAL_ALG_DES3_KD:
<span class="nc" id="L547">            des3KdDecrypt(token, ciphertext, cStart, cLen, plaintext, pStart);</span>
<span class="nc" id="L548">            break;</span>

        case MessageToken.SEAL_ALG_ARCFOUR_HMAC:
<span class="nc" id="L551">            arcFourDecrypt(token, ciphertext, cStart, cLen, plaintext, pStart);</span>
<span class="nc" id="L552">            break;</span>

        default:
<span class="nc" id="L555">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;Unsupported seal algorithm: &quot; + sealAlg);
        }
<span class="nc" id="L558">    }</span>

    // decrypt data in the new GSS tokens
    void decryptData(WrapToken_v2 token, byte[] ciphertext, int cStart,
                int cLen, byte[] plaintext, int pStart, int key_usage)
        throws GSSException {

        /*
        Krb5Token.debug(&quot;decryptData : ciphertext =  &quot; +
                Krb5Token.getHexBytes(ciphertext));
        */

<span class="pc bpc" id="L570" title="2 of 3 branches missed.">        switch (etype) {</span>
            case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96:
<span class="fc" id="L572">                    aes128Decrypt(token, ciphertext, cStart, cLen,</span>
                                plaintext, pStart, key_usage);
<span class="fc" id="L574">                    break;</span>
            case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96:
<span class="nc" id="L576">                    aes256Decrypt(token, ciphertext, cStart, cLen,</span>
                                plaintext, pStart, key_usage);
<span class="nc" id="L578">                    break;</span>
            default:
<span class="nc" id="L580">                    throw new GSSException(GSSException.FAILURE, -1,</span>
                        &quot;Unsupported etype: &quot; + etype);
            }
<span class="fc" id="L583">    }</span>

    void decryptData(WrapToken token, InputStream cipherStream, int cLen,
        byte[] plaintext, int pStart)
        throws GSSException, IOException {

<span class="nc bnc" id="L589" title="All 4 branches missed.">        switch (sealAlg) {</span>
        case MessageToken.SEAL_ALG_DES:
<span class="nc" id="L591">            desCbcDecrypt(token, getDesEncryptionKey(keybytes),</span>
                cipherStream, cLen, plaintext, pStart);
<span class="nc" id="L593">            break;</span>

        case MessageToken.SEAL_ALG_DES3_KD:

            // Read encrypted data from stream
<span class="nc" id="L598">            byte[] ciphertext = new byte[cLen];</span>
            try {
<span class="nc" id="L600">                Krb5Token.readFully(cipherStream, ciphertext, 0, cLen);</span>
<span class="nc" id="L601">            } catch (IOException e) {</span>
<span class="nc" id="L602">                GSSException ge = new GSSException(</span>
                    GSSException.DEFECTIVE_TOKEN, -1,
                    &quot;Cannot read complete token&quot;);
<span class="nc" id="L605">                ge.initCause(e);</span>
<span class="nc" id="L606">                throw ge;</span>
<span class="nc" id="L607">            }</span>

<span class="nc" id="L609">            des3KdDecrypt(token, ciphertext, 0, cLen, plaintext, pStart);</span>
<span class="nc" id="L610">            break;</span>

        case MessageToken.SEAL_ALG_ARCFOUR_HMAC:

            // Read encrypted data from stream
<span class="nc" id="L615">            byte[] ctext = new byte[cLen];</span>
            try {
<span class="nc" id="L617">                Krb5Token.readFully(cipherStream, ctext, 0, cLen);</span>
<span class="nc" id="L618">            } catch (IOException e) {</span>
<span class="nc" id="L619">                GSSException ge = new GSSException(</span>
                    GSSException.DEFECTIVE_TOKEN, -1,
                    &quot;Cannot read complete token&quot;);
<span class="nc" id="L622">                ge.initCause(e);</span>
<span class="nc" id="L623">                throw ge;</span>
<span class="nc" id="L624">            }</span>

<span class="nc" id="L626">            arcFourDecrypt(token, ctext, 0, cLen, plaintext, pStart);</span>
<span class="nc" id="L627">            break;</span>

        default:
<span class="nc" id="L630">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;Unsupported seal algorithm: &quot; + sealAlg);
        }
<span class="nc" id="L633">    }</span>

    void decryptData(WrapToken_v2 token, InputStream cipherStream, int cLen,
        byte[] plaintext, int pStart, int key_usage)
        throws GSSException, IOException {

        // Read encrypted data from stream
<span class="nc" id="L640">        byte[] ciphertext = new byte[cLen];</span>
        try {
<span class="nc" id="L642">                Krb5Token.readFully(cipherStream, ciphertext, 0, cLen);</span>
<span class="nc" id="L643">        } catch (IOException e) {</span>
<span class="nc" id="L644">                GSSException ge = new GSSException(</span>
                    GSSException.DEFECTIVE_TOKEN, -1,
                    &quot;Cannot read complete token&quot;);
<span class="nc" id="L647">                ge.initCause(e);</span>
<span class="nc" id="L648">                throw ge;</span>
<span class="nc" id="L649">        }</span>
<span class="nc bnc" id="L650" title="All 3 branches missed.">        switch (etype) {</span>
            case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96:
<span class="nc" id="L652">                    aes128Decrypt(token, ciphertext, 0, cLen,</span>
                                plaintext, pStart, key_usage);
<span class="nc" id="L654">                    break;</span>
            case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96:
<span class="nc" id="L656">                    aes256Decrypt(token, ciphertext, 0, cLen,</span>
                                plaintext, pStart, key_usage);
<span class="nc" id="L658">                    break;</span>
            default:
<span class="nc" id="L660">                    throw new GSSException(GSSException.FAILURE, -1,</span>
                        &quot;Unsupported etype: &quot; + etype);
        }
<span class="nc" id="L663">    }</span>

    void encryptData(WrapToken token, byte[] confounder, byte[] plaintext,
        int start, int len, byte[] padding, OutputStream os)
        throws GSSException, IOException {

<span class="nc bnc" id="L669" title="All 4 branches missed.">        switch (sealAlg) {</span>
        case MessageToken.SEAL_ALG_DES:
            // Encrypt on the fly and write
<span class="nc" id="L672">            Cipher des = getInitializedDes(true, getDesEncryptionKey(keybytes),</span>
                ZERO_IV);
<span class="nc" id="L674">            CipherOutputStream cos = new CipherOutputStream(os, des);</span>
            // debug(getHexBytes(confounder, confounder.length));
<span class="nc" id="L676">            cos.write(confounder);</span>
            // debug(&quot; &quot; + getHexBytes(plaintext, start, len));
<span class="nc" id="L678">            cos.write(plaintext, start, len);</span>
            // debug(&quot; &quot; + getHexBytes(padding, padding.length));
<span class="nc" id="L680">            cos.write(padding);</span>
<span class="nc" id="L681">            break;</span>

        case MessageToken.SEAL_ALG_DES3_KD:
<span class="nc" id="L684">            byte[] ctext = des3KdEncrypt(confounder, plaintext, start, len,</span>
                padding);

            // Write to stream
<span class="nc" id="L688">            os.write(ctext);</span>
<span class="nc" id="L689">            break;</span>

        case MessageToken.SEAL_ALG_ARCFOUR_HMAC:
<span class="nc" id="L692">            byte[] ciphertext = arcFourEncrypt(token, confounder, plaintext,</span>
                start, len, padding);

            // Write to stream
<span class="nc" id="L696">            os.write(ciphertext);</span>
<span class="nc" id="L697">            break;</span>

        default:
<span class="nc" id="L700">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;Unsupported seal algorithm: &quot; + sealAlg);
        }
<span class="nc" id="L703">    }</span>

    /*
     * Encrypt data in the new GSS tokens
     *
     * Wrap Tokens (with confidentiality)
     * { Encrypt(16-byte confounder | plaintext | 16-byte token_header) |
     *           12-byte HMAC }
     * where HMAC is on {16-byte confounder | plaintext | 16-byte token_header}
     * HMAC is not encrypted; it is appended at the end.
     */
    byte[] encryptData(WrapToken_v2 token, byte[] confounder, byte[] tokenHeader,
            byte[] plaintext, int start, int len, int key_usage)
            throws GSSException {

<span class="pc bpc" id="L718" title="2 of 3 branches missed.">        switch (etype) {</span>
            case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96:
<span class="fc" id="L720">                return aes128Encrypt(confounder, tokenHeader,</span>
                            plaintext, start, len, key_usage);
            case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96:
<span class="nc" id="L723">                return aes256Encrypt(confounder, tokenHeader,</span>
                            plaintext, start, len, key_usage);
            default:
<span class="nc" id="L726">                throw new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Unsupported etype: &quot; + etype);
        }
    }

    void encryptData(WrapToken token, byte[] confounder, byte[] plaintext,
        int pStart, int pLen, byte[] padding, byte[] ciphertext, int cStart)
        throws GSSException {

<span class="nc bnc" id="L735" title="All 4 branches missed.">        switch (sealAlg) {</span>
        case MessageToken.SEAL_ALG_DES:
<span class="nc" id="L737">            int pos = cStart;</span>
            // Encrypt and write
<span class="nc" id="L739">            Cipher des = getInitializedDes(true, getDesEncryptionKey(keybytes),</span>
                ZERO_IV);
            try {
                // debug(getHexBytes(confounder, confounder.length));
<span class="nc" id="L743">                pos += des.update(confounder, 0, confounder.length,</span>
                                  ciphertext, pos);
                // debug(&quot; &quot; + getHexBytes(dataBytes, dataOffset, dataLen));
<span class="nc" id="L746">                pos += des.update(plaintext, pStart, pLen,</span>
                                  ciphertext, pos);
                // debug(&quot; &quot; + getHexBytes(padding, padding.length));
<span class="nc" id="L749">                des.update(padding, 0, padding.length,</span>
                           ciphertext, pos);
<span class="nc" id="L751">                des.doFinal();</span>
<span class="nc" id="L752">            } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L753">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L754">                    &quot;Could not use DES Cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L755">                ge.initCause(e);</span>
<span class="nc" id="L756">                throw ge;</span>
<span class="nc" id="L757">            }</span>
            break;

        case MessageToken.SEAL_ALG_DES3_KD:
<span class="nc" id="L761">            byte[] ctext = des3KdEncrypt(confounder, plaintext, pStart, pLen,</span>
                padding);
<span class="nc" id="L763">            System.arraycopy(ctext, 0, ciphertext, cStart, ctext.length);</span>
<span class="nc" id="L764">            break;</span>

        case MessageToken.SEAL_ALG_ARCFOUR_HMAC:
<span class="nc" id="L767">            byte[] ctext2 = arcFourEncrypt(token, confounder, plaintext, pStart,</span>
                pLen, padding);
<span class="nc" id="L769">            System.arraycopy(ctext2, 0, ciphertext, cStart, ctext2.length);</span>
<span class="nc" id="L770">            break;</span>

        default:
<span class="nc" id="L773">            throw new GSSException(GSSException.FAILURE, -1,</span>
                &quot;Unsupported seal algorithm: &quot; + sealAlg);
        }
<span class="nc" id="L776">    }</span>

    /*
     * Encrypt data in the new GSS tokens
     *
     * Wrap Tokens (with confidentiality)
     * { Encrypt(16-byte confounder | plaintext | 16-byte token_header) |
     *           12-byte HMAC }
     * where HMAC is on {16-byte confounder | plaintext | 16-byte token_header}
     * HMAC is not encrypted; it is appended at the end.
     */
    int encryptData(WrapToken_v2 token, byte[] confounder, byte[] tokenHeader,
        byte[] plaintext, int pStart, int pLen, byte[] ciphertext, int cStart,
        int key_usage) throws GSSException {

<span class="nc" id="L791">        byte[] ctext = null;</span>
<span class="nc bnc" id="L792" title="All 3 branches missed.">        switch (etype) {</span>
            case EncryptedData.ETYPE_AES128_CTS_HMAC_SHA1_96:
<span class="nc" id="L794">                    ctext = aes128Encrypt(confounder, tokenHeader,</span>
                                plaintext, pStart, pLen, key_usage);
<span class="nc" id="L796">                    break;</span>
            case EncryptedData.ETYPE_AES256_CTS_HMAC_SHA1_96:
<span class="nc" id="L798">                    ctext = aes256Encrypt(confounder, tokenHeader,</span>
                                plaintext, pStart, pLen, key_usage);
<span class="nc" id="L800">                    break;</span>
            default:
<span class="nc" id="L802">                    throw new GSSException(GSSException.FAILURE, -1,</span>
                        &quot;Unsupported etype: &quot; + etype);
        }
<span class="nc" id="L805">        System.arraycopy(ctext, 0, ciphertext, cStart, ctext.length);</span>
<span class="nc" id="L806">        return ctext.length;</span>
    }

    // --------------------- DES methods

    /**
     * Computes the DesCbc checksum based on the algorithm published in FIPS
     * Publication 113. This involves applying padding to the data passed
     * in, then performing DesCbc encryption on the data with a zero initial
     * vector, and finally returning the last 8 bytes of the encryption
     * result.
     *
     * @param key the bytes for the DES key
     * @param header a header to process first before the data is.
     * @param data the data to checksum
     * @param offset the offset where the data begins
     * @param len the length of the data
     * @throws GSSException when an error occuse in the encryption
     */
    private byte[] getDesCbcChecksum(byte key[],
                                     byte[] header,
                                     byte[] data, int offset, int len)
        throws GSSException {

<span class="nc" id="L830">        Cipher des = getInitializedDes(true, key, ZERO_IV);</span>

<span class="nc" id="L832">        int blockSize = des.getBlockSize();</span>

        /*
         * Here the data need not be a multiple of the blocksize
         * (8). Encrypt and throw away results for all blocks except for
         * the very last block.
         */

<span class="nc" id="L840">        byte[] finalBlock = new byte[blockSize];</span>

<span class="nc" id="L842">        int numBlocks = len / blockSize;</span>
<span class="nc" id="L843">        int lastBytes = len % blockSize;</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">        if (lastBytes == 0) {</span>
            // No need for padding. Save last block from application data
<span class="nc" id="L846">            numBlocks -= 1;</span>
<span class="nc" id="L847">            System.arraycopy(data, offset + numBlocks*blockSize,</span>
                             finalBlock, 0, blockSize);
        } else {
<span class="nc" id="L850">            System.arraycopy(data, offset + numBlocks*blockSize,</span>
                             finalBlock, 0, lastBytes);
            // Zero padding automatically done
        }

        try {
<span class="nc bnc" id="L856" title="All 2 branches missed.">            byte[] temp = new byte[Math.max(blockSize,</span>
                (header == null? blockSize : header.length))];

<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (header != null) {</span>
                // header will be null when doing DES-MD5 Checksum
<span class="nc" id="L861">                des.update(header, 0, header.length, temp, 0);</span>
            }

            // Iterate over all but the last block
<span class="nc bnc" id="L865" title="All 2 branches missed.">            for (int i = 0; i &lt; numBlocks; i++) {</span>
<span class="nc" id="L866">                des.update(data, offset, blockSize,</span>
                           temp, 0);
<span class="nc" id="L868">                offset += blockSize;</span>
            }

            // Now process the final block
<span class="nc" id="L872">            byte[] retVal = new byte[blockSize];</span>
<span class="nc" id="L873">            des.update(finalBlock, 0, blockSize, retVal, 0);</span>
<span class="nc" id="L874">            des.doFinal();</span>

<span class="nc" id="L876">            return retVal;</span>
<span class="nc" id="L877">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L878">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L879">                &quot;Could not use DES Cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L880">            ge.initCause(e);</span>
<span class="nc" id="L881">            throw ge;</span>
        }
    }

    /**
     * Obtains an initialized DES cipher.
     *
     * @param encryptMode true if encryption is desired, false is decryption
     * is desired.
     * @param key the bytes for the DES key
     * @param ivBytes the initial vector bytes
     */
    private final Cipher getInitializedDes(boolean encryptMode, byte[] key,
                                          byte[] ivBytes)
        throws  GSSException  {


        try {
<span class="nc" id="L899">            IvParameterSpec iv = new IvParameterSpec(ivBytes);</span>
<span class="nc" id="L900">            SecretKey jceKey = (SecretKey) (new SecretKeySpec(key, &quot;DES&quot;));</span>

<span class="nc" id="L902">            Cipher desCipher = Cipher.getInstance(&quot;DES/CBC/NoPadding&quot;);</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">            desCipher.init(</span>
                (encryptMode ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE),
                jceKey, iv);
<span class="nc" id="L906">            return desCipher;</span>
<span class="nc" id="L907">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L908">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L909">                e.getMessage());</span>
<span class="nc" id="L910">            ge.initCause(e);</span>
<span class="nc" id="L911">            throw ge;</span>
        }
    }

    /**
     * Helper routine to decrypt fromm a byte array and write the
     * application data straight to an output array with minimal
     * buffer copies. The confounder and the padding are stored
     * separately and not copied into this output array.
     * @param key the DES key to use
     * @param cipherText the encrypted data
     * @param offset the offset for the encrypted data
     * @param len the length of the encrypted data
     * @param dataOutBuf the output buffer where the application data
     * should be writte
     * @param dataOffset the offser where the application data should
     * be written.
     * @throws GSSException is an error occurs while decrypting the
     * data
     */
    private void desCbcDecrypt(WrapToken token, byte[] key, byte[] cipherText,
        int offset, int len, byte[] dataOutBuf, int dataOffset)
         throws GSSException {

        try {

<span class="nc" id="L937">            int temp = 0;</span>

<span class="nc" id="L939">            Cipher des = getInitializedDes(false, key, ZERO_IV);</span>

            /*
             * Remove the counfounder first.
             * CONFOUNDER_SIZE is one DES block ie 8 bytes.
             */
<span class="nc" id="L945">            temp = des.update(cipherText, offset, WrapToken.CONFOUNDER_SIZE,</span>
                              token.confounder);
            // temp should be CONFOUNDER_SIZE
            // debug(&quot;\n\ttemp is &quot; + temp + &quot; and CONFOUNDER_SIZE is &quot;
            //  + CONFOUNDER_SIZE);

<span class="nc" id="L951">            offset += WrapToken.CONFOUNDER_SIZE;</span>
<span class="nc" id="L952">            len -= WrapToken.CONFOUNDER_SIZE;</span>

            /*
             * len is a multiple of 8 due to padding.
             * Decrypt all blocks directly into the output buffer except for
             * the very last block. Remove the trailing padding bytes from the
             * very last block and copy that into the output buffer.
             */

<span class="nc" id="L961">            int blockSize = des.getBlockSize();</span>
<span class="nc" id="L962">            int numBlocks = len / blockSize - 1;</span>

            // Iterate over all but the last block
<span class="nc bnc" id="L965" title="All 2 branches missed.">            for (int i = 0; i &lt; numBlocks; i++) {</span>
<span class="nc" id="L966">                temp = des.update(cipherText, offset, blockSize,</span>
                                  dataOutBuf, dataOffset);
                // temp should be blockSize
                // debug(&quot;\n\ttemp is &quot; + temp + &quot; and blockSize is &quot;
                //    + blockSize);

<span class="nc" id="L972">                offset += blockSize;</span>
<span class="nc" id="L973">                dataOffset += blockSize;</span>
            }

            // Now process the last block
<span class="nc" id="L977">            byte[] finalBlock = new byte[blockSize];</span>
<span class="nc" id="L978">            des.update(cipherText, offset, blockSize, finalBlock);</span>

<span class="nc" id="L980">            des.doFinal();</span>

            /*
             * There is always at least one padding byte. The padding bytes
             * are all the value of the number of padding bytes.
             */

<span class="nc" id="L987">            int padSize = finalBlock[blockSize - 1];</span>
<span class="nc bnc" id="L988" title="All 4 branches missed.">            if (padSize &lt; 1  || padSize &gt; 8)</span>
<span class="nc" id="L989">                throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,</span>
                                        &quot;Invalid padding on Wrap Token&quot;);
<span class="nc" id="L991">            token.padding = WrapToken.pads[padSize];</span>
<span class="nc" id="L992">            blockSize -= padSize;</span>

            // Copy this last block into the output buffer
<span class="nc" id="L995">            System.arraycopy(finalBlock, 0, dataOutBuf, dataOffset,</span>
                             blockSize);

<span class="nc" id="L998">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L999">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L1000">                &quot;Could not use DES cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L1001">            ge.initCause(e);</span>
<span class="nc" id="L1002">            throw ge;</span>
<span class="nc" id="L1003">        }</span>
<span class="nc" id="L1004">    }</span>

    /**
     * Helper routine to decrypt from an InputStream and write the
     * application data straight to an output array with minimal
     * buffer copies. The confounder and the padding are stored
     * separately and not copied into this output array.
     * @param key the DES key to use
     * @param is the InputStream from which the cipher text should be
     * read
     * @param len the length of the ciphertext data
     * @param dataOutBuf the output buffer where the application data
     * should be writte
     * @param dataOffset the offser where the application data should
     * be written.
     * @throws GSSException is an error occurs while decrypting the
     * data
     */
    private void desCbcDecrypt(WrapToken token, byte[] key,
        InputStream is, int len, byte[] dataOutBuf, int dataOffset)
        throws GSSException, IOException {

<span class="nc" id="L1026">        int temp = 0;</span>

<span class="nc" id="L1028">        Cipher des = getInitializedDes(false, key, ZERO_IV);</span>

<span class="nc" id="L1030">        WrapTokenInputStream truncatedInputStream =</span>
            new WrapTokenInputStream(is, len);
<span class="nc" id="L1032">        CipherInputStream cis = new CipherInputStream(truncatedInputStream,</span>
                                                      des);
        /*
         * Remove the counfounder first.
         * CONFOUNDER_SIZE is one DES block ie 8 bytes.
         */
<span class="nc" id="L1038">        temp = cis.read(token.confounder);</span>

<span class="nc" id="L1040">        len -= temp;</span>
        // temp should be CONFOUNDER_SIZE
        // debug(&quot;Got &quot; + temp + &quot; bytes; CONFOUNDER_SIZE is &quot;
        //     + CONFOUNDER_SIZE + &quot;\n&quot;);
        // debug(&quot;Confounder is &quot; + getHexBytes(confounder) + &quot;\n&quot;);


        /*
         * len is a multiple of 8 due to padding.
         * Decrypt all blocks directly into the output buffer except for
         * the very last block. Remove the trailing padding bytes from the
         * very last block and copy that into the output buffer.
         */

<span class="nc" id="L1054">        int blockSize = des.getBlockSize();</span>
<span class="nc" id="L1055">        int numBlocks = len / blockSize - 1;</span>

        // Iterate over all but the last block
<span class="nc bnc" id="L1058" title="All 2 branches missed.">        for (int i = 0; i &lt; numBlocks; i++) {</span>
            // debug(&quot;dataOffset is &quot; + dataOffset + &quot;\n&quot;);
<span class="nc" id="L1060">            temp = cis.read(dataOutBuf, dataOffset, blockSize);</span>

            // temp should be blockSize
            // debug(&quot;Got &quot; + temp + &quot; bytes and blockSize is &quot;
            //    + blockSize + &quot;\n&quot;);
            // debug(&quot;Bytes are: &quot;
            //    + getHexBytes(dataOutBuf, dataOffset, temp) + &quot;\n&quot;);
<span class="nc" id="L1067">            dataOffset += blockSize;</span>
        }

        // Now process the last block
<span class="nc" id="L1071">        byte[] finalBlock = new byte[blockSize];</span>
        // debug(&quot;Will call read on finalBlock&quot; + &quot;\n&quot;);
<span class="nc" id="L1073">        temp = cis.read(finalBlock);</span>
        // temp should be blockSize
        /*
          debug(&quot;Got &quot; + temp + &quot; bytes and blockSize is &quot;
          + blockSize + &quot;\n&quot;);
          debug(&quot;Bytes are: &quot;
          + getHexBytes(finalBlock, 0, temp) + &quot;\n&quot;);
          debug(&quot;Will call doFinal&quot; + &quot;\n&quot;);
        */
        try {
<span class="nc" id="L1083">            des.doFinal();</span>
<span class="nc" id="L1084">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L1085">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L1086">                &quot;Could not use DES cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L1087">            ge.initCause(e);</span>
<span class="nc" id="L1088">            throw ge;</span>
<span class="nc" id="L1089">        }</span>

        /*
         * There is always at least one padding byte. The padding bytes
         * are all the value of the number of padding bytes.
         */

<span class="nc" id="L1096">        int padSize = finalBlock[blockSize - 1];</span>
<span class="nc bnc" id="L1097" title="All 4 branches missed.">        if (padSize &lt; 1  || padSize &gt; 8)</span>
<span class="nc" id="L1098">            throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,</span>
                                   &quot;Invalid padding on Wrap Token&quot;);
<span class="nc" id="L1100">        token.padding = WrapToken.pads[padSize];</span>
<span class="nc" id="L1101">        blockSize -= padSize;</span>

        // Copy this last block into the output buffer
<span class="nc" id="L1104">        System.arraycopy(finalBlock, 0, dataOutBuf, dataOffset,</span>
                         blockSize);
<span class="nc" id="L1106">    }</span>

    private static byte[] getDesEncryptionKey(byte[] key)
        throws GSSException {

        /*
         * To meet export control requirements, double check that the
         * key being used is no longer than 64 bits.
         *
         * Note that from a protocol point of view, an
         * algorithm that is not DES will be rejected before this
         * point. Also, a DES key that is not 64 bits will be
         * rejected by a good JCE provider.
         */
<span class="nc bnc" id="L1120" title="All 2 branches missed.">        if (key.length &gt; 8)</span>
<span class="nc" id="L1121">            throw new GSSException(GSSException.FAILURE, -100,</span>
                                   &quot;Invalid DES Key!&quot;);

<span class="nc" id="L1124">        byte[] retVal = new byte[key.length];</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">        for (int i = 0; i &lt; key.length; i++)</span>
<span class="nc" id="L1126">            retVal[i] = (byte)(key[i] ^ 0xf0);  // RFC 1964, Section 1.2.2</span>
<span class="nc" id="L1127">        return retVal;</span>
    }

    // ---- DES3-KD methods
    private void des3KdDecrypt(WrapToken token, byte[] ciphertext,
        int cStart, int cLen, byte[] plaintext, int pStart)
        throws GSSException {
        byte[] ptext;
        try {
<span class="nc" id="L1136">            ptext = Des3.decryptRaw(keybytes, KG_USAGE_SEAL, ZERO_IV,</span>
                ciphertext, cStart, cLen);
<span class="nc" id="L1138">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L1139">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L1140">                &quot;Could not use DES3-KD Cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L1141">            ge.initCause(e);</span>
<span class="nc" id="L1142">            throw ge;</span>
<span class="nc" id="L1143">        }</span>

        /*
        Krb5Token.debug(&quot;\ndes3KdDecrypt in: &quot; +
            Krb5Token.getHexBytes(ciphertext, cStart, cLen));
        Krb5Token.debug(&quot;\ndes3KdDecrypt plain: &quot; +
            Krb5Token.getHexBytes(ptext));
        */

        // Strip out confounder and padding
        /*
         * There is always at least one padding byte. The padding bytes
         * are all the value of the number of padding bytes.
         */
<span class="nc" id="L1157">        int padSize = ptext[ptext.length - 1];</span>
<span class="nc bnc" id="L1158" title="All 4 branches missed.">        if (padSize &lt; 1  || padSize &gt; 8)</span>
<span class="nc" id="L1159">            throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,</span>
                &quot;Invalid padding on Wrap Token&quot;);

<span class="nc" id="L1162">        token.padding = WrapToken.pads[padSize];</span>
<span class="nc" id="L1163">        int len = ptext.length - WrapToken.CONFOUNDER_SIZE - padSize;</span>

<span class="nc" id="L1165">        System.arraycopy(ptext, WrapToken.CONFOUNDER_SIZE,</span>
            plaintext, pStart, len);

        // Needed to calculate checksum
<span class="nc" id="L1169">        System.arraycopy(ptext, 0, token.confounder,</span>
            0, WrapToken.CONFOUNDER_SIZE);
<span class="nc" id="L1171">    }</span>

    private byte[] des3KdEncrypt(byte[] confounder, byte[] plaintext,
        int start, int len, byte[] padding) throws GSSException {


        // [confounder | plaintext | padding]
<span class="nc" id="L1178">        byte[] all = new byte[confounder.length + len + padding.length];</span>
<span class="nc" id="L1179">        System.arraycopy(confounder, 0, all, 0, confounder.length);</span>
<span class="nc" id="L1180">        System.arraycopy(plaintext, start, all, confounder.length, len);</span>
<span class="nc" id="L1181">        System.arraycopy(padding, 0, all, confounder.length + len,</span>
            padding.length);

        // Krb5Token.debug(&quot;\ndes3KdEncrypt:&quot; + Krb5Token.getHexBytes(all));

        // Encrypt
        try {
<span class="nc" id="L1188">            byte[] answer = Des3.encryptRaw(keybytes, KG_USAGE_SEAL, ZERO_IV,</span>
                all, 0, all.length);
            // Krb5Token.debug(&quot;\ndes3KdEncrypt encrypted:&quot; +
            //  Krb5Token.getHexBytes(answer));
<span class="nc" id="L1192">            return answer;</span>
<span class="nc" id="L1193">        } catch (Exception e) {</span>
            // GeneralSecurityException, KrbCryptoException
<span class="nc" id="L1195">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L1196">                &quot;Could not use DES3-KD Cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L1197">            ge.initCause(e);</span>
<span class="nc" id="L1198">            throw ge;</span>
        }
    }

    // ---- RC4-HMAC methods
    private void arcFourDecrypt(WrapToken token, byte[] ciphertext,
        int cStart, int cLen, byte[] plaintext, int pStart)
        throws GSSException {

        // obtain Sequence number needed for decryption
        // first decrypt the Sequence Number using checksum
<span class="nc" id="L1209">        byte[] seqNum = decryptSeq(token.getChecksum(),</span>
<span class="nc" id="L1210">                token.getEncSeqNumber(), 0, 8);</span>

        byte[] ptext;
        try {
<span class="nc" id="L1214">            ptext = ArcFourHmac.decryptRaw(keybytes, KG_USAGE_SEAL, ZERO_IV,</span>
                ciphertext, cStart, cLen, seqNum);
<span class="nc" id="L1216">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L1217">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L1218">                &quot;Could not use ArcFour Cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L1219">            ge.initCause(e);</span>
<span class="nc" id="L1220">            throw ge;</span>
<span class="nc" id="L1221">        }</span>

        /*
        Krb5Token.debug(&quot;\narcFourDecrypt in: &quot; +
            Krb5Token.getHexBytes(ciphertext, cStart, cLen));
        Krb5Token.debug(&quot;\narcFourDecrypt plain: &quot; +
            Krb5Token.getHexBytes(ptext));
        */

        // Strip out confounder and padding
        /*
         * There is always at least one padding byte. The padding bytes
         * are all the value of the number of padding bytes.
         */
<span class="nc" id="L1235">        int padSize = ptext[ptext.length - 1];</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">        if (padSize &lt; 1)</span>
<span class="nc" id="L1237">            throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,</span>
                &quot;Invalid padding on Wrap Token&quot;);

<span class="nc" id="L1240">        token.padding = WrapToken.pads[padSize];</span>
<span class="nc" id="L1241">        int len = ptext.length - WrapToken.CONFOUNDER_SIZE - padSize;</span>

<span class="nc" id="L1243">        System.arraycopy(ptext, WrapToken.CONFOUNDER_SIZE,</span>
            plaintext, pStart, len);

        // Krb5Token.debug(&quot;\narcFourDecrypt plaintext: &quot; +
        //    Krb5Token.getHexBytes(plaintext));

        // Needed to calculate checksum
<span class="nc" id="L1250">        System.arraycopy(ptext, 0, token.confounder,</span>
            0, WrapToken.CONFOUNDER_SIZE);
<span class="nc" id="L1252">    }</span>

    private byte[] arcFourEncrypt(WrapToken token, byte[] confounder,
        byte[] plaintext, int start, int len, byte[] padding)
        throws GSSException {

        // [confounder | plaintext | padding]
<span class="nc" id="L1259">        byte[] all = new byte[confounder.length + len + padding.length];</span>
<span class="nc" id="L1260">        System.arraycopy(confounder, 0, all, 0, confounder.length);</span>
<span class="nc" id="L1261">        System.arraycopy(plaintext, start, all, confounder.length, len);</span>
<span class="nc" id="L1262">        System.arraycopy(padding, 0, all, confounder.length + len,</span>
            padding.length);

        // get the token Sequence Number required for encryption
        // Note: When using this RC4 based encryption type, the sequence number
        // is always sent in big-endian rather than little-endian order.
<span class="nc" id="L1268">        byte[] seqNum = new byte[4];</span>
<span class="nc" id="L1269">        WrapToken.writeBigEndian(token.getSequenceNumber(), seqNum);</span>

        // Krb5Token.debug(&quot;\narcFourEncrypt:&quot; + Krb5Token.getHexBytes(all));

        // Encrypt
        try {
<span class="nc" id="L1275">            byte[] answer = ArcFourHmac.encryptRaw(keybytes, KG_USAGE_SEAL,</span>
                                        seqNum, all, 0, all.length);
            // Krb5Token.debug(&quot;\narcFourEncrypt encrypted:&quot; +
            //  Krb5Token.getHexBytes(answer));
<span class="nc" id="L1279">            return answer;</span>
<span class="nc" id="L1280">        } catch (Exception e) {</span>
            // GeneralSecurityException, KrbCryptoException
<span class="nc" id="L1282">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L1283">                &quot;Could not use ArcFour Cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L1284">            ge.initCause(e);</span>
<span class="nc" id="L1285">            throw ge;</span>
        }
    }

    // ---- AES methods
    private byte[] aes128Encrypt(byte[] confounder, byte[] tokenHeader,
        byte[] plaintext, int start, int len, int key_usage)
        throws GSSException {

        // encrypt { AES-plaintext-data | filler | header }
        // AES-plaintext-data { confounder | plaintext }
        // WrapToken = { tokenHeader |
        //      Encrypt (confounder | plaintext | tokenHeader ) | HMAC }

<span class="fc" id="L1299">        byte[] all = new byte[confounder.length + len + tokenHeader.length];</span>
<span class="fc" id="L1300">        System.arraycopy(confounder, 0, all, 0, confounder.length);</span>
<span class="fc" id="L1301">        System.arraycopy(plaintext, start, all, confounder.length, len);</span>
<span class="fc" id="L1302">        System.arraycopy(tokenHeader, 0, all, confounder.length+len,</span>
                                tokenHeader.length);

        // Krb5Token.debug(&quot;\naes128Encrypt:&quot; + Krb5Token.getHexBytes(all));
        try {
<span class="fc" id="L1307">            byte[] answer = Aes128.encryptRaw(keybytes, key_usage,</span>
                                ZERO_IV_AES,
                                all, 0, all.length);
            // Krb5Token.debug(&quot;\naes128Encrypt encrypted:&quot; +
            //                  Krb5Token.getHexBytes(answer));
<span class="fc" id="L1312">            return answer;</span>
<span class="nc" id="L1313">        } catch (Exception e) {</span>
            // GeneralSecurityException, KrbCryptoException
<span class="nc" id="L1315">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L1316">                &quot;Could not use AES128 Cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L1317">            ge.initCause(e);</span>
<span class="nc" id="L1318">            throw ge;</span>
        }
    }

    private void aes128Decrypt(WrapToken_v2 token, byte[] ciphertext,
        int cStart, int cLen, byte[] plaintext, int pStart, int key_usage)
        throws GSSException {

<span class="fc" id="L1326">        byte[] ptext = null;</span>

        try {
<span class="fc" id="L1329">            ptext = Aes128.decryptRaw(keybytes, key_usage,</span>
                        ZERO_IV_AES, ciphertext, cStart, cLen);
<span class="nc" id="L1331">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L1332">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L1333">                &quot;Could not use AES128 Cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L1334">            ge.initCause(e);</span>
<span class="nc" id="L1335">            throw ge;</span>
<span class="fc" id="L1336">        }</span>

        /*
        Krb5Token.debug(&quot;\naes128Decrypt in: &quot; +
            Krb5Token.getHexBytes(ciphertext, cStart, cLen));
        Krb5Token.debug(&quot;\naes128Decrypt plain: &quot; +
            Krb5Token.getHexBytes(ptext));
        Krb5Token.debug(&quot;\naes128Decrypt ptext: &quot; +
            Krb5Token.getHexBytes(ptext));
        */

        // Strip out confounder and token header
<span class="fc" id="L1348">        int len = ptext.length - WrapToken_v2.CONFOUNDER_SIZE -</span>
                        WrapToken_v2.TOKEN_HEADER_SIZE;
<span class="fc" id="L1350">        System.arraycopy(ptext, WrapToken_v2.CONFOUNDER_SIZE,</span>
                                plaintext, pStart, len);

        /*
        Krb5Token.debug(&quot;\naes128Decrypt plaintext: &quot; +
            Krb5Token.getHexBytes(plaintext, pStart, len));
        */
<span class="fc" id="L1357">    }</span>

    private byte[] aes256Encrypt(byte[] confounder, byte[] tokenHeader,
        byte[] plaintext, int start, int len, int key_usage)
        throws GSSException {

        // encrypt { AES-plaintext-data | filler | header }
        // AES-plaintext-data { confounder | plaintext }
        // WrapToken = { tokenHeader |
        //       Encrypt (confounder | plaintext | tokenHeader ) | HMAC }

<span class="nc" id="L1368">        byte[] all = new byte[confounder.length + len + tokenHeader.length];</span>
<span class="nc" id="L1369">        System.arraycopy(confounder, 0, all, 0, confounder.length);</span>
<span class="nc" id="L1370">        System.arraycopy(plaintext, start, all, confounder.length, len);</span>
<span class="nc" id="L1371">        System.arraycopy(tokenHeader, 0, all, confounder.length+len,</span>
                                tokenHeader.length);

        // Krb5Token.debug(&quot;\naes256Encrypt:&quot; + Krb5Token.getHexBytes(all));

        try {
<span class="nc" id="L1377">            byte[] answer = Aes256.encryptRaw(keybytes, key_usage,</span>
                                ZERO_IV_AES, all, 0, all.length);
            // Krb5Token.debug(&quot;\naes256Encrypt encrypted:&quot; +
            //  Krb5Token.getHexBytes(answer));
<span class="nc" id="L1381">            return answer;</span>
<span class="nc" id="L1382">        } catch (Exception e) {</span>
            // GeneralSecurityException, KrbCryptoException
<span class="nc" id="L1384">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L1385">                &quot;Could not use AES256 Cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L1386">            ge.initCause(e);</span>
<span class="nc" id="L1387">            throw ge;</span>
        }
    }

    private void aes256Decrypt(WrapToken_v2 token, byte[] ciphertext,
        int cStart, int cLen, byte[] plaintext, int pStart, int key_usage)
        throws GSSException {

        byte[] ptext;
        try {
<span class="nc" id="L1397">            ptext = Aes256.decryptRaw(keybytes, key_usage,</span>
                        ZERO_IV_AES, ciphertext, cStart, cLen);
<span class="nc" id="L1399">        } catch (GeneralSecurityException e) {</span>
<span class="nc" id="L1400">            GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
<span class="nc" id="L1401">                &quot;Could not use AES128 Cipher - &quot; + e.getMessage());</span>
<span class="nc" id="L1402">            ge.initCause(e);</span>
<span class="nc" id="L1403">            throw ge;</span>
<span class="nc" id="L1404">        }</span>

        /*
        Krb5Token.debug(&quot;\naes256Decrypt in: &quot; +
            Krb5Token.getHexBytes(ciphertext, cStart, cLen));
        Krb5Token.debug(&quot;\naes256Decrypt plain: &quot; +
            Krb5Token.getHexBytes(ptext));
        Krb5Token.debug(&quot;\naes256Decrypt ptext: &quot; +
            Krb5Token.getHexBytes(ptext));
        */

        // Strip out confounder and token header
<span class="nc" id="L1416">        int len = ptext.length - WrapToken_v2.CONFOUNDER_SIZE -</span>
                        WrapToken_v2.TOKEN_HEADER_SIZE;
<span class="nc" id="L1418">        System.arraycopy(ptext, WrapToken_v2.CONFOUNDER_SIZE,</span>
                                plaintext, pStart, len);

        /*
        Krb5Token.debug(&quot;\naes128Decrypt plaintext: &quot; +
            Krb5Token.getHexBytes(plaintext, pStart, len));
        */

<span class="nc" id="L1426">    }</span>

    /**
     * This class provides a truncated inputstream needed by WrapToken. The
     * truncated inputstream is passed to CipherInputStream. It prevents
     * the CipherInputStream from treating the bytes of the following token
     * as part fo the ciphertext for this token.
     */
    class WrapTokenInputStream extends InputStream {

        private InputStream is;
        private int length;
        private int remaining;

        private int temp;

<span class="nc" id="L1442">        public WrapTokenInputStream(InputStream is, int length) {</span>
<span class="nc" id="L1443">            this.is = is;</span>
<span class="nc" id="L1444">            this.length = length;</span>
<span class="nc" id="L1445">            remaining = length;</span>
<span class="nc" id="L1446">        }</span>

        public final int read() throws IOException {
<span class="nc bnc" id="L1449" title="All 2 branches missed.">            if (remaining == 0)</span>
<span class="nc" id="L1450">                return -1;</span>
            else {
<span class="nc" id="L1452">                temp = is.read();</span>
<span class="nc bnc" id="L1453" title="All 2 branches missed.">                if (temp != -1)</span>
<span class="nc" id="L1454">                    remaining -= temp;</span>
<span class="nc" id="L1455">                return temp;</span>
            }
        }

        public final int read(byte[] b) throws IOException {
<span class="nc bnc" id="L1460" title="All 2 branches missed.">            if (remaining == 0)</span>
<span class="nc" id="L1461">                return -1;</span>
            else {
<span class="nc" id="L1463">                temp = Math.min(remaining, b.length);</span>
<span class="nc" id="L1464">                temp = is.read(b, 0, temp);</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">                if (temp != -1)</span>
<span class="nc" id="L1466">                    remaining -= temp;</span>
<span class="nc" id="L1467">                return temp;</span>
            }
        }

        public final int read(byte[] b,
                              int off,
                              int len) throws IOException {
<span class="nc bnc" id="L1474" title="All 2 branches missed.">            if (remaining == 0)</span>
<span class="nc" id="L1475">                return -1;</span>
            else {
<span class="nc" id="L1477">                temp = Math.min(remaining, len);</span>
<span class="nc" id="L1478">                temp = is.read(b, off, temp);</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">                if (temp != -1)</span>
<span class="nc" id="L1480">                    remaining -= temp;</span>
<span class="nc" id="L1481">                return temp;</span>
            }
        }

        public final long skip(long n)  throws IOException {
<span class="nc bnc" id="L1486" title="All 2 branches missed.">            if (remaining == 0)</span>
<span class="nc" id="L1487">                return 0;</span>
            else {
<span class="nc" id="L1489">                temp = (int) Math.min(remaining, n);</span>
<span class="nc" id="L1490">                temp = (int) is.skip(temp);</span>
<span class="nc" id="L1491">                remaining -= temp;</span>
<span class="nc" id="L1492">                return temp;</span>
            }
        }

        public final int available() throws IOException {
<span class="nc" id="L1497">            return Math.min(remaining, is.available());</span>
        }

        public final void close() throws IOException {
<span class="nc" id="L1501">            remaining = 0;</span>
<span class="nc" id="L1502">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>