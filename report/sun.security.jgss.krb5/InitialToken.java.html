<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InitialToken.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.security.jgss.krb5</a> &gt; <span class="el_source">InitialToken.java</span></div><h1>InitialToken.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.jgss.krb5;

import org.ietf.jgss.*;
import javax.security.auth.kerberos.DelegationPermission;
import java.io.IOException;
import java.net.InetAddress;
import java.net.Inet4Address;
import java.net.Inet6Address;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import sun.security.krb5.*;
import sun.security.krb5.internal.Krb5;

<span class="fc" id="L40">abstract class InitialToken extends Krb5Token {</span>

    private static final int CHECKSUM_TYPE = 0x8003;

    private static final int CHECKSUM_LENGTH_SIZE     = 4;
    private static final int CHECKSUM_BINDINGS_SIZE   = 16;
    private static final int CHECKSUM_FLAGS_SIZE      = 4;
    private static final int CHECKSUM_DELEG_OPT_SIZE  = 2;
    private static final int CHECKSUM_DELEG_LGTH_SIZE = 2;

    private static final int CHECKSUM_DELEG_FLAG    = 1;
    private static final int CHECKSUM_MUTUAL_FLAG   = 2;
    private static final int CHECKSUM_REPLAY_FLAG   = 4;
    private static final int CHECKSUM_SEQUENCE_FLAG = 8;
    private static final int CHECKSUM_CONF_FLAG     = 16;
    private static final int CHECKSUM_INTEG_FLAG    = 32;

<span class="fc" id="L57">    private final byte[] CHECKSUM_FIRST_BYTES =</span>
    {(byte)0x10, (byte)0x00, (byte)0x00, (byte)0x00};

    private static final int CHANNEL_BINDING_AF_INET = 2;
    private static final int CHANNEL_BINDING_AF_INET6 = 24;
    private static final int CHANNEL_BINDING_AF_NULL_ADDR = 255;

    private static final int Inet4_ADDRSZ = 4;
    private static final int Inet6_ADDRSZ = 16;

<span class="fc" id="L67">    protected class OverloadedChecksum {</span>

<span class="fc" id="L69">        private byte[] checksumBytes = null;</span>
<span class="fc" id="L70">        private Credentials delegCreds = null;</span>
<span class="fc" id="L71">        private int flags = 0;</span>

        /**
         * Called on the initiator side when creating the
         * InitSecContextToken.
         */
        public OverloadedChecksum(Krb5Context context,
                                  Credentials tgt,
                                  Credentials serviceTicket)
<span class="fc" id="L80">            throws KrbException, IOException, GSSException {</span>

<span class="fc" id="L82">            byte[] krbCredMessage = null;</span>
<span class="fc" id="L83">            int pos = 0;</span>
<span class="fc" id="L84">            int size = CHECKSUM_LENGTH_SIZE + CHECKSUM_BINDINGS_SIZE +</span>
                CHECKSUM_FLAGS_SIZE;

<span class="fc bfc" id="L87" title="All 2 branches covered.">            if (!tgt.isForwardable()) {</span>
<span class="fc" id="L88">                context.setCredDelegState(false);</span>
<span class="fc" id="L89">                context.setDelegPolicyState(false);</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">            } else if (context.getCredDelegState()) {</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">                if (context.getDelegPolicyState()) {</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">                    if (!serviceTicket.checkDelegate()) {</span>
                        // delegation not permitted by server policy, mark it
<span class="nc" id="L94">                        context.setDelegPolicyState(false);</span>
                    }
                }
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">            } else if (context.getDelegPolicyState()) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                if (serviceTicket.checkDelegate()) {</span>
<span class="nc" id="L99">                    context.setCredDelegState(true);</span>
                } else {
<span class="nc" id="L101">                    context.setDelegPolicyState(false);</span>
                }
            }

<span class="fc bfc" id="L105" title="All 2 branches covered.">            if (context.getCredDelegState()) {</span>
<span class="fc" id="L106">                KrbCred krbCred = null;</span>
<span class="fc" id="L107">                CipherHelper cipherHelper =</span>
<span class="fc" id="L108">                    context.getCipherHelper(serviceTicket.getSessionKey());</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">                if (useNullKey(cipherHelper)) {</span>
<span class="nc" id="L110">                    krbCred = new KrbCred(tgt, serviceTicket,</span>
                                              EncryptionKey.NULL_KEY);
                } else {
<span class="fc" id="L113">                    krbCred = new KrbCred(tgt, serviceTicket,</span>
<span class="fc" id="L114">                                    serviceTicket.getSessionKey());</span>
                }
<span class="fc" id="L116">                krbCredMessage = krbCred.getMessage();</span>
<span class="fc" id="L117">                size += CHECKSUM_DELEG_OPT_SIZE +</span>
                        CHECKSUM_DELEG_LGTH_SIZE +
                        krbCredMessage.length;
            }

<span class="fc" id="L122">            checksumBytes = new byte[size];</span>

<span class="fc" id="L124">            checksumBytes[pos++] = CHECKSUM_FIRST_BYTES[0];</span>
<span class="fc" id="L125">            checksumBytes[pos++] = CHECKSUM_FIRST_BYTES[1];</span>
<span class="fc" id="L126">            checksumBytes[pos++] = CHECKSUM_FIRST_BYTES[2];</span>
<span class="fc" id="L127">            checksumBytes[pos++] = CHECKSUM_FIRST_BYTES[3];</span>

<span class="fc" id="L129">            ChannelBinding localBindings = context.getChannelBinding();</span>
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">            if (localBindings != null) {</span>
<span class="nc" id="L131">                byte[] localBindingsBytes =</span>
<span class="nc" id="L132">                    computeChannelBinding(context.getChannelBinding());</span>
<span class="nc" id="L133">                System.arraycopy(localBindingsBytes, 0,</span>
                             checksumBytes, pos, localBindingsBytes.length);
                //              System.out.println(&quot;ChannelBinding hash: &quot;
                //         + getHexBytes(localBindingsBytes));
            }

<span class="fc" id="L139">            pos += CHECKSUM_BINDINGS_SIZE;</span>

<span class="fc bfc" id="L141" title="All 2 branches covered.">            if (context.getCredDelegState())</span>
<span class="fc" id="L142">                flags |= CHECKSUM_DELEG_FLAG;</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">            if (context.getMutualAuthState())</span>
<span class="fc" id="L144">                flags |= CHECKSUM_MUTUAL_FLAG;</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">            if (context.getReplayDetState())</span>
<span class="fc" id="L146">                flags |= CHECKSUM_REPLAY_FLAG;</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">            if (context.getSequenceDetState())</span>
<span class="fc" id="L148">                flags |= CHECKSUM_SEQUENCE_FLAG;</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">            if (context.getIntegState())</span>
<span class="fc" id="L150">                flags |= CHECKSUM_INTEG_FLAG;</span>
<span class="pc bpc" id="L151" title="1 of 2 branches missed.">            if (context.getConfState())</span>
<span class="fc" id="L152">                flags |= CHECKSUM_CONF_FLAG;</span>

<span class="fc" id="L154">            byte[] temp = new byte[4];</span>
<span class="fc" id="L155">            writeLittleEndian(flags, temp);</span>
<span class="fc" id="L156">            checksumBytes[pos++] = temp[0];</span>
<span class="fc" id="L157">            checksumBytes[pos++] = temp[1];</span>
<span class="fc" id="L158">            checksumBytes[pos++] = temp[2];</span>
<span class="fc" id="L159">            checksumBytes[pos++] = temp[3];</span>

<span class="fc bfc" id="L161" title="All 2 branches covered.">            if (context.getCredDelegState()) {</span>

<span class="fc" id="L163">                PrincipalName delegateTo =</span>
<span class="fc" id="L164">                    serviceTicket.getServer();</span>
                // Cannot use '\&quot;' instead of &quot;\&quot;&quot; in constructor because
                // it is interpreted as suggested length!
<span class="fc" id="L167">                StringBuffer buf = new StringBuffer(&quot;\&quot;&quot;);</span>
<span class="fc" id="L168">                buf.append(delegateTo.getName()).append('\&quot;');</span>
<span class="fc" id="L169">                String realm = delegateTo.getRealmAsString();</span>
<span class="fc" id="L170">                buf.append(&quot; \&quot;krbtgt/&quot;).append(realm).append('@');</span>
<span class="fc" id="L171">                buf.append(realm).append('\&quot;');</span>
<span class="fc" id="L172">                SecurityManager sm = System.getSecurityManager();</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                if (sm != null) {</span>
<span class="fc" id="L174">                    DelegationPermission perm =</span>
<span class="fc" id="L175">                        new DelegationPermission(buf.toString());</span>
<span class="fc" id="L176">                    sm.checkPermission(perm);</span>
                }


                /*
                 * Write 1 in little endian but in two bytes
                 * for DlgOpt
                 */

<span class="fc" id="L185">                checksumBytes[pos++] = (byte)0x01;</span>
<span class="fc" id="L186">                checksumBytes[pos++] = (byte)0x00;</span>

                /*
                 * Write the length of the delegated credential in little
                 * endian but in two bytes for Dlgth
                 */

<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                if (krbCredMessage.length &gt; 0x0000ffff)</span>
<span class="nc" id="L194">                    throw new GSSException(GSSException.FAILURE, -1,</span>
                        &quot;Incorrect message length&quot;);

<span class="fc" id="L197">                writeLittleEndian(krbCredMessage.length, temp);</span>
<span class="fc" id="L198">                checksumBytes[pos++] = temp[0];</span>
<span class="fc" id="L199">                checksumBytes[pos++] = temp[1];</span>
<span class="fc" id="L200">                System.arraycopy(krbCredMessage, 0,</span>
                                 checksumBytes, pos, krbCredMessage.length);
            }

<span class="fc" id="L204">        }</span>

        /**
         * Called on the acceptor side when reading an InitSecContextToken.
         */
        // XXX Passing in Checksum is not required. byte[] can
        // be passed in if this checksum type denotes a
        // raw_checksum. In that case, make Checksum class krb5
        // internal.
        public OverloadedChecksum(Krb5Context context, Checksum checksum,
                                  EncryptionKey key, EncryptionKey subKey)
<span class="fc" id="L215">            throws GSSException, KrbException, IOException {</span>

<span class="fc" id="L217">            int pos = 0;</span>

<span class="pc bpc" id="L219" title="1 of 2 branches missed.">            if (checksum == null) {</span>
<span class="nc" id="L220">                GSSException ge = new GSSException(GSSException.FAILURE, -1,</span>
                        &quot;No cksum in AP_REQ's authenticator&quot;);
<span class="nc" id="L222">                ge.initCause(new KrbException(Krb5.KRB_AP_ERR_INAPP_CKSUM));</span>
<span class="nc" id="L223">                throw ge;</span>
            }
<span class="fc" id="L225">            checksumBytes = checksum.getBytes();</span>

<span class="pc bpc" id="L227" title="1 of 2 branches missed.">            if ((checksumBytes[0] != CHECKSUM_FIRST_BYTES[0]) ||</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">                (checksumBytes[1] != CHECKSUM_FIRST_BYTES[1]) ||</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                (checksumBytes[2] != CHECKSUM_FIRST_BYTES[2]) ||</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">                (checksumBytes[3] != CHECKSUM_FIRST_BYTES[3])) {</span>
<span class="nc" id="L231">                throw new GSSException(GSSException.FAILURE, -1,</span>
                        &quot;Incorrect checksum&quot;);
            }

<span class="fc" id="L235">            ChannelBinding localBindings = context.getChannelBinding();</span>

            // Ignore remote channel binding info when not requested at
            // local side (RFC 4121 4.1.1.2: the acceptor MAY ignore...).
            //
            // All major krb5 implementors implement this &quot;MAY&quot;,
            // and some applications depend on it as a workaround
            // for not having a way to negotiate the use of channel
            // binding -- the initiator application always uses CB
            // and hopes the acceptor will ignore the CB if the
            // acceptor doesn't support CB.
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            if (localBindings != null) {</span>
<span class="nc" id="L247">                byte[] remoteBindingBytes = new byte[CHECKSUM_BINDINGS_SIZE];</span>
<span class="nc" id="L248">                System.arraycopy(checksumBytes, 4, remoteBindingBytes, 0,</span>
                                 CHECKSUM_BINDINGS_SIZE);

<span class="nc" id="L251">                byte[] noBindings = new byte[CHECKSUM_BINDINGS_SIZE];</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">                if (!Arrays.equals(noBindings, remoteBindingBytes)) {</span>
<span class="nc" id="L253">                    byte[] localBindingsBytes =</span>
<span class="nc" id="L254">                        computeChannelBinding(localBindings);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">                    if (!Arrays.equals(localBindingsBytes,</span>
                                                remoteBindingBytes)) {
<span class="nc" id="L257">                        throw new GSSException(GSSException.BAD_BINDINGS, -1,</span>
                                               &quot;Bytes mismatch!&quot;);
                    }
<span class="nc" id="L260">                } else {</span>
<span class="nc" id="L261">                    throw new GSSException(GSSException.BAD_BINDINGS, -1,</span>
                                           &quot;Token missing ChannelBinding!&quot;);
                }
            }

<span class="fc" id="L266">            flags = readLittleEndian(checksumBytes, 20, 4);</span>

<span class="fc bfc" id="L268" title="All 2 branches covered.">            if ((flags &amp; CHECKSUM_DELEG_FLAG) &gt; 0) {</span>

                /*
                 * XXX
                 * if ((checksumBytes[24] != (byte)0x01) &amp;&amp;
                 * (checksumBytes[25] != (byte)0x00))
                 */

<span class="fc" id="L276">                int credLen = readLittleEndian(checksumBytes, 26, 2);</span>
<span class="fc" id="L277">                byte[] credBytes = new byte[credLen];</span>
<span class="fc" id="L278">                System.arraycopy(checksumBytes, 28, credBytes, 0, credLen);</span>

                KrbCred cred;
                try {
<span class="fc" id="L282">                    cred = new KrbCred(credBytes, key);</span>
<span class="fc" id="L283">                } catch (KrbException ke) {</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                    if (subKey != null) {</span>
<span class="fc" id="L285">                        cred = new KrbCred(credBytes, subKey);</span>
                    } else {
<span class="nc" id="L287">                        throw ke;</span>
                    }
<span class="fc" id="L289">                }</span>
<span class="fc" id="L290">                delegCreds = cred.getDelegatedCreds()[0];</span>
            }
<span class="fc" id="L292">        }</span>

        // check if KRB-CRED message should use NULL_KEY for encryption
        private boolean useNullKey(CipherHelper ch) {
<span class="fc" id="L296">            boolean flag = true;</span>
            // for &quot;newer&quot; etypes and RC4-HMAC do not use NULL KEY
<span class="pc bpc" id="L298" title="3 of 4 branches missed.">            if ((ch.getProto() == 1) || ch.isArcFour()) {</span>
<span class="fc" id="L299">                flag = false;</span>
            }
<span class="fc" id="L301">            return flag;</span>
        }

        public Checksum getChecksum() throws KrbException {
<span class="fc" id="L305">            return new Checksum(checksumBytes, CHECKSUM_TYPE);</span>
        }

        public Credentials getDelegatedCreds() {
<span class="fc" id="L309">            return delegCreds;</span>
        }

        // Only called by acceptor
        public void setContextFlags(Krb5Context context) {
                // default for cred delegation is false
<span class="fc bfc" id="L315" title="All 2 branches covered.">            if ((flags &amp; CHECKSUM_DELEG_FLAG) &gt; 0)</span>
<span class="fc" id="L316">                context.setCredDelegState(true);</span>
                // default for the following are true
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">            if ((flags &amp; CHECKSUM_MUTUAL_FLAG) == 0) {</span>
<span class="nc" id="L319">                context.setMutualAuthState(false);</span>
            }
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">            if ((flags &amp; CHECKSUM_REPLAY_FLAG) == 0) {</span>
<span class="nc" id="L322">                context.setReplayDetState(false);</span>
            }
<span class="pc bpc" id="L324" title="1 of 2 branches missed.">            if ((flags &amp; CHECKSUM_SEQUENCE_FLAG) == 0) {</span>
<span class="nc" id="L325">                context.setSequenceDetState(false);</span>
            }
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">            if ((flags &amp; CHECKSUM_CONF_FLAG) == 0) {</span>
<span class="nc" id="L328">                context.setConfState(false);</span>
            }
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">            if ((flags &amp; CHECKSUM_INTEG_FLAG) == 0) {</span>
<span class="nc" id="L331">                context.setIntegState(false);</span>
            }
<span class="fc" id="L333">        }</span>
    }

    private int getAddrType(InetAddress addr) {
<span class="nc" id="L337">        int addressType = CHANNEL_BINDING_AF_NULL_ADDR;</span>

<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (addr instanceof Inet4Address)</span>
<span class="nc" id="L340">            addressType = CHANNEL_BINDING_AF_INET;</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        else if (addr instanceof Inet6Address)</span>
<span class="nc" id="L342">            addressType = CHANNEL_BINDING_AF_INET6;</span>
<span class="nc" id="L343">        return (addressType);</span>
    }

    private byte[] getAddrBytes(InetAddress addr) throws GSSException {
<span class="nc" id="L347">        int addressType = getAddrType(addr);</span>
<span class="nc" id="L348">        byte[] addressBytes = addr.getAddress();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (addressBytes != null) {</span>
<span class="nc bnc" id="L350" title="All 3 branches missed.">            switch (addressType) {</span>
                case CHANNEL_BINDING_AF_INET:
<span class="nc bnc" id="L352" title="All 2 branches missed.">                    if (addressBytes.length != Inet4_ADDRSZ) {</span>
<span class="nc" id="L353">                        throw new GSSException(GSSException.FAILURE, -1,</span>
                        &quot;Incorrect AF-INET address length in ChannelBinding.&quot;);
                    }
<span class="nc" id="L356">                    return (addressBytes);</span>
                case CHANNEL_BINDING_AF_INET6:
<span class="nc bnc" id="L358" title="All 2 branches missed.">                    if (addressBytes.length != Inet6_ADDRSZ) {</span>
<span class="nc" id="L359">                        throw new GSSException(GSSException.FAILURE, -1,</span>
                        &quot;Incorrect AF-INET6 address length in ChannelBinding.&quot;);
                    }
<span class="nc" id="L362">                    return (addressBytes);</span>
                default:
<span class="nc" id="L364">                    throw new GSSException(GSSException.FAILURE, -1,</span>
                    &quot;Cannot handle non AF-INET addresses in ChannelBinding.&quot;);
            }
        }
<span class="nc" id="L368">        return null;</span>
    }

    private byte[] computeChannelBinding(ChannelBinding channelBinding)
        throws GSSException {

<span class="nc" id="L374">        InetAddress initiatorAddress = channelBinding.getInitiatorAddress();</span>
<span class="nc" id="L375">        InetAddress acceptorAddress = channelBinding.getAcceptorAddress();</span>
<span class="nc" id="L376">        int size = 5*4;</span>

<span class="nc" id="L378">        int initiatorAddressType = getAddrType(initiatorAddress);</span>
<span class="nc" id="L379">        int acceptorAddressType = getAddrType(acceptorAddress);</span>

<span class="nc" id="L381">        byte[] initiatorAddressBytes = null;</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">        if (initiatorAddress != null) {</span>
<span class="nc" id="L383">            initiatorAddressBytes = getAddrBytes(initiatorAddress);</span>
<span class="nc" id="L384">            size += initiatorAddressBytes.length;</span>
        }

<span class="nc" id="L387">        byte[] acceptorAddressBytes = null;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (acceptorAddress != null) {</span>
<span class="nc" id="L389">            acceptorAddressBytes = getAddrBytes(acceptorAddress);</span>
<span class="nc" id="L390">            size += acceptorAddressBytes.length;</span>
        }

<span class="nc" id="L393">        byte[] appDataBytes = channelBinding.getApplicationData();</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (appDataBytes != null) {</span>
<span class="nc" id="L395">            size += appDataBytes.length;</span>
        }

<span class="nc" id="L398">        byte[] data = new byte[size];</span>

<span class="nc" id="L400">        int pos = 0;</span>

<span class="nc" id="L402">        writeLittleEndian(initiatorAddressType, data, pos);</span>
<span class="nc" id="L403">        pos += 4;</span>

<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (initiatorAddressBytes != null) {</span>
<span class="nc" id="L406">            writeLittleEndian(initiatorAddressBytes.length, data, pos);</span>
<span class="nc" id="L407">            pos += 4;</span>
<span class="nc" id="L408">            System.arraycopy(initiatorAddressBytes, 0,</span>
                             data, pos, initiatorAddressBytes.length);
<span class="nc" id="L410">            pos += initiatorAddressBytes.length;</span>
        } else {
            // Write length 0
<span class="nc" id="L413">            pos += 4;</span>
        }

<span class="nc" id="L416">        writeLittleEndian(acceptorAddressType, data, pos);</span>
<span class="nc" id="L417">        pos += 4;</span>

<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (acceptorAddressBytes != null) {</span>
<span class="nc" id="L420">            writeLittleEndian(acceptorAddressBytes.length, data, pos);</span>
<span class="nc" id="L421">            pos += 4;</span>
<span class="nc" id="L422">            System.arraycopy(acceptorAddressBytes, 0,</span>
                             data, pos, acceptorAddressBytes.length);
<span class="nc" id="L424">            pos += acceptorAddressBytes.length;</span>
        } else {
            // Write length 0
<span class="nc" id="L427">            pos += 4;</span>
        }

<span class="nc bnc" id="L430" title="All 2 branches missed.">        if (appDataBytes != null) {</span>
<span class="nc" id="L431">            writeLittleEndian(appDataBytes.length, data, pos);</span>
<span class="nc" id="L432">            pos += 4;</span>
<span class="nc" id="L433">            System.arraycopy(appDataBytes, 0, data, pos,</span>
                             appDataBytes.length);
<span class="nc" id="L435">            pos += appDataBytes.length;</span>
        } else {
            // Write 0
<span class="nc" id="L438">            pos += 4;</span>
        }

        try {
<span class="nc" id="L442">            MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);</span>
<span class="nc" id="L443">            return md5.digest(data);</span>
<span class="nc" id="L444">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L445">                throw new GSSException(GSSException.FAILURE, -1,</span>
                                       &quot;Could not get MD5 Message Digest - &quot;
<span class="nc" id="L447">                                       + e.getMessage());</span>
        }
    }

    public abstract byte[] encode() throws IOException;

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>