<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MessageToken.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">sun.security.jgss.krb5</a> &gt; <span class="el_source">MessageToken.java</span></div><h1>MessageToken.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.security.jgss.krb5;

import org.ietf.jgss.*;
import sun.security.jgss.*;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.security.MessageDigest;

/**
 * This class is a base class for other token definitions that pertain to
 * per-message GSS-API calls. Conceptually GSS-API has two types of
 * per-message tokens: WrapToken and MicToken. They differ in the respect
 * that a WrapToken carries additional plaintext or ciphertext application
 * data besides just the sequence number and checksum. This class
 * encapsulates the commonality in the structure of the WrapToken and the
 * MicToken. This structure can be represented as:
 * &lt;p&gt;
 * &lt;pre&gt;
 *     0..1           TOK_ID          Identification field.
 *                                    01 01 - Mic token
 *                                    02 01 - Wrap token
 *     2..3           SGN_ALG         Checksum algorithm indicator.
 *                                    00 00 - DES MAC MD5
 *                                    01 00 - MD2.5
 *                                    02 00 - DES MAC
 *                                    04 00 - HMAC SHA1 DES3-KD
 *                                    11 00 - RC4-HMAC
 *     4..5           SEAL_ALG        ff ff - none
 *                                    00 00 - DES
 *                                    02 00 - DES3-KD
 *                                    10 00 - RC4-HMAC
 *     6..7           Filler          Contains ff ff
 *     8..15          SND_SEQ         Encrypted sequence number field.
 *     16..s+15       SGN_CKSUM       Checksum of plaintext padded data,
 *                                   calculated according to algorithm
 *                                  specified in SGN_ALG field.
 *     s+16..last     Data            encrypted or plaintext padded data
 * &lt;/pre&gt;
 * Where &quot;s&quot; indicates the size of the checksum.
 * &lt;p&gt;
 * As always, this is preceeded by a GSSHeader.
 *
 * @author Mayank Upadhyay
 * @author Ram Marti
 * @see sun.security.jgss.GSSHeader
 */

abstract class MessageToken extends Krb5Token {
    /* Fields in header minus checksum size */
    private static final int TOKEN_NO_CKSUM_SIZE = 16;

    /**
     * Filler data as defined in the specification of the Kerberos v5 GSS-API
     * Mechanism.
     */
    private static final int FILLER = 0xffff;

     // Signing algorithm values (for the SNG_ALG field)

     // From RFC 1964
     /* Use a DES MAC MD5 checksum */
    static final int SGN_ALG_DES_MAC_MD5 = 0x0000;

     /* Use DES MAC checksum. */
    static final int SGN_ALG_DES_MAC     = 0x0200;

     // From draft-raeburn-cat-gssapi-krb5-3des-00
     /* Use a HMAC SHA1 DES3 -KD checksum */
    static final int SGN_ALG_HMAC_SHA1_DES3_KD = 0x0400;

     // Sealing algorithm values (for the SEAL_ALG field)

     // RFC 1964
    /**
     * A value for the SEAL_ALG field that indicates that no encryption was
     * used.
     */
    static final int SEAL_ALG_NONE    = 0xffff;
     /* Use DES CBC encryption algorithm. */
    static final int SEAL_ALG_DES = 0x0000;

    // From draft-raeburn-cat-gssapi-krb5-3des-00
    /**
     * Use DES3-KD sealing algorithm. (draft-raeburn-cat-gssapi-krb5-3des-00)
     * This algorithm uses triple-DES with key derivation, with a usage
     * value KG_USAGE_SEAL.  Padding is still to 8-byte multiples, and the
     * IV for encrypting application data is zero.
     */
    static final int SEAL_ALG_DES3_KD = 0x0200;

    // draft draft-brezak-win2k-krb-rc4-hmac-04.txt
    static final int SEAL_ALG_ARCFOUR_HMAC = 0x1000;
    static final int SGN_ALG_HMAC_MD5_ARCFOUR = 0x1100;

    private static final int TOKEN_ID_POS = 0;
    private static final int SIGN_ALG_POS = 2;
    private static final int SEAL_ALG_POS = 4;

    private int seqNumber;

<span class="nc" id="L128">    private boolean confState = true;</span>
<span class="nc" id="L129">    private boolean initiator = true;</span>

<span class="nc" id="L131">    private int tokenId = 0;</span>
<span class="nc" id="L132">    private GSSHeader gssHeader = null;</span>
<span class="nc" id="L133">    private MessageTokenHeader tokenHeader = null;</span>
<span class="nc" id="L134">    private byte[] checksum = null;</span>
<span class="nc" id="L135">    private byte[] encSeqNumber = null;</span>
<span class="nc" id="L136">    private byte[] seqNumberData = null;</span>

    /* cipher instance used by the corresponding GSSContext */
<span class="nc" id="L139">    CipherHelper cipherHelper = null;</span>


    /**
     * Constructs a MessageToken from a byte array. If there are more bytes
     * in the array than needed, the extra bytes are simply ignroed.
     *
     * @param tokenId the token id that should be contained in this token as
     * it is read.
     * @param context the Kerberos context associated with this token
     * @param tokenBytes the byte array containing the token
     * @param tokenOffset the offset where the token begins
     * @param tokenLen the length of the token
     * @param prop the MessageProp structure in which the properties of the
     * token should be stored.
     * @throws GSSException if there is a problem parsing the token
     */
    MessageToken(int tokenId, Krb5Context context,
                 byte[] tokenBytes, int tokenOffset, int tokenLen,
                 MessageProp prop) throws GSSException {
<span class="nc" id="L159">        this(tokenId, context,</span>
             new ByteArrayInputStream(tokenBytes, tokenOffset, tokenLen),
             prop);
<span class="nc" id="L162">    }</span>

    /**
     * Constructs a MessageToken from an InputStream. Bytes will be read on
     * demand and the thread might block if there are not enough bytes to
     * complete the token.
     *
     * @param tokenId the token id that should be contained in this token as
     * it is read.
     * @param context the Kerberos context associated with this token
     * @param is the InputStream from which to read
     * @param prop the MessageProp structure in which the properties of the
     * token should be stored.
     * @throws GSSException if there is a problem reading from the
     * InputStream or parsing the token
     */
    MessageToken(int tokenId, Krb5Context context, InputStream is,
<span class="nc" id="L179">                 MessageProp prop) throws GSSException {</span>
<span class="nc" id="L180">        init(tokenId, context);</span>

        try {
<span class="nc" id="L183">            gssHeader = new GSSHeader(is);</span>

<span class="nc bnc" id="L185" title="All 2 branches missed.">            if (!gssHeader.getOid().equals((Object)OID)) {</span>
<span class="nc" id="L186">                throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,</span>
<span class="nc" id="L187">                                       getTokenName(tokenId));</span>
            }
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (!confState) {</span>
<span class="nc" id="L190">                prop.setPrivacy(false);</span>
            }

<span class="nc" id="L193">            tokenHeader = new MessageTokenHeader(is, prop);</span>

<span class="nc" id="L195">            encSeqNumber = new byte[8];</span>
<span class="nc" id="L196">            readFully(is, encSeqNumber);</span>

            // debug(&quot;\n\tRead EncSeq#=&quot; +
            // getHexBytes(encSeqNumber, encSeqNumber.length));

<span class="nc" id="L201">            checksum = new byte[cipherHelper.getChecksumLength()];</span>
<span class="nc" id="L202">            readFully(is, checksum);</span>

            // debug(&quot;\n\tRead checksum=&quot; +
            // getHexBytes(checksum, checksum.length));
            // debug(&quot;\nLeaving MessageToken.Cons\n&quot;);

<span class="nc" id="L208">        } catch (IOException e) {</span>
<span class="nc" id="L209">            throw new GSSException(GSSException.DEFECTIVE_TOKEN, -1,</span>
<span class="nc" id="L210">                getTokenName(tokenId) + &quot;:&quot; + e.getMessage());</span>
<span class="nc" id="L211">        }</span>
<span class="nc" id="L212">    }</span>

    /**
     * Used to obtain the GSSHeader that was at the start of this
     * token.
     */
    public final GSSHeader getGSSHeader() {
<span class="nc" id="L219">        return gssHeader;</span>
    }

    /**
     * Used to obtain the token id that was contained in this token.
     * @return the token id in the token
     */
    public final int getTokenId() {
<span class="nc" id="L227">        return tokenId;</span>
    }

    /**
     * Used to obtain the encrypted sequence number in this token.
     * @return the encrypted sequence number in the token
     */
    public final byte[] getEncSeqNumber() {
<span class="nc" id="L235">        return encSeqNumber;</span>
    }

    /**
     * Used to obtain the checksum that was contained in this token.
     * @return the checksum in the token
     */
    public final byte[] getChecksum() {
<span class="nc" id="L243">        return checksum;</span>
    }

    /**
     * Used to determine if this token contains any encrypted data.
     * @return true if it contains any encrypted data, false if there is only
     * plaintext data or if there is no data.
     */
    public final boolean getConfState() {
<span class="nc" id="L252">        return confState;</span>
    }

    /**
     * Generates the checksum field and the encrypted sequence number
     * field. The encrypted sequence number uses the 8 bytes of the checksum
     * as an initial vector in a fixed DesCbc algorithm.
     *
     * @param prop the MessageProp structure that determines what sort of
     * checksum and sealing algorithm should be used. The lower byte
     * of qop determines the checksum algorithm while the upper byte
     * determines the signing algorithm.
     *       Checksum values are:
     *           0 - default (DES_MAC)
     *           1 - MD5
     *           2 - DES_MD5
     *           3 - DES_MAC
     *           4 - HMAC_SHA1
     *       Sealing values are:
     *           0 - default (DES)
     *           1 - DES
     *           2 - DES3-KD
     *
     * @param optionalHeader an optional header that will be processed first
     * during  checksum calculation
     *
     * @param data the application data to checksum
     * @param offset the offset where the data starts
     * @param len the length of the data
     *
     * @param optionalTrailer an optional trailer that will be processed
     * last during checksum calculation. e.g., padding that should be
     * appended to the application data
     *
     * @throws GSSException if an error occurs in the checksum calculation or
     * encryption sequence number calculation.
     */
    public void genSignAndSeqNumber(MessageProp prop,
                                    byte[] optionalHeader,
                                    byte[] data, int offset, int len,
                                    byte[] optionalTrailer)
        throws GSSException {

        //    debug(&quot;Inside MessageToken.genSignAndSeqNumber:\n&quot;);

<span class="nc" id="L297">        int qop = prop.getQOP();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        if (qop != 0) {</span>
<span class="nc" id="L299">            qop = 0;</span>
<span class="nc" id="L300">            prop.setQOP(qop);</span>
        }

<span class="nc bnc" id="L303" title="All 2 branches missed.">        if (!confState) {</span>
<span class="nc" id="L304">            prop.setPrivacy(false);</span>
        }

        // Create a token header with the correct sign and seal algorithm
        // values.
<span class="nc" id="L309">        tokenHeader =</span>
<span class="nc" id="L310">            new MessageTokenHeader(tokenId, prop.getPrivacy(), qop);</span>

        // Calculate SGN_CKSUM

<span class="nc" id="L314">        checksum =</span>
<span class="nc" id="L315">            getChecksum(optionalHeader, data, offset, len, optionalTrailer);</span>

        // debug(&quot;\n\tCalc checksum=&quot; +
        // getHexBytes(checksum, checksum.length));

        // Calculate SND_SEQ

<span class="nc" id="L322">        seqNumberData = new byte[8];</span>

        // When using this RC4 based encryption type, the sequence number is
        // always sent in big-endian rather than little-endian order.
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (cipherHelper.isArcFour()) {</span>
<span class="nc" id="L327">            writeBigEndian(seqNumber, seqNumberData);</span>
        } else {
            // for all other etypes
<span class="nc" id="L330">            writeLittleEndian(seqNumber, seqNumberData);</span>
        }
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (!initiator) {</span>
<span class="nc" id="L333">            seqNumberData[4] = (byte)0xff;</span>
<span class="nc" id="L334">            seqNumberData[5] = (byte)0xff;</span>
<span class="nc" id="L335">            seqNumberData[6] = (byte)0xff;</span>
<span class="nc" id="L336">            seqNumberData[7] = (byte)0xff;</span>
        }

<span class="nc" id="L339">        encSeqNumber = cipherHelper.encryptSeq(checksum, seqNumberData, 0, 8);</span>

        // debug(&quot;\n\tCalc seqNum=&quot; +
        //    getHexBytes(seqNumberData, seqNumberData.length));
        // debug(&quot;\n\tCalc encSeqNum=&quot; +
        //    getHexBytes(encSeqNumber, encSeqNumber.length));
<span class="nc" id="L345">    }</span>

    /**
     * Verifies that the checksum field and sequence number direction bytes
     * are valid and consistent with the application data.
     *
     * @param optionalHeader an optional header that will be processed first
     * during checksum calculation.
     *
     * @param data the application data
     * @param offset the offset where the data begins
     * @param len the length of the application data
     *
     * @param optionalTrailer an optional trailer that will be processed last
     * during checksum calculation. e.g., padding that should be appended to
     * the application data
     *
     * @throws GSSException if an error occurs in the checksum calculation or
     * encryption sequence number calculation.
     */
    public final boolean verifySignAndSeqNumber(byte[] optionalHeader,
                                        byte[] data, int offset, int len,
                                        byte[] optionalTrailer)
        throws GSSException {
         // debug(&quot;\tIn verifySign:\n&quot;);

         // debug(&quot;\t\tchecksum:   [&quot; + getHexBytes(checksum) + &quot;]\n&quot;);

<span class="nc" id="L373">        byte[] myChecksum =</span>
<span class="nc" id="L374">            getChecksum(optionalHeader, data, offset, len, optionalTrailer);</span>

        // debug(&quot;\t\tmychecksum: [&quot; + getHexBytes(myChecksum) +&quot;]\n&quot;);
        // debug(&quot;\t\tchecksum:   [&quot; + getHexBytes(checksum) + &quot;]\n&quot;);

<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (MessageDigest.isEqual(checksum, myChecksum)) {</span>

<span class="nc" id="L381">            seqNumberData = cipherHelper.decryptSeq(</span>
                checksum, encSeqNumber, 0, 8);

            // debug(&quot;\t\tencSeqNumber:   [&quot; + getHexBytes(encSeqNumber)
            //  + &quot;]\n&quot;);
            // debug(&quot;\t\tseqNumberData:   [&quot; + getHexBytes(seqNumberData)
            //  + &quot;]\n&quot;);

            /*
             * The token from the initiator has direction bytes 0x00 and
             * the token from the acceptor has direction bytes 0xff.
             */
<span class="nc" id="L393">            byte directionByte = 0;</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">            if (initiator)</span>
<span class="nc" id="L395">                directionByte = (byte) 0xff; // Received token from acceptor</span>

<span class="nc bnc" id="L397" title="All 8 branches missed.">            if ((seqNumberData[4] == directionByte) &amp;&amp;</span>
                  (seqNumberData[5] == directionByte) &amp;&amp;
                  (seqNumberData[6] == directionByte) &amp;&amp;
                  (seqNumberData[7] == directionByte))
<span class="nc" id="L401">                return true;</span>
        }

<span class="nc" id="L404">        return false;</span>

    }

    public final int getSequenceNumber() {
<span class="nc" id="L409">        int sequenceNum = 0;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (cipherHelper.isArcFour()) {</span>
<span class="nc" id="L411">            sequenceNum = readBigEndian(seqNumberData, 0, 4);</span>
        } else {
<span class="nc" id="L413">            sequenceNum = readLittleEndian(seqNumberData, 0, 4);</span>
        }
<span class="nc" id="L415">        return sequenceNum;</span>
    }

    /**
     * Computes the checksum based on the algorithm stored in the
     * tokenHeader.
     *
     * @param optionalHeader an optional header that will be processed first
     * during checksum calculation.
     *
     * @param data the application data
     * @param offset the offset where the data begins
     * @param len the length of the application data
     *
     * @param optionalTrailer an optional trailer that will be processed last
     * during checksum calculation. e.g., padding that should be appended to
     * the application data
     *
     * @throws GSSException if an error occurs in the checksum calculation.
     */
    private byte[] getChecksum(byte[] optionalHeader,
                               byte[] data, int offset, int len,
                               byte[] optionalTrailer)
        throws GSSException {

        //      debug(&quot;Will do getChecksum:\n&quot;);

        /*
         * For checksum calculation the token header bytes i.e., the first 8
         * bytes following the GSSHeader, are logically prepended to the
         * application data to bind the data to this particular token.
         *
         * Note: There is no such requirement wrt adding padding to the
         * application data for checksumming, although the cryptographic
         * algorithm used might itself apply some padding.
         */

<span class="nc" id="L452">        byte[] tokenHeaderBytes = tokenHeader.getBytes();</span>
<span class="nc" id="L453">        byte[] existingHeader = optionalHeader;</span>
<span class="nc" id="L454">        byte[] checksumDataHeader = tokenHeaderBytes;</span>

<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (existingHeader != null) {</span>
<span class="nc" id="L457">            checksumDataHeader = new byte[tokenHeaderBytes.length +</span>
                                         existingHeader.length];
<span class="nc" id="L459">            System.arraycopy(tokenHeaderBytes, 0,</span>
                             checksumDataHeader, 0, tokenHeaderBytes.length);
<span class="nc" id="L461">            System.arraycopy(existingHeader, 0,</span>
                             checksumDataHeader, tokenHeaderBytes.length,
                             existingHeader.length);
        }

<span class="nc" id="L466">        return cipherHelper.calculateChecksum(tokenHeader.getSignAlg(),</span>
             checksumDataHeader, optionalTrailer, data, offset, len, tokenId);
    }


    /**
     * Constructs an empty MessageToken for the local context to send to
     * the peer. It also increments the local sequence number in the
     * Krb5Context instance it uses after obtaining the object lock for
     * it.
     *
     * @param tokenId the token id that should be contained in this token
     * @param context the Kerberos context associated with this token
     */
<span class="nc" id="L480">    MessageToken(int tokenId, Krb5Context context) throws GSSException {</span>
        /*
          debug(&quot;\n============================&quot;);
          debug(&quot;\nMySessionKey=&quot; +
          getHexBytes(context.getMySessionKey().getBytes()));
          debug(&quot;\nPeerSessionKey=&quot; +
          getHexBytes(context.getPeerSessionKey().getBytes()));
          debug(&quot;\n============================\n&quot;);
        */
<span class="nc" id="L489">        init(tokenId, context);</span>
<span class="nc" id="L490">        this.seqNumber = context.incrementMySequenceNumber();</span>
<span class="nc" id="L491">    }</span>

    private void init(int tokenId, Krb5Context context) throws GSSException {
<span class="nc" id="L494">        this.tokenId = tokenId;</span>
        // Just for consistency check in Wrap
<span class="nc" id="L496">        this.confState = context.getConfState();</span>

<span class="nc" id="L498">        this.initiator = context.isInitiator();</span>

<span class="nc" id="L500">        this.cipherHelper = context.getCipherHelper(null);</span>
        //    debug(&quot;In MessageToken.Cons&quot;);
<span class="nc" id="L502">    }</span>

    /**
     * Encodes a GSSHeader and this token onto an OutputStream.
     *
     * @param os the OutputStream to which this should be written
     * @throws GSSException if an error occurs while writing to the OutputStream
     */
    public void encode(OutputStream os) throws IOException, GSSException {
<span class="nc" id="L511">        gssHeader = new GSSHeader(OID, getKrb5TokenSize());</span>
<span class="nc" id="L512">        gssHeader.encode(os);</span>
<span class="nc" id="L513">        tokenHeader.encode(os);</span>
        // debug(&quot;Writing seqNumber: &quot; + getHexBytes(encSeqNumber));
<span class="nc" id="L515">        os.write(encSeqNumber);</span>
        // debug(&quot;Writing checksum: &quot; + getHexBytes(checksum));
<span class="nc" id="L517">        os.write(checksum);</span>
<span class="nc" id="L518">    }</span>

    /**
     * Obtains the size of this token. Note that this excludes the size of
     * the GSSHeader.
     * @return token size
     */
    protected int getKrb5TokenSize() throws GSSException {
<span class="nc" id="L526">        return getTokenSize();</span>
    }

    protected final int getTokenSize() throws GSSException {
<span class="nc" id="L530">        return TOKEN_NO_CKSUM_SIZE + cipherHelper.getChecksumLength();</span>
    }

    protected static final int getTokenSize(CipherHelper ch)
        throws GSSException {
<span class="nc" id="L535">         return TOKEN_NO_CKSUM_SIZE + ch.getChecksumLength();</span>
    }

    /**
     * Obtains the conext key that is associated with this token.
     * @return the context key
     */
    /*
    public final byte[] getContextKey() {
        return contextKey;
    }
    */

    /**
     * Obtains the encryption algorithm that should be used in this token
     * given the state of confidentiality the application requested.
     * Requested qop must be consistent with negotiated session key.
     * @param confRequested true if the application desired confidentiality
     * on this token, false otherwise
     * @param qop the qop requested by the application
     * @throws GSSException if qop is incompatible with the negotiated
     *         session key
     */
    protected abstract int getSealAlg(boolean confRequested, int qop)
        throws GSSException;

    // ******************************************* //
    //  I N N E R    C L A S S E S    F O L L O W
    // ******************************************* //

    /**
     * This inner class represents the initial portion of the message token
     * and contains information about the checksum and encryption algorithms
     * that are in use. It constitutes the first 8 bytes of the
     * message token:
     * &lt;pre&gt;
     *     0..1           TOK_ID          Identification field.
     *                                    01 01 - Mic token
     *                                    02 01 - Wrap token
     *     2..3           SGN_ALG         Checksum algorithm indicator.
     *                                    00 00 - DES MAC MD5
     *                                    01 00 - MD2.5
     *                                    02 00 - DES MAC
     *                                    04 00 - HMAC SHA1 DES3-KD
     *                                    11 00 - RC4-HMAC
     *     4..5           SEAL_ALG        ff ff - none
     *                                    00 00 - DES
     *                                    02 00 - DES3-KD
     *                                    10 00 - RC4-HMAC
     *     6..7           Filler          Contains ff ff
     * &lt;/pre&gt;
     */
    class MessageTokenHeader {

         private int tokenId;
         private int signAlg;
         private int sealAlg;

<span class="nc" id="L593">         private byte[] bytes = new byte[8];</span>

        /**
         * Constructs a MessageTokenHeader for the specified token type with
         * appropriate checksum and encryption algorithms fields.
         *
         * @param tokenId the token id for this message token
         * @param conf true if confidentiality will be resuested with this
         * message token, false otherwise.
         * @param qop the value of the quality of protection that will be
         * desired.
         */
        public MessageTokenHeader(int tokenId, boolean conf, int qop)
<span class="nc" id="L606">         throws GSSException {</span>

<span class="nc" id="L608">            this.tokenId = tokenId;</span>

<span class="nc" id="L610">            signAlg = MessageToken.this.getSgnAlg(qop);</span>

<span class="nc" id="L612">            sealAlg = MessageToken.this.getSealAlg(conf, qop);</span>

<span class="nc" id="L614">            bytes[0] = (byte) (tokenId &gt;&gt;&gt; 8);</span>
<span class="nc" id="L615">            bytes[1] = (byte) (tokenId);</span>

<span class="nc" id="L617">            bytes[2] = (byte) (signAlg &gt;&gt;&gt; 8);</span>
<span class="nc" id="L618">            bytes[3] = (byte) (signAlg);</span>

<span class="nc" id="L620">            bytes[4] = (byte) (sealAlg &gt;&gt;&gt; 8);</span>
<span class="nc" id="L621">            bytes[5] = (byte) (sealAlg);</span>

<span class="nc" id="L623">            bytes[6] = (byte) (MessageToken.FILLER &gt;&gt;&gt; 8);</span>
<span class="nc" id="L624">            bytes[7] = (byte) (MessageToken.FILLER);</span>
<span class="nc" id="L625">        }</span>

        /**
         * Constructs a MessageTokenHeader by reading it from an InputStream
         * and sets the appropriate confidentiality and quality of protection
         * values in a MessageProp structure.
         *
         * @param is the InputStream to read from
         * @param prop the MessageProp to populate
         * @throws IOException is an error occurs while reading from the
         * InputStream
         */
        public MessageTokenHeader(InputStream is, MessageProp prop)
<span class="nc" id="L638">            throws IOException {</span>
<span class="nc" id="L639">            readFully(is, bytes);</span>
<span class="nc" id="L640">            tokenId = readInt(bytes, TOKEN_ID_POS);</span>
<span class="nc" id="L641">            signAlg = readInt(bytes, SIGN_ALG_POS);</span>
<span class="nc" id="L642">            sealAlg = readInt(bytes, SEAL_ALG_POS);</span>
            //          debug(&quot;\nMessageTokenHeader read tokenId=&quot; +
            //                getHexBytes(bytes) + &quot;\n&quot;);
            // XXX compare to FILLER
<span class="nc" id="L646">            int temp = readInt(bytes, SEAL_ALG_POS + 2);</span>

            //              debug(&quot;SIGN_ALG=&quot; + signAlg);

<span class="nc bnc" id="L650" title="All 2 branches missed.">            switch (sealAlg) {</span>
            case SEAL_ALG_DES:
            case SEAL_ALG_DES3_KD:
            case SEAL_ALG_ARCFOUR_HMAC:
<span class="nc" id="L654">                prop.setPrivacy(true);</span>
<span class="nc" id="L655">                break;</span>

            default:
<span class="nc" id="L658">                prop.setPrivacy(false);</span>
            }

<span class="nc" id="L661">            prop.setQOP(0);  // default</span>
<span class="nc" id="L662">        }</span>

        /**
         * Encodes this MessageTokenHeader onto an OutputStream
         * @param os the OutputStream to write to
         * @throws IOException is an error occurs while writing
         */
        public final void encode(OutputStream os) throws IOException {
<span class="nc" id="L670">            os.write(bytes);</span>
<span class="nc" id="L671">        }</span>


        /**
         * Returns the token id for the message token.
         * @return the token id
         * @see sun.security.jgss.krb5.Krb5Token#MIC_ID
         * @see sun.security.jgss.krb5.Krb5Token#WRAP_ID
         */
        public final int getTokenId() {
<span class="nc" id="L681">            return tokenId;</span>
        }

        /**
         * Returns the sign algorithm for the message token.
         * @return the sign algorithm
         * @see sun.security.jgss.krb5.MessageToken#SIGN_DES_MAC
         * @see sun.security.jgss.krb5.MessageToken#SIGN_DES_MAC_MD5
         */
        public final int getSignAlg() {
<span class="nc" id="L691">            return signAlg;</span>
        }

        /**
         * Returns the seal algorithm for the message token.
         * @return the seal algorithm
         * @see sun.security.jgss.krb5.MessageToken#SEAL_ALG_DES
         * @see sun.security.jgss.krb5.MessageToken#SEAL_ALG_NONE
         */
        public final int getSealAlg() {
<span class="nc" id="L701">            return sealAlg;</span>
        }

        /**
         * Returns the bytes of this header.
         * @return 8 bytes that form this header
         */
        public final byte[] getBytes() {
<span class="nc" id="L709">            return bytes;</span>
        }
    } // end of class MessageTokenHeader


    /**
     * Determine signing algorithm based on QOP.
     */
    protected int getSgnAlg(int qop) throws GSSException {
         // QOP ignored
<span class="nc" id="L719">         return cipherHelper.getSgnAlg();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>