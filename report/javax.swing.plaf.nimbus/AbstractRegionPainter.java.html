<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractRegionPainter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.plaf.nimbus</a> &gt; <span class="el_source">AbstractRegionPainter.java</span></div><h1>AbstractRegionPainter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.plaf.nimbus;

import java.awt.*;
import java.awt.image.*;
import java.lang.reflect.Method;
import javax.swing.*;
import javax.swing.plaf.UIResource;
import javax.swing.Painter;
import java.awt.print.PrinterGraphics;

/**
 * Convenient base class for defining Painter instances for rendering a
 * region or component in Nimbus.
 *
 * @author Jasper Potts
 * @author Richard Bair
 */
public abstract class AbstractRegionPainter implements Painter&lt;JComponent&gt; {
    /**
     * PaintContext, which holds a lot of the state needed for cache hinting and x/y value decoding
     * The data contained within the context is typically only computed once and reused over
     * multiple paint calls, whereas the other values (w, h, f, leftWidth, etc) are recomputed
     * for each call to paint.
     *
     * This field is retrieved from subclasses on each paint operation. It is up
     * to the subclass to compute and cache the PaintContext over multiple calls.
     */
    private PaintContext ctx;
    /**
     * The scaling factor. Recomputed on each call to paint.
     */
    private float f;
    /*
      Various metrics used for decoding x/y values based on the canvas size
      and stretching insets.

      On each call to paint, we first ask the subclass for the PaintContext.
      From the context we get the canvas size and stretching insets, and whether
      the algorithm should be &quot;inverted&quot;, meaning the center section remains
      a fixed size and the other sections scale.

      We then use these values to compute a series of metrics (listed below)
      which are used to decode points in a specific axis (x or y).

      The leftWidth represents the distance from the left edge of the region
      to the first stretching inset, after accounting for any scaling factor
      (such as DPI scaling). The centerWidth is the distance between the leftWidth
      and the rightWidth. The rightWidth is the distance from the right edge,
      to the right inset (after scaling has been applied).

      The same logic goes for topHeight, centerHeight, and bottomHeight.

      The leftScale represents the proportion of the width taken by the left section.
      The same logic is applied to the other scales.

      The various widths/heights are used to decode control points. The
      various scales are used to decode bezier handles (or anchors).
    */
    /**
     * The width of the left section. Recomputed on each call to paint.
     */
    private float leftWidth;
    /**
     * The height of the top section. Recomputed on each call to paint.
     */
    private float topHeight;
    /**
     * The width of the center section. Recomputed on each call to paint.
     */
    private float centerWidth;
    /**
     * The height of the center section. Recomputed on each call to paint.
     */
    private float centerHeight;
    /**
     * The width of the right section. Recomputed on each call to paint.
     */
    private float rightWidth;
    /**
     * The height of the bottom section. Recomputed on each call to paint.
     */
    private float bottomHeight;
    /**
     * The scaling factor to use for the left section. Recomputed on each call to paint.
     */
    private float leftScale;
    /**
     * The scaling factor to use for the top section. Recomputed on each call to paint.
     */
    private float topScale;
    /**
     * The scaling factor to use for the center section, in the horizontal
     * direction. Recomputed on each call to paint.
     */
    private float centerHScale;
    /**
     * The scaling factor to use for the center section, in the vertical
     * direction. Recomputed on each call to paint.
     */
    private float centerVScale;
    /**
     * The scaling factor to use for the right section. Recomputed on each call to paint.
     */
    private float rightScale;
    /**
     * The scaling factor to use for the bottom section. Recomputed on each call to paint.
     */
    private float bottomScale;

    /**
     * Create a new AbstractRegionPainter
     */
<span class="nc" id="L137">    protected AbstractRegionPainter() { }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public final void paint(Graphics2D g, JComponent c, int w, int h) {
        //don't render if the width/height are too small
<span class="nc bnc" id="L145" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;=0) return;</span>

<span class="nc" id="L147">        Object[] extendedCacheKeys = getExtendedCacheKeys(c);</span>
<span class="nc" id="L148">        ctx = getPaintContext();</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        PaintContext.CacheMode cacheMode = ctx == null ? PaintContext.CacheMode.NO_CACHING : ctx.cacheMode;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (cacheMode == PaintContext.CacheMode.NO_CACHING ||</span>
<span class="nc bnc" id="L151" title="All 4 branches missed.">                !ImageCache.getInstance().isImageCachable(w, h) ||</span>
                g instanceof PrinterGraphics) {
            // no caching so paint directly
<span class="nc" id="L154">            paint0(g, c, w, h, extendedCacheKeys);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">        } else if (cacheMode == PaintContext.CacheMode.FIXED_SIZES) {</span>
<span class="nc" id="L156">            paintWithFixedSizeCaching(g, c, w, h, extendedCacheKeys);</span>
        } else {
            // 9 Square caching
<span class="nc" id="L159">            paintWith9SquareCaching(g, ctx, c, w, h, extendedCacheKeys);</span>
        }
<span class="nc" id="L161">    }</span>

    /**
     * Get any extra attributes which the painter implementation would like
     * to include in the image cache lookups. This is checked for every call
     * of the paint(g, c, w, h) method.
     *
     * @param c The component on the current paint call
     * @return Array of extra objects to be included in the cache key
     */
    protected Object[] getExtendedCacheKeys(JComponent c) {
<span class="nc" id="L172">        return null;</span>
    }

    /**
     * &lt;p&gt;Gets the PaintContext for this painting operation. This method is called on every
     * paint, and so should be fast and produce no garbage. The PaintContext contains
     * information such as cache hints. It also contains data necessary for decoding
     * points at runtime, such as the stretching insets, the canvas size at which the
     * encoded points were defined, and whether the stretching insets are inverted.&lt;/p&gt;
     *
     * &lt;p&gt; This method allows for subclasses to package the painting of different states
     * with possibly different canvas sizes, etc, into one AbstractRegionPainter implementation.&lt;/p&gt;
     *
     * @return a PaintContext associated with this paint operation.
     */
    protected abstract PaintContext getPaintContext();

    /**
     * &lt;p&gt;Configures the given Graphics2D. Often, rendering hints or compositing rules are
     * applied to a Graphics2D object prior to painting, which should affect all of the
     * subsequent painting operations. This method provides a convenient hook for configuring
     * the Graphics object prior to rendering, regardless of whether the render operation is
     * performed to an intermediate buffer or directly to the display.&lt;/p&gt;
     *
     * @param g The Graphics2D object to configure. Will not be null.
     */
    protected void configureGraphics(Graphics2D g) {
<span class="nc" id="L199">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc" id="L200">    }</span>

    /**
     * Actually performs the painting operation. Subclasses must implement this method.
     * The graphics object passed may represent the actual surface being rendered to,
     * or it may be an intermediate buffer. It has also been pre-translated. Simply render
     * the component as if it were located at 0, 0 and had a width of &lt;code&gt;width&lt;/code&gt;
     * and a height of &lt;code&gt;height&lt;/code&gt;. For performance reasons, you may want to read
     * the clip from the Graphics2D object and only render within that space.
     *
     * @param g The Graphics2D surface to paint to
     * @param c The JComponent related to the drawing event. For example, if the
     *          region being rendered is Button, then &lt;code&gt;c&lt;/code&gt; will be a
     *          JButton. If the region being drawn is ScrollBarSlider, then the
     *          component will be JScrollBar. This value may be null.
     * @param width The width of the region to paint. Note that in the case of
     *              painting the foreground, this value may differ from c.getWidth().
     * @param height The height of the region to paint. Note that in the case of
     *               painting the foreground, this value may differ from c.getHeight().
     * @param extendedCacheKeys The result of the call to getExtendedCacheKeys()
     */
    protected abstract void doPaint(Graphics2D g, JComponent c, int width,
                                    int height, Object[] extendedCacheKeys);

    /**
     * Decodes and returns a float value representing the actual pixel location for
     * the given encoded X value.
     *
     * @param x an encoded x value (0...1, or 1...2, or 2...3)
     * @return the decoded x value
     * @throws IllegalArgumentException
     *      if {@code x &lt; 0} or {@code x &gt; 3}
     */
    protected final float decodeX(float x) {
<span class="nc bnc" id="L234" title="All 4 branches missed.">        if (x &gt;= 0 &amp;&amp; x &lt;= 1) {</span>
<span class="nc" id="L235">            return x * leftWidth;</span>
<span class="nc bnc" id="L236" title="All 4 branches missed.">        } else if (x &gt; 1 &amp;&amp; x &lt; 2) {</span>
<span class="nc" id="L237">            return ((x-1) * centerWidth) + leftWidth;</span>
<span class="nc bnc" id="L238" title="All 4 branches missed.">        } else if (x &gt;= 2 &amp;&amp; x &lt;= 3) {</span>
<span class="nc" id="L239">            return ((x-2) * rightWidth) + leftWidth + centerWidth;</span>
        } else {
<span class="nc" id="L241">            throw new IllegalArgumentException(&quot;Invalid x&quot;);</span>
        }
    }

    /**
     * Decodes and returns a float value representing the actual pixel location for
     * the given encoded y value.
     *
     * @param y an encoded y value (0...1, or 1...2, or 2...3)
     * @return the decoded y value
     * @throws IllegalArgumentException
     *      if {@code y &lt; 0} or {@code y &gt; 3}
     */
    protected final float decodeY(float y) {
<span class="nc bnc" id="L255" title="All 4 branches missed.">        if (y &gt;= 0 &amp;&amp; y &lt;= 1) {</span>
<span class="nc" id="L256">            return y * topHeight;</span>
<span class="nc bnc" id="L257" title="All 4 branches missed.">        } else if (y &gt; 1 &amp;&amp; y &lt; 2) {</span>
<span class="nc" id="L258">            return ((y-1) * centerHeight) + topHeight;</span>
<span class="nc bnc" id="L259" title="All 4 branches missed.">        } else if (y &gt;= 2 &amp;&amp; y &lt;= 3) {</span>
<span class="nc" id="L260">            return ((y-2) * bottomHeight) + topHeight + centerHeight;</span>
        } else {
<span class="nc" id="L262">            throw new IllegalArgumentException(&quot;Invalid y&quot;);</span>
        }
    }

    /**
     * Decodes and returns a float value representing the actual pixel location for
     * the anchor point given the encoded X value of the control point, and the offset
     * distance to the anchor from that control point.
     *
     * @param x an encoded x value of the bezier control point (0...1, or 1...2, or 2...3)
     * @param dx the offset distance to the anchor from the control point x
     * @return the decoded x location of the control point
     * @throws IllegalArgumentException
     *      if {@code x &lt; 0} or {@code x &gt; 3}
     */
    protected final float decodeAnchorX(float x, float dx) {
<span class="nc bnc" id="L278" title="All 4 branches missed.">        if (x &gt;= 0 &amp;&amp; x &lt;= 1) {</span>
<span class="nc" id="L279">            return decodeX(x) + (dx * leftScale);</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">        } else if (x &gt; 1 &amp;&amp; x &lt; 2) {</span>
<span class="nc" id="L281">            return decodeX(x) + (dx * centerHScale);</span>
<span class="nc bnc" id="L282" title="All 4 branches missed.">        } else if (x &gt;= 2 &amp;&amp; x &lt;= 3) {</span>
<span class="nc" id="L283">            return decodeX(x) + (dx * rightScale);</span>
        } else {
<span class="nc" id="L285">            throw new IllegalArgumentException(&quot;Invalid x&quot;);</span>
        }
    }

    /**
     * Decodes and returns a float value representing the actual pixel location for
     * the anchor point given the encoded Y value of the control point, and the offset
     * distance to the anchor from that control point.
     *
     * @param y an encoded y value of the bezier control point (0...1, or 1...2, or 2...3)
     * @param dy the offset distance to the anchor from the control point y
     * @return the decoded y position of the control point
     * @throws IllegalArgumentException
     *      if {@code y &lt; 0} or {@code y &gt; 3}
     */
    protected final float decodeAnchorY(float y, float dy) {
<span class="nc bnc" id="L301" title="All 4 branches missed.">        if (y &gt;= 0 &amp;&amp; y &lt;= 1) {</span>
<span class="nc" id="L302">            return decodeY(y) + (dy * topScale);</span>
<span class="nc bnc" id="L303" title="All 4 branches missed.">        } else if (y &gt; 1 &amp;&amp; y &lt; 2) {</span>
<span class="nc" id="L304">            return decodeY(y) + (dy * centerVScale);</span>
<span class="nc bnc" id="L305" title="All 4 branches missed.">        } else if (y &gt;= 2 &amp;&amp; y &lt;= 3) {</span>
<span class="nc" id="L306">            return decodeY(y) + (dy * bottomScale);</span>
        } else {
<span class="nc" id="L308">            throw new IllegalArgumentException(&quot;Invalid y&quot;);</span>
        }
    }

    /**
     * Decodes and returns a color, which is derived from a base color in UI
     * defaults.
     *
     * @param key     A key corresponding to the value in the UI Defaults table
     *                of UIManager where the base color is defined
     * @param hOffset The hue offset used for derivation.
     * @param sOffset The saturation offset used for derivation.
     * @param bOffset The brightness offset used for derivation.
     * @param aOffset The alpha offset used for derivation. Between 0...255
     * @return The derived color, whose color value will change if the parent
     *         uiDefault color changes.
     */
    protected final Color decodeColor(String key, float hOffset, float sOffset,
                                      float bOffset, int aOffset) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">        if (UIManager.getLookAndFeel() instanceof NimbusLookAndFeel){</span>
<span class="nc" id="L328">            NimbusLookAndFeel laf = (NimbusLookAndFeel) UIManager.getLookAndFeel();</span>
<span class="nc" id="L329">            return laf.getDerivedColor(key, hOffset, sOffset, bOffset, aOffset, true);</span>
        } else {
            // can not give a right answer as painter sould not be used outside
            // of nimbus laf but do the best we can
<span class="nc" id="L333">            return Color.getHSBColor(hOffset,sOffset,bOffset);</span>
        }
    }

    /**
     * Decodes and returns a color, which is derived from a offset between two
     * other colors.
     *
     * @param color1   The first color
     * @param color2   The second color
     * @param midPoint The offset between color 1 and color 2, a value of 0.0 is
     *                 color 1 and 1.0 is color 2;
     * @return The derived color
     */
    protected final Color decodeColor(Color color1, Color color2,
                                      float midPoint) {
<span class="nc" id="L349">        return new Color(NimbusLookAndFeel.deriveARGB(color1, color2, midPoint));</span>
    }

    /**
     * Given parameters for creating a LinearGradientPaint, this method will
     * create and return a linear gradient paint. One primary purpose for this
     * method is to avoid creating a LinearGradientPaint where the start and
     * end points are equal. In such a case, the end y point is slightly
     * increased to avoid the overlap.
     *
     * @param x1
     * @param y1
     * @param x2
     * @param y2
     * @param midpoints
     * @param colors
     * @return a valid LinearGradientPaint. This method never returns null.
     * @throws NullPointerException
     *      if {@code midpoints} array is null,
     *      or {@code colors} array is null,
     * @throws IllegalArgumentException
     *      if start and end points are the same points,
     *      or {@code midpoints.length != colors.length},
     *      or {@code colors} is less than 2 in size,
     *      or a {@code midpoints} value is less than 0.0 or greater than 1.0,
     *      or the {@code midpoints} are not provided in strictly increasing order
     */
    protected final LinearGradientPaint decodeGradient(float x1, float y1, float x2, float y2, float[] midpoints, Color[] colors) {
<span class="nc bnc" id="L377" title="All 4 branches missed.">        if (x1 == x2 &amp;&amp; y1 == y2) {</span>
<span class="nc" id="L378">            y2 += .00001f;</span>
        }
<span class="nc" id="L380">        return new LinearGradientPaint(x1, y1, x2, y2, midpoints, colors);</span>
    }

    /**
     * Given parameters for creating a RadialGradientPaint, this method will
     * create and return a radial gradient paint. One primary purpose for this
     * method is to avoid creating a RadialGradientPaint where the radius
     * is non-positive. In such a case, the radius is just slightly
     * increased to avoid 0.
     *
     * @param x
     * @param y
     * @param r
     * @param midpoints
     * @param colors
     * @return a valid RadialGradientPaint. This method never returns null.
     * @throws NullPointerException
     *      if {@code midpoints} array is null,
     *      or {@code colors} array is null
     * @throws IllegalArgumentException
     *      if {@code r} is non-positive,
     *      or {@code midpoints.length != colors.length},
     *      or {@code colors} is less than 2 in size,
     *      or a {@code midpoints} value is less than 0.0 or greater than 1.0,
     *      or the {@code midpoints} are not provided in strictly increasing order
     */
    protected final RadialGradientPaint decodeRadialGradient(float x, float y, float r, float[] midpoints, Color[] colors) {
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (r == 0f) {</span>
<span class="nc" id="L408">            r = .00001f;</span>
        }
<span class="nc" id="L410">        return new RadialGradientPaint(x, y, r, midpoints, colors);</span>
    }

    /**
     * Get a color property from the given JComponent. First checks for a
     * &lt;code&gt;getXXX()&lt;/code&gt; method and if that fails checks for a client
     * property with key &lt;code&gt;property&lt;/code&gt;. If that still fails to return
     * a Color then &lt;code&gt;defaultColor&lt;/code&gt; is returned.
     *
     * @param c The component to get the color property from
     * @param property The name of a bean style property or client property
     * @param defaultColor The color to return if no color was obtained from
     *        the component.
     * @return The color that was obtained from the component or defaultColor
     */
    protected final Color getComponentColor(JComponent c, String property,
                                            Color defaultColor,
                                            float saturationOffset,
                                            float brightnessOffset,
                                            int alphaOffset) {
<span class="nc" id="L430">        Color color = null;</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (c != null) {</span>
            // handle some special cases for performance
<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (&quot;background&quot;.equals(property)) {</span>
<span class="nc" id="L434">                color = c.getBackground();</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">            } else if (&quot;foreground&quot;.equals(property)) {</span>
<span class="nc" id="L436">                color = c.getForeground();</span>
<span class="nc bnc" id="L437" title="All 4 branches missed.">            } else if (c instanceof JList &amp;&amp; &quot;selectionForeground&quot;.equals(property)) {</span>
<span class="nc" id="L438">                color = ((JList) c).getSelectionForeground();</span>
<span class="nc bnc" id="L439" title="All 4 branches missed.">            } else if (c instanceof JList &amp;&amp; &quot;selectionBackground&quot;.equals(property)) {</span>
<span class="nc" id="L440">                color = ((JList) c).getSelectionBackground();</span>
<span class="nc bnc" id="L441" title="All 4 branches missed.">            } else if (c instanceof JTable &amp;&amp; &quot;selectionForeground&quot;.equals(property)) {</span>
<span class="nc" id="L442">                color = ((JTable) c).getSelectionForeground();</span>
<span class="nc bnc" id="L443" title="All 4 branches missed.">            } else if (c instanceof JTable &amp;&amp; &quot;selectionBackground&quot;.equals(property)) {</span>
<span class="nc" id="L444">                color = ((JTable) c).getSelectionBackground();</span>
            } else {
<span class="nc" id="L446">                String s = &quot;get&quot; + Character.toUpperCase(property.charAt(0)) + property.substring(1);</span>
                try {
<span class="nc" id="L448">                    Method method = c.getClass().getMethod(s);</span>
<span class="nc" id="L449">                    color = (Color) method.invoke(c);</span>
<span class="nc" id="L450">                } catch (Exception e) {</span>
                    //don't do anything, it just didn't work, that's all.
                    //This could be a normal occurance if you use a property
                    //name referring to a key in clientProperties instead of
                    //a real property
<span class="nc" id="L455">                }</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                if (color == null) {</span>
<span class="nc" id="L457">                    Object value = c.getClientProperty(property);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                    if (value instanceof Color) {</span>
<span class="nc" id="L459">                        color = (Color) value;</span>
                    }
                }
            }
        }
        // we return the defaultColor if the color found is null, or if
        // it is a UIResource. This is done because the color for the
        // ENABLED state is set on the component, but you don't want to use
        // that color for the over state. So we only respect the color
        // specified for the property if it was set by the user, as opposed
        // to set by us.
<span class="nc bnc" id="L470" title="All 4 branches missed.">        if (color == null || color instanceof UIResource) {</span>
<span class="nc" id="L471">            return defaultColor;</span>
<span class="nc bnc" id="L472" title="All 6 branches missed.">        } else if (saturationOffset != 0 || brightnessOffset != 0 || alphaOffset != 0) {</span>
<span class="nc" id="L473">            float[] tmp = Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);</span>
<span class="nc" id="L474">            tmp[1] = clamp(tmp[1] + saturationOffset);</span>
<span class="nc" id="L475">            tmp[2] = clamp(tmp[2] + brightnessOffset);</span>
<span class="nc" id="L476">            int alpha = clamp(color.getAlpha() + alphaOffset);</span>
<span class="nc" id="L477">            return new Color((Color.HSBtoRGB(tmp[0], tmp[1], tmp[2]) &amp; 0xFFFFFF) | (alpha &lt;&lt;24));</span>
        } else {
<span class="nc" id="L479">            return color;</span>
        }
    }

    /**
     * A class encapsulating state useful when painting. Generally, instances of this
     * class are created once, and reused for each paint request without modification.
     * This class contains values useful when hinting the cache engine, and when decoding
     * control points and bezier curve anchors.
     */
    protected static class PaintContext {
<span class="nc" id="L490">        protected static enum CacheMode {</span>
<span class="nc" id="L491">            NO_CACHING, FIXED_SIZES, NINE_SQUARE_SCALE</span>
        }

<span class="nc" id="L494">        private static Insets EMPTY_INSETS = new Insets(0, 0, 0, 0);</span>

        private Insets stretchingInsets;
        private Dimension canvasSize;
        private boolean inverted;
        private CacheMode cacheMode;
        private double maxHorizontalScaleFactor;
        private double maxVerticalScaleFactor;

        private float a; // insets.left
        private float b; // canvasSize.width - insets.right
        private float c; // insets.top
        private float d; // canvasSize.height - insets.bottom;
        private float aPercent; // only used if inverted == true
        private float bPercent; // only used if inverted == true
        private float cPercent; // only used if inverted == true
        private float dPercent; // only used if inverted == true

        /**
         * Creates a new PaintContext which does not attempt to cache or scale any cached
         * images.
         *
         * @param insets The stretching insets. May be null. If null, then assumed to be 0, 0, 0, 0.
         * @param canvasSize The size of the canvas used when encoding the various x/y values. May be null.
         *                   If null, then it is assumed that there are no encoded values, and any calls
         *                   to one of the &quot;decode&quot; methods will return the passed in value.
         * @param inverted Whether to &quot;invert&quot; the meaning of the 9-square grid and stretching insets
         */
        public PaintContext(Insets insets, Dimension canvasSize, boolean inverted) {
<span class="nc" id="L523">            this(insets, canvasSize, inverted, null, 1, 1);</span>
<span class="nc" id="L524">        }</span>

        /**
         * Creates a new PaintContext.
         *
         * @param insets The stretching insets. May be null. If null, then assumed to be 0, 0, 0, 0.
         * @param canvasSize The size of the canvas used when encoding the various x/y values. May be null.
         *                   If null, then it is assumed that there are no encoded values, and any calls
         *                   to one of the &quot;decode&quot; methods will return the passed in value.
         * @param inverted Whether to &quot;invert&quot; the meaning of the 9-square grid and stretching insets
         * @param cacheMode A hint as to which caching mode to use. If null, then set to no caching.
         * @param maxH The maximum scale in the horizontal direction to use before punting and redrawing from scratch.
         *             For example, if maxH is 2, then we will attempt to scale any cached images up to 2x the canvas
         *             width before redrawing from scratch. Reasonable maxH values may improve painting performance.
         *             If set too high, then you may get poor looking graphics at higher zoom levels. Must be &amp;gt;= 1.
         * @param maxV The maximum scale in the vertical direction to use before punting and redrawing from scratch.
         *             For example, if maxV is 2, then we will attempt to scale any cached images up to 2x the canvas
         *             height before redrawing from scratch. Reasonable maxV values may improve painting performance.
         *             If set too high, then you may get poor looking graphics at higher zoom levels. Must be &amp;gt;= 1.
         */
        public PaintContext(Insets insets, Dimension canvasSize, boolean inverted,
<span class="nc" id="L545">                            CacheMode cacheMode, double maxH, double maxV) {</span>
<span class="nc bnc" id="L546" title="All 4 branches missed.">            if (maxH &lt; 1 || maxH &lt; 1) {</span>
<span class="nc" id="L547">                throw new IllegalArgumentException(&quot;Both maxH and maxV must be &gt;= 1&quot;);</span>
            }

<span class="nc bnc" id="L550" title="All 2 branches missed.">            this.stretchingInsets = insets == null ? EMPTY_INSETS : insets;</span>
<span class="nc" id="L551">            this.canvasSize = canvasSize;</span>
<span class="nc" id="L552">            this.inverted = inverted;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">            this.cacheMode = cacheMode == null ? CacheMode.NO_CACHING : cacheMode;</span>
<span class="nc" id="L554">            this.maxHorizontalScaleFactor = maxH;</span>
<span class="nc" id="L555">            this.maxVerticalScaleFactor = maxV;</span>

<span class="nc bnc" id="L557" title="All 2 branches missed.">            if (canvasSize != null) {</span>
<span class="nc" id="L558">                a = stretchingInsets.left;</span>
<span class="nc" id="L559">                b = canvasSize.width - stretchingInsets.right;</span>
<span class="nc" id="L560">                c = stretchingInsets.top;</span>
<span class="nc" id="L561">                d = canvasSize.height - stretchingInsets.bottom;</span>
<span class="nc" id="L562">                this.canvasSize = canvasSize;</span>
<span class="nc" id="L563">                this.inverted = inverted;</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                if (inverted) {</span>
<span class="nc" id="L565">                    float available = canvasSize.width - (b - a);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                    aPercent = available &gt; 0f ? a / available : 0f;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                    bPercent = available &gt; 0f ? b / available : 0f;</span>
<span class="nc" id="L568">                    available = canvasSize.height - (d - c);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                    cPercent = available &gt; 0f ? c / available : 0f;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                    dPercent = available &gt; 0f ? d / available : 0f;</span>
                }
            }
<span class="nc" id="L573">        }</span>
    }

    //---------------------- private methods

    //initializes the class to prepare it for being able to decode points
    private void prepare(float w, float h) {
        //if no PaintContext has been specified, reset the values and bail
        //also bail if the canvasSize was not set (since decoding will not work)
<span class="nc bnc" id="L582" title="All 4 branches missed.">        if (ctx == null || ctx.canvasSize == null) {</span>
<span class="nc" id="L583">            f = 1f;</span>
<span class="nc" id="L584">            leftWidth = centerWidth = rightWidth = 0f;</span>
<span class="nc" id="L585">            topHeight = centerHeight = bottomHeight = 0f;</span>
<span class="nc" id="L586">            leftScale = centerHScale = rightScale = 0f;</span>
<span class="nc" id="L587">            topScale = centerVScale = bottomScale = 0f;</span>
<span class="nc" id="L588">            return;</span>
        }

        //calculate the scaling factor, and the sizes for the various 9-square sections
<span class="nc" id="L592">        Number scale = (Number)UIManager.get(&quot;scale&quot;);</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">        f = scale == null ? 1f : scale.floatValue();</span>

<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (ctx.inverted) {</span>
<span class="nc" id="L596">            centerWidth = (ctx.b - ctx.a) * f;</span>
<span class="nc" id="L597">            float availableSpace = w - centerWidth;</span>
<span class="nc" id="L598">            leftWidth = availableSpace * ctx.aPercent;</span>
<span class="nc" id="L599">            rightWidth = availableSpace * ctx.bPercent;</span>
<span class="nc" id="L600">            centerHeight = (ctx.d - ctx.c) * f;</span>
<span class="nc" id="L601">            availableSpace = h - centerHeight;</span>
<span class="nc" id="L602">            topHeight = availableSpace * ctx.cPercent;</span>
<span class="nc" id="L603">            bottomHeight = availableSpace * ctx.dPercent;</span>
<span class="nc" id="L604">        } else {</span>
<span class="nc" id="L605">            leftWidth = ctx.a * f;</span>
<span class="nc" id="L606">            rightWidth = (float)(ctx.canvasSize.getWidth() - ctx.b) * f;</span>
<span class="nc" id="L607">            centerWidth = w - leftWidth - rightWidth;</span>
<span class="nc" id="L608">            topHeight = ctx.c * f;</span>
<span class="nc" id="L609">            bottomHeight = (float)(ctx.canvasSize.getHeight() - ctx.d) * f;</span>
<span class="nc" id="L610">            centerHeight = h - topHeight - bottomHeight;</span>
        }

<span class="nc bnc" id="L613" title="All 2 branches missed.">        leftScale = ctx.a == 0f ? 0f : leftWidth / ctx.a;</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">        centerHScale = (ctx.b - ctx.a) == 0f ? 0f : centerWidth / (ctx.b - ctx.a);</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">        rightScale = (ctx.canvasSize.width - ctx.b) == 0f ? 0f : rightWidth / (ctx.canvasSize.width - ctx.b);</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">        topScale = ctx.c == 0f ? 0f : topHeight / ctx.c;</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">        centerVScale = (ctx.d - ctx.c) == 0f ? 0f : centerHeight / (ctx.d - ctx.c);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">        bottomScale = (ctx.canvasSize.height - ctx.d) == 0f ? 0f : bottomHeight / (ctx.canvasSize.height - ctx.d);</span>
<span class="nc" id="L619">    }</span>

    private void paintWith9SquareCaching(Graphics2D g, PaintContext ctx,
                                         JComponent c, int w, int h,
                                         Object[] extendedCacheKeys) {
        // check if we can scale to the requested size
<span class="nc" id="L625">        Dimension canvas = ctx.canvasSize;</span>
<span class="nc" id="L626">        Insets insets = ctx.stretchingInsets;</span>

<span class="nc bnc" id="L628" title="All 4 branches missed.">        if (w &lt;= (canvas.width * ctx.maxHorizontalScaleFactor) &amp;&amp; h &lt;= (canvas.height * ctx.maxVerticalScaleFactor)) {</span>
            // get image at canvas size
<span class="nc" id="L630">            VolatileImage img = getImage(g.getDeviceConfiguration(), c, canvas.width, canvas.height, extendedCacheKeys);</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            if (img != null) {</span>
                // calculate dst inserts
                // todo: destination inserts need to take into acount scale factor for high dpi. Note: You can use f for this, I think
                Insets dstInsets;
<span class="nc bnc" id="L635" title="All 2 branches missed.">                if (ctx.inverted){</span>
<span class="nc" id="L636">                    int leftRight = (w-(canvas.width-(insets.left+insets.right)))/2;</span>
<span class="nc" id="L637">                    int topBottom = (h-(canvas.height-(insets.top+insets.bottom)))/2;</span>
<span class="nc" id="L638">                    dstInsets = new Insets(topBottom,leftRight,topBottom,leftRight);</span>
<span class="nc" id="L639">                } else {</span>
<span class="nc" id="L640">                    dstInsets = insets;</span>
                }
                // paint 9 square scaled
<span class="nc" id="L643">                Object oldScaleingHints = g.getRenderingHint(RenderingHints.KEY_INTERPOLATION);</span>
<span class="nc" id="L644">                g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);</span>
<span class="nc" id="L645">                ImageScalingHelper.paint(g, 0, 0, w, h, img, insets, dstInsets,</span>
                        ImageScalingHelper.PaintType.PAINT9_STRETCH, ImageScalingHelper.PAINT_ALL);
<span class="nc bnc" id="L647" title="All 2 branches missed.">                g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,</span>
                    oldScaleingHints!=null?oldScaleingHints:RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);
<span class="nc" id="L649">            } else {</span>
                // render directly
<span class="nc" id="L651">                paint0(g, c, w, h, extendedCacheKeys);</span>
            }
<span class="nc" id="L653">        } else {</span>
            // paint directly
<span class="nc" id="L655">            paint0(g, c, w, h, extendedCacheKeys);</span>
        }
<span class="nc" id="L657">    }</span>

    private void paintWithFixedSizeCaching(Graphics2D g, JComponent c, int w,
                                           int h, Object[] extendedCacheKeys) {
<span class="nc" id="L661">        VolatileImage img = getImage(g.getDeviceConfiguration(), c, w, h, extendedCacheKeys);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (img != null) {</span>
            //render cached image
<span class="nc" id="L664">            g.drawImage(img, 0, 0, null);</span>
        } else {
            // render directly
<span class="nc" id="L667">            paint0(g, c, w, h, extendedCacheKeys);</span>
        }
<span class="nc" id="L669">    }</span>

    /** Gets the rendered image for this painter at the requested size, either from cache or create a new one */
    private VolatileImage getImage(GraphicsConfiguration config, JComponent c,
                                   int w, int h, Object[] extendedCacheKeys) {
<span class="nc" id="L674">        ImageCache imageCache = ImageCache.getInstance();</span>
        //get the buffer for this component
<span class="nc" id="L676">        VolatileImage buffer = (VolatileImage) imageCache.getImage(config, w, h, this, extendedCacheKeys);</span>

<span class="nc" id="L678">        int renderCounter = 0; //to avoid any potential, though unlikely, infinite loop</span>
        do {
            //validate the buffer so we can check for surface loss
<span class="nc" id="L681">            int bufferStatus = VolatileImage.IMAGE_INCOMPATIBLE;</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">            if (buffer != null) {</span>
<span class="nc" id="L683">                bufferStatus = buffer.validate(config);</span>
            }

            //If the buffer status is incompatible or restored, then we need to re-render to the volatile image
<span class="nc bnc" id="L687" title="All 4 branches missed.">            if (bufferStatus == VolatileImage.IMAGE_INCOMPATIBLE || bufferStatus == VolatileImage.IMAGE_RESTORED) {</span>
                //if the buffer is null (hasn't been created), or isn't the right size, or has lost its contents,
                //then recreate the buffer
<span class="nc bnc" id="L690" title="All 8 branches missed.">                if (buffer == null || buffer.getWidth() != w || buffer.getHeight() != h ||</span>
                        bufferStatus == VolatileImage.IMAGE_INCOMPATIBLE) {
                    //clear any resources related to the old back buffer
<span class="nc bnc" id="L693" title="All 2 branches missed.">                    if (buffer != null) {</span>
<span class="nc" id="L694">                        buffer.flush();</span>
<span class="nc" id="L695">                        buffer = null;</span>
                    }
                    //recreate the buffer
<span class="nc" id="L698">                    buffer = config.createCompatibleVolatileImage(w, h,</span>
                            Transparency.TRANSLUCENT);
                    // put in cache for future
<span class="nc" id="L701">                    imageCache.setImage(buffer, config, w, h, this, extendedCacheKeys);</span>
                }
                //create the graphics context with which to paint to the buffer
<span class="nc" id="L704">                Graphics2D bg = buffer.createGraphics();</span>
                //clear the background before configuring the graphics
<span class="nc" id="L706">                bg.setComposite(AlphaComposite.Clear);</span>
<span class="nc" id="L707">                bg.fillRect(0, 0, w, h);</span>
<span class="nc" id="L708">                bg.setComposite(AlphaComposite.SrcOver);</span>
<span class="nc" id="L709">                configureGraphics(bg);</span>
                // paint the painter into buffer
<span class="nc" id="L711">                paint0(bg, c, w, h, extendedCacheKeys);</span>
                //close buffer graphics
<span class="nc" id="L713">                bg.dispose();</span>
            }
<span class="nc bnc" id="L715" title="All 4 branches missed.">        } while (buffer.contentsLost() &amp;&amp; renderCounter++ &lt; 3);</span>
        // check if we failed
<span class="nc bnc" id="L717" title="All 2 branches missed.">        if (renderCounter == 3) return null;</span>
        // return image
<span class="nc" id="L719">        return buffer;</span>
    }

    //convenience method which creates a temporary graphics object by creating a
    //clone of the passed in one, configuring it, drawing with it, disposing it.
    //These steps have to be taken to ensure that any hints set on the graphics
    //are removed subsequent to painting.
    private void paint0(Graphics2D g, JComponent c, int width, int height,
                        Object[] extendedCacheKeys) {
<span class="nc" id="L728">        prepare(width, height);</span>
<span class="nc" id="L729">        g = (Graphics2D)g.create();</span>
<span class="nc" id="L730">        configureGraphics(g);</span>
<span class="nc" id="L731">        doPaint(g, c, width, height, extendedCacheKeys);</span>
<span class="nc" id="L732">        g.dispose();</span>
<span class="nc" id="L733">    }</span>

    private float clamp(float value) {
<span class="nc bnc" id="L736" title="All 2 branches missed.">        if (value &lt; 0) {</span>
<span class="nc" id="L737">            value = 0;</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">        } else if (value &gt; 1) {</span>
<span class="nc" id="L739">            value = 1;</span>
        }
<span class="nc" id="L741">        return value;</span>
    }

    private int clamp(int value) {
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (value &lt; 0) {</span>
<span class="nc" id="L746">            value = 0;</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">        } else if (value &gt; 255) {</span>
<span class="nc" id="L748">            value = 255;</span>
        }
<span class="nc" id="L750">        return value;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>