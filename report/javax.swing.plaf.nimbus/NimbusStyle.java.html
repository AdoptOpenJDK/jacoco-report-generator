<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>NimbusStyle.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing.plaf.nimbus</a> &gt; <span class="el_source">NimbusStyle.java</span></div><h1>NimbusStyle.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing.plaf.nimbus;

import javax.swing.Painter;

import javax.swing.JComponent;
import javax.swing.UIDefaults;
import javax.swing.UIManager;
import javax.swing.plaf.ColorUIResource;
import javax.swing.plaf.synth.ColorType;
import static javax.swing.plaf.synth.SynthConstants.*;
import javax.swing.plaf.synth.SynthContext;
import javax.swing.plaf.synth.SynthPainter;
import javax.swing.plaf.synth.SynthStyle;
import java.awt.Color;
import java.awt.Font;
import java.awt.Insets;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * &lt;p&gt;A SynthStyle implementation used by Nimbus. Each Region that has been
 * registered with the NimbusLookAndFeel will have an associated NimbusStyle.
 * Third party components that are registered with the NimbusLookAndFeel will
 * therefore be handed a NimbusStyle from the look and feel from the
 * #getStyle(JComponent, Region) method.&lt;/p&gt;
 *
 * &lt;p&gt;This class properly reads and retrieves values placed in the UIDefaults
 * according to the standard Nimbus naming conventions. It will create and
 * retrieve painters, fonts, colors, and other data stored there.&lt;/p&gt;
 *
 * &lt;p&gt;NimbusStyle also supports the ability to override settings on a per
 * component basis. NimbusStyle checks the component's client property map for
 * &quot;Nimbus.Overrides&quot;. If the value associated with this key is an instance of
 * UIDefaults, then the values in that defaults table will override the standard
 * Nimbus defaults in UIManager, but for that component instance only.&lt;/p&gt;
 *
 * &lt;p&gt;Optionally, you may specify the client property
 * &quot;Nimbus.Overrides.InheritDefaults&quot;. If true, this client property indicates
 * that the defaults located in UIManager should first be read, and then
 * replaced with defaults located in the component client properties. If false,
 * then only the defaults located in the component client property map will
 * be used. If not specified, it is assumed to be true.&lt;/p&gt;
 *
 * &lt;p&gt;You must specify &quot;Nimbus.Overrides&quot; for &quot;Nimbus.Overrides.InheritDefaults&quot;
 * to have any effect. &quot;Nimbus.Overrides&quot; indicates whether there are any
 * overrides, while &quot;Nimbus.Overrides.InheritDefaults&quot; indicates whether those
 * overrides should first be initialized with the defaults from UIManager.&lt;/p&gt;
 *
 * &lt;p&gt;The NimbusStyle is reloaded whenever a property change event is fired
 * for a component for &quot;Nimbus.Overrides&quot; or &quot;Nimbus.Overrides.InheritDefaults&quot;.
 * So for example, setting a new UIDefaults on a component would cause the
 * style to be reloaded.&lt;/p&gt;
 *
 * &lt;p&gt;The values are only read out of UIManager once, and then cached. If
 * you need to read the values again (for example, if the UI is being reloaded),
 * then discard this NimbusStyle and read a new one from NimbusLookAndFeel
 * using NimbusLookAndFeel.getStyle.&lt;/p&gt;
 *
 * &lt;p&gt;The primary API of interest in this class for 3rd party component authors
 * are the three methods which retrieve painters: #getBackgroundPainter,
 * #getForegroundPainter, and #getBorderPainter.&lt;/p&gt;
 *
 * &lt;p&gt;NimbusStyle allows you to specify custom states, or modify the order of
 * states. Synth (and thus Nimbus) has the concept of a &quot;state&quot;. For example,
 * a JButton might be in the &quot;MOUSE_OVER&quot; state, or the &quot;ENABLED&quot; state, or the
 * &quot;DISABLED&quot; state. These are all &quot;standard&quot; states which are defined in synth,
 * and which apply to all synth Regions.&lt;/p&gt;
 *
 * &lt;p&gt;Sometimes, however, you need to have a custom state. For example, you
 * want JButton to render differently if it's parent is a JToolbar. In Nimbus,
 * you specify these custom states by including a special key in UIDefaults.
 * The following UIDefaults entries define three states for this button:&lt;/p&gt;
 *
 * &lt;pre&gt;&lt;code&gt;
 *     JButton.States = Enabled, Disabled, Toolbar
 *     JButton[Enabled].backgroundPainter = somePainter
 *     JButton[Disabled].background = BLUE
 *     JButton[Toolbar].backgroundPainter = someOtherPaint
 * &lt;/code&gt;&lt;/pre&gt;
 *
 * &lt;p&gt;As you can see, the &lt;code&gt;JButton.States&lt;/code&gt; entry lists the states
 * that the JButton style will support. You then specify the settings for
 * each state. If you do not specify the &lt;code&gt;JButton.States&lt;/code&gt; entry,
 * then the standard Synth states will be assumed. If you specify the entry
 * but the list of states is empty or null, then the standard synth states
 * will be assumed.&lt;/p&gt;
 *
 * @author Richard Bair
 * @author Jasper Potts
 */
<span class="nc bnc" id="L121" title="All 2 branches missed.">public final class NimbusStyle extends SynthStyle {</span>
    /* Keys and scales for large/small/mini components, based on Apples sizes */
    public static final String LARGE_KEY = &quot;large&quot;;
    public static final String SMALL_KEY = &quot;small&quot;;
    public static final String MINI_KEY = &quot;mini&quot;;
    public static final double LARGE_SCALE = 1.15;
    public static final double SMALL_SCALE = 0.857;
    public static final double MINI_SCALE = 0.714;

    /**
     * Special constant used for performance reasons during the get() method.
     * If get() runs through all of the search locations and determines that
     * there is no value, then NULL will be placed into the values map. This way
     * on subsequent lookups it will simply extract NULL, see it, and return
     * null rather than continuing the lookup procedure.
     */
<span class="nc" id="L137">    private static final Object NULL = '\0';</span>
    /**
     * &lt;p&gt;The Color to return from getColorForState if it would otherwise have
     * returned null.&lt;/p&gt;
     *
     * &lt;p&gt;Returning null from getColorForState is a very bad thing, as it causes
     * the AWT peer for the component to install a SystemColor, which is not a
     * UIResource. As a result, if &lt;code&gt;null&lt;/code&gt; is returned from
     * getColorForState, then thereafter the color is not updated for other
     * states or on LAF changes or updates. This DEFAULT_COLOR is used to
     * ensure that a ColorUIResource is always returned from
     * getColorForState.&lt;/p&gt;
     */
<span class="nc" id="L150">    private static final Color DEFAULT_COLOR = new ColorUIResource(Color.BLACK);</span>
    /**
     * Simple Comparator for ordering the RuntimeStates according to their
     * rank.
     */
<span class="nc" id="L155">    private static final Comparator&lt;RuntimeState&gt; STATE_COMPARATOR =</span>
<span class="nc" id="L156">        new Comparator&lt;RuntimeState&gt;() {</span>
            @Override
            public int compare(RuntimeState a, RuntimeState b) {
<span class="nc" id="L159">                return a.state - b.state;</span>
            }
        };
    /**
     * The prefix for the component or region that this NimbusStyle
     * represents. This prefix is used to lookup state in the UIManager.
     * It should be something like Button or Slider.Thumb or &quot;MyButton&quot; or
     * ComboBox.&quot;ComboBox.arrowButton&quot; or &quot;MyComboBox&quot;.&quot;ComboBox.arrowButton&quot;
     */
    private String prefix;
    /**
     * The SynthPainter that will be returned from this NimbusStyle. The
     * SynthPainter returned will be a SynthPainterImpl, which will in turn
     * delegate back to this NimbusStyle for the proper Painter (not
     * SynthPainter) to use for painting the foreground, background, or border.
     */
    private SynthPainter painter;
    /**
     * Data structure containing all of the defaults, insets, states, and other
     * values associated with this style. This instance refers to default
     * values, and are used when no overrides are discovered in the client
     * properties of a component. These values are lazily created on first
     * access.
     */
    private Values values;

    /**
     * A temporary CacheKey used to perform lookups. This pattern avoids
     * creating useless garbage keys, or concatenating strings, etc.
     */
<span class="nc" id="L189">    private CacheKey tmpKey = new CacheKey(&quot;&quot;, 0);</span>

    /**
     * Some NimbusStyles are created for a specific component only. In Nimbus,
     * this happens whenever the component has as a client property a
     * UIDefaults which overrides (or supplements) those defaults found in
     * UIManager.
     */
    private WeakReference&lt;JComponent&gt; component;

    /**
     * Create a new NimbusStyle. Only the prefix must be supplied. At the
     * appropriate time, installDefaults will be called. At that point, all of
     * the state information will be pulled from UIManager and stored locally
     * within this style.
     *
     * @param prefix Something like Button or Slider.Thumb or
     *        org.jdesktop.swingx.JXStatusBar or ComboBox.&quot;ComboBox.arrowButton&quot;
     * @param c an optional reference to a component that this NimbusStyle
     *        should be associated with. This is only used when the component
     *        has Nimbus overrides registered in its client properties and
     *        should be null otherwise.
     */
<span class="nc" id="L212">    NimbusStyle(String prefix, JComponent c) {</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (c != null) {</span>
<span class="nc" id="L214">            this.component = new WeakReference&lt;JComponent&gt;(c);</span>
        }
<span class="nc" id="L216">        this.prefix = prefix;</span>
<span class="nc" id="L217">        this.painter = new SynthPainterImpl(this);</span>
<span class="nc" id="L218">    }</span>

    /**
     * {@inheritDoc}
     *
     * Overridden to cause this style to populate itself with data from
     * UIDefaults, if necessary.
     */
    @Override public void installDefaults(SynthContext ctx) {
<span class="nc" id="L227">        validate();</span>

        //delegate to the superclass to install defaults such as background,
        //foreground, font, and opaque onto the swing component.
<span class="nc" id="L231">        super.installDefaults(ctx);</span>
<span class="nc" id="L232">    }</span>

    /**
     * Pulls data out of UIDefaults, if it has not done so already, and sets
     * up the internal state.
     */
    private void validate() {
        // a non-null values object is the flag we use to determine whether
        // to reparse from UIManager.
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (values != null) return;</span>

        // reconstruct this NimbusStyle based on the entries in the UIManager
        // and possibly based on any overrides within the component's
        // client properties (assuming such a component exists and contains
        // any Nimbus.Overrides)
<span class="nc" id="L247">        values = new Values();</span>

        Map&lt;String, Object&gt; defaults =
<span class="nc" id="L250">                ((NimbusLookAndFeel) UIManager.getLookAndFeel()).</span>
<span class="nc" id="L251">                        getDefaultsForPrefix(prefix);</span>

        // inspect the client properties for the key &quot;Nimbus.Overrides&quot;. If the
        // value is an instance of UIDefaults, then these defaults are used
        // in place of, or in addition to, the defaults in UIManager.
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (component != null) {</span>
            // We know component.get() is non-null here, as if the component
            // were GC'ed, we wouldn't be processing its style.
<span class="nc" id="L259">            Object o = component.get().getClientProperty(&quot;Nimbus.Overrides&quot;);</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            if (o instanceof UIDefaults) {</span>
<span class="nc" id="L261">                Object i = component.get().getClientProperty(</span>
                        &quot;Nimbus.Overrides.InheritDefaults&quot;);
<span class="nc bnc" id="L263" title="All 2 branches missed.">                boolean inherit = i instanceof Boolean ? (Boolean)i : true;</span>
<span class="nc" id="L264">                UIDefaults d = (UIDefaults)o;</span>
<span class="nc" id="L265">                TreeMap&lt;String, Object&gt; map = new TreeMap&lt;String, Object&gt;();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">                for (Object obj : d.keySet()) {</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">                    if (obj instanceof String) {</span>
<span class="nc" id="L268">                        String key = (String)obj;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">                        if (key.startsWith(prefix)) {</span>
<span class="nc" id="L270">                            map.put(key, d.get(key));</span>
                        }
                    }
<span class="nc" id="L273">                }</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">                if (inherit) {</span>
<span class="nc" id="L275">                    defaults.putAll(map);</span>
                } else {
<span class="nc" id="L277">                    defaults = map;</span>
                }
            }
        }

        //a list of the different types of states used by this style. This
        //list may contain only &quot;standard&quot; states (those defined by Synth),
        //or it may contain custom states, or it may contain only &quot;standard&quot;
        //states but list them in a non-standard order.
<span class="nc" id="L286">        List&lt;State&gt; states = new ArrayList&lt;State&gt;();</span>
        //a map of state name to code
<span class="nc" id="L288">        Map&lt;String,Integer&gt; stateCodes = new HashMap&lt;String,Integer&gt;();</span>
        //This is a list of runtime &quot;state&quot; context objects. These contain
        //the values associated with each state.
<span class="nc" id="L291">        List&lt;RuntimeState&gt; runtimeStates = new ArrayList&lt;RuntimeState&gt;();</span>

        //determine whether there are any custom states, or custom state
        //order. If so, then read all those custom states and define the
        //&quot;values&quot; stateTypes to be a non-null array.
        //Otherwise, let the &quot;values&quot; stateTypes be null to indicate that
        //there are no custom states or custom state ordering
<span class="nc" id="L298">        String statesString = (String)defaults.get(prefix + &quot;.States&quot;);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        if (statesString != null) {</span>
<span class="nc" id="L300">            String s[] = statesString.split(&quot;,&quot;);</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            for (int i=0; i&lt;s.length; i++) {</span>
<span class="nc" id="L302">                s[i] = s[i].trim();</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if (!State.isStandardStateName(s[i])) {</span>
                    //this is a non-standard state name, so look for the
                    //custom state associated with it
<span class="nc" id="L306">                    String stateName = prefix + &quot;.&quot; + s[i];</span>
<span class="nc" id="L307">                    State customState = (State)defaults.get(stateName);</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">                    if (customState != null) {</span>
<span class="nc" id="L309">                        states.add(customState);</span>
                    }
<span class="nc" id="L311">                } else {</span>
<span class="nc" id="L312">                    states.add(State.getStandardState(s[i]));</span>
                }
            }

            //if there were any states defined, then set the stateTypes array
            //to be non-null. Otherwise, leave it null (meaning, use the
            //standard synth states).
<span class="nc bnc" id="L319" title="All 2 branches missed.">            if (states.size() &gt; 0) {</span>
<span class="nc" id="L320">                values.stateTypes = states.toArray(new State[states.size()]);</span>
            }

            //assign codes for each of the state types
<span class="nc" id="L324">            int code = 1;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            for (State state : states) {</span>
<span class="nc" id="L326">                stateCodes.put(state.getName(), code);</span>
<span class="nc" id="L327">                code &lt;&lt;= 1;</span>
<span class="nc" id="L328">            }</span>
<span class="nc" id="L329">        } else {</span>
            //since there were no custom states defined, setup the list of
            //standard synth states. Note that the &quot;v.stateTypes&quot; is not
            //being set here, indicating that at runtime the state selection
            //routines should use standard synth states instead of custom
            //states. I do need to popuplate this temp list now though, so that
            //the remainder of this method will function as expected.
<span class="nc" id="L336">            states.add(State.Enabled);</span>
<span class="nc" id="L337">            states.add(State.MouseOver);</span>
<span class="nc" id="L338">            states.add(State.Pressed);</span>
<span class="nc" id="L339">            states.add(State.Disabled);</span>
<span class="nc" id="L340">            states.add(State.Focused);</span>
<span class="nc" id="L341">            states.add(State.Selected);</span>
<span class="nc" id="L342">            states.add(State.Default);</span>

            //assign codes for the states
<span class="nc" id="L345">            stateCodes.put(&quot;Enabled&quot;, ENABLED);</span>
<span class="nc" id="L346">            stateCodes.put(&quot;MouseOver&quot;, MOUSE_OVER);</span>
<span class="nc" id="L347">            stateCodes.put(&quot;Pressed&quot;, PRESSED);</span>
<span class="nc" id="L348">            stateCodes.put(&quot;Disabled&quot;, DISABLED);</span>
<span class="nc" id="L349">            stateCodes.put(&quot;Focused&quot;, FOCUSED);</span>
<span class="nc" id="L350">            stateCodes.put(&quot;Selected&quot;, SELECTED);</span>
<span class="nc" id="L351">            stateCodes.put(&quot;Default&quot;, DEFAULT);</span>
        }

        //Now iterate over all the keys in the defaults table
<span class="nc bnc" id="L355" title="All 2 branches missed.">        for (String key : defaults.keySet()) {</span>
            //The key is something like JButton.Enabled.backgroundPainter,
            //or JButton.States, or JButton.background.
            //Remove the &quot;JButton.&quot; portion of the key
<span class="nc" id="L359">            String temp = key.substring(prefix.length());</span>
            //if there is a &quot; or : then we skip it because it is a subregion
            //of some kind
<span class="nc bnc" id="L362" title="All 4 branches missed.">            if (temp.indexOf('&quot;') != -1 || temp.indexOf(':') != -1) continue;</span>
            //remove the separator
<span class="nc" id="L364">            temp = temp.substring(1);</span>
            //At this point, temp may be any of the following:
            //background
            //[Enabled].background
            //[Enabled+MouseOver].background
            //property.foo

            //parse out the states and the property
<span class="nc" id="L372">            String stateString = null;</span>
<span class="nc" id="L373">            String property = null;</span>
<span class="nc" id="L374">            int bracketIndex = temp.indexOf(']');</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            if (bracketIndex &lt; 0) {</span>
                //there is not a state string, so property = temp
<span class="nc" id="L377">                property = temp;</span>
            } else {
<span class="nc" id="L379">                stateString = temp.substring(0, bracketIndex);</span>
<span class="nc" id="L380">                property = temp.substring(bracketIndex + 2);</span>
            }

            //now that I have the state (if any) and the property, get the
            //value for this property and install it where it belongs
<span class="nc bnc" id="L385" title="All 2 branches missed.">            if (stateString == null) {</span>
                //there was no state, just a property. Check for the custom
                //&quot;contentMargins&quot; property (which is handled specially by
                //Synth/Nimbus). Also check for the property being &quot;States&quot;,
                //in which case it is not a real property and should be ignored.
                //otherwise, assume it is a property and install it on the
                //values object
<span class="nc bnc" id="L392" title="All 2 branches missed.">                if (&quot;contentMargins&quot;.equals(property)) {</span>
<span class="nc" id="L393">                    values.contentMargins = (Insets)defaults.get(key);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                } else if (&quot;States&quot;.equals(property)) {</span>
                    //ignore
                } else {
<span class="nc" id="L397">                    values.defaults.put(property, defaults.get(key));</span>
                }
            } else {
                //it is possible that the developer has a malformed UIDefaults
                //entry, such that something was specified in the place of
                //the State portion of the key but it wasn't a state. In this
                //case, skip will be set to true
<span class="nc" id="L404">                boolean skip = false;</span>
                //this variable keeps track of the int value associated with
                //the state. See SynthState for details.
<span class="nc" id="L407">                int componentState = 0;</span>
                //Multiple states may be specified in the string, such as
                //Enabled+MouseOver
<span class="nc" id="L410">                String[] stateParts = stateString.split(&quot;\\+&quot;);</span>
                //For each state, we need to find the State object associated
                //with it, or skip it if it cannot be found.
<span class="nc bnc" id="L413" title="All 2 branches missed.">                for (String s : stateParts) {</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">                    if (stateCodes.containsKey(s)) {</span>
<span class="nc" id="L415">                        componentState |= stateCodes.get(s);</span>
                    } else {
                        //Was not a state. Maybe it was a subregion or something
                        //skip it.
<span class="nc" id="L419">                        skip = true;</span>
<span class="nc" id="L420">                        break;</span>
                    }
                }

<span class="nc bnc" id="L424" title="All 2 branches missed.">                if (skip) continue;</span>

                //find the RuntimeState for this State
<span class="nc" id="L427">                RuntimeState rs = null;</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                for (RuntimeState s : runtimeStates) {</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                    if (s.state == componentState) {</span>
<span class="nc" id="L430">                        rs = s;</span>
<span class="nc" id="L431">                        break;</span>
                    }
<span class="nc" id="L433">                }</span>

                //couldn't find the runtime state, so create a new one
<span class="nc bnc" id="L436" title="All 2 branches missed.">                if (rs == null) {</span>
<span class="nc" id="L437">                    rs = new RuntimeState(componentState, stateString);</span>
<span class="nc" id="L438">                    runtimeStates.add(rs);</span>
                }

                //check for a couple special properties, such as for the
                //painters. If these are found, then set the specially on
                //the runtime state. Else, it is just a normal property,
                //so put it in the UIDefaults associated with that runtime
                //state
<span class="nc bnc" id="L446" title="All 2 branches missed.">                if (&quot;backgroundPainter&quot;.equals(property)) {</span>
<span class="nc" id="L447">                    rs.backgroundPainter = getPainter(defaults, key);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">                } else if (&quot;foregroundPainter&quot;.equals(property)) {</span>
<span class="nc" id="L449">                    rs.foregroundPainter = getPainter(defaults, key);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">                } else if (&quot;borderPainter&quot;.equals(property)) {</span>
<span class="nc" id="L451">                    rs.borderPainter = getPainter(defaults, key);</span>
                } else {
<span class="nc" id="L453">                    rs.defaults.put(property, defaults.get(key));</span>
                }
            }
<span class="nc" id="L456">        }</span>

        //now that I've collected all the runtime states, I'll sort them based
        //on their integer &quot;state&quot; (see SynthState for how this works).
<span class="nc" id="L460">        Collections.sort(runtimeStates, STATE_COMPARATOR);</span>

        //finally, set the array of runtime states on the values object
<span class="nc" id="L463">        values.states = runtimeStates.toArray(new RuntimeState[runtimeStates.size()]);</span>
<span class="nc" id="L464">    }</span>

    private Painter getPainter(Map&lt;String, Object&gt; defaults, String key) {
<span class="nc" id="L467">        Object p = defaults.get(key);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (p instanceof UIDefaults.LazyValue) {</span>
<span class="nc" id="L469">            p = ((UIDefaults.LazyValue)p).createValue(UIManager.getDefaults());</span>
        }
<span class="nc bnc" id="L471" title="All 2 branches missed.">        return (p instanceof Painter ? (Painter)p : null);</span>
    }

    /**
     * {@inheritDoc}
     *
     * Overridden to cause this style to populate itself with data from
     * UIDefaults, if necessary.
     */
    @Override public Insets getInsets(SynthContext ctx, Insets in) {
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (in == null) {</span>
<span class="nc" id="L482">            in = new Insets(0, 0, 0, 0);</span>
        }

<span class="nc" id="L485">        Values v = getValues(ctx);</span>

<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (v.contentMargins == null) {</span>
<span class="nc" id="L488">            in.bottom = in.top = in.left = in.right = 0;</span>
<span class="nc" id="L489">            return in;</span>
        } else {
<span class="nc" id="L491">            in.bottom = v.contentMargins.bottom;</span>
<span class="nc" id="L492">            in.top = v.contentMargins.top;</span>
<span class="nc" id="L493">            in.left = v.contentMargins.left;</span>
<span class="nc" id="L494">            in.right = v.contentMargins.right;</span>
            // Account for scale
            // The key &quot;JComponent.sizeVariant&quot; is used to match Apple's LAF
<span class="nc" id="L497">            String scaleKey = (String)ctx.getComponent().getClientProperty(</span>
                    &quot;JComponent.sizeVariant&quot;);
<span class="nc bnc" id="L499" title="All 2 branches missed.">            if (scaleKey != null){</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                if (LARGE_KEY.equals(scaleKey)){</span>
<span class="nc" id="L501">                    in.bottom *= LARGE_SCALE;</span>
<span class="nc" id="L502">                    in.top *= LARGE_SCALE;</span>
<span class="nc" id="L503">                    in.left *= LARGE_SCALE;</span>
<span class="nc" id="L504">                    in.right *= LARGE_SCALE;</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                } else if (SMALL_KEY.equals(scaleKey)){</span>
<span class="nc" id="L506">                    in.bottom *= SMALL_SCALE;</span>
<span class="nc" id="L507">                    in.top *= SMALL_SCALE;</span>
<span class="nc" id="L508">                    in.left *= SMALL_SCALE;</span>
<span class="nc" id="L509">                    in.right *= SMALL_SCALE;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">                } else if (MINI_KEY.equals(scaleKey)){</span>
<span class="nc" id="L511">                    in.bottom *= MINI_SCALE;</span>
<span class="nc" id="L512">                    in.top *= MINI_SCALE;</span>
<span class="nc" id="L513">                    in.left *= MINI_SCALE;</span>
<span class="nc" id="L514">                    in.right *= MINI_SCALE;</span>
                }
            }
<span class="nc" id="L517">            return in;</span>
        }
    }

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Overridden to cause this style to populate itself with data from
     * UIDefaults, if necessary.&lt;/p&gt;
     *
     * &lt;p&gt;In addition, NimbusStyle handles ColorTypes slightly differently from
     * Synth.&lt;/p&gt;
     * &lt;ul&gt;
     *  &lt;li&gt;ColorType.BACKGROUND will equate to the color stored in UIDefaults
     *      named &quot;background&quot;.&lt;/li&gt;
     *  &lt;li&gt;ColorType.TEXT_BACKGROUND will equate to the color stored in
     *      UIDefaults named &quot;textBackground&quot;.&lt;/li&gt;
     *  &lt;li&gt;ColorType.FOREGROUND will equate to the color stored in UIDefaults
     *      named &quot;textForeground&quot;.&lt;/li&gt;
     *  &lt;li&gt;ColorType.TEXT_FOREGROUND will equate to the color stored in
     *      UIDefaults named &quot;textForeground&quot;.&lt;/li&gt;
     * &lt;/ul&gt;
     */
    @Override protected Color getColorForState(SynthContext ctx, ColorType type) {
<span class="nc" id="L541">        String key = null;</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (type == ColorType.BACKGROUND) {</span>
<span class="nc" id="L543">            key = &quot;background&quot;;</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">        } else if (type == ColorType.FOREGROUND) {</span>
            //map FOREGROUND as TEXT_FOREGROUND
<span class="nc" id="L546">            key = &quot;textForeground&quot;;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">        } else if (type == ColorType.TEXT_BACKGROUND) {</span>
<span class="nc" id="L548">            key = &quot;textBackground&quot;;</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">        } else if (type == ColorType.TEXT_FOREGROUND) {</span>
<span class="nc" id="L550">            key = &quot;textForeground&quot;;</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">        } else if (type == ColorType.FOCUS) {</span>
<span class="nc" id="L552">            key = &quot;focus&quot;;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">        } else if (type != null) {</span>
<span class="nc" id="L554">            key = type.toString();</span>
        } else {
<span class="nc" id="L556">            return DEFAULT_COLOR;</span>
        }
<span class="nc" id="L558">        Color c = (Color) get(ctx, key);</span>
        //if all else fails, return a default color (which is a ColorUIResource)
<span class="nc bnc" id="L560" title="All 2 branches missed.">        if (c == null) c = DEFAULT_COLOR;</span>
<span class="nc" id="L561">        return c;</span>
    }

    /**
     * {@inheritDoc}
     *
     * Overridden to cause this style to populate itself with data from
     * UIDefaults, if necessary. If a value named &quot;font&quot; is not found in
     * UIDefaults, then the &quot;defaultFont&quot; font in UIDefaults will be returned
     * instead.
     */
    @Override protected Font getFontForState(SynthContext ctx) {
<span class="nc" id="L573">        Font f = (Font)get(ctx, &quot;font&quot;);</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (f == null) f = UIManager.getFont(&quot;defaultFont&quot;);</span>

        // Account for scale
        // The key &quot;JComponent.sizeVariant&quot; is used to match Apple's LAF
<span class="nc" id="L578">        String scaleKey = (String)ctx.getComponent().getClientProperty(</span>
                &quot;JComponent.sizeVariant&quot;);
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (scaleKey != null){</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">            if (LARGE_KEY.equals(scaleKey)){</span>
<span class="nc" id="L582">                f = f.deriveFont(Math.round(f.getSize2D()*LARGE_SCALE));</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">            } else if (SMALL_KEY.equals(scaleKey)){</span>
<span class="nc" id="L584">                f = f.deriveFont(Math.round(f.getSize2D()*SMALL_SCALE));</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">            } else if (MINI_KEY.equals(scaleKey)){</span>
<span class="nc" id="L586">                f = f.deriveFont(Math.round(f.getSize2D()*MINI_SCALE));</span>
            }
        }
<span class="nc" id="L589">        return f;</span>
    }

    /**
     * {@inheritDoc}
     *
     * Returns the SynthPainter for this style, which ends up delegating to
     * the Painters installed in this style.
     */
    @Override public SynthPainter getPainter(SynthContext ctx) {
<span class="nc" id="L599">        return painter;</span>
    }

    /**
     * {@inheritDoc}
     *
     * Overridden to cause this style to populate itself with data from
     * UIDefaults, if necessary. If opacity is not specified in UI defaults,
     * then it defaults to being non-opaque.
     */
    @Override public boolean isOpaque(SynthContext ctx) {
        // Force Table CellRenderers to be opaque
<span class="nc bnc" id="L611" title="All 2 branches missed.">        if (&quot;Table.cellRenderer&quot;.equals(ctx.getComponent().getName())) {</span>
<span class="nc" id="L612">            return true;</span>
        }
<span class="nc" id="L614">        Boolean opaque = (Boolean)get(ctx, &quot;opaque&quot;);</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">        return opaque == null ? false : opaque;</span>
    }

    /**
     * {@inheritDoc}
     *
     * &lt;p&gt;Overridden to cause this style to populate itself with data from
     * UIDefaults, if necessary.&lt;/p&gt;
     *
     * &lt;p&gt;Properties in UIDefaults may be specified in a chained manner. For
     * example:
     * &lt;pre&gt;
     * background
     * Button.opacity
     * Button.Enabled.foreground
     * Button.Enabled+Selected.background
     * &lt;/pre&gt;
     *
     * &lt;p&gt;In this example, suppose you were in the Enabled+Selected state and
     * searched for &quot;foreground&quot;. In this case, we first check for
     * Button.Enabled+Selected.foreground, but no such color exists. We then
     * fall back to the next valid state, in this case,
     * Button.Enabled.foreground, and have a match. So we return it.&lt;/p&gt;
     *
     * &lt;p&gt;Again, if we were in the state Enabled and looked for &quot;background&quot;, we
     * wouldn't find it in Button.Enabled, or in Button, but would at the top
     * level in UIManager. So we return that value.&lt;/p&gt;
     *
     * &lt;p&gt;One special note: the &quot;key&quot; passed to this method could be of the form
     * &quot;background&quot; or &quot;Button.background&quot; where &quot;Button&quot; equals the prefix
     * passed to the NimbusStyle constructor. In either case, it looks for
     * &quot;background&quot;.&lt;/p&gt;
     *
     * @param ctx
     * @param key must not be null
     */
    @Override public Object get(SynthContext ctx, Object key) {
<span class="nc" id="L652">        Values v = getValues(ctx);</span>

        // strip off the prefix, if there is one.
<span class="nc" id="L655">        String fullKey = key.toString();</span>
<span class="nc" id="L656">        String partialKey = fullKey.substring(fullKey.indexOf(&quot;.&quot;) + 1);</span>

<span class="nc" id="L658">        Object obj = null;</span>
<span class="nc" id="L659">        int xstate = getExtendedState(ctx, v);</span>

        // check the cache
<span class="nc" id="L662">        tmpKey.init(partialKey, xstate);</span>
<span class="nc" id="L663">        obj = v.cache.get(tmpKey);</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">        boolean wasInCache = obj != null;</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">        if (!wasInCache){</span>
            // Search exact matching states and then lesser matching states
<span class="nc" id="L667">            RuntimeState s = null;</span>
<span class="nc" id="L668">            int[] lastIndex = new int[] {-1};</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">            while (obj == null &amp;&amp;</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">                    (s = getNextState(v.states, lastIndex, xstate)) != null) {</span>
<span class="nc" id="L671">                obj = s.defaults.get(partialKey);</span>
            }
            // Search Region Defaults
<span class="nc bnc" id="L674" title="All 4 branches missed.">            if (obj == null &amp;&amp; v.defaults != null) {</span>
<span class="nc" id="L675">                obj = v.defaults.get(partialKey);</span>
            }
            // return found object
            // Search UIManager Defaults
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if (obj == null) obj = UIManager.get(fullKey);</span>
            // Search Synth Defaults for InputMaps
<span class="nc bnc" id="L681" title="All 4 branches missed.">            if (obj == null &amp;&amp; partialKey.equals(&quot;focusInputMap&quot;)) {</span>
<span class="nc" id="L682">                obj = super.get(ctx, fullKey);</span>
            }
            // if all we got was a null, store this fact for later use
<span class="nc bnc" id="L685" title="All 2 branches missed.">            v.cache.put(new CacheKey(partialKey, xstate),</span>
                    obj == null ? NULL : obj);
        }
        // return found object
<span class="nc bnc" id="L689" title="All 2 branches missed.">        return obj == NULL ? null : obj;</span>
    }

    /**
     * Gets the appropriate background Painter, if there is one, for the state
     * specified in the given SynthContext. This method does appropriate
     * fallback searching, as described in #get.
     *
     * @param ctx The SynthContext. Must not be null.
     * @return The background painter associated for the given state, or null if
     * none could be found.
     */
    public Painter getBackgroundPainter(SynthContext ctx) {
<span class="nc" id="L702">        Values v = getValues(ctx);</span>
<span class="nc" id="L703">        int xstate = getExtendedState(ctx, v);</span>
<span class="nc" id="L704">        Painter p = null;</span>

        // check the cache
<span class="nc" id="L707">        tmpKey.init(&quot;backgroundPainter$$instance&quot;, xstate);</span>
<span class="nc" id="L708">        p = (Painter)v.cache.get(tmpKey);</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (p != null) return p;</span>

        // not in cache, so lookup and store in cache
<span class="nc" id="L712">        RuntimeState s = null;</span>
<span class="nc" id="L713">        int[] lastIndex = new int[] {-1};</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        while ((s = getNextState(v.states, lastIndex, xstate)) != null) {</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">            if (s.backgroundPainter != null) {</span>
<span class="nc" id="L716">                p = s.backgroundPainter;</span>
<span class="nc" id="L717">                break;</span>
            }
        }
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (p == null) p = (Painter)get(ctx, &quot;backgroundPainter&quot;);</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">        if (p != null) {</span>
<span class="nc" id="L722">            v.cache.put(new CacheKey(&quot;backgroundPainter$$instance&quot;, xstate), p);</span>
        }
<span class="nc" id="L724">        return p;</span>
    }

    /**
     * Gets the appropriate foreground Painter, if there is one, for the state
     * specified in the given SynthContext. This method does appropriate
     * fallback searching, as described in #get.
     *
     * @param ctx The SynthContext. Must not be null.
     * @return The foreground painter associated for the given state, or null if
     * none could be found.
     */
    public Painter getForegroundPainter(SynthContext ctx) {
<span class="nc" id="L737">        Values v = getValues(ctx);</span>
<span class="nc" id="L738">        int xstate = getExtendedState(ctx, v);</span>
<span class="nc" id="L739">        Painter p = null;</span>

        // check the cache
<span class="nc" id="L742">        tmpKey.init(&quot;foregroundPainter$$instance&quot;, xstate);</span>
<span class="nc" id="L743">        p = (Painter)v.cache.get(tmpKey);</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (p != null) return p;</span>

        // not in cache, so lookup and store in cache
<span class="nc" id="L747">        RuntimeState s = null;</span>
<span class="nc" id="L748">        int[] lastIndex = new int[] {-1};</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">        while ((s = getNextState(v.states, lastIndex, xstate)) != null) {</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">            if (s.foregroundPainter != null) {</span>
<span class="nc" id="L751">                p = s.foregroundPainter;</span>
<span class="nc" id="L752">                break;</span>
            }
        }
<span class="nc bnc" id="L755" title="All 2 branches missed.">        if (p == null) p = (Painter)get(ctx, &quot;foregroundPainter&quot;);</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if (p != null) {</span>
<span class="nc" id="L757">            v.cache.put(new CacheKey(&quot;foregroundPainter$$instance&quot;, xstate), p);</span>
        }
<span class="nc" id="L759">        return p;</span>
    }

    /**
     * Gets the appropriate border Painter, if there is one, for the state
     * specified in the given SynthContext. This method does appropriate
     * fallback searching, as described in #get.
     *
     * @param ctx The SynthContext. Must not be null.
     * @return The border painter associated for the given state, or null if
     * none could be found.
     */
    public Painter getBorderPainter(SynthContext ctx) {
<span class="nc" id="L772">        Values v = getValues(ctx);</span>
<span class="nc" id="L773">        int xstate = getExtendedState(ctx, v);</span>
<span class="nc" id="L774">        Painter p = null;</span>

        // check the cache
<span class="nc" id="L777">        tmpKey.init(&quot;borderPainter$$instance&quot;, xstate);</span>
<span class="nc" id="L778">        p = (Painter)v.cache.get(tmpKey);</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (p != null) return p;</span>

        // not in cache, so lookup and store in cache
<span class="nc" id="L782">        RuntimeState s = null;</span>
<span class="nc" id="L783">        int[] lastIndex = new int[] {-1};</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">        while ((s = getNextState(v.states, lastIndex, xstate)) != null) {</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">            if (s.borderPainter != null) {</span>
<span class="nc" id="L786">                p = s.borderPainter;</span>
<span class="nc" id="L787">                break;</span>
            }
        }
<span class="nc bnc" id="L790" title="All 2 branches missed.">        if (p == null) p = (Painter)get(ctx, &quot;borderPainter&quot;);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">        if (p != null) {</span>
<span class="nc" id="L792">            v.cache.put(new CacheKey(&quot;borderPainter$$instance&quot;, xstate), p);</span>
        }
<span class="nc" id="L794">        return p;</span>
    }

    /**
     * Utility method which returns the proper Values based on the given
     * SynthContext. Ensures that parsing of the values has occurred, or
     * reoccurs as necessary.
     *
     * @param ctx The SynthContext
     * @return a non-null values reference
     */
    private Values getValues(SynthContext ctx) {
<span class="nc" id="L806">        validate();</span>
<span class="nc" id="L807">        return values;</span>
    }

    /**
     * Simple utility method that searches the given array of Strings for the
     * given string. This method is only called from getExtendedState if
     * the developer has specified a specific state for the component to be
     * in (ie, has &quot;wedged&quot; the component in that state) by specifying
     * they client property &quot;Nimbus.State&quot;.
     *
     * @param names a non-null array of strings
     * @param name the name to look for in the array
     * @return true or false based on whether the given name is in the array
     */
    private boolean contains(String[] names, String name) {
<span class="nc bnc" id="L822" title="All 4 branches missed.">        assert name != null;</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">        for (int i=0; i&lt;names.length; i++) {</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">            if (name.equals(names[i])) {</span>
<span class="nc" id="L825">                return true;</span>
            }
        }
<span class="nc" id="L828">        return false;</span>
    }

    /**
     * &lt;p&gt;Gets the extended state for a given synth context. Nimbus supports the
     * ability to define custom states. The algorithm used for choosing what
     * style information to use for a given state requires a single integer
     * bit string where each bit in the integer represents a different state
     * that the component is in. This method uses the componentState as
     * reported in the SynthContext, in addition to custom states, to determine
     * what this extended state is.&lt;/p&gt;
     *
     * &lt;p&gt;In addition, this method checks the component in the given context
     * for a client property called &quot;Nimbus.State&quot;. If one exists, then it will
     * decompose the String associated with that property to determine what
     * state to return. In this way, the developer can force a component to be
     * in a specific state, regardless of what the &quot;real&quot; state of the component
     * is.&lt;/p&gt;
     *
     * &lt;p&gt;The string associated with &quot;Nimbus.State&quot; would be of the form:
     * &lt;pre&gt;Enabled+CustomState+MouseOver&lt;/pre&gt;&lt;/p&gt;
     *
     * @param ctx
     * @param v
     * @return
     */
    private int getExtendedState(SynthContext ctx, Values v) {
<span class="nc" id="L855">        JComponent c = ctx.getComponent();</span>
<span class="nc" id="L856">        int xstate = 0;</span>
<span class="nc" id="L857">        int mask = 1;</span>
        //check for the Nimbus.State client property
        //Performance NOTE: getClientProperty ends up inside a synchronized
        //block, so there is some potential for performance issues here, however
        //I'm not certain that there is one on a modern VM.
<span class="nc" id="L862">        Object property = c.getClientProperty(&quot;Nimbus.State&quot;);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (property != null) {</span>
<span class="nc" id="L864">            String stateNames = property.toString();</span>
<span class="nc" id="L865">            String[] states = stateNames.split(&quot;\\+&quot;);</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">            if (v.stateTypes == null){</span>
                // standard states only
<span class="nc bnc" id="L868" title="All 2 branches missed.">                for (String stateStr : states) {</span>
<span class="nc" id="L869">                    State.StandardState s = State.getStandardState(stateStr);</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">                    if (s != null) xstate |= s.getState();</span>
                }
            } else {
                // custom states
<span class="nc bnc" id="L874" title="All 2 branches missed.">                for (State s : v.stateTypes) {</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                    if (contains(states, s.getName())) {</span>
<span class="nc" id="L876">                        xstate |= mask;</span>
                    }
<span class="nc" id="L878">                    mask &lt;&lt;= 1;</span>
                }
            }
<span class="nc" id="L881">        } else {</span>
            //if there are no custom states defined, then simply return the
            //state that Synth reported
<span class="nc bnc" id="L884" title="All 2 branches missed.">            if (v.stateTypes == null) return ctx.getComponentState();</span>

            //there are custom states on this values, so I'll have to iterate
            //over them all and return a custom extended state
<span class="nc" id="L888">            int state = ctx.getComponentState();</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">            for (State s : v.stateTypes) {</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">                if (s.isInState(c, state)) {</span>
<span class="nc" id="L891">                    xstate |= mask;</span>
                }
<span class="nc" id="L893">                mask &lt;&lt;= 1;</span>
            }
        }
<span class="nc" id="L896">        return xstate;</span>
    }

    /**
     * &lt;p&gt;Gets the RuntimeState that most closely matches the state in the given
     * context, but is less specific than the given &quot;lastState&quot;. Essentially,
     * this allows you to search for the next best state.&lt;/p&gt;
     *
     * &lt;p&gt;For example, if you had the following three states:
     * &lt;pre&gt;
     * Enabled
     * Enabled+Pressed
     * Disabled
     * &lt;/pre&gt;
     * And you wanted to find the state that best represented
     * ENABLED+PRESSED+FOCUSED and &lt;code&gt;lastState&lt;/code&gt; was null (or an
     * empty array, or an array with a single int with index == -1), then
     * Enabled+Pressed would be returned. If you then call this method again but
     * pass the index of Enabled+Pressed as the &quot;lastState&quot;, then
     * Enabled would be returned. If you call this method a third time and pass
     * the index of Enabled in as the &lt;code&gt;lastState&lt;/code&gt;, then null would be
     * returned.&lt;/p&gt;
     *
     * &lt;p&gt;The actual code path for determining the proper state is the same as
     * in Synth.&lt;/p&gt;
     *
     * @param ctx
     * @param lastState a 1 element array, allowing me to do pass-by-reference.
     * @return
     */
    private RuntimeState getNextState(RuntimeState[] states,
                                      int[] lastState,
                                      int xstate) {
        // Use the StateInfo with the most bits that matches that of state.
        // If there are none, then fallback to
        // the StateInfo with a state of 0, indicating it'll match anything.

        // Consider if we have 3 StateInfos a, b and c with states:
        // SELECTED, SELECTED | ENABLED, 0
        //
        // Input                          Return Value
        // -----                          ------------
        // SELECTED                       a
        // SELECTED | ENABLED             b
        // MOUSE_OVER                     c
        // SELECTED | ENABLED | FOCUSED   b
        // ENABLED                        c

<span class="nc bnc" id="L944" title="All 4 branches missed.">        if (states != null &amp;&amp; states.length &gt; 0) {</span>
<span class="nc" id="L945">            int bestCount = 0;</span>
<span class="nc" id="L946">            int bestIndex = -1;</span>
<span class="nc" id="L947">            int wildIndex = -1;</span>

            //if xstate is 0, then search for the runtime state with component
            //state of 0. That is, find the exact match and return it.
<span class="nc bnc" id="L951" title="All 2 branches missed.">            if (xstate == 0) {</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">                for (int counter = states.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">                    if (states[counter].state == 0) {</span>
<span class="nc" id="L954">                        lastState[0] = counter;</span>
<span class="nc" id="L955">                        return states[counter];</span>
                    }
                }
                //an exact match couldn't be found, so there was no match.
<span class="nc" id="L959">                lastState[0] = -1;</span>
<span class="nc" id="L960">                return null;</span>
            }

            //xstate is some value != 0

            //determine from which index to start looking. If lastState[0] is -1
            //then we know to start from the end of the state array. Otherwise,
            //we start at the lastIndex - 1.
<span class="nc bnc" id="L968" title="All 4 branches missed.">            int lastStateIndex = lastState == null || lastState[0] == -1 ?</span>
                states.length : lastState[0];

<span class="nc bnc" id="L971" title="All 2 branches missed.">            for (int counter = lastStateIndex - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L972">                int oState = states[counter].state;</span>

<span class="nc bnc" id="L974" title="All 2 branches missed.">                if (oState == 0) {</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">                    if (wildIndex == -1) {</span>
<span class="nc" id="L976">                        wildIndex = counter;</span>
                    }
<span class="nc bnc" id="L978" title="All 2 branches missed.">                } else if ((xstate &amp; oState) == oState) {</span>
                    // This is key, we need to make sure all bits of the
                    // StateInfo match, otherwise a StateInfo with
                    // SELECTED | ENABLED would match ENABLED, which we
                    // don't want.

                    // This comes from BigInteger.bitCnt
<span class="nc" id="L985">                    int bitCount = oState;</span>
<span class="nc" id="L986">                    bitCount -= (0xaaaaaaaa &amp; bitCount) &gt;&gt;&gt; 1;</span>
<span class="nc" id="L987">                    bitCount = (bitCount &amp; 0x33333333) + ((bitCount &gt;&gt;&gt; 2) &amp;</span>
                            0x33333333);
<span class="nc" id="L989">                    bitCount = bitCount + (bitCount &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f;</span>
<span class="nc" id="L990">                    bitCount += bitCount &gt;&gt;&gt; 8;</span>
<span class="nc" id="L991">                    bitCount += bitCount &gt;&gt;&gt; 16;</span>
<span class="nc" id="L992">                    bitCount = bitCount &amp; 0xff;</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">                    if (bitCount &gt; bestCount) {</span>
<span class="nc" id="L994">                        bestIndex = counter;</span>
<span class="nc" id="L995">                        bestCount = bitCount;</span>
                    }
                }
            }
<span class="nc bnc" id="L999" title="All 2 branches missed.">            if (bestIndex != -1) {</span>
<span class="nc" id="L1000">                lastState[0] = bestIndex;</span>
<span class="nc" id="L1001">                return states[bestIndex];</span>
            }
<span class="nc bnc" id="L1003" title="All 2 branches missed.">            if (wildIndex != -1) {</span>
<span class="nc" id="L1004">                lastState[0] = wildIndex;</span>
<span class="nc" id="L1005">                return states[wildIndex];</span>
            }
        }
<span class="nc" id="L1008">        lastState[0] = -1;</span>
<span class="nc" id="L1009">        return null;</span>
    }

    /**
     * Contains values such as the UIDefaults and painters associated with
     * a state. Whereas &lt;code&gt;State&lt;/code&gt; represents a distinct state that a
     * component can be in (such as Enabled), this class represents the colors,
     * fonts, painters, etc associated with some state for this
     * style.
     */
    private final class RuntimeState implements Cloneable {
        int state;
        Painter backgroundPainter;
        Painter foregroundPainter;
        Painter borderPainter;
        String stateName;
<span class="nc" id="L1025">        UIDefaults defaults = new UIDefaults(10, .7f);</span>

<span class="nc" id="L1027">        private RuntimeState(int state, String stateName) {</span>
<span class="nc" id="L1028">            this.state = state;</span>
<span class="nc" id="L1029">            this.stateName = stateName;</span>
<span class="nc" id="L1030">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L1034">            return stateName;</span>
        }

        @Override
        public RuntimeState clone() {
<span class="nc" id="L1039">            RuntimeState clone = new RuntimeState(state, stateName);</span>
<span class="nc" id="L1040">            clone.backgroundPainter = backgroundPainter;</span>
<span class="nc" id="L1041">            clone.foregroundPainter = foregroundPainter;</span>
<span class="nc" id="L1042">            clone.borderPainter = borderPainter;</span>
<span class="nc" id="L1043">            clone.defaults.putAll(defaults);</span>
<span class="nc" id="L1044">            return clone;</span>
        }
    }

    /**
     * Essentially a struct of data for a style. A default instance of this
     * class is used by NimbusStyle. Additional instances exist for each
     * component that has overrides.
     */
<span class="nc" id="L1053">    private static final class Values {</span>
        /**
         * The list of State types. A State represents a type of state, such
         * as Enabled, Default, WindowFocused, etc. These can be custom states.
         */
<span class="nc" id="L1058">        State[] stateTypes = null;</span>
        /**
         * The list of actual runtime state representations. These can represent things such
         * as Enabled + Focused. Thus, they differ from States in that they contain
         * several states together, and have associated properties, data, etc.
         */
<span class="nc" id="L1064">        RuntimeState[] states = null;</span>
        /**
         * The content margins for this region.
         */
        Insets contentMargins;
        /**
         * Defaults on the region/component level.
         */
<span class="nc" id="L1072">        UIDefaults defaults = new UIDefaults(10, .7f);</span>
        /**
         * Simple cache. After a value has been looked up, it is stored
         * in this cache for later retrieval. The key is a concatenation of
         * the property being looked up, two dollar signs, and the extended
         * state. So for example:
         *
         * foo.bar$$2353
         */
<span class="nc" id="L1081">        Map&lt;CacheKey,Object&gt; cache = new HashMap&lt;CacheKey,Object&gt;();</span>
    }

    /**
     * This implementation presupposes that key is never null and that
     * the two keys being checked for equality are never null
     */
    private static final class CacheKey {
        private String key;
        private int xstate;

<span class="nc" id="L1092">        CacheKey(Object key, int xstate) {</span>
<span class="nc" id="L1093">            init(key, xstate);</span>
<span class="nc" id="L1094">        }</span>

        void init(Object key, int xstate) {
<span class="nc" id="L1097">            this.key = key.toString();</span>
<span class="nc" id="L1098">            this.xstate = xstate;</span>
<span class="nc" id="L1099">        }</span>

        @Override
        public boolean equals(Object obj) {
<span class="nc" id="L1103">            final CacheKey other = (CacheKey) obj;</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">            if (obj == null) return false;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">            if (this.xstate != other.xstate) return false;</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            if (!this.key.equals(other.key)) return false;</span>
<span class="nc" id="L1107">            return true;</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L1112">            int hash = 3;</span>
<span class="nc" id="L1113">            hash = 29 * hash + this.key.hashCode();</span>
<span class="nc" id="L1114">            hash = 29 * hash + this.xstate;</span>
<span class="nc" id="L1115">            return hash;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>