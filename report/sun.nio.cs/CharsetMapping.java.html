<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CharsetMapping.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.nio.cs</a> &gt; <span class="el_source">CharsetMapping.java</span></div><h1>CharsetMapping.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.cs;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.security.*;

<span class="fc" id="L38">public class CharsetMapping {</span>
    public final static char UNMAPPABLE_DECODING = '\uFFFD';
    public final static int  UNMAPPABLE_ENCODING = 0xFFFD;

    char[] b2cSB;                //singlebyte b-&gt;c
    char[] b2cDB1;               //dobulebyte b-&gt;c /db1
    char[] b2cDB2;               //dobulebyte b-&gt;c /db2

    int    b2Min, b2Max;         //min/max(start/end) value of 2nd byte
    int    b1MinDB1, b1MaxDB1;   //min/Max(start/end) value of 1st byte/db1
    int    b1MinDB2, b1MaxDB2;   //min/Max(start/end) value of 1st byte/db2
    int    dbSegSize;

    char[] c2b;
    char[] c2bIndex;

    // Supplementary
    char[] b2cSupp;
    char[] c2bSupp;

    // Composite
    Entry[] b2cComp;
    Entry[] c2bComp;

    public char decodeSingle(int b) {
<span class="nc" id="L63">        return b2cSB[b];</span>
    }

    public char decodeDouble(int b1, int b2) {
<span class="nc bnc" id="L67" title="All 4 branches missed.">        if (b2 &gt;= b2Min &amp;&amp; b2 &lt; b2Max) {</span>
<span class="nc" id="L68">            b2 -= b2Min;</span>
<span class="nc bnc" id="L69" title="All 4 branches missed.">            if (b1 &gt;= b1MinDB1 &amp;&amp; b1 &lt;= b1MaxDB1) {</span>
<span class="nc" id="L70">                b1 -= b1MinDB1;</span>
<span class="nc" id="L71">                return b2cDB1[b1 * dbSegSize + b2];</span>
            }
<span class="nc bnc" id="L73" title="All 4 branches missed.">            if (b1 &gt;= b1MinDB2 &amp;&amp; b1 &lt;= b1MaxDB2) {</span>
<span class="nc" id="L74">                b1 -= b1MinDB2;</span>
<span class="nc" id="L75">                return b2cDB2[b1 * dbSegSize + b2];</span>
            }
        }
<span class="nc" id="L78">        return UNMAPPABLE_DECODING;</span>
    }

    // for jis0213 all supplementary characters are in 0x2xxxx range,
    // so only the xxxx part is now stored, should actually store the
    // codepoint value instead.
    public char[] decodeSurrogate(int db, char[] cc) {
<span class="nc" id="L85">        int end = b2cSupp.length / 2;</span>
<span class="nc" id="L86">        int i = Arrays.binarySearch(b2cSupp, 0, end, (char)db);</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">        if (i &gt;= 0) {</span>
<span class="nc" id="L88">            Character.toChars(b2cSupp[end + i] + 0x20000, cc, 0);</span>
<span class="nc" id="L89">            return cc;</span>
        }
<span class="nc" id="L91">        return null;</span>
    }

    public char[] decodeComposite(Entry comp, char[] cc) {
<span class="nc" id="L95">        int i = findBytes(b2cComp, comp);</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">        if (i &gt;= 0) {</span>
<span class="nc" id="L97">            cc[0] = (char)b2cComp[i].cp;</span>
<span class="nc" id="L98">            cc[1] = (char)b2cComp[i].cp2;</span>
<span class="nc" id="L99">            return cc;</span>
        }
<span class="nc" id="L101">        return null;</span>
    }

    public int encodeChar(char ch) {
<span class="nc" id="L105">        int index = c2bIndex[ch &gt;&gt; 8];</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (index == 0xffff)</span>
<span class="nc" id="L107">            return UNMAPPABLE_ENCODING;</span>
<span class="nc" id="L108">        return c2b[index + (ch &amp; 0xff)];</span>
    }

    public int encodeSurrogate(char hi, char lo) {
<span class="nc" id="L112">        int cp = Character.toCodePoint(hi, lo);</span>
<span class="nc bnc" id="L113" title="All 4 branches missed.">        if (cp &lt; 0x20000 || cp &gt;= 0x30000)</span>
<span class="nc" id="L114">            return UNMAPPABLE_ENCODING;</span>
<span class="nc" id="L115">        int end = c2bSupp.length / 2;</span>
<span class="nc" id="L116">        int i = Arrays.binarySearch(c2bSupp, 0, end, (char)cp);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (i &gt;= 0)</span>
<span class="nc" id="L118">            return c2bSupp[end + i];</span>
<span class="nc" id="L119">        return UNMAPPABLE_ENCODING;</span>
    }

    public boolean isCompositeBase(Entry comp) {
<span class="nc bnc" id="L123" title="All 4 branches missed.">        if (comp.cp &lt;= 0x31f7 &amp;&amp; comp.cp &gt;= 0xe6) {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">            return (findCP(c2bComp, comp) &gt;= 0);</span>
        }
<span class="nc" id="L126">        return false;</span>
    }

    public int encodeComposite(Entry comp) {
<span class="nc" id="L130">        int i = findComp(c2bComp, comp);</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (i &gt;= 0)</span>
<span class="nc" id="L132">            return c2bComp[i].bs;</span>
<span class="nc" id="L133">        return UNMAPPABLE_ENCODING;</span>
    }

    // init the CharsetMapping object from the .dat binary file
    public static CharsetMapping get(final InputStream is) {
<span class="pc" id="L138">        return AccessController.doPrivileged(new PrivilegedAction&lt;CharsetMapping&gt;() {</span>
            public CharsetMapping run() {
<span class="nc" id="L140">                return new CharsetMapping().load(is);</span>
            }
        });
    }

<span class="nc" id="L145">    public static class Entry {</span>
        public int bs;   //byte sequence reps
        public int cp;   //Unicode codepoint
        public int cp2;  //CC of composite
    }

<span class="fc" id="L151">    static Comparator&lt;Entry&gt; comparatorBytes =</span>
<span class="fc" id="L152">        new Comparator&lt;Entry&gt;() {</span>
            public int compare(Entry m1, Entry m2) {
<span class="nc" id="L154">                return m1.bs - m2.bs;</span>
            }
            public boolean equals(Object obj) {
<span class="nc bnc" id="L157" title="All 2 branches missed.">                return this == obj;</span>
            }
    };

<span class="fc" id="L161">    static Comparator&lt;Entry&gt; comparatorCP =</span>
<span class="fc" id="L162">        new Comparator&lt;Entry&gt;() {</span>
            public int compare(Entry m1, Entry m2) {
<span class="nc" id="L164">                return m1.cp - m2.cp;</span>
            }
            public boolean equals(Object obj) {
<span class="nc bnc" id="L167" title="All 2 branches missed.">                return this == obj;</span>
            }
    };

<span class="fc" id="L171">    static Comparator&lt;Entry&gt; comparatorComp =</span>
<span class="fc" id="L172">        new Comparator&lt;Entry&gt;() {</span>
            public int compare(Entry m1, Entry m2) {
<span class="nc" id="L174">                 int v = m1.cp - m2.cp;</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                 if (v == 0)</span>
<span class="nc" id="L176">                   v = m1.cp2 - m2.cp2;</span>
<span class="nc" id="L177">                 return v;</span>
            }
            public boolean equals(Object obj) {
<span class="nc bnc" id="L180" title="All 2 branches missed.">                return this == obj;</span>
            }
    };

    static int findBytes(Entry[] a, Entry k) {
<span class="nc" id="L185">        return Arrays.binarySearch(a, 0, a.length, k, comparatorBytes);</span>
    }

    static int findCP(Entry[] a, Entry k) {
<span class="nc" id="L189">        return Arrays.binarySearch(a, 0, a.length, k, comparatorCP);</span>
    }

    static int findComp(Entry[] a, Entry k) {
<span class="nc" id="L193">        return Arrays.binarySearch(a, 0, a.length, k, comparatorComp);</span>
    }

    /*****************************************************************************/
    // tags of different charset mapping tables
    private final static int MAP_SINGLEBYTE      = 0x1; // 0..256  : c
    private final static int MAP_DOUBLEBYTE1     = 0x2; // min..max: c
    private final static int MAP_DOUBLEBYTE2     = 0x3; // min..max: c [DB2]
    private final static int MAP_SUPPLEMENT      = 0x5; //           db,c
    private final static int MAP_SUPPLEMENT_C2B  = 0x6; //           c,db
    private final static int MAP_COMPOSITE       = 0x7; //           db,base,cc
    private final static int MAP_INDEXC2B        = 0x8; // index table of c-&gt;bb

    private static final boolean readNBytes(InputStream in, byte[] bb, int N)
        throws IOException
    {
<span class="nc" id="L209">        int off = 0;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        while (N &gt; 0) {</span>
<span class="nc" id="L211">            int n = in.read(bb, off, N);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">            if (n == -1)</span>
<span class="nc" id="L213">                return false;</span>
<span class="nc" id="L214">            N = N - n;</span>
<span class="nc" id="L215">            off += n;</span>
<span class="nc" id="L216">        }</span>
<span class="nc" id="L217">        return true;</span>
    }

<span class="fc" id="L220">    int off = 0;</span>
    byte[] bb;
    private char[] readCharArray() {
        // first 2 bytes are the number of &quot;chars&quot; stored in this table
<span class="nc" id="L224">        int size  = ((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff);</span>
<span class="nc" id="L225">        char [] cc = new char[size];</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L227">            cc[i] = (char)(((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff));</span>
        }
<span class="nc" id="L229">        return cc;</span>
    }

    void readSINGLEBYTE() {
<span class="nc" id="L233">        char[] map = readCharArray();</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        for (int i = 0; i &lt; map.length; i++) {</span>
<span class="nc" id="L235">            char c = map[i];</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            if (c != UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L237">                c2b[c2bIndex[c &gt;&gt; 8] + (c&amp;0xff)] = (char)i;</span>
            }
        }
<span class="nc" id="L240">        b2cSB = map;</span>
<span class="nc" id="L241">    }</span>

    void readINDEXC2B() {
<span class="nc" id="L244">        char[] map = readCharArray();</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        for (int i = map.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L246" title="All 4 branches missed.">            if (c2b == null &amp;&amp; map[i] != -1) {</span>
<span class="nc" id="L247">                c2b = new char[map[i] + 256];</span>
<span class="nc" id="L248">                Arrays.fill(c2b, (char)UNMAPPABLE_ENCODING);</span>
<span class="nc" id="L249">                break;</span>
            }
        }
<span class="nc" id="L252">        c2bIndex = map;</span>
<span class="nc" id="L253">    }</span>

    char[] readDB(int b1Min, int b2Min, int segSize) {
<span class="nc" id="L256">        char[] map = readCharArray();</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">        for (int i = 0; i &lt; map.length; i++) {</span>
<span class="nc" id="L258">            char c = map[i];</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (c != UNMAPPABLE_DECODING) {</span>
<span class="nc" id="L260">                int b1 = i / segSize;</span>
<span class="nc" id="L261">                int b2 = i % segSize;</span>
<span class="nc" id="L262">                int b = (b1 + b1Min)* 256 + (b2 + b2Min);</span>
                //System.out.printf(&quot;    DB %x\t%x%n&quot;, b, c &amp; 0xffff);
<span class="nc" id="L264">                c2b[c2bIndex[c &gt;&gt; 8] + (c&amp;0xff)] = (char)(b);</span>
            }
        }
<span class="nc" id="L267">        return map;</span>
    }

    void readDOUBLEBYTE1() {
<span class="nc" id="L271">        b1MinDB1 = ((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff);</span>
<span class="nc" id="L272">        b1MaxDB1 = ((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff);</span>
<span class="nc" id="L273">        b2Min =    ((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff);</span>
<span class="nc" id="L274">        b2Max =    ((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff);</span>
<span class="nc" id="L275">        dbSegSize = b2Max - b2Min + 1;</span>
<span class="nc" id="L276">        b2cDB1 = readDB(b1MinDB1, b2Min, dbSegSize);</span>
<span class="nc" id="L277">    }</span>

    void readDOUBLEBYTE2() {
<span class="nc" id="L280">        b1MinDB2 = ((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff);</span>
<span class="nc" id="L281">        b1MaxDB2 = ((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff);</span>
<span class="nc" id="L282">        b2Min =    ((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff);</span>
<span class="nc" id="L283">        b2Max =    ((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff);</span>
<span class="nc" id="L284">        dbSegSize = b2Max - b2Min + 1;</span>
<span class="nc" id="L285">        b2cDB2 = readDB(b1MinDB2, b2Min, dbSegSize);</span>
<span class="nc" id="L286">    }</span>

    void readCOMPOSITE() {
<span class="nc" id="L289">        char[] map = readCharArray();</span>
<span class="nc" id="L290">        int mLen = map.length/3;</span>
<span class="nc" id="L291">        b2cComp = new Entry[mLen];</span>
<span class="nc" id="L292">        c2bComp = new Entry[mLen];</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        for (int i = 0, j= 0; i &lt; mLen; i++) {</span>
<span class="nc" id="L294">            Entry m = new Entry();</span>
<span class="nc" id="L295">            m.bs = map[j++];</span>
<span class="nc" id="L296">            m.cp = map[j++];</span>
<span class="nc" id="L297">            m.cp2 = map[j++];</span>
<span class="nc" id="L298">            b2cComp[i] = m;</span>
<span class="nc" id="L299">            c2bComp[i] = m;</span>
        }
<span class="nc" id="L301">        Arrays.sort(c2bComp, 0, c2bComp.length, comparatorComp);</span>
<span class="nc" id="L302">    }</span>

    CharsetMapping load(InputStream in) {
        try {
            // The first 4 bytes are the size of the total data followed in
            // this .dat file.
<span class="nc" id="L308">            int len = ((in.read()&amp;0xff) &lt;&lt; 24) | ((in.read()&amp;0xff) &lt;&lt; 16) |</span>
<span class="nc" id="L309">                      ((in.read()&amp;0xff) &lt;&lt; 8) | (in.read()&amp;0xff);</span>
<span class="nc" id="L310">            bb = new byte[len];</span>
<span class="nc" id="L311">            off = 0;</span>
            //System.out.printf(&quot;In : Total=%d%n&quot;, len);
            // Read in all bytes
<span class="nc bnc" id="L314" title="All 2 branches missed.">            if (!readNBytes(in, bb, len))</span>
<span class="nc" id="L315">                throw new RuntimeException(&quot;Corrupted data file&quot;);</span>
<span class="nc" id="L316">            in.close();</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">            while (off &lt; len) {</span>
<span class="nc" id="L319">                int type = ((bb[off++]&amp;0xff)&lt;&lt;8) | (bb[off++]&amp;0xff);</span>
<span class="nc bnc" id="L320" title="All 8 branches missed.">                switch(type) {</span>
                case MAP_INDEXC2B:
<span class="nc" id="L322">                    readINDEXC2B();</span>
<span class="nc" id="L323">                    break;</span>
                case MAP_SINGLEBYTE:
<span class="nc" id="L325">                    readSINGLEBYTE();</span>
<span class="nc" id="L326">                    break;</span>
                case MAP_DOUBLEBYTE1:
<span class="nc" id="L328">                    readDOUBLEBYTE1();</span>
<span class="nc" id="L329">                    break;</span>
                case MAP_DOUBLEBYTE2:
<span class="nc" id="L331">                    readDOUBLEBYTE2();</span>
<span class="nc" id="L332">                    break;</span>
                case MAP_SUPPLEMENT:
<span class="nc" id="L334">                    b2cSupp = readCharArray();</span>
<span class="nc" id="L335">                    break;</span>
                case MAP_SUPPLEMENT_C2B:
<span class="nc" id="L337">                    c2bSupp = readCharArray();</span>
<span class="nc" id="L338">                    break;</span>
                case MAP_COMPOSITE:
<span class="nc" id="L340">                    readCOMPOSITE();</span>
<span class="nc" id="L341">                    break;</span>
                default:
<span class="nc" id="L343">                    throw new RuntimeException(&quot;Corrupted data file&quot;);</span>
                }
<span class="nc" id="L345">            }</span>
<span class="nc" id="L346">            bb = null;</span>
<span class="nc" id="L347">            return this;</span>
<span class="nc" id="L348">        } catch (IOException x) {</span>
<span class="nc" id="L349">            x.printStackTrace();</span>
<span class="nc" id="L350">            return null;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>