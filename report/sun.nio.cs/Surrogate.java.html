<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Surrogate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">sun.nio.cs</a> &gt; <span class="el_source">Surrogate.java</span></div><h1>Surrogate.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package sun.nio.cs;

import java.nio.CharBuffer;
import java.nio.charset.CoderResult;
import java.nio.charset.MalformedInputException;
import java.nio.charset.UnmappableCharacterException;

/**
 * Utility class for dealing with surrogates.
 *
 * @author Mark Reinhold
 * @author Martin Buchholz
 * @author Ulf Zibis
 */
<span class="pc bpc" id="L40" title="1 of 2 branches missed.">public class Surrogate {</span>

<span class="nc" id="L42">    private Surrogate() { }</span>

    // TODO: Deprecate/remove the following redundant definitions
    public static final char MIN_HIGH = Character.MIN_HIGH_SURROGATE;
    public static final char MAX_HIGH = Character.MAX_HIGH_SURROGATE;
    public static final char MIN_LOW  = Character.MIN_LOW_SURROGATE;
    public static final char MAX_LOW  = Character.MAX_LOW_SURROGATE;
    public static final char MIN      = Character.MIN_SURROGATE;
    public static final char MAX      = Character.MAX_SURROGATE;
    public static final int UCS4_MIN  = Character.MIN_SUPPLEMENTARY_CODE_POINT;
    public static final int UCS4_MAX  = Character.MAX_CODE_POINT;

    /**
     * Tells whether or not the given value is in the high surrogate range.
     * Use of {@link Character#isHighSurrogate} is generally preferred.
     */
    public static boolean isHigh(int c) {
<span class="nc bnc" id="L59" title="All 4 branches missed.">        return (MIN_HIGH &lt;= c) &amp;&amp; (c &lt;= MAX_HIGH);</span>
    }

    /**
     * Tells whether or not the given value is in the low surrogate range.
     * Use of {@link Character#isLowSurrogate} is generally preferred.
     */
    public static boolean isLow(int c) {
<span class="nc bnc" id="L67" title="All 4 branches missed.">        return (MIN_LOW &lt;= c) &amp;&amp; (c &lt;= MAX_LOW);</span>
    }

    /**
     * Tells whether or not the given value is in the surrogate range.
     * Use of {@link Character#isSurrogate} is generally preferred.
     */
    public static boolean is(int c) {
<span class="fc bfc" id="L75" title="All 4 branches covered.">        return (MIN &lt;= c) &amp;&amp; (c &lt;= MAX);</span>
    }

    /**
     * Tells whether or not the given UCS-4 character must be represented as a
     * surrogate pair in UTF-16.
     * Use of {@link Character#isSupplementaryCodePoint} is generally preferred.
     */
    public static boolean neededFor(int uc) {
<span class="nc" id="L84">        return Character.isSupplementaryCodePoint(uc);</span>
    }

    /**
     * Returns the high UTF-16 surrogate for the given supplementary UCS-4 character.
     * Use of {@link Character#highSurrogate} is generally preferred.
     */
    public static char high(int uc) {
<span class="nc bnc" id="L92" title="All 4 branches missed.">        assert Character.isSupplementaryCodePoint(uc);</span>
<span class="nc" id="L93">        return Character.highSurrogate(uc);</span>
    }

    /**
     * Returns the low UTF-16 surrogate for the given supplementary UCS-4 character.
     * Use of {@link Character#lowSurrogate} is generally preferred.
     */
    public static char low(int uc) {
<span class="nc bnc" id="L101" title="All 4 branches missed.">        assert Character.isSupplementaryCodePoint(uc);</span>
<span class="nc" id="L102">        return Character.lowSurrogate(uc);</span>
    }

    /**
     * Converts the given surrogate pair into a 32-bit UCS-4 character.
     * Use of {@link Character#toCodePoint} is generally preferred.
     */
    public static int toUCS4(char c, char d) {
<span class="nc bnc" id="L110" title="All 6 branches missed.">        assert Character.isHighSurrogate(c) &amp;&amp; Character.isLowSurrogate(d);</span>
<span class="nc" id="L111">        return Character.toCodePoint(c, d);</span>
    }

    /**
     * Surrogate parsing support.  Charset implementations may use instances of
     * this class to handle the details of parsing UTF-16 surrogate pairs.
     */
<span class="fc bfc" id="L118" title="All 2 branches covered.">    public static class Parser {</span>

<span class="fc" id="L120">        public Parser() { }</span>

        private int character;          // UCS-4
<span class="fc" id="L123">        private CoderResult error = CoderResult.UNDERFLOW;</span>
        private boolean isPair;

        /**
         * Returns the UCS-4 character previously parsed.
         */
        public int character() {
<span class="nc bnc" id="L130" title="All 4 branches missed.">            assert (error == null);</span>
<span class="nc" id="L131">            return character;</span>
        }

        /**
         * Tells whether or not the previously-parsed UCS-4 character was
         * originally represented by a surrogate pair.
         */
        public boolean isPair() {
<span class="nc bnc" id="L139" title="All 4 branches missed.">            assert (error == null);</span>
<span class="nc" id="L140">            return isPair;</span>
        }

        /**
         * Returns the number of UTF-16 characters consumed by the previous
         * parse.
         */
        public int increment() {
<span class="nc bnc" id="L148" title="All 4 branches missed.">            assert (error == null);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            return isPair ? 2 : 1;</span>
        }

        /**
         * If the previous parse operation detected an error, return the object
         * describing that error.
         */
        public CoderResult error() {
<span class="pc bpc" id="L157" title="2 of 4 branches missed.">            assert (error != null);</span>
<span class="fc" id="L158">            return error;</span>
        }

        /**
         * Returns an unmappable-input result object, with the appropriate
         * input length, for the previously-parsed character.
         */
        public CoderResult unmappableResult() {
<span class="pc bpc" id="L166" title="2 of 4 branches missed.">            assert (error == null);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">            return CoderResult.unmappableForLength(isPair ? 2 : 1);</span>
        }

        /**
         * Parses a UCS-4 character from the given source buffer, handling
         * surrogates.
         *
         * @param  c    The first character
         * @param  in   The source buffer, from which one more character
         *              will be consumed if c is a high surrogate
         *
         * @returns  Either a parsed UCS-4 character, in which case the isPair()
         *           and increment() methods will return meaningful values, or
         *           -1, in which case error() will return a descriptive result
         *           object
         */
        public int parse(char c, CharBuffer in) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (Character.isHighSurrogate(c)) {</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">                if (!in.hasRemaining()) {</span>
<span class="fc" id="L186">                    error = CoderResult.UNDERFLOW;</span>
<span class="fc" id="L187">                    return -1;</span>
                }
<span class="fc" id="L189">                char d = in.get();</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                if (Character.isLowSurrogate(d)) {</span>
<span class="fc" id="L191">                    character = Character.toCodePoint(c, d);</span>
<span class="fc" id="L192">                    isPair = true;</span>
<span class="fc" id="L193">                    error = null;</span>
<span class="fc" id="L194">                    return character;</span>
                }
<span class="fc" id="L196">                error = CoderResult.malformedForLength(1);</span>
<span class="fc" id="L197">                return -1;</span>
            }
<span class="fc bfc" id="L199" title="All 2 branches covered.">            if (Character.isLowSurrogate(c)) {</span>
<span class="fc" id="L200">                error = CoderResult.malformedForLength(1);</span>
<span class="fc" id="L201">                return -1;</span>
            }
<span class="fc" id="L203">            character = c;</span>
<span class="fc" id="L204">            isPair = false;</span>
<span class="fc" id="L205">            error = null;</span>
<span class="fc" id="L206">            return character;</span>
        }

        /**
         * Parses a UCS-4 character from the given source buffer, handling
         * surrogates.
         *
         * @param  c    The first character
         * @param  ia   The input array, from which one more character
         *              will be consumed if c is a high surrogate
         * @param  ip   The input index
         * @param  il   The input limit
         *
         * @returns  Either a parsed UCS-4 character, in which case the isPair()
         *           and increment() methods will return meaningful values, or
         *           -1, in which case error() will return a descriptive result
         *           object
         */
        public int parse(char c, char[] ia, int ip, int il) {
<span class="pc bpc" id="L225" title="2 of 4 branches missed.">            assert (ia[ip] == c);</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">            if (Character.isHighSurrogate(c)) {</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">                if (il - ip &lt; 2) {</span>
<span class="fc" id="L228">                    error = CoderResult.UNDERFLOW;</span>
<span class="fc" id="L229">                    return -1;</span>
                }
<span class="fc" id="L231">                char d = ia[ip + 1];</span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">                if (Character.isLowSurrogate(d)) {</span>
<span class="fc" id="L233">                    character = Character.toCodePoint(c, d);</span>
<span class="fc" id="L234">                    isPair = true;</span>
<span class="fc" id="L235">                    error = null;</span>
<span class="fc" id="L236">                    return character;</span>
                }
<span class="fc" id="L238">                error = CoderResult.malformedForLength(1);</span>
<span class="fc" id="L239">                return -1;</span>
            }
<span class="fc bfc" id="L241" title="All 2 branches covered.">            if (Character.isLowSurrogate(c)) {</span>
<span class="fc" id="L242">                error = CoderResult.malformedForLength(1);</span>
<span class="fc" id="L243">                return -1;</span>
            }
<span class="fc" id="L245">            character = c;</span>
<span class="fc" id="L246">            isPair = false;</span>
<span class="fc" id="L247">            error = null;</span>
<span class="fc" id="L248">            return character;</span>
        }

    }

    /**
     * Surrogate generation support.  Charset implementations may use instances
     * of this class to handle the details of generating UTF-16 surrogate
     * pairs.
     */
<span class="nc bnc" id="L258" title="All 2 branches missed.">    public static class Generator {</span>

<span class="nc" id="L260">        public Generator() { }</span>

<span class="nc" id="L262">        private CoderResult error = CoderResult.OVERFLOW;</span>

        /**
         * If the previous generation operation detected an error, return the
         * object describing that error.
         */
        public CoderResult error() {
<span class="nc bnc" id="L269" title="All 4 branches missed.">            assert error != null;</span>
<span class="nc" id="L270">            return error;</span>
        }

        /**
         * Generates one or two UTF-16 characters to represent the given UCS-4
         * character.
         *
         * @param  uc   The UCS-4 character
         * @param  len  The number of input bytes from which the UCS-4 value
         *              was constructed (used when creating result objects)
         * @param  dst  The destination buffer, to which one or two UTF-16
         *              characters will be written
         *
         * @returns  Either a positive count of the number of UTF-16 characters
         *           written to the destination buffer, or -1, in which case
         *           error() will return a descriptive result object
         */
        public int generate(int uc, int len, CharBuffer dst) {
<span class="nc bnc" id="L288" title="All 2 branches missed.">            if (Character.isBmpCodePoint(uc)) {</span>
<span class="nc" id="L289">                char c = (char) uc;</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">                if (Character.isSurrogate(c)) {</span>
<span class="nc" id="L291">                    error = CoderResult.malformedForLength(len);</span>
<span class="nc" id="L292">                    return -1;</span>
                }
<span class="nc bnc" id="L294" title="All 2 branches missed.">                if (dst.remaining() &lt; 1) {</span>
<span class="nc" id="L295">                    error = CoderResult.OVERFLOW;</span>
<span class="nc" id="L296">                    return -1;</span>
                }
<span class="nc" id="L298">                dst.put(c);</span>
<span class="nc" id="L299">                error = null;</span>
<span class="nc" id="L300">                return 1;</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">            } else if (Character.isValidCodePoint(uc)) {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">                if (dst.remaining() &lt; 2) {</span>
<span class="nc" id="L303">                    error = CoderResult.OVERFLOW;</span>
<span class="nc" id="L304">                    return -1;</span>
                }
<span class="nc" id="L306">                dst.put(Character.highSurrogate(uc));</span>
<span class="nc" id="L307">                dst.put(Character.lowSurrogate(uc));</span>
<span class="nc" id="L308">                error = null;</span>
<span class="nc" id="L309">                return 2;</span>
            } else {
<span class="nc" id="L311">                error = CoderResult.unmappableForLength(len);</span>
<span class="nc" id="L312">                return -1;</span>
            }
        }

        /**
         * Generates one or two UTF-16 characters to represent the given UCS-4
         * character.
         *
         * @param  uc   The UCS-4 character
         * @param  len  The number of input bytes from which the UCS-4 value
         *              was constructed (used when creating result objects)
         * @param  da   The destination array, to which one or two UTF-16
         *              characters will be written
         * @param  dp   The destination position
         * @param  dl   The destination limit
         *
         * @returns  Either a positive count of the number of UTF-16 characters
         *           written to the destination buffer, or -1, in which case
         *           error() will return a descriptive result object
         */
        public int generate(int uc, int len, char[] da, int dp, int dl) {
<span class="nc bnc" id="L333" title="All 2 branches missed.">            if (Character.isBmpCodePoint(uc)) {</span>
<span class="nc" id="L334">                char c = (char) uc;</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">                if (Character.isSurrogate(c)) {</span>
<span class="nc" id="L336">                    error = CoderResult.malformedForLength(len);</span>
<span class="nc" id="L337">                    return -1;</span>
                }
<span class="nc bnc" id="L339" title="All 2 branches missed.">                if (dl - dp &lt; 1) {</span>
<span class="nc" id="L340">                    error = CoderResult.OVERFLOW;</span>
<span class="nc" id="L341">                    return -1;</span>
                }
<span class="nc" id="L343">                da[dp] = c;</span>
<span class="nc" id="L344">                error = null;</span>
<span class="nc" id="L345">                return 1;</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            } else if (Character.isValidCodePoint(uc)) {</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">                if (dl - dp &lt; 2) {</span>
<span class="nc" id="L348">                    error = CoderResult.OVERFLOW;</span>
<span class="nc" id="L349">                    return -1;</span>
                }
<span class="nc" id="L351">                da[dp] = Character.highSurrogate(uc);</span>
<span class="nc" id="L352">                da[dp + 1] = Character.lowSurrogate(uc);</span>
<span class="nc" id="L353">                error = null;</span>
<span class="nc" id="L354">                return 2;</span>
            } else {
<span class="nc" id="L356">                error = CoderResult.unmappableForLength(len);</span>
<span class="nc" id="L357">                return -1;</span>
            }
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>