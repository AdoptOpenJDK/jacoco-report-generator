<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Rfc2253Parser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.naming.ldap</a> &gt; <span class="el_source">Rfc2253Parser.java</span></div><h1>Rfc2253Parser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.naming.ldap;

import java.util.List;
import java.util.ArrayList;

import javax.naming.InvalidNameException;

/*
 * RFC2253Parser implements a recursive descent parser for a single DN.
 */
final class Rfc2253Parser {

        private final String name;      // DN being parsed
        private final char[] chars;     // characters in LDAP name being parsed
        private final int len;  // length of &quot;chars&quot;
<span class="fc" id="L41">        private int cur = 0;    // index of first unconsumed char in &quot;chars&quot;</span>

        /*
         * Given an LDAP DN in string form, returns a parser for it.
         */
<span class="fc" id="L46">        Rfc2253Parser(String name) {</span>
<span class="fc" id="L47">            this.name = name;</span>
<span class="fc" id="L48">            len = name.length();</span>
<span class="fc" id="L49">            chars = name.toCharArray();</span>
<span class="fc" id="L50">        }</span>

        /*
         * Parses the DN, returning a List of its RDNs.
         */
        // public List&lt;Rdn&gt; getDN() throws InvalidNameException {

        List&lt;Rdn&gt; parseDn() throws InvalidNameException {
<span class="fc" id="L58">            cur = 0;</span>

            // ArrayList&lt;Rdn&gt; rdns =
            //  new ArrayList&lt;Rdn&gt;(len / 3 + 10);  // leave room for growth

<span class="fc" id="L63">            ArrayList&lt;Rdn&gt; rdns =</span>
                new ArrayList&lt;&gt;(len / 3 + 10);  // leave room for growth

<span class="fc bfc" id="L66" title="All 2 branches covered.">            if (len == 0) {</span>
<span class="fc" id="L67">                return rdns;</span>
            }

<span class="fc" id="L70">            rdns.add(doParse(new Rdn()));</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">            while (cur &lt; len) {</span>
<span class="pc bpc" id="L72" title="3 of 4 branches missed.">                if (chars[cur] == ',' || chars[cur] == ';') {</span>
<span class="fc" id="L73">                    ++cur;</span>
<span class="fc" id="L74">                    rdns.add(0, doParse(new Rdn()));</span>
                } else {
<span class="nc" id="L76">                    throw new InvalidNameException(&quot;Invalid name: &quot; + name);</span>
                }
            }
<span class="fc" id="L79">            return rdns;</span>
        }

        /*
         * Parses the DN, if it is known to contain a single RDN.
         */
        Rdn parseRdn() throws InvalidNameException {
<span class="nc" id="L86">            return parseRdn(new Rdn());</span>
        }

        /*
         * Parses the DN, if it is known to contain a single RDN.
         */
        Rdn parseRdn(Rdn rdn) throws InvalidNameException {
<span class="nc" id="L93">            rdn = doParse(rdn);</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">            if (cur &lt; len) {</span>
<span class="nc" id="L95">                throw new InvalidNameException(&quot;Invalid RDN: &quot; + name);</span>
            }
<span class="nc" id="L97">            return rdn;</span>
        }

        /*
         * Parses the next RDN and returns it.  Throws an exception if
         * none is found.  Leading and trailing whitespace is consumed.
         */
         private Rdn doParse(Rdn rdn) throws InvalidNameException {

<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            while (cur &lt; len) {</span>
<span class="fc" id="L107">                consumeWhitespace();</span>
<span class="fc" id="L108">                String attrType = parseAttrType();</span>
<span class="fc" id="L109">                consumeWhitespace();</span>
<span class="pc bpc" id="L110" title="2 of 4 branches missed.">                if (cur &gt;= len || chars[cur] != '=') {</span>
<span class="nc" id="L111">                    throw new InvalidNameException(&quot;Invalid name: &quot; + name);</span>
                }
<span class="fc" id="L113">                ++cur;          // consume '='</span>
<span class="fc" id="L114">                consumeWhitespace();</span>
<span class="fc" id="L115">                String value = parseAttrValue();</span>
<span class="fc" id="L116">                consumeWhitespace();</span>

<span class="fc" id="L118">                rdn.put(attrType, Rdn.unescapeValue(value));</span>
<span class="pc bpc" id="L119" title="1 of 4 branches missed.">                if (cur &gt;= len || chars[cur] != '+') {</span>
<span class="fc" id="L120">                    break;</span>
                }
<span class="nc" id="L122">                ++cur;          // consume '+'</span>
<span class="nc" id="L123">            }</span>
<span class="fc" id="L124">            rdn.sort();</span>
<span class="fc" id="L125">            return rdn;</span>
        }

        /*
         * Returns the attribute type that begins at the next unconsumed
         * char.  No leading whitespace is expected.
         * This routine is more generous than RFC 2253.  It accepts
         * attribute types composed of any nonempty combination of Unicode
         * letters, Unicode digits, '.', '-', and internal space characters.
         */
        private String parseAttrType() throws InvalidNameException {

<span class="fc" id="L137">            final int beg = cur;</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">            while (cur &lt; len) {</span>
<span class="fc" id="L139">                char c = chars[cur];</span>
<span class="pc bpc" id="L140" title="3 of 8 branches missed.">                if (Character.isLetterOrDigit(c) ||</span>
                        c == '.' ||
                        c == '-' ||
                        c == ' ') {
<span class="fc" id="L144">                    ++cur;</span>
                } else {
                    break;
                }
<span class="fc" id="L148">            }</span>
            // Back out any trailing spaces.
<span class="pc bpc" id="L150" title="2 of 4 branches missed.">            while ((cur &gt; beg) &amp;&amp; (chars[cur - 1] == ' ')) {</span>
<span class="nc" id="L151">                --cur;</span>
            }

<span class="pc bpc" id="L154" title="1 of 2 branches missed.">            if (beg == cur) {</span>
<span class="nc" id="L155">                throw new InvalidNameException(&quot;Invalid name: &quot; + name);</span>
            }
<span class="fc" id="L157">            return new String(chars, beg, cur - beg);</span>
        }

        /*
         * Returns the attribute value that begins at the next unconsumed
         * char.  No leading whitespace is expected.
         */
        private String parseAttrValue() throws InvalidNameException {

<span class="pc bpc" id="L166" title="2 of 4 branches missed.">            if (cur &lt; len &amp;&amp; chars[cur] == '#') {</span>
<span class="nc" id="L167">                return parseBinaryAttrValue();</span>
<span class="pc bpc" id="L168" title="2 of 4 branches missed.">            } else if (cur &lt; len &amp;&amp; chars[cur] == '&quot;') {</span>
<span class="nc" id="L169">                return parseQuotedAttrValue();</span>
            } else {
<span class="fc" id="L171">                return parseStringAttrValue();</span>
            }
        }

        private String parseBinaryAttrValue() throws InvalidNameException {
<span class="nc" id="L176">            final int beg = cur;</span>
<span class="nc" id="L177">            ++cur;                      // consume '#'</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">            while ((cur &lt; len) &amp;&amp;</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                    Character.isLetterOrDigit(chars[cur])) {</span>
<span class="nc" id="L180">                ++cur;</span>
            }
<span class="nc" id="L182">            return new String(chars, beg, cur - beg);</span>
        }

        private String parseQuotedAttrValue() throws InvalidNameException {

<span class="nc" id="L187">            final int beg = cur;</span>
<span class="nc" id="L188">            ++cur;                      // consume '&quot;'</span>

<span class="nc bnc" id="L190" title="All 4 branches missed.">            while ((cur &lt; len) &amp;&amp; chars[cur] != '&quot;') {</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                if (chars[cur] == '\\') {</span>
<span class="nc" id="L192">                    ++cur;              // consume backslash, then what follows</span>
                }
<span class="nc" id="L194">                ++cur;</span>
            }
<span class="nc bnc" id="L196" title="All 2 branches missed.">            if (cur &gt;= len) {   // no closing quote</span>
<span class="nc" id="L197">                throw new InvalidNameException(&quot;Invalid name: &quot; + name);</span>
            }
<span class="nc" id="L199">            ++cur;      // consume closing quote</span>

<span class="nc" id="L201">            return new String(chars, beg, cur - beg);</span>
        }

        private String parseStringAttrValue() throws InvalidNameException {

<span class="fc" id="L206">            final int beg = cur;</span>
<span class="fc" id="L207">            int esc = -1;       // index of the most recently escaped character</span>

<span class="fc bfc" id="L209" title="All 4 branches covered.">            while ((cur &lt; len) &amp;&amp; !atTerminator()) {</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">                if (chars[cur] == '\\') {</span>
<span class="nc" id="L211">                    ++cur;              // consume backslash, then what follows</span>
<span class="nc" id="L212">                    esc = cur;</span>
                }
<span class="fc" id="L214">                ++cur;</span>
            }
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">            if (cur &gt; len) {            // 'twas backslash followed by nothing</span>
<span class="nc" id="L217">                throw new InvalidNameException(&quot;Invalid name: &quot; + name);</span>
            }

            // Trim off (unescaped) trailing whitespace.
            int end;
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">            for (end = cur; end &gt; beg; end--) {</span>
<span class="pc bpc" id="L223" title="3 of 4 branches missed.">                if (!isWhitespace(chars[end - 1]) || (esc == end - 1)) {</span>
<span class="nc" id="L224">                    break;</span>
                }
            }
<span class="fc" id="L227">            return new String(chars, beg, end - beg);</span>
        }

        private void consumeWhitespace() {
<span class="pc bpc" id="L231" title="1 of 4 branches missed.">            while ((cur &lt; len) &amp;&amp; isWhitespace(chars[cur])) {</span>
<span class="nc" id="L232">                ++cur;</span>
            }
<span class="fc" id="L234">        }</span>

        /*
         * Returns true if next unconsumed character is one that terminates
         * a string attribute value.
         */
        private boolean atTerminator() {
<span class="pc bpc" id="L241" title="3 of 8 branches missed.">            return (cur &lt; len &amp;&amp;</span>
                    (chars[cur] == ',' ||
                        chars[cur] == ';' ||
                        chars[cur] == '+'));
        }

        /*
         * Best guess as to what RFC 2253 means by &quot;whitespace&quot;.
         */
        private static boolean isWhitespace(char c) {
<span class="pc bpc" id="L251" title="2 of 4 branches missed.">            return (c == ' ' || c == '\r');</span>
        }
    }
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>