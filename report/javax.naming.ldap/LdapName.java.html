<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>LdapName.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.naming.ldap</a> &gt; <span class="el_source">LdapName.java</span></div><h1>LdapName.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.naming.ldap;

import javax.naming.Name;
import javax.naming.InvalidNameException;

import java.util.Enumeration;
import java.util.Collection;
import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Collections;

import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;

/**
 * This class represents a distinguished name as specified by
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;.
 * A distinguished name, or DN, is composed of an ordered list of
 * components called &lt;em&gt;relative distinguished name&lt;/em&gt;s, or RDNs.
 * Details of a DN's syntax are described in RFC 2253.
 *&lt;p&gt;
 * This class resolves a few ambiguities found in RFC 2253
 * as follows:
 * &lt;ul&gt;
 * &lt;li&gt; RFC 2253 leaves the term &quot;whitespace&quot; undefined. The
 *      ASCII space character 0x20 (&quot; &quot;) is used in its place.
 * &lt;li&gt; Whitespace is allowed on either side of ',', ';', '=', and '+'.
 *      Such whitespace is accepted but not generated by this code,
 *      and is ignored when comparing names.
 * &lt;li&gt; AttributeValue strings containing '=' or non-leading '#'
 *      characters (unescaped) are accepted.
 * &lt;/ul&gt;
 *&lt;p&gt;
 * String names passed to &lt;code&gt;LdapName&lt;/code&gt; or returned by it
 * use the full Unicode character set. They may also contain
 * characters encoded into UTF-8 with each octet represented by a
 * three-character substring such as &quot;\\B4&quot;.
 * They may not, however, contain characters encoded into UTF-8 with
 * each octet represented by a single character in the string:  the
 * meaning would be ambiguous.
 *&lt;p&gt;
 * &lt;code&gt;LdapName&lt;/code&gt; will properly parse all valid names, but
 * does not attempt to detect all possible violations when parsing
 * invalid names.  It is &quot;generous&quot; in accepting invalid names.
 * The &quot;validity&quot; of a name is determined ultimately when it
 * is supplied to an LDAP server, which may accept or
 * reject the name based on factors such as its schema information
 * and interoperability considerations.
 *&lt;p&gt;
 * When names are tested for equality, attribute types, both binary
 * and string values, are case-insensitive.
 * String values with different but equivalent usage of quoting,
 * escaping, or UTF8-hex-encoding are considered equal.  The order of
 * components in multi-valued RDNs (such as &quot;ou=Sales+cn=Bob&quot;) is not
 * significant.
 * &lt;p&gt;
 * The components of a LDAP name, that is, RDNs, are numbered. The
 * indexes of a LDAP name with n RDNs range from 0 to n-1.
 * This range may be written as [0,n).
 * The right most RDN is at index 0, and the left most RDN is at
 * index n-1. For example, the distinguished name:
 * &quot;CN=Steve Kille, O=Isode Limited, C=GB&quot; is numbered in the following
 * sequence ranging from 0 to 2: {C=GB, O=Isode Limited, CN=Steve Kille}. An
 * empty LDAP name is represented by an empty RDN list.
 *&lt;p&gt;
 * Concurrent multithreaded read-only access of an instance of
 * &lt;tt&gt;LdapName&lt;/tt&gt; need not be synchronized.
 *&lt;p&gt;
 * Unless otherwise noted, the behavior of passing a null argument
 * to a constructor or method in this class will cause a
 * NullPointerException to be thrown.
 *
 * @author Scott Seligman
 * @since 1.5
 */

public class LdapName implements Name {

    private transient List&lt;Rdn&gt; rdns;   // parsed name components
    private transient String unparsed;  // if non-null, the DN in unparsed form
    private static final long serialVersionUID = -1595520034788997356L;

    /**
     * Constructs an LDAP name from the given distinguished name.
     *
     * @param name  This is a non-null distinguished name formatted
     * according to the rules defined in
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;.
     *
     * @throws InvalidNameException if a syntax violation is detected.
     * @see Rdn#escapeValue(Object value)
     */
<span class="fc" id="L121">    public LdapName(String name) throws InvalidNameException {</span>
<span class="fc" id="L122">        unparsed = name;</span>
<span class="fc" id="L123">        parse();</span>
<span class="fc" id="L124">    }</span>

    /**
     * Constructs an LDAP name given its parsed RDN components.
     * &lt;p&gt;
     * The indexing of RDNs in the list follows the numbering of
     * RDNs described in the class description.
     *
     * @param rdns The non-null list of &lt;tt&gt;Rdn&lt;/tt&gt;s forming this LDAP name.
     */
<span class="nc" id="L134">    public LdapName(List&lt;Rdn&gt; rdns) {</span>

        // if (rdns instanceof ArrayList&lt;Rdn&gt;) {
        //      this.rdns = rdns.clone();
        // } else if (rdns instanceof List&lt;Rdn&gt;) {
        //      this.rdns = new ArrayList&lt;Rdn&gt;(rdns);
        // } else {
        //      throw IllegalArgumentException(
        //              &quot;Invalid entries, list entries must be of type Rdn&quot;);
        //  }

<span class="nc" id="L145">        this.rdns = new ArrayList&lt;&gt;(rdns.size());</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">        for (int i = 0; i &lt; rdns.size(); i++) {</span>
<span class="nc" id="L147">            Object obj = rdns.get(i);</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            if (!(obj instanceof Rdn)) {</span>
<span class="nc" id="L149">                throw new IllegalArgumentException(&quot;Entry:&quot; + obj +</span>
                        &quot;  not a valid type;list entries must be of type Rdn&quot;);
            }
<span class="nc" id="L152">            this.rdns.add((Rdn)obj);</span>
        }
<span class="nc" id="L154">    }</span>

    /*
     * Constructs an LDAP name given its parsed components (the elements
     * of &quot;rdns&quot; in the range [beg,end)) and, optionally
     * (if &quot;name&quot; is not null), the unparsed DN.
     *
     */
<span class="nc" id="L162">    private LdapName(String name, List&lt;Rdn&gt; rdns, int beg, int end) {</span>
<span class="nc" id="L163">        unparsed = name;</span>
        // this.rdns = rdns.subList(beg, end);

<span class="nc" id="L166">        List&lt;Rdn&gt; sList = rdns.subList(beg, end);</span>
<span class="nc" id="L167">        this.rdns = new ArrayList&lt;&gt;(sList);</span>
<span class="nc" id="L168">    }</span>

    /**
     * Retrieves the number of components in this LDAP name.
     * @return The non-negative number of components in this LDAP name.
     */
    public int size() {
<span class="nc" id="L175">        return rdns.size();</span>
    }

    /**
     * Determines whether this LDAP name is empty.
     * An empty name is one with zero components.
     * @return true if this LDAP name is empty, false otherwise.
     */
    public boolean isEmpty() {
<span class="nc" id="L184">        return rdns.isEmpty();</span>
    }

    /**
     * Retrieves the components of this name as an enumeration
     * of strings. The effect of updates to this name on this enumeration
     * is undefined. If the name has zero components, an empty (non-null)
     * enumeration is returned.
     * The order of the components returned by the enumeration is same as
     * the order in which the components are numbered as described in the
     * class description.
     *
     * @return A non-null enumeration of the components of this LDAP name.
     * Each element of the enumeration is of class String.
     */
    public Enumeration&lt;String&gt; getAll() {
<span class="nc" id="L200">        final Iterator&lt;Rdn&gt; iter = rdns.iterator();</span>

<span class="nc" id="L202">        return new Enumeration&lt;String&gt;() {</span>
            public boolean hasMoreElements() {
<span class="nc" id="L204">                return iter.hasNext();</span>
            }
            public String nextElement() {
<span class="nc" id="L207">                return iter.next().toString();</span>
            }
        };
    }

    /**
     * Retrieves a component of this LDAP name as a string.
     * @param  posn The 0-based index of the component to retrieve.
     *              Must be in the range [0,size()).
     * @return The non-null component at index posn.
     * @exception IndexOutOfBoundsException if posn is outside the
     *          specified range.
     */
    public String get(int posn) {
<span class="nc" id="L221">        return rdns.get(posn).toString();</span>
    }

    /**
     * Retrieves an RDN of this LDAP name as an Rdn.
     * @param   posn The 0-based index of the RDN to retrieve.
     *          Must be in the range [0,size()).
     * @return The non-null RDN at index posn.
     * @exception IndexOutOfBoundsException if posn is outside the
     *            specified range.
     */
    public Rdn getRdn(int posn) {
<span class="nc" id="L233">        return rdns.get(posn);</span>
    }

    /**
     * Creates a name whose components consist of a prefix of the
     * components of this LDAP name.
     * Subsequent changes to this name will not affect the name
     * that is returned and vice versa.
     * @param  posn     The 0-based index of the component at which to stop.
     *                  Must be in the range [0,size()].
     * @return  An instance of &lt;tt&gt;LdapName&lt;/tt&gt; consisting of the
     *          components at indexes in the range [0,posn).
     *          If posn is zero, an empty LDAP name is returned.
     * @exception   IndexOutOfBoundsException
     *              If posn is outside the specified range.
     */
    public Name getPrefix(int posn) {
        try {
<span class="nc" id="L251">            return new LdapName(null, rdns, 0, posn);</span>
<span class="nc" id="L252">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L253">            throw new IndexOutOfBoundsException(</span>
<span class="nc" id="L254">                &quot;Posn: &quot; + posn + &quot;, Size: &quot;+ rdns.size());</span>
        }
    }

    /**
     * Creates a name whose components consist of a suffix of the
     * components in this LDAP name.
     * Subsequent changes to this name do not affect the name that is
     * returned and vice versa.
     *
     * @param  posn     The 0-based index of the component at which to start.
     *                  Must be in the range [0,size()].
     * @return  An instance of &lt;tt&gt;LdapName&lt;/tt&gt; consisting of the
     *          components at indexes in the range [posn,size()).
     *          If posn is equal to size(), an empty LDAP name is
     *          returned.
     * @exception IndexOutOfBoundsException
     *          If posn is outside the specified range.
     */
    public Name getSuffix(int posn) {
        try {
<span class="nc" id="L275">            return new LdapName(null, rdns, posn, rdns.size());</span>
<span class="nc" id="L276">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L277">            throw new IndexOutOfBoundsException(</span>
<span class="nc" id="L278">                &quot;Posn: &quot; + posn + &quot;, Size: &quot;+ rdns.size());</span>
        }
    }

    /**
     * Determines whether this LDAP name starts with a specified LDAP name
     * prefix.
     * A name &lt;tt&gt;n&lt;/tt&gt; is a prefix if it is equal to
     * &lt;tt&gt;getPrefix(n.size())&lt;/tt&gt;--in other words this LDAP
     * name starts with 'n'. If n is null or not a RFC2253 formatted name
     * as described in the class description, false is returned.
     *
     * @param n The LDAP name to check.
     * @return  true if &lt;tt&gt;n&lt;/tt&gt; is a prefix of this LDAP name,
     * false otherwise.
     * @see #getPrefix(int posn)
     */
    public boolean startsWith(Name n) {
<span class="nc bnc" id="L296" title="All 2 branches missed.">        if (n == null) {</span>
<span class="nc" id="L297">            return false;</span>
        }
<span class="nc" id="L299">        int len1 = rdns.size();</span>
<span class="nc" id="L300">        int len2 = n.size();</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">        return (len1 &gt;= len2 &amp;&amp;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">                matches(0, len2, n));</span>
    }

    /**
     * Determines whether the specified RDN sequence forms a prefix of this
     * LDAP name.  Returns true if this LdapName is at least as long as rdns,
     * and for every position p in the range [0, rdns.size()) the component
     * getRdn(p) matches rdns.get(p). Returns false otherwise. If rdns is
     * null, false is returned.
     *
     * @param rdns The sequence of &lt;tt&gt;Rdn&lt;/tt&gt;s to check.
     * @return  true if &lt;tt&gt;rdns&lt;/tt&gt; form a prefix of this LDAP name,
     *          false otherwise.
     */
    public boolean startsWith(List&lt;Rdn&gt; rdns) {
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (rdns == null) {</span>
<span class="nc" id="L318">            return false;</span>
        }
<span class="nc" id="L320">        int len1 = this.rdns.size();</span>
<span class="nc" id="L321">        int len2 = rdns.size();</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">        return (len1 &gt;= len2 &amp;&amp;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                doesListMatch(0, len2, rdns));</span>
    }

    /**
     * Determines whether this LDAP name ends with a specified
     * LDAP name suffix.
     * A name &lt;tt&gt;n&lt;/tt&gt; is a suffix if it is equal to
     * &lt;tt&gt;getSuffix(size()-n.size())&lt;/tt&gt;--in other words this LDAP
     * name ends with 'n'. If n is null or not a RFC2253 formatted name
     * as described in the class description, false is returned.
     *
     * @param n The LDAP name to check.
     * @return true if &lt;tt&gt;n&lt;/tt&gt; is a suffix of this name, false otherwise.
     * @see #getSuffix(int posn)
     */
    public boolean endsWith(Name n) {
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (n == null) {</span>
<span class="nc" id="L340">            return false;</span>
        }
<span class="nc" id="L342">        int len1 = rdns.size();</span>
<span class="nc" id="L343">        int len2 = n.size();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        return (len1 &gt;= len2 &amp;&amp;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                matches(len1 - len2, len1, n));</span>
    }

    /**
     * Determines whether the specified RDN sequence forms a suffix of this
     * LDAP name.  Returns true if this LdapName is at least as long as rdns,
     * and for every position p in the range [size() - rdns.size(), size())
     * the component getRdn(p) matches rdns.get(p). Returns false otherwise.
     * If rdns is null, false is returned.
     *
     * @param rdns The sequence of &lt;tt&gt;Rdn&lt;/tt&gt;s to check.
     * @return  true if &lt;tt&gt;rdns&lt;/tt&gt; form a suffix of this LDAP name,
     *          false otherwise.
     */
    public boolean endsWith(List&lt;Rdn&gt; rdns) {
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (rdns == null) {</span>
<span class="nc" id="L361">            return false;</span>
        }
<span class="nc" id="L363">        int len1 = this.rdns.size();</span>
<span class="nc" id="L364">        int len2 = rdns.size();</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">        return (len1 &gt;= len2 &amp;&amp;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">                doesListMatch(len1 - len2, len1, rdns));</span>
    }

    private boolean doesListMatch(int beg, int end, List&lt;Rdn&gt; rdns) {
<span class="nc bnc" id="L370" title="All 2 branches missed.">        for (int i = beg; i &lt; end; i++) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">            if (!this.rdns.get(i).equals(rdns.get(i - beg))) {</span>
<span class="nc" id="L372">                return false;</span>
            }
        }
<span class="nc" id="L375">        return true;</span>
    }

    /*
     * Helper method for startsWith() and endsWith().
     * Returns true if components [beg,end) match the components of &quot;n&quot;.
     * If &quot;n&quot; is not an LdapName, each of its components is parsed as
     * the string form of an RDN.
     * The following must hold:  end - beg == n.size().
     */
    private boolean matches(int beg, int end, Name n) {
<span class="nc bnc" id="L386" title="All 2 branches missed.">        if (n instanceof LdapName) {</span>
<span class="nc" id="L387">            LdapName ln = (LdapName) n;</span>
<span class="nc" id="L388">            return doesListMatch(beg, end, ln.rdns);</span>
        } else {
<span class="nc bnc" id="L390" title="All 2 branches missed.">            for (int i = beg; i &lt; end; i++) {</span>
                Rdn rdn;
<span class="nc" id="L392">                String rdnString = n.get(i - beg);</span>
                try {
<span class="nc" id="L394">                    rdn = (new Rfc2253Parser(rdnString)).parseRdn();</span>
<span class="nc" id="L395">                } catch (InvalidNameException e) {</span>
<span class="nc" id="L396">                    return false;</span>
<span class="nc" id="L397">                }</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                if (!rdn.equals(rdns.get(i))) {</span>
<span class="nc" id="L399">                    return false;</span>
                }
            }
        }
<span class="nc" id="L403">        return true;</span>
    }

    /**
     * Adds the components of a name -- in order -- to the end of this name.
     *
     * @param   suffix The non-null components to add.
     * @return  The updated name (not a new instance).
     *
     * @throws  InvalidNameException if &lt;tt&gt;suffix&lt;/tt&gt; is not a valid LDAP
     *          name, or if the addition of the components would violate the
     *          syntax rules of this LDAP name.
     */
    public Name addAll(Name suffix) throws InvalidNameException {
<span class="nc" id="L417">         return addAll(size(), suffix);</span>
    }


    /**
     * Adds the RDNs of a name -- in order -- to the end of this name.
     *
     * @param   suffixRdns The non-null suffix &lt;tt&gt;Rdn&lt;/tt&gt;s to add.
     * @return  The updated name (not a new instance).
     */
    public Name addAll(List&lt;Rdn&gt; suffixRdns) {
<span class="nc" id="L428">        return addAll(size(), suffixRdns);</span>
    }

    /**
     * Adds the components of a name -- in order -- at a specified position
     * within this name. Components of this LDAP name at or after the
     * index (if any) of the first new component are shifted up
     * (away from index 0) to accommodate the new components.
     *
     * @param suffix    The non-null components to add.
     * @param posn      The index at which to add the new component.
     *                  Must be in the range [0,size()].
     *
     * @return  The updated name (not a new instance).
     *
     * @throws  InvalidNameException if &lt;tt&gt;suffix&lt;/tt&gt; is not a valid LDAP
     *          name, or if the addition of the components would violate the
     *          syntax rules of this LDAP name.
     * @throws  IndexOutOfBoundsException
     *          If posn is outside the specified range.
     */
    public Name addAll(int posn, Name suffix)
        throws InvalidNameException {
<span class="nc" id="L451">        unparsed = null;        // no longer valid</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">        if (suffix instanceof LdapName) {</span>
<span class="nc" id="L453">            LdapName s = (LdapName) suffix;</span>
<span class="nc" id="L454">            rdns.addAll(posn, s.rdns);</span>
<span class="nc" id="L455">        } else {</span>
<span class="nc" id="L456">            Enumeration&lt;String&gt; comps = suffix.getAll();</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">            while (comps.hasMoreElements()) {</span>
<span class="nc" id="L458">                rdns.add(posn++,</span>
<span class="nc" id="L459">                    (new Rfc2253Parser(comps.nextElement()).</span>
<span class="nc" id="L460">                    parseRdn()));</span>
            }
        }
<span class="nc" id="L463">        return this;</span>
    }

    /**
     * Adds the RDNs of a name -- in order -- at a specified position
     * within this name. RDNs of this LDAP name at or after the
     * index (if any) of the first new RDN are shifted up (away from index 0) to
     * accommodate the new RDNs.
     *
     * @param suffixRdns        The non-null suffix &lt;tt&gt;Rdn&lt;/tt&gt;s to add.
     * @param posn              The index at which to add the suffix RDNs.
     *                          Must be in the range [0,size()].
     *
     * @return  The updated name (not a new instance).
     * @throws  IndexOutOfBoundsException
     *          If posn is outside the specified range.
     */
    public Name addAll(int posn, List&lt;Rdn&gt; suffixRdns) {
<span class="nc" id="L481">        unparsed = null;</span>
<span class="nc bnc" id="L482" title="All 2 branches missed.">        for (int i = 0; i &lt; suffixRdns.size(); i++) {</span>
<span class="nc" id="L483">            Object obj = suffixRdns.get(i);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (!(obj instanceof Rdn)) {</span>
<span class="nc" id="L485">                throw new IllegalArgumentException(&quot;Entry:&quot; + obj +</span>
                &quot;  not a valid type;suffix list entries must be of type Rdn&quot;);
            }
<span class="nc" id="L488">            rdns.add(i + posn, (Rdn)obj);</span>
        }
<span class="nc" id="L490">        return this;</span>
    }

    /**
     * Adds a single component to the end of this LDAP name.
     *
     * @param comp      The non-null component to add.
     * @return          The updated LdapName, not a new instance.
     *                  Cannot be null.
     * @exception       InvalidNameException If adding comp at end of the name
     *                  would violate the name's syntax.
     */
    public Name add(String comp) throws InvalidNameException {
<span class="nc" id="L503">        return add(size(), comp);</span>
    }

    /**
     * Adds a single RDN to the end of this LDAP name.
     *
     * @param comp      The non-null RDN to add.
     *
     * @return          The updated LdapName, not a new instance.
     *                  Cannot be null.
     */
    public Name add(Rdn comp) {
<span class="nc" id="L515">        return add(size(), comp);</span>
    }

    /**
     * Adds a single component at a specified position within this
     * LDAP name.
     * Components of this LDAP name at or after the index (if any) of the new
     * component are shifted up by one (away from index 0) to accommodate
     * the new component.
     *
     * @param  comp     The non-null component to add.
     * @param  posn     The index at which to add the new component.
     *                  Must be in the range [0,size()].
     * @return          The updated LdapName, not a new instance.
     *                  Cannot be null.
     * @exception       IndexOutOfBoundsException
     *                  If posn is outside the specified range.
     * @exception       InvalidNameException If adding comp at the
     *                  specified position would violate the name's syntax.
     */
    public Name add(int posn, String comp) throws InvalidNameException {
<span class="nc" id="L536">        Rdn rdn = (new Rfc2253Parser(comp)).parseRdn();</span>
<span class="nc" id="L537">        rdns.add(posn, rdn);</span>
<span class="nc" id="L538">        unparsed = null;        // no longer valid</span>
<span class="nc" id="L539">        return this;</span>
    }

    /**
     * Adds a single RDN at a specified position within this
     * LDAP name.
     * RDNs of this LDAP name at or after the index (if any) of the new
     * RDN are shifted up by one (away from index 0) to accommodate
     * the new RDN.
     *
     * @param  comp     The non-null RDN to add.
     * @param  posn     The index at which to add the new RDN.
     *                  Must be in the range [0,size()].
     * @return          The updated LdapName, not a new instance.
     *                  Cannot be null.
     * @exception       IndexOutOfBoundsException
     *                  If posn is outside the specified range.
     */
    public Name add(int posn, Rdn comp) {
<span class="nc bnc" id="L558" title="All 2 branches missed.">        if (comp == null) {</span>
<span class="nc" id="L559">            throw new NullPointerException(&quot;Cannot set comp to null&quot;);</span>
        }
<span class="nc" id="L561">        rdns.add(posn, comp);</span>
<span class="nc" id="L562">        unparsed = null;        // no longer valid</span>
<span class="nc" id="L563">        return this;</span>
    }

    /**
     * Removes a component from this LDAP name.
     * The component of this name at the specified position is removed.
     * Components with indexes greater than this position (if any)
     * are shifted down (toward index 0) by one.
     *
     * @param posn      The index of the component to remove.
     *                  Must be in the range [0,size()).
     * @return          The component removed (a String).
     *
     * @throws          IndexOutOfBoundsException
     *                  if posn is outside the specified range.
     * @throws          InvalidNameException if deleting the component
     *                  would violate the syntax rules of the name.
     */
    public Object remove(int posn) throws InvalidNameException {
<span class="nc" id="L582">        unparsed = null;        // no longer valid</span>
<span class="nc" id="L583">        return rdns.remove(posn).toString();</span>
    }

    /**
     * Retrieves the list of relative distinguished names.
     * The contents of the list are unmodifiable.
     * The indexing of RDNs in the returned list follows the numbering of
     * RDNs as described in the class description.
     * If the name has zero components, an empty list is returned.
     *
     * @return  The name as a list of RDNs which are instances of
     *          the class {@link Rdn Rdn}.
     */
    public List&lt;Rdn&gt; getRdns() {
<span class="nc" id="L597">        return Collections.unmodifiableList(rdns);</span>
    }

    /**
     * Generates a new copy of this name.
     * Subsequent changes to the components of this name will not
     * affect the new copy, and vice versa.
     *
     * @return A copy of the this LDAP name.
     */
    public Object clone() {
<span class="nc" id="L608">        return new LdapName(unparsed, rdns, 0, rdns.size());</span>
    }

    /**
     * Returns a string representation of this LDAP name in a format
     * defined by &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;
     * and described in the class description. If the name has zero
     * components an empty string is returned.
     *
     * @return The string representation of the LdapName.
     */
    public String toString() {
<span class="nc bnc" id="L620" title="All 2 branches missed.">        if (unparsed != null) {</span>
<span class="nc" id="L621">            return unparsed;</span>
        }
<span class="nc" id="L623">        StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L624">        int size = rdns.size();</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">        if ((size - 1) &gt;= 0) {</span>
<span class="nc" id="L626">            builder.append(rdns.get(size - 1));</span>
        }
<span class="nc bnc" id="L628" title="All 2 branches missed.">        for (int next = size - 2; next &gt;= 0; next--) {</span>
<span class="nc" id="L629">            builder.append(',');</span>
<span class="nc" id="L630">            builder.append(rdns.get(next));</span>
        }
<span class="nc" id="L632">        unparsed = builder.toString();</span>
<span class="nc" id="L633">        return unparsed;</span>
    }

    /**
     * Determines whether two LDAP names are equal.
     * If obj is null or not an LDAP name, false is returned.
     * &lt;p&gt;
     * Two LDAP names are equal if each RDN in one is equal
     * to the corresponding RDN in the other. This implies
     * both have the same number of RDNs, and each RDN's
     * equals() test against the corresponding RDN in the other
     * name returns true. See {@link Rdn#equals(Object obj)}
     * for a definition of RDN equality.
     *
     * @param  obj      The possibly null object to compare against.
     * @return          true if obj is equal to this LDAP name,
     *                  false otherwise.
     * @see #hashCode
     */
    public boolean equals(Object obj) {
        // check possible shortcuts
<span class="nc bnc" id="L654" title="All 2 branches missed.">        if (obj == this) {</span>
<span class="nc" id="L655">            return true;</span>
        }
<span class="nc bnc" id="L657" title="All 2 branches missed.">        if (!(obj instanceof LdapName)) {</span>
<span class="nc" id="L658">            return false;</span>
        }
<span class="nc" id="L660">        LdapName that = (LdapName) obj;</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">        if (rdns.size() != that.rdns.size()) {</span>
<span class="nc" id="L662">            return false;</span>
        }
<span class="nc bnc" id="L664" title="All 4 branches missed.">        if (unparsed != null &amp;&amp; unparsed.equalsIgnoreCase(</span>
                that.unparsed)) {
<span class="nc" id="L666">            return true;</span>
        }
        // Compare RDNs one by one for equality
<span class="nc bnc" id="L669" title="All 2 branches missed.">        for (int i = 0; i &lt; rdns.size(); i++) {</span>
            // Compare a single pair of RDNs.
<span class="nc" id="L671">            Rdn rdn1 = rdns.get(i);</span>
<span class="nc" id="L672">            Rdn rdn2 = that.rdns.get(i);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">            if (!rdn1.equals(rdn2)) {</span>
<span class="nc" id="L674">                return false;</span>
            }
        }
<span class="nc" id="L677">        return true;</span>
    }

    /**
     * Compares this LdapName with the specified Object for order.
     * Returns a negative integer, zero, or a positive integer as this
     * Name is less than, equal to, or greater than the given Object.
     * &lt;p&gt;
     * If obj is null or not an instance of LdapName, ClassCastException
     * is thrown.
     * &lt;p&gt;
     * Ordering of LDAP names follows the lexicographical rules for
     * string comparison, with the extension that this applies to all
     * the RDNs in the LDAP name. All the RDNs are lined up in their
     * specified order and compared lexicographically.
     * See {@link Rdn#compareTo(Object obj) Rdn.compareTo(Object obj)}
     * for RDN comparison rules.
     * &lt;p&gt;
     * If this LDAP name is lexicographically lesser than obj,
     * a negative number is returned.
     * If this LDAP name is lexicographically greater than obj,
     * a positive number is returned.
     * @param obj The non-null LdapName instance to compare against.
     *
     * @return  A negative integer, zero, or a positive integer as this Name
     *          is less than, equal to, or greater than the given obj.
     * @exception ClassCastException if obj is null or not a LdapName.
     */
    public int compareTo(Object obj) {

<span class="nc bnc" id="L707" title="All 2 branches missed.">        if (!(obj instanceof LdapName)) {</span>
<span class="nc" id="L708">            throw new ClassCastException(&quot;The obj is not a LdapName&quot;);</span>
        }

        // check possible shortcuts
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (obj == this) {</span>
<span class="nc" id="L713">            return 0;</span>
        }
<span class="nc" id="L715">        LdapName that = (LdapName) obj;</span>

<span class="nc bnc" id="L717" title="All 4 branches missed.">        if (unparsed != null &amp;&amp; unparsed.equalsIgnoreCase(</span>
                        that.unparsed)) {
<span class="nc" id="L719">            return 0;</span>
        }

        // Compare RDNs one by one, lexicographically.
<span class="nc" id="L723">        int minSize = Math.min(rdns.size(), that.rdns.size());</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">        for (int i = 0; i &lt; minSize; i++) {</span>
            // Compare a single pair of RDNs.
<span class="nc" id="L726">            Rdn rdn1 = rdns.get(i);</span>
<span class="nc" id="L727">            Rdn rdn2 = that.rdns.get(i);</span>

<span class="nc" id="L729">            int diff = rdn1.compareTo(rdn2);</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (diff != 0) {</span>
<span class="nc" id="L731">                return diff;</span>
            }
        }
<span class="nc" id="L734">        return (rdns.size() - that.rdns.size());        // longer DN wins</span>
    }

    /**
     * Computes the hash code of this LDAP name.
     * The hash code is the sum of the hash codes of individual RDNs
     * of this  name.
     *
     * @return An int representing the hash code of this name.
     * @see #equals
     */
    public int hashCode() {
        // Sum up the hash codes of the components.
<span class="nc" id="L747">        int hash = 0;</span>

        // For each RDN...
<span class="nc bnc" id="L750" title="All 2 branches missed.">        for (int i = 0; i &lt; rdns.size(); i++) {</span>
<span class="nc" id="L751">            Rdn rdn = rdns.get(i);</span>
<span class="nc" id="L752">            hash += rdn.hashCode();</span>
        }
<span class="nc" id="L754">        return hash;</span>
    }

    /**
     * Serializes only the unparsed DN, for compactness and to avoid
     * any implementation dependency.
     *
     * @serialData      The DN string
     */
    private void writeObject(ObjectOutputStream s)
            throws java.io.IOException {
<span class="nc" id="L765">        s.defaultWriteObject();</span>
<span class="nc" id="L766">        s.writeObject(toString());</span>
<span class="nc" id="L767">    }</span>

    private void readObject(ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
<span class="nc" id="L771">        s.defaultReadObject();</span>
<span class="nc" id="L772">        unparsed = (String)s.readObject();</span>
        try {
<span class="nc" id="L774">            parse();</span>
<span class="nc" id="L775">        } catch (InvalidNameException e) {</span>
            // shouldn't happen
<span class="nc" id="L777">            throw new java.io.StreamCorruptedException(</span>
                    &quot;Invalid name: &quot; + unparsed);
<span class="nc" id="L779">        }</span>
<span class="nc" id="L780">    }</span>

    private void parse() throws InvalidNameException {
        // rdns = (ArrayList&lt;Rdn&gt;) (new RFC2253Parser(unparsed)).getDN();

<span class="fc" id="L785">        rdns = new Rfc2253Parser(unparsed).parseDn();</span>
<span class="fc" id="L786">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>