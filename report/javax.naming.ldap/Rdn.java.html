<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Rdn.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.naming.ldap</a> &gt; <span class="el_source">Rdn.java</span></div><h1>Rdn.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.naming.ldap;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Collections;

import javax.naming.InvalidNameException;
import javax.naming.directory.BasicAttributes;
import javax.naming.directory.Attributes;
import javax.naming.directory.Attribute;
import javax.naming.NamingEnumeration;
import javax.naming.NamingException;

import java.io.Serializable;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;

/**
 * This class represents a relative distinguished name, or RDN, which is a
 * component of a distinguished name as specified by
 * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;.
 * An example of an RDN is &quot;OU=Sales+CN=J.Smith&quot;. In this example,
 * the RDN consist of multiple attribute type/value pairs. The
 * RDN is parsed as described in the class description for
 * {@link javax.naming.ldap.LdapName &lt;tt&gt;LdapName&lt;/tt&gt;}.
 * &lt;p&gt;
 * The Rdn class represents an RDN as attribute type/value mappings,
 * which can be viewed using
 * {@link javax.naming.directory.Attributes Attributes}.
 * In addition, it contains convenience methods that allow easy retrieval
 * of type and value when the Rdn consist of a single type/value pair,
 * which is how it appears in a typical usage.
 * It also contains helper methods that allow escaping of the unformatted
 * attribute value and unescaping of the value formatted according to the
 * escaping syntax defined in RFC2253. For methods that take or return
 * attribute value as an Object, the value is either a String
 * (in unescaped form) or a byte array.
 * &lt;p&gt;
 * &lt;code&gt;Rdn&lt;/code&gt; will properly parse all valid RDNs, but
 * does not attempt to detect all possible violations when parsing
 * invalid RDNs. It is &quot;generous&quot; in accepting invalid RDNs.
 * The &quot;validity&quot; of a name is determined ultimately when it
 * is supplied to an LDAP server, which may accept or
 * reject the name based on factors such as its schema information
 * and interoperability considerations.
 *
 * &lt;p&gt;
 * The following code example shows how to construct an Rdn using the
 * constructor that takes type and value as arguments:
 * &lt;pre&gt;
 *      Rdn rdn = new Rdn(&quot;cn&quot;, &quot;Juicy, Fruit&quot;);
 *      System.out.println(rdn.toString());
 * &lt;/pre&gt;
 * The last line will print &lt;tt&gt;cn=Juicy\, Fruit&lt;/tt&gt;. The
 * {@link #unescapeValue(String) &lt;tt&gt;unescapeValue()&lt;/tt&gt;} method can be
 * used to unescape the escaped comma resulting in the original
 * value &lt;tt&gt;&quot;Juicy, Fruit&quot;&lt;/tt&gt;. The {@link #escapeValue(Object)
 * &lt;tt&gt;escapeValue()&lt;/tt&gt;} method adds the escape back preceding the comma.
 * &lt;p&gt;
 * This class can be instantiated by a string representation
 * of the RDN defined in RFC 2253 as shown in the following code example:
 * &lt;pre&gt;
 *      Rdn rdn = new Rdn(&quot;cn=Juicy\\, Fruit&quot;);
 *      System.out.println(rdn.toString());
 * &lt;/pre&gt;
 * The last line will print &lt;tt&gt;cn=Juicy\, Fruit&lt;/tt&gt;.
 * &lt;p&gt;
 * Concurrent multithreaded read-only access of an instance of
 * &lt;tt&gt;Rdn&lt;/tt&gt; need not be synchronized.
 * &lt;p&gt;
 * Unless otherwise noted, the behavior of passing a null argument
 * to a constructor or method in this class will cause NullPointerException
 * to be thrown.
 *
 * @since 1.5
 */

public class Rdn implements Serializable, Comparable&lt;Object&gt; {

    private transient ArrayList&lt;RdnEntry&gt; entries;

    // The common case.
    private static final int DEFAULT_SIZE = 1;

    private static final long serialVersionUID = -5994465067210009656L;

    /**
     * Constructs an Rdn from the given attribute set. See
     * {@link javax.naming.directory.Attributes Attributes}.
     * &lt;p&gt;
     * The string attribute values are not interpreted as
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;
     * formatted RDN strings. That is, the values are used
     * literally (not parsed) and assumed to be unescaped.
     *
     * @param attrSet The non-null and non-empty attributes containing
     * type/value mappings.
     * @throws InvalidNameException If contents of &lt;tt&gt;attrSet&lt;/tt&gt; cannot
     *          be used to construct a valid RDN.
     */
<span class="nc" id="L129">    public Rdn(Attributes attrSet) throws InvalidNameException {</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        if (attrSet.size() == 0) {</span>
<span class="nc" id="L131">            throw new InvalidNameException(&quot;Attributes cannot be empty&quot;);</span>
        }
<span class="nc" id="L133">        entries = new ArrayList&lt;&gt;(attrSet.size());</span>
<span class="nc" id="L134">        NamingEnumeration&lt;? extends Attribute&gt; attrs = attrSet.getAll();</span>
        try {
<span class="nc bnc" id="L136" title="All 2 branches missed.">            for (int nEntries = 0; attrs.hasMore(); nEntries++) {</span>
<span class="nc" id="L137">                RdnEntry entry = new RdnEntry();</span>
<span class="nc" id="L138">                Attribute attr = attrs.next();</span>
<span class="nc" id="L139">                entry.type = attr.getID();</span>
<span class="nc" id="L140">                entry.value = attr.get();</span>
<span class="nc" id="L141">                entries.add(nEntries, entry);</span>
            }
<span class="nc" id="L143">        } catch (NamingException e) {</span>
<span class="nc" id="L144">            InvalidNameException e2 = new InvalidNameException(</span>
<span class="nc" id="L145">                                        e.getMessage());</span>
<span class="nc" id="L146">            e2.initCause(e);</span>
<span class="nc" id="L147">            throw e2;</span>
<span class="nc" id="L148">        }</span>
<span class="nc" id="L149">        sort(); // arrange entries for comparison</span>
<span class="nc" id="L150">    }</span>

    /**
     * Constructs an Rdn from the given string.
     * This constructor takes a string formatted according to the rules
     * defined in &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;
     * and described in the class description for
     * {@link javax.naming.ldap.LdapName}.
     *
     * @param rdnString The non-null and non-empty RFC2253 formatted string.
     * @throws InvalidNameException If a syntax error occurs during
     *                  parsing of the rdnString.
     */
<span class="nc" id="L163">    public Rdn(String rdnString) throws InvalidNameException {</span>
<span class="nc" id="L164">        entries = new ArrayList&lt;&gt;(DEFAULT_SIZE);</span>
<span class="nc" id="L165">        (new Rfc2253Parser(rdnString)).parseRdn(this);</span>
<span class="nc" id="L166">    }</span>

    /**
     * Constructs an Rdn from the given &lt;tt&gt;rdn&lt;/tt&gt;.
     * The contents of the &lt;tt&gt;rdn&lt;/tt&gt; are simply copied into the newly
     * created Rdn.
     * @param rdn The non-null Rdn to be copied.
     */
<span class="nc" id="L174">    public Rdn(Rdn rdn) {</span>
<span class="nc" id="L175">        entries = new ArrayList&lt;&gt;(rdn.entries.size());</span>
<span class="nc" id="L176">        entries.addAll(rdn.entries);</span>
<span class="nc" id="L177">    }</span>

    /**
     * Constructs an Rdn from the given attribute type and
     * value.
     * The string attribute values are not interpreted as
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;
     * formatted RDN strings. That is, the values are used
     * literally (not parsed) and assumed to be unescaped.
     *
     * @param type The non-null and non-empty string attribute type.
     * @param value The non-null and non-empty attribute value.
     * @throws InvalidNameException If type/value cannot be used to
     *                  construct a valid RDN.
     * @see #toString()
     */
<span class="nc" id="L193">    public Rdn(String type, Object value) throws InvalidNameException {</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (value == null) {</span>
<span class="nc" id="L195">            throw new NullPointerException(&quot;Cannot set value to null&quot;);</span>
        }
<span class="nc bnc" id="L197" title="All 4 branches missed.">        if (type.equals(&quot;&quot;) || isEmptyValue(value)) {</span>
<span class="nc" id="L198">            throw new InvalidNameException(</span>
                &quot;type or value cannot be empty, type:&quot; + type +
                &quot; value:&quot; + value);
        }
<span class="nc" id="L202">        entries = new ArrayList&lt;&gt;(DEFAULT_SIZE);</span>
<span class="nc" id="L203">        put(type, value);</span>
<span class="nc" id="L204">    }</span>

    private boolean isEmptyValue(Object val) {
<span class="nc bnc" id="L207" title="All 8 branches missed.">        return ((val instanceof String) &amp;&amp; val.equals(&quot;&quot;)) ||</span>
        ((val instanceof byte[]) &amp;&amp; (((byte[]) val).length == 0));
    }

    // An empty constructor used by the parser
<span class="fc" id="L212">    Rdn() {</span>
<span class="fc" id="L213">        entries = new ArrayList&lt;&gt;(DEFAULT_SIZE);</span>
<span class="fc" id="L214">    }</span>

    /*
     * Adds the given attribute type and value to this Rdn.
     * The string attribute values are not interpreted as
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;
     * formatted RDN strings. That is the values are used
     * literally (not parsed) and assumed to be unescaped.
     *
     * @param type The non-null and non-empty string attribute type.
     * @param value The non-null and non-empty attribute value.
     * @return The updated Rdn, not a new one. Cannot be null.
     * @see #toString()
     */
    Rdn put(String type, Object value) {

        // create new Entry
<span class="fc" id="L231">        RdnEntry newEntry = new RdnEntry();</span>
<span class="fc" id="L232">        newEntry.type =  type;</span>
<span class="pc bpc" id="L233" title="1 of 2 branches missed.">        if (value instanceof byte[]) {  // clone the byte array</span>
<span class="nc" id="L234">            newEntry.value = ((byte[]) value).clone();</span>
        } else {
<span class="fc" id="L236">            newEntry.value = value;</span>
        }
<span class="fc" id="L238">        entries.add(newEntry);</span>
<span class="fc" id="L239">        return this;</span>
    }

    void sort() {
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        if (entries.size() &gt; 1) {</span>
<span class="nc" id="L244">            Collections.sort(entries);</span>
        }
<span class="fc" id="L246">    }</span>

    /**
     * Retrieves one of this Rdn's value.
     * This is a convenience method for obtaining the value,
     * when the RDN contains a single type and value mapping,
     * which is the common RDN usage.
     * &lt;p&gt;
     * For a multi-valued RDN, this method returns value corresponding
     * to the type returned by {@link #getType() getType()} method.
     *
     * @return The non-null attribute value.
     */
    public Object getValue() {
<span class="nc" id="L260">        return entries.get(0).getValue();</span>
    }

    /**
     * Retrieves one of this Rdn's type.
     * This is a convenience method for obtaining the type,
     * when the RDN contains a single type and value mapping,
     * which is the common RDN usage.
     * &lt;p&gt;
     * For a multi-valued RDN, the type/value pairs have
     * no specific order defined on them. In that case, this method
     * returns type of one of the type/value pairs.
     * The {@link #getValue() getValue()} method returns the
     * value corresponding to the type returned by this method.
     *
     * @return The non-null attribute type.
     */
    public String getType() {
<span class="nc" id="L278">        return entries.get(0).getType();</span>
    }

    /**
     * Returns this Rdn as a string represented in a format defined by
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt; and described
     * in the class description for {@link javax.naming.ldap.LdapName LdapName}.
     *
     * @return The string representation of the Rdn.
     */
    public String toString() {
<span class="nc" id="L289">        StringBuilder builder = new StringBuilder();</span>
<span class="nc" id="L290">        int size = entries.size();</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (size &gt; 0) {</span>
<span class="nc" id="L292">            builder.append(entries.get(0));</span>
        }
<span class="nc bnc" id="L294" title="All 2 branches missed.">        for (int next = 1; next &lt; size; next++) {</span>
<span class="nc" id="L295">            builder.append('+');</span>
<span class="nc" id="L296">            builder.append(entries.get(next));</span>
        }
<span class="nc" id="L298">        return builder.toString();</span>
    }

    /**
     * Compares this Rdn with the specified Object for order.
     * Returns a negative integer, zero, or a positive integer as this
     * Rdn is less than, equal to, or greater than the given Object.
     * &lt;p&gt;
     * If obj is null or not an instance of Rdn, ClassCastException
     * is thrown.
     * &lt;p&gt;
     * The attribute type and value pairs of the RDNs are lined up
     * against each other and compared lexicographically. The order of
     * components in multi-valued Rdns (such as &quot;ou=Sales+cn=Bob&quot;) is not
     * significant.
     *
     * @param obj The non-null object to compare against.
     * @return  A negative integer, zero, or a positive integer as this Rdn
     *          is less than, equal to, or greater than the given Object.
     * @exception ClassCastException if obj is null or not a Rdn.
     */
    public int compareTo(Object obj) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (!(obj instanceof Rdn)) {</span>
<span class="nc" id="L321">            throw new ClassCastException(&quot;The obj is not a Rdn&quot;);</span>
        }
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (obj == this) {</span>
<span class="nc" id="L324">            return 0;</span>
        }
<span class="nc" id="L326">        Rdn that = (Rdn) obj;</span>
<span class="nc" id="L327">        int minSize = Math.min(entries.size(), that.entries.size());</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        for (int i = 0; i &lt; minSize; i++) {</span>

            // Compare a single pair of type/value pairs.
<span class="nc" id="L331">            int diff = entries.get(i).compareTo(that.entries.get(i));</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">            if (diff != 0) {</span>
<span class="nc" id="L333">                return diff;</span>
            }
        }
<span class="nc" id="L336">        return (entries.size() - that.entries.size());  // longer RDN wins</span>
    }

    /**
     * Compares the specified Object with this Rdn for equality.
     * Returns true if the given object is also a Rdn and the two Rdns
     * represent the same attribute type and value mappings. The order of
     * components in multi-valued Rdns (such as &quot;ou=Sales+cn=Bob&quot;) is not
     * significant.
     * &lt;p&gt;
     * Type and value equality matching is done as below:
     * &lt;ul&gt;
     * &lt;li&gt; The types are compared for equality with their case ignored.
     * &lt;li&gt; String values with different but equivalent usage of quoting,
     * escaping, or UTF8-hex-encoding are considered equal.
     * The case of the values is ignored during the comparison.
     * &lt;/ul&gt;
     * &lt;p&gt;
     * If obj is null or not an instance of Rdn, false is returned.
     * &lt;p&gt;
     * @param obj object to be compared for equality with this Rdn.
     * @return true if the specified object is equal to this Rdn.
     * @see #hashCode()
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L361" title="All 2 branches missed.">        if (obj == this) {</span>
<span class="nc" id="L362">            return true;</span>
        }
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (!(obj instanceof Rdn)) {</span>
<span class="nc" id="L365">            return false;</span>
        }
<span class="nc" id="L367">        Rdn that = (Rdn) obj;</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (entries.size() != that.size()) {</span>
<span class="nc" id="L369">            return false;</span>
        }
<span class="nc bnc" id="L371" title="All 2 branches missed.">        for (int i = 0; i &lt; entries.size(); i++) {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (!entries.get(i).equals(that.entries.get(i))) {</span>
<span class="nc" id="L373">                return false;</span>
            }
        }
<span class="nc" id="L376">        return true;</span>
    }

    /**
     * Returns the hash code of this RDN. Two RDNs that are
     * equal (according to the equals method) will have the same
     * hash code.
     *
     * @return An int representing the hash code of this Rdn.
     * @see #equals
     */
    public int hashCode() {

        // Sum up the hash codes of the components.
<span class="nc" id="L390">        int hash = 0;</span>

        // For each type/value pair...
<span class="nc bnc" id="L393" title="All 2 branches missed.">        for (int i = 0; i &lt; entries.size(); i++) {</span>
<span class="nc" id="L394">            hash += entries.get(i).hashCode();</span>
        }
<span class="nc" id="L396">        return hash;</span>
    }

    /**
     * Retrieves the {@link javax.naming.directory.Attributes Attributes}
     * view of the type/value mappings contained in this Rdn.
     *
     * @return  The non-null attributes containing the type/value
     *          mappings of this Rdn.
     */
    public Attributes toAttributes() {
<span class="nc" id="L407">        Attributes attrs = new BasicAttributes(true);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">        for (int i = 0; i &lt; entries.size(); i++) {</span>
<span class="nc" id="L409">            RdnEntry entry = entries.get(i);</span>
<span class="nc" id="L410">            Attribute attr = attrs.put(entry.getType(), entry.getValue());</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (attr != null) {</span>
<span class="nc" id="L412">                attr.add(entry.getValue());</span>
<span class="nc" id="L413">                attrs.put(attr);</span>
            }
        }
<span class="nc" id="L416">        return attrs;</span>
    }


<span class="fc" id="L420">    private static class RdnEntry implements Comparable&lt;RdnEntry&gt; {</span>
        private String type;
        private Object value;

        // If non-null, a cannonical representation of the value suitable
        // for comparison using String.compareTo()
<span class="fc" id="L426">        private String comparable = null;</span>

        String getType() {
<span class="nc" id="L429">            return type;</span>
        }

        Object getValue() {
<span class="nc" id="L433">            return value;</span>
        }

        public int compareTo(RdnEntry that) {
<span class="nc" id="L437">            int diff = type.compareToIgnoreCase(that.type);</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (diff != 0) {</span>
<span class="nc" id="L439">                return diff;</span>
            }
<span class="nc bnc" id="L441" title="All 2 branches missed.">            if (value.equals(that.value)) {     // try shortcut</span>
<span class="nc" id="L442">                return 0;</span>
            }
<span class="nc" id="L444">            return getValueComparable().compareTo(</span>
<span class="nc" id="L445">                        that.getValueComparable());</span>
        }

        public boolean equals(Object obj) {
<span class="nc bnc" id="L449" title="All 2 branches missed.">            if (obj == this) {</span>
<span class="nc" id="L450">                return true;</span>
            }
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (!(obj instanceof RdnEntry)) {</span>
<span class="nc" id="L453">                return false;</span>
            }

            // Any change here must be reflected in hashCode()
<span class="nc" id="L457">            RdnEntry that = (RdnEntry) obj;</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">            return (type.equalsIgnoreCase(that.type)) &amp;&amp;</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">                        (getValueComparable().equals(</span>
<span class="nc" id="L460">                        that.getValueComparable()));</span>
        }

        public int hashCode() {
<span class="nc" id="L464">            return (type.toUpperCase(Locale.ENGLISH).hashCode() +</span>
<span class="nc" id="L465">                getValueComparable().hashCode());</span>
        }

        public String toString() {
<span class="nc" id="L469">            return type + &quot;=&quot; + escapeValue(value);</span>
        }

        private String getValueComparable() {
<span class="nc bnc" id="L473" title="All 2 branches missed.">            if (comparable != null) {</span>
<span class="nc" id="L474">                return comparable;              // return cached result</span>
            }

            // cache result
<span class="nc bnc" id="L478" title="All 2 branches missed.">            if (value instanceof byte[]) {</span>
<span class="nc" id="L479">                comparable = escapeBinaryValue((byte[]) value);</span>
            } else {
<span class="nc" id="L481">                comparable = ((String) value).toUpperCase(Locale.ENGLISH);</span>
            }
<span class="nc" id="L483">            return comparable;</span>
        }
    }

    /**
     * Retrieves the number of attribute type/value pairs in this Rdn.
     * @return The non-negative number of type/value pairs in this Rdn.
     */
    public int size() {
<span class="nc" id="L492">        return entries.size();</span>
    }

    /**
     * Given the value of an attribute, returns a string escaped according
     * to the rules specified in
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;.
     * &lt;p&gt;
     * For example, if the val is &quot;Sue, Grabbit and Runn&quot;, the escaped
     * value returned by this method is &quot;Sue\, Grabbit and Runn&quot;.
     * &lt;p&gt;
     * A string value is represented as a String and binary value
     * as a byte array.
     *
     * @param val The non-null object to be escaped.
     * @return Escaped string value.
     * @throws ClassCastException if val is is not a String or byte array.
     */
    public static String escapeValue(Object val) {
<span class="nc bnc" id="L511" title="All 2 branches missed.">        return (val instanceof byte[])</span>
<span class="nc" id="L512">                ? escapeBinaryValue((byte[])val)</span>
<span class="nc" id="L513">                : escapeStringValue((String)val);</span>
    }

    /*
     * Given the value of a string-valued attribute, returns a
     * string suitable for inclusion in a DN.  This is accomplished by
     * using backslash (\) to escape the following characters:
     *  leading and trailing whitespace
     *  , = + &lt; &gt; # ; &quot; \
     */
    private static final String escapees = &quot;,=+&lt;&gt;#;\&quot;\\&quot;;

    private static String escapeStringValue(String val) {

<span class="nc" id="L527">            char[] chars = val.toCharArray();</span>
<span class="nc" id="L528">            StringBuilder builder = new StringBuilder(2 * val.length());</span>

            // Find leading and trailing whitespace.
            int lead;   // index of first char that is not leading whitespace
<span class="nc bnc" id="L532" title="All 2 branches missed.">            for (lead = 0; lead &lt; chars.length; lead++) {</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                if (!isWhitespace(chars[lead])) {</span>
<span class="nc" id="L534">                    break;</span>
                }
            }
            int trail;  // index of last char that is not trailing whitespace
<span class="nc bnc" id="L538" title="All 2 branches missed.">            for (trail = chars.length - 1; trail &gt;= 0; trail--) {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">                if (!isWhitespace(chars[trail])) {</span>
<span class="nc" id="L540">                    break;</span>
                }
            }

<span class="nc bnc" id="L544" title="All 2 branches missed.">            for (int i = 0; i &lt; chars.length; i++) {</span>
<span class="nc" id="L545">                char c = chars[i];</span>
<span class="nc bnc" id="L546" title="All 6 branches missed.">                if ((i &lt; lead) || (i &gt; trail) || (escapees.indexOf(c) &gt;= 0)) {</span>
<span class="nc" id="L547">                    builder.append('\\');</span>
                }
<span class="nc" id="L549">                builder.append(c);</span>
            }
<span class="nc" id="L551">            return builder.toString();</span>
    }

    /*
     * Given the value of a binary attribute, returns a string
     * suitable for inclusion in a DN (such as &quot;#CEB1DF80&quot;).
     * TBD: This method should actually generate the ber encoding
     * of the binary value
     */
    private static String escapeBinaryValue(byte[] val) {

<span class="nc" id="L562">        StringBuilder builder = new StringBuilder(1 + 2 * val.length);</span>
<span class="nc" id="L563">        builder.append(&quot;#&quot;);</span>

<span class="nc bnc" id="L565" title="All 2 branches missed.">        for (int i = 0; i &lt; val.length; i++) {</span>
<span class="nc" id="L566">            byte b = val[i];</span>
<span class="nc" id="L567">            builder.append(Character.forDigit(0xF &amp; (b &gt;&gt;&gt; 4), 16));</span>
<span class="nc" id="L568">            builder.append(Character.forDigit(0xF &amp; b, 16));</span>
        }
<span class="nc" id="L570">        return builder.toString();</span>
    }

    /**
     * Given an attribute value string formated according to the rules
     * specified in
     * &lt;a href=&quot;http://www.ietf.org/rfc/rfc2253.txt&quot;&gt;RFC 2253&lt;/a&gt;,
     * returns the unformated value.  Escapes and quotes are
     * stripped away, and hex-encoded UTF-8 is converted to equivalent
     * UTF-16 characters. Returns a string value as a String, and a
     * binary value as a byte array.
     * &lt;p&gt;
     * Legal and illegal values are defined in RFC 2253.
     * This method is generous in accepting the values and does not
     * catch all illegal values.
     * Therefore, passing in an illegal value might not necessarily
     * trigger an &lt;tt&gt;IllegalArgumentException&lt;/tt&gt;.
     *
     * @param   val     The non-null string to be unescaped.
     * @return          Unescaped value.
     * @throws          IllegalArgumentException When an Illegal value
     *                  is provided.
     */
    public static Object unescapeValue(String val) {

<span class="fc" id="L595">            char[] chars = val.toCharArray();</span>
<span class="fc" id="L596">            int beg = 0;</span>
<span class="fc" id="L597">            int end = chars.length;</span>

            // Trim off leading and trailing whitespace.
<span class="pc bpc" id="L600" title="2 of 4 branches missed.">            while ((beg &lt; end) &amp;&amp; isWhitespace(chars[beg])) {</span>
<span class="nc" id="L601">                ++beg;</span>
            }

<span class="pc bpc" id="L604" title="2 of 4 branches missed.">            while ((beg &lt; end) &amp;&amp; isWhitespace(chars[end - 1])) {</span>
<span class="nc" id="L605">                --end;</span>
            }

            // Add back the trailing whitespace with a preceding '\'
            // (escaped or unescaped) that was taken off in the above
            // loop. Whether or not to retain this whitespace is decided below.
<span class="pc bpc" id="L611" title="5 of 6 branches missed.">            if (end != chars.length &amp;&amp;</span>
                    (beg &lt; end) &amp;&amp;
                    chars[end - 1] == '\\') {
<span class="nc" id="L614">                end++;</span>
            }
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">            if (beg &gt;= end) {</span>
<span class="nc" id="L617">                return &quot;&quot;;</span>
            }

<span class="pc bpc" id="L620" title="1 of 2 branches missed.">            if (chars[beg] == '#') {</span>
                // Value is binary (eg: &quot;#CEB1DF80&quot;).
<span class="nc" id="L622">                return decodeHexPairs(chars, ++beg, end);</span>
            }

            // Trim off quotes.
<span class="pc bpc" id="L626" title="3 of 4 branches missed.">            if ((chars[beg] == '\&quot;') &amp;&amp; (chars[end - 1] == '\&quot;')) {</span>
<span class="nc" id="L627">                ++beg;</span>
<span class="nc" id="L628">                --end;</span>
            }

<span class="fc" id="L631">            StringBuilder builder = new StringBuilder(end - beg);</span>
<span class="fc" id="L632">            int esc = -1; // index of the last escaped character</span>

<span class="fc bfc" id="L634" title="All 2 branches covered.">            for (int i = beg; i &lt; end; i++) {</span>
<span class="pc bpc" id="L635" title="3 of 4 branches missed.">                if ((chars[i] == '\\') &amp;&amp; (i + 1 &lt; end)) {</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">                    if (!Character.isLetterOrDigit(chars[i + 1])) {</span>
<span class="nc" id="L637">                        ++i;                            // skip backslash</span>
<span class="nc" id="L638">                        builder.append(chars[i]);       // snarf escaped char</span>
<span class="nc" id="L639">                        esc = i;</span>
                    } else {

                        // Convert hex-encoded UTF-8 to 16-bit chars.
<span class="nc" id="L643">                        byte[] utf8 = getUtf8Octets(chars, i, end);</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">                        if (utf8.length &gt; 0) {</span>
                            try {
<span class="nc" id="L646">                                builder.append(new String(utf8, &quot;UTF8&quot;));</span>
<span class="nc" id="L647">                            } catch (java.io.UnsupportedEncodingException e) {</span>
                                // shouldn't happen
<span class="nc" id="L649">                            }</span>
<span class="nc" id="L650">                            i += utf8.length * 3 - 1;</span>
                        } else { // no utf8 bytes available, invalid DN

                            // '/' has no meaning, throw exception
<span class="nc" id="L654">                            throw new IllegalArgumentException(</span>
                                &quot;Not a valid attribute string value:&quot; +
                                val + &quot;,improper usage of backslash&quot;);
                        }
<span class="nc" id="L658">                    }</span>
                } else {
<span class="fc" id="L660">                    builder.append(chars[i]);   // snarf unescaped char</span>
                }
            }

            // Get rid of the unescaped trailing whitespace with the
            // preceding '\' character that was previously added back.
<span class="fc" id="L666">            int len = builder.length();</span>
<span class="pc bpc" id="L667" title="3 of 4 branches missed.">            if (isWhitespace(builder.charAt(len - 1)) &amp;&amp; esc != (end - 1)) {</span>
<span class="nc" id="L668">                builder.setLength(len - 1);</span>
            }
<span class="fc" id="L670">            return builder.toString();</span>
        }


        /*
         * Given an array of chars (with starting and ending indexes into it)
         * representing bytes encoded as hex-pairs (such as &quot;CEB1DF80&quot;),
         * returns a byte array containing the decoded bytes.
         */
        private static byte[] decodeHexPairs(char[] chars, int beg, int end) {
<span class="nc" id="L680">            byte[] bytes = new byte[(end - beg) / 2];</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">            for (int i = 0; beg + 1 &lt; end; i++) {</span>
<span class="nc" id="L682">                int hi = Character.digit(chars[beg], 16);</span>
<span class="nc" id="L683">                int lo = Character.digit(chars[beg + 1], 16);</span>
<span class="nc bnc" id="L684" title="All 4 branches missed.">                if (hi &lt; 0 || lo &lt; 0) {</span>
<span class="nc" id="L685">                    break;</span>
                }
<span class="nc" id="L687">                bytes[i] = (byte)((hi&lt;&lt;4) + lo);</span>
<span class="nc" id="L688">                beg += 2;</span>
            }
<span class="nc bnc" id="L690" title="All 2 branches missed.">            if (beg != end) {</span>
<span class="nc" id="L691">                throw new IllegalArgumentException(</span>
                        &quot;Illegal attribute value: &quot; + new String(chars));
            }
<span class="nc" id="L694">            return bytes;</span>
        }

        /*
         * Given an array of chars (with starting and ending indexes into it),
         * finds the largest prefix consisting of hex-encoded UTF-8 octets,
         * and returns a byte array containing the corresponding UTF-8 octets.
         *
         * Hex-encoded UTF-8 octets look like this:
         *      \03\B1\DF\80
         */
        private static byte[] getUtf8Octets(char[] chars, int beg, int end) {
<span class="nc" id="L706">            byte[] utf8 = new byte[(end - beg) / 3];    // allow enough room</span>
<span class="nc" id="L707">            int len = 0;        // index of first unused byte in utf8</span>

<span class="nc bnc" id="L709" title="All 4 branches missed.">            while ((beg + 2 &lt; end) &amp;&amp;</span>
                   (chars[beg++] == '\\')) {
<span class="nc" id="L711">                int hi = Character.digit(chars[beg++], 16);</span>
<span class="nc" id="L712">                int lo = Character.digit(chars[beg++], 16);</span>
<span class="nc bnc" id="L713" title="All 4 branches missed.">                if (hi &lt; 0 || lo &lt; 0) {</span>
<span class="nc" id="L714">                   break;</span>
                }
<span class="nc" id="L716">                utf8[len++] = (byte)((hi&lt;&lt;4) + lo);</span>
<span class="nc" id="L717">            }</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">            if (len == utf8.length) {</span>
<span class="nc" id="L719">                return utf8;</span>
            } else {
<span class="nc" id="L721">                byte[] res = new byte[len];</span>
<span class="nc" id="L722">                System.arraycopy(utf8, 0, res, 0, len);</span>
<span class="nc" id="L723">                return res;</span>
            }
        }

    /*
     * Best guess as to what RFC 2253 means by &quot;whitespace&quot;.
     */
    private static boolean isWhitespace(char c) {
<span class="pc bpc" id="L731" title="2 of 4 branches missed.">        return (c == ' ' || c == '\r');</span>
    }

    /**
     * Serializes only the unparsed RDN, for compactness and to avoid
     * any implementation dependency.
     *
     * @serialData      The RDN string
     */
    private void writeObject(ObjectOutputStream s)
            throws java.io.IOException {
<span class="nc" id="L742">        s.defaultWriteObject();</span>
<span class="nc" id="L743">        s.writeObject(toString());</span>
<span class="nc" id="L744">    }</span>

    private void readObject(ObjectInputStream s)
            throws IOException, ClassNotFoundException {
<span class="nc" id="L748">        s.defaultReadObject();</span>
<span class="nc" id="L749">        entries = new ArrayList&lt;&gt;(DEFAULT_SIZE);</span>
<span class="nc" id="L750">        String unparsed = (String) s.readObject();</span>
        try {
<span class="nc" id="L752">            (new Rfc2253Parser(unparsed)).parseRdn(this);</span>
<span class="nc" id="L753">        } catch (InvalidNameException e) {</span>
            // shouldn't happen
<span class="nc" id="L755">            throw new java.io.StreamCorruptedException(</span>
                    &quot;Invalid name: &quot; + unparsed);
<span class="nc" id="L757">        }</span>
<span class="nc" id="L758">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>