<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>Track.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.sound.midi</a> &gt; <span class="el_source">Track.java</span></div><h1>Track.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.sound.midi;

import java.util.Vector;
import java.util.ArrayList;
import java.util.HashSet;
import com.sun.media.sound.MidiUtils;

/**
 * A MIDI track is an independent stream of MIDI events (time-stamped MIDI
 * data) that can be stored along with other tracks in a standard MIDI file.
 * The MIDI specification allows only 16 channels of MIDI data, but tracks
 * are a way to get around this limitation.  A MIDI file can contain any number
 * of tracks, each containing its own stream of up to 16 channels of MIDI data.
 * &lt;p&gt;
 * A &lt;code&gt;Track&lt;/code&gt; occupies a middle level in the hierarchy of data played
 * by a &lt;code&gt;{@link Sequencer}&lt;/code&gt;: sequencers play sequences, which contain tracks,
 * which contain MIDI events.  A sequencer may provide controls that mute
 * or solo individual tracks.
 * &lt;p&gt;
 * The timing information and resolution for a track is controlled by and stored
 * in the sequence containing the track. A given &lt;code&gt;Track&lt;/code&gt;
 * is considered to belong to the particular &lt;code&gt;{@link Sequence}&lt;/code&gt; that
 * maintains its timing. For this reason, a new (empty) track is created by calling the
 * &lt;code&gt;{@link Sequence#createTrack}&lt;/code&gt; method, rather than by directly invoking a
 * &lt;code&gt;Track&lt;/code&gt; constructor.
 * &lt;p&gt;
 * The &lt;code&gt;Track&lt;/code&gt; class provides methods to edit the track by adding
 * or removing &lt;code&gt;MidiEvent&lt;/code&gt; objects from it.  These operations keep
 * the event list in the correct time order.  Methods are also
 * included to obtain the track's size, in terms of either the number of events
 * it contains or its duration in ticks.
 *
 * @see Sequencer#setTrackMute
 * @see Sequencer#setTrackSolo
 *
 * @author Kara Kytle
 * @author Florian Bomers
 */
public class Track {

    // TODO: use arrays for faster access

    // the list containing the events
<span class="nc" id="L69">    private ArrayList eventsList = new ArrayList();</span>

    // use a hashset to detect duplicate events in add(MidiEvent)
<span class="nc" id="L72">    private HashSet set = new HashSet();</span>

    private MidiEvent eotEvent;


    /**
     * Package-private constructor.  Constructs a new, empty Track object,
     * which initially contains one event, the meta-event End of Track.
     */
<span class="nc" id="L81">    Track() {</span>
        // start with the end of track event
<span class="nc" id="L83">        MetaMessage eot = new ImmutableEndOfTrack();</span>
<span class="nc" id="L84">        eotEvent = new MidiEvent(eot, 0);</span>
<span class="nc" id="L85">        eventsList.add(eotEvent);</span>
<span class="nc" id="L86">        set.add(eotEvent);</span>
<span class="nc" id="L87">    }</span>

    /**
     * Adds a new event to the track.  However, if the event is already
     * contained in the track, it is not added again.  The list of events
     * is kept in time order, meaning that this event inserted at the
     * appropriate place in the list, not necessarily at the end.
     *
     * @param event the event to add
     * @return &lt;code&gt;true&lt;/code&gt; if the event did not already exist in the
     * track and was added, otherwise &lt;code&gt;false&lt;/code&gt;
     */
    public boolean add(MidiEvent event) {
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (event == null) {</span>
<span class="nc" id="L101">            return false;</span>
        }
<span class="nc" id="L103">        synchronized(eventsList) {</span>

<span class="nc bnc" id="L105" title="All 2 branches missed.">            if (!set.contains(event)) {</span>
<span class="nc" id="L106">                int eventsCount = eventsList.size();</span>

                // get the last event
<span class="nc" id="L109">                MidiEvent lastEvent = null;</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">                if (eventsCount &gt; 0) {</span>
<span class="nc" id="L111">                    lastEvent = (MidiEvent) eventsList.get(eventsCount - 1);</span>
                }
                // sanity check that we have a correct end-of-track
<span class="nc bnc" id="L114" title="All 2 branches missed.">                if (lastEvent != eotEvent) {</span>
                    // if there is no eot event, add our immutable instance again
<span class="nc bnc" id="L116" title="All 2 branches missed.">                    if (lastEvent != null) {</span>
                        // set eotEvent's tick to the last tick of the track
<span class="nc" id="L118">                        eotEvent.setTick(lastEvent.getTick());</span>
                    } else {
                        // if the events list is empty, just set the tick to 0
<span class="nc" id="L121">                        eotEvent.setTick(0);</span>
                    }
                    // we needn't check for a duplicate of eotEvent in &quot;eventsList&quot;,
                    // since then it would appear in the set.
<span class="nc" id="L125">                    eventsList.add(eotEvent);</span>
<span class="nc" id="L126">                    set.add(eotEvent);</span>
<span class="nc" id="L127">                    eventsCount = eventsList.size();</span>
                }

                // first see if we are trying to add
                // and endoftrack event.
<span class="nc bnc" id="L132" title="All 2 branches missed.">                if (MidiUtils.isMetaEndOfTrack(event.getMessage())) {</span>
                    // since end of track event is useful
                    // for delays at the end of a track, we want to keep
                    // the tick value requested here if it is greater
                    // than the one on the eot we are maintaining.
                    // Otherwise, we only want a single eot event, so ignore.
<span class="nc bnc" id="L138" title="All 2 branches missed.">                    if (event.getTick() &gt; eotEvent.getTick()) {</span>
<span class="nc" id="L139">                        eotEvent.setTick(event.getTick());</span>
                    }
<span class="nc" id="L141">                    return true;</span>
                }

                // prevent duplicates
<span class="nc" id="L145">                set.add(event);</span>

                // insert event such that events is sorted in increasing
                // tick order
<span class="nc" id="L149">                int i = eventsCount;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">                for ( ; i &gt; 0; i--) {</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">                    if (event.getTick() &gt;= ((MidiEvent)eventsList.get(i-1)).getTick()) {</span>
<span class="nc" id="L152">                        break;</span>
                    }
                }
<span class="nc bnc" id="L155" title="All 2 branches missed.">                if (i == eventsCount) {</span>
                    // we're adding an event after the
                    // tick value of our eot, so push the eot out.
                    // Always add at the end for better performance:
                    // this saves all the checks and arraycopy when inserting

                    // overwrite eot with new event
<span class="nc" id="L162">                    eventsList.set(eventsCount - 1, event);</span>
                    // set new time of eot, if necessary
<span class="nc bnc" id="L164" title="All 2 branches missed.">                    if (eotEvent.getTick() &lt; event.getTick()) {</span>
<span class="nc" id="L165">                        eotEvent.setTick(event.getTick());</span>
                    }
                    // add eot again at the end
<span class="nc" id="L168">                    eventsList.add(eotEvent);</span>
                } else {
<span class="nc" id="L170">                    eventsList.add(i, event);</span>
                }
<span class="nc" id="L172">                return true;</span>
            }
<span class="nc" id="L174">        }</span>

<span class="nc" id="L176">        return false;</span>
    }


    /**
     * Removes the specified event from the track.
     * @param event the event to remove
     * @return &lt;code&gt;true&lt;/code&gt; if the event existed in the track and was removed,
     * otherwise &lt;code&gt;false&lt;/code&gt;
     */
    public boolean remove(MidiEvent event) {

        // this implementation allows removing the EOT event.
        // pretty bad, but would probably be too risky to
        // change behavior now, in case someone does tricks like:
        //
        // while (track.size() &gt; 0) track.remove(track.get(track.size() - 1));

        // also, would it make sense to adjust the EOT's time
        // to the last event, if the last non-EOT event is removed?
        // Or: document that the ticks() length will not be reduced
        // by deleting events (unless the EOT event is removed)
<span class="nc" id="L198">        synchronized(eventsList) {</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">            if (set.remove(event)) {</span>
<span class="nc" id="L200">                int i = eventsList.indexOf(event);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (i &gt;= 0) {</span>
<span class="nc" id="L202">                    eventsList.remove(i);</span>
<span class="nc" id="L203">                    return true;</span>
                }
            }
<span class="nc" id="L206">        }</span>
<span class="nc" id="L207">        return false;</span>
    }


    /**
     * Obtains the event at the specified index.
     * @param index the location of the desired event in the event vector
     * @throws ArrayIndexOutOfBoundsException  if the
     * specified index is negative or not less than the current size of
     * this track.
     * @see #size
     * @return the event at the specified index
     */
    public MidiEvent get(int index) throws ArrayIndexOutOfBoundsException {
        try {
<span class="nc" id="L222">            synchronized(eventsList) {</span>
<span class="nc" id="L223">                return (MidiEvent)eventsList.get(index);</span>
<span class="nc" id="L224">            }</span>
<span class="nc" id="L225">        } catch (IndexOutOfBoundsException ioobe) {</span>
<span class="nc" id="L226">            throw new ArrayIndexOutOfBoundsException(ioobe.getMessage());</span>
        }
    }


    /**
     * Obtains the number of events in this track.
     * @return the size of the track's event vector
     */
    public int size() {
<span class="nc" id="L236">        synchronized(eventsList) {</span>
<span class="nc" id="L237">            return eventsList.size();</span>
<span class="nc" id="L238">        }</span>
    }


    /**
     * Obtains the length of the track, expressed in MIDI ticks.  (The
     * duration of a tick in seconds is determined by the timing resolution
     * of the &lt;code&gt;Sequence&lt;/code&gt; containing this track, and also by
     * the tempo of the music as set by the sequencer.)
     * @return the duration, in ticks
     * @see Sequence#Sequence(float, int)
     * @see Sequencer#setTempoInBPM(float)
     * @see Sequencer#getTickPosition()
     */
    public long ticks() {
<span class="nc" id="L253">        long ret = 0;</span>
<span class="nc" id="L254">        synchronized (eventsList) {</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">            if (eventsList.size() &gt; 0) {</span>
<span class="nc" id="L256">                ret = ((MidiEvent)eventsList.get(eventsList.size() - 1)).getTick();</span>
            }
<span class="nc" id="L258">        }</span>
<span class="nc" id="L259">        return ret;</span>
    }

    private static class ImmutableEndOfTrack extends MetaMessage {
        private ImmutableEndOfTrack() {
<span class="nc" id="L264">            super(new byte[3]);</span>
<span class="nc" id="L265">            data[0] = (byte) META;</span>
<span class="nc" id="L266">            data[1] = MidiUtils.META_END_OF_TRACK_TYPE;</span>
<span class="nc" id="L267">            data[2] = 0;</span>
<span class="nc" id="L268">        }</span>

        public void setMessage(int type, byte[] data, int length) throws InvalidMidiDataException {
<span class="nc" id="L271">            throw new InvalidMidiDataException(&quot;cannot modify end of track message&quot;);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>