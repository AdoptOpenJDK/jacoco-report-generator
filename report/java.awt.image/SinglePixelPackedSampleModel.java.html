<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>SinglePixelPackedSampleModel.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">SinglePixelPackedSampleModel.java</span></div><h1>SinglePixelPackedSampleModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/* ****************************************************************
 ******************************************************************
 ******************************************************************
 *** COPYRIGHT (c) Eastman Kodak Company, 1997
 *** As  an unpublished  work pursuant to Title 17 of the United
 *** States Code.  All rights reserved.
 ******************************************************************
 ******************************************************************
 ******************************************************************/

package java.awt.image;

import java.util.Arrays;

/**
 *  This class represents pixel data packed such that the N samples which make
 *  up a single pixel are stored in a single data array element, and each data
 *  data array element holds samples for only one pixel.
 *  This class supports
 *  {@link DataBuffer#TYPE_BYTE TYPE_BYTE},
 *  {@link DataBuffer#TYPE_USHORT TYPE_USHORT},
 *  {@link DataBuffer#TYPE_INT TYPE_INT} data types.
 *  All data array elements reside
 *  in the first bank of a DataBuffer.  Accessor methods are provided so
 *  that the image data can be manipulated directly. Scanline stride is the
 *  number of data array elements between a given sample and the corresponding
 *  sample in the same column of the next scanline. Bit masks are the masks
 *  required to extract the samples representing the bands of the pixel.
 *  Bit offsets are the offsets in bits into the data array
 *  element of the samples representing the bands of the pixel.
 * &lt;p&gt;
 * The following code illustrates extracting the bits of the sample
 * representing band &lt;code&gt;b&lt;/code&gt; for pixel &lt;code&gt;x,y&lt;/code&gt;
 * from DataBuffer &lt;code&gt;data&lt;/code&gt;:
 * &lt;pre&gt;{@code
 *      int sample = data.getElem(y * scanlineStride + x);
 *      sample = (sample &amp; bitMasks[b]) &gt;&gt;&gt; bitOffsets[b];
 * }&lt;/pre&gt;
 */

public class SinglePixelPackedSampleModel extends SampleModel
{
    /** Bit masks for all bands of the image data. */
    private int bitMasks[];

    /** Bit Offsets for all bands of the image data. */
    private int bitOffsets[];

    /** Bit sizes for all the bands of the image data. */
    private int bitSizes[];

    /** Maximum bit size. */
    private int maxBitSize;

    /** Line stride of the region of image data described by this
     *  SinglePixelPackedSampleModel.
     */
    private int scanlineStride;

    private static native void initIDs();
    static {
<span class="nc" id="L87">        ColorModel.loadLibraries();</span>
<span class="nc" id="L88">        initIDs();</span>
<span class="nc" id="L89">    }</span>

    /**
     * Constructs a SinglePixelPackedSampleModel with bitMasks.length bands.
     * Each sample is stored in a data array element in the position of
     * its corresponding bit mask.  Each bit mask must be contiguous and
     * masks must not overlap. Bit masks exceeding data type capacity are
     * truncated.
     * @param dataType  The data type for storing samples.
     * @param w         The width (in pixels) of the region of the
     *                  image data described.
     * @param h         The height (in pixels) of the region of the
     *                  image data described.
     * @param bitMasks  The bit masks for all bands.
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         either &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     *         &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     */
    public SinglePixelPackedSampleModel(int dataType, int w, int h,
                                   int bitMasks[]) {
<span class="nc" id="L110">        this(dataType, w, h, w, bitMasks);</span>
<span class="nc bnc" id="L111" title="All 6 branches missed.">        if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;</span>
            dataType != DataBuffer.TYPE_USHORT &amp;&amp;
            dataType != DataBuffer.TYPE_INT) {
<span class="nc" id="L114">            throw new IllegalArgumentException(&quot;Unsupported data type &quot;+</span>
                                               dataType);
        }
<span class="nc" id="L117">    }</span>

    /**
     * Constructs a SinglePixelPackedSampleModel with bitMasks.length bands
     * and a scanline stride equal to scanlineStride data array elements.
     * Each sample is stored in a data array element in the position of
     * its corresponding bit mask.  Each bit mask must be contiguous and
     * masks must not overlap. Bit masks exceeding data type capacity are
     * truncated.
     * @param dataType  The data type for storing samples.
     * @param w         The width (in pixels) of the region of
     *                  image data described.
     * @param h         The height (in pixels) of the region of
     *                  image data described.
     * @param scanlineStride The line stride of the image data.
     * @param bitMasks The bit masks for all bands.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     * @throws IllegalArgumentException if any mask in
     *         &lt;code&gt;bitMask&lt;/code&gt; is not contiguous
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         either &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     *         &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     */
    public SinglePixelPackedSampleModel(int dataType, int w, int h,
                                   int scanlineStride, int bitMasks[]) {
<span class="nc" id="L144">        super(dataType, w, h, bitMasks.length);</span>
<span class="nc bnc" id="L145" title="All 6 branches missed.">        if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;</span>
            dataType != DataBuffer.TYPE_USHORT &amp;&amp;
            dataType != DataBuffer.TYPE_INT) {
<span class="nc" id="L148">            throw new IllegalArgumentException(&quot;Unsupported data type &quot;+</span>
                                               dataType);
        }
<span class="nc" id="L151">        this.dataType = dataType;</span>
<span class="nc" id="L152">        this.bitMasks = (int[]) bitMasks.clone();</span>
<span class="nc" id="L153">        this.scanlineStride = scanlineStride;</span>

<span class="nc" id="L155">        this.bitOffsets = new int[numBands];</span>
<span class="nc" id="L156">        this.bitSizes = new int[numBands];</span>

<span class="nc" id="L158">        int maxMask = (int)((1L &lt;&lt; DataBuffer.getDataTypeSize(dataType)) - 1);</span>

<span class="nc" id="L160">        this.maxBitSize = 0;</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">        for (int i=0; i&lt;numBands; i++) {</span>
<span class="nc" id="L162">            int bitOffset = 0, bitSize = 0, mask;</span>
<span class="nc" id="L163">            this.bitMasks[i] &amp;= maxMask;</span>
<span class="nc" id="L164">            mask = this.bitMasks[i];</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">            if (mask != 0) {</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">                while ((mask &amp; 1) == 0) {</span>
<span class="nc" id="L167">                    mask = mask &gt;&gt;&gt; 1;</span>
<span class="nc" id="L168">                    bitOffset++;</span>
                }
<span class="nc bnc" id="L170" title="All 2 branches missed.">                while ((mask &amp; 1) == 1) {</span>
<span class="nc" id="L171">                    mask = mask &gt;&gt;&gt; 1;</span>
<span class="nc" id="L172">                    bitSize++;</span>
                }
<span class="nc bnc" id="L174" title="All 2 branches missed.">                if (mask != 0) {</span>
<span class="nc" id="L175">                    throw new IllegalArgumentException(&quot;Mask &quot;+bitMasks[i]+</span>
                                                       &quot; must be contiguous&quot;);
                }
            }
<span class="nc" id="L179">            bitOffsets[i] = bitOffset;</span>
<span class="nc" id="L180">            bitSizes[i] = bitSize;</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">            if (bitSize &gt; maxBitSize) {</span>
<span class="nc" id="L182">                maxBitSize = bitSize;</span>
            }
        }
<span class="nc" id="L185">    }</span>

    /**
     * Returns the number of data elements needed to transfer one pixel
     * via the getDataElements and setDataElements methods.
     * For a SinglePixelPackedSampleModel, this is one.
     */
    public int getNumDataElements() {
<span class="nc" id="L193">        return 1;</span>
    }

    /**
     * Returns the size of the buffer (in data array elements)
     * needed for a data buffer that matches this
     * SinglePixelPackedSampleModel.
     */
    private long getBufferSize() {
<span class="nc" id="L202">      long size = scanlineStride * (height-1) + width;</span>
<span class="nc" id="L203">      return size;</span>
    }

    /**
     * Creates a new SinglePixelPackedSampleModel with the specified
     * width and height.  The new SinglePixelPackedSampleModel will have the
     * same storage data type and bit masks as this
     * SinglePixelPackedSampleModel.
     * @param w the width of the resulting &lt;code&gt;SampleModel&lt;/code&gt;
     * @param h the height of the resulting &lt;code&gt;SampleModel&lt;/code&gt;
     * @return a &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; with the
     *         specified width and height.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     */
    public SampleModel createCompatibleSampleModel(int w, int h) {
<span class="nc" id="L219">      SampleModel sampleModel = new SinglePixelPackedSampleModel(dataType, w, h,</span>
                                                              bitMasks);
<span class="nc" id="L221">      return sampleModel;</span>
    }

    /**
     * Creates a DataBuffer that corresponds to this
     * SinglePixelPackedSampleModel.  The DataBuffer's data type and size
     * will be consistent with this SinglePixelPackedSampleModel.  The
     * DataBuffer will have a single bank.
     */
    public DataBuffer createDataBuffer() {
<span class="nc" id="L231">        DataBuffer dataBuffer = null;</span>

<span class="nc" id="L233">        int size = (int)getBufferSize();</span>
<span class="nc bnc" id="L234" title="All 4 branches missed.">        switch (dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L236">            dataBuffer = new DataBufferByte(size);</span>
<span class="nc" id="L237">            break;</span>
        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L239">            dataBuffer = new DataBufferUShort(size);</span>
<span class="nc" id="L240">            break;</span>
        case DataBuffer.TYPE_INT:
<span class="nc" id="L242">            dataBuffer = new DataBufferInt(size);</span>
            break;
        }
<span class="nc" id="L245">        return dataBuffer;</span>
    }

    /** Returns the number of bits per sample for all bands. */
    public int[] getSampleSize() {
<span class="nc" id="L250">        return bitSizes.clone();</span>
    }

    /** Returns the number of bits per sample for the specified band. */
    public int getSampleSize(int band) {
<span class="nc" id="L255">        return bitSizes[band];</span>
    }

    /** Returns the offset (in data array elements) of pixel (x,y).
     *  The data element containing pixel &lt;code&gt;x,y&lt;/code&gt;
     *  can be retrieved from a DataBuffer &lt;code&gt;data&lt;/code&gt; with a
     *  SinglePixelPackedSampleModel &lt;code&gt;sppsm&lt;/code&gt; as:
     * &lt;pre&gt;
     *        data.getElem(sppsm.getOffset(x, y));
     * &lt;/pre&gt;
     * @param x the X coordinate of the specified pixel
     * @param y the Y coordinate of the specified pixel
     * @return the offset of the specified pixel.
     */
    public int getOffset(int x, int y) {
<span class="nc" id="L270">        int offset = y * scanlineStride + x;</span>
<span class="nc" id="L271">        return offset;</span>
    }

    /** Returns the bit offsets into the data array element representing
     *  a pixel for all bands.
     *  @return the bit offsets representing a pixel for all bands.
     */
    public int [] getBitOffsets() {
<span class="nc" id="L279">      return (int[])bitOffsets.clone();</span>
    }

    /** Returns the bit masks for all bands.
     *  @return the bit masks for all bands.
     */
    public int [] getBitMasks() {
<span class="nc" id="L286">      return (int[])bitMasks.clone();</span>
    }

    /** Returns the scanline stride of this SinglePixelPackedSampleModel.
     *  @return the scanline stride of this
     *          &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt;.
     */
    public int getScanlineStride() {
<span class="nc" id="L294">      return scanlineStride;</span>
    }

    /**
     * This creates a new SinglePixelPackedSampleModel with a subset of the
     * bands of this SinglePixelPackedSampleModel.  The new
     * SinglePixelPackedSampleModel can be used with any DataBuffer that the
     * existing SinglePixelPackedSampleModel can be used with.  The new
     * SinglePixelPackedSampleModel/DataBuffer combination will represent
     * an image with a subset of the bands of the original
     * SinglePixelPackedSampleModel/DataBuffer combination.
     * @exception RasterFormatException if the length of the bands argument is
     *                                  greater than the number of bands in
     *                                  the sample model.
     */
    public SampleModel createSubsetSampleModel(int bands[]) {
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (bands.length &gt; numBands)</span>
<span class="nc" id="L311">            throw new RasterFormatException(&quot;There are only &quot; +</span>
                                            numBands +
                                            &quot; bands&quot;);
<span class="nc" id="L314">        int newBitMasks[] = new int[bands.length];</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        for (int i=0; i&lt;bands.length; i++)</span>
<span class="nc" id="L316">            newBitMasks[i] = bitMasks[bands[i]];</span>

<span class="nc" id="L318">        return new SinglePixelPackedSampleModel(this.dataType, width, height,</span>
                                           this.scanlineStride, newBitMasks);
    }

    /**
     * Returns data for a single pixel in a primitive array of type
     * TransferType.  For a SinglePixelPackedSampleModel, the array will
     * have one element, and the type will be the same as the storage
     * data type.  Generally, obj
     * should be passed in as null, so that the Object will be created
     * automatically and will be of the right primitive data type.
     * &lt;p&gt;
     * The following code illustrates transferring data for one pixel from
     * DataBuffer &lt;code&gt;db1&lt;/code&gt;, whose storage layout is described by
     * SinglePixelPackedSampleModel &lt;code&gt;sppsm1&lt;/code&gt;, to
     * DataBuffer &lt;code&gt;db2&lt;/code&gt;, whose storage layout is described by
     * SinglePixelPackedSampleModel &lt;code&gt;sppsm2&lt;/code&gt;.
     * The transfer will generally be more efficient than using
     * getPixel/setPixel.
     * &lt;pre&gt;
     *       SinglePixelPackedSampleModel sppsm1, sppsm2;
     *       DataBufferInt db1, db2;
     *       sppsm2.setDataElements(x, y, sppsm1.getDataElements(x, y, null,
     *                              db1), db2);
     * &lt;/pre&gt;
     * Using getDataElements/setDataElements to transfer between two
     * DataBuffer/SampleModel pairs is legitimate if the SampleModels have
     * the same number of bands, corresponding bands have the same number of
     * bits per sample, and the TransferTypes are the same.
     * &lt;p&gt;
     * If obj is non-null, it should be a primitive array of type TransferType.
     * Otherwise, a ClassCastException is thrown.  An
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds, or if obj is non-null and is not large enough to hold
     * the pixel data.
     * @param x         The X coordinate of the pixel location.
     * @param y         The Y coordinate of the pixel location.
     * @param obj       If non-null, a primitive array in which to return
     *                  the pixel data.
     * @param data      The DataBuffer containing the image data.
     * @return the data for the specified pixel.
     * @see #setDataElements(int, int, Object, DataBuffer)
     */
    public Object getDataElements(int x, int y, Object obj, DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L363" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L364">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L368">        int type = getTransferType();</span>

<span class="nc bnc" id="L370" title="All 4 branches missed.">        switch(type) {</span>

        case DataBuffer.TYPE_BYTE:

            byte[] bdata;

<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L377">                bdata = new byte[1];</span>
            else
<span class="nc" id="L379">                bdata = (byte[])obj;</span>

<span class="nc" id="L381">            bdata[0] = (byte)data.getElem(y * scanlineStride + x);</span>

<span class="nc" id="L383">            obj = (Object)bdata;</span>
<span class="nc" id="L384">            break;</span>

        case DataBuffer.TYPE_USHORT:

            short[] sdata;

<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L391">                sdata = new short[1];</span>
            else
<span class="nc" id="L393">                sdata = (short[])obj;</span>

<span class="nc" id="L395">            sdata[0] = (short)data.getElem(y * scanlineStride + x);</span>

<span class="nc" id="L397">            obj = (Object)sdata;</span>
<span class="nc" id="L398">            break;</span>

        case DataBuffer.TYPE_INT:

            int[] idata;

<span class="nc bnc" id="L404" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L405">                idata = new int[1];</span>
            else
<span class="nc" id="L407">                idata = (int[])obj;</span>

<span class="nc" id="L409">            idata[0] = data.getElem(y * scanlineStride + x);</span>

<span class="nc" id="L411">            obj = (Object)idata;</span>
            break;
        }

<span class="nc" id="L415">        return obj;</span>
    }

    /**
     * Returns all samples in for the specified pixel in an int array.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location.
     * @param y         The Y coordinate of the pixel location.
     * @param iArray    If non-null, returns the samples in this array
     * @param data      The DataBuffer containing the image data.
     * @return all samples for the specified pixel.
     * @see #setPixel(int, int, int[], DataBuffer)
     */
    public int [] getPixel(int x, int y, int iArray[], DataBuffer data) {
<span class="nc bnc" id="L430" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L431">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int pixels[];
<span class="nc bnc" id="L435" title="All 2 branches missed.">        if (iArray == null) {</span>
<span class="nc" id="L436">            pixels = new int [numBands];</span>
        } else {
<span class="nc" id="L438">            pixels = iArray;</span>
        }

<span class="nc" id="L441">        int value = data.getElem(y * scanlineStride + x);</span>
<span class="nc bnc" id="L442" title="All 2 branches missed.">        for (int i=0; i&lt;numBands; i++) {</span>
<span class="nc" id="L443">            pixels[i] = (value &amp; bitMasks[i]) &gt;&gt;&gt; bitOffsets[i];</span>
        }
<span class="nc" id="L445">        return pixels;</span>
    }

    /**
     * Returns all samples for the specified rectangle of pixels in
     * an int array, one sample per array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the upper left pixel location.
     * @param y         The Y coordinate of the upper left pixel location.
     * @param w         The width of the pixel rectangle.
     * @param h         The height of the pixel rectangle.
     * @param iArray    If non-null, returns the samples in this array.
     * @param data      The DataBuffer containing the image data.
     * @return all samples for the specified region of pixels.
     * @see #setPixels(int, int, int, int, int[], DataBuffer)
     */
    public int[] getPixels(int x, int y, int w, int h,
                           int iArray[], DataBuffer data) {
<span class="nc" id="L464">        int x1 = x + w;</span>
<span class="nc" id="L465">        int y1 = y + h;</span>

<span class="nc bnc" id="L467" title="All 20 branches missed.">        if (x &lt; 0 || x &gt;= width || w &gt; width || x1 &lt; 0 || x1 &gt; width ||</span>
            y &lt; 0 || y &gt;= height || h &gt; height || y1 &lt; 0 || y1 &gt;  height)
        {
<span class="nc" id="L470">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int pixels[];
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L475">           pixels = iArray;</span>
        } else {
<span class="nc" id="L477">           pixels = new int [w*h*numBands];</span>
        }
<span class="nc" id="L479">        int lineOffset = y*scanlineStride + x;</span>
<span class="nc" id="L480">        int dstOffset = 0;</span>

<span class="nc bnc" id="L482" title="All 2 branches missed.">        for (int i = 0; i &lt; h; i++) {</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">           for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L484">              int value = data.getElem(lineOffset+j);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">              for (int k=0; k &lt; numBands; k++) {</span>
<span class="nc" id="L486">                  pixels[dstOffset++] =</span>
                     ((value &amp; bitMasks[k]) &gt;&gt;&gt; bitOffsets[k]);
              }
           }
<span class="nc" id="L490">           lineOffset += scanlineStride;</span>
        }
<span class="nc" id="L492">        return pixels;</span>
    }

    /**
     * Returns as int the sample in a specified band for the pixel
     * located at (x,y).
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location.
     * @param y         The Y coordinate of the pixel location.
     * @param b         The band to return.
     * @param data      The DataBuffer containing the image data.
     * @return the sample in a specified band for the specified
     *         pixel.
     * @see #setSample(int, int, int, int, DataBuffer)
     */
    public int getSample(int x, int y, int b, DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L510" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L511">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L514">        int sample = data.getElem(y * scanlineStride + x);</span>
<span class="nc" id="L515">        return ((sample &amp; bitMasks[b]) &gt;&gt;&gt; bitOffsets[b]);</span>
    }

    /**
     * Returns the samples for a specified band for the specified rectangle
     * of pixels in an int array, one sample per array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the upper left pixel location.
     * @param y         The Y coordinate of the upper left pixel location.
     * @param w         The width of the pixel rectangle.
     * @param h         The height of the pixel rectangle.
     * @param b         The band to return.
     * @param iArray    If non-null, returns the samples in this array.
     * @param data      The DataBuffer containing the image data.
     * @return the samples for the specified band for the specified
     *         region of pixels.
     * @see #setSamples(int, int, int, int, int, int[], DataBuffer)
     */
    public int[] getSamples(int x, int y, int w, int h, int b,
                           int iArray[], DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L537" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x + w &gt; width) || (y + h &gt; height)) {</span>
<span class="nc" id="L538">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int samples[];
<span class="nc bnc" id="L542" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L543">           samples = iArray;</span>
        } else {
<span class="nc" id="L545">           samples = new int [w*h];</span>
        }
<span class="nc" id="L547">        int lineOffset = y*scanlineStride + x;</span>
<span class="nc" id="L548">        int dstOffset = 0;</span>

<span class="nc bnc" id="L550" title="All 2 branches missed.">        for (int i = 0; i &lt; h; i++) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">           for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L552">              int value = data.getElem(lineOffset+j);</span>
<span class="nc" id="L553">              samples[dstOffset++] =</span>
                 ((value &amp; bitMasks[b]) &gt;&gt;&gt; bitOffsets[b]);
           }
<span class="nc" id="L556">           lineOffset += scanlineStride;</span>
        }
<span class="nc" id="L558">        return samples;</span>
    }

    /**
     * Sets the data for a single pixel in the specified DataBuffer from a
     * primitive array of type TransferType.  For a
     * SinglePixelPackedSampleModel, only the first element of the array
     * will hold valid data, and the type of the array must be the same as
     * the storage data type of the SinglePixelPackedSampleModel.
     * &lt;p&gt;
     * The following code illustrates transferring data for one pixel from
     * DataBuffer &lt;code&gt;db1&lt;/code&gt;, whose storage layout is described by
     * SinglePixelPackedSampleModel &lt;code&gt;sppsm1&lt;/code&gt;,
     * to DataBuffer &lt;code&gt;db2&lt;/code&gt;, whose storage layout is described by
     * SinglePixelPackedSampleModel &lt;code&gt;sppsm2&lt;/code&gt;.
     * The transfer will generally be more efficient than using
     * getPixel/setPixel.
     * &lt;pre&gt;
     *       SinglePixelPackedSampleModel sppsm1, sppsm2;
     *       DataBufferInt db1, db2;
     *       sppsm2.setDataElements(x, y, sppsm1.getDataElements(x, y, null,
     *                              db1), db2);
     * &lt;/pre&gt;
     * Using getDataElements/setDataElements to transfer between two
     * DataBuffer/SampleModel pairs is legitimate if the SampleModels have
     * the same number of bands, corresponding bands have the same number of
     * bits per sample, and the TransferTypes are the same.
     * &lt;p&gt;
     * obj must be a primitive array of type TransferType.  Otherwise,
     * a ClassCastException is thrown.  An
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds, or if obj is not large enough to hold the pixel data.
     * @param x         The X coordinate of the pixel location.
     * @param y         The Y coordinate of the pixel location.
     * @param obj       A primitive array containing pixel data.
     * @param data      The DataBuffer containing the image data.
     * @see #getDataElements(int, int, Object, DataBuffer)
     */
    public void setDataElements(int x, int y, Object obj, DataBuffer data) {
<span class="nc bnc" id="L597" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L598">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L602">        int type = getTransferType();</span>

<span class="nc bnc" id="L604" title="All 4 branches missed.">        switch(type) {</span>

        case DataBuffer.TYPE_BYTE:

<span class="nc" id="L608">            byte[] barray = (byte[])obj;</span>
<span class="nc" id="L609">            data.setElem(y*scanlineStride+x, ((int)barray[0])&amp;0xff);</span>
<span class="nc" id="L610">            break;</span>

        case DataBuffer.TYPE_USHORT:

<span class="nc" id="L614">            short[] sarray = (short[])obj;</span>
<span class="nc" id="L615">            data.setElem(y*scanlineStride+x, ((int)sarray[0])&amp;0xffff);</span>
<span class="nc" id="L616">            break;</span>

        case DataBuffer.TYPE_INT:

<span class="nc" id="L620">            int[] iarray = (int[])obj;</span>
<span class="nc" id="L621">            data.setElem(y*scanlineStride+x, iarray[0]);</span>
            break;
        }
<span class="nc" id="L624">    }</span>

    /**
     * Sets a pixel in the DataBuffer using an int array of samples for input.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location.
     * @param y         The Y coordinate of the pixel location.
     * @param iArray    The input samples in an int array.
     * @param data      The DataBuffer containing the image data.
     * @see #getPixel(int, int, int[], DataBuffer)
     */
    public void setPixel(int x, int y,
                         int iArray[],
                         DataBuffer data) {
<span class="nc bnc" id="L639" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L640">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L643">        int lineOffset = y * scanlineStride + x;</span>
<span class="nc" id="L644">        int value = data.getElem(lineOffset);</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">        for (int i=0; i &lt; numBands; i++) {</span>
<span class="nc" id="L646">            value &amp;= ~bitMasks[i];</span>
<span class="nc" id="L647">            value |= ((iArray[i] &lt;&lt; bitOffsets[i]) &amp; bitMasks[i]);</span>
        }
<span class="nc" id="L649">        data.setElem(lineOffset, value);</span>
<span class="nc" id="L650">    }</span>

    /**
     * Sets all samples for a rectangle of pixels from an int array containing
     * one sample per array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the upper left pixel location.
     * @param y         The Y coordinate of the upper left pixel location.
     * @param w         The width of the pixel rectangle.
     * @param h         The height of the pixel rectangle.
     * @param iArray    The input samples in an int array.
     * @param data      The DataBuffer containing the image data.
     * @see #getPixels(int, int, int, int, int[], DataBuffer)
     */
    public void setPixels(int x, int y, int w, int h,
                          int iArray[], DataBuffer data) {
<span class="nc" id="L667">        int x1 = x + w;</span>
<span class="nc" id="L668">        int y1 = y + h;</span>

<span class="nc bnc" id="L670" title="All 20 branches missed.">        if (x &lt; 0 || x &gt;= width || w &gt; width || x1 &lt; 0 || x1 &gt; width ||</span>
            y &lt; 0 || y &gt;= height || h &gt; height || y1 &lt; 0 || y1 &gt;  height)
        {
<span class="nc" id="L673">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L677">        int lineOffset = y*scanlineStride + x;</span>
<span class="nc" id="L678">        int srcOffset = 0;</span>

<span class="nc bnc" id="L680" title="All 2 branches missed.">        for (int i = 0; i &lt; h; i++) {</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">           for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L682">               int value = data.getElem(lineOffset+j);</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">               for (int k=0; k &lt; numBands; k++) {</span>
<span class="nc" id="L684">                   value &amp;= ~bitMasks[k];</span>
<span class="nc" id="L685">                   int srcValue = iArray[srcOffset++];</span>
<span class="nc" id="L686">                   value |= ((srcValue &lt;&lt; bitOffsets[k])</span>
                             &amp; bitMasks[k]);
               }
<span class="nc" id="L689">               data.setElem(lineOffset+j, value);</span>
           }
<span class="nc" id="L691">           lineOffset += scanlineStride;</span>
        }
<span class="nc" id="L693">    }</span>

    /**
     * Sets a sample in the specified band for the pixel located at (x,y)
     * in the DataBuffer using an int for input.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location.
     * @param y         The Y coordinate of the pixel location.
     * @param b         The band to set.
     * @param s         The input sample as an int.
     * @param data      The DataBuffer containing the image data.
     * @see #getSample(int, int, int, DataBuffer)
     */
    public void setSample(int x, int y, int b, int s,
                          DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L710" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L711">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L714">        int value = data.getElem(y*scanlineStride + x);</span>
<span class="nc" id="L715">        value &amp;= ~bitMasks[b];</span>
<span class="nc" id="L716">        value |= (s &lt;&lt; bitOffsets[b]) &amp; bitMasks[b];</span>
<span class="nc" id="L717">        data.setElem(y*scanlineStride + x,value);</span>
<span class="nc" id="L718">    }</span>

    /**
     * Sets the samples in the specified band for the specified rectangle
     * of pixels from an int array containing one sample per array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the upper left pixel location.
     * @param y         The Y coordinate of the upper left pixel location.
     * @param w         The width of the pixel rectangle.
     * @param h         The height of the pixel rectangle.
     * @param b         The band to set.
     * @param iArray    The input samples in an int array.
     * @param data      The DataBuffer containing the image data.
     * @see #getSamples(int, int, int, int, int, int[], DataBuffer)
     */
    public void setSamples(int x, int y, int w, int h, int b,
                          int iArray[], DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L737" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x + w &gt; width) || (y + h &gt; height)) {</span>
<span class="nc" id="L738">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L741">        int lineOffset = y*scanlineStride + x;</span>
<span class="nc" id="L742">        int srcOffset = 0;</span>

<span class="nc bnc" id="L744" title="All 2 branches missed.">        for (int i = 0; i &lt; h; i++) {</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">           for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L746">              int value = data.getElem(lineOffset+j);</span>
<span class="nc" id="L747">              value &amp;= ~bitMasks[b];</span>
<span class="nc" id="L748">              int sample = iArray[srcOffset++];</span>
<span class="nc" id="L749">              value |= ((int)sample &lt;&lt; bitOffsets[b]) &amp; bitMasks[b];</span>
<span class="nc" id="L750">              data.setElem(lineOffset+j,value);</span>
           }
<span class="nc" id="L752">           lineOffset += scanlineStride;</span>
        }
<span class="nc" id="L754">    }</span>

    public boolean equals(Object o) {
<span class="nc bnc" id="L757" title="All 4 branches missed.">        if ((o == null) || !(o instanceof SinglePixelPackedSampleModel)) {</span>
<span class="nc" id="L758">            return false;</span>
        }

<span class="nc" id="L761">        SinglePixelPackedSampleModel that = (SinglePixelPackedSampleModel)o;</span>
<span class="nc bnc" id="L762" title="All 8 branches missed.">        return this.width == that.width &amp;&amp;</span>
            this.height == that.height &amp;&amp;
            this.numBands == that.numBands &amp;&amp;
            this.dataType == that.dataType &amp;&amp;
<span class="nc bnc" id="L766" title="All 2 branches missed.">            Arrays.equals(this.bitMasks, that.bitMasks) &amp;&amp;</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">            Arrays.equals(this.bitOffsets, that.bitOffsets) &amp;&amp;</span>
<span class="nc bnc" id="L768" title="All 6 branches missed.">            Arrays.equals(this.bitSizes, that.bitSizes) &amp;&amp;</span>
            this.maxBitSize == that.maxBitSize &amp;&amp;
            this.scanlineStride == that.scanlineStride;
    }

    // If we implement equals() we must also implement hashCode
    public int hashCode() {
<span class="nc" id="L775">        int hash = 0;</span>
<span class="nc" id="L776">        hash = width;</span>
<span class="nc" id="L777">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L778">        hash ^= height;</span>
<span class="nc" id="L779">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L780">        hash ^= numBands;</span>
<span class="nc" id="L781">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L782">        hash ^= dataType;</span>
<span class="nc" id="L783">        hash &lt;&lt;= 8;</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">        for (int i = 0; i &lt; bitMasks.length; i++) {</span>
<span class="nc" id="L785">            hash ^= bitMasks[i];</span>
<span class="nc" id="L786">            hash &lt;&lt;= 8;</span>
        }
<span class="nc bnc" id="L788" title="All 2 branches missed.">        for (int i = 0; i &lt; bitOffsets.length; i++) {</span>
<span class="nc" id="L789">            hash ^= bitOffsets[i];</span>
<span class="nc" id="L790">            hash &lt;&lt;= 8;</span>
        }
<span class="nc bnc" id="L792" title="All 2 branches missed.">        for (int i = 0; i &lt; bitSizes.length; i++) {</span>
<span class="nc" id="L793">            hash ^= bitSizes[i];</span>
<span class="nc" id="L794">            hash &lt;&lt;= 8;</span>
        }
<span class="nc" id="L796">        hash ^= maxBitSize;</span>
<span class="nc" id="L797">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L798">        hash ^= scanlineStride;</span>
<span class="nc" id="L799">        return hash;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>