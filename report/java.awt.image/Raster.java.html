<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Raster.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">Raster.java</span></div><h1>Raster.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/* ****************************************************************
 ******************************************************************
 ******************************************************************
 *** COPYRIGHT (c) Eastman Kodak Company, 1997
 *** As  an unpublished  work pursuant to Title 17 of the United
 *** States Code.  All rights reserved.
 ******************************************************************
 ******************************************************************
 ******************************************************************/


package java.awt.image;
import java.awt.Rectangle;
import java.awt.Point;

import sun.awt.image.ByteInterleavedRaster;
import sun.awt.image.ShortInterleavedRaster;
import sun.awt.image.IntegerInterleavedRaster;
import sun.awt.image.ByteBandedRaster;
import sun.awt.image.ShortBandedRaster;
import sun.awt.image.BytePackedRaster;
import sun.awt.image.SunWritableRaster;

/**
 * A class representing a rectangular array of pixels.  A Raster
 * encapsulates a DataBuffer that stores the sample values and a
 * SampleModel that describes how to locate a given sample value in a
 * DataBuffer.
 * &lt;p&gt;
 * A Raster defines values for pixels occupying a particular
 * rectangular area of the plane, not necessarily including (0, 0).
 * The rectangle, known as the Raster's bounding rectangle and
 * available by means of the getBounds method, is defined by minX,
 * minY, width, and height values.  The minX and minY values define
 * the coordinate of the upper left corner of the Raster.  References
 * to pixels outside of the bounding rectangle may result in an
 * exception being thrown, or may result in references to unintended
 * elements of the Raster's associated DataBuffer.  It is the user's
 * responsibility to avoid accessing such pixels.
 * &lt;p&gt;
 * A SampleModel describes how samples of a Raster
 * are stored in the primitive array elements of a DataBuffer.
 * Samples may be stored one per data element, as in a
 * PixelInterleavedSampleModel or BandedSampleModel, or packed several to
 * an element, as in a SinglePixelPackedSampleModel or
 * MultiPixelPackedSampleModel.  The SampleModel is also
 * controls whether samples are sign extended, allowing unsigned
 * data to be stored in signed Java data types such as byte, short, and
 * int.
 * &lt;p&gt;
 * Although a Raster may live anywhere in the plane, a SampleModel
 * makes use of a simple coordinate system that starts at (0, 0).  A
 * Raster therefore contains a translation factor that allows pixel
 * locations to be mapped between the Raster's coordinate system and
 * that of the SampleModel.  The translation from the SampleModel
 * coordinate system to that of the Raster may be obtained by the
 * getSampleModelTranslateX and getSampleModelTranslateY methods.
 * &lt;p&gt;
 * A Raster may share a DataBuffer with another Raster either by
 * explicit construction or by the use of the createChild and
 * createTranslatedChild methods.  Rasters created by these methods
 * can return a reference to the Raster they were created from by
 * means of the getParent method.  For a Raster that was not
 * constructed by means of a call to createTranslatedChild or
 * createChild, getParent will return null.
 * &lt;p&gt;
 * The createTranslatedChild method returns a new Raster that
 * shares all of the data of the current Raster, but occupies a
 * bounding rectangle of the same width and height but with a
 * different starting point.  For example, if the parent Raster
 * occupied the region (10, 10) to (100, 100), and the translated
 * Raster was defined to start at (50, 50), then pixel (20, 20) of the
 * parent and pixel (60, 60) of the child occupy the same location in
 * the DataBuffer shared by the two Rasters.  In the first case, (-10,
 * -10) should be added to a pixel coordinate to obtain the
 * corresponding SampleModel coordinate, and in the second case (-50,
 * -50) should be added.
 * &lt;p&gt;
 * The translation between a parent and child Raster may be
 * determined by subtracting the child's sampleModelTranslateX and
 * sampleModelTranslateY values from those of the parent.
 * &lt;p&gt;
 * The createChild method may be used to create a new Raster
 * occupying only a subset of its parent's bounding rectangle
 * (with the same or a translated coordinate system) or
 * with a subset of the bands of its parent.
 * &lt;p&gt;
 * All constructors are protected.  The correct way to create a
 * Raster is to use one of the static create methods defined in this
 * class.  These methods create instances of Raster that use the
 * standard Interleaved, Banded, and Packed SampleModels and that may
 * be processed more efficiently than a Raster created by combining
 * an externally generated SampleModel and DataBuffer.
 * @see java.awt.image.DataBuffer
 * @see java.awt.image.SampleModel
 * @see java.awt.image.PixelInterleavedSampleModel
 * @see java.awt.image.BandedSampleModel
 * @see java.awt.image.SinglePixelPackedSampleModel
 * @see java.awt.image.MultiPixelPackedSampleModel
 */
public class Raster {

    /**
     * The SampleModel that describes how pixels from this Raster
     * are stored in the DataBuffer.
     */
    protected SampleModel sampleModel;

    /** The DataBuffer that stores the image data. */
    protected DataBuffer dataBuffer;

    /** The X coordinate of the upper-left pixel of this Raster. */
    protected int minX;

    /** The Y coordinate of the upper-left pixel of this Raster. */
    protected int minY;

    /** The width of this Raster. */
    protected int width;

    /** The height of this Raster. */
    protected int height;

    /**
     * The X translation from the coordinate space of the
     * Raster's SampleModel to that of the Raster.
     */
    protected int sampleModelTranslateX;

    /**
     * The Y translation from the coordinate space of the
     * Raster's SampleModel to that of the Raster.
     */
    protected int sampleModelTranslateY;

    /** The number of bands in the Raster. */
    protected int numBands;

    /** The number of DataBuffer data elements per pixel. */
    protected int numDataElements;

    /** The parent of this Raster, or null. */
    protected Raster parent;

    static private native void initIDs();
    static {
<span class="nc" id="L172">        ColorModel.loadLibraries();</span>
<span class="nc" id="L173">        initIDs();</span>
<span class="nc" id="L174">    }</span>

    /**
     * Creates a Raster based on a PixelInterleavedSampleModel with the
     * specified data type, width, height, and number of bands.
     *
     * &lt;p&gt; The upper left corner of the Raster is given by the
     * location argument.  If location is null, (0, 0) will be used.
     * The dataType parameter should be one of the enumerated values
     * defined in the DataBuffer class.
     *
     * &lt;p&gt; Note that interleaved &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     * Rasters are not supported.  To create a 1-band Raster of type
     * &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;, use
     * Raster.createPackedRaster().
     * &lt;p&gt; The only dataTypes supported currently are TYPE_BYTE
     * and TYPE_USHORT.
     * @param dataType  the data type for storing samples
     * @param w         the width in pixels of the image data
     * @param h         the height in pixels of the image data
     * @param bands     the number of bands
     * @param location  the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     * @return a WritableRaster object with the specified data type,
     *         width, height and number of bands.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;location.x + w&lt;/code&gt; or
     *         &lt;code&gt;location.y + h&lt;/code&gt; results in integer
     *         overflow
     */
    public static WritableRaster createInterleavedRaster(int dataType,
                                                         int w, int h,
                                                         int bands,
                                                         Point location) {
<span class="nc" id="L208">        int[] bandOffsets = new int[bands];</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">        for (int i = 0; i &lt; bands; i++) {</span>
<span class="nc" id="L210">            bandOffsets[i] = i;</span>
        }
<span class="nc" id="L212">        return createInterleavedRaster(dataType, w, h, w*bands, bands,</span>
                                       bandOffsets, location);
    }

    /**
     * Creates a Raster based on a PixelInterleavedSampleModel with the
     * specified data type, width, height, scanline stride, pixel
     * stride, and band offsets.  The number of bands is inferred from
     * bandOffsets.length.
     *
     * &lt;p&gt; The upper left corner of the Raster is given by the
     * location argument.  If location is null, (0, 0) will be used.
     * The dataType parameter should be one of the enumerated values
     * defined in the DataBuffer class.
     *
     * &lt;p&gt; Note that interleaved &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     * Rasters are not supported.  To create a 1-band Raster of type
     * &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;, use
     * Raster.createPackedRaster().
     * &lt;p&gt; The only dataTypes supported currently are TYPE_BYTE
     * and TYPE_USHORT.
     * @param dataType  the data type for storing samples
     * @param w         the width in pixels of the image data
     * @param h         the height in pixels of the image data
     * @param scanlineStride the line stride of the image data
     * @param pixelStride the pixel stride of the image data
     * @param bandOffsets the offsets of all bands
     * @param location  the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     * @return a WritableRaster object with the specified data type,
     *         width, height, scanline stride, pixel stride and band
     *         offsets.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;location.x + w&lt;/code&gt; or
     *         &lt;code&gt;location.y + h&lt;/code&gt; results in integer
     *         overflow
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types, which are
     *         &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;, or
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.
     */
    public static WritableRaster createInterleavedRaster(int dataType,
                                                         int w, int h,
                                                         int scanlineStride,
                                                         int pixelStride,
                                                         int bandOffsets[],
                                                         Point location) {
        DataBuffer d;

<span class="nc" id="L261">        int size = scanlineStride * (h - 1) + // fisrt (h - 1) scans</span>
            pixelStride * w; // last scan

<span class="nc bnc" id="L264" title="All 3 branches missed.">        switch(dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L266">            d = new DataBufferByte(size);</span>
<span class="nc" id="L267">            break;</span>

        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L270">            d = new DataBufferUShort(size);</span>
<span class="nc" id="L271">            break;</span>

        default:
<span class="nc" id="L274">            throw new IllegalArgumentException(&quot;Unsupported data type &quot; +</span>
                                                dataType);
        }

<span class="nc" id="L278">        return createInterleavedRaster(d, w, h, scanlineStride,</span>
                                       pixelStride, bandOffsets, location);
    }

    /**
     * Creates a Raster based on a BandedSampleModel with the
     * specified data type, width, height, and number of bands.
     *
     * &lt;p&gt; The upper left corner of the Raster is given by the
     * location argument.  If location is null, (0, 0) will be used.
     * The dataType parameter should be one of the enumerated values
     * defined in the DataBuffer class.
     *
     * &lt;p&gt; The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT,
     * and TYPE_INT.
     * @param dataType  the data type for storing samples
     * @param w         the width in pixels of the image data
     * @param h         the height in pixels of the image data
     * @param bands     the number of bands
     * @param location  the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     * @return a WritableRaster object with the specified data type,
     *         width, height and number of bands.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;location.x + w&lt;/code&gt; or
     *         &lt;code&gt;location.y + h&lt;/code&gt; results in integer
     *         overflow
     * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;bands&lt;/code&gt;
     *         is less than 1
     */
    public static WritableRaster createBandedRaster(int dataType,
                                                    int w, int h,
                                                    int bands,
                                                    Point location) {
<span class="nc bnc" id="L312" title="All 2 branches missed.">        if (bands &lt; 1) {</span>
<span class="nc" id="L313">            throw new ArrayIndexOutOfBoundsException(&quot;Number of bands (&quot;+</span>
                                                     bands+&quot;) must&quot;+
                                                     &quot; be greater than 0&quot;);
        }
<span class="nc" id="L317">        int[] bankIndices = new int[bands];</span>
<span class="nc" id="L318">        int[] bandOffsets = new int[bands];</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        for (int i = 0; i &lt; bands; i++) {</span>
<span class="nc" id="L320">            bankIndices[i] = i;</span>
<span class="nc" id="L321">            bandOffsets[i] = 0;</span>
        }

<span class="nc" id="L324">        return createBandedRaster(dataType, w, h, w,</span>
                                  bankIndices, bandOffsets,
                                  location);
    }

    /**
     * Creates a Raster based on a BandedSampleModel with the
     * specified data type, width, height, scanline stride, bank
     * indices and band offsets.  The number of bands is inferred from
     * bankIndices.length and bandOffsets.length, which must be the
     * same.
     *
     * &lt;p&gt; The upper left corner of the Raster is given by the
     * location argument.  The dataType parameter should be one of the
     * enumerated values defined in the DataBuffer class.
     *
     * &lt;p&gt; The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT,
     * and TYPE_INT.
     * @param dataType  the data type for storing samples
     * @param w         the width in pixels of the image data
     * @param h         the height in pixels of the image data
     * @param scanlineStride the line stride of the image data
     * @param bankIndices the bank indices for each band
     * @param bandOffsets the offsets of all bands
     * @param location  the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     * @return a WritableRaster object with the specified data type,
     *         width, height, scanline stride, bank indices and band
     *         offsets.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;location.x + w&lt;/code&gt; or
     *         &lt;code&gt;location.y + h&lt;/code&gt; results in integer
     *         overflow
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types, which are
     *         &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     *         or &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;bankIndices&lt;/code&gt;
     *         or &lt;code&gt;bandOffsets&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     */
    public static WritableRaster createBandedRaster(int dataType,
                                                    int w, int h,
                                                    int scanlineStride,
                                                    int bankIndices[],
                                                    int bandOffsets[],
                                                    Point location) {
        DataBuffer d;
<span class="nc" id="L372">        int bands = bandOffsets.length;</span>

<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (bankIndices == null) {</span>
<span class="nc" id="L375">            throw new</span>
                ArrayIndexOutOfBoundsException(&quot;Bank indices array is null&quot;);
        }
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (bandOffsets == null) {</span>
<span class="nc" id="L379">            throw new</span>
                ArrayIndexOutOfBoundsException(&quot;Band offsets array is null&quot;);
        }

        // Figure out the #banks and the largest band offset
<span class="nc" id="L384">        int maxBank = bankIndices[0];</span>
<span class="nc" id="L385">        int maxBandOff = bandOffsets[0];</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">        for (int i = 1; i &lt; bands; i++) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (bankIndices[i] &gt; maxBank) {</span>
<span class="nc" id="L388">                maxBank = bankIndices[i];</span>
            }
<span class="nc bnc" id="L390" title="All 2 branches missed.">            if (bandOffsets[i] &gt; maxBandOff) {</span>
<span class="nc" id="L391">                maxBandOff = bandOffsets[i];</span>
            }
        }
<span class="nc" id="L394">        int banks = maxBank + 1;</span>
<span class="nc" id="L395">        int size = maxBandOff +</span>
            scanlineStride * (h - 1) + // fisrt (h - 1) scans
            w; // last scan

<span class="nc bnc" id="L399" title="All 4 branches missed.">        switch(dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L401">            d = new DataBufferByte(size, banks);</span>
<span class="nc" id="L402">            break;</span>

        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L405">            d = new DataBufferUShort(size, banks);</span>
<span class="nc" id="L406">            break;</span>

        case DataBuffer.TYPE_INT:
<span class="nc" id="L409">            d = new DataBufferInt(size, banks);</span>
<span class="nc" id="L410">            break;</span>

        default:
<span class="nc" id="L413">            throw new IllegalArgumentException(&quot;Unsupported data type &quot; +</span>
                                                dataType);
        }

<span class="nc" id="L417">        return createBandedRaster(d, w, h, scanlineStride,</span>
                                  bankIndices, bandOffsets, location);
    }

    /**
     * Creates a Raster based on a SinglePixelPackedSampleModel with
     * the specified data type, width, height, and band masks.
     * The number of bands is inferred from bandMasks.length.
     *
     * &lt;p&gt; The upper left corner of the Raster is given by the
     * location argument.  If location is null, (0, 0) will be used.
     * The dataType parameter should be one of the enumerated values
     * defined in the DataBuffer class.
     *
     * &lt;p&gt; The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT,
     * and TYPE_INT.
     * @param dataType  the data type for storing samples
     * @param w         the width in pixels of the image data
     * @param h         the height in pixels of the image data
     * @param bandMasks an array containing an entry for each band
     * @param location  the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     * @return a WritableRaster object with the specified data type,
     *         width, height, and band masks.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;location.x + w&lt;/code&gt; or
     *         &lt;code&gt;location.y + h&lt;/code&gt; results in integer
     *         overflow
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types, which are
     *         &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     *         or &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     */
    public static WritableRaster createPackedRaster(int dataType,
                                                    int w, int h,
                                                    int bandMasks[],
                                                    Point location) {
        DataBuffer d;

<span class="nc bnc" id="L457" title="All 4 branches missed.">        switch(dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L459">            d = new DataBufferByte(w*h);</span>
<span class="nc" id="L460">            break;</span>

        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L463">            d = new DataBufferUShort(w*h);</span>
<span class="nc" id="L464">            break;</span>

        case DataBuffer.TYPE_INT:
<span class="nc" id="L467">            d = new DataBufferInt(w*h);</span>
<span class="nc" id="L468">            break;</span>

        default:
<span class="nc" id="L471">            throw new IllegalArgumentException(&quot;Unsupported data type &quot; +</span>
                                                dataType);
        }

<span class="nc" id="L475">        return createPackedRaster(d, w, h, w, bandMasks, location);</span>
    }

    /**
     * Creates a Raster based on a packed SampleModel with the
     * specified data type, width, height, number of bands, and bits
     * per band.  If the number of bands is one, the SampleModel will
     * be a MultiPixelPackedSampleModel.
     *
     * &lt;p&gt; If the number of bands is more than one, the SampleModel
     * will be a SinglePixelPackedSampleModel, with each band having
     * bitsPerBand bits.  In either case, the requirements on dataType
     * and bitsPerBand imposed by the corresponding SampleModel must
     * be met.
     *
     * &lt;p&gt; The upper left corner of the Raster is given by the
     * location argument.  If location is null, (0, 0) will be used.
     * The dataType parameter should be one of the enumerated values
     * defined in the DataBuffer class.
     *
     * &lt;p&gt; The only dataTypes supported currently are TYPE_BYTE, TYPE_USHORT,
     * and TYPE_INT.
     * @param dataType  the data type for storing samples
     * @param w         the width in pixels of the image data
     * @param h         the height in pixels of the image data
     * @param bands     the number of bands
     * @param bitsPerBand the number of bits per band
     * @param location  the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     * @return a WritableRaster object with the specified data type,
     *         width, height, number of bands, and bits per band.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;location.x + w&lt;/code&gt; or
     *         &lt;code&gt;location.y + h&lt;/code&gt; results in integer
     *         overflow
     * @throws IllegalArgumentException if the product of
     *         &lt;code&gt;bitsPerBand&lt;/code&gt; and &lt;code&gt;bands&lt;/code&gt; is
     *         greater than the number of bits held by
     *         &lt;code&gt;dataType&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;bitsPerBand&lt;/code&gt; or
     *         &lt;code&gt;bands&lt;/code&gt; is not greater than zero
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types, which are
     *         &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     *         or &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     */
    public static WritableRaster createPackedRaster(int dataType,
                                                    int w, int h,
                                                    int bands,
                                                    int bitsPerBand,
                                                    Point location) {
        DataBuffer d;

<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (bands &lt;= 0) {</span>
<span class="nc" id="L530">            throw new IllegalArgumentException(&quot;Number of bands (&quot;+bands+</span>
                                               &quot;) must be greater than 0&quot;);
        }

<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (bitsPerBand &lt;= 0) {</span>
<span class="nc" id="L535">            throw new IllegalArgumentException(&quot;Bits per band (&quot;+bitsPerBand+</span>
                                               &quot;) must be greater than 0&quot;);
        }

<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (bands != 1) {</span>
<span class="nc" id="L540">            int[] masks = new int[bands];</span>
<span class="nc" id="L541">            int mask = (1 &lt;&lt; bitsPerBand) - 1;</span>
<span class="nc" id="L542">            int shift = (bands-1)*bitsPerBand;</span>

            /* Make sure the total mask size will fit in the data type */
<span class="nc bnc" id="L545" title="All 2 branches missed.">            if (shift+bitsPerBand &gt; DataBuffer.getDataTypeSize(dataType)) {</span>
<span class="nc" id="L546">                throw new IllegalArgumentException(&quot;bitsPerBand(&quot;+</span>
                                                   bitsPerBand+&quot;) * bands is &quot;+
                                                   &quot; greater than data type &quot;+
                                                   &quot;size.&quot;);
            }
<span class="nc bnc" id="L551" title="All 2 branches missed.">            switch(dataType) {</span>
            case DataBuffer.TYPE_BYTE:
            case DataBuffer.TYPE_USHORT:
            case DataBuffer.TYPE_INT:
<span class="nc" id="L555">                break;</span>
            default:
<span class="nc" id="L557">                throw new IllegalArgumentException(&quot;Unsupported data type &quot; +</span>
                                                    dataType);
            }

<span class="nc bnc" id="L561" title="All 2 branches missed.">            for (int i = 0; i &lt; bands; i++) {</span>
<span class="nc" id="L562">                masks[i] = mask &lt;&lt; shift;</span>
<span class="nc" id="L563">                shift = shift - bitsPerBand;</span>
            }

<span class="nc" id="L566">            return createPackedRaster(dataType, w, h, masks, location);</span>
        }
        else {
<span class="nc" id="L569">            double fw = w;</span>
<span class="nc bnc" id="L570" title="All 4 branches missed.">            switch(dataType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L572">                d = new DataBufferByte((int)(Math.ceil(fw/(8/bitsPerBand)))*h);</span>
<span class="nc" id="L573">                break;</span>

            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L576">                d = new DataBufferUShort((int)(Math.ceil(fw/(16/bitsPerBand)))*h);</span>
<span class="nc" id="L577">                break;</span>

            case DataBuffer.TYPE_INT:
<span class="nc" id="L580">                d = new DataBufferInt((int)(Math.ceil(fw/(32/bitsPerBand)))*h);</span>
<span class="nc" id="L581">                break;</span>

            default:
<span class="nc" id="L584">                throw new IllegalArgumentException(&quot;Unsupported data type &quot; +</span>
                                                   dataType);
            }

<span class="nc" id="L588">            return createPackedRaster(d, w, h, bitsPerBand, location);</span>
        }
    }

    /**
     * Creates a Raster based on a PixelInterleavedSampleModel with the
     * specified DataBuffer, width, height, scanline stride, pixel
     * stride, and band offsets.  The number of bands is inferred from
     * bandOffsets.length.  The upper left corner of the Raster
     * is given by the location argument.  If location is null, (0, 0)
     * will be used.
     * &lt;p&gt; Note that interleaved &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     * Rasters are not supported.  To create a 1-band Raster of type
     * &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;, use
     * Raster.createPackedRaster().
     * @param dataBuffer the &lt;code&gt;DataBuffer&lt;/code&gt; that contains the
     *        image data
     * @param w         the width in pixels of the image data
     * @param h         the height in pixels of the image data
     * @param scanlineStride the line stride of the image data
     * @param pixelStride the pixel stride of the image data
     * @param bandOffsets the offsets of all bands
     * @param location  the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     * @return a WritableRaster object with the specified
     *         &lt;code&gt;DataBuffer&lt;/code&gt;, width, height, scanline stride,
     *         pixel stride and band offsets.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;location.x + w&lt;/code&gt; or
     *         &lt;code&gt;location.y + h&lt;/code&gt; results in integer
     *         overflow
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types, which are
     *         &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     * @throws RasterFormatException if &lt;code&gt;dataBuffer&lt;/code&gt; has more
     *         than one bank.
     * @throws NullPointerException if &lt;code&gt;dataBuffer&lt;/code&gt; is null
     */
    public static WritableRaster createInterleavedRaster(DataBuffer dataBuffer,
                                                         int w, int h,
                                                         int scanlineStride,
                                                         int pixelStride,
                                                         int bandOffsets[],
                                                         Point location) {
<span class="nc bnc" id="L633" title="All 2 branches missed.">        if (dataBuffer == null) {</span>
<span class="nc" id="L634">            throw new NullPointerException(&quot;DataBuffer cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (location == null) {</span>
<span class="nc" id="L637">            location = new Point(0, 0);</span>
        }
<span class="nc" id="L639">        int dataType = dataBuffer.getDataType();</span>

<span class="nc" id="L641">        PixelInterleavedSampleModel csm =</span>
            new PixelInterleavedSampleModel(dataType, w, h,
                                            pixelStride,
                                            scanlineStride,
                                            bandOffsets);
<span class="nc bnc" id="L646" title="All 3 branches missed.">        switch(dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L648">            return new ByteInterleavedRaster(csm, dataBuffer, location);</span>

        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L651">            return new ShortInterleavedRaster(csm, dataBuffer, location);</span>

        default:
<span class="nc" id="L654">            throw new IllegalArgumentException(&quot;Unsupported data type &quot; +</span>
                                                dataType);
        }
    }

    /**
     * Creates a Raster based on a BandedSampleModel with the
     * specified DataBuffer, width, height, scanline stride, bank
     * indices, and band offsets.  The number of bands is inferred
     * from bankIndices.length and bandOffsets.length, which must be
     * the same.  The upper left corner of the Raster is given by the
     * location argument.  If location is null, (0, 0) will be used.
     * @param dataBuffer the &lt;code&gt;DataBuffer&lt;/code&gt; that contains the
     *        image data
     * @param w         the width in pixels of the image data
     * @param h         the height in pixels of the image data
     * @param scanlineStride the line stride of the image data
     * @param bankIndices the bank indices for each band
     * @param bandOffsets the offsets of all bands
     * @param location  the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     * @return a WritableRaster object with the specified
     *         &lt;code&gt;DataBuffer&lt;/code&gt;, width, height, scanline stride,
     *         bank indices and band offsets.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;location.x + w&lt;/code&gt; or
     *         &lt;code&gt;location.y + h&lt;/code&gt; results in integer
     *         overflow
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types, which are
     *         &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     *         or &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;dataBuffer&lt;/code&gt; is null
     */
    public static WritableRaster createBandedRaster(DataBuffer dataBuffer,
                                                    int w, int h,
                                                    int scanlineStride,
                                                    int bankIndices[],
                                                    int bandOffsets[],
                                                    Point location) {
<span class="nc bnc" id="L695" title="All 2 branches missed.">        if (dataBuffer == null) {</span>
<span class="nc" id="L696">            throw new NullPointerException(&quot;DataBuffer cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L698" title="All 2 branches missed.">        if (location == null) {</span>
<span class="nc" id="L699">           location = new Point(0,0);</span>
        }
<span class="nc" id="L701">        int dataType = dataBuffer.getDataType();</span>

<span class="nc" id="L703">        int bands = bankIndices.length;</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">        if (bandOffsets.length != bands) {</span>
<span class="nc" id="L705">            throw new IllegalArgumentException(</span>
                                   &quot;bankIndices.length != bandOffsets.length&quot;);
        }

<span class="nc" id="L709">        BandedSampleModel bsm =</span>
            new BandedSampleModel(dataType, w, h,
                                  scanlineStride,
                                  bankIndices, bandOffsets);

<span class="nc bnc" id="L714" title="All 4 branches missed.">        switch(dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L716">            return new ByteBandedRaster(bsm, dataBuffer, location);</span>

        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L719">            return new ShortBandedRaster(bsm, dataBuffer, location);</span>

        case DataBuffer.TYPE_INT:
<span class="nc" id="L722">            return new SunWritableRaster(bsm, dataBuffer, location);</span>

        default:
<span class="nc" id="L725">            throw new IllegalArgumentException(&quot;Unsupported data type &quot; +</span>
                                                dataType);
        }
    }

    /**
     * Creates a Raster based on a SinglePixelPackedSampleModel with
     * the specified DataBuffer, width, height, scanline stride, and
     * band masks.  The number of bands is inferred from bandMasks.length.
     * The upper left corner of the Raster is given by
     * the location argument.  If location is null, (0, 0) will be used.
     * @param dataBuffer the &lt;code&gt;DataBuffer&lt;/code&gt; that contains the
     *        image data
     * @param w         the width in pixels of the image data
     * @param h         the height in pixels of the image data
     * @param scanlineStride the line stride of the image data
     * @param bandMasks an array containing an entry for each band
     * @param location  the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     * @return a WritableRaster object with the specified
     *         &lt;code&gt;DataBuffer&lt;/code&gt;, width, height, scanline stride,
     *         and band masks.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;location.x + w&lt;/code&gt; or
     *         &lt;code&gt;location.y + h&lt;/code&gt; results in integer
     *         overflow
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types, which are
     *         &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     *         or &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     * @throws RasterFormatException if &lt;code&gt;dataBuffer&lt;/code&gt; has more
     *         than one bank.
     * @throws NullPointerException if &lt;code&gt;dataBuffer&lt;/code&gt; is null
     */
    public static WritableRaster createPackedRaster(DataBuffer dataBuffer,
                                                    int w, int h,
                                                    int scanlineStride,
                                                    int bandMasks[],
                                                    Point location) {
<span class="nc bnc" id="L765" title="All 2 branches missed.">        if (dataBuffer == null) {</span>
<span class="nc" id="L766">            throw new NullPointerException(&quot;DataBuffer cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if (location == null) {</span>
<span class="nc" id="L769">           location = new Point(0,0);</span>
        }
<span class="nc" id="L771">        int dataType = dataBuffer.getDataType();</span>

<span class="nc" id="L773">        SinglePixelPackedSampleModel sppsm =</span>
            new SinglePixelPackedSampleModel(dataType, w, h, scanlineStride,
                                             bandMasks);

<span class="nc bnc" id="L777" title="All 4 branches missed.">        switch(dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L779">            return new ByteInterleavedRaster(sppsm, dataBuffer, location);</span>

        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L782">            return new ShortInterleavedRaster(sppsm, dataBuffer, location);</span>

        case DataBuffer.TYPE_INT:
<span class="nc" id="L785">            return new IntegerInterleavedRaster(sppsm, dataBuffer, location);</span>

        default:
<span class="nc" id="L788">            throw new IllegalArgumentException(&quot;Unsupported data type &quot; +</span>
                                                dataType);
        }
    }

    /**
     * Creates a Raster based on a MultiPixelPackedSampleModel with the
     * specified DataBuffer, width, height, and bits per pixel.  The upper
     * left corner of the Raster is given by the location argument.  If
     * location is null, (0, 0) will be used.
     * @param dataBuffer the &lt;code&gt;DataBuffer&lt;/code&gt; that contains the
     *        image data
     * @param w         the width in pixels of the image data
     * @param h         the height in pixels of the image data
     * @param bitsPerPixel the number of bits for each pixel
     * @param location  the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     * @return a WritableRaster object with the specified
     *         &lt;code&gt;DataBuffer&lt;/code&gt;, width, height, and
     *         bits per pixel.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;location.x + w&lt;/code&gt; or
     *         &lt;code&gt;location.y + h&lt;/code&gt; results in integer
     *         overflow
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types, which are
     *         &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     *         or &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     * @throws RasterFormatException if &lt;code&gt;dataBuffer&lt;/code&gt; has more
     *         than one bank.
     * @throws NullPointerException if &lt;code&gt;dataBuffer&lt;/code&gt; is null
     */
    public static WritableRaster createPackedRaster(DataBuffer dataBuffer,
                                                    int w, int h,
                                                    int bitsPerPixel,
                                                    Point location) {
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (dataBuffer == null) {</span>
<span class="nc" id="L826">            throw new NullPointerException(&quot;DataBuffer cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L828" title="All 2 branches missed.">        if (location == null) {</span>
<span class="nc" id="L829">           location = new Point(0,0);</span>
        }
<span class="nc" id="L831">        int dataType = dataBuffer.getDataType();</span>

<span class="nc bnc" id="L833" title="All 6 branches missed.">        if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;</span>
            dataType != DataBuffer.TYPE_USHORT &amp;&amp;
            dataType != DataBuffer.TYPE_INT) {
<span class="nc" id="L836">            throw new IllegalArgumentException(&quot;Unsupported data type &quot; +</span>
                                               dataType);
        }

<span class="nc bnc" id="L840" title="All 2 branches missed.">        if (dataBuffer.getNumBanks() != 1) {</span>
<span class="nc" id="L841">            throw new</span>
                RasterFormatException(&quot;DataBuffer for packed Rasters&quot;+
                                      &quot; must only have 1 bank.&quot;);
        }

<span class="nc" id="L846">        MultiPixelPackedSampleModel mppsm =</span>
                new MultiPixelPackedSampleModel(dataType, w, h, bitsPerPixel);

<span class="nc bnc" id="L849" title="All 8 branches missed.">        if (dataType == DataBuffer.TYPE_BYTE &amp;&amp;</span>
            (bitsPerPixel == 1 || bitsPerPixel == 2 || bitsPerPixel == 4)) {
<span class="nc" id="L851">            return new BytePackedRaster(mppsm, dataBuffer, location);</span>
        } else {
<span class="nc" id="L853">            return new SunWritableRaster(mppsm, dataBuffer, location);</span>
        }
    }


    /**
     *  Creates a Raster with the specified SampleModel and DataBuffer.
     *  The upper left corner of the Raster is given by the location argument.
     *  If location is null, (0, 0) will be used.
     *  @param sm the specified &lt;code&gt;SampleModel&lt;/code&gt;
     *  @param db the specified &lt;code&gt;DataBuffer&lt;/code&gt;
     *  @param location the upper-left corner of the &lt;code&gt;Raster&lt;/code&gt;
     *  @return a &lt;code&gt;Raster&lt;/code&gt; with the specified
     *          &lt;code&gt;SampleModel&lt;/code&gt;, &lt;code&gt;DataBuffer&lt;/code&gt;, and
     *          location.
     * @throws RasterFormatException if computing either
     *         &lt;code&gt;location.x + sm.getWidth()&lt;/code&gt; or
     *         &lt;code&gt;location.y + sm.getHeight()&lt;/code&gt; results in integer
     *         overflow
     * @throws RasterFormatException if &lt;code&gt;db&lt;/code&gt; has more
     *         than one bank and &lt;code&gt;sm&lt;/code&gt; is a
     *         PixelInterleavedSampleModel, SinglePixelPackedSampleModel,
     *         or MultiPixelPackedSampleModel.
     *  @throws NullPointerException if either SampleModel or DataBuffer is
     *          null
     */
    public static Raster createRaster(SampleModel sm,
                                      DataBuffer db,
                                      Point location) {
<span class="nc bnc" id="L882" title="All 4 branches missed.">        if ((sm == null) || (db == null)) {</span>
<span class="nc" id="L883">            throw new NullPointerException(&quot;SampleModel and DataBuffer cannot be null&quot;);</span>
        }

<span class="nc bnc" id="L886" title="All 2 branches missed.">        if (location == null) {</span>
<span class="nc" id="L887">           location = new Point(0,0);</span>
        }
<span class="nc" id="L889">        int dataType = sm.getDataType();</span>

<span class="nc bnc" id="L891" title="All 2 branches missed.">        if (sm instanceof PixelInterleavedSampleModel) {</span>
<span class="nc bnc" id="L892" title="All 3 branches missed.">            switch(dataType) {</span>
                case DataBuffer.TYPE_BYTE:
<span class="nc" id="L894">                    return new ByteInterleavedRaster(sm, db, location);</span>

                case DataBuffer.TYPE_USHORT:
<span class="nc" id="L897">                    return new ShortInterleavedRaster(sm, db, location);</span>
            }
<span class="nc bnc" id="L899" title="All 2 branches missed.">        } else if (sm instanceof SinglePixelPackedSampleModel) {</span>
<span class="nc bnc" id="L900" title="All 4 branches missed.">            switch(dataType) {</span>
                case DataBuffer.TYPE_BYTE:
<span class="nc" id="L902">                    return new ByteInterleavedRaster(sm, db, location);</span>

                case DataBuffer.TYPE_USHORT:
<span class="nc" id="L905">                    return new ShortInterleavedRaster(sm, db, location);</span>

                case DataBuffer.TYPE_INT:
<span class="nc" id="L908">                    return new IntegerInterleavedRaster(sm, db, location);</span>
            }
<span class="nc bnc" id="L910" title="All 4 branches missed.">        } else if (sm instanceof MultiPixelPackedSampleModel &amp;&amp;</span>
                   dataType == DataBuffer.TYPE_BYTE &amp;&amp;
<span class="nc bnc" id="L912" title="All 2 branches missed.">                   sm.getSampleSize(0) &lt; 8) {</span>
<span class="nc" id="L913">            return new BytePackedRaster(sm, db, location);</span>
        }

        // we couldn't do anything special - do the generic thing

<span class="nc" id="L918">        return new Raster(sm,db,location);</span>
    }

    /**
     *  Creates a WritableRaster with the specified SampleModel.
     *  The upper left corner of the Raster is given by the location argument.
     *  If location is null, (0, 0) will be used.
     *  @param sm the specified &lt;code&gt;SampleModel&lt;/code&gt;
     *  @param location the upper-left corner of the
     *         &lt;code&gt;WritableRaster&lt;/code&gt;
     *  @return a &lt;code&gt;WritableRaster&lt;/code&gt; with the specified
     *          &lt;code&gt;SampleModel&lt;/code&gt; and location.
     *  @throws RasterFormatException if computing either
     *          &lt;code&gt;location.x + sm.getWidth()&lt;/code&gt; or
     *          &lt;code&gt;location.y + sm.getHeight()&lt;/code&gt; results in integer
     *          overflow
     */
    public static WritableRaster createWritableRaster(SampleModel sm,
                                                      Point location) {
<span class="nc bnc" id="L937" title="All 2 branches missed.">        if (location == null) {</span>
<span class="nc" id="L938">           location = new Point(0,0);</span>
        }

<span class="nc" id="L941">        return createWritableRaster(sm, sm.createDataBuffer(), location);</span>
    }

    /**
     *  Creates a WritableRaster with the specified SampleModel and DataBuffer.
     *  The upper left corner of the Raster is given by the location argument.
     *  If location is null, (0, 0) will be used.
     *  @param sm the specified &lt;code&gt;SampleModel&lt;/code&gt;
     *  @param db the specified &lt;code&gt;DataBuffer&lt;/code&gt;
     *  @param location the upper-left corner of the
     *         &lt;code&gt;WritableRaster&lt;/code&gt;
     *  @return a &lt;code&gt;WritableRaster&lt;/code&gt; with the specified
     *          &lt;code&gt;SampleModel&lt;/code&gt;, &lt;code&gt;DataBuffer&lt;/code&gt;, and
     *          location.
     * @throws RasterFormatException if computing either
     *         &lt;code&gt;location.x + sm.getWidth()&lt;/code&gt; or
     *         &lt;code&gt;location.y + sm.getHeight()&lt;/code&gt; results in integer
     *         overflow
     * @throws RasterFormatException if &lt;code&gt;db&lt;/code&gt; has more
     *         than one bank and &lt;code&gt;sm&lt;/code&gt; is a
     *         PixelInterleavedSampleModel, SinglePixelPackedSampleModel,
     *         or MultiPixelPackedSampleModel.
     * @throws NullPointerException if either SampleModel or DataBuffer is null
     */
    public static WritableRaster createWritableRaster(SampleModel sm,
                                                      DataBuffer db,
                                                      Point location) {
<span class="nc bnc" id="L968" title="All 4 branches missed.">        if ((sm == null) || (db == null)) {</span>
<span class="nc" id="L969">            throw new NullPointerException(&quot;SampleModel and DataBuffer cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (location == null) {</span>
<span class="nc" id="L972">           location = new Point(0,0);</span>
        }

<span class="nc" id="L975">        int dataType = sm.getDataType();</span>

<span class="nc bnc" id="L977" title="All 2 branches missed.">        if (sm instanceof PixelInterleavedSampleModel) {</span>
<span class="nc bnc" id="L978" title="All 3 branches missed.">            switch(dataType) {</span>
                case DataBuffer.TYPE_BYTE:
<span class="nc" id="L980">                    return new ByteInterleavedRaster(sm, db, location);</span>

                case DataBuffer.TYPE_USHORT:
<span class="nc" id="L983">                    return new ShortInterleavedRaster(sm, db, location);</span>
            }
<span class="nc bnc" id="L985" title="All 2 branches missed.">        } else if (sm instanceof SinglePixelPackedSampleModel) {</span>
<span class="nc bnc" id="L986" title="All 4 branches missed.">            switch(dataType) {</span>
                case DataBuffer.TYPE_BYTE:
<span class="nc" id="L988">                    return new ByteInterleavedRaster(sm, db, location);</span>

                case DataBuffer.TYPE_USHORT:
<span class="nc" id="L991">                    return new ShortInterleavedRaster(sm, db, location);</span>

                case DataBuffer.TYPE_INT:
<span class="nc" id="L994">                    return new IntegerInterleavedRaster(sm, db, location);</span>
            }
<span class="nc bnc" id="L996" title="All 4 branches missed.">        } else if (sm instanceof MultiPixelPackedSampleModel &amp;&amp;</span>
                   dataType == DataBuffer.TYPE_BYTE &amp;&amp;
<span class="nc bnc" id="L998" title="All 2 branches missed.">                   sm.getSampleSize(0) &lt; 8) {</span>
<span class="nc" id="L999">            return new BytePackedRaster(sm, db, location);</span>
        }

        // we couldn't do anything special - do the generic thing

<span class="nc" id="L1004">        return new SunWritableRaster(sm,db,location);</span>
    }

    /**
     *  Constructs a Raster with the given SampleModel.  The Raster's
     *  upper left corner is origin and it is the same size as the
     *  SampleModel.  A DataBuffer large enough to describe the
     *  Raster is automatically created.
     *  @param sampleModel     The SampleModel that specifies the layout
     *  @param origin          The Point that specified the origin
     *  @throws RasterFormatException if computing either
     *          &lt;code&gt;origin.x + sampleModel.getWidth()&lt;/code&gt; or
     *          &lt;code&gt;origin.y + sampleModel.getHeight()&lt;/code&gt; results in
     *          integer overflow
     *  @throws NullPointerException either &lt;code&gt;sampleModel&lt;/code&gt; or
     *          &lt;code&gt;origin&lt;/code&gt; is null
     */
    protected Raster(SampleModel sampleModel,
                     Point origin) {
<span class="nc" id="L1023">        this(sampleModel,</span>
<span class="nc" id="L1024">             sampleModel.createDataBuffer(),</span>
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L1027">                           sampleModel.getWidth(),</span>
<span class="nc" id="L1028">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L1031">    }</span>

    /**
     *  Constructs a Raster with the given SampleModel and DataBuffer.
     *  The Raster's upper left corner is origin and it is the same size
     *  as the SampleModel.  The DataBuffer is not initialized and must
     *  be compatible with SampleModel.
     *  @param sampleModel     The SampleModel that specifies the layout
     *  @param dataBuffer      The DataBuffer that contains the image data
     *  @param origin          The Point that specifies the origin
     *  @throws RasterFormatException if computing either
     *          &lt;code&gt;origin.x + sampleModel.getWidth()&lt;/code&gt; or
     *          &lt;code&gt;origin.y + sampleModel.getHeight()&lt;/code&gt; results in
     *          integer overflow
     *  @throws NullPointerException either &lt;code&gt;sampleModel&lt;/code&gt; or
     *          &lt;code&gt;origin&lt;/code&gt; is null
     */
    protected Raster(SampleModel sampleModel,
                     DataBuffer dataBuffer,
                     Point origin) {
<span class="nc" id="L1051">        this(sampleModel,</span>
             dataBuffer,
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L1055">                           sampleModel.getWidth(),</span>
<span class="nc" id="L1056">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L1059">    }</span>

    /**
     * Constructs a Raster with the given SampleModel, DataBuffer, and
     * parent.  aRegion specifies the bounding rectangle of the new
     * Raster.  When translated into the base Raster's coordinate
     * system, aRegion must be contained by the base Raster.
     * (The base Raster is the Raster's ancestor which has no parent.)
     * sampleModelTranslate specifies the sampleModelTranslateX and
     * sampleModelTranslateY values of the new Raster.
     *
     * Note that this constructor should generally be called by other
     * constructors or create methods, it should not be used directly.
     * @param sampleModel     The SampleModel that specifies the layout
     * @param dataBuffer      The DataBuffer that contains the image data
     * @param aRegion         The Rectangle that specifies the image area
     * @param sampleModelTranslate  The Point that specifies the translation
     *                        from SampleModel to Raster coordinates
     * @param parent          The parent (if any) of this raster
     * @throws NullPointerException if any of &lt;code&gt;sampleModel&lt;/code&gt;,
     *         &lt;code&gt;dataBuffer&lt;/code&gt;, &lt;code&gt;aRegion&lt;/code&gt; or
     *         &lt;code&gt;sampleModelTranslate&lt;/code&gt; is null
     * @throws RasterFormatException if &lt;code&gt;aRegion&lt;/code&gt; has width
     *         or height less than or equal to zero, or computing either
     *         &lt;code&gt;aRegion.x + aRegion.width&lt;/code&gt; or
     *         &lt;code&gt;aRegion.y + aRegion.height&lt;/code&gt; results in integer
     *         overflow
     */
    protected Raster(SampleModel sampleModel,
                     DataBuffer dataBuffer,
                     Rectangle aRegion,
                     Point sampleModelTranslate,
<span class="nc" id="L1091">                     Raster parent) {</span>

<span class="nc bnc" id="L1093" title="All 8 branches missed.">        if ((sampleModel == null) || (dataBuffer == null) ||</span>
            (aRegion == null) || (sampleModelTranslate == null)) {
<span class="nc" id="L1095">            throw new NullPointerException(&quot;SampleModel, dataBuffer, aRegion and &quot; +</span>
                                           &quot;sampleModelTranslate cannot be null&quot;);
        }
<span class="nc" id="L1098">       this.sampleModel = sampleModel;</span>
<span class="nc" id="L1099">       this.dataBuffer = dataBuffer;</span>
<span class="nc" id="L1100">       minX = aRegion.x;</span>
<span class="nc" id="L1101">       minY = aRegion.y;</span>
<span class="nc" id="L1102">       width = aRegion.width;</span>
<span class="nc" id="L1103">       height = aRegion.height;</span>
<span class="nc bnc" id="L1104" title="All 4 branches missed.">       if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">           throw new RasterFormatException(&quot;negative or zero &quot; +</span>
               ((width &lt;= 0) ? &quot;width&quot; : &quot;height&quot;));
       }
<span class="nc bnc" id="L1108" title="All 2 branches missed.">       if ((minX + width) &lt; minX) {</span>
<span class="nc" id="L1109">           throw new RasterFormatException(</span>
               &quot;overflow condition for X coordinates of Raster&quot;);
       }
<span class="nc bnc" id="L1112" title="All 2 branches missed.">       if ((minY + height) &lt; minY) {</span>
<span class="nc" id="L1113">           throw new RasterFormatException(</span>
               &quot;overflow condition for Y coordinates of Raster&quot;);
       }

<span class="nc" id="L1117">       sampleModelTranslateX = sampleModelTranslate.x;</span>
<span class="nc" id="L1118">       sampleModelTranslateY = sampleModelTranslate.y;</span>

<span class="nc" id="L1120">       numBands = sampleModel.getNumBands();</span>
<span class="nc" id="L1121">       numDataElements = sampleModel.getNumDataElements();</span>
<span class="nc" id="L1122">       this.parent = parent;</span>
<span class="nc" id="L1123">    }</span>


    /**
     * Returns the parent Raster (if any) of this Raster or null.
     * @return the parent Raster or &lt;code&gt;null&lt;/code&gt;.
     */
    public Raster getParent() {
<span class="nc" id="L1131">        return parent;</span>
    }

    /**
     * Returns the X translation from the coordinate system of the
     * SampleModel to that of the Raster.  To convert a pixel's X
     * coordinate from the Raster coordinate system to the SampleModel
     * coordinate system, this value must be subtracted.
     * @return the X translation from the coordinate space of the
     *         Raster's SampleModel to that of the Raster.
     */
    final public int getSampleModelTranslateX() {
<span class="nc" id="L1143">        return sampleModelTranslateX;</span>
    }

    /**
     * Returns the Y translation from the coordinate system of the
     * SampleModel to that of the Raster.  To convert a pixel's Y
     * coordinate from the Raster coordinate system to the SampleModel
     * coordinate system, this value must be subtracted.
     * @return the Y translation from the coordinate space of the
     *         Raster's SampleModel to that of the Raster.
     */
    final public int getSampleModelTranslateY() {
<span class="nc" id="L1155">        return sampleModelTranslateY;</span>
    }

    /**
     * Create a compatible WritableRaster the same size as this Raster with
     * the same SampleModel and a new initialized DataBuffer.
     * @return a compatible &lt;code&gt;WritableRaster&lt;/code&gt; with the same sample
     *         model and a new data buffer.
     */
    public WritableRaster createCompatibleWritableRaster() {
<span class="nc" id="L1165">        return new SunWritableRaster(sampleModel, new Point(0,0));</span>
    }

    /**
     * Create a compatible WritableRaster with the specified size, a new
     * SampleModel, and a new initialized DataBuffer.
     * @param w the specified width of the new &lt;code&gt;WritableRaster&lt;/code&gt;
     * @param h the specified height of the new &lt;code&gt;WritableRaster&lt;/code&gt;
     * @return a compatible &lt;code&gt;WritableRaster&lt;/code&gt; with the specified
     *         size and a new sample model and data buffer.
     * @exception RasterFormatException if the width or height is less than
     *                               or equal to zero.
     */
    public WritableRaster createCompatibleWritableRaster(int w, int h) {
<span class="nc bnc" id="L1179" title="All 4 branches missed.">        if (w &lt;= 0 || h &lt;=0) {</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">            throw new RasterFormatException(&quot;negative &quot; +</span>
                                          ((w &lt;= 0) ? &quot;width&quot; : &quot;height&quot;));
        }

<span class="nc" id="L1184">        SampleModel sm = sampleModel.createCompatibleSampleModel(w,h);</span>

<span class="nc" id="L1186">        return new SunWritableRaster(sm, new Point(0,0));</span>
    }

    /**
     * Create a compatible WritableRaster with location (minX, minY)
     * and size (width, height) specified by rect, a
     * new SampleModel, and a new initialized DataBuffer.
     * @param rect a &lt;code&gt;Rectangle&lt;/code&gt; that specifies the size and
     *        location of the &lt;code&gt;WritableRaster&lt;/code&gt;
     * @return a compatible &lt;code&gt;WritableRaster&lt;/code&gt; with the specified
     *         size and location and a new sample model and data buffer.
     * @throws RasterFormatException if &lt;code&gt;rect&lt;/code&gt; has width
     *         or height less than or equal to zero, or computing either
     *         &lt;code&gt;rect.x + rect.width&lt;/code&gt; or
     *         &lt;code&gt;rect.y + rect.height&lt;/code&gt; results in integer
     *         overflow
     * @throws NullPointerException if &lt;code&gt;rect&lt;/code&gt; is null
     */
    public WritableRaster createCompatibleWritableRaster(Rectangle rect) {
<span class="nc bnc" id="L1205" title="All 2 branches missed.">        if (rect == null) {</span>
<span class="nc" id="L1206">            throw new NullPointerException(&quot;Rect cannot be null&quot;);</span>
        }
<span class="nc" id="L1208">        return createCompatibleWritableRaster(rect.x, rect.y,</span>
                                              rect.width, rect.height);
    }

    /**
     * Create a compatible WritableRaster with the specified
     * location (minX, minY) and size (width, height), a
     * new SampleModel, and a new initialized DataBuffer.
     * @param x the X coordinate of the upper-left corner of
     *        the &lt;code&gt;WritableRaster&lt;/code&gt;
     * @param y the Y coordinate of the upper-left corner of
     *        the &lt;code&gt;WritableRaster&lt;/code&gt;
     * @param w the specified width of the &lt;code&gt;WritableRaster&lt;/code&gt;
     * @param h the specified height of the &lt;code&gt;WritableRaster&lt;/code&gt;
     * @return a compatible &lt;code&gt;WritableRaster&lt;/code&gt; with the specified
     *         size and location and a new sample model and data buffer.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing either
     *         &lt;code&gt;x + w&lt;/code&gt; or
     *         &lt;code&gt;y + h&lt;/code&gt; results in integer
     *         overflow
     */
    public WritableRaster createCompatibleWritableRaster(int x, int y,
                                                         int w, int h) {
<span class="nc" id="L1232">        WritableRaster ret = createCompatibleWritableRaster(w, h);</span>
<span class="nc" id="L1233">        return ret.createWritableChild(0,0,w,h,x,y,null);</span>
    }

    /**
     * Create a Raster with the same size, SampleModel and DataBuffer
     * as this one, but with a different location.  The new Raster
     * will possess a reference to the current Raster, accessible
     * through its getParent() method.
     *
     * @param childMinX the X coordinate of the upper-left
     *        corner of the new &lt;code&gt;Raster&lt;/code&gt;
     * @param childMinY the Y coordinate of the upper-left
     *        corner of the new &lt;code&gt;Raster&lt;/code&gt;
     * @return a new &lt;code&gt;Raster&lt;/code&gt; with the same size, SampleModel,
     *         and DataBuffer as this &lt;code&gt;Raster&lt;/code&gt;, but with the
     *         specified location.
     * @throws RasterFormatException if  computing either
     *         &lt;code&gt;childMinX + this.getWidth()&lt;/code&gt; or
     *         &lt;code&gt;childMinY + this.getHeight()&lt;/code&gt; results in integer
     *         overflow
     */
    public Raster createTranslatedChild(int childMinX, int childMinY) {
<span class="nc" id="L1255">        return createChild(minX,minY,width,height,</span>
                           childMinX,childMinY,null);
    }

    /**
     * Returns a new Raster which shares all or part of this Raster's
     * DataBuffer.  The new Raster will possess a reference to the
     * current Raster, accessible through its getParent() method.
     *
     * &lt;p&gt; The parentX, parentY, width and height parameters
     * form a Rectangle in this Raster's coordinate space,
     * indicating the area of pixels to be shared.  An error will
     * be thrown if this Rectangle is not contained with the bounds
     * of the current Raster.
     *
     * &lt;p&gt; The new Raster may additionally be translated to a
     * different coordinate system for the plane than that used by the current
     * Raster.  The childMinX and childMinY parameters give the new
     * (x, y) coordinate of the upper-left pixel of the returned
     * Raster; the coordinate (childMinX, childMinY) in the new Raster
     * will map to the same pixel as the coordinate (parentX, parentY)
     * in the current Raster.
     *
     * &lt;p&gt; The new Raster may be defined to contain only a subset of
     * the bands of the current Raster, possibly reordered, by means
     * of the bandList parameter.  If bandList is null, it is taken to
     * include all of the bands of the current Raster in their current
     * order.
     *
     * &lt;p&gt; To create a new Raster that contains a subregion of the current
     * Raster, but shares its coordinate system and bands,
     * this method should be called with childMinX equal to parentX,
     * childMinY equal to parentY, and bandList equal to null.
     *
     * @param parentX The X coordinate of the upper-left corner
     *        in this Raster's coordinates
     * @param parentY The Y coordinate of the upper-left corner
     *        in this Raster's coordinates
     * @param width      Width of the region starting at (parentX, parentY)
     * @param height     Height of the region starting at (parentX, parentY).
     * @param childMinX The X coordinate of the upper-left corner
     *                   of the returned Raster
     * @param childMinY The Y coordinate of the upper-left corner
     *                   of the returned Raster
     * @param bandList   Array of band indices, or null to use all bands
     * @return a new &lt;code&gt;Raster&lt;/code&gt;.
     * @exception RasterFormatException if the specified subregion is outside
     *                               of the raster bounds.
     * @throws RasterFormatException if &lt;code&gt;width&lt;/code&gt; or
     *         &lt;code&gt;height&lt;/code&gt;
     *         is less than or equal to zero, or computing any of
     *         &lt;code&gt;parentX + width&lt;/code&gt;, &lt;code&gt;parentY + height&lt;/code&gt;,
     *         &lt;code&gt;childMinX + width&lt;/code&gt;, or
     *         &lt;code&gt;childMinY + height&lt;/code&gt; results in integer
     *         overflow
     */
    public Raster createChild(int parentX, int parentY,
                              int width, int height,
                              int childMinX, int childMinY,
                              int bandList[]) {
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        if (parentX &lt; this.minX) {</span>
<span class="nc" id="L1316">            throw new RasterFormatException(&quot;parentX lies outside raster&quot;);</span>
        }
<span class="nc bnc" id="L1318" title="All 2 branches missed.">        if (parentY &lt; this.minY) {</span>
<span class="nc" id="L1319">            throw new RasterFormatException(&quot;parentY lies outside raster&quot;);</span>
        }
<span class="nc bnc" id="L1321" title="All 4 branches missed.">        if ((parentX + width &lt; parentX) ||</span>
            (parentX + width &gt; this.width + this.minX)) {
<span class="nc" id="L1323">            throw new RasterFormatException(&quot;(parentX + width) is outside raster&quot;);</span>
        }
<span class="nc bnc" id="L1325" title="All 4 branches missed.">        if ((parentY + height &lt; parentY) ||</span>
            (parentY + height &gt; this.height + this.minY)) {
<span class="nc" id="L1327">            throw new RasterFormatException(&quot;(parentY + height) is outside raster&quot;);</span>
        }

        SampleModel subSampleModel;
        // Note: the SampleModel for the child Raster should have the same
        // width and height as that for the parent, since it represents
        // the physical layout of the pixel data.  The child Raster's width
        // and height represent a &quot;virtual&quot; view of the pixel data, so
        // they may be different than those of the SampleModel.
<span class="nc bnc" id="L1336" title="All 2 branches missed.">        if (bandList == null) {</span>
<span class="nc" id="L1337">            subSampleModel = sampleModel;</span>
        } else {
<span class="nc" id="L1339">            subSampleModel = sampleModel.createSubsetSampleModel(bandList);</span>
        }

<span class="nc" id="L1342">        int deltaX = childMinX - parentX;</span>
<span class="nc" id="L1343">        int deltaY = childMinY - parentY;</span>

<span class="nc" id="L1345">        return new Raster(subSampleModel, getDataBuffer(),</span>
                          new Rectangle(childMinX, childMinY, width, height),
                          new Point(sampleModelTranslateX + deltaX,
                                    sampleModelTranslateY + deltaY), this);
    }

    /**
     * Returns the bounding Rectangle of this Raster. This function returns
     * the same information as getMinX/MinY/Width/Height.
     * @return the bounding box of this &lt;code&gt;Raster&lt;/code&gt;.
     */
    public Rectangle getBounds() {
<span class="nc" id="L1357">        return new Rectangle(minX, minY, width, height);</span>
    }

    /** Returns the minimum valid X coordinate of the Raster.
     *  @return the minimum x coordinate of this &lt;code&gt;Raster&lt;/code&gt;.
     */
    final public int getMinX() {
<span class="nc" id="L1364">        return minX;</span>
    }

    /** Returns the minimum valid Y coordinate of the Raster.
     *  @return the minimum y coordinate of this &lt;code&gt;Raster&lt;/code&gt;.
     */
    final public int getMinY() {
<span class="nc" id="L1371">        return minY;</span>
    }

    /** Returns the width in pixels of the Raster.
     *  @return the width of this &lt;code&gt;Raster&lt;/code&gt;.
     */
    final public int getWidth() {
<span class="nc" id="L1378">        return width;</span>
    }

    /** Returns the height in pixels of the Raster.
     *  @return the height of this &lt;code&gt;Raster&lt;/code&gt;.
     */
    final public int getHeight() {
<span class="nc" id="L1385">        return height;</span>
    }

    /** Returns the number of bands (samples per pixel) in this Raster.
     *  @return the number of bands of this &lt;code&gt;Raster&lt;/code&gt;.
     */
    final public int getNumBands() {
<span class="nc" id="L1392">        return numBands;</span>
    }

    /**
     *  Returns the number of data elements needed to transfer one pixel
     *  via the getDataElements and setDataElements methods.  When pixels
     *  are transferred via these methods, they may be transferred in a
     *  packed or unpacked format, depending on the implementation of the
     *  underlying SampleModel.  Using these methods, pixels are transferred
     *  as an array of getNumDataElements() elements of a primitive type given
     *  by getTransferType().  The TransferType may or may not be the same
     *  as the storage data type of the DataBuffer.
     *  @return the number of data elements.
     */
    final public int getNumDataElements() {
<span class="nc" id="L1407">        return sampleModel.getNumDataElements();</span>
    }

    /**
     *  Returns the TransferType used to transfer pixels via the
     *  getDataElements and setDataElements methods.  When pixels
     *  are transferred via these methods, they may be transferred in a
     *  packed or unpacked format, depending on the implementation of the
     *  underlying SampleModel.  Using these methods, pixels are transferred
     *  as an array of getNumDataElements() elements of a primitive type given
     *  by getTransferType().  The TransferType may or may not be the same
     *  as the storage data type of the DataBuffer.  The TransferType will
     *  be one of the types defined in DataBuffer.
     *  @return this transfer type.
     */
    final public int getTransferType() {
<span class="nc" id="L1423">        return sampleModel.getTransferType();</span>
    }

    /** Returns the DataBuffer associated with this Raster.
     *  @return the &lt;code&gt;DataBuffer&lt;/code&gt; of this &lt;code&gt;Raster&lt;/code&gt;.
     */
    public DataBuffer getDataBuffer() {
<span class="nc" id="L1430">        return dataBuffer;</span>
    }

    /** Returns the SampleModel that describes the layout of the image data.
     *  @return the &lt;code&gt;SampleModel&lt;/code&gt; of this &lt;code&gt;Raster&lt;/code&gt;.
     */
    public SampleModel getSampleModel() {
<span class="nc" id="L1437">        return sampleModel;</span>
    }

    /**
     * Returns data for a single pixel in a primitive array of type
     * TransferType.  For image data supported by the Java 2D(tm) API,
     * this will be one of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,
     * DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT,
     * or DataBuffer.TYPE_DOUBLE.  Data may be returned in a packed format,
     * thus increasing efficiency for data transfers.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of TransferType.
     * @see java.awt.image.SampleModel#getDataElements(int, int, Object, DataBuffer)
     * @param x        The X coordinate of the pixel location
     * @param y        The Y coordinate of the pixel location
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length getNumDataElements().
     *                 If null, an array of appropriate type and size will be
     *                 allocated
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the requested pixel data.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if outData is too small to hold the output.
     */
    public Object getDataElements(int x, int y, Object outData) {
<span class="nc" id="L1466">        return sampleModel.getDataElements(x - sampleModelTranslateX,</span>
                                           y - sampleModelTranslateY,
                                           outData, dataBuffer);
    }

    /**
     * Returns the pixel data for the specified rectangle of pixels in a
     * primitive array of type TransferType.
     * For image data supported by the Java 2D API, this
     * will be one of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,
     * DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT,
     * or DataBuffer.TYPE_DOUBLE.  Data may be returned in a packed format,
     * thus increasing efficiency for data transfers.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * A ClassCastException will be thrown if the input object is non null
     * and references anything other than an array of TransferType.
     * @see java.awt.image.SampleModel#getDataElements(int, int, int, int, Object, DataBuffer)
     * @param x    The X coordinate of the upper-left pixel location
     * @param y    The Y coordinate of the upper-left pixel location
     * @param w    Width of the pixel rectangle
     * @param h   Height of the pixel rectangle
     * @param outData  An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements().
     *                 If null, an array of appropriate type and size will be
     *                 allocated.
     * @return         An object reference to an array of type defined by
     *                 getTransferType() with the requested pixel data.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if outData is too small to hold the output.
     */
    public Object getDataElements(int x, int y, int w, int h, Object outData) {
<span class="nc" id="L1500">        return sampleModel.getDataElements(x - sampleModelTranslateX,</span>
                                           y - sampleModelTranslateY,
                                           w, h, outData, dataBuffer);
    }

    /**
     * Returns the samples in an array of int for the specified pixel.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x The X coordinate of the pixel location
     * @param y The Y coordinate of the pixel location
     * @param iArray An optionally preallocated int array
     * @return the samples for the specified pixel.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if iArray is too small to hold the output.
     */
    public int[] getPixel(int x, int y, int iArray[]) {
<span class="nc" id="L1519">        return sampleModel.getPixel(x - sampleModelTranslateX,</span>
                                    y - sampleModelTranslateY,
                                    iArray, dataBuffer);
    }

    /**
     * Returns the samples in an array of float for the
     * specified pixel.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x The X coordinate of the pixel location
     * @param y The Y coordinate of the pixel location
     * @param fArray An optionally preallocated float array
     * @return the samples for the specified pixel.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if fArray is too small to hold the output.
     */
    public float[] getPixel(int x, int y, float fArray[]) {
<span class="nc" id="L1539">        return sampleModel.getPixel(x - sampleModelTranslateX,</span>
                                    y - sampleModelTranslateY,
                                    fArray, dataBuffer);
    }

    /**
     * Returns the samples in an array of double for the specified pixel.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x The X coordinate of the pixel location
     * @param y The Y coordinate of the pixel location
     * @param dArray An optionally preallocated double array
     * @return the samples for the specified pixel.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if dArray is too small to hold the output.
     */
    public double[] getPixel(int x, int y, double dArray[]) {
<span class="nc" id="L1558">        return sampleModel.getPixel(x - sampleModelTranslateX,</span>
                                    y - sampleModelTranslateY,
                                    dArray, dataBuffer);
    }

    /**
     * Returns an int array containing all samples for a rectangle of pixels,
     * one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x      The X coordinate of the upper-left pixel location
     * @param y      The Y coordinate of the upper-left pixel location
     * @param w      Width of the pixel rectangle
     * @param h      Height of the pixel rectangle
     * @param iArray An optionally pre-allocated int array
     * @return the samples for the specified rectangle of pixels.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if iArray is too small to hold the output.
     */
    public int[] getPixels(int x, int y, int w, int h, int iArray[]) {
<span class="nc" id="L1580">        return sampleModel.getPixels(x - sampleModelTranslateX,</span>
                                     y - sampleModelTranslateY, w, h,
                                     iArray, dataBuffer);
    }

    /**
     * Returns a float array containing all samples for a rectangle of pixels,
     * one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x        The X coordinate of the pixel location
     * @param y        The Y coordinate of the pixel location
     * @param w        Width of the pixel rectangle
     * @param h        Height of the pixel rectangle
     * @param fArray   An optionally pre-allocated float array
     * @return the samples for the specified rectangle of pixels.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if fArray is too small to hold the output.
     */
    public float[] getPixels(int x, int y, int w, int h,
                             float fArray[]) {
<span class="nc" id="L1603">        return sampleModel.getPixels(x - sampleModelTranslateX,</span>
                                     y - sampleModelTranslateY, w, h,
                                     fArray, dataBuffer);
    }

    /**
     * Returns a double array containing all samples for a rectangle of pixels,
     * one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x        The X coordinate of the upper-left pixel location
     * @param y        The Y coordinate of the upper-left pixel location
     * @param w        Width of the pixel rectangle
     * @param h        Height of the pixel rectangle
     * @param dArray   An optionally pre-allocated double array
     * @return the samples for the specified rectangle of pixels.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if dArray is too small to hold the output.
     */
    public double[] getPixels(int x, int y, int w, int h,
                              double dArray[]) {
<span class="nc" id="L1626">        return sampleModel.getPixels(x - sampleModelTranslateX,</span>
                                     y - sampleModelTranslateY,
                                     w, h, dArray, dataBuffer);
    }


    /**
     * Returns the sample in a specified band for the pixel located
     * at (x,y) as an int.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x        The X coordinate of the pixel location
     * @param y        The Y coordinate of the pixel location
     * @param b        The band to return
     * @return the sample in the specified band for the pixel at the
     *         specified coordinate.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds.
     */
    public int getSample(int x, int y, int b) {
<span class="nc" id="L1648">        return sampleModel.getSample(x - sampleModelTranslateX,</span>
                                     y - sampleModelTranslateY, b,
                                     dataBuffer);
    }

    /**
     * Returns the sample in a specified band
     * for the pixel located at (x,y) as a float.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x        The X coordinate of the pixel location
     * @param y        The Y coordinate of the pixel location
     * @param b        The band to return
     * @return the sample in the specified band for the pixel at the
     *         specified coordinate.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds.
     */
    public float getSampleFloat(int x, int y, int b) {
<span class="nc" id="L1669">        return sampleModel.getSampleFloat(x - sampleModelTranslateX,</span>
                                          y - sampleModelTranslateY, b,
                                          dataBuffer);
    }

    /**
     * Returns the sample in a specified band
     * for a pixel located at (x,y) as a double.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x        The X coordinate of the pixel location
     * @param y        The Y coordinate of the pixel location
     * @param b        The band to return
     * @return the sample in the specified band for the pixel at the
     *         specified coordinate.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds.
     */
    public double getSampleDouble(int x, int y, int b) {
<span class="nc" id="L1690">        return sampleModel.getSampleDouble(x - sampleModelTranslateX,</span>
                                           y - sampleModelTranslateY,
                                           b, dataBuffer);
    }

    /**
     * Returns the samples for a specified band for the specified rectangle
     * of pixels in an int array, one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x        The X coordinate of the upper-left pixel location
     * @param y        The Y coordinate of the upper-left pixel location
     * @param w        Width of the pixel rectangle
     * @param h        Height of the pixel rectangle
     * @param b        The band to return
     * @param iArray   An optionally pre-allocated int array
     * @return the samples for the specified band for the specified
     *         rectangle of pixels.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds, or if iArray is too small to
     * hold the output.
     */
    public int[] getSamples(int x, int y, int w, int h, int b,
                            int iArray[]) {
<span class="nc" id="L1716">        return sampleModel.getSamples(x - sampleModelTranslateX,</span>
                                      y - sampleModelTranslateY,
                                      w, h, b, iArray,
                                      dataBuffer);
    }

    /**
     * Returns the samples for a specified band for the specified rectangle
     * of pixels in a float array, one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x        The X coordinate of the upper-left pixel location
     * @param y        The Y coordinate of the upper-left pixel location
     * @param w        Width of the pixel rectangle
     * @param h        Height of the pixel rectangle
     * @param b        The band to return
     * @param fArray   An optionally pre-allocated float array
     * @return the samples for the specified band for the specified
     *         rectangle of pixels.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds, or if fArray is too small to
     * hold the output.
     */
    public float[] getSamples(int x, int y, int w, int h, int b,
                              float fArray[]) {
<span class="nc" id="L1743">        return sampleModel.getSamples(x - sampleModelTranslateX,</span>
                                      y - sampleModelTranslateY,
                                      w, h, b, fArray, dataBuffer);
    }

    /**
     * Returns the samples for a specified band for a specified rectangle
     * of pixels in a double array, one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown
     * if the coordinates are not in bounds.  However, explicit bounds
     * checking is not guaranteed.
     * @param x        The X coordinate of the upper-left pixel location
     * @param y        The Y coordinate of the upper-left pixel location
     * @param w        Width of the pixel rectangle
     * @param h        Height of the pixel rectangle
     * @param b        The band to return
     * @param dArray   An optionally pre-allocated double array
     * @return the samples for the specified band for the specified
     *         rectangle of pixels.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds, or if dArray is too small to
     * hold the output.
     */
    public double[] getSamples(int x, int y, int w, int h, int b,
                               double dArray[]) {
<span class="nc" id="L1769">         return sampleModel.getSamples(x - sampleModelTranslateX,</span>
                                       y - sampleModelTranslateY,
                                       w, h, b, dArray, dataBuffer);
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>