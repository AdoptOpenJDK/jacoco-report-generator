<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RGBImageFilter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">RGBImageFilter.java</span></div><h1>RGBImageFilter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.image.ImageConsumer;
import java.awt.image.ColorModel;

/**
 * This class provides an easy way to create an ImageFilter which modifies
 * the pixels of an image in the default RGB ColorModel.  It is meant to
 * be used in conjunction with a FilteredImageSource object to produce
 * filtered versions of existing images.  It is an abstract class that
 * provides the calls needed to channel all of the pixel data through a
 * single method which converts pixels one at a time in the default RGB
 * ColorModel regardless of the ColorModel being used by the ImageProducer.
 * The only method which needs to be defined to create a useable image
 * filter is the filterRGB method.  Here is an example of a definition
 * of a filter which swaps the red and blue components of an image:
 * &lt;pre&gt;{@code
 *
 *      class RedBlueSwapFilter extends RGBImageFilter {
 *          public RedBlueSwapFilter() {
 *              // The filter's operation does not depend on the
 *              // pixel's location, so IndexColorModels can be
 *              // filtered directly.
 *              canFilterIndexColorModel = true;
 *          }
 *
 *          public int filterRGB(int x, int y, int rgb) {
 *              return ((rgb &amp; 0xff00ff00)
 *                      | ((rgb &amp; 0xff0000) &gt;&gt; 16)
 *                      | ((rgb &amp; 0xff) &lt;&lt; 16));
 *          }
 *      }
 *
 * }&lt;/pre&gt;
 *
 * @see FilteredImageSource
 * @see ImageFilter
 * @see ColorModel#getRGBdefault
 *
 * @author      Jim Graham
 */
<span class="nc" id="L67">public abstract class RGBImageFilter extends ImageFilter {</span>

    /**
     * The &lt;code&gt;ColorModel&lt;/code&gt; to be replaced by
     * &lt;code&gt;newmodel&lt;/code&gt; when the user calls
     * {@link #substituteColorModel(ColorModel, ColorModel) substituteColorModel}.
     */
    protected ColorModel origmodel;

    /**
     * The &lt;code&gt;ColorModel&lt;/code&gt; with which to
     * replace &lt;code&gt;origmodel&lt;/code&gt; when the user calls
     * &lt;code&gt;substituteColorModel&lt;/code&gt;.
     */
    protected ColorModel newmodel;

    /**
     * This boolean indicates whether or not it is acceptable to apply
     * the color filtering of the filterRGB method to the color table
     * entries of an IndexColorModel object in lieu of pixel by pixel
     * filtering.  Subclasses should set this variable to true in their
     * constructor if their filterRGB method does not depend on the
     * coordinate of the pixel being filtered.
     * @see #substituteColorModel
     * @see #filterRGB
     * @see IndexColorModel
     */
    protected boolean canFilterIndexColorModel;

    /**
     * If the ColorModel is an IndexColorModel and the subclass has
     * set the canFilterIndexColorModel flag to true, we substitute
     * a filtered version of the color model here and wherever
     * that original ColorModel object appears in the setPixels methods.
     * If the ColorModel is not an IndexColorModel or is null, this method
     * overrides the default ColorModel used by the ImageProducer and
     * specifies the default RGB ColorModel instead.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels
     * are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     * @see ImageConsumer
     * @see ColorModel#getRGBdefault
     */
    public void setColorModel(ColorModel model) {
<span class="nc bnc" id="L115" title="All 4 branches missed.">        if (canFilterIndexColorModel &amp;&amp; (model instanceof IndexColorModel)) {</span>
<span class="nc" id="L116">            ColorModel newcm = filterIndexColorModel((IndexColorModel)model);</span>
<span class="nc" id="L117">            substituteColorModel(model, newcm);</span>
<span class="nc" id="L118">            consumer.setColorModel(newcm);</span>
<span class="nc" id="L119">        } else {</span>
<span class="nc" id="L120">            consumer.setColorModel(ColorModel.getRGBdefault());</span>
        }
<span class="nc" id="L122">    }</span>

    /**
     * Registers two ColorModel objects for substitution.  If the oldcm
     * is encountered during any of the setPixels methods, the newcm
     * is substituted and the pixels passed through
     * untouched (but with the new ColorModel object).
     * @param oldcm the ColorModel object to be replaced on the fly
     * @param newcm the ColorModel object to replace oldcm on the fly
     */
    public void substituteColorModel(ColorModel oldcm, ColorModel newcm) {
<span class="nc" id="L133">        origmodel = oldcm;</span>
<span class="nc" id="L134">        newmodel = newcm;</span>
<span class="nc" id="L135">    }</span>

    /**
     * Filters an IndexColorModel object by running each entry in its
     * color tables through the filterRGB function that RGBImageFilter
     * subclasses must provide.  Uses coordinates of -1 to indicate that
     * a color table entry is being filtered rather than an actual
     * pixel value.
     * @param icm the IndexColorModel object to be filtered
     * @exception NullPointerException if &lt;code&gt;icm&lt;/code&gt; is null
     * @return a new IndexColorModel representing the filtered colors
     */
    public IndexColorModel filterIndexColorModel(IndexColorModel icm) {
<span class="nc" id="L148">        int mapsize = icm.getMapSize();</span>
<span class="nc" id="L149">        byte r[] = new byte[mapsize];</span>
<span class="nc" id="L150">        byte g[] = new byte[mapsize];</span>
<span class="nc" id="L151">        byte b[] = new byte[mapsize];</span>
<span class="nc" id="L152">        byte a[] = new byte[mapsize];</span>
<span class="nc" id="L153">        icm.getReds(r);</span>
<span class="nc" id="L154">        icm.getGreens(g);</span>
<span class="nc" id="L155">        icm.getBlues(b);</span>
<span class="nc" id="L156">        icm.getAlphas(a);</span>
<span class="nc" id="L157">        int trans = icm.getTransparentPixel();</span>
<span class="nc" id="L158">        boolean needalpha = false;</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        for (int i = 0; i &lt; mapsize; i++) {</span>
<span class="nc" id="L160">            int rgb = filterRGB(-1, -1, icm.getRGB(i));</span>
<span class="nc" id="L161">            a[i] = (byte) (rgb &gt;&gt; 24);</span>
<span class="nc bnc" id="L162" title="All 4 branches missed.">            if (a[i] != ((byte)0xff) &amp;&amp; i != trans) {</span>
<span class="nc" id="L163">                needalpha = true;</span>
            }
<span class="nc" id="L165">            r[i] = (byte) (rgb &gt;&gt; 16);</span>
<span class="nc" id="L166">            g[i] = (byte) (rgb &gt;&gt; 8);</span>
<span class="nc" id="L167">            b[i] = (byte) (rgb &gt;&gt; 0);</span>
        }
<span class="nc bnc" id="L169" title="All 2 branches missed.">        if (needalpha) {</span>
<span class="nc" id="L170">            return new IndexColorModel(icm.getPixelSize(), mapsize,</span>
                                       r, g, b, a);
        } else {
<span class="nc" id="L173">            return new IndexColorModel(icm.getPixelSize(), mapsize,</span>
                                       r, g, b, trans);
        }
    }

    /**
     * Filters a buffer of pixels in the default RGB ColorModel by passing
     * them one by one through the filterRGB method.
     * @param x the X coordinate of the upper-left corner of the region
     *          of pixels
     * @param y the Y coordinate of the upper-left corner of the region
     *          of pixels
     * @param w the width of the region of pixels
     * @param h the height of the region of pixels
     * @param pixels the array of pixels
     * @param off the offset into the &lt;code&gt;pixels&lt;/code&gt; array
     * @param scansize the distance from one row of pixels to the next
     *        in the array
     * @see ColorModel#getRGBdefault
     * @see #filterRGB
     */
    public void filterRGBPixels(int x, int y, int w, int h,
                                int pixels[], int off, int scansize) {
<span class="nc" id="L196">        int index = off;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">        for (int cy = 0; cy &lt; h; cy++) {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">            for (int cx = 0; cx &lt; w; cx++) {</span>
<span class="nc" id="L199">                pixels[index] = filterRGB(x + cx, y + cy, pixels[index]);</span>
<span class="nc" id="L200">                index++;</span>
            }
<span class="nc" id="L202">            index += scansize - w;</span>
        }
<span class="nc" id="L204">        consumer.setPixels(x, y, w, h, ColorModel.getRGBdefault(),</span>
                           pixels, off, scansize);
<span class="nc" id="L206">    }</span>

    /**
     * If the ColorModel object is the same one that has already
     * been converted, then simply passes the pixels through with the
     * converted ColorModel. Otherwise converts the buffer of byte
     * pixels to the default RGB ColorModel and passes the converted
     * buffer to the filterRGBPixels method to be converted one by one.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels
     * are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     * @see ColorModel#getRGBdefault
     * @see #filterRGBPixels
     */
    public void setPixels(int x, int y, int w, int h,
                          ColorModel model, byte pixels[], int off,
                          int scansize) {
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (model == origmodel) {</span>
<span class="nc" id="L228">            consumer.setPixels(x, y, w, h, newmodel, pixels, off, scansize);</span>
        } else {
<span class="nc" id="L230">            int filteredpixels[] = new int[w];</span>
<span class="nc" id="L231">            int index = off;</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            for (int cy = 0; cy &lt; h; cy++) {</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                for (int cx = 0; cx &lt; w; cx++) {</span>
<span class="nc" id="L234">                    filteredpixels[cx] = model.getRGB((pixels[index] &amp; 0xff));</span>
<span class="nc" id="L235">                    index++;</span>
                }
<span class="nc" id="L237">                index += scansize - w;</span>
<span class="nc" id="L238">                filterRGBPixels(x, y + cy, w, 1, filteredpixels, 0, w);</span>
            }
        }
<span class="nc" id="L241">    }</span>

    /**
     * If the ColorModel object is the same one that has already
     * been converted, then simply passes the pixels through with the
     * converted ColorModel, otherwise converts the buffer of integer
     * pixels to the default RGB ColorModel and passes the converted
     * buffer to the filterRGBPixels method to be converted one by one.
     * Converts a buffer of integer pixels to the default RGB ColorModel
     * and passes the converted buffer to the filterRGBPixels method.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels
     * are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     * @see ColorModel#getRGBdefault
     * @see #filterRGBPixels
     */
    public void setPixels(int x, int y, int w, int h,
                          ColorModel model, int pixels[], int off,
                          int scansize) {
<span class="nc bnc" id="L264" title="All 2 branches missed.">        if (model == origmodel) {</span>
<span class="nc" id="L265">            consumer.setPixels(x, y, w, h, newmodel, pixels, off, scansize);</span>
        } else {
<span class="nc" id="L267">            int filteredpixels[] = new int[w];</span>
<span class="nc" id="L268">            int index = off;</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            for (int cy = 0; cy &lt; h; cy++) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                for (int cx = 0; cx &lt; w; cx++) {</span>
<span class="nc" id="L271">                    filteredpixels[cx] = model.getRGB(pixels[index]);</span>
<span class="nc" id="L272">                    index++;</span>
                }
<span class="nc" id="L274">                index += scansize - w;</span>
<span class="nc" id="L275">                filterRGBPixels(x, y + cy, w, 1, filteredpixels, 0, w);</span>
            }
        }
<span class="nc" id="L278">    }</span>

    /**
     * Subclasses must specify a method to convert a single input pixel
     * in the default RGB ColorModel to a single output pixel.
     * @param x the X coordinate of the pixel
     * @param y the Y coordinate of the pixel
     * @param rgb the integer pixel representation in the default RGB
     *            color model
     * @return a filtered pixel in the default RGB color model.
     * @see ColorModel#getRGBdefault
     * @see #filterRGBPixels
     */
    public abstract int filterRGB(int x, int y, int rgb);
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>