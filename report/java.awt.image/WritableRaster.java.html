<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>WritableRaster.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">WritableRaster.java</span></div><h1>WritableRaster.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/* ****************************************************************
 ******************************************************************
 ******************************************************************
 *** COPYRIGHT (c) Eastman Kodak Company, 1997
 *** As  an unpublished  work pursuant to Title 17 of the United
 *** States Code.  All rights reserved.
 ******************************************************************
 ******************************************************************
 ******************************************************************/

package java.awt.image;
import java.awt.Rectangle;
import java.awt.Point;

/**
 * This class extends Raster to provide pixel writing capabilities.
 * Refer to the class comment for Raster for descriptions of how
 * a Raster stores pixels.
 *
 * &lt;p&gt; The constructors of this class are protected.  To instantiate
 * a WritableRaster, use one of the createWritableRaster factory methods
 * in the Raster class.
 */
public class WritableRaster extends Raster {

    /**
     *  Constructs a WritableRaster with the given SampleModel.  The
     *  WritableRaster's upper left corner is origin and it is the
     *  same size as the  SampleModel.  A DataBuffer large enough to
     *  describe the WritableRaster is automatically created.
     *  @param sampleModel     The SampleModel that specifies the layout.
     *  @param origin          The Point that specifies the origin.
     *  @throws RasterFormatException if computing either
     *          &lt;code&gt;origin.x + sampleModel.getWidth()&lt;/code&gt; or
     *          &lt;code&gt;origin.y + sampleModel.getHeight()&lt;/code&gt; results
     *          in integer overflow
     */
    protected WritableRaster(SampleModel sampleModel,
                             Point origin) {
<span class="nc" id="L65">        this(sampleModel,</span>
<span class="nc" id="L66">             sampleModel.createDataBuffer(),</span>
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L69">                           sampleModel.getWidth(),</span>
<span class="nc" id="L70">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L73">    }</span>

    /**
     *  Constructs a WritableRaster with the given SampleModel and DataBuffer.
     *  The WritableRaster's upper left corner is origin and it is the same
     *  size as the SampleModel.  The DataBuffer is not initialized and must
     *  be compatible with SampleModel.
     *  @param sampleModel     The SampleModel that specifies the layout.
     *  @param dataBuffer      The DataBuffer that contains the image data.
     *  @param origin          The Point that specifies the origin.
     *  @throws RasterFormatException if computing either
     *          &lt;code&gt;origin.x + sampleModel.getWidth()&lt;/code&gt; or
     *          &lt;code&gt;origin.y + sampleModel.getHeight()&lt;/code&gt; results
     *          in integer overflow
     */
    protected WritableRaster(SampleModel sampleModel,
                             DataBuffer dataBuffer,
                             Point origin) {
<span class="nc" id="L91">        this(sampleModel,</span>
             dataBuffer,
             new Rectangle(origin.x,
                           origin.y,
<span class="nc" id="L95">                           sampleModel.getWidth(),</span>
<span class="nc" id="L96">                           sampleModel.getHeight()),</span>
             origin,
             null);
<span class="nc" id="L99">    }</span>

    /**
     * Constructs a WritableRaster with the given SampleModel, DataBuffer,
     * and parent.  aRegion specifies the bounding rectangle of the new
     * Raster.  When translated into the base Raster's coordinate
     * system, aRegion must be contained by the base Raster.
     * (The base Raster is the Raster's ancestor which has no parent.)
     * sampleModelTranslate specifies the sampleModelTranslateX and
     * sampleModelTranslateY values of the new Raster.
     *
     * Note that this constructor should generally be called by other
     * constructors or create methods, it should not be used directly.
     * @param sampleModel     The SampleModel that specifies the layout.
     * @param dataBuffer      The DataBuffer that contains the image data.
     * @param aRegion         The Rectangle that specifies the image area.
     * @param sampleModelTranslate  The Point that specifies the translation
     *                        from SampleModel to Raster coordinates.
     * @param parent          The parent (if any) of this raster.
     * @throws RasterFormatException if &lt;code&gt;aRegion&lt;/code&gt; has width
     *         or height less than or equal to zero, or computing either
     *         &lt;code&gt;aRegion.x + aRegion.width&lt;/code&gt; or
     *         &lt;code&gt;aRegion.y + aRegion.height&lt;/code&gt; results in integer
     *         overflow
     */
    protected WritableRaster(SampleModel sampleModel,
                             DataBuffer dataBuffer,
                             Rectangle aRegion,
                             Point sampleModelTranslate,
                             WritableRaster parent){
<span class="nc" id="L129">        super(sampleModel,dataBuffer,aRegion,sampleModelTranslate,parent);</span>
<span class="nc" id="L130">    }</span>

    /** Returns the parent WritableRaster (if any) of this WritableRaster,
     *  or else null.
     *  @return the parent of this &lt;code&gt;WritableRaster&lt;/code&gt;, or
     *          &lt;code&gt;null&lt;/code&gt;.
     */
    public WritableRaster getWritableParent() {
<span class="nc" id="L138">        return (WritableRaster)parent;</span>
    }

    /**
     * Create a WritableRaster with the same size, SampleModel and DataBuffer
     * as this one, but with a different location.  The new WritableRaster
     * will possess a reference to the current WritableRaster, accessible
     * through its getParent() and getWritableParent() methods.
     *
     * @param childMinX X coord of the upper left corner of the new Raster.
     * @param childMinY Y coord of the upper left corner of the new Raster.
     * @return a &lt;code&gt;WritableRaster&lt;/code&gt; the same as this one except
     *         for the specified location.
     * @throws RasterFormatException if  computing either
     *         &lt;code&gt;childMinX + this.getWidth()&lt;/code&gt; or
     *         &lt;code&gt;childMinY + this.getHeight()&lt;/code&gt; results in integer
     *         overflow
     */
    public WritableRaster createWritableTranslatedChild(int childMinX,
                                                        int childMinY) {
<span class="nc" id="L158">        return createWritableChild(minX,minY,width,height,</span>
                                   childMinX,childMinY,null);
    }

    /**
     * Returns a new WritableRaster which shares all or part of this
     * WritableRaster's DataBuffer.  The new WritableRaster will
     * possess a reference to the current WritableRaster, accessible
     * through its getParent() and getWritableParent() methods.
     *
     * &lt;p&gt; The parentX, parentY, width and height parameters form a
     * Rectangle in this WritableRaster's coordinate space, indicating
     * the area of pixels to be shared.  An error will be thrown if
     * this Rectangle is not contained with the bounds of the current
     * WritableRaster.
     *
     * &lt;p&gt; The new WritableRaster may additionally be translated to a
     * different coordinate system for the plane than that used by the current
     * WritableRaster.  The childMinX and childMinY parameters give
     * the new (x, y) coordinate of the upper-left pixel of the
     * returned WritableRaster; the coordinate (childMinX, childMinY)
     * in the new WritableRaster will map to the same pixel as the
     * coordinate (parentX, parentY) in the current WritableRaster.
     *
     * &lt;p&gt; The new WritableRaster may be defined to contain only a
     * subset of the bands of the current WritableRaster, possibly
     * reordered, by means of the bandList parameter.  If bandList is
     * null, it is taken to include all of the bands of the current
     * WritableRaster in their current order.
     *
     * &lt;p&gt; To create a new WritableRaster that contains a subregion of
     * the current WritableRaster, but shares its coordinate system
     * and bands, this method should be called with childMinX equal to
     * parentX, childMinY equal to parentY, and bandList equal to
     * null.
     *
     * @param parentX    X coordinate of the upper left corner in this
     *                   WritableRaster's coordinates.
     * @param parentY    Y coordinate of the upper left corner in this
     *                   WritableRaster's coordinates.
     * @param w          Width of the region starting at (parentX, parentY).
     * @param h          Height of the region starting at (parentX, parentY).
     * @param childMinX  X coordinate of the upper left corner of
     *                   the returned WritableRaster.
     * @param childMinY  Y coordinate of the upper left corner of
     *                   the returned WritableRaster.
     * @param bandList   Array of band indices, or null to use all bands.
     * @return a &lt;code&gt;WritableRaster&lt;/code&gt; sharing all or part of the
     *         &lt;code&gt;DataBuffer&lt;/code&gt; of this &lt;code&gt;WritableRaster&lt;/code&gt;.
     * @exception RasterFormatException if the subregion is outside of the
     *                               raster bounds.
     * @throws RasterFormatException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero, or computing any of
     *         &lt;code&gt;parentX + w&lt;/code&gt;, &lt;code&gt;parentY + h&lt;/code&gt;,
     *         &lt;code&gt;childMinX + w&lt;/code&gt;, or
     *         &lt;code&gt;childMinY + h&lt;/code&gt; results in integer
     *         overflow
     */
    public WritableRaster createWritableChild(int parentX, int parentY,
                                              int w, int h,
                                              int childMinX, int childMinY,
                                              int bandList[]) {
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (parentX &lt; this.minX) {</span>
<span class="nc" id="L222">            throw new RasterFormatException(&quot;parentX lies outside raster&quot;);</span>
        }
<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (parentY &lt; this.minY) {</span>
<span class="nc" id="L225">            throw new RasterFormatException(&quot;parentY lies outside raster&quot;);</span>
        }
<span class="nc bnc" id="L227" title="All 4 branches missed.">        if ((parentX+w &lt; parentX) || (parentX+w &gt; this.width + this.minX)) {</span>
<span class="nc" id="L228">            throw new RasterFormatException(&quot;(parentX + width) is outside raster&quot;);</span>
        }
<span class="nc bnc" id="L230" title="All 4 branches missed.">        if ((parentY+h &lt; parentY) || (parentY+h &gt; this.height + this.minY)) {</span>
<span class="nc" id="L231">            throw new RasterFormatException(&quot;(parentY + height) is outside raster&quot;);</span>
        }

        SampleModel sm;
        // Note: the SampleModel for the child Raster should have the same
        // width and height as that for the parent, since it represents
        // the physical layout of the pixel data.  The child Raster's width
        // and height represent a &quot;virtual&quot; view of the pixel data, so
        // they may be different than those of the SampleModel.
<span class="nc bnc" id="L240" title="All 2 branches missed.">        if (bandList != null) {</span>
<span class="nc" id="L241">            sm = sampleModel.createSubsetSampleModel(bandList);</span>
        }
        else {
<span class="nc" id="L244">            sm = sampleModel;</span>
        }

<span class="nc" id="L247">        int deltaX = childMinX - parentX;</span>
<span class="nc" id="L248">        int deltaY = childMinY - parentY;</span>

<span class="nc" id="L250">        return new WritableRaster(sm,</span>
<span class="nc" id="L251">                                  getDataBuffer(),</span>
                                  new Rectangle(childMinX,childMinY,
                                                w, h),
                                  new Point(sampleModelTranslateX+deltaX,
                                            sampleModelTranslateY+deltaY),
                                  this);
    }

    /**
     * Sets the data for a single pixel from a
     * primitive array of type TransferType.  For image data supported by
     * the Java 2D(tm) API, this will be one of DataBuffer.TYPE_BYTE,
     * DataBuffer.TYPE_USHORT, DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT,
     * DataBuffer.TYPE_FLOAT, or DataBuffer.TYPE_DOUBLE.  Data in the array
     * may be in a packed format, thus increasing efficiency for data
     * transfers.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds, or if inData is not large enough to hold the pixel data.
     * However, explicit bounds checking is not guaranteed.
     * A ClassCastException will be thrown if the input object is not null
     * and references anything other than an array of TransferType.
     * @see java.awt.image.SampleModel#setDataElements(int, int, Object, DataBuffer)
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param inData   An object reference to an array of type defined by
     *                 getTransferType() and length getNumDataElements()
     *                 containing the pixel data to place at x,y.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if inData is too small to hold the input.
     */
    public void setDataElements(int x, int y, Object inData) {
<span class="nc" id="L283">        sampleModel.setDataElements(x-sampleModelTranslateX,</span>
                                    y-sampleModelTranslateY,
                                    inData, dataBuffer);
<span class="nc" id="L286">    }</span>

    /**
     * Sets the data for a rectangle of pixels from an input Raster.
     * The input Raster must be compatible with this WritableRaster
     * in that they must have the same number of bands, corresponding bands
     * must have the same number of bits per sample, the TransferTypes
     * and NumDataElements must be the same, and the packing used by
     * the getDataElements/setDataElements must be identical.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param inRaster Raster containing data to place at x,y.
     *
     * @throws NullPointerException if inRaster is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds.
     */
    public void setDataElements(int x, int y, Raster inRaster) {
<span class="nc" id="L307">        int dstOffX = x+inRaster.getMinX();</span>
<span class="nc" id="L308">        int dstOffY = y+inRaster.getMinY();</span>
<span class="nc" id="L309">        int width  = inRaster.getWidth();</span>
<span class="nc" id="L310">        int height = inRaster.getHeight();</span>
<span class="nc bnc" id="L311" title="All 8 branches missed.">        if ((dstOffX &lt; this.minX) || (dstOffY &lt; this.minY) ||</span>
            (dstOffX + width &gt; this.minX + this.width) ||
            (dstOffY + height &gt; this.minY + this.height)) {
<span class="nc" id="L314">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L318">        int srcOffX = inRaster.getMinX();</span>
<span class="nc" id="L319">        int srcOffY = inRaster.getMinY();</span>
<span class="nc" id="L320">        Object tdata = null;</span>

<span class="nc bnc" id="L322" title="All 2 branches missed.">        for (int startY=0; startY &lt; height; startY++) {</span>
<span class="nc" id="L323">            tdata = inRaster.getDataElements(srcOffX, srcOffY+startY,</span>
                                             width, 1, tdata);
<span class="nc" id="L325">            setDataElements(dstOffX, dstOffY+startY,</span>
                            width, 1, tdata);
        }
<span class="nc" id="L328">    }</span>

    /**
     * Sets the data for a rectangle of pixels from a
     * primitive array of type TransferType.  For image data supported by
     * the Java 2D API, this will be one of DataBuffer.TYPE_BYTE,
     * DataBuffer.TYPE_USHORT, DataBuffer.TYPE_INT, DataBuffer.TYPE_SHORT,
     * DataBuffer.TYPE_FLOAT, or DataBuffer.TYPE_DOUBLE.  Data in the array
     * may be in a packed format, thus increasing efficiency for data
     * transfers.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds, or if inData is not large enough to hold the pixel data.
     * However, explicit bounds checking is not guaranteed.
     * A ClassCastException will be thrown if the input object is not null
     * and references anything other than an array of TransferType.
     * @see java.awt.image.SampleModel#setDataElements(int, int, int, int, Object, DataBuffer)
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param inData   An object reference to an array of type defined by
     *                 getTransferType() and length w*h*getNumDataElements()
     *                 containing the pixel data to place between x,y and
     *                 x+w-1, y+h-1.
     *
     * @throws NullPointerException if inData is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if inData is too small to hold the input.
     */
    public void setDataElements(int x, int y, int w, int h, Object inData) {
<span class="nc" id="L358">        sampleModel.setDataElements(x-sampleModelTranslateX,</span>
                                    y-sampleModelTranslateY,
                                    w,h,inData,dataBuffer);
<span class="nc" id="L361">    }</span>

    /**
     * Copies pixels from Raster srcRaster to this WritableRaster.  Each pixel
     * in srcRaster is copied to the same x,y address in this raster, unless
     * the address falls outside the bounds of this raster.  srcRaster
     * must have the same number of bands as this WritableRaster.  The
     * copy is a simple copy of source samples to the corresponding destination
     * samples.
     * &lt;p&gt;
     * If all samples of both source and destination Rasters are of
     * integral type and less than or equal to 32 bits in size, then calling
     * this method is equivalent to executing the following code for all
     * &lt;code&gt;x,y&lt;/code&gt; addresses valid in both Rasters.
     * &lt;pre&gt;{@code
     *       Raster srcRaster;
     *       WritableRaster dstRaster;
     *       for (int b = 0; b &lt; srcRaster.getNumBands(); b++) {
     *           dstRaster.setSample(x, y, b, srcRaster.getSample(x, y, b));
     *       }
     * }&lt;/pre&gt;
     * Thus, when copying an integral type source to an integral type
     * destination, if the source sample size is greater than the destination
     * sample size for a particular band, the high order bits of the source
     * sample are truncated.  If the source sample size is less than the
     * destination size for a particular band, the high order bits of the
     * destination are zero-extended or sign-extended depending on whether
     * srcRaster's SampleModel treats the sample as a signed or unsigned
     * quantity.
     * &lt;p&gt;
     * When copying a float or double source to an integral type destination,
     * each source sample is cast to the destination type.  When copying an
     * integral type source to a float or double destination, the source
     * is first converted to a 32-bit int (if necessary), using the above
     * rules for integral types, and then the int is cast to float or
     * double.
     * &lt;p&gt;
     * @param srcRaster  The  Raster from which to copy pixels.
     *
     * @throws NullPointerException if srcRaster is null.
     */
    public void setRect(Raster srcRaster) {
<span class="nc" id="L403">        setRect(0,0,srcRaster);</span>
<span class="nc" id="L404">    }</span>

    /**
     * Copies pixels from Raster srcRaster to this WritableRaster.
     * For each (x, y) address in srcRaster, the corresponding pixel
     * is copied to address (x+dx, y+dy) in this WritableRaster,
     * unless (x+dx, y+dy) falls outside the bounds of this raster.
     * srcRaster must have the same number of bands as this WritableRaster.
     * The copy is a simple copy of source samples to the corresponding
     * destination samples.  For details, see
     * {@link WritableRaster#setRect(Raster)}.
     *
     * @param dx        The X translation factor from src space to dst space
     *                  of the copy.
     * @param dy        The Y translation factor from src space to dst space
     *                  of the copy.
     * @param srcRaster The Raster from which to copy pixels.
     *
     * @throws NullPointerException if srcRaster is null.
     */
    public void setRect(int dx, int dy, Raster srcRaster) {
<span class="nc" id="L425">        int width  = srcRaster.getWidth();</span>
<span class="nc" id="L426">        int height = srcRaster.getHeight();</span>
<span class="nc" id="L427">        int srcOffX = srcRaster.getMinX();</span>
<span class="nc" id="L428">        int srcOffY = srcRaster.getMinY();</span>
<span class="nc" id="L429">        int dstOffX = dx+srcOffX;</span>
<span class="nc" id="L430">        int dstOffY = dy+srcOffY;</span>

        // Clip to this raster
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (dstOffX &lt; this.minX) {</span>
<span class="nc" id="L434">            int skipX = this.minX - dstOffX;</span>
<span class="nc" id="L435">            width -= skipX;</span>
<span class="nc" id="L436">            srcOffX += skipX;</span>
<span class="nc" id="L437">            dstOffX = this.minX;</span>
        }
<span class="nc bnc" id="L439" title="All 2 branches missed.">        if (dstOffY &lt; this.minY) {</span>
<span class="nc" id="L440">            int skipY = this.minY - dstOffY;</span>
<span class="nc" id="L441">            height -= skipY;</span>
<span class="nc" id="L442">            srcOffY += skipY;</span>
<span class="nc" id="L443">            dstOffY = this.minY;</span>
        }
<span class="nc bnc" id="L445" title="All 2 branches missed.">        if (dstOffX+width &gt; this.minX+this.width) {</span>
<span class="nc" id="L446">            width = this.minX + this.width - dstOffX;</span>
        }
<span class="nc bnc" id="L448" title="All 2 branches missed.">        if (dstOffY+height &gt; this.minY+this.height) {</span>
<span class="nc" id="L449">            height = this.minY + this.height - dstOffY;</span>
        }

<span class="nc bnc" id="L452" title="All 4 branches missed.">        if (width &lt;= 0 || height &lt;= 0) {</span>
<span class="nc" id="L453">            return;</span>
        }

<span class="nc bnc" id="L456" title="All 4 branches missed.">        switch (srcRaster.getSampleModel().getDataType()) {</span>
        case DataBuffer.TYPE_BYTE:
        case DataBuffer.TYPE_SHORT:
        case DataBuffer.TYPE_USHORT:
        case DataBuffer.TYPE_INT:
<span class="nc" id="L461">            int[] iData = null;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">            for (int startY=0; startY &lt; height; startY++) {</span>
                // Grab one scanline at a time
<span class="nc" id="L464">                iData =</span>
<span class="nc" id="L465">                    srcRaster.getPixels(srcOffX, srcOffY+startY, width, 1,</span>
                                        iData);
<span class="nc" id="L467">                setPixels(dstOffX, dstOffY+startY, width, 1, iData);</span>
            }
<span class="nc" id="L469">            break;</span>

        case DataBuffer.TYPE_FLOAT:
<span class="nc" id="L472">            float[] fData = null;</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">            for (int startY=0; startY &lt; height; startY++) {</span>
<span class="nc" id="L474">                fData =</span>
<span class="nc" id="L475">                    srcRaster.getPixels(srcOffX, srcOffY+startY, width, 1,</span>
                                        fData);
<span class="nc" id="L477">                setPixels(dstOffX, dstOffY+startY, width, 1, fData);</span>
            }
<span class="nc" id="L479">            break;</span>

        case DataBuffer.TYPE_DOUBLE:
<span class="nc" id="L482">            double[] dData = null;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">            for (int startY=0; startY &lt; height; startY++) {</span>
                // Grab one scanline at a time
<span class="nc" id="L485">                dData =</span>
<span class="nc" id="L486">                    srcRaster.getPixels(srcOffX, srcOffY+startY, width, 1,</span>
                                        dData);
<span class="nc" id="L488">                setPixels(dstOffX, dstOffY+startY, width, 1, dData);</span>
            }
            break;
        }
<span class="nc" id="L492">    }</span>

    /**
     * Sets a pixel in the DataBuffer using an int array of samples for input.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x      The X coordinate of the pixel location.
     * @param y      The Y coordinate of the pixel location.
     * @param iArray The input samples in a int array.
     *
     * @throws NullPointerException if iArray is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if iArray is too small to hold the input.
     */
    public void setPixel(int x, int y, int iArray[]) {
<span class="nc" id="L508">        sampleModel.setPixel(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                             iArray,dataBuffer);
<span class="nc" id="L510">    }</span>

    /**
     * Sets a pixel in the DataBuffer using a float array of samples for input.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x      The X coordinate of the pixel location.
     * @param y      The Y coordinate of the pixel location.
     * @param fArray The input samples in a float array.
     *
     * @throws NullPointerException if fArray is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if fArray is too small to hold the input.
     */
    public void setPixel(int x, int y, float fArray[]) {
<span class="nc" id="L526">        sampleModel.setPixel(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                             fArray,dataBuffer);
<span class="nc" id="L528">    }</span>

    /**
     * Sets a pixel in the DataBuffer using a double array of samples for input.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x      The X coordinate of the pixel location.
     * @param y      The Y coordinate of the pixel location.
     * @param dArray The input samples in a double array.
     *
     * @throws NullPointerException if dArray is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if dArray is too small to hold the input.
     */
    public void setPixel(int x, int y, double dArray[]) {
<span class="nc" id="L544">        sampleModel.setPixel(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                             dArray,dataBuffer);
<span class="nc" id="L546">    }</span>

    /**
     * Sets all samples for a rectangle of pixels from an int array containing
     * one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param iArray   The input int pixel array.
     *
     * @throws NullPointerException if iArray is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if iArray is too small to hold the input.
     */
    public void setPixels(int x, int y, int w, int h, int iArray[]) {
<span class="nc" id="L565">        sampleModel.setPixels(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                              w,h,iArray,dataBuffer);
<span class="nc" id="L567">    }</span>

    /**
     * Sets all samples for a rectangle of pixels from a float array containing
     * one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param fArray   The input float pixel array.
     *
     * @throws NullPointerException if fArray is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if fArray is too small to hold the input.
     */
    public void setPixels(int x, int y, int w, int h, float fArray[]) {
<span class="nc" id="L586">        sampleModel.setPixels(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                              w,h,fArray,dataBuffer);
<span class="nc" id="L588">    }</span>

    /**
     * Sets all samples for a rectangle of pixels from a double array containing
     * one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param dArray   The input double pixel array.
     *
     * @throws NullPointerException if dArray is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates are not
     * in bounds, or if dArray is too small to hold the input.
     */
    public void setPixels(int x, int y, int w, int h, double dArray[]) {
<span class="nc" id="L607">        sampleModel.setPixels(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                              w,h,dArray,dataBuffer);
<span class="nc" id="L609">    }</span>

    /**
     * Sets a sample in the specified band for the pixel located at (x,y)
     * in the DataBuffer using an int for input.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param b        The band to set.
     * @param s        The input sample.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds.
     */
    public void setSample(int x, int y, int b, int s) {
<span class="nc" id="L626">        sampleModel.setSample(x-sampleModelTranslateX,</span>
                              y-sampleModelTranslateY, b, s,
                              dataBuffer);
<span class="nc" id="L629">    }</span>

    /**
     * Sets a sample in the specified band for the pixel located at (x,y)
     * in the DataBuffer using a float for input.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param b        The band to set.
     * @param s        The input sample as a float.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds.
     */
    public void setSample(int x, int y, int b, float s){
<span class="nc" id="L646">        sampleModel.setSample(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                              b,s,dataBuffer);
<span class="nc" id="L648">    }</span>

    /**
     * Sets a sample in the specified band for the pixel located at (x,y)
     * in the DataBuffer using a double for input.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x        The X coordinate of the pixel location.
     * @param y        The Y coordinate of the pixel location.
     * @param b        The band to set.
     * @param s        The input sample as a double.
     *
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds.
     */
    public void setSample(int x, int y, int b, double s){
<span class="nc" id="L665">        sampleModel.setSample(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                                    b,s,dataBuffer);
<span class="nc" id="L667">    }</span>

    /**
     * Sets the samples in the specified band for the specified rectangle
     * of pixels from an int array containing one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param b        The band to set.
     * @param iArray   The input int sample array.
     *
     * @throws NullPointerException if iArray is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds, or if iArray is too small to
     * hold the input.
     */
    public void setSamples(int x, int y, int w, int h, int b,
                           int iArray[]) {
<span class="nc" id="L689">        sampleModel.setSamples(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                               w,h,b,iArray,dataBuffer);
<span class="nc" id="L691">    }</span>

    /**
     * Sets the samples in the specified band for the specified rectangle
     * of pixels from a float array containing one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param b        The band to set.
     * @param fArray   The input float sample array.
     *
     * @throws NullPointerException if fArray is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds, or if fArray is too small to
     * hold the input.
     */
    public void setSamples(int x, int y, int w, int h, int b,
                           float fArray[]) {
<span class="nc" id="L713">        sampleModel.setSamples(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                               w,h,b,fArray,dataBuffer);
<span class="nc" id="L715">    }</span>

    /**
     * Sets the samples in the specified band for the specified rectangle
     * of pixels from a double array containing one sample per array element.
     * An ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * However, explicit bounds checking is not guaranteed.
     * @param x        The X coordinate of the upper left pixel location.
     * @param y        The Y coordinate of the upper left pixel location.
     * @param w        Width of the pixel rectangle.
     * @param h        Height of the pixel rectangle.
     * @param b        The band to set.
     * @param dArray   The input double sample array.
     *
     * @throws NullPointerException if dArray is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates or
     * the band index are not in bounds, or if dArray is too small to
     * hold the input.
     */
    public void setSamples(int x, int y, int w, int h, int b,
                           double dArray[]) {
<span class="nc" id="L737">        sampleModel.setSamples(x-sampleModelTranslateX,y-sampleModelTranslateY,</span>
                              w,h,b,dArray,dataBuffer);
<span class="nc" id="L739">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>