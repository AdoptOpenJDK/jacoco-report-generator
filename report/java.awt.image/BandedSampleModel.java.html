<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BandedSampleModel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">BandedSampleModel.java</span></div><h1>BandedSampleModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/* ****************************************************************
 ******************************************************************
 ******************************************************************
 *** COPYRIGHT (c) Eastman Kodak Company, 1997
 *** As  an unpublished  work pursuant to Title 17 of the United
 *** States Code.  All rights reserved.
 ******************************************************************
 ******************************************************************
 ******************************************************************/

package java.awt.image;

/**
 *  This class represents image data which is stored in a band interleaved
 *  fashion and for
 *  which each sample of a pixel occupies one data element of the DataBuffer.
 *  It subclasses ComponentSampleModel but provides a more efficient
 *  implementation for accessing band interleaved image data than is provided
 *  by ComponentSampleModel.  This class should typically be used when working
 *  with images which store sample data for each band in a different bank of the
 *  DataBuffer. Accessor methods are provided so that image data can be
 *  manipulated directly. Pixel stride is the number of
 *  data array elements between two samples for the same band on the same
 *  scanline. The pixel stride for a BandedSampleModel is one.
 *  Scanline stride is the number of data array elements between
 *  a given sample and the corresponding sample in the same column of the next
 *  scanline.  Band offsets denote the number
 *  of data array elements from the first data array element of the bank
 *  of the DataBuffer holding each band to the first sample of the band.
 *  The bands are numbered from 0 to N-1.
 *  Bank indices denote the correspondence between a bank of the data buffer
 *  and a band of image data.  This class supports
 *  {@link DataBuffer#TYPE_BYTE TYPE_BYTE},
 *  {@link DataBuffer#TYPE_USHORT TYPE_USHORT},
 *  {@link DataBuffer#TYPE_SHORT TYPE_SHORT},
 *  {@link DataBuffer#TYPE_INT TYPE_INT},
 *  {@link DataBuffer#TYPE_FLOAT TYPE_FLOAT}, and
 *  {@link DataBuffer#TYPE_DOUBLE TYPE_DOUBLE} datatypes
 */


public final class BandedSampleModel extends ComponentSampleModel
{

    /**
     * Constructs a BandedSampleModel with the specified parameters.
     * The pixel stride will be one data element.  The scanline stride
     * will be the same as the width.  Each band will be stored in
     * a separate bank and all band offsets will be zero.
     * @param dataType  The data type for storing samples.
     * @param w         The width (in pixels) of the region of
     *                  image data described.
     * @param h         The height (in pixels) of the region of image
     *                  data described.
     * @param numBands  The number of bands for the image data.
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types
     */
    public BandedSampleModel(int dataType, int w, int h, int numBands) {
<span class="nc" id="L85">        super(dataType, w, h, 1, w,</span>
<span class="nc" id="L86">              BandedSampleModel.createIndicesArray(numBands),</span>
<span class="nc" id="L87">              BandedSampleModel.createOffsetArray(numBands));</span>
<span class="nc" id="L88">    }</span>

    /**
     * Constructs a BandedSampleModel with the specified parameters.
     * The number of bands will be inferred from the lengths of the
     * bandOffsets bankIndices arrays, which must be equal.  The pixel
     * stride will be one data element.
     * @param dataType  The data type for storing samples.
     * @param w         The width (in pixels) of the region of
     *                  image data described.
     * @param h         The height (in pixels) of the region of
     *                  image data described.
     * @param scanlineStride The line stride of the of the image data.
     * @param bankIndices The bank index for each band.
     * @param bandOffsets The band offset for each band.
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types
     */
    public BandedSampleModel(int dataType,
                             int w, int h,
                             int scanlineStride,
                             int bankIndices[],
                             int bandOffsets[]) {

<span class="nc" id="L112">        super(dataType, w, h, 1,scanlineStride, bankIndices, bandOffsets);</span>
<span class="nc" id="L113">    }</span>

    /**
     * Creates a new BandedSampleModel with the specified
     * width and height.  The new BandedSampleModel will have the same
     * number of bands, storage data type, and bank indices
     * as this BandedSampleModel.  The band offsets will be compressed
     * such that the offset between bands will be w*pixelStride and
     * the minimum of all of the band offsets is zero.
     * @param w the width of the resulting &lt;code&gt;BandedSampleModel&lt;/code&gt;
     * @param h the height of the resulting &lt;code&gt;BandedSampleModel&lt;/code&gt;
     * @return a new &lt;code&gt;BandedSampleModel&lt;/code&gt; with the specified
     *         width and height.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; equals either
     *         &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt; or
     *         &lt;code&gt;Integer.MIN_VALUE&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types
     */
    public SampleModel createCompatibleSampleModel(int w, int h) {
        int[] bandOffs;

<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (numBanks == 1) {</span>
<span class="nc" id="L137">            bandOffs = orderBands(bandOffsets, w*h);</span>
        }
        else {
<span class="nc" id="L140">            bandOffs = new int[bandOffsets.length];</span>
        }

<span class="nc" id="L143">        SampleModel sampleModel =</span>
            new BandedSampleModel(dataType, w, h, w, bankIndices, bandOffs);
<span class="nc" id="L145">        return sampleModel;</span>
    }

    /**
     * Creates a new BandedSampleModel with a subset of the bands of this
     * BandedSampleModel.  The new BandedSampleModel can be
     * used with any DataBuffer that the existing BandedSampleModel
     * can be used with.  The new BandedSampleModel/DataBuffer
     * combination will represent an image with a subset of the bands
     * of the original BandedSampleModel/DataBuffer combination.
     * @throws RasterFormatException if the number of bands is greater than
     *                               the number of banks in this sample model.
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types
     */
    public SampleModel createSubsetSampleModel(int bands[]) {
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (bands.length &gt; bankIndices.length)</span>
<span class="nc" id="L162">            throw new RasterFormatException(&quot;There are only &quot; +</span>
                                            bankIndices.length +
                                            &quot; bands&quot;);
<span class="nc" id="L165">        int newBankIndices[] = new int[bands.length];</span>
<span class="nc" id="L166">        int newBandOffsets[] = new int[bands.length];</span>

<span class="nc bnc" id="L168" title="All 2 branches missed.">        for (int i=0; i&lt;bands.length; i++) {</span>
<span class="nc" id="L169">            newBankIndices[i] = bankIndices[bands[i]];</span>
<span class="nc" id="L170">            newBandOffsets[i] = bandOffsets[bands[i]];</span>
        }

<span class="nc" id="L173">        return new BandedSampleModel(this.dataType, width, height,</span>
                                     this.scanlineStride,
                                     newBankIndices, newBandOffsets);
    }

    /**
     * Creates a DataBuffer that corresponds to this BandedSampleModel,
     * The DataBuffer's data type, number of banks, and size
     * will be consistent with this BandedSampleModel.
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported types.
     */
    public DataBuffer createDataBuffer() {
<span class="nc" id="L186">        DataBuffer dataBuffer = null;</span>

<span class="nc" id="L188">        int size = scanlineStride * height;</span>
<span class="nc bnc" id="L189" title="All 7 branches missed.">        switch (dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L191">            dataBuffer = new DataBufferByte(size, numBanks);</span>
<span class="nc" id="L192">            break;</span>
        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L194">            dataBuffer = new DataBufferUShort(size, numBanks);</span>
<span class="nc" id="L195">            break;</span>
        case DataBuffer.TYPE_SHORT:
<span class="nc" id="L197">            dataBuffer = new DataBufferShort(size, numBanks);</span>
<span class="nc" id="L198">            break;</span>
        case DataBuffer.TYPE_INT:
<span class="nc" id="L200">            dataBuffer = new DataBufferInt(size, numBanks);</span>
<span class="nc" id="L201">            break;</span>
        case DataBuffer.TYPE_FLOAT:
<span class="nc" id="L203">            dataBuffer = new DataBufferFloat(size, numBanks);</span>
<span class="nc" id="L204">            break;</span>
        case DataBuffer.TYPE_DOUBLE:
<span class="nc" id="L206">            dataBuffer = new DataBufferDouble(size, numBanks);</span>
<span class="nc" id="L207">            break;</span>
        default:
<span class="nc" id="L209">            throw new IllegalArgumentException(&quot;dataType is not one &quot; +</span>
                &quot;of the supported types.&quot;);
        }

<span class="nc" id="L213">        return dataBuffer;</span>
    }


    /**
     * Returns data for a single pixel in a primitive array of type
     * TransferType.  For a BandedSampleModel, this will be the same
     * as the data type, and samples will be returned one per array
     * element.  Generally, obj
     * should be passed in as null, so that the Object will be created
     * automatically and will be of the right primitive data type.
     * &lt;p&gt;
     * The following code illustrates transferring data for one pixel from
     * DataBuffer &lt;code&gt;db1&lt;/code&gt;, whose storage layout is described by
     * BandedSampleModel &lt;code&gt;bsm1&lt;/code&gt;, to DataBuffer &lt;code&gt;db2&lt;/code&gt;,
     * whose storage layout is described by
     * BandedSampleModel &lt;code&gt;bsm2&lt;/code&gt;.
     * The transfer will generally be more efficient than using
     * getPixel/setPixel.
     * &lt;pre&gt;
     *       BandedSampleModel bsm1, bsm2;
     *       DataBufferInt db1, db2;
     *       bsm2.setDataElements(x, y, bsm1.getDataElements(x, y, null, db1),
     *                            db2);
     * &lt;/pre&gt;
     * Using getDataElements/setDataElements to transfer between two
     * DataBuffer/SampleModel pairs is legitimate if the SampleModels have
     * the same number of bands, corresponding bands have the same number of
     * bits per sample, and the TransferTypes are the same.
     * &lt;p&gt;
     * If obj is non-null, it should be a primitive array of type TransferType.
     * Otherwise, a ClassCastException is thrown.  An
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds, or if obj is non-null and is not large enough to hold
     * the pixel data.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param obj       If non-null, a primitive array in which to return
     *                  the pixel data.
     * @param data      The DataBuffer containing the image data.
     * @return the data for the specified pixel.
     * @see #setDataElements(int, int, Object, DataBuffer)
     */
    public Object getDataElements(int x, int y, Object obj, DataBuffer data) {
<span class="nc bnc" id="L257" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L258">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L261">        int type = getTransferType();</span>
<span class="nc" id="L262">        int numDataElems = getNumDataElements();</span>
<span class="nc" id="L263">        int pixelOffset = y*scanlineStride + x;</span>

<span class="nc bnc" id="L265" title="All 6 branches missed.">        switch(type) {</span>

        case DataBuffer.TYPE_BYTE:

            byte[] bdata;

<span class="nc bnc" id="L271" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L272">                bdata = new byte[numDataElems];</span>
            } else {
<span class="nc" id="L274">                bdata = (byte[])obj;</span>
            }

<span class="nc bnc" id="L277" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L278">                bdata[i] = (byte)data.getElem(bankIndices[i],</span>
                                              pixelOffset + bandOffsets[i]);
            }

<span class="nc" id="L282">            obj = (Object)bdata;</span>
<span class="nc" id="L283">            break;</span>

        case DataBuffer.TYPE_USHORT:
        case DataBuffer.TYPE_SHORT:

            short[] sdata;

<span class="nc bnc" id="L290" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L291">                sdata = new short[numDataElems];</span>
            } else {
<span class="nc" id="L293">                sdata = (short[])obj;</span>
            }

<span class="nc bnc" id="L296" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L297">                sdata[i] = (short)data.getElem(bankIndices[i],</span>
                                               pixelOffset + bandOffsets[i]);
            }

<span class="nc" id="L301">            obj = (Object)sdata;</span>
<span class="nc" id="L302">            break;</span>

        case DataBuffer.TYPE_INT:

            int[] idata;

<span class="nc bnc" id="L308" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L309">                idata = new int[numDataElems];</span>
            } else {
<span class="nc" id="L311">                idata = (int[])obj;</span>
            }

<span class="nc bnc" id="L314" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L315">                idata[i] = data.getElem(bankIndices[i],</span>
                                        pixelOffset + bandOffsets[i]);
            }

<span class="nc" id="L319">            obj = (Object)idata;</span>
<span class="nc" id="L320">            break;</span>

        case DataBuffer.TYPE_FLOAT:

            float[] fdata;

<span class="nc bnc" id="L326" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L327">                fdata = new float[numDataElems];</span>
            } else {
<span class="nc" id="L329">                fdata = (float[])obj;</span>
            }

<span class="nc bnc" id="L332" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L333">                fdata[i] = data.getElemFloat(bankIndices[i],</span>
                                             pixelOffset + bandOffsets[i]);
            }

<span class="nc" id="L337">            obj = (Object)fdata;</span>
<span class="nc" id="L338">            break;</span>

        case DataBuffer.TYPE_DOUBLE:

            double[] ddata;

<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L345">                ddata = new double[numDataElems];</span>
            } else {
<span class="nc" id="L347">                ddata = (double[])obj;</span>
            }

<span class="nc bnc" id="L350" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L351">                ddata[i] = data.getElemDouble(bankIndices[i],</span>
                                              pixelOffset + bandOffsets[i]);
            }

<span class="nc" id="L355">            obj = (Object)ddata;</span>
            break;
        }

<span class="nc" id="L359">        return obj;</span>
    }

    /**
     * Returns all samples for the specified pixel in an int array.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param iArray    If non-null, returns the samples in this array
     * @param data      The DataBuffer containing the image data
     * @return the samples for the specified pixel.
     * @see #setPixel(int, int, int[], DataBuffer)
     */
    public int[] getPixel(int x, int y, int iArray[], DataBuffer data) {
<span class="nc bnc" id="L374" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L375">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

        int[] pixels;

<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L382">           pixels = iArray;</span>
        } else {
<span class="nc" id="L384">           pixels = new int [numBands];</span>
        }

<span class="nc" id="L387">        int pixelOffset = y*scanlineStride + x;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        for (int i=0; i&lt;numBands; i++) {</span>
<span class="nc" id="L389">            pixels[i] = data.getElem(bankIndices[i],</span>
                                     pixelOffset + bandOffsets[i]);
        }
<span class="nc" id="L392">        return pixels;</span>
    }

    /**
     * Returns all samples for the specified rectangle of pixels in
     * an int array, one sample per data array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the upper left pixel location
     * @param y         The Y coordinate of the upper left pixel location
     * @param w         The width of the pixel rectangle
     * @param h         The height of the pixel rectangle
     * @param iArray    If non-null, returns the samples in this array
     * @param data      The DataBuffer containing the image data
     * @return the samples for the pixels within the specified region.
     * @see #setPixels(int, int, int, int, int[], DataBuffer)
     */
    public int[] getPixels(int x, int y, int w, int h,
                           int iArray[], DataBuffer data) {
<span class="nc" id="L411">        int x1 = x + w;</span>
<span class="nc" id="L412">        int y1 = y + h;</span>

<span class="nc bnc" id="L414" title="All 20 branches missed.">        if (x &lt; 0 || x &gt;= width || w &gt; width || x1 &lt; 0 || x1 &gt; width ||</span>
            y &lt; 0 || y &gt;= height || h &gt; height || y1 &lt; 0 || y1 &gt;  height)
        {
<span class="nc" id="L417">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int[] pixels;

<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L423">           pixels = iArray;</span>
        } else {
<span class="nc" id="L425">           pixels = new int[w*h*numBands];</span>
        }

<span class="nc bnc" id="L428" title="All 2 branches missed.">        for (int k = 0; k &lt; numBands; k++) {</span>
<span class="nc" id="L429">            int lineOffset = y*scanlineStride + x + bandOffsets[k];</span>
<span class="nc" id="L430">            int srcOffset = k;</span>
<span class="nc" id="L431">            int bank = bankIndices[k];</span>

<span class="nc bnc" id="L433" title="All 2 branches missed.">            for (int i = 0; i &lt; h; i++) {</span>
<span class="nc" id="L434">                int pixelOffset = lineOffset;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">                for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L436">                    pixels[srcOffset] = data.getElem(bank, pixelOffset++);</span>
<span class="nc" id="L437">                    srcOffset += numBands;</span>
                }
<span class="nc" id="L439">                lineOffset += scanlineStride;</span>
            }
        }
<span class="nc" id="L442">        return pixels;</span>
    }

    /**
     * Returns as int the sample in a specified band for the pixel
     * located at (x,y).
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         The band to return
     * @param data      The DataBuffer containing the image data
     * @return the sample in the specified band for the specified pixel.
     * @see #setSample(int, int, int, int, DataBuffer)
     */
    public int getSample(int x, int y, int b, DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L459" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L460">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L463">        int sample =</span>
<span class="nc" id="L464">            data.getElem(bankIndices[b],</span>
                         y*scanlineStride + x + bandOffsets[b]);
<span class="nc" id="L466">        return sample;</span>
    }

    /**
     * Returns the sample in a specified band
     * for the pixel located at (x,y) as a float.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         The band to return
     * @param data      The DataBuffer containing the image data
     * @return a float value that represents the sample in the specified
     * band for the specified pixel.
     */
    public float getSampleFloat(int x, int y, int b, DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L483" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L484">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L488">        float sample = data.getElemFloat(bankIndices[b],</span>
                                    y*scanlineStride + x + bandOffsets[b]);
<span class="nc" id="L490">        return sample;</span>
    }

    /**
     * Returns the sample in a specified band
     * for a pixel located at (x,y) as a double.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         The band to return
     * @param data      The DataBuffer containing the image data
     * @return a double value that represents the sample in the specified
     * band for the specified pixel.
     */
    public double getSampleDouble(int x, int y, int b, DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L507" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L508">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L512">        double sample = data.getElemDouble(bankIndices[b],</span>
                                       y*scanlineStride + x + bandOffsets[b]);
<span class="nc" id="L514">        return sample;</span>
    }

    /**
     * Returns the samples in a specified band for the specified rectangle
     * of pixels in an int array, one sample per data array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the upper left pixel location
     * @param y         The Y coordinate of the upper left pixel location
     * @param w         The width of the pixel rectangle
     * @param h         The height of the pixel rectangle
     * @param b         The band to return
     * @param iArray    If non-null, returns the samples in this array
     * @param data      The DataBuffer containing the image data
     * @return the samples in the specified band for the pixels within
     * the specified region.
     * @see #setSamples(int, int, int, int, int, int[], DataBuffer)
     */
    public int[] getSamples(int x, int y, int w, int h, int b,
                            int iArray[], DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L536" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x + w &gt; width) || (y + h &gt; height)) {</span>
<span class="nc" id="L537">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int samples[];
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L542">           samples = iArray;</span>
        } else {
<span class="nc" id="L544">           samples = new int [w*h];</span>
        }

<span class="nc" id="L547">        int lineOffset = y*scanlineStride + x + bandOffsets[b];</span>
<span class="nc" id="L548">        int srcOffset = 0;</span>
<span class="nc" id="L549">        int bank = bankIndices[b];</span>

<span class="nc bnc" id="L551" title="All 2 branches missed.">        for (int i = 0; i &lt; h; i++) {</span>
<span class="nc" id="L552">           int sampleOffset = lineOffset;</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">           for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L554">               samples[srcOffset++] = data.getElem(bank, sampleOffset++);</span>
           }
<span class="nc" id="L556">           lineOffset += scanlineStride;</span>
        }
<span class="nc" id="L558">        return samples;</span>
    }

    /**
     * Sets the data for a single pixel in the specified DataBuffer from a
     * primitive array of type TransferType.  For a BandedSampleModel,
     * this will be the same as the data type, and samples are transferred
     * one per array element.
     * &lt;p&gt;
     * The following code illustrates transferring data for one pixel from
     * DataBuffer &lt;code&gt;db1&lt;/code&gt;, whose storage layout is described by
     * BandedSampleModel &lt;code&gt;bsm1&lt;/code&gt;, to DataBuffer &lt;code&gt;db2&lt;/code&gt;,
     * whose storage layout is described by
     * BandedSampleModel &lt;code&gt;bsm2&lt;/code&gt;.
     * The transfer will generally be more efficient than using
     * getPixel/setPixel.
     * &lt;pre&gt;
     *       BandedSampleModel bsm1, bsm2;
     *       DataBufferInt db1, db2;
     *       bsm2.setDataElements(x, y, bsm1.getDataElements(x, y, null, db1),
     *                            db2);
     * &lt;/pre&gt;
     * Using getDataElements/setDataElements to transfer between two
     * DataBuffer/SampleModel pairs is legitimate if the SampleModels have
     * the same number of bands, corresponding bands have the same number of
     * bits per sample, and the TransferTypes are the same.
     * &lt;p&gt;
     * obj must be a primitive array of type TransferType.  Otherwise,
     * a ClassCastException is thrown.  An
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds, or if obj is not large enough to hold the pixel data.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param obj       If non-null, returns the primitive array in this
     *                  object
     * @param data      The DataBuffer containing the image data
     * @see #getDataElements(int, int, Object, DataBuffer)
     */
    public void setDataElements(int x, int y, Object obj, DataBuffer data) {
<span class="nc bnc" id="L597" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L598">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L601">        int type = getTransferType();</span>
<span class="nc" id="L602">        int numDataElems = getNumDataElements();</span>
<span class="nc" id="L603">        int pixelOffset = y*scanlineStride + x;</span>

<span class="nc bnc" id="L605" title="All 6 branches missed.">        switch(type) {</span>

        case DataBuffer.TYPE_BYTE:

<span class="nc" id="L609">            byte[] barray = (byte[])obj;</span>

<span class="nc bnc" id="L611" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L612">                data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],</span>
                             barray[i] &amp; 0xff);
            }
<span class="nc" id="L615">            break;</span>

        case DataBuffer.TYPE_USHORT:
        case DataBuffer.TYPE_SHORT:

<span class="nc" id="L620">            short[] sarray = (short[])obj;</span>

<span class="nc bnc" id="L622" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L623">                data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],</span>
                             sarray[i] &amp; 0xffff);
            }
<span class="nc" id="L626">            break;</span>

        case DataBuffer.TYPE_INT:

<span class="nc" id="L630">            int[] iarray = (int[])obj;</span>

<span class="nc bnc" id="L632" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L633">                data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],</span>
                             iarray[i]);
            }
<span class="nc" id="L636">            break;</span>

        case DataBuffer.TYPE_FLOAT:

<span class="nc" id="L640">            float[] farray = (float[])obj;</span>

<span class="nc bnc" id="L642" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L643">                data.setElemFloat(bankIndices[i], pixelOffset + bandOffsets[i],</span>
                                  farray[i]);
            }
<span class="nc" id="L646">            break;</span>

        case DataBuffer.TYPE_DOUBLE:

<span class="nc" id="L650">            double[] darray = (double[])obj;</span>

<span class="nc bnc" id="L652" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L653">                data.setElemDouble(bankIndices[i], pixelOffset + bandOffsets[i],</span>
                                   darray[i]);
            }
            break;

        }
<span class="nc" id="L659">    }</span>

    /**
     * Sets a pixel in the DataBuffer using an int array of samples for input.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param iArray    The input samples in an int array
     * @param data      The DataBuffer containing the image data
     * @see #getPixel(int, int, int[], DataBuffer)
     */
    public void setPixel(int x, int y, int iArray[], DataBuffer data) {
<span class="nc bnc" id="L672" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L673">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L676">       int pixelOffset = y*scanlineStride + x;</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">       for (int i=0; i&lt;numBands; i++) {</span>
<span class="nc" id="L678">           data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],</span>
                        iArray[i]);
       }
<span class="nc" id="L681">    }</span>

    /**
     * Sets all samples for a rectangle of pixels from an int array containing
     * one sample per array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the upper left pixel location
     * @param y         The Y coordinate of the upper left pixel location
     * @param w         The width of the pixel rectangle
     * @param h         The height of the pixel rectangle
     * @param iArray    The input samples in an int array
     * @param data      The DataBuffer containing the image data
     * @see #getPixels(int, int, int, int, int[], DataBuffer)
     */
    public void setPixels(int x, int y, int w, int h,
                          int iArray[], DataBuffer data) {
<span class="nc" id="L698">        int x1 = x + w;</span>
<span class="nc" id="L699">        int y1 = y + h;</span>

<span class="nc bnc" id="L701" title="All 20 branches missed.">        if (x &lt; 0 || x &gt;= width || w &gt; width || x1 &lt; 0 || x1 &gt; width ||</span>
            y &lt; 0 || y &gt;= height || h &gt; height || y1 &lt; 0 || y1 &gt;  height)
        {
<span class="nc" id="L704">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc bnc" id="L708" title="All 2 branches missed.">        for (int k = 0; k &lt; numBands; k++) {</span>
<span class="nc" id="L709">            int lineOffset = y*scanlineStride + x + bandOffsets[k];</span>
<span class="nc" id="L710">            int srcOffset = k;</span>
<span class="nc" id="L711">            int bank = bankIndices[k];</span>

<span class="nc bnc" id="L713" title="All 2 branches missed.">            for (int i = 0; i &lt; h; i++) {</span>
<span class="nc" id="L714">                int pixelOffset = lineOffset;</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">                for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L716">                    data.setElem(bank, pixelOffset++, iArray[srcOffset]);</span>
<span class="nc" id="L717">                    srcOffset += numBands;</span>
                }
<span class="nc" id="L719">                lineOffset += scanlineStride;</span>
           }
        }
<span class="nc" id="L722">    }</span>

    /**
     * Sets a sample in the specified band for the pixel located at (x,y)
     * in the DataBuffer using an int for input.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         The band to set
     * @param s         The input sample as an int
     * @param data      The DataBuffer containing the image data
     * @see #getSample(int, int, int, DataBuffer)
     */
    public void setSample(int x, int y, int b, int s,
                          DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L739" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L740">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L743">        data.setElem(bankIndices[b],</span>
                     y*scanlineStride + x + bandOffsets[b], s);
<span class="nc" id="L745">    }</span>

    /**
     * Sets a sample in the specified band for the pixel located at (x,y)
     * in the DataBuffer using a float for input.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         The band to set
     * @param s         The input sample as a float
     * @param data      The DataBuffer containing the image data
     * @see #getSample(int, int, int, DataBuffer)
     */
    public void setSample(int x, int y, int b,
                          float s ,
                          DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L763" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L764">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L767">        data.setElemFloat(bankIndices[b],</span>
                          y*scanlineStride + x + bandOffsets[b], s);
<span class="nc" id="L769">    }</span>

    /**
     * Sets a sample in the specified band for the pixel located at (x,y)
     * in the DataBuffer using a double for input.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         The band to set
     * @param s         The input sample as a double
     * @param data      The DataBuffer containing the image data
     * @see #getSample(int, int, int, DataBuffer)
     */
    public void setSample(int x, int y, int b,
                          double s,
                          DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L787" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L788">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L791">        data.setElemDouble(bankIndices[b],</span>
                          y*scanlineStride + x + bandOffsets[b], s);
<span class="nc" id="L793">    }</span>

    /**
     * Sets the samples in the specified band for the specified rectangle
     * of pixels from an int array containing one sample per data array element.
     * ArrayIndexOutOfBoundsException may be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the upper left pixel location
     * @param y         The Y coordinate of the upper left pixel location
     * @param w         The width of the pixel rectangle
     * @param h         The height of the pixel rectangle
     * @param b         The band to set
     * @param iArray    The input sample array
     * @param data      The DataBuffer containing the image data
     * @see #getSamples(int, int, int, int, int, int[], DataBuffer)
     */
    public void setSamples(int x, int y, int w, int h, int b,
                           int iArray[], DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L812" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x + w &gt; width) || (y + h &gt; height)) {</span>
<span class="nc" id="L813">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L816">        int lineOffset = y*scanlineStride + x + bandOffsets[b];</span>
<span class="nc" id="L817">        int srcOffset = 0;</span>
<span class="nc" id="L818">        int bank = bankIndices[b];</span>

<span class="nc bnc" id="L820" title="All 2 branches missed.">        for (int i = 0; i &lt; h; i++) {</span>
<span class="nc" id="L821">           int sampleOffset = lineOffset;</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">           for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L823">              data.setElem(bank, sampleOffset++, iArray[srcOffset++]);</span>
           }
<span class="nc" id="L825">           lineOffset += scanlineStride;</span>
        }
<span class="nc" id="L827">    }</span>

    private static int[] createOffsetArray(int numBands) {
<span class="nc" id="L830">        int[] bandOffsets = new int[numBands];</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">        for (int i=0; i &lt; numBands; i++) {</span>
<span class="nc" id="L832">            bandOffsets[i] = 0;</span>
        }
<span class="nc" id="L834">        return bandOffsets;</span>
    }

    private static int[] createIndicesArray(int numBands) {
<span class="nc" id="L838">        int[] bankIndices = new int[numBands];</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">        for (int i=0; i &lt; numBands; i++) {</span>
<span class="nc" id="L840">            bankIndices[i] = i;</span>
        }
<span class="nc" id="L842">        return bankIndices;</span>
    }

    // Differentiate hash code from other ComponentSampleModel subclasses
    public int hashCode() {
<span class="nc" id="L847">        return super.hashCode() ^ 0x2;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>