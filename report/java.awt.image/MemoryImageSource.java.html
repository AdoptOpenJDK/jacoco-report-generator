<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>MemoryImageSource.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">MemoryImageSource.java</span></div><h1>MemoryImageSource.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.image.ImageConsumer;
import java.awt.image.ImageProducer;
import java.awt.image.ColorModel;
import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;

/**
 * This class is an implementation of the ImageProducer interface which
 * uses an array to produce pixel values for an Image.  Here is an example
 * which calculates a 100x100 image representing a fade from black to blue
 * along the X axis and a fade from black to red along the Y axis:
 * &lt;pre&gt;{@code
 *
 *      int w = 100;
 *      int h = 100;
 *      int pix[] = new int[w * h];
 *      int index = 0;
 *      for (int y = 0; y &lt; h; y++) {
 *          int red = (y * 255) / (h - 1);
 *          for (int x = 0; x &lt; w; x++) {
 *              int blue = (x * 255) / (w - 1);
 *              pix[index++] = (255 &lt;&lt; 24) | (red &lt;&lt; 16) | blue;
 *          }
 *      }
 *      Image img = createImage(new MemoryImageSource(w, h, pix, 0, w));
 *
 * }&lt;/pre&gt;
 * The MemoryImageSource is also capable of managing a memory image which
 * varies over time to allow animation or custom rendering.  Here is an
 * example showing how to set up the animation source and signal changes
 * in the data (adapted from the MemoryAnimationSourceDemo by Garth Dickie):
 * &lt;pre&gt;{@code
 *
 *      int pixels[];
 *      MemoryImageSource source;
 *
 *      public void init() {
 *          int width = 50;
 *          int height = 50;
 *          int size = width * height;
 *          pixels = new int[size];
 *
 *          int value = getBackground().getRGB();
 *          for (int i = 0; i &lt; size; i++) {
 *              pixels[i] = value;
 *          }
 *
 *          source = new MemoryImageSource(width, height, pixels, 0, width);
 *          source.setAnimated(true);
 *          image = createImage(source);
 *      }
 *
 *      public void run() {
 *          Thread me = Thread.currentThread( );
 *          me.setPriority(Thread.MIN_PRIORITY);
 *
 *          while (true) {
 *              try {
 *                  Thread.sleep(10);
 *              } catch( InterruptedException e ) {
 *                  return;
 *              }
 *
 *              // Modify the values in the pixels array at (x, y, w, h)
 *
 *              // Send the new data to the interested ImageConsumers
 *              source.newPixels(x, y, w, h);
 *          }
 *      }
 *
 * }&lt;/pre&gt;
 *
 * @see ImageProducer
 *
 * @author      Jim Graham
 * @author      Animation capabilities inspired by the
 *              MemoryAnimationSource class written by Garth Dickie
 */
public class MemoryImageSource implements ImageProducer {
    int width;
    int height;
    ColorModel model;
    Object pixels;
    int pixeloffset;
    int pixelscan;
    Hashtable properties;
<span class="nc" id="L115">    Vector theConsumers = new Vector();</span>
    boolean animating;
    boolean fullbuffers;

    /**
     * Constructs an ImageProducer object which uses an array of bytes
     * to produce data for an Image object.
     * @param w the width of the rectangle of pixels
     * @param h the height of the rectangle of pixels
     * @param cm the specified &lt;code&gt;ColorModel&lt;/code&gt;
     * @param pix an array of pixels
     * @param off the offset into the array of where to store the
     *        first pixel
     * @param scan the distance from one row of pixels to the next in
     *        the array
     * @see java.awt.Component#createImage
     */
    public MemoryImageSource(int w, int h, ColorModel cm,
<span class="nc" id="L133">                             byte[] pix, int off, int scan) {</span>
<span class="nc" id="L134">        initialize(w, h, cm, (Object) pix, off, scan, null);</span>
<span class="nc" id="L135">    }</span>

    /**
     * Constructs an ImageProducer object which uses an array of bytes
     * to produce data for an Image object.
     * @param w the width of the rectangle of pixels
     * @param h the height of the rectangle of pixels
     * @param cm the specified &lt;code&gt;ColorModel&lt;/code&gt;
     * @param pix an array of pixels
     * @param off the offset into the array of where to store the
     *        first pixel
     * @param scan the distance from one row of pixels to the next in
     *        the array
     * @param props a list of properties that the &lt;code&gt;ImageProducer&lt;/code&gt;
     *        uses to process an image
     * @see java.awt.Component#createImage
     */
    public MemoryImageSource(int w, int h, ColorModel cm,
                             byte[] pix, int off, int scan,
                             Hashtable&lt;?,?&gt; props)
<span class="nc" id="L155">    {</span>
<span class="nc" id="L156">        initialize(w, h, cm, (Object) pix, off, scan, props);</span>
<span class="nc" id="L157">    }</span>

    /**
     * Constructs an ImageProducer object which uses an array of integers
     * to produce data for an Image object.
     * @param w the width of the rectangle of pixels
     * @param h the height of the rectangle of pixels
     * @param cm the specified &lt;code&gt;ColorModel&lt;/code&gt;
     * @param pix an array of pixels
     * @param off the offset into the array of where to store the
     *        first pixel
     * @param scan the distance from one row of pixels to the next in
     *        the array
     * @see java.awt.Component#createImage
     */
    public MemoryImageSource(int w, int h, ColorModel cm,
<span class="nc" id="L173">                             int[] pix, int off, int scan) {</span>
<span class="nc" id="L174">        initialize(w, h, cm, (Object) pix, off, scan, null);</span>
<span class="nc" id="L175">    }</span>

    /**
     * Constructs an ImageProducer object which uses an array of integers
     * to produce data for an Image object.
     * @param w the width of the rectangle of pixels
     * @param h the height of the rectangle of pixels
     * @param cm the specified &lt;code&gt;ColorModel&lt;/code&gt;
     * @param pix an array of pixels
     * @param off the offset into the array of where to store the
     *        first pixel
     * @param scan the distance from one row of pixels to the next in
     *        the array
     * @param props a list of properties that the &lt;code&gt;ImageProducer&lt;/code&gt;
     *        uses to process an image
     * @see java.awt.Component#createImage
     */
    public MemoryImageSource(int w, int h, ColorModel cm,
                             int[] pix, int off, int scan,
                             Hashtable&lt;?,?&gt; props)
<span class="nc" id="L195">    {</span>
<span class="nc" id="L196">        initialize(w, h, cm, (Object) pix, off, scan, props);</span>
<span class="nc" id="L197">    }</span>

    private void initialize(int w, int h, ColorModel cm,
                            Object pix, int off, int scan, Hashtable props) {
<span class="nc" id="L201">        width = w;</span>
<span class="nc" id="L202">        height = h;</span>
<span class="nc" id="L203">        model = cm;</span>
<span class="nc" id="L204">        pixels = pix;</span>
<span class="nc" id="L205">        pixeloffset = off;</span>
<span class="nc" id="L206">        pixelscan = scan;</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        if (props == null) {</span>
<span class="nc" id="L208">            props = new Hashtable();</span>
        }
<span class="nc" id="L210">        properties = props;</span>
<span class="nc" id="L211">    }</span>

    /**
     * Constructs an ImageProducer object which uses an array of integers
     * in the default RGB ColorModel to produce data for an Image object.
     * @param w the width of the rectangle of pixels
     * @param h the height of the rectangle of pixels
     * @param pix an array of pixels
     * @param off the offset into the array of where to store the
     *        first pixel
     * @param scan the distance from one row of pixels to the next in
     *        the array
     * @see java.awt.Component#createImage
     * @see ColorModel#getRGBdefault
     */
<span class="nc" id="L226">    public MemoryImageSource(int w, int h, int pix[], int off, int scan) {</span>
<span class="nc" id="L227">        initialize(w, h, ColorModel.getRGBdefault(),</span>
                   (Object) pix, off, scan, null);
<span class="nc" id="L229">    }</span>

    /**
     * Constructs an ImageProducer object which uses an array of integers
     * in the default RGB ColorModel to produce data for an Image object.
     * @param w the width of the rectangle of pixels
     * @param h the height of the rectangle of pixels
     * @param pix an array of pixels
     * @param off the offset into the array of where to store the
     *        first pixel
     * @param scan the distance from one row of pixels to the next in
     *        the array
     * @param props a list of properties that the &lt;code&gt;ImageProducer&lt;/code&gt;
     *        uses to process an image
     * @see java.awt.Component#createImage
     * @see ColorModel#getRGBdefault
     */
    public MemoryImageSource(int w, int h, int pix[], int off, int scan,
                             Hashtable&lt;?,?&gt; props)
<span class="nc" id="L248">    {</span>
<span class="nc" id="L249">        initialize(w, h, ColorModel.getRGBdefault(),</span>
                   (Object) pix, off, scan, props);
<span class="nc" id="L251">    }</span>

    /**
     * Adds an ImageConsumer to the list of consumers interested in
     * data for this image.
     * @param ic the specified &lt;code&gt;ImageConsumer&lt;/code&gt;
     * @throws NullPointerException if the specified
     *           &lt;code&gt;ImageConsumer&lt;/code&gt; is null
     * @see ImageConsumer
     */
    public synchronized void addConsumer(ImageConsumer ic) {
<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (theConsumers.contains(ic)) {</span>
<span class="nc" id="L263">            return;</span>
        }
<span class="nc" id="L265">        theConsumers.addElement(ic);</span>
        try {
<span class="nc" id="L267">            initConsumer(ic);</span>
<span class="nc" id="L268">            sendPixels(ic, 0, 0, width, height);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">            if (isConsumer(ic)) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">                ic.imageComplete(animating</span>
                                 ? ImageConsumer.SINGLEFRAMEDONE
                                 : ImageConsumer.STATICIMAGEDONE);
<span class="nc bnc" id="L273" title="All 4 branches missed.">                if (!animating &amp;&amp; isConsumer(ic)) {</span>
<span class="nc" id="L274">                    ic.imageComplete(ImageConsumer.IMAGEERROR);</span>
<span class="nc" id="L275">                    removeConsumer(ic);</span>
                }
            }
<span class="nc" id="L278">        } catch (Exception e) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">            if (isConsumer(ic)) {</span>
<span class="nc" id="L280">                ic.imageComplete(ImageConsumer.IMAGEERROR);</span>
            }
<span class="nc" id="L282">        }</span>
<span class="nc" id="L283">    }</span>

    /**
     * Determines if an ImageConsumer is on the list of consumers currently
     * interested in data for this image.
     * @param ic the specified &lt;code&gt;ImageConsumer&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the &lt;code&gt;ImageConsumer&lt;/code&gt;
     * is on the list; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see ImageConsumer
     */
    public synchronized boolean isConsumer(ImageConsumer ic) {
<span class="nc" id="L294">        return theConsumers.contains(ic);</span>
    }

    /**
     * Removes an ImageConsumer from the list of consumers interested in
     * data for this image.
     * @param ic the specified &lt;code&gt;ImageConsumer&lt;/code&gt;
     * @see ImageConsumer
     */
    public synchronized void removeConsumer(ImageConsumer ic) {
<span class="nc" id="L304">        theConsumers.removeElement(ic);</span>
<span class="nc" id="L305">    }</span>

    /**
     * Adds an ImageConsumer to the list of consumers interested in
     * data for this image and immediately starts delivery of the
     * image data through the ImageConsumer interface.
     * @param ic the specified &lt;code&gt;ImageConsumer&lt;/code&gt;
     * image data through the ImageConsumer interface.
     * @see ImageConsumer
     */
    public void startProduction(ImageConsumer ic) {
<span class="nc" id="L316">        addConsumer(ic);</span>
<span class="nc" id="L317">    }</span>

    /**
     * Requests that a given ImageConsumer have the image data delivered
     * one more time in top-down, left-right order.
     * @param ic the specified &lt;code&gt;ImageConsumer&lt;/code&gt;
     * @see ImageConsumer
     */
    public void requestTopDownLeftRightResend(ImageConsumer ic) {
        // Ignored.  The data is either single frame and already in TDLR
        // format or it is multi-frame and TDLR resends aren't critical.
<span class="nc" id="L328">    }</span>

    /**
     * Changes this memory image into a multi-frame animation or a
     * single-frame static image depending on the animated parameter.
     * &lt;p&gt;This method should be called immediately after the
     * MemoryImageSource is constructed and before an image is
     * created with it to ensure that all ImageConsumers will
     * receive the correct multi-frame data.  If an ImageConsumer
     * is added to this ImageProducer before this flag is set then
     * that ImageConsumer will see only a snapshot of the pixel
     * data that was available when it connected.
     * @param animated &lt;code&gt;true&lt;/code&gt; if the image is a
     *       multi-frame animation
     */
    public synchronized void setAnimated(boolean animated) {
<span class="nc" id="L344">        this.animating = animated;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (!animating) {</span>
<span class="nc" id="L346">            Enumeration enum_ = theConsumers.elements();</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">            while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L348">                ImageConsumer ic = (ImageConsumer) enum_.nextElement();</span>
<span class="nc" id="L349">                ic.imageComplete(ImageConsumer.STATICIMAGEDONE);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                if (isConsumer(ic)) {</span>
<span class="nc" id="L351">                    ic.imageComplete(ImageConsumer.IMAGEERROR);</span>
                }
<span class="nc" id="L353">            }</span>
<span class="nc" id="L354">            theConsumers.removeAllElements();</span>
        }
<span class="nc" id="L356">    }</span>

    /**
     * Specifies whether this animated memory image should always be
     * updated by sending the complete buffer of pixels whenever
     * there is a change.
     * This flag is ignored if the animation flag is not turned on
     * through the setAnimated() method.
     * &lt;p&gt;This method should be called immediately after the
     * MemoryImageSource is constructed and before an image is
     * created with it to ensure that all ImageConsumers will
     * receive the correct pixel delivery hints.
     * @param fullbuffers &lt;code&gt;true&lt;/code&gt; if the complete pixel
     *             buffer should always
     * be sent
     * @see #setAnimated
     */
    public synchronized void setFullBufferUpdates(boolean fullbuffers) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (this.fullbuffers == fullbuffers) {</span>
<span class="nc" id="L375">            return;</span>
        }
<span class="nc" id="L377">        this.fullbuffers = fullbuffers;</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (animating) {</span>
<span class="nc" id="L379">            Enumeration enum_ = theConsumers.elements();</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L381">                ImageConsumer ic = (ImageConsumer) enum_.nextElement();</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">                ic.setHints(fullbuffers</span>
                            ? (ImageConsumer.TOPDOWNLEFTRIGHT |
                               ImageConsumer.COMPLETESCANLINES)
                            : ImageConsumer.RANDOMPIXELORDER);
<span class="nc" id="L386">            }</span>
        }
<span class="nc" id="L388">    }</span>

    /**
     * Sends a whole new buffer of pixels to any ImageConsumers that
     * are currently interested in the data for this image and notify
     * them that an animation frame is complete.
     * This method only has effect if the animation flag has been
     * turned on through the setAnimated() method.
     * @see #newPixels(int, int, int, int, boolean)
     * @see ImageConsumer
     * @see #setAnimated
     */
    public void newPixels() {
<span class="nc" id="L401">        newPixels(0, 0, width, height, true);</span>
<span class="nc" id="L402">    }</span>

    /**
     * Sends a rectangular region of the buffer of pixels to any
     * ImageConsumers that are currently interested in the data for
     * this image and notify them that an animation frame is complete.
     * This method only has effect if the animation flag has been
     * turned on through the setAnimated() method.
     * If the full buffer update flag was turned on with the
     * setFullBufferUpdates() method then the rectangle parameters
     * will be ignored and the entire buffer will always be sent.
     * @param x the x coordinate of the upper left corner of the rectangle
     * of pixels to be sent
     * @param y the y coordinate of the upper left corner of the rectangle
     * of pixels to be sent
     * @param w the width of the rectangle of pixels to be sent
     * @param h the height of the rectangle of pixels to be sent
     * @see #newPixels(int, int, int, int, boolean)
     * @see ImageConsumer
     * @see #setAnimated
     * @see #setFullBufferUpdates
     */
    public synchronized void newPixels(int x, int y, int w, int h) {
<span class="nc" id="L425">        newPixels(x, y, w, h, true);</span>
<span class="nc" id="L426">    }</span>

    /**
     * Sends a rectangular region of the buffer of pixels to any
     * ImageConsumers that are currently interested in the data for
     * this image.
     * If the framenotify parameter is true then the consumers are
     * also notified that an animation frame is complete.
     * This method only has effect if the animation flag has been
     * turned on through the setAnimated() method.
     * If the full buffer update flag was turned on with the
     * setFullBufferUpdates() method then the rectangle parameters
     * will be ignored and the entire buffer will always be sent.
     * @param x the x coordinate of the upper left corner of the rectangle
     * of pixels to be sent
     * @param y the y coordinate of the upper left corner of the rectangle
     * of pixels to be sent
     * @param w the width of the rectangle of pixels to be sent
     * @param h the height of the rectangle of pixels to be sent
     * @param framenotify &lt;code&gt;true&lt;/code&gt; if the consumers should be sent a
     * {@link ImageConsumer#SINGLEFRAMEDONE SINGLEFRAMEDONE} notification
     * @see ImageConsumer
     * @see #setAnimated
     * @see #setFullBufferUpdates
     */
    public synchronized void newPixels(int x, int y, int w, int h,
                                       boolean framenotify) {
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (animating) {</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            if (fullbuffers) {</span>
<span class="nc" id="L455">                x = y = 0;</span>
<span class="nc" id="L456">                w = width;</span>
<span class="nc" id="L457">                h = height;</span>
            } else {
<span class="nc bnc" id="L459" title="All 2 branches missed.">                if (x &lt; 0) {</span>
<span class="nc" id="L460">                    w += x;</span>
<span class="nc" id="L461">                    x = 0;</span>
                }
<span class="nc bnc" id="L463" title="All 2 branches missed.">                if (x + w &gt; width) {</span>
<span class="nc" id="L464">                    w = width - x;</span>
                }
<span class="nc bnc" id="L466" title="All 2 branches missed.">                if (y &lt; 0) {</span>
<span class="nc" id="L467">                    h += y;</span>
<span class="nc" id="L468">                    y = 0;</span>
                }
<span class="nc bnc" id="L470" title="All 2 branches missed.">                if (y + h &gt; height) {</span>
<span class="nc" id="L471">                    h = height - y;</span>
                }
            }
<span class="nc bnc" id="L474" title="All 6 branches missed.">            if ((w &lt;= 0 || h &lt;= 0) &amp;&amp; !framenotify) {</span>
<span class="nc" id="L475">                return;</span>
            }
<span class="nc" id="L477">            Enumeration enum_ = theConsumers.elements();</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">            while (enum_.hasMoreElements()) {</span>
<span class="nc" id="L479">                ImageConsumer ic = (ImageConsumer) enum_.nextElement();</span>
<span class="nc bnc" id="L480" title="All 4 branches missed.">                if (w &gt; 0 &amp;&amp; h &gt; 0) {</span>
<span class="nc" id="L481">                    sendPixels(ic, x, y, w, h);</span>
                }
<span class="nc bnc" id="L483" title="All 4 branches missed.">                if (framenotify &amp;&amp; isConsumer(ic)) {</span>
<span class="nc" id="L484">                    ic.imageComplete(ImageConsumer.SINGLEFRAMEDONE);</span>
                }
<span class="nc" id="L486">            }</span>
        }
<span class="nc" id="L488">    }</span>

    /**
     * Changes to a new byte array to hold the pixels for this image.
     * If the animation flag has been turned on through the setAnimated()
     * method, then the new pixels will be immediately delivered to any
     * ImageConsumers that are currently interested in the data for
     * this image.
     * @param newpix the new pixel array
     * @param newmodel the specified &lt;code&gt;ColorModel&lt;/code&gt;
     * @param offset the offset into the array
     * @param scansize the distance from one row of pixels to the next in
     * the array
     * @see #newPixels(int, int, int, int, boolean)
     * @see #setAnimated
     */
    public synchronized void newPixels(byte[] newpix, ColorModel newmodel,
                                       int offset, int scansize) {
<span class="nc" id="L506">        this.pixels = newpix;</span>
<span class="nc" id="L507">        this.model = newmodel;</span>
<span class="nc" id="L508">        this.pixeloffset = offset;</span>
<span class="nc" id="L509">        this.pixelscan = scansize;</span>
<span class="nc" id="L510">        newPixels();</span>
<span class="nc" id="L511">    }</span>

    /**
     * Changes to a new int array to hold the pixels for this image.
     * If the animation flag has been turned on through the setAnimated()
     * method, then the new pixels will be immediately delivered to any
     * ImageConsumers that are currently interested in the data for
     * this image.
     * @param newpix the new pixel array
     * @param newmodel the specified &lt;code&gt;ColorModel&lt;/code&gt;
     * @param offset the offset into the array
     * @param scansize the distance from one row of pixels to the next in
     * the array
     * @see #newPixels(int, int, int, int, boolean)
     * @see #setAnimated
     */
    public synchronized void newPixels(int[] newpix, ColorModel newmodel,
                                       int offset, int scansize) {
<span class="nc" id="L529">        this.pixels = newpix;</span>
<span class="nc" id="L530">        this.model = newmodel;</span>
<span class="nc" id="L531">        this.pixeloffset = offset;</span>
<span class="nc" id="L532">        this.pixelscan = scansize;</span>
<span class="nc" id="L533">        newPixels();</span>
<span class="nc" id="L534">    }</span>

    private void initConsumer(ImageConsumer ic) {
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (isConsumer(ic)) {</span>
<span class="nc" id="L538">            ic.setDimensions(width, height);</span>
        }
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (isConsumer(ic)) {</span>
<span class="nc" id="L541">            ic.setProperties(properties);</span>
        }
<span class="nc bnc" id="L543" title="All 2 branches missed.">        if (isConsumer(ic)) {</span>
<span class="nc" id="L544">            ic.setColorModel(model);</span>
        }
<span class="nc bnc" id="L546" title="All 2 branches missed.">        if (isConsumer(ic)) {</span>
<span class="nc bnc" id="L547" title="All 4 branches missed.">            ic.setHints(animating</span>
                        ? (fullbuffers
                           ? (ImageConsumer.TOPDOWNLEFTRIGHT |
                              ImageConsumer.COMPLETESCANLINES)
                           : ImageConsumer.RANDOMPIXELORDER)
                        : (ImageConsumer.TOPDOWNLEFTRIGHT |
                           ImageConsumer.COMPLETESCANLINES |
                           ImageConsumer.SINGLEPASS |
                           ImageConsumer.SINGLEFRAME));
        }
<span class="nc" id="L557">    }</span>

    private void sendPixels(ImageConsumer ic, int x, int y, int w, int h) {
<span class="nc" id="L560">        int off = pixeloffset + pixelscan * y + x;</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (isConsumer(ic)) {</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">            if (pixels instanceof byte[]) {</span>
<span class="nc" id="L563">                ic.setPixels(x, y, w, h, model,</span>
                             ((byte[]) pixels), off, pixelscan);
            } else {
<span class="nc" id="L566">                ic.setPixels(x, y, w, h, model,</span>
                             ((int[]) pixels), off, pixelscan);
            }
        }
<span class="nc" id="L570">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>