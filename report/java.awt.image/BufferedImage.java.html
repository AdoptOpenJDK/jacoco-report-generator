<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>BufferedImage.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">BufferedImage.java</span></div><h1>BufferedImage.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.Transparency;
import java.awt.color.ColorSpace;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsEnvironment;
import java.awt.ImageCapabilities;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Point2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Hashtable;
import java.util.Vector;

import sun.awt.image.BytePackedRaster;
import sun.awt.image.ShortComponentRaster;
import sun.awt.image.ByteComponentRaster;
import sun.awt.image.IntegerComponentRaster;
import sun.awt.image.OffScreenImageSource;

/**
 *
 * The &lt;code&gt;BufferedImage&lt;/code&gt; subclass describes an {@link
 * java.awt.Image Image} with an accessible buffer of image data.
 * A &lt;code&gt;BufferedImage&lt;/code&gt; is comprised of a {@link ColorModel} and a
 * {@link Raster} of image data.
 * The number and types of bands in the {@link SampleModel} of the
 * &lt;code&gt;Raster&lt;/code&gt; must match the number and types required by the
 * &lt;code&gt;ColorModel&lt;/code&gt; to represent its color and alpha components.
 * All &lt;code&gt;BufferedImage&lt;/code&gt; objects have an upper left corner
 * coordinate of (0,&amp;nbsp;0).  Any &lt;code&gt;Raster&lt;/code&gt; used to construct a
 * &lt;code&gt;BufferedImage&lt;/code&gt; must therefore have minX=0 and minY=0.
 *
 * &lt;p&gt;
 * This class relies on the data fetching and setting methods
 * of &lt;code&gt;Raster&lt;/code&gt;,
 * and on the color characterization methods of &lt;code&gt;ColorModel&lt;/code&gt;.
 *
 * @see ColorModel
 * @see Raster
 * @see WritableRaster
 */

public class BufferedImage extends java.awt.Image
                           implements WritableRenderedImage, Transparency
{
<span class="nc" id="L75">    int        imageType = TYPE_CUSTOM;</span>
    ColorModel colorModel;
    WritableRaster raster;
    OffScreenImageSource osis;
    Hashtable properties;

    boolean    isAlphaPremultiplied;// If true, alpha has been premultiplied in
    // color channels

    /**
     * Image Type Constants
     */

    /**
     * Image type is not recognized so it must be a customized
     * image.  This type is only used as a return value for the getType()
     * method.
     */
    public static final int TYPE_CUSTOM = 0;

    /**
     * Represents an image with 8-bit RGB color components packed into
     * integer pixels.  The image has a {@link DirectColorModel} without
     * alpha.
     * When data with non-opaque alpha is stored
     * in an image of this type,
     * the color data must be adjusted to a non-premultiplied form
     * and the alpha discarded,
     * as described in the
     * {@link java.awt.AlphaComposite} documentation.
     */
    public static final int TYPE_INT_RGB = 1;

    /**
     * Represents an image with 8-bit RGBA color components packed into
     * integer pixels.  The image has a &lt;code&gt;DirectColorModel&lt;/code&gt;
     * with alpha. The color data in this image is considered not to be
     * premultiplied with alpha.  When this type is used as the
     * &lt;code&gt;imageType&lt;/code&gt; argument to a &lt;code&gt;BufferedImage&lt;/code&gt;
     * constructor, the created image is consistent with images
     * created in the JDK1.1 and earlier releases.
     */
    public static final int TYPE_INT_ARGB = 2;

    /**
     * Represents an image with 8-bit RGBA color components packed into
     * integer pixels.  The image has a &lt;code&gt;DirectColorModel&lt;/code&gt;
     * with alpha.  The color data in this image is considered to be
     * premultiplied with alpha.
     */
    public static final int TYPE_INT_ARGB_PRE = 3;

    /**
     * Represents an image with 8-bit RGB color components, corresponding
     * to a Windows- or Solaris- style BGR color model, with the colors
     * Blue, Green, and Red packed into integer pixels.  There is no alpha.
     * The image has a {@link DirectColorModel}.
     * When data with non-opaque alpha is stored
     * in an image of this type,
     * the color data must be adjusted to a non-premultiplied form
     * and the alpha discarded,
     * as described in the
     * {@link java.awt.AlphaComposite} documentation.
     */
    public static final int TYPE_INT_BGR = 4;

    /**
     * Represents an image with 8-bit RGB color components, corresponding
     * to a Windows-style BGR color model) with the colors Blue, Green,
     * and Red stored in 3 bytes.  There is no alpha.  The image has a
     * &lt;code&gt;ComponentColorModel&lt;/code&gt;.
     * When data with non-opaque alpha is stored
     * in an image of this type,
     * the color data must be adjusted to a non-premultiplied form
     * and the alpha discarded,
     * as described in the
     * {@link java.awt.AlphaComposite} documentation.
     */
    public static final int TYPE_3BYTE_BGR = 5;

    /**
     * Represents an image with 8-bit RGBA color components with the colors
     * Blue, Green, and Red stored in 3 bytes and 1 byte of alpha.  The
     * image has a &lt;code&gt;ComponentColorModel&lt;/code&gt; with alpha.  The
     * color data in this image is considered not to be premultiplied with
     * alpha.  The byte data is interleaved in a single
     * byte array in the order A, B, G, R
     * from lower to higher byte addresses within each pixel.
     */
    public static final int TYPE_4BYTE_ABGR = 6;

    /**
     * Represents an image with 8-bit RGBA color components with the colors
     * Blue, Green, and Red stored in 3 bytes and 1 byte of alpha.  The
     * image has a &lt;code&gt;ComponentColorModel&lt;/code&gt; with alpha. The color
     * data in this image is considered to be premultiplied with alpha.
     * The byte data is interleaved in a single byte array in the order
     * A, B, G, R from lower to higher byte addresses within each pixel.
     */
    public static final int TYPE_4BYTE_ABGR_PRE = 7;

    /**
     * Represents an image with 5-6-5 RGB color components (5-bits red,
     * 6-bits green, 5-bits blue) with no alpha.  This image has
     * a &lt;code&gt;DirectColorModel&lt;/code&gt;.
     * When data with non-opaque alpha is stored
     * in an image of this type,
     * the color data must be adjusted to a non-premultiplied form
     * and the alpha discarded,
     * as described in the
     * {@link java.awt.AlphaComposite} documentation.
     */
    public static final int TYPE_USHORT_565_RGB = 8;

    /**
     * Represents an image with 5-5-5 RGB color components (5-bits red,
     * 5-bits green, 5-bits blue) with no alpha.  This image has
     * a &lt;code&gt;DirectColorModel&lt;/code&gt;.
     * When data with non-opaque alpha is stored
     * in an image of this type,
     * the color data must be adjusted to a non-premultiplied form
     * and the alpha discarded,
     * as described in the
     * {@link java.awt.AlphaComposite} documentation.
     */
    public static final int TYPE_USHORT_555_RGB = 9;

    /**
     * Represents a unsigned byte grayscale image, non-indexed.  This
     * image has a &lt;code&gt;ComponentColorModel&lt;/code&gt; with a CS_GRAY
     * {@link ColorSpace}.
     * When data with non-opaque alpha is stored
     * in an image of this type,
     * the color data must be adjusted to a non-premultiplied form
     * and the alpha discarded,
     * as described in the
     * {@link java.awt.AlphaComposite} documentation.
     */
    public static final int TYPE_BYTE_GRAY = 10;

    /**
     * Represents an unsigned short grayscale image, non-indexed).  This
     * image has a &lt;code&gt;ComponentColorModel&lt;/code&gt; with a CS_GRAY
     * &lt;code&gt;ColorSpace&lt;/code&gt;.
     * When data with non-opaque alpha is stored
     * in an image of this type,
     * the color data must be adjusted to a non-premultiplied form
     * and the alpha discarded,
     * as described in the
     * {@link java.awt.AlphaComposite} documentation.
     */
    public static final int TYPE_USHORT_GRAY = 11;

    /**
     * Represents an opaque byte-packed 1, 2, or 4 bit image.  The
     * image has an {@link IndexColorModel} without alpha.  When this
     * type is used as the &lt;code&gt;imageType&lt;/code&gt; argument to the
     * &lt;code&gt;BufferedImage&lt;/code&gt; constructor that takes an
     * &lt;code&gt;imageType&lt;/code&gt; argument but no &lt;code&gt;ColorModel&lt;/code&gt;
     * argument, a 1-bit image is created with an
     * &lt;code&gt;IndexColorModel&lt;/code&gt; with two colors in the default
     * sRGB &lt;code&gt;ColorSpace&lt;/code&gt;: {0,&amp;nbsp;0,&amp;nbsp;0} and
     * {255,&amp;nbsp;255,&amp;nbsp;255}.
     *
     * &lt;p&gt; Images with 2 or 4 bits per pixel may be constructed via
     * the &lt;code&gt;BufferedImage&lt;/code&gt; constructor that takes a
     * &lt;code&gt;ColorModel&lt;/code&gt; argument by supplying a
     * &lt;code&gt;ColorModel&lt;/code&gt; with an appropriate map size.
     *
     * &lt;p&gt; Images with 8 bits per pixel should use the image types
     * &lt;code&gt;TYPE_BYTE_INDEXED&lt;/code&gt; or &lt;code&gt;TYPE_BYTE_GRAY&lt;/code&gt;
     * depending on their &lt;code&gt;ColorModel&lt;/code&gt;.

     * &lt;p&gt; When color data is stored in an image of this type,
     * the closest color in the colormap is determined
     * by the &lt;code&gt;IndexColorModel&lt;/code&gt; and the resulting index is stored.
     * Approximation and loss of alpha or color components
     * can result, depending on the colors in the
     * &lt;code&gt;IndexColorModel&lt;/code&gt; colormap.
     */
    public static final int TYPE_BYTE_BINARY = 12;

    /**
     * Represents an indexed byte image.  When this type is used as the
     * &lt;code&gt;imageType&lt;/code&gt; argument to the &lt;code&gt;BufferedImage&lt;/code&gt;
     * constructor that takes an &lt;code&gt;imageType&lt;/code&gt; argument
     * but no &lt;code&gt;ColorModel&lt;/code&gt; argument, an
     * &lt;code&gt;IndexColorModel&lt;/code&gt; is created with
     * a 256-color 6/6/6 color cube palette with the rest of the colors
     * from 216-255 populated by grayscale values in the
     * default sRGB ColorSpace.
     *
     * &lt;p&gt; When color data is stored in an image of this type,
     * the closest color in the colormap is determined
     * by the &lt;code&gt;IndexColorModel&lt;/code&gt; and the resulting index is stored.
     * Approximation and loss of alpha or color components
     * can result, depending on the colors in the
     * &lt;code&gt;IndexColorModel&lt;/code&gt; colormap.
     */
    public static final int TYPE_BYTE_INDEXED = 13;

    private static final int DCM_RED_MASK   = 0x00ff0000;
    private static final int DCM_GREEN_MASK = 0x0000ff00;
    private static final int DCM_BLUE_MASK  = 0x000000ff;
    private static final int DCM_ALPHA_MASK = 0xff000000;
    private static final int DCM_565_RED_MASK = 0xf800;
    private static final int DCM_565_GRN_MASK = 0x07E0;
    private static final int DCM_565_BLU_MASK = 0x001F;
    private static final int DCM_555_RED_MASK = 0x7C00;
    private static final int DCM_555_GRN_MASK = 0x03E0;
    private static final int DCM_555_BLU_MASK = 0x001F;
    private static final int DCM_BGR_RED_MASK = 0x0000ff;
    private static final int DCM_BGR_GRN_MASK = 0x00ff00;
    private static final int DCM_BGR_BLU_MASK = 0xff0000;


    static private native void initIDs();
    static {
<span class="nc" id="L293">        ColorModel.loadLibraries();</span>
<span class="nc" id="L294">        initIDs();</span>
<span class="nc" id="L295">    }</span>

    /**
     * Constructs a &lt;code&gt;BufferedImage&lt;/code&gt; of one of the predefined
     * image types.  The &lt;code&gt;ColorSpace&lt;/code&gt; for the image is the
     * default sRGB space.
     * @param width     width of the created image
     * @param height    height of the created image
     * @param imageType type of the created image
     * @see ColorSpace
     * @see #TYPE_INT_RGB
     * @see #TYPE_INT_ARGB
     * @see #TYPE_INT_ARGB_PRE
     * @see #TYPE_INT_BGR
     * @see #TYPE_3BYTE_BGR
     * @see #TYPE_4BYTE_ABGR
     * @see #TYPE_4BYTE_ABGR_PRE
     * @see #TYPE_BYTE_GRAY
     * @see #TYPE_USHORT_GRAY
     * @see #TYPE_BYTE_BINARY
     * @see #TYPE_BYTE_INDEXED
     * @see #TYPE_USHORT_565_RGB
     * @see #TYPE_USHORT_555_RGB
     */
    public BufferedImage(int width,
                         int height,
<span class="nc" id="L321">                         int imageType) {</span>
<span class="nc bnc" id="L322" title="All 14 branches missed.">        switch (imageType) {</span>
        case TYPE_INT_RGB:
            {
<span class="nc" id="L325">                colorModel = new DirectColorModel(24,</span>
                                                  0x00ff0000,   // Red
                                                  0x0000ff00,   // Green
                                                  0x000000ff,   // Blue
                                                  0x0           // Alpha
                                                  );
<span class="nc" id="L331">                  raster = colorModel.createCompatibleWritableRaster(width,</span>
                                                                      height);
            }
<span class="nc" id="L334">        break;</span>

        case TYPE_INT_ARGB:
            {
<span class="nc" id="L338">                colorModel = ColorModel.getRGBdefault();</span>

<span class="nc" id="L340">                raster = colorModel.createCompatibleWritableRaster(width,</span>
                                                                   height);
            }
<span class="nc" id="L343">        break;</span>

        case TYPE_INT_ARGB_PRE:
            {
<span class="nc" id="L347">                colorModel = new</span>
                    DirectColorModel(
<span class="nc" id="L349">                                     ColorSpace.getInstance(ColorSpace.CS_sRGB),</span>
                                     32,
                                     0x00ff0000,// Red
                                     0x0000ff00,// Green
                                     0x000000ff,// Blue
                                     0xff000000,// Alpha
                                     true,       // Alpha Premultiplied
                                     DataBuffer.TYPE_INT
                                     );

<span class="nc" id="L359">                  raster = colorModel.createCompatibleWritableRaster(width,</span>
                                                                      height);
            }
<span class="nc" id="L362">        break;</span>

        case TYPE_INT_BGR:
            {
<span class="nc" id="L366">                colorModel = new DirectColorModel(24,</span>
                                                  0x000000ff,   // Red
                                                  0x0000ff00,   // Green
                                                  0x00ff0000    // Blue
                                                  );
<span class="nc" id="L371">                  raster = colorModel.createCompatibleWritableRaster(width,</span>
                                                                      height);
            }
<span class="nc" id="L374">        break;</span>

        case TYPE_3BYTE_BGR:
            {
<span class="nc" id="L378">                ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>
<span class="nc" id="L379">                int[] nBits = {8, 8, 8};</span>
<span class="nc" id="L380">                int[] bOffs = {2, 1, 0};</span>
<span class="nc" id="L381">                colorModel = new ComponentColorModel(cs, nBits, false, false,</span>
                                                     Transparency.OPAQUE,
                                                     DataBuffer.TYPE_BYTE);
<span class="nc" id="L384">                raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,</span>
                                                        width, height,
                                                        width*3, 3,
                                                        bOffs, null);
            }
<span class="nc" id="L389">        break;</span>

        case TYPE_4BYTE_ABGR:
            {
<span class="nc" id="L393">                ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>
<span class="nc" id="L394">                int[] nBits = {8, 8, 8, 8};</span>
<span class="nc" id="L395">                int[] bOffs = {3, 2, 1, 0};</span>
<span class="nc" id="L396">                colorModel = new ComponentColorModel(cs, nBits, true, false,</span>
                                                     Transparency.TRANSLUCENT,
                                                     DataBuffer.TYPE_BYTE);
<span class="nc" id="L399">                raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,</span>
                                                        width, height,
                                                        width*4, 4,
                                                        bOffs, null);
            }
<span class="nc" id="L404">        break;</span>

        case TYPE_4BYTE_ABGR_PRE:
            {
<span class="nc" id="L408">                ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>
<span class="nc" id="L409">                int[] nBits = {8, 8, 8, 8};</span>
<span class="nc" id="L410">                int[] bOffs = {3, 2, 1, 0};</span>
<span class="nc" id="L411">                colorModel = new ComponentColorModel(cs, nBits, true, true,</span>
                                                     Transparency.TRANSLUCENT,
                                                     DataBuffer.TYPE_BYTE);
<span class="nc" id="L414">                raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,</span>
                                                        width, height,
                                                        width*4, 4,
                                                        bOffs, null);
            }
<span class="nc" id="L419">        break;</span>

        case TYPE_BYTE_GRAY:
            {
<span class="nc" id="L423">                ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);</span>
<span class="nc" id="L424">                int[] nBits = {8};</span>
<span class="nc" id="L425">                colorModel = new ComponentColorModel(cs, nBits, false, true,</span>
                                                     Transparency.OPAQUE,
                                                     DataBuffer.TYPE_BYTE);
<span class="nc" id="L428">                raster = colorModel.createCompatibleWritableRaster(width,</span>
                                                                   height);
            }
<span class="nc" id="L431">        break;</span>

        case TYPE_USHORT_GRAY:
            {
<span class="nc" id="L435">                ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);</span>
<span class="nc" id="L436">                int[] nBits = {16};</span>
<span class="nc" id="L437">                colorModel = new ComponentColorModel(cs, nBits, false, true,</span>
                                                     Transparency.OPAQUE,
                                                     DataBuffer.TYPE_USHORT);
<span class="nc" id="L440">                raster = colorModel.createCompatibleWritableRaster(width,</span>
                                                                   height);
            }
<span class="nc" id="L443">        break;</span>

        case TYPE_BYTE_BINARY:
            {
<span class="nc" id="L447">                byte[] arr = {(byte)0, (byte)0xff};</span>

<span class="nc" id="L449">                colorModel = new IndexColorModel(1, 2, arr, arr, arr);</span>
<span class="nc" id="L450">                raster = Raster.createPackedRaster(DataBuffer.TYPE_BYTE,</span>
                                                   width, height, 1, 1, null);
            }
<span class="nc" id="L453">        break;</span>

        case TYPE_BYTE_INDEXED:
            {
                // Create a 6x6x6 color cube
<span class="nc" id="L458">                int[] cmap = new int[256];</span>
<span class="nc" id="L459">                int i=0;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                for (int r=0; r &lt; 256; r += 51) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                    for (int g=0; g &lt; 256; g += 51) {</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                        for (int b=0; b &lt; 256; b += 51) {</span>
<span class="nc" id="L463">                            cmap[i++] = (r&lt;&lt;16)|(g&lt;&lt;8)|b;</span>
                        }
                    }
                }
                // And populate the rest of the cmap with gray values
<span class="nc" id="L468">                int grayIncr = 256/(256-i);</span>

                // The gray ramp will be between 18 and 252
<span class="nc" id="L471">                int gray = grayIncr*3;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                for (; i &lt; 256; i++) {</span>
<span class="nc" id="L473">                    cmap[i] = (gray&lt;&lt;16)|(gray&lt;&lt;8)|gray;</span>
<span class="nc" id="L474">                    gray += grayIncr;</span>
                }

<span class="nc" id="L477">                colorModel = new IndexColorModel(8, 256, cmap, 0, false, -1,</span>
                                                 DataBuffer.TYPE_BYTE);
<span class="nc" id="L479">                raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,</span>
                                                      width, height, 1, null);
            }
<span class="nc" id="L482">        break;</span>

        case TYPE_USHORT_565_RGB:
            {
<span class="nc" id="L486">                colorModel = new DirectColorModel(16,</span>
                                                  DCM_565_RED_MASK,
                                                  DCM_565_GRN_MASK,
                                                  DCM_565_BLU_MASK
                                                  );
<span class="nc" id="L491">                raster = colorModel.createCompatibleWritableRaster(width,</span>
                                                                   height);
            }
<span class="nc" id="L494">            break;</span>

        case TYPE_USHORT_555_RGB:
            {
<span class="nc" id="L498">                colorModel = new DirectColorModel(15,</span>
                                                  DCM_555_RED_MASK,
                                                  DCM_555_GRN_MASK,
                                                  DCM_555_BLU_MASK
                                                  );
<span class="nc" id="L503">                raster = colorModel.createCompatibleWritableRaster(width,</span>
                                                                   height);
            }
<span class="nc" id="L506">            break;</span>

        default:
<span class="nc" id="L509">            throw new IllegalArgumentException (&quot;Unknown image type &quot; +</span>
                                                imageType);
        }

<span class="nc" id="L513">        this.imageType = imageType;</span>
<span class="nc" id="L514">    }</span>

    /**
     * Constructs a &lt;code&gt;BufferedImage&lt;/code&gt; of one of the predefined
     * image types:
     * TYPE_BYTE_BINARY or TYPE_BYTE_INDEXED.
     *
     * &lt;p&gt; If the image type is TYPE_BYTE_BINARY, the number of
     * entries in the color model is used to determine whether the
     * image should have 1, 2, or 4 bits per pixel.  If the color model
     * has 1 or 2 entries, the image will have 1 bit per pixel.  If it
     * has 3 or 4 entries, the image with have 2 bits per pixel.  If
     * it has between 5 and 16 entries, the image will have 4 bits per
     * pixel.  Otherwise, an IllegalArgumentException will be thrown.
     *
     * @param width     width of the created image
     * @param height    height of the created image
     * @param imageType type of the created image
     * @param cm        &lt;code&gt;IndexColorModel&lt;/code&gt; of the created image
     * @throws IllegalArgumentException   if the imageType is not
     * TYPE_BYTE_BINARY or TYPE_BYTE_INDEXED or if the imageType is
     * TYPE_BYTE_BINARY and the color map has more than 16 entries.
     * @see #TYPE_BYTE_BINARY
     * @see #TYPE_BYTE_INDEXED
     */
    public BufferedImage (int width,
                          int height,
                          int imageType,
<span class="nc" id="L542">                          IndexColorModel cm) {</span>
<span class="nc bnc" id="L543" title="All 4 branches missed.">        if (cm.hasAlpha() &amp;&amp; cm.isAlphaPremultiplied()) {</span>
<span class="nc" id="L544">            throw new IllegalArgumentException(&quot;This image types do not have &quot;+</span>
                                               &quot;premultiplied alpha.&quot;);
        }

<span class="nc bnc" id="L548" title="All 3 branches missed.">        switch(imageType) {</span>
        case TYPE_BYTE_BINARY:
            int bits; // Will be set below
<span class="nc" id="L551">            int mapSize = cm.getMapSize();</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            if (mapSize &lt;= 2) {</span>
<span class="nc" id="L553">                bits = 1;</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">            } else if (mapSize &lt;= 4) {</span>
<span class="nc" id="L555">                bits = 2;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">            } else if (mapSize &lt;= 16) {</span>
<span class="nc" id="L557">                bits = 4;</span>
            } else {
<span class="nc" id="L559">                throw new IllegalArgumentException</span>
                    (&quot;Color map for TYPE_BYTE_BINARY &quot; +
                     &quot;must have no more than 16 entries&quot;);
            }
<span class="nc" id="L563">            raster = Raster.createPackedRaster(DataBuffer.TYPE_BYTE,</span>
                                                width, height, 1, bits, null);
<span class="nc" id="L565">            break;</span>

        case TYPE_BYTE_INDEXED:
<span class="nc" id="L568">            raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,</span>
                                                    width, height, 1, null);
<span class="nc" id="L570">            break;</span>
        default:
<span class="nc" id="L572">            throw new IllegalArgumentException(&quot;Invalid image type (&quot; +</span>
                                               imageType+&quot;).  Image type must&quot;+
                                               &quot; be either TYPE_BYTE_BINARY or &quot;+
                                               &quot; TYPE_BYTE_INDEXED&quot;);
        }

<span class="nc bnc" id="L578" title="All 2 branches missed.">        if (!cm.isCompatibleRaster(raster)) {</span>
<span class="nc" id="L579">            throw new IllegalArgumentException(&quot;Incompatible image type and IndexColorModel&quot;);</span>
        }

<span class="nc" id="L582">        colorModel = cm;</span>
<span class="nc" id="L583">        this.imageType = imageType;</span>
<span class="nc" id="L584">    }</span>

    /**
     * Constructs a new &lt;code&gt;BufferedImage&lt;/code&gt; with a specified
     * &lt;code&gt;ColorModel&lt;/code&gt; and &lt;code&gt;Raster&lt;/code&gt;.  If the number and
     * types of bands in the &lt;code&gt;SampleModel&lt;/code&gt; of the
     * &lt;code&gt;Raster&lt;/code&gt; do not match the number and types required by
     * the &lt;code&gt;ColorModel&lt;/code&gt; to represent its color and alpha
     * components, a {@link RasterFormatException} is thrown.  This
     * method can multiply or divide the color &lt;code&gt;Raster&lt;/code&gt; data by
     * alpha to match the &lt;code&gt;alphaPremultiplied&lt;/code&gt; state
     * in the &lt;code&gt;ColorModel&lt;/code&gt;.  Properties for this
     * &lt;code&gt;BufferedImage&lt;/code&gt; can be established by passing
     * in a {@link Hashtable} of &lt;code&gt;String&lt;/code&gt;/&lt;code&gt;Object&lt;/code&gt;
     * pairs.
     * @param cm &lt;code&gt;ColorModel&lt;/code&gt; for the new image
     * @param raster     &lt;code&gt;Raster&lt;/code&gt; for the image data
     * @param isRasterPremultiplied   if &lt;code&gt;true&lt;/code&gt;, the data in
     *                  the raster has been premultiplied with alpha.
     * @param properties &lt;code&gt;Hashtable&lt;/code&gt; of
     *                  &lt;code&gt;String&lt;/code&gt;/&lt;code&gt;Object&lt;/code&gt; pairs.
     * @exception RasterFormatException if the number and
     * types of bands in the &lt;code&gt;SampleModel&lt;/code&gt; of the
     * &lt;code&gt;Raster&lt;/code&gt; do not match the number and types required by
     * the &lt;code&gt;ColorModel&lt;/code&gt; to represent its color and alpha
     * components.
     * @exception IllegalArgumentException if
     *          &lt;code&gt;raster&lt;/code&gt; is incompatible with &lt;code&gt;cm&lt;/code&gt;
     * @see ColorModel
     * @see Raster
     * @see WritableRaster
     */


/*
 *
 *  FOR NOW THE CODE WHICH DEFINES THE RASTER TYPE IS DUPLICATED BY DVF
 *  SEE THE METHOD DEFINERASTERTYPE @ RASTEROUTPUTMANAGER
 *
 */
    public BufferedImage (ColorModel cm,
                          WritableRaster raster,
                          boolean isRasterPremultiplied,
<span class="nc" id="L627">                          Hashtable&lt;?,?&gt; properties) {</span>

<span class="nc bnc" id="L629" title="All 2 branches missed.">        if (!cm.isCompatibleRaster(raster)) {</span>
<span class="nc" id="L630">            throw new</span>
                IllegalArgumentException(&quot;Raster &quot;+raster+
                                         &quot; is incompatible with ColorModel &quot;+
                                         cm);
        }

<span class="nc bnc" id="L636" title="All 4 branches missed.">        if ((raster.minX != 0) || (raster.minY != 0)) {</span>
<span class="nc" id="L637">            throw new</span>
                IllegalArgumentException(&quot;Raster &quot;+raster+
                                         &quot; has minX or minY not equal to zero: &quot;
                                         + raster.minX + &quot; &quot; + raster.minY);
        }

<span class="nc" id="L643">        colorModel = cm;</span>
<span class="nc" id="L644">        this.raster  = raster;</span>
<span class="nc" id="L645">        this.properties = properties;</span>
<span class="nc" id="L646">        int numBands = raster.getNumBands();</span>
<span class="nc" id="L647">        boolean isAlphaPre = cm.isAlphaPremultiplied();</span>
<span class="nc" id="L648">        final boolean isStandard = isStandard(cm, raster);</span>
        ColorSpace cs;

        // Force the raster data alpha state to match the premultiplied
        // state in the color model
<span class="nc" id="L653">        coerceData(isRasterPremultiplied);</span>

<span class="nc" id="L655">        SampleModel sm = raster.getSampleModel();</span>
<span class="nc" id="L656">        cs = cm.getColorSpace();</span>
<span class="nc" id="L657">        int csType = cs.getType();</span>
<span class="nc bnc" id="L658" title="All 2 branches missed.">        if (csType != ColorSpace.TYPE_RGB) {</span>
<span class="nc bnc" id="L659" title="All 6 branches missed.">            if (csType == ColorSpace.TYPE_GRAY &amp;&amp;</span>
                isStandard &amp;&amp;
                cm instanceof ComponentColorModel) {
                // Check if this might be a child raster (fix for bug 4240596)
<span class="nc bnc" id="L663" title="All 2 branches missed.">                if (sm instanceof ComponentSampleModel &amp;&amp;</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">                    ((ComponentSampleModel)sm).getPixelStride() != numBands) {</span>
<span class="nc" id="L665">                    imageType = TYPE_CUSTOM;</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">                } else if (raster instanceof ByteComponentRaster &amp;&amp;</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">                       raster.getNumBands() == 1 &amp;&amp;</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">                       cm.getComponentSize(0) == 8 &amp;&amp;</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">                       ((ByteComponentRaster)raster).getPixelStride() == 1) {</span>
<span class="nc" id="L670">                    imageType = TYPE_BYTE_GRAY;</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                } else if (raster instanceof ShortComponentRaster &amp;&amp;</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">                       raster.getNumBands() == 1 &amp;&amp;</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                       cm.getComponentSize(0) == 16 &amp;&amp;</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                       ((ShortComponentRaster)raster).getPixelStride() == 1) {</span>
<span class="nc" id="L675">                    imageType = TYPE_USHORT_GRAY;</span>
                }
            } else {
<span class="nc" id="L678">                imageType = TYPE_CUSTOM;</span>
            }
<span class="nc" id="L680">            return;</span>
        }

<span class="nc bnc" id="L683" title="All 6 branches missed.">        if ((raster instanceof IntegerComponentRaster) &amp;&amp;</span>
            (numBands == 3 || numBands == 4)) {
<span class="nc" id="L685">            IntegerComponentRaster iraster =</span>
                (IntegerComponentRaster) raster;
            // Check if the raster params and the color model
            // are correct
<span class="nc" id="L689">            int pixSize = cm.getPixelSize();</span>
<span class="nc bnc" id="L690" title="All 10 branches missed.">            if (iraster.getPixelStride() == 1 &amp;&amp;</span>
                isStandard &amp;&amp;
                cm instanceof DirectColorModel  &amp;&amp;
                (pixSize == 32 || pixSize == 24))
            {
                // Now check on the DirectColorModel params
<span class="nc" id="L696">                DirectColorModel dcm = (DirectColorModel) cm;</span>
<span class="nc" id="L697">                int rmask = dcm.getRedMask();</span>
<span class="nc" id="L698">                int gmask = dcm.getGreenMask();</span>
<span class="nc" id="L699">                int bmask = dcm.getBlueMask();</span>
<span class="nc bnc" id="L700" title="All 6 branches missed.">                if (rmask == DCM_RED_MASK &amp;&amp; gmask == DCM_GREEN_MASK &amp;&amp;</span>
                    bmask == DCM_BLUE_MASK)
                {
<span class="nc bnc" id="L703" title="All 2 branches missed.">                    if (dcm.getAlphaMask() == DCM_ALPHA_MASK) {</span>
<span class="nc bnc" id="L704" title="All 2 branches missed.">                        imageType = (isAlphaPre</span>
                                     ? TYPE_INT_ARGB_PRE
                                     : TYPE_INT_ARGB);
                    }
                    else {
                        // No Alpha
<span class="nc bnc" id="L710" title="All 2 branches missed.">                        if (!dcm.hasAlpha()) {</span>
<span class="nc" id="L711">                            imageType = TYPE_INT_RGB;</span>
                        }
                    }
                }   // if (dcm.getRedMask() == DCM_RED_MASK &amp;&amp;
<span class="nc bnc" id="L715" title="All 6 branches missed.">                else if (rmask == DCM_BGR_RED_MASK &amp;&amp; gmask == DCM_BGR_GRN_MASK</span>
                         &amp;&amp; bmask == DCM_BGR_BLU_MASK) {
<span class="nc bnc" id="L717" title="All 2 branches missed.">                    if (!dcm.hasAlpha()) {</span>
<span class="nc" id="L718">                        imageType = TYPE_INT_BGR;</span>
                    }
                }  // if (rmask == DCM_BGR_RED_MASK &amp;&amp;
            }   // if (iraster.getPixelStride() == 1
<span class="nc" id="L722">        }   // ((raster instanceof IntegerComponentRaster) &amp;&amp;</span>
<span class="nc bnc" id="L723" title="All 6 branches missed.">        else if ((cm instanceof IndexColorModel) &amp;&amp; (numBands == 1) &amp;&amp;</span>
                 isStandard &amp;&amp;
<span class="nc bnc" id="L725" title="All 4 branches missed.">                 (!cm.hasAlpha() || !isAlphaPre))</span>
        {
<span class="nc" id="L727">            IndexColorModel icm = (IndexColorModel) cm;</span>
<span class="nc" id="L728">            int pixSize = icm.getPixelSize();</span>

<span class="nc bnc" id="L730" title="All 2 branches missed.">            if (raster instanceof BytePackedRaster) {</span>
<span class="nc" id="L731">                imageType = TYPE_BYTE_BINARY;</span>
            }   // if (raster instanceof BytePackedRaster)
<span class="nc bnc" id="L733" title="All 2 branches missed.">            else if (raster instanceof ByteComponentRaster) {</span>
<span class="nc" id="L734">                ByteComponentRaster braster = (ByteComponentRaster) raster;</span>
<span class="nc bnc" id="L735" title="All 4 branches missed.">                if (braster.getPixelStride() == 1 &amp;&amp; pixSize &lt;= 8) {</span>
<span class="nc" id="L736">                    imageType = TYPE_BYTE_INDEXED;</span>
                }
            }
<span class="nc" id="L739">        }   // else if (cm instanceof IndexColorModel) &amp;&amp; (numBands == 1))</span>
<span class="nc bnc" id="L740" title="All 8 branches missed.">        else if ((raster instanceof ShortComponentRaster)</span>
                 &amp;&amp; (cm instanceof DirectColorModel)
                 &amp;&amp; isStandard
                 &amp;&amp; (numBands == 3)
<span class="nc bnc" id="L744" title="All 2 branches missed.">                 &amp;&amp; !cm.hasAlpha())</span>
        {
<span class="nc" id="L746">            DirectColorModel dcm = (DirectColorModel) cm;</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            if (dcm.getRedMask() == DCM_565_RED_MASK) {</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">                if (dcm.getGreenMask() == DCM_565_GRN_MASK &amp;&amp;</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">                    dcm.getBlueMask()  == DCM_565_BLU_MASK) {</span>
<span class="nc" id="L750">                    imageType = TYPE_USHORT_565_RGB;</span>
                }
            }
<span class="nc bnc" id="L753" title="All 2 branches missed.">            else if (dcm.getRedMask() == DCM_555_RED_MASK) {</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">                if (dcm.getGreenMask() == DCM_555_GRN_MASK &amp;&amp;</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">                    dcm.getBlueMask() == DCM_555_BLU_MASK) {</span>
<span class="nc" id="L756">                    imageType = TYPE_USHORT_555_RGB;</span>
                }
            }
<span class="nc" id="L759">        }   // else if ((cm instanceof IndexColorModel) &amp;&amp; (numBands == 1))</span>
<span class="nc bnc" id="L760" title="All 6 branches missed.">        else if ((raster instanceof ByteComponentRaster)</span>
                 &amp;&amp; (cm instanceof ComponentColorModel)
                 &amp;&amp; isStandard
<span class="nc bnc" id="L763" title="All 6 branches missed.">                 &amp;&amp; (raster.getSampleModel() instanceof PixelInterleavedSampleModel)</span>
                 &amp;&amp; (numBands == 3 || numBands == 4))
        {
<span class="nc" id="L766">            ComponentColorModel ccm = (ComponentColorModel) cm;</span>
<span class="nc" id="L767">            PixelInterleavedSampleModel csm =</span>
<span class="nc" id="L768">                (PixelInterleavedSampleModel)raster.getSampleModel();</span>
<span class="nc" id="L769">            ByteComponentRaster braster = (ByteComponentRaster) raster;</span>
<span class="nc" id="L770">            int[] offs = csm.getBandOffsets();</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">            if (ccm.getNumComponents() != numBands) {</span>
<span class="nc" id="L772">                throw new RasterFormatException(&quot;Number of components in &quot;+</span>
                                                &quot;ColorModel (&quot;+
<span class="nc" id="L774">                                                ccm.getNumComponents()+</span>
                                                &quot;) does not match # in &quot;+
                                                &quot; Raster (&quot;+numBands+&quot;)&quot;);
            }
<span class="nc" id="L778">            int[] nBits = ccm.getComponentSize();</span>
<span class="nc" id="L779">            boolean is8bit = true;</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">            for (int i=0; i &lt; numBands; i++) {</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">                if (nBits[i] != 8) {</span>
<span class="nc" id="L782">                    is8bit = false;</span>
<span class="nc" id="L783">                    break;</span>
                }
            }
<span class="nc bnc" id="L786" title="All 2 branches missed.">            if (is8bit &amp;&amp;</span>
<span class="nc bnc" id="L787" title="All 8 branches missed.">                braster.getPixelStride() == numBands &amp;&amp;</span>
                offs[0] == numBands-1 &amp;&amp;
                offs[1] == numBands-2 &amp;&amp;
                offs[2] == numBands-3)
            {
<span class="nc bnc" id="L792" title="All 4 branches missed.">                if (numBands == 3 &amp;&amp; !ccm.hasAlpha()) {</span>
<span class="nc" id="L793">                    imageType = TYPE_3BYTE_BGR;</span>
                }
<span class="nc bnc" id="L795" title="All 4 branches missed.">                else if (offs[3] == 0 &amp;&amp; ccm.hasAlpha()) {</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">                    imageType = (isAlphaPre</span>
                                 ? TYPE_4BYTE_ABGR_PRE
                                 : TYPE_4BYTE_ABGR);
                }
            }
        }   // else if ((raster instanceof ByteComponentRaster) &amp;&amp;
<span class="nc" id="L802">    }</span>

    private static boolean isStandard(ColorModel cm, WritableRaster wr) {
<span class="nc" id="L805">        final Class&lt;? extends ColorModel&gt; cmClass = cm.getClass();</span>
<span class="nc" id="L806">        final Class&lt;? extends WritableRaster&gt; wrClass = wr.getClass();</span>
<span class="nc" id="L807">        final Class&lt;? extends SampleModel&gt; smClass = wr.getSampleModel().getClass();</span>

<span class="nc" id="L809">        final PrivilegedAction&lt;Boolean&gt; checkClassLoadersAction =</span>
                new PrivilegedAction&lt;Boolean&gt;()
<span class="nc" id="L811">        {</span>

            @Override
            public Boolean run() {
<span class="nc" id="L815">                final ClassLoader std = System.class.getClassLoader();</span>

<span class="nc bnc" id="L817" title="All 2 branches missed.">                return (cmClass.getClassLoader() == std) &amp;&amp;</span>
<span class="nc bnc" id="L818" title="All 2 branches missed.">                        (smClass.getClassLoader() == std) &amp;&amp;</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">                        (wrClass.getClassLoader() == std);</span>
            }
        };
<span class="nc" id="L822">        return AccessController.doPrivileged(checkClassLoadersAction);</span>
    }

    /**
     * Returns the image type.  If it is not one of the known types,
     * TYPE_CUSTOM is returned.
     * @return the image type of this &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @see #TYPE_INT_RGB
     * @see #TYPE_INT_ARGB
     * @see #TYPE_INT_ARGB_PRE
     * @see #TYPE_INT_BGR
     * @see #TYPE_3BYTE_BGR
     * @see #TYPE_4BYTE_ABGR
     * @see #TYPE_4BYTE_ABGR_PRE
     * @see #TYPE_BYTE_GRAY
     * @see #TYPE_BYTE_BINARY
     * @see #TYPE_BYTE_INDEXED
     * @see #TYPE_USHORT_GRAY
     * @see #TYPE_USHORT_565_RGB
     * @see #TYPE_USHORT_555_RGB
     * @see #TYPE_CUSTOM
     */
    public int getType() {
<span class="nc" id="L845">        return imageType;</span>
    }

    /**
     * Returns the &lt;code&gt;ColorModel&lt;/code&gt;.
     * @return the &lt;code&gt;ColorModel&lt;/code&gt; of this
     *  &lt;code&gt;BufferedImage&lt;/code&gt;.
     */
    public ColorModel getColorModel() {
<span class="nc" id="L854">        return colorModel;</span>
    }

    /**
     * Returns the {@link WritableRaster}.
     * @return the &lt;code&gt;WriteableRaster&lt;/code&gt; of this
     *  &lt;code&gt;BufferedImage&lt;/code&gt;.
     */
    public WritableRaster getRaster() {
<span class="nc" id="L863">        return raster;</span>
    }


    /**
     * Returns a &lt;code&gt;WritableRaster&lt;/code&gt; representing the alpha
     * channel for &lt;code&gt;BufferedImage&lt;/code&gt; objects
     * with &lt;code&gt;ColorModel&lt;/code&gt; objects that support a separate
     * spatial alpha channel, such as &lt;code&gt;ComponentColorModel&lt;/code&gt; and
     * &lt;code&gt;DirectColorModel&lt;/code&gt;.  Returns &lt;code&gt;null&lt;/code&gt; if there
     * is no alpha channel associated with the &lt;code&gt;ColorModel&lt;/code&gt; in
     * this image.  This method assumes that for all
     * &lt;code&gt;ColorModel&lt;/code&gt; objects other than
     * &lt;code&gt;IndexColorModel&lt;/code&gt;, if the &lt;code&gt;ColorModel&lt;/code&gt;
     * supports alpha, there is a separate alpha channel
     * which is stored as the last band of image data.
     * If the image uses an &lt;code&gt;IndexColorModel&lt;/code&gt; that
     * has alpha in the lookup table, this method returns
     * &lt;code&gt;null&lt;/code&gt; since there is no spatially discrete alpha
     * channel.  This method creates a new
     * &lt;code&gt;WritableRaster&lt;/code&gt;, but shares the data array.
     * @return a &lt;code&gt;WritableRaster&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; if this
     *          &lt;code&gt;BufferedImage&lt;/code&gt; has no alpha channel associated
     *          with its &lt;code&gt;ColorModel&lt;/code&gt;.
     */
    public WritableRaster getAlphaRaster() {
<span class="nc" id="L889">        return colorModel.getAlphaRaster(raster);</span>
    }

    /**
     * Returns an integer pixel in the default RGB color model
     * (TYPE_INT_ARGB) and default sRGB colorspace.  Color
     * conversion takes place if this default model does not match
     * the image &lt;code&gt;ColorModel&lt;/code&gt;.  There are only 8-bits of
     * precision for each color component in the returned data when using
     * this method.
     *
     * &lt;p&gt;
     *
     * An &lt;code&gt;ArrayOutOfBoundsException&lt;/code&gt; may be thrown
     * if the coordinates are not in bounds.
     * However, explicit bounds checking is not guaranteed.
     *
     * @param x the X coordinate of the pixel from which to get
     *          the pixel in the default RGB color model and sRGB
     *          color space
     * @param y the Y coordinate of the pixel from which to get
     *          the pixel in the default RGB color model and sRGB
     *          color space
     * @return an integer pixel in the default RGB color model and
     *          default sRGB colorspace.
     * @see #setRGB(int, int, int)
     * @see #setRGB(int, int, int, int, int[], int, int)
     */
    public int getRGB(int x, int y) {
<span class="nc" id="L918">        return colorModel.getRGB(raster.getDataElements(x, y, null));</span>
    }

    /**
     * Returns an array of integer pixels in the default RGB color model
     * (TYPE_INT_ARGB) and default sRGB color space,
     * from a portion of the image data.  Color conversion takes
     * place if the default model does not match the image
     * &lt;code&gt;ColorModel&lt;/code&gt;.  There are only 8-bits of precision for
     * each color component in the returned data when
     * using this method.  With a specified coordinate (x,&amp;nbsp;y) in the
     * image, the ARGB pixel can be accessed in this way:
     * &lt;p&gt;
     *
     * &lt;pre&gt;
     *    pixel   = rgbArray[offset + (y-startY)*scansize + (x-startX)]; &lt;/pre&gt;
     *
     * &lt;p&gt;
     *
     * An &lt;code&gt;ArrayOutOfBoundsException&lt;/code&gt; may be thrown
     * if the region is not in bounds.
     * However, explicit bounds checking is not guaranteed.
     *
     * @param startX      the starting X coordinate
     * @param startY      the starting Y coordinate
     * @param w           width of region
     * @param h           height of region
     * @param rgbArray    if not &lt;code&gt;null&lt;/code&gt;, the rgb pixels are
     *          written here
     * @param offset      offset into the &lt;code&gt;rgbArray&lt;/code&gt;
     * @param scansize    scanline stride for the &lt;code&gt;rgbArray&lt;/code&gt;
     * @return            array of RGB pixels.
     * @see #setRGB(int, int, int)
     * @see #setRGB(int, int, int, int, int[], int, int)
     */
    public int[] getRGB(int startX, int startY, int w, int h,
                        int[] rgbArray, int offset, int scansize) {
<span class="nc" id="L955">        int yoff  = offset;</span>
        int off;
        Object data;
<span class="nc" id="L958">        int nbands = raster.getNumBands();</span>
<span class="nc" id="L959">        int dataType = raster.getDataBuffer().getDataType();</span>
<span class="nc bnc" id="L960" title="All 6 branches missed.">        switch (dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L962">            data = new byte[nbands];</span>
<span class="nc" id="L963">            break;</span>
        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L965">            data = new short[nbands];</span>
<span class="nc" id="L966">            break;</span>
        case DataBuffer.TYPE_INT:
<span class="nc" id="L968">            data = new int[nbands];</span>
<span class="nc" id="L969">            break;</span>
        case DataBuffer.TYPE_FLOAT:
<span class="nc" id="L971">            data = new float[nbands];</span>
<span class="nc" id="L972">            break;</span>
        case DataBuffer.TYPE_DOUBLE:
<span class="nc" id="L974">            data = new double[nbands];</span>
<span class="nc" id="L975">            break;</span>
        default:
<span class="nc" id="L977">            throw new IllegalArgumentException(&quot;Unknown data buffer type: &quot;+</span>
                                               dataType);
        }

<span class="nc bnc" id="L981" title="All 2 branches missed.">        if (rgbArray == null) {</span>
<span class="nc" id="L982">            rgbArray = new int[offset+h*scansize];</span>
        }

<span class="nc bnc" id="L985" title="All 2 branches missed.">        for (int y = startY; y &lt; startY+h; y++, yoff+=scansize) {</span>
<span class="nc" id="L986">            off = yoff;</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">            for (int x = startX; x &lt; startX+w; x++) {</span>
<span class="nc" id="L988">                rgbArray[off++] = colorModel.getRGB(raster.getDataElements(x,</span>
                                                                        y,
                                                                        data));
            }
        }

<span class="nc" id="L994">        return rgbArray;</span>
    }


    /**
     * Sets a pixel in this &lt;code&gt;BufferedImage&lt;/code&gt; to the specified
     * RGB value. The pixel is assumed to be in the default RGB color
     * model, TYPE_INT_ARGB, and default sRGB color space.  For images
     * with an &lt;code&gt;IndexColorModel&lt;/code&gt;, the index with the nearest
     * color is chosen.
     *
     * &lt;p&gt;
     *
     * An &lt;code&gt;ArrayOutOfBoundsException&lt;/code&gt; may be thrown
     * if the coordinates are not in bounds.
     * However, explicit bounds checking is not guaranteed.
     *
     * @param x the X coordinate of the pixel to set
     * @param y the Y coordinate of the pixel to set
     * @param rgb the RGB value
     * @see #getRGB(int, int)
     * @see #getRGB(int, int, int, int, int[], int, int)
     */
    public synchronized void setRGB(int x, int y, int rgb) {
<span class="nc" id="L1018">        raster.setDataElements(x, y, colorModel.getDataElements(rgb, null));</span>
<span class="nc" id="L1019">    }</span>

    /**
     * Sets an array of integer pixels in the default RGB color model
     * (TYPE_INT_ARGB) and default sRGB color space,
     * into a portion of the image data.  Color conversion takes place
     * if the default model does not match the image
     * &lt;code&gt;ColorModel&lt;/code&gt;.  There are only 8-bits of precision for
     * each color component in the returned data when
     * using this method.  With a specified coordinate (x,&amp;nbsp;y) in the
     * this image, the ARGB pixel can be accessed in this way:
     * &lt;pre&gt;
     *    pixel   = rgbArray[offset + (y-startY)*scansize + (x-startX)];
     * &lt;/pre&gt;
     * WARNING: No dithering takes place.
     *
     * &lt;p&gt;
     *
     * An &lt;code&gt;ArrayOutOfBoundsException&lt;/code&gt; may be thrown
     * if the region is not in bounds.
     * However, explicit bounds checking is not guaranteed.
     *
     * @param startX      the starting X coordinate
     * @param startY      the starting Y coordinate
     * @param w           width of the region
     * @param h           height of the region
     * @param rgbArray    the rgb pixels
     * @param offset      offset into the &lt;code&gt;rgbArray&lt;/code&gt;
     * @param scansize    scanline stride for the &lt;code&gt;rgbArray&lt;/code&gt;
     * @see #getRGB(int, int)
     * @see #getRGB(int, int, int, int, int[], int, int)
     */
    public void setRGB(int startX, int startY, int w, int h,
                        int[] rgbArray, int offset, int scansize) {
<span class="nc" id="L1053">        int yoff  = offset;</span>
        int off;
<span class="nc" id="L1055">        Object pixel = null;</span>

<span class="nc bnc" id="L1057" title="All 2 branches missed.">        for (int y = startY; y &lt; startY+h; y++, yoff+=scansize) {</span>
<span class="nc" id="L1058">            off = yoff;</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">            for (int x = startX; x &lt; startX+w; x++) {</span>
<span class="nc" id="L1060">                pixel = colorModel.getDataElements(rgbArray[off++], pixel);</span>
<span class="nc" id="L1061">                raster.setDataElements(x, y, pixel);</span>
            }
        }
<span class="nc" id="L1064">    }</span>


    /**
     * Returns the width of the &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @return the width of this &lt;code&gt;BufferedImage&lt;/code&gt;
     */
    public int getWidth() {
<span class="nc" id="L1072">        return raster.getWidth();</span>
    }

    /**
     * Returns the height of the &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @return the height of this &lt;code&gt;BufferedImage&lt;/code&gt;
     */
    public int getHeight() {
<span class="nc" id="L1080">        return raster.getHeight();</span>
    }

    /**
     * Returns the width of the &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @param observer ignored
     * @return the width of this &lt;code&gt;BufferedImage&lt;/code&gt;
     */
    public int getWidth(ImageObserver observer) {
<span class="nc" id="L1089">        return raster.getWidth();</span>
    }

    /**
     * Returns the height of the &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @param observer ignored
     * @return the height of this &lt;code&gt;BufferedImage&lt;/code&gt;
     */
    public int getHeight(ImageObserver observer) {
<span class="nc" id="L1098">        return raster.getHeight();</span>
    }

    /**
     * Returns the object that produces the pixels for the image.
     * @return the {@link ImageProducer} that is used to produce the
     * pixels for this image.
     * @see ImageProducer
     */
    public ImageProducer getSource() {
<span class="nc bnc" id="L1108" title="All 2 branches missed.">        if (osis == null) {</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">            if (properties == null) {</span>
<span class="nc" id="L1110">                properties = new Hashtable();</span>
            }
<span class="nc" id="L1112">            osis = new OffScreenImageSource(this, properties);</span>
        }
<span class="nc" id="L1114">        return osis;</span>
    }


    /**
     * Returns a property of the image by name.  Individual property names
     * are defined by the various image formats.  If a property is not
     * defined for a particular image, this method returns the
     * &lt;code&gt;UndefinedProperty&lt;/code&gt; field.  If the properties
     * for this image are not yet known, then this method returns
     * &lt;code&gt;null&lt;/code&gt; and the &lt;code&gt;ImageObserver&lt;/code&gt; object is
     * notified later.  The property name &quot;comment&quot; should be used to
     * store an optional comment that can be presented to the user as a
     * description of the image, its source, or its author.
     * @param name the property name
     * @param observer the &lt;code&gt;ImageObserver&lt;/code&gt; that receives
     *  notification regarding image information
     * @return an {@link Object} that is the property referred to by the
     *          specified &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; if the
     *          properties of this image are not yet known.
     * @throws NullPointerException if the property name is null.
     * @see ImageObserver
     * @see java.awt.Image#UndefinedProperty
     */
    public Object getProperty(String name, ImageObserver observer) {
<span class="nc" id="L1139">        return getProperty(name);</span>
    }

    /**
     * Returns a property of the image by name.
     * @param name the property name
     * @return an &lt;code&gt;Object&lt;/code&gt; that is the property referred to by
     *          the specified &lt;code&gt;name&lt;/code&gt;.
     * @throws NullPointerException if the property name is null.
     */
    public Object getProperty(String name) {
<span class="nc bnc" id="L1150" title="All 2 branches missed.">        if (name == null) {</span>
<span class="nc" id="L1151">            throw new NullPointerException(&quot;null property name is not allowed&quot;);</span>
        }
<span class="nc bnc" id="L1153" title="All 2 branches missed.">        if (properties == null) {</span>
<span class="nc" id="L1154">            return java.awt.Image.UndefinedProperty;</span>
        }
<span class="nc" id="L1156">        Object o = properties.get(name);</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">        if (o == null) {</span>
<span class="nc" id="L1158">            o = java.awt.Image.UndefinedProperty;</span>
        }
<span class="nc" id="L1160">        return o;</span>
    }

    /**
     * This method returns a {@link Graphics2D}, but is here
     * for backwards compatibility.  {@link #createGraphics() createGraphics} is more
     * convenient, since it is declared to return a
     * &lt;code&gt;Graphics2D&lt;/code&gt;.
     * @return a &lt;code&gt;Graphics2D&lt;/code&gt;, which can be used to draw into
     *          this image.
     */
    public java.awt.Graphics getGraphics() {
<span class="nc" id="L1172">        return createGraphics();</span>
    }

    /**
     * Creates a &lt;code&gt;Graphics2D&lt;/code&gt;, which can be used to draw into
     * this &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @return a &lt;code&gt;Graphics2D&lt;/code&gt;, used for drawing into this
     *          image.
     */
    public Graphics2D createGraphics() {
        GraphicsEnvironment env =
<span class="nc" id="L1183">            GraphicsEnvironment.getLocalGraphicsEnvironment();</span>
<span class="nc" id="L1184">        return env.createGraphics(this);</span>
    }

    /**
     * Returns a subimage defined by a specified rectangular region.
     * The returned &lt;code&gt;BufferedImage&lt;/code&gt; shares the same
     * data array as the original image.
     * @param x the X coordinate of the upper-left corner of the
     *          specified rectangular region
     * @param y the Y coordinate of the upper-left corner of the
     *          specified rectangular region
     * @param w the width of the specified rectangular region
     * @param h the height of the specified rectangular region
     * @return a &lt;code&gt;BufferedImage&lt;/code&gt; that is the subimage of this
     *          &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @exception RasterFormatException if the specified
     * area is not contained within this &lt;code&gt;BufferedImage&lt;/code&gt;.
     */
    public BufferedImage getSubimage (int x, int y, int w, int h) {
<span class="nc" id="L1203">        return new BufferedImage (colorModel,</span>
<span class="nc" id="L1204">                                  raster.createWritableChild(x, y, w, h,</span>
                                                             0, 0, null),
<span class="nc" id="L1206">                                  colorModel.isAlphaPremultiplied(),</span>
                                  properties);
    }

    /**
     * Returns whether or not the alpha has been premultiplied.  It
     * returns &lt;code&gt;false&lt;/code&gt; if there is no alpha.
     * @return &lt;code&gt;true&lt;/code&gt; if the alpha has been premultiplied;
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean isAlphaPremultiplied() {
<span class="nc" id="L1217">        return colorModel.isAlphaPremultiplied();</span>
    }

    /**
     * Forces the data to match the state specified in the
     * &lt;code&gt;isAlphaPremultiplied&lt;/code&gt; variable.  It may multiply or
     * divide the color raster data by alpha, or do nothing if the data is
     * in the correct state.
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the alpha has been
     *          premultiplied; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public void coerceData (boolean isAlphaPremultiplied) {
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if (colorModel.hasAlpha() &amp;&amp;</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">            colorModel.isAlphaPremultiplied() != isAlphaPremultiplied) {</span>
            // Make the color model do the conversion
<span class="nc" id="L1232">            colorModel = colorModel.coerceData (raster, isAlphaPremultiplied);</span>
        }
<span class="nc" id="L1234">    }</span>

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; representation of this
     * &lt;code&gt;BufferedImage&lt;/code&gt; object and its values.
     * @return a &lt;code&gt;String&lt;/code&gt; representing this
     *          &lt;code&gt;BufferedImage&lt;/code&gt;.
     */
    public String toString() {
<span class="nc" id="L1243">        return &quot;BufferedImage@&quot;+Integer.toHexString(hashCode())</span>
            +&quot;: type = &quot;+imageType
            +&quot; &quot;+colorModel+&quot; &quot;+raster;
    }

    /**
     * Returns a {@link Vector} of {@link RenderedImage} objects that are
     * the immediate sources, not the sources of these immediate sources,
     * of image data for this &lt;code&gt;BufferedImage&lt;/code&gt;.  This
     * method returns &lt;code&gt;null&lt;/code&gt; if the &lt;code&gt;BufferedImage&lt;/code&gt;
     * has no information about its immediate sources.  It returns an
     * empty &lt;code&gt;Vector&lt;/code&gt; if the &lt;code&gt;BufferedImage&lt;/code&gt; has no
     * immediate sources.
     * @return a &lt;code&gt;Vector&lt;/code&gt; containing immediate sources of
     *          this &lt;code&gt;BufferedImage&lt;/code&gt; object's image date, or
     *          &lt;code&gt;null&lt;/code&gt; if this &lt;code&gt;BufferedImage&lt;/code&gt; has
     *          no information about its immediate sources, or an empty
     *          &lt;code&gt;Vector&lt;/code&gt; if this &lt;code&gt;BufferedImage&lt;/code&gt;
     *          has no immediate sources.
     */
    public Vector&lt;RenderedImage&gt; getSources() {
<span class="nc" id="L1264">        return null;</span>
    }

    /**
     * Returns an array of names recognized by
     * {@link #getProperty(String) getProperty(String)}
     * or &lt;code&gt;null&lt;/code&gt;, if no property names are recognized.
     * @return a &lt;code&gt;String&lt;/code&gt; array containing all of the property
     *          names that &lt;code&gt;getProperty(String)&lt;/code&gt; recognizes;
     *          or &lt;code&gt;null&lt;/code&gt; if no property names are recognized.
     */
    public String[] getPropertyNames() {
<span class="nc" id="L1276">         return null;</span>
    }

    /**
     * Returns the minimum x coordinate of this
     * &lt;code&gt;BufferedImage&lt;/code&gt;.  This is always zero.
     * @return the minimum x coordinate of this
     *          &lt;code&gt;BufferedImage&lt;/code&gt;.
     */
    public int getMinX() {
<span class="nc" id="L1286">        return raster.getMinX();</span>
    }

    /**
     * Returns the minimum y coordinate of this
     * &lt;code&gt;BufferedImage&lt;/code&gt;.  This is always zero.
     * @return the minimum y coordinate of this
     *          &lt;code&gt;BufferedImage&lt;/code&gt;.
     */
    public int getMinY() {
<span class="nc" id="L1296">        return raster.getMinY();</span>
    }

    /**
     * Returns the &lt;code&gt;SampleModel&lt;/code&gt; associated with this
     * &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @return the &lt;code&gt;SampleModel&lt;/code&gt; of this
     *          &lt;code&gt;BufferedImage&lt;/code&gt;.
     */
    public SampleModel getSampleModel() {
<span class="nc" id="L1306">        return raster.getSampleModel();</span>
    }

    /**
     * Returns the number of tiles in the x direction.
     * This is always one.
     * @return the number of tiles in the x direction.
     */
    public int getNumXTiles() {
<span class="nc" id="L1315">        return 1;</span>
    }

    /**
     * Returns the number of tiles in the y direction.
     * This is always one.
     * @return the number of tiles in the y direction.
     */
    public int getNumYTiles() {
<span class="nc" id="L1324">        return 1;</span>
    }

    /**
     * Returns the minimum tile index in the x direction.
     * This is always zero.
     * @return the minimum tile index in the x direction.
     */
    public int getMinTileX() {
<span class="nc" id="L1333">        return 0;</span>
    }

    /**
     * Returns the minimum tile index in the y direction.
     * This is always zero.
     * @return the minimum tile index in the y direction.
     */
    public int getMinTileY() {
<span class="nc" id="L1342">        return 0;</span>
    }

    /**
     * Returns the tile width in pixels.
     * @return the tile width in pixels.
     */
    public int getTileWidth() {
<span class="nc" id="L1350">       return raster.getWidth();</span>
    }

    /**
     * Returns the tile height in pixels.
     * @return the tile height in pixels.
     */
    public int getTileHeight() {
<span class="nc" id="L1358">       return raster.getHeight();</span>
    }

    /**
     * Returns the x offset of the tile grid relative to the origin,
     * For example, the x coordinate of the location of tile
     * (0,&amp;nbsp;0).  This is always zero.
     * @return the x offset of the tile grid.
     */
    public int getTileGridXOffset() {
<span class="nc" id="L1368">        return raster.getSampleModelTranslateX();</span>
    }

    /**
     * Returns the y offset of the tile grid relative to the origin,
     * For example, the y coordinate of the location of tile
     * (0,&amp;nbsp;0).  This is always zero.
     * @return the y offset of the tile grid.
     */
    public int getTileGridYOffset() {
<span class="nc" id="L1378">        return raster.getSampleModelTranslateY();</span>
    }

    /**
     * Returns tile (&lt;code&gt;tileX&lt;/code&gt;,&amp;nbsp;&lt;code&gt;tileY&lt;/code&gt;).  Note
     * that &lt;code&gt;tileX&lt;/code&gt; and &lt;code&gt;tileY&lt;/code&gt; are indices
     * into the tile array, not pixel locations.  The &lt;code&gt;Raster&lt;/code&gt;
     * that is returned is live, which means that it is updated if the
     * image is changed.
     * @param tileX the x index of the requested tile in the tile array
     * @param tileY the y index of the requested tile in the tile array
     * @return a &lt;code&gt;Raster&lt;/code&gt; that is the tile defined by the
     *          arguments &lt;code&gt;tileX&lt;/code&gt; and &lt;code&gt;tileY&lt;/code&gt;.
     * @exception ArrayIndexOutOfBoundsException if both
     *          &lt;code&gt;tileX&lt;/code&gt; and &lt;code&gt;tileY&lt;/code&gt; are not
     *          equal to 0
     */
    public Raster getTile(int tileX, int tileY) {
<span class="nc bnc" id="L1396" title="All 4 branches missed.">        if (tileX == 0 &amp;&amp; tileY == 0) {</span>
<span class="nc" id="L1397">            return raster;</span>
        }
<span class="nc" id="L1399">        throw new ArrayIndexOutOfBoundsException(&quot;BufferedImages only have&quot;+</span>
             &quot; one tile with index 0,0&quot;);
    }

    /**
     * Returns the image as one large tile.  The &lt;code&gt;Raster&lt;/code&gt;
     * returned is a copy of the image data is not updated if the
     * image is changed.
     * @return a &lt;code&gt;Raster&lt;/code&gt; that is a copy of the image data.
     * @see #setData(Raster)
     */
    public Raster getData() {

        // REMIND : this allocates a whole new tile if raster is a
        // subtile.  (It only copies in the requested area)
        // We should do something smarter.
<span class="nc" id="L1415">        int width = raster.getWidth();</span>
<span class="nc" id="L1416">        int height = raster.getHeight();</span>
<span class="nc" id="L1417">        int startX = raster.getMinX();</span>
<span class="nc" id="L1418">        int startY = raster.getMinY();</span>
<span class="nc" id="L1419">        WritableRaster wr =</span>
<span class="nc" id="L1420">           Raster.createWritableRaster(raster.getSampleModel(),</span>
<span class="nc" id="L1421">                         new Point(raster.getSampleModelTranslateX(),</span>
<span class="nc" id="L1422">                                   raster.getSampleModelTranslateY()));</span>

<span class="nc" id="L1424">        Object tdata = null;</span>

<span class="nc bnc" id="L1426" title="All 2 branches missed.">        for (int i = startY; i &lt; startY+height; i++)  {</span>
<span class="nc" id="L1427">            tdata = raster.getDataElements(startX,i,width,1,tdata);</span>
<span class="nc" id="L1428">            wr.setDataElements(startX,i,width,1, tdata);</span>
        }
<span class="nc" id="L1430">        return wr;</span>
    }

    /**
     * Computes and returns an arbitrary region of the
     * &lt;code&gt;BufferedImage&lt;/code&gt;.  The &lt;code&gt;Raster&lt;/code&gt; returned is a
     * copy of the image data and is not updated if the image is
     * changed.
     * @param rect the region of the &lt;code&gt;BufferedImage&lt;/code&gt; to be
     * returned.
     * @return a &lt;code&gt;Raster&lt;/code&gt; that is a copy of the image data of
     *          the specified region of the &lt;code&gt;BufferedImage&lt;/code&gt;
     * @see #setData(Raster)
     */
    public Raster getData(Rectangle rect) {
<span class="nc" id="L1445">        SampleModel sm = raster.getSampleModel();</span>
<span class="nc" id="L1446">        SampleModel nsm = sm.createCompatibleSampleModel(rect.width,</span>
                                                         rect.height);
<span class="nc" id="L1448">        WritableRaster wr = Raster.createWritableRaster(nsm,</span>
<span class="nc" id="L1449">                                                  rect.getLocation());</span>
<span class="nc" id="L1450">        int width = rect.width;</span>
<span class="nc" id="L1451">        int height = rect.height;</span>
<span class="nc" id="L1452">        int startX = rect.x;</span>
<span class="nc" id="L1453">        int startY = rect.y;</span>

<span class="nc" id="L1455">        Object tdata = null;</span>

<span class="nc bnc" id="L1457" title="All 2 branches missed.">        for (int i = startY; i &lt; startY+height; i++)  {</span>
<span class="nc" id="L1458">            tdata = raster.getDataElements(startX,i,width,1,tdata);</span>
<span class="nc" id="L1459">            wr.setDataElements(startX,i,width,1, tdata);</span>
        }
<span class="nc" id="L1461">        return wr;</span>
    }

    /**
     * Computes an arbitrary rectangular region of the
     * &lt;code&gt;BufferedImage&lt;/code&gt; and copies it into a specified
     * &lt;code&gt;WritableRaster&lt;/code&gt;.  The region to be computed is
     * determined from the bounds of the specified
     * &lt;code&gt;WritableRaster&lt;/code&gt;.  The specified
     * &lt;code&gt;WritableRaster&lt;/code&gt; must have a
     * &lt;code&gt;SampleModel&lt;/code&gt; that is compatible with this image.  If
     * &lt;code&gt;outRaster&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * an appropriate &lt;code&gt;WritableRaster&lt;/code&gt; is created.
     * @param outRaster a &lt;code&gt;WritableRaster&lt;/code&gt; to hold the returned
     *          part of the image, or &lt;code&gt;null&lt;/code&gt;
     * @return a reference to the supplied or created
     *          &lt;code&gt;WritableRaster&lt;/code&gt;.
     */
    public WritableRaster copyData(WritableRaster outRaster) {
<span class="nc bnc" id="L1480" title="All 2 branches missed.">        if (outRaster == null) {</span>
<span class="nc" id="L1481">            return (WritableRaster) getData();</span>
        }
<span class="nc" id="L1483">        int width = outRaster.getWidth();</span>
<span class="nc" id="L1484">        int height = outRaster.getHeight();</span>
<span class="nc" id="L1485">        int startX = outRaster.getMinX();</span>
<span class="nc" id="L1486">        int startY = outRaster.getMinY();</span>

<span class="nc" id="L1488">        Object tdata = null;</span>

<span class="nc bnc" id="L1490" title="All 2 branches missed.">        for (int i = startY; i &lt; startY+height; i++)  {</span>
<span class="nc" id="L1491">            tdata = raster.getDataElements(startX,i,width,1,tdata);</span>
<span class="nc" id="L1492">            outRaster.setDataElements(startX,i,width,1, tdata);</span>
        }

<span class="nc" id="L1495">        return outRaster;</span>
    }

  /**
     * Sets a rectangular region of the image to the contents of the
     * specified &lt;code&gt;Raster&lt;/code&gt; &lt;code&gt;r&lt;/code&gt;, which is
     * assumed to be in the same coordinate space as the
     * &lt;code&gt;BufferedImage&lt;/code&gt;. The operation is clipped to the bounds
     * of the &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @param r the specified &lt;code&gt;Raster&lt;/code&gt;
     * @see #getData
     * @see #getData(Rectangle)
    */
    public void setData(Raster r) {
<span class="nc" id="L1509">        int width = r.getWidth();</span>
<span class="nc" id="L1510">        int height = r.getHeight();</span>
<span class="nc" id="L1511">        int startX = r.getMinX();</span>
<span class="nc" id="L1512">        int startY = r.getMinY();</span>

<span class="nc" id="L1514">        int[] tdata = null;</span>

        // Clip to the current Raster
<span class="nc" id="L1517">        Rectangle rclip = new Rectangle(startX, startY, width, height);</span>
<span class="nc" id="L1518">        Rectangle bclip = new Rectangle(0, 0, raster.width, raster.height);</span>
<span class="nc" id="L1519">        Rectangle intersect = rclip.intersection(bclip);</span>
<span class="nc bnc" id="L1520" title="All 2 branches missed.">        if (intersect.isEmpty()) {</span>
<span class="nc" id="L1521">            return;</span>
        }
<span class="nc" id="L1523">        width = intersect.width;</span>
<span class="nc" id="L1524">        height = intersect.height;</span>
<span class="nc" id="L1525">        startX = intersect.x;</span>
<span class="nc" id="L1526">        startY = intersect.y;</span>

        // remind use get/setDataElements for speed if Rasters are
        // compatible
<span class="nc bnc" id="L1530" title="All 2 branches missed.">        for (int i = startY; i &lt; startY+height; i++)  {</span>
<span class="nc" id="L1531">            tdata = r.getPixels(startX,i,width,1,tdata);</span>
<span class="nc" id="L1532">            raster.setPixels(startX,i,width,1, tdata);</span>
        }
<span class="nc" id="L1534">    }</span>


  /**
   * Adds a tile observer.  If the observer is already present,
   * it receives multiple notifications.
   * @param to the specified {@link TileObserver}
   */
    public void addTileObserver (TileObserver to) {
<span class="nc" id="L1543">    }</span>

  /**
   * Removes a tile observer.  If the observer was not registered,
   * nothing happens.  If the observer was registered for multiple
   * notifications, it is now registered for one fewer notification.
   * @param to the specified &lt;code&gt;TileObserver&lt;/code&gt;.
   */
    public void removeTileObserver (TileObserver to) {
<span class="nc" id="L1552">    }</span>

    /**
     * Returns whether or not a tile is currently checked out for writing.
     * @param tileX the x index of the tile.
     * @param tileY the y index of the tile.
     * @return &lt;code&gt;true&lt;/code&gt; if the tile specified by the specified
     *          indices is checked out for writing; &lt;code&gt;false&lt;/code&gt;
     *          otherwise.
     * @exception ArrayIndexOutOfBoundsException if both
     *          &lt;code&gt;tileX&lt;/code&gt; and &lt;code&gt;tileY&lt;/code&gt; are not equal
     *          to 0
     */
    public boolean isTileWritable (int tileX, int tileY) {
<span class="nc bnc" id="L1566" title="All 4 branches missed.">        if (tileX == 0 &amp;&amp; tileY == 0) {</span>
<span class="nc" id="L1567">            return true;</span>
        }
<span class="nc" id="L1569">        throw new IllegalArgumentException(&quot;Only 1 tile in image&quot;);</span>
    }

    /**
     * Returns an array of {@link Point} objects indicating which tiles
     * are checked out for writing.  Returns &lt;code&gt;null&lt;/code&gt; if none are
     * checked out.
     * @return a &lt;code&gt;Point&lt;/code&gt; array that indicates the tiles that
     *          are checked out for writing, or &lt;code&gt;null&lt;/code&gt; if no
     *          tiles are checked out for writing.
     */
    public Point[] getWritableTileIndices() {
<span class="nc" id="L1581">        Point[] p = new Point[1];</span>
<span class="nc" id="L1582">        p[0] = new Point(0, 0);</span>

<span class="nc" id="L1584">        return p;</span>
    }

    /**
     * Returns whether or not any tile is checked out for writing.
     * Semantically equivalent to
     * &lt;pre&gt;
     * (getWritableTileIndices() != null).
     * &lt;/pre&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if any tile is checked out for writing;
     *          &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean hasTileWriters () {
<span class="nc" id="L1597">        return true;</span>
    }

  /**
   * Checks out a tile for writing.  All registered
   * &lt;code&gt;TileObservers&lt;/code&gt; are notified when a tile goes from having
   * no writers to having one writer.
   * @param tileX the x index of the tile
   * @param tileY the y index of the tile
   * @return a &lt;code&gt;WritableRaster&lt;/code&gt; that is the tile, indicated by
   *            the specified indices, to be checked out for writing.
   */
    public WritableRaster getWritableTile (int tileX, int tileY) {
<span class="nc" id="L1610">        return raster;</span>
    }

  /**
   * Relinquishes permission to write to a tile.  If the caller
   * continues to write to the tile, the results are undefined.
   * Calls to this method should only appear in matching pairs
   * with calls to {@link #getWritableTile(int, int) getWritableTile(int, int)}.  Any other leads
   * to undefined results.  All registered &lt;code&gt;TileObservers&lt;/code&gt;
   * are notified when a tile goes from having one writer to having no
   * writers.
   * @param tileX the x index of the tile
   * @param tileY the y index of the tile
   */
    public void releaseWritableTile (int tileX, int tileY) {
<span class="nc" id="L1625">    }</span>

    /**
     * Returns the transparency.  Returns either OPAQUE, BITMASK,
     * or TRANSLUCENT.
     * @return the transparency of this &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @see Transparency#OPAQUE
     * @see Transparency#BITMASK
     * @see Transparency#TRANSLUCENT
     * @since 1.5
     */
    public int getTransparency() {
<span class="nc" id="L1637">        return colorModel.getTransparency();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>