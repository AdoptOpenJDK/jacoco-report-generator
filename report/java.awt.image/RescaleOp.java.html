<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>RescaleOp.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">RescaleOp.java</span></div><h1>RescaleOp.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2000, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.color.ColorSpace;
import java.awt.geom.Rectangle2D;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.RenderingHints;
import sun.awt.image.ImagingLib;

/**
 * This class performs a pixel-by-pixel rescaling of the data in the
 * source image by multiplying the sample values for each pixel by a scale
 * factor and then adding an offset. The scaled sample values are clipped
 * to the minimum/maximum representable in the destination image.
 * &lt;p&gt;
 * The pseudo code for the rescaling operation is as follows:
 * &lt;pre&gt;
 *for each pixel from Source object {
 *    for each band/component of the pixel {
 *        dstElement = (srcElement*scaleFactor) + offset
 *    }
 *}
 * &lt;/pre&gt;
 * &lt;p&gt;
 * For Rasters, rescaling operates on bands.  The number of
 * sets of scaling constants may be one, in which case the same constants
 * are applied to all bands, or it must equal the number of Source
 * Raster bands.
 * &lt;p&gt;
 * For BufferedImages, rescaling operates on color and alpha components.
 * The number of sets of scaling constants may be one, in which case the
 * same constants are applied to all color (but not alpha) components.
 * Otherwise, the  number of sets of scaling constants may
 * equal the number of Source color components, in which case no
 * rescaling of the alpha component (if present) is performed.
 * If neither of these cases apply, the number of sets of scaling constants
 * must equal the number of Source color components plus alpha components,
 * in which case all color and alpha components are rescaled.
 * &lt;p&gt;
 * BufferedImage sources with premultiplied alpha data are treated in the same
 * manner as non-premultiplied images for purposes of rescaling.  That is,
 * the rescaling is done per band on the raw data of the BufferedImage source
 * without regard to whether the data is premultiplied.  If a color conversion
 * is required to the destination ColorModel, the premultiplied state of
 * both source and destination will be taken into account for this step.
 * &lt;p&gt;
 * Images with an IndexColorModel cannot be rescaled.
 * &lt;p&gt;
 * If a RenderingHints object is specified in the constructor, the
 * color rendering hint and the dithering hint may be used when color
 * conversion is required.
 * &lt;p&gt;
 * Note that in-place operation is allowed (i.e. the source and destination can
 * be the same object).
 * @see java.awt.RenderingHints#KEY_COLOR_RENDERING
 * @see java.awt.RenderingHints#KEY_DITHERING
 */
public class RescaleOp implements BufferedImageOp, RasterOp {
    float[] scaleFactors;
    float[] offsets;
<span class="nc" id="L86">    int length = 0;</span>
    RenderingHints hints;

    private int srcNbits;
    private int dstNbits;


    /**
     * Constructs a new RescaleOp with the desired scale factors
     * and offsets.  The length of the scaleFactor and offset arrays
     * must meet the restrictions stated in the class comments above.
     * The RenderingHints argument may be null.
     * @param scaleFactors the specified scale factors
     * @param offsets the specified offsets
     * @param hints the specified &lt;code&gt;RenderingHints&lt;/code&gt;, or
     *        &lt;code&gt;null&lt;/code&gt;
     */
    public RescaleOp (float[] scaleFactors, float[] offsets,
<span class="nc" id="L104">                      RenderingHints hints) {</span>
<span class="nc" id="L105">        length = scaleFactors.length;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (length &gt; offsets.length) length = offsets.length;</span>

<span class="nc" id="L108">        this.scaleFactors = new float[length];</span>
<span class="nc" id="L109">        this.offsets      = new float[length];</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">        for (int i=0; i &lt; length; i++) {</span>
<span class="nc" id="L111">            this.scaleFactors[i] = scaleFactors[i];</span>
<span class="nc" id="L112">            this.offsets[i]      = offsets[i];</span>
        }
<span class="nc" id="L114">        this.hints = hints;</span>
<span class="nc" id="L115">    }</span>

    /**
     * Constructs a new RescaleOp with the desired scale factor
     * and offset.  The scaleFactor and offset will be applied to
     * all bands in a source Raster and to all color (but not alpha)
     * components in a BufferedImage.
     * The RenderingHints argument may be null.
     * @param scaleFactor the specified scale factor
     * @param offset the specified offset
     * @param hints the specified &lt;code&gt;RenderingHints&lt;/code&gt;, or
     *        &lt;code&gt;null&lt;/code&gt;
     */
<span class="nc" id="L128">    public RescaleOp (float scaleFactor, float offset, RenderingHints hints) {</span>
<span class="nc" id="L129">        length = 1;</span>
<span class="nc" id="L130">        this.scaleFactors = new float[1];</span>
<span class="nc" id="L131">        this.offsets      = new float[1];</span>
<span class="nc" id="L132">        this.scaleFactors[0] = scaleFactor;</span>
<span class="nc" id="L133">        this.offsets[0]       = offset;</span>
<span class="nc" id="L134">        this.hints = hints;</span>
<span class="nc" id="L135">    }</span>

    /**
     * Returns the scale factors in the given array. The array is also
     * returned for convenience.  If scaleFactors is null, a new array
     * will be allocated.
     * @param scaleFactors the array to contain the scale factors of
     *        this &lt;code&gt;RescaleOp&lt;/code&gt;
     * @return the scale factors of this &lt;code&gt;RescaleOp&lt;/code&gt;.
     */
    final public float[] getScaleFactors (float scaleFactors[]) {
<span class="nc bnc" id="L146" title="All 2 branches missed.">        if (scaleFactors == null) {</span>
<span class="nc" id="L147">            return (float[]) this.scaleFactors.clone();</span>
        }
<span class="nc" id="L149">        System.arraycopy (this.scaleFactors, 0, scaleFactors, 0,</span>
<span class="nc" id="L150">                          Math.min(this.scaleFactors.length,</span>
                                   scaleFactors.length));
<span class="nc" id="L152">        return scaleFactors;</span>
    }

    /**
     * Returns the offsets in the given array. The array is also returned
     * for convenience.  If offsets is null, a new array
     * will be allocated.
     * @param offsets the array to contain the offsets of
     *        this &lt;code&gt;RescaleOp&lt;/code&gt;
     * @return the offsets of this &lt;code&gt;RescaleOp&lt;/code&gt;.
     */
    final public float[] getOffsets(float offsets[]) {
<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (offsets == null) {</span>
<span class="nc" id="L165">            return (float[]) this.offsets.clone();</span>
        }

<span class="nc" id="L168">        System.arraycopy (this.offsets, 0, offsets, 0,</span>
<span class="nc" id="L169">                          Math.min(this.offsets.length, offsets.length));</span>
<span class="nc" id="L170">        return offsets;</span>
    }

    /**
     * Returns the number of scaling factors and offsets used in this
     * RescaleOp.
     * @return the number of scaling factors and offsets of this
     *         &lt;code&gt;RescaleOp&lt;/code&gt;.
     */
    final public int getNumFactors() {
<span class="nc" id="L180">        return length;</span>
    }


    /**
     * Creates a ByteLookupTable to implement the rescale.
     * The table may have either a SHORT or BYTE input.
     * @param nElems    Number of elements the table is to have.
     *                  This will generally be 256 for byte and
     *                  65536 for short.
     */
    private ByteLookupTable createByteLut(float scale[],
                                          float off[],
                                          int   nBands,
                                          int   nElems) {

<span class="nc" id="L196">        byte[][]        lutData = new byte[scale.length][nElems];</span>

<span class="nc bnc" id="L198" title="All 2 branches missed.">        for (int band=0; band&lt;scale.length; band++) {</span>
<span class="nc" id="L199">            float  bandScale   = scale[band];</span>
<span class="nc" id="L200">            float  bandOff     = off[band];</span>
<span class="nc" id="L201">            byte[] bandLutData = lutData[band];</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">            for (int i=0; i&lt;nElems; i++) {</span>
<span class="nc" id="L203">                int val = (int)(i*bandScale + bandOff);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">                if ((val &amp; 0xffffff00) != 0) {</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">                    if (val &lt; 0) {</span>
<span class="nc" id="L206">                        val = 0;</span>
                    } else {
<span class="nc" id="L208">                        val = 255;</span>
                    }
                }
<span class="nc" id="L211">                bandLutData[i] = (byte)val;</span>
            }

        }

<span class="nc" id="L216">        return new ByteLookupTable(0, lutData);</span>
    }

    /**
     * Creates a ShortLookupTable to implement the rescale.
     * The table may have either a SHORT or BYTE input.
     * @param nElems    Number of elements the table is to have.
     *                  This will generally be 256 for byte and
     *                  65536 for short.
     */
    private ShortLookupTable createShortLut(float scale[],
                                            float off[],
                                            int   nBands,
                                            int   nElems) {

<span class="nc" id="L231">        short[][]        lutData = new short[scale.length][nElems];</span>

<span class="nc bnc" id="L233" title="All 2 branches missed.">        for (int band=0; band&lt;scale.length; band++) {</span>
<span class="nc" id="L234">            float   bandScale   = scale[band];</span>
<span class="nc" id="L235">            float   bandOff     = off[band];</span>
<span class="nc" id="L236">            short[] bandLutData = lutData[band];</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">            for (int i=0; i&lt;nElems; i++) {</span>
<span class="nc" id="L238">                int val = (int)(i*bandScale + bandOff);</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                if ((val &amp; 0xffff0000) != 0) {</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                    if (val &lt; 0) {</span>
<span class="nc" id="L241">                        val = 0;</span>
                    } else {
<span class="nc" id="L243">                        val = 65535;</span>
                    }
                }
<span class="nc" id="L246">                bandLutData[i] = (short)val;</span>
            }
        }

<span class="nc" id="L250">        return new ShortLookupTable(0, lutData);</span>
    }


    /**
     * Determines if the rescale can be performed as a lookup.
     * The dst must be a byte or short type.
     * The src must be less than 16 bits.
     * All source band sizes must be the same and all dst band sizes
     * must be the same.
     */
    private boolean canUseLookup(Raster src, Raster dst) {

        //
        // Check that the src datatype is either a BYTE or SHORT
        //
<span class="nc" id="L266">        int datatype = src.getDataBuffer().getDataType();</span>
<span class="nc bnc" id="L267" title="All 4 branches missed.">        if(datatype != DataBuffer.TYPE_BYTE &amp;&amp;</span>
           datatype != DataBuffer.TYPE_USHORT) {
<span class="nc" id="L269">            return false;</span>
        }

        //
        // Check dst sample sizes. All must be 8 or 16 bits.
        //
<span class="nc" id="L275">        SampleModel dstSM = dst.getSampleModel();</span>
<span class="nc" id="L276">        dstNbits = dstSM.getSampleSize(0);</span>

<span class="nc bnc" id="L278" title="All 4 branches missed.">        if (!(dstNbits == 8 || dstNbits == 16)) {</span>
<span class="nc" id="L279">            return false;</span>
        }
<span class="nc bnc" id="L281" title="All 2 branches missed.">        for (int i=1; i&lt;src.getNumBands(); i++) {</span>
<span class="nc" id="L282">            int bandSize = dstSM.getSampleSize(i);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">            if (bandSize != dstNbits) {</span>
<span class="nc" id="L284">                return false;</span>
            }
        }

        //
        // Check src sample sizes. All must be the same size
        //
<span class="nc" id="L291">        SampleModel srcSM = src.getSampleModel();</span>
<span class="nc" id="L292">        srcNbits = srcSM.getSampleSize(0);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (srcNbits &gt; 16) {</span>
<span class="nc" id="L294">            return false;</span>
        }
<span class="nc bnc" id="L296" title="All 2 branches missed.">        for (int i=1; i&lt;src.getNumBands(); i++) {</span>
<span class="nc" id="L297">            int bandSize = srcSM.getSampleSize(i);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">            if (bandSize != srcNbits) {</span>
<span class="nc" id="L299">                return false;</span>
            }
        }

<span class="nc" id="L303">        return true;</span>
    }

    /**
     * Rescales the source BufferedImage.
     * If the color model in the source image is not the same as that
     * in the destination image, the pixels will be converted
     * in the destination.  If the destination image is null,
     * a BufferedImage will be created with the source ColorModel.
     * An IllegalArgumentException may be thrown if the number of
     * scaling factors/offsets in this object does not meet the
     * restrictions stated in the class comments above, or if the
     * source image has an IndexColorModel.
     * @param src the &lt;code&gt;BufferedImage&lt;/code&gt; to be filtered
     * @param dst the destination for the filtering operation
     *            or &lt;code&gt;null&lt;/code&gt;
     * @return the filtered &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @throws IllegalArgumentException if the &lt;code&gt;ColorModel&lt;/code&gt;
     *         of &lt;code&gt;src&lt;/code&gt; is an &lt;code&gt;IndexColorModel&lt;/code&gt;,
     *         or if the number of scaling factors and offsets in this
     *         &lt;code&gt;RescaleOp&lt;/code&gt; do not meet the requirements
     *         stated in the class comments.
     */
    public final BufferedImage filter (BufferedImage src, BufferedImage dst) {
<span class="nc" id="L327">        ColorModel srcCM = src.getColorModel();</span>
        ColorModel dstCM;
<span class="nc" id="L329">        int numBands = srcCM.getNumColorComponents();</span>


<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (srcCM instanceof IndexColorModel) {</span>
<span class="nc" id="L333">            throw new</span>
                IllegalArgumentException(&quot;Rescaling cannot be &quot;+
                                         &quot;performed on an indexed image&quot;);
        }
<span class="nc bnc" id="L337" title="All 4 branches missed.">        if (length != 1 &amp;&amp; length != numBands &amp;&amp;</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">            length != srcCM.getNumComponents())</span>
        {
<span class="nc" id="L340">            throw new IllegalArgumentException(&quot;Number of scaling constants &quot;+</span>
                                               &quot;does not equal the number of&quot;+
                                               &quot; of color or color/alpha &quot;+
                                               &quot; components&quot;);
        }

<span class="nc" id="L346">        boolean needToConvert = false;</span>

        // Include alpha
<span class="nc bnc" id="L349" title="All 4 branches missed.">        if (length &gt; numBands &amp;&amp; srcCM.hasAlpha()) {</span>
<span class="nc" id="L350">            length = numBands+1;</span>
        }

<span class="nc" id="L353">        int width = src.getWidth();</span>
<span class="nc" id="L354">        int height = src.getHeight();</span>

<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L357">            dst = createCompatibleDestImage(src, null);</span>
<span class="nc" id="L358">            dstCM = srcCM;</span>
        }
        else {
<span class="nc bnc" id="L361" title="All 2 branches missed.">            if (width != dst.getWidth()) {</span>
<span class="nc" id="L362">                throw new</span>
                    IllegalArgumentException(&quot;Src width (&quot;+width+
                                             &quot;) not equal to dst width (&quot;+
<span class="nc" id="L365">                                             dst.getWidth()+&quot;)&quot;);</span>
            }
<span class="nc bnc" id="L367" title="All 2 branches missed.">            if (height != dst.getHeight()) {</span>
<span class="nc" id="L368">                throw new</span>
                    IllegalArgumentException(&quot;Src height (&quot;+height+
                                             &quot;) not equal to dst height (&quot;+
<span class="nc" id="L371">                                             dst.getHeight()+&quot;)&quot;);</span>
            }

<span class="nc" id="L374">            dstCM = dst.getColorModel();</span>
<span class="nc" id="L375">            if(srcCM.getColorSpace().getType() !=</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">               dstCM.getColorSpace().getType()) {</span>
<span class="nc" id="L377">                needToConvert = true;</span>
<span class="nc" id="L378">                dst = createCompatibleDestImage(src, null);</span>
            }

        }

<span class="nc" id="L383">        BufferedImage origDst = dst;</span>

        //
        // Try to use a native BI rescale operation first
        //
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (ImagingLib.filter(this, src, dst) == null) {</span>
            //
            // Native BI rescale failed - convert to rasters
            //
<span class="nc" id="L392">            WritableRaster srcRaster = src.getRaster();</span>
<span class="nc" id="L393">            WritableRaster dstRaster = dst.getRaster();</span>

<span class="nc bnc" id="L395" title="All 2 branches missed.">            if (srcCM.hasAlpha()) {</span>
<span class="nc bnc" id="L396" title="All 4 branches missed.">                if (numBands-1 == length || length == 1) {</span>
<span class="nc" id="L397">                    int minx = srcRaster.getMinX();</span>
<span class="nc" id="L398">                    int miny = srcRaster.getMinY();</span>
<span class="nc" id="L399">                    int[] bands = new int[numBands-1];</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">                    for (int i=0; i &lt; numBands-1; i++) {</span>
<span class="nc" id="L401">                        bands[i] = i;</span>
                    }
<span class="nc" id="L403">                    srcRaster =</span>
<span class="nc" id="L404">                        srcRaster.createWritableChild(minx, miny,</span>
<span class="nc" id="L405">                                                      srcRaster.getWidth(),</span>
<span class="nc" id="L406">                                                      srcRaster.getHeight(),</span>
                                                      minx, miny,
                                                      bands);
                }
            }
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (dstCM.hasAlpha()) {</span>
<span class="nc" id="L412">                int dstNumBands = dstRaster.getNumBands();</span>
<span class="nc bnc" id="L413" title="All 4 branches missed.">                if (dstNumBands-1 == length || length == 1) {</span>
<span class="nc" id="L414">                    int minx = dstRaster.getMinX();</span>
<span class="nc" id="L415">                    int miny = dstRaster.getMinY();</span>
<span class="nc" id="L416">                    int[] bands = new int[numBands-1];</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">                    for (int i=0; i &lt; numBands-1; i++) {</span>
<span class="nc" id="L418">                        bands[i] = i;</span>
                    }
<span class="nc" id="L420">                    dstRaster =</span>
<span class="nc" id="L421">                        dstRaster.createWritableChild(minx, miny,</span>
<span class="nc" id="L422">                                                      dstRaster.getWidth(),</span>
<span class="nc" id="L423">                                                      dstRaster.getHeight(),</span>
                                                      minx, miny,
                                                      bands);
                }
            }

            //
            // Call the raster filter method
            //
<span class="nc" id="L432">            filter(srcRaster, dstRaster);</span>

        }

<span class="nc bnc" id="L436" title="All 2 branches missed.">        if (needToConvert) {</span>
            // ColorModels are not the same
<span class="nc" id="L438">            ColorConvertOp ccop = new ColorConvertOp(hints);</span>
<span class="nc" id="L439">            ccop.filter(dst, origDst);</span>
        }

<span class="nc" id="L442">        return origDst;</span>
    }

    /**
     * Rescales the pixel data in the source Raster.
     * If the destination Raster is null, a new Raster will be created.
     * The source and destination must have the same number of bands.
     * Otherwise, an IllegalArgumentException is thrown.
     * Note that the number of scaling factors/offsets in this object must
     * meet the restrictions stated in the class comments above.
     * Otherwise, an IllegalArgumentException is thrown.
     * @param src the &lt;code&gt;Raster&lt;/code&gt; to be filtered
     * @param dst the destination for the filtering operation
     *            or &lt;code&gt;null&lt;/code&gt;
     * @return the filtered &lt;code&gt;WritableRaster&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;src&lt;/code&gt; and
     *         &lt;code&gt;dst&lt;/code&gt; do not have the same number of bands,
     *         or if the number of scaling factors and offsets in this
     *         &lt;code&gt;RescaleOp&lt;/code&gt; do not meet the requirements
     *         stated in the class comments.
     */
    public final WritableRaster filter (Raster src, WritableRaster dst)  {
<span class="nc" id="L464">        int numBands = src.getNumBands();</span>
<span class="nc" id="L465">        int width  = src.getWidth();</span>
<span class="nc" id="L466">        int height = src.getHeight();</span>
<span class="nc" id="L467">        int[] srcPix = null;</span>
<span class="nc" id="L468">        int step = 0;</span>
<span class="nc" id="L469">        int tidx = 0;</span>

        // Create a new destination Raster, if needed
<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L473">            dst = createCompatibleDestRaster(src);</span>
        }
<span class="nc bnc" id="L475" title="All 4 branches missed.">        else if (height != dst.getHeight() || width != dst.getWidth()) {</span>
<span class="nc" id="L476">            throw new</span>
               IllegalArgumentException(&quot;Width or height of Rasters do not &quot;+
                                        &quot;match&quot;);
        }
<span class="nc bnc" id="L480" title="All 2 branches missed.">        else if (numBands != dst.getNumBands()) {</span>
            // Make sure that the number of bands are equal
<span class="nc" id="L482">            throw new IllegalArgumentException(&quot;Number of bands in src &quot;</span>
                            + numBands
                            + &quot; does not equal number of bands in dest &quot;
<span class="nc" id="L485">                            + dst.getNumBands());</span>
        }
        // Make sure that the arrays match
        // Make sure that the low/high/constant arrays match
<span class="nc bnc" id="L489" title="All 4 branches missed.">        if (length != 1 &amp;&amp; length != src.getNumBands()) {</span>
<span class="nc" id="L490">            throw new IllegalArgumentException(&quot;Number of scaling constants &quot;+</span>
                                               &quot;does not equal the number of&quot;+
                                               &quot; of bands in the src raster&quot;);
        }


        //
        // Try for a native raster rescale first
        //
<span class="nc bnc" id="L499" title="All 2 branches missed.">        if (ImagingLib.filter(this, src, dst) != null) {</span>
<span class="nc" id="L500">            return dst;</span>
        }

        //
        // Native raster rescale failed.
        // Try to see if a lookup operation can be used
        //
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (canUseLookup(src, dst)) {</span>
<span class="nc" id="L508">            int srcNgray = (1 &lt;&lt; srcNbits);</span>
<span class="nc" id="L509">            int dstNgray = (1 &lt;&lt; dstNbits);</span>

<span class="nc bnc" id="L511" title="All 2 branches missed.">            if (dstNgray == 256) {</span>
<span class="nc" id="L512">                ByteLookupTable lut = createByteLut(scaleFactors, offsets,</span>
                                                    numBands, srcNgray);
<span class="nc" id="L514">                LookupOp op = new LookupOp(lut, hints);</span>
<span class="nc" id="L515">                op.filter(src, dst);</span>
<span class="nc" id="L516">            } else {</span>
<span class="nc" id="L517">                ShortLookupTable lut = createShortLut(scaleFactors, offsets,</span>
                                                      numBands, srcNgray);
<span class="nc" id="L519">                LookupOp op = new LookupOp(lut, hints);</span>
<span class="nc" id="L520">                op.filter(src, dst);</span>
            }
<span class="nc" id="L522">        } else {</span>
            //
            // Fall back to the slow code
            //
<span class="nc bnc" id="L526" title="All 2 branches missed.">            if (length &gt; 1) {</span>
<span class="nc" id="L527">                step = 1;</span>
            }

<span class="nc" id="L530">            int sminX = src.getMinX();</span>
<span class="nc" id="L531">            int sY = src.getMinY();</span>
<span class="nc" id="L532">            int dminX = dst.getMinX();</span>
<span class="nc" id="L533">            int dY = dst.getMinY();</span>
            int sX;
            int dX;

            //
            //  Determine bits per band to determine maxval for clamps.
            //  The min is assumed to be zero.
            //  REMIND: This must change if we ever support signed data types.
            //
            int nbits;
<span class="nc" id="L543">            int dstMax[] = new int[numBands];</span>
<span class="nc" id="L544">            int dstMask[] = new int[numBands];</span>
<span class="nc" id="L545">            SampleModel dstSM = dst.getSampleModel();</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            for (int z=0; z&lt;numBands; z++) {</span>
<span class="nc" id="L547">                nbits = dstSM.getSampleSize(z);</span>
<span class="nc" id="L548">                dstMax[z] = (1 &lt;&lt; nbits) - 1;</span>
<span class="nc" id="L549">                dstMask[z] = ~(dstMax[z]);</span>
            }

            int val;
<span class="nc bnc" id="L553" title="All 2 branches missed.">            for (int y=0; y &lt; height; y++, sY++, dY++) {</span>
<span class="nc" id="L554">                dX = dminX;</span>
<span class="nc" id="L555">                sX = sminX;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">                for (int x = 0; x &lt; width; x++, sX++, dX++) {</span>
                    // Get data for all bands at this x,y position
<span class="nc" id="L558">                    srcPix = src.getPixel(sX, sY, srcPix);</span>
<span class="nc" id="L559">                    tidx = 0;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                    for (int z=0; z&lt;numBands; z++, tidx += step) {</span>
<span class="nc" id="L561">                        val = (int)(srcPix[z]*scaleFactors[tidx]</span>
                                          + offsets[tidx]);
                        // Clamp
<span class="nc bnc" id="L564" title="All 2 branches missed.">                        if ((val &amp; dstMask[z]) != 0) {</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                            if (val &lt; 0) {</span>
<span class="nc" id="L566">                                val = 0;</span>
                            } else {
<span class="nc" id="L568">                                val = dstMax[z];</span>
                            }
                        }
<span class="nc" id="L571">                        srcPix[z] = val;</span>

                    }

                    // Put it back for all bands
<span class="nc" id="L576">                    dst.setPixel(dX, dY, srcPix);</span>
                }
            }
        }
<span class="nc" id="L580">        return dst;</span>
    }

    /**
     * Returns the bounding box of the rescaled destination image.  Since
     * this is not a geometric operation, the bounding box does not
     * change.
     */
    public final Rectangle2D getBounds2D (BufferedImage src) {
<span class="nc" id="L589">         return getBounds2D(src.getRaster());</span>
    }

    /**
     * Returns the bounding box of the rescaled destination Raster.  Since
     * this is not a geometric operation, the bounding box does not
     * change.
     * @param src the rescaled destination &lt;code&gt;Raster&lt;/code&gt;
     * @return the bounds of the specified &lt;code&gt;Raster&lt;/code&gt;.
     */
    public final Rectangle2D getBounds2D (Raster src) {
<span class="nc" id="L600">        return src.getBounds();</span>
    }

    /**
     * Creates a zeroed destination image with the correct size and number of
     * bands.
     * @param src       Source image for the filter operation.
     * @param destCM    ColorModel of the destination.  If null, the
     *                  ColorModel of the source will be used.
     * @return the zeroed-destination image.
     */
    public BufferedImage createCompatibleDestImage (BufferedImage src,
                                                    ColorModel destCM) {
        BufferedImage image;
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (destCM == null) {</span>
<span class="nc" id="L615">            ColorModel cm = src.getColorModel();</span>
<span class="nc" id="L616">            image = new BufferedImage(cm,</span>
<span class="nc" id="L617">                                      src.getRaster().createCompatibleWritableRaster(),</span>
<span class="nc" id="L618">                                      cm.isAlphaPremultiplied(),</span>
                                      null);
<span class="nc" id="L620">        }</span>
        else {
<span class="nc" id="L622">            int w = src.getWidth();</span>
<span class="nc" id="L623">            int h = src.getHeight();</span>
<span class="nc" id="L624">            image = new BufferedImage (destCM,</span>
<span class="nc" id="L625">                                   destCM.createCompatibleWritableRaster(w, h),</span>
<span class="nc" id="L626">                                   destCM.isAlphaPremultiplied(), null);</span>
        }

<span class="nc" id="L629">        return image;</span>
    }

    /**
     * Creates a zeroed-destination &lt;code&gt;Raster&lt;/code&gt; with the correct
     * size and number of bands, given this source.
     * @param src       the source &lt;code&gt;Raster&lt;/code&gt;
     * @return the zeroed-destination &lt;code&gt;Raster&lt;/code&gt;.
     */
    public WritableRaster createCompatibleDestRaster (Raster src) {
<span class="nc" id="L639">        return src.createCompatibleWritableRaster(src.getWidth(), src.getHeight());</span>
    }

    /**
     * Returns the location of the destination point given a
     * point in the source.  If dstPt is non-null, it will
     * be used to hold the return value.  Since this is not a geometric
     * operation, the srcPt will equal the dstPt.
     * @param srcPt a point in the source image
     * @param dstPt the destination point or &lt;code&gt;null&lt;/code&gt;
     * @return the location of the destination point.
     */
    public final Point2D getPoint2D (Point2D srcPt, Point2D dstPt) {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (dstPt == null) {</span>
<span class="nc" id="L653">            dstPt = new Point2D.Float();</span>
        }
<span class="nc" id="L655">        dstPt.setLocation(srcPt.getX(), srcPt.getY());</span>
<span class="nc" id="L656">        return dstPt;</span>
    }

    /**
     * Returns the rendering hints for this op.
     * @return the rendering hints of this &lt;code&gt;RescaleOp&lt;/code&gt;.
     */
    public final RenderingHints getRenderingHints() {
<span class="nc" id="L664">        return hints;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>