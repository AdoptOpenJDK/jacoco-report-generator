<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ReplicateScaleFilter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">ReplicateScaleFilter.java</span></div><h1>ReplicateScaleFilter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1996, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.image.ImageConsumer;
import java.awt.image.ColorModel;
import java.util.Hashtable;
import java.awt.Rectangle;

/**
 * An ImageFilter class for scaling images using the simplest algorithm.
 * This class extends the basic ImageFilter Class to scale an existing
 * image and provide a source for a new image containing the resampled
 * image.  The pixels in the source image are sampled to produce pixels
 * for an image of the specified size by replicating rows and columns of
 * pixels to scale up or omitting rows and columns of pixels to scale
 * down.
 * &lt;p&gt;It is meant to be used in conjunction with a FilteredImageSource
 * object to produce scaled versions of existing images.  Due to
 * implementation dependencies, there may be differences in pixel values
 * of an image filtered on different platforms.
 *
 * @see FilteredImageSource
 * @see ImageFilter
 *
 * @author      Jim Graham
 */
public class ReplicateScaleFilter extends ImageFilter {

    /**
     * The width of the source image.
     */
    protected int srcWidth;

    /**
     * The height of the source image.
     */
    protected int srcHeight;

    /**
     * The target width to scale the image.
     */
    protected int destWidth;

    /**
     * The target height to scale the image.
     */
    protected int destHeight;

    /**
     * An &lt;code&gt;int&lt;/code&gt; array containing information about a
     * row of pixels.
     */
    protected int srcrows[];

    /**
     * An &lt;code&gt;int&lt;/code&gt; array containing information about a
     * column of pixels.
     */
    protected int srccols[];

    /**
     * A &lt;code&gt;byte&lt;/code&gt; array initialized with a size of
     * {@link #destWidth} and used to deliver a row of pixel
     * data to the {@link ImageConsumer}.
     */
    protected Object outpixbuf;

    /**
     * Constructs a ReplicateScaleFilter that scales the pixels from
     * its source Image as specified by the width and height parameters.
     * @param width the target width to scale the image
     * @param height the target height to scale the image
     * @throws IllegalArgumentException if &lt;code&gt;width&lt;/code&gt; equals
     *         zero or &lt;code&gt;height&lt;/code&gt; equals zero
     */
<span class="nc" id="L100">    public ReplicateScaleFilter(int width, int height) {</span>
<span class="nc bnc" id="L101" title="All 4 branches missed.">        if (width == 0 || height == 0) {</span>
<span class="nc" id="L102">            throw new IllegalArgumentException(&quot;Width (&quot;+width+</span>
                                                &quot;) and height (&quot;+height+
                                                &quot;) must be non-zero&quot;);
        }
<span class="nc" id="L106">        destWidth = width;</span>
<span class="nc" id="L107">        destHeight = height;</span>
<span class="nc" id="L108">    }</span>

    /**
     * Passes along the properties from the source object after adding a
     * property indicating the scale applied.
     * This method invokes &lt;code&gt;super.setProperties&lt;/code&gt;,
     * which might result in additional properties being added.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels
     * are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     */
    public void setProperties(Hashtable&lt;?,?&gt; props) {
<span class="nc" id="L124">        Hashtable&lt;Object,Object&gt; p = (Hashtable&lt;Object,Object&gt;)props.clone();</span>
<span class="nc" id="L125">        String key = &quot;rescale&quot;;</span>
<span class="nc" id="L126">        String val = destWidth + &quot;x&quot; + destHeight;</span>
<span class="nc" id="L127">        Object o = p.get(key);</span>
<span class="nc bnc" id="L128" title="All 4 branches missed.">        if (o != null &amp;&amp; o instanceof String) {</span>
<span class="nc" id="L129">            val = ((String) o) + &quot;, &quot; + val;</span>
        }
<span class="nc" id="L131">        p.put(key, val);</span>
<span class="nc" id="L132">        super.setProperties(p);</span>
<span class="nc" id="L133">    }</span>

    /**
     * Override the dimensions of the source image and pass the dimensions
     * of the new scaled size to the ImageConsumer.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels
     * are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     * @see ImageConsumer
     */
    public void setDimensions(int w, int h) {
<span class="nc" id="L148">        srcWidth = w;</span>
<span class="nc" id="L149">        srcHeight = h;</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (destWidth &lt; 0) {</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">            if (destHeight &lt; 0) {</span>
<span class="nc" id="L152">                destWidth = srcWidth;</span>
<span class="nc" id="L153">                destHeight = srcHeight;</span>
            } else {
<span class="nc" id="L155">                destWidth = srcWidth * destHeight / srcHeight;</span>
            }
<span class="nc bnc" id="L157" title="All 2 branches missed.">        } else if (destHeight &lt; 0) {</span>
<span class="nc" id="L158">            destHeight = srcHeight * destWidth / srcWidth;</span>
        }
<span class="nc" id="L160">        consumer.setDimensions(destWidth, destHeight);</span>
<span class="nc" id="L161">    }</span>

    private void calculateMaps() {
<span class="nc" id="L164">        srcrows = new int[destHeight + 1];</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">        for (int y = 0; y &lt;= destHeight; y++) {</span>
<span class="nc" id="L166">            srcrows[y] = (2 * y * srcHeight + srcHeight) / (2 * destHeight);</span>
        }
<span class="nc" id="L168">        srccols = new int[destWidth + 1];</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        for (int x = 0; x &lt;= destWidth; x++) {</span>
<span class="nc" id="L170">            srccols[x] = (2 * x * srcWidth + srcWidth) / (2 * destWidth);</span>
        }
<span class="nc" id="L172">    }</span>

    /**
     * Choose which rows and columns of the delivered byte pixels are
     * needed for the destination scaled image and pass through just
     * those rows and columns that are needed, replicated as necessary.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels
     * are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     */
    public void setPixels(int x, int y, int w, int h,
                          ColorModel model, byte pixels[], int off,
                          int scansize) {
<span class="nc bnc" id="L189" title="All 4 branches missed.">        if (srcrows == null || srccols == null) {</span>
<span class="nc" id="L190">            calculateMaps();</span>
        }
        int sx, sy;
<span class="nc" id="L193">        int dx1 = (2 * x * destWidth + srcWidth - 1) / (2 * srcWidth);</span>
<span class="nc" id="L194">        int dy1 = (2 * y * destHeight + srcHeight - 1) / (2 * srcHeight);</span>
        byte outpix[];
<span class="nc bnc" id="L196" title="All 4 branches missed.">        if (outpixbuf != null &amp;&amp; outpixbuf instanceof byte[]) {</span>
<span class="nc" id="L197">            outpix = (byte[]) outpixbuf;</span>
        } else {
<span class="nc" id="L199">            outpix = new byte[destWidth];</span>
<span class="nc" id="L200">            outpixbuf = outpix;</span>
        }
<span class="nc bnc" id="L202" title="All 2 branches missed.">        for (int dy = dy1; (sy = srcrows[dy]) &lt; y + h; dy++) {</span>
<span class="nc" id="L203">            int srcoff = off + scansize * (sy - y);</span>
            int dx;
<span class="nc bnc" id="L205" title="All 2 branches missed.">            for (dx = dx1; (sx = srccols[dx]) &lt; x + w; dx++) {</span>
<span class="nc" id="L206">                outpix[dx] = pixels[srcoff + sx - x];</span>
            }
<span class="nc bnc" id="L208" title="All 2 branches missed.">            if (dx &gt; dx1) {</span>
<span class="nc" id="L209">                consumer.setPixels(dx1, dy, dx - dx1, 1,</span>
                                   model, outpix, dx1, destWidth);
            }
        }
<span class="nc" id="L213">    }</span>

    /**
     * Choose which rows and columns of the delivered int pixels are
     * needed for the destination scaled image and pass through just
     * those rows and columns that are needed, replicated as necessary.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels
     * are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     */
    public void setPixels(int x, int y, int w, int h,
                          ColorModel model, int pixels[], int off,
                          int scansize) {
<span class="nc bnc" id="L230" title="All 4 branches missed.">        if (srcrows == null || srccols == null) {</span>
<span class="nc" id="L231">            calculateMaps();</span>
        }
        int sx, sy;
<span class="nc" id="L234">        int dx1 = (2 * x * destWidth + srcWidth - 1) / (2 * srcWidth);</span>
<span class="nc" id="L235">        int dy1 = (2 * y * destHeight + srcHeight - 1) / (2 * srcHeight);</span>
        int outpix[];
<span class="nc bnc" id="L237" title="All 4 branches missed.">        if (outpixbuf != null &amp;&amp; outpixbuf instanceof int[]) {</span>
<span class="nc" id="L238">            outpix = (int[]) outpixbuf;</span>
        } else {
<span class="nc" id="L240">            outpix = new int[destWidth];</span>
<span class="nc" id="L241">            outpixbuf = outpix;</span>
        }
<span class="nc bnc" id="L243" title="All 2 branches missed.">        for (int dy = dy1; (sy = srcrows[dy]) &lt; y + h; dy++) {</span>
<span class="nc" id="L244">            int srcoff = off + scansize * (sy - y);</span>
            int dx;
<span class="nc bnc" id="L246" title="All 2 branches missed.">            for (dx = dx1; (sx = srccols[dx]) &lt; x + w; dx++) {</span>
<span class="nc" id="L247">                outpix[dx] = pixels[srcoff + sx - x];</span>
            }
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (dx &gt; dx1) {</span>
<span class="nc" id="L250">                consumer.setPixels(dx1, dy, dx - dx1, 1,</span>
                                   model, outpix, dx1, destWidth);
            }
        }
<span class="nc" id="L254">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>