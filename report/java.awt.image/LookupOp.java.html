<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>LookupOp.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">LookupOp.java</span></div><h1>LookupOp.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2000, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */


package java.awt.image;

import java.awt.color.ColorSpace;
import java.awt.geom.Rectangle2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.Point2D;
import sun.awt.image.ImagingLib;

/**
 * This class implements a lookup operation from the source
 * to the destination.  The LookupTable object may contain a single array
 * or multiple arrays, subject to the restrictions below.
 * &lt;p&gt;
 * For Rasters, the lookup operates on bands.  The number of
 * lookup arrays may be one, in which case the same array is
 * applied to all bands, or it must equal the number of Source
 * Raster bands.
 * &lt;p&gt;
 * For BufferedImages, the lookup operates on color and alpha components.
 * The number of lookup arrays may be one, in which case the
 * same array is applied to all color (but not alpha) components.
 * Otherwise, the number of lookup arrays may
 * equal the number of Source color components, in which case no
 * lookup of the alpha component (if present) is performed.
 * If neither of these cases apply, the number of lookup arrays
 * must equal the number of Source color components plus alpha components,
 * in which case lookup is performed for all color and alpha components.
 * This allows non-uniform rescaling of multi-band BufferedImages.
 * &lt;p&gt;
 * BufferedImage sources with premultiplied alpha data are treated in the same
 * manner as non-premultiplied images for purposes of the lookup.  That is,
 * the lookup is done per band on the raw data of the BufferedImage source
 * without regard to whether the data is premultiplied.  If a color conversion
 * is required to the destination ColorModel, the premultiplied state of
 * both source and destination will be taken into account for this step.
 * &lt;p&gt;
 * Images with an IndexColorModel cannot be used.
 * &lt;p&gt;
 * If a RenderingHints object is specified in the constructor, the
 * color rendering hint and the dithering hint may be used when color
 * conversion is required.
 * &lt;p&gt;
 * This class allows the Source to be the same as the Destination.
 *
 * @see LookupTable
 * @see java.awt.RenderingHints#KEY_COLOR_RENDERING
 * @see java.awt.RenderingHints#KEY_DITHERING
 */

public class LookupOp implements BufferedImageOp, RasterOp {
    private LookupTable ltable;
    private int numComponents;
    RenderingHints hints;

    /**
     * Constructs a &lt;code&gt;LookupOp&lt;/code&gt; object given the lookup
     * table and a &lt;code&gt;RenderingHints&lt;/code&gt; object, which might
     * be &lt;code&gt;null&lt;/code&gt;.
     * @param lookup the specified &lt;code&gt;LookupTable&lt;/code&gt;
     * @param hints the specified &lt;code&gt;RenderingHints&lt;/code&gt;,
     *        or &lt;code&gt;null&lt;/code&gt;
     */
<span class="nc" id="L90">    public LookupOp(LookupTable lookup, RenderingHints hints) {</span>
<span class="nc" id="L91">        this.ltable = lookup;</span>
<span class="nc" id="L92">        this.hints  = hints;</span>
<span class="nc" id="L93">        numComponents = ltable.getNumComponents();</span>
<span class="nc" id="L94">    }</span>

    /**
     * Returns the &lt;code&gt;LookupTable&lt;/code&gt;.
     * @return the &lt;code&gt;LookupTable&lt;/code&gt; of this
     *         &lt;code&gt;LookupOp&lt;/code&gt;.
     */
    public final LookupTable getTable() {
<span class="nc" id="L102">        return ltable;</span>
    }

    /**
     * Performs a lookup operation on a &lt;code&gt;BufferedImage&lt;/code&gt;.
     * If the color model in the source image is not the same as that
     * in the destination image, the pixels will be converted
     * in the destination.  If the destination image is &lt;code&gt;null&lt;/code&gt;,
     * a &lt;code&gt;BufferedImage&lt;/code&gt; will be created with an appropriate
     * &lt;code&gt;ColorModel&lt;/code&gt;.  An &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * might be thrown if the number of arrays in the
     * &lt;code&gt;LookupTable&lt;/code&gt; does not meet the restrictions
     * stated in the class comment above, or if the source image
     * has an &lt;code&gt;IndexColorModel&lt;/code&gt;.
     * @param src the &lt;code&gt;BufferedImage&lt;/code&gt; to be filtered
     * @param dst the &lt;code&gt;BufferedImage&lt;/code&gt; in which to
     *            store the results of the filter operation
     * @return the filtered &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @throws IllegalArgumentException if the number of arrays in the
     *         &lt;code&gt;LookupTable&lt;/code&gt; does not meet the restrictions
     *         described in the class comments, or if the source image
     *         has an &lt;code&gt;IndexColorModel&lt;/code&gt;.
     */
    public final BufferedImage filter(BufferedImage src, BufferedImage dst) {
<span class="nc" id="L126">        ColorModel srcCM = src.getColorModel();</span>
<span class="nc" id="L127">        int numBands = srcCM.getNumColorComponents();</span>
        ColorModel dstCM;
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (srcCM instanceof IndexColorModel) {</span>
<span class="nc" id="L130">            throw new</span>
                IllegalArgumentException(&quot;LookupOp cannot be &quot;+
                                         &quot;performed on an indexed image&quot;);
        }
<span class="nc" id="L134">        int numComponents = ltable.getNumComponents();</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (numComponents != 1 &amp;&amp;</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            numComponents != srcCM.getNumComponents() &amp;&amp;</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">            numComponents != srcCM.getNumColorComponents())</span>
        {
<span class="nc" id="L139">            throw new IllegalArgumentException(&quot;Number of arrays in the &quot;+</span>
                                               &quot; lookup table (&quot;+
                                               numComponents+
                                               &quot; is not compatible with the &quot;+
                                               &quot; src image: &quot;+src);
        }


<span class="nc" id="L147">        boolean needToConvert = false;</span>

<span class="nc" id="L149">        int width = src.getWidth();</span>
<span class="nc" id="L150">        int height = src.getHeight();</span>

<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L153">            dst = createCompatibleDestImage(src, null);</span>
<span class="nc" id="L154">            dstCM = srcCM;</span>
        }
        else {
<span class="nc bnc" id="L157" title="All 2 branches missed.">            if (width != dst.getWidth()) {</span>
<span class="nc" id="L158">                throw new</span>
                    IllegalArgumentException(&quot;Src width (&quot;+width+
                                             &quot;) not equal to dst width (&quot;+
<span class="nc" id="L161">                                             dst.getWidth()+&quot;)&quot;);</span>
            }
<span class="nc bnc" id="L163" title="All 2 branches missed.">            if (height != dst.getHeight()) {</span>
<span class="nc" id="L164">                throw new</span>
                    IllegalArgumentException(&quot;Src height (&quot;+height+
                                             &quot;) not equal to dst height (&quot;+
<span class="nc" id="L167">                                             dst.getHeight()+&quot;)&quot;);</span>
            }

<span class="nc" id="L170">            dstCM = dst.getColorModel();</span>
<span class="nc" id="L171">            if (srcCM.getColorSpace().getType() !=</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">                dstCM.getColorSpace().getType())</span>
            {
<span class="nc" id="L174">                needToConvert = true;</span>
<span class="nc" id="L175">                dst = createCompatibleDestImage(src, null);</span>
            }

        }

<span class="nc" id="L180">        BufferedImage origDst = dst;</span>

<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (ImagingLib.filter(this, src, dst) == null) {</span>
            // Do it the slow way
<span class="nc" id="L184">            WritableRaster srcRaster = src.getRaster();</span>
<span class="nc" id="L185">            WritableRaster dstRaster = dst.getRaster();</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">            if (srcCM.hasAlpha()) {</span>
<span class="nc bnc" id="L188" title="All 4 branches missed.">                if (numBands-1 == numComponents || numComponents == 1) {</span>
<span class="nc" id="L189">                    int minx = srcRaster.getMinX();</span>
<span class="nc" id="L190">                    int miny = srcRaster.getMinY();</span>
<span class="nc" id="L191">                    int[] bands = new int[numBands-1];</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                    for (int i=0; i &lt; numBands-1; i++) {</span>
<span class="nc" id="L193">                        bands[i] = i;</span>
                    }
<span class="nc" id="L195">                    srcRaster =</span>
<span class="nc" id="L196">                        srcRaster.createWritableChild(minx, miny,</span>
<span class="nc" id="L197">                                                      srcRaster.getWidth(),</span>
<span class="nc" id="L198">                                                      srcRaster.getHeight(),</span>
                                                      minx, miny,
                                                      bands);
                }
            }
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (dstCM.hasAlpha()) {</span>
<span class="nc" id="L204">                int dstNumBands = dstRaster.getNumBands();</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">                if (dstNumBands-1 == numComponents || numComponents == 1) {</span>
<span class="nc" id="L206">                    int minx = dstRaster.getMinX();</span>
<span class="nc" id="L207">                    int miny = dstRaster.getMinY();</span>
<span class="nc" id="L208">                    int[] bands = new int[numBands-1];</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">                    for (int i=0; i &lt; numBands-1; i++) {</span>
<span class="nc" id="L210">                        bands[i] = i;</span>
                    }
<span class="nc" id="L212">                    dstRaster =</span>
<span class="nc" id="L213">                        dstRaster.createWritableChild(minx, miny,</span>
<span class="nc" id="L214">                                                      dstRaster.getWidth(),</span>
<span class="nc" id="L215">                                                      dstRaster.getHeight(),</span>
                                                      minx, miny,
                                                      bands);
                }
            }

<span class="nc" id="L221">            filter(srcRaster, dstRaster);</span>
        }

<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (needToConvert) {</span>
            // ColorModels are not the same
<span class="nc" id="L226">            ColorConvertOp ccop = new ColorConvertOp(hints);</span>
<span class="nc" id="L227">            ccop.filter(dst, origDst);</span>
        }

<span class="nc" id="L230">        return origDst;</span>
    }

    /**
     * Performs a lookup operation on a &lt;code&gt;Raster&lt;/code&gt;.
     * If the destination &lt;code&gt;Raster&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * a new &lt;code&gt;Raster&lt;/code&gt; will be created.
     * The &lt;code&gt;IllegalArgumentException&lt;/code&gt; might be thrown
     * if the source &lt;code&gt;Raster&lt;/code&gt; and the destination
     * &lt;code&gt;Raster&lt;/code&gt; do not have the same
     * number of bands or if the number of arrays in the
     * &lt;code&gt;LookupTable&lt;/code&gt; does not meet the
     * restrictions stated in the class comment above.
     * @param src the source &lt;code&gt;Raster&lt;/code&gt; to filter
     * @param dst the destination &lt;code&gt;WritableRaster&lt;/code&gt; for the
     *            filtered &lt;code&gt;src&lt;/code&gt;
     * @return the filtered &lt;code&gt;WritableRaster&lt;/code&gt;.
     * @throws IllegalArgumentException if the source and destinations
     *         rasters do not have the same number of bands, or the
     *         number of arrays in the &lt;code&gt;LookupTable&lt;/code&gt; does
     *         not meet the restrictions described in the class comments.
     *
     */
    public final WritableRaster filter (Raster src, WritableRaster dst) {
<span class="nc" id="L254">        int numBands  = src.getNumBands();</span>
<span class="nc" id="L255">        int dstLength = dst.getNumBands();</span>
<span class="nc" id="L256">        int height    = src.getHeight();</span>
<span class="nc" id="L257">        int width     = src.getWidth();</span>
<span class="nc" id="L258">        int srcPix[]  = new int[numBands];</span>

        // Create a new destination Raster, if needed

<span class="nc bnc" id="L262" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L263">            dst = createCompatibleDestRaster(src);</span>
        }
<span class="nc bnc" id="L265" title="All 4 branches missed.">        else if (height != dst.getHeight() || width != dst.getWidth()) {</span>
<span class="nc" id="L266">            throw new</span>
                IllegalArgumentException (&quot;Width or height of Rasters do not &quot;+
                                          &quot;match&quot;);
        }
<span class="nc" id="L270">        dstLength = dst.getNumBands();</span>

<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (numBands != dstLength) {</span>
<span class="nc" id="L273">            throw new</span>
                IllegalArgumentException (&quot;Number of channels in the src (&quot;
                                          + numBands +
                                          &quot;) does not match number of channels&quot;
                                          + &quot; in the destination (&quot;
                                          + dstLength + &quot;)&quot;);
        }
<span class="nc" id="L280">        int numComponents = ltable.getNumComponents();</span>
<span class="nc bnc" id="L281" title="All 4 branches missed.">        if (numComponents != 1 &amp;&amp; numComponents != src.getNumBands()) {</span>
<span class="nc" id="L282">            throw new IllegalArgumentException(&quot;Number of arrays in the &quot;+</span>
                                               &quot; lookup table (&quot;+
                                               numComponents+
                                               &quot; is not compatible with the &quot;+
                                               &quot; src Raster: &quot;+src);
        }


<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (ImagingLib.filter(this, src, dst) != null) {</span>
<span class="nc" id="L291">            return dst;</span>
        }

        // Optimize for cases we know about
<span class="nc bnc" id="L295" title="All 2 branches missed.">        if (ltable instanceof ByteLookupTable) {</span>
<span class="nc" id="L296">            byteFilter ((ByteLookupTable) ltable, src, dst,</span>
                        width, height, numBands);
        }
<span class="nc bnc" id="L299" title="All 2 branches missed.">        else if (ltable instanceof ShortLookupTable) {</span>
<span class="nc" id="L300">            shortFilter ((ShortLookupTable) ltable, src, dst, width,</span>
                         height, numBands);
        }
        else {
            // Not one we recognize so do it slowly
<span class="nc" id="L305">            int sminX = src.getMinX();</span>
<span class="nc" id="L306">            int sY = src.getMinY();</span>
<span class="nc" id="L307">            int dminX = dst.getMinX();</span>
<span class="nc" id="L308">            int dY = dst.getMinY();</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            for (int y=0; y &lt; height; y++, sY++, dY++) {</span>
<span class="nc" id="L310">                int sX = sminX;</span>
<span class="nc" id="L311">                int dX = dminX;</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">                for (int x=0; x &lt; width; x++, sX++, dX++) {</span>
                    // Find data for all bands at this x,y position
<span class="nc" id="L314">                    src.getPixel(sX, sY, srcPix);</span>

                    // Lookup the data for all bands at this x,y position
<span class="nc" id="L317">                    ltable.lookupPixel(srcPix, srcPix);</span>

                    // Put it back for all bands
<span class="nc" id="L320">                    dst.setPixel(dX, dY, srcPix);</span>
                }
            }
        }

<span class="nc" id="L325">        return dst;</span>
    }

    /**
     * Returns the bounding box of the filtered destination image.  Since
     * this is not a geometric operation, the bounding box does not
     * change.
     * @param src the &lt;code&gt;BufferedImage&lt;/code&gt; to be filtered
     * @return the bounds of the filtered definition image.
     */
    public final Rectangle2D getBounds2D (BufferedImage src) {
<span class="nc" id="L336">        return getBounds2D(src.getRaster());</span>
    }

    /**
     * Returns the bounding box of the filtered destination Raster.  Since
     * this is not a geometric operation, the bounding box does not
     * change.
     * @param src the &lt;code&gt;Raster&lt;/code&gt; to be filtered
     * @return the bounds of the filtered definition &lt;code&gt;Raster&lt;/code&gt;.
     */
    public final Rectangle2D getBounds2D (Raster src) {
<span class="nc" id="L347">        return src.getBounds();</span>

    }

    /**
     * Creates a zeroed destination image with the correct size and number of
     * bands.  If destCM is &lt;code&gt;null&lt;/code&gt;, an appropriate
     * &lt;code&gt;ColorModel&lt;/code&gt; will be used.
     * @param src       Source image for the filter operation.
     * @param destCM    the destination's &lt;code&gt;ColorModel&lt;/code&gt;, which
     *                  can be &lt;code&gt;null&lt;/code&gt;.
     * @return a filtered destination &lt;code&gt;BufferedImage&lt;/code&gt;.
     */
    public BufferedImage createCompatibleDestImage (BufferedImage src,
                                                    ColorModel destCM) {
        BufferedImage image;
<span class="nc" id="L363">        int w = src.getWidth();</span>
<span class="nc" id="L364">        int h = src.getHeight();</span>
<span class="nc" id="L365">        int transferType = DataBuffer.TYPE_BYTE;</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">        if (destCM == null) {</span>
<span class="nc" id="L367">            ColorModel cm = src.getColorModel();</span>
<span class="nc" id="L368">            Raster raster = src.getRaster();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">            if (cm instanceof ComponentColorModel) {</span>
<span class="nc" id="L370">                DataBuffer db = raster.getDataBuffer();</span>
<span class="nc" id="L371">                boolean hasAlpha = cm.hasAlpha();</span>
<span class="nc" id="L372">                boolean isPre    = cm.isAlphaPremultiplied();</span>
<span class="nc" id="L373">                int trans        = cm.getTransparency();</span>
<span class="nc" id="L374">                int[] nbits = null;</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                if (ltable instanceof ByteLookupTable) {</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                    if (db.getDataType() == db.TYPE_USHORT) {</span>
                        // Dst raster should be of type byte
<span class="nc bnc" id="L378" title="All 2 branches missed.">                        if (hasAlpha) {</span>
<span class="nc" id="L379">                            nbits = new int[2];</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">                            if (trans == cm.BITMASK) {</span>
<span class="nc" id="L381">                                nbits[1] = 1;</span>
                            }
                            else {
<span class="nc" id="L384">                                nbits[1] = 8;</span>
                            }
                        }
                        else {
<span class="nc" id="L388">                            nbits = new int[1];</span>
                        }
<span class="nc" id="L390">                        nbits[0] = 8;</span>
                    }
                    // For byte, no need to change the cm
                }
<span class="nc bnc" id="L394" title="All 2 branches missed.">                else if (ltable instanceof ShortLookupTable) {</span>
<span class="nc" id="L395">                    transferType = DataBuffer.TYPE_USHORT;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">                    if (db.getDataType() == db.TYPE_BYTE) {</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">                        if (hasAlpha) {</span>
<span class="nc" id="L398">                            nbits = new int[2];</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                            if (trans == cm.BITMASK) {</span>
<span class="nc" id="L400">                                nbits[1] = 1;</span>
                            }
                            else {
<span class="nc" id="L403">                                nbits[1] = 16;</span>
                            }
                        }
                        else {
<span class="nc" id="L407">                            nbits = new int[1];</span>
                        }
<span class="nc" id="L409">                        nbits[0] = 16;</span>
                    }
                }
<span class="nc bnc" id="L412" title="All 2 branches missed.">                if (nbits != null) {</span>
<span class="nc" id="L413">                    cm = new ComponentColorModel(cm.getColorSpace(),</span>
                                                 nbits, hasAlpha, isPre,
                                                 trans, transferType);
                }
            }
<span class="nc" id="L418">            image = new BufferedImage(cm,</span>
<span class="nc" id="L419">                                      cm.createCompatibleWritableRaster(w, h),</span>
<span class="nc" id="L420">                                      cm.isAlphaPremultiplied(),</span>
                                      null);
<span class="nc" id="L422">        }</span>
        else {
<span class="nc" id="L424">            image = new BufferedImage(destCM,</span>
<span class="nc" id="L425">                                      destCM.createCompatibleWritableRaster(w,</span>
                                                                            h),
<span class="nc" id="L427">                                      destCM.isAlphaPremultiplied(),</span>
                                      null);
        }

<span class="nc" id="L431">        return image;</span>
    }

    /**
     * Creates a zeroed-destination &lt;code&gt;Raster&lt;/code&gt; with the
     * correct size and number of bands, given this source.
     * @param src the &lt;code&gt;Raster&lt;/code&gt; to be transformed
     * @return the zeroed-destination &lt;code&gt;Raster&lt;/code&gt;.
     */
    public WritableRaster createCompatibleDestRaster (Raster src) {
<span class="nc" id="L441">        return src.createCompatibleWritableRaster();</span>
    }

    /**
     * Returns the location of the destination point given a
     * point in the source.  If &lt;code&gt;dstPt&lt;/code&gt; is not
     * &lt;code&gt;null&lt;/code&gt;, it will be used to hold the return value.
     * Since this is not a geometric operation, the &lt;code&gt;srcPt&lt;/code&gt;
     * will equal the &lt;code&gt;dstPt&lt;/code&gt;.
     * @param srcPt a &lt;code&gt;Point2D&lt;/code&gt; that represents a point
     *        in the source image
     * @param dstPt a &lt;code&gt;Point2D&lt;/code&gt;that represents the location
     *        in the destination
     * @return the &lt;code&gt;Point2D&lt;/code&gt; in the destination that
     *         corresponds to the specified point in the source.
     */
    public final Point2D getPoint2D (Point2D srcPt, Point2D dstPt) {
<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (dstPt == null) {</span>
<span class="nc" id="L459">            dstPt = new Point2D.Float();</span>
        }
<span class="nc" id="L461">        dstPt.setLocation(srcPt.getX(), srcPt.getY());</span>

<span class="nc" id="L463">        return dstPt;</span>
    }

    /**
     * Returns the rendering hints for this op.
     * @return the &lt;code&gt;RenderingHints&lt;/code&gt; object associated
     *         with this op.
     */
    public final RenderingHints getRenderingHints() {
<span class="nc" id="L472">        return hints;</span>
    }

    private final void byteFilter(ByteLookupTable lookup, Raster src,
                                  WritableRaster dst,
                                  int width, int height, int numBands) {
<span class="nc" id="L478">        int[] srcPix = null;</span>

        // Find the ref to the table and the offset
<span class="nc" id="L481">        byte[][] table = lookup.getTable();</span>
<span class="nc" id="L482">        int offset = lookup.getOffset();</span>
        int tidx;
<span class="nc" id="L484">        int step=1;</span>

        // Check if it is one lookup applied to all bands
<span class="nc bnc" id="L487" title="All 2 branches missed.">        if (table.length == 1) {</span>
<span class="nc" id="L488">            step=0;</span>
        }

        int x;
        int y;
        int band;
<span class="nc" id="L494">        int len = table[0].length;</span>

        // Loop through the data
<span class="nc bnc" id="L497" title="All 2 branches missed.">        for ( y=0; y &lt; height; y++) {</span>
<span class="nc" id="L498">            tidx = 0;</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">            for ( band=0; band &lt; numBands; band++, tidx+=step) {</span>
                // Find data for this band, scanline
<span class="nc" id="L501">                srcPix = src.getSamples(0, y, width, 1, band, srcPix);</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">                for ( x=0; x &lt; width; x++) {</span>
<span class="nc" id="L504">                    int index = srcPix[x]-offset;</span>
<span class="nc bnc" id="L505" title="All 4 branches missed.">                    if (index &lt; 0 || index &gt; len) {</span>
<span class="nc" id="L506">                        throw new</span>
                            IllegalArgumentException(&quot;index (&quot;+index+
                                                     &quot;(out of range: &quot;+
                                                     &quot; srcPix[&quot;+x+
                                                     &quot;]=&quot;+ srcPix[x]+
                                                     &quot; offset=&quot;+ offset);
                    }
                    // Do the lookup
<span class="nc" id="L514">                    srcPix[x] = table[tidx][index];</span>
                }
                // Put it back
<span class="nc" id="L517">                dst.setSamples(0, y, width, 1, band, srcPix);</span>
            }
        }
<span class="nc" id="L520">    }</span>

    private final void shortFilter(ShortLookupTable lookup, Raster src,
                                   WritableRaster dst,
                                   int width, int height, int numBands) {
        int band;
<span class="nc" id="L526">        int[] srcPix = null;</span>

        // Find the ref to the table and the offset
<span class="nc" id="L529">        short[][] table = lookup.getTable();</span>
<span class="nc" id="L530">        int offset = lookup.getOffset();</span>
        int tidx;
<span class="nc" id="L532">        int step=1;</span>

        // Check if it is one lookup applied to all bands
<span class="nc bnc" id="L535" title="All 2 branches missed.">        if (table.length == 1) {</span>
<span class="nc" id="L536">            step=0;</span>
        }

<span class="nc" id="L539">        int x = 0;</span>
<span class="nc" id="L540">        int y = 0;</span>
        int index;
<span class="nc" id="L542">        int maxShort = (1&lt;&lt;16)-1;</span>
        // Loop through the data
<span class="nc bnc" id="L544" title="All 2 branches missed.">        for (y=0; y &lt; height; y++) {</span>
<span class="nc" id="L545">            tidx = 0;</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            for ( band=0; band &lt; numBands; band++, tidx+=step) {</span>
                // Find data for this band, scanline
<span class="nc" id="L548">                srcPix = src.getSamples(0, y, width, 1, band, srcPix);</span>

<span class="nc bnc" id="L550" title="All 2 branches missed.">                for ( x=0; x &lt; width; x++) {</span>
<span class="nc" id="L551">                    index = srcPix[x]-offset;</span>
<span class="nc bnc" id="L552" title="All 4 branches missed.">                    if (index &lt; 0 || index &gt; maxShort) {</span>
<span class="nc" id="L553">                        throw new</span>
                            IllegalArgumentException(&quot;index out of range &quot;+
                                                     index+&quot; x is &quot;+x+
                                                     &quot;srcPix[x]=&quot;+srcPix[x]
                                                     +&quot; offset=&quot;+ offset);
                    }
                    // Do the lookup
<span class="nc" id="L560">                    srcPix[x] = table[tidx][index];</span>
                }
                // Put it back
<span class="nc" id="L563">                dst.setSamples(0, y, width, 1, band, srcPix);</span>
            }
        }
<span class="nc" id="L566">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>