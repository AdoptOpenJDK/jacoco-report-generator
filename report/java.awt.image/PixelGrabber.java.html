<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PixelGrabber.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">PixelGrabber.java</span></div><h1>PixelGrabber.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.util.Hashtable;
import java.awt.image.ImageProducer;
import java.awt.image.ImageConsumer;
import java.awt.image.ColorModel;
import java.awt.Image;

/**
 * The PixelGrabber class implements an ImageConsumer which can be attached
 * to an Image or ImageProducer object to retrieve a subset of the pixels
 * in that image.  Here is an example:
 * &lt;pre&gt;{@code
 *
 * public void handlesinglepixel(int x, int y, int pixel) {
 *      int alpha = (pixel &gt;&gt; 24) &amp; 0xff;
 *      int red   = (pixel &gt;&gt; 16) &amp; 0xff;
 *      int green = (pixel &gt;&gt;  8) &amp; 0xff;
 *      int blue  = (pixel      ) &amp; 0xff;
 *      // Deal with the pixel as necessary...
 * }
 *
 * public void handlepixels(Image img, int x, int y, int w, int h) {
 *      int[] pixels = new int[w * h];
 *      PixelGrabber pg = new PixelGrabber(img, x, y, w, h, pixels, 0, w);
 *      try {
 *          pg.grabPixels();
 *      } catch (InterruptedException e) {
 *          System.err.println(&quot;interrupted waiting for pixels!&quot;);
 *          return;
 *      }
 *      if ((pg.getStatus() &amp; ImageObserver.ABORT) != 0) {
 *          System.err.println(&quot;image fetch aborted or errored&quot;);
 *          return;
 *      }
 *      for (int j = 0; j &lt; h; j++) {
 *          for (int i = 0; i &lt; w; i++) {
 *              handlesinglepixel(x+i, y+j, pixels[j * w + i]);
 *          }
 *      }
 * }
 *
 * }&lt;/pre&gt;
 *
 * @see ColorModel#getRGBdefault
 *
 * @author      Jim Graham
 */
public class PixelGrabber implements ImageConsumer {
    ImageProducer producer;

    int dstX;
    int dstY;
    int dstW;
    int dstH;

    ColorModel imageModel;
    byte[] bytePixels;
    int[] intPixels;
    int dstOff;
    int dstScan;

    private boolean grabbing;
    private int flags;

    private static final int GRABBEDBITS = (ImageObserver.FRAMEBITS
                                            | ImageObserver.ALLBITS);
    private static final int DONEBITS = (GRABBEDBITS
                                         | ImageObserver.ERROR);

    /**
     * Create a PixelGrabber object to grab the (x, y, w, h) rectangular
     * section of pixels from the specified image into the given array.
     * The pixels are stored into the array in the default RGB ColorModel.
     * The RGB data for pixel (i, j) where (i, j) is inside the rectangle
     * (x, y, w, h) is stored in the array at
     * &lt;tt&gt;pix[(j - y) * scansize + (i - x) + off]&lt;/tt&gt;.
     * @see ColorModel#getRGBdefault
     * @param img the image to retrieve pixels from
     * @param x the x coordinate of the upper left corner of the rectangle
     * of pixels to retrieve from the image, relative to the default
     * (unscaled) size of the image
     * @param y the y coordinate of the upper left corner of the rectangle
     * of pixels to retrieve from the image
     * @param w the width of the rectangle of pixels to retrieve
     * @param h the height of the rectangle of pixels to retrieve
     * @param pix the array of integers which are to be used to hold the
     * RGB pixels retrieved from the image
     * @param off the offset into the array of where to store the first pixel
     * @param scansize the distance from one row of pixels to the next in
     * the array
     */
    public PixelGrabber(Image img, int x, int y, int w, int h,
                        int[] pix, int off, int scansize) {
<span class="nc" id="L120">        this(img.getSource(), x, y, w, h, pix, off, scansize);</span>
<span class="nc" id="L121">    }</span>

    /**
     * Create a PixelGrabber object to grab the (x, y, w, h) rectangular
     * section of pixels from the image produced by the specified
     * ImageProducer into the given array.
     * The pixels are stored into the array in the default RGB ColorModel.
     * The RGB data for pixel (i, j) where (i, j) is inside the rectangle
     * (x, y, w, h) is stored in the array at
     * &lt;tt&gt;pix[(j - y) * scansize + (i - x) + off]&lt;/tt&gt;.
     * @param ip the &lt;code&gt;ImageProducer&lt;/code&gt; that produces the
     * image from which to retrieve pixels
     * @param x the x coordinate of the upper left corner of the rectangle
     * of pixels to retrieve from the image, relative to the default
     * (unscaled) size of the image
     * @param y the y coordinate of the upper left corner of the rectangle
     * of pixels to retrieve from the image
     * @param w the width of the rectangle of pixels to retrieve
     * @param h the height of the rectangle of pixels to retrieve
     * @param pix the array of integers which are to be used to hold the
     * RGB pixels retrieved from the image
     * @param off the offset into the array of where to store the first pixel
     * @param scansize the distance from one row of pixels to the next in
     * the array
     * @see ColorModel#getRGBdefault
     */
    public PixelGrabber(ImageProducer ip, int x, int y, int w, int h,
<span class="nc" id="L148">                        int[] pix, int off, int scansize) {</span>
<span class="nc" id="L149">        producer = ip;</span>
<span class="nc" id="L150">        dstX = x;</span>
<span class="nc" id="L151">        dstY = y;</span>
<span class="nc" id="L152">        dstW = w;</span>
<span class="nc" id="L153">        dstH = h;</span>
<span class="nc" id="L154">        dstOff = off;</span>
<span class="nc" id="L155">        dstScan = scansize;</span>
<span class="nc" id="L156">        intPixels = pix;</span>
<span class="nc" id="L157">        imageModel = ColorModel.getRGBdefault();</span>
<span class="nc" id="L158">    }</span>

    /**
     * Create a PixelGrabber object to grab the (x, y, w, h) rectangular
     * section of pixels from the specified image.  The pixels are
     * accumulated in the original ColorModel if the same ColorModel
     * is used for every call to setPixels, otherwise the pixels are
     * accumulated in the default RGB ColorModel.  If the forceRGB
     * parameter is true, then the pixels will be accumulated in the
     * default RGB ColorModel anyway.  A buffer is allocated by the
     * PixelGrabber to hold the pixels in either case.  If {@code (w &lt; 0)} or
     * {@code (h &lt; 0)}, then they will default to the remaining width and
     * height of the source data when that information is delivered.
     * @param img the image to retrieve the image data from
     * @param x the x coordinate of the upper left corner of the rectangle
     * of pixels to retrieve from the image, relative to the default
     * (unscaled) size of the image
     * @param y the y coordinate of the upper left corner of the rectangle
     * of pixels to retrieve from the image
     * @param w the width of the rectangle of pixels to retrieve
     * @param h the height of the rectangle of pixels to retrieve
     * @param forceRGB true if the pixels should always be converted to
     * the default RGB ColorModel
     */
    public PixelGrabber(Image img, int x, int y, int w, int h,
                        boolean forceRGB)
<span class="nc" id="L184">    {</span>
<span class="nc" id="L185">        producer = img.getSource();</span>
<span class="nc" id="L186">        dstX = x;</span>
<span class="nc" id="L187">        dstY = y;</span>
<span class="nc" id="L188">        dstW = w;</span>
<span class="nc" id="L189">        dstH = h;</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        if (forceRGB) {</span>
<span class="nc" id="L191">            imageModel = ColorModel.getRGBdefault();</span>
        }
<span class="nc" id="L193">    }</span>

    /**
     * Request the PixelGrabber to start fetching the pixels.
     */
    public synchronized void startGrabbing() {
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if ((flags &amp; DONEBITS) != 0) {</span>
<span class="nc" id="L200">            return;</span>
        }
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (!grabbing) {</span>
<span class="nc" id="L203">            grabbing = true;</span>
<span class="nc" id="L204">            flags &amp;= ~(ImageObserver.ABORT);</span>
<span class="nc" id="L205">            producer.startProduction(this);</span>
        }
<span class="nc" id="L207">    }</span>

    /**
     * Request the PixelGrabber to abort the image fetch.
     */
    public synchronized void abortGrabbing() {
<span class="nc" id="L213">        imageComplete(IMAGEABORTED);</span>
<span class="nc" id="L214">    }</span>

    /**
     * Request the Image or ImageProducer to start delivering pixels and
     * wait for all of the pixels in the rectangle of interest to be
     * delivered.
     * @return true if the pixels were successfully grabbed, false on
     * abort, error or timeout
     * @exception InterruptedException
     *            Another thread has interrupted this thread.
     */
    public boolean grabPixels() throws InterruptedException {
<span class="nc" id="L226">        return grabPixels(0);</span>
    }

    /**
     * Request the Image or ImageProducer to start delivering pixels and
     * wait for all of the pixels in the rectangle of interest to be
     * delivered or until the specified timeout has elapsed.  This method
     * behaves in the following ways, depending on the value of
     * &lt;code&gt;ms&lt;/code&gt;:
     * &lt;ul&gt;
     * &lt;li&gt; If {@code ms == 0}, waits until all pixels are delivered
     * &lt;li&gt; If {@code ms &gt; 0}, waits until all pixels are delivered
     * as timeout expires.
     * &lt;li&gt; If {@code ms &lt; 0}, returns &lt;code&gt;true&lt;/code&gt; if all pixels
     * are grabbed, &lt;code&gt;false&lt;/code&gt; otherwise and does not wait.
     * &lt;/ul&gt;
     * @param ms the number of milliseconds to wait for the image pixels
     * to arrive before timing out
     * @return true if the pixels were successfully grabbed, false on
     * abort, error or timeout
     * @exception InterruptedException
     *            Another thread has interrupted this thread.
     */
    public synchronized boolean grabPixels(long ms)
        throws InterruptedException
    {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if ((flags &amp; DONEBITS) != 0) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            return (flags &amp; GRABBEDBITS) != 0;</span>
        }
<span class="nc" id="L255">        long end = ms + System.currentTimeMillis();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">        if (!grabbing) {</span>
<span class="nc" id="L257">            grabbing = true;</span>
<span class="nc" id="L258">            flags &amp;= ~(ImageObserver.ABORT);</span>
<span class="nc" id="L259">            producer.startProduction(this);</span>
        }
<span class="nc bnc" id="L261" title="All 2 branches missed.">        while (grabbing) {</span>
            long timeout;
<span class="nc bnc" id="L263" title="All 2 branches missed.">            if (ms == 0) {</span>
<span class="nc" id="L264">                timeout = 0;</span>
            } else {
<span class="nc" id="L266">                timeout = end - System.currentTimeMillis();</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">                if (timeout &lt;= 0) {</span>
<span class="nc" id="L268">                    break;</span>
                }
            }
<span class="nc" id="L271">            wait(timeout);</span>
<span class="nc" id="L272">        }</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">        return (flags &amp; GRABBEDBITS) != 0;</span>
    }

    /**
     * Return the status of the pixels.  The ImageObserver flags
     * representing the available pixel information are returned.
     * @return the bitwise OR of all relevant ImageObserver flags
     * @see ImageObserver
     */
    public synchronized int getStatus() {
<span class="nc" id="L283">        return flags;</span>
    }

    /**
     * Get the width of the pixel buffer (after adjusting for image width).
     * If no width was specified for the rectangle of pixels to grab then
     * then this information will only be available after the image has
     * delivered the dimensions.
     * @return the final width used for the pixel buffer or -1 if the width
     * is not yet known
     * @see #getStatus
     */
    public synchronized int getWidth() {
<span class="nc bnc" id="L296" title="All 2 branches missed.">        return (dstW &lt; 0) ? -1 : dstW;</span>
    }

    /**
     * Get the height of the pixel buffer (after adjusting for image height).
     * If no width was specified for the rectangle of pixels to grab then
     * then this information will only be available after the image has
     * delivered the dimensions.
     * @return the final height used for the pixel buffer or -1 if the height
     * is not yet known
     * @see #getStatus
     */
    public synchronized int getHeight() {
<span class="nc bnc" id="L309" title="All 2 branches missed.">        return (dstH &lt; 0) ? -1 : dstH;</span>
    }

    /**
     * Get the pixel buffer.  If the PixelGrabber was not constructed
     * with an explicit pixel buffer to hold the pixels then this method
     * will return null until the size and format of the image data is
     * known.
     * Since the PixelGrabber may fall back on accumulating the data
     * in the default RGB ColorModel at any time if the source image
     * uses more than one ColorModel to deliver the data, the array
     * object returned by this method may change over time until the
     * image grab is complete.
     * @return either a byte array or an int array
     * @see #getStatus
     * @see #setPixels(int, int, int, int, ColorModel, byte[], int, int)
     * @see #setPixels(int, int, int, int, ColorModel, int[], int, int)
     */
    public synchronized Object getPixels() {
<span class="nc bnc" id="L328" title="All 2 branches missed.">        return (bytePixels == null)</span>
            ? ((Object) intPixels)
            : ((Object) bytePixels);
    }

    /**
     * Get the ColorModel for the pixels stored in the array.  If the
     * PixelGrabber was constructed with an explicit pixel buffer then
     * this method will always return the default RGB ColorModel,
     * otherwise it may return null until the ColorModel used by the
     * ImageProducer is known.
     * Since the PixelGrabber may fall back on accumulating the data
     * in the default RGB ColorModel at any time if the source image
     * uses more than one ColorModel to deliver the data, the ColorModel
     * object returned by this method may change over time until the
     * image grab is complete and may not reflect any of the ColorModel
     * objects that was used by the ImageProducer to deliver the pixels.
     * @return the ColorModel object used for storing the pixels
     * @see #getStatus
     * @see ColorModel#getRGBdefault
     * @see #setColorModel(ColorModel)
     */
    public synchronized ColorModel getColorModel() {
<span class="nc" id="L351">        return imageModel;</span>
    }

    /**
     * The setDimensions method is part of the ImageConsumer API which
     * this class must implement to retrieve the pixels.
     * &lt;p&gt;
     * Note: This method is intended to be called by the ImageProducer
     * of the Image whose pixels are being grabbed.  Developers using
     * this class to retrieve pixels from an image should avoid calling
     * this method directly since that operation could result in problems
     * with retrieving the requested pixels.
     * @param width the width of the dimension
     * @param height the height of the dimension
     */
    public void setDimensions(int width, int height) {
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (dstW &lt; 0) {</span>
<span class="nc" id="L368">            dstW = width - dstX;</span>
        }
<span class="nc bnc" id="L370" title="All 2 branches missed.">        if (dstH &lt; 0) {</span>
<span class="nc" id="L371">            dstH = height - dstY;</span>
        }
<span class="nc bnc" id="L373" title="All 4 branches missed.">        if (dstW &lt;= 0 || dstH &lt;= 0) {</span>
<span class="nc" id="L374">            imageComplete(STATICIMAGEDONE);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">        } else if (intPixels == null &amp;&amp;</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">                   imageModel == ColorModel.getRGBdefault()) {</span>
<span class="nc" id="L377">            intPixels = new int[dstW * dstH];</span>
<span class="nc" id="L378">            dstScan = dstW;</span>
<span class="nc" id="L379">            dstOff = 0;</span>
        }
<span class="nc" id="L381">        flags |= (ImageObserver.WIDTH | ImageObserver.HEIGHT);</span>
<span class="nc" id="L382">    }</span>

    /**
     * The setHints method is part of the ImageConsumer API which
     * this class must implement to retrieve the pixels.
     * &lt;p&gt;
     * Note: This method is intended to be called by the ImageProducer
     * of the Image whose pixels are being grabbed.  Developers using
     * this class to retrieve pixels from an image should avoid calling
     * this method directly since that operation could result in problems
     * with retrieving the requested pixels.
     * @param hints a set of hints used to process the pixels
     */
    public void setHints(int hints) {
<span class="nc" id="L396">        return;</span>
    }

    /**
     * The setProperties method is part of the ImageConsumer API which
     * this class must implement to retrieve the pixels.
     * &lt;p&gt;
     * Note: This method is intended to be called by the ImageProducer
     * of the Image whose pixels are being grabbed.  Developers using
     * this class to retrieve pixels from an image should avoid calling
     * this method directly since that operation could result in problems
     * with retrieving the requested pixels.
     * @param props the list of properties
     */
    public void setProperties(Hashtable&lt;?,?&gt; props) {
<span class="nc" id="L411">        return;</span>
    }

    /**
     * The setColorModel method is part of the ImageConsumer API which
     * this class must implement to retrieve the pixels.
     * &lt;p&gt;
     * Note: This method is intended to be called by the ImageProducer
     * of the Image whose pixels are being grabbed.  Developers using
     * this class to retrieve pixels from an image should avoid calling
     * this method directly since that operation could result in problems
     * with retrieving the requested pixels.
     * @param model the specified &lt;code&gt;ColorModel&lt;/code&gt;
     * @see #getColorModel
     */
    public void setColorModel(ColorModel model) {
<span class="nc" id="L427">        return;</span>
    }

    private void convertToRGB() {
<span class="nc" id="L431">        int size = dstW * dstH;</span>
<span class="nc" id="L432">        int newpixels[] = new int[size];</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">        if (bytePixels != null) {</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L435">                newpixels[i] = imageModel.getRGB(bytePixels[i] &amp; 0xff);</span>
            }
<span class="nc bnc" id="L437" title="All 2 branches missed.">        } else if (intPixels != null) {</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L439">                newpixels[i] = imageModel.getRGB(intPixels[i]);</span>
            }
        }
<span class="nc" id="L442">        bytePixels = null;</span>
<span class="nc" id="L443">        intPixels = newpixels;</span>
<span class="nc" id="L444">        dstScan = dstW;</span>
<span class="nc" id="L445">        dstOff = 0;</span>
<span class="nc" id="L446">        imageModel = ColorModel.getRGBdefault();</span>
<span class="nc" id="L447">    }</span>

    /**
     * The setPixels method is part of the ImageConsumer API which
     * this class must implement to retrieve the pixels.
     * &lt;p&gt;
     * Note: This method is intended to be called by the ImageProducer
     * of the Image whose pixels are being grabbed.  Developers using
     * this class to retrieve pixels from an image should avoid calling
     * this method directly since that operation could result in problems
     * with retrieving the requested pixels.
     * @param srcX the X coordinate of the upper-left corner
     *        of the area of pixels to be set
     * @param srcY the Y coordinate of the upper-left corner
     *        of the area of pixels to be set
     * @param srcW the width of the area of pixels
     * @param srcH the height of the area of pixels
     * @param model the specified &lt;code&gt;ColorModel&lt;/code&gt;
     * @param pixels the array of pixels
     * @param srcOff the offset into the pixels array
     * @param srcScan the distance from one row of pixels to the next
     *        in the pixels array
     * @see #getPixels
     */
    public void setPixels(int srcX, int srcY, int srcW, int srcH,
                          ColorModel model,
                          byte pixels[], int srcOff, int srcScan) {
<span class="nc bnc" id="L474" title="All 2 branches missed.">        if (srcY &lt; dstY) {</span>
<span class="nc" id="L475">            int diff = dstY - srcY;</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">            if (diff &gt;= srcH) {</span>
<span class="nc" id="L477">                return;</span>
            }
<span class="nc" id="L479">            srcOff += srcScan * diff;</span>
<span class="nc" id="L480">            srcY += diff;</span>
<span class="nc" id="L481">            srcH -= diff;</span>
        }
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (srcY + srcH &gt; dstY + dstH) {</span>
<span class="nc" id="L484">            srcH = (dstY + dstH) - srcY;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">            if (srcH &lt;= 0) {</span>
<span class="nc" id="L486">                return;</span>
            }
        }
<span class="nc bnc" id="L489" title="All 2 branches missed.">        if (srcX &lt; dstX) {</span>
<span class="nc" id="L490">            int diff = dstX - srcX;</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">            if (diff &gt;= srcW) {</span>
<span class="nc" id="L492">                return;</span>
            }
<span class="nc" id="L494">            srcOff += diff;</span>
<span class="nc" id="L495">            srcX += diff;</span>
<span class="nc" id="L496">            srcW -= diff;</span>
        }
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (srcX + srcW &gt; dstX + dstW) {</span>
<span class="nc" id="L499">            srcW = (dstX + dstW) - srcX;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (srcW &lt;= 0) {</span>
<span class="nc" id="L501">                return;</span>
            }
        }
<span class="nc" id="L504">        int dstPtr = dstOff + (srcY - dstY) * dstScan + (srcX - dstX);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        if (intPixels == null) {</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">            if (bytePixels == null) {</span>
<span class="nc" id="L507">                bytePixels = new byte[dstW * dstH];</span>
<span class="nc" id="L508">                dstScan = dstW;</span>
<span class="nc" id="L509">                dstOff = 0;</span>
<span class="nc" id="L510">                imageModel = model;</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">            } else if (imageModel != model) {</span>
<span class="nc" id="L512">                convertToRGB();</span>
            }
<span class="nc bnc" id="L514" title="All 2 branches missed.">            if (bytePixels != null) {</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">                for (int h = srcH; h &gt; 0; h--) {</span>
<span class="nc" id="L516">                    System.arraycopy(pixels, srcOff, bytePixels, dstPtr, srcW);</span>
<span class="nc" id="L517">                    srcOff += srcScan;</span>
<span class="nc" id="L518">                    dstPtr += dstScan;</span>
                }
            }
        }
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (intPixels != null) {</span>
<span class="nc" id="L523">            int dstRem = dstScan - srcW;</span>
<span class="nc" id="L524">            int srcRem = srcScan - srcW;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            for (int h = srcH; h &gt; 0; h--) {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">                for (int w = srcW; w &gt; 0; w--) {</span>
<span class="nc" id="L527">                    intPixels[dstPtr++] = model.getRGB(pixels[srcOff++]&amp;0xff);</span>
                }
<span class="nc" id="L529">                srcOff += srcRem;</span>
<span class="nc" id="L530">                dstPtr += dstRem;</span>
            }
        }
<span class="nc" id="L533">        flags |= ImageObserver.SOMEBITS;</span>
<span class="nc" id="L534">    }</span>

    /**
     * The setPixels method is part of the ImageConsumer API which
     * this class must implement to retrieve the pixels.
     * &lt;p&gt;
     * Note: This method is intended to be called by the ImageProducer
     * of the Image whose pixels are being grabbed.  Developers using
     * this class to retrieve pixels from an image should avoid calling
     * this method directly since that operation could result in problems
     * with retrieving the requested pixels.
     * @param srcX the X coordinate of the upper-left corner
     *        of the area of pixels to be set
     * @param srcY the Y coordinate of the upper-left corner
     *        of the area of pixels to be set
     * @param srcW the width of the area of pixels
     * @param srcH the height of the area of pixels
     * @param model the specified &lt;code&gt;ColorModel&lt;/code&gt;
     * @param pixels the array of pixels
     * @param srcOff the offset into the pixels array
     * @param srcScan the distance from one row of pixels to the next
     *        in the pixels array
     * @see #getPixels
     */
    public void setPixels(int srcX, int srcY, int srcW, int srcH,
                          ColorModel model,
                          int pixels[], int srcOff, int srcScan) {
<span class="nc bnc" id="L561" title="All 2 branches missed.">        if (srcY &lt; dstY) {</span>
<span class="nc" id="L562">            int diff = dstY - srcY;</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (diff &gt;= srcH) {</span>
<span class="nc" id="L564">                return;</span>
            }
<span class="nc" id="L566">            srcOff += srcScan * diff;</span>
<span class="nc" id="L567">            srcY += diff;</span>
<span class="nc" id="L568">            srcH -= diff;</span>
        }
<span class="nc bnc" id="L570" title="All 2 branches missed.">        if (srcY + srcH &gt; dstY + dstH) {</span>
<span class="nc" id="L571">            srcH = (dstY + dstH) - srcY;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">            if (srcH &lt;= 0) {</span>
<span class="nc" id="L573">                return;</span>
            }
        }
<span class="nc bnc" id="L576" title="All 2 branches missed.">        if (srcX &lt; dstX) {</span>
<span class="nc" id="L577">            int diff = dstX - srcX;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">            if (diff &gt;= srcW) {</span>
<span class="nc" id="L579">                return;</span>
            }
<span class="nc" id="L581">            srcOff += diff;</span>
<span class="nc" id="L582">            srcX += diff;</span>
<span class="nc" id="L583">            srcW -= diff;</span>
        }
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (srcX + srcW &gt; dstX + dstW) {</span>
<span class="nc" id="L586">            srcW = (dstX + dstW) - srcX;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">            if (srcW &lt;= 0) {</span>
<span class="nc" id="L588">                return;</span>
            }
        }
<span class="nc bnc" id="L591" title="All 2 branches missed.">        if (intPixels == null) {</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">            if (bytePixels == null) {</span>
<span class="nc" id="L593">                intPixels = new int[dstW * dstH];</span>
<span class="nc" id="L594">                dstScan = dstW;</span>
<span class="nc" id="L595">                dstOff = 0;</span>
<span class="nc" id="L596">                imageModel = model;</span>
            } else {
<span class="nc" id="L598">                convertToRGB();</span>
            }
        }
<span class="nc" id="L601">        int dstPtr = dstOff + (srcY - dstY) * dstScan + (srcX - dstX);</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">        if (imageModel == model) {</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">            for (int h = srcH; h &gt; 0; h--) {</span>
<span class="nc" id="L604">                System.arraycopy(pixels, srcOff, intPixels, dstPtr, srcW);</span>
<span class="nc" id="L605">                srcOff += srcScan;</span>
<span class="nc" id="L606">                dstPtr += dstScan;</span>
            }
        } else {
<span class="nc bnc" id="L609" title="All 2 branches missed.">            if (imageModel != ColorModel.getRGBdefault()) {</span>
<span class="nc" id="L610">                convertToRGB();</span>
            }
<span class="nc" id="L612">            int dstRem = dstScan - srcW;</span>
<span class="nc" id="L613">            int srcRem = srcScan - srcW;</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">            for (int h = srcH; h &gt; 0; h--) {</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">                for (int w = srcW; w &gt; 0; w--) {</span>
<span class="nc" id="L616">                    intPixels[dstPtr++] = model.getRGB(pixels[srcOff++]);</span>
                }
<span class="nc" id="L618">                srcOff += srcRem;</span>
<span class="nc" id="L619">                dstPtr += dstRem;</span>
            }
        }
<span class="nc" id="L622">        flags |= ImageObserver.SOMEBITS;</span>
<span class="nc" id="L623">    }</span>

    /**
     * The imageComplete method is part of the ImageConsumer API which
     * this class must implement to retrieve the pixels.
     * &lt;p&gt;
     * Note: This method is intended to be called by the ImageProducer
     * of the Image whose pixels are being grabbed.  Developers using
     * this class to retrieve pixels from an image should avoid calling
     * this method directly since that operation could result in problems
     * with retrieving the requested pixels.
     * @param status the status of image loading
     */
    public synchronized void imageComplete(int status) {
<span class="nc" id="L637">        grabbing = false;</span>
<span class="nc bnc" id="L638" title="All 4 branches missed.">        switch (status) {</span>
        default:
        case IMAGEERROR:
<span class="nc" id="L641">            flags |= ImageObserver.ERROR | ImageObserver.ABORT;</span>
<span class="nc" id="L642">            break;</span>
        case IMAGEABORTED:
<span class="nc" id="L644">            flags |= ImageObserver.ABORT;</span>
<span class="nc" id="L645">            break;</span>
        case STATICIMAGEDONE:
<span class="nc" id="L647">            flags |= ImageObserver.ALLBITS;</span>
<span class="nc" id="L648">            break;</span>
        case SINGLEFRAMEDONE:
<span class="nc" id="L650">            flags |= ImageObserver.FRAMEBITS;</span>
            break;
        }
<span class="nc" id="L653">        producer.removeConsumer(this);</span>
<span class="nc" id="L654">        notifyAll();</span>
<span class="nc" id="L655">    }</span>

    /**
     * Returns the status of the pixels.  The ImageObserver flags
     * representing the available pixel information are returned.
     * This method and {@link #getStatus() getStatus} have the
     * same implementation, but &lt;code&gt;getStatus&lt;/code&gt; is the
     * preferred method because it conforms to the convention of
     * naming information-retrieval methods with the form
     * &quot;getXXX&quot;.
     * @return the bitwise OR of all relevant ImageObserver flags
     * @see ImageObserver
     * @see #getStatus()
     */
    public synchronized int status() {
<span class="nc" id="L670">        return flags;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>