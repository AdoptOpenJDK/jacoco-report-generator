<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BandCombineOp.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">BandCombineOp.java</span></div><h1>BandCombineOp.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.GraphicsEnvironment;
import java.awt.color.ICC_Profile;
import java.awt.geom.Rectangle2D;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.RenderingHints;
import sun.awt.image.ImagingLib;
import java.util.Arrays;

/**
 * This class performs an arbitrary linear combination of the bands
 * in a &lt;CODE&gt;Raster&lt;/CODE&gt;, using a specified matrix.
 * &lt;p&gt;
 * The width of the matrix must be equal to the number of bands in the
 * source &lt;CODE&gt;Raster&lt;/CODE&gt;, optionally plus one.  If there is one more
 * column in the matrix than the number of bands, there is an implied 1 at the
 * end of the vector of band samples representing a pixel.  The height
 * of the matrix must be equal to the number of bands in the destination.
 * &lt;p&gt;
 * For example, a 3-banded &lt;CODE&gt;Raster&lt;/CODE&gt; might have the following
 * transformation applied to each pixel in order to invert the second band of
 * the &lt;CODE&gt;Raster&lt;/CODE&gt;.
 * &lt;pre&gt;
 *   [ 1.0   0.0   0.0    0.0  ]     [ b1 ]
 *   [ 0.0  -1.0   0.0  255.0  ]  x  [ b2 ]
 *   [ 0.0   0.0   1.0    0.0  ]     [ b3 ]
 *                                   [ 1 ]
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * Note that the source and destination can be the same object.
 */
public class BandCombineOp implements  RasterOp {
    float[][] matrix;
<span class="nc" id="L62">    int nrows = 0;</span>
<span class="nc" id="L63">    int ncols = 0;</span>
    RenderingHints hints;

    /**
     * Constructs a &lt;CODE&gt;BandCombineOp&lt;/CODE&gt; with the specified matrix.
     * The width of the matrix must be equal to the number of bands in
     * the source &lt;CODE&gt;Raster&lt;/CODE&gt;, optionally plus one.  If there is one
     * more column in the matrix than the number of bands, there is an implied
     * 1 at the end of the vector of band samples representing a pixel.  The
     * height of the matrix must be equal to the number of bands in the
     * destination.
     * &lt;p&gt;
     * The first subscript is the row index and the second
     * is the column index.  This operation uses none of the currently
     * defined rendering hints; the &lt;CODE&gt;RenderingHints&lt;/CODE&gt; argument can be
     * null.
     *
     * @param matrix The matrix to use for the band combine operation.
     * @param hints The &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object for this operation.
     * Not currently used so it can be null.
     */
<span class="nc" id="L84">    public BandCombineOp (float[][] matrix, RenderingHints hints) {</span>
<span class="nc" id="L85">        nrows = matrix.length;</span>
<span class="nc" id="L86">        ncols = matrix[0].length;</span>
<span class="nc" id="L87">        this.matrix = new float[nrows][];</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">        for (int i=0; i &lt; nrows; i++) {</span>
            /* Arrays.copyOf is forgiving of the source array being
             * too short, but it is also faster than other cloning
             * methods, so we provide our own protection for short
             * matrix rows.
             */
<span class="nc bnc" id="L94" title="All 2 branches missed.">            if (ncols &gt; matrix[i].length) {</span>
<span class="nc" id="L95">                throw new IndexOutOfBoundsException(&quot;row &quot;+i+&quot; too short&quot;);</span>
            }
<span class="nc" id="L97">            this.matrix[i] = Arrays.copyOf(matrix[i], ncols);</span>
        }
<span class="nc" id="L99">        this.hints  = hints;</span>
<span class="nc" id="L100">    }</span>

    /**
     * Returns a copy of the linear combination matrix.
     *
     * @return The matrix associated with this band combine operation.
     */
    public final float[][] getMatrix() {
<span class="nc" id="L108">        float[][] ret = new float[nrows][];</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">        for (int i = 0; i &lt; nrows; i++) {</span>
<span class="nc" id="L110">            ret[i] = Arrays.copyOf(matrix[i], ncols);</span>
        }
<span class="nc" id="L112">        return ret;</span>
    }

    /**
     * Transforms the &lt;CODE&gt;Raster&lt;/CODE&gt; using the matrix specified in the
     * constructor. An &lt;CODE&gt;IllegalArgumentException&lt;/CODE&gt; may be thrown if
     * the number of bands in the source or destination is incompatible with
     * the matrix.  See the class comments for more details.
     * &lt;p&gt;
     * If the destination is null, it will be created with a number of bands
     * equalling the number of rows in the matrix. No exception is thrown
     * if the operation causes a data overflow.
     *
     * @param src The &lt;CODE&gt;Raster&lt;/CODE&gt; to be filtered.
     * @param dst The &lt;CODE&gt;Raster&lt;/CODE&gt; in which to store the results
     * of the filter operation.
     *
     * @return The filtered &lt;CODE&gt;Raster&lt;/CODE&gt;.
     *
     * @throws IllegalArgumentException If the number of bands in the
     * source or destination is incompatible with the matrix.
     */
    public WritableRaster filter(Raster src, WritableRaster dst) {
<span class="nc" id="L135">        int nBands = src.getNumBands();</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">        if (ncols != nBands &amp;&amp; ncols != (nBands+1)) {</span>
<span class="nc" id="L137">            throw new IllegalArgumentException(&quot;Number of columns in the &quot;+</span>
                                               &quot;matrix (&quot;+ncols+
                                               &quot;) must be equal to the number&quot;+
                                               &quot; of bands ([+1]) in src (&quot;+
                                               nBands+&quot;).&quot;);
        }
<span class="nc bnc" id="L143" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L144">            dst = createCompatibleDestRaster(src);</span>
        }
<span class="nc bnc" id="L146" title="All 2 branches missed.">        else if (nrows != dst.getNumBands()) {</span>
<span class="nc" id="L147">            throw new IllegalArgumentException(&quot;Number of rows in the &quot;+</span>
                                               &quot;matrix (&quot;+nrows+
                                               &quot;) must be equal to the number&quot;+
                                               &quot; of bands ([+1]) in dst (&quot;+
                                               nBands+&quot;).&quot;);
        }

<span class="nc bnc" id="L154" title="All 2 branches missed.">        if (ImagingLib.filter(this, src, dst) != null) {</span>
<span class="nc" id="L155">            return dst;</span>
        }

<span class="nc" id="L158">        int[] pixel = null;</span>
<span class="nc" id="L159">        int[] dstPixel = new int[dst.getNumBands()];</span>
        float accum;
<span class="nc" id="L161">        int sminX = src.getMinX();</span>
<span class="nc" id="L162">        int sY = src.getMinY();</span>
<span class="nc" id="L163">        int dminX = dst.getMinX();</span>
<span class="nc" id="L164">        int dY = dst.getMinY();</span>
        int sX;
        int dX;
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (ncols == nBands) {</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">            for (int y=0; y &lt; src.getHeight(); y++, sY++, dY++) {</span>
<span class="nc" id="L169">                dX = dminX;</span>
<span class="nc" id="L170">                sX = sminX;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">                for (int x=0; x &lt; src.getWidth(); x++, sX++, dX++) {</span>
<span class="nc" id="L172">                    pixel = src.getPixel(sX, sY, pixel);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">                    for (int r=0; r &lt; nrows; r++) {</span>
<span class="nc" id="L174">                        accum = 0.f;</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">                        for (int c=0; c &lt; ncols; c++) {</span>
<span class="nc" id="L176">                            accum += matrix[r][c]*pixel[c];</span>
                        }
<span class="nc" id="L178">                        dstPixel[r] = (int) accum;</span>
                    }
<span class="nc" id="L180">                    dst.setPixel(dX, dY, dstPixel);</span>
                }
            }
        }
        else {
            // Need to add constant
<span class="nc bnc" id="L186" title="All 2 branches missed.">            for (int y=0; y &lt; src.getHeight(); y++, sY++, dY++) {</span>
<span class="nc" id="L187">                dX = dminX;</span>
<span class="nc" id="L188">                sX = sminX;</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">                for (int x=0; x &lt; src.getWidth(); x++, sX++, dX++) {</span>
<span class="nc" id="L190">                    pixel = src.getPixel(sX, sY, pixel);</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                    for (int r=0; r &lt; nrows; r++) {</span>
<span class="nc" id="L192">                        accum = 0.f;</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                        for (int c=0; c &lt; nBands; c++) {</span>
<span class="nc" id="L194">                            accum += matrix[r][c]*pixel[c];</span>
                        }
<span class="nc" id="L196">                        dstPixel[r] = (int) (accum+matrix[r][nBands]);</span>
                    }
<span class="nc" id="L198">                    dst.setPixel(dX, dY, dstPixel);</span>
                }
            }
        }

<span class="nc" id="L203">        return dst;</span>
    }

    /**
     * Returns the bounding box of the transformed destination.  Since
     * this is not a geometric operation, the bounding box is the same for
     * the source and destination.
     * An &lt;CODE&gt;IllegalArgumentException&lt;/CODE&gt; may be thrown if the number of
     * bands in the source is incompatible with the matrix.  See
     * the class comments for more details.
     *
     * @param src The &lt;CODE&gt;Raster&lt;/CODE&gt; to be filtered.
     *
     * @return The &lt;CODE&gt;Rectangle2D&lt;/CODE&gt; representing the destination
     * image's bounding box.
     *
     * @throws IllegalArgumentException If the number of bands in the source
     * is incompatible with the matrix.
     */
    public final Rectangle2D getBounds2D (Raster src) {
<span class="nc" id="L223">        return src.getBounds();</span>
    }


    /**
     * Creates a zeroed destination &lt;CODE&gt;Raster&lt;/CODE&gt; with the correct size
     * and number of bands.
     * An &lt;CODE&gt;IllegalArgumentException&lt;/CODE&gt; may be thrown if the number of
     * bands in the source is incompatible with the matrix.  See
     * the class comments for more details.
     *
     * @param src The &lt;CODE&gt;Raster&lt;/CODE&gt; to be filtered.
     *
     * @return The zeroed destination &lt;CODE&gt;Raster&lt;/CODE&gt;.
     */
    public WritableRaster createCompatibleDestRaster (Raster src) {
<span class="nc" id="L239">        int nBands = src.getNumBands();</span>
<span class="nc bnc" id="L240" title="All 4 branches missed.">        if ((ncols != nBands) &amp;&amp; (ncols != (nBands+1))) {</span>
<span class="nc" id="L241">            throw new IllegalArgumentException(&quot;Number of columns in the &quot;+</span>
                                               &quot;matrix (&quot;+ncols+
                                               &quot;) must be equal to the number&quot;+
                                               &quot; of bands ([+1]) in src (&quot;+
                                               nBands+&quot;).&quot;);
        }
<span class="nc bnc" id="L247" title="All 2 branches missed.">        if (src.getNumBands() == nrows) {</span>
<span class="nc" id="L248">            return src.createCompatibleWritableRaster();</span>
        }
        else {
<span class="nc" id="L251">            throw new IllegalArgumentException(&quot;Don't know how to create a &quot;+</span>
                                               &quot; compatible Raster with &quot;+
                                               nrows+&quot; bands.&quot;);
        }
    }

    /**
     * Returns the location of the corresponding destination point given a
     * point in the source &lt;CODE&gt;Raster&lt;/CODE&gt;.  If &lt;CODE&gt;dstPt&lt;/CODE&gt; is
     * specified, it is used to hold the return value.
     * Since this is not a geometric operation, the point returned
     * is the same as the specified &lt;CODE&gt;srcPt&lt;/CODE&gt;.
     *
     * @param srcPt The &lt;code&gt;Point2D&lt;/code&gt; that represents the point in
     *              the source &lt;code&gt;Raster&lt;/code&gt;
     * @param dstPt The &lt;CODE&gt;Point2D&lt;/CODE&gt; in which to store the result.
     *
     * @return The &lt;CODE&gt;Point2D&lt;/CODE&gt; in the destination image that
     * corresponds to the specified point in the source image.
     */
    public final Point2D getPoint2D (Point2D srcPt, Point2D dstPt) {
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (dstPt == null) {</span>
<span class="nc" id="L273">            dstPt = new Point2D.Float();</span>
        }
<span class="nc" id="L275">        dstPt.setLocation(srcPt.getX(), srcPt.getY());</span>

<span class="nc" id="L277">        return dstPt;</span>
    }

    /**
     * Returns the rendering hints for this operation.
     *
     * @return The &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object associated with this
     * operation.  Returns null if no hints have been set.
     */
    public final RenderingHints getRenderingHints() {
<span class="nc" id="L287">        return hints;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>