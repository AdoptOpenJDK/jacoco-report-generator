<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>AffineTransformOp.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">AffineTransformOp.java</span></div><h1>AffineTransformOp.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Point2D;
import java.awt.AlphaComposite;
import java.awt.GraphicsEnvironment;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Transparency;
import java.lang.annotation.Native;
import sun.awt.image.ImagingLib;

/**
 * This class uses an affine transform to perform a linear mapping from
 * 2D coordinates in the source image or &lt;CODE&gt;Raster&lt;/CODE&gt; to 2D coordinates
 * in the destination image or &lt;CODE&gt;Raster&lt;/CODE&gt;.
 * The type of interpolation that is used is specified through a constructor,
 * either by a &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object or by one of the integer
 * interpolation types defined in this class.
 * &lt;p&gt;
 * If a &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object is specified in the constructor, the
 * interpolation hint and the rendering quality hint are used to set
 * the interpolation type for this operation.  The color rendering hint
 * and the dithering hint can be used when color conversion is required.
 * &lt;p&gt;
 * Note that the following constraints have to be met:
 * &lt;ul&gt;
 * &lt;li&gt;The source and destination must be different.
 * &lt;li&gt;For &lt;CODE&gt;Raster&lt;/CODE&gt; objects, the number of bands in the source must
 * be equal to the number of bands in the destination.
 * &lt;/ul&gt;
 * @see AffineTransform
 * @see BufferedImageFilter
 * @see java.awt.RenderingHints#KEY_INTERPOLATION
 * @see java.awt.RenderingHints#KEY_RENDERING
 * @see java.awt.RenderingHints#KEY_COLOR_RENDERING
 * @see java.awt.RenderingHints#KEY_DITHERING
 */
public class AffineTransformOp implements BufferedImageOp, RasterOp {
    private AffineTransform xform;
    RenderingHints hints;

    /**
     * Nearest-neighbor interpolation type.
     */
    @Native public static final int TYPE_NEAREST_NEIGHBOR = 1;

    /**
     * Bilinear interpolation type.
     */
    @Native public static final int TYPE_BILINEAR = 2;

    /**
     * Bicubic interpolation type.
     */
    @Native public static final int TYPE_BICUBIC = 3;

<span class="nc" id="L85">    int interpolationType = TYPE_NEAREST_NEIGHBOR;</span>

    /**
     * Constructs an &lt;CODE&gt;AffineTransformOp&lt;/CODE&gt; given an affine transform.
     * The interpolation type is determined from the
     * &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object.  If the interpolation hint is
     * defined, it will be used. Otherwise, if the rendering quality hint is
     * defined, the interpolation type is determined from its value.  If no
     * hints are specified (&lt;CODE&gt;hints&lt;/CODE&gt; is null),
     * the interpolation type is {@link #TYPE_NEAREST_NEIGHBOR
     * TYPE_NEAREST_NEIGHBOR}.
     *
     * @param xform The &lt;CODE&gt;AffineTransform&lt;/CODE&gt; to use for the
     * operation.
     *
     * @param hints The &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object used to specify
     * the interpolation type for the operation.
     *
     * @throws ImagingOpException if the transform is non-invertible.
     * @see java.awt.RenderingHints#KEY_INTERPOLATION
     * @see java.awt.RenderingHints#KEY_RENDERING
     */
<span class="nc" id="L107">    public AffineTransformOp(AffineTransform xform, RenderingHints hints){</span>
<span class="nc" id="L108">        validateTransform(xform);</span>
<span class="nc" id="L109">        this.xform = (AffineTransform) xform.clone();</span>
<span class="nc" id="L110">        this.hints = hints;</span>

<span class="nc bnc" id="L112" title="All 2 branches missed.">        if (hints != null) {</span>
<span class="nc" id="L113">            Object value = hints.get(hints.KEY_INTERPOLATION);</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L115">                value = hints.get(hints.KEY_RENDERING);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">                if (value == hints.VALUE_RENDER_SPEED) {</span>
<span class="nc" id="L117">                    interpolationType = TYPE_NEAREST_NEIGHBOR;</span>
                }
<span class="nc bnc" id="L119" title="All 2 branches missed.">                else if (value == hints.VALUE_RENDER_QUALITY) {</span>
<span class="nc" id="L120">                    interpolationType = TYPE_BILINEAR;</span>
                }
            }
<span class="nc bnc" id="L123" title="All 2 branches missed.">            else if (value == hints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR) {</span>
<span class="nc" id="L124">                interpolationType = TYPE_NEAREST_NEIGHBOR;</span>
            }
<span class="nc bnc" id="L126" title="All 2 branches missed.">            else if (value == hints.VALUE_INTERPOLATION_BILINEAR) {</span>
<span class="nc" id="L127">                interpolationType = TYPE_BILINEAR;</span>
            }
<span class="nc bnc" id="L129" title="All 2 branches missed.">            else if (value == hints.VALUE_INTERPOLATION_BICUBIC) {</span>
<span class="nc" id="L130">                interpolationType = TYPE_BICUBIC;</span>
            }
<span class="nc" id="L132">        }</span>
        else {
<span class="nc" id="L134">            interpolationType = TYPE_NEAREST_NEIGHBOR;</span>
        }
<span class="nc" id="L136">    }</span>

    /**
     * Constructs an &lt;CODE&gt;AffineTransformOp&lt;/CODE&gt; given an affine transform
     * and the interpolation type.
     *
     * @param xform The &lt;CODE&gt;AffineTransform&lt;/CODE&gt; to use for the operation.
     * @param interpolationType One of the integer
     * interpolation type constants defined by this class:
     * {@link #TYPE_NEAREST_NEIGHBOR TYPE_NEAREST_NEIGHBOR},
     * {@link #TYPE_BILINEAR TYPE_BILINEAR},
     * {@link #TYPE_BICUBIC TYPE_BICUBIC}.
     * @throws ImagingOpException if the transform is non-invertible.
     */
<span class="nc" id="L150">    public AffineTransformOp(AffineTransform xform, int interpolationType) {</span>
<span class="nc" id="L151">        validateTransform(xform);</span>
<span class="nc" id="L152">        this.xform = (AffineTransform)xform.clone();</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        switch(interpolationType) {</span>
            case TYPE_NEAREST_NEIGHBOR:
            case TYPE_BILINEAR:
            case TYPE_BICUBIC:
<span class="nc" id="L157">                break;</span>
        default:
<span class="nc" id="L159">            throw new IllegalArgumentException(&quot;Unknown interpolation type: &quot;+</span>
                                               interpolationType);
        }
<span class="nc" id="L162">        this.interpolationType = interpolationType;</span>
<span class="nc" id="L163">    }</span>

    /**
     * Returns the interpolation type used by this op.
     * @return the interpolation type.
     * @see #TYPE_NEAREST_NEIGHBOR
     * @see #TYPE_BILINEAR
     * @see #TYPE_BICUBIC
     */
    public final int getInterpolationType() {
<span class="nc" id="L173">        return interpolationType;</span>
    }

    /**
     * Transforms the source &lt;CODE&gt;BufferedImage&lt;/CODE&gt; and stores the results
     * in the destination &lt;CODE&gt;BufferedImage&lt;/CODE&gt;.
     * If the color models for the two images do not match, a color
     * conversion into the destination color model is performed.
     * If the destination image is null,
     * a &lt;CODE&gt;BufferedImage&lt;/CODE&gt; is created with the source
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * &lt;p&gt;
     * The coordinates of the rectangle returned by
     * &lt;code&gt;getBounds2D(BufferedImage)&lt;/code&gt;
     * are not necessarily the same as the coordinates of the
     * &lt;code&gt;BufferedImage&lt;/code&gt; returned by this method.  If the
     * upper-left corner coordinates of the rectangle are
     * negative then this part of the rectangle is not drawn.  If the
     * upper-left corner coordinates of the  rectangle are positive
     * then the filtered image is drawn at that position in the
     * destination &lt;code&gt;BufferedImage&lt;/code&gt;.
     * &lt;p&gt;
     * An &lt;CODE&gt;IllegalArgumentException&lt;/CODE&gt; is thrown if the source is
     * the same as the destination.
     *
     * @param src The &lt;CODE&gt;BufferedImage&lt;/CODE&gt; to transform.
     * @param dst The &lt;CODE&gt;BufferedImage&lt;/CODE&gt; in which to store the results
     * of the transformation.
     *
     * @return The filtered &lt;CODE&gt;BufferedImage&lt;/CODE&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;src&lt;/code&gt; and
     *         &lt;code&gt;dst&lt;/code&gt; are the same
     * @throws ImagingOpException if the image cannot be transformed
     *         because of a data-processing error that might be
     *         caused by an invalid image format, tile format, or
     *         image-processing operation, or any other unsupported
     *         operation.
     */
    public final BufferedImage filter(BufferedImage src, BufferedImage dst) {

<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (src == null) {</span>
<span class="nc" id="L214">            throw new NullPointerException(&quot;src image is null&quot;);</span>
        }
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (src == dst) {</span>
<span class="nc" id="L217">            throw new IllegalArgumentException(&quot;src image cannot be the &quot;+</span>
                                               &quot;same as the dst image&quot;);
        }

<span class="nc" id="L221">        boolean needToConvert = false;</span>
<span class="nc" id="L222">        ColorModel srcCM = src.getColorModel();</span>
        ColorModel dstCM;
<span class="nc" id="L224">        BufferedImage origDst = dst;</span>

<span class="nc bnc" id="L226" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L227">            dst = createCompatibleDestImage(src, null);</span>
<span class="nc" id="L228">            dstCM = srcCM;</span>
<span class="nc" id="L229">            origDst = dst;</span>
        }
        else {
<span class="nc" id="L232">            dstCM = dst.getColorModel();</span>
<span class="nc" id="L233">            if (srcCM.getColorSpace().getType() !=</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                dstCM.getColorSpace().getType())</span>
            {
<span class="nc" id="L236">                int type = xform.getType();</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                boolean needTrans = ((type&amp;</span>
                                      (xform.TYPE_MASK_ROTATION|
                                       xform.TYPE_GENERAL_TRANSFORM))
                                     != 0);
<span class="nc bnc" id="L241" title="All 6 branches missed.">                if (! needTrans &amp;&amp; type != xform.TYPE_TRANSLATION &amp;&amp; type != xform.TYPE_IDENTITY)</span>
                {
<span class="nc" id="L243">                    double[] mtx = new double[4];</span>
<span class="nc" id="L244">                    xform.getMatrix(mtx);</span>
                    // Check out the matrix.  A non-integral scale will force ARGB
                    // since the edge conditions can't be guaranteed.
<span class="nc bnc" id="L247" title="All 4 branches missed.">                    needTrans = (mtx[0] != (int)mtx[0] || mtx[3] != (int)mtx[3]);</span>
                }

<span class="nc bnc" id="L250" title="All 2 branches missed.">                if (needTrans &amp;&amp;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">                    srcCM.getTransparency() == Transparency.OPAQUE)</span>
                {
                    // Need to convert first
<span class="nc" id="L254">                    ColorConvertOp ccop = new ColorConvertOp(hints);</span>
<span class="nc" id="L255">                    BufferedImage tmpSrc = null;</span>
<span class="nc" id="L256">                    int sw = src.getWidth();</span>
<span class="nc" id="L257">                    int sh = src.getHeight();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">                    if (dstCM.getTransparency() == Transparency.OPAQUE) {</span>
<span class="nc" id="L259">                        tmpSrc = new BufferedImage(sw, sh,</span>
                                                  BufferedImage.TYPE_INT_ARGB);
                    }
                    else {
<span class="nc" id="L263">                        WritableRaster r =</span>
<span class="nc" id="L264">                            dstCM.createCompatibleWritableRaster(sw, sh);</span>
<span class="nc" id="L265">                        tmpSrc = new BufferedImage(dstCM, r,</span>
<span class="nc" id="L266">                                                  dstCM.isAlphaPremultiplied(),</span>
                                                  null);
                    }
<span class="nc" id="L269">                    src = ccop.filter(src, tmpSrc);</span>
<span class="nc" id="L270">                }</span>
                else {
<span class="nc" id="L272">                    needToConvert = true;</span>
<span class="nc" id="L273">                    dst = createCompatibleDestImage(src, null);</span>
                }
            }

        }

<span class="nc bnc" id="L279" title="All 2 branches missed.">        if (interpolationType != TYPE_NEAREST_NEIGHBOR &amp;&amp;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">            dst.getColorModel() instanceof IndexColorModel) {</span>
<span class="nc" id="L281">            dst = new BufferedImage(dst.getWidth(), dst.getHeight(),</span>
                                    BufferedImage.TYPE_INT_ARGB);
        }
<span class="nc bnc" id="L284" title="All 2 branches missed.">        if (ImagingLib.filter(this, src, dst) == null) {</span>
<span class="nc" id="L285">            throw new ImagingOpException (&quot;Unable to transform src image&quot;);</span>
        }

<span class="nc bnc" id="L288" title="All 2 branches missed.">        if (needToConvert) {</span>
<span class="nc" id="L289">            ColorConvertOp ccop = new ColorConvertOp(hints);</span>
<span class="nc" id="L290">            ccop.filter(dst, origDst);</span>
<span class="nc" id="L291">        }</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        else if (origDst != dst) {</span>
<span class="nc" id="L293">            java.awt.Graphics2D g = origDst.createGraphics();</span>
            try {
<span class="nc" id="L295">                g.setComposite(AlphaComposite.Src);</span>
<span class="nc" id="L296">                g.drawImage(dst, 0, 0, null);</span>
            } finally {
<span class="nc" id="L298">                g.dispose();</span>
<span class="nc" id="L299">            }</span>
        }

<span class="nc" id="L302">        return origDst;</span>
    }

    /**
     * Transforms the source &lt;CODE&gt;Raster&lt;/CODE&gt; and stores the results in
     * the destination &lt;CODE&gt;Raster&lt;/CODE&gt;.  This operation performs the
     * transform band by band.
     * &lt;p&gt;
     * If the destination &lt;CODE&gt;Raster&lt;/CODE&gt; is null, a new
     * &lt;CODE&gt;Raster&lt;/CODE&gt; is created.
     * An &lt;CODE&gt;IllegalArgumentException&lt;/CODE&gt; may be thrown if the source is
     * the same as the destination or if the number of bands in
     * the source is not equal to the number of bands in the
     * destination.
     * &lt;p&gt;
     * The coordinates of the rectangle returned by
     * &lt;code&gt;getBounds2D(Raster)&lt;/code&gt;
     * are not necessarily the same as the coordinates of the
     * &lt;code&gt;WritableRaster&lt;/code&gt; returned by this method.  If the
     * upper-left corner coordinates of rectangle are negative then
     * this part of the rectangle is not drawn.  If the coordinates
     * of the rectangle are positive then the filtered image is drawn at
     * that position in the destination &lt;code&gt;Raster&lt;/code&gt;.
     * &lt;p&gt;
     * @param src The &lt;CODE&gt;Raster&lt;/CODE&gt; to transform.
     * @param dst The &lt;CODE&gt;Raster&lt;/CODE&gt; in which to store the results of the
     * transformation.
     *
     * @return The transformed &lt;CODE&gt;Raster&lt;/CODE&gt;.
     *
     * @throws ImagingOpException if the raster cannot be transformed
     *         because of a data-processing error that might be
     *         caused by an invalid image format, tile format, or
     *         image-processing operation, or any other unsupported
     *         operation.
     */
    public final WritableRaster filter(Raster src, WritableRaster dst) {
<span class="nc bnc" id="L339" title="All 2 branches missed.">        if (src == null) {</span>
<span class="nc" id="L340">            throw new NullPointerException(&quot;src image is null&quot;);</span>
        }
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L343">            dst = createCompatibleDestRaster(src);</span>
        }
<span class="nc bnc" id="L345" title="All 2 branches missed.">        if (src == dst) {</span>
<span class="nc" id="L346">            throw new IllegalArgumentException(&quot;src image cannot be the &quot;+</span>
                                               &quot;same as the dst image&quot;);
        }
<span class="nc bnc" id="L349" title="All 2 branches missed.">        if (src.getNumBands() != dst.getNumBands()) {</span>
<span class="nc" id="L350">            throw new IllegalArgumentException(&quot;Number of src bands (&quot;+</span>
<span class="nc" id="L351">                                               src.getNumBands()+</span>
                                               &quot;) does not match number of &quot;+
                                               &quot; dst bands (&quot;+
<span class="nc" id="L354">                                               dst.getNumBands()+&quot;)&quot;);</span>
        }

<span class="nc bnc" id="L357" title="All 2 branches missed.">        if (ImagingLib.filter(this, src, dst) == null) {</span>
<span class="nc" id="L358">            throw new ImagingOpException (&quot;Unable to transform src image&quot;);</span>
        }
<span class="nc" id="L360">        return dst;</span>
    }

    /**
     * Returns the bounding box of the transformed destination.  The
     * rectangle returned is the actual bounding box of the
     * transformed points.  The coordinates of the upper-left corner
     * of the returned rectangle might not be (0,&amp;nbsp;0).
     *
     * @param src The &lt;CODE&gt;BufferedImage&lt;/CODE&gt; to be transformed.
     *
     * @return The &lt;CODE&gt;Rectangle2D&lt;/CODE&gt; representing the destination's
     * bounding box.
     */
    public final Rectangle2D getBounds2D (BufferedImage src) {
<span class="nc" id="L375">        return getBounds2D(src.getRaster());</span>
    }

    /**
     * Returns the bounding box of the transformed destination.  The
     * rectangle returned will be the actual bounding box of the
     * transformed points.  The coordinates of the upper-left corner
     * of the returned rectangle might not be (0,&amp;nbsp;0).
     *
     * @param src The &lt;CODE&gt;Raster&lt;/CODE&gt; to be transformed.
     *
     * @return The &lt;CODE&gt;Rectangle2D&lt;/CODE&gt; representing the destination's
     * bounding box.
     */
    public final Rectangle2D getBounds2D (Raster src) {
<span class="nc" id="L390">        int w = src.getWidth();</span>
<span class="nc" id="L391">        int h = src.getHeight();</span>

        // Get the bounding box of the src and transform the corners
<span class="nc" id="L394">        float[] pts = {0, 0, w, 0, w, h, 0, h};</span>
<span class="nc" id="L395">        xform.transform(pts, 0, pts, 0, 4);</span>

        // Get the min, max of the dst
<span class="nc" id="L398">        float fmaxX = pts[0];</span>
<span class="nc" id="L399">        float fmaxY = pts[1];</span>
<span class="nc" id="L400">        float fminX = pts[0];</span>
<span class="nc" id="L401">        float fminY = pts[1];</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">        for (int i=2; i &lt; 8; i+=2) {</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (pts[i] &gt; fmaxX) {</span>
<span class="nc" id="L404">                fmaxX = pts[i];</span>
            }
<span class="nc bnc" id="L406" title="All 2 branches missed.">            else if (pts[i] &lt; fminX) {</span>
<span class="nc" id="L407">                fminX = pts[i];</span>
            }
<span class="nc bnc" id="L409" title="All 2 branches missed.">            if (pts[i+1] &gt; fmaxY) {</span>
<span class="nc" id="L410">                fmaxY = pts[i+1];</span>
            }
<span class="nc bnc" id="L412" title="All 2 branches missed.">            else if (pts[i+1] &lt; fminY) {</span>
<span class="nc" id="L413">                fminY = pts[i+1];</span>
            }
        }

<span class="nc" id="L417">        return new Rectangle2D.Float(fminX, fminY, fmaxX-fminX, fmaxY-fminY);</span>
    }

    /**
     * Creates a zeroed destination image with the correct size and number of
     * bands.  A &lt;CODE&gt;RasterFormatException&lt;/CODE&gt; may be thrown if the
     * transformed width or height is equal to 0.
     * &lt;p&gt;
     * If &lt;CODE&gt;destCM&lt;/CODE&gt; is null,
     * an appropriate &lt;CODE&gt;ColorModel&lt;/CODE&gt; is used; this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; may have
     * an alpha channel even if the source &lt;CODE&gt;ColorModel&lt;/CODE&gt; is opaque.
     *
     * @param src  The &lt;CODE&gt;BufferedImage&lt;/CODE&gt; to be transformed.
     * @param destCM  &lt;CODE&gt;ColorModel&lt;/CODE&gt; of the destination.  If null,
     * an appropriate &lt;CODE&gt;ColorModel&lt;/CODE&gt; is used.
     *
     * @return The zeroed destination image.
     */
    public BufferedImage createCompatibleDestImage (BufferedImage src,
                                                    ColorModel destCM) {
        BufferedImage image;
<span class="nc" id="L439">        Rectangle r = getBounds2D(src).getBounds();</span>

        // If r.x (or r.y) is &lt; 0, then we want to only create an image
        // that is in the positive range.
        // If r.x (or r.y) is &gt; 0, then we need to create an image that
        // includes the translation.
<span class="nc" id="L445">        int w = r.x + r.width;</span>
<span class="nc" id="L446">        int h = r.y + r.height;</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (w &lt;= 0) {</span>
<span class="nc" id="L448">            throw new RasterFormatException(&quot;Transformed width (&quot;+w+</span>
                                            &quot;) is less than or equal to 0.&quot;);
        }
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (h &lt;= 0) {</span>
<span class="nc" id="L452">            throw new RasterFormatException(&quot;Transformed height (&quot;+h+</span>
                                            &quot;) is less than or equal to 0.&quot;);
        }

<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (destCM == null) {</span>
<span class="nc" id="L457">            ColorModel cm = src.getColorModel();</span>
<span class="nc bnc" id="L458" title="All 4 branches missed.">            if (interpolationType != TYPE_NEAREST_NEIGHBOR &amp;&amp;</span>
                (cm instanceof IndexColorModel ||
<span class="nc bnc" id="L460" title="All 2 branches missed.">                 cm.getTransparency() == Transparency.OPAQUE))</span>
            {
<span class="nc" id="L462">                image = new BufferedImage(w, h,</span>
                                          BufferedImage.TYPE_INT_ARGB);
            }
            else {
<span class="nc" id="L466">                image = new BufferedImage(cm,</span>
<span class="nc" id="L467">                          src.getRaster().createCompatibleWritableRaster(w,h),</span>
<span class="nc" id="L468">                          cm.isAlphaPremultiplied(), null);</span>
            }
<span class="nc" id="L470">        }</span>
        else {
<span class="nc" id="L472">            image = new BufferedImage(destCM,</span>
<span class="nc" id="L473">                                    destCM.createCompatibleWritableRaster(w,h),</span>
<span class="nc" id="L474">                                    destCM.isAlphaPremultiplied(), null);</span>
        }

<span class="nc" id="L477">        return image;</span>
    }

    /**
     * Creates a zeroed destination &lt;CODE&gt;Raster&lt;/CODE&gt; with the correct size
     * and number of bands.  A &lt;CODE&gt;RasterFormatException&lt;/CODE&gt; may be thrown
     * if the transformed width or height is equal to 0.
     *
     * @param src The &lt;CODE&gt;Raster&lt;/CODE&gt; to be transformed.
     *
     * @return The zeroed destination &lt;CODE&gt;Raster&lt;/CODE&gt;.
     */
    public WritableRaster createCompatibleDestRaster (Raster src) {
<span class="nc" id="L490">        Rectangle2D r = getBounds2D(src);</span>

<span class="nc" id="L492">        return src.createCompatibleWritableRaster((int)r.getX(),</span>
<span class="nc" id="L493">                                                  (int)r.getY(),</span>
<span class="nc" id="L494">                                                  (int)r.getWidth(),</span>
<span class="nc" id="L495">                                                  (int)r.getHeight());</span>
    }

    /**
     * Returns the location of the corresponding destination point given a
     * point in the source.  If &lt;CODE&gt;dstPt&lt;/CODE&gt; is specified, it
     * is used to hold the return value.
     *
     * @param srcPt The &lt;code&gt;Point2D&lt;/code&gt; that represents the source
     *              point.
     * @param dstPt The &lt;CODE&gt;Point2D&lt;/CODE&gt; in which to store the result.
     *
     * @return The &lt;CODE&gt;Point2D&lt;/CODE&gt; in the destination that corresponds to
     * the specified point in the source.
     */
    public final Point2D getPoint2D (Point2D srcPt, Point2D dstPt) {
<span class="nc" id="L511">        return xform.transform (srcPt, dstPt);</span>
    }

    /**
     * Returns the affine transform used by this transform operation.
     *
     * @return The &lt;CODE&gt;AffineTransform&lt;/CODE&gt; associated with this op.
     */
    public final AffineTransform getTransform() {
<span class="nc" id="L520">        return (AffineTransform) xform.clone();</span>
    }

    /**
     * Returns the rendering hints used by this transform operation.
     *
     * @return The &lt;CODE&gt;RenderingHints&lt;/CODE&gt; object associated with this op.
     */
    public final RenderingHints getRenderingHints() {
<span class="nc bnc" id="L529" title="All 2 branches missed.">        if (hints == null) {</span>
            Object val;
<span class="nc bnc" id="L531" title="All 4 branches missed.">            switch(interpolationType) {</span>
            case TYPE_NEAREST_NEIGHBOR:
<span class="nc" id="L533">                val = RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR;</span>
<span class="nc" id="L534">                break;</span>
            case TYPE_BILINEAR:
<span class="nc" id="L536">                val = RenderingHints.VALUE_INTERPOLATION_BILINEAR;</span>
<span class="nc" id="L537">                break;</span>
            case TYPE_BICUBIC:
<span class="nc" id="L539">                val = RenderingHints.VALUE_INTERPOLATION_BICUBIC;</span>
<span class="nc" id="L540">                break;</span>
            default:
                // Should never get here
<span class="nc" id="L543">                throw new InternalError(&quot;Unknown interpolation type &quot;+</span>
                                         interpolationType);

            }
<span class="nc" id="L547">            hints = new RenderingHints(RenderingHints.KEY_INTERPOLATION, val);</span>
        }

<span class="nc" id="L550">        return hints;</span>
    }

    // We need to be able to invert the transform if we want to
    // transform the image.  If the determinant of the matrix is 0,
    // then we can't invert the transform.
    void validateTransform(AffineTransform xform) {
<span class="nc bnc" id="L557" title="All 2 branches missed.">        if (Math.abs(xform.getDeterminant()) &lt;= Double.MIN_VALUE) {</span>
<span class="nc" id="L558">            throw new ImagingOpException(&quot;Unable to invert transform &quot;+xform);</span>
        }
<span class="nc" id="L560">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>