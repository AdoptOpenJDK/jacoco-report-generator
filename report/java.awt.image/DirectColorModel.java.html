<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>DirectColorModel.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">DirectColorModel.java</span></div><h1>DirectColorModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2001, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.color.ColorSpace;
import java.awt.Transparency;

/**
 * The &lt;code&gt;DirectColorModel&lt;/code&gt; class is a &lt;code&gt;ColorModel&lt;/code&gt;
 * class that works with pixel values that represent RGB
 * color and alpha information as separate samples and that pack all
 * samples for a single pixel into a single int, short, or byte quantity.
 * This class can be used only with ColorSpaces of type ColorSpace.TYPE_RGB.
 * In addition, for each component of the ColorSpace, the minimum
 * normalized component value obtained via the &lt;code&gt;getMinValue()&lt;/code&gt;
 * method of ColorSpace must be 0.0, and the maximum value obtained via
 * the &lt;code&gt;getMaxValue()&lt;/code&gt; method must be 1.0 (these min/max
 * values are typical for RGB spaces).
 * There must be three color samples in the pixel values and there can
 * be a single alpha sample.  For those methods that use a primitive array
 * pixel representation of type &lt;code&gt;transferType&lt;/code&gt;, the array
 * length is always one.  The transfer
 * types supported are DataBuffer.TYPE_BYTE,
 * DataBuffer.TYPE_USHORT, and DataBuffer.TYPE_INT.
 * Color and alpha samples are stored in the single
 * element of the array in bits indicated by bit masks.  Each bit mask
 * must be contiguous and masks must not overlap.  The same masks apply to
 * the single int pixel representation used by other methods.  The
 * correspondence of masks and color/alpha samples is as follows:
 * &lt;ul&gt;
 * &lt;li&gt; Masks are identified by indices running from 0 through 2
 * if no alpha is present, or 3 if an alpha is present.
 * &lt;li&gt; The first three indices refer to color samples;
 * index 0 corresponds to red, index 1 to green, and index 2 to blue.
 * &lt;li&gt; Index 3 corresponds to the alpha sample, if present.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The translation from pixel values to color/alpha components for
 * display or processing purposes is a one-to-one correspondence of
 * samples to components.  A &lt;code&gt;DirectColorModel&lt;/code&gt; is
 * typically used with image data which uses masks to define packed
 * samples.  For example, a &lt;code&gt;DirectColorModel&lt;/code&gt; can be used in
 * conjunction with a &lt;code&gt;SinglePixelPackedSampleModel&lt;/code&gt; to
 * construct a {@link BufferedImage}.  Normally the masks used by the
 * {@link SampleModel} and the &lt;code&gt;ColorModel&lt;/code&gt; would be the
 * same.  However, if they are different, the color interpretation
 * of pixel data will be done according to the masks of the
 * &lt;code&gt;ColorModel&lt;/code&gt;.
 * &lt;p&gt;
 * A single int pixel representation is valid for all objects of this
 * class, since it is always possible to represent pixel values used with
 * this class in a single int.  Therefore, methods which use this
 * representation will not throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt;
 * due to an invalid pixel value.
 * &lt;p&gt;
 * This color model is similar to an X11 TrueColor visual.
 * The default RGB ColorModel specified by the
 * {@link ColorModel#getRGBdefault() getRGBdefault} method is a
 * &lt;code&gt;DirectColorModel&lt;/code&gt; with the following parameters:
 * &lt;pre&gt;
 * Number of bits:        32
 * Red mask:              0x00ff0000
 * Green mask:            0x0000ff00
 * Blue mask:             0x000000ff
 * Alpha mask:            0xff000000
 * Color space:           sRGB
 * isAlphaPremultiplied:  False
 * Transparency:          Transparency.TRANSLUCENT
 * transferType:          DataBuffer.TYPE_INT
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Many of the methods in this class are final. This is because the
 * underlying native graphics code makes assumptions about the layout
 * and operation of this class and those assumptions are reflected in
 * the implementations of the methods here that are marked final.  You
 * can subclass this class for other reasons, but you cannot override
 * or modify the behavior of those methods.
 *
 * @see ColorModel
 * @see ColorSpace
 * @see SinglePixelPackedSampleModel
 * @see BufferedImage
 * @see ColorModel#getRGBdefault
 *
 */
public class DirectColorModel extends PackedColorModel {
    private int red_mask;
    private int green_mask;
    private int blue_mask;
    private int alpha_mask;
    private int red_offset;
    private int green_offset;
    private int blue_offset;
    private int alpha_offset;
    private int red_scale;
    private int green_scale;
    private int blue_scale;
    private int alpha_scale;
    private boolean is_LinearRGB;
    private int lRGBprecision;
    private byte[] tosRGB8LUT;
    private byte[] fromsRGB8LUT8;
    private short[] fromsRGB8LUT16;

    /**
     * Constructs a &lt;code&gt;DirectColorModel&lt;/code&gt; from the specified masks
     * that indicate which bits in an &lt;code&gt;int&lt;/code&gt; pixel representation
     * contain the red, green and blue color samples.  As pixel values do not
     * contain alpha information, all pixels are treated as opaque, which
     * means that alpha&amp;nbsp;=&amp;nbsp;1.0.  All of the bits
     * in each mask must be contiguous and fit in the specified number
     * of least significant bits of an &lt;code&gt;int&lt;/code&gt; pixel representation.
     *  The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space. The
     * transparency value is Transparency.OPAQUE.  The transfer type
     * is the smallest of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,
     * or DataBuffer.TYPE_INT that can hold a single pixel.
     * @param bits the number of bits in the pixel values; for example,
     *         the sum of the number of bits in the masks.
     * @param rmask specifies a mask indicating which bits in an
     *         integer pixel contain the red component
     * @param gmask specifies a mask indicating which bits in an
     *         integer pixel contain the green component
     * @param bmask specifies a mask indicating which bits in an
     *         integer pixel contain the blue component
     *
     */
    public DirectColorModel(int bits,
                            int rmask, int gmask, int bmask) {
<span class="nc" id="L152">        this(bits, rmask, gmask, bmask, 0);</span>
<span class="nc" id="L153">    }</span>

    /**
     * Constructs a &lt;code&gt;DirectColorModel&lt;/code&gt; from the specified masks
     * that indicate which bits in an &lt;code&gt;int&lt;/code&gt; pixel representation
     * contain the red, green and blue color samples and the alpha sample,
     * if present.  If &lt;code&gt;amask&lt;/code&gt; is 0, pixel values do not contain
     * alpha information and all pixels are treated as opaque, which means
     * that alpha&amp;nbsp;=&amp;nbsp;1.0.  All of the bits in each mask must
     * be contiguous and fit in the specified number of least significant bits
     * of an &lt;code&gt;int&lt;/code&gt; pixel representation.  Alpha, if present, is not
     * premultiplied.  The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value is Transparency.OPAQUE if no alpha is
     * present, or Transparency.TRANSLUCENT otherwise.  The transfer type
     * is the smallest of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,
     * or DataBuffer.TYPE_INT that can hold a single pixel.
     * @param bits the number of bits in the pixel values; for example,
     *         the sum of the number of bits in the masks.
     * @param rmask specifies a mask indicating which bits in an
     *         integer pixel contain the red component
     * @param gmask specifies a mask indicating which bits in an
     *         integer pixel contain the green component
     * @param bmask specifies a mask indicating which bits in an
     *         integer pixel contain the blue component
     * @param amask specifies a mask indicating which bits in an
     *         integer pixel contain the alpha component
     */
    public DirectColorModel(int bits, int rmask, int gmask,
                            int bmask, int amask) {
<span class="nc bnc" id="L182" title="All 2 branches missed.">        super (ColorSpace.getInstance(ColorSpace.CS_sRGB),</span>
               bits, rmask, gmask, bmask, amask, false,
               amask == 0 ? Transparency.OPAQUE : Transparency.TRANSLUCENT,
<span class="nc" id="L185">               ColorModel.getDefaultTransferType(bits));</span>
<span class="nc" id="L186">        setFields();</span>
<span class="nc" id="L187">    }</span>

    /**
     * Constructs a &lt;code&gt;DirectColorModel&lt;/code&gt; from the specified
     * parameters.  Color components are in the specified
     * &lt;code&gt;ColorSpace&lt;/code&gt;, which must be of type ColorSpace.TYPE_RGB
     * and have minimum normalized component values which are all 0.0
     * and maximum values which are all 1.0.
     * The masks specify which bits in an &lt;code&gt;int&lt;/code&gt; pixel
     * representation contain the red, green and blue color samples and
     * the alpha sample, if present.  If &lt;code&gt;amask&lt;/code&gt; is 0, pixel
     * values do not contain alpha information and all pixels are treated
     * as opaque, which means that alpha&amp;nbsp;=&amp;nbsp;1.0.  All of the
     * bits in each mask must be contiguous and fit in the specified number
     * of least significant bits of an &lt;code&gt;int&lt;/code&gt; pixel
     * representation.  If there is alpha, the &lt;code&gt;boolean&lt;/code&gt;
     * &lt;code&gt;isAlphaPremultiplied&lt;/code&gt; specifies how to interpret
     * color and alpha samples in pixel values.  If the &lt;code&gt;boolean&lt;/code&gt;
     * is &lt;code&gt;true&lt;/code&gt;, color samples are assumed to have been
     * multiplied by the alpha sample.  The transparency value is
     * Transparency.OPAQUE, if no alpha is present, or
     * Transparency.TRANSLUCENT otherwise.  The transfer type
     * is the type of primitive array used to represent pixel values and
     * must be one of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or
     * DataBuffer.TYPE_INT.
     * @param space the specified &lt;code&gt;ColorSpace&lt;/code&gt;
     * @param bits the number of bits in the pixel values; for example,
     *         the sum of the number of bits in the masks.
     * @param rmask specifies a mask indicating which bits in an
     *         integer pixel contain the red component
     * @param gmask specifies a mask indicating which bits in an
     *         integer pixel contain the green component
     * @param bmask specifies a mask indicating which bits in an
     *         integer pixel contain the blue component
     * @param amask specifies a mask indicating which bits in an
     *         integer pixel contain the alpha component
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if color samples are
     *        premultiplied by the alpha sample; &lt;code&gt;false&lt;/code&gt; otherwise
     * @param transferType the type of array used to represent pixel values
     * @throws IllegalArgumentException if &lt;code&gt;space&lt;/code&gt; is not a
     *         TYPE_RGB space or if the min/max normalized component
     *         values are not 0.0/1.0.
     */
    public DirectColorModel(ColorSpace space, int bits, int rmask,
                            int gmask, int bmask, int amask,
                            boolean isAlphaPremultiplied,
                            int transferType) {
<span class="nc bnc" id="L234" title="All 2 branches missed.">        super (space, bits, rmask, gmask, bmask, amask,</span>
               isAlphaPremultiplied,
               amask == 0 ? Transparency.OPAQUE : Transparency.TRANSLUCENT,
               transferType);
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (ColorModel.isLinearRGBspace(colorSpace)) {</span>
<span class="nc" id="L239">            is_LinearRGB = true;</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">            if (maxBits &lt;= 8) {</span>
<span class="nc" id="L241">                lRGBprecision = 8;</span>
<span class="nc" id="L242">                tosRGB8LUT = ColorModel.getLinearRGB8TosRGB8LUT();</span>
<span class="nc" id="L243">                fromsRGB8LUT8 = ColorModel.getsRGB8ToLinearRGB8LUT();</span>
            } else {
<span class="nc" id="L245">                lRGBprecision = 16;</span>
<span class="nc" id="L246">                tosRGB8LUT = ColorModel.getLinearRGB16TosRGB8LUT();</span>
<span class="nc" id="L247">                fromsRGB8LUT16 = ColorModel.getsRGB8ToLinearRGB16LUT();</span>
            }
<span class="nc bnc" id="L249" title="All 2 branches missed.">        } else if (!is_sRGB) {</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            for (int i = 0; i &lt; 3; i++) {</span>
                // super constructor checks that space is TYPE_RGB
                // check here that min/max are all 0.0/1.0
<span class="nc bnc" id="L253" title="All 2 branches missed.">                if ((space.getMinValue(i) != 0.0f) ||</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">                    (space.getMaxValue(i) != 1.0f)) {</span>
<span class="nc" id="L255">                    throw new IllegalArgumentException(</span>
                        &quot;Illegal min/max RGB component value&quot;);
                }
            }
        }
<span class="nc" id="L260">        setFields();</span>
<span class="nc" id="L261">    }</span>

    /**
     * Returns the mask indicating which bits in an &lt;code&gt;int&lt;/code&gt; pixel
     * representation contain the red color component.
     * @return the mask, which indicates which bits of the &lt;code&gt;int&lt;/code&gt;
     *         pixel representation contain the red color sample.
     */
    final public int getRedMask() {
<span class="nc" id="L270">        return maskArray[0];</span>
    }

    /**
     * Returns the mask indicating which bits in an &lt;code&gt;int&lt;/code&gt; pixel
     * representation contain the green color component.
     * @return the mask, which indicates which bits of the &lt;code&gt;int&lt;/code&gt;
     *         pixel representation contain the green color sample.
     */
    final public int getGreenMask() {
<span class="nc" id="L280">        return maskArray[1];</span>
    }

    /**
     * Returns the mask indicating which bits in an &lt;code&gt;int&lt;/code&gt; pixel
     * representation contain the blue color component.
     * @return the mask, which indicates which bits of the &lt;code&gt;int&lt;/code&gt;
     *         pixel representation contain the blue color sample.
     */
    final public int getBlueMask() {
<span class="nc" id="L290">        return maskArray[2];</span>
    }

    /**
     * Returns the mask indicating which bits in an &lt;code&gt;int&lt;/code&gt; pixel
     * representation contain the alpha component.
     * @return the mask, which indicates which bits of the &lt;code&gt;int&lt;/code&gt;
     *         pixel representation contain the alpha sample.
     */
    final public int getAlphaMask() {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (supportsAlpha) {</span>
<span class="nc" id="L301">            return maskArray[3];</span>
        } else {
<span class="nc" id="L303">            return 0;</span>
        }
    }


    /*
     * Given an int pixel in this ColorModel's ColorSpace, converts
     * it to the default sRGB ColorSpace and returns the R, G, and B
     * components as float values between 0.0 and 1.0.
     */
    private float[] getDefaultRGBComponents(int pixel) {
<span class="nc" id="L314">        int components[] = getComponents(pixel, null, 0);</span>
<span class="nc" id="L315">        float norm[] = getNormalizedComponents(components, 0, null, 0);</span>
        // Note that getNormalizedComponents returns non-premultiplied values
<span class="nc" id="L317">        return colorSpace.toRGB(norm);</span>
    }


    private int getsRGBComponentFromsRGB(int pixel, int idx) {
<span class="nc" id="L322">        int c = ((pixel &amp; maskArray[idx]) &gt;&gt;&gt; maskOffsets[idx]);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (isAlphaPremultiplied) {</span>
<span class="nc" id="L324">            int a = ((pixel &amp; maskArray[3]) &gt;&gt;&gt; maskOffsets[3]);</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            c = (a == 0) ? 0 :</span>
                         (int) (((c * scaleFactors[idx]) * 255.0f /
                                 (a * scaleFactors[3])) + 0.5f);
<span class="nc bnc" id="L328" title="All 2 branches missed.">        } else if (scaleFactors[idx] != 1.0f) {</span>
<span class="nc" id="L329">            c = (int) ((c * scaleFactors[idx]) + 0.5f);</span>
        }
<span class="nc" id="L331">        return c;</span>
    }


    private int getsRGBComponentFromLinearRGB(int pixel, int idx) {
<span class="nc" id="L336">        int c = ((pixel &amp; maskArray[idx]) &gt;&gt;&gt; maskOffsets[idx]);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        if (isAlphaPremultiplied) {</span>
<span class="nc" id="L338">            float factor = (float) ((1 &lt;&lt; lRGBprecision) - 1);</span>
<span class="nc" id="L339">            int a = ((pixel &amp; maskArray[3]) &gt;&gt;&gt; maskOffsets[3]);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            c = (a == 0) ? 0 :</span>
                         (int) (((c * scaleFactors[idx]) * factor /
                                 (a * scaleFactors[3])) + 0.5f);
<span class="nc bnc" id="L343" title="All 2 branches missed.">        } else if (nBits[idx] != lRGBprecision) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (lRGBprecision == 16) {</span>
<span class="nc" id="L345">                c = (int) ((c * scaleFactors[idx] * 257.0f) + 0.5f);</span>
            } else {
<span class="nc" id="L347">                c = (int) ((c * scaleFactors[idx]) + 0.5f);</span>
            }
        }
        // now range of c is 0-255 or 0-65535, depending on lRGBprecision
<span class="nc" id="L351">        return tosRGB8LUT[c] &amp; 0xff;</span>
    }


    /**
     * Returns the red color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;code&gt;ColorSpace&lt;/code&gt;, sRGB.  A
     * color conversion is done if necessary.  The pixel value is specified
     * as an &lt;code&gt;int&lt;/code&gt;.
     * The returned value is a non pre-multiplied value.  Thus, if the
     * alpha is premultiplied, this method divides it out before returning
     * the value.  If the alpha value is 0, for example, the red value
     * is 0.
     * @param pixel the specified pixel
     * @return the red color component for the specified pixel, from
     *         0 to 255 in the sRGB &lt;code&gt;ColorSpace&lt;/code&gt;.
     */
    final public int getRed(int pixel) {
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (is_sRGB) {</span>
<span class="nc" id="L370">            return getsRGBComponentFromsRGB(pixel, 0);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        } else if (is_LinearRGB) {</span>
<span class="nc" id="L372">            return getsRGBComponentFromLinearRGB(pixel, 0);</span>
        }
<span class="nc" id="L374">        float rgb[] = getDefaultRGBComponents(pixel);</span>
<span class="nc" id="L375">        return (int) (rgb[0] * 255.0f + 0.5f);</span>
    }

    /**
     * Returns the green color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;code&gt;ColorSpace&lt;/code&gt;, sRGB.  A
     * color conversion is done if necessary.  The pixel value is specified
     * as an &lt;code&gt;int&lt;/code&gt;.
     * The returned value is a non pre-multiplied value.  Thus, if the
     * alpha is premultiplied, this method divides it out before returning
     * the value.  If the alpha value is 0, for example, the green value
     * is 0.
     * @param pixel the specified pixel
     * @return the green color component for the specified pixel, from
     *         0 to 255 in the sRGB &lt;code&gt;ColorSpace&lt;/code&gt;.
     */
    final public int getGreen(int pixel) {
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (is_sRGB) {</span>
<span class="nc" id="L393">            return getsRGBComponentFromsRGB(pixel, 1);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">        } else if (is_LinearRGB) {</span>
<span class="nc" id="L395">            return getsRGBComponentFromLinearRGB(pixel, 1);</span>
        }
<span class="nc" id="L397">        float rgb[] = getDefaultRGBComponents(pixel);</span>
<span class="nc" id="L398">        return (int) (rgb[1] * 255.0f + 0.5f);</span>
    }

    /**
     * Returns the blue color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;code&gt;ColorSpace&lt;/code&gt;, sRGB.  A
     * color conversion is done if necessary.  The pixel value is specified
     * as an &lt;code&gt;int&lt;/code&gt;.
     * The returned value is a non pre-multiplied value.  Thus, if the
     * alpha is premultiplied, this method divides it out before returning
     * the value.  If the alpha value is 0, for example, the blue value
     * is 0.
     * @param pixel the specified pixel
     * @return the blue color component for the specified pixel, from
     *         0 to 255 in the sRGB &lt;code&gt;ColorSpace&lt;/code&gt;.
     */
    final public int getBlue(int pixel) {
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (is_sRGB) {</span>
<span class="nc" id="L416">            return getsRGBComponentFromsRGB(pixel, 2);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">        } else if (is_LinearRGB) {</span>
<span class="nc" id="L418">            return getsRGBComponentFromLinearRGB(pixel, 2);</span>
        }
<span class="nc" id="L420">        float rgb[] = getDefaultRGBComponents(pixel);</span>
<span class="nc" id="L421">        return (int) (rgb[2] * 255.0f + 0.5f);</span>
    }

    /**
     * Returns the alpha component for the specified pixel, scaled
     * from 0 to 255.  The pixel value is specified as an &lt;code&gt;int&lt;/code&gt;.
     * @param pixel the specified pixel
     * @return the value of the alpha component of &lt;code&gt;pixel&lt;/code&gt;
     *         from 0 to 255.
     */
    final public int getAlpha(int pixel) {
<span class="nc bnc" id="L432" title="All 2 branches missed.">        if (!supportsAlpha) return 255;</span>
<span class="nc" id="L433">        int a = ((pixel &amp; maskArray[3]) &gt;&gt;&gt; maskOffsets[3]);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        if (scaleFactors[3] != 1.0f) {</span>
<span class="nc" id="L435">            a = (int)(a * scaleFactors[3] + 0.5f);</span>
        }
<span class="nc" id="L437">        return a;</span>
    }

    /**
     * Returns the color/alpha components of the pixel in the default
     * RGB color model format.  A color conversion is done if necessary.
     * The pixel value is specified as an &lt;code&gt;int&lt;/code&gt;.
     * The returned value is in a non pre-multiplied format.  Thus, if
     * the alpha is premultiplied, this method divides it out of the
     * color components.  If the alpha value is 0, for example, the color
     * values are each 0.
     * @param pixel the specified pixel
     * @return the RGB value of the color/alpha components of the specified
     *         pixel.
     * @see ColorModel#getRGBdefault
     */
    final public int getRGB(int pixel) {
<span class="nc bnc" id="L454" title="All 4 branches missed.">        if (is_sRGB || is_LinearRGB) {</span>
<span class="nc" id="L455">            return (getAlpha(pixel) &lt;&lt; 24)</span>
<span class="nc" id="L456">                | (getRed(pixel) &lt;&lt; 16)</span>
<span class="nc" id="L457">                | (getGreen(pixel) &lt;&lt; 8)</span>
<span class="nc" id="L458">                | (getBlue(pixel) &lt;&lt; 0);</span>
        }
<span class="nc" id="L460">        float rgb[] = getDefaultRGBComponents(pixel);</span>
<span class="nc" id="L461">        return (getAlpha(pixel) &lt;&lt; 24)</span>
            | (((int) (rgb[0] * 255.0f + 0.5f)) &lt;&lt; 16)
            | (((int) (rgb[1] * 255.0f + 0.5f)) &lt;&lt; 8)
            | (((int) (rgb[2] * 255.0f + 0.5f)) &lt;&lt; 0);
    }

    /**
     * Returns the red color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;code&gt;ColorSpace&lt;/code&gt;, sRGB.  A
     * color conversion is done if necessary.  The pixel value is specified
     * by an array of data elements of type &lt;code&gt;transferType&lt;/code&gt; passed
     * in as an object reference.
     * The returned value is a non pre-multiplied value.  Thus, if the
     * alpha is premultiplied, this method divides it out before returning
     * the value.  If the alpha value is 0, for example, the red value
     * is 0.
     * If &lt;code&gt;inData&lt;/code&gt; is not a primitive array of type
     * &lt;code&gt;transferType&lt;/code&gt;, a &lt;code&gt;ClassCastException&lt;/code&gt; is
     * thrown.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a
     * pixel value for this &lt;code&gt;ColorModel&lt;/code&gt;.  Since
     * &lt;code&gt;DirectColorModel&lt;/code&gt; can be subclassed, subclasses inherit
     * the implementation of this method and if they don't override it
     * then they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     * An &lt;code&gt;UnsupportedOperationException&lt;/code&gt; is thrown if this
     * &lt;code&gt;transferType&lt;/code&gt; is not supported by this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param inData the array containing the pixel value
     * @return the value of the red component of the specified pixel.
     * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;inData&lt;/code&gt; is not
     *         large enough to hold a pixel value for this color model
     * @throws ClassCastException if &lt;code&gt;inData&lt;/code&gt; is not a
     *         primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws UnsupportedOperationException if this &lt;code&gt;transferType&lt;/code&gt;
     *         is not supported by this color model
     */
    public int getRed(Object inData) {
<span class="nc" id="L499">        int pixel=0;</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L502">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L503">               pixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L504">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L506">               short sdata[] = (short[])inData;</span>
<span class="nc" id="L507">               pixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L508">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L510">               int idata[] = (int[])inData;</span>
<span class="nc" id="L511">               pixel = idata[0];</span>
<span class="nc" id="L512">            break;</span>
            default:
<span class="nc" id="L514">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc" id="L517">        return getRed(pixel);</span>
    }


    /**
     * Returns the green color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;code&gt;ColorSpace&lt;/code&gt;, sRGB.  A
     * color conversion is done if necessary.  The pixel value is specified
     * by an array of data elements of type &lt;code&gt;transferType&lt;/code&gt; passed
     * in as an object reference.
     * The returned value is a non pre-multiplied value.  Thus, if the
     * alpha is premultiplied, this method divides it out before returning
     * the value.  If the alpha value is 0, for example, the green value
     * is 0.  If &lt;code&gt;inData&lt;/code&gt; is not a primitive array of type
     * &lt;code&gt;transferType&lt;/code&gt;, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.
     *  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel
     * value for this &lt;code&gt;ColorModel&lt;/code&gt;.  Since
     * &lt;code&gt;DirectColorModel&lt;/code&gt; can be subclassed, subclasses inherit
     * the implementation of this method and if they don't override it
     * then they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     * An &lt;code&gt;UnsupportedOperationException&lt;/code&gt; is
     * thrown if this &lt;code&gt;transferType&lt;/code&gt; is not supported by this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param inData the array containing the pixel value
     * @return the value of the green component of the specified pixel.
     * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;inData&lt;/code&gt; is not
     *         large enough to hold a pixel value for this color model
     * @throws ClassCastException if &lt;code&gt;inData&lt;/code&gt; is not a
     *         primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws UnsupportedOperationException if this &lt;code&gt;transferType&lt;/code&gt;
     *         is not supported by this color model
     */
    public int getGreen(Object inData) {
<span class="nc" id="L552">        int pixel=0;</span>
<span class="nc bnc" id="L553" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L555">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L556">               pixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L557">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L559">               short sdata[] = (short[])inData;</span>
<span class="nc" id="L560">               pixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L561">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L563">               int idata[] = (int[])inData;</span>
<span class="nc" id="L564">               pixel = idata[0];</span>
<span class="nc" id="L565">            break;</span>
            default:
<span class="nc" id="L567">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc" id="L570">        return getGreen(pixel);</span>
    }


    /**
     * Returns the blue color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;code&gt;ColorSpace&lt;/code&gt;, sRGB.  A
     * color conversion is done if necessary.  The pixel value is specified
     * by an array of data elements of type &lt;code&gt;transferType&lt;/code&gt; passed
     * in as an object reference.
     * The returned value is a non pre-multiplied value.  Thus, if the
     * alpha is premultiplied, this method divides it out before returning
     * the value.  If the alpha value is 0, for example, the blue value
     * is 0.  If &lt;code&gt;inData&lt;/code&gt; is not a primitive array of type
     * &lt;code&gt;transferType&lt;/code&gt;, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.
     *  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel
     * value for this &lt;code&gt;ColorModel&lt;/code&gt;.  Since
     * &lt;code&gt;DirectColorModel&lt;/code&gt; can be subclassed, subclasses inherit
     * the implementation of this method and if they don't override it
     * then they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     * An &lt;code&gt;UnsupportedOperationException&lt;/code&gt; is
     * thrown if this &lt;code&gt;transferType&lt;/code&gt; is not supported by this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param inData the array containing the pixel value
     * @return the value of the blue component of the specified pixel.
     * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;inData&lt;/code&gt; is not
     *         large enough to hold a pixel value for this color model
     * @throws ClassCastException if &lt;code&gt;inData&lt;/code&gt; is not a
     *         primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws UnsupportedOperationException if this &lt;code&gt;transferType&lt;/code&gt;
     *         is not supported by this color model
     */
    public int getBlue(Object inData) {
<span class="nc" id="L605">        int pixel=0;</span>
<span class="nc bnc" id="L606" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L608">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L609">               pixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L610">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L612">               short sdata[] = (short[])inData;</span>
<span class="nc" id="L613">               pixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L614">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L616">               int idata[] = (int[])inData;</span>
<span class="nc" id="L617">               pixel = idata[0];</span>
<span class="nc" id="L618">            break;</span>
            default:
<span class="nc" id="L620">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc" id="L623">        return getBlue(pixel);</span>
    }

    /**
     * Returns the alpha component for the specified pixel, scaled
     * from 0 to 255.  The pixel value is specified by an array of data
     * elements of type &lt;code&gt;transferType&lt;/code&gt; passed in as an object
     * reference.
     * If &lt;code&gt;inData&lt;/code&gt; is not a primitive array of type
     * &lt;code&gt;transferType&lt;/code&gt;, a &lt;code&gt;ClassCastException&lt;/code&gt; is
     * thrown.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel
     * value for this &lt;code&gt;ColorModel&lt;/code&gt;.  Since
     * &lt;code&gt;DirectColorModel&lt;/code&gt; can be subclassed, subclasses inherit
     * the implementation of this method and if they don't override it
     * then they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     * If this &lt;code&gt;transferType&lt;/code&gt; is not supported, an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; is thrown.
     * @param inData the specified pixel
     * @return the alpha component of the specified pixel, scaled from
     *         0 to 255.
     * @exception ClassCastException if &lt;code&gt;inData&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @exception ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt;
     * @exception UnsupportedOperationException if this
     *  &lt;code&gt;tranferType&lt;/code&gt; is not supported by this
     *  &lt;code&gt;ColorModel&lt;/code&gt;
     */
    public int getAlpha(Object inData) {
<span class="nc" id="L655">        int pixel=0;</span>
<span class="nc bnc" id="L656" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L658">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L659">               pixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L660">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L662">               short sdata[] = (short[])inData;</span>
<span class="nc" id="L663">               pixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L664">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L666">               int idata[] = (int[])inData;</span>
<span class="nc" id="L667">               pixel = idata[0];</span>
<span class="nc" id="L668">            break;</span>
            default:
<span class="nc" id="L670">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc" id="L673">        return getAlpha(pixel);</span>
    }

    /**
     * Returns the color/alpha components for the specified pixel in the
     * default RGB color model format.  A color conversion is done if
     * necessary.  The pixel value is specified by an array of data
     * elements of type &lt;code&gt;transferType&lt;/code&gt; passed in as an object
     * reference.  If &lt;code&gt;inData&lt;/code&gt; is not a primitive array of type
     * &lt;code&gt;transferType&lt;/code&gt;, a &lt;code&gt;ClassCastException&lt;/code&gt; is
     * thrown.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel
     * value for this &lt;code&gt;ColorModel&lt;/code&gt;.
     * The returned value is in a non pre-multiplied format.  Thus, if
     * the alpha is premultiplied, this method divides it out of the
     * color components.  If the alpha value is 0, for example, the color
     * values is 0.  Since &lt;code&gt;DirectColorModel&lt;/code&gt; can be
     * subclassed, subclasses inherit the implementation of this method
     * and if they don't override it then
     * they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param inData the specified pixel
     * @return the color and alpha components of the specified pixel.
     * @exception UnsupportedOperationException if this
     *            &lt;code&gt;transferType&lt;/code&gt; is not supported by this
     *            &lt;code&gt;ColorModel&lt;/code&gt;
     * @see ColorModel#getRGBdefault
     */
    public int getRGB(Object inData) {
<span class="nc" id="L703">        int pixel=0;</span>
<span class="nc bnc" id="L704" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L706">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L707">               pixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L708">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L710">               short sdata[] = (short[])inData;</span>
<span class="nc" id="L711">               pixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L712">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L714">               int idata[] = (int[])inData;</span>
<span class="nc" id="L715">               pixel = idata[0];</span>
<span class="nc" id="L716">            break;</span>
            default:
<span class="nc" id="L718">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc" id="L721">        return getRGB(pixel);</span>
    }

    /**
     * Returns a data element array representation of a pixel in this
     * &lt;code&gt;ColorModel&lt;/code&gt;, given an integer pixel representation in the
     * default RGB color model.
     * This array can then be passed to the &lt;code&gt;setDataElements&lt;/code&gt;
     * method of a &lt;code&gt;WritableRaster&lt;/code&gt; object.  If the pixel variable
     * is &lt;code&gt;null&lt;/code&gt;, a new array is allocated.  If &lt;code&gt;pixel&lt;/code&gt;
     * is not &lt;code&gt;null&lt;/code&gt;, it must be a primitive array of type
     * &lt;code&gt;transferType&lt;/code&gt;; otherwise, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel
     * value for this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel array is returned.
     * Since &lt;code&gt;DirectColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param rgb the integer pixel representation in the default RGB
     *            color model
     * @param pixel the specified pixel
     * @return an array representation of the specified pixel in this
     *         &lt;code&gt;ColorModel&lt;/code&gt;
     * @exception ClassCastException if &lt;code&gt;pixel&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @exception ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt;
     * @exception UnsupportedOperationException if this
     *  &lt;code&gt;transferType&lt;/code&gt; is not supported by this
     *  &lt;code&gt;ColorModel&lt;/code&gt;
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     */
    public Object getDataElements(int rgb, Object pixel) {
        //REMIND: maybe more efficient not to use int array for
        //DataBuffer.TYPE_USHORT and DataBuffer.TYPE_INT
<span class="nc" id="L761">        int intpixel[] = null;</span>
<span class="nc bnc" id="L762" title="All 4 branches missed.">        if (transferType == DataBuffer.TYPE_INT &amp;&amp;</span>
            pixel != null) {
<span class="nc" id="L764">            intpixel = (int[])pixel;</span>
<span class="nc" id="L765">            intpixel[0] = 0;</span>
        } else {
<span class="nc" id="L767">            intpixel = new int[1];</span>
        }

<span class="nc" id="L770">        ColorModel defaultCM = ColorModel.getRGBdefault();</span>
<span class="nc bnc" id="L771" title="All 4 branches missed.">        if (this == defaultCM || equals(defaultCM)) {</span>
<span class="nc" id="L772">            intpixel[0] = rgb;</span>
<span class="nc" id="L773">            return intpixel;</span>
        }

        int red, grn, blu, alp;
<span class="nc" id="L777">        red = (rgb&gt;&gt;16) &amp; 0xff;</span>
<span class="nc" id="L778">        grn = (rgb&gt;&gt;8) &amp; 0xff;</span>
<span class="nc" id="L779">        blu = rgb &amp; 0xff;</span>
<span class="nc bnc" id="L780" title="All 4 branches missed.">        if (is_sRGB || is_LinearRGB) {</span>
            int precision;
            float factor;
<span class="nc bnc" id="L783" title="All 2 branches missed.">            if (is_LinearRGB) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">                if (lRGBprecision == 8) {</span>
<span class="nc" id="L785">                    red = fromsRGB8LUT8[red] &amp; 0xff;</span>
<span class="nc" id="L786">                    grn = fromsRGB8LUT8[grn] &amp; 0xff;</span>
<span class="nc" id="L787">                    blu = fromsRGB8LUT8[blu] &amp; 0xff;</span>
<span class="nc" id="L788">                    precision = 8;</span>
<span class="nc" id="L789">                    factor = 1.0f / 255.0f;</span>
                } else {
<span class="nc" id="L791">                    red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L792">                    grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L793">                    blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L794">                    precision = 16;</span>
<span class="nc" id="L795">                    factor = 1.0f / 65535.0f;</span>
                }
            } else {
<span class="nc" id="L798">                precision = 8;</span>
<span class="nc" id="L799">                factor = 1.0f / 255.0f;</span>
            }
<span class="nc bnc" id="L801" title="All 2 branches missed.">            if (supportsAlpha) {</span>
<span class="nc" id="L802">                alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">                if (isAlphaPremultiplied) {</span>
<span class="nc" id="L804">                    factor *= (alp * (1.0f / 255.0f));</span>
<span class="nc" id="L805">                    precision = -1;  // force component calculations below</span>
                }
<span class="nc bnc" id="L807" title="All 2 branches missed.">                if (nBits[3] != 8) {</span>
<span class="nc" id="L808">                    alp = (int)</span>
                        ((alp * (1.0f / 255.0f) * ((1&lt;&lt;nBits[3]) - 1)) + 0.5f);
<span class="nc bnc" id="L810" title="All 2 branches missed.">                    if (alp &gt; ((1&lt;&lt;nBits[3]) - 1)) {</span>
                        // fix 4412670 - see comment below
<span class="nc" id="L812">                        alp = (1&lt;&lt;nBits[3]) - 1;</span>
                    }
                }
<span class="nc" id="L815">                intpixel[0] = alp &lt;&lt; maskOffsets[3];</span>
            }
<span class="nc bnc" id="L817" title="All 2 branches missed.">            if (nBits[0] != precision) {</span>
<span class="nc" id="L818">                red = (int) ((red * factor * ((1&lt;&lt;nBits[0]) - 1)) + 0.5f);</span>
            }
<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (nBits[1] != precision) {</span>
<span class="nc" id="L821">                grn = (int) ((grn * factor * ((1&lt;&lt;nBits[1]) - 1)) + 0.5f);</span>
            }
<span class="nc bnc" id="L823" title="All 2 branches missed.">            if (nBits[2] != precision) {</span>
<span class="nc" id="L824">                blu = (int) ((blu * factor * ((1&lt;&lt;nBits[2]) - 1)) + 0.5f);</span>
            }
<span class="nc" id="L826">        } else {</span>
            // Need to convert the color
<span class="nc" id="L828">            float[] norm = new float[3];</span>
<span class="nc" id="L829">            float factor = 1.0f / 255.0f;</span>
<span class="nc" id="L830">            norm[0] = red * factor;</span>
<span class="nc" id="L831">            norm[1] = grn * factor;</span>
<span class="nc" id="L832">            norm[2] = blu * factor;</span>
<span class="nc" id="L833">            norm = colorSpace.fromRGB(norm);</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">            if (supportsAlpha) {</span>
<span class="nc" id="L835">                alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                if (isAlphaPremultiplied) {</span>
<span class="nc" id="L837">                    factor *= alp;</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">                    for (int i = 0; i &lt; 3; i++) {</span>
<span class="nc" id="L839">                        norm[i] *= factor;</span>
                    }
                }
<span class="nc bnc" id="L842" title="All 2 branches missed.">                if (nBits[3] != 8) {</span>
<span class="nc" id="L843">                    alp = (int)</span>
                        ((alp * (1.0f / 255.0f) * ((1&lt;&lt;nBits[3]) - 1)) + 0.5f);
<span class="nc bnc" id="L845" title="All 2 branches missed.">                    if (alp &gt; ((1&lt;&lt;nBits[3]) - 1)) {</span>
                        // fix 4412670 - see comment below
<span class="nc" id="L847">                        alp = (1&lt;&lt;nBits[3]) - 1;</span>
                    }
                }
<span class="nc" id="L850">                intpixel[0] = alp &lt;&lt; maskOffsets[3];</span>
            }
<span class="nc" id="L852">            red = (int) ((norm[0] * ((1&lt;&lt;nBits[0]) - 1)) + 0.5f);</span>
<span class="nc" id="L853">            grn = (int) ((norm[1] * ((1&lt;&lt;nBits[1]) - 1)) + 0.5f);</span>
<span class="nc" id="L854">            blu = (int) ((norm[2] * ((1&lt;&lt;nBits[2]) - 1)) + 0.5f);</span>
        }

<span class="nc bnc" id="L857" title="All 2 branches missed.">        if (maxBits &gt; 23) {</span>
            // fix 4412670 - for components of 24 or more bits
            // some calculations done above with float precision
            // may lose enough precision that the integer result
            // overflows nBits, so we need to clamp.
<span class="nc bnc" id="L862" title="All 2 branches missed.">            if (red &gt; ((1&lt;&lt;nBits[0]) - 1)) {</span>
<span class="nc" id="L863">                red = (1&lt;&lt;nBits[0]) - 1;</span>
            }
<span class="nc bnc" id="L865" title="All 2 branches missed.">            if (grn &gt; ((1&lt;&lt;nBits[1]) - 1)) {</span>
<span class="nc" id="L866">                grn = (1&lt;&lt;nBits[1]) - 1;</span>
            }
<span class="nc bnc" id="L868" title="All 2 branches missed.">            if (blu &gt; ((1&lt;&lt;nBits[2]) - 1)) {</span>
<span class="nc" id="L869">                blu = (1&lt;&lt;nBits[2]) - 1;</span>
            }
        }

<span class="nc" id="L873">        intpixel[0] |= (red &lt;&lt; maskOffsets[0]) |</span>
                       (grn &lt;&lt; maskOffsets[1]) |
                       (blu &lt;&lt; maskOffsets[2]);

<span class="nc bnc" id="L877" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE: {
               byte bdata[];
<span class="nc bnc" id="L880" title="All 2 branches missed.">               if (pixel == null) {</span>
<span class="nc" id="L881">                   bdata = new byte[1];</span>
               } else {
<span class="nc" id="L883">                   bdata = (byte[])pixel;</span>
               }
<span class="nc" id="L885">               bdata[0] = (byte)(0xff&amp;intpixel[0]);</span>
<span class="nc" id="L886">               return bdata;</span>
            }
            case DataBuffer.TYPE_USHORT:{
               short sdata[];
<span class="nc bnc" id="L890" title="All 2 branches missed.">               if (pixel == null) {</span>
<span class="nc" id="L891">                   sdata = new short[1];</span>
               } else {
<span class="nc" id="L893">                   sdata = (short[])pixel;</span>
               }
<span class="nc" id="L895">               sdata[0] = (short)(intpixel[0]&amp;0xffff);</span>
<span class="nc" id="L896">               return sdata;</span>
            }
            case DataBuffer.TYPE_INT:
<span class="nc" id="L899">               return intpixel;</span>
        }
<span class="nc" id="L901">        throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                 &quot;implemented for transferType &quot; + transferType);

    }

    /**
     * Returns an array of unnormalized color/alpha components given a pixel
     * in this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel value is specified as an
     * &lt;code&gt;int&lt;/code&gt;.  If the &lt;code&gt;components&lt;/code&gt; array is
     * &lt;code&gt;null&lt;/code&gt;, a new array is allocated.  The
     * &lt;code&gt;components&lt;/code&gt; array is returned.  Color/alpha components are
     * stored in the &lt;code&gt;components&lt;/code&gt; array starting at
     * &lt;code&gt;offset&lt;/code&gt;, even if the array is allocated by this method.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * &lt;code&gt;components&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt; and is not large
     * enough to hold all the color and alpha components, starting at
     * &lt;code&gt;offset&lt;/code&gt;.
     * @param pixel the specified pixel
     * @param components the array to receive the color and alpha
     * components of the specified pixel
     * @param offset the offset into the &lt;code&gt;components&lt;/code&gt; array at
     * which to start storing the color and alpha components
     * @return an array containing the color and alpha components of the
     * specified pixel starting at the specified offset.
     */
    final public int[] getComponents(int pixel, int[] components, int offset) {
<span class="nc bnc" id="L927" title="All 2 branches missed.">        if (components == null) {</span>
<span class="nc" id="L928">            components = new int[offset+numComponents];</span>
        }

<span class="nc bnc" id="L931" title="All 2 branches missed.">        for (int i=0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L932">            components[offset+i] = (pixel &amp; maskArray[i]) &gt;&gt;&gt; maskOffsets[i];</span>
        }

<span class="nc" id="L935">        return components;</span>
    }

    /**
     * Returns an array of unnormalized color/alpha components given a pixel
     * in this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel value is specified by an
     * array of data elements of type &lt;code&gt;transferType&lt;/code&gt; passed in as
     * an object reference.  If &lt;code&gt;pixel&lt;/code&gt; is not a primitive array
     * of type &lt;code&gt;transferType&lt;/code&gt;, a &lt;code&gt;ClassCastException&lt;/code&gt;
     * is thrown.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a
     * pixel value for this &lt;code&gt;ColorModel&lt;/code&gt;.  If the
     * &lt;code&gt;components&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;, a new
     * array is allocated.  The &lt;code&gt;components&lt;/code&gt; array is returned.
     * Color/alpha components are stored in the &lt;code&gt;components&lt;/code&gt; array
     * starting at &lt;code&gt;offset&lt;/code&gt;, even if the array is allocated by
     * this method.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;
     * is thrown if the &lt;code&gt;components&lt;/code&gt; array is not
     * &lt;code&gt;null&lt;/code&gt; and is not large enough to hold all the color and
     * alpha components, starting at &lt;code&gt;offset&lt;/code&gt;.
     * Since &lt;code&gt;DirectColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     * @param pixel the specified pixel
     * @param components the array to receive the color and alpha
     *        components of the specified pixel
     * @param offset the offset into the &lt;code&gt;components&lt;/code&gt; array at
     *        which to start storing the color and alpha components
     * @return an array containing the color and alpha components of the
     * specified pixel starting at the specified offset.
     * @exception ClassCastException if &lt;code&gt;pixel&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @exception ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt;, or if &lt;code&gt;components&lt;/code&gt;
     *  is not &lt;code&gt;null&lt;/code&gt; and is not large enough to hold all the
     *  color and alpha components, starting at &lt;code&gt;offset&lt;/code&gt;
     * @exception UnsupportedOperationException if this
     *            &lt;code&gt;transferType&lt;/code&gt; is not supported by this
     *            color model
     */
    final public int[] getComponents(Object pixel, int[] components,
                                     int offset) {
<span class="nc" id="L979">        int intpixel=0;</span>
<span class="nc bnc" id="L980" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L982">               byte bdata[] = (byte[])pixel;</span>
<span class="nc" id="L983">               intpixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L984">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L986">               short sdata[] = (short[])pixel;</span>
<span class="nc" id="L987">               intpixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L988">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L990">               int idata[] = (int[])pixel;</span>
<span class="nc" id="L991">               intpixel = idata[0];</span>
<span class="nc" id="L992">            break;</span>
            default:
<span class="nc" id="L994">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc" id="L997">        return getComponents(intpixel, components, offset);</span>
    }

    /**
     * Creates a &lt;code&gt;WritableRaster&lt;/code&gt; with the specified width and
     * height that has a data layout (&lt;code&gt;SampleModel&lt;/code&gt;) compatible
     * with this &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param w the width to apply to the new &lt;code&gt;WritableRaster&lt;/code&gt;
     * @param h the height to apply to the new &lt;code&gt;WritableRaster&lt;/code&gt;
     * @return a &lt;code&gt;WritableRaster&lt;/code&gt; object with the specified
     * width and height.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or &lt;code&gt;h&lt;/code&gt;
     *         is less than or equal to zero
     * @see WritableRaster
     * @see SampleModel
     */
    final public WritableRaster createCompatibleWritableRaster (int w,
                                                                int h) {
<span class="nc bnc" id="L1015" title="All 4 branches missed.">        if ((w &lt;= 0) || (h &lt;= 0)) {</span>
<span class="nc" id="L1016">            throw new IllegalArgumentException(&quot;Width (&quot; + w + &quot;) and height (&quot; + h +</span>
                                               &quot;) cannot be &lt;= 0&quot;);
        }
        int[] bandmasks;
<span class="nc bnc" id="L1020" title="All 2 branches missed.">        if (supportsAlpha) {</span>
<span class="nc" id="L1021">            bandmasks = new int[4];</span>
<span class="nc" id="L1022">            bandmasks[3] = alpha_mask;</span>
        }
        else {
<span class="nc" id="L1025">            bandmasks = new int[3];</span>
        }
<span class="nc" id="L1027">        bandmasks[0] = red_mask;</span>
<span class="nc" id="L1028">        bandmasks[1] = green_mask;</span>
<span class="nc" id="L1029">        bandmasks[2] = blue_mask;</span>

<span class="nc bnc" id="L1031" title="All 2 branches missed.">        if (pixel_bits &gt; 16) {</span>
<span class="nc" id="L1032">            return Raster.createPackedRaster(DataBuffer.TYPE_INT,</span>
                                             w,h,bandmasks,null);
        }
<span class="nc bnc" id="L1035" title="All 2 branches missed.">        else if (pixel_bits &gt; 8) {</span>
<span class="nc" id="L1036">            return Raster.createPackedRaster(DataBuffer.TYPE_USHORT,</span>
                                             w,h,bandmasks,null);
        }
        else {
<span class="nc" id="L1040">            return Raster.createPackedRaster(DataBuffer.TYPE_BYTE,</span>
                                             w,h,bandmasks,null);
        }
    }

    /**
     * Returns a pixel value represented as an &lt;code&gt;int&lt;/code&gt; in this
     * &lt;code&gt;ColorModel&lt;/code&gt;, given an array of unnormalized color/alpha
     * components.   An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if the &lt;code&gt;components&lt;/code&gt; array is
     * not large enough to hold all the color and alpha components, starting
     * at &lt;code&gt;offset&lt;/code&gt;.
     * @param components an array of unnormalized color and alpha
     * components
     * @param offset the index into &lt;code&gt;components&lt;/code&gt; at which to
     * begin retrieving the color and alpha components
     * @return an &lt;code&gt;int&lt;/code&gt; pixel value in this
     * &lt;code&gt;ColorModel&lt;/code&gt; corresponding to the specified components.
     * @exception ArrayIndexOutOfBoundsException if
     *  the &lt;code&gt;components&lt;/code&gt; array is not large enough to
     *  hold all of the color and alpha components starting at
     *  &lt;code&gt;offset&lt;/code&gt;
     */
    public int getDataElement(int[] components, int offset) {
<span class="nc" id="L1064">        int pixel = 0;</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        for (int i=0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L1066">            pixel |= ((components[offset+i]&lt;&lt;maskOffsets[i])&amp;maskArray[i]);</span>
        }
<span class="nc" id="L1068">        return pixel;</span>
    }

    /**
     * Returns a data element array representation of a pixel in this
     * &lt;code&gt;ColorModel&lt;/code&gt;, given an array of unnormalized color/alpha
     * components.
     * This array can then be passed to the &lt;code&gt;setDataElements&lt;/code&gt;
     * method of a &lt;code&gt;WritableRaster&lt;/code&gt; object.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * &lt;code&gt;components&lt;/code&gt; array
     * is not large enough to hold all the color and alpha components,
     * starting at offset.  If the &lt;code&gt;obj&lt;/code&gt; variable is
     * &lt;code&gt;null&lt;/code&gt;, a new array is allocated.  If &lt;code&gt;obj&lt;/code&gt; is
     * not &lt;code&gt;null&lt;/code&gt;, it must be a primitive array
     * of type &lt;code&gt;transferType&lt;/code&gt;; otherwise, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * &lt;code&gt;obj&lt;/code&gt; is not large enough to hold a pixel value for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * Since &lt;code&gt;DirectColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     * @param components an array of unnormalized color and alpha
     * components
     * @param offset the index into &lt;code&gt;components&lt;/code&gt; at which to
     * begin retrieving color and alpha components
     * @param obj the &lt;code&gt;Object&lt;/code&gt; representing an array of color
     * and alpha components
     * @return an &lt;code&gt;Object&lt;/code&gt; representing an array of color and
     * alpha components.
     * @exception ClassCastException if &lt;code&gt;obj&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @exception ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;obj&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt; or the &lt;code&gt;components&lt;/code&gt;
     *  array is not large enough to hold all of the color and alpha
     *  components starting at &lt;code&gt;offset&lt;/code&gt;
     * @exception UnsupportedOperationException if this
     *            &lt;code&gt;transferType&lt;/code&gt; is not supported by this
     *            color model
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     */
    public Object getDataElements(int[] components, int offset, Object obj) {
<span class="nc" id="L1114">        int pixel = 0;</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">        for (int i=0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L1116">            pixel |= ((components[offset+i]&lt;&lt;maskOffsets[i])&amp;maskArray[i]);</span>
        }
<span class="nc bnc" id="L1118" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc bnc" id="L1120" title="All 2 branches missed.">               if (obj instanceof byte[]) {</span>
<span class="nc" id="L1121">                   byte bdata[] = (byte[])obj;</span>
<span class="nc" id="L1122">                   bdata[0] = (byte)(pixel&amp;0xff);</span>
<span class="nc" id="L1123">                   return bdata;</span>
               } else {
<span class="nc" id="L1125">                   byte bdata[] = {(byte)(pixel&amp;0xff)};</span>
<span class="nc" id="L1126">                   return bdata;</span>
               }
            case DataBuffer.TYPE_USHORT:
<span class="nc bnc" id="L1129" title="All 2 branches missed.">               if (obj instanceof short[]) {</span>
<span class="nc" id="L1130">                   short sdata[] = (short[])obj;</span>
<span class="nc" id="L1131">                   sdata[0] = (short)(pixel&amp;0xffff);</span>
<span class="nc" id="L1132">                   return sdata;</span>
               } else {
<span class="nc" id="L1134">                   short sdata[] = {(short)(pixel&amp;0xffff)};</span>
<span class="nc" id="L1135">                   return sdata;</span>
               }
            case DataBuffer.TYPE_INT:
<span class="nc bnc" id="L1138" title="All 2 branches missed.">               if (obj instanceof int[]) {</span>
<span class="nc" id="L1139">                   int idata[] = (int[])obj;</span>
<span class="nc" id="L1140">                   idata[0] = pixel;</span>
<span class="nc" id="L1141">                   return idata;</span>
               } else {
<span class="nc" id="L1143">                   int idata[] = {pixel};</span>
<span class="nc" id="L1144">                   return idata;</span>
               }
            default:
<span class="nc" id="L1147">               throw new ClassCastException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
    }

    /**
     * Forces the raster data to match the state specified in the
     * &lt;code&gt;isAlphaPremultiplied&lt;/code&gt; variable, assuming the data is
     * currently correctly described by this &lt;code&gt;ColorModel&lt;/code&gt;.  It
     * may multiply or divide the color raster data by alpha, or do
     * nothing if the data is in the correct state.  If the data needs to
     * be coerced, this method will also return an instance of this
     * &lt;code&gt;ColorModel&lt;/code&gt; with the &lt;code&gt;isAlphaPremultiplied&lt;/code&gt;
     * flag set appropriately.  This method will throw a
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if this transferType is
     * not supported by this &lt;code&gt;ColorModel&lt;/code&gt;.  Since
     * &lt;code&gt;ColorModel&lt;/code&gt; can be subclassed, subclasses inherit the
     * implementation of this method and if they don't override it then
     * they throw an exception if they use an unsupported transferType.
     *
     * @param raster the &lt;code&gt;WritableRaster&lt;/code&gt; data
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the alpha is
     * premultiplied; &lt;code&gt;false&lt;/code&gt; otherwise
     * @return a &lt;code&gt;ColorModel&lt;/code&gt; object that represents the
     * coerced data.
     * @exception UnsupportedOperationException if this
     *            &lt;code&gt;transferType&lt;/code&gt; is not supported by this
     *            color model
     */
    final public ColorModel coerceData (WritableRaster raster,
                                        boolean isAlphaPremultiplied)
    {
<span class="nc bnc" id="L1179" title="All 2 branches missed.">        if (!supportsAlpha ||</span>
<span class="nc bnc" id="L1180" title="All 2 branches missed.">            this.isAlphaPremultiplied() == isAlphaPremultiplied) {</span>
<span class="nc" id="L1181">            return this;</span>
        }

<span class="nc" id="L1184">        int w = raster.getWidth();</span>
<span class="nc" id="L1185">        int h = raster.getHeight();</span>
<span class="nc" id="L1186">        int aIdx = numColorComponents;</span>
        float normAlpha;
<span class="nc" id="L1188">        float alphaScale = 1.0f / ((float) ((1 &lt;&lt; nBits[aIdx]) - 1));</span>

<span class="nc" id="L1190">        int rminX = raster.getMinX();</span>
<span class="nc" id="L1191">        int rY = raster.getMinY();</span>
        int rX;
<span class="nc" id="L1193">        int pixel[] = null;</span>
<span class="nc" id="L1194">        int zpixel[] = null;</span>

<span class="nc bnc" id="L1196" title="All 2 branches missed.">        if (isAlphaPremultiplied) {</span>
            // Must mean that we are currently not premultiplied so
            // multiply by alpha
<span class="nc bnc" id="L1199" title="All 4 branches missed.">            switch (transferType) {</span>
                case DataBuffer.TYPE_BYTE: {
<span class="nc bnc" id="L1201" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L1202">                        rX = rminX;</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L1204">                            pixel = raster.getPixel(rX, rY, pixel);</span>
<span class="nc" id="L1205">                            normAlpha = pixel[aIdx] * alphaScale;</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">                            if (normAlpha != 0.f) {</span>
<span class="nc bnc" id="L1207" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L1208">                                    pixel[c] = (int) (pixel[c] * normAlpha +</span>
                                                      0.5f);
                                }
<span class="nc" id="L1211">                                raster.setPixel(rX, rY, pixel);</span>
                            } else {
<span class="nc bnc" id="L1213" title="All 2 branches missed.">                                if (zpixel == null) {</span>
<span class="nc" id="L1214">                                    zpixel = new int[numComponents];</span>
<span class="nc" id="L1215">                                    java.util.Arrays.fill(zpixel, 0);</span>
                                }
<span class="nc" id="L1217">                                raster.setPixel(rX, rY, zpixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L1222">                break;</span>
                case DataBuffer.TYPE_USHORT: {
<span class="nc bnc" id="L1224" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L1225">                        rX = rminX;</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L1227">                            pixel = raster.getPixel(rX, rY, pixel);</span>
<span class="nc" id="L1228">                            normAlpha = pixel[aIdx] * alphaScale;</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">                            if (normAlpha != 0.f) {</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L1231">                                    pixel[c] = (int) (pixel[c] * normAlpha +</span>
                                                      0.5f);
                                }
<span class="nc" id="L1234">                                raster.setPixel(rX, rY, pixel);</span>
                            } else {
<span class="nc bnc" id="L1236" title="All 2 branches missed.">                                if (zpixel == null) {</span>
<span class="nc" id="L1237">                                    zpixel = new int[numComponents];</span>
<span class="nc" id="L1238">                                    java.util.Arrays.fill(zpixel, 0);</span>
                                }
<span class="nc" id="L1240">                                raster.setPixel(rX, rY, zpixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L1245">                break;</span>
                case DataBuffer.TYPE_INT: {
<span class="nc bnc" id="L1247" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L1248">                        rX = rminX;</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L1250">                            pixel = raster.getPixel(rX, rY, pixel);</span>
<span class="nc" id="L1251">                            normAlpha = pixel[aIdx] * alphaScale;</span>
<span class="nc bnc" id="L1252" title="All 2 branches missed.">                            if (normAlpha != 0.f) {</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L1254">                                    pixel[c] = (int) (pixel[c] * normAlpha +</span>
                                                      0.5f);
                                }
<span class="nc" id="L1257">                                raster.setPixel(rX, rY, pixel);</span>
                            } else {
<span class="nc bnc" id="L1259" title="All 2 branches missed.">                                if (zpixel == null) {</span>
<span class="nc" id="L1260">                                    zpixel = new int[numComponents];</span>
<span class="nc" id="L1261">                                    java.util.Arrays.fill(zpixel, 0);</span>
                                }
<span class="nc" id="L1263">                                raster.setPixel(rX, rY, zpixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L1268">                break;</span>
                default:
<span class="nc" id="L1270">                    throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                         &quot;implemented for transferType &quot; + transferType);
            }
        }
        else {
            // We are premultiplied and want to divide it out
<span class="nc bnc" id="L1276" title="All 4 branches missed.">            switch (transferType) {</span>
                case DataBuffer.TYPE_BYTE: {
<span class="nc bnc" id="L1278" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L1279">                        rX = rminX;</span>
<span class="nc bnc" id="L1280" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L1281">                            pixel = raster.getPixel(rX, rY, pixel);</span>
<span class="nc" id="L1282">                            normAlpha = pixel[aIdx] * alphaScale;</span>
<span class="nc bnc" id="L1283" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc" id="L1284">                                float invAlpha = 1.0f / normAlpha;</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L1286">                                    pixel[c] = (int) (pixel[c] * invAlpha +</span>
                                                      0.5f);
                                }
<span class="nc" id="L1289">                                raster.setPixel(rX, rY, pixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L1294">                break;</span>
                case DataBuffer.TYPE_USHORT: {
<span class="nc bnc" id="L1296" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L1297">                        rX = rminX;</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L1299">                            pixel = raster.getPixel(rX, rY, pixel);</span>
<span class="nc" id="L1300">                            normAlpha = pixel[aIdx] * alphaScale;</span>
<span class="nc bnc" id="L1301" title="All 2 branches missed.">                            if (normAlpha != 0) {</span>
<span class="nc" id="L1302">                                float invAlpha = 1.0f / normAlpha;</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L1304">                                    pixel[c] = (int) (pixel[c] * invAlpha +</span>
                                                      0.5f);
                                }
<span class="nc" id="L1307">                                raster.setPixel(rX, rY, pixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L1312">                break;</span>
                case DataBuffer.TYPE_INT: {
<span class="nc bnc" id="L1314" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L1315">                        rX = rminX;</span>
<span class="nc bnc" id="L1316" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L1317">                            pixel = raster.getPixel(rX, rY, pixel);</span>
<span class="nc" id="L1318">                            normAlpha = pixel[aIdx] * alphaScale;</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">                            if (normAlpha != 0) {</span>
<span class="nc" id="L1320">                                float invAlpha = 1.0f / normAlpha;</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L1322">                                    pixel[c] = (int) (pixel[c] * invAlpha +</span>
                                                      0.5f);
                                }
<span class="nc" id="L1325">                                raster.setPixel(rX, rY, pixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L1330">                break;</span>
                default:
<span class="nc" id="L1332">                    throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                         &quot;implemented for transferType &quot; + transferType);
            }
        }

        // Return a new color model
<span class="nc" id="L1338">        return new DirectColorModel(colorSpace, pixel_bits, maskArray[0],</span>
                                    maskArray[1], maskArray[2], maskArray[3],
                                    isAlphaPremultiplied,
                                    transferType);

    }

    /**
      * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;raster&lt;/code&gt; is compatible
      * with this &lt;code&gt;ColorModel&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it is
      * not.
      * @param raster the {@link Raster} object to test for compatibility
      * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;raster&lt;/code&gt; is compatible
      * with this &lt;code&gt;ColorModel&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.
      */
    public boolean isCompatibleRaster(Raster raster) {
<span class="nc" id="L1354">        SampleModel sm = raster.getSampleModel();</span>
        SinglePixelPackedSampleModel spsm;
<span class="nc bnc" id="L1356" title="All 2 branches missed.">        if (sm instanceof SinglePixelPackedSampleModel) {</span>
<span class="nc" id="L1357">            spsm = (SinglePixelPackedSampleModel) sm;</span>
        }
        else {
<span class="nc" id="L1360">            return false;</span>
        }
<span class="nc bnc" id="L1362" title="All 2 branches missed.">        if (spsm.getNumBands() != getNumComponents()) {</span>
<span class="nc" id="L1363">            return false;</span>
        }

<span class="nc" id="L1366">        int[] bitMasks = spsm.getBitMasks();</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">        for (int i=0; i&lt;numComponents; i++) {</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">            if (bitMasks[i] != maskArray[i]) {</span>
<span class="nc" id="L1369">                return false;</span>
            }
        }

<span class="nc bnc" id="L1373" title="All 2 branches missed.">        return (raster.getTransferType() == transferType);</span>
    }

    private void setFields() {
        // Set the private fields
        // REMIND: Get rid of these from the native code
<span class="nc" id="L1379">        red_mask     = maskArray[0];</span>
<span class="nc" id="L1380">        red_offset   = maskOffsets[0];</span>
<span class="nc" id="L1381">        green_mask   = maskArray[1];</span>
<span class="nc" id="L1382">        green_offset = maskOffsets[1];</span>
<span class="nc" id="L1383">        blue_mask    = maskArray[2];</span>
<span class="nc" id="L1384">        blue_offset  = maskOffsets[2];</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">        if (nBits[0] &lt; 8) {</span>
<span class="nc" id="L1386">            red_scale = (1 &lt;&lt; nBits[0]) - 1;</span>
        }
<span class="nc bnc" id="L1388" title="All 2 branches missed.">        if (nBits[1] &lt; 8) {</span>
<span class="nc" id="L1389">            green_scale = (1 &lt;&lt; nBits[1]) - 1;</span>
        }
<span class="nc bnc" id="L1391" title="All 2 branches missed.">        if (nBits[2] &lt; 8) {</span>
<span class="nc" id="L1392">            blue_scale = (1 &lt;&lt; nBits[2]) - 1;</span>
        }
<span class="nc bnc" id="L1394" title="All 2 branches missed.">        if (supportsAlpha) {</span>
<span class="nc" id="L1395">            alpha_mask   = maskArray[3];</span>
<span class="nc" id="L1396">            alpha_offset = maskOffsets[3];</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">            if (nBits[3] &lt; 8) {</span>
<span class="nc" id="L1398">                alpha_scale = (1 &lt;&lt; nBits[3]) - 1;</span>
            }
        }
<span class="nc" id="L1401">    }</span>

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; that represents this
     * &lt;code&gt;DirectColorModel&lt;/code&gt;.
     * @return a &lt;code&gt;String&lt;/code&gt; representing this
     * &lt;code&gt;DirectColorModel&lt;/code&gt;.
     */
    public String toString() {
<span class="nc" id="L1410">        return new String(&quot;DirectColorModel: rmask=&quot;</span>
<span class="nc" id="L1411">                          +Integer.toHexString(red_mask)+&quot; gmask=&quot;</span>
<span class="nc" id="L1412">                          +Integer.toHexString(green_mask)+&quot; bmask=&quot;</span>
<span class="nc" id="L1413">                          +Integer.toHexString(blue_mask)+&quot; amask=&quot;</span>
<span class="nc" id="L1414">                          +Integer.toHexString(alpha_mask));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>