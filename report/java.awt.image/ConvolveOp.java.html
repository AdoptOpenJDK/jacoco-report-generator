<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConvolveOp.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">ConvolveOp.java</span></div><h1>ConvolveOp.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.color.ICC_Profile;
import java.awt.geom.Rectangle2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.Point2D;
import java.lang.annotation.Native;
import sun.awt.image.ImagingLib;

/**
 * This class implements a convolution from the source
 * to the destination.
 * Convolution using a convolution kernel is a spatial operation that
 * computes the output pixel from an input pixel by multiplying the kernel
 * with the surround of the input pixel.
 * This allows the output pixel to be affected by the immediate neighborhood
 * in a way that can be mathematically specified with a kernel.
 *&lt;p&gt;
 * This class operates with BufferedImage data in which color components are
 * premultiplied with the alpha component.  If the Source BufferedImage has
 * an alpha component, and the color components are not premultiplied with
 * the alpha component, then the data are premultiplied before being
 * convolved.  If the Destination has color components which are not
 * premultiplied, then alpha is divided out before storing into the
 * Destination (if alpha is 0, the color components are set to 0).  If the
 * Destination has no alpha component, then the resulting alpha is discarded
 * after first dividing it out of the color components.
 * &lt;p&gt;
 * Rasters are treated as having no alpha channel.  If the above treatment
 * of the alpha channel in BufferedImages is not desired, it may be avoided
 * by getting the Raster of a source BufferedImage and using the filter method
 * of this class which works with Rasters.
 * &lt;p&gt;
 * If a RenderingHints object is specified in the constructor, the
 * color rendering hint and the dithering hint may be used when color
 * conversion is required.
 *&lt;p&gt;
 * Note that the Source and the Destination may not be the same object.
 * @see Kernel
 * @see java.awt.RenderingHints#KEY_COLOR_RENDERING
 * @see java.awt.RenderingHints#KEY_DITHERING
 */
public class ConvolveOp implements BufferedImageOp, RasterOp {
    Kernel kernel;
    int edgeHint;
    RenderingHints hints;
    /**
     * Edge condition constants.
     */

    /**
     * Pixels at the edge of the destination image are set to zero.  This
     * is the default.
     */

    @Native public static final int EDGE_ZERO_FILL = 0;

    /**
     * Pixels at the edge of the source image are copied to
     * the corresponding pixels in the destination without modification.
     */
    @Native public static final int EDGE_NO_OP     = 1;

    /**
     * Constructs a ConvolveOp given a Kernel, an edge condition, and a
     * RenderingHints object (which may be null).
     * @param kernel the specified &lt;code&gt;Kernel&lt;/code&gt;
     * @param edgeCondition the specified edge condition
     * @param hints the specified &lt;code&gt;RenderingHints&lt;/code&gt; object
     * @see Kernel
     * @see #EDGE_NO_OP
     * @see #EDGE_ZERO_FILL
     * @see java.awt.RenderingHints
     */
<span class="nc" id="L101">    public ConvolveOp(Kernel kernel, int edgeCondition, RenderingHints hints) {</span>
<span class="nc" id="L102">        this.kernel   = kernel;</span>
<span class="nc" id="L103">        this.edgeHint = edgeCondition;</span>
<span class="nc" id="L104">        this.hints    = hints;</span>
<span class="nc" id="L105">    }</span>

    /**
     * Constructs a ConvolveOp given a Kernel.  The edge condition
     * will be EDGE_ZERO_FILL.
     * @param kernel the specified &lt;code&gt;Kernel&lt;/code&gt;
     * @see Kernel
     * @see #EDGE_ZERO_FILL
     */
<span class="nc" id="L114">    public ConvolveOp(Kernel kernel) {</span>
<span class="nc" id="L115">        this.kernel   = kernel;</span>
<span class="nc" id="L116">        this.edgeHint = EDGE_ZERO_FILL;</span>
<span class="nc" id="L117">    }</span>

    /**
     * Returns the edge condition.
     * @return the edge condition of this &lt;code&gt;ConvolveOp&lt;/code&gt;.
     * @see #EDGE_NO_OP
     * @see #EDGE_ZERO_FILL
     */
    public int getEdgeCondition() {
<span class="nc" id="L126">        return edgeHint;</span>
    }

    /**
     * Returns the Kernel.
     * @return the &lt;code&gt;Kernel&lt;/code&gt; of this &lt;code&gt;ConvolveOp&lt;/code&gt;.
     */
    public final Kernel getKernel() {
<span class="nc" id="L134">        return (Kernel) kernel.clone();</span>
    }

    /**
     * Performs a convolution on BufferedImages.  Each component of the
     * source image will be convolved (including the alpha component, if
     * present).
     * If the color model in the source image is not the same as that
     * in the destination image, the pixels will be converted
     * in the destination.  If the destination image is null,
     * a BufferedImage will be created with the source ColorModel.
     * The IllegalArgumentException may be thrown if the source is the
     * same as the destination.
     * @param src the source &lt;code&gt;BufferedImage&lt;/code&gt; to filter
     * @param dst the destination &lt;code&gt;BufferedImage&lt;/code&gt; for the
     *        filtered &lt;code&gt;src&lt;/code&gt;
     * @return the filtered &lt;code&gt;BufferedImage&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;src&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;src&lt;/code&gt; equals
     *         &lt;code&gt;dst&lt;/code&gt;
     * @throws ImagingOpException if &lt;code&gt;src&lt;/code&gt; cannot be filtered
     */
    public final BufferedImage filter (BufferedImage src, BufferedImage dst) {
<span class="nc bnc" id="L157" title="All 2 branches missed.">        if (src == null) {</span>
<span class="nc" id="L158">            throw new NullPointerException(&quot;src image is null&quot;);</span>
        }
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (src == dst) {</span>
<span class="nc" id="L161">            throw new IllegalArgumentException(&quot;src image cannot be the &quot;+</span>
                                               &quot;same as the dst image&quot;);
        }

<span class="nc" id="L165">        boolean needToConvert = false;</span>
<span class="nc" id="L166">        ColorModel srcCM = src.getColorModel();</span>
        ColorModel dstCM;
<span class="nc" id="L168">        BufferedImage origDst = dst;</span>

        // Can't convolve an IndexColorModel.  Need to expand it
<span class="nc bnc" id="L171" title="All 2 branches missed.">        if (srcCM instanceof IndexColorModel) {</span>
<span class="nc" id="L172">            IndexColorModel icm = (IndexColorModel) srcCM;</span>
<span class="nc" id="L173">            src = icm.convertToIntDiscrete(src.getRaster(), false);</span>
<span class="nc" id="L174">            srcCM = src.getColorModel();</span>
        }

<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L178">            dst = createCompatibleDestImage(src, null);</span>
<span class="nc" id="L179">            dstCM = srcCM;</span>
<span class="nc" id="L180">            origDst = dst;</span>
        }
        else {
<span class="nc" id="L183">            dstCM = dst.getColorModel();</span>
<span class="nc" id="L184">            if (srcCM.getColorSpace().getType() !=</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                dstCM.getColorSpace().getType())</span>
            {
<span class="nc" id="L187">                needToConvert = true;</span>
<span class="nc" id="L188">                dst = createCompatibleDestImage(src, null);</span>
<span class="nc" id="L189">                dstCM = dst.getColorModel();</span>
            }
<span class="nc bnc" id="L191" title="All 2 branches missed.">            else if (dstCM instanceof IndexColorModel) {</span>
<span class="nc" id="L192">                dst = createCompatibleDestImage(src, null);</span>
<span class="nc" id="L193">                dstCM = dst.getColorModel();</span>
            }
        }

<span class="nc bnc" id="L197" title="All 2 branches missed.">        if (ImagingLib.filter(this, src, dst) == null) {</span>
<span class="nc" id="L198">            throw new ImagingOpException (&quot;Unable to convolve src image&quot;);</span>
        }

<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (needToConvert) {</span>
<span class="nc" id="L202">            ColorConvertOp ccop = new ColorConvertOp(hints);</span>
<span class="nc" id="L203">            ccop.filter(dst, origDst);</span>
<span class="nc" id="L204">        }</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">        else if (origDst != dst) {</span>
<span class="nc" id="L206">            java.awt.Graphics2D g = origDst.createGraphics();</span>
            try {
<span class="nc" id="L208">                g.drawImage(dst, 0, 0, null);</span>
            } finally {
<span class="nc" id="L210">                g.dispose();</span>
<span class="nc" id="L211">            }</span>
        }

<span class="nc" id="L214">        return origDst;</span>
    }

    /**
     * Performs a convolution on Rasters.  Each band of the source Raster
     * will be convolved.
     * The source and destination must have the same number of bands.
     * If the destination Raster is null, a new Raster will be created.
     * The IllegalArgumentException may be thrown if the source is
     * the same as the destination.
     * @param src the source &lt;code&gt;Raster&lt;/code&gt; to filter
     * @param dst the destination &lt;code&gt;WritableRaster&lt;/code&gt; for the
     *        filtered &lt;code&gt;src&lt;/code&gt;
     * @return the filtered &lt;code&gt;WritableRaster&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;src&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @throws ImagingOpException if &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt;
     *         do not have the same number of bands
     * @throws ImagingOpException if &lt;code&gt;src&lt;/code&gt; cannot be filtered
     * @throws IllegalArgumentException if &lt;code&gt;src&lt;/code&gt; equals
     *         &lt;code&gt;dst&lt;/code&gt;
     */
    public final WritableRaster filter (Raster src, WritableRaster dst) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L237">            dst = createCompatibleDestRaster(src);</span>
        }
<span class="nc bnc" id="L239" title="All 2 branches missed.">        else if (src == dst) {</span>
<span class="nc" id="L240">            throw new IllegalArgumentException(&quot;src image cannot be the &quot;+</span>
                                               &quot;same as the dst image&quot;);
        }
<span class="nc bnc" id="L243" title="All 2 branches missed.">        else if (src.getNumBands() != dst.getNumBands()) {</span>
<span class="nc" id="L244">            throw new ImagingOpException(&quot;Different number of bands in src &quot;+</span>
                                         &quot; and dst Rasters&quot;);
        }

<span class="nc bnc" id="L248" title="All 2 branches missed.">        if (ImagingLib.filter(this, src, dst) == null) {</span>
<span class="nc" id="L249">            throw new ImagingOpException (&quot;Unable to convolve src image&quot;);</span>
        }

<span class="nc" id="L252">        return dst;</span>
    }

    /**
     * Creates a zeroed destination image with the correct size and number
     * of bands.  If destCM is null, an appropriate ColorModel will be used.
     * @param src       Source image for the filter operation.
     * @param destCM    ColorModel of the destination.  Can be null.
     * @return a destination &lt;code&gt;BufferedImage&lt;/code&gt; with the correct
     *         size and number of bands.
     */
    public BufferedImage createCompatibleDestImage(BufferedImage src,
                                                   ColorModel destCM) {
        BufferedImage image;

<span class="nc" id="L267">        int w = src.getWidth();</span>
<span class="nc" id="L268">        int h = src.getHeight();</span>

<span class="nc" id="L270">        WritableRaster wr = null;</span>

<span class="nc bnc" id="L272" title="All 2 branches missed.">        if (destCM == null) {</span>
<span class="nc" id="L273">            destCM = src.getColorModel();</span>
            // Not much support for ICM
<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (destCM instanceof IndexColorModel) {</span>
<span class="nc" id="L276">                destCM = ColorModel.getRGBdefault();</span>
            } else {
                /* Create destination image as similar to the source
                 *  as it possible...
                 */
<span class="nc" id="L281">                wr = src.getData().createCompatibleWritableRaster(w, h);</span>
            }
        }

<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (wr == null) {</span>
            /* This is the case when destination color model
             * was explicitly specified (and it may be not compatible
             * with source raster structure) or source is indexed image.
             * We should use destination color model to create compatible
             * destination raster here.
             */
<span class="nc" id="L292">            wr = destCM.createCompatibleWritableRaster(w, h);</span>
        }

<span class="nc" id="L295">        image = new BufferedImage (destCM, wr,</span>
<span class="nc" id="L296">                                   destCM.isAlphaPremultiplied(), null);</span>

<span class="nc" id="L298">        return image;</span>
    }

    /**
     * Creates a zeroed destination Raster with the correct size and number
     * of bands, given this source.
     */
    public WritableRaster createCompatibleDestRaster(Raster src) {
<span class="nc" id="L306">        return src.createCompatibleWritableRaster();</span>
    }

    /**
     * Returns the bounding box of the filtered destination image.  Since
     * this is not a geometric operation, the bounding box does not
     * change.
     */
    public final Rectangle2D getBounds2D(BufferedImage src) {
<span class="nc" id="L315">        return getBounds2D(src.getRaster());</span>
    }

    /**
     * Returns the bounding box of the filtered destination Raster.  Since
     * this is not a geometric operation, the bounding box does not
     * change.
     */
    public final Rectangle2D getBounds2D(Raster src) {
<span class="nc" id="L324">        return src.getBounds();</span>
    }

    /**
     * Returns the location of the destination point given a
     * point in the source.  If dstPt is non-null, it will
     * be used to hold the return value.  Since this is not a geometric
     * operation, the srcPt will equal the dstPt.
     */
    public final Point2D getPoint2D(Point2D srcPt, Point2D dstPt) {
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (dstPt == null) {</span>
<span class="nc" id="L335">            dstPt = new Point2D.Float();</span>
        }
<span class="nc" id="L337">        dstPt.setLocation(srcPt.getX(), srcPt.getY());</span>

<span class="nc" id="L339">        return dstPt;</span>
    }

    /**
     * Returns the rendering hints for this op.
     */
    public final RenderingHints getRenderingHints() {
<span class="nc" id="L346">        return hints;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>