<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>CropImageFilter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">CropImageFilter.java</span></div><h1>CropImageFilter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.image.ImageConsumer;
import java.awt.image.ColorModel;
import java.util.Hashtable;
import java.awt.Rectangle;

/**
 * An ImageFilter class for cropping images.
 * This class extends the basic ImageFilter Class to extract a given
 * rectangular region of an existing Image and provide a source for a
 * new image containing just the extracted region.  It is meant to
 * be used in conjunction with a FilteredImageSource object to produce
 * cropped versions of existing images.
 *
 * @see FilteredImageSource
 * @see ImageFilter
 *
 * @author      Jim Graham
 */
public class CropImageFilter extends ImageFilter {
    int cropX;
    int cropY;
    int cropW;
    int cropH;

    /**
     * Constructs a CropImageFilter that extracts the absolute rectangular
     * region of pixels from its source Image as specified by the x, y,
     * w, and h parameters.
     * @param x the x location of the top of the rectangle to be extracted
     * @param y the y location of the top of the rectangle to be extracted
     * @param w the width of the rectangle to be extracted
     * @param h the height of the rectangle to be extracted
     */
<span class="nc" id="L61">    public CropImageFilter(int x, int y, int w, int h) {</span>
<span class="nc" id="L62">        cropX = x;</span>
<span class="nc" id="L63">        cropY = y;</span>
<span class="nc" id="L64">        cropW = w;</span>
<span class="nc" id="L65">        cropH = h;</span>
<span class="nc" id="L66">    }</span>

    /**
     * Passes along  the properties from the source object after adding a
     * property indicating the cropped region.
     * This method invokes &lt;code&gt;super.setProperties&lt;/code&gt;,
     * which might result in additional properties being added.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose pixels
     * are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     */
    public void setProperties(Hashtable&lt;?,?&gt; props) {
<span class="nc" id="L82">        Hashtable&lt;Object,Object&gt; p = (Hashtable&lt;Object,Object&gt;)props.clone();</span>
<span class="nc" id="L83">        p.put(&quot;croprect&quot;, new Rectangle(cropX, cropY, cropW, cropH));</span>
<span class="nc" id="L84">        super.setProperties(p);</span>
<span class="nc" id="L85">    }</span>

    /**
     * Override the source image's dimensions and pass the dimensions
     * of the rectangular cropped region to the ImageConsumer.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose
     * pixels are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     * @see ImageConsumer
     */
    public void setDimensions(int w, int h) {
<span class="nc" id="L100">        consumer.setDimensions(cropW, cropH);</span>
<span class="nc" id="L101">    }</span>

    /**
     * Determine whether the delivered byte pixels intersect the region to
     * be extracted and passes through only that subset of pixels that
     * appear in the output region.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose
     * pixels are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     */
    public void setPixels(int x, int y, int w, int h,
                          ColorModel model, byte pixels[], int off,
                          int scansize) {
<span class="nc" id="L118">        int x1 = x;</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (x1 &lt; cropX) {</span>
<span class="nc" id="L120">            x1 = cropX;</span>
        }
<span class="nc" id="L122">    int x2 = addWithoutOverflow(x, w);</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">        if (x2 &gt; cropX + cropW) {</span>
<span class="nc" id="L124">            x2 = cropX + cropW;</span>
        }
<span class="nc" id="L126">        int y1 = y;</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (y1 &lt; cropY) {</span>
<span class="nc" id="L128">            y1 = cropY;</span>
        }

<span class="nc" id="L131">    int y2 = addWithoutOverflow(y, h);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (y2 &gt; cropY + cropH) {</span>
<span class="nc" id="L133">            y2 = cropY + cropH;</span>
        }
<span class="nc bnc" id="L135" title="All 4 branches missed.">        if (x1 &gt;= x2 || y1 &gt;= y2) {</span>
<span class="nc" id="L136">            return;</span>
        }
<span class="nc" id="L138">        consumer.setPixels(x1 - cropX, y1 - cropY, (x2 - x1), (y2 - y1),</span>
                           model, pixels,
                           off + (y1 - y) * scansize + (x1 - x), scansize);
<span class="nc" id="L141">    }</span>

    /**
     * Determine if the delivered int pixels intersect the region to
     * be extracted and pass through only that subset of pixels that
     * appear in the output region.
     * &lt;p&gt;
     * Note: This method is intended to be called by the
     * &lt;code&gt;ImageProducer&lt;/code&gt; of the &lt;code&gt;Image&lt;/code&gt; whose
     * pixels are being filtered. Developers using
     * this class to filter pixels from an image should avoid calling
     * this method directly since that operation could interfere
     * with the filtering operation.
     */
    public void setPixels(int x, int y, int w, int h,
                          ColorModel model, int pixels[], int off,
                          int scansize) {
<span class="nc" id="L158">        int x1 = x;</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (x1 &lt; cropX) {</span>
<span class="nc" id="L160">            x1 = cropX;</span>
        }
<span class="nc" id="L162">    int x2 = addWithoutOverflow(x, w);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">        if (x2 &gt; cropX + cropW) {</span>
<span class="nc" id="L164">            x2 = cropX + cropW;</span>
        }
<span class="nc" id="L166">        int y1 = y;</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (y1 &lt; cropY) {</span>
<span class="nc" id="L168">            y1 = cropY;</span>
        }

<span class="nc" id="L171">    int y2 = addWithoutOverflow(y, h);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (y2 &gt; cropY + cropH) {</span>
<span class="nc" id="L173">            y2 = cropY + cropH;</span>
        }
<span class="nc bnc" id="L175" title="All 4 branches missed.">        if (x1 &gt;= x2 || y1 &gt;= y2) {</span>
<span class="nc" id="L176">            return;</span>
        }
<span class="nc" id="L178">        consumer.setPixels(x1 - cropX, y1 - cropY, (x2 - x1), (y2 - y1),</span>
                           model, pixels,
                           off + (y1 - y) * scansize + (x1 - x), scansize);
<span class="nc" id="L181">    }</span>

    //check for potential overflow (see bug 4801285)
    private int addWithoutOverflow(int x, int w) {
<span class="nc" id="L185">        int x2 = x + w;</span>
<span class="nc bnc" id="L186" title="All 6 branches missed.">        if ( x &gt; 0 &amp;&amp; w &gt; 0 &amp;&amp; x2 &lt; 0 ) {</span>
<span class="nc" id="L187">            x2 = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L188" title="All 6 branches missed.">        } else if( x &lt; 0 &amp;&amp; w &lt; 0 &amp;&amp; x2 &gt; 0 ) {</span>
<span class="nc" id="L189">            x2 = Integer.MIN_VALUE;</span>
        }
<span class="nc" id="L191">        return x2;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>