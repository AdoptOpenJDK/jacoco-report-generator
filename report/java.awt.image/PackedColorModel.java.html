<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>PackedColorModel.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">PackedColorModel.java</span></div><h1>PackedColorModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.Transparency;
import java.awt.color.ColorSpace;

/**
 * The &lt;code&gt;PackedColorModel&lt;/code&gt; class is an abstract
 * {@link ColorModel} class that works with pixel values which represent
 * color and alpha information as separate samples and which pack all
 * samples for a single pixel into a single int, short, or byte quantity.
 * This class can be used with an arbitrary {@link ColorSpace}.  The number of
 * color samples in the pixel values must be the same as the number of color
 * components in the &lt;code&gt;ColorSpace&lt;/code&gt;.  There can be a single alpha
 * sample.  The array length is always 1 for those methods that use a
 * primitive array pixel representation of type &lt;code&gt;transferType&lt;/code&gt;.
 * The transfer types supported are DataBuffer.TYPE_BYTE,
 * DataBuffer.TYPE_USHORT, and DataBuffer.TYPE_INT.
 * Color and alpha samples are stored in the single element of the array
 * in bits indicated by bit masks.  Each bit mask must be contiguous and
 * masks must not overlap.  The same masks apply to the single int
 * pixel representation used by other methods.  The correspondence of
 * masks and color/alpha samples is as follows:
 * &lt;ul&gt;
 * &lt;li&gt; Masks are identified by indices running from 0 through
 * {@link ColorModel#getNumComponents() getNumComponents}&amp;nbsp;-&amp;nbsp;1.
 * &lt;li&gt; The first
 * {@link ColorModel#getNumColorComponents() getNumColorComponents}
 * indices refer to color samples.
 * &lt;li&gt; If an alpha sample is present, it corresponds the last index.
 * &lt;li&gt; The order of the color indices is specified
 * by the &lt;code&gt;ColorSpace&lt;/code&gt;.  Typically, this reflects the name of
 * the color space type (for example, TYPE_RGB), index 0
 * corresponds to red, index 1 to green, and index 2 to blue.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The translation from pixel values to color/alpha components for
 * display or processing purposes is a one-to-one correspondence of
 * samples to components.
 * A &lt;code&gt;PackedColorModel&lt;/code&gt; is typically used with image data
 * that uses masks to define packed samples.  For example, a
 * &lt;code&gt;PackedColorModel&lt;/code&gt; can be used in conjunction with a
 * {@link SinglePixelPackedSampleModel} to construct a
 * {@link BufferedImage}.  Normally the masks used by the
 * {@link SampleModel} and the &lt;code&gt;ColorModel&lt;/code&gt; would be the same.
 * However, if they are different, the color interpretation of pixel data is
 * done according to the masks of the &lt;code&gt;ColorModel&lt;/code&gt;.
 * &lt;p&gt;
 * A single &lt;code&gt;int&lt;/code&gt; pixel representation is valid for all objects
 * of this class since it is always possible to represent pixel values
 * used with this class in a single &lt;code&gt;int&lt;/code&gt;.  Therefore, methods
 * that use this representation do not throw an
 * &lt;code&gt;IllegalArgumentException&lt;/code&gt; due to an invalid pixel value.
 * &lt;p&gt;
 * A subclass of &lt;code&gt;PackedColorModel&lt;/code&gt; is {@link DirectColorModel},
 * which is similar to an X11 TrueColor visual.
 *
 * @see DirectColorModel
 * @see SinglePixelPackedSampleModel
 * @see BufferedImage
 */

public abstract class PackedColorModel extends ColorModel {
    int[] maskArray;
    int[] maskOffsets;
    float[] scaleFactors;

    /**
     * Constructs a &lt;code&gt;PackedColorModel&lt;/code&gt; from a color mask array,
     * which specifies which bits in an &lt;code&gt;int&lt;/code&gt; pixel representation
     * contain each of the color samples, and an alpha mask.  Color
     * components are in the specified &lt;code&gt;ColorSpace&lt;/code&gt;.  The length of
     * &lt;code&gt;colorMaskArray&lt;/code&gt; should be the number of components in
     * the &lt;code&gt;ColorSpace&lt;/code&gt;.  All of the bits in each mask
     * must be contiguous and fit in the specified number of least significant
     * bits of an &lt;code&gt;int&lt;/code&gt; pixel representation.  If the
     * &lt;code&gt;alphaMask&lt;/code&gt; is 0, there is no alpha.  If there is alpha,
     * the &lt;code&gt;boolean&lt;/code&gt; &lt;code&gt;isAlphaPremultiplied&lt;/code&gt; specifies
     * how to interpret color and alpha samples in pixel values.  If the
     * &lt;code&gt;boolean&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, color samples are assumed
     * to have been multiplied by the alpha sample.  The transparency,
     * &lt;code&gt;trans&lt;/code&gt;, specifies what alpha values can be represented
     * by this color model.  The transfer type is the type of primitive
     * array used to represent pixel values.
     * @param space the specified &lt;code&gt;ColorSpace&lt;/code&gt;
     * @param bits the number of bits in the pixel values
     * @param colorMaskArray array that specifies the masks representing
     *         the bits of the pixel values that represent the color
     *         components
     * @param alphaMask specifies the mask representing
     *         the bits of the pixel values that represent the alpha
     *         component
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if color samples are
     *        premultiplied by the alpha sample; &lt;code&gt;false&lt;/code&gt; otherwise
     * @param trans specifies the alpha value that can be represented by
     *        this color model
     * @param transferType the type of array used to represent pixel values
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less than
     *         1 or greater than 32
     */
    public PackedColorModel (ColorSpace space, int bits,
                             int[] colorMaskArray, int alphaMask,
                             boolean isAlphaPremultiplied,
                             int trans, int transferType) {
<span class="nc bnc" id="L129" title="All 2 branches missed.">        super(bits, PackedColorModel.createBitsArray(colorMaskArray,</span>
                                                     alphaMask),
              space, (alphaMask == 0 ? false : true),
              isAlphaPremultiplied, trans, transferType);
<span class="nc bnc" id="L133" title="All 4 branches missed.">        if (bits &lt; 1 || bits &gt; 32) {</span>
<span class="nc" id="L134">            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;</span>
                                               +&quot; 1 and 32.&quot;);
        }
<span class="nc" id="L137">        maskArray   = new int[numComponents];</span>
<span class="nc" id="L138">        maskOffsets = new int[numComponents];</span>
<span class="nc" id="L139">        scaleFactors = new float[numComponents];</span>

<span class="nc bnc" id="L141" title="All 2 branches missed.">        for (int i=0; i &lt; numColorComponents; i++) {</span>
            // Get the mask offset and #bits
<span class="nc" id="L143">            DecomposeMask(colorMaskArray[i], i, space.getName(i));</span>
        }
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (alphaMask != 0) {</span>
<span class="nc" id="L146">            DecomposeMask(alphaMask, numColorComponents, &quot;alpha&quot;);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (nBits[numComponents-1] == 1) {</span>
<span class="nc" id="L148">                transparency = Transparency.BITMASK;</span>
            }
        }
<span class="nc" id="L151">    }</span>

    /**
     * Constructs a &lt;code&gt;PackedColorModel&lt;/code&gt; from the specified
     * masks which indicate which bits in an &lt;code&gt;int&lt;/code&gt; pixel
     * representation contain the alpha, red, green and blue color samples.
     * Color components are in the specified &lt;code&gt;ColorSpace&lt;/code&gt;, which
     * must be of type ColorSpace.TYPE_RGB.  All of the bits in each
     * mask must be contiguous and fit in the specified number of
     * least significant bits of an &lt;code&gt;int&lt;/code&gt; pixel representation.  If
     * &lt;code&gt;amask&lt;/code&gt; is 0, there is no alpha.  If there is alpha,
     * the &lt;code&gt;boolean&lt;/code&gt; &lt;code&gt;isAlphaPremultiplied&lt;/code&gt;
     * specifies how to interpret color and alpha samples
     * in pixel values.  If the &lt;code&gt;boolean&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;,
     * color samples are assumed to have been multiplied by the alpha sample.
     * The transparency, &lt;code&gt;trans&lt;/code&gt;, specifies what alpha values
     * can be represented by this color model.
     * The transfer type is the type of primitive array used to represent
     * pixel values.
     * @param space the specified &lt;code&gt;ColorSpace&lt;/code&gt;
     * @param bits the number of bits in the pixel values
     * @param rmask specifies the mask representing
     *         the bits of the pixel values that represent the red
     *         color component
     * @param gmask specifies the mask representing
     *         the bits of the pixel values that represent the green
     *         color component
     * @param bmask specifies the mask representing
     *         the bits of the pixel values that represent
     *         the blue color component
     * @param amask specifies the mask representing
     *         the bits of the pixel values that represent
     *         the alpha component
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if color samples are
     *        premultiplied by the alpha sample; &lt;code&gt;false&lt;/code&gt; otherwise
     * @param trans specifies the alpha value that can be represented by
     *        this color model
     * @param transferType the type of array used to represent pixel values
     * @throws IllegalArgumentException if &lt;code&gt;space&lt;/code&gt; is not a
     *         TYPE_RGB space
     * @see ColorSpace
     */
    public PackedColorModel(ColorSpace space, int bits, int rmask, int gmask,
                            int bmask, int amask,
                            boolean isAlphaPremultiplied,
                            int trans, int transferType) {
<span class="nc bnc" id="L197" title="All 2 branches missed.">        super (bits, PackedColorModel.createBitsArray(rmask, gmask, bmask,</span>
                                                      amask),
               space, (amask == 0 ? false : true),
               isAlphaPremultiplied, trans, transferType);

<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (space.getType() != ColorSpace.TYPE_RGB) {</span>
<span class="nc" id="L203">            throw new IllegalArgumentException(&quot;ColorSpace must be TYPE_RGB.&quot;);</span>
        }
<span class="nc" id="L205">        maskArray = new int[numComponents];</span>
<span class="nc" id="L206">        maskOffsets = new int[numComponents];</span>
<span class="nc" id="L207">        scaleFactors = new float[numComponents];</span>

<span class="nc" id="L209">        DecomposeMask(rmask, 0, &quot;red&quot;);</span>

<span class="nc" id="L211">        DecomposeMask(gmask, 1, &quot;green&quot;);</span>

<span class="nc" id="L213">        DecomposeMask(bmask, 2, &quot;blue&quot;);</span>

<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (amask != 0) {</span>
<span class="nc" id="L216">            DecomposeMask(amask, 3, &quot;alpha&quot;);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (nBits[3] == 1) {</span>
<span class="nc" id="L218">                transparency = Transparency.BITMASK;</span>
            }
        }
<span class="nc" id="L221">    }</span>

    /**
     * Returns the mask indicating which bits in a pixel
     * contain the specified color/alpha sample.  For color
     * samples, &lt;code&gt;index&lt;/code&gt; corresponds to the placement of color
     * sample names in the color space.  Thus, an &lt;code&gt;index&lt;/code&gt;
     * equal to 0 for a CMYK ColorSpace would correspond to
     * Cyan and an &lt;code&gt;index&lt;/code&gt; equal to 1 would correspond to
     * Magenta.  If there is alpha, the alpha &lt;code&gt;index&lt;/code&gt; would be:
     * &lt;pre&gt;
     *      alphaIndex = numComponents() - 1;
     * &lt;/pre&gt;
     * @param index the specified color or alpha sample
     * @return the mask, which indicates which bits of the &lt;code&gt;int&lt;/code&gt;
     *         pixel representation contain the color or alpha sample specified
     *         by &lt;code&gt;index&lt;/code&gt;.
     * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;index&lt;/code&gt; is
     *         greater than the number of components minus 1 in this
     *         &lt;code&gt;PackedColorModel&lt;/code&gt; or if &lt;code&gt;index&lt;/code&gt; is
     *         less than zero
     */
    final public int getMask(int index) {
<span class="nc" id="L244">        return maskArray[index];</span>
    }

    /**
     * Returns a mask array indicating which bits in a pixel
     * contain the color and alpha samples.
     * @return the mask array , which indicates which bits of the
     *         &lt;code&gt;int&lt;/code&gt; pixel
     *         representation contain the color or alpha samples.
     */
    final public int[] getMasks() {
<span class="nc" id="L255">        return (int[]) maskArray.clone();</span>
    }

    /*
     * A utility function to compute the mask offset and scalefactor,
     * store these and the mask in instance arrays, and verify that
     * the mask fits in the specified pixel size.
     */
    private void DecomposeMask(int mask,  int idx, String componentName) {
<span class="nc" id="L264">        int off = 0;</span>
<span class="nc" id="L265">        int count = nBits[idx];</span>

        // Store the mask
<span class="nc" id="L268">        maskArray[idx]   = mask;</span>

        // Now find the shift
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (mask != 0) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">            while ((mask &amp; 1) == 0) {</span>
<span class="nc" id="L273">                mask &gt;&gt;&gt;= 1;</span>
<span class="nc" id="L274">                off++;</span>
            }
        }

<span class="nc bnc" id="L278" title="All 2 branches missed.">        if (off + count &gt; pixel_bits) {</span>
<span class="nc" id="L279">            throw new IllegalArgumentException(componentName + &quot; mask &quot;+</span>
<span class="nc" id="L280">                                        Integer.toHexString(maskArray[idx])+</span>
                                               &quot; overflows pixel (expecting &quot;+
                                               pixel_bits+&quot; bits&quot;);
        }

<span class="nc" id="L285">        maskOffsets[idx] = off;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">        if (count == 0) {</span>
            // High enough to scale any 0-ff value down to 0.0, but not
            // high enough to get Infinity when scaling back to pixel bits
<span class="nc" id="L289">            scaleFactors[idx] = 256.0f;</span>
        } else {
<span class="nc" id="L291">            scaleFactors[idx] = 255.0f / ((1 &lt;&lt; count) - 1);</span>
        }

<span class="nc" id="L294">    }</span>

    /**
     * Creates a &lt;code&gt;SampleModel&lt;/code&gt; with the specified width and
     * height that has a data layout compatible with this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param w the width (in pixels) of the region of the image data
     *          described
     * @param h the height (in pixels) of the region of the image data
     *          described
     * @return the newly created &lt;code&gt;SampleModel&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     * @see SampleModel
     */
    public SampleModel createCompatibleSampleModel(int w, int h) {
<span class="nc" id="L310">        return new SinglePixelPackedSampleModel(transferType, w, h,</span>
                                                maskArray);
    }

    /**
     * Checks if the specified &lt;code&gt;SampleModel&lt;/code&gt; is compatible
     * with this &lt;code&gt;ColorModel&lt;/code&gt;.  If &lt;code&gt;sm&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;, this method returns &lt;code&gt;false&lt;/code&gt;.
     * @param sm the specified &lt;code&gt;SampleModel&lt;/code&gt;,
     * or &lt;code&gt;null&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;SampleModel&lt;/code&gt;
     *         is compatible with this &lt;code&gt;ColorModel&lt;/code&gt;;
     *         &lt;code&gt;false&lt;/code&gt; otherwise.
     * @see SampleModel
     */
    public boolean isCompatibleSampleModel(SampleModel sm) {
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (! (sm instanceof SinglePixelPackedSampleModel)) {</span>
<span class="nc" id="L327">            return false;</span>
        }

        // Must have the same number of components
<span class="nc bnc" id="L331" title="All 2 branches missed.">        if (numComponents != sm.getNumBands()) {</span>
<span class="nc" id="L332">            return false;</span>
        }

        // Transfer type must be the same
<span class="nc bnc" id="L336" title="All 2 branches missed.">        if (sm.getTransferType() != transferType) {</span>
<span class="nc" id="L337">            return false;</span>
        }

<span class="nc" id="L340">        SinglePixelPackedSampleModel sppsm = (SinglePixelPackedSampleModel) sm;</span>
        // Now compare the specific masks
<span class="nc" id="L342">        int[] bitMasks = sppsm.getBitMasks();</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (bitMasks.length != maskArray.length) {</span>
<span class="nc" id="L344">            return false;</span>
        }

        /* compare 'effective' masks only, i.e. only part of the mask
         * which fits the capacity of the transfer type.
         */
<span class="nc" id="L350">        int maxMask = (int)((1L &lt;&lt; DataBuffer.getDataTypeSize(transferType)) - 1);</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">        for (int i=0; i &lt; bitMasks.length; i++) {</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">            if ((maxMask &amp; bitMasks[i]) != (maxMask &amp; maskArray[i])) {</span>
<span class="nc" id="L353">                return false;</span>
            }
        }

<span class="nc" id="L357">        return true;</span>
    }

    /**
     * Returns a {@link WritableRaster} representing the alpha channel of
     * an image, extracted from the input &lt;code&gt;WritableRaster&lt;/code&gt;.
     * This method assumes that &lt;code&gt;WritableRaster&lt;/code&gt; objects
     * associated with this &lt;code&gt;ColorModel&lt;/code&gt; store the alpha band,
     * if present, as the last band of image data.  Returns &lt;code&gt;null&lt;/code&gt;
     * if there is no separate spatial alpha channel associated with this
     * &lt;code&gt;ColorModel&lt;/code&gt;.  This method creates a new
     * &lt;code&gt;WritableRaster&lt;/code&gt;, but shares the data array.
     * @param raster a &lt;code&gt;WritableRaster&lt;/code&gt; containing an image
     * @return a &lt;code&gt;WritableRaster&lt;/code&gt; that represents the alpha
     *         channel of the image contained in &lt;code&gt;raster&lt;/code&gt;.
     */
    public WritableRaster getAlphaRaster(WritableRaster raster) {
<span class="nc bnc" id="L374" title="All 2 branches missed.">        if (hasAlpha() == false) {</span>
<span class="nc" id="L375">            return null;</span>
        }

<span class="nc" id="L378">        int x = raster.getMinX();</span>
<span class="nc" id="L379">        int y = raster.getMinY();</span>
<span class="nc" id="L380">        int[] band = new int[1];</span>
<span class="nc" id="L381">        band[0] = raster.getNumBands() - 1;</span>
<span class="nc" id="L382">        return raster.createWritableChild(x, y, raster.getWidth(),</span>
<span class="nc" id="L383">                                          raster.getHeight(), x, y,</span>
                                          band);
    }

    /**
     * Tests if the specified &lt;code&gt;Object&lt;/code&gt; is an instance
     * of &lt;code&gt;PackedColorModel&lt;/code&gt; and equals this
     * &lt;code&gt;PackedColorModel&lt;/code&gt;.
     * @param obj the &lt;code&gt;Object&lt;/code&gt; to test for equality
     * @return &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;Object&lt;/code&gt;
     * is an instance of &lt;code&gt;PackedColorModel&lt;/code&gt; and equals this
     * &lt;code&gt;PackedColorModel&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (!(obj instanceof PackedColorModel)) {</span>
<span class="nc" id="L398">            return false;</span>
        }

<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (!super.equals(obj)) {</span>
<span class="nc" id="L402">            return false;</span>
        }

<span class="nc" id="L405">        PackedColorModel cm = (PackedColorModel) obj;</span>
<span class="nc" id="L406">        int numC = cm.getNumComponents();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (numC != numComponents) {</span>
<span class="nc" id="L408">            return false;</span>
        }
<span class="nc bnc" id="L410" title="All 2 branches missed.">        for(int i=0; i &lt; numC; i++) {</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">            if (maskArray[i] != cm.getMask(i)) {</span>
<span class="nc" id="L412">                return false;</span>
            }
        }
<span class="nc" id="L415">        return true;</span>
    }

    private final static int[] createBitsArray(int[]colorMaskArray,
                                               int alphaMask) {
<span class="nc" id="L420">        int numColors = colorMaskArray.length;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">        int numAlpha = (alphaMask == 0 ? 0 : 1);</span>
<span class="nc" id="L422">        int[] arr = new int[numColors+numAlpha];</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">        for (int i=0; i &lt; numColors; i++) {</span>
<span class="nc" id="L424">            arr[i] = countBits(colorMaskArray[i]);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (arr[i] &lt; 0) {</span>
<span class="nc" id="L426">                throw new IllegalArgumentException(&quot;Noncontiguous color mask (&quot;</span>
<span class="nc" id="L427">                                     + Integer.toHexString(colorMaskArray[i])+</span>
                                     &quot;at index &quot;+i);
            }
        }
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (alphaMask != 0) {</span>
<span class="nc" id="L432">            arr[numColors] = countBits(alphaMask);</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (arr[numColors] &lt; 0) {</span>
<span class="nc" id="L434">                throw new IllegalArgumentException(&quot;Noncontiguous alpha mask (&quot;</span>
<span class="nc" id="L435">                                     + Integer.toHexString(alphaMask));</span>
            }
        }
<span class="nc" id="L438">        return arr;</span>
    }

    private final static int[] createBitsArray(int rmask, int gmask, int bmask,
                                         int amask) {
<span class="nc bnc" id="L443" title="All 2 branches missed.">        int[] arr = new int[3 + (amask == 0 ? 0 : 1)];</span>
<span class="nc" id="L444">        arr[0] = countBits(rmask);</span>
<span class="nc" id="L445">        arr[1] = countBits(gmask);</span>
<span class="nc" id="L446">        arr[2] = countBits(bmask);</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (arr[0] &lt; 0) {</span>
<span class="nc" id="L448">            throw new IllegalArgumentException(&quot;Noncontiguous red mask (&quot;</span>
<span class="nc" id="L449">                                     + Integer.toHexString(rmask));</span>
        }
<span class="nc bnc" id="L451" title="All 2 branches missed.">        else if (arr[1] &lt; 0) {</span>
<span class="nc" id="L452">            throw new IllegalArgumentException(&quot;Noncontiguous green mask (&quot;</span>
<span class="nc" id="L453">                                     + Integer.toHexString(gmask));</span>
        }
<span class="nc bnc" id="L455" title="All 2 branches missed.">        else if (arr[2] &lt; 0) {</span>
<span class="nc" id="L456">            throw new IllegalArgumentException(&quot;Noncontiguous blue mask (&quot;</span>
<span class="nc" id="L457">                                     + Integer.toHexString(bmask));</span>
        }
<span class="nc bnc" id="L459" title="All 2 branches missed.">        if (amask != 0) {</span>
<span class="nc" id="L460">            arr[3] = countBits(amask);</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">            if (arr[3] &lt; 0) {</span>
<span class="nc" id="L462">                throw new IllegalArgumentException(&quot;Noncontiguous alpha mask (&quot;</span>
<span class="nc" id="L463">                                     + Integer.toHexString(amask));</span>
            }
        }
<span class="nc" id="L466">        return arr;</span>
    }

    private final static int countBits(int mask) {
<span class="nc" id="L470">        int count = 0;</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        if (mask != 0) {</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            while ((mask &amp; 1) == 0) {</span>
<span class="nc" id="L473">                mask &gt;&gt;&gt;= 1;</span>
            }
<span class="nc bnc" id="L475" title="All 2 branches missed.">            while ((mask &amp; 1) == 1) {</span>
<span class="nc" id="L476">                mask &gt;&gt;&gt;= 1;</span>
<span class="nc" id="L477">                count++;</span>
            }
        }
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (mask != 0) {</span>
<span class="nc" id="L481">            return -1;</span>
        }
<span class="nc" id="L483">        return count;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>