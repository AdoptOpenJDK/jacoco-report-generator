<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ComponentColorModel.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">ComponentColorModel.java</span></div><h1>ComponentColorModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.color.ColorSpace;
import java.awt.color.ICC_ColorSpace;

/**
 * A &lt;CODE&gt;ColorModel&lt;/CODE&gt; class that works with pixel values that
 * represent color and alpha information as separate samples and that
 * store each sample in a separate data element.  This class can be
 * used with an arbitrary &lt;CODE&gt;ColorSpace&lt;/CODE&gt;.  The number of
 * color samples in the pixel values must be same as the number of
 * color components in the &lt;CODE&gt;ColorSpace&lt;/CODE&gt;. There may be a
 * single alpha sample.
 * &lt;p&gt;
 * For those methods that use
 * a primitive array pixel representation of type &lt;CODE&gt;transferType&lt;/CODE&gt;,
 * the array length is the same as the number of color and alpha samples.
 * Color samples are stored first in the array followed by the alpha
 * sample, if present.  The order of the color samples is specified
 * by the &lt;CODE&gt;ColorSpace&lt;/CODE&gt;.  Typically, this order reflects the
 * name of the color space type. For example, for &lt;CODE&gt;TYPE_RGB&lt;/CODE&gt;,
 * index 0 corresponds to red, index 1 to green, and index 2 to blue.
 * &lt;p&gt;
 * The translation from pixel sample values to color/alpha components for
 * display or processing purposes is based on a one-to-one correspondence of
 * samples to components.
 * Depending on the transfer type used to create an instance of
 * &lt;code&gt;ComponentColorModel&lt;/code&gt;, the pixel sample values
 * represented by that instance may be signed or unsigned and may
 * be of integral type or float or double (see below for details).
 * The translation from sample values to normalized color/alpha components
 * must follow certain rules.  For float and double samples, the translation
 * is an identity, i.e. normalized component values are equal to the
 * corresponding sample values.  For integral samples, the translation
 * should be only a simple scale and offset, where the scale and offset
 * constants may be different for each component.  The result of
 * applying the scale and offset constants is a set of color/alpha
 * component values, which are guaranteed to fall within a certain
 * range.  Typically, the range for a color component will be the range
 * defined by the &lt;code&gt;getMinValue&lt;/code&gt; and &lt;code&gt;getMaxValue&lt;/code&gt;
 * methods of the &lt;code&gt;ColorSpace&lt;/code&gt; class.  The range for an
 * alpha component should be 0.0 to 1.0.
 * &lt;p&gt;
 * Instances of &lt;code&gt;ComponentColorModel&lt;/code&gt; created with transfer types
 * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
 * and &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt; have pixel sample values which
 * are treated as unsigned integral values.
 * The number of bits in a color or alpha sample of a pixel value might not
 * be the same as the number of bits for the corresponding color or alpha
 * sample passed to the
 * &lt;code&gt;ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)&lt;/code&gt;
 * constructor.  In
 * that case, this class assumes that the least significant n bits of a sample
 * value hold the component value, where n is the number of significant bits
 * for the component passed to the constructor.  It also assumes that
 * any higher-order bits in a sample value are zero.  Thus, sample values
 * range from 0 to 2&lt;sup&gt;n&lt;/sup&gt; - 1.  This class maps these sample values
 * to normalized color component values such that 0 maps to the value
 * obtained from the &lt;code&gt;ColorSpace's&lt;/code&gt; &lt;code&gt;getMinValue&lt;/code&gt;
 * method for each component and 2&lt;sup&gt;n&lt;/sup&gt; - 1 maps to the value
 * obtained from &lt;code&gt;getMaxValue&lt;/code&gt;.  To create a
 * &lt;code&gt;ComponentColorModel&lt;/code&gt; with a different color sample mapping
 * requires subclassing this class and overriding the
 * &lt;code&gt;getNormalizedComponents(Object, float[], int)&lt;/code&gt; method.
 * The mapping for an alpha sample always maps 0 to 0.0 and
 * 2&lt;sup&gt;n&lt;/sup&gt; - 1 to 1.0.
 * &lt;p&gt;
 * For instances with unsigned sample values,
 * the unnormalized color/alpha component representation is only
 * supported if two conditions hold.  First, sample value value 0 must
 * map to normalized component value 0.0 and sample value 2&lt;sup&gt;n&lt;/sup&gt; - 1
 * to 1.0.  Second the min/max range of all color components of the
 * &lt;code&gt;ColorSpace&lt;/code&gt; must be 0.0 to 1.0.  In this case, the
 * component representation is the n least
 * significant bits of the corresponding sample.  Thus each component is
 * an unsigned integral value between 0 and 2&lt;sup&gt;n&lt;/sup&gt; - 1, where
 * n is the number of significant bits for a particular component.
 * If these conditions are not met, any method taking an unnormalized
 * component argument will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt;.
 * &lt;p&gt;
 * Instances of &lt;code&gt;ComponentColorModel&lt;/code&gt; created with transfer types
 * &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, and
 * &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt; have pixel sample values which
 * are treated as signed short, float, or double values.
 * Such instances do not support the unnormalized color/alpha component
 * representation, so any methods taking such a representation as an argument
 * will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; when called on one
 * of these instances.  The normalized component values of instances
 * of this class have a range which depends on the transfer
 * type as follows: for float samples, the full range of the float data
 * type; for double samples, the full range of the float data type
 * (resulting from casting double to float); for short samples,
 * from approximately -maxVal to +maxVal, where maxVal is the per
 * component maximum value for the &lt;code&gt;ColorSpace&lt;/code&gt;
 * (-32767 maps to -maxVal, 0 maps to 0.0, and 32767 maps
 * to +maxVal).  A subclass may override the scaling for short sample
 * values to normalized component values by overriding the
 * &lt;code&gt;getNormalizedComponents(Object, float[], int)&lt;/code&gt; method.
 * For float and double samples, the normalized component values are
 * taken to be equal to the corresponding sample values, and subclasses
 * should not attempt to add any non-identity scaling for these transfer
 * types.
 * &lt;p&gt;
 * Instances of &lt;code&gt;ComponentColorModel&lt;/code&gt; created with transfer types
 * &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, and
 * &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;
 * use all the bits of all sample values.  Thus all color/alpha components
 * have 16 bits when using &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;, 32 bits when
 * using &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, and 64 bits when using
 * &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.  When the
 * &lt;code&gt;ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)&lt;/code&gt;
 * form of constructor is used with one of these transfer types, the
 * bits array argument is ignored.
 * &lt;p&gt;
 * It is possible to have color/alpha sample values
 * which cannot be reasonably interpreted as component values for rendering.
 * This can happen when &lt;code&gt;ComponentColorModel&lt;/code&gt; is subclassed to
 * override the mapping of unsigned sample values to normalized color
 * component values or when signed sample values outside a certain range
 * are used.  (As an example, specifying an alpha component as a signed
 * short value outside the range 0 to 32767, normalized range 0.0 to 1.0, can
 * lead to unexpected results.) It is the
 * responsibility of applications to appropriately scale pixel data before
 * rendering such that color components fall within the normalized range
 * of the &lt;code&gt;ColorSpace&lt;/code&gt; (obtained using the &lt;code&gt;getMinValue&lt;/code&gt;
 * and &lt;code&gt;getMaxValue&lt;/code&gt; methods of the &lt;code&gt;ColorSpace&lt;/code&gt; class)
 * and the alpha component is between 0.0 and 1.0.  If color or alpha
 * component values fall outside these ranges, rendering results are
 * indeterminate.
 * &lt;p&gt;
 * Methods that use a single int pixel representation throw
 * an &lt;CODE&gt;IllegalArgumentException&lt;/CODE&gt;, unless the number of components
 * for the &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt; is one and the component
 * value is unsigned -- in other words,  a single color component using
 * a transfer type of &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;,
 * &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;, or &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;
 * and no alpha.
 * &lt;p&gt;
 * A &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt; can be used in conjunction with a
 * &lt;CODE&gt;ComponentSampleModel&lt;/CODE&gt;, a &lt;CODE&gt;BandedSampleModel&lt;/CODE&gt;,
 * or a &lt;CODE&gt;PixelInterleavedSampleModel&lt;/CODE&gt; to construct a
 * &lt;CODE&gt;BufferedImage&lt;/CODE&gt;.
 *
 * @see ColorModel
 * @see ColorSpace
 * @see ComponentSampleModel
 * @see BandedSampleModel
 * @see PixelInterleavedSampleModel
 * @see BufferedImage
 *
 */
public class ComponentColorModel extends ColorModel {

    /**
     * &lt;code&gt;signed&lt;/code&gt;  is &lt;code&gt;true&lt;/code&gt; for &lt;code&gt;short&lt;/code&gt;,
     * &lt;code&gt;float&lt;/code&gt;, and &lt;code&gt;double&lt;/code&gt; transfer types; it
     * is &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;,
     * and &lt;code&gt;int&lt;/code&gt; transfer types.
     */
    private boolean signed; // true for transfer types short, float, double
                            // false for byte, ushort, int
    private boolean is_sRGB_stdScale;
    private boolean is_LinearRGB_stdScale;
    private boolean is_LinearGray_stdScale;
    private boolean is_ICCGray_stdScale;
    private byte[] tosRGB8LUT;
    private byte[] fromsRGB8LUT8;
    private short[] fromsRGB8LUT16;
    private byte[] fromLinearGray16ToOtherGray8LUT;
    private short[] fromLinearGray16ToOtherGray16LUT;
    private boolean needScaleInit;
    private boolean noUnnorm;
    private boolean nonStdScale;
    private float[] min;
    private float[] diffMinMax;
    private float[] compOffset;
    private float[] compScale;

    /**
     * Constructs a &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt; from the specified
     * parameters. Color components will be in the specified
     * &lt;CODE&gt;ColorSpace&lt;/CODE&gt;.  The supported transfer types are
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;,
     * and &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.
     * If not null, the &lt;CODE&gt;bits&lt;/CODE&gt; array specifies the
     * number of significant bits per color and alpha component and its
     * length should be at least the number of components in the
     * &lt;CODE&gt;ColorSpace&lt;/CODE&gt; if there is no alpha
     * information in the pixel values, or one more than this number if
     * there is alpha information.  When the &lt;CODE&gt;transferType&lt;/CODE&gt; is
     * &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;,
     * or &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt; the &lt;CODE&gt;bits&lt;/CODE&gt; array
     * argument is ignored.  &lt;CODE&gt;hasAlpha&lt;/CODE&gt; indicates whether alpha
     * information is present.  If &lt;CODE&gt;hasAlpha&lt;/CODE&gt; is true, then
     * the boolean &lt;CODE&gt;isAlphaPremultiplied&lt;/CODE&gt;
     * specifies how to interpret color and alpha samples in pixel values.
     * If the boolean is true, color samples are assumed to have been
     * multiplied by the alpha sample. The &lt;CODE&gt;transparency&lt;/CODE&gt;
     * specifies what alpha values can be represented by this color model.
     * The acceptable &lt;code&gt;transparency&lt;/code&gt; values are
     * &lt;CODE&gt;OPAQUE&lt;/CODE&gt;, &lt;CODE&gt;BITMASK&lt;/CODE&gt; or &lt;CODE&gt;TRANSLUCENT&lt;/CODE&gt;.
     * The &lt;CODE&gt;transferType&lt;/CODE&gt; is the type of primitive array used
     * to represent pixel values.
     *
     * @param colorSpace       The &lt;CODE&gt;ColorSpace&lt;/CODE&gt; associated
     *                         with this color model.
     * @param bits             The number of significant bits per component.
     *                         May be null, in which case all bits of all
     *                         component samples will be significant.
     *                         Ignored if transferType is one of
     *                         &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;,
     *                         &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, or
     *                         &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;,
     *                         in which case all bits of all component
     *                         samples will be significant.
     * @param hasAlpha         If true, this color model supports alpha.
     * @param isAlphaPremultiplied If true, alpha is premultiplied.
     * @param transparency     Specifies what alpha values can be represented
     *                         by this color model.
     * @param transferType     Specifies the type of primitive array used to
     *                         represent pixel values.
     *
     * @throws IllegalArgumentException If the &lt;CODE&gt;bits&lt;/CODE&gt; array
     *         argument is not null, its length is less than the number of
     *         color and alpha components, and transferType is one of
     *         &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;,
     *         &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;, or
     *         &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;.
     * @throws IllegalArgumentException If transferType is not one of
     *         &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;,
     *         &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     *         &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;,
     *         &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;,
     *         &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, or
     *         &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.
     *
     * @see ColorSpace
     * @see java.awt.Transparency
     */
    public ComponentColorModel (ColorSpace colorSpace,
                                int[] bits,
                                boolean hasAlpha,
                                boolean isAlphaPremultiplied,
                                int transparency,
                                int transferType) {
<span class="nc" id="L273">        super (bitsHelper(transferType, colorSpace, hasAlpha),</span>
<span class="nc" id="L274">               bitsArrayHelper(bits, transferType, colorSpace, hasAlpha),</span>
               colorSpace, hasAlpha, isAlphaPremultiplied, transparency,
               transferType);
<span class="nc bnc" id="L277" title="All 4 branches missed.">        switch(transferType) {</span>
            case DataBuffer.TYPE_BYTE:
            case DataBuffer.TYPE_USHORT:
            case DataBuffer.TYPE_INT:
<span class="nc" id="L281">                signed = false;</span>
<span class="nc" id="L282">                needScaleInit = true;</span>
<span class="nc" id="L283">                break;</span>
            case DataBuffer.TYPE_SHORT:
<span class="nc" id="L285">                signed = true;</span>
<span class="nc" id="L286">                needScaleInit = true;</span>
<span class="nc" id="L287">                break;</span>
            case DataBuffer.TYPE_FLOAT:
            case DataBuffer.TYPE_DOUBLE:
<span class="nc" id="L290">                signed = true;</span>
<span class="nc" id="L291">                needScaleInit = false;</span>
<span class="nc" id="L292">                noUnnorm = true;</span>
<span class="nc" id="L293">                nonStdScale = false;</span>
<span class="nc" id="L294">                break;</span>
            default:
<span class="nc" id="L296">                throw new IllegalArgumentException(&quot;This constructor is not &quot;+</span>
                         &quot;compatible with transferType &quot; + transferType);
        }
<span class="nc" id="L299">        setupLUTs();</span>
<span class="nc" id="L300">    }</span>

    /**
     * Constructs a &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt; from the specified
     * parameters. Color components will be in the specified
     * &lt;CODE&gt;ColorSpace&lt;/CODE&gt;.  The supported transfer types are
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;,
     * and &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.  The number of significant
     * bits per color and alpha component will be 8, 16, 32, 16, 32,  or 64,
     * respectively.  The number of color components will be the
     * number of components in the &lt;CODE&gt;ColorSpace&lt;/CODE&gt;.  There will be
     * an alpha component if &lt;CODE&gt;hasAlpha&lt;/CODE&gt; is &lt;CODE&gt;true&lt;/CODE&gt;.
     * If &lt;CODE&gt;hasAlpha&lt;/CODE&gt; is true, then
     * the boolean &lt;CODE&gt;isAlphaPremultiplied&lt;/CODE&gt;
     * specifies how to interpret color and alpha samples in pixel values.
     * If the boolean is true, color samples are assumed to have been
     * multiplied by the alpha sample. The &lt;CODE&gt;transparency&lt;/CODE&gt;
     * specifies what alpha values can be represented by this color model.
     * The acceptable &lt;code&gt;transparency&lt;/code&gt; values are
     * &lt;CODE&gt;OPAQUE&lt;/CODE&gt;, &lt;CODE&gt;BITMASK&lt;/CODE&gt; or &lt;CODE&gt;TRANSLUCENT&lt;/CODE&gt;.
     * The &lt;CODE&gt;transferType&lt;/CODE&gt; is the type of primitive array used
     * to represent pixel values.
     *
     * @param colorSpace       The &lt;CODE&gt;ColorSpace&lt;/CODE&gt; associated
     *                         with this color model.
     * @param hasAlpha         If true, this color model supports alpha.
     * @param isAlphaPremultiplied If true, alpha is premultiplied.
     * @param transparency     Specifies what alpha values can be represented
     *                         by this color model.
     * @param transferType     Specifies the type of primitive array used to
     *                         represent pixel values.
     *
     * @throws IllegalArgumentException If transferType is not one of
     *         &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;,
     *         &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     *         &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;,
     *         &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;,
     *         &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, or
     *         &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.
     *
     * @see ColorSpace
     * @see java.awt.Transparency
     * @since 1.4
     */
    public ComponentColorModel (ColorSpace colorSpace,
                                boolean hasAlpha,
                                boolean isAlphaPremultiplied,
                                int transparency,
                                int transferType) {
<span class="nc" id="L351">        this(colorSpace, null, hasAlpha, isAlphaPremultiplied,</span>
             transparency, transferType);
<span class="nc" id="L353">    }</span>

    private static int bitsHelper(int transferType,
                                  ColorSpace colorSpace,
                                  boolean hasAlpha) {
<span class="nc" id="L358">        int numBits = DataBuffer.getDataTypeSize(transferType);</span>
<span class="nc" id="L359">        int numComponents = colorSpace.getNumComponents();</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (hasAlpha) {</span>
<span class="nc" id="L361">            ++numComponents;</span>
        }
<span class="nc" id="L363">        return numBits * numComponents;</span>
    }

    private static int[] bitsArrayHelper(int[] origBits,
                                         int transferType,
                                         ColorSpace colorSpace,
                                         boolean hasAlpha) {
<span class="nc bnc" id="L370" title="All 2 branches missed.">        switch(transferType) {</span>
            case DataBuffer.TYPE_BYTE:
            case DataBuffer.TYPE_USHORT:
            case DataBuffer.TYPE_INT:
<span class="nc bnc" id="L374" title="All 2 branches missed.">                if (origBits != null) {</span>
<span class="nc" id="L375">                    return origBits;</span>
                }
                break;
            default:
                break;
        }
<span class="nc" id="L381">        int numBits = DataBuffer.getDataTypeSize(transferType);</span>
<span class="nc" id="L382">        int numComponents = colorSpace.getNumComponents();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (hasAlpha) {</span>
<span class="nc" id="L384">            ++numComponents;</span>
        }
<span class="nc" id="L386">        int[] bits = new int[numComponents];</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        for (int i = 0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L388">            bits[i] = numBits;</span>
        }
<span class="nc" id="L390">        return bits;</span>
    }

    private void setupLUTs() {
        // REMIND: there is potential to accelerate sRGB, LinearRGB,
        // LinearGray, ICCGray, and non-ICC Gray spaces with non-standard
        // scaling, if that becomes important
        //
        // NOTE: The is_xxx_stdScale and nonStdScale booleans are provisionally
        // set here when this method is called at construction time.  These
        // variables may be set again when initScale is called later.
        // When setupLUTs returns, nonStdScale is true if (the transferType
        // is not float or double) AND (some minimum ColorSpace component
        // value is not 0.0 OR some maximum ColorSpace component value
        // is not 1.0).  This is correct for the calls to
        // getNormalizedComponents(Object, float[], int) from initScale().
        // initScale() may change the value nonStdScale based on the
        // return value of getNormalizedComponents() - this will only
        // happen if getNormalizedComponents() has been overridden by a
        // subclass to make the mapping of min/max pixel sample values
        // something different from min/max color component values.
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (is_sRGB) {</span>
<span class="nc" id="L412">            is_sRGB_stdScale = true;</span>
<span class="nc" id="L413">            nonStdScale = false;</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        } else if (ColorModel.isLinearRGBspace(colorSpace)) {</span>
            // Note that the built-in Linear RGB space has a normalized
            // range of 0.0 - 1.0 for each coordinate.  Usage of these
            // LUTs makes that assumption.
<span class="nc" id="L418">            is_LinearRGB_stdScale = true;</span>
<span class="nc" id="L419">            nonStdScale = false;</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (transferType == DataBuffer.TYPE_BYTE) {</span>
<span class="nc" id="L421">                tosRGB8LUT = ColorModel.getLinearRGB8TosRGB8LUT();</span>
<span class="nc" id="L422">                fromsRGB8LUT8 = ColorModel.getsRGB8ToLinearRGB8LUT();</span>
            } else {
<span class="nc" id="L424">                tosRGB8LUT = ColorModel.getLinearRGB16TosRGB8LUT();</span>
<span class="nc" id="L425">                fromsRGB8LUT16 = ColorModel.getsRGB8ToLinearRGB16LUT();</span>
            }
<span class="nc bnc" id="L427" title="All 4 branches missed.">        } else if ((colorSpaceType == ColorSpace.TYPE_GRAY) &amp;&amp;</span>
                   (colorSpace instanceof ICC_ColorSpace) &amp;&amp;
<span class="nc bnc" id="L429" title="All 2 branches missed.">                   (colorSpace.getMinValue(0) == 0.0f) &amp;&amp;</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">                   (colorSpace.getMaxValue(0) == 1.0f)) {</span>
            // Note that a normalized range of 0.0 - 1.0 for the gray
            // component is required, because usage of these LUTs makes
            // that assumption.
<span class="nc" id="L434">            ICC_ColorSpace ics = (ICC_ColorSpace) colorSpace;</span>
<span class="nc" id="L435">            is_ICCGray_stdScale = true;</span>
<span class="nc" id="L436">            nonStdScale = false;</span>
<span class="nc" id="L437">            fromsRGB8LUT16 = ColorModel.getsRGB8ToLinearRGB16LUT();</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (ColorModel.isLinearGRAYspace(ics)) {</span>
<span class="nc" id="L439">                is_LinearGray_stdScale = true;</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">                if (transferType == DataBuffer.TYPE_BYTE) {</span>
<span class="nc" id="L441">                    tosRGB8LUT = ColorModel.getGray8TosRGB8LUT(ics);</span>
                } else {
<span class="nc" id="L443">                    tosRGB8LUT = ColorModel.getGray16TosRGB8LUT(ics);</span>
                }
            } else {
<span class="nc bnc" id="L446" title="All 2 branches missed.">                if (transferType == DataBuffer.TYPE_BYTE) {</span>
<span class="nc" id="L447">                    tosRGB8LUT = ColorModel.getGray8TosRGB8LUT(ics);</span>
<span class="nc" id="L448">                    fromLinearGray16ToOtherGray8LUT =</span>
<span class="nc" id="L449">                        ColorModel.getLinearGray16ToOtherGray8LUT(ics);</span>
                } else {
<span class="nc" id="L451">                    tosRGB8LUT = ColorModel.getGray16TosRGB8LUT(ics);</span>
<span class="nc" id="L452">                    fromLinearGray16ToOtherGray16LUT =</span>
<span class="nc" id="L453">                        ColorModel.getLinearGray16ToOtherGray16LUT(ics);</span>
                }
            }
<span class="nc bnc" id="L456" title="All 2 branches missed.">        } else if (needScaleInit) {</span>
            // if transferType is byte, ushort, int, or short and we
            // don't already know the ColorSpace has minVlaue == 0.0f and
            // maxValue == 1.0f for all components, we need to check that
            // now and setup the min[] and diffMinMax[] arrays if necessary.
<span class="nc" id="L461">            nonStdScale = false;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">            for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                if ((colorSpace.getMinValue(i) != 0.0f) ||</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                    (colorSpace.getMaxValue(i) != 1.0f)) {</span>
<span class="nc" id="L465">                    nonStdScale = true;</span>
<span class="nc" id="L466">                    break;</span>
                }
            }
<span class="nc bnc" id="L469" title="All 2 branches missed.">            if (nonStdScale) {</span>
<span class="nc" id="L470">                min = new float[numColorComponents];</span>
<span class="nc" id="L471">                diffMinMax = new float[numColorComponents];</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L473">                    min[i] = colorSpace.getMinValue(i);</span>
<span class="nc" id="L474">                    diffMinMax[i] = colorSpace.getMaxValue(i) - min[i];</span>
                }
            }
        }
<span class="nc" id="L478">    }</span>

    private void initScale() {
        // This method is called the first time any method which uses
        // pixel sample value to color component value scaling information
        // is called if the transferType supports non-standard scaling
        // as defined above (byte, ushort, int, and short), unless the
        // method is getNormalizedComponents(Object, float[], int) (that
        // method must be overridden to use non-standard scaling).  This
        // method also sets up the noUnnorm boolean variable for these
        // transferTypes.  After this method is called, the nonStdScale
        // variable will be true if getNormalizedComponents() maps a
        // sample value of 0 to anything other than 0.0f OR maps a
        // sample value of 2^^n - 1 (2^^15 - 1 for short transferType)
        // to anything other than 1.0f.  Note that this can be independent
        // of the colorSpace min/max component values, if the
        // getNormalizedComponents() method has been overridden for some
        // reason, e.g. to provide greater dynamic range in the sample
        // values than in the color component values.  Unfortunately,
        // this method can't be called at construction time, since a
        // subclass may still have uninitialized state that would cause
        // getNormalizedComponents() to return an incorrect result.
<span class="nc" id="L500">        needScaleInit = false; // only needs to called once</span>
<span class="nc bnc" id="L501" title="All 4 branches missed.">        if (nonStdScale || signed) {</span>
            // The unnormalized form is only supported for unsigned
            // transferTypes and when the ColorSpace min/max values
            // are 0.0/1.0.  When this method is called nonStdScale is
            // true if the latter condition does not hold.  In addition,
            // the unnormalized form requires that the full range of
            // the pixel sample values map to the full 0.0 - 1.0 range
            // of color component values.  That condition is checked
            // later in this method.
<span class="nc" id="L510">            noUnnorm = true;</span>
        } else {
<span class="nc" id="L512">            noUnnorm = false;</span>
        }
        float[] lowVal, highVal;
<span class="nc bnc" id="L515" title="All 5 branches missed.">        switch (transferType) {</span>
        case DataBuffer.TYPE_BYTE:
            {
<span class="nc" id="L518">                byte[] bpixel = new byte[numComponents];</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L520">                    bpixel[i] = 0;</span>
                }
<span class="nc bnc" id="L522" title="All 2 branches missed.">                if (supportsAlpha) {</span>
<span class="nc" id="L523">                    bpixel[numColorComponents] =</span>
                        (byte) ((1 &lt;&lt; nBits[numColorComponents]) - 1);
                }
<span class="nc" id="L526">                lowVal = getNormalizedComponents(bpixel, null, 0);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L528">                    bpixel[i] = (byte) ((1 &lt;&lt; nBits[i]) - 1);</span>
                }
<span class="nc" id="L530">                highVal = getNormalizedComponents(bpixel, null, 0);</span>
            }
<span class="nc" id="L532">            break;</span>
        case DataBuffer.TYPE_USHORT:
            {
<span class="nc" id="L535">                short[] uspixel = new short[numComponents];</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L537">                    uspixel[i] = 0;</span>
                }
<span class="nc bnc" id="L539" title="All 2 branches missed.">                if (supportsAlpha) {</span>
<span class="nc" id="L540">                    uspixel[numColorComponents] =</span>
                        (short) ((1 &lt;&lt; nBits[numColorComponents]) - 1);
                }
<span class="nc" id="L543">                lowVal = getNormalizedComponents(uspixel, null, 0);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L545">                    uspixel[i] = (short) ((1 &lt;&lt; nBits[i]) - 1);</span>
                }
<span class="nc" id="L547">                highVal = getNormalizedComponents(uspixel, null, 0);</span>
            }
<span class="nc" id="L549">            break;</span>
        case DataBuffer.TYPE_INT:
            {
<span class="nc" id="L552">                int[] ipixel = new int[numComponents];</span>
<span class="nc bnc" id="L553" title="All 2 branches missed.">                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L554">                    ipixel[i] = 0;</span>
                }
<span class="nc bnc" id="L556" title="All 2 branches missed.">                if (supportsAlpha) {</span>
<span class="nc" id="L557">                    ipixel[numColorComponents] =</span>
                        ((1 &lt;&lt; nBits[numColorComponents]) - 1);
                }
<span class="nc" id="L560">                lowVal = getNormalizedComponents(ipixel, null, 0);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L562">                    ipixel[i] = ((1 &lt;&lt; nBits[i]) - 1);</span>
                }
<span class="nc" id="L564">                highVal = getNormalizedComponents(ipixel, null, 0);</span>
            }
<span class="nc" id="L566">            break;</span>
        case DataBuffer.TYPE_SHORT:
            {
<span class="nc" id="L569">                short[] spixel = new short[numComponents];</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L571">                    spixel[i] = 0;</span>
                }
<span class="nc bnc" id="L573" title="All 2 branches missed.">                if (supportsAlpha) {</span>
<span class="nc" id="L574">                    spixel[numColorComponents] = 32767;</span>
                }
<span class="nc" id="L576">                lowVal = getNormalizedComponents(spixel, null, 0);</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L578">                    spixel[i] = 32767;</span>
                }
<span class="nc" id="L580">                highVal = getNormalizedComponents(spixel, null, 0);</span>
            }
<span class="nc" id="L582">            break;</span>
        default:
<span class="nc" id="L584">            lowVal = highVal = null;  // to keep the compiler from complaining</span>
            break;
        }
<span class="nc" id="L587">        nonStdScale = false;</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">        for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc bnc" id="L589" title="All 4 branches missed.">            if ((lowVal[i] != 0.0f) || (highVal[i] != 1.0f)) {</span>
<span class="nc" id="L590">                nonStdScale = true;</span>
<span class="nc" id="L591">                break;</span>
            }
        }
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (nonStdScale) {</span>
<span class="nc" id="L595">            noUnnorm = true;</span>
<span class="nc" id="L596">            is_sRGB_stdScale = false;</span>
<span class="nc" id="L597">            is_LinearRGB_stdScale = false;</span>
<span class="nc" id="L598">            is_LinearGray_stdScale = false;</span>
<span class="nc" id="L599">            is_ICCGray_stdScale = false;</span>
<span class="nc" id="L600">            compOffset = new float[numColorComponents];</span>
<span class="nc" id="L601">            compScale = new float[numColorComponents];</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">            for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L603">                compOffset[i] = lowVal[i];</span>
<span class="nc" id="L604">                compScale[i] = 1.0f / (highVal[i] - lowVal[i]);</span>
            }
        }
<span class="nc" id="L607">    }</span>

    private int getRGBComponent(int pixel, int idx) {
<span class="nc bnc" id="L610" title="All 2 branches missed.">        if (numComponents &gt; 1) {</span>
<span class="nc" id="L611">            throw new</span>
                IllegalArgumentException(&quot;More than one component per pixel&quot;);
        }
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (signed) {</span>
<span class="nc" id="L615">            throw new</span>
                IllegalArgumentException(&quot;Component value is signed&quot;);
        }
<span class="nc bnc" id="L618" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L619">            initScale();</span>
        }
        // Since there is only 1 component, there is no alpha

        // Normalize the pixel in order to convert it
<span class="nc" id="L624">        Object opixel = null;</span>
<span class="nc bnc" id="L625" title="All 4 branches missed.">        switch (transferType) {</span>
        case DataBuffer.TYPE_BYTE:
            {
<span class="nc" id="L628">                byte[] bpixel = { (byte) pixel };</span>
<span class="nc" id="L629">                opixel = bpixel;</span>
            }
<span class="nc" id="L631">            break;</span>
        case DataBuffer.TYPE_USHORT:
            {
<span class="nc" id="L634">                short[] spixel = { (short) pixel };</span>
<span class="nc" id="L635">                opixel = spixel;</span>
            }
<span class="nc" id="L637">            break;</span>
        case DataBuffer.TYPE_INT:
            {
<span class="nc" id="L640">                int[] ipixel = { pixel };</span>
<span class="nc" id="L641">                opixel = ipixel;</span>
            }
            break;
        }
<span class="nc" id="L645">        float[] norm = getNormalizedComponents(opixel, null, 0);</span>
<span class="nc" id="L646">        float[] rgb = colorSpace.toRGB(norm);</span>

<span class="nc" id="L648">        return (int) (rgb[idx] * 255.0f + 0.5f);</span>
    }

    /**
     * Returns the red color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion
     * is done if necessary.  The pixel value is specified as an int.
     * The returned value will be a non pre-multiplied value.
     * If the alpha is premultiplied, this method divides
     * it out before returning the value (if the alpha value is 0,
     * the red value will be 0).
     *
     * @param pixel The pixel from which you want to get the red color component.
     *
     * @return The red color component for the specified pixel, as an int.
     *
     * @throws IllegalArgumentException If there is more than
     * one component in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws IllegalArgumentException If the component value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; is signed
     */
    public int getRed(int pixel) {
<span class="nc" id="L670">        return getRGBComponent(pixel, 0);</span>
    }

    /**
     * Returns the green color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion
     * is done if necessary.  The pixel value is specified as an int.
     * The returned value will be a non
     * pre-multiplied value. If the alpha is premultiplied, this method
     * divides it out before returning the value (if the alpha value is 0,
     * the green value will be 0).
     *
     * @param pixel The pixel from which you want to get the green color component.
     *
     * @return The green color component for the specified pixel, as an int.
     *
     * @throws IllegalArgumentException If there is more than
     * one component in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws IllegalArgumentException If the component value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; is signed
     */
    public int getGreen(int pixel) {
<span class="nc" id="L692">        return getRGBComponent(pixel, 1);</span>
    }

    /**
     * Returns the blue color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion
     * is done if necessary.  The pixel value is specified as an int.
     * The returned value will be a non
     * pre-multiplied value. If the alpha is premultiplied, this method
     * divides it out before returning the value (if the alpha value is 0,
     * the blue value will be 0).
     *
     * @param pixel The pixel from which you want to get the blue color component.
     *
     * @return The blue color component for the specified pixel, as an int.
     *
     * @throws IllegalArgumentException If there is more than
     * one component in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws IllegalArgumentException If the component value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; is signed
     */
    public int getBlue(int pixel) {
<span class="nc" id="L714">        return getRGBComponent(pixel, 2);</span>
    }

    /**
     * Returns the alpha component for the specified pixel, scaled
     * from 0 to 255.   The pixel value is specified as an int.
     *
     * @param pixel The pixel from which you want to get the alpha component.
     *
     * @return The alpha component for the specified pixel, as an int.
     *
     * @throws IllegalArgumentException If there is more than
     * one component in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws IllegalArgumentException If the component value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; is signed
     */
    public int getAlpha(int pixel) {
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (supportsAlpha == false) {</span>
<span class="nc" id="L732">            return 255;</span>
        }
<span class="nc bnc" id="L734" title="All 2 branches missed.">        if (numComponents &gt; 1) {</span>
<span class="nc" id="L735">            throw new</span>
                IllegalArgumentException(&quot;More than one component per pixel&quot;);
        }
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (signed) {</span>
<span class="nc" id="L739">            throw new</span>
                IllegalArgumentException(&quot;Component value is signed&quot;);
        }

<span class="nc" id="L743">        return (int) ((((float) pixel) / ((1&lt;&lt;nBits[0])-1)) * 255.0f + 0.5f);</span>
    }

    /**
     * Returns the color/alpha components of the pixel in the default
     * RGB color model format.  A color conversion is done if necessary.
     * The returned value will be in a non pre-multiplied format. If
     * the alpha is premultiplied, this method divides it out of the
     * color components (if the alpha value is 0, the color values will be 0).
     *
     * @param pixel The pixel from which you want to get the color/alpha components.
     *
     * @return The color/alpha components for the specified pixel, as an int.
     *
     * @throws IllegalArgumentException If there is more than
     * one component in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws IllegalArgumentException If the component value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; is signed
     */
    public int getRGB(int pixel) {
<span class="nc bnc" id="L763" title="All 2 branches missed.">        if (numComponents &gt; 1) {</span>
<span class="nc" id="L764">            throw new</span>
                IllegalArgumentException(&quot;More than one component per pixel&quot;);
        }
<span class="nc bnc" id="L767" title="All 2 branches missed.">        if (signed) {</span>
<span class="nc" id="L768">            throw new</span>
                IllegalArgumentException(&quot;Component value is signed&quot;);
        }

<span class="nc" id="L772">        return (getAlpha(pixel) &lt;&lt; 24)</span>
<span class="nc" id="L773">            | (getRed(pixel) &lt;&lt; 16)</span>
<span class="nc" id="L774">            | (getGreen(pixel) &lt;&lt; 8)</span>
<span class="nc" id="L775">            | (getBlue(pixel) &lt;&lt; 0);</span>
    }

    private int extractComponent(Object inData, int idx, int precision) {
        // Extract component idx from inData.  The precision argument
        // should be either 8 or 16.  If it's 8, this method will return
        // an 8-bit value.  If it's 16, this method will return a 16-bit
        // value for transferTypes other than TYPE_BYTE.  For TYPE_BYTE,
        // an 8-bit value will be returned.

        // This method maps the input value corresponding to a
        // normalized ColorSpace component value of 0.0 to 0, and the
        // input value corresponding to a normalized ColorSpace
        // component value of 1.0 to 2^n - 1 (where n is 8 or 16), so
        // it is appropriate only for ColorSpaces with min/max component
        // values of 0.0/1.0.  This will be true for sRGB, the built-in
        // Linear RGB and Linear Gray spaces, and any other ICC grayscale
        // spaces for which we have precomputed LUTs.

<span class="nc bnc" id="L794" title="All 4 branches missed.">        boolean needAlpha = (supportsAlpha &amp;&amp; isAlphaPremultiplied);</span>
<span class="nc" id="L795">        int alp = 0;</span>
        int comp;
<span class="nc" id="L797">        int mask = (1 &lt;&lt; nBits[idx]) - 1;</span>

<span class="nc bnc" id="L799" title="All 7 branches missed.">        switch (transferType) {</span>
            // Note: we do no clamping of the pixel data here - we
            // assume that the data is scaled properly
            case DataBuffer.TYPE_SHORT: {
<span class="nc" id="L803">                short sdata[] = (short[]) inData;</span>
<span class="nc" id="L804">                float scalefactor = (float) ((1 &lt;&lt; precision) - 1);</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">                if (needAlpha) {</span>
<span class="nc" id="L806">                    short s = sdata[numColorComponents];</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">                    if (s != (short) 0) {</span>
<span class="nc" id="L808">                        return (int) ((((float) sdata[idx]) /</span>
                                       ((float) s)) * scalefactor + 0.5f);
                    } else {
<span class="nc" id="L811">                        return 0;</span>
                    }
                } else {
<span class="nc" id="L814">                    return (int) ((sdata[idx] / 32767.0f) * scalefactor + 0.5f);</span>
                }
            }
            case DataBuffer.TYPE_FLOAT: {
<span class="nc" id="L818">                float fdata[] = (float[]) inData;</span>
<span class="nc" id="L819">                float scalefactor = (float) ((1 &lt;&lt; precision) - 1);</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">                if (needAlpha) {</span>
<span class="nc" id="L821">                    float f = fdata[numColorComponents];</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">                    if (f != 0.0f) {</span>
<span class="nc" id="L823">                        return (int) (((fdata[idx] / f) * scalefactor) + 0.5f);</span>
                    } else {
<span class="nc" id="L825">                        return 0;</span>
                    }
                } else {
<span class="nc" id="L828">                    return (int) (fdata[idx] * scalefactor + 0.5f);</span>
                }
            }
            case DataBuffer.TYPE_DOUBLE: {
<span class="nc" id="L832">                double ddata[] = (double[]) inData;</span>
<span class="nc" id="L833">                double scalefactor = (double) ((1 &lt;&lt; precision) - 1);</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">                if (needAlpha) {</span>
<span class="nc" id="L835">                    double d = ddata[numColorComponents];</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                    if (d != 0.0) {</span>
<span class="nc" id="L837">                        return (int) (((ddata[idx] / d) * scalefactor) + 0.5);</span>
                    } else {
<span class="nc" id="L839">                        return 0;</span>
                    }
                } else {
<span class="nc" id="L842">                    return (int) (ddata[idx] * scalefactor + 0.5);</span>
                }
            }
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L846">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L847">               comp = bdata[idx] &amp; mask;</span>
<span class="nc" id="L848">               precision = 8;</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">               if (needAlpha) {</span>
<span class="nc" id="L850">                   alp = bdata[numColorComponents] &amp; mask;</span>
               }
            break;
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L854">               short usdata[] = (short[])inData;</span>
<span class="nc" id="L855">               comp = usdata[idx] &amp; mask;</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">               if (needAlpha) {</span>
<span class="nc" id="L857">                   alp = usdata[numColorComponents] &amp; mask;</span>
               }
            break;
            case DataBuffer.TYPE_INT:
<span class="nc" id="L861">               int idata[] = (int[])inData;</span>
<span class="nc" id="L862">               comp = idata[idx];</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">               if (needAlpha) {</span>
<span class="nc" id="L864">                   alp = idata[numColorComponents];</span>
               }
            break;
            default:
<span class="nc" id="L868">               throw new</span>
                   UnsupportedOperationException(&quot;This method has not &quot;+
                   &quot;been implemented for transferType &quot; + transferType);
        }
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (needAlpha) {</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">            if (alp != 0) {</span>
<span class="nc" id="L874">                float scalefactor = (float) ((1 &lt;&lt; precision) - 1);</span>
<span class="nc" id="L875">                float fcomp = ((float) comp) / ((float)mask);</span>
<span class="nc" id="L876">                float invalp = ((float) ((1&lt;&lt;nBits[numColorComponents]) - 1)) /</span>
                               ((float) alp);
<span class="nc" id="L878">                return (int) (fcomp * invalp * scalefactor + 0.5f);</span>
            } else {
<span class="nc" id="L880">                return 0;</span>
            }
        } else {
<span class="nc bnc" id="L883" title="All 2 branches missed.">            if (nBits[idx] != precision) {</span>
<span class="nc" id="L884">                float scalefactor = (float) ((1 &lt;&lt; precision) - 1);</span>
<span class="nc" id="L885">                float fcomp = ((float) comp) / ((float)mask);</span>
<span class="nc" id="L886">                return (int) (fcomp * scalefactor + 0.5f);</span>
            }
<span class="nc" id="L888">            return comp;</span>
        }
    }

    private int getRGBComponent(Object inData, int idx) {
<span class="nc bnc" id="L893" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L894">            initScale();</span>
        }
<span class="nc bnc" id="L896" title="All 2 branches missed.">        if (is_sRGB_stdScale) {</span>
<span class="nc" id="L897">            return extractComponent(inData, idx, 8);</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">        } else if (is_LinearRGB_stdScale) {</span>
<span class="nc" id="L899">            int lutidx = extractComponent(inData, idx, 16);</span>
<span class="nc" id="L900">            return tosRGB8LUT[lutidx] &amp; 0xff;</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">        } else if (is_ICCGray_stdScale) {</span>
<span class="nc" id="L902">            int lutidx = extractComponent(inData, 0, 16);</span>
<span class="nc" id="L903">            return tosRGB8LUT[lutidx] &amp; 0xff;</span>
        }

        // Not CS_sRGB, CS_LINEAR_RGB, or any TYPE_GRAY ICC_ColorSpace
<span class="nc" id="L907">        float[] norm = getNormalizedComponents(inData, null, 0);</span>
        // Note that getNormalizedComponents returns non-premultiplied values
<span class="nc" id="L909">        float[] rgb = colorSpace.toRGB(norm);</span>
<span class="nc" id="L910">        return (int) (rgb[idx] * 255.0f + 0.5f);</span>
    }

    /**
     * Returns the red color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion
     * is done if necessary.  The &lt;CODE&gt;pixel&lt;/CODE&gt; value is specified by an array
     * of data elements of type &lt;CODE&gt;transferType&lt;/CODE&gt; passed in as an object
     * reference. The returned value will be a non pre-multiplied value. If the
     * alpha is premultiplied, this method divides it out before returning
     * the value (if the alpha value is 0, the red value will be 0). Since
     * &lt;code&gt;ComponentColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't override
     * it then they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param inData The pixel from which you want to get the red color component,
     * specified by an array of data elements of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     *
     * @return The red color component for the specified pixel, as an int.
     *
     * @throws ClassCastException If &lt;CODE&gt;inData&lt;/CODE&gt; is not a primitive array
     * of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     * @throws ArrayIndexOutOfBoundsException if &lt;CODE&gt;inData&lt;/CODE&gt; is not
     * large enough to hold a pixel value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws UnsupportedOperationException If the transfer type of
     * this &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt;
     * is not one of the supported transfer types:
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, or &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.
     */
    public int getRed(Object inData) {
<span class="nc" id="L944">        return getRGBComponent(inData, 0);</span>
    }


    /**
     * Returns the green color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;CODE&gt;ColorSpace&lt;/CODE&gt;, sRGB.
     * A color conversion is done if necessary.  The &lt;CODE&gt;pixel&lt;/CODE&gt; value
     * is specified by an array of data elements of type &lt;CODE&gt;transferType&lt;/CODE&gt;
     * passed in as an object reference. The returned value is a non pre-multiplied
     * value. If the alpha is premultiplied, this method divides it out before
     * returning the value (if the alpha value is 0, the green value will be 0).
     * Since &lt;code&gt;ComponentColorModel&lt;/code&gt; can be subclassed,
     * subclasses inherit the implementation of this method and if they
     * don't override it then they throw an exception if they use an
     * unsupported &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param inData The pixel from which you want to get the green color component,
     * specified by an array of data elements of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     *
     * @return The green color component for the specified pixel, as an int.
     *
     * @throws ClassCastException If &lt;CODE&gt;inData&lt;/CODE&gt; is not a primitive array
     * of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     * @throws ArrayIndexOutOfBoundsException if &lt;CODE&gt;inData&lt;/CODE&gt; is not
     * large enough to hold a pixel value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws UnsupportedOperationException If the transfer type of
     * this &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt;
     * is not one of the supported transfer types:
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, or &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.
     */
    public int getGreen(Object inData) {
<span class="nc" id="L979">        return getRGBComponent(inData, 1);</span>
    }


    /**
     * Returns the blue color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;CODE&gt;ColorSpace&lt;/CODE&gt;, sRGB.
     * A color conversion is done if necessary.  The &lt;CODE&gt;pixel&lt;/CODE&gt; value is
     * specified by an array of data elements of type &lt;CODE&gt;transferType&lt;/CODE&gt;
     * passed in as an object reference. The returned value is a non pre-multiplied
     * value. If the alpha is premultiplied, this method divides it out before
     * returning the value (if the alpha value is 0, the blue value will be 0).
     * Since &lt;code&gt;ComponentColorModel&lt;/code&gt; can be subclassed,
     * subclasses inherit the implementation of this method and if they
     * don't override it then they throw an exception if they use an
     * unsupported &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param inData The pixel from which you want to get the blue color component,
     * specified by an array of data elements of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     *
     * @return The blue color component for the specified pixel, as an int.
     *
     * @throws ClassCastException If &lt;CODE&gt;inData&lt;/CODE&gt; is not a primitive array
     * of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     * @throws ArrayIndexOutOfBoundsException if &lt;CODE&gt;inData&lt;/CODE&gt; is not
     * large enough to hold a pixel value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws UnsupportedOperationException If the transfer type of
     * this &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt;
     * is not one of the supported transfer types:
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, or &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.
     */
    public int getBlue(Object inData) {
<span class="nc" id="L1014">        return getRGBComponent(inData, 2);</span>
    }

    /**
     * Returns the alpha component for the specified pixel, scaled from
     * 0 to 255.  The pixel value is specified by an array of data
     * elements of type &lt;CODE&gt;transferType&lt;/CODE&gt; passed in as an
     * object reference.  Since &lt;code&gt;ComponentColorModel&lt;/code&gt; can be
     * subclassed, subclasses inherit the
     * implementation of this method and if they don't override it then
     * they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param inData The pixel from which you want to get the alpha component,
     * specified by an array of data elements of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     *
     * @return The alpha component for the specified pixel, as an int.
     *
     * @throws ClassCastException If &lt;CODE&gt;inData&lt;/CODE&gt; is not a primitive array
     * of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     * @throws ArrayIndexOutOfBoundsException if &lt;CODE&gt;inData&lt;/CODE&gt; is not
     * large enough to hold a pixel value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws UnsupportedOperationException If the transfer type of
     * this &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt;
     * is not one of the supported transfer types:
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, or &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.
     */
    public int getAlpha(Object inData) {
<span class="nc bnc" id="L1045" title="All 2 branches missed.">        if (supportsAlpha == false) {</span>
<span class="nc" id="L1046">            return 255;</span>
        }

<span class="nc" id="L1049">        int alpha = 0;</span>
<span class="nc" id="L1050">        int aIdx = numColorComponents;</span>
<span class="nc" id="L1051">        int mask = (1 &lt;&lt; nBits[aIdx]) - 1;</span>

<span class="nc bnc" id="L1053" title="All 7 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_SHORT:
<span class="nc" id="L1055">                short sdata[] = (short[])inData;</span>
<span class="nc" id="L1056">                alpha = (int) ((sdata[aIdx] / 32767.0f) * 255.0f + 0.5f);</span>
<span class="nc" id="L1057">                return alpha;</span>
            case DataBuffer.TYPE_FLOAT:
<span class="nc" id="L1059">                float fdata[] = (float[])inData;</span>
<span class="nc" id="L1060">                alpha = (int) (fdata[aIdx] * 255.0f + 0.5f);</span>
<span class="nc" id="L1061">                return alpha;</span>
            case DataBuffer.TYPE_DOUBLE:
<span class="nc" id="L1063">                double ddata[] = (double[])inData;</span>
<span class="nc" id="L1064">                alpha = (int) (ddata[aIdx] * 255.0 + 0.5);</span>
<span class="nc" id="L1065">                return alpha;</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L1067">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L1068">               alpha = bdata[aIdx] &amp; mask;</span>
<span class="nc" id="L1069">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L1071">               short usdata[] = (short[])inData;</span>
<span class="nc" id="L1072">               alpha = usdata[aIdx] &amp; mask;</span>
<span class="nc" id="L1073">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L1075">               int idata[] = (int[])inData;</span>
<span class="nc" id="L1076">               alpha = idata[aIdx];</span>
<span class="nc" id="L1077">            break;</span>
            default:
<span class="nc" id="L1079">               throw new</span>
                   UnsupportedOperationException(&quot;This method has not &quot;+
                   &quot;been implemented for transferType &quot; + transferType);
        }

<span class="nc bnc" id="L1084" title="All 2 branches missed.">        if (nBits[aIdx] == 8) {</span>
<span class="nc" id="L1085">            return alpha;</span>
        } else {
<span class="nc" id="L1087">            return (int)</span>
                ((((float) alpha) / ((float) ((1 &lt;&lt; nBits[aIdx]) - 1))) *
                 255.0f + 0.5f);
        }
    }

    /**
     * Returns the color/alpha components for the specified pixel in the
     * default RGB color model format.  A color conversion is done if
     * necessary.  The pixel value is specified by an
     * array of data elements of type &lt;CODE&gt;transferType&lt;/CODE&gt; passed
     * in as an object reference.
     * The returned value is in a non pre-multiplied format. If
     * the alpha is premultiplied, this method divides it out of the
     * color components (if the alpha value is 0, the color values will be 0).
     * Since &lt;code&gt;ComponentColorModel&lt;/code&gt; can be subclassed,
     * subclasses inherit the implementation of this method and if they
     * don't override it then they throw an exception if they use an
     * unsupported &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param inData The pixel from which you want to get the color/alpha components,
     * specified by an array of data elements of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     *
     * @return The color/alpha components for the specified pixel, as an int.
     *
     * @throws ClassCastException If &lt;CODE&gt;inData&lt;/CODE&gt; is not a primitive array
     * of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     * @throws ArrayIndexOutOfBoundsException if &lt;CODE&gt;inData&lt;/CODE&gt; is not
     * large enough to hold a pixel value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws UnsupportedOperationException If the transfer type of
     * this &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt;
     * is not one of the supported transfer types:
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, or &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.
     * @see ColorModel#getRGBdefault
     */
    public int getRGB(Object inData) {
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L1127">            initScale();</span>
        }
<span class="nc bnc" id="L1129" title="All 4 branches missed.">        if (is_sRGB_stdScale || is_LinearRGB_stdScale) {</span>
<span class="nc" id="L1130">            return (getAlpha(inData) &lt;&lt; 24)</span>
<span class="nc" id="L1131">                | (getRed(inData) &lt;&lt; 16)</span>
<span class="nc" id="L1132">                | (getGreen(inData) &lt;&lt; 8)</span>
<span class="nc" id="L1133">                | (getBlue(inData));</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">        } else if (colorSpaceType == ColorSpace.TYPE_GRAY) {</span>
<span class="nc" id="L1135">            int gray = getRed(inData); // Red sRGB component should equal</span>
                                       // green and blue components
<span class="nc" id="L1137">            return (getAlpha(inData) &lt;&lt; 24)</span>
                | (gray &lt;&lt; 16)
                | (gray &lt;&lt;  8)
                | gray;
        }
<span class="nc" id="L1142">        float[] norm = getNormalizedComponents(inData, null, 0);</span>
        // Note that getNormalizedComponents returns non-premult values
<span class="nc" id="L1144">        float[] rgb = colorSpace.toRGB(norm);</span>
<span class="nc" id="L1145">        return (getAlpha(inData) &lt;&lt; 24)</span>
            | (((int) (rgb[0] * 255.0f + 0.5f)) &lt;&lt; 16)
            | (((int) (rgb[1] * 255.0f + 0.5f)) &lt;&lt; 8)
            | (((int) (rgb[2] * 255.0f + 0.5f)) &lt;&lt; 0);
    }

    /**
     * Returns a data element array representation of a pixel in this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;, given an integer pixel representation
     * in the default RGB color model.
     * This array can then be passed to the &lt;CODE&gt;setDataElements&lt;/CODE&gt;
     * method of a &lt;CODE&gt;WritableRaster&lt;/CODE&gt; object.  If the
     * &lt;CODE&gt;pixel&lt;/CODE&gt;
     * parameter is null, a new array is allocated.  Since
     * &lt;code&gt;ComponentColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then
     * they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param rgb the integer representation of the pixel in the RGB
     *            color model
     * @param pixel the specified pixel
     * @return The data element array representation of a pixel
     * in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws ClassCastException If &lt;CODE&gt;pixel&lt;/CODE&gt; is not null and
     * is not a primitive array of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     * @throws ArrayIndexOutOfBoundsException If &lt;CODE&gt;pixel&lt;/CODE&gt; is
     * not large enough to hold a pixel value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws UnsupportedOperationException If the transfer type of
     * this &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt;
     * is not one of the supported transfer types:
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, or &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.
     *
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     */
    public Object getDataElements(int rgb, Object pixel) {
        // REMIND: Use rendering hints?

        int red, grn, blu, alp;
<span class="nc" id="L1189">        red = (rgb&gt;&gt;16) &amp; 0xff;</span>
<span class="nc" id="L1190">        grn = (rgb&gt;&gt;8) &amp; 0xff;</span>
<span class="nc" id="L1191">        blu = rgb &amp; 0xff;</span>

<span class="nc bnc" id="L1193" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L1194">            initScale();</span>
        }
<span class="nc bnc" id="L1196" title="All 2 branches missed.">        if (signed) {</span>
            // Handle SHORT, FLOAT, &amp; DOUBLE here

<span class="nc bnc" id="L1199" title="All 4 branches missed.">            switch(transferType) {</span>
            case DataBuffer.TYPE_SHORT:
                {
                    short sdata[];
<span class="nc bnc" id="L1203" title="All 2 branches missed.">                    if (pixel == null) {</span>
<span class="nc" id="L1204">                        sdata = new short[numComponents];</span>
                    } else {
<span class="nc" id="L1206">                        sdata = (short[])pixel;</span>
                    }
                    float factor;
<span class="nc bnc" id="L1209" title="All 4 branches missed.">                    if (is_sRGB_stdScale || is_LinearRGB_stdScale) {</span>
<span class="nc" id="L1210">                        factor = 32767.0f / 255.0f;</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">                        if (is_LinearRGB_stdScale) {</span>
<span class="nc" id="L1212">                            red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1213">                            grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1214">                            blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1215">                            factor = 32767.0f / 65535.0f;</span>
                        }
<span class="nc bnc" id="L1217" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1218">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1219">                            sdata[3] =</span>
                                (short) (alp * (32767.0f / 255.0f) + 0.5f);
<span class="nc bnc" id="L1221" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1222">                                factor = alp * factor * (1.0f / 255.0f);</span>
                            }
                        }
<span class="nc" id="L1225">                        sdata[0] = (short) (red * factor + 0.5f);</span>
<span class="nc" id="L1226">                        sdata[1] = (short) (grn * factor + 0.5f);</span>
<span class="nc" id="L1227">                        sdata[2] = (short) (blu * factor + 0.5f);</span>
<span class="nc bnc" id="L1228" title="All 2 branches missed.">                    } else if (is_LinearGray_stdScale) {</span>
<span class="nc" id="L1229">                        red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1230">                        grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1231">                        blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1232">                        float gray = ((0.2125f * red) +</span>
                                      (0.7154f * grn) +
                                      (0.0721f * blu)) / 65535.0f;
<span class="nc" id="L1235">                        factor = 32767.0f;</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1237">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1238">                            sdata[1] =</span>
                                (short) (alp * (32767.0f / 255.0f) + 0.5f);
<span class="nc bnc" id="L1240" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1241">                                factor = alp * factor * (1.0f / 255.0f);</span>
                            }
                        }
<span class="nc" id="L1244">                        sdata[0] = (short) (gray * factor + 0.5f);</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">                    } else if (is_ICCGray_stdScale) {</span>
<span class="nc" id="L1246">                        red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1247">                        grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1248">                        blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1249">                        int gray = (int) ((0.2125f * red) +</span>
                                          (0.7154f * grn) +
                                          (0.0721f * blu) + 0.5f);
<span class="nc" id="L1252">                        gray = fromLinearGray16ToOtherGray16LUT[gray] &amp; 0xffff;</span>
<span class="nc" id="L1253">                        factor = 32767.0f / 65535.0f;</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1255">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1256">                            sdata[1] =</span>
                                (short) (alp * (32767.0f / 255.0f) + 0.5f);
<span class="nc bnc" id="L1258" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1259">                                factor = alp * factor * (1.0f / 255.0f);</span>
                            }
                        }
<span class="nc" id="L1262">                        sdata[0] = (short) (gray * factor + 0.5f);</span>
<span class="nc" id="L1263">                    } else {</span>
<span class="nc" id="L1264">                        factor = 1.0f / 255.0f;</span>
<span class="nc" id="L1265">                        float norm[] = new float[3];</span>
<span class="nc" id="L1266">                        norm[0] = red * factor;</span>
<span class="nc" id="L1267">                        norm[1] = grn * factor;</span>
<span class="nc" id="L1268">                        norm[2] = blu * factor;</span>
<span class="nc" id="L1269">                        norm = colorSpace.fromRGB(norm);</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">                        if (nonStdScale) {</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">                            for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1272">                                norm[i] = (norm[i] - compOffset[i]) *</span>
                                          compScale[i];
                                // REMIND: need to analyze whether this
                                // clamping is necessary
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                                if (norm[i] &lt; 0.0f) {</span>
<span class="nc" id="L1277">                                    norm[i] = 0.0f;</span>
                                }
<span class="nc bnc" id="L1279" title="All 2 branches missed.">                                if (norm[i] &gt; 1.0f) {</span>
<span class="nc" id="L1280">                                    norm[i] = 1.0f;</span>
                                }
                            }
                        }
<span class="nc" id="L1284">                        factor = 32767.0f;</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1286">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1287">                            sdata[numColorComponents] =</span>
                                (short) (alp * (32767.0f / 255.0f) + 0.5f);
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1290">                                factor *= alp * (1.0f / 255.0f);</span>
                            }
                        }
<span class="nc bnc" id="L1293" title="All 2 branches missed.">                        for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1294">                            sdata[i] = (short) (norm[i] * factor + 0.5f);</span>
                        }
                    }
<span class="nc" id="L1297">                    return sdata;</span>
                }
            case DataBuffer.TYPE_FLOAT:
                {
                    float fdata[];
<span class="nc bnc" id="L1302" title="All 2 branches missed.">                    if (pixel == null) {</span>
<span class="nc" id="L1303">                        fdata = new float[numComponents];</span>
                    } else {
<span class="nc" id="L1305">                        fdata = (float[])pixel;</span>
                    }
                    float factor;
<span class="nc bnc" id="L1308" title="All 4 branches missed.">                    if (is_sRGB_stdScale || is_LinearRGB_stdScale) {</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                        if (is_LinearRGB_stdScale) {</span>
<span class="nc" id="L1310">                            red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1311">                            grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1312">                            blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1313">                            factor = 1.0f / 65535.0f;</span>
                        } else {
<span class="nc" id="L1315">                            factor = 1.0f / 255.0f;</span>
                        }
<span class="nc bnc" id="L1317" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1318">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1319">                            fdata[3] = alp * (1.0f / 255.0f);</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1321">                                factor *= fdata[3];</span>
                            }
                        }
<span class="nc" id="L1324">                        fdata[0] = red * factor;</span>
<span class="nc" id="L1325">                        fdata[1] = grn * factor;</span>
<span class="nc" id="L1326">                        fdata[2] = blu * factor;</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">                    } else if (is_LinearGray_stdScale) {</span>
<span class="nc" id="L1328">                        red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1329">                        grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1330">                        blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1331">                        fdata[0] = ((0.2125f * red) +</span>
                                    (0.7154f * grn) +
                                    (0.0721f * blu)) / 65535.0f;
<span class="nc bnc" id="L1334" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1335">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1336">                            fdata[1] = alp * (1.0f / 255.0f);</span>
<span class="nc bnc" id="L1337" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1338">                                fdata[0] *= fdata[1];</span>
                            }
                        }
<span class="nc bnc" id="L1341" title="All 2 branches missed.">                    } else if (is_ICCGray_stdScale) {</span>
<span class="nc" id="L1342">                        red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1343">                        grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1344">                        blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1345">                        int gray = (int) ((0.2125f * red) +</span>
                                          (0.7154f * grn) +
                                          (0.0721f * blu) + 0.5f);
<span class="nc" id="L1348">                        fdata[0] = (fromLinearGray16ToOtherGray16LUT[gray] &amp;</span>
                                    0xffff) / 65535.0f;
<span class="nc bnc" id="L1350" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1351">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1352">                            fdata[1] = alp * (1.0f / 255.0f);</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1354">                                fdata[0] *= fdata[1];</span>
                            }
                        }
<span class="nc" id="L1357">                    } else {</span>
<span class="nc" id="L1358">                        float norm[] = new float[3];</span>
<span class="nc" id="L1359">                        factor = 1.0f / 255.0f;</span>
<span class="nc" id="L1360">                        norm[0] = red * factor;</span>
<span class="nc" id="L1361">                        norm[1] = grn * factor;</span>
<span class="nc" id="L1362">                        norm[2] = blu * factor;</span>
<span class="nc" id="L1363">                        norm = colorSpace.fromRGB(norm);</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1365">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1366">                            fdata[numColorComponents] = alp * factor;</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1368">                                factor *= alp;</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">                                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1370">                                    norm[i] *= factor;</span>
                                }
                            }
                        }
<span class="nc bnc" id="L1374" title="All 2 branches missed.">                        for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1375">                            fdata[i] = norm[i];</span>
                        }
                    }
<span class="nc" id="L1378">                    return fdata;</span>
                }
            case DataBuffer.TYPE_DOUBLE:
                {
                    double ddata[];
<span class="nc bnc" id="L1383" title="All 2 branches missed.">                    if (pixel == null) {</span>
<span class="nc" id="L1384">                        ddata = new double[numComponents];</span>
                    } else {
<span class="nc" id="L1386">                        ddata = (double[])pixel;</span>
                    }
<span class="nc bnc" id="L1388" title="All 4 branches missed.">                    if (is_sRGB_stdScale || is_LinearRGB_stdScale) {</span>
                        double factor;
<span class="nc bnc" id="L1390" title="All 2 branches missed.">                        if (is_LinearRGB_stdScale) {</span>
<span class="nc" id="L1391">                            red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1392">                            grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1393">                            blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1394">                            factor = 1.0 / 65535.0;</span>
                        } else {
<span class="nc" id="L1396">                            factor = 1.0 / 255.0;</span>
                        }
<span class="nc bnc" id="L1398" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1399">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1400">                            ddata[3] = alp * (1.0 / 255.0);</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1402">                                factor *= ddata[3];</span>
                            }
                        }
<span class="nc" id="L1405">                        ddata[0] = red * factor;</span>
<span class="nc" id="L1406">                        ddata[1] = grn * factor;</span>
<span class="nc" id="L1407">                        ddata[2] = blu * factor;</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">                    } else if (is_LinearGray_stdScale) {</span>
<span class="nc" id="L1409">                        red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1410">                        grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1411">                        blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1412">                        ddata[0] = ((0.2125 * red) +</span>
                                    (0.7154 * grn) +
                                    (0.0721 * blu)) / 65535.0;
<span class="nc bnc" id="L1415" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1416">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1417">                            ddata[1] = alp * (1.0 / 255.0);</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1419">                                ddata[0] *= ddata[1];</span>
                            }
                        }
<span class="nc bnc" id="L1422" title="All 2 branches missed.">                    } else if (is_ICCGray_stdScale) {</span>
<span class="nc" id="L1423">                        red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1424">                        grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1425">                        blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1426">                        int gray = (int) ((0.2125f * red) +</span>
                                          (0.7154f * grn) +
                                          (0.0721f * blu) + 0.5f);
<span class="nc" id="L1429">                        ddata[0] = (fromLinearGray16ToOtherGray16LUT[gray] &amp;</span>
                                    0xffff) / 65535.0;
<span class="nc bnc" id="L1431" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1432">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1433">                            ddata[1] = alp * (1.0 / 255.0);</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1435">                                ddata[0] *= ddata[1];</span>
                            }
                        }
<span class="nc" id="L1438">                    } else {</span>
<span class="nc" id="L1439">                        float factor = 1.0f / 255.0f;</span>
<span class="nc" id="L1440">                        float norm[] = new float[3];</span>
<span class="nc" id="L1441">                        norm[0] = red * factor;</span>
<span class="nc" id="L1442">                        norm[1] = grn * factor;</span>
<span class="nc" id="L1443">                        norm[2] = blu * factor;</span>
<span class="nc" id="L1444">                        norm = colorSpace.fromRGB(norm);</span>
<span class="nc bnc" id="L1445" title="All 2 branches missed.">                        if (supportsAlpha) {</span>
<span class="nc" id="L1446">                            alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc" id="L1447">                            ddata[numColorComponents] = alp * (1.0 / 255.0);</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">                            if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1449">                                factor *= alp;</span>
<span class="nc bnc" id="L1450" title="All 2 branches missed.">                                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1451">                                    norm[i] *= factor;</span>
                                }
                            }
                        }
<span class="nc bnc" id="L1455" title="All 2 branches missed.">                        for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1456">                            ddata[i] = norm[i];</span>
                        }
                    }
<span class="nc" id="L1459">                    return ddata;</span>
                }
            }
        }

        // Handle BYTE, USHORT, &amp; INT here
        //REMIND: maybe more efficient not to use int array for
        //DataBuffer.TYPE_USHORT and DataBuffer.TYPE_INT
        int intpixel[];
<span class="nc bnc" id="L1468" title="All 4 branches missed.">        if (transferType == DataBuffer.TYPE_INT &amp;&amp;</span>
            pixel != null) {
<span class="nc" id="L1470">           intpixel = (int[])pixel;</span>
        } else {
<span class="nc" id="L1472">            intpixel = new int[numComponents];</span>
        }

<span class="nc bnc" id="L1475" title="All 4 branches missed.">        if (is_sRGB_stdScale || is_LinearRGB_stdScale) {</span>
            int precision;
            float factor;
<span class="nc bnc" id="L1478" title="All 2 branches missed.">            if (is_LinearRGB_stdScale) {</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">                if (transferType == DataBuffer.TYPE_BYTE) {</span>
<span class="nc" id="L1480">                    red = fromsRGB8LUT8[red] &amp; 0xff;</span>
<span class="nc" id="L1481">                    grn = fromsRGB8LUT8[grn] &amp; 0xff;</span>
<span class="nc" id="L1482">                    blu = fromsRGB8LUT8[blu] &amp; 0xff;</span>
<span class="nc" id="L1483">                    precision = 8;</span>
<span class="nc" id="L1484">                    factor = 1.0f / 255.0f;</span>
                } else {
<span class="nc" id="L1486">                    red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1487">                    grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1488">                    blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1489">                    precision = 16;</span>
<span class="nc" id="L1490">                    factor = 1.0f / 65535.0f;</span>
                }
            } else {
<span class="nc" id="L1493">                precision = 8;</span>
<span class="nc" id="L1494">                factor = 1.0f / 255.0f;</span>
            }
<span class="nc bnc" id="L1496" title="All 2 branches missed.">            if (supportsAlpha) {</span>
<span class="nc" id="L1497">                alp = (rgb&gt;&gt;24)&amp;0xff;</span>
<span class="nc bnc" id="L1498" title="All 2 branches missed.">                if (nBits[3] == 8) {</span>
<span class="nc" id="L1499">                    intpixel[3] = alp;</span>
                }
                else {
<span class="nc" id="L1502">                    intpixel[3] = (int)</span>
                        (alp * (1.0f / 255.0f) * ((1&lt;&lt;nBits[3]) - 1) + 0.5f);
                }
<span class="nc bnc" id="L1505" title="All 2 branches missed.">                if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1506">                    factor *= (alp * (1.0f / 255.0f));</span>
<span class="nc" id="L1507">                    precision = -1;  // force component calculations below</span>
                }
            }
<span class="nc bnc" id="L1510" title="All 2 branches missed.">            if (nBits[0] == precision) {</span>
<span class="nc" id="L1511">                intpixel[0] = red;</span>
            }
            else {
<span class="nc" id="L1514">                intpixel[0] = (int) (red * factor * ((1&lt;&lt;nBits[0]) - 1) + 0.5f);</span>
            }
<span class="nc bnc" id="L1516" title="All 2 branches missed.">            if (nBits[1] == precision) {</span>
<span class="nc" id="L1517">                intpixel[1] = (int)(grn);</span>
            }
            else {
<span class="nc" id="L1520">                intpixel[1] = (int) (grn * factor * ((1&lt;&lt;nBits[1]) - 1) + 0.5f);</span>
            }
<span class="nc bnc" id="L1522" title="All 2 branches missed.">            if (nBits[2] == precision) {</span>
<span class="nc" id="L1523">                intpixel[2] = (int)(blu);</span>
            }
            else {
<span class="nc" id="L1526">                intpixel[2] = (int) (blu * factor * ((1&lt;&lt;nBits[2]) - 1) + 0.5f);</span>
            }
<span class="nc bnc" id="L1528" title="All 2 branches missed.">        } else if (is_LinearGray_stdScale) {</span>
<span class="nc" id="L1529">            red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1530">            grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1531">            blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1532">            float gray = ((0.2125f * red) +</span>
                          (0.7154f * grn) +
                          (0.0721f * blu)) / 65535.0f;
<span class="nc bnc" id="L1535" title="All 2 branches missed.">            if (supportsAlpha) {</span>
<span class="nc" id="L1536">                alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">                if (nBits[1] == 8) {</span>
<span class="nc" id="L1538">                    intpixel[1] = alp;</span>
                } else {
<span class="nc" id="L1540">                    intpixel[1] = (int) (alp * (1.0f / 255.0f) *</span>
                                         ((1 &lt;&lt; nBits[1]) - 1) + 0.5f);
                }
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1544">                    gray *= (alp * (1.0f / 255.0f));</span>
                }
            }
<span class="nc" id="L1547">            intpixel[0] = (int) (gray * ((1 &lt;&lt; nBits[0]) - 1) + 0.5f);</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">        } else if (is_ICCGray_stdScale) {</span>
<span class="nc" id="L1549">            red = fromsRGB8LUT16[red] &amp; 0xffff;</span>
<span class="nc" id="L1550">            grn = fromsRGB8LUT16[grn] &amp; 0xffff;</span>
<span class="nc" id="L1551">            blu = fromsRGB8LUT16[blu] &amp; 0xffff;</span>
<span class="nc" id="L1552">            int gray16 = (int) ((0.2125f * red) +</span>
                                (0.7154f * grn) +
                                (0.0721f * blu) + 0.5f);
<span class="nc" id="L1555">            float gray = (fromLinearGray16ToOtherGray16LUT[gray16] &amp;</span>
                          0xffff) / 65535.0f;
<span class="nc bnc" id="L1557" title="All 2 branches missed.">            if (supportsAlpha) {</span>
<span class="nc" id="L1558">                alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc bnc" id="L1559" title="All 2 branches missed.">                if (nBits[1] == 8) {</span>
<span class="nc" id="L1560">                    intpixel[1] = alp;</span>
                } else {
<span class="nc" id="L1562">                    intpixel[1] = (int) (alp * (1.0f / 255.0f) *</span>
                                         ((1 &lt;&lt; nBits[1]) - 1) + 0.5f);
                }
<span class="nc bnc" id="L1565" title="All 2 branches missed.">                if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1566">                    gray *= (alp * (1.0f / 255.0f));</span>
                }
            }
<span class="nc" id="L1569">            intpixel[0] = (int) (gray * ((1 &lt;&lt; nBits[0]) - 1) + 0.5f);</span>
<span class="nc" id="L1570">        } else {</span>
            // Need to convert the color
<span class="nc" id="L1572">            float[] norm = new float[3];</span>
<span class="nc" id="L1573">            float factor = 1.0f / 255.0f;</span>
<span class="nc" id="L1574">            norm[0] = red * factor;</span>
<span class="nc" id="L1575">            norm[1] = grn * factor;</span>
<span class="nc" id="L1576">            norm[2] = blu * factor;</span>
<span class="nc" id="L1577">            norm = colorSpace.fromRGB(norm);</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">            if (nonStdScale) {</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">                for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1580">                    norm[i] = (norm[i] - compOffset[i]) *</span>
                              compScale[i];
                    // REMIND: need to analyze whether this
                    // clamping is necessary
<span class="nc bnc" id="L1584" title="All 2 branches missed.">                    if (norm[i] &lt; 0.0f) {</span>
<span class="nc" id="L1585">                        norm[i] = 0.0f;</span>
                    }
<span class="nc bnc" id="L1587" title="All 2 branches missed.">                    if (norm[i] &gt; 1.0f) {</span>
<span class="nc" id="L1588">                        norm[i] = 1.0f;</span>
                    }
                }
            }
<span class="nc bnc" id="L1592" title="All 2 branches missed.">            if (supportsAlpha) {</span>
<span class="nc" id="L1593">                alp = (rgb&gt;&gt;24) &amp; 0xff;</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">                if (nBits[numColorComponents] == 8) {</span>
<span class="nc" id="L1595">                    intpixel[numColorComponents] = alp;</span>
                }
                else {
<span class="nc" id="L1598">                    intpixel[numColorComponents] =</span>
                        (int) (alp * factor *
                               ((1&lt;&lt;nBits[numColorComponents]) - 1) + 0.5f);
                }
<span class="nc bnc" id="L1602" title="All 2 branches missed.">                if (isAlphaPremultiplied) {</span>
<span class="nc" id="L1603">                    factor *= alp;</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">                    for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1605">                        norm[i] *= factor;</span>
                    }
                }
            }
<span class="nc bnc" id="L1609" title="All 2 branches missed.">            for (int i = 0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1610">                intpixel[i] = (int) (norm[i] * ((1&lt;&lt;nBits[i]) - 1) + 0.5f);</span>
            }
        }

<span class="nc bnc" id="L1614" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE: {
               byte bdata[];
<span class="nc bnc" id="L1617" title="All 2 branches missed.">               if (pixel == null) {</span>
<span class="nc" id="L1618">                   bdata = new byte[numComponents];</span>
               } else {
<span class="nc" id="L1620">                   bdata = (byte[])pixel;</span>
               }
<span class="nc bnc" id="L1622" title="All 2 branches missed.">               for (int i = 0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L1623">                   bdata[i] = (byte)(0xff&amp;intpixel[i]);</span>
               }
<span class="nc" id="L1625">               return bdata;</span>
            }
            case DataBuffer.TYPE_USHORT:{
               short sdata[];
<span class="nc bnc" id="L1629" title="All 2 branches missed.">               if (pixel == null) {</span>
<span class="nc" id="L1630">                   sdata = new short[numComponents];</span>
               } else {
<span class="nc" id="L1632">                   sdata = (short[])pixel;</span>
               }
<span class="nc bnc" id="L1634" title="All 2 branches missed.">               for (int i = 0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L1635">                   sdata[i] = (short)(intpixel[i]&amp;0xffff);</span>
               }
<span class="nc" id="L1637">               return sdata;</span>
            }
            case DataBuffer.TYPE_INT:
<span class="nc bnc" id="L1640" title="All 2 branches missed.">                if (maxBits &gt; 23) {</span>
                    // fix 4412670 - for components of 24 or more bits
                    // some calculations done above with float precision
                    // may lose enough precision that the integer result
                    // overflows nBits, so we need to clamp.
<span class="nc bnc" id="L1645" title="All 2 branches missed.">                    for (int i = 0; i &lt; numComponents; i++) {</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">                        if (intpixel[i] &gt; ((1&lt;&lt;nBits[i]) - 1)) {</span>
<span class="nc" id="L1647">                            intpixel[i] = (1&lt;&lt;nBits[i]) - 1;</span>
                        }
                    }
                }
<span class="nc" id="L1651">                return intpixel;</span>
        }
<span class="nc" id="L1653">        throw new IllegalArgumentException(&quot;This method has not been &quot;+</span>
                 &quot;implemented for transferType &quot; + transferType);
    }

   /** Returns an array of unnormalized color/alpha components given a pixel
     * in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * An IllegalArgumentException is thrown if the component value for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; is not conveniently representable in the
     * unnormalized form.  Color/alpha components are stored
     * in the &lt;CODE&gt;components&lt;/CODE&gt; array starting at &lt;CODE&gt;offset&lt;/CODE&gt;
     * (even if the array is allocated by this method).
     *
     * @param pixel The pixel value specified as an integer.
     * @param components An integer array in which to store the unnormalized
     * color/alpha components. If the &lt;CODE&gt;components&lt;/CODE&gt; array is null,
     * a new array is allocated.
     * @param offset An offset into the &lt;CODE&gt;components&lt;/CODE&gt; array.
     *
     * @return The components array.
     *
     * @throws IllegalArgumentException If there is more than one
     * component in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws IllegalArgumentException If this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; does not support the unnormalized form
     * @throws ArrayIndexOutOfBoundsException If the &lt;CODE&gt;components&lt;/CODE&gt;
     * array is not null and is not large enough to hold all the color and
     * alpha components (starting at offset).
     */
    public int[] getComponents(int pixel, int[] components, int offset) {
<span class="nc bnc" id="L1682" title="All 2 branches missed.">        if (numComponents &gt; 1) {</span>
<span class="nc" id="L1683">            throw new</span>
                IllegalArgumentException(&quot;More than one component per pixel&quot;);
        }
<span class="nc bnc" id="L1686" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L1687">            initScale();</span>
        }
<span class="nc bnc" id="L1689" title="All 2 branches missed.">        if (noUnnorm) {</span>
<span class="nc" id="L1690">            throw new</span>
                IllegalArgumentException(
                    &quot;This ColorModel does not support the unnormalized form&quot;);
        }
<span class="nc bnc" id="L1694" title="All 2 branches missed.">        if (components == null) {</span>
<span class="nc" id="L1695">            components = new int[offset+1];</span>
        }

<span class="nc" id="L1698">        components[offset+0] = (pixel &amp; ((1&lt;&lt;nBits[0]) - 1));</span>
<span class="nc" id="L1699">        return components;</span>
    }

    /**
     * Returns an array of unnormalized color/alpha components given a pixel
     * in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.  The pixel value is specified by an
     * array of data elements of type &lt;CODE&gt;transferType&lt;/CODE&gt; passed in as
     * an object reference.
     * An IllegalArgumentException is thrown if the component values for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; are not conveniently representable in the
     * unnormalized form.
     * Color/alpha components are stored in the &lt;CODE&gt;components&lt;/CODE&gt; array
     * starting at  &lt;CODE&gt;offset&lt;/CODE&gt; (even if the array is allocated by
     * this method).  Since &lt;code&gt;ComponentColorModel&lt;/code&gt; can be
     * subclassed, subclasses inherit the
     * implementation of this method and if they don't override it then
     * this method might throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param pixel A pixel value specified by an array of data elements of
     * type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     * @param components An integer array in which to store the unnormalized
     * color/alpha components. If the &lt;CODE&gt;components&lt;/CODE&gt; array is null,
     * a new array is allocated.
     * @param offset An offset into the &lt;CODE&gt;components&lt;/CODE&gt; array.
     *
     * @return The &lt;CODE&gt;components&lt;/CODE&gt; array.
     *
     * @throws IllegalArgumentException If this
     * &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt; does not support the unnormalized form
     * @throws UnsupportedOperationException in some cases iff the
     * transfer type of this &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt;
     * is not one of the following transfer types:
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * or &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;.
     * @throws ClassCastException If &lt;CODE&gt;pixel&lt;/CODE&gt; is not a primitive
     * array of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     * @throws IllegalArgumentException If the &lt;CODE&gt;components&lt;/CODE&gt; array is
     * not null and is not large enough to hold all the color and alpha
     * components (starting at offset), or if &lt;CODE&gt;pixel&lt;/CODE&gt; is not large
     * enough to hold a pixel value for this ColorModel.
     */
    public int[] getComponents(Object pixel, int[] components, int offset) {
        int intpixel[];
<span class="nc bnc" id="L1743" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L1744">            initScale();</span>
        }
<span class="nc bnc" id="L1746" title="All 2 branches missed.">        if (noUnnorm) {</span>
<span class="nc" id="L1747">            throw new</span>
                IllegalArgumentException(
                    &quot;This ColorModel does not support the unnormalized form&quot;);
        }
<span class="nc bnc" id="L1751" title="All 2 branches missed.">        if (pixel instanceof int[]) {</span>
<span class="nc" id="L1752">            intpixel = (int[])pixel;</span>
        } else {
<span class="nc" id="L1754">            intpixel = DataBuffer.toIntArray(pixel);</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">            if (intpixel == null) {</span>
<span class="nc" id="L1756">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
            }
        }
<span class="nc bnc" id="L1760" title="All 2 branches missed.">        if (intpixel.length &lt; numComponents) {</span>
<span class="nc" id="L1761">            throw new IllegalArgumentException</span>
                (&quot;Length of pixel array &lt; number of components in model&quot;);
        }
<span class="nc bnc" id="L1764" title="All 2 branches missed.">        if (components == null) {</span>
<span class="nc" id="L1765">            components = new int[offset+numComponents];</span>
        }
<span class="nc bnc" id="L1767" title="All 2 branches missed.">        else if ((components.length-offset) &lt; numComponents) {</span>
<span class="nc" id="L1768">            throw new IllegalArgumentException</span>
                (&quot;Length of components array &lt; number of components in model&quot;);
        }
<span class="nc" id="L1771">        System.arraycopy(intpixel, 0, components, offset, numComponents);</span>

<span class="nc" id="L1773">        return components;</span>
    }

    /**
     * Returns an array of all of the color/alpha components in unnormalized
     * form, given a normalized component array.  Unnormalized components
     * are unsigned integral values between 0 and 2&lt;sup&gt;n&lt;/sup&gt; - 1, where
     * n is the number of bits for a particular component.  Normalized
     * components are float values between a per component minimum and
     * maximum specified by the &lt;code&gt;ColorSpace&lt;/code&gt; object for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.  An &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * will be thrown if color component values for this
     * &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently representable in the
     * unnormalized form.  If the
     * &lt;code&gt;components&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;, a new array
     * will be allocated.  The &lt;code&gt;components&lt;/code&gt; array will
     * be returned.  Color/alpha components are stored in the
     * &lt;code&gt;components&lt;/code&gt; array starting at &lt;code&gt;offset&lt;/code&gt; (even
     * if the array is allocated by this method). An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * &lt;code&gt;components&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt; and is not
     * large enough to hold all the color and alpha
     * components (starting at &lt;code&gt;offset&lt;/code&gt;).  An
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if the
     * &lt;code&gt;normComponents&lt;/code&gt; array is not large enough to hold
     * all the color and alpha components starting at
     * &lt;code&gt;normOffset&lt;/code&gt;.
     * @param normComponents an array containing normalized components
     * @param normOffset the offset into the &lt;code&gt;normComponents&lt;/code&gt;
     * array at which to start retrieving normalized components
     * @param components an array that receives the components from
     * &lt;code&gt;normComponents&lt;/code&gt;
     * @param offset the index into &lt;code&gt;components&lt;/code&gt; at which to
     * begin storing normalized components from
     * &lt;code&gt;normComponents&lt;/code&gt;
     * @return an array containing unnormalized color and alpha
     * components.
     * @throws IllegalArgumentException If this
     * &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt; does not support the unnormalized form
     * @throws IllegalArgumentException if the length of
     *          &lt;code&gt;normComponents&lt;/code&gt; minus &lt;code&gt;normOffset&lt;/code&gt;
     *          is less than &lt;code&gt;numComponents&lt;/code&gt;
     */
    public int[] getUnnormalizedComponents(float[] normComponents,
                                           int normOffset,
                                           int[] components, int offset) {
<span class="nc bnc" id="L1819" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L1820">            initScale();</span>
        }
<span class="nc bnc" id="L1822" title="All 2 branches missed.">        if (noUnnorm) {</span>
<span class="nc" id="L1823">            throw new</span>
                IllegalArgumentException(
                    &quot;This ColorModel does not support the unnormalized form&quot;);
        }
<span class="nc" id="L1827">        return super.getUnnormalizedComponents(normComponents, normOffset,</span>
                                               components, offset);
    }

    /**
     * Returns an array of all of the color/alpha components in normalized
     * form, given an unnormalized component array.  Unnormalized components
     * are unsigned integral values between 0 and 2&lt;sup&gt;n&lt;/sup&gt; - 1, where
     * n is the number of bits for a particular component.  Normalized
     * components are float values between a per component minimum and
     * maximum specified by the &lt;code&gt;ColorSpace&lt;/code&gt; object for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.  An &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * will be thrown if color component values for this
     * &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently representable in the
     * unnormalized form.  If the
     * &lt;code&gt;normComponents&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;, a new array
     * will be allocated.  The &lt;code&gt;normComponents&lt;/code&gt; array
     * will be returned.  Color/alpha components are stored in the
     * &lt;code&gt;normComponents&lt;/code&gt; array starting at
     * &lt;code&gt;normOffset&lt;/code&gt; (even if the array is allocated by this
     * method).  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown
     * if the &lt;code&gt;normComponents&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt;
     * and is not large enough to hold all the color and alpha components
     * (starting at &lt;code&gt;normOffset&lt;/code&gt;).  An
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if the
     * &lt;code&gt;components&lt;/code&gt; array is not large enough to hold all the
     * color and alpha components starting at &lt;code&gt;offset&lt;/code&gt;.
     * @param components an array containing unnormalized components
     * @param offset the offset into the &lt;code&gt;components&lt;/code&gt; array at
     * which to start retrieving unnormalized components
     * @param normComponents an array that receives the normalized components
     * @param normOffset the index into &lt;code&gt;normComponents&lt;/code&gt; at
     * which to begin storing normalized components
     * @return an array containing normalized color and alpha
     * components.
     * @throws IllegalArgumentException If this
     * &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt; does not support the unnormalized form
     */
    public float[] getNormalizedComponents(int[] components, int offset,
                                           float[] normComponents,
                                           int normOffset) {
<span class="nc bnc" id="L1868" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L1869">            initScale();</span>
        }
<span class="nc bnc" id="L1871" title="All 2 branches missed.">        if (noUnnorm) {</span>
<span class="nc" id="L1872">            throw new</span>
                IllegalArgumentException(
                    &quot;This ColorModel does not support the unnormalized form&quot;);
        }
<span class="nc" id="L1876">        return super.getNormalizedComponents(components, offset,</span>
                                             normComponents, normOffset);
    }

    /**
     * Returns a pixel value represented as an int in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;,
     * given an array of unnormalized color/alpha components.
     *
     * @param components An array of unnormalized color/alpha components.
     * @param offset An offset into the &lt;CODE&gt;components&lt;/CODE&gt; array.
     *
     * @return A pixel value represented as an int.
     *
     * @throws IllegalArgumentException If there is more than one component
     * in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws IllegalArgumentException If this
     * &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt; does not support the unnormalized form
     */
    public int getDataElement(int[] components, int offset) {
<span class="nc bnc" id="L1895" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L1896">            initScale();</span>
        }
<span class="nc bnc" id="L1898" title="All 2 branches missed.">        if (numComponents == 1) {</span>
<span class="nc bnc" id="L1899" title="All 2 branches missed.">            if (noUnnorm) {</span>
<span class="nc" id="L1900">                throw new</span>
                    IllegalArgumentException(
                    &quot;This ColorModel does not support the unnormalized form&quot;);
            }
<span class="nc" id="L1904">            return components[offset+0];</span>
        }
<span class="nc" id="L1906">        throw new IllegalArgumentException(&quot;This model returns &quot;+</span>
                                           numComponents+
                                           &quot; elements in the pixel array.&quot;);
    }

    /**
     * Returns a data element array representation of a pixel in this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;, given an array of unnormalized color/alpha
     * components. This array can then be passed to the &lt;CODE&gt;setDataElements&lt;/CODE&gt;
     * method of a &lt;CODE&gt;WritableRaster&lt;/CODE&gt; object.
     *
     * @param components An array of unnormalized color/alpha components.
     * @param offset The integer offset into the &lt;CODE&gt;components&lt;/CODE&gt; array.
     * @param obj The object in which to store the data element array
     * representation of the pixel. If &lt;CODE&gt;obj&lt;/CODE&gt; variable is null,
     * a new array is allocated.  If &lt;CODE&gt;obj&lt;/CODE&gt; is not null, it must
     * be a primitive array of type &lt;CODE&gt;transferType&lt;/CODE&gt;. An
     * &lt;CODE&gt;ArrayIndexOutOfBoundsException&lt;/CODE&gt; is thrown if
     * &lt;CODE&gt;obj&lt;/CODE&gt; is not large enough to hold a pixel value
     * for this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.  Since
     * &lt;code&gt;ComponentColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then they throw an exception if they use an
     * unsupported &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @return The data element array representation of a pixel
     * in this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     *
     * @throws IllegalArgumentException If the components array
     * is not large enough to hold all the color and alpha components
     * (starting at offset).
     * @throws ClassCastException If &lt;CODE&gt;obj&lt;/CODE&gt; is not null and is not a
     * primitive  array of type &lt;CODE&gt;transferType&lt;/CODE&gt;.
     * @throws ArrayIndexOutOfBoundsException If &lt;CODE&gt;obj&lt;/CODE&gt; is not large
     * enough to hold a pixel value for this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @throws IllegalArgumentException If this
     * &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt; does not support the unnormalized form
     * @throws UnsupportedOperationException If the transfer type of
     * this &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt;
     * is not one of the following transfer types:
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * or &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;.
     *
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     */
    public Object getDataElements(int[] components, int offset, Object obj) {
<span class="nc bnc" id="L1953" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L1954">            initScale();</span>
        }
<span class="nc bnc" id="L1956" title="All 2 branches missed.">        if (noUnnorm) {</span>
<span class="nc" id="L1957">            throw new</span>
                IllegalArgumentException(
                    &quot;This ColorModel does not support the unnormalized form&quot;);
        }
<span class="nc bnc" id="L1961" title="All 2 branches missed.">        if ((components.length-offset) &lt; numComponents) {</span>
<span class="nc" id="L1962">            throw new IllegalArgumentException(&quot;Component array too small&quot;+</span>
                                               &quot; (should be &quot;+numComponents);
        }
<span class="nc bnc" id="L1965" title="All 4 branches missed.">        switch(transferType) {</span>
        case DataBuffer.TYPE_INT:
            {
                int[] pixel;
<span class="nc bnc" id="L1969" title="All 2 branches missed.">                if (obj == null) {</span>
<span class="nc" id="L1970">                    pixel = new int[numComponents];</span>
                }
                else {
<span class="nc" id="L1973">                    pixel = (int[]) obj;</span>
                }
<span class="nc" id="L1975">                System.arraycopy(components, offset, pixel, 0,</span>
                                 numComponents);
<span class="nc" id="L1977">                return pixel;</span>
            }

        case DataBuffer.TYPE_BYTE:
            {
                byte[] pixel;
<span class="nc bnc" id="L1983" title="All 2 branches missed.">                if (obj == null) {</span>
<span class="nc" id="L1984">                    pixel = new byte[numComponents];</span>
                }
                else {
<span class="nc" id="L1987">                    pixel = (byte[]) obj;</span>
                }
<span class="nc bnc" id="L1989" title="All 2 branches missed.">                for (int i=0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L1990">                    pixel[i] = (byte) (components[offset+i]&amp;0xff);</span>
                }
<span class="nc" id="L1992">                return pixel;</span>
            }

        case DataBuffer.TYPE_USHORT:
            {
                short[] pixel;
<span class="nc bnc" id="L1998" title="All 2 branches missed.">                if (obj == null) {</span>
<span class="nc" id="L1999">                    pixel = new short[numComponents];</span>
                }
                else {
<span class="nc" id="L2002">                    pixel = (short[]) obj;</span>
                }
<span class="nc bnc" id="L2004" title="All 2 branches missed.">                for (int i=0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L2005">                    pixel[i] = (short) (components[offset+i]&amp;0xffff);</span>
                }
<span class="nc" id="L2007">                return pixel;</span>
            }

        default:
<span class="nc" id="L2011">            throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                                        &quot;implemented for transferType &quot; +
                                        transferType);
        }
    }

    /**
     * Returns a pixel value represented as an &lt;code&gt;int&lt;/code&gt; in this
     * &lt;code&gt;ColorModel&lt;/code&gt;, given an array of normalized color/alpha
     * components.  This method will throw an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; if pixel values for this
     * &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently representable as a
     * single &lt;code&gt;int&lt;/code&gt;.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if  the
     * &lt;code&gt;normComponents&lt;/code&gt; array is not large enough to hold all the
     * color and alpha components (starting at &lt;code&gt;normOffset&lt;/code&gt;).
     * @param normComponents an array of normalized color and alpha
     * components
     * @param normOffset the index into &lt;code&gt;normComponents&lt;/code&gt; at which to
     * begin retrieving the color and alpha components
     * @return an &lt;code&gt;int&lt;/code&gt; pixel value in this
     * &lt;code&gt;ColorModel&lt;/code&gt; corresponding to the specified components.
     * @throws IllegalArgumentException if
     *  pixel values for this &lt;code&gt;ColorModel&lt;/code&gt; are not
     *  conveniently representable as a single &lt;code&gt;int&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  the &lt;code&gt;normComponents&lt;/code&gt; array is not large enough to
     *  hold all of the color and alpha components starting at
     *  &lt;code&gt;normOffset&lt;/code&gt;
     * @since 1.4
     */
    public int getDataElement(float[] normComponents, int normOffset) {
<span class="nc bnc" id="L2043" title="All 2 branches missed.">        if (numComponents &gt; 1) {</span>
<span class="nc" id="L2044">            throw new</span>
                IllegalArgumentException(&quot;More than one component per pixel&quot;);
        }
<span class="nc bnc" id="L2047" title="All 2 branches missed.">        if (signed) {</span>
<span class="nc" id="L2048">            throw new</span>
                IllegalArgumentException(&quot;Component value is signed&quot;);
        }
<span class="nc bnc" id="L2051" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L2052">            initScale();</span>
        }
<span class="nc" id="L2054">        Object pixel = getDataElements(normComponents, normOffset, null);</span>
<span class="nc bnc" id="L2055" title="All 4 branches missed.">        switch (transferType) {</span>
        case DataBuffer.TYPE_BYTE:
            {
<span class="nc" id="L2058">                byte bpixel[] = (byte[]) pixel;</span>
<span class="nc" id="L2059">                return bpixel[0] &amp; 0xff;</span>
            }
        case DataBuffer.TYPE_USHORT:
            {
<span class="nc" id="L2063">                short[] uspixel = (short[]) pixel;</span>
<span class="nc" id="L2064">                return uspixel[0] &amp; 0xffff;</span>
            }
        case DataBuffer.TYPE_INT:
            {
<span class="nc" id="L2068">                int[] ipixel = (int[]) pixel;</span>
<span class="nc" id="L2069">                return ipixel[0];</span>
            }
        default:
<span class="nc" id="L2072">            throw new UnsupportedOperationException(&quot;This method has not been &quot;</span>
                + &quot;implemented for transferType &quot; + transferType);
        }
    }

    /**
     * Returns a data element array representation of a pixel in this
     * &lt;code&gt;ColorModel&lt;/code&gt;, given an array of normalized color/alpha
     * components.  This array can then be passed to the
     * &lt;code&gt;setDataElements&lt;/code&gt; method of a &lt;code&gt;WritableRaster&lt;/code&gt;
     * object.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown
     * if the &lt;code&gt;normComponents&lt;/code&gt; array is not large enough to hold
     * all the color and alpha components (starting at
     * &lt;code&gt;normOffset&lt;/code&gt;).  If the &lt;code&gt;obj&lt;/code&gt; variable is
     * &lt;code&gt;null&lt;/code&gt;, a new array will be allocated.  If
     * &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it must be a primitive
     * array of type transferType; otherwise, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * &lt;code&gt;obj&lt;/code&gt; is not large enough to hold a pixel value for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param normComponents an array of normalized color and alpha
     * components
     * @param normOffset the index into &lt;code&gt;normComponents&lt;/code&gt; at which to
     * begin retrieving color and alpha components
     * @param obj a primitive data array to hold the returned pixel
     * @return an &lt;code&gt;Object&lt;/code&gt; which is a primitive data array
     * representation of a pixel
     * @throws ClassCastException if &lt;code&gt;obj&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;obj&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt; or the &lt;code&gt;normComponents&lt;/code&gt;
     *  array is not large enough to hold all of the color and alpha
     *  components starting at &lt;code&gt;normOffset&lt;/code&gt;
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     * @since 1.4
     */
    public Object getDataElements(float[] normComponents, int normOffset,
                                  Object obj) {
<span class="nc bnc" id="L2113" title="All 4 branches missed.">        boolean needAlpha = supportsAlpha &amp;&amp; isAlphaPremultiplied;</span>
        float[] stdNormComponents;
<span class="nc bnc" id="L2115" title="All 2 branches missed.">        if (needScaleInit) {</span>
<span class="nc" id="L2116">            initScale();</span>
        }
<span class="nc bnc" id="L2118" title="All 2 branches missed.">        if (nonStdScale) {</span>
<span class="nc" id="L2119">            stdNormComponents = new float[numComponents];</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">            for (int c = 0, nc = normOffset; c &lt; numColorComponents;</span>
<span class="nc" id="L2121">                 c++, nc++) {</span>
<span class="nc" id="L2122">                stdNormComponents[c] = (normComponents[nc] - compOffset[c]) *</span>
                                       compScale[c];
                // REMIND: need to analyze whether this
                // clamping is necessary
<span class="nc bnc" id="L2126" title="All 2 branches missed.">                if (stdNormComponents[c] &lt; 0.0f) {</span>
<span class="nc" id="L2127">                    stdNormComponents[c] = 0.0f;</span>
                }
<span class="nc bnc" id="L2129" title="All 2 branches missed.">                if (stdNormComponents[c] &gt; 1.0f) {</span>
<span class="nc" id="L2130">                    stdNormComponents[c] = 1.0f;</span>
                }
            }
<span class="nc bnc" id="L2133" title="All 2 branches missed.">            if (supportsAlpha) {</span>
<span class="nc" id="L2134">                stdNormComponents[numColorComponents] =</span>
                    normComponents[numColorComponents + normOffset];
            }
<span class="nc" id="L2137">            normOffset = 0;</span>
        } else {
<span class="nc" id="L2139">            stdNormComponents = normComponents;</span>
        }
<span class="nc bnc" id="L2141" title="All 7 branches missed.">        switch (transferType) {</span>
        case DataBuffer.TYPE_BYTE:
            byte[] bpixel;
<span class="nc bnc" id="L2144" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L2145">                bpixel = new byte[numComponents];</span>
            } else {
<span class="nc" id="L2147">                bpixel = (byte[]) obj;</span>
            }
<span class="nc bnc" id="L2149" title="All 2 branches missed.">            if (needAlpha) {</span>
<span class="nc" id="L2150">                float alpha =</span>
                    stdNormComponents[numColorComponents + normOffset];
<span class="nc bnc" id="L2152" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numColorComponents;</span>
<span class="nc" id="L2153">                     c++, nc++) {</span>
<span class="nc" id="L2154">                    bpixel[c] = (byte) ((stdNormComponents[nc] * alpha) *</span>
                                        ((float) ((1 &lt;&lt; nBits[c]) - 1)) + 0.5f);
                }
<span class="nc" id="L2157">                bpixel[numColorComponents] =</span>
                    (byte) (alpha *
                            ((float) ((1 &lt;&lt; nBits[numColorComponents]) - 1)) +
                            0.5f);
<span class="nc" id="L2161">            } else {</span>
<span class="nc bnc" id="L2162" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numComponents;</span>
<span class="nc" id="L2163">                     c++, nc++) {</span>
<span class="nc" id="L2164">                    bpixel[c] = (byte) (stdNormComponents[nc] *</span>
                                        ((float) ((1 &lt;&lt; nBits[c]) - 1)) + 0.5f);
                }
            }
<span class="nc" id="L2168">            return bpixel;</span>
        case DataBuffer.TYPE_USHORT:
            short[] uspixel;
<span class="nc bnc" id="L2171" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L2172">                uspixel = new short[numComponents];</span>
            } else {
<span class="nc" id="L2174">                uspixel = (short[]) obj;</span>
            }
<span class="nc bnc" id="L2176" title="All 2 branches missed.">            if (needAlpha) {</span>
<span class="nc" id="L2177">                float alpha =</span>
                    stdNormComponents[numColorComponents + normOffset];
<span class="nc bnc" id="L2179" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numColorComponents;</span>
<span class="nc" id="L2180">                     c++, nc++) {</span>
<span class="nc" id="L2181">                    uspixel[c] = (short) ((stdNormComponents[nc] * alpha) *</span>
                                          ((float) ((1 &lt;&lt; nBits[c]) - 1)) +
                                          0.5f);
                }
<span class="nc" id="L2185">                uspixel[numColorComponents] =</span>
                    (short) (alpha *
                             ((float) ((1 &lt;&lt; nBits[numColorComponents]) - 1)) +
                             0.5f);
<span class="nc" id="L2189">            } else {</span>
<span class="nc bnc" id="L2190" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numComponents;</span>
<span class="nc" id="L2191">                     c++, nc++) {</span>
<span class="nc" id="L2192">                    uspixel[c] = (short) (stdNormComponents[nc] *</span>
                                          ((float) ((1 &lt;&lt; nBits[c]) - 1)) +
                                          0.5f);
                }
            }
<span class="nc" id="L2197">            return uspixel;</span>
        case DataBuffer.TYPE_INT:
            int[] ipixel;
<span class="nc bnc" id="L2200" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L2201">                ipixel = new int[numComponents];</span>
            } else {
<span class="nc" id="L2203">                ipixel = (int[]) obj;</span>
            }
<span class="nc bnc" id="L2205" title="All 2 branches missed.">            if (needAlpha) {</span>
<span class="nc" id="L2206">                float alpha =</span>
                    stdNormComponents[numColorComponents + normOffset];
<span class="nc bnc" id="L2208" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numColorComponents;</span>
<span class="nc" id="L2209">                     c++, nc++) {</span>
<span class="nc" id="L2210">                    ipixel[c] = (int) ((stdNormComponents[nc] * alpha) *</span>
                                       ((float) ((1 &lt;&lt; nBits[c]) - 1)) + 0.5f);
                }
<span class="nc" id="L2213">                ipixel[numColorComponents] =</span>
                    (int) (alpha *
                           ((float) ((1 &lt;&lt; nBits[numColorComponents]) - 1)) +
                           0.5f);
<span class="nc" id="L2217">            } else {</span>
<span class="nc bnc" id="L2218" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numComponents;</span>
<span class="nc" id="L2219">                     c++, nc++) {</span>
<span class="nc" id="L2220">                    ipixel[c] = (int) (stdNormComponents[nc] *</span>
                                       ((float) ((1 &lt;&lt; nBits[c]) - 1)) + 0.5f);
                }
            }
<span class="nc" id="L2224">            return ipixel;</span>
        case DataBuffer.TYPE_SHORT:
            short[] spixel;
<span class="nc bnc" id="L2227" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L2228">                spixel = new short[numComponents];</span>
            } else {
<span class="nc" id="L2230">                spixel = (short[]) obj;</span>
            }
<span class="nc bnc" id="L2232" title="All 2 branches missed.">            if (needAlpha) {</span>
<span class="nc" id="L2233">                float alpha =</span>
                    stdNormComponents[numColorComponents + normOffset];
<span class="nc bnc" id="L2235" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numColorComponents;</span>
<span class="nc" id="L2236">                     c++, nc++) {</span>
<span class="nc" id="L2237">                    spixel[c] = (short)</span>
                        (stdNormComponents[nc] * alpha * 32767.0f + 0.5f);
                }
<span class="nc" id="L2240">                spixel[numColorComponents] = (short) (alpha * 32767.0f + 0.5f);</span>
<span class="nc" id="L2241">            } else {</span>
<span class="nc bnc" id="L2242" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numComponents;</span>
<span class="nc" id="L2243">                     c++, nc++) {</span>
<span class="nc" id="L2244">                    spixel[c] = (short)</span>
                        (stdNormComponents[nc] * 32767.0f + 0.5f);
                }
            }
<span class="nc" id="L2248">            return spixel;</span>
        case DataBuffer.TYPE_FLOAT:
            float[] fpixel;
<span class="nc bnc" id="L2251" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L2252">                fpixel = new float[numComponents];</span>
            } else {
<span class="nc" id="L2254">                fpixel = (float[]) obj;</span>
            }
<span class="nc bnc" id="L2256" title="All 2 branches missed.">            if (needAlpha) {</span>
<span class="nc" id="L2257">                float alpha = normComponents[numColorComponents + normOffset];</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numColorComponents;</span>
<span class="nc" id="L2259">                     c++, nc++) {</span>
<span class="nc" id="L2260">                    fpixel[c] = normComponents[nc] * alpha;</span>
                }
<span class="nc" id="L2262">                fpixel[numColorComponents] = alpha;</span>
<span class="nc" id="L2263">            } else {</span>
<span class="nc bnc" id="L2264" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numComponents;</span>
<span class="nc" id="L2265">                     c++, nc++) {</span>
<span class="nc" id="L2266">                    fpixel[c] = normComponents[nc];</span>
                }
            }
<span class="nc" id="L2269">            return fpixel;</span>
        case DataBuffer.TYPE_DOUBLE:
            double[] dpixel;
<span class="nc bnc" id="L2272" title="All 2 branches missed.">            if (obj == null) {</span>
<span class="nc" id="L2273">                dpixel = new double[numComponents];</span>
            } else {
<span class="nc" id="L2275">                dpixel = (double[]) obj;</span>
            }
<span class="nc bnc" id="L2277" title="All 2 branches missed.">            if (needAlpha) {</span>
<span class="nc" id="L2278">                double alpha =</span>
                    (double) (normComponents[numColorComponents + normOffset]);
<span class="nc bnc" id="L2280" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numColorComponents;</span>
<span class="nc" id="L2281">                     c++, nc++) {</span>
<span class="nc" id="L2282">                    dpixel[c] = normComponents[nc] * alpha;</span>
                }
<span class="nc" id="L2284">                dpixel[numColorComponents] = alpha;</span>
<span class="nc" id="L2285">            } else {</span>
<span class="nc bnc" id="L2286" title="All 2 branches missed.">                for (int c = 0, nc = normOffset; c &lt; numComponents;</span>
<span class="nc" id="L2287">                     c++, nc++) {</span>
<span class="nc" id="L2288">                    dpixel[c] = (double) normComponents[nc];</span>
                }
            }
<span class="nc" id="L2291">            return dpixel;</span>
        default:
<span class="nc" id="L2293">            throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                                        &quot;implemented for transferType &quot; +
                                        transferType);
        }
    }

    /**
     * Returns an array of all of the color/alpha components in normalized
     * form, given a pixel in this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel
     * value is specified by an array of data elements of type transferType
     * passed in as an object reference.  If pixel is not a primitive array
     * of type transferType, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel value for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * Normalized components are float values between a per component minimum
     * and maximum specified by the &lt;code&gt;ColorSpace&lt;/code&gt; object for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.  If the
     * &lt;code&gt;normComponents&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;, a new array
     * will be allocated.  The &lt;code&gt;normComponents&lt;/code&gt; array
     * will be returned.  Color/alpha components are stored in the
     * &lt;code&gt;normComponents&lt;/code&gt; array starting at
     * &lt;code&gt;normOffset&lt;/code&gt; (even if the array is allocated by this
     * method).  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown
     * if the &lt;code&gt;normComponents&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt;
     * and is not large enough to hold all the color and alpha components
     * (starting at &lt;code&gt;normOffset&lt;/code&gt;).
     * &lt;p&gt;
     * This method must be overridden by a subclass if that subclass
     * is designed to translate pixel sample values to color component values
     * in a non-default way.  The default translations implemented by this
     * class is described in the class comments.  Any subclass implementing
     * a non-default translation must follow the constraints on allowable
     * translations defined there.
     * @param pixel the specified pixel
     * @param normComponents an array to receive the normalized components
     * @param normOffset the offset into the &lt;code&gt;normComponents&lt;/code&gt;
     * array at which to start storing normalized components
     * @return an array containing normalized color and alpha
     * components.
     * @throws ClassCastException if &lt;code&gt;pixel&lt;/code&gt; is not a primitive
     *          array of type transferType
     * @throws ArrayIndexOutOfBoundsException if
     *          &lt;code&gt;normComponents&lt;/code&gt; is not large enough to hold all
     *          color and alpha components starting at &lt;code&gt;normOffset&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *          &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel
     *          value for this &lt;code&gt;ColorModel&lt;/code&gt;.
     * @since 1.4
     */
    public float[] getNormalizedComponents(Object pixel,
                                           float[] normComponents,
                                           int normOffset) {
<span class="nc bnc" id="L2346" title="All 2 branches missed.">        if (normComponents == null) {</span>
<span class="nc" id="L2347">            normComponents = new float[numComponents+normOffset];</span>
        }
<span class="nc bnc" id="L2349" title="All 7 branches missed.">        switch (transferType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L2351">            byte[] bpixel = (byte[]) pixel;</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">            for (int c = 0, nc = normOffset; c &lt; numComponents; c++, nc++) {</span>
<span class="nc" id="L2353">                normComponents[nc] = ((float) (bpixel[c] &amp; 0xff)) /</span>
                                     ((float) ((1 &lt;&lt; nBits[c]) - 1));
            }
<span class="nc" id="L2356">            break;</span>
        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L2358">            short[] uspixel = (short[]) pixel;</span>
<span class="nc bnc" id="L2359" title="All 2 branches missed.">            for (int c = 0, nc = normOffset; c &lt; numComponents; c++, nc++) {</span>
<span class="nc" id="L2360">                normComponents[nc] = ((float) (uspixel[c] &amp; 0xffff)) /</span>
                                     ((float) ((1 &lt;&lt; nBits[c]) - 1));
            }
<span class="nc" id="L2363">            break;</span>
        case DataBuffer.TYPE_INT:
<span class="nc" id="L2365">            int[] ipixel = (int[]) pixel;</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">            for (int c = 0, nc = normOffset; c &lt; numComponents; c++, nc++) {</span>
<span class="nc" id="L2367">                normComponents[nc] = ((float) ipixel[c]) /</span>
                                     ((float) ((1 &lt;&lt; nBits[c]) - 1));
            }
<span class="nc" id="L2370">            break;</span>
        case DataBuffer.TYPE_SHORT:
<span class="nc" id="L2372">            short[] spixel = (short[]) pixel;</span>
<span class="nc bnc" id="L2373" title="All 2 branches missed.">            for (int c = 0, nc = normOffset; c &lt; numComponents; c++, nc++) {</span>
<span class="nc" id="L2374">                normComponents[nc] = ((float) spixel[c]) / 32767.0f;</span>
            }
<span class="nc" id="L2376">            break;</span>
        case DataBuffer.TYPE_FLOAT:
<span class="nc" id="L2378">            float[] fpixel = (float[]) pixel;</span>
<span class="nc bnc" id="L2379" title="All 2 branches missed.">            for (int c = 0, nc = normOffset; c &lt; numComponents; c++, nc++) {</span>
<span class="nc" id="L2380">                normComponents[nc] = fpixel[c];</span>
            }
<span class="nc" id="L2382">            break;</span>
        case DataBuffer.TYPE_DOUBLE:
<span class="nc" id="L2384">            double[] dpixel = (double[]) pixel;</span>
<span class="nc bnc" id="L2385" title="All 2 branches missed.">            for (int c = 0, nc = normOffset; c &lt; numComponents; c++, nc++) {</span>
<span class="nc" id="L2386">                normComponents[nc] = (float) dpixel[c];</span>
            }
<span class="nc" id="L2388">            break;</span>
        default:
<span class="nc" id="L2390">            throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                                        &quot;implemented for transferType &quot; +
                                        transferType);
        }

<span class="nc bnc" id="L2395" title="All 4 branches missed.">        if (supportsAlpha &amp;&amp; isAlphaPremultiplied) {</span>
<span class="nc" id="L2396">            float alpha = normComponents[numColorComponents + normOffset];</span>
<span class="nc bnc" id="L2397" title="All 2 branches missed.">            if (alpha != 0.0f) {</span>
<span class="nc" id="L2398">                float invAlpha = 1.0f / alpha;</span>
<span class="nc bnc" id="L2399" title="All 2 branches missed.">                for (int c = normOffset; c &lt; numColorComponents + normOffset;</span>
<span class="nc" id="L2400">                     c++) {</span>
<span class="nc" id="L2401">                    normComponents[c] *= invAlpha;</span>
                }
            }
        }
<span class="nc bnc" id="L2405" title="All 2 branches missed.">        if (min != null) {</span>
            // Normally (i.e. when this class is not subclassed to override
            // this method), the test (min != null) will be equivalent to
            // the test (nonStdScale).  However, there is an unlikely, but
            // possible case, in which this method is overridden, nonStdScale
            // is set true by initScale(), the subclass method for some
            // reason calls this superclass method, but the min and
            // diffMinMax arrays were never initialized by setupLUTs().  In
            // that case, the right thing to do is follow the intended
            // semantics of this method, and rescale the color components
            // only if the ColorSpace min/max were detected to be other
            // than 0.0/1.0 by setupLUTs().  Note that this implies the
            // transferType is byte, ushort, int, or short - i.e. components
            // derived from float and double pixel data are never rescaled.
<span class="nc bnc" id="L2419" title="All 2 branches missed.">            for (int c = 0; c &lt; numColorComponents; c++) {</span>
<span class="nc" id="L2420">                normComponents[c + normOffset] = min[c] +</span>
                    diffMinMax[c] * normComponents[c + normOffset];
            }
        }
<span class="nc" id="L2424">        return normComponents;</span>
    }

    /**
     * Forces the raster data to match the state specified in the
     * &lt;CODE&gt;isAlphaPremultiplied&lt;/CODE&gt; variable, assuming the data
     * is currently correctly described by this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * It may multiply or divide the color raster data by alpha, or
     * do nothing if the data is in the correct state.  If the data needs
     * to be coerced, this method also returns an instance of
     * this &lt;CODE&gt;ColorModel&lt;/CODE&gt; with
     * the &lt;CODE&gt;isAlphaPremultiplied&lt;/CODE&gt; flag set appropriately.
     * Since &lt;code&gt;ColorModel&lt;/code&gt; can be subclassed, subclasses inherit
     * the implementation of this method and if they don't override it
     * then they throw an exception if they use an unsupported
     * &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @throws NullPointerException if &lt;code&gt;raster&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt; and data coercion is required.
     * @throws UnsupportedOperationException if the transfer type of
     * this &lt;CODE&gt;ComponentColorModel&lt;/CODE&gt;
     * is not one of the supported transfer types:
     * &lt;CODE&gt;DataBuffer.TYPE_BYTE&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_USHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_INT&lt;/CODE&gt;, &lt;CODE&gt;DataBuffer.TYPE_SHORT&lt;/CODE&gt;,
     * &lt;CODE&gt;DataBuffer.TYPE_FLOAT&lt;/CODE&gt;, or &lt;CODE&gt;DataBuffer.TYPE_DOUBLE&lt;/CODE&gt;.
     */
    public ColorModel coerceData (WritableRaster raster,
                                  boolean isAlphaPremultiplied) {
<span class="nc bnc" id="L2452" title="All 4 branches missed.">        if ((supportsAlpha == false) ||</span>
            (this.isAlphaPremultiplied == isAlphaPremultiplied))
        {
            // Nothing to do
<span class="nc" id="L2456">            return this;</span>
        }

<span class="nc" id="L2459">        int w = raster.getWidth();</span>
<span class="nc" id="L2460">        int h = raster.getHeight();</span>
<span class="nc" id="L2461">        int aIdx = raster.getNumBands() - 1;</span>
        float normAlpha;
<span class="nc" id="L2463">        int rminX = raster.getMinX();</span>
<span class="nc" id="L2464">        int rY = raster.getMinY();</span>
        int rX;
<span class="nc bnc" id="L2466" title="All 2 branches missed.">        if (isAlphaPremultiplied) {</span>
<span class="nc bnc" id="L2467" title="All 7 branches missed.">            switch (transferType) {</span>
                case DataBuffer.TYPE_BYTE: {
<span class="nc" id="L2469">                    byte pixel[] = null;</span>
<span class="nc" id="L2470">                    byte zpixel[] = null;</span>
<span class="nc" id="L2471">                    float alphaScale = 1.0f / ((float) ((1&lt;&lt;nBits[aIdx]) - 1));</span>
<span class="nc bnc" id="L2472" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2473">                        rX = rminX;</span>
<span class="nc bnc" id="L2474" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2475">                            pixel = (byte[])raster.getDataElements(rX, rY,</span>
                                                                   pixel);
<span class="nc" id="L2477">                            normAlpha = (pixel[aIdx] &amp; 0xff) * alphaScale;</span>
<span class="nc bnc" id="L2478" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc bnc" id="L2479" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2480">                                    pixel[c] = (byte)((pixel[c] &amp; 0xff) *</span>
                                                      normAlpha + 0.5f);
                                }
<span class="nc" id="L2483">                                raster.setDataElements(rX, rY, pixel);</span>
                            } else {
<span class="nc bnc" id="L2485" title="All 2 branches missed.">                                if (zpixel == null) {</span>
<span class="nc" id="L2486">                                    zpixel = new byte[numComponents];</span>
<span class="nc" id="L2487">                                    java.util.Arrays.fill(zpixel, (byte) 0);</span>
                                }
<span class="nc" id="L2489">                                raster.setDataElements(rX, rY, zpixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2494">                break;</span>
                case DataBuffer.TYPE_USHORT: {
<span class="nc" id="L2496">                    short pixel[] = null;</span>
<span class="nc" id="L2497">                    short zpixel[] = null;</span>
<span class="nc" id="L2498">                    float alphaScale = 1.0f / ((float) ((1&lt;&lt;nBits[aIdx]) - 1));</span>
<span class="nc bnc" id="L2499" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2500">                        rX = rminX;</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2502">                            pixel = (short[])raster.getDataElements(rX, rY,</span>
                                                                    pixel);
<span class="nc" id="L2504">                            normAlpha = (pixel[aIdx] &amp; 0xffff) * alphaScale;</span>
<span class="nc bnc" id="L2505" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc bnc" id="L2506" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2507">                                    pixel[c] = (short)</span>
                                        ((pixel[c] &amp; 0xffff) * normAlpha +
                                         0.5f);
                                }
<span class="nc" id="L2511">                                raster.setDataElements(rX, rY, pixel);</span>
                            } else {
<span class="nc bnc" id="L2513" title="All 2 branches missed.">                                if (zpixel == null) {</span>
<span class="nc" id="L2514">                                    zpixel = new short[numComponents];</span>
<span class="nc" id="L2515">                                    java.util.Arrays.fill(zpixel, (short) 0);</span>
                                }
<span class="nc" id="L2517">                                raster.setDataElements(rX, rY, zpixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2522">                break;</span>
                case DataBuffer.TYPE_INT: {
<span class="nc" id="L2524">                    int pixel[] = null;</span>
<span class="nc" id="L2525">                    int zpixel[] = null;</span>
<span class="nc" id="L2526">                    float alphaScale = 1.0f / ((float) ((1&lt;&lt;nBits[aIdx]) - 1));</span>
<span class="nc bnc" id="L2527" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2528">                        rX = rminX;</span>
<span class="nc bnc" id="L2529" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2530">                            pixel = (int[])raster.getDataElements(rX, rY,</span>
                                                                  pixel);
<span class="nc" id="L2532">                            normAlpha = pixel[aIdx] * alphaScale;</span>
<span class="nc bnc" id="L2533" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc bnc" id="L2534" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2535">                                    pixel[c] = (int) (pixel[c] * normAlpha +</span>
                                                      0.5f);
                                }
<span class="nc" id="L2538">                                raster.setDataElements(rX, rY, pixel);</span>
                            } else {
<span class="nc bnc" id="L2540" title="All 2 branches missed.">                                if (zpixel == null) {</span>
<span class="nc" id="L2541">                                    zpixel = new int[numComponents];</span>
<span class="nc" id="L2542">                                    java.util.Arrays.fill(zpixel, 0);</span>
                                }
<span class="nc" id="L2544">                                raster.setDataElements(rX, rY, zpixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2549">                break;</span>
                case DataBuffer.TYPE_SHORT: {
<span class="nc" id="L2551">                    short pixel[] = null;</span>
<span class="nc" id="L2552">                    short zpixel[] = null;</span>
<span class="nc" id="L2553">                    float alphaScale = 1.0f / 32767.0f;</span>
<span class="nc bnc" id="L2554" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2555">                        rX = rminX;</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2557">                            pixel = (short[]) raster.getDataElements(rX, rY,</span>
                                                                     pixel);
<span class="nc" id="L2559">                            normAlpha = pixel[aIdx] * alphaScale;</span>
<span class="nc bnc" id="L2560" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc bnc" id="L2561" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2562">                                    pixel[c] = (short) (pixel[c] * normAlpha +</span>
                                                        0.5f);
                                }
<span class="nc" id="L2565">                                raster.setDataElements(rX, rY, pixel);</span>
                            } else {
<span class="nc bnc" id="L2567" title="All 2 branches missed.">                                if (zpixel == null) {</span>
<span class="nc" id="L2568">                                    zpixel = new short[numComponents];</span>
<span class="nc" id="L2569">                                    java.util.Arrays.fill(zpixel, (short) 0);</span>
                                }
<span class="nc" id="L2571">                                raster.setDataElements(rX, rY, zpixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2576">                break;</span>
                case DataBuffer.TYPE_FLOAT: {
<span class="nc" id="L2578">                    float pixel[] = null;</span>
<span class="nc" id="L2579">                    float zpixel[] = null;</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2581">                        rX = rminX;</span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2583">                            pixel = (float[]) raster.getDataElements(rX, rY,</span>
                                                                     pixel);
<span class="nc" id="L2585">                            normAlpha = pixel[aIdx];</span>
<span class="nc bnc" id="L2586" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc bnc" id="L2587" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2588">                                    pixel[c] *= normAlpha;</span>
                                }
<span class="nc" id="L2590">                                raster.setDataElements(rX, rY, pixel);</span>
                            } else {
<span class="nc bnc" id="L2592" title="All 2 branches missed.">                                if (zpixel == null) {</span>
<span class="nc" id="L2593">                                    zpixel = new float[numComponents];</span>
<span class="nc" id="L2594">                                    java.util.Arrays.fill(zpixel, 0.0f);</span>
                                }
<span class="nc" id="L2596">                                raster.setDataElements(rX, rY, zpixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2601">                break;</span>
                case DataBuffer.TYPE_DOUBLE: {
<span class="nc" id="L2603">                    double pixel[] = null;</span>
<span class="nc" id="L2604">                    double zpixel[] = null;</span>
<span class="nc bnc" id="L2605" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2606">                        rX = rminX;</span>
<span class="nc bnc" id="L2607" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2608">                            pixel = (double[]) raster.getDataElements(rX, rY,</span>
                                                                      pixel);
<span class="nc" id="L2610">                            double dnormAlpha = pixel[aIdx];</span>
<span class="nc bnc" id="L2611" title="All 2 branches missed.">                            if (dnormAlpha != 0.0) {</span>
<span class="nc bnc" id="L2612" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2613">                                    pixel[c] *= dnormAlpha;</span>
                                }
<span class="nc" id="L2615">                                raster.setDataElements(rX, rY, pixel);</span>
                            } else {
<span class="nc bnc" id="L2617" title="All 2 branches missed.">                                if (zpixel == null) {</span>
<span class="nc" id="L2618">                                    zpixel = new double[numComponents];</span>
<span class="nc" id="L2619">                                    java.util.Arrays.fill(zpixel, 0.0);</span>
                                }
<span class="nc" id="L2621">                                raster.setDataElements(rX, rY, zpixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2626">                break;</span>
                default:
<span class="nc" id="L2628">                    throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                         &quot;implemented for transferType &quot; + transferType);
            }
        }
        else {
            // We are premultiplied and want to divide it out
<span class="nc bnc" id="L2634" title="All 7 branches missed.">            switch (transferType) {</span>
                case DataBuffer.TYPE_BYTE: {
<span class="nc" id="L2636">                    byte pixel[] = null;</span>
<span class="nc" id="L2637">                    float alphaScale = 1.0f / ((float) ((1&lt;&lt;nBits[aIdx]) - 1));</span>
<span class="nc bnc" id="L2638" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2639">                        rX = rminX;</span>
<span class="nc bnc" id="L2640" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2641">                            pixel = (byte[])raster.getDataElements(rX, rY,</span>
                                                                   pixel);
<span class="nc" id="L2643">                            normAlpha = (pixel[aIdx] &amp; 0xff) * alphaScale;</span>
<span class="nc bnc" id="L2644" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc" id="L2645">                                float invAlpha = 1.0f / normAlpha;</span>
<span class="nc bnc" id="L2646" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2647">                                    pixel[c] = (byte)</span>
                                        ((pixel[c] &amp; 0xff) * invAlpha + 0.5f);
                                }
<span class="nc" id="L2650">                                raster.setDataElements(rX, rY, pixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2655">                break;</span>
                case DataBuffer.TYPE_USHORT: {
<span class="nc" id="L2657">                    short pixel[] = null;</span>
<span class="nc" id="L2658">                    float alphaScale = 1.0f / ((float) ((1&lt;&lt;nBits[aIdx]) - 1));</span>
<span class="nc bnc" id="L2659" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2660">                        rX = rminX;</span>
<span class="nc bnc" id="L2661" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2662">                            pixel = (short[])raster.getDataElements(rX, rY,</span>
                                                                    pixel);
<span class="nc" id="L2664">                            normAlpha = (pixel[aIdx] &amp; 0xffff) * alphaScale;</span>
<span class="nc bnc" id="L2665" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc" id="L2666">                                float invAlpha = 1.0f / normAlpha;</span>
<span class="nc bnc" id="L2667" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2668">                                    pixel[c] = (short)</span>
                                        ((pixel[c] &amp; 0xffff) * invAlpha + 0.5f);
                                }
<span class="nc" id="L2671">                                raster.setDataElements(rX, rY, pixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2676">                break;</span>
                case DataBuffer.TYPE_INT: {
<span class="nc" id="L2678">                    int pixel[] = null;</span>
<span class="nc" id="L2679">                    float alphaScale = 1.0f / ((float) ((1&lt;&lt;nBits[aIdx]) - 1));</span>
<span class="nc bnc" id="L2680" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2681">                        rX = rminX;</span>
<span class="nc bnc" id="L2682" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2683">                            pixel = (int[])raster.getDataElements(rX, rY,</span>
                                                                  pixel);
<span class="nc" id="L2685">                            normAlpha = pixel[aIdx] * alphaScale;</span>
<span class="nc bnc" id="L2686" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc" id="L2687">                                float invAlpha = 1.0f / normAlpha;</span>
<span class="nc bnc" id="L2688" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2689">                                    pixel[c] = (int)</span>
                                        (pixel[c] * invAlpha + 0.5f);
                                }
<span class="nc" id="L2692">                                raster.setDataElements(rX, rY, pixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2697">                break;</span>
                case DataBuffer.TYPE_SHORT: {
<span class="nc" id="L2699">                    short pixel[] = null;</span>
<span class="nc" id="L2700">                    float alphaScale = 1.0f / 32767.0f;</span>
<span class="nc bnc" id="L2701" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2702">                        rX = rminX;</span>
<span class="nc bnc" id="L2703" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2704">                            pixel = (short[])raster.getDataElements(rX, rY,</span>
                                                                    pixel);
<span class="nc" id="L2706">                            normAlpha = pixel[aIdx] * alphaScale;</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc" id="L2708">                                float invAlpha = 1.0f / normAlpha;</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2710">                                    pixel[c] = (short)</span>
                                        (pixel[c] * invAlpha + 0.5f);
                                }
<span class="nc" id="L2713">                                raster.setDataElements(rX, rY, pixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2718">                break;</span>
                case DataBuffer.TYPE_FLOAT: {
<span class="nc" id="L2720">                    float pixel[] = null;</span>
<span class="nc bnc" id="L2721" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2722">                        rX = rminX;</span>
<span class="nc bnc" id="L2723" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2724">                            pixel = (float[])raster.getDataElements(rX, rY,</span>
                                                                    pixel);
<span class="nc" id="L2726">                            normAlpha = pixel[aIdx];</span>
<span class="nc bnc" id="L2727" title="All 2 branches missed.">                            if (normAlpha != 0.0f) {</span>
<span class="nc" id="L2728">                                float invAlpha = 1.0f / normAlpha;</span>
<span class="nc bnc" id="L2729" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2730">                                    pixel[c] *= invAlpha;</span>
                                }
<span class="nc" id="L2732">                                raster.setDataElements(rX, rY, pixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2737">                break;</span>
                case DataBuffer.TYPE_DOUBLE: {
<span class="nc" id="L2739">                    double pixel[] = null;</span>
<span class="nc bnc" id="L2740" title="All 2 branches missed.">                    for (int y = 0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L2741">                        rX = rminX;</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">                        for (int x = 0; x &lt; w; x++, rX++) {</span>
<span class="nc" id="L2743">                            pixel = (double[])raster.getDataElements(rX, rY,</span>
                                                                     pixel);
<span class="nc" id="L2745">                            double dnormAlpha = pixel[aIdx];</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">                            if (dnormAlpha != 0.0) {</span>
<span class="nc" id="L2747">                                double invAlpha = 1.0 / dnormAlpha;</span>
<span class="nc bnc" id="L2748" title="All 2 branches missed.">                                for (int c=0; c &lt; aIdx; c++) {</span>
<span class="nc" id="L2749">                                    pixel[c] *= invAlpha;</span>
                                }
<span class="nc" id="L2751">                                raster.setDataElements(rX, rY, pixel);</span>
                            }
                        }
                    }
                }
<span class="nc" id="L2756">                break;</span>
                default:
<span class="nc" id="L2758">                    throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                         &quot;implemented for transferType &quot; + transferType);
            }
        }

        // Return a new color model
<span class="nc bnc" id="L2764" title="All 2 branches missed.">        if (!signed) {</span>
<span class="nc" id="L2765">            return new ComponentColorModel(colorSpace, nBits, supportsAlpha,</span>
                                           isAlphaPremultiplied, transparency,
                                           transferType);
        } else {
<span class="nc" id="L2769">            return new ComponentColorModel(colorSpace, supportsAlpha,</span>
                                           isAlphaPremultiplied, transparency,
                                           transferType);
        }

    }

    /**
      * Returns true if &lt;CODE&gt;raster&lt;/CODE&gt; is compatible with this
      * &lt;CODE&gt;ColorModel&lt;/CODE&gt;; false if it is not.
      *
      * @param raster The &lt;CODE&gt;Raster&lt;/CODE&gt; object to test for compatibility.
      *
      * @return &lt;CODE&gt;true&lt;/CODE&gt; if &lt;CODE&gt;raster&lt;/CODE&gt; is compatible with this
      * &lt;CODE&gt;ColorModel&lt;/CODE&gt;, &lt;CODE&gt;false&lt;/CODE&gt; if it is not.
      */
    public boolean isCompatibleRaster(Raster raster) {

<span class="nc" id="L2787">        SampleModel sm = raster.getSampleModel();</span>

<span class="nc bnc" id="L2789" title="All 2 branches missed.">        if (sm instanceof ComponentSampleModel) {</span>
<span class="nc bnc" id="L2790" title="All 2 branches missed.">            if (sm.getNumBands() != getNumComponents()) {</span>
<span class="nc" id="L2791">                return false;</span>
            }
<span class="nc bnc" id="L2793" title="All 2 branches missed.">            for (int i=0; i&lt;nBits.length; i++) {</span>
<span class="nc bnc" id="L2794" title="All 2 branches missed.">                if (sm.getSampleSize(i) &lt; nBits[i]) {</span>
<span class="nc" id="L2795">                    return false;</span>
                }
            }
<span class="nc bnc" id="L2798" title="All 2 branches missed.">            return (raster.getTransferType() == transferType);</span>
        }
        else {
<span class="nc" id="L2801">            return false;</span>
        }
    }

    /**
     * Creates a &lt;CODE&gt;WritableRaster&lt;/CODE&gt; with the specified width and height,
     * that  has a data layout (&lt;CODE&gt;SampleModel&lt;/CODE&gt;) compatible with
     * this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     *
     * @param w The width of the &lt;CODE&gt;WritableRaster&lt;/CODE&gt; you want to create.
     * @param h The height of the &lt;CODE&gt;WritableRaster&lt;/CODE&gt; you want to create.
     *
     * @return A &lt;CODE&gt;WritableRaster&lt;/CODE&gt; that is compatible with
     * this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * @see WritableRaster
     * @see SampleModel
     */
    public WritableRaster createCompatibleWritableRaster (int w, int h) {
<span class="nc" id="L2819">        int dataSize = w*h*numComponents;</span>
<span class="nc" id="L2820">        WritableRaster raster = null;</span>

<span class="nc bnc" id="L2822" title="All 2 branches missed.">        switch (transferType) {</span>
        case DataBuffer.TYPE_BYTE:
        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L2825">            raster = Raster.createInterleavedRaster(transferType,</span>
                                                    w, h,
                                                    numComponents, null);
<span class="nc" id="L2828">            break;</span>
        default:
<span class="nc" id="L2830">            SampleModel sm = createCompatibleSampleModel(w, h);</span>
<span class="nc" id="L2831">            DataBuffer db = sm.createDataBuffer();</span>
<span class="nc" id="L2832">            raster = Raster.createWritableRaster(sm, db, null);</span>
        }

<span class="nc" id="L2835">        return raster;</span>
    }

    /**
     * Creates a &lt;CODE&gt;SampleModel&lt;/CODE&gt; with the specified width and height,
     * that  has a data layout compatible with this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     *
     * @param w The width of the &lt;CODE&gt;SampleModel&lt;/CODE&gt; you want to create.
     * @param h The height of the &lt;CODE&gt;SampleModel&lt;/CODE&gt; you want to create.
     *
     * @return A &lt;CODE&gt;SampleModel&lt;/CODE&gt; that is compatible with this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     *
     * @see SampleModel
     */
    public SampleModel createCompatibleSampleModel(int w, int h) {
<span class="nc" id="L2851">        int[] bandOffsets = new int[numComponents];</span>
<span class="nc bnc" id="L2852" title="All 2 branches missed.">        for (int i=0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L2853">            bandOffsets[i] = i;</span>
        }
<span class="nc bnc" id="L2855" title="All 2 branches missed.">        switch (transferType) {</span>
        case DataBuffer.TYPE_BYTE:
        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L2858">            return new PixelInterleavedSampleModel(transferType, w, h,</span>
                                                   numComponents,
                                                   w*numComponents,
                                                   bandOffsets);
        default:
<span class="nc" id="L2863">            return new ComponentSampleModel(transferType, w, h,</span>
                                            numComponents,
                                            w*numComponents,
                                            bandOffsets);
        }
    }

    /**
     * Checks whether or not the specified &lt;CODE&gt;SampleModel&lt;/CODE&gt;
     * is compatible with this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     *
     * @param sm The &lt;CODE&gt;SampleModel&lt;/CODE&gt; to test for compatibility.
     *
     * @return &lt;CODE&gt;true&lt;/CODE&gt; if the &lt;CODE&gt;SampleModel&lt;/CODE&gt; is
     * compatible with this &lt;CODE&gt;ColorModel&lt;/CODE&gt;, &lt;CODE&gt;false&lt;/CODE&gt;
     * if it is not.
     *
     * @see SampleModel
     */
    public boolean isCompatibleSampleModel(SampleModel sm) {
<span class="nc bnc" id="L2883" title="All 2 branches missed.">        if (!(sm instanceof ComponentSampleModel)) {</span>
<span class="nc" id="L2884">            return false;</span>
        }

        // Must have the same number of components
<span class="nc bnc" id="L2888" title="All 2 branches missed.">        if (numComponents != sm.getNumBands()) {</span>
<span class="nc" id="L2889">            return false;</span>
        }

<span class="nc bnc" id="L2892" title="All 2 branches missed.">        if (sm.getTransferType() != transferType) {</span>
<span class="nc" id="L2893">            return false;</span>
        }

<span class="nc" id="L2896">        return true;</span>
    }

    /**
     * Returns a &lt;CODE&gt;Raster&lt;/CODE&gt; representing the alpha channel of an image,
     * extracted from the input &lt;CODE&gt;Raster&lt;/CODE&gt;.
     * This method assumes that &lt;CODE&gt;Raster&lt;/CODE&gt; objects associated with
     * this &lt;CODE&gt;ColorModel&lt;/CODE&gt; store the alpha band, if present, as
     * the last band of image data. Returns null if there is no separate spatial
     * alpha channel associated with this &lt;CODE&gt;ColorModel&lt;/CODE&gt;.
     * This method creates a new &lt;CODE&gt;Raster&lt;/CODE&gt;, but will share the data
     * array.
     *
     * @param raster The &lt;CODE&gt;WritableRaster&lt;/CODE&gt; from which to extract the
     * alpha  channel.
     *
     * @return A &lt;CODE&gt;WritableRaster&lt;/CODE&gt; containing the image's alpha channel.
     *
     */
    public WritableRaster getAlphaRaster(WritableRaster raster) {
<span class="nc bnc" id="L2916" title="All 2 branches missed.">        if (hasAlpha() == false) {</span>
<span class="nc" id="L2917">            return null;</span>
        }

<span class="nc" id="L2920">        int x = raster.getMinX();</span>
<span class="nc" id="L2921">        int y = raster.getMinY();</span>
<span class="nc" id="L2922">        int[] band = new int[1];</span>
<span class="nc" id="L2923">        band[0] = raster.getNumBands() - 1;</span>
<span class="nc" id="L2924">        return raster.createWritableChild(x, y, raster.getWidth(),</span>
<span class="nc" id="L2925">                                          raster.getHeight(), x, y,</span>
                                          band);
    }

    /**
     * Compares this color model with another for equality.
     *
     * @param obj The object to compare with this color model.
     * @return &lt;CODE&gt;true&lt;/CODE&gt; if the color model objects are equal,
     * &lt;CODE&gt;false&lt;/CODE&gt; if they are not.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L2937" title="All 2 branches missed.">        if (!super.equals(obj)) {</span>
<span class="nc" id="L2938">            return false;</span>
        }

<span class="nc bnc" id="L2941" title="All 2 branches missed.">        if (obj.getClass() !=  getClass()) {</span>
<span class="nc" id="L2942">            return false;</span>
        }

<span class="nc" id="L2945">        return true;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>