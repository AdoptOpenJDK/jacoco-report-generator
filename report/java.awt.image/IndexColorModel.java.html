<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IndexColorModel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">IndexColorModel.java</span></div><h1>IndexColorModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.Transparency;
import java.awt.color.ColorSpace;
import java.math.BigInteger;

/**
 * The &lt;code&gt;IndexColorModel&lt;/code&gt; class is a &lt;code&gt;ColorModel&lt;/code&gt;
 * class that works with pixel values consisting of a
 * single sample that is an index into a fixed colormap in the default
 * sRGB color space.  The colormap specifies red, green, blue, and
 * optional alpha components corresponding to each index.  All components
 * are represented in the colormap as 8-bit unsigned integral values.
 * Some constructors allow the caller to specify &quot;holes&quot; in the colormap
 * by indicating which colormap entries are valid and which represent
 * unusable colors via the bits set in a &lt;code&gt;BigInteger&lt;/code&gt; object.
 * This color model is similar to an X11 PseudoColor visual.
 * &lt;p&gt;
 * Some constructors provide a means to specify an alpha component
 * for each pixel in the colormap, while others either provide no
 * such means or, in some cases, a flag to indicate whether the
 * colormap data contains alpha values.  If no alpha is supplied to
 * the constructor, an opaque alpha component (alpha = 1.0) is
 * assumed for each entry.
 * An optional transparent pixel value can be supplied that indicates a
 * pixel to be made completely transparent, regardless of any alpha
 * component supplied or assumed for that pixel value.
 * Note that the color components in the colormap of an
 * &lt;code&gt;IndexColorModel&lt;/code&gt; objects are never pre-multiplied with
 * the alpha components.
 * &lt;p&gt;
 * &lt;a name=&quot;transparency&quot;&gt;
 * The transparency of an &lt;code&gt;IndexColorModel&lt;/code&gt; object is
 * determined by examining the alpha components of the colors in the
 * colormap and choosing the most specific value after considering
 * the optional alpha values and any transparent index specified.
 * The transparency value is &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;
 * only if all valid colors in
 * the colormap are opaque and there is no valid transparent pixel.
 * If all valid colors
 * in the colormap are either completely opaque (alpha = 1.0) or
 * completely transparent (alpha = 0.0), which typically occurs when
 * a valid transparent pixel is specified,
 * the value is &lt;code&gt;Transparency.BITMASK&lt;/code&gt;.
 * Otherwise, the value is &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;, indicating
 * that some valid color has an alpha component that is
 * neither completely transparent nor completely opaque
 * (0.0 &amp;lt; alpha &amp;lt; 1.0).
 * &lt;/a&gt;
 *
 * &lt;p&gt;
 * If an &lt;code&gt;IndexColorModel&lt;/code&gt; object has
 * a transparency value of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
 * then the &lt;code&gt;hasAlpha&lt;/code&gt;
 * and &lt;code&gt;getNumComponents&lt;/code&gt; methods
 * (both inherited from &lt;code&gt;ColorModel&lt;/code&gt;)
 * return false and 3, respectively.
 * For any other transparency value,
 * &lt;code&gt;hasAlpha&lt;/code&gt; returns true
 * and &lt;code&gt;getNumComponents&lt;/code&gt; returns 4.
 *
 * &lt;p&gt;
 * &lt;a name=&quot;index_values&quot;&gt;
 * The values used to index into the colormap are taken from the least
 * significant &lt;em&gt;n&lt;/em&gt; bits of pixel representations where
 * &lt;em&gt;n&lt;/em&gt; is based on the pixel size specified in the constructor.
 * For pixel sizes smaller than 8 bits, &lt;em&gt;n&lt;/em&gt; is rounded up to a
 * power of two (3 becomes 4 and 5,6,7 become 8).
 * For pixel sizes between 8 and 16 bits, &lt;em&gt;n&lt;/em&gt; is equal to the
 * pixel size.
 * Pixel sizes larger than 16 bits are not supported by this class.
 * Higher order bits beyond &lt;em&gt;n&lt;/em&gt; are ignored in pixel representations.
 * Index values greater than or equal to the map size, but less than
 * 2&lt;sup&gt;&lt;em&gt;n&lt;/em&gt;&lt;/sup&gt;, are undefined and return 0 for all color and
 * alpha components.
 * &lt;/a&gt;
 * &lt;p&gt;
 * For those methods that use a primitive array pixel representation of
 * type &lt;code&gt;transferType&lt;/code&gt;, the array length is always one.
 * The transfer types supported are &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; and
 * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.  A single int pixel
 * representation is valid for all objects of this class, since it is
 * always possible to represent pixel values used with this class in a
 * single int.  Therefore, methods that use this representation do
 * not throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt; due to an invalid
 * pixel value.
 * &lt;p&gt;
 * Many of the methods in this class are final.  The reason for
 * this is that the underlying native graphics code makes assumptions
 * about the layout and operation of this class and those assumptions
 * are reflected in the implementations of the methods here that are
 * marked final.  You can subclass this class for other reasons, but
 * you cannot override or modify the behaviour of those methods.
 *
 * @see ColorModel
 * @see ColorSpace
 * @see DataBuffer
 *
 */
public class IndexColorModel extends ColorModel {
    private int rgb[];
    private int map_size;
    private int pixel_mask;
<span class="nc" id="L129">    private int transparent_index = -1;</span>
    private boolean allgrayopaque;
    private BigInteger validBits;

<span class="nc" id="L133">    private sun.awt.image.BufImgSurfaceData.ICMColorData colorData = null;</span>

<span class="nc" id="L135">    private static int[] opaqueBits = {8, 8, 8};</span>
<span class="nc" id="L136">    private static int[] alphaBits = {8, 8, 8, 8};</span>

    static private native void initIDs();
    static {
<span class="nc" id="L140">        ColorModel.loadLibraries();</span>
<span class="nc" id="L141">        initIDs();</span>
<span class="nc" id="L142">    }</span>
    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from the specified
     * arrays of red, green, and blue components.  Pixels described
     * by this color model all have alpha components of 255
     * unnormalized (1.0&amp;nbsp;normalized), which means they
     * are fully opaque.  All of the arrays specifying the color
     * components must have at least the specified number of entries.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * Since there is no alpha information in any of the arguments
     * to this constructor, the transparency value is always
     * &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;.
     * The transfer type is the smallest of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;
     * or &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt; that can hold a single pixel.
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param r         the array of red color components
     * @param g         the array of green color components
     * @param b         the array of blue color components
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less
     *         than 1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less
     *         than 1
     */
    public IndexColorModel(int bits, int size,
                           byte r[], byte g[], byte b[]) {
<span class="nc" id="L168">        super(bits, opaqueBits,</span>
<span class="nc" id="L169">              ColorSpace.getInstance(ColorSpace.CS_sRGB),</span>
              false, false, OPAQUE,
<span class="nc" id="L171">              ColorModel.getDefaultTransferType(bits));</span>
<span class="nc bnc" id="L172" title="All 4 branches missed.">        if (bits &lt; 1 || bits &gt; 16) {</span>
<span class="nc" id="L173">            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;</span>
                                               +&quot; 1 and 16.&quot;);
        }
<span class="nc" id="L176">        setRGBs(size, r, g, b, null);</span>
<span class="nc" id="L177">        calculatePixelMask();</span>
<span class="nc" id="L178">    }</span>

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from the given arrays
     * of red, green, and blue components.  Pixels described by this color
     * model all have alpha components of 255 unnormalized
     * (1.0&amp;nbsp;normalized), which means they are fully opaque, except
     * for the indicated pixel to be made transparent.  All of the arrays
     * specifying the color components must have at least the specified
     * number of entries.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be &lt;code&gt;Transparency.OPAQUE&lt;/code&gt; or
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt; depending on the arguments, as
     * specified in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * The transfer type is the smallest of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;
     * or &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt; that can hold a
     * single pixel.
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param r         the array of red color components
     * @param g         the array of green color components
     * @param b         the array of blue color components
     * @param trans     the index of the transparent pixel
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less than
     *          1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less than
     *          1
     */
    public IndexColorModel(int bits, int size,
                           byte r[], byte g[], byte b[], int trans) {
<span class="nc" id="L208">        super(bits, opaqueBits,</span>
<span class="nc" id="L209">              ColorSpace.getInstance(ColorSpace.CS_sRGB),</span>
              false, false, OPAQUE,
<span class="nc" id="L211">              ColorModel.getDefaultTransferType(bits));</span>
<span class="nc bnc" id="L212" title="All 4 branches missed.">        if (bits &lt; 1 || bits &gt; 16) {</span>
<span class="nc" id="L213">            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;</span>
                                               +&quot; 1 and 16.&quot;);
        }
<span class="nc" id="L216">        setRGBs(size, r, g, b, null);</span>
<span class="nc" id="L217">        setTransparentPixel(trans);</span>
<span class="nc" id="L218">        calculatePixelMask();</span>
<span class="nc" id="L219">    }</span>

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from the given
     * arrays of red, green, blue and alpha components.  All of the
     * arrays specifying the components must have at least the specified
     * number of entries.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be any of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt;,
     * or &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;
     * depending on the arguments, as specified
     * in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * The transfer type is the smallest of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;
     * or &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt; that can hold a single pixel.
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param r         the array of red color components
     * @param g         the array of green color components
     * @param b         the array of blue color components
     * @param a         the array of alpha value components
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less
     *           than 1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less
     *           than 1
     */
    public IndexColorModel(int bits, int size,
                           byte r[], byte g[], byte b[], byte a[]) {
<span class="nc" id="L247">        super (bits, alphaBits,</span>
<span class="nc" id="L248">               ColorSpace.getInstance(ColorSpace.CS_sRGB),</span>
               true, false, TRANSLUCENT,
<span class="nc" id="L250">               ColorModel.getDefaultTransferType(bits));</span>
<span class="nc bnc" id="L251" title="All 4 branches missed.">        if (bits &lt; 1 || bits &gt; 16) {</span>
<span class="nc" id="L252">            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;</span>
                                               +&quot; 1 and 16.&quot;);
        }
<span class="nc" id="L255">        setRGBs (size, r, g, b, a);</span>
<span class="nc" id="L256">        calculatePixelMask();</span>
<span class="nc" id="L257">    }</span>

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from a single
     * array of interleaved red, green, blue and optional alpha
     * components.  The array must have enough values in it to
     * fill all of the needed component arrays of the specified
     * size.  The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be any of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt;,
     * or &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;
     * depending on the arguments, as specified
     * in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * The transfer type is the smallest of
     * &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; or &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     * that can hold a single pixel.
     *
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param cmap      the array of color components
     * @param start     the starting offset of the first color component
     * @param hasalpha  indicates whether alpha values are contained in
     *                  the &lt;code&gt;cmap&lt;/code&gt; array
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less
     *           than 1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less
     *           than 1
     */
    public IndexColorModel(int bits, int size, byte cmap[], int start,
                           boolean hasalpha) {
<span class="nc" id="L287">        this(bits, size, cmap, start, hasalpha, -1);</span>
<span class="nc bnc" id="L288" title="All 4 branches missed.">        if (bits &lt; 1 || bits &gt; 16) {</span>
<span class="nc" id="L289">            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;</span>
                                               +&quot; 1 and 16.&quot;);
        }
<span class="nc" id="L292">    }</span>

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from a single array of
     * interleaved red, green, blue and optional alpha components.  The
     * specified transparent index represents a pixel that is made
     * entirely transparent regardless of any alpha value specified
     * for it.  The array must have enough values in it to fill all
     * of the needed component arrays of the specified size.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be any of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt;,
     * or &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;
     * depending on the arguments, as specified
     * in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * The transfer type is the smallest of
     * &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; or &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     * that can hold a single pixel.
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param cmap      the array of color components
     * @param start     the starting offset of the first color component
     * @param hasalpha  indicates whether alpha values are contained in
     *                  the &lt;code&gt;cmap&lt;/code&gt; array
     * @param trans     the index of the fully transparent pixel
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less than
     *               1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less than
     *               1
     */
    public IndexColorModel(int bits, int size, byte cmap[], int start,
                           boolean hasalpha, int trans) {
        // REMIND: This assumes the ordering: RGB[A]
<span class="nc" id="L325">        super(bits, opaqueBits,</span>
<span class="nc" id="L326">              ColorSpace.getInstance(ColorSpace.CS_sRGB),</span>
              false, false, OPAQUE,
<span class="nc" id="L328">              ColorModel.getDefaultTransferType(bits));</span>

<span class="nc bnc" id="L330" title="All 4 branches missed.">        if (bits &lt; 1 || bits &gt; 16) {</span>
<span class="nc" id="L331">            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;</span>
                                               +&quot; 1 and 16.&quot;);
        }
<span class="nc bnc" id="L334" title="All 2 branches missed.">        if (size &lt; 1) {</span>
<span class="nc" id="L335">            throw new IllegalArgumentException(&quot;Map size (&quot;+size+</span>
                                               &quot;) must be &gt;= 1&quot;);
        }
<span class="nc" id="L338">        map_size = size;</span>
<span class="nc" id="L339">        rgb = new int[calcRealMapSize(bits, size)];</span>
<span class="nc" id="L340">        int j = start;</span>
<span class="nc" id="L341">        int alpha = 0xff;</span>
<span class="nc" id="L342">        boolean allgray = true;</span>
<span class="nc" id="L343">        int transparency = OPAQUE;</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L345">            int r = cmap[j++] &amp; 0xff;</span>
<span class="nc" id="L346">            int g = cmap[j++] &amp; 0xff;</span>
<span class="nc" id="L347">            int b = cmap[j++] &amp; 0xff;</span>
<span class="nc bnc" id="L348" title="All 6 branches missed.">            allgray = allgray &amp;&amp; (r == g) &amp;&amp; (g == b);</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">            if (hasalpha) {</span>
<span class="nc" id="L350">                alpha = cmap[j++] &amp; 0xff;</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                if (alpha != 0xff) {</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                    if (alpha == 0x00) {</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">                        if (transparency == OPAQUE) {</span>
<span class="nc" id="L354">                            transparency = BITMASK;</span>
                        }
<span class="nc bnc" id="L356" title="All 2 branches missed.">                        if (transparent_index &lt; 0) {</span>
<span class="nc" id="L357">                            transparent_index = i;</span>
                        }
                    } else {
<span class="nc" id="L360">                        transparency = TRANSLUCENT;</span>
                    }
<span class="nc" id="L362">                    allgray = false;</span>
                }
            }
<span class="nc" id="L365">            rgb[i] = (alpha &lt;&lt; 24) | (r &lt;&lt; 16) | (g &lt;&lt; 8) | b;</span>
        }
<span class="nc" id="L367">        this.allgrayopaque = allgray;</span>
<span class="nc" id="L368">        setTransparency(transparency);</span>
<span class="nc" id="L369">        setTransparentPixel(trans);</span>
<span class="nc" id="L370">        calculatePixelMask();</span>
<span class="nc" id="L371">    }</span>

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from an array of
     * ints where each int is comprised of red, green, blue, and
     * optional alpha components in the default RGB color model format.
     * The specified transparent index represents a pixel that is made
     * entirely transparent regardless of any alpha value specified
     * for it.  The array must have enough values in it to fill all
     * of the needed component arrays of the specified size.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be any of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt;,
     * or &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;
     * depending on the arguments, as specified
     * in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * @param bits      the number of bits each pixel occupies
     * @param size      the size of the color component arrays
     * @param cmap      the array of color components
     * @param start     the starting offset of the first color component
     * @param hasalpha  indicates whether alpha values are contained in
     *                  the &lt;code&gt;cmap&lt;/code&gt; array
     * @param trans     the index of the fully transparent pixel
     * @param transferType the data type of the array used to represent
     *           pixel values.  The data type must be either
     *           &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; or
     *           &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less
     *           than 1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less
     *           than 1
     * @throws IllegalArgumentException if &lt;code&gt;transferType&lt;/code&gt; is not
     *           one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; or
     *           &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     */
    public IndexColorModel(int bits, int size,
                           int cmap[], int start,
                           boolean hasalpha, int trans, int transferType) {
        // REMIND: This assumes the ordering: RGB[A]
<span class="nc" id="L410">        super(bits, opaqueBits,</span>
<span class="nc" id="L411">              ColorSpace.getInstance(ColorSpace.CS_sRGB),</span>
              false, false, OPAQUE,
              transferType);

<span class="nc bnc" id="L415" title="All 4 branches missed.">        if (bits &lt; 1 || bits &gt; 16) {</span>
<span class="nc" id="L416">            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;</span>
                                               +&quot; 1 and 16.&quot;);
        }
<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (size &lt; 1) {</span>
<span class="nc" id="L420">            throw new IllegalArgumentException(&quot;Map size (&quot;+size+</span>
                                               &quot;) must be &gt;= 1&quot;);
        }
<span class="nc bnc" id="L423" title="All 4 branches missed.">        if ((transferType != DataBuffer.TYPE_BYTE) &amp;&amp;</span>
            (transferType != DataBuffer.TYPE_USHORT)) {
<span class="nc" id="L425">            throw new IllegalArgumentException(&quot;transferType must be either&quot; +</span>
                &quot;DataBuffer.TYPE_BYTE or DataBuffer.TYPE_USHORT&quot;);
        }

<span class="nc" id="L429">        setRGBs(size, cmap, start, hasalpha);</span>
<span class="nc" id="L430">        setTransparentPixel(trans);</span>
<span class="nc" id="L431">        calculatePixelMask();</span>
<span class="nc" id="L432">    }</span>

    /**
     * Constructs an &lt;code&gt;IndexColorModel&lt;/code&gt; from an
     * &lt;code&gt;int&lt;/code&gt; array where each &lt;code&gt;int&lt;/code&gt; is
     * comprised of red, green, blue, and alpha
     * components in the default RGB color model format.
     * The array must have enough values in it to fill all
     * of the needed component arrays of the specified size.
     * The &lt;code&gt;ColorSpace&lt;/code&gt; is the default sRGB space.
     * The transparency value may be any of &lt;code&gt;Transparency.OPAQUE&lt;/code&gt;,
     * &lt;code&gt;Transparency.BITMASK&lt;/code&gt;,
     * or &lt;code&gt;Transparency.TRANSLUCENT&lt;/code&gt;
     * depending on the arguments, as specified
     * in the &lt;a href=&quot;#transparency&quot;&gt;class description&lt;/a&gt; above.
     * The transfer type must be one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.
     * The &lt;code&gt;BigInteger&lt;/code&gt; object specifies the valid/invalid pixels
     * in the &lt;code&gt;cmap&lt;/code&gt; array.  A pixel is valid if the
     * &lt;code&gt;BigInteger&lt;/code&gt; value at that index is set, and is invalid
     * if the &lt;code&gt;BigInteger&lt;/code&gt; bit  at that index is not set.
     * @param bits the number of bits each pixel occupies
     * @param size the size of the color component array
     * @param cmap the array of color components
     * @param start the starting offset of the first color component
     * @param transferType the specified data type
     * @param validBits a &lt;code&gt;BigInteger&lt;/code&gt; object.  If a bit is
     *    set in the BigInteger, the pixel at that index is valid.
     *    If a bit is not set, the pixel at that index
     *    is considered invalid.  If null, all pixels are valid.
     *    Only bits from 0 to the map size are considered.
     * @throws IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is less
     *           than 1 or greater than 16
     * @throws IllegalArgumentException if &lt;code&gt;size&lt;/code&gt; is less
     *           than 1
     * @throws IllegalArgumentException if &lt;code&gt;transferType&lt;/code&gt; is not
     *           one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt; or
     *           &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;
     *
     * @since 1.3
     */
    public IndexColorModel(int bits, int size, int cmap[], int start,
                           int transferType, BigInteger validBits) {
<span class="nc" id="L475">        super (bits, alphaBits,</span>
<span class="nc" id="L476">               ColorSpace.getInstance(ColorSpace.CS_sRGB),</span>
               true, false, TRANSLUCENT,
               transferType);

<span class="nc bnc" id="L480" title="All 4 branches missed.">        if (bits &lt; 1 || bits &gt; 16) {</span>
<span class="nc" id="L481">            throw new IllegalArgumentException(&quot;Number of bits must be between&quot;</span>
                                               +&quot; 1 and 16.&quot;);
        }
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (size &lt; 1) {</span>
<span class="nc" id="L485">            throw new IllegalArgumentException(&quot;Map size (&quot;+size+</span>
                                               &quot;) must be &gt;= 1&quot;);
        }
<span class="nc bnc" id="L488" title="All 4 branches missed.">        if ((transferType != DataBuffer.TYPE_BYTE) &amp;&amp;</span>
            (transferType != DataBuffer.TYPE_USHORT)) {
<span class="nc" id="L490">            throw new IllegalArgumentException(&quot;transferType must be either&quot; +</span>
                &quot;DataBuffer.TYPE_BYTE or DataBuffer.TYPE_USHORT&quot;);
        }

<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (validBits != null) {</span>
            // Check to see if it is all valid
<span class="nc bnc" id="L496" title="All 2 branches missed.">            for (int i=0; i &lt; size; i++) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                if (!validBits.testBit(i)) {</span>
<span class="nc" id="L498">                    this.validBits = validBits;</span>
<span class="nc" id="L499">                    break;</span>
                }
            }
        }

<span class="nc" id="L504">        setRGBs(size, cmap, start, true);</span>
<span class="nc" id="L505">        calculatePixelMask();</span>
<span class="nc" id="L506">    }</span>

    private void setRGBs(int size, byte r[], byte g[], byte b[], byte a[]) {
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (size &lt; 1) {</span>
<span class="nc" id="L510">            throw new IllegalArgumentException(&quot;Map size (&quot;+size+</span>
                                               &quot;) must be &gt;= 1&quot;);
        }
<span class="nc" id="L513">        map_size = size;</span>
<span class="nc" id="L514">        rgb = new int[calcRealMapSize(pixel_bits, size)];</span>
<span class="nc" id="L515">        int alpha = 0xff;</span>
<span class="nc" id="L516">        int transparency = OPAQUE;</span>
<span class="nc" id="L517">        boolean allgray = true;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L519">            int rc = r[i] &amp; 0xff;</span>
<span class="nc" id="L520">            int gc = g[i] &amp; 0xff;</span>
<span class="nc" id="L521">            int bc = b[i] &amp; 0xff;</span>
<span class="nc bnc" id="L522" title="All 6 branches missed.">            allgray = allgray &amp;&amp; (rc == gc) &amp;&amp; (gc == bc);</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">            if (a != null) {</span>
<span class="nc" id="L524">                alpha = a[i] &amp; 0xff;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">                if (alpha != 0xff) {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">                    if (alpha == 0x00) {</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">                        if (transparency == OPAQUE) {</span>
<span class="nc" id="L528">                            transparency = BITMASK;</span>
                        }
<span class="nc bnc" id="L530" title="All 2 branches missed.">                        if (transparent_index &lt; 0) {</span>
<span class="nc" id="L531">                            transparent_index = i;</span>
                        }
                    } else {
<span class="nc" id="L534">                        transparency = TRANSLUCENT;</span>
                    }
<span class="nc" id="L536">                    allgray = false;</span>
                }
            }
<span class="nc" id="L539">            rgb[i] = (alpha &lt;&lt; 24) | (rc &lt;&lt; 16) | (gc &lt;&lt; 8) | bc;</span>
        }
<span class="nc" id="L541">        this.allgrayopaque = allgray;</span>
<span class="nc" id="L542">        setTransparency(transparency);</span>
<span class="nc" id="L543">    }</span>

    private void setRGBs(int size, int cmap[], int start, boolean hasalpha) {
<span class="nc" id="L546">        map_size = size;</span>
<span class="nc" id="L547">        rgb = new int[calcRealMapSize(pixel_bits, size)];</span>
<span class="nc" id="L548">        int j = start;</span>
<span class="nc" id="L549">        int transparency = OPAQUE;</span>
<span class="nc" id="L550">        boolean allgray = true;</span>
<span class="nc" id="L551">        BigInteger validBits = this.validBits;</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        for (int i = 0; i &lt; size; i++, j++) {</span>
<span class="nc bnc" id="L553" title="All 4 branches missed.">            if (validBits != null &amp;&amp; !validBits.testBit(i)) {</span>
<span class="nc" id="L554">                continue;</span>
            }
<span class="nc" id="L556">            int cmaprgb = cmap[j];</span>
<span class="nc" id="L557">            int r = (cmaprgb &gt;&gt; 16) &amp; 0xff;</span>
<span class="nc" id="L558">            int g = (cmaprgb &gt;&gt;  8) &amp; 0xff;</span>
<span class="nc" id="L559">            int b = (cmaprgb      ) &amp; 0xff;</span>
<span class="nc bnc" id="L560" title="All 6 branches missed.">            allgray = allgray &amp;&amp; (r == g) &amp;&amp; (g == b);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">            if (hasalpha) {</span>
<span class="nc" id="L562">                int alpha = cmaprgb &gt;&gt;&gt; 24;</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                if (alpha != 0xff) {</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                    if (alpha == 0x00) {</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                        if (transparency == OPAQUE) {</span>
<span class="nc" id="L566">                            transparency = BITMASK;</span>
                        }
<span class="nc bnc" id="L568" title="All 2 branches missed.">                        if (transparent_index &lt; 0) {</span>
<span class="nc" id="L569">                            transparent_index = i;</span>
                        }
                    } else {
<span class="nc" id="L572">                        transparency = TRANSLUCENT;</span>
                    }
<span class="nc" id="L574">                    allgray = false;</span>
                }
<span class="nc" id="L576">            } else {</span>
<span class="nc" id="L577">                cmaprgb |= 0xff000000;</span>
            }
<span class="nc" id="L579">            rgb[i] = cmaprgb;</span>
        }
<span class="nc" id="L581">        this.allgrayopaque = allgray;</span>
<span class="nc" id="L582">        setTransparency(transparency);</span>
<span class="nc" id="L583">    }</span>

    private int calcRealMapSize(int bits, int size) {
<span class="nc" id="L586">        int newSize = Math.max(1 &lt;&lt; bits, size);</span>
<span class="nc" id="L587">        return Math.max(newSize, 256);</span>
    }

    private BigInteger getAllValid() {
<span class="nc" id="L591">        int numbytes = (map_size+7)/8;</span>
<span class="nc" id="L592">        byte[] valid = new byte[numbytes];</span>
<span class="nc" id="L593">        java.util.Arrays.fill(valid, (byte)0xff);</span>
<span class="nc" id="L594">        valid[0] = (byte)(0xff &gt;&gt;&gt; (numbytes*8 - map_size));</span>

<span class="nc" id="L596">        return new BigInteger(1, valid);</span>
    }

    /**
     * Returns the transparency.  Returns either OPAQUE, BITMASK,
     * or TRANSLUCENT
     * @return the transparency of this &lt;code&gt;IndexColorModel&lt;/code&gt;
     * @see Transparency#OPAQUE
     * @see Transparency#BITMASK
     * @see Transparency#TRANSLUCENT
     */
    public int getTransparency() {
<span class="nc" id="L608">        return transparency;</span>
    }

    /**
     * Returns an array of the number of bits for each color/alpha component.
     * The array contains the color components in the order red, green,
     * blue, followed by the alpha component, if present.
     * @return an array containing the number of bits of each color
     *         and alpha component of this &lt;code&gt;IndexColorModel&lt;/code&gt;
     */
    public int[] getComponentSize() {
<span class="nc bnc" id="L619" title="All 2 branches missed.">        if (nBits == null) {</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            if (supportsAlpha) {</span>
<span class="nc" id="L621">                nBits = new int[4];</span>
<span class="nc" id="L622">                nBits[3] = 8;</span>
            }
            else {
<span class="nc" id="L625">                nBits = new int[3];</span>
            }
<span class="nc" id="L627">            nBits[0] = nBits[1] = nBits[2] = 8;</span>
        }
<span class="nc" id="L629">        return nBits.clone();</span>
    }

    /**
     * Returns the size of the color/alpha component arrays in this
     * &lt;code&gt;IndexColorModel&lt;/code&gt;.
     * @return the size of the color and alpha component arrays.
     */
    final public int getMapSize() {
<span class="nc" id="L638">        return map_size;</span>
    }

    /**
     * Returns the index of a transparent pixel in this
     * &lt;code&gt;IndexColorModel&lt;/code&gt; or -1 if there is no pixel
     * with an alpha value of 0.  If a transparent pixel was
     * explicitly specified in one of the constructors by its
     * index, then that index will be preferred, otherwise,
     * the index of any pixel which happens to be fully transparent
     * may be returned.
     * @return the index of a transparent pixel in this
     *         &lt;code&gt;IndexColorModel&lt;/code&gt; object, or -1 if there
     *         is no such pixel
     */
    final public int getTransparentPixel() {
<span class="nc" id="L654">        return transparent_index;</span>
    }

    /**
     * Copies the array of red color components into the specified array.
     * Only the initial entries of the array as specified by
     * {@link #getMapSize() getMapSize} are written.
     * @param r the specified array into which the elements of the
     *      array of red color components are copied
     */
    final public void getReds(byte r[]) {
<span class="nc bnc" id="L665" title="All 2 branches missed.">        for (int i = 0; i &lt; map_size; i++) {</span>
<span class="nc" id="L666">            r[i] = (byte) (rgb[i] &gt;&gt; 16);</span>
        }
<span class="nc" id="L668">    }</span>

    /**
     * Copies the array of green color components into the specified array.
     * Only the initial entries of the array as specified by
     * &lt;code&gt;getMapSize&lt;/code&gt; are written.
     * @param g the specified array into which the elements of the
     *      array of green color components are copied
     */
    final public void getGreens(byte g[]) {
<span class="nc bnc" id="L678" title="All 2 branches missed.">        for (int i = 0; i &lt; map_size; i++) {</span>
<span class="nc" id="L679">            g[i] = (byte) (rgb[i] &gt;&gt; 8);</span>
        }
<span class="nc" id="L681">    }</span>

    /**
     * Copies the array of blue color components into the specified array.
     * Only the initial entries of the array as specified by
     * &lt;code&gt;getMapSize&lt;/code&gt; are written.
     * @param b the specified array into which the elements of the
     *      array of blue color components are copied
     */
    final public void getBlues(byte b[]) {
<span class="nc bnc" id="L691" title="All 2 branches missed.">        for (int i = 0; i &lt; map_size; i++) {</span>
<span class="nc" id="L692">            b[i] = (byte) rgb[i];</span>
        }
<span class="nc" id="L694">    }</span>

    /**
     * Copies the array of alpha transparency components into the
     * specified array.  Only the initial entries of the array as specified
     * by &lt;code&gt;getMapSize&lt;/code&gt; are written.
     * @param a the specified array into which the elements of the
     *      array of alpha components are copied
     */
    final public void getAlphas(byte a[]) {
<span class="nc bnc" id="L704" title="All 2 branches missed.">        for (int i = 0; i &lt; map_size; i++) {</span>
<span class="nc" id="L705">            a[i] = (byte) (rgb[i] &gt;&gt; 24);</span>
        }
<span class="nc" id="L707">    }</span>

    /**
     * Converts data for each index from the color and alpha component
     * arrays to an int in the default RGB ColorModel format and copies
     * the resulting 32-bit ARGB values into the specified array.  Only
     * the initial entries of the array as specified by
     * &lt;code&gt;getMapSize&lt;/code&gt; are
     * written.
     * @param rgb the specified array into which the converted ARGB
     *        values from this array of color and alpha components
     *        are copied.
     */
    final public void getRGBs(int rgb[]) {
<span class="nc" id="L721">        System.arraycopy(this.rgb, 0, rgb, 0, map_size);</span>
<span class="nc" id="L722">    }</span>

    private void setTransparentPixel(int trans) {
<span class="nc bnc" id="L725" title="All 4 branches missed.">        if (trans &gt;= 0 &amp;&amp; trans &lt; map_size) {</span>
<span class="nc" id="L726">            rgb[trans] &amp;= 0x00ffffff;</span>
<span class="nc" id="L727">            transparent_index = trans;</span>
<span class="nc" id="L728">            allgrayopaque = false;</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">            if (this.transparency == OPAQUE) {</span>
<span class="nc" id="L730">                setTransparency(BITMASK);</span>
            }
        }
<span class="nc" id="L733">    }</span>

    private void setTransparency(int transparency) {
<span class="nc bnc" id="L736" title="All 2 branches missed.">        if (this.transparency != transparency) {</span>
<span class="nc" id="L737">            this.transparency = transparency;</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">            if (transparency == OPAQUE) {</span>
<span class="nc" id="L739">                supportsAlpha = false;</span>
<span class="nc" id="L740">                numComponents = 3;</span>
<span class="nc" id="L741">                nBits = opaqueBits;</span>
            } else {
<span class="nc" id="L743">                supportsAlpha = true;</span>
<span class="nc" id="L744">                numComponents = 4;</span>
<span class="nc" id="L745">                nBits = alphaBits;</span>
            }
        }
<span class="nc" id="L748">    }</span>

    /**
     * This method is called from the constructors to set the pixel_mask
     * value, which is based on the value of pixel_bits.  The pixel_mask
     * value is used to mask off the pixel parameters for methods such
     * as getRed(), getGreen(), getBlue(), getAlpha(), and getRGB().
     */
    private final void calculatePixelMask() {
        // Note that we adjust the mask so that our masking behavior here
        // is consistent with that of our native rendering loops.
<span class="nc" id="L759">        int maskbits = pixel_bits;</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if (maskbits == 3) {</span>
<span class="nc" id="L761">            maskbits = 4;</span>
<span class="nc bnc" id="L762" title="All 4 branches missed.">        } else if (maskbits &gt; 4 &amp;&amp; maskbits &lt; 8) {</span>
<span class="nc" id="L763">            maskbits = 8;</span>
        }
<span class="nc" id="L765">        pixel_mask = (1 &lt;&lt; maskbits) - 1;</span>
<span class="nc" id="L766">    }</span>

    /**
     * Returns the red color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  The pixel value
     * is specified as an int.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of the pixel value, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * calculate the returned value.
     * The returned value is a non pre-multiplied value.
     * @param pixel the specified pixel
     * @return the value of the red color component for the specified pixel
     */
    final public int getRed(int pixel) {
<span class="nc" id="L780">        return (rgb[pixel &amp; pixel_mask] &gt;&gt; 16) &amp; 0xff;</span>
    }

    /**
     * Returns the green color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  The pixel value
     * is specified as an int.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of the pixel value, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * calculate the returned value.
     * The returned value is a non pre-multiplied value.
     * @param pixel the specified pixel
     * @return the value of the green color component for the specified pixel
     */
    final public int getGreen(int pixel) {
<span class="nc" id="L795">        return (rgb[pixel &amp; pixel_mask] &gt;&gt; 8) &amp; 0xff;</span>
    }

    /**
     * Returns the blue color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  The pixel value
     * is specified as an int.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of the pixel value, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * calculate the returned value.
     * The returned value is a non pre-multiplied value.
     * @param pixel the specified pixel
     * @return the value of the blue color component for the specified pixel
     */
    final public int getBlue(int pixel) {
<span class="nc" id="L810">        return rgb[pixel &amp; pixel_mask] &amp; 0xff;</span>
    }

    /**
     * Returns the alpha component for the specified pixel, scaled
     * from 0 to 255.  The pixel value is specified as an int.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of the pixel value, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * calculate the returned value.
     * @param pixel the specified pixel
     * @return the value of the alpha component for the specified pixel
     */
    final public int getAlpha(int pixel) {
<span class="nc" id="L823">        return (rgb[pixel &amp; pixel_mask] &gt;&gt; 24) &amp; 0xff;</span>
    }

    /**
     * Returns the color/alpha components of the pixel in the default
     * RGB color model format.  The pixel value is specified as an int.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of the pixel value, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * calculate the returned value.
     * The returned value is in a non pre-multiplied format.
     * @param pixel the specified pixel
     * @return the color and alpha components of the specified pixel
     * @see ColorModel#getRGBdefault
     */
    final public int getRGB(int pixel) {
<span class="nc" id="L838">        return rgb[pixel &amp; pixel_mask];</span>
    }

    private static final int CACHESIZE = 40;
<span class="nc" id="L842">    private int lookupcache[] = new int[CACHESIZE];</span>

    /**
     * Returns a data element array representation of a pixel in this
     * ColorModel, given an integer pixel representation in the
     * default RGB color model.  This array can then be passed to the
     * {@link WritableRaster#setDataElements(int, int, java.lang.Object) setDataElements}
     * method of a {@link WritableRaster} object.  If the pixel variable is
     * &lt;code&gt;null&lt;/code&gt;, a new array is allocated.  If &lt;code&gt;pixel&lt;/code&gt;
     * is not &lt;code&gt;null&lt;/code&gt;, it must be
     * a primitive array of type &lt;code&gt;transferType&lt;/code&gt;; otherwise, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel
     * value for this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel array is returned.
     * &lt;p&gt;
     * Since &lt;code&gt;IndexColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then they throw an exception if they use an
     * unsupported &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param rgb the integer pixel representation in the default RGB
     * color model
     * @param pixel the specified pixel
     * @return an array representation of the specified pixel in this
     *  &lt;code&gt;IndexColorModel&lt;/code&gt;.
     * @throws ClassCastException if &lt;code&gt;pixel&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt;
     * @throws UnsupportedOperationException if &lt;code&gt;transferType&lt;/code&gt;
     *         is invalid
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     */
    public synchronized Object getDataElements(int rgb, Object pixel) {
<span class="nc" id="L879">        int red = (rgb&gt;&gt;16) &amp; 0xff;</span>
<span class="nc" id="L880">        int green = (rgb&gt;&gt;8) &amp; 0xff;</span>
<span class="nc" id="L881">        int blue  = rgb &amp; 0xff;</span>
<span class="nc" id="L882">        int alpha = (rgb&gt;&gt;&gt;24);</span>
<span class="nc" id="L883">        int pix = 0;</span>

        // Note that pixels are stored at lookupcache[2*i]
        // and the rgb that was searched is stored at
        // lookupcache[2*i+1].  Also, the pixel is first
        // inverted using the unary complement operator
        // before storing in the cache so it can never be 0.
<span class="nc bnc" id="L890" title="All 2 branches missed.">        for (int i = CACHESIZE - 2; i &gt;= 0; i -= 2) {</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">            if ((pix = lookupcache[i]) == 0) {</span>
<span class="nc" id="L892">                break;</span>
            }
<span class="nc bnc" id="L894" title="All 2 branches missed.">            if (rgb == lookupcache[i+1]) {</span>
<span class="nc" id="L895">                return installpixel(pixel, ~pix);</span>
            }
        }

<span class="nc bnc" id="L899" title="All 2 branches missed.">        if (allgrayopaque) {</span>
            // IndexColorModel objects are all tagged as
            // non-premultiplied so ignore the alpha value
            // of the incoming color, convert the
            // non-premultiplied color components to a
            // grayscale value and search for the closest
            // gray value in the palette.  Since all colors
            // in the palette are gray, we only need compare
            // to one of the color components for a match
            // using a simple linear distance formula.

<span class="nc" id="L910">            int minDist = 256;</span>
            int d;
<span class="nc" id="L912">            int gray = (int) (red*77 + green*150 + blue*29 + 128)/256;</span>

<span class="nc bnc" id="L914" title="All 2 branches missed.">            for (int i = 0; i &lt; map_size; i++) {</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">                if (this.rgb[i] == 0x0) {</span>
                    // For allgrayopaque colormaps, entries are 0
                    // iff they are an invalid color and should be
                    // ignored during color searches.
<span class="nc" id="L919">                    continue;</span>
                }
<span class="nc" id="L921">                d = (this.rgb[i] &amp; 0xff) - gray;</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">                if (d &lt; 0) d = -d;</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                if (d &lt; minDist) {</span>
<span class="nc" id="L924">                    pix = i;</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                    if (d == 0) {</span>
<span class="nc" id="L926">                        break;</span>
                    }
<span class="nc" id="L928">                    minDist = d;</span>
                }
            }
<span class="nc bnc" id="L931" title="All 2 branches missed.">        } else if (transparency == OPAQUE) {</span>
            // IndexColorModel objects are all tagged as
            // non-premultiplied so ignore the alpha value
            // of the incoming color and search for closest
            // color match independently using a 3 component
            // Euclidean distance formula.
            // For opaque colormaps, palette entries are 0
            // iff they are an invalid color and should be
            // ignored during color searches.
            // As an optimization, exact color searches are
            // likely to be fairly common in opaque colormaps
            // so first we will do a quick search for an
            // exact match.

<span class="nc" id="L945">            int smallestError = Integer.MAX_VALUE;</span>
<span class="nc" id="L946">            int lut[] = this.rgb;</span>
            int lutrgb;
<span class="nc bnc" id="L948" title="All 2 branches missed.">            for (int i=0; i &lt; map_size; i++) {</span>
<span class="nc" id="L949">                lutrgb = lut[i];</span>
<span class="nc bnc" id="L950" title="All 4 branches missed.">                if (lutrgb == rgb &amp;&amp; lutrgb != 0) {</span>
<span class="nc" id="L951">                    pix = i;</span>
<span class="nc" id="L952">                    smallestError = 0;</span>
<span class="nc" id="L953">                    break;</span>
                }
            }

<span class="nc bnc" id="L957" title="All 2 branches missed.">            if (smallestError != 0) {</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">                for (int i=0; i &lt; map_size; i++) {</span>
<span class="nc" id="L959">                    lutrgb = lut[i];</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">                    if (lutrgb == 0) {</span>
<span class="nc" id="L961">                        continue;</span>
                    }

<span class="nc" id="L964">                    int tmp = ((lutrgb &gt;&gt; 16) &amp; 0xff) - red;</span>
<span class="nc" id="L965">                    int currentError = tmp*tmp;</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">                    if (currentError &lt; smallestError) {</span>
<span class="nc" id="L967">                        tmp = ((lutrgb &gt;&gt; 8) &amp; 0xff) - green;</span>
<span class="nc" id="L968">                        currentError += tmp * tmp;</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">                        if (currentError &lt; smallestError) {</span>
<span class="nc" id="L970">                            tmp = (lutrgb &amp; 0xff) - blue;</span>
<span class="nc" id="L971">                            currentError += tmp * tmp;</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">                            if (currentError &lt; smallestError) {</span>
<span class="nc" id="L973">                                pix = i;</span>
<span class="nc" id="L974">                                smallestError = currentError;</span>
                            }
                        }
                    }
                }
            }
<span class="nc bnc" id="L980" title="All 4 branches missed.">        } else if (alpha == 0 &amp;&amp; transparent_index &gt;= 0) {</span>
            // Special case - transparent color maps to the
            // specified transparent pixel, if there is one

<span class="nc" id="L984">            pix = transparent_index;</span>
        } else {
            // IndexColorModel objects are all tagged as
            // non-premultiplied so use non-premultiplied
            // color components in the distance calculations.
            // Look for closest match using a 4 component
            // Euclidean distance formula.

<span class="nc" id="L992">            int smallestError = Integer.MAX_VALUE;</span>
<span class="nc" id="L993">            int lut[] = this.rgb;</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">            for (int i=0; i &lt; map_size; i++) {</span>
<span class="nc" id="L995">                int lutrgb = lut[i];</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">                if (lutrgb == rgb) {</span>
<span class="nc bnc" id="L997" title="All 4 branches missed.">                    if (validBits != null &amp;&amp; !validBits.testBit(i)) {</span>
<span class="nc" id="L998">                        continue;</span>
                    }
<span class="nc" id="L1000">                    pix = i;</span>
<span class="nc" id="L1001">                    break;</span>
                }

<span class="nc" id="L1004">                int tmp = ((lutrgb &gt;&gt; 16) &amp; 0xff) - red;</span>
<span class="nc" id="L1005">                int currentError = tmp*tmp;</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                if (currentError &lt; smallestError) {</span>
<span class="nc" id="L1007">                    tmp = ((lutrgb &gt;&gt; 8) &amp; 0xff) - green;</span>
<span class="nc" id="L1008">                    currentError += tmp * tmp;</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                    if (currentError &lt; smallestError) {</span>
<span class="nc" id="L1010">                        tmp = (lutrgb &amp; 0xff) - blue;</span>
<span class="nc" id="L1011">                        currentError += tmp * tmp;</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                        if (currentError &lt; smallestError) {</span>
<span class="nc" id="L1013">                            tmp = (lutrgb &gt;&gt;&gt; 24) - alpha;</span>
<span class="nc" id="L1014">                            currentError += tmp * tmp;</span>
<span class="nc bnc" id="L1015" title="All 4 branches missed.">                            if (currentError &lt; smallestError &amp;&amp;</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">                                (validBits == null || validBits.testBit(i)))</span>
                            {
<span class="nc" id="L1018">                                pix = i;</span>
<span class="nc" id="L1019">                                smallestError = currentError;</span>
                            }
                        }
                    }
                }
            }
        }
<span class="nc" id="L1026">        System.arraycopy(lookupcache, 2, lookupcache, 0, CACHESIZE - 2);</span>
<span class="nc" id="L1027">        lookupcache[CACHESIZE - 1] = rgb;</span>
<span class="nc" id="L1028">        lookupcache[CACHESIZE - 2] = ~pix;</span>
<span class="nc" id="L1029">        return installpixel(pixel, pix);</span>
    }

    private Object installpixel(Object pixel, int pix) {
<span class="nc bnc" id="L1033" title="All 4 branches missed.">        switch (transferType) {</span>
        case DataBuffer.TYPE_INT:
            int[] intObj;
<span class="nc bnc" id="L1036" title="All 2 branches missed.">            if (pixel == null) {</span>
<span class="nc" id="L1037">                pixel = intObj = new int[1];</span>
            } else {
<span class="nc" id="L1039">                intObj = (int[]) pixel;</span>
            }
<span class="nc" id="L1041">            intObj[0] = pix;</span>
<span class="nc" id="L1042">            break;</span>
        case DataBuffer.TYPE_BYTE:
            byte[] byteObj;
<span class="nc bnc" id="L1045" title="All 2 branches missed.">            if (pixel == null) {</span>
<span class="nc" id="L1046">                pixel = byteObj = new byte[1];</span>
            } else {
<span class="nc" id="L1048">                byteObj = (byte[]) pixel;</span>
            }
<span class="nc" id="L1050">            byteObj[0] = (byte) pix;</span>
<span class="nc" id="L1051">            break;</span>
        case DataBuffer.TYPE_USHORT:
            short[] shortObj;
<span class="nc bnc" id="L1054" title="All 2 branches missed.">            if (pixel == null) {</span>
<span class="nc" id="L1055">                pixel = shortObj = new short[1];</span>
            } else {
<span class="nc" id="L1057">                shortObj = (short[]) pixel;</span>
            }
<span class="nc" id="L1059">            shortObj[0] = (short) pix;</span>
<span class="nc" id="L1060">            break;</span>
        default:
<span class="nc" id="L1062">            throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                             &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc" id="L1065">        return pixel;</span>
    }

    /**
     * Returns an array of unnormalized color/alpha components for a
     * specified pixel in this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel value
     * is specified as an int.  If the &lt;code&gt;components&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;,
     * a new array is allocated that contains
     * &lt;code&gt;offset + getNumComponents()&lt;/code&gt; elements.
     * The &lt;code&gt;components&lt;/code&gt; array is returned,
     * with the alpha component included
     * only if &lt;code&gt;hasAlpha&lt;/code&gt; returns true.
     * Color/alpha components are stored in the &lt;code&gt;components&lt;/code&gt; array starting
     * at &lt;code&gt;offset&lt;/code&gt; even if the array is allocated by this method.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;
     * is thrown if  the &lt;code&gt;components&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt; and is
     * not large enough to hold all the color and alpha components
     * starting at &lt;code&gt;offset&lt;/code&gt;.
     * @param pixel the specified pixel
     * @param components the array to receive the color and alpha
     * components of the specified pixel
     * @param offset the offset into the &lt;code&gt;components&lt;/code&gt; array at
     * which to start storing the color and alpha components
     * @return an array containing the color and alpha components of the
     * specified pixel starting at the specified offset.
     * @see ColorModel#hasAlpha
     * @see ColorModel#getNumComponents
     */
    public int[] getComponents(int pixel, int[] components, int offset) {
<span class="nc bnc" id="L1094" title="All 2 branches missed.">        if (components == null) {</span>
<span class="nc" id="L1095">            components = new int[offset+numComponents];</span>
        }

        // REMIND: Needs to change if different color space
<span class="nc" id="L1099">        components[offset+0] = getRed(pixel);</span>
<span class="nc" id="L1100">        components[offset+1] = getGreen(pixel);</span>
<span class="nc" id="L1101">        components[offset+2] = getBlue(pixel);</span>
<span class="nc bnc" id="L1102" title="All 4 branches missed.">        if (supportsAlpha &amp;&amp; (components.length-offset) &gt; 3) {</span>
<span class="nc" id="L1103">            components[offset+3] = getAlpha(pixel);</span>
        }

<span class="nc" id="L1106">        return components;</span>
    }

    /**
     * Returns an array of unnormalized color/alpha components for
     * a specified pixel in this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel
     * value is specified by an array of data elements of type
     * &lt;code&gt;transferType&lt;/code&gt; passed in as an object reference.
     * If &lt;code&gt;pixel&lt;/code&gt; is not a primitive array of type
     * &lt;code&gt;transferType&lt;/code&gt;, a &lt;code&gt;ClassCastException&lt;/code&gt;
     * is thrown.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;
     * is thrown if &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold
     * a pixel value for this &lt;code&gt;ColorModel&lt;/code&gt;.  If the
     * &lt;code&gt;components&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;, a new array
     * is allocated that contains
     * &lt;code&gt;offset + getNumComponents()&lt;/code&gt; elements.
     * The &lt;code&gt;components&lt;/code&gt; array is returned,
     * with the alpha component included
     * only if &lt;code&gt;hasAlpha&lt;/code&gt; returns true.
     * Color/alpha components are stored in the &lt;code&gt;components&lt;/code&gt;
     * array starting at &lt;code&gt;offset&lt;/code&gt; even if the array is
     * allocated by this method.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is also
     * thrown if  the &lt;code&gt;components&lt;/code&gt; array is not
     * &lt;code&gt;null&lt;/code&gt; and is not large enough to hold all the color
     * and alpha components starting at &lt;code&gt;offset&lt;/code&gt;.
     * &lt;p&gt;
     * Since &lt;code&gt;IndexColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then they throw an exception if they use an
     * unsupported &lt;code&gt;transferType&lt;/code&gt;.
     *
     * @param pixel the specified pixel
     * @param components an array that receives the color and alpha
     * components of the specified pixel
     * @param offset the index into the &lt;code&gt;components&lt;/code&gt; array at
     * which to begin storing the color and alpha components of the
     * specified pixel
     * @return an array containing the color and alpha components of the
     * specified pixel starting at the specified offset.
     * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;pixel&lt;/code&gt;
     *            is not large enough to hold a pixel value for this
     *            &lt;code&gt;ColorModel&lt;/code&gt; or if the
     *            &lt;code&gt;components&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt;
     *            and is not large enough to hold all the color
     *            and alpha components starting at &lt;code&gt;offset&lt;/code&gt;
     * @throws ClassCastException if &lt;code&gt;pixel&lt;/code&gt; is not a
     *            primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws UnsupportedOperationException if &lt;code&gt;transferType&lt;/code&gt;
     *         is not one of the supported transfer types
     * @see ColorModel#hasAlpha
     * @see ColorModel#getNumComponents
     */
    public int[] getComponents(Object pixel, int[] components, int offset) {
        int intpixel;
<span class="nc bnc" id="L1161" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L1163">               byte bdata[] = (byte[])pixel;</span>
<span class="nc" id="L1164">               intpixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L1165">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L1167">               short sdata[] = (short[])pixel;</span>
<span class="nc" id="L1168">               intpixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L1169">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L1171">               int idata[] = (int[])pixel;</span>
<span class="nc" id="L1172">               intpixel = idata[0];</span>
<span class="nc" id="L1173">            break;</span>
            default:
<span class="nc" id="L1175">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc" id="L1178">        return getComponents(intpixel, components, offset);</span>
    }

    /**
     * Returns a pixel value represented as an int in this
     * &lt;code&gt;ColorModel&lt;/code&gt; given an array of unnormalized
     * color/alpha components.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;
     * is thrown if the &lt;code&gt;components&lt;/code&gt; array is not large
     * enough to hold all of the color and alpha components starting
     * at &lt;code&gt;offset&lt;/code&gt;.  Since
     * &lt;code&gt;ColorModel&lt;/code&gt; can be subclassed, subclasses inherit the
     * implementation of this method and if they don't override it then
     * they throw an exception if they use an unsupported transferType.
     * @param components an array of unnormalized color and alpha
     * components
     * @param offset the index into &lt;code&gt;components&lt;/code&gt; at which to
     * begin retrieving the color and alpha components
     * @return an &lt;code&gt;int&lt;/code&gt; pixel value in this
     * &lt;code&gt;ColorModel&lt;/code&gt; corresponding to the specified components.
     * @throws ArrayIndexOutOfBoundsException if
     *  the &lt;code&gt;components&lt;/code&gt; array is not large enough to
     *  hold all of the color and alpha components starting at
     *  &lt;code&gt;offset&lt;/code&gt;
     * @throws UnsupportedOperationException if &lt;code&gt;transferType&lt;/code&gt;
     *         is invalid
     */
    public int getDataElement(int[] components, int offset) {
<span class="nc" id="L1206">        int rgb = (components[offset+0]&lt;&lt;16)</span>
            | (components[offset+1]&lt;&lt;8) | (components[offset+2]);
<span class="nc bnc" id="L1208" title="All 2 branches missed.">        if (supportsAlpha) {</span>
<span class="nc" id="L1209">            rgb |= (components[offset+3]&lt;&lt;24);</span>
        }
        else {
<span class="nc" id="L1212">            rgb |= 0xff000000;</span>
        }
<span class="nc" id="L1214">        Object inData = getDataElements(rgb, null);</span>
        int pixel;
<span class="nc bnc" id="L1216" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L1218">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L1219">               pixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L1220">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L1222">               short sdata[] = (short[])inData;</span>
<span class="nc" id="L1223">               pixel = sdata[0];</span>
<span class="nc" id="L1224">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L1226">               int idata[] = (int[])inData;</span>
<span class="nc" id="L1227">               pixel = idata[0];</span>
<span class="nc" id="L1228">            break;</span>
            default:
<span class="nc" id="L1230">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc" id="L1233">        return pixel;</span>
    }

    /**
     * Returns a data element array representation of a pixel in this
     * &lt;code&gt;ColorModel&lt;/code&gt; given an array of unnormalized color/alpha
     * components.  This array can then be passed to the
     * &lt;code&gt;setDataElements&lt;/code&gt; method of a &lt;code&gt;WritableRaster&lt;/code&gt;
     * object.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if the
     * &lt;code&gt;components&lt;/code&gt; array is not large enough to hold all of the
     * color and alpha components starting at &lt;code&gt;offset&lt;/code&gt;.
     * If the pixel variable is &lt;code&gt;null&lt;/code&gt;, a new array
     * is allocated.  If &lt;code&gt;pixel&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;,
     * it must be a primitive array of type &lt;code&gt;transferType&lt;/code&gt;;
     * otherwise, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if pixel
     * is not large enough to hold a pixel value for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * &lt;p&gt;
     * Since &lt;code&gt;IndexColorModel&lt;/code&gt; can be subclassed, subclasses
     * inherit the implementation of this method and if they don't
     * override it then they throw an exception if they use an
     * unsupported &lt;code&gt;transferType&lt;/code&gt;
     *
     * @param components an array of unnormalized color and alpha
     * components
     * @param offset the index into &lt;code&gt;components&lt;/code&gt; at which to
     * begin retrieving color and alpha components
     * @param pixel the &lt;code&gt;Object&lt;/code&gt; representing an array of color
     * and alpha components
     * @return an &lt;code&gt;Object&lt;/code&gt; representing an array of color and
     * alpha components.
     * @throws ClassCastException if &lt;code&gt;pixel&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt; or the &lt;code&gt;components&lt;/code&gt;
     *  array is not large enough to hold all of the color and alpha
     *  components starting at &lt;code&gt;offset&lt;/code&gt;
     * @throws UnsupportedOperationException if &lt;code&gt;transferType&lt;/code&gt;
     *         is not one of the supported transfer types
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     */
    public Object getDataElements(int[] components, int offset, Object pixel) {
<span class="nc" id="L1279">        int rgb = (components[offset+0]&lt;&lt;16) | (components[offset+1]&lt;&lt;8)</span>
            | (components[offset+2]);
<span class="nc bnc" id="L1281" title="All 2 branches missed.">        if (supportsAlpha) {</span>
<span class="nc" id="L1282">            rgb |= (components[offset+3]&lt;&lt;24);</span>
        }
        else {
<span class="nc" id="L1285">            rgb &amp;= 0xff000000;</span>
        }
<span class="nc" id="L1287">        return getDataElements(rgb, pixel);</span>
    }

    /**
     * Creates a &lt;code&gt;WritableRaster&lt;/code&gt; with the specified width
     * and height that has a data layout (&lt;code&gt;SampleModel&lt;/code&gt;)
     * compatible with this &lt;code&gt;ColorModel&lt;/code&gt;.  This method
     * only works for color models with 16 or fewer bits per pixel.
     * &lt;p&gt;
     * Since &lt;code&gt;IndexColorModel&lt;/code&gt; can be subclassed, any
     * subclass that supports greater than 16 bits per pixel must
     * override this method.
     *
     * @param w the width to apply to the new &lt;code&gt;WritableRaster&lt;/code&gt;
     * @param h the height to apply to the new &lt;code&gt;WritableRaster&lt;/code&gt;
     * @return a &lt;code&gt;WritableRaster&lt;/code&gt; object with the specified
     * width and height.
     * @throws UnsupportedOperationException if the number of bits in a
     *         pixel is greater than 16
     * @see WritableRaster
     * @see SampleModel
     */
    public WritableRaster createCompatibleWritableRaster(int w, int h) {
        WritableRaster raster;

<span class="nc bnc" id="L1312" title="All 6 branches missed.">        if (pixel_bits == 1 || pixel_bits == 2 || pixel_bits == 4) {</span>
            // TYPE_BINARY
<span class="nc" id="L1314">            raster = Raster.createPackedRaster(DataBuffer.TYPE_BYTE,</span>
                                               w, h, 1, pixel_bits, null);
        }
<span class="nc bnc" id="L1317" title="All 2 branches missed.">        else if (pixel_bits &lt;= 8) {</span>
<span class="nc" id="L1318">            raster = Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,</span>
                                                  w,h,1,null);
        }
<span class="nc bnc" id="L1321" title="All 2 branches missed.">        else if (pixel_bits &lt;= 16) {</span>
<span class="nc" id="L1322">            raster = Raster.createInterleavedRaster(DataBuffer.TYPE_USHORT,</span>
                                                  w,h,1,null);
        }
        else {
<span class="nc" id="L1326">            throw new</span>
                UnsupportedOperationException(&quot;This method is not supported &quot;+
                                              &quot; for pixel bits &gt; 16.&quot;);
        }
<span class="nc" id="L1330">        return raster;</span>
    }

    /**
      * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;raster&lt;/code&gt; is compatible
      * with this &lt;code&gt;ColorModel&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; if it
      * is not compatible with this &lt;code&gt;ColorModel&lt;/code&gt;.
      * @param raster the {@link Raster} object to test for compatibility
      * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;raster&lt;/code&gt; is compatible
      * with this &lt;code&gt;ColorModel&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.
      *
      */
    public boolean isCompatibleRaster(Raster raster) {

<span class="nc" id="L1344">        int size = raster.getSampleModel().getSampleSize(0);</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">        return ((raster.getTransferType() == transferType) &amp;&amp;</span>
<span class="nc bnc" id="L1346" title="All 4 branches missed.">                (raster.getNumBands() == 1) &amp;&amp; ((1 &lt;&lt; size) &gt;= map_size));</span>
    }

    /**
     * Creates a &lt;code&gt;SampleModel&lt;/code&gt; with the specified
     * width and height that has a data layout compatible with
     * this &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param w the width to apply to the new &lt;code&gt;SampleModel&lt;/code&gt;
     * @param h the height to apply to the new &lt;code&gt;SampleModel&lt;/code&gt;
     * @return a &lt;code&gt;SampleModel&lt;/code&gt; object with the specified
     * width and height.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     * @see SampleModel
     */
    public SampleModel createCompatibleSampleModel(int w, int h) {
<span class="nc" id="L1362">        int[] off = new int[1];</span>
<span class="nc" id="L1363">        off[0] = 0;</span>
<span class="nc bnc" id="L1364" title="All 6 branches missed.">        if (pixel_bits == 1 || pixel_bits == 2 || pixel_bits == 4) {</span>
<span class="nc" id="L1365">            return new MultiPixelPackedSampleModel(transferType, w, h,</span>
                                                   pixel_bits);
        }
        else {
<span class="nc" id="L1369">            return new ComponentSampleModel(transferType, w, h, 1, w,</span>
                                            off);
        }
    }

    /**
     * Checks if the specified &lt;code&gt;SampleModel&lt;/code&gt; is compatible
     * with this &lt;code&gt;ColorModel&lt;/code&gt;.  If &lt;code&gt;sm&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;, this method returns &lt;code&gt;false&lt;/code&gt;.
     * @param sm the specified &lt;code&gt;SampleModel&lt;/code&gt;,
     *           or &lt;code&gt;null&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;SampleModel&lt;/code&gt;
     * is compatible with this &lt;code&gt;ColorModel&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     * @see SampleModel
     */
    public boolean isCompatibleSampleModel(SampleModel sm) {
        // fix 4238629
<span class="nc bnc" id="L1387" title="All 4 branches missed.">        if (! (sm instanceof ComponentSampleModel) &amp;&amp;</span>
            ! (sm instanceof MultiPixelPackedSampleModel)   ) {
<span class="nc" id="L1389">            return false;</span>
        }

        // Transfer type must be the same
<span class="nc bnc" id="L1393" title="All 2 branches missed.">        if (sm.getTransferType() != transferType) {</span>
<span class="nc" id="L1394">            return false;</span>
        }

<span class="nc bnc" id="L1397" title="All 2 branches missed.">        if (sm.getNumBands() != 1) {</span>
<span class="nc" id="L1398">            return false;</span>
        }

<span class="nc" id="L1401">        return true;</span>
    }

    /**
     * Returns a new &lt;code&gt;BufferedImage&lt;/code&gt; of TYPE_INT_ARGB or
     * TYPE_INT_RGB that has a &lt;code&gt;Raster&lt;/code&gt; with pixel data
     * computed by expanding the indices in the source &lt;code&gt;Raster&lt;/code&gt;
     * using the color/alpha component arrays of this &lt;code&gt;ColorModel&lt;/code&gt;.
     * Only the lower &lt;em&gt;n&lt;/em&gt; bits of each index value in the source
     * &lt;code&gt;Raster&lt;/code&gt;, as specified in the
     * &lt;a href=&quot;#index_values&quot;&gt;class description&lt;/a&gt; above, are used to
     * compute the color/alpha values in the returned image.
     * If &lt;code&gt;forceARGB&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a TYPE_INT_ARGB image is
     * returned regardless of whether or not this &lt;code&gt;ColorModel&lt;/code&gt;
     * has an alpha component array or a transparent pixel.
     * @param raster the specified &lt;code&gt;Raster&lt;/code&gt;
     * @param forceARGB if &lt;code&gt;true&lt;/code&gt;, the returned
     *     &lt;code&gt;BufferedImage&lt;/code&gt; is TYPE_INT_ARGB; otherwise it is
     *     TYPE_INT_RGB
     * @return a &lt;code&gt;BufferedImage&lt;/code&gt; created with the specified
     *     &lt;code&gt;Raster&lt;/code&gt;
     * @throws IllegalArgumentException if the raster argument is not
     *           compatible with this IndexColorModel
     */
    public BufferedImage convertToIntDiscrete(Raster raster,
                                              boolean forceARGB) {
        ColorModel cm;

<span class="nc bnc" id="L1429" title="All 2 branches missed.">        if (!isCompatibleRaster(raster)) {</span>
<span class="nc" id="L1430">            throw new IllegalArgumentException(&quot;This raster is not compatible&quot; +</span>
                 &quot;with this IndexColorModel.&quot;);
        }
<span class="nc bnc" id="L1433" title="All 4 branches missed.">        if (forceARGB || transparency == TRANSLUCENT) {</span>
<span class="nc" id="L1434">            cm = ColorModel.getRGBdefault();</span>
        }
<span class="nc bnc" id="L1436" title="All 2 branches missed.">        else if (transparency == BITMASK) {</span>
<span class="nc" id="L1437">            cm = new DirectColorModel(25, 0xff0000, 0x00ff00, 0x0000ff,</span>
                                      0x1000000);
        }
        else {
<span class="nc" id="L1441">            cm = new DirectColorModel(24, 0xff0000, 0x00ff00, 0x0000ff);</span>
        }

<span class="nc" id="L1444">        int w = raster.getWidth();</span>
<span class="nc" id="L1445">        int h = raster.getHeight();</span>
<span class="nc" id="L1446">        WritableRaster discreteRaster =</span>
<span class="nc" id="L1447">                  cm.createCompatibleWritableRaster(w, h);</span>
<span class="nc" id="L1448">        Object obj = null;</span>
<span class="nc" id="L1449">        int[] data = null;</span>

<span class="nc" id="L1451">        int rX = raster.getMinX();</span>
<span class="nc" id="L1452">        int rY = raster.getMinY();</span>

<span class="nc bnc" id="L1454" title="All 2 branches missed.">        for (int y=0; y &lt; h; y++, rY++) {</span>
<span class="nc" id="L1455">            obj = raster.getDataElements(rX, rY, w, 1, obj);</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">            if (obj instanceof int[]) {</span>
<span class="nc" id="L1457">                data = (int[])obj;</span>
            } else {
<span class="nc" id="L1459">                data = DataBuffer.toIntArray(obj);</span>
            }
<span class="nc bnc" id="L1461" title="All 2 branches missed.">            for (int x=0; x &lt; w; x++) {</span>
<span class="nc" id="L1462">                data[x] = rgb[data[x] &amp; pixel_mask];</span>
            }
<span class="nc" id="L1464">            discreteRaster.setDataElements(0, y, w, 1, data);</span>
        }

<span class="nc" id="L1467">        return new BufferedImage(cm, discreteRaster, false, null);</span>
    }

    /**
     * Returns whether or not the pixel is valid.
     * @param pixel the specified pixel value
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;pixel&lt;/code&gt;
     * is valid; &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.3
     */
    public boolean isValid(int pixel) {
<span class="nc bnc" id="L1478" title="All 6 branches missed.">        return ((pixel &gt;= 0 &amp;&amp; pixel &lt; map_size) &amp;&amp;</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">                (validBits == null || validBits.testBit(pixel)));</span>
    }

    /**
     * Returns whether or not all of the pixels are valid.
     * @return &lt;code&gt;true&lt;/code&gt; if all pixels are valid;
     * &lt;code&gt;false&lt;/code&gt; otherwise.
     * @since 1.3
     */
    public boolean isValid() {
<span class="nc bnc" id="L1489" title="All 2 branches missed.">        return (validBits == null);</span>
    }

    /**
     * Returns a &lt;code&gt;BigInteger&lt;/code&gt; that indicates the valid/invalid
     * pixels in the colormap.  A bit is valid if the
     * &lt;code&gt;BigInteger&lt;/code&gt; value at that index is set, and is invalid
     * if the &lt;code&gt;BigInteger&lt;/code&gt; value at that index is not set.
     * The only valid ranges to query in the &lt;code&gt;BigInteger&lt;/code&gt; are
     * between 0 and the map size.
     * @return a &lt;code&gt;BigInteger&lt;/code&gt; indicating the valid/invalid pixels.
     * @since 1.3
     */
    public BigInteger getValidPixels() {
<span class="nc bnc" id="L1503" title="All 2 branches missed.">        if (validBits == null) {</span>
<span class="nc" id="L1504">            return getAllValid();</span>
        }
        else {
<span class="nc" id="L1507">            return validBits;</span>
        }
    }

    /**
     * Disposes of system resources associated with this
     * &lt;code&gt;ColorModel&lt;/code&gt; once this &lt;code&gt;ColorModel&lt;/code&gt; is no
     * longer referenced.
     */
    public void finalize() {
<span class="nc" id="L1517">    }</span>

    /**
     * Returns the &lt;code&gt;String&lt;/code&gt; representation of the contents of
     * this &lt;code&gt;ColorModel&lt;/code&gt;object.
     * @return a &lt;code&gt;String&lt;/code&gt; representing the contents of this
     * &lt;code&gt;ColorModel&lt;/code&gt; object.
     */
    public String toString() {
<span class="nc" id="L1526">       return new String(&quot;IndexColorModel: #pixelBits = &quot;+pixel_bits</span>
                         + &quot; numComponents = &quot;+numComponents
                         + &quot; color space = &quot;+colorSpace
                         + &quot; transparency = &quot;+transparency
                         + &quot; transIndex   = &quot;+transparent_index
                         + &quot; has alpha = &quot;+supportsAlpha
                         + &quot; isAlphaPre = &quot;+isAlphaPremultiplied
                         );
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>