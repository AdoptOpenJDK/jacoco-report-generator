<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MultiPixelPackedSampleModel.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">MultiPixelPackedSampleModel.java</span></div><h1>MultiPixelPackedSampleModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/* ****************************************************************
 ******************************************************************
 ******************************************************************
 *** COPYRIGHT (c) Eastman Kodak Company, 1997
 *** As  an unpublished  work pursuant to Title 17 of the United
 *** States Code.  All rights reserved.
 ******************************************************************
 ******************************************************************
 ******************************************************************/

package java.awt.image;

/**
 * The &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; class represents
 * one-banded images and can pack multiple one-sample
 * pixels into one data element.  Pixels are not allowed to span data elements.
 * The data type can be DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,
 * or DataBuffer.TYPE_INT.  Each pixel must be a power of 2 number of bits
 * and a power of 2 number of pixels must fit exactly in one data element.
 * Pixel bit stride is equal to the number of bits per pixel.  Scanline
 * stride is in data elements and the last several data elements might be
 * padded with unused pixels.  Data bit offset is the offset in bits from
 * the beginning of the {@link DataBuffer} to the first pixel and must be
 * a multiple of pixel bit stride.
 * &lt;p&gt;
 * The following code illustrates extracting the bits for pixel
 * &lt;code&gt;x,&amp;nbsp;y&lt;/code&gt; from &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;data&lt;/code&gt;
 * and storing the pixel data in data elements of type
 * &lt;code&gt;dataType&lt;/code&gt;:
 * &lt;pre&gt;{@code
 *      int dataElementSize = DataBuffer.getDataTypeSize(dataType);
 *      int bitnum = dataBitOffset + x*pixelBitStride;
 *      int element = data.getElem(y*scanlineStride + bitnum/dataElementSize);
 *      int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))
 *                  - pixelBitStride;
 *      int pixel = (element &gt;&gt; shift) &amp; ((1 &lt;&lt; pixelBitStride) - 1);
 * }&lt;/pre&gt;
 */

public class MultiPixelPackedSampleModel extends SampleModel
{
    /** The number of bits from one pixel to the next. */
    int pixelBitStride;

    /** Bitmask that extracts the rightmost pixel of a data element. */
    int bitMask;

    /**
      * The number of pixels that fit in a data element.  Also used
      * as the number of bits per pixel.
      */
    int pixelsPerDataElement;

    /** The size of a data element in bits. */
    int dataElementSize;

    /** The bit offset into the data array where the first pixel begins.
     */
    int dataBitOffset;

    /** ScanlineStride of the data buffer described in data array elements. */
    int scanlineStride;

    /**
     * Constructs a &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; with the
     * specified data type, width, height and number of bits per pixel.
     * @param dataType  the data type for storing samples
     * @param w         the width, in pixels, of the region of
     *                  image data described
     * @param h         the height, in pixels, of the region of
     *                  image data described
     * @param numberOfBits the number of bits per pixel
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         either &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     *         &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     */
    public MultiPixelPackedSampleModel(int dataType,
                                       int w,
                                       int h,
                                       int numberOfBits) {
<span class="nc" id="L107">        this(dataType,w,h,</span>
             numberOfBits,
<span class="nc" id="L109">            (w*numberOfBits+DataBuffer.getDataTypeSize(dataType)-1)/</span>
<span class="nc" id="L110">                DataBuffer.getDataTypeSize(dataType),</span>
             0);
<span class="nc bnc" id="L112" title="All 6 branches missed.">        if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;</span>
            dataType != DataBuffer.TYPE_USHORT &amp;&amp;
            dataType != DataBuffer.TYPE_INT) {
<span class="nc" id="L115">            throw new IllegalArgumentException(&quot;Unsupported data type &quot;+</span>
                                               dataType);
        }
<span class="nc" id="L118">    }</span>

    /**
     * Constructs a &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; with
     * specified data type, width, height, number of bits per pixel,
     * scanline stride and data bit offset.
     * @param dataType  the data type for storing samples
     * @param w         the width, in pixels, of the region of
     *                  image data described
     * @param h         the height, in pixels, of the region of
     *                  image data described
     * @param numberOfBits the number of bits per pixel
     * @param scanlineStride the line stride of the image data
     * @param dataBitOffset the data bit offset for the region of image
     *                  data described
     * @exception RasterFormatException if the number of bits per pixel
     *                  is not a power of 2 or if a power of 2 number of
     *                  pixels do not fit in one data element.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         either &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     *         &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     *         &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;
     */
    public MultiPixelPackedSampleModel(int dataType, int w, int h,
                                       int numberOfBits,
                                       int scanlineStride,
                                       int dataBitOffset) {
<span class="nc" id="L147">        super(dataType, w, h, 1);</span>
<span class="nc bnc" id="L148" title="All 6 branches missed.">        if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;</span>
            dataType != DataBuffer.TYPE_USHORT &amp;&amp;
            dataType != DataBuffer.TYPE_INT) {
<span class="nc" id="L151">            throw new IllegalArgumentException(&quot;Unsupported data type &quot;+</span>
                                               dataType);
        }
<span class="nc" id="L154">        this.dataType = dataType;</span>
<span class="nc" id="L155">        this.pixelBitStride = numberOfBits;</span>
<span class="nc" id="L156">        this.scanlineStride = scanlineStride;</span>
<span class="nc" id="L157">        this.dataBitOffset = dataBitOffset;</span>
<span class="nc" id="L158">        this.dataElementSize = DataBuffer.getDataTypeSize(dataType);</span>
<span class="nc" id="L159">        this.pixelsPerDataElement = dataElementSize/numberOfBits;</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (pixelsPerDataElement*numberOfBits != dataElementSize) {</span>
<span class="nc" id="L161">           throw new RasterFormatException(&quot;MultiPixelPackedSampleModel &quot; +</span>
                                             &quot;does not allow pixels to &quot; +
                                             &quot;span data element boundaries&quot;);
        }
<span class="nc" id="L165">        this.bitMask = (1 &lt;&lt; numberOfBits) - 1;</span>
<span class="nc" id="L166">    }</span>


    /**
     * Creates a new &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; with the
     * specified width and height.  The new
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; has the
     * same storage data type and number of bits per pixel as this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     * @param w the specified width
     * @param h the specified height
     * @return a {@link SampleModel} with the specified width and height
     * and with the same storage data type and number of bits per pixel
     * as this &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     */
    public SampleModel createCompatibleSampleModel(int w, int h) {
<span class="nc" id="L184">      SampleModel sampleModel =</span>
            new MultiPixelPackedSampleModel(dataType, w, h, pixelBitStride);
<span class="nc" id="L186">      return sampleModel;</span>
    }

    /**
     * Creates a &lt;code&gt;DataBuffer&lt;/code&gt; that corresponds to this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.  The
     * &lt;code&gt;DataBuffer&lt;/code&gt; object's data type and size
     * is consistent with this &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     * The &lt;code&gt;DataBuffer&lt;/code&gt; has a single bank.
     * @return a &lt;code&gt;DataBuffer&lt;/code&gt; with the same data type and
     * size as this &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     */
    public DataBuffer createDataBuffer() {
<span class="nc" id="L199">        DataBuffer dataBuffer = null;</span>

<span class="nc" id="L201">        int size = (int)scanlineStride*height;</span>
<span class="nc bnc" id="L202" title="All 4 branches missed.">        switch (dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L204">            dataBuffer = new DataBufferByte(size+(dataBitOffset+7)/8);</span>
<span class="nc" id="L205">            break;</span>
        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L207">            dataBuffer = new DataBufferUShort(size+(dataBitOffset+15)/16);</span>
<span class="nc" id="L208">            break;</span>
        case DataBuffer.TYPE_INT:
<span class="nc" id="L210">            dataBuffer = new DataBufferInt(size+(dataBitOffset+31)/32);</span>
            break;
        }
<span class="nc" id="L213">        return dataBuffer;</span>
    }

    /**
     * Returns the number of data elements needed to transfer one pixel
     * via the {@link #getDataElements} and {@link #setDataElements}
     * methods.  For a &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;, this is
     * one.
     * @return the number of data elements.
     */
    public int getNumDataElements() {
<span class="nc" id="L224">        return 1;</span>
    }

    /**
     * Returns the number of bits per sample for all bands.
     * @return the number of bits per sample.
     */
    public int[] getSampleSize() {
<span class="nc" id="L232">        int sampleSize[] = {pixelBitStride};</span>
<span class="nc" id="L233">        return sampleSize;</span>
    }

    /**
     * Returns the number of bits per sample for the specified band.
     * @param band the specified band
     * @return the number of bits per sample for the specified band.
     */
    public int getSampleSize(int band) {
<span class="nc" id="L242">        return pixelBitStride;</span>
    }

    /**
     * Returns the offset of pixel (x,&amp;nbsp;y) in data array elements.
     * @param x the X coordinate of the specified pixel
     * @param y the Y coordinate of the specified pixel
     * @return the offset of the specified pixel.
     */
    public int getOffset(int x, int y) {
<span class="nc" id="L252">        int offset = y * scanlineStride;</span>
<span class="nc" id="L253">        offset +=  (x*pixelBitStride+dataBitOffset)/dataElementSize;</span>
<span class="nc" id="L254">        return offset;</span>
    }

    /**
     *  Returns the offset, in bits, into the data element in which it is
     *  stored for the &lt;code&gt;x&lt;/code&gt;th pixel of a scanline.
     *  This offset is the same for all scanlines.
     *  @param x the specified pixel
     *  @return the bit offset of the specified pixel.
     */
    public int getBitOffset(int x){
<span class="nc" id="L265">       return  (x*pixelBitStride+dataBitOffset)%dataElementSize;</span>
    }

    /**
     * Returns the scanline stride.
     * @return the scanline stride of this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     */
    public int getScanlineStride() {
<span class="nc" id="L274">        return scanlineStride;</span>
    }

    /**
     * Returns the pixel bit stride in bits.  This value is the same as
     * the number of bits per pixel.
     * @return the &lt;code&gt;pixelBitStride&lt;/code&gt; of this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     */
    public int getPixelBitStride() {
<span class="nc" id="L284">        return pixelBitStride;</span>
    }

    /**
     * Returns the data bit offset in bits.
     * @return the &lt;code&gt;dataBitOffset&lt;/code&gt; of this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     */
    public int getDataBitOffset() {
<span class="nc" id="L293">        return dataBitOffset;</span>
    }

    /**
     *  Returns the TransferType used to transfer pixels by way of the
     *  &lt;code&gt;getDataElements&lt;/code&gt; and &lt;code&gt;setDataElements&lt;/code&gt;
     *  methods. The TransferType might or might not be the same as the
     *  storage DataType.  The TransferType is one of
     *  DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,
     *  or DataBuffer.TYPE_INT.
     *  @return the transfertype.
     */
    public int getTransferType() {
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (pixelBitStride &gt; 16)</span>
<span class="nc" id="L307">            return DataBuffer.TYPE_INT;</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">        else if (pixelBitStride &gt; 8)</span>
<span class="nc" id="L309">            return DataBuffer.TYPE_USHORT;</span>
        else
<span class="nc" id="L311">            return DataBuffer.TYPE_BYTE;</span>
    }

    /**
     * Creates a new &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; with a
     * subset of the bands of this
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.  Since a
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; only has one band, the
     * bands argument must have a length of one and indicate the zeroth
     * band.
     * @param bands the specified bands
     * @return a new &lt;code&gt;SampleModel&lt;/code&gt; with a subset of bands of
     * this &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;.
     * @exception RasterFormatException if the number of bands requested
     * is not one.
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     */
    public SampleModel createSubsetSampleModel(int bands[]) {
<span class="nc bnc" id="L330" title="All 2 branches missed.">        if (bands != null) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">           if (bands.length != 1)</span>
<span class="nc" id="L332">            throw new RasterFormatException(&quot;MultiPixelPackedSampleModel has &quot;</span>
                                            + &quot;only one band.&quot;);
        }
<span class="nc" id="L335">        SampleModel sm = createCompatibleSampleModel(width, height);</span>
<span class="nc" id="L336">        return sm;</span>
    }

    /**
     * Returns as &lt;code&gt;int&lt;/code&gt; the sample in a specified band for the
     * pixel located at (x,&amp;nbsp;y).  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * coordinates are not in bounds.
     * @param x         the X coordinate of the specified pixel
     * @param y         the Y coordinate of the specified pixel
     * @param b         the band to return, which is assumed to be 0
     * @param data      the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image
     *                  data
     * @return the specified band containing the sample of the specified
     * pixel.
     * @exception ArrayIndexOutOfBoundException if the specified
     *          coordinates are not in bounds.
     * @see #setSample(int, int, int, int, DataBuffer)
     */
    public int getSample(int x, int y, int b, DataBuffer data) {
        // 'b' must be 0
<span class="nc bnc" id="L357" title="All 10 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height) ||</span>
            (b != 0)) {
<span class="nc" id="L359">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L362">        int bitnum = dataBitOffset + x*pixelBitStride;</span>
<span class="nc" id="L363">        int element = data.getElem(y*scanlineStride + bitnum/dataElementSize);</span>
<span class="nc" id="L364">        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))</span>
                    - pixelBitStride;
<span class="nc" id="L366">        return (element &gt;&gt; shift) &amp; bitMask;</span>
    }

    /**
     * Sets a sample in the specified band for the pixel located at
     * (x,&amp;nbsp;y) in the &lt;code&gt;DataBuffer&lt;/code&gt; using an
     * &lt;code&gt;int&lt;/code&gt; for input.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * coordinates are not in bounds.
     * @param x the X coordinate of the specified pixel
     * @param y the Y coordinate of the specified pixel
     * @param b the band to return, which is assumed to be 0
     * @param s the input sample as an &lt;code&gt;int&lt;/code&gt;
     * @param data the &lt;code&gt;DataBuffer&lt;/code&gt; where image data is stored
     * @exception ArrayIndexOutOfBoundsException if the coordinates are
     * not in bounds.
     * @see #getSample(int, int, int, DataBuffer)
     */
    public void setSample(int x, int y, int b, int s,
                          DataBuffer data) {
        // 'b' must be 0
<span class="nc bnc" id="L387" title="All 10 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height) ||</span>
            (b != 0)) {
<span class="nc" id="L389">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L392">        int bitnum = dataBitOffset + x * pixelBitStride;</span>
<span class="nc" id="L393">        int index = y * scanlineStride + (bitnum / dataElementSize);</span>
<span class="nc" id="L394">        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))</span>
                    - pixelBitStride;
<span class="nc" id="L396">        int element = data.getElem(index);</span>
<span class="nc" id="L397">        element &amp;= ~(bitMask &lt;&lt; shift);</span>
<span class="nc" id="L398">        element |= (s &amp; bitMask) &lt;&lt; shift;</span>
<span class="nc" id="L399">        data.setElem(index,element);</span>
<span class="nc" id="L400">    }</span>

    /**
     * Returns data for a single pixel in a primitive array of type
     * TransferType.  For a &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;,
     * the array has one element, and the type is the smallest of
     * DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT
     * that can hold a single pixel.  Generally, &lt;code&gt;obj&lt;/code&gt;
     * should be passed in as &lt;code&gt;null&lt;/code&gt;, so that the
     * &lt;code&gt;Object&lt;/code&gt; is created automatically and is the
     * correct primitive data type.
     * &lt;p&gt;
     * The following code illustrates transferring data for one pixel from
     * &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db1&lt;/code&gt;, whose storage layout is
     * described by &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;
     * &lt;code&gt;mppsm1&lt;/code&gt;, to &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db2&lt;/code&gt;,
     * whose storage layout is described by
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; &lt;code&gt;mppsm2&lt;/code&gt;.
     * The transfer is generally more efficient than using
     * &lt;code&gt;getPixel&lt;/code&gt; or &lt;code&gt;setPixel&lt;/code&gt;.
     * &lt;pre&gt;
     *       MultiPixelPackedSampleModel mppsm1, mppsm2;
     *       DataBufferInt db1, db2;
     *       mppsm2.setDataElements(x, y, mppsm1.getDataElements(x, y, null,
     *                              db1), db2);
     * &lt;/pre&gt;
     * Using &lt;code&gt;getDataElements&lt;/code&gt; or &lt;code&gt;setDataElements&lt;/code&gt;
     * to transfer between two &lt;code&gt;DataBuffer/SampleModel&lt;/code&gt; pairs
     * is legitimate if the &lt;code&gt;SampleModels&lt;/code&gt; have the same number
     * of bands, corresponding bands have the same number of
     * bits per sample, and the TransferTypes are the same.
     * &lt;p&gt;
     * If &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should be a
     * primitive array of type TransferType.  Otherwise, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * coordinates are not in bounds, or if &lt;code&gt;obj&lt;/code&gt; is not
     * &lt;code&gt;null&lt;/code&gt; and is not large enough to hold the pixel data.
     * @param x the X coordinate of the specified pixel
     * @param y the Y coordinate of the specified pixel
     * @param obj a primitive array in which to return the pixel data or
     *          &lt;code&gt;null&lt;/code&gt;.
     * @param data the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image data.
     * @return an &lt;code&gt;Object&lt;/code&gt; containing data for the specified
     *  pixel.
     * @exception ClassCastException if &lt;code&gt;obj&lt;/code&gt; is not a
     *  primitive array of type TransferType or is not &lt;code&gt;null&lt;/code&gt;
     * @exception ArrayIndexOutOfBoundsException if the coordinates are
     * not in bounds, or if &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt; or
     * not large enough to hold the pixel data
     * @see #setDataElements(int, int, Object, DataBuffer)
     */
    public Object getDataElements(int x, int y, Object obj, DataBuffer data) {
<span class="nc bnc" id="L453" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L454">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L458">        int type = getTransferType();</span>
<span class="nc" id="L459">        int bitnum = dataBitOffset + x*pixelBitStride;</span>
<span class="nc" id="L460">        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))</span>
                    - pixelBitStride;
<span class="nc" id="L462">        int element = 0;</span>

<span class="nc bnc" id="L464" title="All 4 branches missed.">        switch(type) {</span>

        case DataBuffer.TYPE_BYTE:

            byte[] bdata;

<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L471">                bdata = new byte[1];</span>
            else
<span class="nc" id="L473">                bdata = (byte[])obj;</span>

<span class="nc" id="L475">            element = data.getElem(y*scanlineStride +</span>
                                    bitnum/dataElementSize);
<span class="nc" id="L477">            bdata[0] = (byte)((element &gt;&gt; shift) &amp; bitMask);</span>

<span class="nc" id="L479">            obj = (Object)bdata;</span>
<span class="nc" id="L480">            break;</span>

        case DataBuffer.TYPE_USHORT:

            short[] sdata;

<span class="nc bnc" id="L486" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L487">                sdata = new short[1];</span>
            else
<span class="nc" id="L489">                sdata = (short[])obj;</span>

<span class="nc" id="L491">            element = data.getElem(y*scanlineStride +</span>
                                   bitnum/dataElementSize);
<span class="nc" id="L493">            sdata[0] = (short)((element &gt;&gt; shift) &amp; bitMask);</span>

<span class="nc" id="L495">            obj = (Object)sdata;</span>
<span class="nc" id="L496">            break;</span>

        case DataBuffer.TYPE_INT:

            int[] idata;

<span class="nc bnc" id="L502" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L503">                idata = new int[1];</span>
            else
<span class="nc" id="L505">                idata = (int[])obj;</span>

<span class="nc" id="L507">            element = data.getElem(y*scanlineStride +</span>
                                   bitnum/dataElementSize);
<span class="nc" id="L509">            idata[0] = (element &gt;&gt; shift) &amp; bitMask;</span>

<span class="nc" id="L511">            obj = (Object)idata;</span>
            break;
        }

<span class="nc" id="L515">        return obj;</span>
    }

    /**
     * Returns the specified single band pixel in the first element
     * of an &lt;code&gt;int&lt;/code&gt; array.
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * coordinates are not in bounds.
     * @param x the X coordinate of the specified pixel
     * @param y the Y coordinate of the specified pixel
     * @param iArray the array containing the pixel to be returned or
     *  &lt;code&gt;null&lt;/code&gt;
     * @param data the &lt;code&gt;DataBuffer&lt;/code&gt; where image data is stored
     * @return an array containing the specified pixel.
     * @exception ArrayIndexOutOfBoundsException if the coordinates
     *  are not in bounds
     * @see #setPixel(int, int, int[], DataBuffer)
     */
    public int[] getPixel(int x, int y, int iArray[], DataBuffer data) {
<span class="nc bnc" id="L534" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L535">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int pixels[];
<span class="nc bnc" id="L539" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L540">           pixels = iArray;</span>
        } else {
<span class="nc" id="L542">           pixels = new int [numBands];</span>
        }
<span class="nc" id="L544">        int bitnum = dataBitOffset + x*pixelBitStride;</span>
<span class="nc" id="L545">        int element = data.getElem(y*scanlineStride + bitnum/dataElementSize);</span>
<span class="nc" id="L546">        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))</span>
                    - pixelBitStride;
<span class="nc" id="L548">        pixels[0] = (element &gt;&gt; shift) &amp; bitMask;</span>
<span class="nc" id="L549">        return pixels;</span>
    }

    /**
     * Sets the data for a single pixel in the specified
     * &lt;code&gt;DataBuffer&lt;/code&gt; from a primitive array of type
     * TransferType.  For a &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;,
     * only the first element of the array holds valid data,
     * and the type must be the smallest of
     * DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, or DataBuffer.TYPE_INT
     * that can hold a single pixel.
     * &lt;p&gt;
     * The following code illustrates transferring data for one pixel from
     * &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db1&lt;/code&gt;, whose storage layout is
     * described by &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt;
     * &lt;code&gt;mppsm1&lt;/code&gt;, to &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db2&lt;/code&gt;,
     * whose storage layout is described by
     * &lt;code&gt;MultiPixelPackedSampleModel&lt;/code&gt; &lt;code&gt;mppsm2&lt;/code&gt;.
     * The transfer is generally more efficient than using
     * &lt;code&gt;getPixel&lt;/code&gt; or &lt;code&gt;setPixel&lt;/code&gt;.
     * &lt;pre&gt;
     *       MultiPixelPackedSampleModel mppsm1, mppsm2;
     *       DataBufferInt db1, db2;
     *       mppsm2.setDataElements(x, y, mppsm1.getDataElements(x, y, null,
     *                              db1), db2);
     * &lt;/pre&gt;
     * Using &lt;code&gt;getDataElements&lt;/code&gt; or &lt;code&gt;setDataElements&lt;/code&gt; to
     * transfer between two &lt;code&gt;DataBuffer/SampleModel&lt;/code&gt; pairs is
     * legitimate if the &lt;code&gt;SampleModel&lt;/code&gt; objects have
     * the same number of bands, corresponding bands have the same number of
     * bits per sample, and the TransferTypes are the same.
     * &lt;p&gt;
     * &lt;code&gt;obj&lt;/code&gt; must be a primitive array of type TransferType.
     * Otherwise, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * coordinates are not in bounds, or if &lt;code&gt;obj&lt;/code&gt; is not large
     * enough to hold the pixel data.
     * @param x the X coordinate of the pixel location
     * @param y the Y coordinate of the pixel location
     * @param obj a primitive array containing pixel data
     * @param data the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image data
     * @see #getDataElements(int, int, Object, DataBuffer)
     */
    public void setDataElements(int x, int y, Object obj, DataBuffer data) {
<span class="nc bnc" id="L593" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L594">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L598">        int type = getTransferType();</span>
<span class="nc" id="L599">        int bitnum = dataBitOffset + x * pixelBitStride;</span>
<span class="nc" id="L600">        int index = y * scanlineStride + (bitnum / dataElementSize);</span>
<span class="nc" id="L601">        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))</span>
                    - pixelBitStride;
<span class="nc" id="L603">        int element = data.getElem(index);</span>
<span class="nc" id="L604">        element &amp;= ~(bitMask &lt;&lt; shift);</span>

<span class="nc bnc" id="L606" title="All 4 branches missed.">        switch(type) {</span>

        case DataBuffer.TYPE_BYTE:

<span class="nc" id="L610">            byte[] barray = (byte[])obj;</span>
<span class="nc" id="L611">            element |= ( ((int)(barray[0])&amp;0xff) &amp; bitMask) &lt;&lt; shift;</span>
<span class="nc" id="L612">            data.setElem(index, element);</span>
<span class="nc" id="L613">            break;</span>

        case DataBuffer.TYPE_USHORT:

<span class="nc" id="L617">            short[] sarray = (short[])obj;</span>
<span class="nc" id="L618">            element |= ( ((int)(sarray[0])&amp;0xffff) &amp; bitMask) &lt;&lt; shift;</span>
<span class="nc" id="L619">            data.setElem(index, element);</span>
<span class="nc" id="L620">            break;</span>

        case DataBuffer.TYPE_INT:

<span class="nc" id="L624">            int[] iarray = (int[])obj;</span>
<span class="nc" id="L625">            element |= (iarray[0] &amp; bitMask) &lt;&lt; shift;</span>
<span class="nc" id="L626">            data.setElem(index, element);</span>
            break;
        }
<span class="nc" id="L629">    }</span>

    /**
     * Sets a pixel in the &lt;code&gt;DataBuffer&lt;/code&gt; using an
     * &lt;code&gt;int&lt;/code&gt; array for input.
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * the coordinates are not in bounds.
     * @param x the X coordinate of the pixel location
     * @param y the Y coordinate of the pixel location
     * @param iArray the input pixel in an &lt;code&gt;int&lt;/code&gt; array
     * @param data the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image data
     * @see #getPixel(int, int, int[], DataBuffer)
     */
    public void setPixel(int x, int y, int[] iArray, DataBuffer data) {
<span class="nc bnc" id="L643" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L644">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L647">        int bitnum = dataBitOffset + x * pixelBitStride;</span>
<span class="nc" id="L648">        int index = y * scanlineStride + (bitnum / dataElementSize);</span>
<span class="nc" id="L649">        int shift = dataElementSize - (bitnum &amp; (dataElementSize-1))</span>
                    - pixelBitStride;
<span class="nc" id="L651">        int element = data.getElem(index);</span>
<span class="nc" id="L652">        element &amp;= ~(bitMask &lt;&lt; shift);</span>
<span class="nc" id="L653">        element |= (iArray[0] &amp; bitMask) &lt;&lt; shift;</span>
<span class="nc" id="L654">        data.setElem(index,element);</span>
<span class="nc" id="L655">    }</span>

    public boolean equals(Object o) {
<span class="nc bnc" id="L658" title="All 4 branches missed.">        if ((o == null) || !(o instanceof MultiPixelPackedSampleModel)) {</span>
<span class="nc" id="L659">            return false;</span>
        }

<span class="nc" id="L662">        MultiPixelPackedSampleModel that = (MultiPixelPackedSampleModel)o;</span>
<span class="nc bnc" id="L663" title="All 20 branches missed.">        return this.width == that.width &amp;&amp;</span>
            this.height == that.height &amp;&amp;
            this.numBands == that.numBands &amp;&amp;
            this.dataType == that.dataType &amp;&amp;
            this.pixelBitStride == that.pixelBitStride &amp;&amp;
            this.bitMask == that.bitMask &amp;&amp;
            this.pixelsPerDataElement == that.pixelsPerDataElement &amp;&amp;
            this.dataElementSize == that.dataElementSize &amp;&amp;
            this.dataBitOffset == that.dataBitOffset &amp;&amp;
            this.scanlineStride == that.scanlineStride;
    }

    // If we implement equals() we must also implement hashCode
    public int hashCode() {
<span class="nc" id="L677">        int hash = 0;</span>
<span class="nc" id="L678">        hash = width;</span>
<span class="nc" id="L679">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L680">        hash ^= height;</span>
<span class="nc" id="L681">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L682">        hash ^= numBands;</span>
<span class="nc" id="L683">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L684">        hash ^= dataType;</span>
<span class="nc" id="L685">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L686">        hash ^= pixelBitStride;</span>
<span class="nc" id="L687">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L688">        hash ^= bitMask;</span>
<span class="nc" id="L689">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L690">        hash ^= pixelsPerDataElement;</span>
<span class="nc" id="L691">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L692">        hash ^= dataElementSize;</span>
<span class="nc" id="L693">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L694">        hash ^= dataBitOffset;</span>
<span class="nc" id="L695">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L696">        hash ^= scanlineStride;</span>
<span class="nc" id="L697">        return hash;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>