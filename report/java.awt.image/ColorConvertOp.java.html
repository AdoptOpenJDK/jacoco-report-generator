<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ColorConvertOp.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">ColorConvertOp.java</span></div><h1>ColorConvertOp.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/**********************************************************************
 **********************************************************************
 **********************************************************************
 *** COPYRIGHT (c) Eastman Kodak Company, 1997                      ***
 *** As  an unpublished  work pursuant to Title 17 of the United    ***
 *** States Code.  All rights reserved.                             ***
 **********************************************************************
 **********************************************************************
 **********************************************************************/

package java.awt.image;

import java.awt.Point;
import java.awt.Graphics2D;
import java.awt.color.*;
import sun.java2d.cmm.ColorTransform;
import sun.java2d.cmm.CMSManager;
import sun.java2d.cmm.ProfileDeferralMgr;
import sun.java2d.cmm.PCMM;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Point2D;
import java.awt.RenderingHints;

/**
 * This class performs a pixel-by-pixel color conversion of the data in
 * the source image.  The resulting color values are scaled to the precision
 * of the destination image.  Color conversion can be specified
 * via an array of ColorSpace objects or an array of ICC_Profile objects.
 * &lt;p&gt;
 * If the source is a BufferedImage with premultiplied alpha, the
 * color components are divided by the alpha component before color conversion.
 * If the destination is a BufferedImage with premultiplied alpha, the
 * color components are multiplied by the alpha component after conversion.
 * Rasters are treated as having no alpha channel, i.e. all bands are
 * color bands.
 * &lt;p&gt;
 * If a RenderingHints object is specified in the constructor, the
 * color rendering hint and the dithering hint may be used to control
 * color conversion.
 * &lt;p&gt;
 * Note that Source and Destination may be the same object.
 * &lt;p&gt;
 * @see java.awt.RenderingHints#KEY_COLOR_RENDERING
 * @see java.awt.RenderingHints#KEY_DITHERING
 */
public class ColorConvertOp implements BufferedImageOp, RasterOp {
    ICC_Profile[]    profileList;
    ColorSpace[]     CSList;
    ColorTransform    thisTransform, thisRasterTransform;
    ICC_Profile      thisSrcProfile, thisDestProfile;
    RenderingHints   hints;
    boolean          gotProfiles;
    float[]          srcMinVals, srcMaxVals, dstMinVals, dstMaxVals;

    /* the class initializer */
    static {
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (ProfileDeferralMgr.deferring) {</span>
<span class="nc" id="L83">            ProfileDeferralMgr.activateProfiles();</span>
        }
<span class="nc" id="L85">    }</span>

    /**
     * Constructs a new ColorConvertOp which will convert
     * from a source color space to a destination color space.
     * The RenderingHints argument may be null.
     * This Op can be used only with BufferedImages, and will convert
     * directly from the ColorSpace of the source image to that of the
     * destination.  The destination argument of the filter method
     * cannot be specified as null.
     * @param hints the &lt;code&gt;RenderingHints&lt;/code&gt; object used to control
     *        the color conversion, or &lt;code&gt;null&lt;/code&gt;
     */
    public ColorConvertOp (RenderingHints hints)
<span class="nc" id="L99">    {</span>
<span class="nc" id="L100">        profileList = new ICC_Profile [0];    /* 0 length list */</span>
<span class="nc" id="L101">        this.hints  = hints;</span>
<span class="nc" id="L102">    }</span>

    /**
     * Constructs a new ColorConvertOp from a ColorSpace object.
     * The RenderingHints argument may be null.  This
     * Op can be used only with BufferedImages, and is primarily useful
     * when the {@link #filter(BufferedImage, BufferedImage) filter}
     * method is invoked with a destination argument of null.
     * In that case, the ColorSpace defines the destination color space
     * for the destination created by the filter method.  Otherwise, the
     * ColorSpace defines an intermediate space to which the source is
     * converted before being converted to the destination space.
     * @param cspace defines the destination &lt;code&gt;ColorSpace&lt;/code&gt; or an
     *        intermediate &lt;code&gt;ColorSpace&lt;/code&gt;
     * @param hints the &lt;code&gt;RenderingHints&lt;/code&gt; object used to control
     *        the color conversion, or &lt;code&gt;null&lt;/code&gt;
     * @throws NullPointerException if cspace is null
     */
    public ColorConvertOp (ColorSpace cspace, RenderingHints hints)
<span class="nc" id="L121">    {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">        if (cspace == null) {</span>
<span class="nc" id="L123">            throw new NullPointerException(&quot;ColorSpace cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L125" title="All 2 branches missed.">        if (cspace instanceof ICC_ColorSpace) {</span>
<span class="nc" id="L126">            profileList = new ICC_Profile [1];    /* 1 profile in the list */</span>

<span class="nc" id="L128">            profileList [0] = ((ICC_ColorSpace) cspace).getProfile();</span>
        }
        else {
<span class="nc" id="L131">            CSList = new ColorSpace[1]; /* non-ICC case: 1 ColorSpace in list */</span>
<span class="nc" id="L132">            CSList[0] = cspace;</span>
        }
<span class="nc" id="L134">        this.hints  = hints;</span>
<span class="nc" id="L135">    }</span>


    /**
     * Constructs a new ColorConvertOp from two ColorSpace objects.
     * The RenderingHints argument may be null.
     * This Op is primarily useful for calling the filter method on
     * Rasters, in which case the two ColorSpaces define the operation
     * to be performed on the Rasters.  In that case, the number of bands
     * in the source Raster must match the number of components in
     * srcCspace, and the number of bands in the destination Raster
     * must match the number of components in dstCspace.  For BufferedImages,
     * the two ColorSpaces define intermediate spaces through which the
     * source is converted before being converted to the destination space.
     * @param srcCspace the source &lt;code&gt;ColorSpace&lt;/code&gt;
     * @param dstCspace the destination &lt;code&gt;ColorSpace&lt;/code&gt;
     * @param hints the &lt;code&gt;RenderingHints&lt;/code&gt; object used to control
     *        the color conversion, or &lt;code&gt;null&lt;/code&gt;
     * @throws NullPointerException if either srcCspace or dstCspace is null
     */
    public ColorConvertOp(ColorSpace srcCspace, ColorSpace dstCspace,
                           RenderingHints hints)
<span class="nc" id="L157">    {</span>
<span class="nc bnc" id="L158" title="All 4 branches missed.">        if ((srcCspace == null) || (dstCspace == null)) {</span>
<span class="nc" id="L159">            throw new NullPointerException(&quot;ColorSpaces cannot be null&quot;);</span>
        }
<span class="nc bnc" id="L161" title="All 4 branches missed.">        if ((srcCspace instanceof ICC_ColorSpace) &amp;&amp;</span>
            (dstCspace instanceof ICC_ColorSpace)) {
<span class="nc" id="L163">            profileList = new ICC_Profile [2];    /* 2 profiles in the list */</span>

<span class="nc" id="L165">            profileList [0] = ((ICC_ColorSpace) srcCspace).getProfile();</span>
<span class="nc" id="L166">            profileList [1] = ((ICC_ColorSpace) dstCspace).getProfile();</span>

<span class="nc" id="L168">            getMinMaxValsFromColorSpaces(srcCspace, dstCspace);</span>
        } else {
            /* non-ICC case: 2 ColorSpaces in list */
<span class="nc" id="L171">            CSList = new ColorSpace[2];</span>
<span class="nc" id="L172">            CSList[0] = srcCspace;</span>
<span class="nc" id="L173">            CSList[1] = dstCspace;</span>
        }
<span class="nc" id="L175">        this.hints  = hints;</span>
<span class="nc" id="L176">    }</span>


     /**
     * Constructs a new ColorConvertOp from an array of ICC_Profiles.
     * The RenderingHints argument may be null.
     * The sequence of profiles may include profiles that represent color
     * spaces, profiles that represent effects, etc.  If the whole sequence
     * does not represent a well-defined color conversion, an exception is
     * thrown.
     * &lt;p&gt;For BufferedImages, if the ColorSpace
     * of the source BufferedImage does not match the requirements of the
     * first profile in the array,
     * the first conversion is to an appropriate ColorSpace.
     * If the requirements of the last profile in the array are not met
     * by the ColorSpace of the destination BufferedImage,
     * the last conversion is to the destination's ColorSpace.
     * &lt;p&gt;For Rasters, the number of bands in the source Raster must match
     * the requirements of the first profile in the array, and the
     * number of bands in the destination Raster must match the requirements
     * of the last profile in the array.  The array must have at least two
     * elements or calling the filter method for Rasters will throw an
     * IllegalArgumentException.
     * @param profiles the array of &lt;code&gt;ICC_Profile&lt;/code&gt; objects
     * @param hints the &lt;code&gt;RenderingHints&lt;/code&gt; object used to control
     *        the color conversion, or &lt;code&gt;null&lt;/code&gt;
     * @exception IllegalArgumentException when the profile sequence does not
     *             specify a well-defined color conversion
     * @exception NullPointerException if profiles is null
     */
    public ColorConvertOp (ICC_Profile[] profiles, RenderingHints hints)
<span class="nc" id="L207">    {</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (profiles == null) {</span>
<span class="nc" id="L209">            throw new NullPointerException(&quot;Profiles cannot be null&quot;);</span>
        }
<span class="nc" id="L211">        gotProfiles = true;</span>
<span class="nc" id="L212">        profileList = new ICC_Profile[profiles.length];</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        for (int i1 = 0; i1 &lt; profiles.length; i1++) {</span>
<span class="nc" id="L214">            profileList[i1] = profiles[i1];</span>
        }
<span class="nc" id="L216">        this.hints  = hints;</span>
<span class="nc" id="L217">    }</span>


    /**
     * Returns the array of ICC_Profiles used to construct this ColorConvertOp.
     * Returns null if the ColorConvertOp was not constructed from such an
     * array.
     * @return the array of &lt;code&gt;ICC_Profile&lt;/code&gt; objects of this
     *         &lt;code&gt;ColorConvertOp&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if this
     *         &lt;code&gt;ColorConvertOp&lt;/code&gt; was not constructed with an
     *         array of &lt;code&gt;ICC_Profile&lt;/code&gt; objects.
     */
    public final ICC_Profile[] getICC_Profiles() {
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (gotProfiles) {</span>
<span class="nc" id="L231">            ICC_Profile[] profiles = new ICC_Profile[profileList.length];</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            for (int i1 = 0; i1 &lt; profileList.length; i1++) {</span>
<span class="nc" id="L233">                profiles[i1] = profileList[i1];</span>
            }
<span class="nc" id="L235">            return profiles;</span>
        }
<span class="nc" id="L237">        return null;</span>
    }

    /**
     * ColorConverts the source BufferedImage.
     * If the destination image is null,
     * a BufferedImage will be created with an appropriate ColorModel.
     * @param src the source &lt;code&gt;BufferedImage&lt;/code&gt; to be converted
     * @param dest the destination &lt;code&gt;BufferedImage&lt;/code&gt;,
     *        or &lt;code&gt;null&lt;/code&gt;
     * @return &lt;code&gt;dest&lt;/code&gt; color converted from &lt;code&gt;src&lt;/code&gt;
     *         or a new, converted &lt;code&gt;BufferedImage&lt;/code&gt;
     *         if &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @exception IllegalArgumentException if dest is null and this op was
     *             constructed using the constructor which takes only a
     *             RenderingHints argument, since the operation is ill defined.
     */
    public final BufferedImage filter(BufferedImage src, BufferedImage dest) {
        ColorSpace srcColorSpace, destColorSpace;
<span class="nc" id="L256">        BufferedImage savdest = null;</span>

<span class="nc bnc" id="L258" title="All 2 branches missed.">        if (src.getColorModel() instanceof IndexColorModel) {</span>
<span class="nc" id="L259">            IndexColorModel icm = (IndexColorModel) src.getColorModel();</span>
<span class="nc" id="L260">            src = icm.convertToIntDiscrete(src.getRaster(), true);</span>
        }
<span class="nc" id="L262">        srcColorSpace = src.getColorModel().getColorSpace();</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (dest != null) {</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">            if (dest.getColorModel() instanceof IndexColorModel) {</span>
<span class="nc" id="L265">                savdest = dest;</span>
<span class="nc" id="L266">                dest = null;</span>
<span class="nc" id="L267">                destColorSpace = null;</span>
            } else {
<span class="nc" id="L269">                destColorSpace = dest.getColorModel().getColorSpace();</span>
            }
        } else {
<span class="nc" id="L272">            destColorSpace = null;</span>
        }

<span class="nc bnc" id="L275" title="All 8 branches missed.">        if ((CSList != null) ||</span>
            (!(srcColorSpace instanceof ICC_ColorSpace)) ||
            ((dest != null) &amp;&amp;
             (!(destColorSpace instanceof ICC_ColorSpace)))) {
            /* non-ICC case */
<span class="nc" id="L280">            dest = nonICCBIFilter(src, srcColorSpace, dest, destColorSpace);</span>
        } else {
<span class="nc" id="L282">            dest = ICCBIFilter(src, srcColorSpace, dest, destColorSpace);</span>
        }

<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (savdest != null) {</span>
<span class="nc" id="L286">            Graphics2D big = savdest.createGraphics();</span>
            try {
<span class="nc" id="L288">                big.drawImage(dest, 0, 0, null);</span>
            } finally {
<span class="nc" id="L290">                big.dispose();</span>
<span class="nc" id="L291">            }</span>
<span class="nc" id="L292">            return savdest;</span>
        } else {
<span class="nc" id="L294">            return dest;</span>
        }
    }

    private final BufferedImage ICCBIFilter(BufferedImage src,
                                            ColorSpace srcColorSpace,
                                            BufferedImage dest,
                                            ColorSpace destColorSpace) {
<span class="nc" id="L302">    int              nProfiles = profileList.length;</span>
<span class="nc" id="L303">    ICC_Profile      srcProfile = null, destProfile = null;</span>

<span class="nc" id="L305">        srcProfile = ((ICC_ColorSpace) srcColorSpace).getProfile();</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (dest == null) {        /* last profile in the list defines</span>
                                      the output color space */
<span class="nc bnc" id="L309" title="All 2 branches missed.">            if (nProfiles == 0) {</span>
<span class="nc" id="L310">                throw new IllegalArgumentException(</span>
                    &quot;Destination ColorSpace is undefined&quot;);
            }
<span class="nc" id="L313">            destProfile = profileList [nProfiles - 1];</span>
<span class="nc" id="L314">            dest = createCompatibleDestImage(src, null);</span>
        }
        else {
<span class="nc bnc" id="L317" title="All 2 branches missed.">            if (src.getHeight() != dest.getHeight() ||</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">                src.getWidth() != dest.getWidth()) {</span>
<span class="nc" id="L319">                throw new IllegalArgumentException(</span>
                    &quot;Width or height of BufferedImages do not match&quot;);
            }
<span class="nc" id="L322">            destProfile = ((ICC_ColorSpace) destColorSpace).getProfile();</span>
        }

        /* Checking if all profiles in the transform sequence are the same.
         * If so, performing just copying the data.
         */
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (srcProfile == destProfile) {</span>
<span class="nc" id="L329">            boolean noTrans = true;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            for (int i = 0; i &lt; nProfiles; i++) {</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">                if (srcProfile != profileList[i]) {</span>
<span class="nc" id="L332">                    noTrans = false;</span>
<span class="nc" id="L333">                    break;</span>
                }
            }
<span class="nc bnc" id="L336" title="All 2 branches missed.">            if (noTrans) {</span>
<span class="nc" id="L337">                Graphics2D g = dest.createGraphics();</span>
                try {
<span class="nc" id="L339">                    g.drawImage(src, 0, 0, null);</span>
                } finally {
<span class="nc" id="L341">                    g.dispose();</span>
<span class="nc" id="L342">                }</span>

<span class="nc" id="L344">                return dest;</span>
            }
        }

        /* make a new transform if needed */
<span class="nc bnc" id="L349" title="All 6 branches missed.">        if ((thisTransform == null) || (thisSrcProfile != srcProfile) ||</span>
            (thisDestProfile != destProfile) ) {
<span class="nc" id="L351">            updateBITransform(srcProfile, destProfile);</span>
        }

        /* color convert the image */
<span class="nc" id="L355">        thisTransform.colorConvert(src, dest);</span>

<span class="nc" id="L357">        return dest;</span>
    }

    private void updateBITransform(ICC_Profile srcProfile,
                                   ICC_Profile destProfile) {
        ICC_Profile[]    theProfiles;
        int              i1, nProfiles, nTransforms, whichTrans, renderState;
        ColorTransform[]  theTransforms;
<span class="nc" id="L365">        boolean          useSrc = false, useDest = false;</span>

<span class="nc" id="L367">        nProfiles = profileList.length;</span>
<span class="nc" id="L368">        nTransforms = nProfiles;</span>
<span class="nc bnc" id="L369" title="All 4 branches missed.">        if ((nProfiles == 0) || (srcProfile != profileList[0])) {</span>
<span class="nc" id="L370">            nTransforms += 1;</span>
<span class="nc" id="L371">            useSrc = true;</span>
        }
<span class="nc bnc" id="L373" title="All 6 branches missed.">        if ((nProfiles == 0) || (destProfile != profileList[nProfiles - 1]) ||</span>
            (nTransforms &lt; 2)) {
<span class="nc" id="L375">            nTransforms += 1;</span>
<span class="nc" id="L376">            useDest = true;</span>
        }

        /* make the profile list */
<span class="nc" id="L380">        theProfiles = new ICC_Profile[nTransforms]; /* the list of profiles</span>
                                                       for this Op */

<span class="nc" id="L383">        int idx = 0;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (useSrc) {</span>
            /* insert source as first profile */
<span class="nc" id="L386">            theProfiles[idx++] = srcProfile;</span>
        }

<span class="nc bnc" id="L389" title="All 2 branches missed.">        for (i1 = 0; i1 &lt; nProfiles; i1++) {</span>
                                   /* insert profiles defined in this Op */
<span class="nc" id="L391">            theProfiles[idx++] = profileList [i1];</span>
        }

<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (useDest) {</span>
            /* insert dest as last profile */
<span class="nc" id="L396">            theProfiles[idx] = destProfile;</span>
        }

        /* make the transform list */
<span class="nc" id="L400">        theTransforms = new ColorTransform [nTransforms];</span>

        /* initialize transform get loop */
<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (theProfiles[0].getProfileClass() == ICC_Profile.CLASS_OUTPUT) {</span>
                                        /* if first profile is a printer
                                           render as colorimetric */
<span class="nc" id="L406">            renderState = ICC_Profile.icRelativeColorimetric;</span>
        }
        else {
<span class="nc" id="L409">            renderState = ICC_Profile.icPerceptual; /* render any other</span>
                                                       class perceptually */
        }

<span class="nc" id="L413">        whichTrans = ColorTransform.In;</span>

<span class="nc" id="L415">        PCMM mdl = CMSManager.getModule();</span>

        /* get the transforms from each profile */
<span class="nc bnc" id="L418" title="All 2 branches missed.">        for (i1 = 0; i1 &lt; nTransforms; i1++) {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (i1 == nTransforms -1) {         /* last profile? */</span>
<span class="nc" id="L420">                whichTrans = ColorTransform.Out; /* get output transform */</span>
            }
            else {      /* check for abstract profile */
<span class="nc bnc" id="L423" title="All 2 branches missed.">                if ((whichTrans == ColorTransform.Simulation) &amp;&amp;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">                    (theProfiles[i1].getProfileClass () ==</span>
                     ICC_Profile.CLASS_ABSTRACT)) {
<span class="nc" id="L426">                renderState = ICC_Profile.icPerceptual;</span>
<span class="nc" id="L427">                    whichTrans = ColorTransform.In;</span>
                }
            }

<span class="nc" id="L431">            theTransforms[i1] = mdl.createTransform (</span>
                theProfiles[i1], renderState, whichTrans);

            /* get this profile's rendering intent to select transform
               from next profile */
<span class="nc" id="L436">            renderState = getRenderingIntent(theProfiles[i1]);</span>

            /* &quot;middle&quot; profiles use simulation transform */
<span class="nc" id="L439">            whichTrans = ColorTransform.Simulation;</span>
        }

        /* make the net transform */
<span class="nc" id="L443">        thisTransform = mdl.createTransform(theTransforms);</span>

        /* update corresponding source and dest profiles */
<span class="nc" id="L446">        thisSrcProfile = srcProfile;</span>
<span class="nc" id="L447">        thisDestProfile = destProfile;</span>
<span class="nc" id="L448">    }</span>

    /**
     * ColorConverts the image data in the source Raster.
     * If the destination Raster is null, a new Raster will be created.
     * The number of bands in the source and destination Rasters must
     * meet the requirements explained above.  The constructor used to
     * create this ColorConvertOp must have provided enough information
     * to define both source and destination color spaces.  See above.
     * Otherwise, an exception is thrown.
     * @param src the source &lt;code&gt;Raster&lt;/code&gt; to be converted
     * @param dest the destination &lt;code&gt;WritableRaster&lt;/code&gt;,
     *        or &lt;code&gt;null&lt;/code&gt;
     * @return &lt;code&gt;dest&lt;/code&gt; color converted from &lt;code&gt;src&lt;/code&gt;
     *         or a new, converted &lt;code&gt;WritableRaster&lt;/code&gt;
     *         if &lt;code&gt;dest&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     * @exception IllegalArgumentException if the number of source or
     *             destination bands is incorrect, the source or destination
     *             color spaces are undefined, or this op was constructed
     *             with one of the constructors that applies only to
     *             operations on BufferedImages.
     */
    public final WritableRaster filter (Raster src, WritableRaster dest)  {

<span class="nc bnc" id="L472" title="All 2 branches missed.">        if (CSList != null) {</span>
            /* non-ICC case */
<span class="nc" id="L474">            return nonICCRasterFilter(src, dest);</span>
        }
<span class="nc" id="L476">        int nProfiles = profileList.length;</span>
<span class="nc bnc" id="L477" title="All 2 branches missed.">        if (nProfiles &lt; 2) {</span>
<span class="nc" id="L478">            throw new IllegalArgumentException(</span>
                &quot;Source or Destination ColorSpace is undefined&quot;);
        }
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (src.getNumBands() != profileList[0].getNumComponents()) {</span>
<span class="nc" id="L482">            throw new IllegalArgumentException(</span>
                &quot;Numbers of source Raster bands and source color space &quot; +
                &quot;components do not match&quot;);
        }
<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (dest == null) {</span>
<span class="nc" id="L487">            dest = createCompatibleDestRaster(src);</span>
        }
        else {
<span class="nc bnc" id="L490" title="All 2 branches missed.">            if (src.getHeight() != dest.getHeight() ||</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">                src.getWidth() != dest.getWidth()) {</span>
<span class="nc" id="L492">                throw new IllegalArgumentException(</span>
                    &quot;Width or height of Rasters do not match&quot;);
            }
<span class="nc" id="L495">            if (dest.getNumBands() !=</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">                profileList[nProfiles-1].getNumComponents()) {</span>
<span class="nc" id="L497">                throw new IllegalArgumentException(</span>
                    &quot;Numbers of destination Raster bands and destination &quot; +
                    &quot;color space components do not match&quot;);
            }
        }

        /* make a new transform if needed */
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (thisRasterTransform == null) {</span>
            int              i1, whichTrans, renderState;
            ColorTransform[]  theTransforms;

            /* make the transform list */
<span class="nc" id="L509">            theTransforms = new ColorTransform [nProfiles];</span>

            /* initialize transform get loop */
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (profileList[0].getProfileClass() == ICC_Profile.CLASS_OUTPUT) {</span>
                                            /* if first profile is a printer
                                               render as colorimetric */
<span class="nc" id="L515">                renderState = ICC_Profile.icRelativeColorimetric;</span>
            }
            else {
<span class="nc" id="L518">                renderState = ICC_Profile.icPerceptual; /* render any other</span>
                                                           class perceptually */
            }

<span class="nc" id="L522">            whichTrans = ColorTransform.In;</span>

<span class="nc" id="L524">            PCMM mdl = CMSManager.getModule();</span>

            /* get the transforms from each profile */
<span class="nc bnc" id="L527" title="All 2 branches missed.">            for (i1 = 0; i1 &lt; nProfiles; i1++) {</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">                if (i1 == nProfiles -1) {         /* last profile? */</span>
<span class="nc" id="L529">                    whichTrans = ColorTransform.Out; /* get output transform */</span>
                }
                else {  /* check for abstract profile */
<span class="nc bnc" id="L532" title="All 2 branches missed.">                    if ((whichTrans == ColorTransform.Simulation) &amp;&amp;</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                        (profileList[i1].getProfileClass () ==</span>
                         ICC_Profile.CLASS_ABSTRACT)) {
<span class="nc" id="L535">                        renderState = ICC_Profile.icPerceptual;</span>
<span class="nc" id="L536">                        whichTrans = ColorTransform.In;</span>
                    }
                }

<span class="nc" id="L540">                theTransforms[i1] = mdl.createTransform (</span>
                    profileList[i1], renderState, whichTrans);

                /* get this profile's rendering intent to select transform
                   from next profile */
<span class="nc" id="L545">                renderState = getRenderingIntent(profileList[i1]);</span>

                /* &quot;middle&quot; profiles use simulation transform */
<span class="nc" id="L548">                whichTrans = ColorTransform.Simulation;</span>
            }

            /* make the net transform */
<span class="nc" id="L552">            thisRasterTransform = mdl.createTransform(theTransforms);</span>
        }

<span class="nc" id="L555">        int srcTransferType = src.getTransferType();</span>
<span class="nc" id="L556">        int dstTransferType = dest.getTransferType();</span>
<span class="nc bnc" id="L557" title="All 8 branches missed.">        if ((srcTransferType == DataBuffer.TYPE_FLOAT) ||</span>
            (srcTransferType == DataBuffer.TYPE_DOUBLE) ||
            (dstTransferType == DataBuffer.TYPE_FLOAT) ||
            (dstTransferType == DataBuffer.TYPE_DOUBLE)) {
<span class="nc bnc" id="L561" title="All 2 branches missed.">            if (srcMinVals == null) {</span>
<span class="nc" id="L562">                getMinMaxValsFromProfiles(profileList[0],</span>
                                          profileList[nProfiles-1]);
            }
            /* color convert the raster */
<span class="nc" id="L566">            thisRasterTransform.colorConvert(src, dest,</span>
                                             srcMinVals, srcMaxVals,
                                             dstMinVals, dstMaxVals);
        } else {
            /* color convert the raster */
<span class="nc" id="L571">            thisRasterTransform.colorConvert(src, dest);</span>
        }


<span class="nc" id="L575">        return dest;</span>
    }

    /**
     * Returns the bounding box of the destination, given this source.
     * Note that this will be the same as the the bounding box of the
     * source.
     * @param src the source &lt;code&gt;BufferedImage&lt;/code&gt;
     * @return a &lt;code&gt;Rectangle2D&lt;/code&gt; that is the bounding box
     *         of the destination, given the specified &lt;code&gt;src&lt;/code&gt;
     */
    public final Rectangle2D getBounds2D (BufferedImage src) {
<span class="nc" id="L587">        return getBounds2D(src.getRaster());</span>
    }

    /**
     * Returns the bounding box of the destination, given this source.
     * Note that this will be the same as the the bounding box of the
     * source.
     * @param src the source &lt;code&gt;Raster&lt;/code&gt;
     * @return a &lt;code&gt;Rectangle2D&lt;/code&gt; that is the bounding box
     *         of the destination, given the specified &lt;code&gt;src&lt;/code&gt;
     */
    public final Rectangle2D getBounds2D (Raster src) {
        /*        return new Rectangle (src.getXOffset(),
                              src.getYOffset(),
                              src.getWidth(), src.getHeight()); */
<span class="nc" id="L602">        return src.getBounds();</span>
    }

    /**
     * Creates a zeroed destination image with the correct size and number of
     * bands, given this source.
     * @param src       Source image for the filter operation.
     * @param destCM    ColorModel of the destination.  If null, an
     *                  appropriate ColorModel will be used.
     * @return a &lt;code&gt;BufferedImage&lt;/code&gt; with the correct size and
     * number of bands from the specified &lt;code&gt;src&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;destCM&lt;/code&gt; is
     *         &lt;code&gt;null&lt;/code&gt; and this &lt;code&gt;ColorConvertOp&lt;/code&gt; was
     *         created without any &lt;code&gt;ICC_Profile&lt;/code&gt; or
     *         &lt;code&gt;ColorSpace&lt;/code&gt; defined for the destination
     */
    public BufferedImage createCompatibleDestImage (BufferedImage src,
                                                    ColorModel destCM) {
<span class="nc" id="L620">        ColorSpace cs = null;;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">        if (destCM == null) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">            if (CSList == null) {</span>
                /* ICC case */
<span class="nc" id="L624">                int nProfiles = profileList.length;</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                if (nProfiles == 0) {</span>
<span class="nc" id="L626">                    throw new IllegalArgumentException(</span>
                        &quot;Destination ColorSpace is undefined&quot;);
                }
<span class="nc" id="L629">                ICC_Profile destProfile = profileList[nProfiles - 1];</span>
<span class="nc" id="L630">                cs = new ICC_ColorSpace(destProfile);</span>
<span class="nc" id="L631">            } else {</span>
                /* non-ICC case */
<span class="nc" id="L633">                int nSpaces = CSList.length;</span>
<span class="nc" id="L634">                cs = CSList[nSpaces - 1];</span>
            }
        }
<span class="nc" id="L637">        return createCompatibleDestImage(src, destCM, cs);</span>
    }

    private BufferedImage createCompatibleDestImage(BufferedImage src,
                                                    ColorModel destCM,
                                                    ColorSpace destCS) {
        BufferedImage image;
<span class="nc bnc" id="L644" title="All 2 branches missed.">        if (destCM == null) {</span>
<span class="nc" id="L645">            ColorModel srcCM = src.getColorModel();</span>
<span class="nc" id="L646">            int nbands = destCS.getNumComponents();</span>
<span class="nc" id="L647">            boolean hasAlpha = srcCM.hasAlpha();</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">            if (hasAlpha) {</span>
<span class="nc" id="L649">               nbands += 1;</span>
            }
<span class="nc" id="L651">            int[] nbits = new int[nbands];</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">            for (int i = 0; i &lt; nbands; i++) {</span>
<span class="nc" id="L653">                nbits[i] = 8;</span>
            }
<span class="nc" id="L655">            destCM = new ComponentColorModel(destCS, nbits, hasAlpha,</span>
<span class="nc" id="L656">                                             srcCM.isAlphaPremultiplied(),</span>
<span class="nc" id="L657">                                             srcCM.getTransparency(),</span>
                                             DataBuffer.TYPE_BYTE);
        }
<span class="nc" id="L660">        int w = src.getWidth();</span>
<span class="nc" id="L661">        int h = src.getHeight();</span>
<span class="nc" id="L662">        image = new BufferedImage(destCM,</span>
<span class="nc" id="L663">                                  destCM.createCompatibleWritableRaster(w, h),</span>
<span class="nc" id="L664">                                  destCM.isAlphaPremultiplied(), null);</span>
<span class="nc" id="L665">        return image;</span>
    }


    /**
     * Creates a zeroed destination Raster with the correct size and number of
     * bands, given this source.
     * @param src the specified &lt;code&gt;Raster&lt;/code&gt;
     * @return a &lt;code&gt;WritableRaster&lt;/code&gt; with the correct size and number
     *         of bands from the specified &lt;code&gt;src&lt;/code&gt;
     * @throws IllegalArgumentException if this &lt;code&gt;ColorConvertOp&lt;/code&gt;
     *         was created without sufficient information to define the
     *         &lt;code&gt;dst&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; color spaces
     */
    public WritableRaster createCompatibleDestRaster (Raster src) {
        int ncomponents;

<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (CSList != null) {</span>
            /* non-ICC case */
<span class="nc bnc" id="L684" title="All 2 branches missed.">            if (CSList.length != 2) {</span>
<span class="nc" id="L685">                throw new IllegalArgumentException(</span>
                    &quot;Destination ColorSpace is undefined&quot;);
            }
<span class="nc" id="L688">            ncomponents = CSList[1].getNumComponents();</span>
        } else {
            /* ICC case */
<span class="nc" id="L691">            int nProfiles = profileList.length;</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">            if (nProfiles &lt; 2) {</span>
<span class="nc" id="L693">                throw new IllegalArgumentException(</span>
                    &quot;Destination ColorSpace is undefined&quot;);
            }
<span class="nc" id="L696">            ncomponents = profileList[nProfiles-1].getNumComponents();</span>
        }

<span class="nc" id="L699">        WritableRaster dest =</span>
<span class="nc" id="L700">            Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,</span>
<span class="nc" id="L701">                                  src.getWidth(),</span>
<span class="nc" id="L702">                                  src.getHeight(),</span>
                                  ncomponents,
<span class="nc" id="L704">                                  new Point(src.getMinX(), src.getMinY()));</span>
<span class="nc" id="L705">        return dest;</span>
    }

    /**
     * Returns the location of the destination point given a
     * point in the source.  If &lt;code&gt;dstPt&lt;/code&gt; is non-null,
     * it will be used to hold the return value.  Note that
     * for this class, the destination point will be the same
     * as the source point.
     * @param srcPt the specified source &lt;code&gt;Point2D&lt;/code&gt;
     * @param dstPt the destination &lt;code&gt;Point2D&lt;/code&gt;
     * @return &lt;code&gt;dstPt&lt;/code&gt; after setting its location to be
     *         the same as &lt;code&gt;srcPt&lt;/code&gt;
     */
    public final Point2D getPoint2D (Point2D srcPt, Point2D dstPt) {
<span class="nc bnc" id="L720" title="All 2 branches missed.">        if (dstPt == null) {</span>
<span class="nc" id="L721">            dstPt = new Point2D.Float();</span>
        }
<span class="nc" id="L723">        dstPt.setLocation(srcPt.getX(), srcPt.getY());</span>

<span class="nc" id="L725">        return dstPt;</span>
    }


    /**
     * Returns the RenderingIntent from the specified ICC Profile.
     */
    private int getRenderingIntent (ICC_Profile profile) {
<span class="nc" id="L733">        byte[] header = profile.getData(ICC_Profile.icSigHead);</span>
<span class="nc" id="L734">        int index = ICC_Profile.icHdrRenderingIntent;</span>

        /* According to ICC spec, only the least-significant 16 bits shall be
         * used to encode the rendering intent. The most significant 16 bits
         * shall be set to zero. Thus, we are ignoring two most significant
         * bytes here.
         *
         *  See http://www.color.org/ICC1v42_2006-05.pdf, section 7.2.15.
         */
<span class="nc" id="L743">        return ((header[index+2] &amp; 0xff) &lt;&lt;  8) |</span>
                (header[index+3] &amp; 0xff);
    }

    /**
     * Returns the rendering hints used by this op.
     * @return the &lt;code&gt;RenderingHints&lt;/code&gt; object of this
     *         &lt;code&gt;ColorConvertOp&lt;/code&gt;
     */
    public final RenderingHints getRenderingHints() {
<span class="nc" id="L753">        return hints;</span>
    }

    private final BufferedImage nonICCBIFilter(BufferedImage src,
                                               ColorSpace srcColorSpace,
                                               BufferedImage dst,
                                               ColorSpace dstColorSpace) {

<span class="nc" id="L761">        int w = src.getWidth();</span>
<span class="nc" id="L762">        int h = src.getHeight();</span>
<span class="nc" id="L763">        ICC_ColorSpace ciespace =</span>
<span class="nc" id="L764">            (ICC_ColorSpace) ColorSpace.getInstance(ColorSpace.CS_CIEXYZ);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L766">            dst = createCompatibleDestImage(src, null);</span>
<span class="nc" id="L767">            dstColorSpace = dst.getColorModel().getColorSpace();</span>
        } else {
<span class="nc bnc" id="L769" title="All 4 branches missed.">            if ((h != dst.getHeight()) || (w != dst.getWidth())) {</span>
<span class="nc" id="L770">                throw new IllegalArgumentException(</span>
                    &quot;Width or height of BufferedImages do not match&quot;);
            }
        }
<span class="nc" id="L774">        Raster srcRas = src.getRaster();</span>
<span class="nc" id="L775">        WritableRaster dstRas = dst.getRaster();</span>
<span class="nc" id="L776">        ColorModel srcCM = src.getColorModel();</span>
<span class="nc" id="L777">        ColorModel dstCM = dst.getColorModel();</span>
<span class="nc" id="L778">        int srcNumComp = srcCM.getNumColorComponents();</span>
<span class="nc" id="L779">        int dstNumComp = dstCM.getNumColorComponents();</span>
<span class="nc" id="L780">        boolean dstHasAlpha = dstCM.hasAlpha();</span>
<span class="nc bnc" id="L781" title="All 4 branches missed.">        boolean needSrcAlpha = srcCM.hasAlpha() &amp;&amp; dstHasAlpha;</span>
        ColorSpace[] list;
<span class="nc bnc" id="L783" title="All 4 branches missed.">        if ((CSList == null) &amp;&amp; (profileList.length != 0)) {</span>
            /* possible non-ICC src, some profiles, possible non-ICC dst */
            boolean nonICCSrc, nonICCDst;
            ICC_Profile srcProfile, dstProfile;
<span class="nc bnc" id="L787" title="All 2 branches missed.">            if (!(srcColorSpace instanceof ICC_ColorSpace)) {</span>
<span class="nc" id="L788">                nonICCSrc = true;</span>
<span class="nc" id="L789">                srcProfile = ciespace.getProfile();</span>
            } else {
<span class="nc" id="L791">                nonICCSrc = false;</span>
<span class="nc" id="L792">                srcProfile = ((ICC_ColorSpace) srcColorSpace).getProfile();</span>
            }
<span class="nc bnc" id="L794" title="All 2 branches missed.">            if (!(dstColorSpace instanceof ICC_ColorSpace)) {</span>
<span class="nc" id="L795">                nonICCDst = true;</span>
<span class="nc" id="L796">                dstProfile = ciespace.getProfile();</span>
            } else {
<span class="nc" id="L798">                nonICCDst = false;</span>
<span class="nc" id="L799">                dstProfile = ((ICC_ColorSpace) dstColorSpace).getProfile();</span>
            }
            /* make a new transform if needed */
<span class="nc bnc" id="L802" title="All 6 branches missed.">            if ((thisTransform == null) || (thisSrcProfile != srcProfile) ||</span>
                (thisDestProfile != dstProfile) ) {
<span class="nc" id="L804">                updateBITransform(srcProfile, dstProfile);</span>
            }
            // process per scanline
<span class="nc" id="L807">            float maxNum = 65535.0f; // use 16-bit precision in CMM</span>
            ColorSpace cs;
            int iccSrcNumComp;
<span class="nc bnc" id="L810" title="All 2 branches missed.">            if (nonICCSrc) {</span>
<span class="nc" id="L811">                cs = ciespace;</span>
<span class="nc" id="L812">                iccSrcNumComp = 3;</span>
            } else {
<span class="nc" id="L814">                cs = srcColorSpace;</span>
<span class="nc" id="L815">                iccSrcNumComp = srcNumComp;</span>
            }
<span class="nc" id="L817">            float[] srcMinVal = new float[iccSrcNumComp];</span>
<span class="nc" id="L818">            float[] srcInvDiffMinMax = new float[iccSrcNumComp];</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">            for (int i = 0; i &lt; srcNumComp; i++) {</span>
<span class="nc" id="L820">                srcMinVal[i] = cs.getMinValue(i);</span>
<span class="nc" id="L821">                srcInvDiffMinMax[i] = maxNum / (cs.getMaxValue(i) - srcMinVal[i]);</span>
            }
            int iccDstNumComp;
<span class="nc bnc" id="L824" title="All 2 branches missed.">            if (nonICCDst) {</span>
<span class="nc" id="L825">                cs = ciespace;</span>
<span class="nc" id="L826">                iccDstNumComp = 3;</span>
            } else {
<span class="nc" id="L828">                cs = dstColorSpace;</span>
<span class="nc" id="L829">                iccDstNumComp = dstNumComp;</span>
            }
<span class="nc" id="L831">            float[] dstMinVal = new float[iccDstNumComp];</span>
<span class="nc" id="L832">            float[] dstDiffMinMax = new float[iccDstNumComp];</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">            for (int i = 0; i &lt; dstNumComp; i++) {</span>
<span class="nc" id="L834">                dstMinVal[i] = cs.getMinValue(i);</span>
<span class="nc" id="L835">                dstDiffMinMax[i] = (cs.getMaxValue(i) - dstMinVal[i]) / maxNum;</span>
            }
            float[] dstColor;
<span class="nc bnc" id="L838" title="All 2 branches missed.">            if (dstHasAlpha) {</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">                int size = ((dstNumComp + 1) &gt; 3) ? (dstNumComp + 1) : 3;</span>
<span class="nc" id="L840">                dstColor = new float[size];</span>
<span class="nc" id="L841">            } else {</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">                int size = (dstNumComp  &gt; 3) ? dstNumComp : 3;</span>
<span class="nc" id="L843">                dstColor = new float[size];</span>
            }
<span class="nc" id="L845">            short[] srcLine = new short[w * iccSrcNumComp];</span>
<span class="nc" id="L846">            short[] dstLine = new short[w * iccDstNumComp];</span>
            Object pixel;
            float[] color;
<span class="nc" id="L849">            float[] alpha = null;</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">            if (needSrcAlpha) {</span>
<span class="nc" id="L851">                alpha = new float[w];</span>
            }
            int idx;
            // process each scanline
<span class="nc bnc" id="L855" title="All 2 branches missed.">            for (int y = 0; y &lt; h; y++) {</span>
                // convert src scanline
<span class="nc" id="L857">                pixel = null;</span>
<span class="nc" id="L858">                color = null;</span>
<span class="nc" id="L859">                idx = 0;</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">                for (int x = 0; x &lt; w; x++) {</span>
<span class="nc" id="L861">                    pixel = srcRas.getDataElements(x, y, pixel);</span>
<span class="nc" id="L862">                    color = srcCM.getNormalizedComponents(pixel, color, 0);</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">                    if (needSrcAlpha) {</span>
<span class="nc" id="L864">                        alpha[x] = color[srcNumComp];</span>
                    }
<span class="nc bnc" id="L866" title="All 2 branches missed.">                    if (nonICCSrc) {</span>
<span class="nc" id="L867">                        color = srcColorSpace.toCIEXYZ(color);</span>
                    }
<span class="nc bnc" id="L869" title="All 2 branches missed.">                    for (int i = 0; i &lt; iccSrcNumComp; i++) {</span>
<span class="nc" id="L870">                        srcLine[idx++] = (short)</span>
                            ((color[i] - srcMinVal[i]) * srcInvDiffMinMax[i] +
                             0.5f);
                    }
                }
                // color convert srcLine to dstLine
<span class="nc" id="L876">                thisTransform.colorConvert(srcLine, dstLine);</span>
                // convert dst scanline
<span class="nc" id="L878">                pixel = null;</span>
<span class="nc" id="L879">                idx = 0;</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">                for (int x = 0; x &lt; w; x++) {</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">                    for (int i = 0; i &lt; iccDstNumComp; i++) {</span>
<span class="nc" id="L882">                        dstColor[i] = ((float) (dstLine[idx++] &amp; 0xffff)) *</span>
                                      dstDiffMinMax[i] + dstMinVal[i];
                    }
<span class="nc bnc" id="L885" title="All 2 branches missed.">                    if (nonICCDst) {</span>
<span class="nc" id="L886">                        color = srcColorSpace.fromCIEXYZ(dstColor);</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">                        for (int i = 0; i &lt; dstNumComp; i++) {</span>
<span class="nc" id="L888">                            dstColor[i] = color[i];</span>
                        }
                    }
<span class="nc bnc" id="L891" title="All 2 branches missed.">                    if (needSrcAlpha) {</span>
<span class="nc" id="L892">                        dstColor[dstNumComp] = alpha[x];</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">                    } else if (dstHasAlpha) {</span>
<span class="nc" id="L894">                        dstColor[dstNumComp] = 1.0f;</span>
                    }
<span class="nc" id="L896">                    pixel = dstCM.getDataElements(dstColor, 0, pixel);</span>
<span class="nc" id="L897">                    dstRas.setDataElements(x, y, pixel);</span>
                }
            }
<span class="nc" id="L900">        } else {</span>
            /* possible non-ICC src, possible CSList, possible non-ICC dst */
            // process per pixel
            int numCS;
<span class="nc bnc" id="L904" title="All 2 branches missed.">            if (CSList == null) {</span>
<span class="nc" id="L905">                numCS = 0;</span>
            } else {
<span class="nc" id="L907">                numCS = CSList.length;</span>
            }
            float[] dstColor;
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (dstHasAlpha) {</span>
<span class="nc" id="L911">                dstColor = new float[dstNumComp + 1];</span>
            } else {
<span class="nc" id="L913">                dstColor = new float[dstNumComp];</span>
            }
<span class="nc" id="L915">            Object spixel = null;</span>
<span class="nc" id="L916">            Object dpixel = null;</span>
<span class="nc" id="L917">            float[] color = null;</span>
            float[] tmpColor;
            // process each pixel
<span class="nc bnc" id="L920" title="All 2 branches missed.">            for (int y = 0; y &lt; h; y++) {</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">                for (int x = 0; x &lt; w; x++) {</span>
<span class="nc" id="L922">                    spixel = srcRas.getDataElements(x, y, spixel);</span>
<span class="nc" id="L923">                    color = srcCM.getNormalizedComponents(spixel, color, 0);</span>
<span class="nc" id="L924">                    tmpColor = srcColorSpace.toCIEXYZ(color);</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">                    for (int i = 0; i &lt; numCS; i++) {</span>
<span class="nc" id="L926">                        tmpColor = CSList[i].fromCIEXYZ(tmpColor);</span>
<span class="nc" id="L927">                        tmpColor = CSList[i].toCIEXYZ(tmpColor);</span>
                    }
<span class="nc" id="L929">                    tmpColor = dstColorSpace.fromCIEXYZ(tmpColor);</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">                    for (int i = 0; i &lt; dstNumComp; i++) {</span>
<span class="nc" id="L931">                        dstColor[i] = tmpColor[i];</span>
                    }
<span class="nc bnc" id="L933" title="All 2 branches missed.">                    if (needSrcAlpha) {</span>
<span class="nc" id="L934">                        dstColor[dstNumComp] = color[srcNumComp];</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">                    } else if (dstHasAlpha) {</span>
<span class="nc" id="L936">                        dstColor[dstNumComp] = 1.0f;</span>
                    }
<span class="nc" id="L938">                    dpixel = dstCM.getDataElements(dstColor, 0, dpixel);</span>
<span class="nc" id="L939">                    dstRas.setDataElements(x, y, dpixel);</span>

                }
            }
        }

<span class="nc" id="L945">        return dst;</span>
    }

    /* color convert a Raster - handles byte, ushort, int, short, float,
       or double transferTypes */
    private final WritableRaster nonICCRasterFilter(Raster src,
                                                    WritableRaster dst)  {

<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (CSList.length != 2) {</span>
<span class="nc" id="L954">            throw new IllegalArgumentException(</span>
                &quot;Destination ColorSpace is undefined&quot;);
        }
<span class="nc bnc" id="L957" title="All 2 branches missed.">        if (src.getNumBands() != CSList[0].getNumComponents()) {</span>
<span class="nc" id="L958">            throw new IllegalArgumentException(</span>
                &quot;Numbers of source Raster bands and source color space &quot; +
                &quot;components do not match&quot;);
        }
<span class="nc bnc" id="L962" title="All 2 branches missed.">        if (dst == null) {</span>
<span class="nc" id="L963">            dst = createCompatibleDestRaster(src);</span>
        } else {
<span class="nc bnc" id="L965" title="All 2 branches missed.">            if (src.getHeight() != dst.getHeight() ||</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">                src.getWidth() != dst.getWidth()) {</span>
<span class="nc" id="L967">                throw new IllegalArgumentException(</span>
                    &quot;Width or height of Rasters do not match&quot;);
            }
<span class="nc bnc" id="L970" title="All 2 branches missed.">            if (dst.getNumBands() != CSList[1].getNumComponents()) {</span>
<span class="nc" id="L971">                throw new IllegalArgumentException(</span>
                    &quot;Numbers of destination Raster bands and destination &quot; +
                    &quot;color space components do not match&quot;);
            }
        }

<span class="nc bnc" id="L977" title="All 2 branches missed.">        if (srcMinVals == null) {</span>
<span class="nc" id="L978">            getMinMaxValsFromColorSpaces(CSList[0], CSList[1]);</span>
        }

<span class="nc" id="L981">        SampleModel srcSM = src.getSampleModel();</span>
<span class="nc" id="L982">        SampleModel dstSM = dst.getSampleModel();</span>
        boolean srcIsFloat, dstIsFloat;
<span class="nc" id="L984">        int srcTransferType = src.getTransferType();</span>
<span class="nc" id="L985">        int dstTransferType = dst.getTransferType();</span>
<span class="nc bnc" id="L986" title="All 4 branches missed.">        if ((srcTransferType == DataBuffer.TYPE_FLOAT) ||</span>
            (srcTransferType == DataBuffer.TYPE_DOUBLE)) {
<span class="nc" id="L988">            srcIsFloat = true;</span>
        } else {
<span class="nc" id="L990">            srcIsFloat = false;</span>
        }
<span class="nc bnc" id="L992" title="All 4 branches missed.">        if ((dstTransferType == DataBuffer.TYPE_FLOAT) ||</span>
            (dstTransferType == DataBuffer.TYPE_DOUBLE)) {
<span class="nc" id="L994">            dstIsFloat = true;</span>
        } else {
<span class="nc" id="L996">            dstIsFloat = false;</span>
        }
<span class="nc" id="L998">        int w = src.getWidth();</span>
<span class="nc" id="L999">        int h = src.getHeight();</span>
<span class="nc" id="L1000">        int srcNumBands = src.getNumBands();</span>
<span class="nc" id="L1001">        int dstNumBands = dst.getNumBands();</span>
<span class="nc" id="L1002">        float[] srcScaleFactor = null;</span>
<span class="nc" id="L1003">        float[] dstScaleFactor = null;</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">        if (!srcIsFloat) {</span>
<span class="nc" id="L1005">            srcScaleFactor = new float[srcNumBands];</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">            for (int i = 0; i &lt; srcNumBands; i++) {</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">                if (srcTransferType == DataBuffer.TYPE_SHORT) {</span>
<span class="nc" id="L1008">                    srcScaleFactor[i] = (srcMaxVals[i] - srcMinVals[i]) /</span>
                                        32767.0f;
                } else {
<span class="nc" id="L1011">                    srcScaleFactor[i] = (srcMaxVals[i] - srcMinVals[i]) /</span>
<span class="nc" id="L1012">                        ((float) ((1 &lt;&lt; srcSM.getSampleSize(i)) - 1));</span>
                }
            }
        }
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        if (!dstIsFloat) {</span>
<span class="nc" id="L1017">            dstScaleFactor = new float[dstNumBands];</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">            for (int i = 0; i &lt; dstNumBands; i++) {</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">                if (dstTransferType == DataBuffer.TYPE_SHORT) {</span>
<span class="nc" id="L1020">                    dstScaleFactor[i] = 32767.0f /</span>
                                        (dstMaxVals[i] - dstMinVals[i]);
                } else {
<span class="nc" id="L1023">                    dstScaleFactor[i] =</span>
<span class="nc" id="L1024">                        ((float) ((1 &lt;&lt; dstSM.getSampleSize(i)) - 1)) /</span>
                        (dstMaxVals[i] - dstMinVals[i]);
                }
            }
        }
<span class="nc" id="L1029">        int ys = src.getMinY();</span>
<span class="nc" id="L1030">        int yd = dst.getMinY();</span>
        int xs, xd;
        float sample;
<span class="nc" id="L1033">        float[] color = new float[srcNumBands];</span>
        float[] tmpColor;
<span class="nc" id="L1035">        ColorSpace srcColorSpace = CSList[0];</span>
<span class="nc" id="L1036">        ColorSpace dstColorSpace = CSList[1];</span>
        // process each pixel
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        for (int y = 0; y &lt; h; y++, ys++, yd++) {</span>
            // get src scanline
<span class="nc" id="L1040">            xs = src.getMinX();</span>
<span class="nc" id="L1041">            xd = dst.getMinX();</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">            for (int x = 0; x &lt; w; x++, xs++, xd++) {</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                for (int i = 0; i &lt; srcNumBands; i++) {</span>
<span class="nc" id="L1044">                    sample = src.getSampleFloat(xs, ys, i);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                    if (!srcIsFloat) {</span>
<span class="nc" id="L1046">                        sample = sample * srcScaleFactor[i] + srcMinVals[i];</span>
                    }
<span class="nc" id="L1048">                    color[i] = sample;</span>
                }
<span class="nc" id="L1050">                tmpColor = srcColorSpace.toCIEXYZ(color);</span>
<span class="nc" id="L1051">                tmpColor = dstColorSpace.fromCIEXYZ(tmpColor);</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">                for (int i = 0; i &lt; dstNumBands; i++) {</span>
<span class="nc" id="L1053">                    sample = tmpColor[i];</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">                    if (!dstIsFloat) {</span>
<span class="nc" id="L1055">                        sample = (sample - dstMinVals[i]) * dstScaleFactor[i];</span>
                    }
<span class="nc" id="L1057">                    dst.setSample(xd, yd, i, sample);</span>
                }
            }
        }
<span class="nc" id="L1061">        return dst;</span>
    }

    private void getMinMaxValsFromProfiles(ICC_Profile srcProfile,
                                           ICC_Profile dstProfile) {
<span class="nc" id="L1066">        int type = srcProfile.getColorSpaceType();</span>
<span class="nc" id="L1067">        int nc = srcProfile.getNumComponents();</span>
<span class="nc" id="L1068">        srcMinVals = new float[nc];</span>
<span class="nc" id="L1069">        srcMaxVals = new float[nc];</span>
<span class="nc" id="L1070">        setMinMax(type, nc, srcMinVals, srcMaxVals);</span>
<span class="nc" id="L1071">        type = dstProfile.getColorSpaceType();</span>
<span class="nc" id="L1072">        nc = dstProfile.getNumComponents();</span>
<span class="nc" id="L1073">        dstMinVals = new float[nc];</span>
<span class="nc" id="L1074">        dstMaxVals = new float[nc];</span>
<span class="nc" id="L1075">        setMinMax(type, nc, dstMinVals, dstMaxVals);</span>
<span class="nc" id="L1076">    }</span>

    private void setMinMax(int type, int nc, float[] minVals, float[] maxVals) {
<span class="nc bnc" id="L1079" title="All 2 branches missed.">        if (type == ColorSpace.TYPE_Lab) {</span>
<span class="nc" id="L1080">            minVals[0] = 0.0f;    // L</span>
<span class="nc" id="L1081">            maxVals[0] = 100.0f;</span>
<span class="nc" id="L1082">            minVals[1] = -128.0f; // a</span>
<span class="nc" id="L1083">            maxVals[1] = 127.0f;</span>
<span class="nc" id="L1084">            minVals[2] = -128.0f; // b</span>
<span class="nc" id="L1085">            maxVals[2] = 127.0f;</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        } else if (type == ColorSpace.TYPE_XYZ) {</span>
<span class="nc" id="L1087">            minVals[0] = minVals[1] = minVals[2] = 0.0f; // X, Y, Z</span>
<span class="nc" id="L1088">            maxVals[0] = maxVals[1] = maxVals[2] = 1.0f + (32767.0f/ 32768.0f);</span>
        } else {
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            for (int i = 0; i &lt; nc; i++) {</span>
<span class="nc" id="L1091">                minVals[i] = 0.0f;</span>
<span class="nc" id="L1092">                maxVals[i] = 1.0f;</span>
            }
        }
<span class="nc" id="L1095">    }</span>

    private void getMinMaxValsFromColorSpaces(ColorSpace srcCspace,
                                              ColorSpace dstCspace) {
<span class="nc" id="L1099">        int nc = srcCspace.getNumComponents();</span>
<span class="nc" id="L1100">        srcMinVals = new float[nc];</span>
<span class="nc" id="L1101">        srcMaxVals = new float[nc];</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        for (int i = 0; i &lt; nc; i++) {</span>
<span class="nc" id="L1103">            srcMinVals[i] = srcCspace.getMinValue(i);</span>
<span class="nc" id="L1104">            srcMaxVals[i] = srcCspace.getMaxValue(i);</span>
        }
<span class="nc" id="L1106">        nc = dstCspace.getNumComponents();</span>
<span class="nc" id="L1107">        dstMinVals = new float[nc];</span>
<span class="nc" id="L1108">        dstMaxVals = new float[nc];</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">        for (int i = 0; i &lt; nc; i++) {</span>
<span class="nc" id="L1110">            dstMinVals[i] = dstCspace.getMinValue(i);</span>
<span class="nc" id="L1111">            dstMaxVals[i] = dstCspace.getMaxValue(i);</span>
        }
<span class="nc" id="L1113">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>