<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ComponentSampleModel.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">ComponentSampleModel.java</span></div><h1>ComponentSampleModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/* ****************************************************************
 ******************************************************************
 ******************************************************************
 *** COPYRIGHT (c) Eastman Kodak Company, 1997
 *** As  an unpublished  work pursuant to Title 17 of the United
 *** States Code.  All rights reserved.
 ******************************************************************
 ******************************************************************
 ******************************************************************/

package java.awt.image;

import java.util.Arrays;

/**
 *  This class represents image data which is stored such that each sample
 *  of a pixel occupies one data element of the DataBuffer.  It stores the
 *  N samples which make up a pixel in N separate data array elements.
 *  Different bands may be in different banks of the DataBuffer.
 *  Accessor methods are provided so that image data can be manipulated
 *  directly. This class can support different kinds of interleaving, e.g.
 *  band interleaving, scanline interleaving, and pixel interleaving.
 *  Pixel stride is the number of data array elements between two samples
 *  for the same band on the same scanline. Scanline stride is the number
 *  of data array elements between a given sample and the corresponding sample
 *  in the same column of the next scanline.  Band offsets denote the number
 *  of data array elements from the first data array element of the bank
 *  of the DataBuffer holding each band to the first sample of the band.
 *  The bands are numbered from 0 to N-1.  This class can represent image
 *  data for which each sample is an unsigned integral number which can be
 *  stored in 8, 16, or 32 bits (using &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
 *  &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;,
 *  respectively), data for which each sample is a signed integral number
 *  which can be stored in 16 bits (using &lt;code&gt;DataBuffer.TYPE_SHORT&lt;/code&gt;),
 *  or data for which each sample is a signed float or double quantity
 *  (using &lt;code&gt;DataBuffer.TYPE_FLOAT&lt;/code&gt; or
 *  &lt;code&gt;DataBuffer.TYPE_DOUBLE&lt;/code&gt;, respectively).
 *  All samples of a given ComponentSampleModel
 *  are stored with the same precision.  All strides and offsets must be
 *  non-negative.  This class supports
 *  {@link DataBuffer#TYPE_BYTE TYPE_BYTE},
 *  {@link DataBuffer#TYPE_USHORT TYPE_USHORT},
 *  {@link DataBuffer#TYPE_SHORT TYPE_SHORT},
 *  {@link DataBuffer#TYPE_INT TYPE_INT},
 *  {@link DataBuffer#TYPE_FLOAT TYPE_FLOAT},
 *  {@link DataBuffer#TYPE_DOUBLE TYPE_DOUBLE},
 *  @see java.awt.image.PixelInterleavedSampleModel
 *  @see java.awt.image.BandedSampleModel
 */

public class ComponentSampleModel extends SampleModel
{
    /** Offsets for all bands in data array elements. */
    protected int bandOffsets[];

    /** Index for each bank storing a band of image data. */
    protected int[] bankIndices;

    /**
     * The number of bands in this
     * &lt;code&gt;ComponentSampleModel&lt;/code&gt;.
     */
<span class="nc" id="L88">    protected int numBands = 1;</span>

    /**
     * The number of banks in this
     * &lt;code&gt;ComponentSampleModel&lt;/code&gt;.
     */
<span class="nc" id="L94">    protected int numBanks = 1;</span>

    /**
     *  Line stride (in data array elements) of the region of image
     *  data described by this ComponentSampleModel.
     */
    protected int scanlineStride;

    /** Pixel stride (in data array elements) of the region of image
     *  data described by this ComponentSampleModel.
     */
    protected int pixelStride;

    static private native void initIDs();
    static {
<span class="nc" id="L109">        ColorModel.loadLibraries();</span>
<span class="nc" id="L110">        initIDs();</span>
<span class="nc" id="L111">    }</span>

    /**
     * Constructs a ComponentSampleModel with the specified parameters.
     * The number of bands will be given by the length of the bandOffsets array.
     * All bands will be stored in the first bank of the DataBuffer.
     * @param dataType  the data type for storing samples
     * @param w         the width (in pixels) of the region of
     *     image data described
     * @param h         the height (in pixels) of the region of
     *     image data described
     * @param pixelStride the pixel stride of the region of image
     *     data described
     * @param scanlineStride the line stride of the region of image
     *     data described
     * @param bandOffsets the offsets of all bands
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     * @throws IllegalArgumentException if &lt;code&gt;pixelStride&lt;/code&gt;
     *         is less than 0
     * @throws IllegalArgumentException if &lt;code&gt;scanlineStride&lt;/code&gt;
     *         is less than 0
     * @throws IllegalArgumentException if &lt;code&gt;numBands&lt;/code&gt;
     *         is less than 1
     * @throws IllegalArgumentException if the product of &lt;code&gt;w&lt;/code&gt;
     *         and &lt;code&gt;h&lt;/code&gt; is greater than
     *         &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types
     */
    public ComponentSampleModel(int dataType,
                                int w, int h,
                                int pixelStride,
                                int scanlineStride,
                                int bandOffsets[]) {
<span class="nc" id="L146">        super(dataType, w, h, bandOffsets.length);</span>
<span class="nc" id="L147">        this.dataType = dataType;</span>
<span class="nc" id="L148">        this.pixelStride = pixelStride;</span>
<span class="nc" id="L149">        this.scanlineStride  = scanlineStride;</span>
<span class="nc" id="L150">        this.bandOffsets = (int[])bandOffsets.clone();</span>
<span class="nc" id="L151">        numBands = this.bandOffsets.length;</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (pixelStride &lt; 0) {</span>
<span class="nc" id="L153">            throw new IllegalArgumentException(&quot;Pixel stride must be &gt;= 0&quot;);</span>
        }
        // TODO - bug 4296691 - remove this check
<span class="nc bnc" id="L156" title="All 2 branches missed.">        if (scanlineStride &lt; 0) {</span>
<span class="nc" id="L157">            throw new IllegalArgumentException(&quot;Scanline stride must be &gt;= 0&quot;);</span>
        }
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (numBands &lt; 1) {</span>
<span class="nc" id="L160">            throw new IllegalArgumentException(&quot;Must have at least one band.&quot;);</span>
        }
<span class="nc bnc" id="L162" title="All 4 branches missed.">        if ((dataType &lt; DataBuffer.TYPE_BYTE) ||</span>
            (dataType &gt; DataBuffer.TYPE_DOUBLE)) {
<span class="nc" id="L164">            throw new IllegalArgumentException(&quot;Unsupported dataType.&quot;);</span>
        }
<span class="nc" id="L166">        bankIndices = new int[numBands];</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        for (int i=0; i&lt;numBands; i++) {</span>
<span class="nc" id="L168">            bankIndices[i] = 0;</span>
        }
<span class="nc" id="L170">        verify();</span>
<span class="nc" id="L171">    }</span>


    /**
     * Constructs a ComponentSampleModel with the specified parameters.
     * The number of bands will be given by the length of the bandOffsets array.
     * Different bands may be stored in different banks of the DataBuffer.
     *
     * @param dataType  the data type for storing samples
     * @param w         the width (in pixels) of the region of
     *     image data described
     * @param h         the height (in pixels) of the region of
     *     image data described
     * @param pixelStride the pixel stride of the region of image
     *     data described
     * @param scanlineStride The line stride of the region of image
     *     data described
     * @param bankIndices the bank indices of all bands
     * @param bandOffsets the band offsets of all bands
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     * @throws IllegalArgumentException if &lt;code&gt;pixelStride&lt;/code&gt;
     *         is less than 0
     * @throws IllegalArgumentException if &lt;code&gt;scanlineStride&lt;/code&gt;
     *         is less than 0
     * @throws IllegalArgumentException if the length of
     *         &lt;code&gt;bankIndices&lt;/code&gt; does not equal the length of
     *         &lt;code&gt;bankOffsets&lt;/code&gt;
     * @throws IllegalArgumentException if any of the bank indices
     *         of &lt;code&gt;bandIndices&lt;/code&gt; is less than 0
     * @throws IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is not
     *         one of the supported data types
     */
    public ComponentSampleModel(int dataType,
                                int w, int h,
                                int pixelStride,
                                int scanlineStride,
                                int bankIndices[],
                                int bandOffsets[]) {
<span class="nc" id="L210">        super(dataType, w, h, bandOffsets.length);</span>
<span class="nc" id="L211">        this.dataType = dataType;</span>
<span class="nc" id="L212">        this.pixelStride = pixelStride;</span>
<span class="nc" id="L213">        this.scanlineStride  = scanlineStride;</span>
<span class="nc" id="L214">        this.bandOffsets = (int[])bandOffsets.clone();</span>
<span class="nc" id="L215">        this.bankIndices = (int[]) bankIndices.clone();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (pixelStride &lt; 0) {</span>
<span class="nc" id="L217">            throw new IllegalArgumentException(&quot;Pixel stride must be &gt;= 0&quot;);</span>
        }
        // TODO - bug 4296691 - remove this check
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (scanlineStride &lt; 0) {</span>
<span class="nc" id="L221">            throw new IllegalArgumentException(&quot;Scanline stride must be &gt;= 0&quot;);</span>
        }
<span class="nc bnc" id="L223" title="All 4 branches missed.">        if ((dataType &lt; DataBuffer.TYPE_BYTE) ||</span>
            (dataType &gt; DataBuffer.TYPE_DOUBLE)) {
<span class="nc" id="L225">            throw new IllegalArgumentException(&quot;Unsupported dataType.&quot;);</span>
        }
<span class="nc" id="L227">        int maxBank = this.bankIndices[0];</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (maxBank &lt; 0) {</span>
<span class="nc" id="L229">            throw new IllegalArgumentException(&quot;Index of bank 0 is less than &quot;+</span>
                                               &quot;0 (&quot;+maxBank+&quot;)&quot;);
        }
<span class="nc bnc" id="L232" title="All 2 branches missed.">        for (int i=1; i &lt; this.bankIndices.length; i++) {</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">            if (this.bankIndices[i] &gt; maxBank) {</span>
<span class="nc" id="L234">                maxBank = this.bankIndices[i];</span>
            }
<span class="nc bnc" id="L236" title="All 2 branches missed.">            else if (this.bankIndices[i] &lt; 0) {</span>
<span class="nc" id="L237">                throw new IllegalArgumentException(&quot;Index of bank &quot;+i+</span>
                                                   &quot; is less than 0 (&quot;+
                                                   maxBank+&quot;)&quot;);
            }
        }
<span class="nc" id="L242">        numBanks         = maxBank+1;</span>
<span class="nc" id="L243">        numBands         = this.bandOffsets.length;</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (this.bandOffsets.length != this.bankIndices.length) {</span>
<span class="nc" id="L245">            throw new IllegalArgumentException(&quot;Length of bandOffsets must &quot;+</span>
                                               &quot;equal length of bankIndices.&quot;);
        }
<span class="nc" id="L248">        verify();</span>
<span class="nc" id="L249">    }</span>

    private void verify() {
<span class="nc" id="L252">        int requiredSize = getBufferSize();</span>
<span class="nc" id="L253">    }</span>

    /**
     * Returns the size of the data buffer (in data elements) needed
     * for a data buffer that matches this ComponentSampleModel.
     */
     private int getBufferSize() {
<span class="nc" id="L260">         int maxBandOff=bandOffsets[0];</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">         for (int i=1; i&lt;bandOffsets.length; i++) {</span>
<span class="nc" id="L262">             maxBandOff = Math.max(maxBandOff,bandOffsets[i]);</span>
         }

<span class="nc bnc" id="L265" title="All 4 branches missed.">         if (maxBandOff &lt; 0 || maxBandOff &gt; (Integer.MAX_VALUE - 1)) {</span>
<span class="nc" id="L266">             throw new IllegalArgumentException(&quot;Invalid band offset&quot;);</span>
         }

<span class="nc bnc" id="L269" title="All 4 branches missed.">         if (pixelStride &lt; 0 || pixelStride &gt; (Integer.MAX_VALUE / width)) {</span>
<span class="nc" id="L270">             throw new IllegalArgumentException(&quot;Invalid pixel stride&quot;);</span>
         }

<span class="nc bnc" id="L273" title="All 4 branches missed.">         if (scanlineStride &lt; 0 || scanlineStride &gt; (Integer.MAX_VALUE / height)) {</span>
<span class="nc" id="L274">             throw new IllegalArgumentException(&quot;Invalid scanline stride&quot;);</span>
         }

<span class="nc" id="L277">         int size = maxBandOff + 1;</span>

<span class="nc" id="L279">         int val = pixelStride * (width - 1);</span>

<span class="nc bnc" id="L281" title="All 2 branches missed.">         if (val &gt; (Integer.MAX_VALUE - size)) {</span>
<span class="nc" id="L282">             throw new IllegalArgumentException(&quot;Invalid pixel stride&quot;);</span>
         }

<span class="nc" id="L285">         size += val;</span>

<span class="nc" id="L287">         val = scanlineStride * (height - 1);</span>

<span class="nc bnc" id="L289" title="All 2 branches missed.">         if (val &gt; (Integer.MAX_VALUE - size)) {</span>
<span class="nc" id="L290">             throw new IllegalArgumentException(&quot;Invalid scan stride&quot;);</span>
         }

<span class="nc" id="L293">         size += val;</span>

<span class="nc" id="L295">         return size;</span>
     }

     /**
      * Preserves band ordering with new step factor...
      */
    int []orderBands(int orig[], int step) {
<span class="nc" id="L302">        int map[] = new int[orig.length];</span>
<span class="nc" id="L303">        int ret[] = new int[orig.length];</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">        for (int i=0; i&lt;map.length; i++) map[i] = i;</span>

<span class="nc bnc" id="L307" title="All 2 branches missed.">        for (int i = 0; i &lt; ret.length; i++) {</span>
<span class="nc" id="L308">            int index = i;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">            for (int j = i+1; j &lt; ret.length; j++) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">                if (orig[map[index]] &gt; orig[map[j]]) {</span>
<span class="nc" id="L311">                    index = j;</span>
                }
            }
<span class="nc" id="L314">            ret[map[index]] = i*step;</span>
<span class="nc" id="L315">            map[index]  = map[i];</span>
        }
<span class="nc" id="L317">        return ret;</span>
    }

    /**
     * Creates a new &lt;code&gt;ComponentSampleModel&lt;/code&gt; with the specified
     * width and height.  The new &lt;code&gt;SampleModel&lt;/code&gt; will have the same
     * number of bands, storage data type, interleaving scheme, and
     * pixel stride as this &lt;code&gt;SampleModel&lt;/code&gt;.
     * @param w the width of the resulting &lt;code&gt;SampleModel&lt;/code&gt;
     * @param h the height of the resulting &lt;code&gt;SampleModel&lt;/code&gt;
     * @return a new &lt;code&gt;ComponentSampleModel&lt;/code&gt; with the specified size
     * @throws IllegalArgumentException if &lt;code&gt;w&lt;/code&gt; or
     *         &lt;code&gt;h&lt;/code&gt; is not greater than 0
     */
    public SampleModel createCompatibleSampleModel(int w, int h) {
<span class="nc" id="L332">        SampleModel ret=null;</span>
        long size;
<span class="nc" id="L334">        int minBandOff=bandOffsets[0];</span>
<span class="nc" id="L335">        int maxBandOff=bandOffsets[0];</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        for (int i=1; i&lt;bandOffsets.length; i++) {</span>
<span class="nc" id="L337">            minBandOff = Math.min(minBandOff,bandOffsets[i]);</span>
<span class="nc" id="L338">            maxBandOff = Math.max(maxBandOff,bandOffsets[i]);</span>
        }
<span class="nc" id="L340">        maxBandOff -= minBandOff;</span>

<span class="nc" id="L342">        int bands   = bandOffsets.length;</span>
        int bandOff[];
<span class="nc" id="L344">        int pStride = Math.abs(pixelStride);</span>
<span class="nc" id="L345">        int lStride = Math.abs(scanlineStride);</span>
<span class="nc" id="L346">        int bStride = Math.abs(maxBandOff);</span>

<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (pStride &gt; lStride) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">            if (pStride &gt; bStride) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                if (lStride &gt; bStride) { // pix &gt; line &gt; band</span>
<span class="nc" id="L351">                    bandOff = new int[bandOffsets.length];</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">                    for (int i=0; i&lt;bands; i++)</span>
<span class="nc" id="L353">                        bandOff[i] = bandOffsets[i]-minBandOff;</span>
<span class="nc" id="L354">                    lStride = bStride+1;</span>
<span class="nc" id="L355">                    pStride = lStride*h;</span>
                } else { // pix &gt; band &gt; line
<span class="nc" id="L357">                    bandOff = orderBands(bandOffsets,lStride*h);</span>
<span class="nc" id="L358">                    pStride = bands*lStride*h;</span>
                }
            } else { // band &gt; pix &gt; line
<span class="nc" id="L361">                pStride = lStride*h;</span>
<span class="nc" id="L362">                bandOff = orderBands(bandOffsets,pStride*w);</span>
            }
        } else {
<span class="nc bnc" id="L365" title="All 2 branches missed.">            if (pStride &gt; bStride) { // line &gt; pix &gt; band</span>
<span class="nc" id="L366">                bandOff = new int[bandOffsets.length];</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">                for (int i=0; i&lt;bands; i++)</span>
<span class="nc" id="L368">                    bandOff[i] = bandOffsets[i]-minBandOff;</span>
<span class="nc" id="L369">                pStride = bStride+1;</span>
<span class="nc" id="L370">                lStride = pStride*w;</span>
            } else {
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if (lStride &gt; bStride) { // line &gt; band &gt; pix</span>
<span class="nc" id="L373">                    bandOff = orderBands(bandOffsets,pStride*w);</span>
<span class="nc" id="L374">                    lStride = bands*pStride*w;</span>
                } else { // band &gt; line &gt; pix
<span class="nc" id="L376">                    lStride = pStride*w;</span>
<span class="nc" id="L377">                    bandOff = orderBands(bandOffsets,lStride*h);</span>
                }
            }
        }

        // make sure we make room for negative offsets...
<span class="nc" id="L383">        int base = 0;</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">        if (scanlineStride &lt; 0) {</span>
<span class="nc" id="L385">            base += lStride*h;</span>
<span class="nc" id="L386">            lStride *= -1;</span>
        }
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (pixelStride    &lt; 0) {</span>
<span class="nc" id="L389">            base += pStride*w;</span>
<span class="nc" id="L390">            pStride *= -1;</span>
        }

<span class="nc bnc" id="L393" title="All 2 branches missed.">        for (int i=0; i&lt;bands; i++)</span>
<span class="nc" id="L394">            bandOff[i] += base;</span>
<span class="nc" id="L395">        return new ComponentSampleModel(dataType, w, h, pStride,</span>
                                        lStride, bankIndices, bandOff);
    }

    /**
     * Creates a new ComponentSampleModel with a subset of the bands
     * of this ComponentSampleModel.  The new ComponentSampleModel can be
     * used with any DataBuffer that the existing ComponentSampleModel
     * can be used with.  The new ComponentSampleModel/DataBuffer
     * combination will represent an image with a subset of the bands
     * of the original ComponentSampleModel/DataBuffer combination.
     * @param bands a subset of bands from this
     *              &lt;code&gt;ComponentSampleModel&lt;/code&gt;
     * @return a &lt;code&gt;ComponentSampleModel&lt;/code&gt; created with a subset
     *          of bands from this &lt;code&gt;ComponentSampleModel&lt;/code&gt;.
     */
    public SampleModel createSubsetSampleModel(int bands[]) {
<span class="nc bnc" id="L412" title="All 2 branches missed.">       if (bands.length &gt; bankIndices.length)</span>
<span class="nc" id="L413">            throw new RasterFormatException(&quot;There are only &quot; +</span>
                                            bankIndices.length +
                                            &quot; bands&quot;);
<span class="nc" id="L416">        int newBankIndices[] = new int[bands.length];</span>
<span class="nc" id="L417">        int newBandOffsets[] = new int[bands.length];</span>

<span class="nc bnc" id="L419" title="All 2 branches missed.">        for (int i=0; i&lt;bands.length; i++) {</span>
<span class="nc" id="L420">            newBankIndices[i] = bankIndices[bands[i]];</span>
<span class="nc" id="L421">            newBandOffsets[i] = bandOffsets[bands[i]];</span>
        }

<span class="nc" id="L424">        return new ComponentSampleModel(this.dataType, width, height,</span>
                                        this.pixelStride,
                                        this.scanlineStride,
                                        newBankIndices, newBandOffsets);
    }

    /**
     * Creates a &lt;code&gt;DataBuffer&lt;/code&gt; that corresponds to this
     * &lt;code&gt;ComponentSampleModel&lt;/code&gt;.
     * The &lt;code&gt;DataBuffer&lt;/code&gt; object's data type, number of banks,
     * and size are be consistent with this &lt;code&gt;ComponentSampleModel&lt;/code&gt;.
     * @return a &lt;code&gt;DataBuffer&lt;/code&gt; whose data type, number of banks
     *         and size are consistent with this
     *         &lt;code&gt;ComponentSampleModel&lt;/code&gt;.
     */
    public DataBuffer createDataBuffer() {
<span class="nc" id="L440">        DataBuffer dataBuffer = null;</span>

<span class="nc" id="L442">        int size = getBufferSize();</span>
<span class="nc bnc" id="L443" title="All 7 branches missed.">        switch (dataType) {</span>
        case DataBuffer.TYPE_BYTE:
<span class="nc" id="L445">            dataBuffer = new DataBufferByte(size, numBanks);</span>
<span class="nc" id="L446">            break;</span>
        case DataBuffer.TYPE_USHORT:
<span class="nc" id="L448">            dataBuffer = new DataBufferUShort(size, numBanks);</span>
<span class="nc" id="L449">            break;</span>
        case DataBuffer.TYPE_SHORT:
<span class="nc" id="L451">            dataBuffer = new DataBufferShort(size, numBanks);</span>
<span class="nc" id="L452">            break;</span>
        case DataBuffer.TYPE_INT:
<span class="nc" id="L454">            dataBuffer = new DataBufferInt(size, numBanks);</span>
<span class="nc" id="L455">            break;</span>
        case DataBuffer.TYPE_FLOAT:
<span class="nc" id="L457">            dataBuffer = new DataBufferFloat(size, numBanks);</span>
<span class="nc" id="L458">            break;</span>
        case DataBuffer.TYPE_DOUBLE:
<span class="nc" id="L460">            dataBuffer = new DataBufferDouble(size, numBanks);</span>
            break;
        }

<span class="nc" id="L464">        return dataBuffer;</span>
    }


    /** Gets the offset for the first band of pixel (x,y).
     *  A sample of the first band can be retrieved from a
     * &lt;code&gt;DataBuffer&lt;/code&gt;
     *  &lt;code&gt;data&lt;/code&gt; with a &lt;code&gt;ComponentSampleModel&lt;/code&gt;
     * &lt;code&gt;csm&lt;/code&gt; as
     * &lt;pre&gt;
     *        data.getElem(csm.getOffset(x, y));
     * &lt;/pre&gt;
     * @param x the X location of the pixel
     * @param y the Y location of the pixel
     * @return the offset for the first band of the specified pixel.
     */
    public int getOffset(int x, int y) {
<span class="nc" id="L481">        int offset = y*scanlineStride + x*pixelStride + bandOffsets[0];</span>
<span class="nc" id="L482">        return offset;</span>
    }

    /** Gets the offset for band b of pixel (x,y).
     *  A sample of band &lt;code&gt;b&lt;/code&gt; can be retrieved from a
     *  &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;data&lt;/code&gt;
     *  with a &lt;code&gt;ComponentSampleModel&lt;/code&gt; &lt;code&gt;csm&lt;/code&gt; as
     * &lt;pre&gt;
     *       data.getElem(csm.getOffset(x, y, b));
     * &lt;/pre&gt;
     * @param x the X location of the specified pixel
     * @param y the Y location of the specified pixel
     * @param b the specified band
     * @return the offset for the specified band of the specified pixel.
     */
    public int getOffset(int x, int y, int b) {
<span class="nc" id="L498">        int offset = y*scanlineStride + x*pixelStride + bandOffsets[b];</span>
<span class="nc" id="L499">        return offset;</span>
    }

    /** Returns the number of bits per sample for all bands.
     *  @return an array containing the number of bits per sample
     *          for all bands, where each element in the array
     *          represents a band.
     */
    public final int[] getSampleSize() {
<span class="nc" id="L508">        int sampleSize[] = new int [numBands];</span>
<span class="nc" id="L509">        int sizeInBits = getSampleSize(0);</span>

<span class="nc bnc" id="L511" title="All 2 branches missed.">        for (int i=0; i&lt;numBands; i++)</span>
<span class="nc" id="L512">            sampleSize[i] = sizeInBits;</span>

<span class="nc" id="L514">        return sampleSize;</span>
    }

    /** Returns the number of bits per sample for the specified band.
     *  @param band the specified band
     *  @return the number of bits per sample for the specified band.
     */
    public final int getSampleSize(int band) {
<span class="nc" id="L522">        return DataBuffer.getDataTypeSize(dataType);</span>
    }

    /** Returns the bank indices for all bands.
     *  @return the bank indices for all bands.
     */
    public final int [] getBankIndices() {
<span class="nc" id="L529">        return (int[]) bankIndices.clone();</span>
    }

    /** Returns the band offset for all bands.
     *  @return the band offsets for all bands.
     */
    public final int [] getBandOffsets() {
<span class="nc" id="L536">        return (int[])bandOffsets.clone();</span>
    }

    /** Returns the scanline stride of this ComponentSampleModel.
     *  @return the scanline stride of this &lt;code&gt;ComponentSampleModel&lt;/code&gt;.
     */
    public final int getScanlineStride() {
<span class="nc" id="L543">        return scanlineStride;</span>
    }

    /** Returns the pixel stride of this ComponentSampleModel.
     *  @return the pixel stride of this &lt;code&gt;ComponentSampleModel&lt;/code&gt;.
     */
    public final int getPixelStride() {
<span class="nc" id="L550">        return pixelStride;</span>
    }

    /**
     * Returns the number of data elements needed to transfer a pixel
     * with the
     * {@link #getDataElements(int, int, Object, DataBuffer) } and
     * {@link #setDataElements(int, int, Object, DataBuffer) }
     * methods.
     * For a &lt;code&gt;ComponentSampleModel&lt;/code&gt;, this is identical to the
     * number of bands.
     * @return the number of data elements needed to transfer a pixel with
     *         the &lt;code&gt;getDataElements&lt;/code&gt; and
     *         &lt;code&gt;setDataElements&lt;/code&gt; methods.
     * @see java.awt.image.SampleModel#getNumDataElements
     * @see #getNumBands
     */
    public final int getNumDataElements() {
<span class="nc" id="L568">        return getNumBands();</span>
    }

    /**
     * Returns data for a single pixel in a primitive array of type
     * &lt;code&gt;TransferType&lt;/code&gt;.  For a &lt;code&gt;ComponentSampleModel&lt;/code&gt;,
     * this is the same as the data type, and samples are returned
     * one per array element.  Generally, &lt;code&gt;obj&lt;/code&gt; should
     * be passed in as &lt;code&gt;null&lt;/code&gt;, so that the &lt;code&gt;Object&lt;/code&gt;
     * is created automatically and is the right primitive data type.
     * &lt;p&gt;
     * The following code illustrates transferring data for one pixel from
     * &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db1&lt;/code&gt;, whose storage layout is
     * described by &lt;code&gt;ComponentSampleModel&lt;/code&gt; &lt;code&gt;csm1&lt;/code&gt;,
     * to &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db2&lt;/code&gt;, whose storage layout
     * is described by &lt;code&gt;ComponentSampleModel&lt;/code&gt; &lt;code&gt;csm2&lt;/code&gt;.
     * The transfer is usually more efficient than using
     * &lt;code&gt;getPixel&lt;/code&gt; and &lt;code&gt;setPixel&lt;/code&gt;.
     * &lt;pre&gt;
     *       ComponentSampleModel csm1, csm2;
     *       DataBufferInt db1, db2;
     *       csm2.setDataElements(x, y,
     *                            csm1.getDataElements(x, y, null, db1), db2);
     * &lt;/pre&gt;
     *
     * Using &lt;code&gt;getDataElements&lt;/code&gt; and &lt;code&gt;setDataElements&lt;/code&gt;
     * to transfer between two &lt;code&gt;DataBuffer/SampleModel&lt;/code&gt;
     * pairs is legitimate if the &lt;code&gt;SampleModel&lt;/code&gt; objects have
     * the same number of bands, corresponding bands have the same number of
     * bits per sample, and the &lt;code&gt;TransferType&lt;/code&gt;s are the same.
     * &lt;p&gt;
     * If &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it should be a
     * primitive array of type &lt;code&gt;TransferType&lt;/code&gt;.
     * Otherwise, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if the
     * coordinates are not in bounds, or if &lt;code&gt;obj&lt;/code&gt; is not
     * &lt;code&gt;null&lt;/code&gt; and is not large enough to hold
     * the pixel data.
     *
     * @param x         the X coordinate of the pixel location
     * @param y         the Y coordinate of the pixel location
     * @param obj       if non-&lt;code&gt;null&lt;/code&gt;, a primitive array
     *                  in which to return the pixel data
     * @param data      the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image data
     * @return the data of the specified pixel
     * @see #setDataElements(int, int, Object, DataBuffer)
     *
     * @throws NullPointerException if data is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates are
     * not in bounds, or if obj is too small to hold the output.
     */
    public Object getDataElements(int x, int y, Object obj, DataBuffer data) {
<span class="nc bnc" id="L620" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L621">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L625">        int type = getTransferType();</span>
<span class="nc" id="L626">        int numDataElems = getNumDataElements();</span>
<span class="nc" id="L627">        int pixelOffset = y*scanlineStride + x*pixelStride;</span>

<span class="nc bnc" id="L629" title="All 6 branches missed.">        switch(type) {</span>

        case DataBuffer.TYPE_BYTE:

            byte[] bdata;

<span class="nc bnc" id="L635" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L636">                bdata = new byte[numDataElems];</span>
            else
<span class="nc" id="L638">                bdata = (byte[])obj;</span>

<span class="nc bnc" id="L640" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L641">                bdata[i] = (byte)data.getElem(bankIndices[i],</span>
                                              pixelOffset + bandOffsets[i]);
            }

<span class="nc" id="L645">            obj = (Object)bdata;</span>
<span class="nc" id="L646">            break;</span>

        case DataBuffer.TYPE_USHORT:
        case DataBuffer.TYPE_SHORT:

            short[] sdata;

<span class="nc bnc" id="L653" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L654">                sdata = new short[numDataElems];</span>
            else
<span class="nc" id="L656">                sdata = (short[])obj;</span>

<span class="nc bnc" id="L658" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L659">                sdata[i] = (short)data.getElem(bankIndices[i],</span>
                                               pixelOffset + bandOffsets[i]);
            }

<span class="nc" id="L663">            obj = (Object)sdata;</span>
<span class="nc" id="L664">            break;</span>

        case DataBuffer.TYPE_INT:

            int[] idata;

<span class="nc bnc" id="L670" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L671">                idata = new int[numDataElems];</span>
            else
<span class="nc" id="L673">                idata = (int[])obj;</span>

<span class="nc bnc" id="L675" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L676">                idata[i] = data.getElem(bankIndices[i],</span>
                                        pixelOffset + bandOffsets[i]);
            }

<span class="nc" id="L680">            obj = (Object)idata;</span>
<span class="nc" id="L681">            break;</span>

        case DataBuffer.TYPE_FLOAT:

            float[] fdata;

<span class="nc bnc" id="L687" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L688">                fdata = new float[numDataElems];</span>
            else
<span class="nc" id="L690">                fdata = (float[])obj;</span>

<span class="nc bnc" id="L692" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L693">                fdata[i] = data.getElemFloat(bankIndices[i],</span>
                                             pixelOffset + bandOffsets[i]);
            }

<span class="nc" id="L697">            obj = (Object)fdata;</span>
<span class="nc" id="L698">            break;</span>

        case DataBuffer.TYPE_DOUBLE:

            double[] ddata;

<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (obj == null)</span>
<span class="nc" id="L705">                ddata = new double[numDataElems];</span>
            else
<span class="nc" id="L707">                ddata = (double[])obj;</span>

<span class="nc bnc" id="L709" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L710">                ddata[i] = data.getElemDouble(bankIndices[i],</span>
                                              pixelOffset + bandOffsets[i]);
            }

<span class="nc" id="L714">            obj = (Object)ddata;</span>
            break;
        }

<span class="nc" id="L718">        return obj;</span>
    }

    /**
     * Returns all samples for the specified pixel in an int array,
     * one sample per array element.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if
     * the coordinates are not in bounds.
     * @param x         the X coordinate of the pixel location
     * @param y         the Y coordinate of the pixel location
     * @param iArray    If non-null, returns the samples in this array
     * @param data      The DataBuffer containing the image data
     * @return the samples of the specified pixel.
     * @see #setPixel(int, int, int[], DataBuffer)
     *
     * @throws NullPointerException if data is null.
     * @throws ArrayIndexOutOfBoundsException if the coordinates are
     * not in bounds, or if iArray is too small to hold the output.
     */
    public int[] getPixel(int x, int y, int iArray[], DataBuffer data) {
<span class="nc bnc" id="L738" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L739">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int pixels[];
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L744">           pixels = iArray;</span>
        } else {
<span class="nc" id="L746">           pixels = new int [numBands];</span>
        }
<span class="nc" id="L748">        int pixelOffset = y*scanlineStride + x*pixelStride;</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">        for (int i=0; i&lt;numBands; i++) {</span>
<span class="nc" id="L750">            pixels[i] = data.getElem(bankIndices[i],</span>
                                     pixelOffset + bandOffsets[i]);
        }
<span class="nc" id="L753">        return pixels;</span>
    }

    /**
     * Returns all samples for the specified rectangle of pixels in
     * an int array, one sample per array element.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if
     * the coordinates are not in bounds.
     * @param x         The X coordinate of the upper left pixel location
     * @param y         The Y coordinate of the upper left pixel location
     * @param w         The width of the pixel rectangle
     * @param h         The height of the pixel rectangle
     * @param iArray    If non-null, returns the samples in this array
     * @param data      The DataBuffer containing the image data
     * @return the samples of the pixels within the specified region.
     * @see #setPixels(int, int, int, int, int[], DataBuffer)
     */
    public int[] getPixels(int x, int y, int w, int h,
                           int iArray[], DataBuffer data) {
<span class="nc" id="L772">        int x1 = x + w;</span>
<span class="nc" id="L773">        int y1 = y + h;</span>

<span class="nc bnc" id="L775" title="All 20 branches missed.">        if (x &lt; 0 || x &gt;= width || w &gt; width || x1 &lt; 0 || x1 &gt; width ||</span>
            y &lt; 0 || y &gt;= height || y &gt; height || y1 &lt; 0 || y1 &gt;  height)
        {
<span class="nc" id="L778">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int pixels[];
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L783">           pixels = iArray;</span>
        } else {
<span class="nc" id="L785">           pixels = new int [w*h*numBands];</span>
        }
<span class="nc" id="L787">        int lineOffset = y*scanlineStride + x*pixelStride;</span>
<span class="nc" id="L788">        int srcOffset = 0;</span>

<span class="nc bnc" id="L790" title="All 2 branches missed.">        for (int i = 0; i &lt; h; i++) {</span>
<span class="nc" id="L791">           int pixelOffset = lineOffset;</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">           for (int j = 0; j &lt; w; j++) {</span>
<span class="nc bnc" id="L793" title="All 2 branches missed.">              for (int k=0; k &lt; numBands; k++) {</span>
<span class="nc" id="L794">                 pixels[srcOffset++] =</span>
<span class="nc" id="L795">                    data.getElem(bankIndices[k], pixelOffset + bandOffsets[k]);</span>
              }
<span class="nc" id="L797">              pixelOffset += pixelStride;</span>
           }
<span class="nc" id="L799">           lineOffset += scanlineStride;</span>
        }
<span class="nc" id="L801">        return pixels;</span>
    }

    /**
     * Returns as int the sample in a specified band for the pixel
     * located at (x,y).
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if
     * the coordinates are not in bounds.
     * @param x         the X coordinate of the pixel location
     * @param y         the Y coordinate of the pixel location
     * @param b         the band to return
     * @param data      the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image data
     * @return the sample in a specified band for the specified pixel
     * @see #setSample(int, int, int, int, DataBuffer)
     */
    public int getSample(int x, int y, int b, DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L818" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L819">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L822">        int sample = data.getElem(bankIndices[b],</span>
                                  y*scanlineStride + x*pixelStride +
                                  bandOffsets[b]);
<span class="nc" id="L825">        return sample;</span>
    }

    /**
     * Returns the sample in a specified band
     * for the pixel located at (x,y) as a float.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be
     * thrown if the coordinates are not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         The band to return
     * @param data      The DataBuffer containing the image data
     * @return a float value representing the sample in the specified
     * band for the specified pixel.
     */
    public float getSampleFloat(int x, int y, int b, DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L842" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L843">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L847">        float sample = data.getElemFloat(bankIndices[b],</span>
                                         y*scanlineStride + x*pixelStride +
                                         bandOffsets[b]);
<span class="nc" id="L850">        return sample;</span>
    }

    /**
     * Returns the sample in a specified band
     * for a pixel located at (x,y) as a double.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be
     * thrown if the coordinates are not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         The band to return
     * @param data      The DataBuffer containing the image data
     * @return a double value representing the sample in the specified
     * band for the specified pixel.
     */
    public double getSampleDouble(int x, int y, int b, DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L867" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L868">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L872">        double sample = data.getElemDouble(bankIndices[b],</span>
                                           y*scanlineStride + x*pixelStride +
                                           bandOffsets[b]);
<span class="nc" id="L875">        return sample;</span>
    }

    /**
     * Returns the samples in a specified band for the specified rectangle
     * of pixels in an int array, one sample per data array element.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if
     * the coordinates are not in bounds.
     * @param x         The X coordinate of the upper left pixel location
     * @param y         The Y coordinate of the upper left pixel location
     * @param w         the width of the pixel rectangle
     * @param h         the height of the pixel rectangle
     * @param b         the band to return
     * @param iArray    if non-&lt;code&gt;null&lt;/code&gt;, returns the samples
     *                  in this array
     * @param data      the &lt;code&gt;DataBuffer&lt;/code&gt; containing the image data
     * @return the samples in the specified band of the specified pixel
     * @see #setSamples(int, int, int, int, int, int[], DataBuffer)
     */
    public int[] getSamples(int x, int y, int w, int h, int b,
                            int iArray[], DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L897" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x + w &gt; width) || (y + h &gt; height)) {</span>
<span class="nc" id="L898">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
        int samples[];
<span class="nc bnc" id="L902" title="All 2 branches missed.">        if (iArray != null) {</span>
<span class="nc" id="L903">           samples = iArray;</span>
        } else {
<span class="nc" id="L905">           samples = new int [w*h];</span>
        }
<span class="nc" id="L907">        int lineOffset = y*scanlineStride + x*pixelStride +  bandOffsets[b];</span>
<span class="nc" id="L908">        int srcOffset = 0;</span>

<span class="nc bnc" id="L910" title="All 2 branches missed.">        for (int i = 0; i &lt; h; i++) {</span>
<span class="nc" id="L911">           int sampleOffset = lineOffset;</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">           for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L913">              samples[srcOffset++] = data.getElem(bankIndices[b],</span>
                                                  sampleOffset);
<span class="nc" id="L915">              sampleOffset += pixelStride;</span>
           }
<span class="nc" id="L917">           lineOffset += scanlineStride;</span>
        }
<span class="nc" id="L919">        return samples;</span>
    }

    /**
     * Sets the data for a single pixel in the specified
     * &lt;code&gt;DataBuffer&lt;/code&gt; from a primitive array of type
     * &lt;code&gt;TransferType&lt;/code&gt;.  For a &lt;code&gt;ComponentSampleModel&lt;/code&gt;,
     * this is the same as the data type, and samples are transferred
     * one per array element.
     * &lt;p&gt;
     * The following code illustrates transferring data for one pixel from
     * &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db1&lt;/code&gt;, whose storage layout is
     * described by &lt;code&gt;ComponentSampleModel&lt;/code&gt; &lt;code&gt;csm1&lt;/code&gt;,
     * to &lt;code&gt;DataBuffer&lt;/code&gt; &lt;code&gt;db2&lt;/code&gt;, whose storage layout
     * is described by &lt;code&gt;ComponentSampleModel&lt;/code&gt; &lt;code&gt;csm2&lt;/code&gt;.
     * The transfer is usually more efficient than using
     * &lt;code&gt;getPixel&lt;/code&gt; and &lt;code&gt;setPixel&lt;/code&gt;.
     * &lt;pre&gt;
     *       ComponentSampleModel csm1, csm2;
     *       DataBufferInt db1, db2;
     *       csm2.setDataElements(x, y, csm1.getDataElements(x, y, null, db1),
     *                            db2);
     * &lt;/pre&gt;
     * Using &lt;code&gt;getDataElements&lt;/code&gt; and &lt;code&gt;setDataElements&lt;/code&gt;
     * to transfer between two &lt;code&gt;DataBuffer/SampleModel&lt;/code&gt; pairs
     * is legitimate if the &lt;code&gt;SampleModel&lt;/code&gt; objects have
     * the same number of bands, corresponding bands have the same number of
     * bits per sample, and the &lt;code&gt;TransferType&lt;/code&gt;s are the same.
     * &lt;p&gt;
     * A &lt;code&gt;ClassCastException&lt;/code&gt; is thrown if &lt;code&gt;obj&lt;/code&gt; is not
     * a primitive array of type &lt;code&gt;TransferType&lt;/code&gt;.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if
     * the coordinates are not in bounds, or if &lt;code&gt;obj&lt;/code&gt; is not large
     * enough to hold the pixel data.
     * @param x         the X coordinate of the pixel location
     * @param y         the Y coordinate of the pixel location
     * @param obj       a primitive array containing pixel data
     * @param data      the DataBuffer containing the image data
     * @see #getDataElements(int, int, Object, DataBuffer)
     */
    public void setDataElements(int x, int y, Object obj, DataBuffer data) {
<span class="nc bnc" id="L960" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L961">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L965">        int type = getTransferType();</span>
<span class="nc" id="L966">        int numDataElems = getNumDataElements();</span>
<span class="nc" id="L967">        int pixelOffset = y*scanlineStride + x*pixelStride;</span>

<span class="nc bnc" id="L969" title="All 6 branches missed.">        switch(type) {</span>

        case DataBuffer.TYPE_BYTE:

<span class="nc" id="L973">            byte[] barray = (byte[])obj;</span>

<span class="nc bnc" id="L975" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L976">                data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],</span>
                           ((int)barray[i])&amp;0xff);
            }
<span class="nc" id="L979">            break;</span>

        case DataBuffer.TYPE_USHORT:
        case DataBuffer.TYPE_SHORT:

<span class="nc" id="L984">            short[] sarray = (short[])obj;</span>

<span class="nc bnc" id="L986" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L987">                data.setElem(bankIndices[i], pixelOffset + bandOffsets[i],</span>
                           ((int)sarray[i])&amp;0xffff);
            }
<span class="nc" id="L990">            break;</span>

        case DataBuffer.TYPE_INT:

<span class="nc" id="L994">            int[] iarray = (int[])obj;</span>

<span class="nc bnc" id="L996" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L997">                data.setElem(bankIndices[i],</span>
                             pixelOffset + bandOffsets[i], iarray[i]);
            }
<span class="nc" id="L1000">            break;</span>

        case DataBuffer.TYPE_FLOAT:

<span class="nc" id="L1004">            float[] farray = (float[])obj;</span>

<span class="nc bnc" id="L1006" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L1007">                data.setElemFloat(bankIndices[i],</span>
                             pixelOffset + bandOffsets[i], farray[i]);
            }
<span class="nc" id="L1010">            break;</span>

        case DataBuffer.TYPE_DOUBLE:

<span class="nc" id="L1014">            double[] darray = (double[])obj;</span>

<span class="nc bnc" id="L1016" title="All 2 branches missed.">            for (int i=0; i&lt;numDataElems; i++) {</span>
<span class="nc" id="L1017">                data.setElemDouble(bankIndices[i],</span>
                             pixelOffset + bandOffsets[i], darray[i]);
            }
            break;

        }
<span class="nc" id="L1023">    }</span>

    /**
     * Sets a pixel in the &lt;code&gt;DataBuffer&lt;/code&gt; using an int array of
     * samples for input.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;
     * might be thrown if the coordinates are
     * not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param iArray    The input samples in an int array
     * @param data      The DataBuffer containing the image data
     * @see #getPixel(int, int, int[], DataBuffer)
     */
    public void setPixel(int x, int y, int iArray[], DataBuffer data) {
<span class="nc bnc" id="L1037" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L1038">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L1041">       int pixelOffset = y*scanlineStride + x*pixelStride;</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">       for (int i=0; i&lt;numBands; i++) {</span>
<span class="nc" id="L1043">           data.setElem(bankIndices[i],</span>
                        pixelOffset + bandOffsets[i],iArray[i]);
       }
<span class="nc" id="L1046">    }</span>

    /**
     * Sets all samples for a rectangle of pixels from an int array containing
     * one sample per array element.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if the
     * coordinates are not in bounds.
     * @param x         The X coordinate of the upper left pixel location
     * @param y         The Y coordinate of the upper left pixel location
     * @param w         The width of the pixel rectangle
     * @param h         The height of the pixel rectangle
     * @param iArray    The input samples in an int array
     * @param data      The DataBuffer containing the image data
     * @see #getPixels(int, int, int, int, int[], DataBuffer)
     */
    public void setPixels(int x, int y, int w, int h,
                          int iArray[], DataBuffer data) {
<span class="nc" id="L1063">        int x1 = x + w;</span>
<span class="nc" id="L1064">        int y1 = y + h;</span>

<span class="nc bnc" id="L1066" title="All 20 branches missed.">        if (x &lt; 0 || x &gt;= width || w &gt; width || x1 &lt; 0 || x1 &gt; width ||</span>
            y &lt; 0 || y &gt;= height || h &gt; height || y1 &lt; 0 || y1 &gt;  height)
        {
<span class="nc" id="L1069">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }

<span class="nc" id="L1073">        int lineOffset = y*scanlineStride + x*pixelStride;</span>
<span class="nc" id="L1074">        int srcOffset = 0;</span>

<span class="nc bnc" id="L1076" title="All 2 branches missed.">        for (int i = 0; i &lt; h; i++) {</span>
<span class="nc" id="L1077">           int pixelOffset = lineOffset;</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">           for (int j = 0; j &lt; w; j++) {</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">              for (int k=0; k &lt; numBands; k++) {</span>
<span class="nc" id="L1080">                 data.setElem(bankIndices[k], pixelOffset + bandOffsets[k],</span>
                              iArray[srcOffset++]);
              }
<span class="nc" id="L1083">              pixelOffset += pixelStride;</span>
           }
<span class="nc" id="L1085">           lineOffset += scanlineStride;</span>
        }
<span class="nc" id="L1087">    }</span>

    /**
     * Sets a sample in the specified band for the pixel located at (x,y)
     * in the &lt;code&gt;DataBuffer&lt;/code&gt; using an int for input.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if the
     * coordinates are not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         the band to set
     * @param s         the input sample as an int
     * @param data      the DataBuffer containing the image data
     * @see #getSample(int, int, int, DataBuffer)
     */
    public void setSample(int x, int y, int b, int s,
                          DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L1104" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L1105">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L1108">        data.setElem(bankIndices[b],</span>
                     y*scanlineStride + x*pixelStride + bandOffsets[b], s);
<span class="nc" id="L1110">    }</span>

    /**
     * Sets a sample in the specified band for the pixel located at (x,y)
     * in the &lt;code&gt;DataBuffer&lt;/code&gt; using a float for input.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if
     * the coordinates are not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         The band to set
     * @param s         The input sample as a float
     * @param data      The DataBuffer containing the image data
     * @see #getSample(int, int, int, DataBuffer)
     */
    public void setSample(int x, int y, int b,
                          float s ,
                          DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L1128" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L1129">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L1132">        data.setElemFloat(bankIndices[b],</span>
                          y*scanlineStride + x*pixelStride + bandOffsets[b],
                          s);
<span class="nc" id="L1135">    }</span>

    /**
     * Sets a sample in the specified band for the pixel located at (x,y)
     * in the &lt;code&gt;DataBuffer&lt;/code&gt; using a double for input.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if
     * the coordinates are not in bounds.
     * @param x         The X coordinate of the pixel location
     * @param y         The Y coordinate of the pixel location
     * @param b         The band to set
     * @param s         The input sample as a double
     * @param data      The DataBuffer containing the image data
     * @see #getSample(int, int, int, DataBuffer)
     */
    public void setSample(int x, int y, int b,
                          double s,
                          DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L1153" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x &gt;= width) || (y &gt;= height)) {</span>
<span class="nc" id="L1154">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L1157">        data.setElemDouble(bankIndices[b],</span>
                          y*scanlineStride + x*pixelStride + bandOffsets[b],
                          s);
<span class="nc" id="L1160">    }</span>

    /**
     * Sets the samples in the specified band for the specified rectangle
     * of pixels from an int array containing one sample per data array element.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; might be thrown if the
     * coordinates are not in bounds.
     * @param x         The X coordinate of the upper left pixel location
     * @param y         The Y coordinate of the upper left pixel location
     * @param w         The width of the pixel rectangle
     * @param h         The height of the pixel rectangle
     * @param b         The band to set
     * @param iArray    The input samples in an int array
     * @param data      The DataBuffer containing the image data
     * @see #getSamples(int, int, int, int, int, int[], DataBuffer)
     */
    public void setSamples(int x, int y, int w, int h, int b,
                           int iArray[], DataBuffer data) {
        // Bounds check for 'b' will be performed automatically
<span class="nc bnc" id="L1179" title="All 8 branches missed.">        if ((x &lt; 0) || (y &lt; 0) || (x + w &gt; width) || (y + h &gt; height)) {</span>
<span class="nc" id="L1180">            throw new ArrayIndexOutOfBoundsException</span>
                (&quot;Coordinate out of bounds!&quot;);
        }
<span class="nc" id="L1183">        int lineOffset = y*scanlineStride + x*pixelStride + bandOffsets[b];</span>
<span class="nc" id="L1184">        int srcOffset = 0;</span>

<span class="nc bnc" id="L1186" title="All 2 branches missed.">        for (int i = 0; i &lt; h; i++) {</span>
<span class="nc" id="L1187">           int sampleOffset = lineOffset;</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">           for (int j = 0; j &lt; w; j++) {</span>
<span class="nc" id="L1189">              data.setElem(bankIndices[b], sampleOffset, iArray[srcOffset++]);</span>
<span class="nc" id="L1190">              sampleOffset += pixelStride;</span>
           }
<span class="nc" id="L1192">           lineOffset += scanlineStride;</span>
        }
<span class="nc" id="L1194">    }</span>

    public boolean equals(Object o) {
<span class="nc bnc" id="L1197" title="All 4 branches missed.">        if ((o == null) || !(o instanceof ComponentSampleModel)) {</span>
<span class="nc" id="L1198">            return false;</span>
        }

<span class="nc" id="L1201">        ComponentSampleModel that = (ComponentSampleModel)o;</span>
<span class="nc bnc" id="L1202" title="All 8 branches missed.">        return this.width == that.width &amp;&amp;</span>
            this.height == that.height &amp;&amp;
            this.numBands == that.numBands &amp;&amp;
            this.dataType == that.dataType &amp;&amp;
<span class="nc bnc" id="L1206" title="All 2 branches missed.">            Arrays.equals(this.bandOffsets, that.bandOffsets) &amp;&amp;</span>
<span class="nc bnc" id="L1207" title="All 10 branches missed.">            Arrays.equals(this.bankIndices, that.bankIndices) &amp;&amp;</span>
            this.numBands == that.numBands &amp;&amp;
            this.numBanks == that.numBanks &amp;&amp;
            this.scanlineStride == that.scanlineStride &amp;&amp;
            this.pixelStride == that.pixelStride;
    }

    // If we implement equals() we must also implement hashCode
    public int hashCode() {
<span class="nc" id="L1216">        int hash = 0;</span>
<span class="nc" id="L1217">        hash = width;</span>
<span class="nc" id="L1218">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L1219">        hash ^= height;</span>
<span class="nc" id="L1220">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L1221">        hash ^= numBands;</span>
<span class="nc" id="L1222">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L1223">        hash ^= dataType;</span>
<span class="nc" id="L1224">        hash &lt;&lt;= 8;</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">        for (int i = 0; i &lt; bandOffsets.length; i++) {</span>
<span class="nc" id="L1226">            hash ^= bandOffsets[i];</span>
<span class="nc" id="L1227">            hash &lt;&lt;= 8;</span>
        }
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        for (int i = 0; i &lt; bankIndices.length; i++) {</span>
<span class="nc" id="L1230">            hash ^= bankIndices[i];</span>
<span class="nc" id="L1231">            hash &lt;&lt;= 8;</span>
        }
<span class="nc" id="L1233">        hash ^= numBands;</span>
<span class="nc" id="L1234">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L1235">        hash ^= numBanks;</span>
<span class="nc" id="L1236">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L1237">        hash ^= scanlineStride;</span>
<span class="nc" id="L1238">        hash &lt;&lt;= 8;</span>
<span class="nc" id="L1239">        hash ^= pixelStride;</span>
<span class="nc" id="L1240">        return hash;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>