<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ColorModel.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">java.awt.image</a> &gt; <span class="el_source">ColorModel.java</span></div><h1>ColorModel.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1995, 2006, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package java.awt.image;

import java.awt.Transparency;
import java.awt.color.ColorSpace;
import java.awt.color.ICC_ColorSpace;
import sun.java2d.cmm.CMSManager;
import sun.java2d.cmm.ColorTransform;
import sun.java2d.cmm.PCMM;
import java.awt.Toolkit;
import java.util.Collections;
import java.util.Map;
import java.util.WeakHashMap;

/**
 * The &lt;code&gt;ColorModel&lt;/code&gt; abstract class encapsulates the
 * methods for translating a pixel value to color components
 * (for example, red, green, and blue) and an alpha component.
 * In order to render an image to the screen, a printer, or another
 * image, pixel values must be converted to color and alpha components.
 * As arguments to or return values from methods of this class,
 * pixels are represented as 32-bit ints or as arrays of primitive types.
 * The number, order, and interpretation of color components for a
 * &lt;code&gt;ColorModel&lt;/code&gt; is specified by its &lt;code&gt;ColorSpace&lt;/code&gt;.
 * A &lt;code&gt;ColorModel&lt;/code&gt; used with pixel data that does not include
 * alpha information treats all pixels as opaque, which is an alpha
 * value of 1.0.
 * &lt;p&gt;
 * This &lt;code&gt;ColorModel&lt;/code&gt; class supports two representations of
 * pixel values.  A pixel value can be a single 32-bit int or an
 * array of primitive types.  The Java(tm) Platform 1.0 and 1.1 APIs
 * represented pixels as single &lt;code&gt;byte&lt;/code&gt; or single
 * &lt;code&gt;int&lt;/code&gt; values.  For purposes of the &lt;code&gt;ColorModel&lt;/code&gt;
 * class, pixel value arguments were passed as ints.  The Java(tm) 2
 * Platform API introduced additional classes for representing images.
 * With {@link BufferedImage} or {@link RenderedImage}
 * objects, based on {@link Raster} and {@link SampleModel} classes, pixel
 * values might not be conveniently representable as a single int.
 * Consequently, &lt;code&gt;ColorModel&lt;/code&gt; now has methods that accept
 * pixel values represented as arrays of primitive types.  The primitive
 * type used by a particular &lt;code&gt;ColorModel&lt;/code&gt; object is called its
 * transfer type.
 * &lt;p&gt;
 * &lt;code&gt;ColorModel&lt;/code&gt; objects used with images for which pixel values
 * are not conveniently representable as a single int throw an
 * {@link IllegalArgumentException} when methods taking a single int pixel
 * argument are called.  Subclasses of &lt;code&gt;ColorModel&lt;/code&gt; must
 * specify the conditions under which this occurs.  This does not
 * occur with {@link DirectColorModel} or {@link IndexColorModel} objects.
 * &lt;p&gt;
 * Currently, the transfer types supported by the Java 2D(tm) API are
 * DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT, DataBuffer.TYPE_INT,
 * DataBuffer.TYPE_SHORT, DataBuffer.TYPE_FLOAT, and DataBuffer.TYPE_DOUBLE.
 * Most rendering operations will perform much faster when using ColorModels
 * and images based on the first three of these types.  In addition, some
 * image filtering operations are not supported for ColorModels and
 * images based on the latter three types.
 * The transfer type for a particular &lt;code&gt;ColorModel&lt;/code&gt; object is
 * specified when the object is created, either explicitly or by default.
 * All subclasses of &lt;code&gt;ColorModel&lt;/code&gt; must specify what the
 * possible transfer types are and how the number of elements in the
 * primitive arrays representing pixels is determined.
 * &lt;p&gt;
 * For &lt;code&gt;BufferedImages&lt;/code&gt;, the transfer type of its
 * &lt;code&gt;Raster&lt;/code&gt; and of the &lt;code&gt;Raster&lt;/code&gt; object's
 * &lt;code&gt;SampleModel&lt;/code&gt; (available from the
 * &lt;code&gt;getTransferType&lt;/code&gt; methods of these classes) must match that
 * of the &lt;code&gt;ColorModel&lt;/code&gt;.  The number of elements in an array
 * representing a pixel for the &lt;code&gt;Raster&lt;/code&gt; and
 * &lt;code&gt;SampleModel&lt;/code&gt; (available from the
 * &lt;code&gt;getNumDataElements&lt;/code&gt; methods of these classes) must match
 * that of the &lt;code&gt;ColorModel&lt;/code&gt;.
 * &lt;p&gt;
 * The algorithm used to convert from pixel values to color and alpha
 * components varies by subclass.  For example, there is not necessarily
 * a one-to-one correspondence between samples obtained from the
 * &lt;code&gt;SampleModel&lt;/code&gt; of a &lt;code&gt;BufferedImage&lt;/code&gt; object's
 * &lt;code&gt;Raster&lt;/code&gt; and color/alpha components.  Even when
 * there is such a correspondence, the number of bits in a sample is not
 * necessarily the same as the number of bits in the corresponding color/alpha
 * component.  Each subclass must specify how the translation from
 * pixel values to color/alpha components is done.
 * &lt;p&gt;
 * Methods in the &lt;code&gt;ColorModel&lt;/code&gt; class use two different
 * representations of color and alpha components - a normalized form
 * and an unnormalized form.  In the normalized form, each component is a
 * &lt;code&gt;float&lt;/code&gt; value between some minimum and maximum values.  For
 * the alpha component, the minimum is 0.0 and the maximum is 1.0.  For
 * color components the minimum and maximum values for each component can
 * be obtained from the &lt;code&gt;ColorSpace&lt;/code&gt; object.  These values
 * will often be 0.0 and 1.0 (e.g. normalized component values for the
 * default sRGB color space range from 0.0 to 1.0), but some color spaces
 * have component values with different upper and lower limits.  These
 * limits can be obtained using the &lt;code&gt;getMinValue&lt;/code&gt; and
 * &lt;code&gt;getMaxValue&lt;/code&gt; methods of the &lt;code&gt;ColorSpace&lt;/code&gt;
 * class.  Normalized color component values are not premultiplied.
 * All &lt;code&gt;ColorModels&lt;/code&gt; must support the normalized form.
 * &lt;p&gt;
 * In the unnormalized
 * form, each component is an unsigned integral value between 0 and
 * 2&lt;sup&gt;n&lt;/sup&gt; - 1, where n is the number of significant bits for a
 * particular component.  If pixel values for a particular
 * &lt;code&gt;ColorModel&lt;/code&gt; represent color samples premultiplied by
 * the alpha sample, unnormalized color component values are
 * also premultiplied.  The unnormalized form is used only with instances
 * of &lt;code&gt;ColorModel&lt;/code&gt; whose &lt;code&gt;ColorSpace&lt;/code&gt; has minimum
 * component values of 0.0 for all components and maximum values of
 * 1.0 for all components.
 * The unnormalized form for color and alpha components can be a convenient
 * representation for &lt;code&gt;ColorModels&lt;/code&gt; whose normalized component
 * values all lie
 * between 0.0 and 1.0.  In such cases the integral value 0 maps to 0.0 and
 * the value 2&lt;sup&gt;n&lt;/sup&gt; - 1 maps to 1.0.  In other cases, such as
 * when the normalized component values can be either negative or positive,
 * the unnormalized form is not convenient.  Such &lt;code&gt;ColorModel&lt;/code&gt;
 * objects throw an {@link IllegalArgumentException} when methods involving
 * an unnormalized argument are called.  Subclasses of &lt;code&gt;ColorModel&lt;/code&gt;
 * must specify the conditions under which this occurs.
 *
 * @see IndexColorModel
 * @see ComponentColorModel
 * @see PackedColorModel
 * @see DirectColorModel
 * @see java.awt.Image
 * @see BufferedImage
 * @see RenderedImage
 * @see java.awt.color.ColorSpace
 * @see SampleModel
 * @see Raster
 * @see DataBuffer
 */
public abstract class ColorModel implements Transparency{
    private long pData;         // Placeholder for data for native functions

    /**
     * The total number of bits in the pixel.
     */
    protected int pixel_bits;
    int nBits[];
<span class="nc" id="L164">    int transparency = Transparency.TRANSLUCENT;</span>
<span class="nc" id="L165">    boolean supportsAlpha = true;</span>
<span class="nc" id="L166">    boolean isAlphaPremultiplied = false;</span>
<span class="nc" id="L167">    int numComponents = -1;</span>
<span class="nc" id="L168">    int numColorComponents = -1;</span>
<span class="nc" id="L169">    ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>
<span class="nc" id="L170">    int colorSpaceType = ColorSpace.TYPE_RGB;</span>
    int maxBits;
<span class="nc" id="L172">    boolean is_sRGB = true;</span>

    /**
     * Data type of the array used to represent pixel values.
     */
    protected int transferType;

    /**
     * This is copied from java.awt.Toolkit since we need the library
     * loaded in java.awt.image also:
     *
     * WARNING: This is a temporary workaround for a problem in the
     * way the AWT loads native libraries. A number of classes in the
     * AWT package have a native method, initIDs(), which initializes
     * the JNI field and method ids used in the native portion of
     * their implementation.
     *
     * Since the use and storage of these ids is done by the
     * implementation libraries, the implementation of these method is
     * provided by the particular AWT implementations (for example,
     * &quot;Toolkit&quot;s/Peer), such as Motif, Microsoft Windows, or Tiny. The
     * problem is that this means that the native libraries must be
     * loaded by the java.* classes, which do not necessarily know the
     * names of the libraries to load. A better way of doing this
     * would be to provide a separate library which defines java.awt.*
     * initIDs, and exports the relevant symbols out to the
     * implementation libraries.
     *
     * For now, we know it's done by the implementation, and we assume
     * that the name of the library is &quot;awt&quot;.  -br.
     */
<span class="nc" id="L203">    private static boolean loaded = false;</span>
    static void loadLibraries() {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (!loaded) {</span>
<span class="nc" id="L206">            java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L207">                new java.security.PrivilegedAction&lt;Void&gt;() {</span>
                    public Void run() {
<span class="nc" id="L209">                        System.loadLibrary(&quot;awt&quot;);</span>
<span class="nc" id="L210">                        return null;</span>
                    }
                });
<span class="nc" id="L213">            loaded = true;</span>
        }
<span class="nc" id="L215">    }</span>
    private static native void initIDs();
    static {
        /* ensure that the proper libraries are loaded */
<span class="nc" id="L219">        loadLibraries();</span>
<span class="nc" id="L220">        initIDs();</span>
    }
    private static ColorModel RGBdefault;

    /**
     * Returns a &lt;code&gt;DirectColorModel&lt;/code&gt; that describes the default
     * format for integer RGB values used in many of the methods in the
     * AWT image interfaces for the convenience of the programmer.
     * The color space is the default {@link ColorSpace}, sRGB.
     * The format for the RGB values is an integer with 8 bits
     * each of alpha, red, green, and blue color components ordered
     * correspondingly from the most significant byte to the least
     * significant byte, as in:  0xAARRGGBB.  Color components are
     * not premultiplied by the alpha component.  This format does not
     * necessarily represent the native or the most efficient
     * &lt;code&gt;ColorModel&lt;/code&gt; for a particular device or for all images.
     * It is merely used as a common color model format.
     * @return a &lt;code&gt;DirectColorModel&lt;/code&gt;object describing default
     *          RGB values.
     */
    public static ColorModel getRGBdefault() {
<span class="nc bnc" id="L241" title="All 2 branches missed.">        if (RGBdefault == null) {</span>
<span class="nc" id="L242">            RGBdefault = new DirectColorModel(32,</span>
                                              0x00ff0000,       // Red
                                              0x0000ff00,       // Green
                                              0x000000ff,       // Blue
                                              0xff000000        // Alpha
                                              );
        }
<span class="nc" id="L249">        return RGBdefault;</span>
    }

    /**
     * Constructs a &lt;code&gt;ColorModel&lt;/code&gt; that translates pixels of the
     * specified number of bits to color/alpha components.  The color
     * space is the default RGB &lt;code&gt;ColorSpace&lt;/code&gt;, which is sRGB.
     * Pixel values are assumed to include alpha information.  If color
     * and alpha information are represented in the pixel value as
     * separate spatial bands, the color bands are assumed not to be
     * premultiplied with the alpha value. The transparency type is
     * java.awt.Transparency.TRANSLUCENT.  The transfer type will be the
     * smallest of DataBuffer.TYPE_BYTE, DataBuffer.TYPE_USHORT,
     * or DataBuffer.TYPE_INT that can hold a single pixel
     * (or DataBuffer.TYPE_UNDEFINED if bits is greater
     * than 32).  Since this constructor has no information about the
     * number of bits per color and alpha component, any subclass calling
     * this constructor should override any method that requires this
     * information.
     * @param bits the number of bits of a pixel
     * @throws IllegalArgumentException if the number
     *          of bits in &lt;code&gt;bits&lt;/code&gt; is less than 1
     */
<span class="nc" id="L272">    public ColorModel(int bits) {</span>
<span class="nc" id="L273">        pixel_bits = bits;</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (bits &lt; 1) {</span>
<span class="nc" id="L275">            throw new IllegalArgumentException(&quot;Number of bits must be &gt; 0&quot;);</span>
        }
<span class="nc" id="L277">        numComponents = 4;</span>
<span class="nc" id="L278">        numColorComponents = 3;</span>
<span class="nc" id="L279">        maxBits = bits;</span>
        // REMIND: make sure transferType is set correctly
<span class="nc" id="L281">        transferType = ColorModel.getDefaultTransferType(bits);</span>
<span class="nc" id="L282">    }</span>

    /**
     * Constructs a &lt;code&gt;ColorModel&lt;/code&gt; that translates pixel values
     * to color/alpha components.  Color components will be in the
     * specified &lt;code&gt;ColorSpace&lt;/code&gt;. &lt;code&gt;pixel_bits&lt;/code&gt; is the
     * number of bits in the pixel values.  The bits array
     * specifies the number of significant bits per color and alpha component.
     * Its length should be the number of components in the
     * &lt;code&gt;ColorSpace&lt;/code&gt; if there is no alpha information in the
     * pixel values, or one more than this number if there is alpha
     * information.  &lt;code&gt;hasAlpha&lt;/code&gt; indicates whether or not alpha
     * information is present.  The &lt;code&gt;boolean&lt;/code&gt;
     * &lt;code&gt;isAlphaPremultiplied&lt;/code&gt; specifies how to interpret pixel
     * values in which color and alpha information are represented as
     * separate spatial bands.  If the &lt;code&gt;boolean&lt;/code&gt;
     * is &lt;code&gt;true&lt;/code&gt;, color samples are assumed to have been
     * multiplied by the alpha sample.  The &lt;code&gt;transparency&lt;/code&gt;
     * specifies what alpha values can be represented by this color model.
     * The transfer type is the type of primitive array used to represent
     * pixel values.  Note that the bits array contains the number of
     * significant bits per color/alpha component after the translation
     * from pixel values.  For example, for an
     * &lt;code&gt;IndexColorModel&lt;/code&gt; with &lt;code&gt;pixel_bits&lt;/code&gt; equal to
     * 16, the bits array might have four elements with each element set
     * to 8.
     * @param pixel_bits the number of bits in the pixel values
     * @param bits array that specifies the number of significant bits
     *          per color and alpha component
     * @param cspace the specified &lt;code&gt;ColorSpace&lt;/code&gt;
     * @param hasAlpha &lt;code&gt;true&lt;/code&gt; if alpha information is present;
     *          &lt;code&gt;false&lt;/code&gt; otherwise
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if color samples are
     *          assumed to be premultiplied by the alpha samples;
     *          &lt;code&gt;false&lt;/code&gt; otherwise
     * @param transparency what alpha values can be represented by this
     *          color model
     * @param transferType the type of the array used to represent pixel
     *          values
     * @throws IllegalArgumentException if the length of
     *          the bit array is less than the number of color or alpha
     *          components in this &lt;code&gt;ColorModel&lt;/code&gt;, or if the
     *          transparency is not a valid value.
     * @throws IllegalArgumentException if the sum of the number
     *          of bits in &lt;code&gt;bits&lt;/code&gt; is less than 1 or if
     *          any of the elements in &lt;code&gt;bits&lt;/code&gt; is less than 0.
     * @see java.awt.Transparency
     */
    protected ColorModel(int pixel_bits, int[] bits, ColorSpace cspace,
                         boolean hasAlpha,
                         boolean isAlphaPremultiplied,
                         int transparency,
<span class="nc" id="L334">                         int transferType) {</span>
<span class="nc" id="L335">        colorSpace                = cspace;</span>
<span class="nc" id="L336">        colorSpaceType            = cspace.getType();</span>
<span class="nc" id="L337">        numColorComponents        = cspace.getNumComponents();</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        numComponents             = numColorComponents + (hasAlpha ? 1 : 0);</span>
<span class="nc" id="L339">        supportsAlpha             = hasAlpha;</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (bits.length &lt; numComponents) {</span>
<span class="nc" id="L341">            throw new IllegalArgumentException(&quot;Number of color/alpha &quot;+</span>
                                               &quot;components should be &quot;+
                                               numComponents+
                                               &quot; but length of bits array is &quot;+
                                               bits.length);
        }

        // 4186669
<span class="nc bnc" id="L349" title="All 4 branches missed.">        if (transparency &lt; Transparency.OPAQUE ||</span>
            transparency &gt; Transparency.TRANSLUCENT)
        {
<span class="nc" id="L352">            throw new IllegalArgumentException(&quot;Unknown transparency: &quot;+</span>
                                               transparency);
        }

<span class="nc bnc" id="L356" title="All 2 branches missed.">        if (supportsAlpha == false) {</span>
<span class="nc" id="L357">            this.isAlphaPremultiplied = false;</span>
<span class="nc" id="L358">            this.transparency = Transparency.OPAQUE;</span>
        }
        else {
<span class="nc" id="L361">            this.isAlphaPremultiplied = isAlphaPremultiplied;</span>
<span class="nc" id="L362">            this.transparency         = transparency;</span>
        }

<span class="nc" id="L365">        nBits = bits.clone();</span>
<span class="nc" id="L366">        this.pixel_bits = pixel_bits;</span>
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (pixel_bits &lt;= 0) {</span>
<span class="nc" id="L368">            throw new IllegalArgumentException(&quot;Number of pixel bits must &quot;+</span>
                                               &quot;be &gt; 0&quot;);
        }
        // Check for bits &lt; 0
<span class="nc" id="L372">        maxBits = 0;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">        for (int i=0; i &lt; bits.length; i++) {</span>
            // bug 4304697
<span class="nc bnc" id="L375" title="All 2 branches missed.">            if (bits[i] &lt; 0) {</span>
<span class="nc" id="L376">                throw new</span>
                    IllegalArgumentException(&quot;Number of bits must be &gt;= 0&quot;);
            }
<span class="nc bnc" id="L379" title="All 2 branches missed.">            if (maxBits &lt; bits[i]) {</span>
<span class="nc" id="L380">                maxBits = bits[i];</span>
            }
        }

        // Make sure that we don't have all 0-bit components
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (maxBits == 0) {</span>
<span class="nc" id="L386">            throw new IllegalArgumentException(&quot;There must be at least &quot;+</span>
                                               &quot;one component with &gt; 0 &quot;+
                                              &quot;pixel bits.&quot;);
        }

        // Save this since we always need to check if it is the default CS
<span class="nc bnc" id="L392" title="All 2 branches missed.">        if (cspace != ColorSpace.getInstance(ColorSpace.CS_sRGB)) {</span>
<span class="nc" id="L393">            is_sRGB = false;</span>
        }

        // Save the transfer type
<span class="nc" id="L397">        this.transferType = transferType;</span>
<span class="nc" id="L398">    }</span>

    /**
     * Returns whether or not alpha is supported in this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if alpha is supported in this
     * &lt;code&gt;ColorModel&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    final public boolean hasAlpha() {
<span class="nc" id="L407">        return supportsAlpha;</span>
    }

    /**
     * Returns whether or not the alpha has been premultiplied in the
     * pixel values to be translated by this &lt;code&gt;ColorModel&lt;/code&gt;.
     * If the boolean is &lt;code&gt;true&lt;/code&gt;, this &lt;code&gt;ColorModel&lt;/code&gt;
     * is to be used to interpret pixel values in which color and alpha
     * information are represented as separate spatial bands, and color
     * samples are assumed to have been multiplied by the
     * alpha sample.
     * @return &lt;code&gt;true&lt;/code&gt; if the alpha values are premultiplied
     *          in the pixel values to be translated by this
     *          &lt;code&gt;ColorModel&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    final public boolean isAlphaPremultiplied() {
<span class="nc" id="L423">        return isAlphaPremultiplied;</span>
    }

    /**
     * Returns the transfer type of this &lt;code&gt;ColorModel&lt;/code&gt;.
     * The transfer type is the type of primitive array used to represent
     * pixel values as arrays.
     * @return the transfer type.
     * @since 1.3
     */
    final public int getTransferType() {
<span class="nc" id="L434">        return transferType;</span>
    }

    /**
     * Returns the number of bits per pixel described by this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * @return the number of bits per pixel.
     */
    public int getPixelSize() {
<span class="nc" id="L443">        return pixel_bits;</span>
    }

    /**
     * Returns the number of bits for the specified color/alpha component.
     * Color components are indexed in the order specified by the
     * &lt;code&gt;ColorSpace&lt;/code&gt;.  Typically, this order reflects the name
     * of the color space type. For example, for TYPE_RGB, index 0
     * corresponds to red, index 1 to green, and index 2
     * to blue.  If this &lt;code&gt;ColorModel&lt;/code&gt; supports alpha, the alpha
     * component corresponds to the index following the last color
     * component.
     * @param componentIdx the index of the color/alpha component
     * @return the number of bits for the color/alpha component at the
     *          specified index.
     * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;componentIdx&lt;/code&gt;
     *         is greater than the number of components or
     *         less than zero
     * @throws NullPointerException if the number of bits array is
     *         &lt;code&gt;null&lt;/code&gt;
     */
    public int getComponentSize(int componentIdx) {
        // REMIND:
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (nBits == null) {</span>
<span class="nc" id="L467">            throw new NullPointerException(&quot;Number of bits array is null.&quot;);</span>
        }

<span class="nc" id="L470">        return nBits[componentIdx];</span>
    }

    /**
     * Returns an array of the number of bits per color/alpha component.
     * The array contains the color components in the order specified by the
     * &lt;code&gt;ColorSpace&lt;/code&gt;, followed by the alpha component, if
     * present.
     * @return an array of the number of bits per color/alpha component
     */
    public int[] getComponentSize() {
<span class="nc bnc" id="L481" title="All 2 branches missed.">        if (nBits != null) {</span>
<span class="nc" id="L482">            return nBits.clone();</span>
        }

<span class="nc" id="L485">        return null;</span>
    }

    /**
     * Returns the transparency.  Returns either OPAQUE, BITMASK,
     * or TRANSLUCENT.
     * @return the transparency of this &lt;code&gt;ColorModel&lt;/code&gt;.
     * @see Transparency#OPAQUE
     * @see Transparency#BITMASK
     * @see Transparency#TRANSLUCENT
     */
    public int getTransparency() {
<span class="nc" id="L497">        return transparency;</span>
    }

    /**
     * Returns the number of components, including alpha, in this
     * &lt;code&gt;ColorModel&lt;/code&gt;.  This is equal to the number of color
     * components, optionally plus one, if there is an alpha component.
     * @return the number of components in this &lt;code&gt;ColorModel&lt;/code&gt;
     */
    public int getNumComponents() {
<span class="nc" id="L507">        return numComponents;</span>
    }

    /**
     * Returns the number of color components in this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * This is the number of components returned by
     * {@link ColorSpace#getNumComponents}.
     * @return the number of color components in this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * @see ColorSpace#getNumComponents
     */
    public int getNumColorComponents() {
<span class="nc" id="L520">        return numColorComponents;</span>
    }

    /**
     * Returns the red color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion
     * is done if necessary.  The pixel value is specified as an int.
     * An &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if pixel
     * values for this &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently
     * representable as a single int.  The returned value is not a
     * pre-multiplied value.  For example, if the
     * alpha is premultiplied, this method divides it out before returning
     * the value.  If the alpha value is 0, the red value is 0.
     * @param pixel a specified pixel
     * @return the value of the red component of the specified pixel.
     */
    public abstract int getRed(int pixel);

    /**
     * Returns the green color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion
     * is done if necessary.  The pixel value is specified as an int.
     * An &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if pixel
     * values for this &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently
     * representable as a single int.  The returned value is a non
     * pre-multiplied value.  For example, if the alpha is premultiplied,
     * this method divides it out before returning
     * the value.  If the alpha value is 0, the green value is 0.
     * @param pixel the specified pixel
     * @return the value of the green component of the specified pixel.
     */
    public abstract int getGreen(int pixel);

    /**
     * Returns the blue color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB ColorSpace, sRGB.  A color conversion
     * is done if necessary.  The pixel value is specified as an int.
     * An &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if pixel values
     * for this &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently representable
     * as a single int.  The returned value is a non pre-multiplied
     * value, for example, if the alpha is premultiplied, this method
     * divides it out before returning the value.  If the alpha value is
     * 0, the blue value is 0.
     * @param pixel the specified pixel
     * @return the value of the blue component of the specified pixel.
     */
    public abstract int getBlue(int pixel);

    /**
     * Returns the alpha component for the specified pixel, scaled
     * from 0 to 255.  The pixel value is specified as an int.
     * An &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if pixel
     * values for this &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently
     * representable as a single int.
     * @param pixel the specified pixel
     * @return the value of alpha component of the specified pixel.
     */
    public abstract int getAlpha(int pixel);

    /**
     * Returns the color/alpha components of the pixel in the default
     * RGB color model format.  A color conversion is done if necessary.
     * The pixel value is specified as an int.
     * An &lt;code&gt;IllegalArgumentException&lt;/code&gt; thrown if pixel values
     * for this &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently representable
     * as a single int.  The returned value is in a non
     * pre-multiplied format. For example, if the alpha is premultiplied,
     * this method divides it out of the color components.  If the alpha
     * value is 0, the color values are 0.
     * @param pixel the specified pixel
     * @return the RGB value of the color/alpha components of the
     *          specified pixel.
     * @see ColorModel#getRGBdefault
     */
    public int getRGB(int pixel) {
<span class="nc" id="L595">        return (getAlpha(pixel) &lt;&lt; 24)</span>
<span class="nc" id="L596">            | (getRed(pixel) &lt;&lt; 16)</span>
<span class="nc" id="L597">            | (getGreen(pixel) &lt;&lt; 8)</span>
<span class="nc" id="L598">            | (getBlue(pixel) &lt;&lt; 0);</span>
    }

    /**
     * Returns the red color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;code&gt;ColorSpace&lt;/code&gt;, sRGB.  A
     * color conversion is done if necessary.  The pixel value is
     * specified by an array of data elements of type transferType passed
     * in as an object reference.  The returned value is a non
     * pre-multiplied value.  For example, if alpha is premultiplied,
     * this method divides it out before returning
     * the value.  If the alpha value is 0, the red value is 0.
     * If &lt;code&gt;inData&lt;/code&gt; is not a primitive array of type
     * transferType, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel value for
     * this &lt;code&gt;ColorModel&lt;/code&gt;.
     * If this &lt;code&gt;transferType&lt;/code&gt; is not supported, a
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be
     * thrown.  Since
     * &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class, any instance
     * must be an instance of a subclass.  Subclasses inherit the
     * implementation of this method and if they don't override it, this
     * method throws an exception if the subclass uses a
     * &lt;code&gt;transferType&lt;/code&gt; other than
     * &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     * &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;.
     * @param inData an array of pixel values
     * @return the value of the red component of the specified pixel.
     * @throws ClassCastException if &lt;code&gt;inData&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt;
     * @throws UnsupportedOperationException if this
     *  &lt;code&gt;tranferType&lt;/code&gt; is not supported by this
     *  &lt;code&gt;ColorModel&lt;/code&gt;
     */
    public int getRed(Object inData) {
<span class="nc" id="L638">        int pixel=0,length=0;</span>
<span class="nc bnc" id="L639" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L641">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L642">               pixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L643">               length = bdata.length;</span>
<span class="nc" id="L644">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L646">               short sdata[] = (short[])inData;</span>
<span class="nc" id="L647">               pixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L648">               length = sdata.length;</span>
<span class="nc" id="L649">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L651">               int idata[] = (int[])inData;</span>
<span class="nc" id="L652">               pixel = idata[0];</span>
<span class="nc" id="L653">               length = idata.length;</span>
<span class="nc" id="L654">            break;</span>
            default:
<span class="nc" id="L656">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (length == 1) {</span>
<span class="nc" id="L660">            return getRed(pixel);</span>
        }
        else {
<span class="nc" id="L663">            throw new UnsupportedOperationException</span>
                (&quot;This method is not supported by this color model&quot;);
        }
    }

    /**
     * Returns the green color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;code&gt;ColorSpace&lt;/code&gt;, sRGB.  A
     * color conversion is done if necessary.  The pixel value is
     * specified by an array of data elements of type transferType passed
     * in as an object reference.  The returned value will be a non
     * pre-multiplied value.  For example, if the alpha is premultiplied,
     * this method divides it out before returning the value.  If the
     * alpha value is 0, the green value is 0.  If &lt;code&gt;inData&lt;/code&gt; is
     * not a primitive array of type transferType, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel value for
     * this &lt;code&gt;ColorModel&lt;/code&gt;.
     * If this &lt;code&gt;transferType&lt;/code&gt; is not supported, a
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be
     * thrown.  Since
     * &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class, any instance
     * must be an instance of a subclass.  Subclasses inherit the
     * implementation of this method and if they don't override it, this
     * method throws an exception if the subclass uses a
     * &lt;code&gt;transferType&lt;/code&gt; other than
     * &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     * &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;.
     * @param inData an array of pixel values
     * @return the value of the green component of the specified pixel.
     * @throws ClassCastException if &lt;code&gt;inData&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt;
     * @throws UnsupportedOperationException if this
     *  &lt;code&gt;tranferType&lt;/code&gt; is not supported by this
     *  &lt;code&gt;ColorModel&lt;/code&gt;
     */
    public int getGreen(Object inData) {
<span class="nc" id="L705">        int pixel=0,length=0;</span>
<span class="nc bnc" id="L706" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L708">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L709">               pixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L710">               length = bdata.length;</span>
<span class="nc" id="L711">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L713">               short sdata[] = (short[])inData;</span>
<span class="nc" id="L714">               pixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L715">               length = sdata.length;</span>
<span class="nc" id="L716">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L718">               int idata[] = (int[])inData;</span>
<span class="nc" id="L719">               pixel = idata[0];</span>
<span class="nc" id="L720">               length = idata.length;</span>
<span class="nc" id="L721">            break;</span>
            default:
<span class="nc" id="L723">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc bnc" id="L726" title="All 2 branches missed.">        if (length == 1) {</span>
<span class="nc" id="L727">            return getGreen(pixel);</span>
        }
        else {
<span class="nc" id="L730">            throw new UnsupportedOperationException</span>
                (&quot;This method is not supported by this color model&quot;);
        }
    }

    /**
     * Returns the blue color component for the specified pixel, scaled
     * from 0 to 255 in the default RGB &lt;code&gt;ColorSpace&lt;/code&gt;, sRGB.  A
     * color conversion is done if necessary.  The pixel value is
     * specified by an array of data elements of type transferType passed
     * in as an object reference.  The returned value is a non
     * pre-multiplied value.  For example, if the alpha is premultiplied,
     * this method divides it out before returning the value.  If the
     * alpha value is 0, the blue value will be 0.  If
     * &lt;code&gt;inData&lt;/code&gt; is not a primitive array of type transferType,
     * a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel
     * value for this &lt;code&gt;ColorModel&lt;/code&gt;.
     * If this &lt;code&gt;transferType&lt;/code&gt; is not supported, a
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be
     * thrown.  Since
     * &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class, any instance
     * must be an instance of a subclass.  Subclasses inherit the
     * implementation of this method and if they don't override it, this
     * method throws an exception if the subclass uses a
     * &lt;code&gt;transferType&lt;/code&gt; other than
     * &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     * &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;.
     * @param inData an array of pixel values
     * @return the value of the blue component of the specified pixel.
     * @throws ClassCastException if &lt;code&gt;inData&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt;
     * @throws UnsupportedOperationException if this
     *  &lt;code&gt;tranferType&lt;/code&gt; is not supported by this
     *  &lt;code&gt;ColorModel&lt;/code&gt;
     */
    public int getBlue(Object inData) {
<span class="nc" id="L772">        int pixel=0,length=0;</span>
<span class="nc bnc" id="L773" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L775">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L776">               pixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L777">               length = bdata.length;</span>
<span class="nc" id="L778">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L780">               short sdata[] = (short[])inData;</span>
<span class="nc" id="L781">               pixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L782">               length = sdata.length;</span>
<span class="nc" id="L783">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L785">               int idata[] = (int[])inData;</span>
<span class="nc" id="L786">               pixel = idata[0];</span>
<span class="nc" id="L787">               length = idata.length;</span>
<span class="nc" id="L788">            break;</span>
            default:
<span class="nc" id="L790">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc bnc" id="L793" title="All 2 branches missed.">        if (length == 1) {</span>
<span class="nc" id="L794">            return getBlue(pixel);</span>
        }
        else {
<span class="nc" id="L797">            throw new UnsupportedOperationException</span>
                (&quot;This method is not supported by this color model&quot;);
        }
    }

    /**
     * Returns the alpha component for the specified pixel, scaled
     * from 0 to 255.  The pixel value is specified by an array of data
     * elements of type transferType passed in as an object reference.
     * If inData is not a primitive array of type transferType, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel value for
     * this &lt;code&gt;ColorModel&lt;/code&gt;.
     * If this &lt;code&gt;transferType&lt;/code&gt; is not supported, a
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be
     * thrown.  Since
     * &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class, any instance
     * must be an instance of a subclass.  Subclasses inherit the
     * implementation of this method and if they don't override it, this
     * method throws an exception if the subclass uses a
     * &lt;code&gt;transferType&lt;/code&gt; other than
     * &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     * &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;.
     * @param inData the specified pixel
     * @return the alpha component of the specified pixel, scaled from
     * 0 to 255.
     * @throws ClassCastException if &lt;code&gt;inData&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt;
     * @throws UnsupportedOperationException if this
     *  &lt;code&gt;tranferType&lt;/code&gt; is not supported by this
     *  &lt;code&gt;ColorModel&lt;/code&gt;
     */
    public int getAlpha(Object inData) {
<span class="nc" id="L835">        int pixel=0,length=0;</span>
<span class="nc bnc" id="L836" title="All 4 branches missed.">        switch (transferType) {</span>
            case DataBuffer.TYPE_BYTE:
<span class="nc" id="L838">               byte bdata[] = (byte[])inData;</span>
<span class="nc" id="L839">               pixel = bdata[0] &amp; 0xff;</span>
<span class="nc" id="L840">               length = bdata.length;</span>
<span class="nc" id="L841">            break;</span>
            case DataBuffer.TYPE_USHORT:
<span class="nc" id="L843">               short sdata[] = (short[])inData;</span>
<span class="nc" id="L844">               pixel = sdata[0] &amp; 0xffff;</span>
<span class="nc" id="L845">               length = sdata.length;</span>
<span class="nc" id="L846">            break;</span>
            case DataBuffer.TYPE_INT:
<span class="nc" id="L848">               int idata[] = (int[])inData;</span>
<span class="nc" id="L849">               pixel = idata[0];</span>
<span class="nc" id="L850">               length = idata.length;</span>
<span class="nc" id="L851">            break;</span>
            default:
<span class="nc" id="L853">               throw new UnsupportedOperationException(&quot;This method has not been &quot;+</span>
                   &quot;implemented for transferType &quot; + transferType);
        }
<span class="nc bnc" id="L856" title="All 2 branches missed.">        if (length == 1) {</span>
<span class="nc" id="L857">            return getAlpha(pixel);</span>
        }
        else {
<span class="nc" id="L860">            throw new UnsupportedOperationException</span>
                (&quot;This method is not supported by this color model&quot;);
        }
    }

    /**
     * Returns the color/alpha components for the specified pixel in the
     * default RGB color model format.  A color conversion is done if
     * necessary.  The pixel value is specified by an array of data
     * elements of type transferType passed in as an object reference.
     * If inData is not a primitive array of type transferType, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;inData&lt;/code&gt; is not large enough to hold a pixel
     * value for this &lt;code&gt;ColorModel&lt;/code&gt;.
     * The returned value will be in a non pre-multiplied format, i.e. if
     * the alpha is premultiplied, this method will divide it out of the
     * color components (if the alpha value is 0, the color values will be 0).
     * @param inData the specified pixel
     * @return the color and alpha components of the specified pixel.
     * @see ColorModel#getRGBdefault
     */
    public int getRGB(Object inData) {
<span class="nc" id="L883">        return (getAlpha(inData) &lt;&lt; 24)</span>
<span class="nc" id="L884">            | (getRed(inData) &lt;&lt; 16)</span>
<span class="nc" id="L885">            | (getGreen(inData) &lt;&lt; 8)</span>
<span class="nc" id="L886">            | (getBlue(inData) &lt;&lt; 0);</span>
    }

    /**
     * Returns a data element array representation of a pixel in this
     * &lt;code&gt;ColorModel&lt;/code&gt;, given an integer pixel representation in
     * the default RGB color model.
     * This array can then be passed to the
     * {@link WritableRaster#setDataElements} method of
     * a {@link WritableRaster} object.  If the pixel variable is
     * &lt;code&gt;null&lt;/code&gt;, a new array will be allocated.  If
     * &lt;code&gt;pixel&lt;/code&gt; is not
     * &lt;code&gt;null&lt;/code&gt;, it must be a primitive array of type
     * &lt;code&gt;transferType&lt;/code&gt;; otherwise, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * &lt;code&gt;pixel&lt;/code&gt; is
     * not large enough to hold a pixel value for this
     * &lt;code&gt;ColorModel&lt;/code&gt;. The pixel array is returned.
     * If this &lt;code&gt;transferType&lt;/code&gt; is not supported, a
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will be
     * thrown.  Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  Subclasses must
     * override this method since the implementation in this abstract
     * class throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     * @param rgb the integer pixel representation in the default RGB
     * color model
     * @param pixel the specified pixel
     * @return an array representation of the specified pixel in this
     *  &lt;code&gt;ColorModel&lt;/code&gt;.
     * @throws ClassCastException if &lt;code&gt;pixel&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt;
     * @throws UnsupportedOperationException if this
     *  method is not supported by this &lt;code&gt;ColorModel&lt;/code&gt;
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     */
    public Object getDataElements(int rgb, Object pixel) {
<span class="nc" id="L927">        throw new UnsupportedOperationException</span>
            (&quot;This method is not supported by this color model.&quot;);
    }

    /**
     * Returns an array of unnormalized color/alpha components given a pixel
     * in this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel value is specified as
     * an &lt;code&gt;int&lt;/code&gt;.  An &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * will be thrown if pixel values for this &lt;code&gt;ColorModel&lt;/code&gt; are
     * not conveniently representable as a single &lt;code&gt;int&lt;/code&gt; or if
     * color component values for this &lt;code&gt;ColorModel&lt;/code&gt; are not
     * conveniently representable in the unnormalized form.
     * For example, this method can be used to retrieve the
     * components for a specific pixel value in a
     * &lt;code&gt;DirectColorModel&lt;/code&gt;.  If the components array is
     * &lt;code&gt;null&lt;/code&gt;, a new array will be allocated.  The
     * components array will be returned.  Color/alpha components are
     * stored in the components array starting at &lt;code&gt;offset&lt;/code&gt;
     * (even if the array is allocated by this method).  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if  the
     * components array is not &lt;code&gt;null&lt;/code&gt; and is not large
     * enough to hold all the color and alpha components (starting at offset).
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  Subclasses must
     * override this method since the implementation in this abstract
     * class throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     * @param pixel the specified pixel
     * @param components the array to receive the color and alpha
     * components of the specified pixel
     * @param offset the offset into the &lt;code&gt;components&lt;/code&gt; array at
     * which to start storing the color and alpha components
     * @return an array containing the color and alpha components of the
     * specified pixel starting at the specified offset.
     * @throws UnsupportedOperationException if this
     *          method is not supported by this &lt;code&gt;ColorModel&lt;/code&gt;
     */
    public int[] getComponents(int pixel, int[] components, int offset) {
<span class="nc" id="L964">        throw new UnsupportedOperationException</span>
            (&quot;This method is not supported by this color model.&quot;);
    }

    /**
     * Returns an array of unnormalized color/alpha components given a pixel
     * in this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel value is specified by
     * an array of data elements of type transferType passed in as an
     * object reference.  If &lt;code&gt;pixel&lt;/code&gt; is not a primitive array
     * of type transferType, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.
     * An &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown if color
     * component values for this &lt;code&gt;ColorModel&lt;/code&gt; are not
     * conveniently representable in the unnormalized form.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is
     * thrown if &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel
     * value for this &lt;code&gt;ColorModel&lt;/code&gt;.
     * This method can be used to retrieve the components for a specific
     * pixel value in any &lt;code&gt;ColorModel&lt;/code&gt;.  If the components
     * array is &lt;code&gt;null&lt;/code&gt;, a new array will be allocated.  The
     * components array will be returned.  Color/alpha components are
     * stored in the &lt;code&gt;components&lt;/code&gt; array starting at
     * &lt;code&gt;offset&lt;/code&gt; (even if the array is allocated by this
     * method).  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt;
     * is thrown if  the components array is not &lt;code&gt;null&lt;/code&gt; and is
     * not large enough to hold all the color and alpha components
     * (starting at &lt;code&gt;offset&lt;/code&gt;).
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  Subclasses must
     * override this method since the implementation in this abstract
     * class throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     * @param pixel the specified pixel
     * @param components an array that receives the color and alpha
     * components of the specified pixel
     * @param offset the index into the &lt;code&gt;components&lt;/code&gt; array at
     * which to begin storing the color and alpha components of the
     * specified pixel
     * @return an array containing the color and alpha components of the
     * specified pixel starting at the specified offset.
     * @throws UnsupportedOperationException if this
     *          method is not supported by this &lt;code&gt;ColorModel&lt;/code&gt;
     */
    public int[] getComponents(Object pixel, int[] components, int offset) {
<span class="nc" id="L1006">        throw new UnsupportedOperationException</span>
            (&quot;This method is not supported by this color model.&quot;);
    }

    /**
     * Returns an array of all of the color/alpha components in unnormalized
     * form, given a normalized component array.  Unnormalized components
     * are unsigned integral values between 0 and 2&lt;sup&gt;n&lt;/sup&gt; - 1, where
     * n is the number of bits for a particular component.  Normalized
     * components are float values between a per component minimum and
     * maximum specified by the &lt;code&gt;ColorSpace&lt;/code&gt; object for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.  An &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * will be thrown if color component values for this
     * &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently representable in the
     * unnormalized form.  If the
     * &lt;code&gt;components&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;, a new array
     * will be allocated.  The &lt;code&gt;components&lt;/code&gt; array will
     * be returned.  Color/alpha components are stored in the
     * &lt;code&gt;components&lt;/code&gt; array starting at &lt;code&gt;offset&lt;/code&gt; (even
     * if the array is allocated by this method). An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if the
     * &lt;code&gt;components&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt; and is not
     * large enough to hold all the color and alpha
     * components (starting at &lt;code&gt;offset&lt;/code&gt;).  An
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if the
     * &lt;code&gt;normComponents&lt;/code&gt; array is not large enough to hold
     * all the color and alpha components starting at
     * &lt;code&gt;normOffset&lt;/code&gt;.
     * @param normComponents an array containing normalized components
     * @param normOffset the offset into the &lt;code&gt;normComponents&lt;/code&gt;
     * array at which to start retrieving normalized components
     * @param components an array that receives the components from
     * &lt;code&gt;normComponents&lt;/code&gt;
     * @param offset the index into &lt;code&gt;components&lt;/code&gt; at which to
     * begin storing normalized components from
     * &lt;code&gt;normComponents&lt;/code&gt;
     * @return an array containing unnormalized color and alpha
     * components.
     * @throws IllegalArgumentException If the component values for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; are not conveniently representable in the
     * unnormalized form.
     * @throws IllegalArgumentException if the length of
     *          &lt;code&gt;normComponents&lt;/code&gt; minus &lt;code&gt;normOffset&lt;/code&gt;
     *          is less than &lt;code&gt;numComponents&lt;/code&gt;
     * @throws UnsupportedOperationException if the
     *          constructor of this &lt;code&gt;ColorModel&lt;/code&gt; called the
     *          &lt;code&gt;super(bits)&lt;/code&gt; constructor, but did not
     *          override this method.  See the constructor,
     *          {@link #ColorModel(int)}.
     */
    public int[] getUnnormalizedComponents(float[] normComponents,
                                           int normOffset,
                                           int[] components, int offset) {
        // Make sure that someone isn't using a custom color model
        // that called the super(bits) constructor.
<span class="nc bnc" id="L1061" title="All 2 branches missed.">        if (colorSpace == null) {</span>
<span class="nc" id="L1062">            throw new UnsupportedOperationException(&quot;This method is not supported &quot;+</span>
                                        &quot;by this color model.&quot;);
        }

<span class="nc bnc" id="L1066" title="All 2 branches missed.">        if (nBits == null) {</span>
<span class="nc" id="L1067">            throw new UnsupportedOperationException (&quot;This method is not supported.  &quot;+</span>
                                         &quot;Unable to determine #bits per &quot;+
                                         &quot;component.&quot;);
        }
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        if ((normComponents.length - normOffset) &lt; numComponents) {</span>
<span class="nc" id="L1072">            throw new</span>
                IllegalArgumentException(
                        &quot;Incorrect number of components.  Expecting &quot;+
                        numComponents);
        }

<span class="nc bnc" id="L1078" title="All 2 branches missed.">        if (components == null) {</span>
<span class="nc" id="L1079">            components = new int[offset+numComponents];</span>
        }

<span class="nc bnc" id="L1082" title="All 4 branches missed.">        if (supportsAlpha &amp;&amp; isAlphaPremultiplied) {</span>
<span class="nc" id="L1083">            float normAlpha = normComponents[normOffset+numColorComponents];</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">            for (int i=0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1085">                components[offset+i] = (int) (normComponents[normOffset+i]</span>
                                              * ((1&lt;&lt;nBits[i]) - 1)
                                              * normAlpha + 0.5f);
            }
<span class="nc" id="L1089">            components[offset+numColorComponents] = (int)</span>
                (normAlpha * ((1&lt;&lt;nBits[numColorComponents]) - 1) + 0.5f);
<span class="nc" id="L1091">        }</span>
        else {
<span class="nc bnc" id="L1093" title="All 2 branches missed.">            for (int i=0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L1094">                components[offset+i] = (int) (normComponents[normOffset+i]</span>
                                              * ((1&lt;&lt;nBits[i]) - 1) + 0.5f);
            }
        }

<span class="nc" id="L1099">        return components;</span>
    }

    /**
     * Returns an array of all of the color/alpha components in normalized
     * form, given an unnormalized component array.  Unnormalized components
     * are unsigned integral values between 0 and 2&lt;sup&gt;n&lt;/sup&gt; - 1, where
     * n is the number of bits for a particular component.  Normalized
     * components are float values between a per component minimum and
     * maximum specified by the &lt;code&gt;ColorSpace&lt;/code&gt; object for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.  An &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * will be thrown if color component values for this
     * &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently representable in the
     * unnormalized form.  If the
     * &lt;code&gt;normComponents&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;, a new array
     * will be allocated.  The &lt;code&gt;normComponents&lt;/code&gt; array
     * will be returned.  Color/alpha components are stored in the
     * &lt;code&gt;normComponents&lt;/code&gt; array starting at
     * &lt;code&gt;normOffset&lt;/code&gt; (even if the array is allocated by this
     * method).  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown
     * if the &lt;code&gt;normComponents&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt;
     * and is not large enough to hold all the color and alpha components
     * (starting at &lt;code&gt;normOffset&lt;/code&gt;).  An
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown if the
     * &lt;code&gt;components&lt;/code&gt; array is not large enough to hold all the
     * color and alpha components starting at &lt;code&gt;offset&lt;/code&gt;.
     * &lt;p&gt;
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  The default implementation
     * of this method in this abstract class assumes that component values
     * for this class are conveniently representable in the unnormalized
     * form.  Therefore, subclasses which may
     * have instances which do not support the unnormalized form must
     * override this method.
     * @param components an array containing unnormalized components
     * @param offset the offset into the &lt;code&gt;components&lt;/code&gt; array at
     * which to start retrieving unnormalized components
     * @param normComponents an array that receives the normalized components
     * @param normOffset the index into &lt;code&gt;normComponents&lt;/code&gt; at
     * which to begin storing normalized components
     * @return an array containing normalized color and alpha
     * components.
     * @throws IllegalArgumentException If the component values for this
     * &lt;CODE&gt;ColorModel&lt;/CODE&gt; are not conveniently representable in the
     * unnormalized form.
     * @throws UnsupportedOperationException if the
     *          constructor of this &lt;code&gt;ColorModel&lt;/code&gt; called the
     *          &lt;code&gt;super(bits)&lt;/code&gt; constructor, but did not
     *          override this method.  See the constructor,
     *          {@link #ColorModel(int)}.
     * @throws UnsupportedOperationException if this method is unable
     *          to determine the number of bits per component
     */
    public float[] getNormalizedComponents(int[] components, int offset,
                                           float[] normComponents,
                                           int normOffset) {
        // Make sure that someone isn't using a custom color model
        // that called the super(bits) constructor.
<span class="nc bnc" id="L1157" title="All 2 branches missed.">        if (colorSpace == null) {</span>
<span class="nc" id="L1158">            throw new UnsupportedOperationException(&quot;This method is not supported by &quot;+</span>
                                        &quot;this color model.&quot;);
        }
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        if (nBits == null) {</span>
<span class="nc" id="L1162">            throw new UnsupportedOperationException (&quot;This method is not supported.  &quot;+</span>
                                         &quot;Unable to determine #bits per &quot;+
                                         &quot;component.&quot;);
        }

<span class="nc bnc" id="L1167" title="All 2 branches missed.">        if ((components.length - offset) &lt; numComponents) {</span>
<span class="nc" id="L1168">            throw new</span>
                IllegalArgumentException(
                        &quot;Incorrect number of components.  Expecting &quot;+
                        numComponents);
        }

<span class="nc bnc" id="L1174" title="All 2 branches missed.">        if (normComponents == null) {</span>
<span class="nc" id="L1175">            normComponents = new float[numComponents+normOffset];</span>
        }

<span class="nc bnc" id="L1178" title="All 4 branches missed.">        if (supportsAlpha &amp;&amp; isAlphaPremultiplied) {</span>
            // Normalized coordinates are non premultiplied
<span class="nc" id="L1180">            float normAlpha = (float)components[offset+numColorComponents];</span>
<span class="nc" id="L1181">            normAlpha /= (float) ((1&lt;&lt;nBits[numColorComponents]) - 1);</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">            if (normAlpha != 0.0f) {</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">                for (int i=0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1184">                    normComponents[normOffset+i] =</span>
                        ((float) components[offset+i]) /
                        (normAlpha * ((float) ((1&lt;&lt;nBits[i]) - 1)));
                }
            } else {
<span class="nc bnc" id="L1189" title="All 2 branches missed.">                for (int i=0; i &lt; numColorComponents; i++) {</span>
<span class="nc" id="L1190">                    normComponents[normOffset+i] = 0.0f;</span>
                }
            }
<span class="nc" id="L1193">            normComponents[normOffset+numColorComponents] = normAlpha;</span>
<span class="nc" id="L1194">        }</span>
        else {
<span class="nc bnc" id="L1196" title="All 2 branches missed.">            for (int i=0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L1197">                normComponents[normOffset+i] = ((float) components[offset+i]) /</span>
                                               ((float) ((1&lt;&lt;nBits[i]) - 1));
            }
        }

<span class="nc" id="L1202">        return normComponents;</span>
    }

    /**
     * Returns a pixel value represented as an &lt;code&gt;int&lt;/code&gt; in this
     * &lt;code&gt;ColorModel&lt;/code&gt;, given an array of unnormalized color/alpha
     * components.  This method will throw an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; if component values for this
     * &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently representable as a
     * single &lt;code&gt;int&lt;/code&gt; or if color component values for this
     * &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently representable in the
     * unnormalized form.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if  the
     * &lt;code&gt;components&lt;/code&gt; array is not large enough to hold all the
     * color and alpha components (starting at &lt;code&gt;offset&lt;/code&gt;).
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  Subclasses must
     * override this method since the implementation in this abstract
     * class throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     * @param components an array of unnormalized color and alpha
     * components
     * @param offset the index into &lt;code&gt;components&lt;/code&gt; at which to
     * begin retrieving the color and alpha components
     * @return an &lt;code&gt;int&lt;/code&gt; pixel value in this
     * &lt;code&gt;ColorModel&lt;/code&gt; corresponding to the specified components.
     * @throws IllegalArgumentException if
     *  pixel values for this &lt;code&gt;ColorModel&lt;/code&gt; are not
     *  conveniently representable as a single &lt;code&gt;int&lt;/code&gt;
     * @throws IllegalArgumentException if
     *  component values for this &lt;code&gt;ColorModel&lt;/code&gt; are not
     *  conveniently representable in the unnormalized form
     * @throws ArrayIndexOutOfBoundsException if
     *  the &lt;code&gt;components&lt;/code&gt; array is not large enough to
     *  hold all of the color and alpha components starting at
     *  &lt;code&gt;offset&lt;/code&gt;
     * @throws UnsupportedOperationException if this
     *  method is not supported by this &lt;code&gt;ColorModel&lt;/code&gt;
     */
    public int getDataElement(int[] components, int offset) {
<span class="nc" id="L1241">        throw new UnsupportedOperationException(&quot;This method is not supported &quot;+</span>
                                    &quot;by this color model.&quot;);
    }

    /**
     * Returns a data element array representation of a pixel in this
     * &lt;code&gt;ColorModel&lt;/code&gt;, given an array of unnormalized color/alpha
     * components.  This array can then be passed to the
     * &lt;code&gt;setDataElements&lt;/code&gt; method of a &lt;code&gt;WritableRaster&lt;/code&gt;
     * object.  This method will throw an &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * if color component values for this &lt;code&gt;ColorModel&lt;/code&gt; are not
     * conveniently representable in the unnormalized form.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown
     * if the &lt;code&gt;components&lt;/code&gt; array is not large enough to hold
     * all the color and alpha components (starting at
     * &lt;code&gt;offset&lt;/code&gt;).  If the &lt;code&gt;obj&lt;/code&gt; variable is
     * &lt;code&gt;null&lt;/code&gt;, a new array will be allocated.  If
     * &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it must be a primitive
     * array of type transferType; otherwise, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * &lt;code&gt;obj&lt;/code&gt; is not large enough to hold a pixel value for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  Subclasses must
     * override this method since the implementation in this abstract
     * class throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     * @param components an array of unnormalized color and alpha
     * components
     * @param offset the index into &lt;code&gt;components&lt;/code&gt; at which to
     * begin retrieving color and alpha components
     * @param obj the &lt;code&gt;Object&lt;/code&gt; representing an array of color
     * and alpha components
     * @return an &lt;code&gt;Object&lt;/code&gt; representing an array of color and
     * alpha components.
     * @throws ClassCastException if &lt;code&gt;obj&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;obj&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt; or the &lt;code&gt;components&lt;/code&gt;
     *  array is not large enough to hold all of the color and alpha
     *  components starting at &lt;code&gt;offset&lt;/code&gt;
     * @throws IllegalArgumentException if
     *  component values for this &lt;code&gt;ColorModel&lt;/code&gt; are not
     *  conveniently representable in the unnormalized form
     * @throws UnsupportedOperationException if this
     *  method is not supported by this &lt;code&gt;ColorModel&lt;/code&gt;
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     */
    public Object getDataElements(int[] components, int offset, Object obj) {
<span class="nc" id="L1292">        throw new UnsupportedOperationException(&quot;This method has not been implemented &quot;+</span>
                                    &quot;for this color model.&quot;);
    }

    /**
     * Returns a pixel value represented as an &lt;code&gt;int&lt;/code&gt; in this
     * &lt;code&gt;ColorModel&lt;/code&gt;, given an array of normalized color/alpha
     * components.  This method will throw an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; if pixel values for this
     * &lt;code&gt;ColorModel&lt;/code&gt; are not conveniently representable as a
     * single &lt;code&gt;int&lt;/code&gt;.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if  the
     * &lt;code&gt;normComponents&lt;/code&gt; array is not large enough to hold all the
     * color and alpha components (starting at &lt;code&gt;normOffset&lt;/code&gt;).
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  The default implementation
     * of this method in this abstract class first converts from the
     * normalized form to the unnormalized form and then calls
     * &lt;code&gt;getDataElement(int[], int)&lt;/code&gt;.  Subclasses which may
     * have instances which do not support the unnormalized form must
     * override this method.
     * @param normComponents an array of normalized color and alpha
     * components
     * @param normOffset the index into &lt;code&gt;normComponents&lt;/code&gt; at which to
     * begin retrieving the color and alpha components
     * @return an &lt;code&gt;int&lt;/code&gt; pixel value in this
     * &lt;code&gt;ColorModel&lt;/code&gt; corresponding to the specified components.
     * @throws IllegalArgumentException if
     *  pixel values for this &lt;code&gt;ColorModel&lt;/code&gt; are not
     *  conveniently representable as a single &lt;code&gt;int&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  the &lt;code&gt;normComponents&lt;/code&gt; array is not large enough to
     *  hold all of the color and alpha components starting at
     *  &lt;code&gt;normOffset&lt;/code&gt;
     * @since 1.4
     */
    public int getDataElement(float[] normComponents, int normOffset) {
<span class="nc" id="L1329">        int components[] = getUnnormalizedComponents(normComponents,</span>
                                                     normOffset, null, 0);
<span class="nc" id="L1331">        return getDataElement(components, 0);</span>
    }

    /**
     * Returns a data element array representation of a pixel in this
     * &lt;code&gt;ColorModel&lt;/code&gt;, given an array of normalized color/alpha
     * components.  This array can then be passed to the
     * &lt;code&gt;setDataElements&lt;/code&gt; method of a &lt;code&gt;WritableRaster&lt;/code&gt;
     * object.  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown
     * if the &lt;code&gt;normComponents&lt;/code&gt; array is not large enough to hold
     * all the color and alpha components (starting at
     * &lt;code&gt;normOffset&lt;/code&gt;).  If the &lt;code&gt;obj&lt;/code&gt; variable is
     * &lt;code&gt;null&lt;/code&gt;, a new array will be allocated.  If
     * &lt;code&gt;obj&lt;/code&gt; is not &lt;code&gt;null&lt;/code&gt;, it must be a primitive
     * array of type transferType; otherwise, a
     * &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.  An
     * &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * &lt;code&gt;obj&lt;/code&gt; is not large enough to hold a pixel value for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  The default implementation
     * of this method in this abstract class first converts from the
     * normalized form to the unnormalized form and then calls
     * &lt;code&gt;getDataElement(int[], int, Object)&lt;/code&gt;.  Subclasses which may
     * have instances which do not support the unnormalized form must
     * override this method.
     * @param normComponents an array of normalized color and alpha
     * components
     * @param normOffset the index into &lt;code&gt;normComponents&lt;/code&gt; at which to
     * begin retrieving color and alpha components
     * @param obj a primitive data array to hold the returned pixel
     * @return an &lt;code&gt;Object&lt;/code&gt; which is a primitive data array
     * representation of a pixel
     * @throws ClassCastException if &lt;code&gt;obj&lt;/code&gt;
     *  is not a primitive array of type &lt;code&gt;transferType&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *  &lt;code&gt;obj&lt;/code&gt; is not large enough to hold a pixel value
     *  for this &lt;code&gt;ColorModel&lt;/code&gt; or the &lt;code&gt;normComponents&lt;/code&gt;
     *  array is not large enough to hold all of the color and alpha
     *  components starting at &lt;code&gt;normOffset&lt;/code&gt;
     * @see WritableRaster#setDataElements
     * @see SampleModel#setDataElements
     * @since 1.4
     */
    public Object getDataElements(float[] normComponents, int normOffset,
                                  Object obj) {
<span class="nc" id="L1377">        int components[] = getUnnormalizedComponents(normComponents,</span>
                                                     normOffset, null, 0);
<span class="nc" id="L1379">        return getDataElements(components, 0, obj);</span>
    }

    /**
     * Returns an array of all of the color/alpha components in normalized
     * form, given a pixel in this &lt;code&gt;ColorModel&lt;/code&gt;.  The pixel
     * value is specified by an array of data elements of type transferType
     * passed in as an object reference.  If pixel is not a primitive array
     * of type transferType, a &lt;code&gt;ClassCastException&lt;/code&gt; is thrown.
     * An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown if
     * &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel value for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * Normalized components are float values between a per component minimum
     * and maximum specified by the &lt;code&gt;ColorSpace&lt;/code&gt; object for this
     * &lt;code&gt;ColorModel&lt;/code&gt;.  If the
     * &lt;code&gt;normComponents&lt;/code&gt; array is &lt;code&gt;null&lt;/code&gt;, a new array
     * will be allocated.  The &lt;code&gt;normComponents&lt;/code&gt; array
     * will be returned.  Color/alpha components are stored in the
     * &lt;code&gt;normComponents&lt;/code&gt; array starting at
     * &lt;code&gt;normOffset&lt;/code&gt; (even if the array is allocated by this
     * method).  An &lt;code&gt;ArrayIndexOutOfBoundsException&lt;/code&gt; is thrown
     * if the &lt;code&gt;normComponents&lt;/code&gt; array is not &lt;code&gt;null&lt;/code&gt;
     * and is not large enough to hold all the color and alpha components
     * (starting at &lt;code&gt;normOffset&lt;/code&gt;).
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  The default implementation
     * of this method in this abstract class first retrieves color and alpha
     * components in the unnormalized form using
     * &lt;code&gt;getComponents(Object, int[], int)&lt;/code&gt; and then calls
     * &lt;code&gt;getNormalizedComponents(int[], int, float[], int)&lt;/code&gt;.
     * Subclasses which may
     * have instances which do not support the unnormalized form must
     * override this method.
     * @param pixel the specified pixel
     * @param normComponents an array to receive the normalized components
     * @param normOffset the offset into the &lt;code&gt;normComponents&lt;/code&gt;
     * array at which to start storing normalized components
     * @return an array containing normalized color and alpha
     * components.
     * @throws ClassCastException if &lt;code&gt;pixel&lt;/code&gt; is not a primitive
     *          array of type transferType
     * @throws ArrayIndexOutOfBoundsException if
     *          &lt;code&gt;normComponents&lt;/code&gt; is not large enough to hold all
     *          color and alpha components starting at &lt;code&gt;normOffset&lt;/code&gt;
     * @throws ArrayIndexOutOfBoundsException if
     *          &lt;code&gt;pixel&lt;/code&gt; is not large enough to hold a pixel
     *          value for this &lt;code&gt;ColorModel&lt;/code&gt;.
     * @throws UnsupportedOperationException if the
     *          constructor of this &lt;code&gt;ColorModel&lt;/code&gt; called the
     *          &lt;code&gt;super(bits)&lt;/code&gt; constructor, but did not
     *          override this method.  See the constructor,
     *          {@link #ColorModel(int)}.
     * @throws UnsupportedOperationException if this method is unable
     *          to determine the number of bits per component
     * @since 1.4
     */
    public float[] getNormalizedComponents(Object pixel,
                                           float[] normComponents,
                                           int normOffset) {
<span class="nc" id="L1438">        int components[] = getComponents(pixel, null, 0);</span>
<span class="nc" id="L1439">        return getNormalizedComponents(components, 0,</span>
                                       normComponents, normOffset);
    }

    /**
     * Tests if the specified &lt;code&gt;Object&lt;/code&gt; is an instance of
     * &lt;code&gt;ColorModel&lt;/code&gt; and if it equals this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param obj the &lt;code&gt;Object&lt;/code&gt; to test for equality
     * @return &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;Object&lt;/code&gt;
     * is an instance of &lt;code&gt;ColorModel&lt;/code&gt; and equals this
     * &lt;code&gt;ColorModel&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    public boolean equals(Object obj) {
<span class="nc bnc" id="L1453" title="All 2 branches missed.">        if (!(obj instanceof ColorModel)) {</span>
<span class="nc" id="L1454">            return false;</span>
        }
<span class="nc" id="L1456">        ColorModel cm = (ColorModel) obj;</span>

<span class="nc bnc" id="L1458" title="All 2 branches missed.">        if (this == cm) {</span>
<span class="nc" id="L1459">            return true;</span>
        }
<span class="nc bnc" id="L1461" title="All 2 branches missed.">        if (supportsAlpha != cm.hasAlpha() ||</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">            isAlphaPremultiplied != cm.isAlphaPremultiplied() ||</span>
<span class="nc bnc" id="L1463" title="All 2 branches missed.">            pixel_bits != cm.getPixelSize() ||</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">            transparency != cm.getTransparency() ||</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">            numComponents != cm.getNumComponents())</span>
        {
<span class="nc" id="L1467">            return false;</span>
        }

<span class="nc" id="L1470">        int[] nb = cm.getComponentSize();</span>

<span class="nc bnc" id="L1472" title="All 4 branches missed.">        if ((nBits != null) &amp;&amp; (nb != null)) {</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">            for (int i = 0; i &lt; numComponents; i++) {</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">                if (nBits[i] != nb[i]) {</span>
<span class="nc" id="L1475">                    return false;</span>
                }
            }
        } else {
<span class="nc bnc" id="L1479" title="All 4 branches missed.">            return ((nBits == null) &amp;&amp; (nb == null));</span>
        }

<span class="nc" id="L1482">        return true;</span>
    }

    /**
     * Returns the hash code for this ColorModel.
     *
     * @return    a hash code for this ColorModel.
     */
    public int hashCode() {

<span class="nc" id="L1492">        int result = 0;</span>

<span class="nc bnc" id="L1494" title="All 4 branches missed.">        result = (supportsAlpha ? 2 : 3) +</span>
                 (isAlphaPremultiplied ? 4 : 5) +
                 pixel_bits * 6 +
                 transparency * 7 +
                 numComponents * 8;

<span class="nc bnc" id="L1500" title="All 2 branches missed.">        if (nBits != null) {</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">            for (int i = 0; i &lt; numComponents; i++) {</span>
<span class="nc" id="L1502">                result = result + nBits[i] * (i + 9);</span>
            }
        }

<span class="nc" id="L1506">        return result;</span>
    }

    /**
     * Returns the &lt;code&gt;ColorSpace&lt;/code&gt; associated with this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * @return the &lt;code&gt;ColorSpace&lt;/code&gt; of this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     */
    final public ColorSpace getColorSpace() {
<span class="nc" id="L1516">        return colorSpace;</span>
    }

    /**
     * Forces the raster data to match the state specified in the
     * &lt;code&gt;isAlphaPremultiplied&lt;/code&gt; variable, assuming the data is
     * currently correctly described by this &lt;code&gt;ColorModel&lt;/code&gt;.  It
     * may multiply or divide the color raster data by alpha, or do
     * nothing if the data is in the correct state.  If the data needs to
     * be coerced, this method will also return an instance of this
     * &lt;code&gt;ColorModel&lt;/code&gt; with the &lt;code&gt;isAlphaPremultiplied&lt;/code&gt;
     * flag set appropriately.  This method will throw a
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if it is not supported
     * by this &lt;code&gt;ColorModel&lt;/code&gt;.
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  Subclasses must
     * override this method since the implementation in this abstract
     * class throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     * @param raster the &lt;code&gt;WritableRaster&lt;/code&gt; data
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the alpha is
     * premultiplied; &lt;code&gt;false&lt;/code&gt; otherwise
     * @return a &lt;code&gt;ColorModel&lt;/code&gt; object that represents the
     * coerced data.
     */
    public ColorModel coerceData (WritableRaster raster,
                                  boolean isAlphaPremultiplied) {
<span class="nc" id="L1542">        throw new UnsupportedOperationException</span>
            (&quot;This method is not supported by this color model&quot;);
    }

    /**
      * Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;raster&lt;/code&gt; is compatible
      * with this &lt;code&gt;ColorModel&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; if it is
      * not.
      * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
      * any instance is an instance of a subclass.  Subclasses must
      * override this method since the implementation in this abstract
      * class throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
      * @param raster the {@link Raster} object to test for compatibility
      * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;raster&lt;/code&gt; is compatible
      * with this &lt;code&gt;ColorModel&lt;/code&gt;.
      * @throws UnsupportedOperationException if this
      *         method has not been implemented for this
      *         &lt;code&gt;ColorModel&lt;/code&gt;
      */
    public boolean isCompatibleRaster(Raster raster) {
<span class="nc" id="L1562">        throw new UnsupportedOperationException(</span>
            &quot;This method has not been implemented for this ColorModel.&quot;);
    }

    /**
     * Creates a &lt;code&gt;WritableRaster&lt;/code&gt; with the specified width and
     * height that has a data layout (&lt;code&gt;SampleModel&lt;/code&gt;) compatible
     * with this &lt;code&gt;ColorModel&lt;/code&gt;.
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  Subclasses must
     * override this method since the implementation in this abstract
     * class throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     * @param w the width to apply to the new &lt;code&gt;WritableRaster&lt;/code&gt;
     * @param h the height to apply to the new &lt;code&gt;WritableRaster&lt;/code&gt;
     * @return a &lt;code&gt;WritableRaster&lt;/code&gt; object with the specified
     * width and height.
     * @throws UnsupportedOperationException if this
     *          method is not supported by this &lt;code&gt;ColorModel&lt;/code&gt;
     * @see WritableRaster
     * @see SampleModel
     */
    public WritableRaster createCompatibleWritableRaster(int w, int h) {
<span class="nc" id="L1584">        throw new UnsupportedOperationException</span>
            (&quot;This method is not supported by this color model&quot;);
    }

    /**
     * Creates a &lt;code&gt;SampleModel&lt;/code&gt; with the specified width and
     * height that has a data layout compatible with this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  Subclasses must
     * override this method since the implementation in this abstract
     * class throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     * @param w the width to apply to the new &lt;code&gt;SampleModel&lt;/code&gt;
     * @param h the height to apply to the new &lt;code&gt;SampleModel&lt;/code&gt;
     * @return a &lt;code&gt;SampleModel&lt;/code&gt; object with the specified
     * width and height.
     * @throws UnsupportedOperationException if this
     *          method is not supported by this &lt;code&gt;ColorModel&lt;/code&gt;
     * @see SampleModel
     */
    public SampleModel createCompatibleSampleModel(int w, int h) {
<span class="nc" id="L1605">        throw new UnsupportedOperationException</span>
            (&quot;This method is not supported by this color model&quot;);
    }

    /** Checks if the &lt;code&gt;SampleModel&lt;/code&gt; is compatible with this
     * &lt;code&gt;ColorModel&lt;/code&gt;.
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class,
     * any instance is an instance of a subclass.  Subclasses must
     * override this method since the implementation in this abstract
     * class throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     * @param sm the specified &lt;code&gt;SampleModel&lt;/code&gt;
     * @return &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;SampleModel&lt;/code&gt;
     * is compatible with this &lt;code&gt;ColorModel&lt;/code&gt;; &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     * @throws UnsupportedOperationException if this
     *          method is not supported by this &lt;code&gt;ColorModel&lt;/code&gt;
     * @see SampleModel
     */
    public boolean isCompatibleSampleModel(SampleModel sm) {
<span class="nc" id="L1624">        throw new UnsupportedOperationException</span>
            (&quot;This method is not supported by this color model&quot;);
    }

    /**
     * Disposes of system resources associated with this
     * &lt;code&gt;ColorModel&lt;/code&gt; once this &lt;code&gt;ColorModel&lt;/code&gt; is no
     * longer referenced.
     */
    public void finalize() {
<span class="nc" id="L1634">    }</span>


    /**
     * Returns a &lt;code&gt;Raster&lt;/code&gt; representing the alpha channel of an
     * image, extracted from the input &lt;code&gt;Raster&lt;/code&gt;, provided that
     * pixel values of this &lt;code&gt;ColorModel&lt;/code&gt; represent color and
     * alpha information as separate spatial bands (e.g.
     * {@link ComponentColorModel} and &lt;code&gt;DirectColorModel&lt;/code&gt;).
     * This method assumes that &lt;code&gt;Raster&lt;/code&gt; objects associated
     * with such a &lt;code&gt;ColorModel&lt;/code&gt; store the alpha band, if
     * present, as the last band of image data.  Returns &lt;code&gt;null&lt;/code&gt;
     * if there is no separate spatial alpha channel associated with this
     * &lt;code&gt;ColorModel&lt;/code&gt;.  If this is an
     * &lt;code&gt;IndexColorModel&lt;/code&gt; which has alpha in the lookup table,
     * this method will return &lt;code&gt;null&lt;/code&gt; since
     * there is no spatially discrete alpha channel.
     * This method will create a new &lt;code&gt;Raster&lt;/code&gt; (but will share
     * the data array).
     * Since &lt;code&gt;ColorModel&lt;/code&gt; is an abstract class, any instance
     * is an instance of a subclass.  Subclasses must override this
     * method to get any behavior other than returning &lt;code&gt;null&lt;/code&gt;
     * because the implementation in this abstract class returns
     * &lt;code&gt;null&lt;/code&gt;.
     * @param raster the specified &lt;code&gt;Raster&lt;/code&gt;
     * @return a &lt;code&gt;Raster&lt;/code&gt; representing the alpha channel of
     * an image, obtained from the specified &lt;code&gt;Raster&lt;/code&gt;.
     */
    public WritableRaster getAlphaRaster(WritableRaster raster) {
<span class="nc" id="L1663">        return null;</span>
    }

    /**
     * Returns the &lt;code&gt;String&lt;/code&gt; representation of the contents of
     * this &lt;code&gt;ColorModel&lt;/code&gt;object.
     * @return a &lt;code&gt;String&lt;/code&gt; representing the contents of this
     * &lt;code&gt;ColorModel&lt;/code&gt; object.
     */
    public String toString() {
<span class="nc" id="L1673">       return new String(&quot;ColorModel: #pixelBits = &quot;+pixel_bits</span>
                         + &quot; numComponents = &quot;+numComponents
                         + &quot; color space = &quot;+colorSpace
                         + &quot; transparency = &quot;+transparency
                         + &quot; has alpha = &quot;+supportsAlpha
                         + &quot; isAlphaPre = &quot;+isAlphaPremultiplied
                         );
    }

    static int getDefaultTransferType(int pixel_bits) {
<span class="nc bnc" id="L1683" title="All 2 branches missed.">        if (pixel_bits &lt;= 8) {</span>
<span class="nc" id="L1684">            return DataBuffer.TYPE_BYTE;</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">        } else if (pixel_bits &lt;= 16) {</span>
<span class="nc" id="L1686">            return DataBuffer.TYPE_USHORT;</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">        } else if (pixel_bits &lt;= 32) {</span>
<span class="nc" id="L1688">            return DataBuffer.TYPE_INT;</span>
        } else {
<span class="nc" id="L1690">            return DataBuffer.TYPE_UNDEFINED;</span>
        }
    }

<span class="nc" id="L1694">    static byte[] l8Tos8 = null;   // 8-bit linear to 8-bit non-linear sRGB LUT</span>
<span class="nc" id="L1695">    static byte[] s8Tol8 = null;   // 8-bit non-linear sRGB to 8-bit linear LUT</span>
<span class="nc" id="L1696">    static byte[] l16Tos8 = null;  // 16-bit linear to 8-bit non-linear sRGB LUT</span>
<span class="nc" id="L1697">    static short[] s8Tol16 = null; // 8-bit non-linear sRGB to 16-bit linear LUT</span>

                                // Maps to hold LUTs for grayscale conversions
<span class="nc" id="L1700">    static Map&lt;ICC_ColorSpace, byte[]&gt; g8Tos8Map = null;     // 8-bit gray values to 8-bit sRGB values</span>
<span class="nc" id="L1701">    static Map&lt;ICC_ColorSpace, byte[]&gt; lg16Toog8Map = null;  // 16-bit linear to 8-bit &quot;other&quot; gray</span>
<span class="nc" id="L1702">    static Map&lt;ICC_ColorSpace, byte[]&gt; g16Tos8Map = null;    // 16-bit gray values to 8-bit sRGB values</span>
<span class="nc" id="L1703">    static Map&lt;ICC_ColorSpace, short[]&gt; lg16Toog16Map = null; // 16-bit linear to 16-bit &quot;other&quot; gray</span>

    static boolean isLinearRGBspace(ColorSpace cs) {
        // Note: CMM.LINEAR_RGBspace will be null if the linear
        // RGB space has not been created yet.
<span class="nc bnc" id="L1708" title="All 2 branches missed.">        return (cs == CMSManager.LINEAR_RGBspace);</span>
    }

    static boolean isLinearGRAYspace(ColorSpace cs) {
        // Note: CMM.GRAYspace will be null if the linear
        // gray space has not been created yet.
<span class="nc bnc" id="L1714" title="All 2 branches missed.">        return (cs == CMSManager.GRAYspace);</span>
    }

    static byte[] getLinearRGB8TosRGB8LUT() {
<span class="nc bnc" id="L1718" title="All 2 branches missed.">        if (l8Tos8 == null) {</span>
<span class="nc" id="L1719">            l8Tos8 = new byte[256];</span>
            float input, output;
            // algorithm for linear RGB to nonlinear sRGB conversion
            // is from the IEC 61966-2-1 International Standard,
            // Colour Management - Default RGB colour space - sRGB,
            // First Edition, 1999-10,
            // avaiable for order at http://www.iec.ch
<span class="nc bnc" id="L1726" title="All 2 branches missed.">            for (int i = 0; i &lt;= 255; i++) {</span>
<span class="nc" id="L1727">                input = ((float) i) / 255.0f;</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">                if (input &lt;= 0.0031308f) {</span>
<span class="nc" id="L1729">                    output = input * 12.92f;</span>
                } else {
<span class="nc" id="L1731">                    output = 1.055f * ((float) Math.pow(input, (1.0 / 2.4)))</span>
                             - 0.055f;
                }
<span class="nc" id="L1734">                l8Tos8[i] = (byte) Math.round(output * 255.0f);</span>
            }
        }
<span class="nc" id="L1737">        return l8Tos8;</span>
    }

    static byte[] getsRGB8ToLinearRGB8LUT() {
<span class="nc bnc" id="L1741" title="All 2 branches missed.">        if (s8Tol8 == null) {</span>
<span class="nc" id="L1742">            s8Tol8 = new byte[256];</span>
            float input, output;
            // algorithm from IEC 61966-2-1 International Standard
<span class="nc bnc" id="L1745" title="All 2 branches missed.">            for (int i = 0; i &lt;= 255; i++) {</span>
<span class="nc" id="L1746">                input = ((float) i) / 255.0f;</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">                if (input &lt;= 0.04045f) {</span>
<span class="nc" id="L1748">                    output = input / 12.92f;</span>
                } else {
<span class="nc" id="L1750">                    output = (float) Math.pow((input + 0.055f) / 1.055f, 2.4);</span>
                }
<span class="nc" id="L1752">                s8Tol8[i] = (byte) Math.round(output * 255.0f);</span>
            }
        }
<span class="nc" id="L1755">        return s8Tol8;</span>
    }

    static byte[] getLinearRGB16TosRGB8LUT() {
<span class="nc bnc" id="L1759" title="All 2 branches missed.">        if (l16Tos8 == null) {</span>
<span class="nc" id="L1760">            l16Tos8 = new byte[65536];</span>
            float input, output;
            // algorithm from IEC 61966-2-1 International Standard
<span class="nc bnc" id="L1763" title="All 2 branches missed.">            for (int i = 0; i &lt;= 65535; i++) {</span>
<span class="nc" id="L1764">                input = ((float) i) / 65535.0f;</span>
<span class="nc bnc" id="L1765" title="All 2 branches missed.">                if (input &lt;= 0.0031308f) {</span>
<span class="nc" id="L1766">                    output = input * 12.92f;</span>
                } else {
<span class="nc" id="L1768">                    output = 1.055f * ((float) Math.pow(input, (1.0 / 2.4)))</span>
                             - 0.055f;
                }
<span class="nc" id="L1771">                l16Tos8[i] = (byte) Math.round(output * 255.0f);</span>
            }
        }
<span class="nc" id="L1774">        return l16Tos8;</span>
    }

    static short[] getsRGB8ToLinearRGB16LUT() {
<span class="nc bnc" id="L1778" title="All 2 branches missed.">        if (s8Tol16 == null) {</span>
<span class="nc" id="L1779">            s8Tol16 = new short[256];</span>
            float input, output;
            // algorithm from IEC 61966-2-1 International Standard
<span class="nc bnc" id="L1782" title="All 2 branches missed.">            for (int i = 0; i &lt;= 255; i++) {</span>
<span class="nc" id="L1783">                input = ((float) i) / 255.0f;</span>
<span class="nc bnc" id="L1784" title="All 2 branches missed.">                if (input &lt;= 0.04045f) {</span>
<span class="nc" id="L1785">                    output = input / 12.92f;</span>
                } else {
<span class="nc" id="L1787">                    output = (float) Math.pow((input + 0.055f) / 1.055f, 2.4);</span>
                }
<span class="nc" id="L1789">                s8Tol16[i] = (short) Math.round(output * 65535.0f);</span>
            }
        }
<span class="nc" id="L1792">        return s8Tol16;</span>
    }

    /*
     * Return a byte LUT that converts 8-bit gray values in the grayCS
     * ColorSpace to the appropriate 8-bit sRGB value.  I.e., if lut
     * is the byte array returned by this method and sval = lut[gval],
     * then the sRGB triple (sval,sval,sval) is the best match to gval.
     * Cache references to any computed LUT in a Map.
     */
    static byte[] getGray8TosRGB8LUT(ICC_ColorSpace grayCS) {
<span class="nc bnc" id="L1803" title="All 2 branches missed.">        if (isLinearGRAYspace(grayCS)) {</span>
<span class="nc" id="L1804">            return getLinearRGB8TosRGB8LUT();</span>
        }
<span class="nc bnc" id="L1806" title="All 2 branches missed.">        if (g8Tos8Map != null) {</span>
<span class="nc" id="L1807">            byte[] g8Tos8LUT = g8Tos8Map.get(grayCS);</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">            if (g8Tos8LUT != null) {</span>
<span class="nc" id="L1809">                return g8Tos8LUT;</span>
            }
        }
<span class="nc" id="L1812">        byte[] g8Tos8LUT = new byte[256];</span>
<span class="nc bnc" id="L1813" title="All 2 branches missed.">        for (int i = 0; i &lt;= 255; i++) {</span>
<span class="nc" id="L1814">            g8Tos8LUT[i] = (byte) i;</span>
        }
<span class="nc" id="L1816">        ColorTransform[] transformList = new ColorTransform[2];</span>
<span class="nc" id="L1817">        PCMM mdl = CMSManager.getModule();</span>
<span class="nc" id="L1818">        ICC_ColorSpace srgbCS =</span>
<span class="nc" id="L1819">            (ICC_ColorSpace) ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>
<span class="nc" id="L1820">        transformList[0] = mdl.createTransform(</span>
<span class="nc" id="L1821">            grayCS.getProfile(), ColorTransform.Any, ColorTransform.In);</span>
<span class="nc" id="L1822">        transformList[1] = mdl.createTransform(</span>
<span class="nc" id="L1823">            srgbCS.getProfile(), ColorTransform.Any, ColorTransform.Out);</span>
<span class="nc" id="L1824">        ColorTransform t = mdl.createTransform(transformList);</span>
<span class="nc" id="L1825">        byte[] tmp = t.colorConvert(g8Tos8LUT, null);</span>
<span class="nc bnc" id="L1826" title="All 2 branches missed.">        for (int i = 0, j= 2; i &lt;= 255; i++, j += 3) {</span>
            // All three components of tmp should be equal, since
            // the input color space to colorConvert is a gray scale
            // space.  However, there are slight anomalies in the results.
            // Copy tmp starting at index 2, since colorConvert seems
            // to be slightly more accurate for the third component!
<span class="nc" id="L1832">            g8Tos8LUT[i] = tmp[j];</span>
        }
<span class="nc bnc" id="L1834" title="All 2 branches missed.">        if (g8Tos8Map == null) {</span>
<span class="nc" id="L1835">            g8Tos8Map = Collections.synchronizedMap(new WeakHashMap&lt;ICC_ColorSpace, byte[]&gt;(2));</span>
        }
<span class="nc" id="L1837">        g8Tos8Map.put(grayCS, g8Tos8LUT);</span>
<span class="nc" id="L1838">        return g8Tos8LUT;</span>
    }

    /*
     * Return a byte LUT that converts 16-bit gray values in the CS_GRAY
     * linear gray ColorSpace to the appropriate 8-bit value in the
     * grayCS ColorSpace.  Cache references to any computed LUT in a Map.
     */
    static byte[] getLinearGray16ToOtherGray8LUT(ICC_ColorSpace grayCS) {
<span class="nc bnc" id="L1847" title="All 2 branches missed.">        if (lg16Toog8Map != null) {</span>
<span class="nc" id="L1848">            byte[] lg16Toog8LUT = lg16Toog8Map.get(grayCS);</span>
<span class="nc bnc" id="L1849" title="All 2 branches missed.">            if (lg16Toog8LUT != null) {</span>
<span class="nc" id="L1850">                return lg16Toog8LUT;</span>
            }
        }
<span class="nc" id="L1853">        short[] tmp = new short[65536];</span>
<span class="nc bnc" id="L1854" title="All 2 branches missed.">        for (int i = 0; i &lt;= 65535; i++) {</span>
<span class="nc" id="L1855">            tmp[i] = (short) i;</span>
        }
<span class="nc" id="L1857">        ColorTransform[] transformList = new ColorTransform[2];</span>
<span class="nc" id="L1858">        PCMM mdl = CMSManager.getModule();</span>
<span class="nc" id="L1859">        ICC_ColorSpace lgCS =</span>
<span class="nc" id="L1860">            (ICC_ColorSpace) ColorSpace.getInstance(ColorSpace.CS_GRAY);</span>
<span class="nc" id="L1861">        transformList[0] = mdl.createTransform (</span>
<span class="nc" id="L1862">            lgCS.getProfile(), ColorTransform.Any, ColorTransform.In);</span>
<span class="nc" id="L1863">        transformList[1] = mdl.createTransform (</span>
<span class="nc" id="L1864">            grayCS.getProfile(), ColorTransform.Any, ColorTransform.Out);</span>
<span class="nc" id="L1865">        ColorTransform t = mdl.createTransform(transformList);</span>
<span class="nc" id="L1866">        tmp = t.colorConvert(tmp, null);</span>
<span class="nc" id="L1867">        byte[] lg16Toog8LUT = new byte[65536];</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">        for (int i = 0; i &lt;= 65535; i++) {</span>
            // scale unsigned short (0 - 65535) to unsigned byte (0 - 255)
<span class="nc" id="L1870">            lg16Toog8LUT[i] =</span>
                (byte) (((float) (tmp[i] &amp; 0xffff)) * (1.0f /257.0f) + 0.5f);
        }
<span class="nc bnc" id="L1873" title="All 2 branches missed.">        if (lg16Toog8Map == null) {</span>
<span class="nc" id="L1874">            lg16Toog8Map = Collections.synchronizedMap(new WeakHashMap&lt;ICC_ColorSpace, byte[]&gt;(2));</span>
        }
<span class="nc" id="L1876">        lg16Toog8Map.put(grayCS, lg16Toog8LUT);</span>
<span class="nc" id="L1877">        return lg16Toog8LUT;</span>
    }

    /*
     * Return a byte LUT that converts 16-bit gray values in the grayCS
     * ColorSpace to the appropriate 8-bit sRGB value.  I.e., if lut
     * is the byte array returned by this method and sval = lut[gval],
     * then the sRGB triple (sval,sval,sval) is the best match to gval.
     * Cache references to any computed LUT in a Map.
     */
    static byte[] getGray16TosRGB8LUT(ICC_ColorSpace grayCS) {
<span class="nc bnc" id="L1888" title="All 2 branches missed.">        if (isLinearGRAYspace(grayCS)) {</span>
<span class="nc" id="L1889">            return getLinearRGB16TosRGB8LUT();</span>
        }
<span class="nc bnc" id="L1891" title="All 2 branches missed.">        if (g16Tos8Map != null) {</span>
<span class="nc" id="L1892">            byte[] g16Tos8LUT = g16Tos8Map.get(grayCS);</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">            if (g16Tos8LUT != null) {</span>
<span class="nc" id="L1894">                return g16Tos8LUT;</span>
            }
        }
<span class="nc" id="L1897">        short[] tmp = new short[65536];</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">        for (int i = 0; i &lt;= 65535; i++) {</span>
<span class="nc" id="L1899">            tmp[i] = (short) i;</span>
        }
<span class="nc" id="L1901">        ColorTransform[] transformList = new ColorTransform[2];</span>
<span class="nc" id="L1902">        PCMM mdl = CMSManager.getModule();</span>
<span class="nc" id="L1903">        ICC_ColorSpace srgbCS =</span>
<span class="nc" id="L1904">            (ICC_ColorSpace) ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>
<span class="nc" id="L1905">        transformList[0] = mdl.createTransform (</span>
<span class="nc" id="L1906">            grayCS.getProfile(), ColorTransform.Any, ColorTransform.In);</span>
<span class="nc" id="L1907">        transformList[1] = mdl.createTransform (</span>
<span class="nc" id="L1908">            srgbCS.getProfile(), ColorTransform.Any, ColorTransform.Out);</span>
<span class="nc" id="L1909">        ColorTransform t = mdl.createTransform(transformList);</span>
<span class="nc" id="L1910">        tmp = t.colorConvert(tmp, null);</span>
<span class="nc" id="L1911">        byte[] g16Tos8LUT = new byte[65536];</span>
<span class="nc bnc" id="L1912" title="All 2 branches missed.">        for (int i = 0, j= 2; i &lt;= 65535; i++, j += 3) {</span>
            // All three components of tmp should be equal, since
            // the input color space to colorConvert is a gray scale
            // space.  However, there are slight anomalies in the results.
            // Copy tmp starting at index 2, since colorConvert seems
            // to be slightly more accurate for the third component!

            // scale unsigned short (0 - 65535) to unsigned byte (0 - 255)
<span class="nc" id="L1920">            g16Tos8LUT[i] =</span>
                (byte) (((float) (tmp[j] &amp; 0xffff)) * (1.0f /257.0f) + 0.5f);
        }
<span class="nc bnc" id="L1923" title="All 2 branches missed.">        if (g16Tos8Map == null) {</span>
<span class="nc" id="L1924">            g16Tos8Map = Collections.synchronizedMap(new WeakHashMap&lt;ICC_ColorSpace, byte[]&gt;(2));</span>
        }
<span class="nc" id="L1926">        g16Tos8Map.put(grayCS, g16Tos8LUT);</span>
<span class="nc" id="L1927">        return g16Tos8LUT;</span>
    }

    /*
     * Return a short LUT that converts 16-bit gray values in the CS_GRAY
     * linear gray ColorSpace to the appropriate 16-bit value in the
     * grayCS ColorSpace.  Cache references to any computed LUT in a Map.
     */
    static short[] getLinearGray16ToOtherGray16LUT(ICC_ColorSpace grayCS) {
<span class="nc bnc" id="L1936" title="All 2 branches missed.">        if (lg16Toog16Map != null) {</span>
<span class="nc" id="L1937">            short[] lg16Toog16LUT = lg16Toog16Map.get(grayCS);</span>
<span class="nc bnc" id="L1938" title="All 2 branches missed.">            if (lg16Toog16LUT != null) {</span>
<span class="nc" id="L1939">                return lg16Toog16LUT;</span>
            }
        }
<span class="nc" id="L1942">        short[] tmp = new short[65536];</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">        for (int i = 0; i &lt;= 65535; i++) {</span>
<span class="nc" id="L1944">            tmp[i] = (short) i;</span>
        }
<span class="nc" id="L1946">        ColorTransform[] transformList = new ColorTransform[2];</span>
<span class="nc" id="L1947">        PCMM mdl = CMSManager.getModule();</span>
<span class="nc" id="L1948">        ICC_ColorSpace lgCS =</span>
<span class="nc" id="L1949">            (ICC_ColorSpace) ColorSpace.getInstance(ColorSpace.CS_GRAY);</span>
<span class="nc" id="L1950">        transformList[0] = mdl.createTransform (</span>
<span class="nc" id="L1951">            lgCS.getProfile(), ColorTransform.Any, ColorTransform.In);</span>
<span class="nc" id="L1952">        transformList[1] = mdl.createTransform(</span>
<span class="nc" id="L1953">            grayCS.getProfile(), ColorTransform.Any, ColorTransform.Out);</span>
<span class="nc" id="L1954">        ColorTransform t = mdl.createTransform(</span>
            transformList);
<span class="nc" id="L1956">        short[] lg16Toog16LUT = t.colorConvert(tmp, null);</span>
<span class="nc bnc" id="L1957" title="All 2 branches missed.">        if (lg16Toog16Map == null) {</span>
<span class="nc" id="L1958">            lg16Toog16Map = Collections.synchronizedMap(new WeakHashMap&lt;ICC_ColorSpace, short[]&gt;(2));</span>
        }
<span class="nc" id="L1960">        lg16Toog16Map.put(grayCS, lg16Toog16LUT);</span>
<span class="nc" id="L1961">        return lg16Toog16LUT;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>