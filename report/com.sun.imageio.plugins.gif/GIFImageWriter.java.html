<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>GIFImageWriter.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.imageio.plugins.gif</a> &gt; <span class="el_source">GIFImageWriter.java</span></div><h1>GIFImageWriter.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.imageio.plugins.gif;

import java.awt.Dimension;
import java.awt.Rectangle;
import java.awt.image.ColorModel;
import java.awt.image.ComponentSampleModel;
import java.awt.image.DataBufferByte;
import java.awt.image.IndexColorModel;
import java.awt.image.Raster;
import java.awt.image.RenderedImage;
import java.awt.image.SampleModel;
import java.awt.image.WritableRaster;
import java.io.IOException;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.Iterator;
import java.util.Locale;
import javax.imageio.IIOException;
import javax.imageio.IIOImage;
import javax.imageio.ImageTypeSpecifier;
import javax.imageio.ImageWriteParam;
import javax.imageio.ImageWriter;
import javax.imageio.spi.ImageWriterSpi;
import javax.imageio.metadata.IIOInvalidTreeException;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.metadata.IIOMetadataFormatImpl;
import javax.imageio.metadata.IIOMetadataNode;
import javax.imageio.stream.ImageOutputStream;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import com.sun.imageio.plugins.common.LZWCompressor;
import com.sun.imageio.plugins.common.PaletteBuilder;
import sun.awt.image.ByteComponentRaster;

public class GIFImageWriter extends ImageWriter {
    private static final boolean DEBUG = false; // XXX false for release!

    static final String STANDARD_METADATA_NAME =
    IIOMetadataFormatImpl.standardMetadataFormatName;

    static final String STREAM_METADATA_NAME =
    GIFWritableStreamMetadata.NATIVE_FORMAT_NAME;

    static final String IMAGE_METADATA_NAME =
    GIFWritableImageMetadata.NATIVE_FORMAT_NAME;

    /**
     * The &lt;code&gt;output&lt;/code&gt; case to an &lt;code&gt;ImageOutputStream&lt;/code&gt;.
     */
<span class="nc" id="L75">    private ImageOutputStream stream = null;</span>

    /**
     * Whether a sequence is being written.
     */
<span class="nc" id="L80">    private boolean isWritingSequence = false;</span>

    /**
     * Whether the header has been written.
     */
<span class="nc" id="L85">    private boolean wroteSequenceHeader = false;</span>

    /**
     * The stream metadata of a sequence.
     */
<span class="nc" id="L90">    private GIFWritableStreamMetadata theStreamMetadata = null;</span>

    /**
     * The index of the image being written.
     */
<span class="nc" id="L95">    private int imageIndex = 0;</span>

    /**
     * The number of bits represented by the value which should be a
     * legal length for a color table.
     */
    private static int getNumBits(int value) throws IOException {
        int numBits;
<span class="nc bnc" id="L103" title="All 9 branches missed.">        switch(value) {</span>
        case 2:
<span class="nc" id="L105">            numBits = 1;</span>
<span class="nc" id="L106">            break;</span>
        case 4:
<span class="nc" id="L108">            numBits = 2;</span>
<span class="nc" id="L109">            break;</span>
        case 8:
<span class="nc" id="L111">            numBits = 3;</span>
<span class="nc" id="L112">            break;</span>
        case 16:
<span class="nc" id="L114">            numBits = 4;</span>
<span class="nc" id="L115">            break;</span>
        case 32:
<span class="nc" id="L117">            numBits = 5;</span>
<span class="nc" id="L118">            break;</span>
        case 64:
<span class="nc" id="L120">            numBits = 6;</span>
<span class="nc" id="L121">            break;</span>
        case 128:
<span class="nc" id="L123">            numBits = 7;</span>
<span class="nc" id="L124">            break;</span>
        case 256:
<span class="nc" id="L126">            numBits = 8;</span>
<span class="nc" id="L127">            break;</span>
        default:
<span class="nc" id="L129">            throw new IOException(&quot;Bad palette length: &quot;+value+&quot;!&quot;);</span>
        }

<span class="nc" id="L132">        return numBits;</span>
    }

    /**
     * Compute the source region and destination dimensions taking any
     * parameter settings into account.
     */
    private static void computeRegions(Rectangle sourceBounds,
                                       Dimension destSize,
                                       ImageWriteParam p) {
        ImageWriteParam param;
<span class="nc" id="L143">        int periodX = 1;</span>
<span class="nc" id="L144">        int periodY = 1;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (p != null) {</span>
<span class="nc" id="L146">            int[] sourceBands = p.getSourceBands();</span>
<span class="nc bnc" id="L147" title="All 6 branches missed.">            if (sourceBands != null &amp;&amp;</span>
                (sourceBands.length != 1 ||
                 sourceBands[0] != 0)) {
<span class="nc" id="L150">                throw new IllegalArgumentException(&quot;Cannot sub-band image!&quot;);</span>
            }

            // Get source region and subsampling factors
<span class="nc" id="L154">            Rectangle sourceRegion = p.getSourceRegion();</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (sourceRegion != null) {</span>
                // Clip to actual image bounds
<span class="nc" id="L157">                sourceRegion = sourceRegion.intersection(sourceBounds);</span>
<span class="nc" id="L158">                sourceBounds.setBounds(sourceRegion);</span>
            }

            // Adjust for subsampling offsets
<span class="nc" id="L162">            int gridX = p.getSubsamplingXOffset();</span>
<span class="nc" id="L163">            int gridY = p.getSubsamplingYOffset();</span>
<span class="nc" id="L164">            sourceBounds.x += gridX;</span>
<span class="nc" id="L165">            sourceBounds.y += gridY;</span>
<span class="nc" id="L166">            sourceBounds.width -= gridX;</span>
<span class="nc" id="L167">            sourceBounds.height -= gridY;</span>

            // Get subsampling factors
<span class="nc" id="L170">            periodX = p.getSourceXSubsampling();</span>
<span class="nc" id="L171">            periodY = p.getSourceYSubsampling();</span>
        }

        // Compute output dimensions
<span class="nc" id="L175">        destSize.setSize((sourceBounds.width + periodX - 1)/periodX,</span>
                         (sourceBounds.height + periodY - 1)/periodY);
<span class="nc bnc" id="L177" title="All 4 branches missed.">        if (destSize.width &lt;= 0 || destSize.height &lt;= 0) {</span>
<span class="nc" id="L178">            throw new IllegalArgumentException(&quot;Empty source region!&quot;);</span>
        }
<span class="nc" id="L180">    }</span>

    /**
     * Create a color table from the image ColorModel and SampleModel.
     */
    private static byte[] createColorTable(ColorModel colorModel,
                                           SampleModel sampleModel)
    {
        byte[] colorTable;
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (colorModel instanceof IndexColorModel) {</span>
<span class="nc" id="L190">            IndexColorModel icm = (IndexColorModel)colorModel;</span>
<span class="nc" id="L191">            int mapSize = icm.getMapSize();</span>

            /**
             * The GIF image format assumes that size of image palette
             * is power of two. We will use closest larger power of two
             * as size of color table.
             */
<span class="nc" id="L198">            int ctSize = getGifPaletteSize(mapSize);</span>

<span class="nc" id="L200">            byte[] reds = new byte[ctSize];</span>
<span class="nc" id="L201">            byte[] greens = new byte[ctSize];</span>
<span class="nc" id="L202">            byte[] blues = new byte[ctSize];</span>
<span class="nc" id="L203">            icm.getReds(reds);</span>
<span class="nc" id="L204">            icm.getGreens(greens);</span>
<span class="nc" id="L205">            icm.getBlues(blues);</span>

            /**
             * fill tail of color component arrays by replica of first color
             * in order to avoid appearance of extra colors in the color table
             */
<span class="nc bnc" id="L211" title="All 2 branches missed.">            for (int i = mapSize; i &lt; ctSize; i++) {</span>
<span class="nc" id="L212">                reds[i] = reds[0];</span>
<span class="nc" id="L213">                greens[i] = greens[0];</span>
<span class="nc" id="L214">                blues[i] = blues[0];</span>
            }

<span class="nc" id="L217">            colorTable = new byte[3*ctSize];</span>
<span class="nc" id="L218">            int idx = 0;</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            for (int i = 0; i &lt; ctSize; i++) {</span>
<span class="nc" id="L220">                colorTable[idx++] = reds[i];</span>
<span class="nc" id="L221">                colorTable[idx++] = greens[i];</span>
<span class="nc" id="L222">                colorTable[idx++] = blues[i];</span>
            }
<span class="nc bnc" id="L224" title="All 2 branches missed.">        } else if (sampleModel.getNumBands() == 1) {</span>
            // create gray-scaled color table for single-banded images
<span class="nc" id="L226">            int numBits = sampleModel.getSampleSize()[0];</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (numBits &gt; 8) {</span>
<span class="nc" id="L228">                numBits = 8;</span>
            }
<span class="nc" id="L230">            int colorTableLength = 3*(1 &lt;&lt; numBits);</span>
<span class="nc" id="L231">            colorTable = new byte[colorTableLength];</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">            for (int i = 0; i &lt; colorTableLength; i++) {</span>
<span class="nc" id="L233">                colorTable[i] = (byte)(i/3);</span>
            }
<span class="nc" id="L235">        } else {</span>
            // We do not have enough information here
            // to create well-fit color table for RGB image.
<span class="nc" id="L238">            colorTable = null;</span>
        }

<span class="nc" id="L241">        return colorTable;</span>
    }

    /**
     * According do GIF specification size of clor table (palette here)
     * must be in range from 2 to 256 and must be power of 2.
     */
    private static int getGifPaletteSize(int x) {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (x &lt;= 2) {</span>
<span class="nc" id="L250">            return 2;</span>
        }
<span class="nc" id="L252">        x = x - 1;</span>
<span class="nc" id="L253">        x = x | (x &gt;&gt; 1);</span>
<span class="nc" id="L254">        x = x | (x &gt;&gt; 2);</span>
<span class="nc" id="L255">        x = x | (x &gt;&gt; 4);</span>
<span class="nc" id="L256">        x = x | (x &gt;&gt; 8);</span>
<span class="nc" id="L257">        x = x | (x &gt;&gt; 16);</span>
<span class="nc" id="L258">        return x + 1;</span>
    }



    public GIFImageWriter(GIFImageWriterSpi originatingProvider) {
<span class="nc" id="L264">        super(originatingProvider);</span>
        if (DEBUG) {
            System.err.println(&quot;GIF Writer is created&quot;);
        }
<span class="nc" id="L268">    }</span>

    public boolean canWriteSequence() {
<span class="nc" id="L271">        return true;</span>
    }

    /**
     * Merges &lt;code&gt;inData&lt;/code&gt; into &lt;code&gt;outData&lt;/code&gt;. The supplied
     * metadata format name is attempted first and failing that the standard
     * metadata format name is attempted.
     */
    private void convertMetadata(String metadataFormatName,
                                 IIOMetadata inData,
                                 IIOMetadata outData) {
<span class="nc" id="L282">        String formatName = null;</span>

<span class="nc" id="L284">        String nativeFormatName = inData.getNativeMetadataFormatName();</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">        if (nativeFormatName != null &amp;&amp;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">            nativeFormatName.equals(metadataFormatName)) {</span>
<span class="nc" id="L287">            formatName = metadataFormatName;</span>
        } else {
<span class="nc" id="L289">            String[] extraFormatNames = inData.getExtraMetadataFormatNames();</span>

<span class="nc bnc" id="L291" title="All 2 branches missed.">            if (extraFormatNames != null) {</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">                for (int i = 0; i &lt; extraFormatNames.length; i++) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">                    if (extraFormatNames[i].equals(metadataFormatName)) {</span>
<span class="nc" id="L294">                        formatName = metadataFormatName;</span>
<span class="nc" id="L295">                        break;</span>
                    }
                }
            }
        }

<span class="nc bnc" id="L301" title="All 2 branches missed.">        if (formatName == null &amp;&amp;</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">            inData.isStandardMetadataFormatSupported()) {</span>
<span class="nc" id="L303">            formatName = STANDARD_METADATA_NAME;</span>
        }

<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (formatName != null) {</span>
            try {
<span class="nc" id="L308">                Node root = inData.getAsTree(formatName);</span>
<span class="nc" id="L309">                outData.mergeTree(formatName, root);</span>
<span class="nc" id="L310">            } catch(IIOInvalidTreeException e) {</span>
                // ignore
<span class="nc" id="L312">            }</span>
        }
<span class="nc" id="L314">    }</span>

    /**
     * Creates a default stream metadata object and merges in the
     * supplied metadata.
     */
    public IIOMetadata convertStreamMetadata(IIOMetadata inData,
                                             ImageWriteParam param) {
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (inData == null) {</span>
<span class="nc" id="L323">            throw new IllegalArgumentException(&quot;inData == null!&quot;);</span>
        }

<span class="nc" id="L326">        IIOMetadata sm = getDefaultStreamMetadata(param);</span>

<span class="nc" id="L328">        convertMetadata(STREAM_METADATA_NAME, inData, sm);</span>

<span class="nc" id="L330">        return sm;</span>
    }

    /**
     * Creates a default image metadata object and merges in the
     * supplied metadata.
     */
    public IIOMetadata convertImageMetadata(IIOMetadata inData,
                                            ImageTypeSpecifier imageType,
                                            ImageWriteParam param) {
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (inData == null) {</span>
<span class="nc" id="L341">            throw new IllegalArgumentException(&quot;inData == null!&quot;);</span>
        }
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (imageType == null) {</span>
<span class="nc" id="L344">            throw new IllegalArgumentException(&quot;imageType == null!&quot;);</span>
        }

<span class="nc" id="L347">        GIFWritableImageMetadata im =</span>
<span class="nc" id="L348">            (GIFWritableImageMetadata)getDefaultImageMetadata(imageType,</span>
                                                              param);

        // Save interlace flag state.

<span class="nc" id="L353">        boolean isProgressive = im.interlaceFlag;</span>

<span class="nc" id="L355">        convertMetadata(IMAGE_METADATA_NAME, inData, im);</span>

        // Undo change to interlace flag if not MODE_COPY_FROM_METADATA.

<span class="nc bnc" id="L359" title="All 4 branches missed.">        if (param != null &amp;&amp; param.canWriteProgressive() &amp;&amp;</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">            param.getProgressiveMode() != param.MODE_COPY_FROM_METADATA) {</span>
<span class="nc" id="L361">            im.interlaceFlag = isProgressive;</span>
        }

<span class="nc" id="L364">        return im;</span>
    }

    public void endWriteSequence() throws IOException {
<span class="nc bnc" id="L368" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L369">            throw new IllegalStateException(&quot;output == null!&quot;);</span>
        }
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (!isWritingSequence) {</span>
<span class="nc" id="L372">            throw new IllegalStateException(&quot;prepareWriteSequence() was not invoked!&quot;);</span>
        }
<span class="nc" id="L374">        writeTrailer();</span>
<span class="nc" id="L375">        resetLocal();</span>
<span class="nc" id="L376">    }</span>

    public IIOMetadata getDefaultImageMetadata(ImageTypeSpecifier imageType,
                                               ImageWriteParam param) {
<span class="nc" id="L380">        GIFWritableImageMetadata imageMetadata =</span>
            new GIFWritableImageMetadata();

        // Image dimensions

<span class="nc" id="L385">        SampleModel sampleModel = imageType.getSampleModel();</span>

<span class="nc" id="L387">        Rectangle sourceBounds = new Rectangle(sampleModel.getWidth(),</span>
<span class="nc" id="L388">                                               sampleModel.getHeight());</span>
<span class="nc" id="L389">        Dimension destSize = new Dimension();</span>
<span class="nc" id="L390">        computeRegions(sourceBounds, destSize, param);</span>

<span class="nc" id="L392">        imageMetadata.imageWidth = destSize.width;</span>
<span class="nc" id="L393">        imageMetadata.imageHeight = destSize.height;</span>

        // Interlacing

<span class="nc bnc" id="L397" title="All 4 branches missed.">        if (param != null &amp;&amp; param.canWriteProgressive() &amp;&amp;</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">            param.getProgressiveMode() == ImageWriteParam.MODE_DISABLED) {</span>
<span class="nc" id="L399">            imageMetadata.interlaceFlag = false;</span>
        } else {
<span class="nc" id="L401">            imageMetadata.interlaceFlag = true;</span>
        }

        // Local color table

<span class="nc" id="L406">        ColorModel colorModel = imageType.getColorModel();</span>

<span class="nc" id="L408">        imageMetadata.localColorTable =</span>
<span class="nc" id="L409">            createColorTable(colorModel, sampleModel);</span>

        // Transparency

<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (colorModel instanceof IndexColorModel) {</span>
<span class="nc" id="L414">            int transparentIndex =</span>
<span class="nc" id="L415">                ((IndexColorModel)colorModel).getTransparentPixel();</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">            if (transparentIndex != -1) {</span>
<span class="nc" id="L417">                imageMetadata.transparentColorFlag = true;</span>
<span class="nc" id="L418">                imageMetadata.transparentColorIndex = transparentIndex;</span>
            }
        }

<span class="nc" id="L422">        return imageMetadata;</span>
    }

    public IIOMetadata getDefaultStreamMetadata(ImageWriteParam param) {
<span class="nc" id="L426">        GIFWritableStreamMetadata streamMetadata =</span>
            new GIFWritableStreamMetadata();
<span class="nc" id="L428">        streamMetadata.version = &quot;89a&quot;;</span>
<span class="nc" id="L429">        return streamMetadata;</span>
    }

    public ImageWriteParam getDefaultWriteParam() {
<span class="nc" id="L433">        return new GIFImageWriteParam(getLocale());</span>
    }

    public void prepareWriteSequence(IIOMetadata streamMetadata)
      throws IOException {

<span class="nc bnc" id="L439" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L440">            throw new IllegalStateException(&quot;Output is not set.&quot;);</span>
        }

<span class="nc" id="L443">        resetLocal();</span>

        // Save the possibly converted stream metadata as an instance variable.
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (streamMetadata == null) {</span>
<span class="nc" id="L447">            this.theStreamMetadata =</span>
<span class="nc" id="L448">                (GIFWritableStreamMetadata)getDefaultStreamMetadata(null);</span>
        } else {
<span class="nc" id="L450">            this.theStreamMetadata = new GIFWritableStreamMetadata();</span>
<span class="nc" id="L451">            convertMetadata(STREAM_METADATA_NAME, streamMetadata,</span>
                            theStreamMetadata);
        }

<span class="nc" id="L455">        this.isWritingSequence = true;</span>
<span class="nc" id="L456">    }</span>

    public void reset() {
<span class="nc" id="L459">        super.reset();</span>
<span class="nc" id="L460">        resetLocal();</span>
<span class="nc" id="L461">    }</span>

    /**
     * Resets locally defined instance variables.
     */
    private void resetLocal() {
<span class="nc" id="L467">        this.isWritingSequence = false;</span>
<span class="nc" id="L468">        this.wroteSequenceHeader = false;</span>
<span class="nc" id="L469">        this.theStreamMetadata = null;</span>
<span class="nc" id="L470">        this.imageIndex = 0;</span>
<span class="nc" id="L471">    }</span>

    public void setOutput(Object output) {
<span class="nc" id="L474">        super.setOutput(output);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">        if (output != null) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">            if (!(output instanceof ImageOutputStream)) {</span>
<span class="nc" id="L477">                throw new</span>
                    IllegalArgumentException(&quot;output is not an ImageOutputStream&quot;);
            }
<span class="nc" id="L480">            this.stream = (ImageOutputStream)output;</span>
<span class="nc" id="L481">            this.stream.setByteOrder(ByteOrder.LITTLE_ENDIAN);</span>
        } else {
<span class="nc" id="L483">            this.stream = null;</span>
        }
<span class="nc" id="L485">    }</span>

    public void write(IIOMetadata sm,
                      IIOImage iioimage,
                      ImageWriteParam p) throws IOException {
<span class="nc bnc" id="L490" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L491">            throw new IllegalStateException(&quot;output == null!&quot;);</span>
        }
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (iioimage == null) {</span>
<span class="nc" id="L494">            throw new IllegalArgumentException(&quot;iioimage == null!&quot;);</span>
        }
<span class="nc bnc" id="L496" title="All 2 branches missed.">        if (iioimage.hasRaster()) {</span>
<span class="nc" id="L497">            throw new UnsupportedOperationException(&quot;canWriteRasters() == false!&quot;);</span>
        }

<span class="nc" id="L500">        resetLocal();</span>

        GIFWritableStreamMetadata streamMetadata;
<span class="nc bnc" id="L503" title="All 2 branches missed.">        if (sm == null) {</span>
<span class="nc" id="L504">            streamMetadata =</span>
<span class="nc" id="L505">                (GIFWritableStreamMetadata)getDefaultStreamMetadata(p);</span>
        } else {
<span class="nc" id="L507">            streamMetadata =</span>
<span class="nc" id="L508">                (GIFWritableStreamMetadata)convertStreamMetadata(sm, p);</span>
        }

<span class="nc" id="L511">        write(true, true, streamMetadata, iioimage, p);</span>
<span class="nc" id="L512">    }</span>

    public void writeToSequence(IIOImage image, ImageWriteParam param)
      throws IOException {
<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L517">            throw new IllegalStateException(&quot;output == null!&quot;);</span>
        }
<span class="nc bnc" id="L519" title="All 2 branches missed.">        if (image == null) {</span>
<span class="nc" id="L520">            throw new IllegalArgumentException(&quot;image == null!&quot;);</span>
        }
<span class="nc bnc" id="L522" title="All 2 branches missed.">        if (image.hasRaster()) {</span>
<span class="nc" id="L523">            throw new UnsupportedOperationException(&quot;canWriteRasters() == false!&quot;);</span>
        }
<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (!isWritingSequence) {</span>
<span class="nc" id="L526">            throw new IllegalStateException(&quot;prepareWriteSequence() was not invoked!&quot;);</span>
        }

<span class="nc bnc" id="L529" title="All 2 branches missed.">        write(!wroteSequenceHeader, false, theStreamMetadata,</span>
              image, param);

<span class="nc bnc" id="L532" title="All 2 branches missed.">        if (!wroteSequenceHeader) {</span>
<span class="nc" id="L533">            wroteSequenceHeader = true;</span>
        }

<span class="nc" id="L536">        this.imageIndex++;</span>
<span class="nc" id="L537">    }</span>


    private boolean needToCreateIndex(RenderedImage image) {

<span class="nc" id="L542">        SampleModel sampleModel = image.getSampleModel();</span>
<span class="nc" id="L543">        ColorModel colorModel = image.getColorModel();</span>

<span class="nc bnc" id="L545" title="All 2 branches missed.">        return sampleModel.getNumBands() != 1 ||</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            sampleModel.getSampleSize()[0] &gt; 8 ||</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">            colorModel.getComponentSize()[0] &gt; 8;</span>
    }

    /**
     * Writes any extension blocks, the Image Descriptor, the image data,
     * and optionally the header (Signature and Logical Screen Descriptor)
     * and trailer (Block Terminator).
     *
     * @param writeHeader Whether to write the header.
     * @param writeTrailer Whether to write the trailer.
     * @param sm The stream metadata or &lt;code&gt;null&lt;/code&gt; if
     * &lt;code&gt;writeHeader&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.
     * @param iioimage The image and image metadata.
     * @param p The write parameters.
     *
     * @throws IllegalArgumentException if the number of bands is not 1.
     * @throws IllegalArgumentException if the number of bits per sample is
     * greater than 8.
     * @throws IllegalArgumentException if the color component size is
     * greater than 8.
     * @throws IllegalArgumentException if &lt;code&gt;writeHeader&lt;/code&gt; is
     * &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;sm&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     * @throws IllegalArgumentException if &lt;code&gt;writeHeader&lt;/code&gt; is
     * &lt;code&gt;false&lt;/code&gt; and a sequence is not being written.
     */
    private void write(boolean writeHeader,
                       boolean writeTrailer,
                       IIOMetadata sm,
                       IIOImage iioimage,
                       ImageWriteParam p) throws IOException {
<span class="nc" id="L577">        clearAbortRequest();</span>

<span class="nc" id="L579">        RenderedImage image = iioimage.getRenderedImage();</span>

        // Check for ability to encode image.
<span class="nc bnc" id="L582" title="All 2 branches missed.">        if (needToCreateIndex(image)) {</span>
<span class="nc" id="L583">            image = PaletteBuilder.createIndexedImage(image);</span>
<span class="nc" id="L584">            iioimage.setRenderedImage(image);</span>
        }

<span class="nc" id="L587">        ColorModel colorModel = image.getColorModel();</span>
<span class="nc" id="L588">        SampleModel sampleModel = image.getSampleModel();</span>

        // Determine source region and destination dimensions.
<span class="nc" id="L591">        Rectangle sourceBounds = new Rectangle(image.getMinX(),</span>
<span class="nc" id="L592">                                               image.getMinY(),</span>
<span class="nc" id="L593">                                               image.getWidth(),</span>
<span class="nc" id="L594">                                               image.getHeight());</span>
<span class="nc" id="L595">        Dimension destSize = new Dimension();</span>
<span class="nc" id="L596">        computeRegions(sourceBounds, destSize, p);</span>

        // Convert any provided image metadata.
<span class="nc" id="L599">        GIFWritableImageMetadata imageMetadata = null;</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if (iioimage.getMetadata() != null) {</span>
<span class="nc" id="L601">            imageMetadata = new GIFWritableImageMetadata();</span>
<span class="nc" id="L602">            convertMetadata(IMAGE_METADATA_NAME, iioimage.getMetadata(),</span>
                            imageMetadata);
            // Converted rgb image can use palette different from global.
            // In order to avoid color artefacts we want to be sure we use
            // appropriate palette. For this we initialize local color table
            // from current color and sample models.
            // At this point we can guarantee that local color table can be
            // build because image was already converted to indexed or
            // gray-scale representations
<span class="nc bnc" id="L611" title="All 2 branches missed.">            if (imageMetadata.localColorTable == null) {</span>
<span class="nc" id="L612">                imageMetadata.localColorTable =</span>
<span class="nc" id="L613">                    createColorTable(colorModel, sampleModel);</span>

                // in case of indexed image we should take care of
                // transparent pixels
<span class="nc bnc" id="L617" title="All 2 branches missed.">                if (colorModel instanceof IndexColorModel) {</span>
<span class="nc" id="L618">                    IndexColorModel icm =</span>
                        (IndexColorModel)colorModel;
<span class="nc" id="L620">                    int index = icm.getTransparentPixel();</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                    imageMetadata.transparentColorFlag = (index != -1);</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                    if (imageMetadata.transparentColorFlag) {</span>
<span class="nc" id="L623">                        imageMetadata.transparentColorIndex = index;</span>
                    }
                    /* NB: transparentColorFlag might have not beed reset for
                       greyscale images but explicitly reseting it here
                       is potentially not right thing to do until we have way
                       to find whether current value was explicitly set by
                       the user.
                    */
                }
            }
        }

        // Global color table values.
<span class="nc" id="L636">        byte[] globalColorTable = null;</span>

        // Write the header (Signature+Logical Screen Descriptor+
        // Global Color Table).
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (writeHeader) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (sm == null) {</span>
<span class="nc" id="L642">                throw new IllegalArgumentException(&quot;Cannot write null header!&quot;);</span>
            }

<span class="nc" id="L645">            GIFWritableStreamMetadata streamMetadata =</span>
                (GIFWritableStreamMetadata)sm;

            // Set the version if not set.
<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (streamMetadata.version == null) {</span>
<span class="nc" id="L650">                streamMetadata.version = &quot;89a&quot;;</span>
            }

            // Set the Logical Screen Desriptor if not set.
<span class="nc bnc" id="L654" title="All 2 branches missed.">            if (streamMetadata.logicalScreenWidth ==</span>
                GIFMetadata.UNDEFINED_INTEGER_VALUE)
            {
<span class="nc" id="L657">                streamMetadata.logicalScreenWidth = destSize.width;</span>
            }

<span class="nc bnc" id="L660" title="All 2 branches missed.">            if (streamMetadata.logicalScreenHeight ==</span>
                GIFMetadata.UNDEFINED_INTEGER_VALUE)
            {
<span class="nc" id="L663">                streamMetadata.logicalScreenHeight = destSize.height;</span>
            }

<span class="nc bnc" id="L666" title="All 2 branches missed.">            if (streamMetadata.colorResolution ==</span>
                GIFMetadata.UNDEFINED_INTEGER_VALUE)
            {
<span class="nc bnc" id="L669" title="All 2 branches missed.">                streamMetadata.colorResolution = colorModel != null ?</span>
<span class="nc" id="L670">                    colorModel.getComponentSize()[0] :</span>
<span class="nc" id="L671">                    sampleModel.getSampleSize()[0];</span>
            }

            // Set the Global Color Table if not set, i.e., if not
            // provided in the stream metadata.
<span class="nc bnc" id="L676" title="All 2 branches missed.">            if (streamMetadata.globalColorTable == null) {</span>
<span class="nc bnc" id="L677" title="All 6 branches missed.">                if (isWritingSequence &amp;&amp; imageMetadata != null &amp;&amp;</span>
                    imageMetadata.localColorTable != null) {
                    // Writing a sequence and a local color table was
                    // provided in the metadata of the first image: use it.
<span class="nc" id="L681">                    streamMetadata.globalColorTable =</span>
                        imageMetadata.localColorTable;
<span class="nc bnc" id="L683" title="All 4 branches missed.">                } else if (imageMetadata == null ||</span>
                           imageMetadata.localColorTable == null) {
                    // Create a color table.
<span class="nc" id="L686">                    streamMetadata.globalColorTable =</span>
<span class="nc" id="L687">                        createColorTable(colorModel, sampleModel);</span>
                }
            }

            // Set the Global Color Table. At this point it should be
            // A) the global color table provided in stream metadata, if any;
            // B) the local color table of the image metadata, if any, if
            //    writing a sequence;
            // C) a table created on the basis of the first image ColorModel
            //    and SampleModel if no local color table is available; or
            // D) null if none of the foregoing conditions obtain (which
            //    should only be if a sequence is not being written and
            //    a local color table is provided in image metadata).
<span class="nc" id="L700">            globalColorTable = streamMetadata.globalColorTable;</span>

            // Write the header.
            int bitsPerPixel;
<span class="nc bnc" id="L704" title="All 2 branches missed.">            if (globalColorTable != null) {</span>
<span class="nc" id="L705">                bitsPerPixel = getNumBits(globalColorTable.length/3);</span>
<span class="nc bnc" id="L706" title="All 4 branches missed.">            } else if (imageMetadata != null &amp;&amp;</span>
                       imageMetadata.localColorTable != null) {
<span class="nc" id="L708">                bitsPerPixel =</span>
<span class="nc" id="L709">                    getNumBits(imageMetadata.localColorTable.length/3);</span>
            } else {
<span class="nc" id="L711">                bitsPerPixel = sampleModel.getSampleSize(0);</span>
            }
<span class="nc" id="L713">            writeHeader(streamMetadata, bitsPerPixel);</span>
<span class="nc bnc" id="L714" title="All 2 branches missed.">        } else if (isWritingSequence) {</span>
<span class="nc" id="L715">            globalColorTable = theStreamMetadata.globalColorTable;</span>
        } else {
<span class="nc" id="L717">            throw new IllegalArgumentException(&quot;Must write header for single image!&quot;);</span>
        }

        // Write extension blocks, Image Descriptor, and image data.
<span class="nc" id="L721">        writeImage(iioimage.getRenderedImage(), imageMetadata, p,</span>
                   globalColorTable, sourceBounds, destSize);

        // Write the trailer.
<span class="nc bnc" id="L725" title="All 2 branches missed.">        if (writeTrailer) {</span>
<span class="nc" id="L726">            writeTrailer();</span>
        }
<span class="nc" id="L728">    }</span>

    /**
     * Writes any extension blocks, the Image Descriptor, and the image data
     *
     * @param iioimage The image and image metadata.
     * @param param The write parameters.
     * @param globalColorTable The Global Color Table.
     * @param sourceBounds The source region.
     * @param destSize The destination dimensions.
     */
    private void writeImage(RenderedImage image,
                            GIFWritableImageMetadata imageMetadata,
                            ImageWriteParam param, byte[] globalColorTable,
                            Rectangle sourceBounds, Dimension destSize)
      throws IOException {
<span class="nc" id="L744">        ColorModel colorModel = image.getColorModel();</span>
<span class="nc" id="L745">        SampleModel sampleModel = image.getSampleModel();</span>

        boolean writeGraphicsControlExtension;
<span class="nc bnc" id="L748" title="All 2 branches missed.">        if (imageMetadata == null) {</span>
            // Create default metadata.
<span class="nc" id="L750">            imageMetadata = (GIFWritableImageMetadata)getDefaultImageMetadata(</span>
                new ImageTypeSpecifier(image), param);

            // Set GraphicControlExtension flag only if there is
            // transparency.
<span class="nc" id="L755">            writeGraphicsControlExtension = imageMetadata.transparentColorFlag;</span>
        } else {
            // Check for GraphicControlExtension element.
<span class="nc" id="L758">            NodeList list = null;</span>
            try {
<span class="nc" id="L760">                IIOMetadataNode root = (IIOMetadataNode)</span>
<span class="nc" id="L761">                    imageMetadata.getAsTree(IMAGE_METADATA_NAME);</span>
<span class="nc" id="L762">                list = root.getElementsByTagName(&quot;GraphicControlExtension&quot;);</span>
<span class="nc" id="L763">            } catch(IllegalArgumentException iae) {</span>
                // Should never happen.
<span class="nc" id="L765">            }</span>

            // Set GraphicControlExtension flag if element present.
<span class="nc bnc" id="L768" title="All 2 branches missed.">            writeGraphicsControlExtension =</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                list != null &amp;&amp; list.getLength() &gt; 0;</span>

            // If progressive mode is not MODE_COPY_FROM_METADATA, ensure
            // the interlacing is set per the ImageWriteParam mode setting.
<span class="nc bnc" id="L773" title="All 4 branches missed.">            if (param != null &amp;&amp; param.canWriteProgressive()) {</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">                if (param.getProgressiveMode() ==</span>
                    ImageWriteParam.MODE_DISABLED) {
<span class="nc" id="L776">                    imageMetadata.interlaceFlag = false;</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                } else if (param.getProgressiveMode() ==</span>
                           ImageWriteParam.MODE_DEFAULT) {
<span class="nc" id="L779">                    imageMetadata.interlaceFlag = true;</span>
                }
            }
        }

        // Unset local color table if equal to global color table.
<span class="nc bnc" id="L785" title="All 2 branches missed.">        if (Arrays.equals(globalColorTable, imageMetadata.localColorTable)) {</span>
<span class="nc" id="L786">            imageMetadata.localColorTable = null;</span>
        }

        // Override dimensions
<span class="nc" id="L790">        imageMetadata.imageWidth = destSize.width;</span>
<span class="nc" id="L791">        imageMetadata.imageHeight = destSize.height;</span>

        // Write Graphics Control Extension.
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (writeGraphicsControlExtension) {</span>
<span class="nc" id="L795">            writeGraphicControlExtension(imageMetadata);</span>
        }

        // Write extension blocks.
<span class="nc" id="L799">        writePlainTextExtension(imageMetadata);</span>
<span class="nc" id="L800">        writeApplicationExtension(imageMetadata);</span>
<span class="nc" id="L801">        writeCommentExtension(imageMetadata);</span>

        // Write Image Descriptor
<span class="nc bnc" id="L804" title="All 4 branches missed.">        int bitsPerPixel =</span>
<span class="nc" id="L805">            getNumBits(imageMetadata.localColorTable == null ?</span>
                       (globalColorTable == null ?
<span class="nc" id="L807">                        sampleModel.getSampleSize(0) :</span>
                        globalColorTable.length/3) :
                       imageMetadata.localColorTable.length/3);
<span class="nc" id="L810">        writeImageDescriptor(imageMetadata, bitsPerPixel);</span>

        // Write image data
<span class="nc" id="L813">        writeRasterData(image, sourceBounds, destSize,</span>
                        param, imageMetadata.interlaceFlag);
<span class="nc" id="L815">    }</span>

    private void writeRows(RenderedImage image, LZWCompressor compressor,
                           int sx, int sdx, int sy, int sdy, int sw,
                           int dy, int ddy, int dw, int dh,
                           int numRowsWritten, int progressReportRowPeriod)
      throws IOException {
        if (DEBUG) System.out.println(&quot;Writing unoptimized&quot;);

<span class="nc" id="L824">        int[] sbuf = new int[sw];</span>
<span class="nc" id="L825">        byte[] dbuf = new byte[dw];</span>

<span class="nc" id="L827">        Raster raster =</span>
<span class="nc bnc" id="L828" title="All 4 branches missed.">            image.getNumXTiles() == 1 &amp;&amp; image.getNumYTiles() == 1 ?</span>
<span class="nc" id="L829">            image.getTile(0, 0) : image.getData();</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">        for (int y = dy; y &lt; dh; y += ddy) {</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">            if (numRowsWritten % progressReportRowPeriod == 0) {</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">                if (abortRequested()) {</span>
<span class="nc" id="L833">                    processWriteAborted();</span>
<span class="nc" id="L834">                    return;</span>
                }
<span class="nc" id="L836">                processImageProgress((numRowsWritten*100.0F)/dh);</span>
            }

<span class="nc" id="L839">            raster.getSamples(sx, sy, sw, 1, 0, sbuf);</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">            for (int i = 0, j = 0; i &lt; dw; i++, j += sdx) {</span>
<span class="nc" id="L841">                dbuf[i] = (byte)sbuf[j];</span>
            }
<span class="nc" id="L843">            compressor.compress(dbuf, 0, dw);</span>
<span class="nc" id="L844">            numRowsWritten++;</span>
<span class="nc" id="L845">            sy += sdy;</span>
        }
<span class="nc" id="L847">    }</span>

    private void writeRowsOpt(byte[] data, int offset, int lineStride,
                              LZWCompressor compressor,
                              int dy, int ddy, int dw, int dh,
                              int numRowsWritten, int progressReportRowPeriod)
      throws IOException {
        if (DEBUG) System.out.println(&quot;Writing optimized&quot;);

<span class="nc" id="L856">        offset += dy*lineStride;</span>
<span class="nc" id="L857">        lineStride *= ddy;</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        for (int y = dy; y &lt; dh; y += ddy) {</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">            if (numRowsWritten % progressReportRowPeriod == 0) {</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">                if (abortRequested()) {</span>
<span class="nc" id="L861">                    processWriteAborted();</span>
<span class="nc" id="L862">                    return;</span>
                }
<span class="nc" id="L864">                processImageProgress((numRowsWritten*100.0F)/dh);</span>
            }

<span class="nc" id="L867">            compressor.compress(data, offset, dw);</span>
<span class="nc" id="L868">            numRowsWritten++;</span>
<span class="nc" id="L869">            offset += lineStride;</span>
        }
<span class="nc" id="L871">    }</span>

    private void writeRasterData(RenderedImage image,
                                 Rectangle sourceBounds,
                                 Dimension destSize,
                                 ImageWriteParam param,
                                 boolean interlaceFlag) throws IOException {

<span class="nc" id="L879">        int sourceXOffset = sourceBounds.x;</span>
<span class="nc" id="L880">        int sourceYOffset = sourceBounds.y;</span>
<span class="nc" id="L881">        int sourceWidth = sourceBounds.width;</span>
<span class="nc" id="L882">        int sourceHeight = sourceBounds.height;</span>

<span class="nc" id="L884">        int destWidth = destSize.width;</span>
<span class="nc" id="L885">        int destHeight = destSize.height;</span>

        int periodX;
        int periodY;
<span class="nc bnc" id="L889" title="All 2 branches missed.">        if (param == null) {</span>
<span class="nc" id="L890">            periodX = 1;</span>
<span class="nc" id="L891">            periodY = 1;</span>
        } else {
<span class="nc" id="L893">            periodX = param.getSourceXSubsampling();</span>
<span class="nc" id="L894">            periodY = param.getSourceYSubsampling();</span>
        }

<span class="nc" id="L897">        SampleModel sampleModel = image.getSampleModel();</span>
<span class="nc" id="L898">        int bitsPerPixel = sampleModel.getSampleSize()[0];</span>

<span class="nc" id="L900">        int initCodeSize = bitsPerPixel;</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if (initCodeSize == 1) {</span>
<span class="nc" id="L902">            initCodeSize++;</span>
        }
<span class="nc" id="L904">        stream.write(initCodeSize);</span>

<span class="nc" id="L906">        LZWCompressor compressor =</span>
            new LZWCompressor(stream, initCodeSize, false);

        /* At this moment we know that input image is indexed image.
         * We can directly copy data iff:
         *   - no subsampling required (periodX = 1, periodY = 0)
         *   - we can access data directly (image is non-tiled,
         *     i.e. image data are in single block)
         *   - we can calculate offset in data buffer (next 3 lines)
         */
<span class="nc bnc" id="L916" title="All 4 branches missed.">        boolean isOptimizedCase =</span>
            periodX == 1 &amp;&amp; periodY == 1 &amp;&amp;
<span class="nc bnc" id="L918" title="All 6 branches missed.">            image.getNumXTiles() == 1 &amp;&amp; image.getNumYTiles() == 1 &amp;&amp;</span>
            sampleModel instanceof ComponentSampleModel &amp;&amp;
<span class="nc bnc" id="L920" title="All 2 branches missed.">            image.getTile(0, 0) instanceof ByteComponentRaster &amp;&amp;</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">            image.getTile(0, 0).getDataBuffer() instanceof DataBufferByte;</span>

<span class="nc" id="L923">        int numRowsWritten = 0;</span>

<span class="nc" id="L925">        int progressReportRowPeriod = Math.max(destHeight/20, 1);</span>

<span class="nc" id="L927">        processImageStarted(imageIndex);</span>

<span class="nc bnc" id="L929" title="All 2 branches missed.">        if (interlaceFlag) {</span>
            if (DEBUG) System.out.println(&quot;Writing interlaced&quot;);

<span class="nc bnc" id="L932" title="All 2 branches missed.">            if (isOptimizedCase) {</span>
<span class="nc" id="L933">                ByteComponentRaster tile =</span>
<span class="nc" id="L934">                    (ByteComponentRaster)image.getTile(0, 0);</span>
<span class="nc" id="L935">                byte[] data = ((DataBufferByte)tile.getDataBuffer()).getData();</span>
<span class="nc" id="L936">                ComponentSampleModel csm =</span>
<span class="nc" id="L937">                    (ComponentSampleModel)tile.getSampleModel();</span>
<span class="nc" id="L938">                int offset = csm.getOffset(sourceXOffset, sourceYOffset, 0);</span>
                // take into account the raster data offset
<span class="nc" id="L940">                offset += tile.getDataOffset(0);</span>
<span class="nc" id="L941">                int lineStride = csm.getScanlineStride();</span>

<span class="nc" id="L943">                writeRowsOpt(data, offset, lineStride, compressor,</span>
                             0, 8, destWidth, destHeight,
                             numRowsWritten, progressReportRowPeriod);

<span class="nc bnc" id="L947" title="All 2 branches missed.">                if (abortRequested()) {</span>
<span class="nc" id="L948">                    return;</span>
                }

<span class="nc" id="L951">                numRowsWritten += destHeight/8;</span>

<span class="nc" id="L953">                writeRowsOpt(data, offset, lineStride, compressor,</span>
                             4, 8, destWidth, destHeight,
                             numRowsWritten, progressReportRowPeriod);

<span class="nc bnc" id="L957" title="All 2 branches missed.">                if (abortRequested()) {</span>
<span class="nc" id="L958">                    return;</span>
                }

<span class="nc" id="L961">                numRowsWritten += (destHeight - 4)/8;</span>

<span class="nc" id="L963">                writeRowsOpt(data, offset, lineStride, compressor,</span>
                             2, 4, destWidth, destHeight,
                             numRowsWritten, progressReportRowPeriod);

<span class="nc bnc" id="L967" title="All 2 branches missed.">                if (abortRequested()) {</span>
<span class="nc" id="L968">                    return;</span>
                }

<span class="nc" id="L971">                numRowsWritten += (destHeight - 2)/4;</span>

<span class="nc" id="L973">                writeRowsOpt(data, offset, lineStride, compressor,</span>
                             1, 2, destWidth, destHeight,
                             numRowsWritten, progressReportRowPeriod);
<span class="nc" id="L976">            } else {</span>
<span class="nc" id="L977">                writeRows(image, compressor,</span>
                          sourceXOffset, periodX,
                          sourceYOffset, 8*periodY,
                          sourceWidth,
                          0, 8, destWidth, destHeight,
                          numRowsWritten, progressReportRowPeriod);

<span class="nc bnc" id="L984" title="All 2 branches missed.">                if (abortRequested()) {</span>
<span class="nc" id="L985">                    return;</span>
                }

<span class="nc" id="L988">                numRowsWritten += destHeight/8;</span>

<span class="nc" id="L990">                writeRows(image, compressor, sourceXOffset, periodX,</span>
                          sourceYOffset + 4*periodY, 8*periodY,
                          sourceWidth,
                          4, 8, destWidth, destHeight,
                          numRowsWritten, progressReportRowPeriod);

<span class="nc bnc" id="L996" title="All 2 branches missed.">                if (abortRequested()) {</span>
<span class="nc" id="L997">                    return;</span>
                }

<span class="nc" id="L1000">                numRowsWritten += (destHeight - 4)/8;</span>

<span class="nc" id="L1002">                writeRows(image, compressor, sourceXOffset, periodX,</span>
                          sourceYOffset + 2*periodY, 4*periodY,
                          sourceWidth,
                          2, 4, destWidth, destHeight,
                          numRowsWritten, progressReportRowPeriod);

<span class="nc bnc" id="L1008" title="All 2 branches missed.">                if (abortRequested()) {</span>
<span class="nc" id="L1009">                    return;</span>
                }

<span class="nc" id="L1012">                numRowsWritten += (destHeight - 2)/4;</span>

<span class="nc" id="L1014">                writeRows(image, compressor, sourceXOffset, periodX,</span>
                          sourceYOffset + periodY, 2*periodY,
                          sourceWidth,
                          1, 2, destWidth, destHeight,
                          numRowsWritten, progressReportRowPeriod);
            }
        } else {
            if (DEBUG) System.out.println(&quot;Writing non-interlaced&quot;);

<span class="nc bnc" id="L1023" title="All 2 branches missed.">            if (isOptimizedCase) {</span>
<span class="nc" id="L1024">                Raster tile = image.getTile(0, 0);</span>
<span class="nc" id="L1025">                byte[] data = ((DataBufferByte)tile.getDataBuffer()).getData();</span>
<span class="nc" id="L1026">                ComponentSampleModel csm =</span>
<span class="nc" id="L1027">                    (ComponentSampleModel)tile.getSampleModel();</span>
<span class="nc" id="L1028">                int offset = csm.getOffset(sourceXOffset, sourceYOffset, 0);</span>
<span class="nc" id="L1029">                int lineStride = csm.getScanlineStride();</span>

<span class="nc" id="L1031">                writeRowsOpt(data, offset, lineStride, compressor,</span>
                             0, 1, destWidth, destHeight,
                             numRowsWritten, progressReportRowPeriod);
<span class="nc" id="L1034">            } else {</span>
<span class="nc" id="L1035">                writeRows(image, compressor,</span>
                          sourceXOffset, periodX,
                          sourceYOffset, periodY,
                          sourceWidth,
                          0, 1, destWidth, destHeight,
                          numRowsWritten, progressReportRowPeriod);
            }
        }

<span class="nc bnc" id="L1044" title="All 2 branches missed.">        if (abortRequested()) {</span>
<span class="nc" id="L1045">            return;</span>
        }

<span class="nc" id="L1048">        processImageProgress(100.0F);</span>

<span class="nc" id="L1050">        compressor.flush();</span>

<span class="nc" id="L1052">        stream.write(0x00);</span>

<span class="nc" id="L1054">        processImageComplete();</span>
<span class="nc" id="L1055">    }</span>

    private void writeHeader(String version,
                             int logicalScreenWidth,
                             int logicalScreenHeight,
                             int colorResolution,
                             int pixelAspectRatio,
                             int backgroundColorIndex,
                             boolean sortFlag,
                             int bitsPerPixel,
                             byte[] globalColorTable) throws IOException {
        try {
            // Signature
<span class="nc" id="L1068">            stream.writeBytes(&quot;GIF&quot;+version);</span>

            // Screen Descriptor
            // Width
<span class="nc" id="L1072">            stream.writeShort((short)logicalScreenWidth);</span>

            // Height
<span class="nc" id="L1075">            stream.writeShort((short)logicalScreenHeight);</span>

            // Global Color Table
            // Packed fields
<span class="nc bnc" id="L1079" title="All 2 branches missed.">            int packedFields = globalColorTable != null ? 0x80 : 0x00;</span>
<span class="nc" id="L1080">            packedFields |= ((colorResolution - 1) &amp; 0x7) &lt;&lt; 4;</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">            if (sortFlag) {</span>
<span class="nc" id="L1082">                packedFields |= 0x8;</span>
            }
<span class="nc" id="L1084">            packedFields |= (bitsPerPixel - 1);</span>
<span class="nc" id="L1085">            stream.write(packedFields);</span>

            // Background color index
<span class="nc" id="L1088">            stream.write(backgroundColorIndex);</span>

            // Pixel aspect ratio
<span class="nc" id="L1091">            stream.write(pixelAspectRatio);</span>

            // Global Color Table
<span class="nc bnc" id="L1094" title="All 2 branches missed.">            if (globalColorTable != null) {</span>
<span class="nc" id="L1095">                stream.write(globalColorTable);</span>
            }
<span class="nc" id="L1097">        } catch (IOException e) {</span>
<span class="nc" id="L1098">            throw new IIOException(&quot;I/O error writing header!&quot;, e);</span>
<span class="nc" id="L1099">        }</span>
<span class="nc" id="L1100">    }</span>

    private void writeHeader(IIOMetadata streamMetadata, int bitsPerPixel)
      throws IOException {

        GIFWritableStreamMetadata sm;
<span class="nc bnc" id="L1106" title="All 2 branches missed.">        if (streamMetadata instanceof GIFWritableStreamMetadata) {</span>
<span class="nc" id="L1107">            sm = (GIFWritableStreamMetadata)streamMetadata;</span>
        } else {
<span class="nc" id="L1109">            sm = new GIFWritableStreamMetadata();</span>
<span class="nc" id="L1110">            Node root =</span>
<span class="nc" id="L1111">                streamMetadata.getAsTree(STREAM_METADATA_NAME);</span>
<span class="nc" id="L1112">            sm.setFromTree(STREAM_METADATA_NAME, root);</span>
        }

<span class="nc" id="L1115">        writeHeader(sm.version,</span>
                    sm.logicalScreenWidth,
                    sm.logicalScreenHeight,
                    sm.colorResolution,
                    sm.pixelAspectRatio,
                    sm.backgroundColorIndex,
                    sm.sortFlag,
                    bitsPerPixel,
                    sm.globalColorTable);
<span class="nc" id="L1124">    }</span>

    private void writeGraphicControlExtension(int disposalMethod,
                                              boolean userInputFlag,
                                              boolean transparentColorFlag,
                                              int delayTime,
                                              int transparentColorIndex)
      throws IOException {
        try {
<span class="nc" id="L1133">            stream.write(0x21);</span>
<span class="nc" id="L1134">            stream.write(0xf9);</span>

<span class="nc" id="L1136">            stream.write(4);</span>

<span class="nc" id="L1138">            int packedFields = (disposalMethod &amp; 0x3) &lt;&lt; 2;</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">            if (userInputFlag) {</span>
<span class="nc" id="L1140">                packedFields |= 0x2;</span>
            }
<span class="nc bnc" id="L1142" title="All 2 branches missed.">            if (transparentColorFlag) {</span>
<span class="nc" id="L1143">                packedFields |= 0x1;</span>
            }
<span class="nc" id="L1145">            stream.write(packedFields);</span>

<span class="nc" id="L1147">            stream.writeShort((short)delayTime);</span>

<span class="nc" id="L1149">            stream.write(transparentColorIndex);</span>
<span class="nc" id="L1150">            stream.write(0x00);</span>
<span class="nc" id="L1151">        } catch (IOException e) {</span>
<span class="nc" id="L1152">            throw new IIOException(&quot;I/O error writing Graphic Control Extension!&quot;, e);</span>
<span class="nc" id="L1153">        }</span>
<span class="nc" id="L1154">    }</span>

    private void writeGraphicControlExtension(GIFWritableImageMetadata im)
      throws IOException {
<span class="nc" id="L1158">        writeGraphicControlExtension(im.disposalMethod,</span>
                                     im.userInputFlag,
                                     im.transparentColorFlag,
                                     im.delayTime,
                                     im.transparentColorIndex);
<span class="nc" id="L1163">    }</span>

    private void writeBlocks(byte[] data) throws IOException {
<span class="nc bnc" id="L1166" title="All 4 branches missed.">        if (data != null &amp;&amp; data.length &gt; 0) {</span>
<span class="nc" id="L1167">            int offset = 0;</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">            while (offset &lt; data.length) {</span>
<span class="nc" id="L1169">                int len = Math.min(data.length - offset, 255);</span>
<span class="nc" id="L1170">                stream.write(len);</span>
<span class="nc" id="L1171">                stream.write(data, offset, len);</span>
<span class="nc" id="L1172">                offset += len;</span>
<span class="nc" id="L1173">            }</span>
        }
<span class="nc" id="L1175">    }</span>

    private void writePlainTextExtension(GIFWritableImageMetadata im)
      throws IOException {
<span class="nc bnc" id="L1179" title="All 2 branches missed.">        if (im.hasPlainTextExtension) {</span>
            try {
<span class="nc" id="L1181">                stream.write(0x21);</span>
<span class="nc" id="L1182">                stream.write(0x1);</span>

<span class="nc" id="L1184">                stream.write(12);</span>

<span class="nc" id="L1186">                stream.writeShort(im.textGridLeft);</span>
<span class="nc" id="L1187">                stream.writeShort(im.textGridTop);</span>
<span class="nc" id="L1188">                stream.writeShort(im.textGridWidth);</span>
<span class="nc" id="L1189">                stream.writeShort(im.textGridHeight);</span>
<span class="nc" id="L1190">                stream.write(im.characterCellWidth);</span>
<span class="nc" id="L1191">                stream.write(im.characterCellHeight);</span>
<span class="nc" id="L1192">                stream.write(im.textForegroundColor);</span>
<span class="nc" id="L1193">                stream.write(im.textBackgroundColor);</span>

<span class="nc" id="L1195">                writeBlocks(im.text);</span>

<span class="nc" id="L1197">                stream.write(0x00);</span>
<span class="nc" id="L1198">            } catch (IOException e) {</span>
<span class="nc" id="L1199">                throw new IIOException(&quot;I/O error writing Plain Text Extension!&quot;, e);</span>
<span class="nc" id="L1200">            }</span>
        }
<span class="nc" id="L1202">    }</span>

    private void writeApplicationExtension(GIFWritableImageMetadata im)
      throws IOException {
<span class="nc bnc" id="L1206" title="All 2 branches missed.">        if (im.applicationIDs != null) {</span>
<span class="nc" id="L1207">            Iterator iterIDs = im.applicationIDs.iterator();</span>
<span class="nc" id="L1208">            Iterator iterCodes = im.authenticationCodes.iterator();</span>
<span class="nc" id="L1209">            Iterator iterData = im.applicationData.iterator();</span>

<span class="nc bnc" id="L1211" title="All 2 branches missed.">            while (iterIDs.hasNext()) {</span>
                try {
<span class="nc" id="L1213">                    stream.write(0x21);</span>
<span class="nc" id="L1214">                    stream.write(0xff);</span>

<span class="nc" id="L1216">                    stream.write(11);</span>
<span class="nc" id="L1217">                    stream.write((byte[])iterIDs.next(), 0, 8);</span>
<span class="nc" id="L1218">                    stream.write((byte[])iterCodes.next(), 0, 3);</span>

<span class="nc" id="L1220">                    writeBlocks((byte[])iterData.next());</span>

<span class="nc" id="L1222">                    stream.write(0x00);</span>
<span class="nc" id="L1223">                } catch (IOException e) {</span>
<span class="nc" id="L1224">                    throw new IIOException(&quot;I/O error writing Application Extension!&quot;, e);</span>
<span class="nc" id="L1225">                }</span>
            }
        }
<span class="nc" id="L1228">    }</span>

    private void writeCommentExtension(GIFWritableImageMetadata im)
      throws IOException {
<span class="nc bnc" id="L1232" title="All 2 branches missed.">        if (im.comments != null) {</span>
            try {
<span class="nc" id="L1234">                Iterator iter = im.comments.iterator();</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">                while (iter.hasNext()) {</span>
<span class="nc" id="L1236">                    stream.write(0x21);</span>
<span class="nc" id="L1237">                    stream.write(0xfe);</span>
<span class="nc" id="L1238">                    writeBlocks((byte[])iter.next());</span>
<span class="nc" id="L1239">                    stream.write(0x00);</span>
                }
<span class="nc" id="L1241">            } catch (IOException e) {</span>
<span class="nc" id="L1242">                throw new IIOException(&quot;I/O error writing Comment Extension!&quot;, e);</span>
<span class="nc" id="L1243">            }</span>
        }
<span class="nc" id="L1245">    }</span>

    private void writeImageDescriptor(int imageLeftPosition,
                                      int imageTopPosition,
                                      int imageWidth,
                                      int imageHeight,
                                      boolean interlaceFlag,
                                      boolean sortFlag,
                                      int bitsPerPixel,
                                      byte[] localColorTable)
      throws IOException {

        try {
<span class="nc" id="L1258">            stream.write(0x2c);</span>

<span class="nc" id="L1260">            stream.writeShort((short)imageLeftPosition);</span>
<span class="nc" id="L1261">            stream.writeShort((short)imageTopPosition);</span>
<span class="nc" id="L1262">            stream.writeShort((short)imageWidth);</span>
<span class="nc" id="L1263">            stream.writeShort((short)imageHeight);</span>

<span class="nc bnc" id="L1265" title="All 2 branches missed.">            int packedFields = localColorTable != null ? 0x80 : 0x00;</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">            if (interlaceFlag) {</span>
<span class="nc" id="L1267">                packedFields |= 0x40;</span>
            }
<span class="nc bnc" id="L1269" title="All 2 branches missed.">            if (sortFlag) {</span>
<span class="nc" id="L1270">                packedFields |= 0x8;</span>
            }
<span class="nc" id="L1272">            packedFields |= (bitsPerPixel - 1);</span>
<span class="nc" id="L1273">            stream.write(packedFields);</span>

<span class="nc bnc" id="L1275" title="All 2 branches missed.">            if (localColorTable != null) {</span>
<span class="nc" id="L1276">                stream.write(localColorTable);</span>
            }
<span class="nc" id="L1278">        } catch (IOException e) {</span>
<span class="nc" id="L1279">            throw new IIOException(&quot;I/O error writing Image Descriptor!&quot;, e);</span>
<span class="nc" id="L1280">        }</span>
<span class="nc" id="L1281">    }</span>

    private void writeImageDescriptor(GIFWritableImageMetadata imageMetadata,
                                      int bitsPerPixel)
      throws IOException {

<span class="nc" id="L1287">        writeImageDescriptor(imageMetadata.imageLeftPosition,</span>
                             imageMetadata.imageTopPosition,
                             imageMetadata.imageWidth,
                             imageMetadata.imageHeight,
                             imageMetadata.interlaceFlag,
                             imageMetadata.sortFlag,
                             bitsPerPixel,
                             imageMetadata.localColorTable);
<span class="nc" id="L1295">    }</span>

    private void writeTrailer() throws IOException {
<span class="nc" id="L1298">        stream.write(0x3b);</span>
<span class="nc" id="L1299">    }</span>
}

class GIFImageWriteParam extends ImageWriteParam {
    GIFImageWriteParam(Locale locale) {
<span class="nc" id="L1304">        super(locale);</span>
<span class="nc" id="L1305">        this.canWriteCompressed = true;</span>
<span class="nc" id="L1306">        this.canWriteProgressive = true;</span>
<span class="nc" id="L1307">        this.compressionTypes = new String[] {&quot;LZW&quot;, &quot;lzw&quot;};</span>
<span class="nc" id="L1308">        this.compressionType = compressionTypes[0];</span>
<span class="nc" id="L1309">    }</span>

    public void setCompressionMode(int mode) {
<span class="nc bnc" id="L1312" title="All 2 branches missed.">        if (mode == MODE_DISABLED) {</span>
<span class="nc" id="L1313">            throw new UnsupportedOperationException(&quot;MODE_DISABLED is not supported.&quot;);</span>
        }
<span class="nc" id="L1315">        super.setCompressionMode(mode);</span>
<span class="nc" id="L1316">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>