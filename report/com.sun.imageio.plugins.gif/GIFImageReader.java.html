<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>GIFImageReader.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">com.sun.imageio.plugins.gif</a> &gt; <span class="el_source">GIFImageReader.java</span></div><h1>GIFImageReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package com.sun.imageio.plugins.gif;

import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.awt.image.DataBuffer;
import java.awt.image.WritableRaster;
import java.io.EOFException;
import java.io.IOException;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import javax.imageio.IIOException;
import javax.imageio.ImageReader;
import javax.imageio.ImageReadParam;
import javax.imageio.ImageTypeSpecifier;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.spi.ImageReaderSpi;
import javax.imageio.stream.ImageInputStream;
import com.sun.imageio.plugins.common.ReaderUtil;
import java.awt.image.ColorModel;
import java.awt.image.IndexColorModel;
import java.awt.image.MultiPixelPackedSampleModel;
import java.awt.image.PixelInterleavedSampleModel;
import java.awt.image.SampleModel;

public class GIFImageReader extends ImageReader {

    // The current ImageInputStream source.
<span class="nc" id="L56">    ImageInputStream stream = null;</span>

    // Per-stream settings

    // True if the file header including stream metadata has been read.
<span class="nc" id="L61">    boolean gotHeader = false;</span>

    // Global metadata, read once per input setting.
<span class="nc" id="L64">    GIFStreamMetadata streamMetadata = null;</span>

    // The current image index
<span class="nc" id="L67">    int currIndex = -1;</span>

    // Metadata for image at 'currIndex', or null.
<span class="nc" id="L70">    GIFImageMetadata imageMetadata = null;</span>

    // A List of Longs indicating the stream positions of the
    // start of the metadata for each image.  Entries are added
    // as needed.
<span class="nc" id="L75">    List imageStartPosition = new ArrayList();</span>

    // Length of metadata for image at 'currIndex', valid only if
    // imageMetadata != null.
    int imageMetadataLength;

    // The number of images in the stream, if known, otherwise -1.
<span class="nc" id="L82">    int numImages = -1;</span>

    // Variables used by the LZW decoding process
<span class="nc" id="L85">    byte[] block = new byte[255];</span>
<span class="nc" id="L86">    int blockLength = 0;</span>
<span class="nc" id="L87">    int bitPos = 0;</span>
<span class="nc" id="L88">    int nextByte = 0;</span>
    int initCodeSize;
    int clearCode;
    int eofCode;

    // 32-bit lookahead buffer
<span class="nc" id="L94">    int next32Bits = 0;</span>

    // Try if the end of the data blocks has been found,
    // and we are simply draining the 32-bit buffer
<span class="nc" id="L98">    boolean lastBlockFound = false;</span>

    // The image to be written.
<span class="nc" id="L101">    BufferedImage theImage = null;</span>

    // The image's tile.
<span class="nc" id="L104">    WritableRaster theTile = null;</span>

    // The image dimensions (from the stream).
<span class="nc" id="L107">    int width = -1, height = -1;</span>

    // The pixel currently being decoded (in the stream's coordinates).
<span class="nc" id="L110">    int streamX = -1, streamY = -1;</span>

    // The number of rows decoded
<span class="nc" id="L113">    int rowsDone = 0;</span>

    // The current interlace pass, starting with 0.
<span class="nc" id="L116">    int interlacePass = 0;</span>

<span class="nc" id="L118">    private byte[] fallbackColorTable = null;</span>

    // End per-stream settings

    // Constants used to control interlacing.
<span class="nc" id="L123">    static final int[] interlaceIncrement = { 8, 8, 4, 2, -1 };</span>
<span class="nc" id="L124">    static final int[] interlaceOffset = { 0, 4, 2, 1, -1 };</span>

    public GIFImageReader(ImageReaderSpi originatingProvider) {
<span class="nc" id="L127">        super(originatingProvider);</span>
<span class="nc" id="L128">    }</span>

    // Take input from an ImageInputStream
    public void setInput(Object input,
                         boolean seekForwardOnly,
                         boolean ignoreMetadata) {
<span class="nc" id="L134">        super.setInput(input, seekForwardOnly, ignoreMetadata);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">        if (input != null) {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">            if (!(input instanceof ImageInputStream)) {</span>
<span class="nc" id="L137">                throw new IllegalArgumentException</span>
                    (&quot;input not an ImageInputStream!&quot;);
            }
<span class="nc" id="L140">            this.stream = (ImageInputStream)input;</span>
        } else {
<span class="nc" id="L142">            this.stream = null;</span>
        }

        // Clear all values based on the previous stream contents
<span class="nc" id="L146">        resetStreamSettings();</span>
<span class="nc" id="L147">    }</span>

    public int getNumImages(boolean allowSearch) throws IIOException {
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L151">            throw new IllegalStateException(&quot;Input not set!&quot;);</span>
        }
<span class="nc bnc" id="L153" title="All 4 branches missed.">        if (seekForwardOnly &amp;&amp; allowSearch) {</span>
<span class="nc" id="L154">            throw new IllegalStateException</span>
                (&quot;seekForwardOnly and allowSearch can't both be true!&quot;);
        }

<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (numImages &gt; 0) {</span>
<span class="nc" id="L159">            return numImages;</span>
        }
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if (allowSearch) {</span>
<span class="nc" id="L162">            this.numImages = locateImage(Integer.MAX_VALUE) + 1;</span>
        }
<span class="nc" id="L164">        return numImages;</span>
    }

    // Throw an IndexOutOfBoundsException if index &lt; minIndex,
    // and bump minIndex if required.
    private void checkIndex(int imageIndex) {
<span class="nc bnc" id="L170" title="All 2 branches missed.">        if (imageIndex &lt; minIndex) {</span>
<span class="nc" id="L171">            throw new IndexOutOfBoundsException(&quot;imageIndex &lt; minIndex!&quot;);</span>
        }
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (seekForwardOnly) {</span>
<span class="nc" id="L174">            minIndex = imageIndex;</span>
        }
<span class="nc" id="L176">    }</span>

    public int getWidth(int imageIndex) throws IIOException {
<span class="nc" id="L179">        checkIndex(imageIndex);</span>

<span class="nc" id="L181">        int index = locateImage(imageIndex);</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">        if (index != imageIndex) {</span>
<span class="nc" id="L183">            throw new IndexOutOfBoundsException();</span>
        }
<span class="nc" id="L185">        readMetadata();</span>
<span class="nc" id="L186">        return imageMetadata.imageWidth;</span>
    }

    public int getHeight(int imageIndex) throws IIOException {
<span class="nc" id="L190">        checkIndex(imageIndex);</span>

<span class="nc" id="L192">        int index = locateImage(imageIndex);</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">        if (index != imageIndex) {</span>
<span class="nc" id="L194">            throw new IndexOutOfBoundsException();</span>
        }
<span class="nc" id="L196">        readMetadata();</span>
<span class="nc" id="L197">        return imageMetadata.imageHeight;</span>
    }

    // We don't check all parameters as ImageTypeSpecifier.createIndexed do
    // since this method is private and we pass consistent data here
    private ImageTypeSpecifier createIndexed(byte[] r, byte[] g, byte[] b,
                                             int bits) {
        ColorModel colorModel;
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (imageMetadata.transparentColorFlag) {</span>
            // Some files erroneously have a transparent color index
            // of 255 even though there are fewer than 256 colors.
<span class="nc" id="L208">            int idx = Math.min(imageMetadata.transparentColorIndex,</span>
                    r.length - 1);
<span class="nc" id="L210">            colorModel = new IndexColorModel(bits, r.length, r, g, b, idx);</span>
<span class="nc" id="L211">        } else {</span>
<span class="nc" id="L212">            colorModel = new IndexColorModel(bits, r.length, r, g, b);</span>
        }

        SampleModel sampleModel;
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if (bits == 8) {</span>
<span class="nc" id="L217">            int[] bandOffsets = {0};</span>
<span class="nc" id="L218">            sampleModel =</span>
                    new PixelInterleavedSampleModel(DataBuffer.TYPE_BYTE,
                    1, 1, 1, 1,
                    bandOffsets);
<span class="nc" id="L222">        } else {</span>
<span class="nc" id="L223">            sampleModel =</span>
                    new MultiPixelPackedSampleModel(DataBuffer.TYPE_BYTE,
                    1, 1, bits);
        }
<span class="nc" id="L227">        return new ImageTypeSpecifier(colorModel, sampleModel);</span>
    }

    public Iterator getImageTypes(int imageIndex) throws IIOException {
<span class="nc" id="L231">        checkIndex(imageIndex);</span>

<span class="nc" id="L233">        int index = locateImage(imageIndex);</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (index != imageIndex) {</span>
<span class="nc" id="L235">            throw new IndexOutOfBoundsException();</span>
        }
<span class="nc" id="L237">        readMetadata();</span>

<span class="nc" id="L239">        List l = new ArrayList(1);</span>

        byte[] colorTable;
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (imageMetadata.localColorTable != null) {</span>
<span class="nc" id="L243">            colorTable = imageMetadata.localColorTable;</span>
<span class="nc" id="L244">            fallbackColorTable = imageMetadata.localColorTable;</span>
        } else {
<span class="nc" id="L246">            colorTable = streamMetadata.globalColorTable;</span>
        }

<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (colorTable == null) {</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">            if (fallbackColorTable == null) {</span>
<span class="nc" id="L251">                this.processWarningOccurred(&quot;Use default color table.&quot;);</span>

                // no color table, the spec allows to use any palette.
<span class="nc" id="L254">                fallbackColorTable = getDefaultPalette();</span>
            }

<span class="nc" id="L257">            colorTable = fallbackColorTable;</span>
        }

        // Normalize color table length to 2^1, 2^2, 2^4, or 2^8
<span class="nc" id="L261">        int length = colorTable.length/3;</span>
        int bits;
<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (length == 2) {</span>
<span class="nc" id="L264">            bits = 1;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        } else if (length == 4) {</span>
<span class="nc" id="L266">            bits = 2;</span>
<span class="nc bnc" id="L267" title="All 4 branches missed.">        } else if (length == 8 || length == 16) {</span>
            // Bump from 3 to 4 bits
<span class="nc" id="L269">            bits = 4;</span>
        } else {
            // Bump to 8 bits
<span class="nc" id="L272">            bits = 8;</span>
        }
<span class="nc" id="L274">        int lutLength = 1 &lt;&lt; bits;</span>
<span class="nc" id="L275">        byte[] r = new byte[lutLength];</span>
<span class="nc" id="L276">        byte[] g = new byte[lutLength];</span>
<span class="nc" id="L277">        byte[] b = new byte[lutLength];</span>

        // Entries from length + 1 to lutLength - 1 will be 0
<span class="nc" id="L280">        int rgbIndex = 0;</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L282">            r[i] = colorTable[rgbIndex++];</span>
<span class="nc" id="L283">            g[i] = colorTable[rgbIndex++];</span>
<span class="nc" id="L284">            b[i] = colorTable[rgbIndex++];</span>
        }

<span class="nc" id="L287">        l.add(createIndexed(r, g, b, bits));</span>
<span class="nc" id="L288">        return l.iterator();</span>
    }

    public ImageReadParam getDefaultReadParam() {
<span class="nc" id="L292">        return new ImageReadParam();</span>
    }

    public IIOMetadata getStreamMetadata() throws IIOException {
<span class="nc" id="L296">        readHeader();</span>
<span class="nc" id="L297">        return streamMetadata;</span>
    }

    public IIOMetadata getImageMetadata(int imageIndex) throws IIOException {
<span class="nc" id="L301">        checkIndex(imageIndex);</span>

<span class="nc" id="L303">        int index = locateImage(imageIndex);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        if (index != imageIndex) {</span>
<span class="nc" id="L305">            throw new IndexOutOfBoundsException(&quot;Bad image index!&quot;);</span>
        }
<span class="nc" id="L307">        readMetadata();</span>
<span class="nc" id="L308">        return imageMetadata;</span>
    }

    // BEGIN LZW STUFF

    private void initNext32Bits() {
<span class="nc" id="L314">        next32Bits = block[0] &amp; 0xff;</span>
<span class="nc" id="L315">        next32Bits |= (block[1] &amp; 0xff) &lt;&lt; 8;</span>
<span class="nc" id="L316">        next32Bits |= (block[2] &amp; 0xff) &lt;&lt; 16;</span>
<span class="nc" id="L317">        next32Bits |= block[3] &lt;&lt; 24;</span>
<span class="nc" id="L318">        nextByte = 4;</span>
<span class="nc" id="L319">    }</span>

    // Load a block (1-255 bytes) at a time, and maintain
    // a 32-bit lookahead buffer that is filled from the left
    // and extracted from the right.
    //
    // When the last block is found, we continue to
    //
    private int getCode(int codeSize, int codeMask) throws IOException {
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (bitPos + codeSize &gt; 32) {</span>
<span class="nc" id="L329">            return eofCode; // No more data available</span>
        }

<span class="nc" id="L332">        int code = (next32Bits &gt;&gt; bitPos) &amp; codeMask;</span>
<span class="nc" id="L333">        bitPos += codeSize;</span>

        // Shift in a byte of new data at a time
<span class="nc bnc" id="L336" title="All 4 branches missed.">        while (bitPos &gt;= 8 &amp;&amp; !lastBlockFound) {</span>
<span class="nc" id="L337">            next32Bits &gt;&gt;&gt;= 8;</span>
<span class="nc" id="L338">            bitPos -= 8;</span>

            // Check if current block is out of bytes
<span class="nc bnc" id="L341" title="All 2 branches missed.">            if (nextByte &gt;= blockLength) {</span>
                // Get next block size
<span class="nc" id="L343">                blockLength = stream.readUnsignedByte();</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                if (blockLength == 0) {</span>
<span class="nc" id="L345">                    lastBlockFound = true;</span>
<span class="nc" id="L346">                    return code;</span>
                } else {
<span class="nc" id="L348">                    int left = blockLength;</span>
<span class="nc" id="L349">                    int off = 0;</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                    while (left &gt; 0) {</span>
<span class="nc" id="L351">                        int nbytes = stream.read(block, off, left);</span>
<span class="nc" id="L352">                        off += nbytes;</span>
<span class="nc" id="L353">                        left -= nbytes;</span>
<span class="nc" id="L354">                    }</span>
<span class="nc" id="L355">                    nextByte = 0;</span>
                }
            }

<span class="nc" id="L359">            next32Bits |= block[nextByte++] &lt;&lt; 24;</span>
        }

<span class="nc" id="L362">        return code;</span>
    }

    public void initializeStringTable(int[] prefix,
                                      byte[] suffix,
                                      byte[] initial,
                                      int[] length) {
<span class="nc" id="L369">        int numEntries = 1 &lt;&lt; initCodeSize;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">        for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L371">            prefix[i] = -1;</span>
<span class="nc" id="L372">            suffix[i] = (byte)i;</span>
<span class="nc" id="L373">            initial[i] = (byte)i;</span>
<span class="nc" id="L374">            length[i] = 1;</span>
        }

        // Fill in the entire table for robustness against
        // out-of-sequence codes.
<span class="nc bnc" id="L379" title="All 2 branches missed.">        for (int i = numEntries; i &lt; 4096; i++) {</span>
<span class="nc" id="L380">            prefix[i] = -1;</span>
<span class="nc" id="L381">            length[i] = 1;</span>
        }

        // tableIndex = numEntries + 2;
        // codeSize = initCodeSize + 1;
        // codeMask = (1 &lt;&lt; codeSize) - 1;
<span class="nc" id="L387">    }</span>

    Rectangle sourceRegion;
    int sourceXSubsampling;
    int sourceYSubsampling;
    int sourceMinProgressivePass;
    int sourceMaxProgressivePass;

    Point destinationOffset;
    Rectangle destinationRegion;

    // Used only if IIOReadUpdateListeners are present
    int updateMinY;
    int updateYStep;

<span class="nc" id="L402">    boolean decodeThisRow = true;</span>
<span class="nc" id="L403">    int destY = 0;</span>

    byte[] rowBuf;

    private void outputRow() {
        // Clip against ImageReadParam
<span class="nc" id="L409">        int width = Math.min(sourceRegion.width,</span>
                             destinationRegion.width*sourceXSubsampling);
<span class="nc" id="L411">        int destX = destinationRegion.x;</span>

<span class="nc bnc" id="L413" title="All 2 branches missed.">        if (sourceXSubsampling == 1) {</span>
<span class="nc" id="L414">            theTile.setDataElements(destX, destY, width, 1, rowBuf);</span>
        } else {
<span class="nc bnc" id="L416" title="All 2 branches missed.">            for (int x = 0; x &lt; width; x += sourceXSubsampling, destX++) {</span>
<span class="nc" id="L417">                theTile.setSample(destX, destY, 0, rowBuf[x] &amp; 0xff);</span>
            }
        }

        // Update IIOReadUpdateListeners, if any
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (updateListeners != null) {</span>
<span class="nc" id="L423">            int[] bands = { 0 };</span>
            // updateYStep will have been initialized if
            // updateListeners is non-null
<span class="nc" id="L426">            processImageUpdate(theImage,</span>
                               destX, destY,
                               width, 1, 1, updateYStep,
                               bands);
        }
<span class="nc" id="L431">    }</span>

    private void computeDecodeThisRow() {
<span class="nc bnc" id="L434" title="All 8 branches missed.">        this.decodeThisRow =</span>
            (destY &lt; destinationRegion.y + destinationRegion.height) &amp;&amp;
            (streamY &gt;= sourceRegion.y) &amp;&amp;
            (streamY &lt; sourceRegion.y + sourceRegion.height) &amp;&amp;
            (((streamY - sourceRegion.y) % sourceYSubsampling) == 0);
<span class="nc" id="L439">    }</span>

    private void outputPixels(byte[] string, int len) {
<span class="nc bnc" id="L442" title="All 4 branches missed.">        if (interlacePass &lt; sourceMinProgressivePass ||</span>
            interlacePass &gt; sourceMaxProgressivePass) {
<span class="nc" id="L444">            return;</span>
        }

<span class="nc bnc" id="L447" title="All 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (streamX &gt;= sourceRegion.x) {</span>
<span class="nc" id="L449">                rowBuf[streamX - sourceRegion.x] = string[i];</span>
            }

            // Process end-of-row
<span class="nc" id="L453">            ++streamX;</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">            if (streamX == width) {</span>
                // Update IIOReadProgressListeners
<span class="nc" id="L456">                ++rowsDone;</span>
<span class="nc" id="L457">                processImageProgress(100.0F*rowsDone/height);</span>

<span class="nc bnc" id="L459" title="All 2 branches missed.">                if (decodeThisRow) {</span>
<span class="nc" id="L460">                    outputRow();</span>
                }

<span class="nc" id="L463">                streamX = 0;</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                if (imageMetadata.interlaceFlag) {</span>
<span class="nc" id="L465">                    streamY += interlaceIncrement[interlacePass];</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                    if (streamY &gt;= height) {</span>
                        // Inform IIOReadUpdateListeners of end of pass
<span class="nc bnc" id="L468" title="All 2 branches missed.">                        if (updateListeners != null) {</span>
<span class="nc" id="L469">                            processPassComplete(theImage);</span>
                        }

<span class="nc" id="L472">                        ++interlacePass;</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                        if (interlacePass &gt; sourceMaxProgressivePass) {</span>
<span class="nc" id="L474">                            return;</span>
                        }
<span class="nc" id="L476">                        streamY = interlaceOffset[interlacePass];</span>
<span class="nc" id="L477">                        startPass(interlacePass);</span>
                    }
                } else {
<span class="nc" id="L480">                    ++streamY;</span>
                }

                // Determine whether pixels from this row will
                // be written to the destination
<span class="nc" id="L485">                this.destY = destinationRegion.y +</span>
                    (streamY - sourceRegion.y)/sourceYSubsampling;
<span class="nc" id="L487">                computeDecodeThisRow();</span>
            }
        }
<span class="nc" id="L490">    }</span>

    // END LZW STUFF

    private void readHeader() throws IIOException {
<span class="nc bnc" id="L495" title="All 2 branches missed.">        if (gotHeader) {</span>
<span class="nc" id="L496">            return;</span>
        }
<span class="nc bnc" id="L498" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L499">            throw new IllegalStateException(&quot;Input not set!&quot;);</span>
        }

        // Create an object to store the stream metadata
<span class="nc" id="L503">        this.streamMetadata = new GIFStreamMetadata();</span>

        try {
<span class="nc" id="L506">            stream.setByteOrder(ByteOrder.LITTLE_ENDIAN);</span>

<span class="nc" id="L508">            byte[] signature = new byte[6];</span>
<span class="nc" id="L509">            stream.readFully(signature);</span>

<span class="nc" id="L511">            StringBuffer version = new StringBuffer(3);</span>
<span class="nc" id="L512">            version.append((char)signature[3]);</span>
<span class="nc" id="L513">            version.append((char)signature[4]);</span>
<span class="nc" id="L514">            version.append((char)signature[5]);</span>
<span class="nc" id="L515">            streamMetadata.version = version.toString();</span>

<span class="nc" id="L517">            streamMetadata.logicalScreenWidth = stream.readUnsignedShort();</span>
<span class="nc" id="L518">            streamMetadata.logicalScreenHeight = stream.readUnsignedShort();</span>

<span class="nc" id="L520">            int packedFields = stream.readUnsignedByte();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">            boolean globalColorTableFlag = (packedFields &amp; 0x80) != 0;</span>
<span class="nc" id="L522">            streamMetadata.colorResolution = ((packedFields &gt;&gt; 4) &amp; 0x7) + 1;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">            streamMetadata.sortFlag = (packedFields &amp; 0x8) != 0;</span>
<span class="nc" id="L524">            int numGCTEntries = 1 &lt;&lt; ((packedFields &amp; 0x7) + 1);</span>

<span class="nc" id="L526">            streamMetadata.backgroundColorIndex = stream.readUnsignedByte();</span>
<span class="nc" id="L527">            streamMetadata.pixelAspectRatio = stream.readUnsignedByte();</span>

<span class="nc bnc" id="L529" title="All 2 branches missed.">            if (globalColorTableFlag) {</span>
<span class="nc" id="L530">                streamMetadata.globalColorTable = new byte[3*numGCTEntries];</span>
<span class="nc" id="L531">                stream.readFully(streamMetadata.globalColorTable);</span>
            } else {
<span class="nc" id="L533">                streamMetadata.globalColorTable = null;</span>
            }

            // Found position of metadata for image 0
<span class="nc" id="L537">            imageStartPosition.add(Long.valueOf(stream.getStreamPosition()));</span>
<span class="nc" id="L538">        } catch (IOException e) {</span>
<span class="nc" id="L539">            throw new IIOException(&quot;I/O error reading header!&quot;, e);</span>
<span class="nc" id="L540">        }</span>

<span class="nc" id="L542">        gotHeader = true;</span>
<span class="nc" id="L543">    }</span>

    private boolean skipImage() throws IIOException {
        // Stream must be at the beginning of an image descriptor
        // upon exit

        try {
            while (true) {
<span class="nc" id="L551">                int blockType = stream.readUnsignedByte();</span>

<span class="nc bnc" id="L553" title="All 2 branches missed.">                if (blockType == 0x2c) {</span>
<span class="nc" id="L554">                    stream.skipBytes(8);</span>

<span class="nc" id="L556">                    int packedFields = stream.readUnsignedByte();</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">                    if ((packedFields &amp; 0x80) != 0) {</span>
                        // Skip color table if any
<span class="nc" id="L559">                        int bits = (packedFields &amp; 0x7) + 1;</span>
<span class="nc" id="L560">                        stream.skipBytes(3*(1 &lt;&lt; bits));</span>
                    }

<span class="nc" id="L563">                    stream.skipBytes(1);</span>

<span class="nc" id="L565">                    int length = 0;</span>
                    do {
<span class="nc" id="L567">                        length = stream.readUnsignedByte();</span>
<span class="nc" id="L568">                        stream.skipBytes(length);</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">                    } while (length &gt; 0);</span>

<span class="nc" id="L571">                    return true;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">                } else if (blockType == 0x3b) {</span>
<span class="nc" id="L573">                    return false;</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">                } else if (blockType == 0x21) {</span>
<span class="nc" id="L575">                    int label = stream.readUnsignedByte();</span>

<span class="nc" id="L577">                    int length = 0;</span>
                    do {
<span class="nc" id="L579">                        length = stream.readUnsignedByte();</span>
<span class="nc" id="L580">                        stream.skipBytes(length);</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">                    } while (length &gt; 0);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                } else if (blockType == 0x0) {</span>
                    // EOF
<span class="nc" id="L584">                    return false;</span>
                } else {
<span class="nc" id="L586">                    int length = 0;</span>
                    do {
<span class="nc" id="L588">                        length = stream.readUnsignedByte();</span>
<span class="nc" id="L589">                        stream.skipBytes(length);</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">                    } while (length &gt; 0);</span>
                }
<span class="nc" id="L592">            }</span>
<span class="nc" id="L593">        } catch (EOFException e) {</span>
<span class="nc" id="L594">            return false;</span>
<span class="nc" id="L595">        } catch (IOException e) {</span>
<span class="nc" id="L596">            throw new IIOException(&quot;I/O error locating image!&quot;, e);</span>
        }
    }

    private int locateImage(int imageIndex) throws IIOException {
<span class="nc" id="L601">        readHeader();</span>

        try {
            // Find closest known index
<span class="nc" id="L605">            int index = Math.min(imageIndex, imageStartPosition.size() - 1);</span>

            // Seek to that position
<span class="nc" id="L608">            Long l = (Long)imageStartPosition.get(index);</span>
<span class="nc" id="L609">            stream.seek(l.longValue());</span>

            // Skip images until at desired index or last image found
<span class="nc bnc" id="L612" title="All 2 branches missed.">            while (index &lt; imageIndex) {</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                if (!skipImage()) {</span>
<span class="nc" id="L614">                    --index;</span>
<span class="nc" id="L615">                    return index;</span>
                }

<span class="nc" id="L618">                Long l1 = new Long(stream.getStreamPosition());</span>
<span class="nc" id="L619">                imageStartPosition.add(l1);</span>
<span class="nc" id="L620">                ++index;</span>
<span class="nc" id="L621">            }</span>
<span class="nc" id="L622">        } catch (IOException e) {</span>
<span class="nc" id="L623">            throw new IIOException(&quot;Couldn't seek!&quot;, e);</span>
<span class="nc" id="L624">        }</span>

<span class="nc bnc" id="L626" title="All 2 branches missed.">        if (currIndex != imageIndex) {</span>
<span class="nc" id="L627">            imageMetadata = null;</span>
        }
<span class="nc" id="L629">        currIndex = imageIndex;</span>
<span class="nc" id="L630">        return imageIndex;</span>
    }

    // Read blocks of 1-255 bytes, stop at a 0-length block
    private byte[] concatenateBlocks() throws IOException {
<span class="nc" id="L635">        byte[] data = new byte[0];</span>
        while (true) {
<span class="nc" id="L637">            int length = stream.readUnsignedByte();</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (length == 0) {</span>
<span class="nc" id="L639">                break;</span>
            }
<span class="nc" id="L641">            byte[] newData = new byte[data.length + length];</span>
<span class="nc" id="L642">            System.arraycopy(data, 0, newData, 0, data.length);</span>
<span class="nc" id="L643">            stream.readFully(newData, data.length, length);</span>
<span class="nc" id="L644">            data = newData;</span>
<span class="nc" id="L645">        }</span>

<span class="nc" id="L647">        return data;</span>
    }

    // Stream must be positioned at start of metadata for 'currIndex'
    private void readMetadata() throws IIOException {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L653">            throw new IllegalStateException(&quot;Input not set!&quot;);</span>
        }

        try {
            // Create an object to store the image metadata
<span class="nc" id="L658">            this.imageMetadata = new GIFImageMetadata();</span>

<span class="nc" id="L660">            long startPosition = stream.getStreamPosition();</span>
            while (true) {
<span class="nc" id="L662">                int blockType = stream.readUnsignedByte();</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">                if (blockType == 0x2c) { // Image Descriptor</span>
<span class="nc" id="L664">                    imageMetadata.imageLeftPosition =</span>
<span class="nc" id="L665">                        stream.readUnsignedShort();</span>
<span class="nc" id="L666">                    imageMetadata.imageTopPosition =</span>
<span class="nc" id="L667">                        stream.readUnsignedShort();</span>
<span class="nc" id="L668">                    imageMetadata.imageWidth = stream.readUnsignedShort();</span>
<span class="nc" id="L669">                    imageMetadata.imageHeight = stream.readUnsignedShort();</span>

<span class="nc" id="L671">                    int idPackedFields = stream.readUnsignedByte();</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">                    boolean localColorTableFlag =</span>
                        (idPackedFields &amp; 0x80) != 0;
<span class="nc bnc" id="L674" title="All 2 branches missed.">                    imageMetadata.interlaceFlag = (idPackedFields &amp; 0x40) != 0;</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">                    imageMetadata.sortFlag = (idPackedFields &amp; 0x20) != 0;</span>
<span class="nc" id="L676">                    int numLCTEntries = 1 &lt;&lt; ((idPackedFields &amp; 0x7) + 1);</span>

<span class="nc bnc" id="L678" title="All 2 branches missed.">                    if (localColorTableFlag) {</span>
                        // Read color table if any
<span class="nc" id="L680">                        imageMetadata.localColorTable =</span>
                            new byte[3*numLCTEntries];
<span class="nc" id="L682">                        stream.readFully(imageMetadata.localColorTable);</span>
                    } else {
<span class="nc" id="L684">                        imageMetadata.localColorTable = null;</span>
                    }

                    // Record length of this metadata block
<span class="nc" id="L688">                    this.imageMetadataLength =</span>
<span class="nc" id="L689">                        (int)(stream.getStreamPosition() - startPosition);</span>

                    // Now positioned at start of LZW-compressed pixels
<span class="nc" id="L692">                    return;</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">                } else if (blockType == 0x21) { // Extension block</span>
<span class="nc" id="L694">                    int label = stream.readUnsignedByte();</span>

<span class="nc bnc" id="L696" title="All 2 branches missed.">                    if (label == 0xf9) { // Graphics Control Extension</span>
<span class="nc" id="L697">                        int gceLength = stream.readUnsignedByte(); // 4</span>
<span class="nc" id="L698">                        int gcePackedFields = stream.readUnsignedByte();</span>
<span class="nc" id="L699">                        imageMetadata.disposalMethod =</span>
                            (gcePackedFields &gt;&gt; 2) &amp; 0x3;
<span class="nc bnc" id="L701" title="All 2 branches missed.">                        imageMetadata.userInputFlag =</span>
                            (gcePackedFields &amp; 0x2) != 0;
<span class="nc bnc" id="L703" title="All 2 branches missed.">                        imageMetadata.transparentColorFlag =</span>
                            (gcePackedFields &amp; 0x1) != 0;

<span class="nc" id="L706">                        imageMetadata.delayTime = stream.readUnsignedShort();</span>
<span class="nc" id="L707">                        imageMetadata.transparentColorIndex</span>
<span class="nc" id="L708">                            = stream.readUnsignedByte();</span>

<span class="nc" id="L710">                        int terminator = stream.readUnsignedByte();</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">                    } else if (label == 0x1) { // Plain text extension</span>
<span class="nc" id="L712">                        int length = stream.readUnsignedByte();</span>
<span class="nc" id="L713">                        imageMetadata.hasPlainTextExtension = true;</span>
<span class="nc" id="L714">                        imageMetadata.textGridLeft =</span>
<span class="nc" id="L715">                            stream.readUnsignedShort();</span>
<span class="nc" id="L716">                        imageMetadata.textGridTop =</span>
<span class="nc" id="L717">                            stream.readUnsignedShort();</span>
<span class="nc" id="L718">                        imageMetadata.textGridWidth =</span>
<span class="nc" id="L719">                            stream.readUnsignedShort();</span>
<span class="nc" id="L720">                        imageMetadata.textGridHeight =</span>
<span class="nc" id="L721">                            stream.readUnsignedShort();</span>
<span class="nc" id="L722">                        imageMetadata.characterCellWidth =</span>
<span class="nc" id="L723">                            stream.readUnsignedByte();</span>
<span class="nc" id="L724">                        imageMetadata.characterCellHeight =</span>
<span class="nc" id="L725">                            stream.readUnsignedByte();</span>
<span class="nc" id="L726">                        imageMetadata.textForegroundColor =</span>
<span class="nc" id="L727">                            stream.readUnsignedByte();</span>
<span class="nc" id="L728">                        imageMetadata.textBackgroundColor =</span>
<span class="nc" id="L729">                            stream.readUnsignedByte();</span>
<span class="nc" id="L730">                        imageMetadata.text = concatenateBlocks();</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">                    } else if (label == 0xfe) { // Comment extension</span>
<span class="nc" id="L732">                        byte[] comment = concatenateBlocks();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                        if (imageMetadata.comments == null) {</span>
<span class="nc" id="L734">                            imageMetadata.comments = new ArrayList();</span>
                        }
<span class="nc" id="L736">                        imageMetadata.comments.add(comment);</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">                    } else if (label == 0xff) { // Application extension</span>
<span class="nc" id="L738">                        int blockSize = stream.readUnsignedByte();</span>
<span class="nc" id="L739">                        byte[] applicationID = new byte[8];</span>
<span class="nc" id="L740">                        byte[] authCode = new byte[3];</span>

                        // read available data
<span class="nc" id="L743">                        byte[] blockData = new byte[blockSize];</span>
<span class="nc" id="L744">                        stream.readFully(blockData);</span>

<span class="nc" id="L746">                        int offset = copyData(blockData, 0, applicationID);</span>
<span class="nc" id="L747">                        offset = copyData(blockData, offset, authCode);</span>

<span class="nc" id="L749">                        byte[] applicationData = concatenateBlocks();</span>

<span class="nc bnc" id="L751" title="All 2 branches missed.">                        if (offset &lt; blockSize) {</span>
<span class="nc" id="L752">                            int len = blockSize - offset;</span>
<span class="nc" id="L753">                            byte[] data =</span>
                                new byte[len + applicationData.length];

<span class="nc" id="L756">                            System.arraycopy(blockData, offset, data, 0, len);</span>
<span class="nc" id="L757">                            System.arraycopy(applicationData, 0, data, len,</span>
                                             applicationData.length);

<span class="nc" id="L760">                            applicationData = data;</span>
                        }

                        // Init lists if necessary
<span class="nc bnc" id="L764" title="All 2 branches missed.">                        if (imageMetadata.applicationIDs == null) {</span>
<span class="nc" id="L765">                            imageMetadata.applicationIDs = new ArrayList();</span>
<span class="nc" id="L766">                            imageMetadata.authenticationCodes =</span>
                                new ArrayList();
<span class="nc" id="L768">                            imageMetadata.applicationData = new ArrayList();</span>
                        }
<span class="nc" id="L770">                        imageMetadata.applicationIDs.add(applicationID);</span>
<span class="nc" id="L771">                        imageMetadata.authenticationCodes.add(authCode);</span>
<span class="nc" id="L772">                        imageMetadata.applicationData.add(applicationData);</span>
<span class="nc" id="L773">                    } else {</span>
                        // Skip over unknown extension blocks
<span class="nc" id="L775">                        int length = 0;</span>
                        do {
<span class="nc" id="L777">                            length = stream.readUnsignedByte();</span>
<span class="nc" id="L778">                            stream.skipBytes(length);</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">                        } while (length &gt; 0);</span>
                    }
<span class="nc bnc" id="L781" title="All 2 branches missed.">                } else if (blockType == 0x3b) { // Trailer</span>
<span class="nc" id="L782">                    throw new IndexOutOfBoundsException</span>
                        (&quot;Attempt to read past end of image sequence!&quot;);
                } else {
<span class="nc" id="L785">                    throw new IIOException(&quot;Unexpected block type &quot; +</span>
                                           blockType + &quot;!&quot;);
                }
<span class="nc" id="L788">            }</span>
<span class="nc" id="L789">        } catch (IIOException iioe) {</span>
<span class="nc" id="L790">            throw iioe;</span>
<span class="nc" id="L791">        } catch (IOException ioe) {</span>
<span class="nc" id="L792">            throw new IIOException(&quot;I/O error reading image metadata!&quot;, ioe);</span>
        }
    }

    private int copyData(byte[] src, int offset, byte[] dst) {
<span class="nc" id="L797">        int len = dst.length;</span>
<span class="nc" id="L798">        int rest = src.length - offset;</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (len &gt; rest) {</span>
<span class="nc" id="L800">            len = rest;</span>
        }
<span class="nc" id="L802">        System.arraycopy(src, offset, dst, 0, len);</span>
<span class="nc" id="L803">        return offset + len;</span>
    }

    private void startPass(int pass) {
<span class="nc bnc" id="L807" title="All 4 branches missed.">        if (updateListeners == null || !imageMetadata.interlaceFlag) {</span>
<span class="nc" id="L808">            return;</span>
        }

<span class="nc" id="L811">        int y = interlaceOffset[interlacePass];</span>
<span class="nc" id="L812">        int yStep = interlaceIncrement[interlacePass];</span>

<span class="nc" id="L814">        int[] vals = ReaderUtil.</span>
<span class="nc" id="L815">            computeUpdatedPixels(sourceRegion,</span>
                                 destinationOffset,
                                 destinationRegion.x,
                                 destinationRegion.y,
                                 destinationRegion.x +
                                 destinationRegion.width - 1,
                                 destinationRegion.y +
                                 destinationRegion.height - 1,
                                 sourceXSubsampling,
                                 sourceYSubsampling,
                                 0,
                                 y,
                                 destinationRegion.width,
                                 (destinationRegion.height + yStep - 1)/yStep,
                                 1,
                                 yStep);

        // Initialized updateMinY and updateYStep
<span class="nc" id="L833">        this.updateMinY = vals[1];</span>
<span class="nc" id="L834">        this.updateYStep = vals[5];</span>

        // Inform IIOReadUpdateListeners of new pass
<span class="nc" id="L837">        int[] bands = { 0 };</span>

<span class="nc" id="L839">        processPassStarted(theImage,</span>
                           interlacePass,
                           sourceMinProgressivePass,
                           sourceMaxProgressivePass,
                           0,
                           updateMinY,
                           1,
                           updateYStep,
                           bands);
<span class="nc" id="L848">    }</span>

    public BufferedImage read(int imageIndex, ImageReadParam param)
        throws IIOException {
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L853">            throw new IllegalStateException(&quot;Input not set!&quot;);</span>
        }
<span class="nc" id="L855">        checkIndex(imageIndex);</span>

<span class="nc" id="L857">        int index = locateImage(imageIndex);</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (index != imageIndex) {</span>
<span class="nc" id="L859">            throw new IndexOutOfBoundsException(&quot;imageIndex out of bounds!&quot;);</span>
        }

<span class="nc" id="L862">        clearAbortRequest();</span>
<span class="nc" id="L863">        readMetadata();</span>

        // A null ImageReadParam means we use the default
<span class="nc bnc" id="L866" title="All 2 branches missed.">        if (param == null) {</span>
<span class="nc" id="L867">            param = getDefaultReadParam();</span>
        }

        // Initialize the destination image
<span class="nc" id="L871">        Iterator imageTypes = getImageTypes(imageIndex);</span>
<span class="nc" id="L872">        this.theImage = getDestination(param,</span>
                                       imageTypes,
                                       imageMetadata.imageWidth,
                                       imageMetadata.imageHeight);
<span class="nc" id="L876">        this.theTile = theImage.getWritableTile(0, 0);</span>
<span class="nc" id="L877">        this.width = imageMetadata.imageWidth;</span>
<span class="nc" id="L878">        this.height = imageMetadata.imageHeight;</span>
<span class="nc" id="L879">        this.streamX = 0;</span>
<span class="nc" id="L880">        this.streamY = 0;</span>
<span class="nc" id="L881">        this.rowsDone = 0;</span>
<span class="nc" id="L882">        this.interlacePass = 0;</span>

        // Get source region, taking subsampling offsets into account,
        // and clipping against the true source bounds

<span class="nc" id="L887">        this.sourceRegion = new Rectangle(0, 0, 0, 0);</span>
<span class="nc" id="L888">        this.destinationRegion = new Rectangle(0, 0, 0, 0);</span>
<span class="nc" id="L889">        computeRegions(param, width, height, theImage,</span>
                       sourceRegion, destinationRegion);
<span class="nc" id="L891">        this.destinationOffset = new Point(destinationRegion.x,</span>
                                           destinationRegion.y);

<span class="nc" id="L894">        this.sourceXSubsampling = param.getSourceXSubsampling();</span>
<span class="nc" id="L895">        this.sourceYSubsampling = param.getSourceYSubsampling();</span>
<span class="nc" id="L896">        this.sourceMinProgressivePass =</span>
<span class="nc" id="L897">            Math.max(param.getSourceMinProgressivePass(), 0);</span>
<span class="nc" id="L898">        this.sourceMaxProgressivePass =</span>
<span class="nc" id="L899">            Math.min(param.getSourceMaxProgressivePass(), 3);</span>

<span class="nc" id="L901">        this.destY = destinationRegion.y +</span>
            (streamY - sourceRegion.y)/sourceYSubsampling;
<span class="nc" id="L903">        computeDecodeThisRow();</span>

        // Inform IIOReadProgressListeners of start of image
<span class="nc" id="L906">        processImageStarted(imageIndex);</span>
<span class="nc" id="L907">        startPass(0);</span>

<span class="nc" id="L909">        this.rowBuf = new byte[width];</span>

        try {
            // Read and decode the image data, fill in theImage
<span class="nc" id="L913">            this.initCodeSize = stream.readUnsignedByte();</span>

            // Read first data block
<span class="nc" id="L916">            this.blockLength = stream.readUnsignedByte();</span>
<span class="nc" id="L917">            int left = blockLength;</span>
<span class="nc" id="L918">            int off = 0;</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">            while (left &gt; 0) {</span>
<span class="nc" id="L920">                int nbytes = stream.read(block, off, left);</span>
<span class="nc" id="L921">                left -= nbytes;</span>
<span class="nc" id="L922">                off += nbytes;</span>
<span class="nc" id="L923">            }</span>

<span class="nc" id="L925">            this.bitPos = 0;</span>
<span class="nc" id="L926">            this.nextByte = 0;</span>
<span class="nc" id="L927">            this.lastBlockFound = false;</span>
<span class="nc" id="L928">            this.interlacePass = 0;</span>

            // Init 32-bit buffer
<span class="nc" id="L931">            initNext32Bits();</span>

<span class="nc" id="L933">            this.clearCode = 1 &lt;&lt; initCodeSize;</span>
<span class="nc" id="L934">            this.eofCode = clearCode + 1;</span>

<span class="nc" id="L936">            int code, oldCode = 0;</span>

<span class="nc" id="L938">            int[] prefix = new int[4096];</span>
<span class="nc" id="L939">            byte[] suffix = new byte[4096];</span>
<span class="nc" id="L940">            byte[] initial = new byte[4096];</span>
<span class="nc" id="L941">            int[] length = new int[4096];</span>
<span class="nc" id="L942">            byte[] string = new byte[4096];</span>

<span class="nc" id="L944">            initializeStringTable(prefix, suffix, initial, length);</span>
<span class="nc" id="L945">            int tableIndex = (1 &lt;&lt; initCodeSize) + 2;</span>
<span class="nc" id="L946">            int codeSize = initCodeSize + 1;</span>
<span class="nc" id="L947">            int codeMask = (1 &lt;&lt; codeSize) - 1;</span>

<span class="nc bnc" id="L949" title="All 2 branches missed.">            while (!abortRequested()) {</span>
<span class="nc" id="L950">                code = getCode(codeSize, codeMask);</span>

<span class="nc bnc" id="L952" title="All 2 branches missed.">                if (code == clearCode) {</span>
<span class="nc" id="L953">                    initializeStringTable(prefix, suffix, initial, length);</span>
<span class="nc" id="L954">                    tableIndex = (1 &lt;&lt; initCodeSize) + 2;</span>
<span class="nc" id="L955">                    codeSize = initCodeSize + 1;</span>
<span class="nc" id="L956">                    codeMask = (1 &lt;&lt; codeSize) - 1;</span>

<span class="nc" id="L958">                    code = getCode(codeSize, codeMask);</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">                    if (code == eofCode) {</span>
                        // Inform IIOReadProgressListeners of end of image
<span class="nc" id="L961">                        processImageComplete();</span>
<span class="nc" id="L962">                        return theImage;</span>
                    }
<span class="nc bnc" id="L964" title="All 2 branches missed.">                } else if (code == eofCode) {</span>
                    // Inform IIOReadProgressListeners of end of image
<span class="nc" id="L966">                    processImageComplete();</span>
<span class="nc" id="L967">                    return theImage;</span>
                } else {
                    int newSuffixIndex;
<span class="nc bnc" id="L970" title="All 2 branches missed.">                    if (code &lt; tableIndex) {</span>
<span class="nc" id="L971">                        newSuffixIndex = code;</span>
                    } else { // code == tableIndex
<span class="nc" id="L973">                        newSuffixIndex = oldCode;</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">                        if (code != tableIndex) {</span>
                            // warning - code out of sequence
                            // possibly data corruption
<span class="nc" id="L977">                            processWarningOccurred(&quot;Out-of-sequence code!&quot;);</span>
                        }
                    }

<span class="nc" id="L981">                    int ti = tableIndex;</span>
<span class="nc" id="L982">                    int oc = oldCode;</span>

<span class="nc" id="L984">                    prefix[ti] = oc;</span>
<span class="nc" id="L985">                    suffix[ti] = initial[newSuffixIndex];</span>
<span class="nc" id="L986">                    initial[ti] = initial[oc];</span>
<span class="nc" id="L987">                    length[ti] = length[oc] + 1;</span>

<span class="nc" id="L989">                    ++tableIndex;</span>
<span class="nc bnc" id="L990" title="All 4 branches missed.">                    if ((tableIndex == (1 &lt;&lt; codeSize)) &amp;&amp;</span>
                        (tableIndex &lt; 4096)) {
<span class="nc" id="L992">                        ++codeSize;</span>
<span class="nc" id="L993">                        codeMask = (1 &lt;&lt; codeSize) - 1;</span>
                    }
                }

                // Reverse code
<span class="nc" id="L998">                int c = code;</span>
<span class="nc" id="L999">                int len = length[c];</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">                for (int i = len - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L1001">                    string[i] = suffix[c];</span>
<span class="nc" id="L1002">                    c = prefix[c];</span>
                }

<span class="nc" id="L1005">                outputPixels(string, len);</span>
<span class="nc" id="L1006">                oldCode = code;</span>
<span class="nc" id="L1007">            }</span>

<span class="nc" id="L1009">            processReadAborted();</span>
<span class="nc" id="L1010">            return theImage;</span>
<span class="nc" id="L1011">        } catch (IOException e) {</span>
<span class="nc" id="L1012">            e.printStackTrace();</span>
<span class="nc" id="L1013">            throw new IIOException(&quot;I/O error reading image!&quot;, e);</span>
        }
    }

    /**
     * Remove all settings including global settings such as
     * &lt;code&gt;Locale&lt;/code&gt;s and listeners, as well as stream settings.
     */
    public void reset() {
<span class="nc" id="L1022">        super.reset();</span>
<span class="nc" id="L1023">        resetStreamSettings();</span>
<span class="nc" id="L1024">    }</span>

    /**
     * Remove local settings based on parsing of a stream.
     */
    private void resetStreamSettings() {
<span class="nc" id="L1030">        gotHeader = false;</span>
<span class="nc" id="L1031">        streamMetadata = null;</span>
<span class="nc" id="L1032">        currIndex = -1;</span>
<span class="nc" id="L1033">        imageMetadata = null;</span>
<span class="nc" id="L1034">        imageStartPosition = new ArrayList();</span>
<span class="nc" id="L1035">        numImages = -1;</span>

        // No need to reinitialize 'block'
<span class="nc" id="L1038">        blockLength = 0;</span>
<span class="nc" id="L1039">        bitPos = 0;</span>
<span class="nc" id="L1040">        nextByte = 0;</span>

<span class="nc" id="L1042">        next32Bits = 0;</span>
<span class="nc" id="L1043">        lastBlockFound = false;</span>

<span class="nc" id="L1045">        theImage = null;</span>
<span class="nc" id="L1046">        theTile = null;</span>
<span class="nc" id="L1047">        width = -1;</span>
<span class="nc" id="L1048">        height = -1;</span>
<span class="nc" id="L1049">        streamX = -1;</span>
<span class="nc" id="L1050">        streamY = -1;</span>
<span class="nc" id="L1051">        rowsDone = 0;</span>
<span class="nc" id="L1052">        interlacePass = 0;</span>

<span class="nc" id="L1054">        fallbackColorTable = null;</span>
<span class="nc" id="L1055">    }</span>

<span class="nc" id="L1057">    private static byte[] defaultPalette = null;</span>

    private static synchronized byte[] getDefaultPalette() {
<span class="nc bnc" id="L1060" title="All 2 branches missed.">        if (defaultPalette == null) {</span>
<span class="nc" id="L1061">            BufferedImage img = new BufferedImage(1, 1,</span>
                    BufferedImage.TYPE_BYTE_INDEXED);
<span class="nc" id="L1063">            IndexColorModel icm = (IndexColorModel) img.getColorModel();</span>

<span class="nc" id="L1065">            final int size = icm.getMapSize();</span>
<span class="nc" id="L1066">            byte[] r = new byte[size];</span>
<span class="nc" id="L1067">            byte[] g = new byte[size];</span>
<span class="nc" id="L1068">            byte[] b = new byte[size];</span>
<span class="nc" id="L1069">            icm.getReds(r);</span>
<span class="nc" id="L1070">            icm.getGreens(g);</span>
<span class="nc" id="L1071">            icm.getBlues(b);</span>

<span class="nc" id="L1073">            defaultPalette = new byte[size * 3];</span>

<span class="nc bnc" id="L1075" title="All 2 branches missed.">            for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1076">                defaultPalette[3 * i + 0] = r[i];</span>
<span class="nc" id="L1077">                defaultPalette[3 * i + 1] = g[i];</span>
<span class="nc" id="L1078">                defaultPalette[3 * i + 2] = b[i];</span>
            }
        }
<span class="nc" id="L1081">        return defaultPalette;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>