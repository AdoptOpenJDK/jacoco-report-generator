<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImageIO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.imageio</a> &gt; <span class="el_source">ImageIO.java</span></div><h1>ImageIO.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio;

import java.awt.image.BufferedImage;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.FilePermission;
import java.io.InputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.net.URL;
import java.security.AccessController;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Set;
import javax.imageio.spi.IIORegistry;
import javax.imageio.spi.ImageReaderSpi;
import javax.imageio.spi.ImageReaderWriterSpi;
import javax.imageio.spi.ImageWriterSpi;
import javax.imageio.spi.ImageInputStreamSpi;
import javax.imageio.spi.ImageOutputStreamSpi;
import javax.imageio.spi.ImageTranscoderSpi;
import javax.imageio.spi.ServiceRegistry;
import javax.imageio.stream.ImageInputStream;
import javax.imageio.stream.ImageOutputStream;
import sun.awt.AppContext;
import sun.security.action.GetPropertyAction;

/**
 * A class containing static convenience methods for locating
 * &lt;code&gt;ImageReader&lt;/code&gt;s and &lt;code&gt;ImageWriter&lt;/code&gt;s, and
 * performing simple encoding and decoding.
 *
 */
public final class ImageIO {

    private static final IIORegistry theRegistry =
<span class="fc" id="L66">        IIORegistry.getDefaultInstance();</span>

    /**
     * Constructor is private to prevent instantiation.
     */
<span class="nc" id="L71">    private ImageIO() {}</span>

    /**
     * Scans for plug-ins on the application class path,
     * loads their service provider classes, and registers a service
     * provider instance for each one found with the
     * &lt;code&gt;IIORegistry&lt;/code&gt;.
     *
     * &lt;p&gt;This method is needed because the application class path can
     * theoretically change, or additional plug-ins may become available.
     * Rather than re-scanning the classpath on every invocation of the
     * API, the class path is scanned automatically only on the first
     * invocation. Clients can call this method to prompt a re-scan.
     * Thus this method need only be invoked by sophisticated applications
     * which dynamically make new plug-ins available at runtime.
     *
     * &lt;p&gt; The &lt;code&gt;getResources&lt;/code&gt; method of the context
     * &lt;code&gt;ClassLoader&lt;/code&gt; is used locate JAR files containing
     * files named
     * &lt;code&gt;META-INF/services/javax.imageio.spi.&lt;/code&gt;&lt;i&gt;classname&lt;/i&gt;,
     * where &lt;i&gt;classname&lt;/i&gt; is one of &lt;code&gt;ImageReaderSpi&lt;/code&gt;,
     * &lt;code&gt;ImageWriterSpi&lt;/code&gt;, &lt;code&gt;ImageTranscoderSpi&lt;/code&gt;,
     * &lt;code&gt;ImageInputStreamSpi&lt;/code&gt;, or
     * &lt;code&gt;ImageOutputStreamSpi&lt;/code&gt;, along the application class
     * path.
     *
     * &lt;p&gt; The contents of the located files indicate the names of
     * actual implementation classes which implement the
     * aforementioned service provider interfaces; the default class
     * loader is then used to load each of these classes and to
     * instantiate an instance of each class, which is then placed
     * into the registry for later retrieval.
     *
     * &lt;p&gt; The exact set of locations searched depends on the
     * implementation of the Java runtime environment.
     *
     * @see ClassLoader#getResources
     */
    public static void scanForPlugins() {
<span class="nc" id="L110">        theRegistry.registerApplicationClasspathSpis();</span>
<span class="nc" id="L111">    }</span>

    // ImageInputStreams

    /**
     * A class to hold information about caching.  Each
     * &lt;code&gt;ThreadGroup&lt;/code&gt; will have its own copy
     * via the &lt;code&gt;AppContext&lt;/code&gt; mechanism.
     */
    static class CacheInfo {
<span class="fc" id="L121">        boolean useCache = true;</span>
<span class="fc" id="L122">        File cacheDirectory = null;</span>
<span class="fc" id="L123">        Boolean hasPermission = null;</span>

<span class="fc" id="L125">        public CacheInfo() {}</span>

        public boolean getUseCache() {
<span class="fc" id="L128">            return useCache;</span>
        }

        public void setUseCache(boolean useCache) {
<span class="nc" id="L132">            this.useCache = useCache;</span>
<span class="nc" id="L133">        }</span>

        public File getCacheDirectory() {
<span class="fc" id="L136">            return cacheDirectory;</span>
        }

        public void setCacheDirectory(File cacheDirectory) {
<span class="nc" id="L140">            this.cacheDirectory = cacheDirectory;</span>
<span class="nc" id="L141">        }</span>

        public Boolean getHasPermission() {
<span class="fc" id="L144">            return hasPermission;</span>
        }

        public void setHasPermission(Boolean hasPermission) {
<span class="fc" id="L148">            this.hasPermission = hasPermission;</span>
<span class="fc" id="L149">        }</span>
    }

    /**
     * Returns the &lt;code&gt;CacheInfo&lt;/code&gt; object associated with this
     * &lt;code&gt;ThreadGroup&lt;/code&gt;.
     */
    private static synchronized CacheInfo getCacheInfo() {
<span class="fc" id="L157">        AppContext context = AppContext.getAppContext();</span>
<span class="fc" id="L158">        CacheInfo info = (CacheInfo)context.get(CacheInfo.class);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">        if (info == null) {</span>
<span class="fc" id="L160">            info = new CacheInfo();</span>
<span class="fc" id="L161">            context.put(CacheInfo.class, info);</span>
        }
<span class="fc" id="L163">        return info;</span>
    }

    /**
     * Returns the default temporary (cache) directory as defined by the
     * java.io.tmpdir system property.
     */
    private static String getTempDir() {
<span class="fc" id="L171">        GetPropertyAction a = new GetPropertyAction(&quot;java.io.tmpdir&quot;);</span>
<span class="fc" id="L172">        return (String)AccessController.doPrivileged(a);</span>
    }

    /**
     * Determines whether the caller has write access to the cache
     * directory, stores the result in the &lt;code&gt;CacheInfo&lt;/code&gt; object,
     * and returns the decision.  This method helps to prevent mysterious
     * SecurityExceptions to be thrown when this convenience class is used
     * in an applet, for example.
     */
    private static boolean hasCachePermission() {
<span class="fc" id="L183">        Boolean hasPermission = getCacheInfo().getHasPermission();</span>

<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (hasPermission != null) {</span>
<span class="nc" id="L186">            return hasPermission.booleanValue();</span>
        } else {
            try {
<span class="fc" id="L189">                SecurityManager security = System.getSecurityManager();</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">                if (security != null) {</span>
<span class="fc" id="L191">                    File cachedir = getCacheDirectory();</span>
                    String cachepath;

<span class="pc bpc" id="L194" title="1 of 2 branches missed.">                    if (cachedir != null) {</span>
<span class="nc" id="L195">                        cachepath = cachedir.getPath();</span>
                    } else {
<span class="fc" id="L197">                        cachepath = getTempDir();</span>

<span class="pc bpc" id="L199" title="2 of 4 branches missed.">                        if (cachepath == null || cachepath.isEmpty()) {</span>
<span class="nc" id="L200">                            getCacheInfo().setHasPermission(Boolean.FALSE);</span>
<span class="nc" id="L201">                            return false;</span>
                        }
                    }

                    // we have to check whether we can read, write,
                    // and delete cache files.
                    // So, compose cache file path and check it.
<span class="fc" id="L208">                    String filepath = cachepath;</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">                    if (!filepath.endsWith(File.separator)) {</span>
<span class="fc" id="L210">                        filepath += File.separator;</span>
                    }
<span class="nc" id="L212">                    filepath += &quot;*&quot;;</span>

<span class="nc" id="L214">                    security.checkPermission(new FilePermission(filepath, &quot;read, write, delete&quot;));</span>
                }
<span class="fc" id="L216">            } catch (SecurityException e) {</span>
<span class="fc" id="L217">                getCacheInfo().setHasPermission(Boolean.FALSE);</span>
<span class="fc" id="L218">                return false;</span>
<span class="nc" id="L219">            }</span>

<span class="nc" id="L221">            getCacheInfo().setHasPermission(Boolean.TRUE);</span>
<span class="nc" id="L222">            return true;</span>
        }
    }

    /**
     * Sets a flag indicating whether a disk-based cache file should
     * be used when creating &lt;code&gt;ImageInputStream&lt;/code&gt;s and
     * &lt;code&gt;ImageOutputStream&lt;/code&gt;s.
     *
     * &lt;p&gt; When reading from a standard &lt;code&gt;InputStream&lt;/code&gt;, it
     * may be necessary to save previously read information in a cache
     * since the underlying stream does not allow data to be re-read.
     * Similarly, when writing to a standard
     * &lt;code&gt;OutputStream&lt;/code&gt;, a cache may be used to allow a
     * previously written value to be changed before flushing it to
     * the final destination.
     *
     * &lt;p&gt; The cache may reside in main memory or on disk.  Setting
     * this flag to &lt;code&gt;false&lt;/code&gt; disallows the use of disk for
     * future streams, which may be advantageous when working with
     * small images, as the overhead of creating and destroying files
     * is removed.
     *
     * &lt;p&gt; On startup, the value is set to &lt;code&gt;true&lt;/code&gt;.
     *
     * @param useCache a &lt;code&gt;boolean&lt;/code&gt; indicating whether a
     * cache file should be used, in cases where it is optional.
     *
     * @see #getUseCache
     */
    public static void setUseCache(boolean useCache) {
<span class="nc" id="L253">        getCacheInfo().setUseCache(useCache);</span>
<span class="nc" id="L254">    }</span>

    /**
     * Returns the current value set by &lt;code&gt;setUseCache&lt;/code&gt;, or
     * &lt;code&gt;true&lt;/code&gt; if no explicit setting has been made.
     *
     * @return true if a disk-based cache may be used for
     * &lt;code&gt;ImageInputStream&lt;/code&gt;s and
     * &lt;code&gt;ImageOutputStream&lt;/code&gt;s.
     *
     * @see #setUseCache
     */
    public static boolean getUseCache() {
<span class="fc" id="L267">        return getCacheInfo().getUseCache();</span>
    }

    /**
     * Sets the directory where cache files are to be created.  A
     * value of &lt;code&gt;null&lt;/code&gt; indicates that the system-dependent
     * default temporary-file directory is to be used.  If
     * &lt;code&gt;getUseCache&lt;/code&gt; returns false, this value is ignored.
     *
     * @param cacheDirectory a &lt;code&gt;File&lt;/code&gt; specifying a directory.
     *
     * @see File#createTempFile(String, String, File)
     *
     * @exception SecurityException if the security manager denies
     * access to the directory.
     * @exception IllegalArgumentException if &lt;code&gt;cacheDir&lt;/code&gt; is
     * non-&lt;code&gt;null&lt;/code&gt; but is not a directory.
     *
     * @see #getCacheDirectory
     */
    public static void setCacheDirectory(File cacheDirectory) {
<span class="nc bnc" id="L288" title="All 4 branches missed.">        if ((cacheDirectory != null) &amp;&amp; !(cacheDirectory.isDirectory())) {</span>
<span class="nc" id="L289">            throw new IllegalArgumentException(&quot;Not a directory!&quot;);</span>
        }
<span class="nc" id="L291">        getCacheInfo().setCacheDirectory(cacheDirectory);</span>
<span class="nc" id="L292">        getCacheInfo().setHasPermission(null);</span>
<span class="nc" id="L293">    }</span>

    /**
     * Returns the current value set by
     * &lt;code&gt;setCacheDirectory&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; if no
     * explicit setting has been made.
     *
     * @return a &lt;code&gt;File&lt;/code&gt; indicating the directory where
     * cache files will be created, or &lt;code&gt;null&lt;/code&gt; to indicate
     * the system-dependent default temporary-file directory.
     *
     * @see #setCacheDirectory
     */
    public static File getCacheDirectory() {
<span class="fc" id="L307">        return getCacheInfo().getCacheDirectory();</span>
    }

    /**
     * Returns an &lt;code&gt;ImageInputStream&lt;/code&gt; that will take its
     * input from the given &lt;code&gt;Object&lt;/code&gt;.  The set of
     * &lt;code&gt;ImageInputStreamSpi&lt;/code&gt;s registered with the
     * &lt;code&gt;IIORegistry&lt;/code&gt; class is queried and the first one
     * that is able to take input from the supplied object is used to
     * create the returned &lt;code&gt;ImageInputStream&lt;/code&gt;.  If no
     * suitable &lt;code&gt;ImageInputStreamSpi&lt;/code&gt; exists,
     * &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * &lt;p&gt; The current cache settings from &lt;code&gt;getUseCache&lt;/code&gt;and
     * &lt;code&gt;getCacheDirectory&lt;/code&gt; will be used to control caching.
     *
     * @param input an &lt;code&gt;Object&lt;/code&gt; to be used as an input
     * source, such as a &lt;code&gt;File&lt;/code&gt;, readable
     * &lt;code&gt;RandomAccessFile&lt;/code&gt;, or &lt;code&gt;InputStream&lt;/code&gt;.
     *
     * @return an &lt;code&gt;ImageInputStream&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if &lt;code&gt;input&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if a cache file is needed but cannot be
     * created.
     *
     * @see javax.imageio.spi.ImageInputStreamSpi
     */
    public static ImageInputStream createImageInputStream(Object input)
        throws IOException {
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L339">            throw new IllegalArgumentException(&quot;input == null!&quot;);</span>
        }

        Iterator iter;
        // Ensure category is present
        try {
<span class="fc" id="L345">            iter = theRegistry.getServiceProviders(ImageInputStreamSpi.class,</span>
                                                   true);
<span class="nc" id="L347">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L348">            return null;</span>
<span class="fc" id="L349">        }</span>

<span class="pc bpc" id="L351" title="2 of 4 branches missed.">        boolean usecache = getUseCache() &amp;&amp; hasCachePermission();</span>

<span class="pc bpc" id="L353" title="1 of 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="fc" id="L354">            ImageInputStreamSpi spi = (ImageInputStreamSpi)iter.next();</span>
<span class="fc bfc" id="L355" title="All 2 branches covered.">            if (spi.getInputClass().isInstance(input)) {</span>
                try {
<span class="fc" id="L357">                    return spi.createInputStreamInstance(input,</span>
                                                         usecache,
<span class="fc" id="L359">                                                         getCacheDirectory());</span>
<span class="nc" id="L360">                } catch (IOException e) {</span>
<span class="nc" id="L361">                    throw new IIOException(&quot;Can't create cache file!&quot;, e);</span>
                }
            }
<span class="fc" id="L364">        }</span>

<span class="nc" id="L366">        return null;</span>
    }

    // ImageOutputStreams

    /**
     * Returns an &lt;code&gt;ImageOutputStream&lt;/code&gt; that will send its
     * output to the given &lt;code&gt;Object&lt;/code&gt;.  The set of
     * &lt;code&gt;ImageOutputStreamSpi&lt;/code&gt;s registered with the
     * &lt;code&gt;IIORegistry&lt;/code&gt; class is queried and the first one
     * that is able to send output from the supplied object is used to
     * create the returned &lt;code&gt;ImageOutputStream&lt;/code&gt;.  If no
     * suitable &lt;code&gt;ImageOutputStreamSpi&lt;/code&gt; exists,
     * &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * &lt;p&gt; The current cache settings from &lt;code&gt;getUseCache&lt;/code&gt;and
     * &lt;code&gt;getCacheDirectory&lt;/code&gt; will be used to control caching.
     *
     * @param output an &lt;code&gt;Object&lt;/code&gt; to be used as an output
     * destination, such as a &lt;code&gt;File&lt;/code&gt;, writable
     * &lt;code&gt;RandomAccessFile&lt;/code&gt;, or &lt;code&gt;OutputStream&lt;/code&gt;.
     *
     * @return an &lt;code&gt;ImageOutputStream&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if &lt;code&gt;output&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if a cache file is needed but cannot be
     * created.
     *
     * @see javax.imageio.spi.ImageOutputStreamSpi
     */
    public static ImageOutputStream createImageOutputStream(Object output)
        throws IOException {
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (output == null) {</span>
<span class="nc" id="L401">            throw new IllegalArgumentException(&quot;output == null!&quot;);</span>
        }

        Iterator iter;
        // Ensure category is present
        try {
<span class="nc" id="L407">            iter = theRegistry.getServiceProviders(ImageOutputStreamSpi.class,</span>
                                                   true);
<span class="nc" id="L409">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L410">            return null;</span>
<span class="nc" id="L411">        }</span>

<span class="nc bnc" id="L413" title="All 4 branches missed.">        boolean usecache = getUseCache() &amp;&amp; hasCachePermission();</span>

<span class="nc bnc" id="L415" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L416">            ImageOutputStreamSpi spi = (ImageOutputStreamSpi)iter.next();</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (spi.getOutputClass().isInstance(output)) {</span>
                try {
<span class="nc" id="L419">                    return spi.createOutputStreamInstance(output,</span>
                                                          usecache,
<span class="nc" id="L421">                                                          getCacheDirectory());</span>
<span class="nc" id="L422">                } catch (IOException e) {</span>
<span class="nc" id="L423">                    throw new IIOException(&quot;Can't create cache file!&quot;, e);</span>
                }
            }
<span class="nc" id="L426">        }</span>

<span class="nc" id="L428">        return null;</span>
    }

<span class="nc" id="L431">    private static enum SpiInfo {</span>
<span class="nc" id="L432">        FORMAT_NAMES {</span>
            @Override
            String[] info(ImageReaderWriterSpi spi) {
<span class="nc" id="L435">                return spi.getFormatNames();</span>
            }
        },
<span class="nc" id="L438">        MIME_TYPES {</span>
            @Override
            String[] info(ImageReaderWriterSpi spi) {
<span class="nc" id="L441">                return spi.getMIMETypes();</span>
            }
        },
<span class="nc" id="L444">        FILE_SUFFIXES {</span>
            @Override
            String[] info(ImageReaderWriterSpi spi) {
<span class="nc" id="L447">                return spi.getFileSuffixes();</span>
            }
        };

        abstract String[] info(ImageReaderWriterSpi spi);
    }

    private static &lt;S extends ImageReaderWriterSpi&gt;
        String[] getReaderWriterInfo(Class&lt;S&gt; spiClass, SpiInfo spiInfo)
    {
        // Ensure category is present
        Iterator&lt;S&gt; iter;
        try {
<span class="nc" id="L460">            iter = theRegistry.getServiceProviders(spiClass, true);</span>
<span class="nc" id="L461">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L462">            return new String[0];</span>
<span class="nc" id="L463">        }</span>

<span class="nc" id="L465">        HashSet&lt;String&gt; s = new HashSet&lt;String&gt;();</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L467">            ImageReaderWriterSpi spi = iter.next();</span>
<span class="nc" id="L468">            Collections.addAll(s, spiInfo.info(spi));</span>
<span class="nc" id="L469">        }</span>

<span class="nc" id="L471">        return s.toArray(new String[s.size()]);</span>
    }

    // Readers

    /**
     * Returns an array of &lt;code&gt;String&lt;/code&gt;s listing all of the
     * informal format names understood by the current set of registered
     * readers.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt;s.
     */
    public static String[] getReaderFormatNames() {
<span class="nc" id="L484">        return getReaderWriterInfo(ImageReaderSpi.class,</span>
                                   SpiInfo.FORMAT_NAMES);
    }

    /**
     * Returns an array of &lt;code&gt;String&lt;/code&gt;s listing all of the
     * MIME types understood by the current set of registered
     * readers.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt;s.
     */
    public static String[] getReaderMIMETypes() {
<span class="nc" id="L496">        return getReaderWriterInfo(ImageReaderSpi.class,</span>
                                   SpiInfo.MIME_TYPES);
    }

    /**
     * Returns an array of &lt;code&gt;String&lt;/code&gt;s listing all of the
     * file suffixes associated with the formats understood
     * by the current set of registered readers.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt;s.
     * @since 1.6
     */
    public static String[] getReaderFileSuffixes() {
<span class="nc" id="L509">        return getReaderWriterInfo(ImageReaderSpi.class,</span>
                                   SpiInfo.FILE_SUFFIXES);
    }

    static class ImageReaderIterator implements Iterator&lt;ImageReader&gt; {
        // Contains ImageReaderSpis
        public Iterator iter;

<span class="fc" id="L517">        public ImageReaderIterator(Iterator iter) {</span>
<span class="fc" id="L518">            this.iter = iter;</span>
<span class="fc" id="L519">        }</span>

        public boolean hasNext() {
<span class="fc" id="L522">            return iter.hasNext();</span>
        }

        public ImageReader next() {
<span class="nc" id="L526">            ImageReaderSpi spi = null;</span>
            try {
<span class="nc" id="L528">                spi = (ImageReaderSpi)iter.next();</span>
<span class="nc" id="L529">                return spi.createReaderInstance();</span>
<span class="nc" id="L530">            } catch (IOException e) {</span>
                // Deregister the spi in this case, but only as
                // an ImageReaderSpi
<span class="nc" id="L533">                theRegistry.deregisterServiceProvider(spi, ImageReaderSpi.class);</span>
            }
<span class="nc" id="L535">            return null;</span>
        }

        public void remove() {
<span class="nc" id="L539">            throw new UnsupportedOperationException();</span>
        }
    }

    static class CanDecodeInputFilter
        implements ServiceRegistry.Filter {

        Object input;

<span class="fc" id="L548">        public CanDecodeInputFilter(Object input) {</span>
<span class="fc" id="L549">            this.input = input;</span>
<span class="fc" id="L550">        }</span>

        public boolean filter(Object elt) {
            try {
<span class="fc" id="L554">                ImageReaderSpi spi = (ImageReaderSpi)elt;</span>
<span class="fc" id="L555">                ImageInputStream stream = null;</span>
<span class="pc bpc" id="L556" title="1 of 2 branches missed.">                if (input instanceof ImageInputStream) {</span>
<span class="fc" id="L557">                    stream = (ImageInputStream)input;</span>
                }

                // Perform mark/reset as a defensive measure
                // even though plug-ins are supposed to take
                // care of it.
<span class="fc" id="L563">                boolean canDecode = false;</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">                if (stream != null) {</span>
<span class="fc" id="L565">                    stream.mark();</span>
                }
<span class="fc" id="L567">                canDecode = spi.canDecodeInput(input);</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">                if (stream != null) {</span>
<span class="fc" id="L569">                    stream.reset();</span>
                }

<span class="fc" id="L572">                return canDecode;</span>
<span class="fc" id="L573">            } catch (IOException e) {</span>
<span class="fc" id="L574">                return false;</span>
            }
        }
    }

    static class CanEncodeImageAndFormatFilter
        implements ServiceRegistry.Filter {

        ImageTypeSpecifier type;
        String formatName;

        public CanEncodeImageAndFormatFilter(ImageTypeSpecifier type,
<span class="nc" id="L586">                                             String formatName) {</span>
<span class="nc" id="L587">            this.type = type;</span>
<span class="nc" id="L588">            this.formatName = formatName;</span>
<span class="nc" id="L589">        }</span>

        public boolean filter(Object elt) {
<span class="nc" id="L592">            ImageWriterSpi spi = (ImageWriterSpi)elt;</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">            return Arrays.asList(spi.getFormatNames()).contains(formatName) &amp;&amp;</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">                spi.canEncodeImage(type);</span>
        }
    }

    static class ContainsFilter
        implements ServiceRegistry.Filter {

        Method method;
        String name;

        // method returns an array of Strings
        public ContainsFilter(Method method,
<span class="nc" id="L606">                              String name) {</span>
<span class="nc" id="L607">            this.method = method;</span>
<span class="nc" id="L608">            this.name = name;</span>
<span class="nc" id="L609">        }</span>

        public boolean filter(Object elt) {
            try {
<span class="nc" id="L613">                return contains((String[])method.invoke(elt), name);</span>
<span class="nc" id="L614">            } catch (Exception e) {</span>
<span class="nc" id="L615">                return false;</span>
            }
        }
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all currently
     * registered &lt;code&gt;ImageReader&lt;/code&gt;s that claim to be able to
     * decode the supplied &lt;code&gt;Object&lt;/code&gt;, typically an
     * &lt;code&gt;ImageInputStream&lt;/code&gt;.
     *
     * &lt;p&gt; The stream position is left at its prior position upon
     * exit from this method.
     *
     * @param input an &lt;code&gt;ImageInputStream&lt;/code&gt; or other
     * &lt;code&gt;Object&lt;/code&gt; containing encoded image data.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing &lt;code&gt;ImageReader&lt;/code&gt;s.
     *
     * @exception IllegalArgumentException if &lt;code&gt;input&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see javax.imageio.spi.ImageReaderSpi#canDecodeInput
     */
    public static Iterator&lt;ImageReader&gt; getImageReaders(Object input) {
<span class="pc bpc" id="L640" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L641">            throw new IllegalArgumentException(&quot;input == null!&quot;);</span>
        }
        Iterator iter;
        // Ensure category is present
        try {
<span class="fc" id="L646">            iter = theRegistry.getServiceProviders(ImageReaderSpi.class,</span>
                                              new CanDecodeInputFilter(input),
                                              true);
<span class="nc" id="L649">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L650">            return Collections.emptyIterator();</span>
<span class="fc" id="L651">        }</span>

<span class="fc" id="L653">        return new ImageReaderIterator(iter);</span>
    }

    private static Method readerFormatNamesMethod;
    private static Method readerFileSuffixesMethod;
    private static Method readerMIMETypesMethod;
    private static Method writerFormatNamesMethod;
    private static Method writerFileSuffixesMethod;
    private static Method writerMIMETypesMethod;

    static {
        try {
<span class="fc" id="L665">            readerFormatNamesMethod =</span>
<span class="fc" id="L666">                ImageReaderSpi.class.getMethod(&quot;getFormatNames&quot;);</span>
<span class="fc" id="L667">            readerFileSuffixesMethod =</span>
<span class="fc" id="L668">                ImageReaderSpi.class.getMethod(&quot;getFileSuffixes&quot;);</span>
<span class="fc" id="L669">            readerMIMETypesMethod =</span>
<span class="fc" id="L670">                ImageReaderSpi.class.getMethod(&quot;getMIMETypes&quot;);</span>

<span class="fc" id="L672">            writerFormatNamesMethod =</span>
<span class="fc" id="L673">                ImageWriterSpi.class.getMethod(&quot;getFormatNames&quot;);</span>
<span class="fc" id="L674">            writerFileSuffixesMethod =</span>
<span class="fc" id="L675">                ImageWriterSpi.class.getMethod(&quot;getFileSuffixes&quot;);</span>
<span class="fc" id="L676">            writerMIMETypesMethod =</span>
<span class="fc" id="L677">                ImageWriterSpi.class.getMethod(&quot;getMIMETypes&quot;);</span>
<span class="nc" id="L678">        } catch (NoSuchMethodException e) {</span>
<span class="nc" id="L679">            e.printStackTrace();</span>
<span class="fc" id="L680">        }</span>
<span class="fc" id="L681">    }</span>

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all currently
     * registered &lt;code&gt;ImageReader&lt;/code&gt;s that claim to be able to
     * decode the named format.
     *
     * @param formatName a &lt;code&gt;String&lt;/code&gt; containing the informal
     * name of a format (&lt;i&gt;e.g.&lt;/i&gt;, &quot;jpeg&quot; or &quot;tiff&quot;.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing
     * &lt;code&gt;ImageReader&lt;/code&gt;s.
     *
     * @exception IllegalArgumentException if &lt;code&gt;formatName&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     *
     * @see javax.imageio.spi.ImageReaderSpi#getFormatNames
     */
    public static Iterator&lt;ImageReader&gt;
        getImageReadersByFormatName(String formatName)
    {
<span class="nc bnc" id="L702" title="All 2 branches missed.">        if (formatName == null) {</span>
<span class="nc" id="L703">            throw new IllegalArgumentException(&quot;formatName == null!&quot;);</span>
        }
        Iterator iter;
        // Ensure category is present
        try {
<span class="nc" id="L708">            iter = theRegistry.getServiceProviders(ImageReaderSpi.class,</span>
                                    new ContainsFilter(readerFormatNamesMethod,
                                                       formatName),
                                                true);
<span class="nc" id="L712">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L713">            return Collections.emptyIterator();</span>
<span class="nc" id="L714">        }</span>
<span class="nc" id="L715">        return new ImageReaderIterator(iter);</span>
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all currently
     * registered &lt;code&gt;ImageReader&lt;/code&gt;s that claim to be able to
     * decode files with the given suffix.
     *
     * @param fileSuffix a &lt;code&gt;String&lt;/code&gt; containing a file
     * suffix (&lt;i&gt;e.g.&lt;/i&gt;, &quot;jpg&quot; or &quot;tiff&quot;).
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing
     * &lt;code&gt;ImageReader&lt;/code&gt;s.
     *
     * @exception IllegalArgumentException if &lt;code&gt;fileSuffix&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     *
     * @see javax.imageio.spi.ImageReaderSpi#getFileSuffixes
     */
    public static Iterator&lt;ImageReader&gt;
        getImageReadersBySuffix(String fileSuffix)
    {
<span class="nc bnc" id="L737" title="All 2 branches missed.">        if (fileSuffix == null) {</span>
<span class="nc" id="L738">            throw new IllegalArgumentException(&quot;fileSuffix == null!&quot;);</span>
        }
        // Ensure category is present
        Iterator iter;
        try {
<span class="nc" id="L743">            iter = theRegistry.getServiceProviders(ImageReaderSpi.class,</span>
                                   new ContainsFilter(readerFileSuffixesMethod,
                                                      fileSuffix),
                                              true);
<span class="nc" id="L747">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L748">            return Collections.emptyIterator();</span>
<span class="nc" id="L749">        }</span>
<span class="nc" id="L750">        return new ImageReaderIterator(iter);</span>
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all currently
     * registered &lt;code&gt;ImageReader&lt;/code&gt;s that claim to be able to
     * decode files with the given MIME type.
     *
     * @param MIMEType a &lt;code&gt;String&lt;/code&gt; containing a file
     * suffix (&lt;i&gt;e.g.&lt;/i&gt;, &quot;image/jpeg&quot; or &quot;image/x-bmp&quot;).
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing
     * &lt;code&gt;ImageReader&lt;/code&gt;s.
     *
     * @exception IllegalArgumentException if &lt;code&gt;MIMEType&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see javax.imageio.spi.ImageReaderSpi#getMIMETypes
     */
    public static Iterator&lt;ImageReader&gt;
        getImageReadersByMIMEType(String MIMEType)
    {
<span class="nc bnc" id="L772" title="All 2 branches missed.">        if (MIMEType == null) {</span>
<span class="nc" id="L773">            throw new IllegalArgumentException(&quot;MIMEType == null!&quot;);</span>
        }
        // Ensure category is present
        Iterator iter;
        try {
<span class="nc" id="L778">            iter = theRegistry.getServiceProviders(ImageReaderSpi.class,</span>
                                      new ContainsFilter(readerMIMETypesMethod,
                                                         MIMEType),
                                              true);
<span class="nc" id="L782">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L783">            return Collections.emptyIterator();</span>
<span class="nc" id="L784">        }</span>
<span class="nc" id="L785">        return new ImageReaderIterator(iter);</span>
    }

    // Writers

    /**
     * Returns an array of &lt;code&gt;String&lt;/code&gt;s listing all of the
     * informal format names understood by the current set of registered
     * writers.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt;s.
     */
    public static String[] getWriterFormatNames() {
<span class="nc" id="L798">        return getReaderWriterInfo(ImageWriterSpi.class,</span>
                                   SpiInfo.FORMAT_NAMES);
    }

    /**
     * Returns an array of &lt;code&gt;String&lt;/code&gt;s listing all of the
     * MIME types understood by the current set of registered
     * writers.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt;s.
     */
    public static String[] getWriterMIMETypes() {
<span class="nc" id="L810">        return getReaderWriterInfo(ImageWriterSpi.class,</span>
                                   SpiInfo.MIME_TYPES);
    }

    /**
     * Returns an array of &lt;code&gt;String&lt;/code&gt;s listing all of the
     * file suffixes associated with the formats understood
     * by the current set of registered writers.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt;s.
     * @since 1.6
     */
    public static String[] getWriterFileSuffixes() {
<span class="nc" id="L823">        return getReaderWriterInfo(ImageWriterSpi.class,</span>
                                   SpiInfo.FILE_SUFFIXES);
    }

    static class ImageWriterIterator implements Iterator&lt;ImageWriter&gt; {
        // Contains ImageWriterSpis
        public Iterator iter;

<span class="nc" id="L831">        public ImageWriterIterator(Iterator iter) {</span>
<span class="nc" id="L832">            this.iter = iter;</span>
<span class="nc" id="L833">        }</span>

        public boolean hasNext() {
<span class="nc" id="L836">            return iter.hasNext();</span>
        }

        public ImageWriter next() {
<span class="nc" id="L840">            ImageWriterSpi spi = null;</span>
            try {
<span class="nc" id="L842">                spi = (ImageWriterSpi)iter.next();</span>
<span class="nc" id="L843">                return spi.createWriterInstance();</span>
<span class="nc" id="L844">            } catch (IOException e) {</span>
                // Deregister the spi in this case, but only as a writerSpi
<span class="nc" id="L846">                theRegistry.deregisterServiceProvider(spi, ImageWriterSpi.class);</span>
            }
<span class="nc" id="L848">            return null;</span>
        }

        public void remove() {
<span class="nc" id="L852">            throw new UnsupportedOperationException();</span>
        }
    }

    private static boolean contains(String[] names, String name) {
<span class="nc bnc" id="L857" title="All 2 branches missed.">        for (int i = 0; i &lt; names.length; i++) {</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">            if (name.equalsIgnoreCase(names[i])) {</span>
<span class="nc" id="L859">                return true;</span>
            }
        }

<span class="nc" id="L863">        return false;</span>
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all currently
     * registered &lt;code&gt;ImageWriter&lt;/code&gt;s that claim to be able to
     * encode the named format.
     *
     * @param formatName a &lt;code&gt;String&lt;/code&gt; containing the informal
     * name of a format (&lt;i&gt;e.g.&lt;/i&gt;, &quot;jpeg&quot; or &quot;tiff&quot;.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing
     * &lt;code&gt;ImageWriter&lt;/code&gt;s.
     *
     * @exception IllegalArgumentException if &lt;code&gt;formatName&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see javax.imageio.spi.ImageWriterSpi#getFormatNames
     */
    public static Iterator&lt;ImageWriter&gt;
        getImageWritersByFormatName(String formatName)
    {
<span class="nc bnc" id="L885" title="All 2 branches missed.">        if (formatName == null) {</span>
<span class="nc" id="L886">            throw new IllegalArgumentException(&quot;formatName == null!&quot;);</span>
        }
        Iterator iter;
        // Ensure category is present
        try {
<span class="nc" id="L891">            iter = theRegistry.getServiceProviders(ImageWriterSpi.class,</span>
                                    new ContainsFilter(writerFormatNamesMethod,
                                                       formatName),
                                            true);
<span class="nc" id="L895">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L896">            return Collections.emptyIterator();</span>
<span class="nc" id="L897">        }</span>
<span class="nc" id="L898">        return new ImageWriterIterator(iter);</span>
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all currently
     * registered &lt;code&gt;ImageWriter&lt;/code&gt;s that claim to be able to
     * encode files with the given suffix.
     *
     * @param fileSuffix a &lt;code&gt;String&lt;/code&gt; containing a file
     * suffix (&lt;i&gt;e.g.&lt;/i&gt;, &quot;jpg&quot; or &quot;tiff&quot;).
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing &lt;code&gt;ImageWriter&lt;/code&gt;s.
     *
     * @exception IllegalArgumentException if &lt;code&gt;fileSuffix&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see javax.imageio.spi.ImageWriterSpi#getFileSuffixes
     */
    public static Iterator&lt;ImageWriter&gt;
        getImageWritersBySuffix(String fileSuffix)
    {
<span class="nc bnc" id="L919" title="All 2 branches missed.">        if (fileSuffix == null) {</span>
<span class="nc" id="L920">            throw new IllegalArgumentException(&quot;fileSuffix == null!&quot;);</span>
        }
        Iterator iter;
        // Ensure category is present
        try {
<span class="nc" id="L925">            iter = theRegistry.getServiceProviders(ImageWriterSpi.class,</span>
                                   new ContainsFilter(writerFileSuffixesMethod,
                                                      fileSuffix),
                                            true);
<span class="nc" id="L929">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L930">            return Collections.emptyIterator();</span>
<span class="nc" id="L931">        }</span>
<span class="nc" id="L932">        return new ImageWriterIterator(iter);</span>
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all currently
     * registered &lt;code&gt;ImageWriter&lt;/code&gt;s that claim to be able to
     * encode files with the given MIME type.
     *
     * @param MIMEType a &lt;code&gt;String&lt;/code&gt; containing a file
     * suffix (&lt;i&gt;e.g.&lt;/i&gt;, &quot;image/jpeg&quot; or &quot;image/x-bmp&quot;).
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing &lt;code&gt;ImageWriter&lt;/code&gt;s.
     *
     * @exception IllegalArgumentException if &lt;code&gt;MIMEType&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see javax.imageio.spi.ImageWriterSpi#getMIMETypes
     */
    public static Iterator&lt;ImageWriter&gt;
        getImageWritersByMIMEType(String MIMEType)
    {
<span class="nc bnc" id="L953" title="All 2 branches missed.">        if (MIMEType == null) {</span>
<span class="nc" id="L954">            throw new IllegalArgumentException(&quot;MIMEType == null!&quot;);</span>
        }
        Iterator iter;
        // Ensure category is present
        try {
<span class="nc" id="L959">            iter = theRegistry.getServiceProviders(ImageWriterSpi.class,</span>
                                      new ContainsFilter(writerMIMETypesMethod,
                                                         MIMEType),
                                            true);
<span class="nc" id="L963">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L964">            return Collections.emptyIterator();</span>
<span class="nc" id="L965">        }</span>
<span class="nc" id="L966">        return new ImageWriterIterator(iter);</span>
    }

    /**
     * Returns an &lt;code&gt;ImageWriter&lt;/code&gt;corresponding to the given
     * &lt;code&gt;ImageReader&lt;/code&gt;, if there is one, or &lt;code&gt;null&lt;/code&gt;
     * if the plug-in for this &lt;code&gt;ImageReader&lt;/code&gt; does not
     * specify a corresponding &lt;code&gt;ImageWriter&lt;/code&gt;, or if the
     * given &lt;code&gt;ImageReader&lt;/code&gt; is not registered.  This
     * mechanism may be used to obtain an &lt;code&gt;ImageWriter&lt;/code&gt;
     * that will understand the internal structure of non-pixel
     * metadata (as encoded by &lt;code&gt;IIOMetadata&lt;/code&gt; objects)
     * generated by the &lt;code&gt;ImageReader&lt;/code&gt;.  By obtaining this
     * data from the &lt;code&gt;ImageReader&lt;/code&gt; and passing it on to the
     * &lt;code&gt;ImageWriter&lt;/code&gt; obtained with this method, a client
     * program can read an image, modify it in some way, and write it
     * back out preserving all metadata, without having to understand
     * anything about the structure of the metadata, or even about
     * the image format.  Note that this method returns the
     * &quot;preferred&quot; writer, which is the first in the list returned by
     * &lt;code&gt;javax.imageio.spi.ImageReaderSpi.getImageWriterSpiNames()&lt;/code&gt;.
     *
     * @param reader an instance of a registered &lt;code&gt;ImageReader&lt;/code&gt;.
     *
     * @return an &lt;code&gt;ImageWriter&lt;/code&gt;, or null.
     *
     * @exception IllegalArgumentException if &lt;code&gt;reader&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #getImageReader(ImageWriter)
     * @see javax.imageio.spi.ImageReaderSpi#getImageWriterSpiNames()
     */
    public static ImageWriter getImageWriter(ImageReader reader) {
<span class="nc bnc" id="L999" title="All 2 branches missed.">        if (reader == null) {</span>
<span class="nc" id="L1000">            throw new IllegalArgumentException(&quot;reader == null!&quot;);</span>
        }

<span class="nc" id="L1003">        ImageReaderSpi readerSpi = reader.getOriginatingProvider();</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">        if (readerSpi == null) {</span>
            Iterator readerSpiIter;
            // Ensure category is present
            try {
<span class="nc" id="L1008">                readerSpiIter =</span>
<span class="nc" id="L1009">                    theRegistry.getServiceProviders(ImageReaderSpi.class,</span>
                                                    false);
<span class="nc" id="L1011">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1012">                return null;</span>
<span class="nc" id="L1013">            }</span>

<span class="nc bnc" id="L1015" title="All 2 branches missed.">            while (readerSpiIter.hasNext()) {</span>
<span class="nc" id="L1016">                ImageReaderSpi temp = (ImageReaderSpi) readerSpiIter.next();</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                if (temp.isOwnReader(reader)) {</span>
<span class="nc" id="L1018">                    readerSpi = temp;</span>
<span class="nc" id="L1019">                    break;</span>
                }
<span class="nc" id="L1021">            }</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">            if (readerSpi == null) {</span>
<span class="nc" id="L1023">                return null;</span>
            }
        }

<span class="nc" id="L1027">        String[] writerNames = readerSpi.getImageWriterSpiNames();</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        if (writerNames == null) {</span>
<span class="nc" id="L1029">            return null;</span>
        }

<span class="nc" id="L1032">        Class writerSpiClass = null;</span>
        try {
<span class="nc" id="L1034">            writerSpiClass = Class.forName(writerNames[0], true,</span>
<span class="nc" id="L1035">                                           ClassLoader.getSystemClassLoader());</span>
<span class="nc" id="L1036">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1037">            return null;</span>
<span class="nc" id="L1038">        }</span>

<span class="nc" id="L1040">        ImageWriterSpi writerSpi = (ImageWriterSpi)</span>
<span class="nc" id="L1041">            theRegistry.getServiceProviderByClass(writerSpiClass);</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        if (writerSpi == null) {</span>
<span class="nc" id="L1043">            return null;</span>
        }

        try {
<span class="nc" id="L1047">            return writerSpi.createWriterInstance();</span>
<span class="nc" id="L1048">        } catch (IOException e) {</span>
            // Deregister the spi in this case, but only as a writerSpi
<span class="nc" id="L1050">            theRegistry.deregisterServiceProvider(writerSpi,</span>
                                                  ImageWriterSpi.class);
<span class="nc" id="L1052">            return null;</span>
        }
    }

    /**
     * Returns an &lt;code&gt;ImageReader&lt;/code&gt;corresponding to the given
     * &lt;code&gt;ImageWriter&lt;/code&gt;, if there is one, or &lt;code&gt;null&lt;/code&gt;
     * if the plug-in for this &lt;code&gt;ImageWriter&lt;/code&gt; does not
     * specify a corresponding &lt;code&gt;ImageReader&lt;/code&gt;, or if the
     * given &lt;code&gt;ImageWriter&lt;/code&gt; is not registered.  This method
     * is provided principally for symmetry with
     * &lt;code&gt;getImageWriter(ImageReader)&lt;/code&gt;.  Note that this
     * method returns the &quot;preferred&quot; reader, which is the first in
     * the list returned by
     * javax.imageio.spi.ImageWriterSpi.&lt;code&gt;getImageReaderSpiNames()&lt;/code&gt;.
     *
     * @param writer an instance of a registered &lt;code&gt;ImageWriter&lt;/code&gt;.
     *
     * @return an &lt;code&gt;ImageReader&lt;/code&gt;, or null.
     *
     * @exception IllegalArgumentException if &lt;code&gt;writer&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #getImageWriter(ImageReader)
     * @see javax.imageio.spi.ImageWriterSpi#getImageReaderSpiNames()
     */
    public static ImageReader getImageReader(ImageWriter writer) {
<span class="nc bnc" id="L1079" title="All 2 branches missed.">        if (writer == null) {</span>
<span class="nc" id="L1080">            throw new IllegalArgumentException(&quot;writer == null!&quot;);</span>
        }

<span class="nc" id="L1083">        ImageWriterSpi writerSpi = writer.getOriginatingProvider();</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">        if (writerSpi == null) {</span>
            Iterator writerSpiIter;
            // Ensure category is present
            try {
<span class="nc" id="L1088">                writerSpiIter =</span>
<span class="nc" id="L1089">                    theRegistry.getServiceProviders(ImageWriterSpi.class,</span>
                                                    false);
<span class="nc" id="L1091">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1092">                return null;</span>
<span class="nc" id="L1093">            }</span>

<span class="nc bnc" id="L1095" title="All 2 branches missed.">            while (writerSpiIter.hasNext()) {</span>
<span class="nc" id="L1096">                ImageWriterSpi temp = (ImageWriterSpi) writerSpiIter.next();</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                if (temp.isOwnWriter(writer)) {</span>
<span class="nc" id="L1098">                    writerSpi = temp;</span>
<span class="nc" id="L1099">                    break;</span>
                }
<span class="nc" id="L1101">            }</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">            if (writerSpi == null) {</span>
<span class="nc" id="L1103">                return null;</span>
            }
        }

<span class="nc" id="L1107">        String[] readerNames = writerSpi.getImageReaderSpiNames();</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">        if (readerNames == null) {</span>
<span class="nc" id="L1109">            return null;</span>
        }

<span class="nc" id="L1112">        Class readerSpiClass = null;</span>
        try {
<span class="nc" id="L1114">            readerSpiClass = Class.forName(readerNames[0], true,</span>
<span class="nc" id="L1115">                                           ClassLoader.getSystemClassLoader());</span>
<span class="nc" id="L1116">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L1117">            return null;</span>
<span class="nc" id="L1118">        }</span>

<span class="nc" id="L1120">        ImageReaderSpi readerSpi = (ImageReaderSpi)</span>
<span class="nc" id="L1121">            theRegistry.getServiceProviderByClass(readerSpiClass);</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">        if (readerSpi == null) {</span>
<span class="nc" id="L1123">            return null;</span>
        }

        try {
<span class="nc" id="L1127">            return readerSpi.createReaderInstance();</span>
<span class="nc" id="L1128">        } catch (IOException e) {</span>
            // Deregister the spi in this case, but only as a readerSpi
<span class="nc" id="L1130">            theRegistry.deregisterServiceProvider(readerSpi,</span>
                                                  ImageReaderSpi.class);
<span class="nc" id="L1132">            return null;</span>
        }
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all currently
     * registered &lt;code&gt;ImageWriter&lt;/code&gt;s that claim to be able to
     * encode images of the given layout (specified using an
     * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;) in the given format.
     *
     * @param type an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; indicating the
     * layout of the image to be written.
     * @param formatName the informal name of the &lt;code&gt;format&lt;/code&gt;.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing &lt;code&gt;ImageWriter&lt;/code&gt;s.
     *
     * @exception IllegalArgumentException if any parameter is
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @see javax.imageio.spi.ImageWriterSpi#canEncodeImage(ImageTypeSpecifier)
     */
    public static Iterator&lt;ImageWriter&gt;
        getImageWriters(ImageTypeSpecifier type, String formatName)
    {
<span class="nc bnc" id="L1156" title="All 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L1157">            throw new IllegalArgumentException(&quot;type == null!&quot;);</span>
        }
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        if (formatName == null) {</span>
<span class="nc" id="L1160">            throw new IllegalArgumentException(&quot;formatName == null!&quot;);</span>
        }

        Iterator iter;
        // Ensure category is present
        try {
<span class="nc" id="L1166">            iter = theRegistry.getServiceProviders(ImageWriterSpi.class,</span>
                                 new CanEncodeImageAndFormatFilter(type,
                                                                   formatName),
                                            true);
<span class="nc" id="L1170">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1171">            return Collections.emptyIterator();</span>
<span class="nc" id="L1172">        }</span>

<span class="nc" id="L1174">        return new ImageWriterIterator(iter);</span>
    }

    static class ImageTranscoderIterator
        implements Iterator&lt;ImageTranscoder&gt;
    {
        // Contains ImageTranscoderSpis
        public Iterator iter;

<span class="nc" id="L1183">        public ImageTranscoderIterator(Iterator iter) {</span>
<span class="nc" id="L1184">            this.iter = iter;</span>
<span class="nc" id="L1185">        }</span>

        public boolean hasNext() {
<span class="nc" id="L1188">            return iter.hasNext();</span>
        }

        public ImageTranscoder next() {
<span class="nc" id="L1192">            ImageTranscoderSpi spi = null;</span>
<span class="nc" id="L1193">            spi = (ImageTranscoderSpi)iter.next();</span>
<span class="nc" id="L1194">            return spi.createTranscoderInstance();</span>
        }

        public void remove() {
<span class="nc" id="L1198">            throw new UnsupportedOperationException();</span>
        }
    }

    static class TranscoderFilter
        implements ServiceRegistry.Filter {

        String readerSpiName;
        String writerSpiName;

        public TranscoderFilter(ImageReaderSpi readerSpi,
<span class="nc" id="L1209">                                ImageWriterSpi writerSpi) {</span>
<span class="nc" id="L1210">            this.readerSpiName = readerSpi.getClass().getName();</span>
<span class="nc" id="L1211">            this.writerSpiName = writerSpi.getClass().getName();</span>
<span class="nc" id="L1212">        }</span>

        public boolean filter(Object elt) {
<span class="nc" id="L1215">            ImageTranscoderSpi spi = (ImageTranscoderSpi)elt;</span>
<span class="nc" id="L1216">            String readerName = spi.getReaderServiceProviderName();</span>
<span class="nc" id="L1217">            String writerName = spi.getWriterServiceProviderName();</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">            return (readerName.equals(readerSpiName) &amp;&amp;</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">                    writerName.equals(writerSpiName));</span>
        }
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all currently
     * registered &lt;code&gt;ImageTranscoder&lt;/code&gt;s that claim to be
     * able to transcode between the metadata of the given
     * &lt;code&gt;ImageReader&lt;/code&gt; and &lt;code&gt;ImageWriter&lt;/code&gt;.
     *
     * @param reader an &lt;code&gt;ImageReader&lt;/code&gt;.
     * @param writer an &lt;code&gt;ImageWriter&lt;/code&gt;.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing
     * &lt;code&gt;ImageTranscoder&lt;/code&gt;s.
     *
     * @exception IllegalArgumentException if &lt;code&gt;reader&lt;/code&gt; or
     * &lt;code&gt;writer&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;.
     */
    public static Iterator&lt;ImageTranscoder&gt;
        getImageTranscoders(ImageReader reader, ImageWriter writer)
    {
<span class="nc bnc" id="L1241" title="All 2 branches missed.">        if (reader == null) {</span>
<span class="nc" id="L1242">            throw new IllegalArgumentException(&quot;reader == null!&quot;);</span>
        }
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        if (writer == null) {</span>
<span class="nc" id="L1245">            throw new IllegalArgumentException(&quot;writer == null!&quot;);</span>
        }
<span class="nc" id="L1247">        ImageReaderSpi readerSpi = reader.getOriginatingProvider();</span>
<span class="nc" id="L1248">        ImageWriterSpi writerSpi = writer.getOriginatingProvider();</span>
<span class="nc" id="L1249">        ServiceRegistry.Filter filter =</span>
            new TranscoderFilter(readerSpi, writerSpi);

        Iterator iter;
        // Ensure category is present
        try {
<span class="nc" id="L1255">            iter = theRegistry.getServiceProviders(ImageTranscoderSpi.class,</span>
                                            filter, true);
<span class="nc" id="L1257">        } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1258">            return Collections.emptyIterator();</span>
<span class="nc" id="L1259">        }</span>
<span class="nc" id="L1260">        return new ImageTranscoderIterator(iter);</span>
    }

    // All-in-one methods

    /**
     * Returns a &lt;code&gt;BufferedImage&lt;/code&gt; as the result of decoding
     * a supplied &lt;code&gt;File&lt;/code&gt; with an &lt;code&gt;ImageReader&lt;/code&gt;
     * chosen automatically from among those currently registered.
     * The &lt;code&gt;File&lt;/code&gt; is wrapped in an
     * &lt;code&gt;ImageInputStream&lt;/code&gt;.  If no registered
     * &lt;code&gt;ImageReader&lt;/code&gt; claims to be able to read the
     * resulting stream, &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * &lt;p&gt; The current cache settings from &lt;code&gt;getUseCache&lt;/code&gt;and
     * &lt;code&gt;getCacheDirectory&lt;/code&gt; will be used to control caching in the
     * &lt;code&gt;ImageInputStream&lt;/code&gt; that is created.
     *
     * &lt;p&gt; Note that there is no &lt;code&gt;read&lt;/code&gt; method that takes a
     * filename as a &lt;code&gt;String&lt;/code&gt;; use this method instead after
     * creating a &lt;code&gt;File&lt;/code&gt; from the filename.
     *
     * &lt;p&gt; This method does not attempt to locate
     * &lt;code&gt;ImageReader&lt;/code&gt;s that can read directly from a
     * &lt;code&gt;File&lt;/code&gt;; that may be accomplished using
     * &lt;code&gt;IIORegistry&lt;/code&gt; and &lt;code&gt;ImageReaderSpi&lt;/code&gt;.
     *
     * @param input a &lt;code&gt;File&lt;/code&gt; to read from.
     *
     * @return a &lt;code&gt;BufferedImage&lt;/code&gt; containing the decoded
     * contents of the input, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if &lt;code&gt;input&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an error occurs during reading.
     */
    public static BufferedImage read(File input) throws IOException {
<span class="nc bnc" id="L1297" title="All 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L1298">            throw new IllegalArgumentException(&quot;input == null!&quot;);</span>
        }
<span class="nc bnc" id="L1300" title="All 2 branches missed.">        if (!input.canRead()) {</span>
<span class="nc" id="L1301">            throw new IIOException(&quot;Can't read input file!&quot;);</span>
        }

<span class="nc" id="L1304">        ImageInputStream stream = createImageInputStream(input);</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L1306">            throw new IIOException(&quot;Can't create an ImageInputStream!&quot;);</span>
        }
<span class="nc" id="L1308">        BufferedImage bi = read(stream);</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">        if (bi == null) {</span>
<span class="nc" id="L1310">            stream.close();</span>
        }
<span class="nc" id="L1312">        return bi;</span>
    }

    /**
     * Returns a &lt;code&gt;BufferedImage&lt;/code&gt; as the result of decoding
     * a supplied &lt;code&gt;InputStream&lt;/code&gt; with an &lt;code&gt;ImageReader&lt;/code&gt;
     * chosen automatically from among those currently registered.
     * The &lt;code&gt;InputStream&lt;/code&gt; is wrapped in an
     * &lt;code&gt;ImageInputStream&lt;/code&gt;.  If no registered
     * &lt;code&gt;ImageReader&lt;/code&gt; claims to be able to read the
     * resulting stream, &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * &lt;p&gt; The current cache settings from &lt;code&gt;getUseCache&lt;/code&gt;and
     * &lt;code&gt;getCacheDirectory&lt;/code&gt; will be used to control caching in the
     * &lt;code&gt;ImageInputStream&lt;/code&gt; that is created.
     *
     * &lt;p&gt; This method does not attempt to locate
     * &lt;code&gt;ImageReader&lt;/code&gt;s that can read directly from an
     * &lt;code&gt;InputStream&lt;/code&gt;; that may be accomplished using
     * &lt;code&gt;IIORegistry&lt;/code&gt; and &lt;code&gt;ImageReaderSpi&lt;/code&gt;.
     *
     * &lt;p&gt; This method &lt;em&gt;does not&lt;/em&gt; close the provided
     * &lt;code&gt;InputStream&lt;/code&gt; after the read operation has completed;
     * it is the responsibility of the caller to close the stream, if desired.
     *
     * @param input an &lt;code&gt;InputStream&lt;/code&gt; to read from.
     *
     * @return a &lt;code&gt;BufferedImage&lt;/code&gt; containing the decoded
     * contents of the input, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if &lt;code&gt;input&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an error occurs during reading.
     */
    public static BufferedImage read(InputStream input) throws IOException {
<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L1348">            throw new IllegalArgumentException(&quot;input == null!&quot;);</span>
        }

<span class="fc" id="L1351">        ImageInputStream stream = createImageInputStream(input);</span>
<span class="fc" id="L1352">        BufferedImage bi = read(stream);</span>
<span class="pc bpc" id="L1353" title="1 of 2 branches missed.">        if (bi == null) {</span>
<span class="fc" id="L1354">            stream.close();</span>
        }
<span class="fc" id="L1356">        return bi;</span>
    }

    /**
     * Returns a &lt;code&gt;BufferedImage&lt;/code&gt; as the result of decoding
     * a supplied &lt;code&gt;URL&lt;/code&gt; with an &lt;code&gt;ImageReader&lt;/code&gt;
     * chosen automatically from among those currently registered.  An
     * &lt;code&gt;InputStream&lt;/code&gt; is obtained from the &lt;code&gt;URL&lt;/code&gt;,
     * which is wrapped in an &lt;code&gt;ImageInputStream&lt;/code&gt;.  If no
     * registered &lt;code&gt;ImageReader&lt;/code&gt; claims to be able to read
     * the resulting stream, &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * &lt;p&gt; The current cache settings from &lt;code&gt;getUseCache&lt;/code&gt;and
     * &lt;code&gt;getCacheDirectory&lt;/code&gt; will be used to control caching in the
     * &lt;code&gt;ImageInputStream&lt;/code&gt; that is created.
     *
     * &lt;p&gt; This method does not attempt to locate
     * &lt;code&gt;ImageReader&lt;/code&gt;s that can read directly from a
     * &lt;code&gt;URL&lt;/code&gt;; that may be accomplished using
     * &lt;code&gt;IIORegistry&lt;/code&gt; and &lt;code&gt;ImageReaderSpi&lt;/code&gt;.
     *
     * @param input a &lt;code&gt;URL&lt;/code&gt; to read from.
     *
     * @return a &lt;code&gt;BufferedImage&lt;/code&gt; containing the decoded
     * contents of the input, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if &lt;code&gt;input&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an error occurs during reading.
     */
    public static BufferedImage read(URL input) throws IOException {
<span class="nc bnc" id="L1387" title="All 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L1388">            throw new IllegalArgumentException(&quot;input == null!&quot;);</span>
        }

<span class="nc" id="L1391">        InputStream istream = null;</span>
        try {
<span class="nc" id="L1393">            istream = input.openStream();</span>
<span class="nc" id="L1394">        } catch (IOException e) {</span>
<span class="nc" id="L1395">            throw new IIOException(&quot;Can't get input stream from URL!&quot;, e);</span>
<span class="nc" id="L1396">        }</span>
<span class="nc" id="L1397">        ImageInputStream stream = createImageInputStream(istream);</span>
        BufferedImage bi;
        try {
<span class="nc" id="L1400">            bi = read(stream);</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">            if (bi == null) {</span>
<span class="nc" id="L1402">                stream.close();</span>
            }
        } finally {
<span class="nc" id="L1405">            istream.close();</span>
<span class="nc" id="L1406">        }</span>
<span class="nc" id="L1407">        return bi;</span>
    }

    /**
     * Returns a &lt;code&gt;BufferedImage&lt;/code&gt; as the result of decoding
     * a supplied &lt;code&gt;ImageInputStream&lt;/code&gt; with an
     * &lt;code&gt;ImageReader&lt;/code&gt; chosen automatically from among those
     * currently registered.  If no registered
     * &lt;code&gt;ImageReader&lt;/code&gt; claims to be able to read the stream,
     * &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * &lt;p&gt; Unlike most other methods in this class, this method &lt;em&gt;does&lt;/em&gt;
     * close the provided &lt;code&gt;ImageInputStream&lt;/code&gt; after the read
     * operation has completed, unless &lt;code&gt;null&lt;/code&gt; is returned,
     * in which case this method &lt;em&gt;does not&lt;/em&gt; close the stream.
     *
     * @param stream an &lt;code&gt;ImageInputStream&lt;/code&gt; to read from.
     *
     * @return a &lt;code&gt;BufferedImage&lt;/code&gt; containing the decoded
     * contents of the input, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if &lt;code&gt;stream&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an error occurs during reading.
     */
    public static BufferedImage read(ImageInputStream stream)
        throws IOException {
<span class="pc bpc" id="L1434" title="1 of 2 branches missed.">        if (stream == null) {</span>
<span class="nc" id="L1435">            throw new IllegalArgumentException(&quot;stream == null!&quot;);</span>
        }

<span class="fc" id="L1438">        Iterator iter = getImageReaders(stream);</span>
<span class="pc bpc" id="L1439" title="1 of 2 branches missed.">        if (!iter.hasNext()) {</span>
<span class="fc" id="L1440">            return null;</span>
        }

<span class="nc" id="L1443">        ImageReader reader = (ImageReader)iter.next();</span>
<span class="nc" id="L1444">        ImageReadParam param = reader.getDefaultReadParam();</span>
<span class="nc" id="L1445">        reader.setInput(stream, true, true);</span>
        BufferedImage bi;
        try {
<span class="nc" id="L1448">            bi = reader.read(0, param);</span>
        } finally {
<span class="nc" id="L1450">            reader.dispose();</span>
<span class="nc" id="L1451">            stream.close();</span>
<span class="nc" id="L1452">        }</span>
<span class="nc" id="L1453">        return bi;</span>
    }

    /**
     * Writes an image using the an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt;
     * that supports the given format to an
     * &lt;code&gt;ImageOutputStream&lt;/code&gt;.  The image is written to the
     * &lt;code&gt;ImageOutputStream&lt;/code&gt; starting at the current stream
     * pointer, overwriting existing stream data from that point
     * forward, if present.
     *
     * &lt;p&gt; This method &lt;em&gt;does not&lt;/em&gt; close the provided
     * &lt;code&gt;ImageOutputStream&lt;/code&gt; after the write operation has completed;
     * it is the responsibility of the caller to close the stream, if desired.
     *
     * @param im a &lt;code&gt;RenderedImage&lt;/code&gt; to be written.
     * @param formatName a &lt;code&gt;String&lt;/code&gt; containing the informal
     * name of the format.
     * @param output an &lt;code&gt;ImageOutputStream&lt;/code&gt; to be written to.
     *
     * @return &lt;code&gt;false&lt;/code&gt; if no appropriate writer is found.
     *
     * @exception IllegalArgumentException if any parameter is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an error occurs during writing.
     */
    public static boolean write(RenderedImage im,
                                String formatName,
                                ImageOutputStream output) throws IOException {
<span class="nc bnc" id="L1482" title="All 2 branches missed.">        if (im == null) {</span>
<span class="nc" id="L1483">            throw new IllegalArgumentException(&quot;im == null!&quot;);</span>
        }
<span class="nc bnc" id="L1485" title="All 2 branches missed.">        if (formatName == null) {</span>
<span class="nc" id="L1486">            throw new IllegalArgumentException(&quot;formatName == null!&quot;);</span>
        }
<span class="nc bnc" id="L1488" title="All 2 branches missed.">        if (output == null) {</span>
<span class="nc" id="L1489">            throw new IllegalArgumentException(&quot;output == null!&quot;);</span>
        }

<span class="nc" id="L1492">        return doWrite(im, getWriter(im, formatName), output);</span>
    }

    /**
     * Writes an image using an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt;
     * that supports the given format to a &lt;code&gt;File&lt;/code&gt;.  If
     * there is already a &lt;code&gt;File&lt;/code&gt; present, its contents are
     * discarded.
     *
     * @param im a &lt;code&gt;RenderedImage&lt;/code&gt; to be written.
     * @param formatName a &lt;code&gt;String&lt;/code&gt; containing the informal
     * name of the format.
     * @param output a &lt;code&gt;File&lt;/code&gt; to be written to.
     *
     * @return &lt;code&gt;false&lt;/code&gt; if no appropriate writer is found.
     *
     * @exception IllegalArgumentException if any parameter is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an error occurs during writing.
     */
    public static boolean write(RenderedImage im,
                                String formatName,
                                File output) throws IOException {
<span class="nc bnc" id="L1515" title="All 2 branches missed.">        if (output == null) {</span>
<span class="nc" id="L1516">            throw new IllegalArgumentException(&quot;output == null!&quot;);</span>
        }
<span class="nc" id="L1518">        ImageOutputStream stream = null;</span>

<span class="nc" id="L1520">        ImageWriter writer = getWriter(im, formatName);</span>
<span class="nc bnc" id="L1521" title="All 2 branches missed.">        if (writer == null) {</span>
            /* Do not make changes in the file system if we have
             * no appropriate writer.
             */
<span class="nc" id="L1525">            return false;</span>
        }

        try {
<span class="nc" id="L1529">            output.delete();</span>
<span class="nc" id="L1530">            stream = createImageOutputStream(output);</span>
<span class="nc" id="L1531">        } catch (IOException e) {</span>
<span class="nc" id="L1532">            throw new IIOException(&quot;Can't create output stream!&quot;, e);</span>
<span class="nc" id="L1533">        }</span>

        try {
<span class="nc" id="L1536">            return doWrite(im, writer, stream);</span>
        } finally {
<span class="nc" id="L1538">            stream.close();</span>
        }
    }

    /**
     * Writes an image using an arbitrary &lt;code&gt;ImageWriter&lt;/code&gt;
     * that supports the given format to an &lt;code&gt;OutputStream&lt;/code&gt;.
     *
     * &lt;p&gt; This method &lt;em&gt;does not&lt;/em&gt; close the provided
     * &lt;code&gt;OutputStream&lt;/code&gt; after the write operation has completed;
     * it is the responsibility of the caller to close the stream, if desired.
     *
     * &lt;p&gt; The current cache settings from &lt;code&gt;getUseCache&lt;/code&gt;and
     * &lt;code&gt;getCacheDirectory&lt;/code&gt; will be used to control caching.
     *
     * @param im a &lt;code&gt;RenderedImage&lt;/code&gt; to be written.
     * @param formatName a &lt;code&gt;String&lt;/code&gt; containing the informal
     * name of the format.
     * @param output an &lt;code&gt;OutputStream&lt;/code&gt; to be written to.
     *
     * @return &lt;code&gt;false&lt;/code&gt; if no appropriate writer is found.
     *
     * @exception IllegalArgumentException if any parameter is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an error occurs during writing.
     */
    public static boolean write(RenderedImage im,
                                String formatName,
                                OutputStream output) throws IOException {
<span class="nc bnc" id="L1567" title="All 2 branches missed.">        if (output == null) {</span>
<span class="nc" id="L1568">            throw new IllegalArgumentException(&quot;output == null!&quot;);</span>
        }
<span class="nc" id="L1570">        ImageOutputStream stream = null;</span>
        try {
<span class="nc" id="L1572">            stream = createImageOutputStream(output);</span>
<span class="nc" id="L1573">        } catch (IOException e) {</span>
<span class="nc" id="L1574">            throw new IIOException(&quot;Can't create output stream!&quot;, e);</span>
<span class="nc" id="L1575">        }</span>

        try {
<span class="nc" id="L1578">            return doWrite(im, getWriter(im, formatName), stream);</span>
        } finally {
<span class="nc" id="L1580">            stream.close();</span>
        }
    }

    /**
     * Returns &lt;code&gt;ImageWriter&lt;/code&gt; instance according to given
     * rendered image and image format or &lt;code&gt;null&lt;/code&gt; if there
     * is no appropriate writer.
     */
    private static ImageWriter getWriter(RenderedImage im,
                                         String formatName) {
<span class="nc" id="L1591">        ImageTypeSpecifier type =</span>
<span class="nc" id="L1592">            ImageTypeSpecifier.createFromRenderedImage(im);</span>
<span class="nc" id="L1593">        Iterator&lt;ImageWriter&gt; iter = getImageWriters(type, formatName);</span>

<span class="nc bnc" id="L1595" title="All 2 branches missed.">        if (iter.hasNext()) {</span>
<span class="nc" id="L1596">            return iter.next();</span>
        } else {
<span class="nc" id="L1598">            return null;</span>
        }
    }

    /**
     * Writes image to output stream  using given image writer.
     */
    private static boolean doWrite(RenderedImage im, ImageWriter writer,
                                 ImageOutputStream output) throws IOException {
<span class="nc bnc" id="L1607" title="All 2 branches missed.">        if (writer == null) {</span>
<span class="nc" id="L1608">            return false;</span>
        }
<span class="nc" id="L1610">        writer.setOutput(output);</span>
        try {
<span class="nc" id="L1612">            writer.write(im);</span>
        } finally {
<span class="nc" id="L1614">            writer.dispose();</span>
<span class="nc" id="L1615">            output.flush();</span>
<span class="nc" id="L1616">        }</span>
<span class="nc" id="L1617">        return true;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>