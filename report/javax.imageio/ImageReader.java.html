<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ImageReader.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.imageio</a> &gt; <span class="el_source">ImageReader.java</span></div><h1>ImageReader.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1999, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio;

import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.awt.image.Raster;
import java.awt.image.RenderedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Set;
import javax.imageio.spi.ImageReaderSpi;
import javax.imageio.event.IIOReadWarningListener;
import javax.imageio.event.IIOReadProgressListener;
import javax.imageio.event.IIOReadUpdateListener;
import javax.imageio.metadata.IIOMetadata;
import javax.imageio.metadata.IIOMetadataFormatImpl;
import javax.imageio.stream.ImageInputStream;

/**
 * An abstract superclass for parsing and decoding of images.  This
 * class must be subclassed by classes that read in images in the
 * context of the Java Image I/O framework.
 *
 * &lt;p&gt; &lt;code&gt;ImageReader&lt;/code&gt; objects are normally instantiated by
 * the service provider interface (SPI) class for the specific format.
 * Service provider classes (e.g., instances of
 * &lt;code&gt;ImageReaderSpi&lt;/code&gt;) are registered with the
 * &lt;code&gt;IIORegistry&lt;/code&gt;, which uses them for format recognition
 * and presentation of available format readers and writers.
 *
 * &lt;p&gt; When an input source is set (using the &lt;code&gt;setInput&lt;/code&gt;
 * method), it may be marked as &quot;seek forward only&quot;.  This setting
 * means that images contained within the input source will only be
 * read in order, possibly allowing the reader to avoid caching
 * portions of the input containing data associated with images that
 * have been read previously.
 *
 * @see ImageWriter
 * @see javax.imageio.spi.IIORegistry
 * @see javax.imageio.spi.ImageReaderSpi
 *
 */
public abstract class ImageReader {

    /**
     * The &lt;code&gt;ImageReaderSpi&lt;/code&gt; that instantiated this object,
     * or &lt;code&gt;null&lt;/code&gt; if its identity is not known or none
     * exists.  By default it is initialized to &lt;code&gt;null&lt;/code&gt;.
     */
    protected ImageReaderSpi originatingProvider;

    /**
     * The &lt;code&gt;ImageInputStream&lt;/code&gt; or other
     * &lt;code&gt;Object&lt;/code&gt; by &lt;code&gt;setInput&lt;/code&gt; and retrieved
     * by &lt;code&gt;getInput&lt;/code&gt;.  By default it is initialized to
     * &lt;code&gt;null&lt;/code&gt;.
     */
<span class="nc" id="L88">    protected Object input = null;</span>

    /**
     * &lt;code&gt;true&lt;/code&gt; if the current input source has been marked
     * as allowing only forward seeking by &lt;code&gt;setInput&lt;/code&gt;.  By
     * default, the value is &lt;code&gt;false&lt;/code&gt;.
     *
     * @see #minIndex
     * @see #setInput
     */
<span class="nc" id="L98">    protected boolean seekForwardOnly = false;</span>

    /**
     * &lt;code&gt;true&lt;/code&gt; if the current input source has been marked
     * as allowing metadata to be ignored by &lt;code&gt;setInput&lt;/code&gt;.
     * By default, the value is &lt;code&gt;false&lt;/code&gt;.
     *
     * @see #setInput
     */
<span class="nc" id="L107">    protected boolean ignoreMetadata = false;</span>

    /**
     * The smallest valid index for reading, initially 0.  When
     * &lt;code&gt;seekForwardOnly&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, various methods
     * may throw an &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; on an
     * attempt to access data associate with an image having a lower
     * index.
     *
     * @see #seekForwardOnly
     * @see #setInput
     */
<span class="nc" id="L119">    protected int minIndex = 0;</span>

    /**
     * An array of &lt;code&gt;Locale&lt;/code&gt;s which may be used to localize
     * warning messages, or &lt;code&gt;null&lt;/code&gt; if localization is not
     * supported.
     */
<span class="nc" id="L126">    protected Locale[] availableLocales = null;</span>

    /**
     * The current &lt;code&gt;Locale&lt;/code&gt; to be used for localization, or
     * &lt;code&gt;null&lt;/code&gt; if none has been set.
     */
<span class="nc" id="L132">    protected Locale locale = null;</span>

    /**
     * A &lt;code&gt;List&lt;/code&gt; of currently registered
     * &lt;code&gt;IIOReadWarningListener&lt;/code&gt;s, initialized by default to
     * &lt;code&gt;null&lt;/code&gt;, which is synonymous with an empty
     * &lt;code&gt;List&lt;/code&gt;.
     */
<span class="nc" id="L140">    protected List&lt;IIOReadWarningListener&gt; warningListeners = null;</span>

    /**
     * A &lt;code&gt;List&lt;/code&gt; of the &lt;code&gt;Locale&lt;/code&gt;s associated with
     * each currently registered &lt;code&gt;IIOReadWarningListener&lt;/code&gt;,
     * initialized by default to &lt;code&gt;null&lt;/code&gt;, which is
     * synonymous with an empty &lt;code&gt;List&lt;/code&gt;.
     */
<span class="nc" id="L148">    protected List&lt;Locale&gt; warningLocales = null;</span>

    /**
     * A &lt;code&gt;List&lt;/code&gt; of currently registered
     * &lt;code&gt;IIOReadProgressListener&lt;/code&gt;s, initialized by default
     * to &lt;code&gt;null&lt;/code&gt;, which is synonymous with an empty
     * &lt;code&gt;List&lt;/code&gt;.
     */
<span class="nc" id="L156">    protected List&lt;IIOReadProgressListener&gt; progressListeners = null;</span>

    /**
     * A &lt;code&gt;List&lt;/code&gt; of currently registered
     * &lt;code&gt;IIOReadUpdateListener&lt;/code&gt;s, initialized by default to
     * &lt;code&gt;null&lt;/code&gt;, which is synonymous with an empty
     * &lt;code&gt;List&lt;/code&gt;.
     */
<span class="nc" id="L164">    protected List&lt;IIOReadUpdateListener&gt; updateListeners = null;</span>

    /**
     * If &lt;code&gt;true&lt;/code&gt;, the current read operation should be
     * aborted.
     */
<span class="nc" id="L170">    private boolean abortFlag = false;</span>

    /**
     * Constructs an &lt;code&gt;ImageReader&lt;/code&gt; and sets its
     * &lt;code&gt;originatingProvider&lt;/code&gt; field to the supplied value.
     *
     * &lt;p&gt; Subclasses that make use of extensions should provide a
     * constructor with signature &lt;code&gt;(ImageReaderSpi,
     * Object)&lt;/code&gt; in order to retrieve the extension object.  If
     * the extension object is unsuitable, an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; should be thrown.
     *
     * @param originatingProvider the &lt;code&gt;ImageReaderSpi&lt;/code&gt; that is
     * invoking this constructor, or &lt;code&gt;null&lt;/code&gt;.
     */
<span class="nc" id="L185">    protected ImageReader(ImageReaderSpi originatingProvider) {</span>
<span class="nc" id="L186">        this.originatingProvider = originatingProvider;</span>
<span class="nc" id="L187">    }</span>

    /**
     * Returns a &lt;code&gt;String&lt;/code&gt; identifying the format of the
     * input source.
     *
     * &lt;p&gt; The default implementation returns
     * &lt;code&gt;originatingProvider.getFormatNames()[0]&lt;/code&gt;.
     * Implementations that may not have an originating service
     * provider, or which desire a different naming policy should
     * override this method.
     *
     * @exception IOException if an error occurs reading the
     * information from the input source.
     *
     * @return the format name, as a &lt;code&gt;String&lt;/code&gt;.
     */
    public String getFormatName() throws IOException {
<span class="nc" id="L205">        return originatingProvider.getFormatNames()[0];</span>
    }

    /**
     * Returns the &lt;code&gt;ImageReaderSpi&lt;/code&gt; that was passed in on
     * the constructor.  Note that this value may be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an &lt;code&gt;ImageReaderSpi&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @see ImageReaderSpi
     */
    public ImageReaderSpi getOriginatingProvider() {
<span class="nc" id="L217">        return originatingProvider;</span>
    }

    /**
     * Sets the input source to use to the given
     * &lt;code&gt;ImageInputStream&lt;/code&gt; or other &lt;code&gt;Object&lt;/code&gt;.
     * The input source must be set before any of the query or read
     * methods are used.  If &lt;code&gt;input&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * any currently set input source will be removed.  In any case,
     * the value of &lt;code&gt;minIndex&lt;/code&gt; will be initialized to 0.
     *
     * &lt;p&gt; The &lt;code&gt;seekForwardOnly&lt;/code&gt; parameter controls whether
     * the value returned by &lt;code&gt;getMinIndex&lt;/code&gt; will be
     * increased as each image (or thumbnail, or image metadata) is
     * read.  If &lt;code&gt;seekForwardOnly&lt;/code&gt; is true, then a call to
     * &lt;code&gt;read(index)&lt;/code&gt; will throw an
     * &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; if {@code index &lt; this.minIndex};
     * otherwise, the value of
     * &lt;code&gt;minIndex&lt;/code&gt; will be set to &lt;code&gt;index&lt;/code&gt;.  If
     * &lt;code&gt;seekForwardOnly&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the value of
     * &lt;code&gt;minIndex&lt;/code&gt; will remain 0 regardless of any read
     * operations.
     *
     * &lt;p&gt; The &lt;code&gt;ignoreMetadata&lt;/code&gt; parameter, if set to
     * &lt;code&gt;true&lt;/code&gt;, allows the reader to disregard any metadata
     * encountered during the read.  Subsequent calls to the
     * &lt;code&gt;getStreamMetadata&lt;/code&gt; and
     * &lt;code&gt;getImageMetadata&lt;/code&gt; methods may return
     * &lt;code&gt;null&lt;/code&gt;, and an &lt;code&gt;IIOImage&lt;/code&gt; returned from
     * &lt;code&gt;readAll&lt;/code&gt; may return &lt;code&gt;null&lt;/code&gt; from their
     * &lt;code&gt;getMetadata&lt;/code&gt; method.  Setting this parameter may
     * allow the reader to work more efficiently.  The reader may
     * choose to disregard this setting and return metadata normally.
     *
     * &lt;p&gt; Subclasses should take care to remove any cached
     * information based on the previous stream, such as header
     * information or partially decoded image data.
     *
     * &lt;p&gt; Use of a general &lt;code&gt;Object&lt;/code&gt; other than an
     * &lt;code&gt;ImageInputStream&lt;/code&gt; is intended for readers that
     * interact directly with a capture device or imaging protocol.
     * The set of legal classes is advertised by the reader's service
     * provider's &lt;code&gt;getInputTypes&lt;/code&gt; method; most readers
     * will return a single-element array containing only
     * &lt;code&gt;ImageInputStream.class&lt;/code&gt; to indicate that they
     * accept only an &lt;code&gt;ImageInputStream&lt;/code&gt;.
     *
     * &lt;p&gt; The default implementation checks the &lt;code&gt;input&lt;/code&gt;
     * argument against the list returned by
     * &lt;code&gt;originatingProvider.getInputTypes()&lt;/code&gt; and fails
     * if the argument is not an instance of one of the classes
     * in the list.  If the originating provider is set to
     * &lt;code&gt;null&lt;/code&gt;, the input is accepted only if it is an
     * &lt;code&gt;ImageInputStream&lt;/code&gt;.
     *
     * @param input the &lt;code&gt;ImageInputStream&lt;/code&gt; or other
     * &lt;code&gt;Object&lt;/code&gt; to use for future decoding.
     * @param seekForwardOnly if &lt;code&gt;true&lt;/code&gt;, images and metadata
     * may only be read in ascending order from this input source.
     * @param ignoreMetadata if &lt;code&gt;true&lt;/code&gt;, metadata
     * may be ignored during reads.
     *
     * @exception IllegalArgumentException if &lt;code&gt;input&lt;/code&gt; is
     * not an instance of one of the classes returned by the
     * originating service provider's &lt;code&gt;getInputTypes&lt;/code&gt;
     * method, or is not an &lt;code&gt;ImageInputStream&lt;/code&gt;.
     *
     * @see ImageInputStream
     * @see #getInput
     * @see javax.imageio.spi.ImageReaderSpi#getInputTypes
     */
    public void setInput(Object input,
                         boolean seekForwardOnly,
                         boolean ignoreMetadata) {
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (input != null) {</span>
<span class="nc" id="L292">            boolean found = false;</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (originatingProvider != null) {</span>
<span class="nc" id="L294">                Class[] classes = originatingProvider.getInputTypes();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">                for (int i = 0; i &lt; classes.length; i++) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">                    if (classes[i].isInstance(input)) {</span>
<span class="nc" id="L297">                        found = true;</span>
<span class="nc" id="L298">                        break;</span>
                    }
                }
<span class="nc" id="L301">            } else {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">                if (input instanceof ImageInputStream) {</span>
<span class="nc" id="L303">                    found = true;</span>
                }
            }
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (!found) {</span>
<span class="nc" id="L307">                throw new IllegalArgumentException(&quot;Incorrect input type!&quot;);</span>
            }

<span class="nc" id="L310">            this.seekForwardOnly = seekForwardOnly;</span>
<span class="nc" id="L311">            this.ignoreMetadata = ignoreMetadata;</span>
<span class="nc" id="L312">            this.minIndex = 0;</span>
        }

<span class="nc" id="L315">        this.input = input;</span>
<span class="nc" id="L316">    }</span>

    /**
     * Sets the input source to use to the given
     * &lt;code&gt;ImageInputStream&lt;/code&gt; or other &lt;code&gt;Object&lt;/code&gt;.
     * The input source must be set before any of the query or read
     * methods are used.  If &lt;code&gt;input&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * any currently set input source will be removed.  In any case,
     * the value of &lt;code&gt;minIndex&lt;/code&gt; will be initialized to 0.
     *
     * &lt;p&gt; The &lt;code&gt;seekForwardOnly&lt;/code&gt; parameter controls whether
     * the value returned by &lt;code&gt;getMinIndex&lt;/code&gt; will be
     * increased as each image (or thumbnail, or image metadata) is
     * read.  If &lt;code&gt;seekForwardOnly&lt;/code&gt; is true, then a call to
     * &lt;code&gt;read(index)&lt;/code&gt; will throw an
     * &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; if {@code index &lt; this.minIndex};
     * otherwise, the value of
     * &lt;code&gt;minIndex&lt;/code&gt; will be set to &lt;code&gt;index&lt;/code&gt;.  If
     * &lt;code&gt;seekForwardOnly&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the value of
     * &lt;code&gt;minIndex&lt;/code&gt; will remain 0 regardless of any read
     * operations.
     *
     * &lt;p&gt; This method is equivalent to &lt;code&gt;setInput(input,
     * seekForwardOnly, false)&lt;/code&gt;.
     *
     * @param input the &lt;code&gt;ImageInputStream&lt;/code&gt; or other
     * &lt;code&gt;Object&lt;/code&gt; to use for future decoding.
     * @param seekForwardOnly if &lt;code&gt;true&lt;/code&gt;, images and metadata
     * may only be read in ascending order from this input source.
     *
     * @exception IllegalArgumentException if &lt;code&gt;input&lt;/code&gt; is
     * not an instance of one of the classes returned by the
     * originating service provider's &lt;code&gt;getInputTypes&lt;/code&gt;
     * method, or is not an &lt;code&gt;ImageInputStream&lt;/code&gt;.
     *
     * @see #getInput
     */
    public void setInput(Object input,
                         boolean seekForwardOnly) {
<span class="nc" id="L355">        setInput(input, seekForwardOnly, false);</span>
<span class="nc" id="L356">    }</span>

    /**
     * Sets the input source to use to the given
     * &lt;code&gt;ImageInputStream&lt;/code&gt; or other &lt;code&gt;Object&lt;/code&gt;.
     * The input source must be set before any of the query or read
     * methods are used.  If &lt;code&gt;input&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * any currently set input source will be removed.  In any case,
     * the value of &lt;code&gt;minIndex&lt;/code&gt; will be initialized to 0.
     *
     * &lt;p&gt; This method is equivalent to &lt;code&gt;setInput(input, false,
     * false)&lt;/code&gt;.
     *
     * @param input the &lt;code&gt;ImageInputStream&lt;/code&gt; or other
     * &lt;code&gt;Object&lt;/code&gt; to use for future decoding.
     *
     * @exception IllegalArgumentException if &lt;code&gt;input&lt;/code&gt; is
     * not an instance of one of the classes returned by the
     * originating service provider's &lt;code&gt;getInputTypes&lt;/code&gt;
     * method, or is not an &lt;code&gt;ImageInputStream&lt;/code&gt;.
     *
     * @see #getInput
     */
    public void setInput(Object input) {
<span class="nc" id="L380">        setInput(input, false, false);</span>
<span class="nc" id="L381">    }</span>

    /**
     * Returns the &lt;code&gt;ImageInputStream&lt;/code&gt; or other
     * &lt;code&gt;Object&lt;/code&gt; previously set as the input source.  If the
     * input source has not been set, &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * @return the &lt;code&gt;Object&lt;/code&gt; that will be used for future
     * decoding, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @see ImageInputStream
     * @see #setInput
     */
    public Object getInput() {
<span class="nc" id="L395">        return input;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the current input source has been
     * marked as seek forward only by passing &lt;code&gt;true&lt;/code&gt; as the
     * &lt;code&gt;seekForwardOnly&lt;/code&gt; argument to the
     * &lt;code&gt;setInput&lt;/code&gt; method.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the input source is seek forward
     * only.
     *
     * @see #setInput
     */
    public boolean isSeekForwardOnly() {
<span class="nc" id="L410">        return seekForwardOnly;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the current input source has been
     * marked as allowing metadata to be ignored by passing
     * &lt;code&gt;true&lt;/code&gt; as the &lt;code&gt;ignoreMetadata&lt;/code&gt; argument
     * to the &lt;code&gt;setInput&lt;/code&gt; method.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the metadata may be ignored.
     *
     * @see #setInput
     */
    public boolean isIgnoringMetadata() {
<span class="nc" id="L424">        return ignoreMetadata;</span>
    }

    /**
     * Returns the lowest valid index for reading an image, thumbnail,
     * or image metadata.  If &lt;code&gt;seekForwardOnly()&lt;/code&gt; is
     * &lt;code&gt;false&lt;/code&gt;, this value will typically remain 0,
     * indicating that random access is possible.  Otherwise, it will
     * contain the value of the most recently accessed index, and
     * increase in a monotonic fashion.
     *
     * @return the minimum legal index for reading.
     */
    public int getMinIndex() {
<span class="nc" id="L438">        return minIndex;</span>
    }

    // Localization

    /**
     * Returns an array of &lt;code&gt;Locale&lt;/code&gt;s that may be used to
     * localize warning listeners and compression settings.  A return
     * value of &lt;code&gt;null&lt;/code&gt; indicates that localization is not
     * supported.
     *
     * &lt;p&gt; The default implementation returns a clone of the
     * &lt;code&gt;availableLocales&lt;/code&gt; instance variable if it is
     * non-&lt;code&gt;null&lt;/code&gt;, or else returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an array of &lt;code&gt;Locale&lt;/code&gt;s that may be used as
     * arguments to &lt;code&gt;setLocale&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.
     */
    public Locale[] getAvailableLocales() {
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (availableLocales == null) {</span>
<span class="nc" id="L458">            return null;</span>
        } else {
<span class="nc" id="L460">            return (Locale[])availableLocales.clone();</span>
        }
    }

    /**
     * Sets the current &lt;code&gt;Locale&lt;/code&gt; of this
     * &lt;code&gt;ImageReader&lt;/code&gt; to the given value.  A value of
     * &lt;code&gt;null&lt;/code&gt; removes any previous setting, and indicates
     * that the reader should localize as it sees fit.
     *
     * @param locale the desired &lt;code&gt;Locale&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if &lt;code&gt;locale&lt;/code&gt; is
     * non-&lt;code&gt;null&lt;/code&gt; but is not one of the values returned by
     * &lt;code&gt;getAvailableLocales&lt;/code&gt;.
     *
     * @see #getLocale
     */
    public void setLocale(Locale locale) {
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (locale != null) {</span>
<span class="nc" id="L481">            Locale[] locales = getAvailableLocales();</span>
<span class="nc" id="L482">            boolean found = false;</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">            if (locales != null) {</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                for (int i = 0; i &lt; locales.length; i++) {</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">                    if (locale.equals(locales[i])) {</span>
<span class="nc" id="L486">                        found = true;</span>
<span class="nc" id="L487">                        break;</span>
                    }
                }
            }
<span class="nc bnc" id="L491" title="All 2 branches missed.">            if (!found) {</span>
<span class="nc" id="L492">                throw new IllegalArgumentException(&quot;Invalid locale!&quot;);</span>
            }
        }
<span class="nc" id="L495">        this.locale = locale;</span>
<span class="nc" id="L496">    }</span>

    /**
     * Returns the currently set &lt;code&gt;Locale&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt; if none has been set.
     *
     * @return the current &lt;code&gt;Locale&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #setLocale
     */
    public Locale getLocale() {
<span class="nc" id="L507">        return locale;</span>
    }

    // Image queries

    /**
     * Returns the number of images, not including thumbnails, available
     * from the current input source.
     *
     * &lt;p&gt; Note that some image formats (such as animated GIF) do not
     * specify how many images are present in the stream.  Thus
     * determining the number of images will require the entire stream
     * to be scanned and may require memory for buffering.  If images
     * are to be processed in order, it may be more efficient to
     * simply call &lt;code&gt;read&lt;/code&gt; with increasing indices until an
     * &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; is thrown to indicate
     * that no more images are available.  The
     * &lt;code&gt;allowSearch&lt;/code&gt; parameter may be set to
     * &lt;code&gt;false&lt;/code&gt; to indicate that an exhaustive search is not
     * desired; the return value will be &lt;code&gt;-1&lt;/code&gt; to indicate
     * that a search is necessary.  If the input has been specified
     * with &lt;code&gt;seekForwardOnly&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;,
     * this method throws an &lt;code&gt;IllegalStateException&lt;/code&gt; if
     * &lt;code&gt;allowSearch&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.
     *
     * @param allowSearch if &lt;code&gt;true&lt;/code&gt;, the true number of
     * images will be returned even if a search is required.  If
     * &lt;code&gt;false&lt;/code&gt;, the reader may return &lt;code&gt;-1&lt;/code&gt;
     * without performing the search.
     *
     * @return the number of images, as an &lt;code&gt;int&lt;/code&gt;, or
     * &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;allowSearch&lt;/code&gt; is
     * &lt;code&gt;false&lt;/code&gt; and a search would be required.
     *
     * @exception IllegalStateException if the input source has not been set,
     * or if the input has been specified with &lt;code&gt;seekForwardOnly&lt;/code&gt;
     * set to &lt;code&gt;true&lt;/code&gt;.
     * @exception IOException if an error occurs reading the
     * information from the input source.
     *
     * @see #setInput
     */
    public abstract int getNumImages(boolean allowSearch) throws IOException;

    /**
     * Returns the width in pixels of the given image within the input
     * source.
     *
     * &lt;p&gt; If the image can be rendered to a user-specified size, then
     * this method returns the default width.
     *
     * @param imageIndex the index of the image to be queried.
     *
     * @return the width of the image, as an &lt;code&gt;int&lt;/code&gt;.
     *
     * @exception IllegalStateException if the input source has not been set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IOException if an error occurs reading the width
     * information from the input source.
     */
    public abstract int getWidth(int imageIndex) throws IOException;

    /**
     * Returns the height in pixels of the given image within the
     * input source.
     *
     * &lt;p&gt; If the image can be rendered to a user-specified size, then
     * this method returns the default height.
     *
     * @param imageIndex the index of the image to be queried.
     *
     * @return the height of the image, as an &lt;code&gt;int&lt;/code&gt;.
     *
     * @exception IllegalStateException if the input source has not been set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IOException if an error occurs reading the height
     * information from the input source.
     */
    public abstract int getHeight(int imageIndex) throws IOException;

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the storage format of the given
     * image places no inherent impediment on random access to pixels.
     * For most compressed formats, such as JPEG, this method should
     * return &lt;code&gt;false&lt;/code&gt;, as a large section of the image in
     * addition to the region of interest may need to be decoded.
     *
     * &lt;p&gt; This is merely a hint for programs that wish to be
     * efficient; all readers must be able to read arbitrary regions
     * as specified in an &lt;code&gt;ImageReadParam&lt;/code&gt;.
     *
     * &lt;p&gt; Note that formats that return &lt;code&gt;false&lt;/code&gt; from
     * this method may nonetheless allow tiling (&lt;i&gt;e.g.&lt;/i&gt; Restart
     * Markers in JPEG), and random access will likely be reasonably
     * efficient on tiles.  See {@link #isImageTiled isImageTiled}.
     *
     * &lt;p&gt; A reader for which all images are guaranteed to support
     * easy random access, or are guaranteed not to support easy
     * random access, may return &lt;code&gt;true&lt;/code&gt; or
     * &lt;code&gt;false&lt;/code&gt; respectively without accessing any image
     * data.  In such cases, it is not necessary to throw an exception
     * even if no input source has been set or the image index is out
     * of bounds.
     *
     * &lt;p&gt; The default implementation returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @param imageIndex the index of the image to be queried.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if reading a region of interest of
     * the given image is likely to be efficient.
     *
     * @exception IllegalStateException if an input source is required
     * to determine the return value, but none has been set.
     * @exception IndexOutOfBoundsException if an image must be
     * accessed to determine the return value, but the supplied index
     * is out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public boolean isRandomAccessEasy(int imageIndex) throws IOException {
<span class="nc" id="L628">        return false;</span>
    }

    /**
     * Returns the aspect ratio of the given image (that is, its width
     * divided by its height) as a &lt;code&gt;float&lt;/code&gt;.  For images
     * that are inherently resizable, this method provides a way to
     * determine the appropriate width given a desired height, or vice
     * versa.  For non-resizable images, the true width and height
     * are used.
     *
     * &lt;p&gt; The default implementation simply returns
     * &lt;code&gt;(float)getWidth(imageIndex)/getHeight(imageIndex)&lt;/code&gt;.
     *
     * @param imageIndex the index of the image to be queried.
     *
     * @return a &lt;code&gt;float&lt;/code&gt; indicating the aspect ratio of the
     * given image.
     *
     * @exception IllegalStateException if the input source has not been set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public float getAspectRatio(int imageIndex) throws IOException {
<span class="nc" id="L653">        return (float)getWidth(imageIndex)/getHeight(imageIndex);</span>
    }

    /**
     * Returns an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; indicating the
     * &lt;code&gt;SampleModel&lt;/code&gt; and &lt;code&gt;ColorModel&lt;/code&gt; which most
     * closely represents the &quot;raw&quot; internal format of the image.  For
     * example, for a JPEG image the raw type might have a YCbCr color
     * space even though the image would conventionally be transformed
     * into an RGB color space prior to display.  The returned value
     * should also be included in the list of values returned by
     * &lt;code&gt;getImageTypes&lt;/code&gt;.
     *
     * &lt;p&gt; The default implementation simply returns the first entry
     * from the list provided by &lt;code&gt;getImageType&lt;/code&gt;.
     *
     * @param imageIndex the index of the image to be queried.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;.
     *
     * @exception IllegalStateException if the input source has not been set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IOException if an error occurs reading the format
     * information from the input source.
     */
    public ImageTypeSpecifier getRawImageType(int imageIndex)
        throws IOException {
<span class="nc" id="L681">        return (ImageTypeSpecifier)getImageTypes(imageIndex).next();</span>
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing possible image
     * types to which the given image may be decoded, in the form of
     * &lt;code&gt;ImageTypeSpecifiers&lt;/code&gt;s.  At least one legal image
     * type will be returned.
     *
     * &lt;p&gt; The first element of the iterator should be the most
     * &quot;natural&quot; type for decoding the image with as little loss as
     * possible.  For example, for a JPEG image the first entry should
     * be an RGB image, even though the image data is stored
     * internally in a YCbCr color space.
     *
     * @param imageIndex the index of the image to be
     * &lt;code&gt;retrieved&lt;/code&gt;.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; containing at least one
     * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; representing suggested image
     * types for decoding the current given image.
     *
     * @exception IllegalStateException if the input source has not been set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IOException if an error occurs reading the format
     * information from the input source.
     *
     * @see ImageReadParam#setDestination(BufferedImage)
     * @see ImageReadParam#setDestinationType(ImageTypeSpecifier)
     */
    public abstract Iterator&lt;ImageTypeSpecifier&gt;
        getImageTypes(int imageIndex) throws IOException;

    /**
     * Returns a default &lt;code&gt;ImageReadParam&lt;/code&gt; object
     * appropriate for this format.  All subclasses should define a
     * set of default values for all parameters and return them with
     * this call.  This method may be called before the input source
     * is set.
     *
     * &lt;p&gt; The default implementation constructs and returns a new
     * &lt;code&gt;ImageReadParam&lt;/code&gt; object that does not allow source
     * scaling (&lt;i&gt;i.e.&lt;/i&gt;, it returns &lt;code&gt;new
     * ImageReadParam()&lt;/code&gt;.
     *
     * @return an &lt;code&gt;ImageReadParam&lt;/code&gt; object which may be used
     * to control the decoding process using a set of default settings.
     */
    public ImageReadParam getDefaultReadParam() {
<span class="nc" id="L731">        return new ImageReadParam();</span>
    }

    /**
     * Returns an &lt;code&gt;IIOMetadata&lt;/code&gt; object representing the
     * metadata associated with the input source as a whole (i.e., not
     * associated with any particular image), or &lt;code&gt;null&lt;/code&gt; if
     * the reader does not support reading metadata, is set to ignore
     * metadata, or if no metadata is available.
     *
     * @return an &lt;code&gt;IIOMetadata&lt;/code&gt; object, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IOException if an error occurs during reading.
     */
    public abstract IIOMetadata getStreamMetadata() throws IOException;

    /**
     * Returns an &lt;code&gt;IIOMetadata&lt;/code&gt; object representing the
     * metadata associated with the input source as a whole (i.e.,
     * not associated with any particular image).  If no such data
     * exists, &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * &lt;p&gt; The resulting metadata object is only responsible for
     * returning documents in the format named by
     * &lt;code&gt;formatName&lt;/code&gt;.  Within any documents that are
     * returned, only nodes whose names are members of
     * &lt;code&gt;nodeNames&lt;/code&gt; are required to be returned.  In this
     * way, the amount of metadata processing done by the reader may
     * be kept to a minimum, based on what information is actually
     * needed.
     *
     * &lt;p&gt; If &lt;code&gt;formatName&lt;/code&gt; is not the name of a supported
     * metadata format, &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * &lt;p&gt; In all cases, it is legal to return a more capable metadata
     * object than strictly necessary.  The format name and node names
     * are merely hints that may be used to reduce the reader's
     * workload.
     *
     * &lt;p&gt; The default implementation simply returns the result of
     * calling &lt;code&gt;getStreamMetadata()&lt;/code&gt;, after checking that
     * the format name is supported.  If it is not,
     * &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * @param formatName a metadata format name that may be used to retrieve
     * a document from the returned &lt;code&gt;IIOMetadata&lt;/code&gt; object.
     * @param nodeNames a &lt;code&gt;Set&lt;/code&gt; containing the names of
     * nodes that may be contained in a retrieved document.
     *
     * @return an &lt;code&gt;IIOMetadata&lt;/code&gt; object, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if &lt;code&gt;formatName&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;nodeNames&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an error occurs during reading.
     */
    public IIOMetadata getStreamMetadata(String formatName,
                                         Set&lt;String&gt; nodeNames)
        throws IOException
    {
<span class="nc" id="L792">        return getMetadata(formatName, nodeNames, true, 0);</span>
    }

    private IIOMetadata getMetadata(String formatName,
                                    Set nodeNames,
                                    boolean wantStream,
                                    int imageIndex) throws IOException {
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (formatName == null) {</span>
<span class="nc" id="L800">            throw new IllegalArgumentException(&quot;formatName == null!&quot;);</span>
        }
<span class="nc bnc" id="L802" title="All 2 branches missed.">        if (nodeNames == null) {</span>
<span class="nc" id="L803">            throw new IllegalArgumentException(&quot;nodeNames == null!&quot;);</span>
        }
<span class="nc bnc" id="L805" title="All 2 branches missed.">        IIOMetadata metadata =</span>
            wantStream
<span class="nc" id="L807">            ? getStreamMetadata()</span>
<span class="nc" id="L808">            : getImageMetadata(imageIndex);</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">        if (metadata != null) {</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">            if (metadata.isStandardMetadataFormatSupported() &amp;&amp;</span>
                formatName.equals
<span class="nc bnc" id="L812" title="All 2 branches missed.">                (IIOMetadataFormatImpl.standardMetadataFormatName)) {</span>
<span class="nc" id="L813">                return metadata;</span>
            }
<span class="nc" id="L815">            String nativeName = metadata.getNativeMetadataFormatName();</span>
<span class="nc bnc" id="L816" title="All 4 branches missed.">            if (nativeName != null &amp;&amp; formatName.equals(nativeName)) {</span>
<span class="nc" id="L817">                return metadata;</span>
            }
<span class="nc" id="L819">            String[] extraNames = metadata.getExtraMetadataFormatNames();</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (extraNames != null) {</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">                for (int i = 0; i &lt; extraNames.length; i++) {</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">                    if (formatName.equals(extraNames[i])) {</span>
<span class="nc" id="L823">                        return metadata;</span>
                    }
                }
            }
        }
<span class="nc" id="L828">        return null;</span>
    }

    /**
     * Returns an &lt;code&gt;IIOMetadata&lt;/code&gt; object containing metadata
     * associated with the given image, or &lt;code&gt;null&lt;/code&gt; if the
     * reader does not support reading metadata, is set to ignore
     * metadata, or if no metadata is available.
     *
     * @param imageIndex the index of the image whose metadata is to
     * be retrieved.
     *
     * @return an &lt;code&gt;IIOMetadata&lt;/code&gt; object, or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalStateException if the input source has not been
     * set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public abstract IIOMetadata getImageMetadata(int imageIndex)
        throws IOException;

    /**
     * Returns an &lt;code&gt;IIOMetadata&lt;/code&gt; object representing the
     * metadata associated with the given image, or &lt;code&gt;null&lt;/code&gt;
     * if the reader does not support reading metadata or none
     * is available.
     *
     * &lt;p&gt; The resulting metadata object is only responsible for
     * returning documents in the format named by
     * &lt;code&gt;formatName&lt;/code&gt;.  Within any documents that are
     * returned, only nodes whose names are members of
     * &lt;code&gt;nodeNames&lt;/code&gt; are required to be returned.  In this
     * way, the amount of metadata processing done by the reader may
     * be kept to a minimum, based on what information is actually
     * needed.
     *
     * &lt;p&gt; If &lt;code&gt;formatName&lt;/code&gt; is not the name of a supported
     * metadata format, &lt;code&gt;null&lt;/code&gt; may be returned.
     *
     * &lt;p&gt; In all cases, it is legal to return a more capable metadata
     * object than strictly necessary.  The format name and node names
     * are merely hints that may be used to reduce the reader's
     * workload.
     *
     * &lt;p&gt; The default implementation simply returns the result of
     * calling &lt;code&gt;getImageMetadata(imageIndex)&lt;/code&gt;, after
     * checking that the format name is supported.  If it is not,
     * &lt;code&gt;null&lt;/code&gt; is returned.
     *
     * @param imageIndex the index of the image whose metadata is to
     * be retrieved.
     * @param formatName a metadata format name that may be used to retrieve
     * a document from the returned &lt;code&gt;IIOMetadata&lt;/code&gt; object.
     * @param nodeNames a &lt;code&gt;Set&lt;/code&gt; containing the names of
     * nodes that may be contained in a retrieved document.
     *
     * @return an &lt;code&gt;IIOMetadata&lt;/code&gt; object, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception IllegalStateException if the input source has not been
     * set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IllegalArgumentException if &lt;code&gt;formatName&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;nodeNames&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IOException if an error occurs during reading.
     */
    public IIOMetadata getImageMetadata(int imageIndex,
                                        String formatName,
                                        Set&lt;String&gt; nodeNames)
        throws IOException {
<span class="nc" id="L903">        return getMetadata(formatName, nodeNames, false, imageIndex);</span>
    }

    /**
     * Reads the image indexed by &lt;code&gt;imageIndex&lt;/code&gt; and returns
     * it as a complete &lt;code&gt;BufferedImage&lt;/code&gt;, using a default
     * &lt;code&gt;ImageReadParam&lt;/code&gt;.  This is a convenience method
     * that calls &lt;code&gt;read(imageIndex, null)&lt;/code&gt;.
     *
     * &lt;p&gt; The image returned will be formatted according to the first
     * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; returned from
     * &lt;code&gt;getImageTypes&lt;/code&gt;.
     *
     * &lt;p&gt; Any registered &lt;code&gt;IIOReadProgressListener&lt;/code&gt; objects
     * will be notified by calling their &lt;code&gt;imageStarted&lt;/code&gt;
     * method, followed by calls to their &lt;code&gt;imageProgress&lt;/code&gt;
     * method as the read progresses.  Finally their
     * &lt;code&gt;imageComplete&lt;/code&gt; method will be called.
     * &lt;code&gt;IIOReadUpdateListener&lt;/code&gt; objects may be updated at
     * other times during the read as pixels are decoded.  Finally,
     * &lt;code&gt;IIOReadWarningListener&lt;/code&gt; objects will receive
     * notification of any non-fatal warnings that occur during
     * decoding.
     *
     * @param imageIndex the index of the image to be retrieved.
     *
     * @return the desired portion of the image as a
     * &lt;code&gt;BufferedImage&lt;/code&gt;.
     *
     * @exception IllegalStateException if the input source has not been
     * set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public BufferedImage read(int imageIndex) throws IOException {
<span class="nc" id="L939">        return read(imageIndex, null);</span>
    }

    /**
     * Reads the image indexed by &lt;code&gt;imageIndex&lt;/code&gt; and returns
     * it as a complete &lt;code&gt;BufferedImage&lt;/code&gt;, using a supplied
     * &lt;code&gt;ImageReadParam&lt;/code&gt;.
     *
     * &lt;p&gt; The actual &lt;code&gt;BufferedImage&lt;/code&gt; returned will be
     * chosen using the algorithm defined by the
     * &lt;code&gt;getDestination&lt;/code&gt; method.
     *
     * &lt;p&gt; Any registered &lt;code&gt;IIOReadProgressListener&lt;/code&gt; objects
     * will be notified by calling their &lt;code&gt;imageStarted&lt;/code&gt;
     * method, followed by calls to their &lt;code&gt;imageProgress&lt;/code&gt;
     * method as the read progresses.  Finally their
     * &lt;code&gt;imageComplete&lt;/code&gt; method will be called.
     * &lt;code&gt;IIOReadUpdateListener&lt;/code&gt; objects may be updated at
     * other times during the read as pixels are decoded.  Finally,
     * &lt;code&gt;IIOReadWarningListener&lt;/code&gt; objects will receive
     * notification of any non-fatal warnings that occur during
     * decoding.
     *
     * &lt;p&gt; The set of source bands to be read and destination bands to
     * be written is determined by calling &lt;code&gt;getSourceBands&lt;/code&gt;
     * and &lt;code&gt;getDestinationBands&lt;/code&gt; on the supplied
     * &lt;code&gt;ImageReadParam&lt;/code&gt;.  If the lengths of the arrays
     * returned by these methods differ, the set of source bands
     * contains an index larger that the largest available source
     * index, or the set of destination bands contains an index larger
     * than the largest legal destination index, an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; If the supplied &lt;code&gt;ImageReadParam&lt;/code&gt; contains
     * optional setting values not supported by this reader (&lt;i&gt;e.g.&lt;/i&gt;
     * source render size or any format-specific settings), they will
     * be ignored.
     *
     * @param imageIndex the index of the image to be retrieved.
     * @param param an &lt;code&gt;ImageReadParam&lt;/code&gt; used to control
     * the reading process, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the desired portion of the image as a
     * &lt;code&gt;BufferedImage&lt;/code&gt;.
     *
     * @exception IllegalStateException if the input source has not been
     * set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IllegalArgumentException if the set of source and
     * destination bands specified by
     * &lt;code&gt;param.getSourceBands&lt;/code&gt; and
     * &lt;code&gt;param.getDestinationBands&lt;/code&gt; differ in length or
     * include indices that are out of bounds.
     * @exception IllegalArgumentException if the resulting image would
     * have a width or height less than 1.
     * @exception IOException if an error occurs during reading.
     */
    public abstract BufferedImage read(int imageIndex, ImageReadParam param)
        throws IOException;

    /**
     * Reads the image indexed by &lt;code&gt;imageIndex&lt;/code&gt; and returns
     * an &lt;code&gt;IIOImage&lt;/code&gt; containing the image, thumbnails, and
     * associated image metadata, using a supplied
     * &lt;code&gt;ImageReadParam&lt;/code&gt;.
     *
     * &lt;p&gt; The actual &lt;code&gt;BufferedImage&lt;/code&gt; referenced by the
     * returned &lt;code&gt;IIOImage&lt;/code&gt; will be chosen using the
     * algorithm defined by the &lt;code&gt;getDestination&lt;/code&gt; method.
     *
     * &lt;p&gt; Any registered &lt;code&gt;IIOReadProgressListener&lt;/code&gt; objects
     * will be notified by calling their &lt;code&gt;imageStarted&lt;/code&gt;
     * method, followed by calls to their &lt;code&gt;imageProgress&lt;/code&gt;
     * method as the read progresses.  Finally their
     * &lt;code&gt;imageComplete&lt;/code&gt; method will be called.
     * &lt;code&gt;IIOReadUpdateListener&lt;/code&gt; objects may be updated at
     * other times during the read as pixels are decoded.  Finally,
     * &lt;code&gt;IIOReadWarningListener&lt;/code&gt; objects will receive
     * notification of any non-fatal warnings that occur during
     * decoding.
     *
     * &lt;p&gt; The set of source bands to be read and destination bands to
     * be written is determined by calling &lt;code&gt;getSourceBands&lt;/code&gt;
     * and &lt;code&gt;getDestinationBands&lt;/code&gt; on the supplied
     * &lt;code&gt;ImageReadParam&lt;/code&gt;.  If the lengths of the arrays
     * returned by these methods differ, the set of source bands
     * contains an index larger that the largest available source
     * index, or the set of destination bands contains an index larger
     * than the largest legal destination index, an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; Thumbnails will be returned in their entirety regardless of
     * the region settings.
     *
     * &lt;p&gt; If the supplied &lt;code&gt;ImageReadParam&lt;/code&gt; contains
     * optional setting values not supported by this reader (&lt;i&gt;e.g.&lt;/i&gt;
     * source render size or any format-specific settings), those
     * values will be ignored.
     *
     * @param imageIndex the index of the image to be retrieved.
     * @param param an &lt;code&gt;ImageReadParam&lt;/code&gt; used to control
     * the reading process, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an &lt;code&gt;IIOImage&lt;/code&gt; containing the desired portion
     * of the image, a set of thumbnails, and associated image
     * metadata.
     *
     * @exception IllegalStateException if the input source has not been
     * set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IllegalArgumentException if the set of source and
     * destination bands specified by
     * &lt;code&gt;param.getSourceBands&lt;/code&gt; and
     * &lt;code&gt;param.getDestinationBands&lt;/code&gt; differ in length or
     * include indices that are out of bounds.
     * @exception IllegalArgumentException if the resulting image
     * would have a width or height less than 1.
     * @exception IOException if an error occurs during reading.
     */
    public IIOImage readAll(int imageIndex, ImageReadParam param)
        throws IOException {
<span class="nc bnc" id="L1062" title="All 2 branches missed.">        if (imageIndex &lt; getMinIndex()) {</span>
<span class="nc" id="L1063">            throw new IndexOutOfBoundsException(&quot;imageIndex &lt; getMinIndex()!&quot;);</span>
        }

<span class="nc" id="L1066">        BufferedImage im = read(imageIndex, param);</span>

<span class="nc" id="L1068">        ArrayList thumbnails = null;</span>
<span class="nc" id="L1069">        int numThumbnails = getNumThumbnails(imageIndex);</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">        if (numThumbnails &gt; 0) {</span>
<span class="nc" id="L1071">            thumbnails = new ArrayList();</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            for (int j = 0; j &lt; numThumbnails; j++) {</span>
<span class="nc" id="L1073">                thumbnails.add(readThumbnail(imageIndex, j));</span>
            }
        }

<span class="nc" id="L1077">        IIOMetadata metadata = getImageMetadata(imageIndex);</span>
<span class="nc" id="L1078">        return new IIOImage(im, thumbnails, metadata);</span>
    }

    /**
     * Returns an &lt;code&gt;Iterator&lt;/code&gt; containing all the images,
     * thumbnails, and metadata, starting at the index given by
     * &lt;code&gt;getMinIndex&lt;/code&gt;, from the input source in the form of
     * &lt;code&gt;IIOImage&lt;/code&gt; objects.  An &lt;code&gt;Iterator&lt;/code&gt;
     * containing &lt;code&gt;ImageReadParam&lt;/code&gt; objects is supplied; one
     * element is consumed for each image read from the input source
     * until no more images are available.  If the read param
     * &lt;code&gt;Iterator&lt;/code&gt; runs out of elements, but there are still
     * more images available from the input source, default read
     * params are used for the remaining images.
     *
     * &lt;p&gt; If &lt;code&gt;params&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, a default read
     * param will be used for all images.
     *
     * &lt;p&gt; The actual &lt;code&gt;BufferedImage&lt;/code&gt; referenced by the
     * returned &lt;code&gt;IIOImage&lt;/code&gt; will be chosen using the
     * algorithm defined by the &lt;code&gt;getDestination&lt;/code&gt; method.
     *
     * &lt;p&gt; Any registered &lt;code&gt;IIOReadProgressListener&lt;/code&gt; objects
     * will be notified by calling their &lt;code&gt;sequenceStarted&lt;/code&gt;
     * method once.  Then, for each image decoded, there will be a
     * call to &lt;code&gt;imageStarted&lt;/code&gt;, followed by calls to
     * &lt;code&gt;imageProgress&lt;/code&gt; as the read progresses, and finally
     * to &lt;code&gt;imageComplete&lt;/code&gt;.  The
     * &lt;code&gt;sequenceComplete&lt;/code&gt; method will be called after the
     * last image has been decoded.
     * &lt;code&gt;IIOReadUpdateListener&lt;/code&gt; objects may be updated at
     * other times during the read as pixels are decoded.  Finally,
     * &lt;code&gt;IIOReadWarningListener&lt;/code&gt; objects will receive
     * notification of any non-fatal warnings that occur during
     * decoding.
     *
     * &lt;p&gt; The set of source bands to be read and destination bands to
     * be written is determined by calling &lt;code&gt;getSourceBands&lt;/code&gt;
     * and &lt;code&gt;getDestinationBands&lt;/code&gt; on the supplied
     * &lt;code&gt;ImageReadParam&lt;/code&gt;.  If the lengths of the arrays
     * returned by these methods differ, the set of source bands
     * contains an index larger that the largest available source
     * index, or the set of destination bands contains an index larger
     * than the largest legal destination index, an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; Thumbnails will be returned in their entirety regardless of the
     * region settings.
     *
     * &lt;p&gt; If any of the supplied &lt;code&gt;ImageReadParam&lt;/code&gt;s contain
     * optional setting values not supported by this reader (&lt;i&gt;e.g.&lt;/i&gt;
     * source render size or any format-specific settings), they will
     * be ignored.
     *
     * @param params an &lt;code&gt;Iterator&lt;/code&gt; containing
     * &lt;code&gt;ImageReadParam&lt;/code&gt; objects.
     *
     * @return an &lt;code&gt;Iterator&lt;/code&gt; representing the
     * contents of the input source as &lt;code&gt;IIOImage&lt;/code&gt;s.
     *
     * @exception IllegalStateException if the input source has not been
     * set.
     * @exception IllegalArgumentException if any
     * non-&lt;code&gt;null&lt;/code&gt; element of &lt;code&gt;params&lt;/code&gt; is not an
     * &lt;code&gt;ImageReadParam&lt;/code&gt;.
     * @exception IllegalArgumentException if the set of source and
     * destination bands specified by
     * &lt;code&gt;param.getSourceBands&lt;/code&gt; and
     * &lt;code&gt;param.getDestinationBands&lt;/code&gt; differ in length or
     * include indices that are out of bounds.
     * @exception IllegalArgumentException if a resulting image would
     * have a width or height less than 1.
     * @exception IOException if an error occurs during reading.
     *
     * @see ImageReadParam
     * @see IIOImage
     */
    public Iterator&lt;IIOImage&gt;
        readAll(Iterator&lt;? extends ImageReadParam&gt; params)
        throws IOException
    {
<span class="nc" id="L1159">        List output = new ArrayList();</span>

<span class="nc" id="L1161">        int imageIndex = getMinIndex();</span>

        // Inform IIOReadProgressListeners we're starting a sequence
<span class="nc" id="L1164">        processSequenceStarted(imageIndex);</span>

        while (true) {
            // Inform IIOReadProgressListeners and IIOReadUpdateListeners
            // that we're starting a new image

<span class="nc" id="L1170">            ImageReadParam param = null;</span>
<span class="nc bnc" id="L1171" title="All 4 branches missed.">            if (params != null &amp;&amp; params.hasNext()) {</span>
<span class="nc" id="L1172">                Object o = params.next();</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">                if (o != null) {</span>
<span class="nc bnc" id="L1174" title="All 2 branches missed.">                    if (o instanceof ImageReadParam) {</span>
<span class="nc" id="L1175">                        param = (ImageReadParam)o;</span>
                    } else {
<span class="nc" id="L1177">                        throw new IllegalArgumentException</span>
                            (&quot;Non-ImageReadParam supplied as part of params!&quot;);
                    }
                }
            }

<span class="nc" id="L1183">            BufferedImage bi = null;</span>
            try {
<span class="nc" id="L1185">                bi = read(imageIndex, param);</span>
<span class="nc" id="L1186">            } catch (IndexOutOfBoundsException e) {</span>
<span class="nc" id="L1187">                break;</span>
<span class="nc" id="L1188">            }</span>

<span class="nc" id="L1190">            ArrayList thumbnails = null;</span>
<span class="nc" id="L1191">            int numThumbnails = getNumThumbnails(imageIndex);</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">            if (numThumbnails &gt; 0) {</span>
<span class="nc" id="L1193">                thumbnails = new ArrayList();</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">                for (int j = 0; j &lt; numThumbnails; j++) {</span>
<span class="nc" id="L1195">                    thumbnails.add(readThumbnail(imageIndex, j));</span>
                }
            }

<span class="nc" id="L1199">            IIOMetadata metadata = getImageMetadata(imageIndex);</span>
<span class="nc" id="L1200">            IIOImage im = new IIOImage(bi, thumbnails, metadata);</span>
<span class="nc" id="L1201">            output.add(im);</span>

<span class="nc" id="L1203">            ++imageIndex;</span>
<span class="nc" id="L1204">        }</span>

        // Inform IIOReadProgressListeners we're ending a sequence
<span class="nc" id="L1207">        processSequenceComplete();</span>

<span class="nc" id="L1209">        return output.iterator();</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this plug-in supports reading
     * just a {@link java.awt.image.Raster Raster} of pixel data.
     * If this method returns &lt;code&gt;false&lt;/code&gt;, calls to
     * {@link #readRaster readRaster} or {@link #readTileRaster readTileRaster}
     * will throw an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * &lt;p&gt; The default implementation returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this plug-in supports reading raw
     * &lt;code&gt;Raster&lt;/code&gt;s.
     *
     * @see #readRaster
     * @see #readTileRaster
     */
    public boolean canReadRaster() {
<span class="nc" id="L1228">        return false;</span>
    }

    /**
     * Returns a new &lt;code&gt;Raster&lt;/code&gt; object containing the raw pixel data
     * from the image stream, without any color conversion applied.  The
     * application must determine how to interpret the pixel data by other
     * means.  Any destination or image-type parameters in the supplied
     * &lt;code&gt;ImageReadParam&lt;/code&gt; object are ignored, but all other
     * parameters are used exactly as in the {@link #read read}
     * method, except that any destination offset is used as a logical rather
     * than a physical offset.  The size of the returned &lt;code&gt;Raster&lt;/code&gt;
     * will always be that of the source region clipped to the actual image.
     * Logical offsets in the stream itself are ignored.
     *
     * &lt;p&gt; This method allows formats that normally apply a color
     * conversion, such as JPEG, and formats that do not normally have an
     * associated colorspace, such as remote sensing or medical imaging data,
     * to provide access to raw pixel data.
     *
     * &lt;p&gt; Any registered &lt;code&gt;readUpdateListener&lt;/code&gt;s are ignored, as
     * there is no &lt;code&gt;BufferedImage&lt;/code&gt;, but all other listeners are
     * called exactly as they are for the {@link #read read} method.
     *
     * &lt;p&gt; If {@link #canReadRaster canReadRaster()} returns
     * &lt;code&gt;false&lt;/code&gt;, this method throws an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * &lt;p&gt; If the supplied &lt;code&gt;ImageReadParam&lt;/code&gt; contains
     * optional setting values not supported by this reader (&lt;i&gt;e.g.&lt;/i&gt;
     * source render size or any format-specific settings), they will
     * be ignored.
     *
     * &lt;p&gt; The default implementation throws an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @param imageIndex the index of the image to be read.
     * @param param an &lt;code&gt;ImageReadParam&lt;/code&gt; used to control
     * the reading process, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the desired portion of the image as a
     * &lt;code&gt;Raster&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if this plug-in does not
     * support reading raw &lt;code&gt;Raster&lt;/code&gt;s.
     * @exception IllegalStateException if the input source has not been
     * set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IOException if an error occurs during reading.
     *
     * @see #canReadRaster
     * @see #read
     * @see java.awt.image.Raster
     */
    public Raster readRaster(int imageIndex, ImageReadParam param)
        throws IOException {
<span class="nc" id="L1285">        throw new UnsupportedOperationException(&quot;readRaster not supported!&quot;);</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the image is organized into
     * &lt;i&gt;tiles&lt;/i&gt;, that is, equal-sized non-overlapping rectangles.
     *
     * &lt;p&gt; A reader plug-in may choose whether or not to expose tiling
     * that is present in the image as it is stored.  It may even
     * choose to advertise tiling when none is explicitly present.  In
     * general, tiling should only be advertised if there is some
     * advantage (in speed or space) to accessing individual tiles.
     * Regardless of whether the reader advertises tiling, it must be
     * capable of reading an arbitrary rectangular region specified in
     * an &lt;code&gt;ImageReadParam&lt;/code&gt;.
     *
     * &lt;p&gt; A reader for which all images are guaranteed to be tiled,
     * or are guaranteed not to be tiled, may return &lt;code&gt;true&lt;/code&gt;
     * or &lt;code&gt;false&lt;/code&gt; respectively without accessing any image
     * data.  In such cases, it is not necessary to throw an exception
     * even if no input source has been set or the image index is out
     * of bounds.
     *
     * &lt;p&gt; The default implementation just returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @param imageIndex the index of the image to be queried.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the image is tiled.
     *
     * @exception IllegalStateException if an input source is required
     * to determine the return value, but none has been set.
     * @exception IndexOutOfBoundsException if an image must be
     * accessed to determine the return value, but the supplied index
     * is out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public boolean isImageTiled(int imageIndex) throws IOException {
<span class="nc" id="L1322">        return false;</span>
    }

    /**
     * Returns the width of a tile in the given image.
     *
     * &lt;p&gt; The default implementation simply returns
     * &lt;code&gt;getWidth(imageIndex)&lt;/code&gt;, which is correct for
     * non-tiled images.  Readers that support tiling should override
     * this method.
     *
     * @return the width of a tile.
     *
     * @param imageIndex the index of the image to be queried.
     *
     * @exception IllegalStateException if the input source has not been set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public int getTileWidth(int imageIndex) throws IOException {
<span class="nc" id="L1343">        return getWidth(imageIndex);</span>
    }

    /**
     * Returns the height of a tile in the given image.
     *
     * &lt;p&gt; The default implementation simply returns
     * &lt;code&gt;getHeight(imageIndex)&lt;/code&gt;, which is correct for
     * non-tiled images.  Readers that support tiling should override
     * this method.
     *
     * @return the height of a tile.
     *
     * @param imageIndex the index of the image to be queried.
     *
     * @exception IllegalStateException if the input source has not been set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public int getTileHeight(int imageIndex) throws IOException {
<span class="nc" id="L1364">        return getHeight(imageIndex);</span>
    }

    /**
     * Returns the X coordinate of the upper-left corner of tile (0,
     * 0) in the given image.
     *
     * &lt;p&gt; A reader for which the tile grid X offset always has the
     * same value (usually 0), may return the value without accessing
     * any image data.  In such cases, it is not necessary to throw an
     * exception even if no input source has been set or the image
     * index is out of bounds.
     *
     * &lt;p&gt; The default implementation simply returns 0, which is
     * correct for non-tiled images and tiled images in most formats.
     * Readers that support tiling with non-(0, 0) offsets should
     * override this method.
     *
     * @return the X offset of the tile grid.
     *
     * @param imageIndex the index of the image to be queried.
     *
     * @exception IllegalStateException if an input source is required
     * to determine the return value, but none has been set.
     * @exception IndexOutOfBoundsException if an image must be
     * accessed to determine the return value, but the supplied index
     * is out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public int getTileGridXOffset(int imageIndex) throws IOException {
<span class="nc" id="L1394">        return 0;</span>
    }

    /**
     * Returns the Y coordinate of the upper-left corner of tile (0,
     * 0) in the given image.
     *
     * &lt;p&gt; A reader for which the tile grid Y offset always has the
     * same value (usually 0), may return the value without accessing
     * any image data.  In such cases, it is not necessary to throw an
     * exception even if no input source has been set or the image
     * index is out of bounds.
     *
     * &lt;p&gt; The default implementation simply returns 0, which is
     * correct for non-tiled images and tiled images in most formats.
     * Readers that support tiling with non-(0, 0) offsets should
     * override this method.
     *
     * @return the Y offset of the tile grid.
     *
     * @param imageIndex the index of the image to be queried.
     *
     * @exception IllegalStateException if an input source is required
     * to determine the return value, but none has been set.
     * @exception IndexOutOfBoundsException if an image must be
     * accessed to determine the return value, but the supplied index
     * is out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public int getTileGridYOffset(int imageIndex) throws IOException {
<span class="nc" id="L1424">        return 0;</span>
    }

    /**
     * Reads the tile indicated by the &lt;code&gt;tileX&lt;/code&gt; and
     * &lt;code&gt;tileY&lt;/code&gt; arguments, returning it as a
     * &lt;code&gt;BufferedImage&lt;/code&gt;.  If the arguments are out of range,
     * an &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.  If the
     * image is not tiled, the values 0, 0 will return the entire
     * image; any other values will cause an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; to be thrown.
     *
     * &lt;p&gt; This method is merely a convenience equivalent to calling
     * &lt;code&gt;read(int, ImageReadParam)&lt;/code&gt; with a read param
     * specifying a source region having offsets of
     * &lt;code&gt;tileX*getTileWidth(imageIndex)&lt;/code&gt;,
     * &lt;code&gt;tileY*getTileHeight(imageIndex)&lt;/code&gt; and width and
     * height of &lt;code&gt;getTileWidth(imageIndex)&lt;/code&gt;,
     * &lt;code&gt;getTileHeight(imageIndex)&lt;/code&gt;; and subsampling
     * factors of 1 and offsets of 0.  To subsample a tile, call
     * &lt;code&gt;read&lt;/code&gt; with a read param specifying this region
     * and different subsampling parameters.
     *
     * &lt;p&gt; The default implementation returns the entire image if
     * &lt;code&gt;tileX&lt;/code&gt; and &lt;code&gt;tileY&lt;/code&gt; are 0, or throws
     * an &lt;code&gt;IllegalArgumentException&lt;/code&gt; otherwise.
     *
     * @param imageIndex the index of the image to be retrieved.
     * @param tileX the column index (starting with 0) of the tile
     * to be retrieved.
     * @param tileY the row index (starting with 0) of the tile
     * to be retrieved.
     *
     * @return the tile as a &lt;code&gt;BufferedImage&lt;/code&gt;.
     *
     * @exception IllegalStateException if the input source has not been
     * set.
     * @exception IndexOutOfBoundsException if &lt;code&gt;imageIndex&lt;/code&gt;
     * is out of bounds.
     * @exception IllegalArgumentException if the tile indices are
     * out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public BufferedImage readTile(int imageIndex,
                                  int tileX, int tileY) throws IOException {
<span class="nc bnc" id="L1469" title="All 4 branches missed.">        if ((tileX != 0) || (tileY != 0)) {</span>
<span class="nc" id="L1470">            throw new IllegalArgumentException(&quot;Invalid tile indices&quot;);</span>
        }
<span class="nc" id="L1472">        return read(imageIndex);</span>
    }

    /**
     * Returns a new &lt;code&gt;Raster&lt;/code&gt; object containing the raw
     * pixel data from the tile, without any color conversion applied.
     * The application must determine how to interpret the pixel data by other
     * means.
     *
     * &lt;p&gt; If {@link #canReadRaster canReadRaster()} returns
     * &lt;code&gt;false&lt;/code&gt;, this method throws an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * &lt;p&gt; The default implementation checks if reading
     * &lt;code&gt;Raster&lt;/code&gt;s is supported, and if so calls {@link
     * #readRaster readRaster(imageIndex, null)} if
     * &lt;code&gt;tileX&lt;/code&gt; and &lt;code&gt;tileY&lt;/code&gt; are 0, or throws an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; otherwise.
     *
     * @param imageIndex the index of the image to be retrieved.
     * @param tileX the column index (starting with 0) of the tile
     * to be retrieved.
     * @param tileY the row index (starting with 0) of the tile
     * to be retrieved.
     *
     * @return the tile as a &lt;code&gt;Raster&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if this plug-in does not
     * support reading raw &lt;code&gt;Raster&lt;/code&gt;s.
     * @exception IllegalArgumentException if the tile indices are
     * out of bounds.
     * @exception IllegalStateException if the input source has not been
     * set.
     * @exception IndexOutOfBoundsException if &lt;code&gt;imageIndex&lt;/code&gt;
     * is out of bounds.
     * @exception IOException if an error occurs during reading.
     *
     * @see #readTile
     * @see #readRaster
     * @see java.awt.image.Raster
     */
    public Raster readTileRaster(int imageIndex,
                                 int tileX, int tileY) throws IOException {
<span class="nc bnc" id="L1515" title="All 2 branches missed.">        if (!canReadRaster()) {</span>
<span class="nc" id="L1516">            throw new UnsupportedOperationException</span>
                (&quot;readTileRaster not supported!&quot;);
        }
<span class="nc bnc" id="L1519" title="All 4 branches missed.">        if ((tileX != 0) || (tileY != 0)) {</span>
<span class="nc" id="L1520">            throw new IllegalArgumentException(&quot;Invalid tile indices&quot;);</span>
        }
<span class="nc" id="L1522">        return readRaster(imageIndex, null);</span>
    }

    // RenderedImages

    /**
     * Returns a &lt;code&gt;RenderedImage&lt;/code&gt; object that contains the
     * contents of the image indexed by &lt;code&gt;imageIndex&lt;/code&gt;.  By
     * default, the returned image is simply the
     * &lt;code&gt;BufferedImage&lt;/code&gt; returned by &lt;code&gt;read(imageIndex,
     * param)&lt;/code&gt;.
     *
     * &lt;p&gt; The semantics of this method may differ from those of the
     * other &lt;code&gt;read&lt;/code&gt; methods in several ways.  First, any
     * destination image and/or image type set in the
     * &lt;code&gt;ImageReadParam&lt;/code&gt; may be ignored.  Second, the usual
     * listener calls are not guaranteed to be made, or to be
     * meaningful if they are.  This is because the returned image may
     * not be fully populated with pixel data at the time it is
     * returned, or indeed at any time.
     *
     * &lt;p&gt; If the supplied &lt;code&gt;ImageReadParam&lt;/code&gt; contains
     * optional setting values not supported by this reader (&lt;i&gt;e.g.&lt;/i&gt;
     * source render size or any format-specific settings), they will
     * be ignored.
     *
     * &lt;p&gt; The default implementation just calls
     * {@link #read read(imageIndex, param)}.
     *
     * @param imageIndex the index of the image to be retrieved.
     * @param param an &lt;code&gt;ImageReadParam&lt;/code&gt; used to control
     * the reading process, or &lt;code&gt;null&lt;/code&gt;.
     *
     * @return a &lt;code&gt;RenderedImage&lt;/code&gt; object providing a view of
     * the image.
     *
     * @exception IllegalStateException if the input source has not been
     * set.
     * @exception IndexOutOfBoundsException if the supplied index is
     * out of bounds.
     * @exception IllegalArgumentException if the set of source and
     * destination bands specified by
     * &lt;code&gt;param.getSourceBands&lt;/code&gt; and
     * &lt;code&gt;param.getDestinationBands&lt;/code&gt; differ in length or
     * include indices that are out of bounds.
     * @exception IllegalArgumentException if the resulting image
     * would have a width or height less than 1.
     * @exception IOException if an error occurs during reading.
     */
    public RenderedImage readAsRenderedImage(int imageIndex,
                                             ImageReadParam param)
        throws IOException {
<span class="nc" id="L1574">        return read(imageIndex, param);</span>
    }

    // Thumbnails

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the image format understood by
     * this reader supports thumbnail preview images associated with
     * it.  The default implementation returns &lt;code&gt;false&lt;/code&gt;.
     *
     * &lt;p&gt; If this method returns &lt;code&gt;false&lt;/code&gt;,
     * &lt;code&gt;hasThumbnails&lt;/code&gt; and &lt;code&gt;getNumThumbnails&lt;/code&gt;
     * will return &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt;,
     * respectively, and &lt;code&gt;readThumbnail&lt;/code&gt; will throw an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;, regardless of their
     * arguments.
     *
     * &lt;p&gt; A reader that does not support thumbnails need not
     * implement any of the thumbnail-related methods.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if thumbnails are supported.
     */
    public boolean readerSupportsThumbnails() {
<span class="nc" id="L1597">        return false;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the given image has thumbnail
     * preview images associated with it.  If the format does not
     * support thumbnails (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt;
     * returns &lt;code&gt;false&lt;/code&gt;), &lt;code&gt;false&lt;/code&gt; will be
     * returned regardless of whether an input source has been set or
     * whether &lt;code&gt;imageIndex&lt;/code&gt; is in bounds.
     *
     * &lt;p&gt; The default implementation returns &lt;code&gt;true&lt;/code&gt; if
     * &lt;code&gt;getNumThumbnails&lt;/code&gt; returns a value greater than 0.
     *
     * @param imageIndex the index of the image being queried.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the given image has thumbnails.
     *
     * @exception IllegalStateException if the reader supports
     * thumbnails but the input source has not been set.
     * @exception IndexOutOfBoundsException if the reader supports
     * thumbnails but &lt;code&gt;imageIndex&lt;/code&gt; is out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public boolean hasThumbnails(int imageIndex) throws IOException {
<span class="nc bnc" id="L1622" title="All 2 branches missed.">        return getNumThumbnails(imageIndex) &gt; 0;</span>
    }

    /**
     * Returns the number of thumbnail preview images associated with
     * the given image.  If the format does not support thumbnails,
     * (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns
     * &lt;code&gt;false&lt;/code&gt;), &lt;code&gt;0&lt;/code&gt; will be returned regardless
     * of whether an input source has been set or whether
     * &lt;code&gt;imageIndex&lt;/code&gt; is in bounds.
     *
     * &lt;p&gt; The default implementation returns 0 without checking its
     * argument.
     *
     * @param imageIndex the index of the image being queried.
     *
     * @return the number of thumbnails associated with the given
     * image.
     *
     * @exception IllegalStateException if the reader supports
     * thumbnails but the input source has not been set.
     * @exception IndexOutOfBoundsException if the reader supports
     * thumbnails but &lt;code&gt;imageIndex&lt;/code&gt; is out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public int getNumThumbnails(int imageIndex)
        throws IOException {
<span class="nc" id="L1649">        return 0;</span>
    }

    /**
     * Returns the width of the thumbnail preview image indexed by
     * &lt;code&gt;thumbnailIndex&lt;/code&gt;, associated with the image indexed
     * by &lt;code&gt;ImageIndex&lt;/code&gt;.
     *
     * &lt;p&gt; If the reader does not support thumbnails,
     * (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns
     * &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;
     * will be thrown.
     *
     * &lt;p&gt; The default implementation simply returns
     * &lt;code&gt;readThumbnail(imageindex,
     * thumbnailIndex).getWidth()&lt;/code&gt;.  Subclasses should therefore
     * override this method if possible in order to avoid forcing the
     * thumbnail to be read.
     *
     * @param imageIndex the index of the image to be retrieved.
     * @param thumbnailIndex the index of the thumbnail to be retrieved.
     *
     * @return the width of the desired thumbnail as an &lt;code&gt;int&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if thumbnails are not
     * supported.
     * @exception IllegalStateException if the input source has not been set.
     * @exception IndexOutOfBoundsException if either of the supplied
     * indices are out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public int getThumbnailWidth(int imageIndex, int thumbnailIndex)
        throws IOException {
<span class="nc" id="L1682">        return readThumbnail(imageIndex, thumbnailIndex).getWidth();</span>
    }

    /**
     * Returns the height of the thumbnail preview image indexed by
     * &lt;code&gt;thumbnailIndex&lt;/code&gt;, associated with the image indexed
     * by &lt;code&gt;ImageIndex&lt;/code&gt;.
     *
     * &lt;p&gt; If the reader does not support thumbnails,
     * (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns
     * &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;
     * will be thrown.
     *
     * &lt;p&gt; The default implementation simply returns
     * &lt;code&gt;readThumbnail(imageindex,
     * thumbnailIndex).getHeight()&lt;/code&gt;.  Subclasses should
     * therefore override this method if possible in order to avoid
     * forcing the thumbnail to be read.
     *
     * @param imageIndex the index of the image to be retrieved.
     * @param thumbnailIndex the index of the thumbnail to be retrieved.
     *
     * @return the height of the desired thumbnail as an &lt;code&gt;int&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if thumbnails are not
     * supported.
     * @exception IllegalStateException if the input source has not been set.
     * @exception IndexOutOfBoundsException if either of the supplied
     * indices are out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public int getThumbnailHeight(int imageIndex, int thumbnailIndex)
        throws IOException {
<span class="nc" id="L1715">        return readThumbnail(imageIndex, thumbnailIndex).getHeight();</span>
    }

    /**
     * Returns the thumbnail preview image indexed by
     * &lt;code&gt;thumbnailIndex&lt;/code&gt;, associated with the image indexed
     * by &lt;code&gt;ImageIndex&lt;/code&gt; as a &lt;code&gt;BufferedImage&lt;/code&gt;.
     *
     * &lt;p&gt; Any registered &lt;code&gt;IIOReadProgressListener&lt;/code&gt; objects
     * will be notified by calling their
     * &lt;code&gt;thumbnailStarted&lt;/code&gt;, &lt;code&gt;thumbnailProgress&lt;/code&gt;,
     * and &lt;code&gt;thumbnailComplete&lt;/code&gt; methods.
     *
     * &lt;p&gt; If the reader does not support thumbnails,
     * (&lt;code&gt;readerSupportsThumbnails&lt;/code&gt; returns
     * &lt;code&gt;false&lt;/code&gt;), an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;
     * will be thrown regardless of whether an input source has been
     * set or whether the indices are in bounds.
     *
     * &lt;p&gt; The default implementation throws an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @param imageIndex the index of the image to be retrieved.
     * @param thumbnailIndex the index of the thumbnail to be retrieved.
     *
     * @return the desired thumbnail as a &lt;code&gt;BufferedImage&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if thumbnails are not
     * supported.
     * @exception IllegalStateException if the input source has not been set.
     * @exception IndexOutOfBoundsException if either of the supplied
     * indices are out of bounds.
     * @exception IOException if an error occurs during reading.
     */
    public BufferedImage readThumbnail(int imageIndex,
                                       int thumbnailIndex)
        throws IOException {
<span class="nc" id="L1752">        throw new UnsupportedOperationException(&quot;Thumbnails not supported!&quot;);</span>
    }

    // Abort

    /**
     * Requests that any current read operation be aborted.  The
     * contents of the image following the abort will be undefined.
     *
     * &lt;p&gt; Readers should call &lt;code&gt;clearAbortRequest&lt;/code&gt; at the
     * beginning of each read operation, and poll the value of
     * &lt;code&gt;abortRequested&lt;/code&gt; regularly during the read.
     */
    public synchronized void abort() {
<span class="nc" id="L1766">        this.abortFlag = true;</span>
<span class="nc" id="L1767">    }</span>

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if a request to abort the current
     * read operation has been made since the reader was instantiated or
     * &lt;code&gt;clearAbortRequest&lt;/code&gt; was called.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the current read operation should
     * be aborted.
     *
     * @see #abort
     * @see #clearAbortRequest
     */
    protected synchronized boolean abortRequested() {
<span class="nc" id="L1781">        return this.abortFlag;</span>
    }

    /**
     * Clears any previous abort request.  After this method has been
     * called, &lt;code&gt;abortRequested&lt;/code&gt; will return
     * &lt;code&gt;false&lt;/code&gt;.
     *
     * @see #abort
     * @see #abortRequested
     */
    protected synchronized void clearAbortRequest() {
<span class="nc" id="L1793">        this.abortFlag = false;</span>
<span class="nc" id="L1794">    }</span>

    // Listeners

    // Add an element to a list, creating a new list if the
    // existing list is null, and return the list.
    static List addToList(List l, Object elt) {
<span class="nc bnc" id="L1801" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L1802">            l = new ArrayList();</span>
        }
<span class="nc" id="L1804">        l.add(elt);</span>
<span class="nc" id="L1805">        return l;</span>
    }


    // Remove an element from a list, discarding the list if the
    // resulting list is empty, and return the list or null.
    static List removeFromList(List l, Object elt) {
<span class="nc bnc" id="L1812" title="All 2 branches missed.">        if (l == null) {</span>
<span class="nc" id="L1813">            return l;</span>
        }
<span class="nc" id="L1815">        l.remove(elt);</span>
<span class="nc bnc" id="L1816" title="All 2 branches missed.">        if (l.size() == 0) {</span>
<span class="nc" id="L1817">            l = null;</span>
        }
<span class="nc" id="L1819">        return l;</span>
    }

    /**
     * Adds an &lt;code&gt;IIOReadWarningListener&lt;/code&gt; to the list of
     * registered warning listeners.  If &lt;code&gt;listener&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;, no exception will be thrown and no action
     * will be taken.  Messages sent to the given listener will be
     * localized, if possible, to match the current
     * &lt;code&gt;Locale&lt;/code&gt;.  If no &lt;code&gt;Locale&lt;/code&gt; has been set,
     * warning messages may be localized as the reader sees fit.
     *
     * @param listener an &lt;code&gt;IIOReadWarningListener&lt;/code&gt; to be registered.
     *
     * @see #removeIIOReadWarningListener
     */
    public void addIIOReadWarningListener(IIOReadWarningListener listener) {
<span class="nc bnc" id="L1836" title="All 2 branches missed.">        if (listener == null) {</span>
<span class="nc" id="L1837">            return;</span>
        }
<span class="nc" id="L1839">        warningListeners = addToList(warningListeners, listener);</span>
<span class="nc" id="L1840">        warningLocales = addToList(warningLocales, getLocale());</span>
<span class="nc" id="L1841">    }</span>

    /**
     * Removes an &lt;code&gt;IIOReadWarningListener&lt;/code&gt; from the list of
     * registered error listeners.  If the listener was not previously
     * registered, or if &lt;code&gt;listener&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;,
     * no exception will be thrown and no action will be taken.
     *
     * @param listener an IIOReadWarningListener to be unregistered.
     *
     * @see #addIIOReadWarningListener
     */
    public void removeIIOReadWarningListener(IIOReadWarningListener listener) {
<span class="nc bnc" id="L1854" title="All 4 branches missed.">        if (listener == null || warningListeners == null) {</span>
<span class="nc" id="L1855">            return;</span>
        }
<span class="nc" id="L1857">        int index = warningListeners.indexOf(listener);</span>
<span class="nc bnc" id="L1858" title="All 2 branches missed.">        if (index != -1) {</span>
<span class="nc" id="L1859">            warningListeners.remove(index);</span>
<span class="nc" id="L1860">            warningLocales.remove(index);</span>
<span class="nc bnc" id="L1861" title="All 2 branches missed.">            if (warningListeners.size() == 0) {</span>
<span class="nc" id="L1862">                warningListeners = null;</span>
<span class="nc" id="L1863">                warningLocales = null;</span>
            }
        }
<span class="nc" id="L1866">    }</span>

    /**
     * Removes all currently registered
     * &lt;code&gt;IIOReadWarningListener&lt;/code&gt; objects.
     *
     * &lt;p&gt; The default implementation sets the
     * &lt;code&gt;warningListeners&lt;/code&gt; and &lt;code&gt;warningLocales&lt;/code&gt;
     * instance variables to &lt;code&gt;null&lt;/code&gt;.
     */
    public void removeAllIIOReadWarningListeners() {
<span class="nc" id="L1877">        warningListeners = null;</span>
<span class="nc" id="L1878">        warningLocales = null;</span>
<span class="nc" id="L1879">    }</span>

    /**
     * Adds an &lt;code&gt;IIOReadProgressListener&lt;/code&gt; to the list of
     * registered progress listeners.  If &lt;code&gt;listener&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;, no exception will be thrown and no action
     * will be taken.
     *
     * @param listener an IIOReadProgressListener to be registered.
     *
     * @see #removeIIOReadProgressListener
     */
    public void addIIOReadProgressListener(IIOReadProgressListener listener) {
<span class="nc bnc" id="L1892" title="All 2 branches missed.">        if (listener == null) {</span>
<span class="nc" id="L1893">            return;</span>
        }
<span class="nc" id="L1895">        progressListeners = addToList(progressListeners, listener);</span>
<span class="nc" id="L1896">    }</span>

    /**
     * Removes an &lt;code&gt;IIOReadProgressListener&lt;/code&gt; from the list
     * of registered progress listeners.  If the listener was not
     * previously registered, or if &lt;code&gt;listener&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;, no exception will be thrown and no action
     * will be taken.
     *
     * @param listener an IIOReadProgressListener to be unregistered.
     *
     * @see #addIIOReadProgressListener
     */
    public void
        removeIIOReadProgressListener (IIOReadProgressListener listener) {
<span class="nc bnc" id="L1911" title="All 4 branches missed.">        if (listener == null || progressListeners == null) {</span>
<span class="nc" id="L1912">            return;</span>
        }
<span class="nc" id="L1914">        progressListeners = removeFromList(progressListeners, listener);</span>
<span class="nc" id="L1915">    }</span>

    /**
     * Removes all currently registered
     * &lt;code&gt;IIOReadProgressListener&lt;/code&gt; objects.
     *
     * &lt;p&gt; The default implementation sets the
     * &lt;code&gt;progressListeners&lt;/code&gt; instance variable to
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public void removeAllIIOReadProgressListeners() {
<span class="nc" id="L1926">        progressListeners = null;</span>
<span class="nc" id="L1927">    }</span>

    /**
     * Adds an &lt;code&gt;IIOReadUpdateListener&lt;/code&gt; to the list of
     * registered update listeners.  If &lt;code&gt;listener&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;, no exception will be thrown and no action
     * will be taken.  The listener will receive notification of pixel
     * updates as images and thumbnails are decoded, including the
     * starts and ends of progressive passes.
     *
     * &lt;p&gt; If no update listeners are present, the reader may choose
     * to perform fewer updates to the pixels of the destination
     * images and/or thumbnails, which may result in more efficient
     * decoding.
     *
     * &lt;p&gt; For example, in progressive JPEG decoding each pass
     * contains updates to a set of coefficients, which would have to
     * be transformed into pixel values and converted to an RGB color
     * space for each pass if listeners are present.  If no listeners
     * are present, the coefficients may simply be accumulated and the
     * final results transformed and color converted one time only.
     *
     * &lt;p&gt; The final results of decoding will be the same whether or
     * not intermediate updates are performed.  Thus if only the final
     * image is desired it may be preferable not to register any
     * &lt;code&gt;IIOReadUpdateListener&lt;/code&gt;s.  In general, progressive
     * updating is most effective when fetching images over a network
     * connection that is very slow compared to local CPU processing;
     * over a fast connection, progressive updates may actually slow
     * down the presentation of the image.
     *
     * @param listener an IIOReadUpdateListener to be registered.
     *
     * @see #removeIIOReadUpdateListener
     */
    public void
        addIIOReadUpdateListener(IIOReadUpdateListener listener) {
<span class="nc bnc" id="L1964" title="All 2 branches missed.">        if (listener == null) {</span>
<span class="nc" id="L1965">            return;</span>
        }
<span class="nc" id="L1967">        updateListeners = addToList(updateListeners, listener);</span>
<span class="nc" id="L1968">    }</span>

    /**
     * Removes an &lt;code&gt;IIOReadUpdateListener&lt;/code&gt; from the list of
     * registered update listeners.  If the listener was not
     * previously registered, or if &lt;code&gt;listener&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;, no exception will be thrown and no action
     * will be taken.
     *
     * @param listener an IIOReadUpdateListener to be unregistered.
     *
     * @see #addIIOReadUpdateListener
     */
    public void removeIIOReadUpdateListener(IIOReadUpdateListener listener) {
<span class="nc bnc" id="L1982" title="All 4 branches missed.">        if (listener == null || updateListeners == null) {</span>
<span class="nc" id="L1983">            return;</span>
        }
<span class="nc" id="L1985">        updateListeners = removeFromList(updateListeners, listener);</span>
<span class="nc" id="L1986">    }</span>

    /**
     * Removes all currently registered
     * &lt;code&gt;IIOReadUpdateListener&lt;/code&gt; objects.
     *
     * &lt;p&gt; The default implementation sets the
     * &lt;code&gt;updateListeners&lt;/code&gt; instance variable to
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public void removeAllIIOReadUpdateListeners() {
<span class="nc" id="L1997">        updateListeners = null;</span>
<span class="nc" id="L1998">    }</span>

    /**
     * Broadcasts the start of an sequence of image reads to all
     * registered &lt;code&gt;IIOReadProgressListener&lt;/code&gt;s by calling
     * their &lt;code&gt;sequenceStarted&lt;/code&gt; method.  Subclasses may use
     * this method as a convenience.
     *
     * @param minIndex the lowest index being read.
     */
    protected void processSequenceStarted(int minIndex) {
<span class="nc bnc" id="L2009" title="All 2 branches missed.">        if (progressListeners == null) {</span>
<span class="nc" id="L2010">            return;</span>
        }
<span class="nc" id="L2012">        int numListeners = progressListeners.size();</span>
<span class="nc bnc" id="L2013" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2014">            IIOReadProgressListener listener =</span>
<span class="nc" id="L2015">                (IIOReadProgressListener)progressListeners.get(i);</span>
<span class="nc" id="L2016">            listener.sequenceStarted(this, minIndex);</span>
        }
<span class="nc" id="L2018">    }</span>

    /**
     * Broadcasts the completion of an sequence of image reads to all
     * registered &lt;code&gt;IIOReadProgressListener&lt;/code&gt;s by calling
     * their &lt;code&gt;sequenceComplete&lt;/code&gt; method.  Subclasses may use
     * this method as a convenience.
     */
    protected void processSequenceComplete() {
<span class="nc bnc" id="L2027" title="All 2 branches missed.">        if (progressListeners == null) {</span>
<span class="nc" id="L2028">            return;</span>
        }
<span class="nc" id="L2030">        int numListeners = progressListeners.size();</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2032">            IIOReadProgressListener listener =</span>
<span class="nc" id="L2033">                (IIOReadProgressListener)progressListeners.get(i);</span>
<span class="nc" id="L2034">            listener.sequenceComplete(this);</span>
        }
<span class="nc" id="L2036">    }</span>

    /**
     * Broadcasts the start of an image read to all registered
     * &lt;code&gt;IIOReadProgressListener&lt;/code&gt;s by calling their
     * &lt;code&gt;imageStarted&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     *
     * @param imageIndex the index of the image about to be read.
     */
    protected void processImageStarted(int imageIndex) {
<span class="nc bnc" id="L2047" title="All 2 branches missed.">        if (progressListeners == null) {</span>
<span class="nc" id="L2048">            return;</span>
        }
<span class="nc" id="L2050">        int numListeners = progressListeners.size();</span>
<span class="nc bnc" id="L2051" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2052">            IIOReadProgressListener listener =</span>
<span class="nc" id="L2053">                (IIOReadProgressListener)progressListeners.get(i);</span>
<span class="nc" id="L2054">            listener.imageStarted(this, imageIndex);</span>
        }
<span class="nc" id="L2056">    }</span>

    /**
     * Broadcasts the current percentage of image completion to all
     * registered &lt;code&gt;IIOReadProgressListener&lt;/code&gt;s by calling
     * their &lt;code&gt;imageProgress&lt;/code&gt; method.  Subclasses may use
     * this method as a convenience.
     *
     * @param percentageDone the current percentage of completion,
     * as a &lt;code&gt;float&lt;/code&gt;.
     */
    protected void processImageProgress(float percentageDone) {
<span class="nc bnc" id="L2068" title="All 2 branches missed.">        if (progressListeners == null) {</span>
<span class="nc" id="L2069">            return;</span>
        }
<span class="nc" id="L2071">        int numListeners = progressListeners.size();</span>
<span class="nc bnc" id="L2072" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2073">            IIOReadProgressListener listener =</span>
<span class="nc" id="L2074">                (IIOReadProgressListener)progressListeners.get(i);</span>
<span class="nc" id="L2075">            listener.imageProgress(this, percentageDone);</span>
        }
<span class="nc" id="L2077">    }</span>

    /**
     * Broadcasts the completion of an image read to all registered
     * &lt;code&gt;IIOReadProgressListener&lt;/code&gt;s by calling their
     * &lt;code&gt;imageComplete&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     */
    protected void processImageComplete() {
<span class="nc bnc" id="L2086" title="All 2 branches missed.">        if (progressListeners == null) {</span>
<span class="nc" id="L2087">            return;</span>
        }
<span class="nc" id="L2089">        int numListeners = progressListeners.size();</span>
<span class="nc bnc" id="L2090" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2091">            IIOReadProgressListener listener =</span>
<span class="nc" id="L2092">                (IIOReadProgressListener)progressListeners.get(i);</span>
<span class="nc" id="L2093">            listener.imageComplete(this);</span>
        }
<span class="nc" id="L2095">    }</span>

    /**
     * Broadcasts the start of a thumbnail read to all registered
     * &lt;code&gt;IIOReadProgressListener&lt;/code&gt;s by calling their
     * &lt;code&gt;thumbnailStarted&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     *
     * @param imageIndex the index of the image associated with the
     * thumbnail.
     * @param thumbnailIndex the index of the thumbnail.
     */
    protected void processThumbnailStarted(int imageIndex,
                                           int thumbnailIndex) {
<span class="nc bnc" id="L2109" title="All 2 branches missed.">        if (progressListeners == null) {</span>
<span class="nc" id="L2110">            return;</span>
        }
<span class="nc" id="L2112">        int numListeners = progressListeners.size();</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2114">            IIOReadProgressListener listener =</span>
<span class="nc" id="L2115">                (IIOReadProgressListener)progressListeners.get(i);</span>
<span class="nc" id="L2116">            listener.thumbnailStarted(this, imageIndex, thumbnailIndex);</span>
        }
<span class="nc" id="L2118">    }</span>

    /**
     * Broadcasts the current percentage of thumbnail completion to
     * all registered &lt;code&gt;IIOReadProgressListener&lt;/code&gt;s by calling
     * their &lt;code&gt;thumbnailProgress&lt;/code&gt; method.  Subclasses may
     * use this method as a convenience.
     *
     * @param percentageDone the current percentage of completion,
     * as a &lt;code&gt;float&lt;/code&gt;.
     */
    protected void processThumbnailProgress(float percentageDone) {
<span class="nc bnc" id="L2130" title="All 2 branches missed.">        if (progressListeners == null) {</span>
<span class="nc" id="L2131">            return;</span>
        }
<span class="nc" id="L2133">        int numListeners = progressListeners.size();</span>
<span class="nc bnc" id="L2134" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2135">            IIOReadProgressListener listener =</span>
<span class="nc" id="L2136">                (IIOReadProgressListener)progressListeners.get(i);</span>
<span class="nc" id="L2137">            listener.thumbnailProgress(this, percentageDone);</span>
        }
<span class="nc" id="L2139">    }</span>

    /**
     * Broadcasts the completion of a thumbnail read to all registered
     * &lt;code&gt;IIOReadProgressListener&lt;/code&gt;s by calling their
     * &lt;code&gt;thumbnailComplete&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     */
    protected void processThumbnailComplete() {
<span class="nc bnc" id="L2148" title="All 2 branches missed.">        if (progressListeners == null) {</span>
<span class="nc" id="L2149">            return;</span>
        }
<span class="nc" id="L2151">        int numListeners = progressListeners.size();</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2153">            IIOReadProgressListener listener =</span>
<span class="nc" id="L2154">                (IIOReadProgressListener)progressListeners.get(i);</span>
<span class="nc" id="L2155">            listener.thumbnailComplete(this);</span>
        }
<span class="nc" id="L2157">    }</span>

    /**
     * Broadcasts that the read has been aborted to all registered
     * &lt;code&gt;IIOReadProgressListener&lt;/code&gt;s by calling their
     * &lt;code&gt;readAborted&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     */
    protected void processReadAborted() {
<span class="nc bnc" id="L2166" title="All 2 branches missed.">        if (progressListeners == null) {</span>
<span class="nc" id="L2167">            return;</span>
        }
<span class="nc" id="L2169">        int numListeners = progressListeners.size();</span>
<span class="nc bnc" id="L2170" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2171">            IIOReadProgressListener listener =</span>
<span class="nc" id="L2172">                (IIOReadProgressListener)progressListeners.get(i);</span>
<span class="nc" id="L2173">            listener.readAborted(this);</span>
        }
<span class="nc" id="L2175">    }</span>

    /**
     * Broadcasts the beginning of a progressive pass to all
     * registered &lt;code&gt;IIOReadUpdateListener&lt;/code&gt;s by calling their
     * &lt;code&gt;passStarted&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     *
     * @param theImage the &lt;code&gt;BufferedImage&lt;/code&gt; being updated.
     * @param pass the index of the current pass, starting with 0.
     * @param minPass the index of the first pass that will be decoded.
     * @param maxPass the index of the last pass that will be decoded.
     * @param minX the X coordinate of the upper-left pixel included
     * in the pass.
     * @param minY the X coordinate of the upper-left pixel included
     * in the pass.
     * @param periodX the horizontal separation between pixels.
     * @param periodY the vertical separation between pixels.
     * @param bands an array of &lt;code&gt;int&lt;/code&gt;s indicating the
     * set of affected bands of the destination.
     */
    protected void processPassStarted(BufferedImage theImage,
                                      int pass,
                                      int minPass, int maxPass,
                                      int minX, int minY,
                                      int periodX, int periodY,
                                      int[] bands) {
<span class="nc bnc" id="L2202" title="All 2 branches missed.">        if (updateListeners == null) {</span>
<span class="nc" id="L2203">            return;</span>
        }
<span class="nc" id="L2205">        int numListeners = updateListeners.size();</span>
<span class="nc bnc" id="L2206" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2207">            IIOReadUpdateListener listener =</span>
<span class="nc" id="L2208">                (IIOReadUpdateListener)updateListeners.get(i);</span>
<span class="nc" id="L2209">            listener.passStarted(this, theImage, pass,</span>
                                 minPass,
                                 maxPass,
                                 minX, minY,
                                 periodX, periodY,
                                 bands);
        }
<span class="nc" id="L2216">    }</span>

    /**
     * Broadcasts the update of a set of samples to all registered
     * &lt;code&gt;IIOReadUpdateListener&lt;/code&gt;s by calling their
     * &lt;code&gt;imageUpdate&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     *
     * @param theImage the &lt;code&gt;BufferedImage&lt;/code&gt; being updated.
     * @param minX the X coordinate of the upper-left pixel included
     * in the pass.
     * @param minY the X coordinate of the upper-left pixel included
     * in the pass.
     * @param width the total width of the area being updated, including
     * pixels being skipped if &lt;code&gt;periodX &amp;gt; 1&lt;/code&gt;.
     * @param height the total height of the area being updated,
     * including pixels being skipped if &lt;code&gt;periodY &amp;gt; 1&lt;/code&gt;.
     * @param periodX the horizontal separation between pixels.
     * @param periodY the vertical separation between pixels.
     * @param bands an array of &lt;code&gt;int&lt;/code&gt;s indicating the
     * set of affected bands of the destination.
     */
    protected void processImageUpdate(BufferedImage theImage,
                                      int minX, int minY,
                                      int width, int height,
                                      int periodX, int periodY,
                                      int[] bands) {
<span class="nc bnc" id="L2243" title="All 2 branches missed.">        if (updateListeners == null) {</span>
<span class="nc" id="L2244">            return;</span>
        }
<span class="nc" id="L2246">        int numListeners = updateListeners.size();</span>
<span class="nc bnc" id="L2247" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2248">            IIOReadUpdateListener listener =</span>
<span class="nc" id="L2249">                (IIOReadUpdateListener)updateListeners.get(i);</span>
<span class="nc" id="L2250">            listener.imageUpdate(this,</span>
                                 theImage,
                                 minX, minY,
                                 width, height,
                                 periodX, periodY,
                                 bands);
        }
<span class="nc" id="L2257">    }</span>

    /**
     * Broadcasts the end of a progressive pass to all
     * registered &lt;code&gt;IIOReadUpdateListener&lt;/code&gt;s by calling their
     * &lt;code&gt;passComplete&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     *
     * @param theImage the &lt;code&gt;BufferedImage&lt;/code&gt; being updated.
     */
    protected void processPassComplete(BufferedImage theImage) {
<span class="nc bnc" id="L2268" title="All 2 branches missed.">        if (updateListeners == null) {</span>
<span class="nc" id="L2269">            return;</span>
        }
<span class="nc" id="L2271">        int numListeners = updateListeners.size();</span>
<span class="nc bnc" id="L2272" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2273">            IIOReadUpdateListener listener =</span>
<span class="nc" id="L2274">                (IIOReadUpdateListener)updateListeners.get(i);</span>
<span class="nc" id="L2275">            listener.passComplete(this, theImage);</span>
        }
<span class="nc" id="L2277">    }</span>

    /**
     * Broadcasts the beginning of a thumbnail progressive pass to all
     * registered &lt;code&gt;IIOReadUpdateListener&lt;/code&gt;s by calling their
     * &lt;code&gt;thumbnailPassStarted&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     *
     * @param theThumbnail the &lt;code&gt;BufferedImage&lt;/code&gt; thumbnail
     * being updated.
     * @param pass the index of the current pass, starting with 0.
     * @param minPass the index of the first pass that will be decoded.
     * @param maxPass the index of the last pass that will be decoded.
     * @param minX the X coordinate of the upper-left pixel included
     * in the pass.
     * @param minY the X coordinate of the upper-left pixel included
     * in the pass.
     * @param periodX the horizontal separation between pixels.
     * @param periodY the vertical separation between pixels.
     * @param bands an array of &lt;code&gt;int&lt;/code&gt;s indicating the
     * set of affected bands of the destination.
     */
    protected void processThumbnailPassStarted(BufferedImage theThumbnail,
                                               int pass,
                                               int minPass, int maxPass,
                                               int minX, int minY,
                                               int periodX, int periodY,
                                               int[] bands) {
<span class="nc bnc" id="L2305" title="All 2 branches missed.">        if (updateListeners == null) {</span>
<span class="nc" id="L2306">            return;</span>
        }
<span class="nc" id="L2308">        int numListeners = updateListeners.size();</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2310">            IIOReadUpdateListener listener =</span>
<span class="nc" id="L2311">                (IIOReadUpdateListener)updateListeners.get(i);</span>
<span class="nc" id="L2312">            listener.thumbnailPassStarted(this, theThumbnail, pass,</span>
                                          minPass,
                                          maxPass,
                                          minX, minY,
                                          periodX, periodY,
                                          bands);
        }
<span class="nc" id="L2319">    }</span>

    /**
     * Broadcasts the update of a set of samples in a thumbnail image
     * to all registered &lt;code&gt;IIOReadUpdateListener&lt;/code&gt;s by
     * calling their &lt;code&gt;thumbnailUpdate&lt;/code&gt; method.  Subclasses may
     * use this method as a convenience.
     *
     * @param theThumbnail the &lt;code&gt;BufferedImage&lt;/code&gt; thumbnail
     * being updated.
     * @param minX the X coordinate of the upper-left pixel included
     * in the pass.
     * @param minY the X coordinate of the upper-left pixel included
     * in the pass.
     * @param width the total width of the area being updated, including
     * pixels being skipped if &lt;code&gt;periodX &amp;gt; 1&lt;/code&gt;.
     * @param height the total height of the area being updated,
     * including pixels being skipped if &lt;code&gt;periodY &amp;gt; 1&lt;/code&gt;.
     * @param periodX the horizontal separation between pixels.
     * @param periodY the vertical separation between pixels.
     * @param bands an array of &lt;code&gt;int&lt;/code&gt;s indicating the
     * set of affected bands of the destination.
     */
    protected void processThumbnailUpdate(BufferedImage theThumbnail,
                                          int minX, int minY,
                                          int width, int height,
                                          int periodX, int periodY,
                                          int[] bands) {
<span class="nc bnc" id="L2347" title="All 2 branches missed.">        if (updateListeners == null) {</span>
<span class="nc" id="L2348">            return;</span>
        }
<span class="nc" id="L2350">        int numListeners = updateListeners.size();</span>
<span class="nc bnc" id="L2351" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2352">            IIOReadUpdateListener listener =</span>
<span class="nc" id="L2353">                (IIOReadUpdateListener)updateListeners.get(i);</span>
<span class="nc" id="L2354">            listener.thumbnailUpdate(this,</span>
                                     theThumbnail,
                                     minX, minY,
                                     width, height,
                                     periodX, periodY,
                                     bands);
        }
<span class="nc" id="L2361">    }</span>

    /**
     * Broadcasts the end of a thumbnail progressive pass to all
     * registered &lt;code&gt;IIOReadUpdateListener&lt;/code&gt;s by calling their
     * &lt;code&gt;thumbnailPassComplete&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     *
     * @param theThumbnail the &lt;code&gt;BufferedImage&lt;/code&gt; thumbnail
     * being updated.
     */
    protected void processThumbnailPassComplete(BufferedImage theThumbnail) {
<span class="nc bnc" id="L2373" title="All 2 branches missed.">        if (updateListeners == null) {</span>
<span class="nc" id="L2374">            return;</span>
        }
<span class="nc" id="L2376">        int numListeners = updateListeners.size();</span>
<span class="nc bnc" id="L2377" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2378">            IIOReadUpdateListener listener =</span>
<span class="nc" id="L2379">                (IIOReadUpdateListener)updateListeners.get(i);</span>
<span class="nc" id="L2380">            listener.thumbnailPassComplete(this, theThumbnail);</span>
        }
<span class="nc" id="L2382">    }</span>

    /**
     * Broadcasts a warning message to all registered
     * &lt;code&gt;IIOReadWarningListener&lt;/code&gt;s by calling their
     * &lt;code&gt;warningOccurred&lt;/code&gt; method.  Subclasses may use this
     * method as a convenience.
     *
     * @param warning the warning message to send.
     *
     * @exception IllegalArgumentException if &lt;code&gt;warning&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     */
    protected void processWarningOccurred(String warning) {
<span class="nc bnc" id="L2396" title="All 2 branches missed.">        if (warningListeners == null) {</span>
<span class="nc" id="L2397">            return;</span>
        }
<span class="nc bnc" id="L2399" title="All 2 branches missed.">        if (warning == null) {</span>
<span class="nc" id="L2400">            throw new IllegalArgumentException(&quot;warning == null!&quot;);</span>
        }
<span class="nc" id="L2402">        int numListeners = warningListeners.size();</span>
<span class="nc bnc" id="L2403" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2404">            IIOReadWarningListener listener =</span>
<span class="nc" id="L2405">                (IIOReadWarningListener)warningListeners.get(i);</span>

<span class="nc" id="L2407">            listener.warningOccurred(this, warning);</span>
        }
<span class="nc" id="L2409">    }</span>

    /**
     * Broadcasts a localized warning message to all registered
     * &lt;code&gt;IIOReadWarningListener&lt;/code&gt;s by calling their
     * &lt;code&gt;warningOccurred&lt;/code&gt; method with a string taken
     * from a &lt;code&gt;ResourceBundle&lt;/code&gt;.  Subclasses may use this
     * method as a convenience.
     *
     * @param baseName the base name of a set of
     * &lt;code&gt;ResourceBundle&lt;/code&gt;s containing localized warning
     * messages.
     * @param keyword the keyword used to index the warning message
     * within the set of &lt;code&gt;ResourceBundle&lt;/code&gt;s.
     *
     * @exception IllegalArgumentException if &lt;code&gt;baseName&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;keyword&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if no appropriate
     * &lt;code&gt;ResourceBundle&lt;/code&gt; may be located.
     * @exception IllegalArgumentException if the named resource is
     * not found in the located &lt;code&gt;ResourceBundle&lt;/code&gt;.
     * @exception IllegalArgumentException if the object retrieved
     * from the &lt;code&gt;ResourceBundle&lt;/code&gt; is not a
     * &lt;code&gt;String&lt;/code&gt;.
     */
    protected void processWarningOccurred(String baseName,
                                          String keyword) {
<span class="nc bnc" id="L2438" title="All 2 branches missed.">        if (warningListeners == null) {</span>
<span class="nc" id="L2439">            return;</span>
        }
<span class="nc bnc" id="L2441" title="All 2 branches missed.">        if (baseName == null) {</span>
<span class="nc" id="L2442">            throw new IllegalArgumentException(&quot;baseName == null!&quot;);</span>
        }
<span class="nc bnc" id="L2444" title="All 2 branches missed.">        if (keyword == null) {</span>
<span class="nc" id="L2445">            throw new IllegalArgumentException(&quot;keyword == null!&quot;);</span>
        }
<span class="nc" id="L2447">        int numListeners = warningListeners.size();</span>
<span class="nc bnc" id="L2448" title="All 2 branches missed.">        for (int i = 0; i &lt; numListeners; i++) {</span>
<span class="nc" id="L2449">            IIOReadWarningListener listener =</span>
<span class="nc" id="L2450">                (IIOReadWarningListener)warningListeners.get(i);</span>
<span class="nc" id="L2451">            Locale locale = (Locale)warningLocales.get(i);</span>
<span class="nc bnc" id="L2452" title="All 2 branches missed.">            if (locale == null) {</span>
<span class="nc" id="L2453">                locale = Locale.getDefault();</span>
            }

            /**
             * If an applet supplies an implementation of ImageReader and
             * resource bundles, then the resource bundle will need to be
             * accessed via the applet class loader. So first try the context
             * class loader to locate the resource bundle.
             * If that throws MissingResourceException, then try the
             * system class loader.
             */
<span class="nc" id="L2464">            ClassLoader loader = (ClassLoader)</span>
<span class="nc" id="L2465">                java.security.AccessController.doPrivileged(</span>
<span class="nc" id="L2466">                   new java.security.PrivilegedAction() {</span>
                      public Object run() {
<span class="nc" id="L2468">                        return Thread.currentThread().getContextClassLoader();</span>
                      }
                });

<span class="nc" id="L2472">            ResourceBundle bundle = null;</span>
            try {
<span class="nc" id="L2474">                bundle = ResourceBundle.getBundle(baseName, locale, loader);</span>
<span class="nc" id="L2475">            } catch (MissingResourceException mre) {</span>
                try {
<span class="nc" id="L2477">                    bundle = ResourceBundle.getBundle(baseName, locale);</span>
<span class="nc" id="L2478">                } catch (MissingResourceException mre1) {</span>
<span class="nc" id="L2479">                    throw new IllegalArgumentException(&quot;Bundle not found!&quot;);</span>
<span class="nc" id="L2480">                }</span>
<span class="nc" id="L2481">            }</span>

<span class="nc" id="L2483">            String warning = null;</span>
            try {
<span class="nc" id="L2485">                warning = bundle.getString(keyword);</span>
<span class="nc" id="L2486">            } catch (ClassCastException cce) {</span>
<span class="nc" id="L2487">                throw new IllegalArgumentException(&quot;Resource is not a String!&quot;);</span>
<span class="nc" id="L2488">            } catch (MissingResourceException mre) {</span>
<span class="nc" id="L2489">                throw new IllegalArgumentException(&quot;Resource is missing!&quot;);</span>
<span class="nc" id="L2490">            }</span>

<span class="nc" id="L2492">            listener.warningOccurred(this, warning);</span>
        }
<span class="nc" id="L2494">    }</span>

    // State management

    /**
     * Restores the &lt;code&gt;ImageReader&lt;/code&gt; to its initial state.
     *
     * &lt;p&gt; The default implementation calls &lt;code&gt;setInput(null,
     * false)&lt;/code&gt;, &lt;code&gt;setLocale(null)&lt;/code&gt;,
     * &lt;code&gt;removeAllIIOReadUpdateListeners()&lt;/code&gt;,
     * &lt;code&gt;removeAllIIOReadWarningListeners()&lt;/code&gt;,
     * &lt;code&gt;removeAllIIOReadProgressListeners()&lt;/code&gt;, and
     * &lt;code&gt;clearAbortRequest&lt;/code&gt;.
     */
    public void reset() {
<span class="nc" id="L2509">        setInput(null, false, false);</span>
<span class="nc" id="L2510">        setLocale(null);</span>
<span class="nc" id="L2511">        removeAllIIOReadUpdateListeners();</span>
<span class="nc" id="L2512">        removeAllIIOReadProgressListeners();</span>
<span class="nc" id="L2513">        removeAllIIOReadWarningListeners();</span>
<span class="nc" id="L2514">        clearAbortRequest();</span>
<span class="nc" id="L2515">    }</span>

    /**
     * Allows any resources held by this object to be released.  The
     * result of calling any other method (other than
     * &lt;code&gt;finalize&lt;/code&gt;) subsequent to a call to this method
     * is undefined.
     *
     * &lt;p&gt;It is important for applications to call this method when they
     * know they will no longer be using this &lt;code&gt;ImageReader&lt;/code&gt;.
     * Otherwise, the reader may continue to hold on to resources
     * indefinitely.
     *
     * &lt;p&gt;The default implementation of this method in the superclass does
     * nothing.  Subclass implementations should ensure that all resources,
     * especially native resources, are released.
     */
    public void dispose() {
<span class="nc" id="L2533">    }</span>

    // Utility methods

    /**
     * A utility method that may be used by readers to compute the
     * region of the source image that should be read, taking into
     * account any source region and subsampling offset settings in
     * the supplied &lt;code&gt;ImageReadParam&lt;/code&gt;.  The actual
     * subsampling factors, destination size, and destination offset
     * are &lt;em&gt;not&lt;/em&gt; taken into consideration, thus further
     * clipping must take place.  The {@link #computeRegions computeRegions}
     * method performs all necessary clipping.
     *
     * @param param the &lt;code&gt;ImageReadParam&lt;/code&gt; being used, or
     * &lt;code&gt;null&lt;/code&gt;.
     * @param srcWidth the width of the source image.
     * @param srcHeight the height of the source image.
     *
     * @return the source region as a &lt;code&gt;Rectangle&lt;/code&gt;.
     */
    protected static Rectangle getSourceRegion(ImageReadParam param,
                                               int srcWidth,
                                               int srcHeight) {
<span class="nc" id="L2557">        Rectangle sourceRegion = new Rectangle(0, 0, srcWidth, srcHeight);</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">        if (param != null) {</span>
<span class="nc" id="L2559">            Rectangle region = param.getSourceRegion();</span>
<span class="nc bnc" id="L2560" title="All 2 branches missed.">            if (region != null) {</span>
<span class="nc" id="L2561">                sourceRegion = sourceRegion.intersection(region);</span>
            }

<span class="nc" id="L2564">            int subsampleXOffset = param.getSubsamplingXOffset();</span>
<span class="nc" id="L2565">            int subsampleYOffset = param.getSubsamplingYOffset();</span>
<span class="nc" id="L2566">            sourceRegion.x += subsampleXOffset;</span>
<span class="nc" id="L2567">            sourceRegion.y += subsampleYOffset;</span>
<span class="nc" id="L2568">            sourceRegion.width -= subsampleXOffset;</span>
<span class="nc" id="L2569">            sourceRegion.height -= subsampleYOffset;</span>
        }

<span class="nc" id="L2572">        return sourceRegion;</span>
    }

    /**
     * Computes the source region of interest and the destination
     * region of interest, taking the width and height of the source
     * image, an optional destination image, and an optional
     * &lt;code&gt;ImageReadParam&lt;/code&gt; into account.  The source region
     * begins with the entire source image.  Then that is clipped to
     * the source region specified in the &lt;code&gt;ImageReadParam&lt;/code&gt;,
     * if one is specified.
     *
     * &lt;p&gt; If either of the destination offsets are negative, the
     * source region is clipped so that its top left will coincide
     * with the top left of the destination image, taking subsampling
     * into account.  Then the result is clipped to the destination
     * image on the right and bottom, if one is specified, taking
     * subsampling and destination offsets into account.
     *
     * &lt;p&gt; Similarly, the destination region begins with the source
     * image, is translated to the destination offset given in the
     * &lt;code&gt;ImageReadParam&lt;/code&gt; if there is one, and finally is
     * clipped to the destination image, if there is one.
     *
     * &lt;p&gt; If either the source or destination regions end up having a
     * width or height of 0, an &lt;code&gt;IllegalArgumentException&lt;/code&gt;
     * is thrown.
     *
     * &lt;p&gt; The {@link #getSourceRegion getSourceRegion&gt;}
     * method may be used if only source clipping is desired.
     *
     * @param param an &lt;code&gt;ImageReadParam&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.
     * @param srcWidth the width of the source image.
     * @param srcHeight the height of the source image.
     * @param image a &lt;code&gt;BufferedImage&lt;/code&gt; that will be the
     * destination image, or &lt;code&gt;null&lt;/code&gt;.
     * @param srcRegion a &lt;code&gt;Rectangle&lt;/code&gt; that will be filled with
     * the source region of interest.
     * @param destRegion a &lt;code&gt;Rectangle&lt;/code&gt; that will be filled with
     * the destination region of interest.
     * @exception IllegalArgumentException if &lt;code&gt;srcRegion&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;dstRegion&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if the resulting source or
     * destination region is empty.
     */
    protected static void computeRegions(ImageReadParam param,
                                         int srcWidth,
                                         int srcHeight,
                                         BufferedImage image,
                                         Rectangle srcRegion,
                                         Rectangle destRegion) {
<span class="nc bnc" id="L2625" title="All 2 branches missed.">        if (srcRegion == null) {</span>
<span class="nc" id="L2626">            throw new IllegalArgumentException(&quot;srcRegion == null!&quot;);</span>
        }
<span class="nc bnc" id="L2628" title="All 2 branches missed.">        if (destRegion == null) {</span>
<span class="nc" id="L2629">            throw new IllegalArgumentException(&quot;destRegion == null!&quot;);</span>
        }

        // Start with the entire source image
<span class="nc" id="L2633">        srcRegion.setBounds(0, 0, srcWidth, srcHeight);</span>

        // Destination also starts with source image, as that is the
        // maximum extent if there is no subsampling
<span class="nc" id="L2637">        destRegion.setBounds(0, 0, srcWidth, srcHeight);</span>

        // Clip that to the param region, if there is one
<span class="nc" id="L2640">        int periodX = 1;</span>
<span class="nc" id="L2641">        int periodY = 1;</span>
<span class="nc" id="L2642">        int gridX = 0;</span>
<span class="nc" id="L2643">        int gridY = 0;</span>
<span class="nc bnc" id="L2644" title="All 2 branches missed.">        if (param != null) {</span>
<span class="nc" id="L2645">            Rectangle paramSrcRegion = param.getSourceRegion();</span>
<span class="nc bnc" id="L2646" title="All 2 branches missed.">            if (paramSrcRegion != null) {</span>
<span class="nc" id="L2647">                srcRegion.setBounds(srcRegion.intersection(paramSrcRegion));</span>
            }
<span class="nc" id="L2649">            periodX = param.getSourceXSubsampling();</span>
<span class="nc" id="L2650">            periodY = param.getSourceYSubsampling();</span>
<span class="nc" id="L2651">            gridX = param.getSubsamplingXOffset();</span>
<span class="nc" id="L2652">            gridY = param.getSubsamplingYOffset();</span>
<span class="nc" id="L2653">            srcRegion.translate(gridX, gridY);</span>
<span class="nc" id="L2654">            srcRegion.width -= gridX;</span>
<span class="nc" id="L2655">            srcRegion.height -= gridY;</span>
<span class="nc" id="L2656">            destRegion.setLocation(param.getDestinationOffset());</span>
        }

        // Now clip any negative destination offsets, i.e. clip
        // to the top and left of the destination image
<span class="nc bnc" id="L2661" title="All 2 branches missed.">        if (destRegion.x &lt; 0) {</span>
<span class="nc" id="L2662">            int delta = -destRegion.x*periodX;</span>
<span class="nc" id="L2663">            srcRegion.x += delta;</span>
<span class="nc" id="L2664">            srcRegion.width -= delta;</span>
<span class="nc" id="L2665">            destRegion.x = 0;</span>
        }
<span class="nc bnc" id="L2667" title="All 2 branches missed.">        if (destRegion.y &lt; 0) {</span>
<span class="nc" id="L2668">            int delta = -destRegion.y*periodY;</span>
<span class="nc" id="L2669">            srcRegion.y += delta;</span>
<span class="nc" id="L2670">            srcRegion.height -= delta;</span>
<span class="nc" id="L2671">            destRegion.y = 0;</span>
        }

        // Now clip the destination Region to the subsampled width and height
<span class="nc" id="L2675">        int subsampledWidth = (srcRegion.width + periodX - 1)/periodX;</span>
<span class="nc" id="L2676">        int subsampledHeight = (srcRegion.height + periodY - 1)/periodY;</span>
<span class="nc" id="L2677">        destRegion.width = subsampledWidth;</span>
<span class="nc" id="L2678">        destRegion.height = subsampledHeight;</span>

        // Now clip that to right and bottom of the destination image,
        // if there is one, taking subsampling into account
<span class="nc bnc" id="L2682" title="All 2 branches missed.">        if (image != null) {</span>
<span class="nc" id="L2683">            Rectangle destImageRect = new Rectangle(0, 0,</span>
<span class="nc" id="L2684">                                                    image.getWidth(),</span>
<span class="nc" id="L2685">                                                    image.getHeight());</span>
<span class="nc" id="L2686">            destRegion.setBounds(destRegion.intersection(destImageRect));</span>
<span class="nc bnc" id="L2687" title="All 2 branches missed.">            if (destRegion.isEmpty()) {</span>
<span class="nc" id="L2688">                throw new IllegalArgumentException</span>
                    (&quot;Empty destination region!&quot;);
            }

<span class="nc" id="L2692">            int deltaX = destRegion.x + subsampledWidth - image.getWidth();</span>
<span class="nc bnc" id="L2693" title="All 2 branches missed.">            if (deltaX &gt; 0) {</span>
<span class="nc" id="L2694">                srcRegion.width -= deltaX*periodX;</span>
            }
<span class="nc" id="L2696">            int deltaY =  destRegion.y + subsampledHeight - image.getHeight();</span>
<span class="nc bnc" id="L2697" title="All 2 branches missed.">            if (deltaY &gt; 0) {</span>
<span class="nc" id="L2698">                srcRegion.height -= deltaY*periodY;</span>
            }
        }
<span class="nc bnc" id="L2701" title="All 4 branches missed.">        if (srcRegion.isEmpty() || destRegion.isEmpty()) {</span>
<span class="nc" id="L2702">            throw new IllegalArgumentException(&quot;Empty region!&quot;);</span>
        }
<span class="nc" id="L2704">    }</span>

    /**
     * A utility method that may be used by readers to test the
     * validity of the source and destination band settings of an
     * &lt;code&gt;ImageReadParam&lt;/code&gt;.  This method may be called as soon
     * as the reader knows both the number of bands of the source
     * image as it exists in the input stream, and the number of bands
     * of the destination image that being written.
     *
     * &lt;p&gt; The method retrieves the source and destination band
     * setting arrays from param using the &lt;code&gt;getSourceBands&lt;/code&gt;
     * and &lt;code&gt;getDestinationBands&lt;/code&gt;methods (or considers them
     * to be &lt;code&gt;null&lt;/code&gt; if &lt;code&gt;param&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;).  If the source band setting array is
     * &lt;code&gt;null&lt;/code&gt;, it is considered to be equal to the array
     * &lt;code&gt;{ 0, 1, ..., numSrcBands - 1 }&lt;/code&gt;, and similarly for
     * the destination band setting array.
     *
     * &lt;p&gt; The method then tests that both arrays are equal in length,
     * and that neither array contains a value larger than the largest
     * available band index.
     *
     * &lt;p&gt; Any failure results in an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; being thrown; success
     * results in the method returning silently.
     *
     * @param param the &lt;code&gt;ImageReadParam&lt;/code&gt; being used to read
     * the image.
     * @param numSrcBands the number of bands of the image as it exists
     * int the input source.
     * @param numDstBands the number of bands in the destination image
     * being written.
     *
     * @exception IllegalArgumentException if &lt;code&gt;param&lt;/code&gt;
     * contains an invalid specification of a source and/or
     * destination band subset.
     */
    protected static void checkReadParamBandSettings(ImageReadParam param,
                                                     int numSrcBands,
                                                     int numDstBands) {
        // A null param is equivalent to srcBands == dstBands == null.
<span class="nc" id="L2746">        int[] srcBands = null;</span>
<span class="nc" id="L2747">        int[] dstBands = null;</span>
<span class="nc bnc" id="L2748" title="All 2 branches missed.">        if (param != null) {</span>
<span class="nc" id="L2749">            srcBands = param.getSourceBands();</span>
<span class="nc" id="L2750">            dstBands = param.getDestinationBands();</span>
        }

<span class="nc bnc" id="L2753" title="All 2 branches missed.">        int paramSrcBandLength =</span>
            (srcBands == null) ? numSrcBands : srcBands.length;
<span class="nc bnc" id="L2755" title="All 2 branches missed.">        int paramDstBandLength =</span>
            (dstBands == null) ? numDstBands : dstBands.length;

<span class="nc bnc" id="L2758" title="All 2 branches missed.">        if (paramSrcBandLength != paramDstBandLength) {</span>
<span class="nc" id="L2759">            throw new IllegalArgumentException(&quot;ImageReadParam num source &amp; dest bands differ!&quot;);</span>
        }

<span class="nc bnc" id="L2762" title="All 2 branches missed.">        if (srcBands != null) {</span>
<span class="nc bnc" id="L2763" title="All 2 branches missed.">            for (int i = 0; i &lt; srcBands.length; i++) {</span>
<span class="nc bnc" id="L2764" title="All 2 branches missed.">                if (srcBands[i] &gt;= numSrcBands) {</span>
<span class="nc" id="L2765">                    throw new IllegalArgumentException(&quot;ImageReadParam source bands contains a value &gt;= the number of source bands!&quot;);</span>
                }
            }
        }

<span class="nc bnc" id="L2770" title="All 2 branches missed.">        if (dstBands != null) {</span>
<span class="nc bnc" id="L2771" title="All 2 branches missed.">            for (int i = 0; i &lt; dstBands.length; i++) {</span>
<span class="nc bnc" id="L2772" title="All 2 branches missed.">                if (dstBands[i] &gt;= numDstBands) {</span>
<span class="nc" id="L2773">                    throw new IllegalArgumentException(&quot;ImageReadParam dest bands contains a value &gt;= the number of dest bands!&quot;);</span>
                }
            }
        }
<span class="nc" id="L2777">    }</span>

    /**
     * Returns the &lt;code&gt;BufferedImage&lt;/code&gt; to which decoded pixel
     * data should be written.  The image is determined by inspecting
     * the supplied &lt;code&gt;ImageReadParam&lt;/code&gt; if it is
     * non-&lt;code&gt;null&lt;/code&gt;; if its &lt;code&gt;getDestination&lt;/code&gt;
     * method returns a non-&lt;code&gt;null&lt;/code&gt; value, that image is
     * simply returned.  Otherwise,
     * &lt;code&gt;param.getDestinationType&lt;/code&gt; method is called to
     * determine if a particular image type has been specified.  If
     * so, the returned &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; is used after
     * checking that it is equal to one of those included in
     * &lt;code&gt;imageTypes&lt;/code&gt;.
     *
     * &lt;p&gt; If &lt;code&gt;param&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or the above
     * steps have not yielded an image or an
     * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;, the first value obtained from
     * the &lt;code&gt;imageTypes&lt;/code&gt; parameter is used.  Typically, the
     * caller will set &lt;code&gt;imageTypes&lt;/code&gt; to the value of
     * &lt;code&gt;getImageTypes(imageIndex)&lt;/code&gt;.
     *
     * &lt;p&gt; Next, the dimensions of the image are determined by a call
     * to &lt;code&gt;computeRegions&lt;/code&gt;.  The actual width and height of
     * the image being decoded are passed in as the &lt;code&gt;width&lt;/code&gt;
     * and &lt;code&gt;height&lt;/code&gt; parameters.
     *
     * @param param an &lt;code&gt;ImageReadParam&lt;/code&gt; to be used to get
     * the destination image or image type, or &lt;code&gt;null&lt;/code&gt;.
     * @param imageTypes an &lt;code&gt;Iterator&lt;/code&gt; of
     * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;s indicating the legal image
     * types, with the default first.
     * @param width the true width of the image or tile begin decoded.
     * @param height the true width of the image or tile being decoded.
     *
     * @return the &lt;code&gt;BufferedImage&lt;/code&gt; to which decoded pixel
     * data should be written.
     *
     * @exception IIOException if the &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;
     * specified by &lt;code&gt;param&lt;/code&gt; does not match any of the legal
     * ones from &lt;code&gt;imageTypes&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;imageTypes&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt; or empty, or if an object not of type
     * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; is retrieved from it.
     * @exception IllegalArgumentException if the resulting image would
     * have a width or height less than 1.
     * @exception IllegalArgumentException if the product of
     * &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; is greater than
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
     */
    protected static BufferedImage
        getDestination(ImageReadParam param,
                       Iterator&lt;ImageTypeSpecifier&gt; imageTypes,
                       int width, int height)
        throws IIOException {
<span class="nc bnc" id="L2832" title="All 4 branches missed.">        if (imageTypes == null || !imageTypes.hasNext()) {</span>
<span class="nc" id="L2833">            throw new IllegalArgumentException(&quot;imageTypes null or empty!&quot;);</span>
        }
<span class="nc bnc" id="L2835" title="All 2 branches missed.">        if ((long)width*height &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L2836">            throw new IllegalArgumentException</span>
                (&quot;width*height &gt; Integer.MAX_VALUE!&quot;);
        }

<span class="nc" id="L2840">        BufferedImage dest = null;</span>
<span class="nc" id="L2841">        ImageTypeSpecifier imageType = null;</span>

        // If param is non-null, use it
<span class="nc bnc" id="L2844" title="All 2 branches missed.">        if (param != null) {</span>
            // Try to get the image itself
<span class="nc" id="L2846">            dest = param.getDestination();</span>
<span class="nc bnc" id="L2847" title="All 2 branches missed.">            if (dest != null) {</span>
<span class="nc" id="L2848">                return dest;</span>
            }

            // No image, get the image type
<span class="nc" id="L2852">            imageType = param.getDestinationType();</span>
        }

        // No info from param, use fallback image type
<span class="nc bnc" id="L2856" title="All 2 branches missed.">        if (imageType == null) {</span>
<span class="nc" id="L2857">            Object o = imageTypes.next();</span>
<span class="nc bnc" id="L2858" title="All 2 branches missed.">            if (!(o instanceof ImageTypeSpecifier)) {</span>
<span class="nc" id="L2859">                throw new IllegalArgumentException</span>
                    (&quot;Non-ImageTypeSpecifier retrieved from imageTypes!&quot;);
            }
<span class="nc" id="L2862">            imageType = (ImageTypeSpecifier)o;</span>
<span class="nc" id="L2863">        } else {</span>
<span class="nc" id="L2864">            boolean foundIt = false;</span>
<span class="nc bnc" id="L2865" title="All 2 branches missed.">            while (imageTypes.hasNext()) {</span>
<span class="nc" id="L2866">                ImageTypeSpecifier type =</span>
<span class="nc" id="L2867">                    (ImageTypeSpecifier)imageTypes.next();</span>
<span class="nc bnc" id="L2868" title="All 2 branches missed.">                if (type.equals(imageType)) {</span>
<span class="nc" id="L2869">                    foundIt = true;</span>
<span class="nc" id="L2870">                    break;</span>
                }
<span class="nc" id="L2872">            }</span>

<span class="nc bnc" id="L2874" title="All 2 branches missed.">            if (!foundIt) {</span>
<span class="nc" id="L2875">                throw new IIOException</span>
                    (&quot;Destination type from ImageReadParam does not match!&quot;);
            }
        }

<span class="nc" id="L2880">        Rectangle srcRegion = new Rectangle(0,0,0,0);</span>
<span class="nc" id="L2881">        Rectangle destRegion = new Rectangle(0,0,0,0);</span>
<span class="nc" id="L2882">        computeRegions(param,</span>
                       width,
                       height,
                       null,
                       srcRegion,
                       destRegion);

<span class="nc" id="L2889">        int destWidth = destRegion.x + destRegion.width;</span>
<span class="nc" id="L2890">        int destHeight = destRegion.y + destRegion.height;</span>
        // Create a new image based on the type specifier
<span class="nc" id="L2892">        return imageType.createBufferedImage(destWidth, destHeight);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>