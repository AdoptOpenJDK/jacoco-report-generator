<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ImageWriteParam.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.imageio</a> &gt; <span class="el_source">ImageWriteParam.java</span></div><h1>ImageWriteParam.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2007, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio;

import java.awt.Dimension;
import java.util.Locale;

/**
 * A class describing how a stream is to be encoded.  Instances of
 * this class or its subclasses are used to supply prescriptive
 * &quot;how-to&quot; information to instances of &lt;code&gt;ImageWriter&lt;/code&gt;.
 *
 * &lt;p&gt; A plug-in for a specific image format may define a subclass of
 * this class, and return objects of that class from the
 * &lt;code&gt;getDefaultWriteParam&lt;/code&gt; method of its
 * &lt;code&gt;ImageWriter&lt;/code&gt; implementation.  For example, the built-in
 * JPEG writer plug-in will return instances of
 * &lt;code&gt;javax.imageio.plugins.jpeg.JPEGImageWriteParam&lt;/code&gt;.
 *
 * &lt;p&gt; The region of the image to be written is determined by first
 * intersecting the actual bounds of the image with the rectangle
 * specified by &lt;code&gt;IIOParam.setSourceRegion&lt;/code&gt;, if any.  If the
 * resulting rectangle has a width or height of zero, the writer will
 * throw an &lt;code&gt;IIOException&lt;/code&gt;. If the intersection is
 * non-empty, writing will commence with the first subsampled pixel
 * and include additional pixels within the intersected bounds
 * according to the horizontal and vertical subsampling factors
 * specified by {@link IIOParam#setSourceSubsampling
 * IIOParam.setSourceSubsampling}.
 *
 * &lt;p&gt; Individual features such as tiling, progressive encoding, and
 * compression may be set in one of four modes.
 * &lt;code&gt;MODE_DISABLED&lt;/code&gt; disables the features;
 * &lt;code&gt;MODE_DEFAULT&lt;/code&gt; enables the feature with
 * writer-controlled parameter values; &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;
 * enables the feature and allows the use of a &lt;code&gt;set&lt;/code&gt; method
 * to provide additional parameters; and
 * &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; copies relevant parameter
 * values from the stream and image metadata objects passed to the
 * writer.  The default for all features is
 * &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.  Non-standard features
 * supplied in subclasses are encouraged, but not required to use a
 * similar scheme.
 *
 * &lt;p&gt; Plug-in writers may extend the functionality of
 * &lt;code&gt;ImageWriteParam&lt;/code&gt; by providing a subclass that implements
 * additional, plug-in specific interfaces.  It is up to the plug-in
 * to document what interfaces are available and how they are to be
 * used.  Writers will silently ignore any extended features of an
 * &lt;code&gt;ImageWriteParam&lt;/code&gt; subclass of which they are not aware.
 * Also, they may ignore any optional features that they normally
 * disable when creating their own &lt;code&gt;ImageWriteParam&lt;/code&gt;
 * instances via &lt;code&gt;getDefaultWriteParam&lt;/code&gt;.
 *
 * &lt;p&gt; Note that unless a query method exists for a capability, it must
 * be supported by all &lt;code&gt;ImageWriter&lt;/code&gt; implementations
 * (&lt;i&gt;e.g.&lt;/i&gt; progressive encoding is optional, but subsampling must be
 * supported).
 *
 *
 * @see ImageReadParam
 */
public class ImageWriteParam extends IIOParam {

    /**
     * A constant value that may be passed into methods such as
     * &lt;code&gt;setTilingMode&lt;/code&gt;, &lt;code&gt;setProgressiveMode&lt;/code&gt;,
     * and &lt;code&gt;setCompressionMode&lt;/code&gt; to disable a feature for
     * future writes.  That is, when this mode is set the stream will
     * &lt;b&gt;not&lt;/b&gt; be tiled, progressive, or compressed, and the
     * relevant accessor methods will throw an
     * &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * @see #MODE_EXPLICIT
     * @see #MODE_COPY_FROM_METADATA
     * @see #MODE_DEFAULT
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     * @see #setTilingMode
     * @see #getTilingMode
     * @see #setCompressionMode
     * @see #getCompressionMode
     */
    public static final int MODE_DISABLED = 0;

    /**
     * A constant value that may be passed into methods such as
     * &lt;code&gt;setTilingMode&lt;/code&gt;,
     * &lt;code&gt;setProgressiveMode&lt;/code&gt;, and
     * &lt;code&gt;setCompressionMode&lt;/code&gt; to enable that feature for
     * future writes.  That is, when this mode is enabled the stream
     * will be tiled, progressive, or compressed according to a
     * sensible default chosen internally by the writer in a plug-in
     * dependent way, and the relevant accessor methods will
     * throw an &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * @see #MODE_DISABLED
     * @see #MODE_EXPLICIT
     * @see #MODE_COPY_FROM_METADATA
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     * @see #setTilingMode
     * @see #getTilingMode
     * @see #setCompressionMode
     * @see #getCompressionMode
     */
    public static final int MODE_DEFAULT = 1;

    /**
     * A constant value that may be passed into methods such as
     * &lt;code&gt;setTilingMode&lt;/code&gt; or &lt;code&gt;setCompressionMode&lt;/code&gt;
     * to enable a feature for future writes. That is, when this mode
     * is set the stream will be tiled or compressed according to
     * additional information supplied to the corresponding
     * &lt;code&gt;set&lt;/code&gt; methods in this class and retrievable from the
     * corresponding &lt;code&gt;get&lt;/code&gt; methods.  Note that this mode is
     * not supported for progressive output.
     *
     * @see #MODE_DISABLED
     * @see #MODE_COPY_FROM_METADATA
     * @see #MODE_DEFAULT
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     * @see #setTilingMode
     * @see #getTilingMode
     * @see #setCompressionMode
     * @see #getCompressionMode
     */
    public static final int MODE_EXPLICIT = 2;

    /**
     * A constant value that may be passed into methods such as
     * &lt;code&gt;setTilingMode&lt;/code&gt;, &lt;code&gt;setProgressiveMode&lt;/code&gt;, or
     * &lt;code&gt;setCompressionMode&lt;/code&gt; to enable that feature for
     * future writes.  That is, when this mode is enabled the stream
     * will be tiled, progressive, or compressed based on the contents
     * of stream and/or image metadata passed into the write
     * operation, and any relevant accessor methods will throw an
     * &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * &lt;p&gt; This is the default mode for all features, so that a read
     * including metadata followed by a write including metadata will
     * preserve as much information as possible.
     *
     * @see #MODE_DISABLED
     * @see #MODE_EXPLICIT
     * @see #MODE_DEFAULT
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     * @see #setTilingMode
     * @see #getTilingMode
     * @see #setCompressionMode
     * @see #getCompressionMode
     */
    public static final int MODE_COPY_FROM_METADATA = 3;

    // If more modes are added, this should be updated.
    private static final int MAX_MODE = MODE_COPY_FROM_METADATA;

    /**
     * A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if this
     * &lt;code&gt;ImageWriteParam&lt;/code&gt; allows tile width and tile height
     * parameters to be set.  By default, the value is
     * &lt;code&gt;false&lt;/code&gt;.  Subclasses must set the value manually.
     *
     * &lt;p&gt; Subclasses that do not support writing tiles should ensure
     * that this value is set to &lt;code&gt;false&lt;/code&gt;.
     */
<span class="nc" id="L192">    protected boolean canWriteTiles = false;</span>

    /**
     * The mode controlling tiling settings, which Must be
     * set to one of the four &lt;code&gt;MODE_*&lt;/code&gt; values.  The default
     * is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not writing tiles may ignore this value.
     *
     * @see #MODE_DISABLED
     * @see #MODE_EXPLICIT
     * @see #MODE_COPY_FROM_METADATA
     * @see #MODE_DEFAULT
     * @see #setTilingMode
     * @see #getTilingMode
     */
<span class="nc" id="L208">    protected int tilingMode = MODE_COPY_FROM_METADATA;</span>

    /**
     * An array of preferred tile size range pairs.  The default value
     * is &lt;code&gt;null&lt;/code&gt;, which indicates that there are no
     * preferred sizes.  If the value is non-&lt;code&gt;null&lt;/code&gt;, it
     * must have an even length of at least two.
     *
     * &lt;p&gt; Subclasses that do not support writing tiles may ignore
     * this value.
     *
     * @see #getPreferredTileSizes
     */
<span class="nc" id="L221">    protected Dimension[] preferredTileSizes = null;</span>

    /**
     * A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if tiling
     * parameters have been specified.
     *
     * &lt;p&gt; Subclasses that do not support writing tiles may ignore
     * this value.
     */
<span class="nc" id="L230">    protected boolean tilingSet = false;</span>

    /**
     * The width of each tile if tiling has been set, or 0 otherwise.
     *
     * &lt;p&gt; Subclasses that do not support tiling may ignore this
     * value.
     */
<span class="nc" id="L238">    protected int tileWidth = 0;</span>

    /**
     * The height of each tile if tiling has been set, or 0 otherwise.
     * The initial value is &lt;code&gt;0&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support tiling may ignore this
     * value.
     */
<span class="nc" id="L247">    protected int tileHeight = 0;</span>

    /**
     * A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if this
     * &lt;code&gt;ImageWriteParam&lt;/code&gt; allows tiling grid offset
     * parameters to be set.  By default, the value is
     * &lt;code&gt;false&lt;/code&gt;.  Subclasses must set the value manually.
     *
     * &lt;p&gt; Subclasses that do not support writing tiles, or that
     * support writing but not offsetting tiles must ensure that this
     * value is set to &lt;code&gt;false&lt;/code&gt;.
     */
<span class="nc" id="L259">    protected boolean canOffsetTiles = false;</span>

    /**
     * The amount by which the tile grid origin should be offset
     * horizontally from the image origin if tiling has been set,
     * or 0 otherwise.  The initial value is &lt;code&gt;0&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support offsetting tiles may ignore
     * this value.
     */
<span class="nc" id="L269">    protected int tileGridXOffset = 0;</span>

    /**
     * The amount by which the tile grid origin should be offset
     * vertically from the image origin if tiling has been set,
     * or 0 otherwise.  The initial value is &lt;code&gt;0&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support offsetting tiles may ignore
     * this value.
     */
<span class="nc" id="L279">    protected int tileGridYOffset = 0;</span>

    /**
     * A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if this
     * &lt;code&gt;ImageWriteParam&lt;/code&gt; allows images to be written as a
     * progressive sequence of increasing quality passes.  By default,
     * the value is &lt;code&gt;false&lt;/code&gt;.  Subclasses must set the value
     * manually.
     *
     * &lt;p&gt; Subclasses that do not support progressive encoding must
     * ensure that this value is set to &lt;code&gt;false&lt;/code&gt;.
     */
<span class="nc" id="L291">    protected boolean canWriteProgressive = false;</span>

    /**
     * The mode controlling progressive encoding, which must be set to
     * one of the four &lt;code&gt;MODE_*&lt;/code&gt; values, except
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  The default is
     * &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support progressive encoding may
     * ignore this value.
     *
     * @see #MODE_DISABLED
     * @see #MODE_EXPLICIT
     * @see #MODE_COPY_FROM_METADATA
     * @see #MODE_DEFAULT
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     */
<span class="nc" id="L309">    protected int progressiveMode = MODE_COPY_FROM_METADATA;</span>

    /**
     * A &lt;code&gt;boolean&lt;/code&gt; that is &lt;code&gt;true&lt;/code&gt; if this writer
     * can write images using compression. By default, the value is
     * &lt;code&gt;false&lt;/code&gt;.  Subclasses must set the value manually.
     *
     * &lt;p&gt; Subclasses that do not support compression must ensure that
     * this value is set to &lt;code&gt;false&lt;/code&gt;.
     */
<span class="nc" id="L319">    protected boolean canWriteCompressed = false;</span>

    /**
     * The mode controlling compression settings, which must be set to
     * one of the four &lt;code&gt;MODE_*&lt;/code&gt; values.  The default is
     * &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support compression may ignore this
     * value.
     *
     * @see #MODE_DISABLED
     * @see #MODE_EXPLICIT
     * @see #MODE_COPY_FROM_METADATA
     * @see #MODE_DEFAULT
     * @see #setCompressionMode
     * @see #getCompressionMode
     */
<span class="nc" id="L336">    protected int compressionMode = MODE_COPY_FROM_METADATA;</span>

    /**
     * An array of &lt;code&gt;String&lt;/code&gt;s containing the names of the
     * available compression types.  Subclasses must set the value
     * manually.
     *
     * &lt;p&gt; Subclasses that do not support compression may ignore this
     * value.
     */
<span class="nc" id="L346">    protected String[] compressionTypes = null;</span>

    /**
     * A &lt;code&gt;String&lt;/code&gt; containing the name of the current
     * compression type, or &lt;code&gt;null&lt;/code&gt; if none is set.
     *
     * &lt;p&gt; Subclasses that do not support compression may ignore this
     * value.
     */
<span class="nc" id="L355">    protected String compressionType = null;</span>

    /**
     * A &lt;code&gt;float&lt;/code&gt; containing the current compression quality
     * setting.  The initial value is &lt;code&gt;1.0F&lt;/code&gt;.
     *
     * &lt;p&gt; Subclasses that do not support compression may ignore this
     * value.
     */
<span class="nc" id="L364">    protected float compressionQuality = 1.0F;</span>

    /**
     * A &lt;code&gt;Locale&lt;/code&gt; to be used to localize compression type
     * names and quality descriptions, or &lt;code&gt;null&lt;/code&gt; to use a
     * default &lt;code&gt;Locale&lt;/code&gt;.  Subclasses must set the value
     * manually.
     */
<span class="nc" id="L372">    protected Locale locale = null;</span>

    /**
     * Constructs an empty &lt;code&gt;ImageWriteParam&lt;/code&gt;.  It is up to
     * the subclass to set up the instance variables properly.
     */
<span class="nc" id="L378">    protected ImageWriteParam() {}</span>

    /**
     * Constructs an &lt;code&gt;ImageWriteParam&lt;/code&gt; set to use a
     * given &lt;code&gt;Locale&lt;/code&gt;.
     *
     * @param locale a &lt;code&gt;Locale&lt;/code&gt; to be used to localize
     * compression type names and quality descriptions, or
     * &lt;code&gt;null&lt;/code&gt;.
     */
<span class="nc" id="L388">    public ImageWriteParam(Locale locale) {</span>
<span class="nc" id="L389">        this.locale = locale;</span>
<span class="nc" id="L390">    }</span>

    // Return a deep copy of the array
    private static Dimension[] clonePreferredTileSizes(Dimension[] sizes) {
<span class="nc bnc" id="L394" title="All 2 branches missed.">        if (sizes == null) {</span>
<span class="nc" id="L395">            return null;</span>
        }
<span class="nc" id="L397">        Dimension[] temp = new Dimension[sizes.length];</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">        for (int i = 0; i &lt; sizes.length; i++) {</span>
<span class="nc" id="L399">            temp[i] = new Dimension(sizes[i]);</span>
        }
<span class="nc" id="L401">        return temp;</span>
    }

    /**
     * Returns the currently set &lt;code&gt;Locale&lt;/code&gt;, or
     * &lt;code&gt;null&lt;/code&gt; if only a default &lt;code&gt;Locale&lt;/code&gt; is
     * supported.
     *
     * @return the current &lt;code&gt;Locale&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt;.
     */
    public Locale getLocale() {
<span class="nc" id="L412">        return locale;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the writer can perform tiling
     * while writing.  If this method returns &lt;code&gt;false&lt;/code&gt;, then
     * &lt;code&gt;setTiling&lt;/code&gt; will throw an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the writer supports tiling.
     *
     * @see #canOffsetTiles()
     * @see #setTiling(int, int, int, int)
     */
    public boolean canWriteTiles() {
<span class="nc" id="L427">        return canWriteTiles;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the writer can perform tiling with
     * non-zero grid offsets while writing.  If this method returns
     * &lt;code&gt;false&lt;/code&gt;, then &lt;code&gt;setTiling&lt;/code&gt; will throw an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if the grid offset
     * arguments are not both zero.  If &lt;code&gt;canWriteTiles&lt;/code&gt;
     * returns &lt;code&gt;false&lt;/code&gt;, this method will return
     * &lt;code&gt;false&lt;/code&gt; as well.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the writer supports non-zero tile
     * offsets.
     *
     * @see #canWriteTiles()
     * @see #setTiling(int, int, int, int)
     */
    public boolean canOffsetTiles() {
<span class="nc" id="L446">        return canOffsetTiles;</span>
    }

    /**
     * Determines whether the image will be tiled in the output
     * stream and, if it will, how the tiling parameters will be
     * determined.  The modes are interpreted as follows:
     *
     * &lt;ul&gt;
     *
     * &lt;li&gt;&lt;code&gt;MODE_DISABLED&lt;/code&gt; - The image will not be tiled.
     * &lt;code&gt;setTiling&lt;/code&gt; will throw an
     * &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * &lt;li&gt;&lt;code&gt;MODE_DEFAULT&lt;/code&gt; - The image will be tiled using
     * default parameters.  &lt;code&gt;setTiling&lt;/code&gt; will throw an
     * &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * &lt;li&gt;&lt;code&gt;MODE_EXPLICIT&lt;/code&gt; - The image will be tiled
     * according to parameters given in the {@link #setTiling setTiling}
     * method.  Any previously set tiling parameters are discarded.
     *
     * &lt;li&gt;&lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; - The image will
     * conform to the metadata object passed in to a write.
     * &lt;code&gt;setTiling&lt;/code&gt; will throw an
     * &lt;code&gt;IllegalStateException&lt;/code&gt;.
     *
     * &lt;/ul&gt;
     *
     * @param mode The mode to use for tiling.
     *
     * @exception UnsupportedOperationException if
     * &lt;code&gt;canWriteTiles&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;mode&lt;/code&gt; is not
     * one of the modes listed above.
     *
     * @see #setTiling
     * @see #getTilingMode
     */
    public void setTilingMode(int mode) {
<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (canWriteTiles() == false) {</span>
<span class="nc" id="L487">            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);</span>
        }
<span class="nc bnc" id="L489" title="All 4 branches missed.">        if (mode &lt; MODE_DISABLED || mode &gt; MAX_MODE) {</span>
<span class="nc" id="L490">            throw new IllegalArgumentException(&quot;Illegal value for mode!&quot;);</span>
        }
<span class="nc" id="L492">        this.tilingMode = mode;</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (mode == MODE_EXPLICIT) {</span>
<span class="nc" id="L494">            unsetTiling();</span>
        }
<span class="nc" id="L496">    }</span>

    /**
     * Returns the current tiling mode, if tiling is supported.
     * Otherwise throws an &lt;code&gt;UnsupportedOperationException&lt;/code&gt;.
     *
     * @return the current tiling mode.
     *
     * @exception UnsupportedOperationException if
     * &lt;code&gt;canWriteTiles&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.
     *
     * @see #setTilingMode
     */
    public int getTilingMode() {
<span class="nc bnc" id="L510" title="All 2 branches missed.">        if (!canWriteTiles()) {</span>
<span class="nc" id="L511">            throw new UnsupportedOperationException(&quot;Tiling not supported&quot;);</span>
        }
<span class="nc" id="L513">        return tilingMode;</span>
    }

    /**
     * Returns an array of &lt;code&gt;Dimension&lt;/code&gt;s indicating the
     * legal size ranges for tiles as they will be encoded in the
     * output file or stream.  The returned array is a copy.
     *
     * &lt;p&gt; The information is returned as a set of pairs; the first
     * element of a pair contains an (inclusive) minimum width and
     * height, and the second element contains an (inclusive) maximum
     * width and height.  Together, each pair defines a valid range of
     * sizes.  To specify a fixed size, use the same width and height
     * for both elements.  To specify an arbitrary range, a value of
     * &lt;code&gt;null&lt;/code&gt; is used in place of an actual array of
     * &lt;code&gt;Dimension&lt;/code&gt;s.
     *
     * &lt;p&gt; If no array is specified on the constructor, but tiling is
     * allowed, then this method returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if the plug-in does
     * not support tiling.
     *
     * @return an array of &lt;code&gt;Dimension&lt;/code&gt;s with an even length
     * of at least two, or &lt;code&gt;null&lt;/code&gt;.
     */
    public Dimension[] getPreferredTileSizes() {
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (!canWriteTiles()) {</span>
<span class="nc" id="L541">            throw new UnsupportedOperationException(&quot;Tiling not supported&quot;);</span>
        }
<span class="nc" id="L543">        return clonePreferredTileSizes(preferredTileSizes);</span>
    }

    /**
     * Specifies that the image should be tiled in the output stream.
     * The &lt;code&gt;tileWidth&lt;/code&gt; and &lt;code&gt;tileHeight&lt;/code&gt;
     * parameters specify the width and height of the tiles in the
     * file.  If the tile width or height is greater than the width or
     * height of the image, the image is not tiled in that dimension.
     *
     * &lt;p&gt; If &lt;code&gt;canOffsetTiles&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;,
     * then the &lt;code&gt;tileGridXOffset&lt;/code&gt; and
     * &lt;code&gt;tileGridYOffset&lt;/code&gt; parameters must be zero.
     *
     * @param tileWidth the width of each tile.
     * @param tileHeight the height of each tile.
     * @param tileGridXOffset the horizontal offset of the tile grid.
     * @param tileGridYOffset the vertical offset of the tile grid.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception UnsupportedOperationException if the plug-in does not
     * support grid offsets, and the grid offsets are not both zero.
     * @exception IllegalArgumentException if the tile size is not
     * within one of the allowable ranges returned by
     * &lt;code&gt;getPreferredTileSizes&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;tileWidth&lt;/code&gt;
     * or &lt;code&gt;tileHeight&lt;/code&gt; is less than or equal to 0.
     *
     * @see #canWriteTiles
     * @see #canOffsetTiles
     * @see #getTileWidth()
     * @see #getTileHeight()
     * @see #getTileGridXOffset()
     * @see #getTileGridYOffset()
     */
    public void setTiling(int tileWidth,
                          int tileHeight,
                          int tileGridXOffset,
                          int tileGridYOffset) {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (!canWriteTiles()) {</span>
<span class="nc" id="L586">            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);</span>
        }
<span class="nc bnc" id="L588" title="All 2 branches missed.">        if (getTilingMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L589">            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);</span>
        }
<span class="nc bnc" id="L591" title="All 4 branches missed.">        if (tileWidth &lt;= 0 || tileHeight &lt;= 0) {</span>
<span class="nc" id="L592">            throw new IllegalArgumentException</span>
                (&quot;tile dimensions are non-positive!&quot;);
        }
<span class="nc bnc" id="L595" title="All 4 branches missed.">        boolean tilesOffset = (tileGridXOffset != 0) || (tileGridYOffset != 0);</span>
<span class="nc bnc" id="L596" title="All 4 branches missed.">        if (!canOffsetTiles() &amp;&amp; tilesOffset) {</span>
<span class="nc" id="L597">            throw new UnsupportedOperationException(&quot;Can't offset tiles!&quot;);</span>
        }
<span class="nc bnc" id="L599" title="All 2 branches missed.">        if (preferredTileSizes != null) {</span>
<span class="nc" id="L600">            boolean ok = true;</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">            for (int i = 0; i &lt; preferredTileSizes.length; i += 2) {</span>
<span class="nc" id="L602">                Dimension min = preferredTileSizes[i];</span>
<span class="nc" id="L603">                Dimension max = preferredTileSizes[i+1];</span>
<span class="nc bnc" id="L604" title="All 8 branches missed.">                if ((tileWidth &lt; min.width) ||</span>
                    (tileWidth &gt; max.width) ||
                    (tileHeight &lt; min.height) ||
                    (tileHeight &gt; max.height)) {
<span class="nc" id="L608">                    ok = false;</span>
<span class="nc" id="L609">                    break;</span>
                }
            }
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (!ok) {</span>
<span class="nc" id="L613">                throw new IllegalArgumentException(&quot;Illegal tile size!&quot;);</span>
            }
        }

<span class="nc" id="L617">        this.tilingSet = true;</span>
<span class="nc" id="L618">        this.tileWidth = tileWidth;</span>
<span class="nc" id="L619">        this.tileHeight = tileHeight;</span>
<span class="nc" id="L620">        this.tileGridXOffset = tileGridXOffset;</span>
<span class="nc" id="L621">        this.tileGridYOffset = tileGridYOffset;</span>
<span class="nc" id="L622">    }</span>

    /**
     * Removes any previous tile grid parameters specified by calls to
     * &lt;code&gt;setTiling&lt;/code&gt;.
     *
     * &lt;p&gt; The default implementation sets the instance variables
     * &lt;code&gt;tileWidth&lt;/code&gt;, &lt;code&gt;tileHeight&lt;/code&gt;,
     * &lt;code&gt;tileGridXOffset&lt;/code&gt;, and
     * &lt;code&gt;tileGridYOffset&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     *
     * @see #setTiling(int, int, int, int)
     */
    public void unsetTiling() {
<span class="nc bnc" id="L641" title="All 2 branches missed.">        if (!canWriteTiles()) {</span>
<span class="nc" id="L642">            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);</span>
        }
<span class="nc bnc" id="L644" title="All 2 branches missed.">        if (getTilingMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L645">            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);</span>
        }
<span class="nc" id="L647">        this.tilingSet = false;</span>
<span class="nc" id="L648">        this.tileWidth = 0;</span>
<span class="nc" id="L649">        this.tileHeight = 0;</span>
<span class="nc" id="L650">        this.tileGridXOffset = 0;</span>
<span class="nc" id="L651">        this.tileGridYOffset = 0;</span>
<span class="nc" id="L652">    }</span>

    /**
     * Returns the width of each tile in an image as it will be
     * written to the output stream.  If tiling parameters have not
     * been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * @return the tile width to be used for encoding.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the tiling parameters have
     * not been set.
     *
     * @see #setTiling(int, int, int, int)
     * @see #getTileHeight()
     */
    public int getTileWidth() {
<span class="nc bnc" id="L672" title="All 2 branches missed.">        if (!canWriteTiles()) {</span>
<span class="nc" id="L673">            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);</span>
        }
<span class="nc bnc" id="L675" title="All 2 branches missed.">        if (getTilingMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L676">            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);</span>
        }
<span class="nc bnc" id="L678" title="All 2 branches missed.">        if (!tilingSet) {</span>
<span class="nc" id="L679">            throw new IllegalStateException(&quot;Tiling parameters not set!&quot;);</span>
        }
<span class="nc" id="L681">        return tileWidth;</span>
    }

    /**
     * Returns the height of each tile in an image as it will be written to
     * the output stream.  If tiling parameters have not
     * been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * @return the tile height to be used for encoding.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the tiling parameters have
     * not been set.
     *
     * @see #setTiling(int, int, int, int)
     * @see #getTileWidth()
     */
    public int getTileHeight() {
<span class="nc bnc" id="L702" title="All 2 branches missed.">        if (!canWriteTiles()) {</span>
<span class="nc" id="L703">            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);</span>
        }
<span class="nc bnc" id="L705" title="All 2 branches missed.">        if (getTilingMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L706">            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);</span>
        }
<span class="nc bnc" id="L708" title="All 2 branches missed.">        if (!tilingSet) {</span>
<span class="nc" id="L709">            throw new IllegalStateException(&quot;Tiling parameters not set!&quot;);</span>
        }
<span class="nc" id="L711">        return tileHeight;</span>
    }

    /**
     * Returns the horizontal tile grid offset of an image as it will
     * be written to the output stream.  If tiling parameters have not
     * been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * @return the tile grid X offset to be used for encoding.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the tiling parameters have
     * not been set.
     *
     * @see #setTiling(int, int, int, int)
     * @see #getTileGridYOffset()
     */
    public int getTileGridXOffset() {
<span class="nc bnc" id="L732" title="All 2 branches missed.">        if (!canWriteTiles()) {</span>
<span class="nc" id="L733">            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);</span>
        }
<span class="nc bnc" id="L735" title="All 2 branches missed.">        if (getTilingMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L736">            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);</span>
        }
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (!tilingSet) {</span>
<span class="nc" id="L739">            throw new IllegalStateException(&quot;Tiling parameters not set!&quot;);</span>
        }
<span class="nc" id="L741">        return tileGridXOffset;</span>
    }

    /**
     * Returns the vertical tile grid offset of an image as it will
     * be written to the output stream.  If tiling parameters have not
     * been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * @return the tile grid Y offset to be used for encoding.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support tiling.
     * @exception IllegalStateException if the tiling mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the tiling parameters have
     * not been set.
     *
     * @see #setTiling(int, int, int, int)
     * @see #getTileGridXOffset()
     */
    public int getTileGridYOffset() {
<span class="nc bnc" id="L762" title="All 2 branches missed.">        if (!canWriteTiles()) {</span>
<span class="nc" id="L763">            throw new UnsupportedOperationException(&quot;Tiling not supported!&quot;);</span>
        }
<span class="nc bnc" id="L765" title="All 2 branches missed.">        if (getTilingMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L766">            throw new IllegalStateException(&quot;Tiling mode not MODE_EXPLICIT!&quot;);</span>
        }
<span class="nc bnc" id="L768" title="All 2 branches missed.">        if (!tilingSet) {</span>
<span class="nc" id="L769">            throw new IllegalStateException(&quot;Tiling parameters not set!&quot;);</span>
        }
<span class="nc" id="L771">        return tileGridYOffset;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the writer can write out images
     * as a series of passes of progressively increasing quality.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the writer supports progressive
     * encoding.
     *
     * @see #setProgressiveMode
     * @see #getProgressiveMode
     */
    public boolean canWriteProgressive() {
<span class="nc" id="L785">        return canWriteProgressive;</span>
    }

    /**
     * Specifies that the writer is to write the image out in a
     * progressive mode such that the stream will contain a series of
     * scans of increasing quality.  If progressive encoding is not
     * supported, an &lt;code&gt;UnsupportedOperationException&lt;/code&gt; will
     * be thrown.
     *
     * &lt;p&gt;  The mode argument determines how
     * the progression parameters are chosen, and must be either
     * &lt;code&gt;MODE_DISABLED&lt;/code&gt;,
     * &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;, or
     * &lt;code&gt;MODE_DEFAULT&lt;/code&gt;.  Otherwise an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The modes are interpreted as follows:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;&lt;code&gt;MODE_DISABLED&lt;/code&gt; - No progression.  Use this to
     *   turn off progression.
     *
     *   &lt;li&gt;&lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; - The output image
     *   will use whatever progression parameters are found in the
     *   metadata objects passed into the writer.
     *
     *   &lt;li&gt;&lt;code&gt;MODE_DEFAULT&lt;/code&gt; - The image will be written
     *   progressively, with parameters chosen by the writer.
     * &lt;/ul&gt;
     *
     * &lt;p&gt; The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.
     *
     * @param mode The mode for setting progression in the output
     * stream.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support progressive encoding.
     * @exception IllegalArgumentException if &lt;code&gt;mode&lt;/code&gt; is not
     * one of the modes listed above.
     *
     * @see #getProgressiveMode
     */
    public void setProgressiveMode(int mode) {
<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (!canWriteProgressive()) {</span>
<span class="nc" id="L830">            throw new UnsupportedOperationException(</span>
                &quot;Progressive output not supported&quot;);
        }
<span class="nc bnc" id="L833" title="All 4 branches missed.">        if (mode &lt; MODE_DISABLED || mode &gt; MAX_MODE) {</span>
<span class="nc" id="L834">            throw new IllegalArgumentException(&quot;Illegal value for mode!&quot;);</span>
        }
<span class="nc bnc" id="L836" title="All 2 branches missed.">        if (mode == MODE_EXPLICIT) {</span>
<span class="nc" id="L837">            throw new IllegalArgumentException(</span>
                &quot;MODE_EXPLICIT not supported for progressive output&quot;);
        }
<span class="nc" id="L840">        this.progressiveMode = mode;</span>
<span class="nc" id="L841">    }</span>

    /**
     * Returns the current mode for writing the stream in a
     * progressive manner.
     *
     * @return the current mode for progressive encoding.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support progressive encoding.
     *
     * @see #setProgressiveMode
     */
    public int getProgressiveMode() {
<span class="nc bnc" id="L855" title="All 2 branches missed.">        if (!canWriteProgressive()) {</span>
<span class="nc" id="L856">            throw new UnsupportedOperationException</span>
                (&quot;Progressive output not supported&quot;);
        }
<span class="nc" id="L859">        return progressiveMode;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this writer supports compression.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the writer supports compression.
     */
    public boolean canWriteCompressed() {
<span class="nc" id="L868">        return canWriteCompressed;</span>
    }

    /**
     * Specifies whether compression is to be performed, and if so how
     * compression parameters are to be determined.  The &lt;code&gt;mode&lt;/code&gt;
     * argument must be one of the four modes, interpreted as follows:
     *
     * &lt;ul&gt;
     *   &lt;li&gt;&lt;code&gt;MODE_DISABLED&lt;/code&gt; - If the mode is set to
     *   &lt;code&gt;MODE_DISABLED&lt;/code&gt;, methods that query or modify the
     *   compression type or parameters will throw an
     *   &lt;code&gt;IllegalStateException&lt;/code&gt; (if compression is
     *   normally supported by the plug-in). Some writers, such as JPEG,
     *   do not normally offer uncompressed output. In this case, attempting
     *   to set the mode to &lt;code&gt;MODE_DISABLED&lt;/code&gt; will throw an
     *   &lt;code&gt;UnsupportedOperationException&lt;/code&gt; and the mode will not be
     *   changed.
     *
     *   &lt;li&gt;&lt;code&gt;MODE_EXPLICIT&lt;/code&gt; - Compress using the
     *   compression type and quality settings specified in this
     *   &lt;code&gt;ImageWriteParam&lt;/code&gt;.  Any previously set compression
     *   parameters are discarded.
     *
     *   &lt;li&gt;&lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt; - Use whatever
     *   compression parameters are specified in metadata objects
     *   passed in to the writer.
     *
     *   &lt;li&gt;&lt;code&gt;MODE_DEFAULT&lt;/code&gt; - Use default compression
     *   parameters.
     * &lt;/ul&gt;
     *
     * &lt;p&gt; The default is &lt;code&gt;MODE_COPY_FROM_METADATA&lt;/code&gt;.
     *
     * @param mode The mode for setting compression in the output
     * stream.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression, or does not support the requested mode.
     * @exception IllegalArgumentException if &lt;code&gt;mode&lt;/code&gt; is not
     * one of the modes listed above.
     *
     * @see #getCompressionMode
     */
    public void setCompressionMode(int mode) {
<span class="nc bnc" id="L913" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L914">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported.&quot;);
        }
<span class="nc bnc" id="L917" title="All 4 branches missed.">        if (mode &lt; MODE_DISABLED || mode &gt; MAX_MODE) {</span>
<span class="nc" id="L918">            throw new IllegalArgumentException(&quot;Illegal value for mode!&quot;);</span>
        }
<span class="nc" id="L920">        this.compressionMode = mode;</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">        if (mode == MODE_EXPLICIT) {</span>
<span class="nc" id="L922">            unsetCompression();</span>
        }
<span class="nc" id="L924">    }</span>

    /**
     * Returns the current compression mode, if compression is
     * supported.
     *
     * @return the current compression mode.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     *
     * @see #setCompressionMode
     */
    public int getCompressionMode() {
<span class="nc bnc" id="L938" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L939">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported.&quot;);
        }
<span class="nc" id="L942">        return compressionMode;</span>
    }

    /**
     * Returns a list of available compression types, as an array or
     * &lt;code&gt;String&lt;/code&gt;s, or &lt;code&gt;null&lt;/code&gt; if a compression
     * type may not be chosen using these interfaces.  The array
     * returned is a copy.
     *
     * &lt;p&gt; If the writer only offers a single, mandatory form of
     * compression, it is not necessary to provide any named
     * compression types.  Named compression types should only be
     * used where the user is able to make a meaningful choice
     * between different schemes.
     *
     * &lt;p&gt; The default implementation checks if compression is
     * supported and throws an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt; if not.  Otherwise,
     * it returns a clone of the &lt;code&gt;compressionTypes&lt;/code&gt;
     * instance variable if it is non-&lt;code&gt;null&lt;/code&gt;, or else
     * returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt;s containing the
     * (non-localized) names of available compression types, or
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     */
    public String[] getCompressionTypes() {
<span class="nc bnc" id="L972" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L973">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported&quot;);
        }
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (compressionTypes == null) {</span>
<span class="nc" id="L977">            return null;</span>
        }
<span class="nc" id="L979">        return (String[])compressionTypes.clone();</span>
    }

    /**
     * Sets the compression type to one of the values indicated by
     * &lt;code&gt;getCompressionTypes&lt;/code&gt;.  If a value of
     * &lt;code&gt;null&lt;/code&gt; is passed in, any previous setting is
     * removed.
     *
     * &lt;p&gt; The default implementation checks whether compression is
     * supported and the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, it calls
     * &lt;code&gt;getCompressionTypes&lt;/code&gt; and checks if
     * &lt;code&gt;compressionType&lt;/code&gt; is one of the legal values.  If it
     * is, the &lt;code&gt;compressionType&lt;/code&gt; instance variable is set.
     * If &lt;code&gt;compressionType&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the
     * instance variable is set without performing any checking.
     *
     * @param compressionType one of the &lt;code&gt;String&lt;/code&gt;s returned
     * by &lt;code&gt;getCompressionTypes&lt;/code&gt;, or &lt;code&gt;null&lt;/code&gt; to
     * remove any previous setting.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception UnsupportedOperationException if there are no
     * settable compression types.
     * @exception IllegalArgumentException if
     * &lt;code&gt;compressionType&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt; but is not
     * one of the values returned by &lt;code&gt;getCompressionTypes&lt;/code&gt;.
     *
     * @see #getCompressionTypes
     * @see #getCompressionType
     * @see #unsetCompression
     */
    public void setCompressionType(String compressionType) {
<span class="nc bnc" id="L1016" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L1017">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported&quot;);
        }
<span class="nc bnc" id="L1020" title="All 2 branches missed.">        if (getCompressionMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L1021">            throw new IllegalStateException</span>
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
<span class="nc" id="L1024">        String[] legalTypes = getCompressionTypes();</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">        if (legalTypes == null) {</span>
<span class="nc" id="L1026">            throw new UnsupportedOperationException(</span>
                &quot;No settable compression types&quot;);
        }
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if (compressionType != null) {</span>
<span class="nc" id="L1030">            boolean found = false;</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">            if (legalTypes != null) {</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                for (int i = 0; i &lt; legalTypes.length; i++) {</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">                    if (compressionType.equals(legalTypes[i])) {</span>
<span class="nc" id="L1034">                        found = true;</span>
<span class="nc" id="L1035">                        break;</span>
                    }
                }
            }
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            if (!found) {</span>
<span class="nc" id="L1040">                throw new IllegalArgumentException(&quot;Unknown compression type!&quot;);</span>
            }
        }
<span class="nc" id="L1043">        this.compressionType = compressionType;</span>
<span class="nc" id="L1044">    }</span>

    /**
     * Returns the currently set compression type, or
     * &lt;code&gt;null&lt;/code&gt; if none has been set.  The type is returned
     * as a &lt;code&gt;String&lt;/code&gt; from among those returned by
     * &lt;code&gt;getCompressionTypes&lt;/code&gt;.
     * If no compression type has been set, &lt;code&gt;null&lt;/code&gt; is
     * returned.
     *
     * &lt;p&gt; The default implementation checks whether compression is
     * supported and the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, it returns the value of the
     * &lt;code&gt;compressionType&lt;/code&gt; instance variable.
     *
     * @return the current compression type as a &lt;code&gt;String&lt;/code&gt;,
     * or &lt;code&gt;null&lt;/code&gt; if no type is set.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     *
     * @see #setCompressionType
     */
    public String getCompressionType() {
<span class="nc bnc" id="L1070" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L1071">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported.&quot;);
        }
<span class="nc bnc" id="L1074" title="All 2 branches missed.">        if (getCompressionMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L1075">            throw new IllegalStateException</span>
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
<span class="nc" id="L1078">        return compressionType;</span>
    }

    /**
     * Removes any previous compression type and quality settings.
     *
     * &lt;p&gt; The default implementation sets the instance variable
     * &lt;code&gt;compressionType&lt;/code&gt; to &lt;code&gt;null&lt;/code&gt;, and the
     * instance variable &lt;code&gt;compressionQuality&lt;/code&gt; to
     * &lt;code&gt;1.0F&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if the plug-in does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     *
     * @see #setCompressionType
     * @see #setCompressionQuality
     */
    public void unsetCompression() {
<span class="nc bnc" id="L1098" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L1099">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported&quot;);
        }
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        if (getCompressionMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L1103">            throw new IllegalStateException</span>
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
<span class="nc" id="L1106">        this.compressionType = null;</span>
<span class="nc" id="L1107">        this.compressionQuality = 1.0F;</span>
<span class="nc" id="L1108">    }</span>

    /**
     * Returns a localized version of the name of the current
     * compression type, using the &lt;code&gt;Locale&lt;/code&gt; returned by
     * &lt;code&gt;getLocale&lt;/code&gt;.
     *
     * &lt;p&gt; The default implementation checks whether compression is
     * supported and the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;compressionType&lt;/code&gt; is &lt;code&gt;non-null&lt;/code&gt; the value
     * of &lt;code&gt;getCompressionType&lt;/code&gt; is returned as a
     * convenience.
     *
     * @return a &lt;code&gt;String&lt;/code&gt; containing a localized version of
     * the name of the current compression type.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if no compression type is set.
     */
    public String getLocalizedCompressionTypeName() {
<span class="nc bnc" id="L1132" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L1133">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported.&quot;);
        }
<span class="nc bnc" id="L1136" title="All 2 branches missed.">        if (getCompressionMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L1137">            throw new IllegalStateException</span>
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
<span class="nc bnc" id="L1140" title="All 2 branches missed.">        if (getCompressionType() == null) {</span>
<span class="nc" id="L1141">            throw new IllegalStateException(&quot;No compression type set!&quot;);</span>
        }
<span class="nc" id="L1143">        return getCompressionType();</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the current compression type
     * provides lossless compression.  If a plug-in provides only
     * one mandatory compression type, then this method may be
     * called without calling &lt;code&gt;setCompressionType&lt;/code&gt; first.
     *
     * &lt;p&gt; If there are multiple compression types but none has
     * been set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks whether compression is
     * supported and the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;
     * &lt;code&gt;true&lt;/code&gt; is returned as a convenience.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the current compression type is
     * lossless.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     */
    public boolean isCompressionLossless() {
<span class="nc bnc" id="L1174" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L1175">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported&quot;);
        }
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        if (getCompressionMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L1179">            throw new IllegalStateException</span>
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
<span class="nc bnc" id="L1182" title="All 2 branches missed.">        if ((getCompressionTypes() != null) &amp;&amp;</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">            (getCompressionType() == null)) {</span>
<span class="nc" id="L1184">            throw new IllegalStateException(&quot;No compression type set!&quot;);</span>
        }
<span class="nc" id="L1186">        return true;</span>
    }

    /**
     * Sets the compression quality to a value between &lt;code&gt;0&lt;/code&gt;
     * and &lt;code&gt;1&lt;/code&gt;.  Only a single compression quality setting
     * is supported by default; writers can provide extended versions
     * of &lt;code&gt;ImageWriteParam&lt;/code&gt; that offer more control.  For
     * lossy compression schemes, the compression quality should
     * control the tradeoff between file size and image quality (for
     * example, by choosing quantization tables when writing JPEG
     * images).  For lossless schemes, the compression quality may be
     * used to control the tradeoff between file size and time taken
     * to perform the compression (for example, by optimizing row
     * filters and setting the ZLIB compression level when writing
     * PNG images).
     *
     * &lt;p&gt; A compression quality setting of 0.0 is most generically
     * interpreted as &quot;high compression is important,&quot; while a setting of
     * 1.0 is most generically interpreted as &quot;high image quality is
     * important.&quot;
     *
     * &lt;p&gt; If there are multiple compression types but none has been
     * set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks that compression is
     * supported, and that the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; returns &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;compressionType&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt; it sets
     * the &lt;code&gt;compressionQuality&lt;/code&gt; instance variable.
     *
     * @param quality a &lt;code&gt;float&lt;/code&gt; between &lt;code&gt;0&lt;/code&gt;and
     * &lt;code&gt;1&lt;/code&gt; indicating the desired quality level.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;quality&lt;/code&gt; is
     * not between &lt;code&gt;0&lt;/code&gt;and &lt;code&gt;1&lt;/code&gt;, inclusive.
     *
     * @see #getCompressionQuality
     */
    public void setCompressionQuality(float quality) {
<span class="nc bnc" id="L1234" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L1235">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported&quot;);
        }
<span class="nc bnc" id="L1238" title="All 2 branches missed.">        if (getCompressionMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L1239">            throw new IllegalStateException</span>
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
<span class="nc bnc" id="L1242" title="All 4 branches missed.">        if (getCompressionTypes() != null &amp;&amp; getCompressionType() == null) {</span>
<span class="nc" id="L1243">            throw new IllegalStateException(&quot;No compression type set!&quot;);</span>
        }
<span class="nc bnc" id="L1245" title="All 4 branches missed.">        if (quality &lt; 0.0F || quality &gt; 1.0F) {</span>
<span class="nc" id="L1246">            throw new IllegalArgumentException(&quot;Quality out-of-bounds!&quot;);</span>
        }
<span class="nc" id="L1248">        this.compressionQuality = quality;</span>
<span class="nc" id="L1249">    }</span>

    /**
     * Returns the current compression quality setting.
     *
     * &lt;p&gt; If there are multiple compression types but none has been
     * set, an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks that compression is
     * supported and that the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, it
     * returns the value of the &lt;code&gt;compressionQuality&lt;/code&gt;
     * instance variable.
     *
     * @return the current compression quality setting.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #setCompressionQuality
     */
    public float getCompressionQuality() {
<span class="nc bnc" id="L1278" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L1279">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported.&quot;);
        }
<span class="nc bnc" id="L1282" title="All 2 branches missed.">        if (getCompressionMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L1283">            throw new IllegalStateException</span>
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
<span class="nc bnc" id="L1286" title="All 2 branches missed.">        if ((getCompressionTypes() != null) &amp;&amp;</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">            (getCompressionType() == null)) {</span>
<span class="nc" id="L1288">            throw new IllegalStateException(&quot;No compression type set!&quot;);</span>
        }
<span class="nc" id="L1290">        return compressionQuality;</span>
    }


    /**
     * Returns a &lt;code&gt;float&lt;/code&gt; indicating an estimate of the
     * number of bits of output data for each bit of input image data
     * at the given quality level.  The value will typically lie
     * between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, with smaller values
     * indicating more compression.  A special value of
     * &lt;code&gt;-1.0F&lt;/code&gt; is used to indicate that no estimate is
     * available.
     *
     * &lt;p&gt; If there are multiple compression types but none has been set,
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks that compression is
     * supported and the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, and
     * &lt;code&gt;quality&lt;/code&gt; is within bounds, it returns
     * &lt;code&gt;-1.0&lt;/code&gt;.
     *
     * @param quality the quality setting whose bit rate is to be
     * queried.
     *
     * @return an estimate of the compressed bit rate, or
     * &lt;code&gt;-1.0F&lt;/code&gt; if no estimate is available.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;quality&lt;/code&gt; is
     * not between &lt;code&gt;0&lt;/code&gt;and &lt;code&gt;1&lt;/code&gt;, inclusive.
     */
    public float getBitRate(float quality) {
<span class="nc bnc" id="L1331" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L1332">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported.&quot;);
        }
<span class="nc bnc" id="L1335" title="All 2 branches missed.">        if (getCompressionMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L1336">            throw new IllegalStateException</span>
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
<span class="nc bnc" id="L1339" title="All 2 branches missed.">        if ((getCompressionTypes() != null) &amp;&amp;</span>
<span class="nc bnc" id="L1340" title="All 2 branches missed.">            (getCompressionType() == null)) {</span>
<span class="nc" id="L1341">            throw new IllegalStateException(&quot;No compression type set!&quot;);</span>
        }
<span class="nc bnc" id="L1343" title="All 4 branches missed.">        if (quality &lt; 0.0F || quality &gt; 1.0F) {</span>
<span class="nc" id="L1344">            throw new IllegalArgumentException(&quot;Quality out-of-bounds!&quot;);</span>
        }
<span class="nc" id="L1346">        return -1.0F;</span>
    }

    /**
     * Returns an array of &lt;code&gt;String&lt;/code&gt;s that may be used along
     * with &lt;code&gt;getCompressionQualityValues&lt;/code&gt; as part of a user
     * interface for setting or displaying the compression quality
     * level.  The &lt;code&gt;String&lt;/code&gt; with index &lt;code&gt;i&lt;/code&gt;
     * provides a description of the range of quality levels between
     * &lt;code&gt;getCompressionQualityValues[i]&lt;/code&gt; and
     * &lt;code&gt;getCompressionQualityValues[i + 1]&lt;/code&gt;.  Note that the
     * length of the array returned from
     * &lt;code&gt;getCompressionQualityValues&lt;/code&gt; will always be one
     * greater than that returned from
     * &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;.
     *
     * &lt;p&gt; As an example, the strings &quot;Good&quot;, &quot;Better&quot;, and &quot;Best&quot;
     * could be associated with the ranges &lt;code&gt;[0, .33)&lt;/code&gt;,
     * &lt;code&gt;[.33, .66)&lt;/code&gt;, and &lt;code&gt;[.66, 1.0]&lt;/code&gt;.  In this
     * case, &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; would
     * return &lt;code&gt;{ &quot;Good&quot;, &quot;Better&quot;, &quot;Best&quot; }&lt;/code&gt; and
     * &lt;code&gt;getCompressionQualityValues&lt;/code&gt; would return
     * &lt;code&gt;{ 0.0F, .33F, .66F, 1.0F }&lt;/code&gt;.
     *
     * &lt;p&gt; If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is
     * returned.  If &lt;code&gt;null&lt;/code&gt; is returned from
     * &lt;code&gt;getCompressionQualityValues&lt;/code&gt;, this method must also
     * return &lt;code&gt;null&lt;/code&gt;.
     *
     * &lt;p&gt; The descriptions should be localized for the
     * &lt;code&gt;Locale&lt;/code&gt; returned by &lt;code&gt;getLocale&lt;/code&gt;, if it
     * is non-&lt;code&gt;null&lt;/code&gt;.
     *
     * &lt;p&gt; If there are multiple compression types but none has been set,
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks that compression is
     * supported and that the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, it
     * returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an array of &lt;code&gt;String&lt;/code&gt;s containing localized
     * descriptions of the compression quality levels.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #getCompressionQualityValues
     */
    public String[] getCompressionQualityDescriptions() {
<span class="nc bnc" id="L1403" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L1404">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported.&quot;);
        }
<span class="nc bnc" id="L1407" title="All 2 branches missed.">        if (getCompressionMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L1408">            throw new IllegalStateException</span>
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
<span class="nc bnc" id="L1411" title="All 2 branches missed.">        if ((getCompressionTypes() != null) &amp;&amp;</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">            (getCompressionType() == null)) {</span>
<span class="nc" id="L1413">            throw new IllegalStateException(&quot;No compression type set!&quot;);</span>
        }
<span class="nc" id="L1415">        return null;</span>
    }

    /**
     * Returns an array of &lt;code&gt;float&lt;/code&gt;s that may be used along
     * with &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt; as part of a user
     * interface for setting or displaying the compression quality
     * level.  See {@link #getCompressionQualityDescriptions
     * getCompressionQualityDescriptions} for more information.
     *
     * &lt;p&gt; If no descriptions are available, &lt;code&gt;null&lt;/code&gt; is
     * returned.  If &lt;code&gt;null&lt;/code&gt; is returned from
     * &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;, this method
     * must also return &lt;code&gt;null&lt;/code&gt;.
     *
     * &lt;p&gt; If there are multiple compression types but none has been set,
     * an &lt;code&gt;IllegalStateException&lt;/code&gt; is thrown.
     *
     * &lt;p&gt; The default implementation checks that compression is
     * supported and that the compression mode is
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.  If so, if
     * &lt;code&gt;getCompressionTypes()&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or
     * &lt;code&gt;getCompressionType()&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, it
     * returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @return an array of &lt;code&gt;float&lt;/code&gt;s indicating the
     * boundaries between the compression quality levels as described
     * by the &lt;code&gt;String&lt;/code&gt;s from
     * &lt;code&gt;getCompressionQualityDescriptions&lt;/code&gt;.
     *
     * @exception UnsupportedOperationException if the writer does not
     * support compression.
     * @exception IllegalStateException if the compression mode is not
     * &lt;code&gt;MODE_EXPLICIT&lt;/code&gt;.
     * @exception IllegalStateException if the set of legal
     * compression types is non-&lt;code&gt;null&lt;/code&gt; and the current
     * compression type is &lt;code&gt;null&lt;/code&gt;.
     *
     * @see #getCompressionQualityDescriptions
     */
    public float[] getCompressionQualityValues() {
<span class="nc bnc" id="L1456" title="All 2 branches missed.">        if (!canWriteCompressed()) {</span>
<span class="nc" id="L1457">            throw new UnsupportedOperationException(</span>
                &quot;Compression not supported.&quot;);
        }
<span class="nc bnc" id="L1460" title="All 2 branches missed.">        if (getCompressionMode() != MODE_EXPLICIT) {</span>
<span class="nc" id="L1461">            throw new IllegalStateException</span>
                (&quot;Compression mode not MODE_EXPLICIT!&quot;);
        }
<span class="nc bnc" id="L1464" title="All 2 branches missed.">        if ((getCompressionTypes() != null) &amp;&amp;</span>
<span class="nc bnc" id="L1465" title="All 2 branches missed.">            (getCompressionType() == null)) {</span>
<span class="nc" id="L1466">            throw new IllegalStateException(&quot;No compression type set!&quot;);</span>
        }
<span class="nc" id="L1468">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>