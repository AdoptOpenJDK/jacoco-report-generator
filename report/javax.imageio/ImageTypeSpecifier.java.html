<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ImageTypeSpecifier.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.imageio</a> &gt; <span class="el_source">ImageTypeSpecifier.java</span></div><h1>ImageTypeSpecifier.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2000, 2003, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.imageio;

import java.awt.Point;
import java.awt.Transparency;
import java.awt.image.BandedSampleModel;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.color.ColorSpace;
import java.awt.image.IndexColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.DirectColorModel;
import java.awt.image.MultiPixelPackedSampleModel;
import java.awt.image.PixelInterleavedSampleModel;
import java.awt.image.SinglePixelPackedSampleModel;
import java.awt.image.Raster;
import java.awt.image.RenderedImage;
import java.awt.image.SampleModel;
import java.awt.image.WritableRaster;
import java.util.Hashtable;

/**
 * A class that allows the format of an image (in particular, its
 * &lt;code&gt;SampleModel&lt;/code&gt; and &lt;code&gt;ColorModel&lt;/code&gt;) to be
 * specified in a convenient manner.
 *
 */
public class ImageTypeSpecifier {

    /**
     * The &lt;code&gt;ColorModel&lt;/code&gt; to be used as a prototype.
     */
    protected ColorModel colorModel;

    /**
     * A &lt;code&gt;SampleModel&lt;/code&gt; to be used as a prototype.
     */
    protected SampleModel sampleModel;

    /**
     * Cached specifiers for all of the standard
     * &lt;code&gt;BufferedImage&lt;/code&gt; types.
     */
    private static ImageTypeSpecifier[] BISpecifier;
    private static ColorSpace sRGB;
    // Initialize the standard specifiers
    static {
<span class="nc" id="L73">        sRGB = ColorSpace.getInstance(ColorSpace.CS_sRGB);</span>

<span class="nc" id="L75">        BISpecifier =</span>
            new ImageTypeSpecifier[BufferedImage.TYPE_BYTE_INDEXED + 1];
<span class="nc" id="L77">    }</span>

    /**
     * A constructor to be used by inner subclasses only.
     */
<span class="nc" id="L82">    private ImageTypeSpecifier() {}</span>

    /**
     * Constructs an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; directly
     * from a &lt;code&gt;ColorModel&lt;/code&gt; and a &lt;code&gt;SampleModel&lt;/code&gt;.
     * It is the caller's responsibility to supply compatible
     * parameters.
     *
     * @param colorModel a &lt;code&gt;ColorModel&lt;/code&gt;.
     * @param sampleModel a &lt;code&gt;SampleModel&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if either parameter is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;sampleModel&lt;/code&gt;
     * is not compatible with &lt;code&gt;colorModel&lt;/code&gt;.
     */
<span class="nc" id="L98">    public ImageTypeSpecifier(ColorModel colorModel, SampleModel sampleModel) {</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">        if (colorModel == null) {</span>
<span class="nc" id="L100">            throw new IllegalArgumentException(&quot;colorModel == null!&quot;);</span>
        }
<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (sampleModel == null) {</span>
<span class="nc" id="L103">            throw new IllegalArgumentException(&quot;sampleModel == null!&quot;);</span>
        }
<span class="nc bnc" id="L105" title="All 2 branches missed.">        if (!colorModel.isCompatibleSampleModel(sampleModel)) {</span>
<span class="nc" id="L106">            throw new IllegalArgumentException</span>
                (&quot;sampleModel is incompatible with colorModel!&quot;);
        }
<span class="nc" id="L109">        this.colorModel = colorModel;</span>
<span class="nc" id="L110">        this.sampleModel = sampleModel;</span>
<span class="nc" id="L111">    }</span>

    /**
     * Constructs an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; from a
     * &lt;code&gt;RenderedImage&lt;/code&gt;.  If a &lt;code&gt;BufferedImage&lt;/code&gt; is
     * being used, one of the factory methods
     * &lt;code&gt;createFromRenderedImage&lt;/code&gt; or
     * &lt;code&gt;createFromBufferedImageType&lt;/code&gt; should be used instead in
     * order to get a more accurate result.
     *
     * @param image a &lt;code&gt;RenderedImage&lt;/code&gt;.
     *
     * @exception IllegalArgumentException if the argument is
     * &lt;code&gt;null&lt;/code&gt;.
     */
<span class="nc" id="L126">    public ImageTypeSpecifier(RenderedImage image) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (image == null) {</span>
<span class="nc" id="L128">            throw new IllegalArgumentException(&quot;image == null!&quot;);</span>
        }
<span class="nc" id="L130">        colorModel = image.getColorModel();</span>
<span class="nc" id="L131">        sampleModel = image.getSampleModel();</span>
<span class="nc" id="L132">    }</span>

    // Packed

    static class Packed extends ImageTypeSpecifier {
        ColorSpace colorSpace;
        int redMask;
        int greenMask;
        int blueMask;
        int alphaMask;
        int transferType;
        boolean isAlphaPremultiplied;

        public Packed(ColorSpace colorSpace,
                      int redMask,
                      int greenMask,
                      int blueMask,
                      int alphaMask, // 0 if no alpha
                      int transferType,
<span class="nc" id="L151">                      boolean isAlphaPremultiplied) {</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">            if (colorSpace == null) {</span>
<span class="nc" id="L153">                throw new IllegalArgumentException(&quot;colorSpace == null!&quot;);</span>
            }
<span class="nc bnc" id="L155" title="All 2 branches missed.">            if (colorSpace.getType() != ColorSpace.TYPE_RGB) {</span>
<span class="nc" id="L156">                throw new IllegalArgumentException</span>
                    (&quot;colorSpace is not of type TYPE_RGB!&quot;);
            }
<span class="nc bnc" id="L159" title="All 6 branches missed.">            if (transferType != DataBuffer.TYPE_BYTE &amp;&amp;</span>
                transferType != DataBuffer.TYPE_USHORT &amp;&amp;
                transferType != DataBuffer.TYPE_INT) {
<span class="nc" id="L162">                throw new IllegalArgumentException</span>
                    (&quot;Bad value for transferType!&quot;);
            }
<span class="nc bnc" id="L165" title="All 8 branches missed.">            if (redMask == 0 &amp;&amp; greenMask == 0 &amp;&amp;</span>
                blueMask == 0 &amp;&amp; alphaMask == 0) {
<span class="nc" id="L167">                throw new IllegalArgumentException</span>
                    (&quot;No mask has at least 1 bit set!&quot;);
            }
<span class="nc" id="L170">            this.colorSpace = colorSpace;</span>
<span class="nc" id="L171">            this.redMask = redMask;</span>
<span class="nc" id="L172">            this.greenMask = greenMask;</span>
<span class="nc" id="L173">            this.blueMask = blueMask;</span>
<span class="nc" id="L174">            this.alphaMask = alphaMask;</span>
<span class="nc" id="L175">            this.transferType = transferType;</span>
<span class="nc" id="L176">            this.isAlphaPremultiplied = isAlphaPremultiplied;</span>

<span class="nc" id="L178">            int bits = 32;</span>
<span class="nc" id="L179">            this.colorModel =</span>
                new DirectColorModel(colorSpace,
                                     bits,
                                     redMask, greenMask, blueMask,
                                     alphaMask, isAlphaPremultiplied,
                                     transferType);
<span class="nc" id="L185">            this.sampleModel = colorModel.createCompatibleSampleModel(1, 1);</span>
<span class="nc" id="L186">        }</span>
    }

    /**
     * Returns a specifier for a packed image format that will use a
     * &lt;code&gt;DirectColorModel&lt;/code&gt; and a packed
     * &lt;code&gt;SampleModel&lt;/code&gt; to store each pixel packed into in a
     * single byte, short, or int.
     *
     * @param colorSpace the desired &lt;code&gt;ColorSpace&lt;/code&gt;.
     * @param redMask a contiguous mask indicated the position of the
     * red channel.
     * @param greenMask a contiguous mask indicated the position of the
     * green channel.
     * @param blueMask a contiguous mask indicated the position of the
     * blue channel.
     * @param alphaMask a contiguous mask indicated the position of the
     * alpha channel.
     * @param transferType the desired &lt;code&gt;SampleModel&lt;/code&gt; transfer type.
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the color channels
     * will be premultipled by the alpha channel.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;colorSpace&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;colorSpace&lt;/code&gt;
     * is not of type &lt;code&gt;TYPE_RGB&lt;/code&gt;.
     * @exception IllegalArgumentException if no mask has at least 1
     * bit set.
     * @exception IllegalArgumentException if
     * &lt;code&gt;transferType&lt;/code&gt; if not one of
     * &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;, or
     * &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;.
     */
    public static ImageTypeSpecifier
        createPacked(ColorSpace colorSpace,
                     int redMask,
                     int greenMask,
                     int blueMask,
                     int alphaMask, // 0 if no alpha
                     int transferType,
                     boolean isAlphaPremultiplied) {
<span class="nc" id="L231">        return new ImageTypeSpecifier.Packed(colorSpace,</span>
                                             redMask,
                                             greenMask,
                                             blueMask,
                                             alphaMask, // 0 if no alpha
                                             transferType,
                                             isAlphaPremultiplied);
    }

    static ColorModel createComponentCM(ColorSpace colorSpace,
                                        int numBands,
                                        int dataType,
                                        boolean hasAlpha,
                                        boolean isAlphaPremultiplied) {
<span class="nc bnc" id="L245" title="All 2 branches missed.">        int transparency =</span>
            hasAlpha ? Transparency.TRANSLUCENT : Transparency.OPAQUE;

<span class="nc" id="L248">        int[] numBits = new int[numBands];</span>
<span class="nc" id="L249">        int bits = DataBuffer.getDataTypeSize(dataType);</span>

<span class="nc bnc" id="L251" title="All 2 branches missed.">        for (int i = 0; i &lt; numBands; i++) {</span>
<span class="nc" id="L252">            numBits[i] = bits;</span>
        }

<span class="nc" id="L255">        return new ComponentColorModel(colorSpace,</span>
                                       numBits,
                                       hasAlpha,
                                       isAlphaPremultiplied,
                                       transparency,
                                       dataType);
    }

    // Interleaved

    static class Interleaved extends ImageTypeSpecifier {
        ColorSpace colorSpace;
        int[] bandOffsets;
        int dataType;
        boolean hasAlpha;
        boolean isAlphaPremultiplied;

        public Interleaved(ColorSpace colorSpace,
                           int[] bandOffsets,
                           int dataType,
                           boolean hasAlpha,
<span class="nc" id="L276">                           boolean isAlphaPremultiplied) {</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (colorSpace == null) {</span>
<span class="nc" id="L278">                throw new IllegalArgumentException(&quot;colorSpace == null!&quot;);</span>
            }
<span class="nc bnc" id="L280" title="All 2 branches missed.">            if (bandOffsets == null) {</span>
<span class="nc" id="L281">                throw new IllegalArgumentException(&quot;bandOffsets == null!&quot;);</span>
            }
<span class="nc bnc" id="L283" title="All 2 branches missed.">            int numBands = colorSpace.getNumComponents() +</span>
                (hasAlpha ? 1 : 0);
<span class="nc bnc" id="L285" title="All 2 branches missed.">            if (bandOffsets.length != numBands) {</span>
<span class="nc" id="L286">                throw new IllegalArgumentException</span>
                    (&quot;bandOffsets.length is wrong!&quot;);
            }
<span class="nc bnc" id="L289" title="All 12 branches missed.">            if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;</span>
                dataType != DataBuffer.TYPE_SHORT &amp;&amp;
                dataType != DataBuffer.TYPE_USHORT &amp;&amp;
                dataType != DataBuffer.TYPE_INT &amp;&amp;
                dataType != DataBuffer.TYPE_FLOAT &amp;&amp;
                dataType != DataBuffer.TYPE_DOUBLE) {
<span class="nc" id="L295">                throw new IllegalArgumentException</span>
                    (&quot;Bad value for dataType!&quot;);
            }
<span class="nc" id="L298">            this.colorSpace = colorSpace;</span>
<span class="nc" id="L299">            this.bandOffsets = (int[])bandOffsets.clone();</span>
<span class="nc" id="L300">            this.dataType = dataType;</span>
<span class="nc" id="L301">            this.hasAlpha = hasAlpha;</span>
<span class="nc" id="L302">            this.isAlphaPremultiplied = isAlphaPremultiplied;</span>

<span class="nc" id="L304">            this.colorModel =</span>
<span class="nc" id="L305">                ImageTypeSpecifier.createComponentCM(colorSpace,</span>
                                                     bandOffsets.length,
                                                     dataType,
                                                     hasAlpha,
                                                     isAlphaPremultiplied);

<span class="nc" id="L311">            int minBandOffset = bandOffsets[0];</span>
<span class="nc" id="L312">            int maxBandOffset = minBandOffset;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">            for (int i = 0; i &lt; bandOffsets.length; i++) {</span>
<span class="nc" id="L314">                int offset = bandOffsets[i];</span>
<span class="nc" id="L315">                minBandOffset = Math.min(offset, minBandOffset);</span>
<span class="nc" id="L316">                maxBandOffset = Math.max(offset, maxBandOffset);</span>
            }
<span class="nc" id="L318">            int pixelStride = maxBandOffset - minBandOffset + 1;</span>

<span class="nc" id="L320">            int w = 1;</span>
<span class="nc" id="L321">            int h = 1;</span>
<span class="nc" id="L322">            this.sampleModel =</span>
                new PixelInterleavedSampleModel(dataType,
                                                w, h,
                                                pixelStride,
                                                w*pixelStride,
                                                bandOffsets);
<span class="nc" id="L328">        }</span>

        public boolean equals(Object o) {
<span class="nc bnc" id="L331" title="All 4 branches missed.">            if ((o == null) ||</span>
                !(o instanceof ImageTypeSpecifier.Interleaved)) {
<span class="nc" id="L333">                return false;</span>
            }

<span class="nc" id="L336">            ImageTypeSpecifier.Interleaved that =</span>
                (ImageTypeSpecifier.Interleaved)o;

<span class="nc bnc" id="L339" title="All 10 branches missed.">            if ((!(this.colorSpace.equals(that.colorSpace))) ||</span>
                (this.dataType != that.dataType) ||
                (this.hasAlpha != that.hasAlpha) ||
                (this.isAlphaPremultiplied != that.isAlphaPremultiplied) ||
                (this.bandOffsets.length != that.bandOffsets.length)) {
<span class="nc" id="L344">                return false;</span>
            }

<span class="nc bnc" id="L347" title="All 2 branches missed.">            for (int i = 0; i &lt; bandOffsets.length; i++) {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                if (this.bandOffsets[i] != that.bandOffsets[i]) {</span>
<span class="nc" id="L349">                    return false;</span>
                }
            }

<span class="nc" id="L353">            return true;</span>
        }

        public int hashCode() {
<span class="nc bnc" id="L357" title="All 2 branches missed.">            return (super.hashCode() +</span>
                    (4 * bandOffsets.length) +
                    (25 * dataType) +
                    (hasAlpha ? 17 : 18));
        }
    }

    /**
     * Returns a specifier for an interleaved image format that will
     * use a &lt;code&gt;ComponentColorModel&lt;/code&gt; and a
     * &lt;code&gt;PixelInterleavedSampleModel&lt;/code&gt; to store each pixel
     * component in a separate byte, short, or int.
     *
     * @param colorSpace the desired &lt;code&gt;ColorSpace&lt;/code&gt;.
     * @param bandOffsets an array of &lt;code&gt;int&lt;/code&gt;s indicating the
     * offsets for each band.
     * @param dataType the desired data type, as one of the enumerations
     * from the &lt;code&gt;DataBuffer&lt;/code&gt; class.
     * @param hasAlpha &lt;code&gt;true&lt;/code&gt; if an alpha channel is desired.
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the color channels
     * will be premultipled by the alpha channel.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;colorSpace&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bandOffsets&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is
     * not one of the legal &lt;code&gt;DataBuffer.TYPE_*&lt;/code&gt; constants.
     * @exception IllegalArgumentException if
     * &lt;code&gt;bandOffsets.length&lt;/code&gt; does not equal the number of
     * color space components, plus 1 if &lt;code&gt;hasAlpha&lt;/code&gt; is
     * &lt;code&gt;true&lt;/code&gt;.
     */
    public static ImageTypeSpecifier
        createInterleaved(ColorSpace colorSpace,
                          int[] bandOffsets,
                          int dataType,
                          boolean hasAlpha,
                          boolean isAlphaPremultiplied) {
<span class="nc" id="L399">        return new ImageTypeSpecifier.Interleaved(colorSpace,</span>
                                                  bandOffsets,
                                                  dataType,
                                                  hasAlpha,
                                                  isAlphaPremultiplied);
    }

    // Banded

    static class Banded extends ImageTypeSpecifier {
        ColorSpace colorSpace;
        int[] bankIndices;
        int[] bandOffsets;
        int dataType;
        boolean hasAlpha;
        boolean isAlphaPremultiplied;

        public Banded(ColorSpace colorSpace,
                      int[] bankIndices,
                      int[] bandOffsets,
                      int dataType,
                      boolean hasAlpha,
<span class="nc" id="L421">                      boolean isAlphaPremultiplied) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (colorSpace == null) {</span>
<span class="nc" id="L423">                throw new IllegalArgumentException(&quot;colorSpace == null!&quot;);</span>
            }
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (bankIndices == null) {</span>
<span class="nc" id="L426">                throw new IllegalArgumentException(&quot;bankIndices == null!&quot;);</span>
            }
<span class="nc bnc" id="L428" title="All 2 branches missed.">            if (bandOffsets == null) {</span>
<span class="nc" id="L429">                throw new IllegalArgumentException(&quot;bandOffsets == null!&quot;);</span>
            }
<span class="nc bnc" id="L431" title="All 2 branches missed.">            if (bankIndices.length != bandOffsets.length) {</span>
<span class="nc" id="L432">                throw new IllegalArgumentException</span>
                    (&quot;bankIndices.length != bandOffsets.length!&quot;);
            }
<span class="nc bnc" id="L435" title="All 12 branches missed.">            if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;</span>
                dataType != DataBuffer.TYPE_SHORT &amp;&amp;
                dataType != DataBuffer.TYPE_USHORT &amp;&amp;
                dataType != DataBuffer.TYPE_INT &amp;&amp;
                dataType != DataBuffer.TYPE_FLOAT &amp;&amp;
                dataType != DataBuffer.TYPE_DOUBLE) {
<span class="nc" id="L441">                throw new IllegalArgumentException</span>
                    (&quot;Bad value for dataType!&quot;);
            }
<span class="nc bnc" id="L444" title="All 2 branches missed.">            int numBands = colorSpace.getNumComponents() +</span>
                (hasAlpha ? 1 : 0);
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (bandOffsets.length != numBands) {</span>
<span class="nc" id="L447">                throw new IllegalArgumentException</span>
                    (&quot;bandOffsets.length is wrong!&quot;);
            }

<span class="nc" id="L451">            this.colorSpace = colorSpace;</span>
<span class="nc" id="L452">            this.bankIndices = (int[])bankIndices.clone();</span>
<span class="nc" id="L453">            this.bandOffsets = (int[])bandOffsets.clone();</span>
<span class="nc" id="L454">            this.dataType = dataType;</span>
<span class="nc" id="L455">            this.hasAlpha = hasAlpha;</span>
<span class="nc" id="L456">            this.isAlphaPremultiplied = isAlphaPremultiplied;</span>

<span class="nc" id="L458">            this.colorModel =</span>
<span class="nc" id="L459">                ImageTypeSpecifier.createComponentCM(colorSpace,</span>
                                                     bankIndices.length,
                                                     dataType,
                                                     hasAlpha,
                                                     isAlphaPremultiplied);

<span class="nc" id="L465">            int w = 1;</span>
<span class="nc" id="L466">            int h = 1;</span>
<span class="nc" id="L467">            this.sampleModel = new BandedSampleModel(dataType,</span>
                                                     w, h,
                                                     w,
                                                     bankIndices,
                                                     bandOffsets);
<span class="nc" id="L472">        }</span>

        public boolean equals(Object o) {
<span class="nc bnc" id="L475" title="All 4 branches missed.">            if ((o == null) ||</span>
                !(o instanceof ImageTypeSpecifier.Banded)) {
<span class="nc" id="L477">                return false;</span>
            }

<span class="nc" id="L480">            ImageTypeSpecifier.Banded that =</span>
                (ImageTypeSpecifier.Banded)o;

<span class="nc bnc" id="L483" title="All 12 branches missed.">            if ((!(this.colorSpace.equals(that.colorSpace))) ||</span>
                (this.dataType != that.dataType) ||
                (this.hasAlpha != that.hasAlpha) ||
                (this.isAlphaPremultiplied != that.isAlphaPremultiplied) ||
                (this.bankIndices.length != that.bankIndices.length) ||
                (this.bandOffsets.length != that.bandOffsets.length)) {
<span class="nc" id="L489">                return false;</span>
            }

<span class="nc bnc" id="L492" title="All 2 branches missed.">            for (int i = 0; i &lt; bankIndices.length; i++) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                if (this.bankIndices[i] != that.bankIndices[i]) {</span>
<span class="nc" id="L494">                    return false;</span>
                }
            }

<span class="nc bnc" id="L498" title="All 2 branches missed.">            for (int i = 0; i &lt; bandOffsets.length; i++) {</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">                if (this.bandOffsets[i] != that.bandOffsets[i]) {</span>
<span class="nc" id="L500">                    return false;</span>
                }
            }

<span class="nc" id="L504">            return true;</span>
        }

        public int hashCode() {
<span class="nc bnc" id="L508" title="All 2 branches missed.">            return (super.hashCode() +</span>
                    (3 * bandOffsets.length) +
                    (7 * bankIndices.length) +
                    (21 * dataType) +
                    (hasAlpha ? 19 : 29));
        }
    }

    /**
     * Returns a specifier for a banded image format that will use a
     * &lt;code&gt;ComponentColorModel&lt;/code&gt; and a
     * &lt;code&gt;BandedSampleModel&lt;/code&gt; to store each channel in a
     * separate array.
     *
     * @param colorSpace the desired &lt;code&gt;ColorSpace&lt;/code&gt;.
     * @param bankIndices an array of &lt;code&gt;int&lt;/code&gt;s indicating the
     * bank in which each band will be stored.
     * @param bandOffsets an array of &lt;code&gt;int&lt;/code&gt;s indicating the
     * starting offset of each band within its bank.
     * @param dataType the desired data type, as one of the enumerations
     * from the &lt;code&gt;DataBuffer&lt;/code&gt; class.
     * @param hasAlpha &lt;code&gt;true&lt;/code&gt; if an alpha channel is desired.
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the color channels
     * will be premultipled by the alpha channel.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;colorSpace&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bankIndices&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bandOffsets&lt;/code&gt;
     * is &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if the lengths of
     * &lt;code&gt;bankIndices&lt;/code&gt; and &lt;code&gt;bandOffsets&lt;/code&gt; differ.
     * @exception IllegalArgumentException if
     * &lt;code&gt;bandOffsets.length&lt;/code&gt; does not equal the number of
     * color space components, plus 1 if &lt;code&gt;hasAlpha&lt;/code&gt; is
     * &lt;code&gt;true&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is
     * not one of the legal &lt;code&gt;DataBuffer.TYPE_*&lt;/code&gt; constants.
     */
    public static ImageTypeSpecifier
        createBanded(ColorSpace colorSpace,
                     int[] bankIndices,
                     int[] bandOffsets,
                     int dataType,
                     boolean hasAlpha,
                     boolean isAlphaPremultiplied) {
<span class="nc" id="L558">        return new ImageTypeSpecifier.Banded(colorSpace,</span>
                                             bankIndices,
                                             bandOffsets,
                                             dataType,
                                             hasAlpha,
                                             isAlphaPremultiplied);
    }

    // Grayscale

    static class Grayscale extends ImageTypeSpecifier {
        int bits;
        int dataType;
        boolean isSigned;
        boolean hasAlpha;
        boolean isAlphaPremultiplied;

        public Grayscale(int bits,
                         int dataType,
                         boolean isSigned,
                         boolean hasAlpha,
                         boolean isAlphaPremultiplied)
<span class="nc" id="L580">        {</span>
<span class="nc bnc" id="L581" title="All 10 branches missed.">            if (bits != 1 &amp;&amp; bits != 2 &amp;&amp; bits != 4 &amp;&amp;</span>
                bits != 8 &amp;&amp; bits != 16)
            {
<span class="nc" id="L584">                throw new IllegalArgumentException(&quot;Bad value for bits!&quot;);</span>
            }
<span class="nc bnc" id="L586" title="All 6 branches missed.">            if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;</span>
                dataType != DataBuffer.TYPE_SHORT &amp;&amp;
                dataType != DataBuffer.TYPE_USHORT)
            {
<span class="nc" id="L590">                throw new IllegalArgumentException</span>
                    (&quot;Bad value for dataType!&quot;);
            }
<span class="nc bnc" id="L593" title="All 4 branches missed.">            if (bits &gt; 8 &amp;&amp; dataType == DataBuffer.TYPE_BYTE) {</span>
<span class="nc" id="L594">                throw new IllegalArgumentException</span>
                    (&quot;Too many bits for dataType!&quot;);
            }

<span class="nc" id="L598">            this.bits = bits;</span>
<span class="nc" id="L599">            this.dataType = dataType;</span>
<span class="nc" id="L600">            this.isSigned = isSigned;</span>
<span class="nc" id="L601">            this.hasAlpha = hasAlpha;</span>
<span class="nc" id="L602">            this.isAlphaPremultiplied = isAlphaPremultiplied;</span>

<span class="nc" id="L604">            ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_GRAY);</span>

<span class="nc bnc" id="L606" title="All 10 branches missed.">            if ((bits == 8 &amp;&amp; dataType == DataBuffer.TYPE_BYTE) ||</span>
                (bits == 16 &amp;&amp;
                 (dataType == DataBuffer.TYPE_SHORT ||
                  dataType == DataBuffer.TYPE_USHORT))) {
                // Use component color model &amp; sample model

<span class="nc bnc" id="L612" title="All 2 branches missed.">                int numBands = hasAlpha ? 2 : 1;</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                int transparency =</span>
                    hasAlpha ? Transparency.TRANSLUCENT : Transparency.OPAQUE;


<span class="nc" id="L617">                int[] nBits = new int[numBands];</span>
<span class="nc" id="L618">                nBits[0] = bits;</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">                if (numBands == 2) {</span>
<span class="nc" id="L620">                    nBits[1] = bits;</span>
                }
<span class="nc" id="L622">                this.colorModel =</span>
                    new ComponentColorModel(colorSpace,
                                            nBits,
                                            hasAlpha,
                                            isAlphaPremultiplied,
                                            transparency,
                                            dataType);

<span class="nc" id="L630">                int[] bandOffsets = new int[numBands];</span>
<span class="nc" id="L631">                bandOffsets[0] = 0;</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">                if (numBands == 2) {</span>
<span class="nc" id="L633">                    bandOffsets[1] = 1;</span>
                }

<span class="nc" id="L636">                int w = 1;</span>
<span class="nc" id="L637">                int h = 1;</span>
<span class="nc" id="L638">                this.sampleModel =</span>
                    new PixelInterleavedSampleModel(dataType,
                                                    w, h,
                                                    numBands, w*numBands,
                                                    bandOffsets);
<span class="nc" id="L643">            } else {</span>
<span class="nc" id="L644">                int numEntries = 1 &lt;&lt; bits;</span>
<span class="nc" id="L645">                byte[] arr = new byte[numEntries];</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">                for (int i = 0; i &lt; numEntries; i++) {</span>
<span class="nc" id="L647">                    arr[i] = (byte)(i*255/(numEntries - 1));</span>
                }
<span class="nc" id="L649">                this.colorModel =</span>
                    new IndexColorModel(bits, numEntries, arr, arr, arr);

<span class="nc" id="L652">                this.sampleModel =</span>
                    new MultiPixelPackedSampleModel(dataType, 1, 1, bits);
            }
<span class="nc" id="L655">        }</span>
    }

    /**
     * Returns a specifier for a grayscale image format that will pack
     * pixels of the given bit depth into array elements of
     * the specified data type.
     *
     * @param bits the number of bits per gray value (1, 2, 4, 8, or 16).
     * @param dataType the desired data type, as one of the enumerations
     * from the &lt;code&gt;DataBuffer&lt;/code&gt; class.
     * @param isSigned &lt;code&gt;true&lt;/code&gt; if negative values are to
     * be represented.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * not one of 1, 2, 4, 8, or 16.
     * @exception IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is
     * not one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_SHORT&lt;/code&gt;, or
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * larger than the bit size of the given &lt;code&gt;dataType&lt;/code&gt;.
     */
    public static ImageTypeSpecifier
        createGrayscale(int bits,
                        int dataType,
                        boolean isSigned) {
<span class="nc" id="L685">        return new ImageTypeSpecifier.Grayscale(bits,</span>
                                                dataType,
                                                isSigned,
                                                false,
                                                false);
    }

    /**
     * Returns a specifier for a grayscale plus alpha image format
     * that will pack pixels of the given bit depth into array
     * elements of the specified data type.
     *
     * @param bits the number of bits per gray value (1, 2, 4, 8, or 16).
     * @param dataType the desired data type, as one of the enumerations
     * from the &lt;code&gt;DataBuffer&lt;/code&gt; class.
     * @param isSigned &lt;code&gt;true&lt;/code&gt; if negative values are to
     * be represented.
     * @param isAlphaPremultiplied &lt;code&gt;true&lt;/code&gt; if the luminance channel
     * will be premultipled by the alpha channel.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * not one of 1, 2, 4, 8, or 16.
     * @exception IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is
     * not one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_SHORT&lt;/code&gt;, or
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * larger than the bit size of the given &lt;code&gt;dataType&lt;/code&gt;.
     */
    public static ImageTypeSpecifier
        createGrayscale(int bits,
                        int dataType,
                        boolean isSigned,
                        boolean isAlphaPremultiplied) {
<span class="nc" id="L722">        return new ImageTypeSpecifier.Grayscale(bits,</span>
                                                dataType,
                                                isSigned,
                                                true,
                                                isAlphaPremultiplied);
    }

    // Indexed

    static class Indexed extends ImageTypeSpecifier {
        byte[] redLUT;
        byte[] greenLUT;
        byte[] blueLUT;
<span class="nc" id="L735">        byte[] alphaLUT = null;</span>
        int bits;
        int dataType;

        public Indexed(byte[] redLUT,
                       byte[] greenLUT,
                       byte[] blueLUT,
                       byte[] alphaLUT,
                       int bits,
<span class="nc" id="L744">                       int dataType) {</span>
<span class="nc bnc" id="L745" title="All 6 branches missed.">            if (redLUT == null || greenLUT == null || blueLUT == null) {</span>
<span class="nc" id="L746">                throw new IllegalArgumentException(&quot;LUT is null!&quot;);</span>
            }
<span class="nc bnc" id="L748" title="All 10 branches missed.">            if (bits != 1 &amp;&amp; bits != 2 &amp;&amp; bits != 4 &amp;&amp;</span>
                bits != 8 &amp;&amp; bits != 16) {
<span class="nc" id="L750">                throw new IllegalArgumentException(&quot;Bad value for bits!&quot;);</span>
            }
<span class="nc bnc" id="L752" title="All 8 branches missed.">            if (dataType != DataBuffer.TYPE_BYTE &amp;&amp;</span>
                dataType != DataBuffer.TYPE_SHORT &amp;&amp;
                dataType != DataBuffer.TYPE_USHORT &amp;&amp;
                dataType != DataBuffer.TYPE_INT) {
<span class="nc" id="L756">                throw new IllegalArgumentException</span>
                    (&quot;Bad value for dataType!&quot;);
            }
<span class="nc bnc" id="L759" title="All 8 branches missed.">            if ((bits &gt; 8 &amp;&amp; dataType == DataBuffer.TYPE_BYTE) ||</span>
                (bits &gt; 16 &amp;&amp; dataType != DataBuffer.TYPE_INT)) {
<span class="nc" id="L761">                throw new IllegalArgumentException</span>
                    (&quot;Too many bits for dataType!&quot;);
            }

<span class="nc" id="L765">            int len = 1 &lt;&lt; bits;</span>
<span class="nc bnc" id="L766" title="All 10 branches missed.">            if (redLUT.length != len ||</span>
                greenLUT.length != len ||
                blueLUT.length != len ||
                (alphaLUT != null &amp;&amp; alphaLUT.length != len)) {
<span class="nc" id="L770">                throw new IllegalArgumentException(&quot;LUT has improper length!&quot;);</span>
            }
<span class="nc" id="L772">            this.redLUT = (byte[])redLUT.clone();</span>
<span class="nc" id="L773">            this.greenLUT = (byte[])greenLUT.clone();</span>
<span class="nc" id="L774">            this.blueLUT = (byte[])blueLUT.clone();</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">            if (alphaLUT != null) {</span>
<span class="nc" id="L776">                this.alphaLUT = (byte[])alphaLUT.clone();</span>
            }
<span class="nc" id="L778">            this.bits = bits;</span>
<span class="nc" id="L779">            this.dataType = dataType;</span>

<span class="nc bnc" id="L781" title="All 2 branches missed.">            if (alphaLUT == null) {</span>
<span class="nc" id="L782">                this.colorModel = new IndexColorModel(bits,</span>
                                                      redLUT.length,
                                                      redLUT,
                                                      greenLUT,
                                                      blueLUT);
            } else {
<span class="nc" id="L788">                this.colorModel = new IndexColorModel(bits,</span>
                                                      redLUT.length,
                                                      redLUT,
                                                      greenLUT,
                                                      blueLUT,
                                                      alphaLUT);
            }

<span class="nc bnc" id="L796" title="All 10 branches missed.">            if ((bits == 8 &amp;&amp; dataType == DataBuffer.TYPE_BYTE) ||</span>
                (bits == 16 &amp;&amp;
                 (dataType == DataBuffer.TYPE_SHORT ||
                  dataType == DataBuffer.TYPE_USHORT))) {
<span class="nc" id="L800">                int[] bandOffsets = { 0 };</span>
<span class="nc" id="L801">                this.sampleModel =</span>
                    new PixelInterleavedSampleModel(dataType,
                                                    1, 1, 1, 1,
                                                    bandOffsets);
<span class="nc" id="L805">            } else {</span>
<span class="nc" id="L806">                this.sampleModel =</span>
                    new MultiPixelPackedSampleModel(dataType, 1, 1, bits);
            }
<span class="nc" id="L809">        }</span>
    }

    /**
     * Returns a specifier for an indexed-color image format that will pack
     * index values of the given bit depth into array elements of
     * the specified data type.
     *
     * @param redLUT an array of &lt;code&gt;byte&lt;/code&gt;s containing
     * the red values for each index.
     * @param greenLUT an array of &lt;code&gt;byte&lt;/code&gt;s containing * the
     *  green values for each index.
     * @param blueLUT an array of &lt;code&gt;byte&lt;/code&gt;s containing the
     * blue values for each index.
     * @param alphaLUT an array of &lt;code&gt;byte&lt;/code&gt;s containing the
     * alpha values for each index, or &lt;code&gt;null&lt;/code&gt; to create a
     * fully opaque LUT.
     * @param bits the number of bits in each index.
     * @param dataType the desired output type, as one of the enumerations
     * from the &lt;code&gt;DataBuffer&lt;/code&gt; class.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;redLUT&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;greenLUT&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;blueLUT&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * not one of 1, 2, 4, 8, or 16.
     * @exception IllegalArgumentException if the
     * non-&lt;code&gt;null&lt;/code&gt; LUT parameters do not have lengths of
     * exactly {@code 1 &lt;&lt; bits}.
     * @exception IllegalArgumentException if &lt;code&gt;dataType&lt;/code&gt; is
     * not one of &lt;code&gt;DataBuffer.TYPE_BYTE&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_SHORT&lt;/code&gt;,
     * &lt;code&gt;DataBuffer.TYPE_USHORT&lt;/code&gt;,
     * or &lt;code&gt;DataBuffer.TYPE_INT&lt;/code&gt;.
     * @exception IllegalArgumentException if &lt;code&gt;bits&lt;/code&gt; is
     * larger than the bit size of the given &lt;code&gt;dataType&lt;/code&gt;.
     */
    public static ImageTypeSpecifier
        createIndexed(byte[] redLUT,
                      byte[] greenLUT,
                      byte[] blueLUT,
                      byte[] alphaLUT,
                      int bits,
                      int dataType) {
<span class="nc" id="L859">        return new ImageTypeSpecifier.Indexed(redLUT,</span>
                                              greenLUT,
                                              blueLUT,
                                              alphaLUT,
                                              bits,
                                              dataType);
    }

    /**
     * Returns an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; that encodes
     * one of the standard &lt;code&gt;BufferedImage&lt;/code&gt; types
     * (other than &lt;code&gt;TYPE_CUSTOM&lt;/code&gt;).
     *
     * @param bufferedImageType an int representing one of the standard
     * &lt;code&gt;BufferedImage&lt;/code&gt; types.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if
     * &lt;code&gt;bufferedImageType&lt;/code&gt; is not one of the standard
     * types, or is equal to &lt;code&gt;TYPE_CUSTOM&lt;/code&gt;.
     *
     * @see java.awt.image.BufferedImage
     * @see java.awt.image.BufferedImage#TYPE_INT_RGB
     * @see java.awt.image.BufferedImage#TYPE_INT_ARGB
     * @see java.awt.image.BufferedImage#TYPE_INT_ARGB_PRE
     * @see java.awt.image.BufferedImage#TYPE_INT_BGR
     * @see java.awt.image.BufferedImage#TYPE_3BYTE_BGR
     * @see java.awt.image.BufferedImage#TYPE_4BYTE_ABGR
     * @see java.awt.image.BufferedImage#TYPE_4BYTE_ABGR_PRE
     * @see java.awt.image.BufferedImage#TYPE_USHORT_565_RGB
     * @see java.awt.image.BufferedImage#TYPE_USHORT_555_RGB
     * @see java.awt.image.BufferedImage#TYPE_BYTE_GRAY
     * @see java.awt.image.BufferedImage#TYPE_USHORT_GRAY
     * @see java.awt.image.BufferedImage#TYPE_BYTE_BINARY
     * @see java.awt.image.BufferedImage#TYPE_BYTE_INDEXED
     */
    public static
        ImageTypeSpecifier createFromBufferedImageType(int bufferedImageType) {
<span class="nc bnc" id="L899" title="All 4 branches missed.">        if (bufferedImageType &gt;= BufferedImage.TYPE_INT_RGB &amp;&amp;</span>
            bufferedImageType &lt;= BufferedImage.TYPE_BYTE_INDEXED) {
<span class="nc" id="L901">            return getSpecifier(bufferedImageType);</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">        } else if (bufferedImageType == BufferedImage.TYPE_CUSTOM) {</span>
<span class="nc" id="L903">            throw new IllegalArgumentException(&quot;Cannot create from TYPE_CUSTOM!&quot;);</span>
        } else {
<span class="nc" id="L905">            throw new IllegalArgumentException(&quot;Invalid BufferedImage type!&quot;);</span>
        }
    }

    /**
     * Returns an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; that encodes the
     * layout of a &lt;code&gt;RenderedImage&lt;/code&gt; (which may be a
     * &lt;code&gt;BufferedImage&lt;/code&gt;).
     *
     * @param image a &lt;code&gt;RenderedImage&lt;/code&gt;.
     *
     * @return an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; with the desired
     * characteristics.
     *
     * @exception IllegalArgumentException if &lt;code&gt;image&lt;/code&gt; is
     * &lt;code&gt;null&lt;/code&gt;.
     */
    public static
        ImageTypeSpecifier createFromRenderedImage(RenderedImage image) {
<span class="nc bnc" id="L924" title="All 2 branches missed.">        if (image == null) {</span>
<span class="nc" id="L925">            throw new IllegalArgumentException(&quot;image == null!&quot;);</span>
        }

<span class="nc bnc" id="L928" title="All 2 branches missed.">        if (image instanceof BufferedImage) {</span>
<span class="nc" id="L929">            int bufferedImageType = ((BufferedImage)image).getType();</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">            if (bufferedImageType != BufferedImage.TYPE_CUSTOM) {</span>
<span class="nc" id="L931">                return getSpecifier(bufferedImageType);</span>
            }
        }

<span class="nc" id="L935">        return new ImageTypeSpecifier(image);</span>
    }

    /**
     * Returns an int containing one of the enumerated constant values
     * describing image formats from &lt;code&gt;BufferedImage&lt;/code&gt;.
     *
     * @return an &lt;code&gt;int&lt;/code&gt; representing a
     * &lt;code&gt;BufferedImage&lt;/code&gt; type.
     *
     * @see java.awt.image.BufferedImage
     * @see java.awt.image.BufferedImage#TYPE_CUSTOM
     * @see java.awt.image.BufferedImage#TYPE_INT_RGB
     * @see java.awt.image.BufferedImage#TYPE_INT_ARGB
     * @see java.awt.image.BufferedImage#TYPE_INT_ARGB_PRE
     * @see java.awt.image.BufferedImage#TYPE_INT_BGR
     * @see java.awt.image.BufferedImage#TYPE_3BYTE_BGR
     * @see java.awt.image.BufferedImage#TYPE_4BYTE_ABGR
     * @see java.awt.image.BufferedImage#TYPE_4BYTE_ABGR_PRE
     * @see java.awt.image.BufferedImage#TYPE_USHORT_565_RGB
     * @see java.awt.image.BufferedImage#TYPE_USHORT_555_RGB
     * @see java.awt.image.BufferedImage#TYPE_BYTE_GRAY
     * @see java.awt.image.BufferedImage#TYPE_USHORT_GRAY
     * @see java.awt.image.BufferedImage#TYPE_BYTE_BINARY
     * @see java.awt.image.BufferedImage#TYPE_BYTE_INDEXED
     */
    public int getBufferedImageType() {
<span class="nc" id="L962">        BufferedImage bi = createBufferedImage(1, 1);</span>
<span class="nc" id="L963">        return bi.getType();</span>
    }

    /**
     * Return the number of color components
     * specified by this object.  This is the same value as returned by
     * &lt;code&gt;ColorModel.getNumComponents&lt;/code&gt;
     *
     * @return the number of components in the image.
     */
    public int getNumComponents() {
<span class="nc" id="L974">        return colorModel.getNumComponents();</span>
    }

    /**
     * Return the number of bands
     * specified by this object.  This is the same value as returned by
     * &lt;code&gt;SampleModel.getNumBands&lt;/code&gt;
     *
     * @return the number of bands in the image.
     */
    public int getNumBands() {
<span class="nc" id="L985">        return sampleModel.getNumBands();</span>
    }

    /**
     * Return the number of bits used to represent samples of the given band.
     *
     * @param band the index of the band to be queried, as an
     * int.
     *
     * @return an int specifying a number of bits.
     *
     * @exception IllegalArgumentException if &lt;code&gt;band&lt;/code&gt; is
     * negative or greater than the largest band index.
     */
    public int getBitsPerBand(int band) {
<span class="nc bnc" id="L1000" title="All 6 branches missed.">        if (band &lt; 0 | band &gt;= getNumBands()) {</span>
<span class="nc" id="L1001">            throw new IllegalArgumentException(&quot;band out of range!&quot;);</span>
        }
<span class="nc" id="L1003">        return sampleModel.getSampleSize(band);</span>
    }

    /**
     * Returns a &lt;code&gt;SampleModel&lt;/code&gt; based on the settings
     * encapsulated within this object.  The width and height of the
     * &lt;code&gt;SampleModel&lt;/code&gt; will be set to arbitrary values.
     *
     * @return a &lt;code&gt;SampleModel&lt;/code&gt; with arbitrary dimensions.
     */
    public SampleModel getSampleModel() {
<span class="nc" id="L1014">        return sampleModel;</span>
    }

    /**
     * Returns a &lt;code&gt;SampleModel&lt;/code&gt; based on the settings
     * encapsulated within this object.  The width and height of the
     * &lt;code&gt;SampleModel&lt;/code&gt; will be set to the supplied values.
     *
     * @param width the desired width of the returned &lt;code&gt;SampleModel&lt;/code&gt;.
     * @param height the desired height of the returned
     * &lt;code&gt;SampleModel&lt;/code&gt;.
     *
     * @return a &lt;code&gt;SampleModel&lt;/code&gt; with the given dimensions.
     *
     * @exception IllegalArgumentException if either &lt;code&gt;width&lt;/code&gt; or
     * &lt;code&gt;height&lt;/code&gt; are negative or zero.
     * @exception IllegalArgumentException if the product of
     * &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; is greater than
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;
     */
    public SampleModel getSampleModel(int width, int height) {
<span class="nc bnc" id="L1035" title="All 2 branches missed.">        if ((long)width*height &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L1036">            throw new IllegalArgumentException</span>
                (&quot;width*height &gt; Integer.MAX_VALUE!&quot;);
        }
<span class="nc" id="L1039">        return sampleModel.createCompatibleSampleModel(width, height);</span>
    }

    /**
     * Returns the &lt;code&gt;ColorModel&lt;/code&gt; specified by this object.
     *
     * @return a &lt;code&gt;ColorModel&lt;/code&gt;.
     */
    public ColorModel getColorModel() {
<span class="nc" id="L1048">        return colorModel;</span>
    }

    /**
     * Creates a &lt;code&gt;BufferedImage&lt;/code&gt; with a given width and
     * height according to the specification embodied in this object.
     *
     * @param width the desired width of the returned
     * &lt;code&gt;BufferedImage&lt;/code&gt;.
     * @param height the desired height of the returned
     * &lt;code&gt;BufferedImage&lt;/code&gt;.
     *
     * @return a new &lt;code&gt;BufferedImage&lt;/code&gt;
     *
     * @exception IllegalArgumentException if either &lt;code&gt;width&lt;/code&gt; or
     * &lt;code&gt;height&lt;/code&gt; are negative or zero.
     * @exception IllegalArgumentException if the product of
     * &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; is greater than
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;, or if the number of array
     * elements needed to store the image is greater than
     * &lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;.
     */
    public BufferedImage createBufferedImage(int width, int height) {
        try {
<span class="nc" id="L1072">            SampleModel sampleModel = getSampleModel(width, height);</span>
<span class="nc" id="L1073">            WritableRaster raster =</span>
<span class="nc" id="L1074">                Raster.createWritableRaster(sampleModel,</span>
                                            new Point(0, 0));
<span class="nc" id="L1076">            return new BufferedImage(colorModel, raster,</span>
<span class="nc" id="L1077">                                     colorModel.isAlphaPremultiplied(),</span>
                                     new Hashtable());
<span class="nc" id="L1079">        } catch (NegativeArraySizeException e) {</span>
            // Exception most likely thrown from a DataBuffer constructor
<span class="nc" id="L1081">            throw new IllegalArgumentException</span>
                (&quot;Array size &gt; Integer.MAX_VALUE!&quot;);
        }
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;Object&lt;/code&gt; is
     * an &lt;code&gt;ImageTypeSpecifier&lt;/code&gt; and has a
     * &lt;code&gt;SampleModel&lt;/code&gt; and &lt;code&gt;ColorModel&lt;/code&gt; that are
     * equal to those of this object.
     *
     * @param o the &lt;code&gt;Object&lt;/code&gt; to be compared for equality.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the given object is an equivalent
     * &lt;code&gt;ImageTypeSpecifier&lt;/code&gt;.
     */
    public boolean equals(Object o) {
<span class="nc bnc" id="L1098" title="All 4 branches missed.">        if ((o == null) || !(o instanceof ImageTypeSpecifier)) {</span>
<span class="nc" id="L1099">            return false;</span>
        }

<span class="nc" id="L1102">        ImageTypeSpecifier that = (ImageTypeSpecifier)o;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">        return (colorModel.equals(that.colorModel)) &amp;&amp;</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">            (sampleModel.equals(that.sampleModel));</span>
    }

    /**
     * Returns the hash code for this ImageTypeSpecifier.
     *
     * @return a hash code for this ImageTypeSpecifier
     */
    public int hashCode() {
<span class="nc" id="L1113">        return (9 * colorModel.hashCode()) + (14 * sampleModel.hashCode());</span>
    }

    private static ImageTypeSpecifier getSpecifier(int type) {
<span class="nc bnc" id="L1117" title="All 2 branches missed.">        if (BISpecifier[type] == null) {</span>
<span class="nc" id="L1118">            BISpecifier[type] = createSpecifier(type);</span>
        }
<span class="nc" id="L1120">        return BISpecifier[type];</span>
    }

    private static ImageTypeSpecifier createSpecifier(int type) {
<span class="nc bnc" id="L1124" title="All 14 branches missed.">        switch(type) {</span>
          case BufferedImage.TYPE_INT_RGB:
<span class="nc" id="L1126">              return createPacked(sRGB,</span>
                                  0x00ff0000,
                                  0x0000ff00,
                                  0x000000ff,
                                  0x0,
                                  DataBuffer.TYPE_INT,
                                  false);

          case BufferedImage.TYPE_INT_ARGB:
<span class="nc" id="L1135">              return createPacked(sRGB,</span>
                                  0x00ff0000,
                                  0x0000ff00,
                                  0x000000ff,
                                  0xff000000,
                                  DataBuffer.TYPE_INT,
                                  false);

          case BufferedImage.TYPE_INT_ARGB_PRE:
<span class="nc" id="L1144">              return createPacked(sRGB,</span>
                                  0x00ff0000,
                                  0x0000ff00,
                                  0x000000ff,
                                  0xff000000,
                                  DataBuffer.TYPE_INT,
                                  true);

          case BufferedImage.TYPE_INT_BGR:
<span class="nc" id="L1153">              return createPacked(sRGB,</span>
                                  0x000000ff,
                                  0x0000ff00,
                                  0x00ff0000,
                                  0x0,
                                  DataBuffer.TYPE_INT,
                                  false);

          case BufferedImage.TYPE_3BYTE_BGR:
<span class="nc" id="L1162">              return createInterleaved(sRGB,</span>
                                       new int[] { 2, 1, 0 },
                                       DataBuffer.TYPE_BYTE,
                                       false,
                                       false);

          case BufferedImage.TYPE_4BYTE_ABGR:
<span class="nc" id="L1169">              return createInterleaved(sRGB,</span>
                                       new int[] { 3, 2, 1, 0 },
                                       DataBuffer.TYPE_BYTE,
                                       true,
                                       false);

          case BufferedImage.TYPE_4BYTE_ABGR_PRE:
<span class="nc" id="L1176">              return createInterleaved(sRGB,</span>
                                       new int[] { 3, 2, 1, 0 },
                                       DataBuffer.TYPE_BYTE,
                                       true,
                                       true);

          case BufferedImage.TYPE_USHORT_565_RGB:
<span class="nc" id="L1183">              return createPacked(sRGB,</span>
                                  0xF800,
                                  0x07E0,
                                  0x001F,
                                  0x0,
                                  DataBuffer.TYPE_USHORT,
                                  false);

          case BufferedImage.TYPE_USHORT_555_RGB:
<span class="nc" id="L1192">              return createPacked(sRGB,</span>
                                  0x7C00,
                                  0x03E0,
                                  0x001F,
                                  0x0,
                                  DataBuffer.TYPE_USHORT,
                                  false);

          case BufferedImage.TYPE_BYTE_GRAY:
<span class="nc" id="L1201">            return createGrayscale(8,</span>
                                   DataBuffer.TYPE_BYTE,
                                   false);

          case BufferedImage.TYPE_USHORT_GRAY:
<span class="nc" id="L1206">            return createGrayscale(16,</span>
                                   DataBuffer.TYPE_USHORT,
                                   false);

          case BufferedImage.TYPE_BYTE_BINARY:
<span class="nc" id="L1211">              return createGrayscale(1,</span>
                                     DataBuffer.TYPE_BYTE,
                                     false);

          case BufferedImage.TYPE_BYTE_INDEXED:
          {

<span class="nc" id="L1218">              BufferedImage bi =</span>
                  new BufferedImage(1, 1, BufferedImage.TYPE_BYTE_INDEXED);
<span class="nc" id="L1220">              IndexColorModel icm = (IndexColorModel)bi.getColorModel();</span>
<span class="nc" id="L1221">              int mapSize = icm.getMapSize();</span>
<span class="nc" id="L1222">              byte[] redLUT = new byte[mapSize];</span>
<span class="nc" id="L1223">              byte[] greenLUT = new byte[mapSize];</span>
<span class="nc" id="L1224">              byte[] blueLUT = new byte[mapSize];</span>
<span class="nc" id="L1225">              byte[] alphaLUT = new byte[mapSize];</span>

<span class="nc" id="L1227">              icm.getReds(redLUT);</span>
<span class="nc" id="L1228">              icm.getGreens(greenLUT);</span>
<span class="nc" id="L1229">              icm.getBlues(blueLUT);</span>
<span class="nc" id="L1230">              icm.getAlphas(alphaLUT);</span>

<span class="nc" id="L1232">              return createIndexed(redLUT, greenLUT, blueLUT, alphaLUT,</span>
                                   8,
                                   DataBuffer.TYPE_BYTE);
          }
          default:
<span class="nc" id="L1237">              throw new IllegalArgumentException(&quot;Invalid BufferedImage type!&quot;);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>