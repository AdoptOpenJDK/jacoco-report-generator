<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>ZoneOffsetTransitionRule.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">java.time.zone</a> &gt; <span class="el_source">ZoneOffsetTransitionRule.java</span></div><h1>ZoneOffsetTransitionRule.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/*
 * This file is available under and governed by the GNU General Public
 * License version 2 only, as published by the Free Software Foundation.
 * However, the following notice accompanied the original version of this
 * file:
 *
 * Copyright (c) 2009-2012, Stephen Colebourne &amp; Michael Nascimento Santos
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of JSR-310 nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package java.time.zone;

import static java.time.temporal.TemporalAdjusters.nextOrSame;
import static java.time.temporal.TemporalAdjusters.previousOrSame;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.Serializable;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Month;
import java.time.ZoneOffset;
import java.time.chrono.IsoChronology;
import java.util.Objects;

/**
 * A rule expressing how to create a transition.
 * &lt;p&gt;
 * This class allows rules for identifying future transitions to be expressed.
 * A rule might be written in many forms:
 * &lt;ul&gt;
 * &lt;li&gt;the 16th March
 * &lt;li&gt;the Sunday on or after the 16th March
 * &lt;li&gt;the Sunday on or before the 16th March
 * &lt;li&gt;the last Sunday in February
 * &lt;/ul&gt;
 * These different rule types can be expressed and queried.
 *
 * @implSpec
 * This class is immutable and thread-safe.
 *
 * @since 1.8
 */
public final class ZoneOffsetTransitionRule implements Serializable {

    /**
     * Serialization version.
     */
    private static final long serialVersionUID = 6889046316657758795L;

    /**
     * The month of the month-day of the first day of the cutover week.
     * The actual date will be adjusted by the dowChange field.
     */
    private final Month month;
    /**
     * The day-of-month of the month-day of the cutover week.
     * If positive, it is the start of the week where the cutover can occur.
     * If negative, it represents the end of the week where cutover can occur.
     * The value is the number of days from the end of the month, such that
     * {@code -1} is the last day of the month, {@code -2} is the second
     * to last day, and so on.
     */
    private final byte dom;
    /**
     * The cutover day-of-week, null to retain the day-of-month.
     */
    private final DayOfWeek dow;
    /**
     * The cutover time in the 'before' offset.
     */
    private final LocalTime time;
    /**
     * Whether the cutover time is midnight at the end of day.
     */
    private final boolean timeEndOfDay;
    /**
     * The definition of how the local time should be interpreted.
     */
    private final TimeDefinition timeDefinition;
    /**
     * The standard offset at the cutover.
     */
    private final ZoneOffset standardOffset;
    /**
     * The offset before the cutover.
     */
    private final ZoneOffset offsetBefore;
    /**
     * The offset after the cutover.
     */
    private final ZoneOffset offsetAfter;

    /**
     * Obtains an instance defining the yearly rule to create transitions between two offsets.
     * &lt;p&gt;
     * Applications should normally obtain an instance from {@link ZoneRules}.
     * This factory is only intended for use when creating {@link ZoneRules}.
     *
     * @param month  the month of the month-day of the first day of the cutover week, not null
     * @param dayOfMonthIndicator  the day of the month-day of the cutover week, positive if the week is that
     *  day or later, negative if the week is that day or earlier, counting from the last day of the month,
     *  from -28 to 31 excluding 0
     * @param dayOfWeek  the required day-of-week, null if the month-day should not be changed
     * @param time  the cutover time in the 'before' offset, not null
     * @param timeEndOfDay  whether the time is midnight at the end of day
     * @param timeDefnition  how to interpret the cutover
     * @param standardOffset  the standard offset in force at the cutover, not null
     * @param offsetBefore  the offset before the cutover, not null
     * @param offsetAfter  the offset after the cutover, not null
     * @return the rule, not null
     * @throws IllegalArgumentException if the day of month indicator is invalid
     * @throws IllegalArgumentException if the end of day flag is true when the time is not midnight
     */
    public static ZoneOffsetTransitionRule of(
            Month month,
            int dayOfMonthIndicator,
            DayOfWeek dayOfWeek,
            LocalTime time,
            boolean timeEndOfDay,
            TimeDefinition timeDefnition,
            ZoneOffset standardOffset,
            ZoneOffset offsetBefore,
            ZoneOffset offsetAfter) {
<span class="fc" id="L180">        Objects.requireNonNull(month, &quot;month&quot;);</span>
<span class="fc" id="L181">        Objects.requireNonNull(time, &quot;time&quot;);</span>
<span class="fc" id="L182">        Objects.requireNonNull(timeDefnition, &quot;timeDefnition&quot;);</span>
<span class="fc" id="L183">        Objects.requireNonNull(standardOffset, &quot;standardOffset&quot;);</span>
<span class="fc" id="L184">        Objects.requireNonNull(offsetBefore, &quot;offsetBefore&quot;);</span>
<span class="fc" id="L185">        Objects.requireNonNull(offsetAfter, &quot;offsetAfter&quot;);</span>
<span class="pc bpc" id="L186" title="3 of 6 branches missed.">        if (dayOfMonthIndicator &lt; -28 || dayOfMonthIndicator &gt; 31 || dayOfMonthIndicator == 0) {</span>
<span class="nc" id="L187">            throw new IllegalArgumentException(&quot;Day of month indicator must be between -28 and 31 inclusive excluding zero&quot;);</span>
        }
<span class="pc bpc" id="L189" title="3 of 4 branches missed.">        if (timeEndOfDay &amp;&amp; time.equals(LocalTime.MIDNIGHT) == false) {</span>
<span class="nc" id="L190">            throw new IllegalArgumentException(&quot;Time must be midnight when end of day flag is true&quot;);</span>
        }
<span class="fc" id="L192">        return new ZoneOffsetTransitionRule(month, dayOfMonthIndicator, dayOfWeek, time, timeEndOfDay, timeDefnition, standardOffset, offsetBefore, offsetAfter);</span>
    }

    /**
     * Creates an instance defining the yearly rule to create transitions between two offsets.
     *
     * @param month  the month of the month-day of the first day of the cutover week, not null
     * @param dayOfMonthIndicator  the day of the month-day of the cutover week, positive if the week is that
     *  day or later, negative if the week is that day or earlier, counting from the last day of the month,
     *  from -28 to 31 excluding 0
     * @param dayOfWeek  the required day-of-week, null if the month-day should not be changed
     * @param time  the cutover time in the 'before' offset, not null
     * @param timeEndOfDay  whether the time is midnight at the end of day
     * @param timeDefnition  how to interpret the cutover
     * @param standardOffset  the standard offset in force at the cutover, not null
     * @param offsetBefore  the offset before the cutover, not null
     * @param offsetAfter  the offset after the cutover, not null
     * @throws IllegalArgumentException if the day of month indicator is invalid
     * @throws IllegalArgumentException if the end of day flag is true when the time is not midnight
     */
    ZoneOffsetTransitionRule(
            Month month,
            int dayOfMonthIndicator,
            DayOfWeek dayOfWeek,
            LocalTime time,
            boolean timeEndOfDay,
            TimeDefinition timeDefnition,
            ZoneOffset standardOffset,
            ZoneOffset offsetBefore,
<span class="fc" id="L221">            ZoneOffset offsetAfter) {</span>
<span class="fc" id="L222">        this.month = month;</span>
<span class="fc" id="L223">        this.dom = (byte) dayOfMonthIndicator;</span>
<span class="fc" id="L224">        this.dow = dayOfWeek;</span>
<span class="fc" id="L225">        this.time = time;</span>
<span class="fc" id="L226">        this.timeEndOfDay = timeEndOfDay;</span>
<span class="fc" id="L227">        this.timeDefinition = timeDefnition;</span>
<span class="fc" id="L228">        this.standardOffset = standardOffset;</span>
<span class="fc" id="L229">        this.offsetBefore = offsetBefore;</span>
<span class="fc" id="L230">        this.offsetAfter = offsetAfter;</span>
<span class="fc" id="L231">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Defend against malicious streams.
     * @return never
     * @throws InvalidObjectException always
     */
    private Object readResolve() throws InvalidObjectException {
<span class="nc" id="L240">        throw new InvalidObjectException(&quot;Deserialization via serialization delegate&quot;);</span>
    }

    /**
     * Writes the object using a
     * &lt;a href=&quot;../../../serialized-form.html#java.time.zone.Ser&quot;&gt;dedicated serialized form&lt;/a&gt;.
     * @serialData
     * Refer to the serialized form of
     * &lt;a href=&quot;../../../serialized-form.html#java.time.zone.ZoneRules&quot;&gt;ZoneRules.writeReplace&lt;/a&gt;
     * for the encoding of epoch seconds and offsets.
     * &lt;pre style=&quot;font-size:1.0em&quot;&gt;{@code
     *
     *      out.writeByte(3);                // identifies a ZoneOffsetTransition
     *      final int timeSecs = (timeEndOfDay ? 86400 : time.toSecondOfDay());
     *      final int stdOffset = standardOffset.getTotalSeconds();
     *      final int beforeDiff = offsetBefore.getTotalSeconds() - stdOffset;
     *      final int afterDiff = offsetAfter.getTotalSeconds() - stdOffset;
     *      final int timeByte = (timeSecs % 3600 == 0 ? (timeEndOfDay ? 24 : time.getHour()) : 31);
     *      final int stdOffsetByte = (stdOffset % 900 == 0 ? stdOffset / 900 + 128 : 255);
     *      final int beforeByte = (beforeDiff == 0 || beforeDiff == 1800 || beforeDiff == 3600 ? beforeDiff / 1800 : 3);
     *      final int afterByte = (afterDiff == 0 || afterDiff == 1800 || afterDiff == 3600 ? afterDiff / 1800 : 3);
     *      final int dowByte = (dow == null ? 0 : dow.getValue());
     *      int b = (month.getValue() &lt;&lt; 28) +          // 4 bits
     *              ((dom + 32) &lt;&lt; 22) +                // 6 bits
     *              (dowByte &lt;&lt; 19) +                   // 3 bits
     *              (timeByte &lt;&lt; 14) +                  // 5 bits
     *              (timeDefinition.ordinal() &lt;&lt; 12) +  // 2 bits
     *              (stdOffsetByte &lt;&lt; 4) +              // 8 bits
     *              (beforeByte &lt;&lt; 2) +                 // 2 bits
     *              afterByte;                          // 2 bits
     *      out.writeInt(b);
     *      if (timeByte == 31) {
     *          out.writeInt(timeSecs);
     *      }
     *      if (stdOffsetByte == 255) {
     *          out.writeInt(stdOffset);
     *      }
     *      if (beforeByte == 3) {
     *          out.writeInt(offsetBefore.getTotalSeconds());
     *      }
     *      if (afterByte == 3) {
     *          out.writeInt(offsetAfter.getTotalSeconds());
     *      }
     * }
     * &lt;/pre&gt;
     *
     * @return the replacing object, not null
     */
    private Object writeReplace() {
<span class="nc" id="L289">        return new Ser(Ser.ZOTRULE, this);</span>
    }

    /**
     * Writes the state to the stream.
     *
     * @param out  the output stream, not null
     * @throws IOException if an error occurs
     */
    void writeExternal(DataOutput out) throws IOException {
<span class="nc bnc" id="L299" title="All 2 branches missed.">        final int timeSecs = (timeEndOfDay ? 86400 : time.toSecondOfDay());</span>
<span class="nc" id="L300">        final int stdOffset = standardOffset.getTotalSeconds();</span>
<span class="nc" id="L301">        final int beforeDiff = offsetBefore.getTotalSeconds() - stdOffset;</span>
<span class="nc" id="L302">        final int afterDiff = offsetAfter.getTotalSeconds() - stdOffset;</span>
<span class="nc bnc" id="L303" title="All 4 branches missed.">        final int timeByte = (timeSecs % 3600 == 0 ? (timeEndOfDay ? 24 : time.getHour()) : 31);</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">        final int stdOffsetByte = (stdOffset % 900 == 0 ? stdOffset / 900 + 128 : 255);</span>
<span class="nc bnc" id="L305" title="All 6 branches missed.">        final int beforeByte = (beforeDiff == 0 || beforeDiff == 1800 || beforeDiff == 3600 ? beforeDiff / 1800 : 3);</span>
<span class="nc bnc" id="L306" title="All 6 branches missed.">        final int afterByte = (afterDiff == 0 || afterDiff == 1800 || afterDiff == 3600 ? afterDiff / 1800 : 3);</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">        final int dowByte = (dow == null ? 0 : dow.getValue());</span>
<span class="nc" id="L308">        int b = (month.getValue() &lt;&lt; 28) +          // 4 bits</span>
                ((dom + 32) &lt;&lt; 22) +                // 6 bits
                (dowByte &lt;&lt; 19) +                   // 3 bits
                (timeByte &lt;&lt; 14) +                  // 5 bits
<span class="nc" id="L312">                (timeDefinition.ordinal() &lt;&lt; 12) +  // 2 bits</span>
                (stdOffsetByte &lt;&lt; 4) +              // 8 bits
                (beforeByte &lt;&lt; 2) +                 // 2 bits
                afterByte;                          // 2 bits
<span class="nc" id="L316">        out.writeInt(b);</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (timeByte == 31) {</span>
<span class="nc" id="L318">            out.writeInt(timeSecs);</span>
        }
<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (stdOffsetByte == 255) {</span>
<span class="nc" id="L321">            out.writeInt(stdOffset);</span>
        }
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (beforeByte == 3) {</span>
<span class="nc" id="L324">            out.writeInt(offsetBefore.getTotalSeconds());</span>
        }
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (afterByte == 3) {</span>
<span class="nc" id="L327">            out.writeInt(offsetAfter.getTotalSeconds());</span>
        }
<span class="nc" id="L329">    }</span>

    /**
     * Reads the state from the stream.
     *
     * @param in  the input stream, not null
     * @return the created object, not null
     * @throws IOException if an error occurs
     */
    static ZoneOffsetTransitionRule readExternal(DataInput in) throws IOException {
<span class="fc" id="L339">        int data = in.readInt();</span>
<span class="fc" id="L340">        Month month = Month.of(data &gt;&gt;&gt; 28);</span>
<span class="fc" id="L341">        int dom = ((data &amp; (63 &lt;&lt; 22)) &gt;&gt;&gt; 22) - 32;</span>
<span class="fc" id="L342">        int dowByte = (data &amp; (7 &lt;&lt; 19)) &gt;&gt;&gt; 19;</span>
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">        DayOfWeek dow = dowByte == 0 ? null : DayOfWeek.of(dowByte);</span>
<span class="fc" id="L344">        int timeByte = (data &amp; (31 &lt;&lt; 14)) &gt;&gt;&gt; 14;</span>
<span class="fc" id="L345">        TimeDefinition defn = TimeDefinition.values()[(data &amp; (3 &lt;&lt; 12)) &gt;&gt;&gt; 12];</span>
<span class="fc" id="L346">        int stdByte = (data &amp; (255 &lt;&lt; 4)) &gt;&gt;&gt; 4;</span>
<span class="fc" id="L347">        int beforeByte = (data &amp; (3 &lt;&lt; 2)) &gt;&gt;&gt; 2;</span>
<span class="fc" id="L348">        int afterByte = (data &amp; 3);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        LocalTime time = (timeByte == 31 ? LocalTime.ofSecondOfDay(in.readInt()) : LocalTime.of(timeByte % 24, 0));</span>
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">        ZoneOffset std = (stdByte == 255 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds((stdByte - 128) * 900));</span>
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">        ZoneOffset before = (beforeByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + beforeByte * 1800));</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">        ZoneOffset after = (afterByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + afterByte * 1800));</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">        return ZoneOffsetTransitionRule.of(month, dom, dow, time, timeByte == 24, defn, std, before, after);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the month of the transition.
     * &lt;p&gt;
     * If the rule defines an exact date then the month is the month of that date.
     * &lt;p&gt;
     * If the rule defines a week where the transition might occur, then the month
     * if the month of either the earliest or latest possible date of the cutover.
     *
     * @return the month of the transition, not null
     */
    public Month getMonth() {
<span class="nc" id="L368">        return month;</span>
    }

    /**
     * Gets the indicator of the day-of-month of the transition.
     * &lt;p&gt;
     * If the rule defines an exact date then the day is the month of that date.
     * &lt;p&gt;
     * If the rule defines a week where the transition might occur, then the day
     * defines either the start of the end of the transition week.
     * &lt;p&gt;
     * If the value is positive, then it represents a normal day-of-month, and is the
     * earliest possible date that the transition can be.
     * The date may refer to 29th February which should be treated as 1st March in non-leap years.
     * &lt;p&gt;
     * If the value is negative, then it represents the number of days back from the
     * end of the month where {@code -1} is the last day of the month.
     * In this case, the day identified is the latest possible date that the transition can be.
     *
     * @return the day-of-month indicator, from -28 to 31 excluding 0
     */
    public int getDayOfMonthIndicator() {
<span class="nc" id="L390">        return dom;</span>
    }

    /**
     * Gets the day-of-week of the transition.
     * &lt;p&gt;
     * If the rule defines an exact date then this returns null.
     * &lt;p&gt;
     * If the rule defines a week where the cutover might occur, then this method
     * returns the day-of-week that the month-day will be adjusted to.
     * If the day is positive then the adjustment is later.
     * If the day is negative then the adjustment is earlier.
     *
     * @return the day-of-week that the transition occurs, null if the rule defines an exact date
     */
    public DayOfWeek getDayOfWeek() {
<span class="nc" id="L406">        return dow;</span>
    }

    /**
     * Gets the local time of day of the transition which must be checked with
     * {@link #isMidnightEndOfDay()}.
     * &lt;p&gt;
     * The time is converted into an instant using the time definition.
     *
     * @return the local time of day of the transition, not null
     */
    public LocalTime getLocalTime() {
<span class="nc" id="L418">        return time;</span>
    }

    /**
     * Is the transition local time midnight at the end of day.
     * &lt;p&gt;
     * The transition may be represented as occurring at 24:00.
     *
     * @return whether a local time of midnight is at the start or end of the day
     */
    public boolean isMidnightEndOfDay() {
<span class="nc" id="L429">        return timeEndOfDay;</span>
    }

    /**
     * Gets the time definition, specifying how to convert the time to an instant.
     * &lt;p&gt;
     * The local time can be converted to an instant using the standard offset,
     * the wall offset or UTC.
     *
     * @return the time definition, not null
     */
    public TimeDefinition getTimeDefinition() {
<span class="nc" id="L441">        return timeDefinition;</span>
    }

    /**
     * Gets the standard offset in force at the transition.
     *
     * @return the standard offset, not null
     */
    public ZoneOffset getStandardOffset() {
<span class="nc" id="L450">        return standardOffset;</span>
    }

    /**
     * Gets the offset before the transition.
     *
     * @return the offset before, not null
     */
    public ZoneOffset getOffsetBefore() {
<span class="nc" id="L459">        return offsetBefore;</span>
    }

    /**
     * Gets the offset after the transition.
     *
     * @return the offset after, not null
     */
    public ZoneOffset getOffsetAfter() {
<span class="nc" id="L468">        return offsetAfter;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Creates a transition instance for the specified year.
     * &lt;p&gt;
     * Calculations are performed using the ISO-8601 chronology.
     *
     * @param year  the year to create a transition for, not null
     * @return the transition instance, not null
     */
    public ZoneOffsetTransition createTransition(int year) {
        LocalDate date;
<span class="nc bnc" id="L482" title="All 2 branches missed.">        if (dom &lt; 0) {</span>
<span class="nc" id="L483">            date = LocalDate.of(year, month, month.length(IsoChronology.INSTANCE.isLeapYear(year)) + 1 + dom);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">            if (dow != null) {</span>
<span class="nc" id="L485">                date = date.with(previousOrSame(dow));</span>
            }
        } else {
<span class="nc" id="L488">            date = LocalDate.of(year, month, dom);</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">            if (dow != null) {</span>
<span class="nc" id="L490">                date = date.with(nextOrSame(dow));</span>
            }
        }
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (timeEndOfDay) {</span>
<span class="nc" id="L494">            date = date.plusDays(1);</span>
        }
<span class="nc" id="L496">        LocalDateTime localDT = LocalDateTime.of(date, time);</span>
<span class="nc" id="L497">        LocalDateTime transition = timeDefinition.createDateTime(localDT, standardOffset, offsetBefore);</span>
<span class="nc" id="L498">        return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this object equals another.
     * &lt;p&gt;
     * The entire state of the object is compared.
     *
     * @param otherRule  the other object to compare to, null returns false
     * @return true if equal
     */
    @Override
    public boolean equals(Object otherRule) {
<span class="nc bnc" id="L512" title="All 2 branches missed.">        if (otherRule == this) {</span>
<span class="nc" id="L513">            return true;</span>
        }
<span class="nc bnc" id="L515" title="All 2 branches missed.">        if (otherRule instanceof ZoneOffsetTransitionRule) {</span>
<span class="nc" id="L516">            ZoneOffsetTransitionRule other = (ZoneOffsetTransitionRule) otherRule;</span>
<span class="nc bnc" id="L517" title="All 8 branches missed.">            return month == other.month &amp;&amp; dom == other.dom &amp;&amp; dow == other.dow &amp;&amp;</span>
                timeDefinition == other.timeDefinition &amp;&amp;
<span class="nc bnc" id="L519" title="All 4 branches missed.">                time.equals(other.time) &amp;&amp;</span>
                timeEndOfDay == other.timeEndOfDay &amp;&amp;
<span class="nc bnc" id="L521" title="All 2 branches missed.">                standardOffset.equals(other.standardOffset) &amp;&amp;</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">                offsetBefore.equals(other.offsetBefore) &amp;&amp;</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">                offsetAfter.equals(other.offsetAfter);</span>
        }
<span class="nc" id="L525">        return false;</span>
    }

    /**
     * Returns a suitable hash code.
     *
     * @return the hash code
     */
    @Override
    public int hashCode() {
<span class="nc bnc" id="L535" title="All 2 branches missed.">        int hash = ((time.toSecondOfDay() + (timeEndOfDay ? 1 : 0)) &lt;&lt; 15) +</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">                (month.ordinal() &lt;&lt; 11) + ((dom + 32) &lt;&lt; 5) +</span>
<span class="nc" id="L537">                ((dow == null ? 7 : dow.ordinal()) &lt;&lt; 2) + (timeDefinition.ordinal());</span>
<span class="nc" id="L538">        return hash ^ standardOffset.hashCode() ^</span>
<span class="nc" id="L539">                offsetBefore.hashCode() ^ offsetAfter.hashCode();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a string describing this object.
     *
     * @return a string for debugging, not null
     */
    @Override
    public String toString() {
<span class="nc" id="L550">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L551">        buf.append(&quot;TransitionRule[&quot;)</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            .append(offsetBefore.compareTo(offsetAfter) &gt; 0 ? &quot;Gap &quot; : &quot;Overlap &quot;)</span>
<span class="nc" id="L553">            .append(offsetBefore).append(&quot; to &quot;).append(offsetAfter).append(&quot;, &quot;);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (dow != null) {</span>
<span class="nc bnc" id="L555" title="All 2 branches missed.">            if (dom == -1) {</span>
<span class="nc" id="L556">                buf.append(dow.name()).append(&quot; on or before last day of &quot;).append(month.name());</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            } else if (dom &lt; 0) {</span>
<span class="nc" id="L558">                buf.append(dow.name()).append(&quot; on or before last day minus &quot;).append(-dom - 1).append(&quot; of &quot;).append(month.name());</span>
            } else {
<span class="nc" id="L560">                buf.append(dow.name()).append(&quot; on or after &quot;).append(month.name()).append(' ').append(dom);</span>
            }
        } else {
<span class="nc" id="L563">            buf.append(month.name()).append(' ').append(dom);</span>
        }
<span class="nc bnc" id="L565" title="All 2 branches missed.">        buf.append(&quot; at &quot;).append(timeEndOfDay ? &quot;24:00&quot; : time.toString())</span>
<span class="nc" id="L566">            .append(&quot; &quot;).append(timeDefinition)</span>
<span class="nc" id="L567">            .append(&quot;, standard offset &quot;).append(standardOffset)</span>
<span class="nc" id="L568">            .append(']');</span>
<span class="nc" id="L569">        return buf.toString();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * A definition of the way a local time can be converted to the actual
     * transition date-time.
     * &lt;p&gt;
     * Time zone rules are expressed in one of three ways:
     * &lt;ul&gt;
     * &lt;li&gt;Relative to UTC&lt;/li&gt;
     * &lt;li&gt;Relative to the standard offset in force&lt;/li&gt;
     * &lt;li&gt;Relative to the wall offset (what you would see on a clock on the wall)&lt;/li&gt;
     * &lt;/ul&gt;
     */
<span class="pc" id="L584">    public static enum TimeDefinition {</span>
        /** The local date-time is expressed in terms of the UTC offset. */
<span class="fc" id="L586">        UTC,</span>
        /** The local date-time is expressed in terms of the wall offset. */
<span class="fc" id="L588">        WALL,</span>
        /** The local date-time is expressed in terms of the standard offset. */
<span class="fc" id="L590">        STANDARD;</span>

        /**
         * Converts the specified local date-time to the local date-time actually
         * seen on a wall clock.
         * &lt;p&gt;
         * This method converts using the type of this enum.
         * The output is defined relative to the 'before' offset of the transition.
         * &lt;p&gt;
         * The UTC type uses the UTC offset.
         * The STANDARD type uses the standard offset.
         * The WALL type returns the input date-time.
         * The result is intended for use with the wall-offset.
         *
         * @param dateTime  the local date-time, not null
         * @param standardOffset  the standard offset, not null
         * @param wallOffset  the wall offset, not null
         * @return the date-time relative to the wall/before offset, not null
         */
        public LocalDateTime createDateTime(LocalDateTime dateTime, ZoneOffset standardOffset, ZoneOffset wallOffset) {
<span class="nc bnc" id="L610" title="All 3 branches missed.">            switch (this) {</span>
                case UTC: {
<span class="nc" id="L612">                    int difference = wallOffset.getTotalSeconds() - ZoneOffset.UTC.getTotalSeconds();</span>
<span class="nc" id="L613">                    return dateTime.plusSeconds(difference);</span>
                }
                case STANDARD: {
<span class="nc" id="L616">                    int difference = wallOffset.getTotalSeconds() - standardOffset.getTotalSeconds();</span>
<span class="nc" id="L617">                    return dateTime.plusSeconds(difference);</span>
                }
                default:  // WALL
<span class="nc" id="L620">                    return dateTime;</span>
            }
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>