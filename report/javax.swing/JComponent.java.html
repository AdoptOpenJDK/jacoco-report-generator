<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JComponent.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JComponent.java</span></div><h1>JComponent.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;


import java.util.HashSet;
import java.util.Hashtable;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Locale;
import java.util.Vector;
import java.util.EventListener;
import java.util.Set;
import java.util.Map;
import java.util.HashMap;

import java.awt.*;
import java.awt.event.*;
import java.awt.image.VolatileImage;
import java.awt.Graphics2D;
import java.awt.peer.LightweightPeer;
import java.awt.dnd.DropTarget;
import java.awt.font.FontRenderContext;
import java.beans.PropertyChangeListener;
import java.beans.VetoableChangeListener;
import java.beans.VetoableChangeSupport;
import java.beans.Transient;

import java.applet.Applet;

import java.io.Serializable;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import java.io.ObjectInputValidation;
import java.io.InvalidObjectException;

import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.plaf.*;
import static javax.swing.ClientPropertyKey.*;
import javax.accessibility.*;

import sun.swing.SwingUtilities2;
import sun.swing.UIClientPropertyKey;

/**
 * The base class for all Swing components except top-level containers.
 * To use a component that inherits from &lt;code&gt;JComponent&lt;/code&gt;,
 * you must place the component in a containment hierarchy
 * whose root is a top-level Swing container.
 * Top-level Swing containers --
 * such as &lt;code&gt;JFrame&lt;/code&gt;, &lt;code&gt;JDialog&lt;/code&gt;,
 * and &lt;code&gt;JApplet&lt;/code&gt; --
 * are specialized components
 * that provide a place for other Swing components to paint themselves.
 * For an explanation of containment hierarchies, see
 * &lt;a
 href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/toplevel.html&quot;&gt;Swing Components and the Containment Hierarchy&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
 *
 * &lt;p&gt;
 * The &lt;code&gt;JComponent&lt;/code&gt; class provides:
 * &lt;ul&gt;
 * &lt;li&gt;The base class for both standard and custom components
 *     that use the Swing architecture.
 * &lt;li&gt;A &quot;pluggable look and feel&quot; (L&amp;amp;F) that can be specified by the
 *     programmer or (optionally) selected by the user at runtime.
 *     The look and feel for each component is provided by a
 *     &lt;em&gt;UI delegate&lt;/em&gt; -- an object that descends from
 *     {@link javax.swing.plaf.ComponentUI}.
 *     See &lt;a
 * href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html&quot;&gt;How
 *     to Set the Look and Feel&lt;/a&gt;
 *     in &lt;em&gt;The Java Tutorial&lt;/em&gt;
 *     for more information.
 * &lt;li&gt;Comprehensive keystroke handling.
 *     See the document &lt;a
 * href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/keybinding.html&quot;&gt;How to Use Key Bindings&lt;/a&gt;,
 *     an article in &lt;em&gt;The Java Tutorial&lt;/em&gt;,
 *     for more information.
 * &lt;li&gt;Support for tool tips --
 *     short descriptions that pop up when the cursor lingers
 *     over a component.
 *     See &lt;a
 * href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tooltip.html&quot;&gt;How
 *     to Use Tool Tips&lt;/a&gt;
 *     in &lt;em&gt;The Java Tutorial&lt;/em&gt;
 *     for more information.
 * &lt;li&gt;Support for accessibility.
 *     &lt;code&gt;JComponent&lt;/code&gt; contains all of the methods in the
 *     &lt;code&gt;Accessible&lt;/code&gt; interface,
 *     but it doesn't actually implement the interface.  That is the
 *     responsibility of the individual classes
 *     that extend &lt;code&gt;JComponent&lt;/code&gt;.
 * &lt;li&gt;Support for component-specific properties.
 *     With the {@link #putClientProperty}
 *     and {@link #getClientProperty} methods,
 *     you can associate name-object pairs
 *     with any object that descends from &lt;code&gt;JComponent&lt;/code&gt;.
 * &lt;li&gt;An infrastructure for painting
 *     that includes double buffering and support for borders.
 *     For more information see &lt;a
 * href=&quot;http://www.oracle.com/technetwork/java/painting-140037.html#swing&quot;&gt;Painting&lt;/a&gt; and
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/border.htmll&quot;&gt;How
 *     to Use Borders&lt;/a&gt;,
 *     both of which are sections in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
 * &lt;/ul&gt;
 * For more information on these subjects, see the
 * &lt;a href=&quot;package-summary.html#package_description&quot;&gt;Swing package description&lt;/a&gt;
 * and &lt;em&gt;The Java Tutorial&lt;/em&gt; section
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/jcomponent.html&quot;&gt;The JComponent Class&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;code&gt;JComponent&lt;/code&gt; and its subclasses document default values
 * for certain properties.  For example, &lt;code&gt;JTable&lt;/code&gt; documents the
 * default row height as 16.  Each &lt;code&gt;JComponent&lt;/code&gt; subclass
 * that has a &lt;code&gt;ComponentUI&lt;/code&gt; will create the
 * &lt;code&gt;ComponentUI&lt;/code&gt; as part of its constructor.  In order
 * to provide a particular look and feel each
 * &lt;code&gt;ComponentUI&lt;/code&gt; may set properties back on the
 * &lt;code&gt;JComponent&lt;/code&gt; that created it.  For example, a custom
 * look and feel may require &lt;code&gt;JTable&lt;/code&gt;s to have a row
 * height of 24. The documented defaults are the value of a property
 * BEFORE the &lt;code&gt;ComponentUI&lt;/code&gt; has been installed.  If you
 * need a specific value for a particular property you should
 * explicitly set it.
 * &lt;p&gt;
 * In release 1.4, the focus subsystem was rearchitected.
 * For more information, see
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
 * How to Use the Focus Subsystem&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @see KeyStroke
 * @see Action
 * @see #setBorder
 * @see #registerKeyboardAction
 * @see JOptionPane
 * @see #setDebugGraphicsOptions
 * @see #setToolTipText
 * @see #setAutoscrolls
 *
 * @author Hans Muller
 * @author Arnaud Weber
 */
public abstract class JComponent extends Container implements Serializable,
                                              TransferHandler.HasGetTransferHandler
{
    /**
     * @see #getUIClassID
     * @see #writeObject
     */
    private static final String uiClassID = &quot;ComponentUI&quot;;

    /**
     * @see #readObject
     */
<span class="fc" id="L194">    private static final Hashtable&lt;ObjectInputStream, ReadObjectCallback&gt; readObjectCallbacks =</span>
            new Hashtable&lt;ObjectInputStream, ReadObjectCallback&gt;(1);

    /**
     * Keys to use for forward focus traversal when the JComponent is
     * managing focus.
     */
    private static Set&lt;KeyStroke&gt; managingFocusForwardTraversalKeys;

    /**
     * Keys to use for backward focus traversal when the JComponent is
     * managing focus.
     */
    private static Set&lt;KeyStroke&gt; managingFocusBackwardTraversalKeys;

    // Following are the possible return values from getObscuredState.
    private static final int NOT_OBSCURED = 0;
    private static final int PARTIALLY_OBSCURED = 1;
    private static final int COMPLETELY_OBSCURED = 2;

    /**
     * Set to true when DebugGraphics has been loaded.
     */
    static boolean DEBUG_GRAPHICS_LOADED;

    /**
     * Key used to look up a value from the AppContext to determine the
     * JComponent the InputVerifier is running for. That is, if
     * AppContext.get(INPUT_VERIFIER_SOURCE_KEY) returns non-null, it
     * indicates the EDT is calling into the InputVerifier from the
     * returned component.
     */
<span class="fc" id="L226">    private static final Object INPUT_VERIFIER_SOURCE_KEY =</span>
            new StringBuilder(&quot;InputVerifierSourceKey&quot;);

    /* The following fields support set methods for the corresponding
     * java.awt.Component properties.
     */
    private boolean isAlignmentXSet;
    private float alignmentX;
    private boolean isAlignmentYSet;
    private float alignmentY;

    /**
     * Backing store for JComponent properties and listeners
     */

    /** The look and feel delegate for this component. */
    protected transient ComponentUI ui;
    /** A list of event listeners for this component. */
<span class="nc" id="L244">    protected EventListenerList listenerList = new EventListenerList();</span>

    private transient ArrayTable clientProperties;
    private VetoableChangeSupport vetoableChangeSupport;
    /**
     * Whether or not autoscroll has been enabled.
     */
    private boolean autoscrolls;
    private Border border;
    private int flags;

    /* Input verifier for this component */
<span class="nc" id="L256">    private InputVerifier inputVerifier = null;</span>

<span class="nc" id="L258">    private boolean verifyInputWhenFocusTarget = true;</span>

    /**
     * Set in &lt;code&gt;_paintImmediately&lt;/code&gt;.
     * Will indicate the child that initiated the painting operation.
     * If &lt;code&gt;paintingChild&lt;/code&gt; is opaque, no need to paint
     * any child components after &lt;code&gt;paintingChild&lt;/code&gt;.
     * Test used in &lt;code&gt;paintChildren&lt;/code&gt;.
     */
    transient Component         paintingChild;

    /**
     * Constant used for &lt;code&gt;registerKeyboardAction&lt;/code&gt; that
     * means that the command should be invoked when
     * the component has the focus.
     */
    public static final int WHEN_FOCUSED = 0;

    /**
     * Constant used for &lt;code&gt;registerKeyboardAction&lt;/code&gt; that
     * means that the command should be invoked when the receiving
     * component is an ancestor of the focused component or is
     * itself the focused component.
     */
    public static final int WHEN_ANCESTOR_OF_FOCUSED_COMPONENT = 1;

    /**
     * Constant used for &lt;code&gt;registerKeyboardAction&lt;/code&gt; that
     * means that the command should be invoked when
     * the receiving component is in the window that has the focus
     * or is itself the focused component.
     */
    public static final int WHEN_IN_FOCUSED_WINDOW = 2;

    /**
     * Constant used by some of the APIs to mean that no condition is defined.
     */
    public static final int UNDEFINED_CONDITION = -1;

    /**
     * The key used by &lt;code&gt;JComponent&lt;/code&gt; to access keyboard bindings.
     */
    private static final String KEYBOARD_BINDINGS_KEY = &quot;_KeyboardBindings&quot;;

    /**
     * An array of &lt;code&gt;KeyStroke&lt;/code&gt;s used for
     * &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; are stashed
     * in the client properties under this string.
     */
    private static final String WHEN_IN_FOCUSED_WINDOW_BINDINGS = &quot;_WhenInFocusedWindow&quot;;

    /**
     * The comment to display when the cursor is over the component,
     * also known as a &quot;value tip&quot;, &quot;flyover help&quot;, or &quot;flyover label&quot;.
     */
    public static final String TOOL_TIP_TEXT_KEY = &quot;ToolTipText&quot;;

    private static final String NEXT_FOCUS = &quot;nextFocus&quot;;

    /**
     * &lt;code&gt;JPopupMenu&lt;/code&gt; assigned to this component
     * and all of its children
     */
    private JPopupMenu popupMenu;

    /** Private flags **/
    private static final int IS_DOUBLE_BUFFERED                       =  0;
    private static final int ANCESTOR_USING_BUFFER                    =  1;
    private static final int IS_PAINTING_TILE                         =  2;
    private static final int IS_OPAQUE                                =  3;
    private static final int KEY_EVENTS_ENABLED                       =  4;
    private static final int FOCUS_INPUTMAP_CREATED                   =  5;
    private static final int ANCESTOR_INPUTMAP_CREATED                =  6;
    private static final int WIF_INPUTMAP_CREATED                     =  7;
    private static final int ACTIONMAP_CREATED                        =  8;
    private static final int CREATED_DOUBLE_BUFFER                    =  9;
    // bit 10 is free
    private static final int IS_PRINTING                              = 11;
    private static final int IS_PRINTING_ALL                          = 12;
    private static final int IS_REPAINTING                            = 13;
    /** Bits 14-21 are used to handle nested writeObject calls. **/
    private static final int WRITE_OBJ_COUNTER_FIRST                  = 14;
    private static final int RESERVED_1                               = 15;
    private static final int RESERVED_2                               = 16;
    private static final int RESERVED_3                               = 17;
    private static final int RESERVED_4                               = 18;
    private static final int RESERVED_5                               = 19;
    private static final int RESERVED_6                               = 20;
    private static final int WRITE_OBJ_COUNTER_LAST                   = 21;

    private static final int REQUEST_FOCUS_DISABLED                   = 22;
    private static final int INHERITS_POPUP_MENU                      = 23;
    private static final int OPAQUE_SET                               = 24;
    private static final int AUTOSCROLLS_SET                          = 25;
    private static final int FOCUS_TRAVERSAL_KEYS_FORWARD_SET         = 26;
    private static final int FOCUS_TRAVERSAL_KEYS_BACKWARD_SET        = 27;
    private static final int REVALIDATE_RUNNABLE_SCHEDULED            = 28;

    /**
     * Temporary rectangles.
     */
<span class="fc" id="L359">    private static java.util.List&lt;Rectangle&gt; tempRectangles = new java.util.ArrayList&lt;Rectangle&gt;(11);</span>

    /** Used for &lt;code&gt;WHEN_FOCUSED&lt;/code&gt; bindings. */
    private InputMap focusInputMap;
    /** Used for &lt;code&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&lt;/code&gt; bindings. */
    private InputMap ancestorInputMap;
    /** Used for &lt;code&gt;WHEN_IN_FOCUSED_KEY&lt;/code&gt; bindings. */
    private ComponentInputMap windowInputMap;

    /** ActionMap. */
    private ActionMap actionMap;

    /** Key used to store the default locale in an AppContext **/
    private static final String defaultLocale = &quot;JComponent.defaultLocale&quot;;

    private static Component componentObtainingGraphicsFrom;
<span class="fc" id="L375">    private static Object componentObtainingGraphicsFromLock = new</span>
            StringBuilder(&quot;componentObtainingGraphicsFrom&quot;);

    /**
     * AA text hints.
     */
    transient private Object aaTextInfo;

    static Graphics safelyGetGraphics(Component c) {
<span class="nc" id="L384">        return safelyGetGraphics(c, SwingUtilities.getRoot(c));</span>
    }

    static Graphics safelyGetGraphics(Component c, Component root) {
<span class="nc" id="L388">        synchronized(componentObtainingGraphicsFromLock) {</span>
<span class="nc" id="L389">            componentObtainingGraphicsFrom = root;</span>
<span class="nc" id="L390">            Graphics g = c.getGraphics();</span>
<span class="nc" id="L391">            componentObtainingGraphicsFrom = null;</span>
<span class="nc" id="L392">            return g;</span>
<span class="nc" id="L393">        }</span>
    }

    static void getGraphicsInvoked(Component root) {
<span class="nc bnc" id="L397" title="All 2 branches missed.">        if (!JComponent.isComponentObtainingGraphicsFrom(root)) {</span>
<span class="nc" id="L398">            JRootPane rootPane = ((RootPaneContainer)root).getRootPane();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">            if (rootPane != null) {</span>
<span class="nc" id="L400">                rootPane.disableTrueDoubleBuffering();</span>
            }
        }
<span class="nc" id="L403">    }</span>


    /**
     * Returns true if {@code c} is the component the graphics is being
     * requested of. This is intended for use when getGraphics is invoked.
     */
    private static boolean isComponentObtainingGraphicsFrom(Component c) {
<span class="nc" id="L411">        synchronized(componentObtainingGraphicsFromLock) {</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">            return (componentObtainingGraphicsFrom == c);</span>
<span class="nc" id="L413">        }</span>
    }

    /**
     * Returns the Set of &lt;code&gt;KeyStroke&lt;/code&gt;s to use if the component
     * is managing focus for forward focus traversal.
     */
    static Set&lt;KeyStroke&gt; getManagingFocusForwardTraversalKeys() {
<span class="nc" id="L421">        synchronized(JComponent.class) {</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (managingFocusForwardTraversalKeys == null) {</span>
<span class="nc" id="L423">                managingFocusForwardTraversalKeys = new HashSet&lt;KeyStroke&gt;(1);</span>
<span class="nc" id="L424">                managingFocusForwardTraversalKeys.add(</span>
<span class="nc" id="L425">                    KeyStroke.getKeyStroke(KeyEvent.VK_TAB,</span>
                                           InputEvent.CTRL_MASK));
            }
<span class="nc" id="L428">        }</span>
<span class="nc" id="L429">        return managingFocusForwardTraversalKeys;</span>
    }

    /**
     * Returns the Set of &lt;code&gt;KeyStroke&lt;/code&gt;s to use if the component
     * is managing focus for backward focus traversal.
     */
    static Set&lt;KeyStroke&gt; getManagingFocusBackwardTraversalKeys() {
<span class="nc" id="L437">        synchronized(JComponent.class) {</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">            if (managingFocusBackwardTraversalKeys == null) {</span>
<span class="nc" id="L439">                managingFocusBackwardTraversalKeys = new HashSet&lt;KeyStroke&gt;(1);</span>
<span class="nc" id="L440">                managingFocusBackwardTraversalKeys.add(</span>
<span class="nc" id="L441">                    KeyStroke.getKeyStroke(KeyEvent.VK_TAB,</span>
                                           InputEvent.SHIFT_MASK |
                                           InputEvent.CTRL_MASK));
            }
<span class="nc" id="L445">        }</span>
<span class="nc" id="L446">        return managingFocusBackwardTraversalKeys;</span>
    }

    private static Rectangle fetchRectangle() {
<span class="nc" id="L450">        synchronized(tempRectangles) {</span>
            Rectangle rect;
<span class="nc" id="L452">            int size = tempRectangles.size();</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">            if (size &gt; 0) {</span>
<span class="nc" id="L454">                rect = tempRectangles.remove(size - 1);</span>
            }
            else {
<span class="nc" id="L457">                rect = new Rectangle(0, 0, 0, 0);</span>
            }
<span class="nc" id="L459">            return rect;</span>
<span class="nc" id="L460">        }</span>
    }

    private static void recycleRectangle(Rectangle rect) {
<span class="nc" id="L464">        synchronized(tempRectangles) {</span>
<span class="nc" id="L465">            tempRectangles.add(rect);</span>
<span class="nc" id="L466">        }</span>
<span class="nc" id="L467">    }</span>

    /**
     * Sets whether or not &lt;code&gt;getComponentPopupMenu&lt;/code&gt; should delegate
     * to the parent if this component does not have a &lt;code&gt;JPopupMenu&lt;/code&gt;
     * assigned to it.
     * &lt;p&gt;
     * The default value for this is false, but some &lt;code&gt;JComponent&lt;/code&gt;
     * subclasses that are implemented as a number of &lt;code&gt;JComponent&lt;/code&gt;s
     * may set this to true.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param value whether or not the JPopupMenu is inherited
     * @see #setComponentPopupMenu
     * @beaninfo
     *        bound: true
     *  description: Whether or not the JPopupMenu is inherited
     * @since 1.5
     */
    public void setInheritsPopupMenu(boolean value) {
<span class="nc" id="L488">        boolean oldValue = getFlag(INHERITS_POPUP_MENU);</span>
<span class="nc" id="L489">        setFlag(INHERITS_POPUP_MENU, value);</span>
<span class="nc" id="L490">        firePropertyChange(&quot;inheritsPopupMenu&quot;, oldValue, value);</span>
<span class="nc" id="L491">    }</span>

    /**
     * Returns true if the JPopupMenu should be inherited from the parent.
     *
     * @see #setComponentPopupMenu
     * @since 1.5
     */
    public boolean getInheritsPopupMenu() {
<span class="nc" id="L500">        return getFlag(INHERITS_POPUP_MENU);</span>
    }

    /**
     * Sets the &lt;code&gt;JPopupMenu&lt;/code&gt; for this &lt;code&gt;JComponent&lt;/code&gt;.
     * The UI is responsible for registering bindings and adding the necessary
     * listeners such that the &lt;code&gt;JPopupMenu&lt;/code&gt; will be shown at
     * the appropriate time. When the &lt;code&gt;JPopupMenu&lt;/code&gt; is shown
     * depends upon the look and feel: some may show it on a mouse event,
     * some may enable a key binding.
     * &lt;p&gt;
     * If &lt;code&gt;popup&lt;/code&gt; is null, and &lt;code&gt;getInheritsPopupMenu&lt;/code&gt;
     * returns true, then &lt;code&gt;getComponentPopupMenu&lt;/code&gt; will be delegated
     * to the parent. This provides for a way to make all child components
     * inherit the popupmenu of the parent.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param popup - the popup that will be assigned to this component
     *                may be null
     * @see #getComponentPopupMenu
     * @beaninfo
     *        bound: true
     *    preferred: true
     *  description: Popup to show
     * @since 1.5
     */
    public void setComponentPopupMenu(JPopupMenu popup) {
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if(popup != null) {</span>
<span class="nc" id="L529">            enableEvents(AWTEvent.MOUSE_EVENT_MASK);</span>
        }
<span class="nc" id="L531">        JPopupMenu oldPopup = this.popupMenu;</span>
<span class="nc" id="L532">        this.popupMenu = popup;</span>
<span class="nc" id="L533">        firePropertyChange(&quot;componentPopupMenu&quot;, oldPopup, popup);</span>
<span class="nc" id="L534">    }</span>

    /**
     * Returns &lt;code&gt;JPopupMenu&lt;/code&gt; that assigned for this component.
     * If this component does not have a &lt;code&gt;JPopupMenu&lt;/code&gt; assigned
     * to it and &lt;code&gt;getInheritsPopupMenu&lt;/code&gt; is true, this
     * will return &lt;code&gt;getParent().getComponentPopupMenu()&lt;/code&gt; (assuming
     * the parent is valid.)
     *
     * @return &lt;code&gt;JPopupMenu&lt;/code&gt; assigned for this component
     *         or &lt;code&gt;null&lt;/code&gt; if no popup assigned
     * @see #setComponentPopupMenu
     * @since 1.5
     */
    public JPopupMenu getComponentPopupMenu() {

<span class="nc bnc" id="L550" title="All 2 branches missed.">        if(!getInheritsPopupMenu()) {</span>
<span class="nc" id="L551">            return popupMenu;</span>
        }

<span class="nc bnc" id="L554" title="All 2 branches missed.">        if(popupMenu == null) {</span>
            // Search parents for its popup
<span class="nc" id="L556">            Container parent = getParent();</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">            while (parent != null) {</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">                if(parent instanceof JComponent) {</span>
<span class="nc" id="L559">                    return ((JComponent)parent).getComponentPopupMenu();</span>
                }
<span class="nc bnc" id="L561" title="All 4 branches missed.">                if(parent instanceof Window ||</span>
                   parent instanceof Applet) {
                    // Reached toplevel, break and return null
<span class="nc" id="L564">                    break;</span>
                }
<span class="nc" id="L566">                parent = parent.getParent();</span>
            }
<span class="nc" id="L568">            return null;</span>
        }

<span class="nc" id="L571">        return popupMenu;</span>
    }

    /**
     * Default &lt;code&gt;JComponent&lt;/code&gt; constructor.  This constructor does
     * very little initialization beyond calling the &lt;code&gt;Container&lt;/code&gt;
     * constructor.  For example, the initial layout manager is
     * &lt;code&gt;null&lt;/code&gt;. It does, however, set the component's locale
     * property to the value returned by
     * &lt;code&gt;JComponent.getDefaultLocale&lt;/code&gt;.
     *
     * @see #getDefaultLocale
     */
    public JComponent() {
<span class="nc" id="L585">        super();</span>
        // We enable key events on all JComponents so that accessibility
        // bindings will work everywhere. This is a partial fix to BugID
        // 4282211.
<span class="nc" id="L589">        enableEvents(AWTEvent.KEY_EVENT_MASK);</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if (isManagingFocus()) {</span>
<span class="nc" id="L591">            LookAndFeel.installProperty(this,</span>
                                        &quot;focusTraversalKeysForward&quot;,
<span class="nc" id="L593">                                  getManagingFocusForwardTraversalKeys());</span>
<span class="nc" id="L594">            LookAndFeel.installProperty(this,</span>
                                        &quot;focusTraversalKeysBackward&quot;,
<span class="nc" id="L596">                                  getManagingFocusBackwardTraversalKeys());</span>
        }

<span class="nc" id="L599">        super.setLocale( JComponent.getDefaultLocale() );</span>
<span class="nc" id="L600">    }</span>


    /**
     * Resets the UI property to a value from the current look and feel.
     * &lt;code&gt;JComponent&lt;/code&gt; subclasses must override this method
     * like this:
     * &lt;pre&gt;
     *   public void updateUI() {
     *      setUI((SliderUI)UIManager.getUI(this);
     *   }
     *  &lt;/pre&gt;
     *
     * @see #setUI
     * @see UIManager#getLookAndFeel
     * @see UIManager#getUI
     */
<span class="nc" id="L617">    public void updateUI() {}</span>


    /**
     * Sets the look and feel delegate for this component.
     * &lt;code&gt;JComponent&lt;/code&gt; subclasses generally override this method
     * to narrow the argument type. For example, in &lt;code&gt;JSlider&lt;/code&gt;:
     * &lt;pre&gt;
     * public void setUI(SliderUI newUI) {
     *     super.setUI(newUI);
     * }
     *  &lt;/pre&gt;
     * &lt;p&gt;
     * Additionally &lt;code&gt;JComponent&lt;/code&gt; subclasses must provide a
     * &lt;code&gt;getUI&lt;/code&gt; method that returns the correct type.  For example:
     * &lt;pre&gt;
     * public SliderUI getUI() {
     *     return (SliderUI)ui;
     * }
     * &lt;/pre&gt;
     *
     * @param newUI the new UI delegate
     * @see #updateUI
     * @see UIManager#getLookAndFeel
     * @see UIManager#getUI
     * @beaninfo
     *        bound: true
     *       hidden: true
     *    attribute: visualUpdate true
     *  description: The component's look and feel delegate.
     */
    protected void setUI(ComponentUI newUI) {
        /* We do not check that the UI instance is different
         * before allowing the switch in order to enable the
         * same UI instance *with different default settings*
         * to be installed.
         */

<span class="nc" id="L655">        uninstallUIAndProperties();</span>

        // aaText shouldn't persist between look and feels, reset it.
<span class="nc" id="L658">        aaTextInfo =</span>
<span class="nc" id="L659">            UIManager.getDefaults().get(SwingUtilities2.AA_TEXT_PROPERTY_KEY);</span>
<span class="nc" id="L660">        ComponentUI oldUI = ui;</span>
<span class="nc" id="L661">        ui = newUI;</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (ui != null) {</span>
<span class="nc" id="L663">            ui.installUI(this);</span>
        }

<span class="nc" id="L666">        firePropertyChange(&quot;UI&quot;, oldUI, newUI);</span>
<span class="nc" id="L667">        revalidate();</span>
<span class="nc" id="L668">        repaint();</span>
<span class="nc" id="L669">    }</span>

    /**
     * Uninstalls the UI, if any, and any client properties designated
     * as being specific to the installed UI - instances of
     * {@code UIClientPropertyKey}.
     */
    private void uninstallUIAndProperties() {
<span class="nc bnc" id="L677" title="All 2 branches missed.">        if (ui != null) {</span>
<span class="nc" id="L678">            ui.uninstallUI(this);</span>
            //clean UIClientPropertyKeys from client properties
<span class="nc bnc" id="L680" title="All 2 branches missed.">            if (clientProperties != null) {</span>
<span class="nc" id="L681">                synchronized(clientProperties) {</span>
<span class="nc" id="L682">                    Object[] clientPropertyKeys =</span>
<span class="nc" id="L683">                        clientProperties.getKeys(null);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                    if (clientPropertyKeys != null) {</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">                        for (Object key : clientPropertyKeys) {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">                            if (key instanceof UIClientPropertyKey) {</span>
<span class="nc" id="L687">                                putClientProperty(key, null);</span>
                            }
                        }
                    }
<span class="nc" id="L691">                }</span>
            }
        }
<span class="nc" id="L694">    }</span>

    /**
     * Returns the &lt;code&gt;UIDefaults&lt;/code&gt; key used to
     * look up the name of the &lt;code&gt;swing.plaf.ComponentUI&lt;/code&gt;
     * class that defines the look and feel
     * for this component.  Most applications will never need to
     * call this method.  Subclasses of &lt;code&gt;JComponent&lt;/code&gt; that support
     * pluggable look and feel should override this method to
     * return a &lt;code&gt;UIDefaults&lt;/code&gt; key that maps to the
     * &lt;code&gt;ComponentUI&lt;/code&gt; subclass that defines their look and feel.
     *
     * @return the &lt;code&gt;UIDefaults&lt;/code&gt; key for a
     *          &lt;code&gt;ComponentUI&lt;/code&gt; subclass
     * @see UIDefaults#getUI
     * @beaninfo
     *      expert: true
     * description: UIClassID
     */
    public String getUIClassID() {
<span class="nc" id="L714">        return uiClassID;</span>
    }


    /**
     * Returns the graphics object used to paint this component.
     * If &lt;code&gt;DebugGraphics&lt;/code&gt; is turned on we create a new
     * &lt;code&gt;DebugGraphics&lt;/code&gt; object if necessary.
     * Otherwise we just configure the
     * specified graphics object's foreground and font.
     *
     * @param g the original &lt;code&gt;Graphics&lt;/code&gt; object
     * @return a &lt;code&gt;Graphics&lt;/code&gt; object configured for this component
     */
    protected Graphics getComponentGraphics(Graphics g) {
<span class="nc" id="L729">        Graphics componentGraphics = g;</span>
<span class="nc bnc" id="L730" title="All 4 branches missed.">        if (ui != null &amp;&amp; DEBUG_GRAPHICS_LOADED) {</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">            if ((DebugGraphics.debugComponentCount() != 0) &amp;&amp;</span>
<span class="nc bnc" id="L732" title="All 4 branches missed.">                    (shouldDebugGraphics() != 0) &amp;&amp;</span>
                    !(g instanceof DebugGraphics)) {
<span class="nc" id="L734">                componentGraphics = new DebugGraphics(g,this);</span>
            }
        }
<span class="nc" id="L737">        componentGraphics.setColor(getForeground());</span>
<span class="nc" id="L738">        componentGraphics.setFont(getFont());</span>

<span class="nc" id="L740">        return componentGraphics;</span>
    }


    /**
     * Calls the UI delegate's paint method, if the UI delegate
     * is non-&lt;code&gt;null&lt;/code&gt;.  We pass the delegate a copy of the
     * &lt;code&gt;Graphics&lt;/code&gt; object to protect the rest of the
     * paint code from irrevocable changes
     * (for example, &lt;code&gt;Graphics.translate&lt;/code&gt;).
     * &lt;p&gt;
     * If you override this in a subclass you should not make permanent
     * changes to the passed in &lt;code&gt;Graphics&lt;/code&gt;. For example, you
     * should not alter the clip &lt;code&gt;Rectangle&lt;/code&gt; or modify the
     * transform. If you need to do these operations you may find it
     * easier to create a new &lt;code&gt;Graphics&lt;/code&gt; from the passed in
     * &lt;code&gt;Graphics&lt;/code&gt; and manipulate it. Further, if you do not
     * invoker super's implementation you must honor the opaque property,
     * that is
     * if this component is opaque, you must completely fill in the background
     * in a non-opaque color. If you do not honor the opaque property you
     * will likely see visual artifacts.
     * &lt;p&gt;
     * The passed in &lt;code&gt;Graphics&lt;/code&gt; object might
     * have a transform other than the identify transform
     * installed on it.  In this case, you might get
     * unexpected results if you cumulatively apply
     * another transform.
     *
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; object to protect
     * @see #paint
     * @see ComponentUI
     */
    protected void paintComponent(Graphics g) {
<span class="nc bnc" id="L774" title="All 2 branches missed.">        if (ui != null) {</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">            Graphics scratchGraphics = (g == null) ? null : g.create();</span>
            try {
<span class="nc" id="L777">                ui.update(scratchGraphics, this);</span>
            }
            finally {
<span class="nc" id="L780">                scratchGraphics.dispose();</span>
<span class="nc" id="L781">            }</span>
        }
<span class="nc" id="L783">    }</span>

    /**
     * Paints this component's children.
     * If &lt;code&gt;shouldUseBuffer&lt;/code&gt; is true,
     * no component ancestor has a buffer and
     * the component children can use a buffer if they have one.
     * Otherwise, one ancestor has a buffer currently in use and children
     * should not use a buffer to paint.
     * @param g  the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
     * @see #paint
     * @see java.awt.Container#paint
     */
    protected void paintChildren(Graphics g) {
<span class="nc" id="L797">        Graphics sg = g;</span>

<span class="nc" id="L799">        synchronized(getTreeLock()) {</span>
<span class="nc" id="L800">            int i = getComponentCount() - 1;</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">            if (i &lt; 0) {</span>
<span class="nc" id="L802">                return;</span>
            }
            // If we are only to paint to a specific child, determine
            // its index.
<span class="nc bnc" id="L806" title="All 4 branches missed.">            if (paintingChild != null &amp;&amp;</span>
                (paintingChild instanceof JComponent) &amp;&amp;
<span class="nc bnc" id="L808" title="All 2 branches missed.">                paintingChild.isOpaque()) {</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">                for (; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                    if (getComponent(i) == paintingChild){</span>
<span class="nc" id="L811">                        break;</span>
                    }
                }
            }
<span class="nc" id="L815">            Rectangle tmpRect = fetchRectangle();</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">            boolean checkSiblings = (!isOptimizedDrawingEnabled() &amp;&amp;</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">                                     checkIfChildObscuredBySibling());</span>
<span class="nc" id="L818">            Rectangle clipBounds = null;</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">            if (checkSiblings) {</span>
<span class="nc" id="L820">                clipBounds = sg.getClipBounds();</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">                if (clipBounds == null) {</span>
<span class="nc" id="L822">                    clipBounds = new Rectangle(0, 0, getWidth(),</span>
<span class="nc" id="L823">                                               getHeight());</span>
                }
            }
<span class="nc" id="L826">            boolean printing = getFlag(IS_PRINTING);</span>
<span class="nc" id="L827">            final Window window = SwingUtilities.getWindowAncestor(this);</span>
<span class="nc bnc" id="L828" title="All 4 branches missed.">            final boolean isWindowOpaque = window == null || window.isOpaque();</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">            for (; i &gt;= 0 ; i--) {</span>
<span class="nc" id="L830">                Component comp = getComponent(i);</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">                if (comp == null) {</span>
<span class="nc" id="L832">                    continue;</span>
                }

<span class="nc" id="L835">                final boolean isJComponent = comp instanceof JComponent;</span>

                // Enable painting of heavyweights in non-opaque windows.
                // See 6884960
<span class="nc bnc" id="L839" title="All 4 branches missed.">                if ((!isWindowOpaque || isJComponent ||</span>
<span class="nc bnc" id="L840" title="All 4 branches missed.">                            isLightweightComponent(comp)) &amp;&amp; comp.isVisible())</span>
                {
                    Rectangle cr;

<span class="nc" id="L844">                    cr = comp.getBounds(tmpRect);</span>

<span class="nc" id="L846">                    boolean hitClip = g.hitClip(cr.x, cr.y, cr.width,</span>
                                                cr.height);

<span class="nc bnc" id="L849" title="All 2 branches missed.">                    if (hitClip) {</span>
<span class="nc bnc" id="L850" title="All 4 branches missed.">                        if (checkSiblings &amp;&amp; i &gt; 0) {</span>
<span class="nc" id="L851">                            int x = cr.x;</span>
<span class="nc" id="L852">                            int y = cr.y;</span>
<span class="nc" id="L853">                            int width = cr.width;</span>
<span class="nc" id="L854">                            int height = cr.height;</span>
<span class="nc" id="L855">                            SwingUtilities.computeIntersection</span>
<span class="nc" id="L856">                                (clipBounds.x, clipBounds.y,</span>
                                 clipBounds.width, clipBounds.height, cr);

<span class="nc bnc" id="L859" title="All 2 branches missed.">                            if(getObscuredState(i, cr.x, cr.y, cr.width,</span>
                                          cr.height) == COMPLETELY_OBSCURED) {
<span class="nc" id="L861">                                continue;</span>
                            }
<span class="nc" id="L863">                            cr.x = x;</span>
<span class="nc" id="L864">                            cr.y = y;</span>
<span class="nc" id="L865">                            cr.width = width;</span>
<span class="nc" id="L866">                            cr.height = height;</span>
                        }
<span class="nc" id="L868">                        Graphics cg = sg.create(cr.x, cr.y, cr.width,</span>
                                                cr.height);
<span class="nc" id="L870">                        cg.setColor(comp.getForeground());</span>
<span class="nc" id="L871">                        cg.setFont(comp.getFont());</span>
<span class="nc" id="L872">                        boolean shouldSetFlagBack = false;</span>
                        try {
<span class="nc bnc" id="L874" title="All 2 branches missed.">                            if(isJComponent) {</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                                if(getFlag(ANCESTOR_USING_BUFFER)) {</span>
<span class="nc" id="L876">                                    ((JComponent)comp).setFlag(</span>
                                                 ANCESTOR_USING_BUFFER,true);
<span class="nc" id="L878">                                    shouldSetFlagBack = true;</span>
                                }
<span class="nc bnc" id="L880" title="All 2 branches missed.">                                if(getFlag(IS_PAINTING_TILE)) {</span>
<span class="nc" id="L881">                                    ((JComponent)comp).setFlag(</span>
                                                 IS_PAINTING_TILE,true);
<span class="nc" id="L883">                                    shouldSetFlagBack = true;</span>
                                }
<span class="nc bnc" id="L885" title="All 2 branches missed.">                                if(!printing) {</span>
<span class="nc" id="L886">                                    comp.paint(cg);</span>
                                }
                                else {
<span class="nc bnc" id="L889" title="All 2 branches missed.">                                    if (!getFlag(IS_PRINTING_ALL)) {</span>
<span class="nc" id="L890">                                        comp.print(cg);</span>
                                    }
                                    else {
<span class="nc" id="L893">                                        comp.printAll(cg);</span>
                                    }
                                }
                            } else {
                                // The component is either lightweight, or
                                // heavyweight in a non-opaque window
<span class="nc bnc" id="L899" title="All 2 branches missed.">                                if (!printing) {</span>
<span class="nc" id="L900">                                    comp.paint(cg);</span>
                                }
                                else {
<span class="nc bnc" id="L903" title="All 2 branches missed.">                                    if (!getFlag(IS_PRINTING_ALL)) {</span>
<span class="nc" id="L904">                                        comp.print(cg);</span>
                                    }
                                    else {
<span class="nc" id="L907">                                        comp.printAll(cg);</span>
                                    }
                                }
                            }
                        } finally {
<span class="nc" id="L912">                            cg.dispose();</span>
<span class="nc bnc" id="L913" title="All 4 branches missed.">                            if(shouldSetFlagBack) {</span>
<span class="nc" id="L914">                                ((JComponent)comp).setFlag(</span>
                                             ANCESTOR_USING_BUFFER,false);
<span class="nc" id="L916">                                ((JComponent)comp).setFlag(</span>
                                             IS_PAINTING_TILE,false);
                            }
                        }
                    }
                }

            }
<span class="nc" id="L924">            recycleRectangle(tmpRect);</span>
<span class="nc" id="L925">        }</span>
<span class="nc" id="L926">    }</span>

    /**
     * Paints the component's border.
     * &lt;p&gt;
     * If you override this in a subclass you should not make permanent
     * changes to the passed in &lt;code&gt;Graphics&lt;/code&gt;. For example, you
     * should not alter the clip &lt;code&gt;Rectangle&lt;/code&gt; or modify the
     * transform. If you need to do these operations you may find it
     * easier to create a new &lt;code&gt;Graphics&lt;/code&gt; from the passed in
     * &lt;code&gt;Graphics&lt;/code&gt; and manipulate it.
     *
     * @param g  the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
     *
     * @see #paint
     * @see #setBorder
     */
    protected void paintBorder(Graphics g) {
<span class="nc" id="L944">        Border border = getBorder();</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">        if (border != null) {</span>
<span class="nc" id="L946">            border.paintBorder(this, g, 0, 0, getWidth(), getHeight());</span>
        }
<span class="nc" id="L948">    }</span>


    /**
     * Calls &lt;code&gt;paint&lt;/code&gt;.  Doesn't clear the background but see
     * &lt;code&gt;ComponentUI.update&lt;/code&gt;, which is called by
     * &lt;code&gt;paintComponent&lt;/code&gt;.
     *
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
     * @see #paint
     * @see #paintComponent
     * @see javax.swing.plaf.ComponentUI
     */
    public void update(Graphics g) {
<span class="nc" id="L962">        paint(g);</span>
<span class="nc" id="L963">    }</span>


    /**
     * Invoked by Swing to draw components.
     * Applications should not invoke &lt;code&gt;paint&lt;/code&gt; directly,
     * but should instead use the &lt;code&gt;repaint&lt;/code&gt; method to
     * schedule the component for redrawing.
     * &lt;p&gt;
     * This method actually delegates the work of painting to three
     * protected methods: &lt;code&gt;paintComponent&lt;/code&gt;,
     * &lt;code&gt;paintBorder&lt;/code&gt;,
     * and &lt;code&gt;paintChildren&lt;/code&gt;.  They're called in the order
     * listed to ensure that children appear on top of component itself.
     * Generally speaking, the component and its children should not
     * paint in the insets area allocated to the border. Subclasses can
     * just override this method, as always.  A subclass that just
     * wants to specialize the UI (look and feel) delegate's
     * &lt;code&gt;paint&lt;/code&gt; method should just override
     * &lt;code&gt;paintComponent&lt;/code&gt;.
     *
     * @param g  the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
     * @see #paintComponent
     * @see #paintBorder
     * @see #paintChildren
     * @see #getComponentGraphics
     * @see #repaint
     */
    public void paint(Graphics g) {
<span class="nc" id="L992">        boolean shouldClearPaintFlags = false;</span>

<span class="nc bnc" id="L994" title="All 4 branches missed.">        if ((getWidth() &lt;= 0) || (getHeight() &lt;= 0)) {</span>
<span class="nc" id="L995">            return;</span>
        }

<span class="nc" id="L998">        Graphics componentGraphics = getComponentGraphics(g);</span>
<span class="nc" id="L999">        Graphics co = componentGraphics.create();</span>
        try {
<span class="nc" id="L1001">            RepaintManager repaintManager = RepaintManager.currentManager(this);</span>
<span class="nc" id="L1002">            Rectangle clipRect = co.getClipBounds();</span>
            int clipX;
            int clipY;
            int clipW;
            int clipH;
<span class="nc bnc" id="L1007" title="All 2 branches missed.">            if (clipRect == null) {</span>
<span class="nc" id="L1008">                clipX = clipY = 0;</span>
<span class="nc" id="L1009">                clipW = getWidth();</span>
<span class="nc" id="L1010">                clipH = getHeight();</span>
            }
            else {
<span class="nc" id="L1013">                clipX = clipRect.x;</span>
<span class="nc" id="L1014">                clipY = clipRect.y;</span>
<span class="nc" id="L1015">                clipW = clipRect.width;</span>
<span class="nc" id="L1016">                clipH = clipRect.height;</span>
            }

<span class="nc bnc" id="L1019" title="All 2 branches missed.">            if(clipW &gt; getWidth()) {</span>
<span class="nc" id="L1020">                clipW = getWidth();</span>
            }
<span class="nc bnc" id="L1022" title="All 2 branches missed.">            if(clipH &gt; getHeight()) {</span>
<span class="nc" id="L1023">                clipH = getHeight();</span>
            }

<span class="nc bnc" id="L1026" title="All 4 branches missed.">            if(getParent() != null &amp;&amp; !(getParent() instanceof JComponent)) {</span>
<span class="nc" id="L1027">                adjustPaintFlags();</span>
<span class="nc" id="L1028">                shouldClearPaintFlags = true;</span>
            }

            int bw,bh;
<span class="nc" id="L1032">            boolean printing = getFlag(IS_PRINTING);</span>
<span class="nc bnc" id="L1033" title="All 4 branches missed.">            if (!printing &amp;&amp; repaintManager.isDoubleBufferingEnabled() &amp;&amp;</span>
<span class="nc bnc" id="L1034" title="All 4 branches missed.">                !getFlag(ANCESTOR_USING_BUFFER) &amp;&amp; isDoubleBuffered() &amp;&amp;</span>
<span class="nc bnc" id="L1035" title="All 4 branches missed.">                (getFlag(IS_REPAINTING) || repaintManager.isPainting()))</span>
            {
<span class="nc" id="L1037">                repaintManager.beginPaint();</span>
                try {
<span class="nc" id="L1039">                    repaintManager.paint(this, this, co, clipX, clipY, clipW,</span>
                                         clipH);
                } finally {
<span class="nc" id="L1042">                    repaintManager.endPaint();</span>
<span class="nc" id="L1043">                }</span>
            }
            else {
                // Will ocassionaly happen in 1.2, especially when printing.
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                if (clipRect == null) {</span>
<span class="nc" id="L1048">                    co.setClip(clipX, clipY, clipW, clipH);</span>
                }

<span class="nc bnc" id="L1051" title="All 2 branches missed.">                if (!rectangleIsObscured(clipX,clipY,clipW,clipH)) {</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">                    if (!printing) {</span>
<span class="nc" id="L1053">                        paintComponent(co);</span>
<span class="nc" id="L1054">                        paintBorder(co);</span>
                    }
                    else {
<span class="nc" id="L1057">                        printComponent(co);</span>
<span class="nc" id="L1058">                        printBorder(co);</span>
                    }
                }
<span class="nc bnc" id="L1061" title="All 2 branches missed.">                if (!printing) {</span>
<span class="nc" id="L1062">                    paintChildren(co);</span>
                }
                else {
<span class="nc" id="L1065">                    printChildren(co);</span>
                }
            }
        } finally {
<span class="nc" id="L1069">            co.dispose();</span>
<span class="nc bnc" id="L1070" title="All 4 branches missed.">            if(shouldClearPaintFlags) {</span>
<span class="nc" id="L1071">                setFlag(ANCESTOR_USING_BUFFER,false);</span>
<span class="nc" id="L1072">                setFlag(IS_PAINTING_TILE,false);</span>
<span class="nc" id="L1073">                setFlag(IS_PRINTING,false);</span>
<span class="nc" id="L1074">                setFlag(IS_PRINTING_ALL,false);</span>
            }
        }
<span class="nc" id="L1077">    }</span>

    // paint forcing use of the double buffer.  This is used for historical
    // reasons: JViewport, when scrolling, previously directly invoked paint
    // while turning off double buffering at the RepaintManager level, this
    // codes simulates that.
    void paintForceDoubleBuffered(Graphics g) {
<span class="nc" id="L1084">        RepaintManager rm = RepaintManager.currentManager(this);</span>
<span class="nc" id="L1085">        Rectangle clip = g.getClipBounds();</span>
<span class="nc" id="L1086">        rm.beginPaint();</span>
<span class="nc" id="L1087">        setFlag(IS_REPAINTING, true);</span>
        try {
<span class="nc" id="L1089">            rm.paint(this, this, g, clip.x, clip.y, clip.width, clip.height);</span>
        } finally {
<span class="nc" id="L1091">            rm.endPaint();</span>
<span class="nc" id="L1092">            setFlag(IS_REPAINTING, false);</span>
<span class="nc" id="L1093">        }</span>
<span class="nc" id="L1094">    }</span>

    /**
     * Returns true if this component, or any of its ancestors, are in
     * the processing of painting.
     */
    boolean isPainting() {
<span class="nc" id="L1101">        Container component = this;</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        while (component != null) {</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">            if (component instanceof JComponent &amp;&amp;</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                   ((JComponent)component).getFlag(ANCESTOR_USING_BUFFER)) {</span>
<span class="nc" id="L1105">                return true;</span>
            }
<span class="nc" id="L1107">            component = component.getParent();</span>
        }
<span class="nc" id="L1109">        return false;</span>
    }

    private void adjustPaintFlags() {
        JComponent jparent;
        Container parent;
<span class="nc bnc" id="L1115" title="All 2 branches missed.">        for(parent = getParent() ; parent != null ; parent =</span>
<span class="nc" id="L1116">            parent.getParent()) {</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">            if(parent instanceof JComponent) {</span>
<span class="nc" id="L1118">                jparent = (JComponent) parent;</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">                if(jparent.getFlag(ANCESTOR_USING_BUFFER))</span>
<span class="nc" id="L1120">                  setFlag(ANCESTOR_USING_BUFFER, true);</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">                if(jparent.getFlag(IS_PAINTING_TILE))</span>
<span class="nc" id="L1122">                  setFlag(IS_PAINTING_TILE, true);</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">                if(jparent.getFlag(IS_PRINTING))</span>
<span class="nc" id="L1124">                  setFlag(IS_PRINTING, true);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">                if(jparent.getFlag(IS_PRINTING_ALL))</span>
<span class="nc" id="L1126">                  setFlag(IS_PRINTING_ALL, true);</span>
                break;
            }
        }
<span class="nc" id="L1130">    }</span>

    /**
     * Invoke this method to print the component. This method invokes
     * &lt;code&gt;print&lt;/code&gt; on the component.
     *
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
     * @see #print
     * @see #printComponent
     * @see #printBorder
     * @see #printChildren
     */
    public void printAll(Graphics g) {
<span class="nc" id="L1143">        setFlag(IS_PRINTING_ALL, true);</span>
        try {
<span class="nc" id="L1145">            print(g);</span>
        }
        finally {
<span class="nc" id="L1148">            setFlag(IS_PRINTING_ALL, false);</span>
<span class="nc" id="L1149">        }</span>
<span class="nc" id="L1150">    }</span>

    /**
     * Invoke this method to print the component to the specified
     * &lt;code&gt;Graphics&lt;/code&gt;. This method will result in invocations
     * of &lt;code&gt;printComponent&lt;/code&gt;, &lt;code&gt;printBorder&lt;/code&gt; and
     * &lt;code&gt;printChildren&lt;/code&gt;. It is recommended that you override
     * one of the previously mentioned methods rather than this one if
     * your intention is to customize the way printing looks. However,
     * it can be useful to override this method should you want to prepare
     * state before invoking the superclass behavior. As an example,
     * if you wanted to change the component's background color before
     * printing, you could do the following:
     * &lt;pre&gt;
     *     public void print(Graphics g) {
     *         Color orig = getBackground();
     *         setBackground(Color.WHITE);
     *
     *         // wrap in try/finally so that we always restore the state
     *         try {
     *             super.print(g);
     *         } finally {
     *             setBackground(orig);
     *         }
     *     }
     * &lt;/pre&gt;
     * &lt;p&gt;
     * Alternatively, or for components that delegate painting to other objects,
     * you can query during painting whether or not the component is in the
     * midst of a print operation. The &lt;code&gt;isPaintingForPrint&lt;/code&gt; method provides
     * this ability and its return value will be changed by this method: to
     * &lt;code&gt;true&lt;/code&gt; immediately before rendering and to &lt;code&gt;false&lt;/code&gt;
     * immediately after. With each change a property change event is fired on
     * this component with the name &lt;code&gt;&quot;paintingForPrint&quot;&lt;/code&gt;.
     * &lt;p&gt;
     * This method sets the component's state such that the double buffer
     * will not be used: painting will be done directly on the passed in
     * &lt;code&gt;Graphics&lt;/code&gt;.
     *
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
     * @see #printComponent
     * @see #printBorder
     * @see #printChildren
     * @see #isPaintingForPrint
     */
    public void print(Graphics g) {
<span class="nc" id="L1196">        setFlag(IS_PRINTING, true);</span>
<span class="nc" id="L1197">        firePropertyChange(&quot;paintingForPrint&quot;, false, true);</span>
        try {
<span class="nc" id="L1199">            paint(g);</span>
        }
        finally {
<span class="nc" id="L1202">            setFlag(IS_PRINTING, false);</span>
<span class="nc" id="L1203">            firePropertyChange(&quot;paintingForPrint&quot;, true, false);</span>
<span class="nc" id="L1204">        }</span>
<span class="nc" id="L1205">    }</span>

    /**
     * This is invoked during a printing operation. This is implemented to
     * invoke &lt;code&gt;paintComponent&lt;/code&gt; on the component. Override this
     * if you wish to add special painting behavior when printing.
     *
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
     * @see #print
     * @since 1.3
     */
    protected void printComponent(Graphics g) {
<span class="nc" id="L1217">        paintComponent(g);</span>
<span class="nc" id="L1218">    }</span>

    /**
     * Prints this component's children. This is implemented to invoke
     * &lt;code&gt;paintChildren&lt;/code&gt; on the component. Override this if you
     * wish to print the children differently than painting.
     *
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
     * @see #print
     * @since 1.3
     */
    protected void printChildren(Graphics g) {
<span class="nc" id="L1230">        paintChildren(g);</span>
<span class="nc" id="L1231">    }</span>

    /**
     * Prints the component's border. This is implemented to invoke
     * &lt;code&gt;paintBorder&lt;/code&gt; on the component. Override this if you
     * wish to print the border differently that it is painted.
     *
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context in which to paint
     * @see #print
     * @since 1.3
     */
    protected void printBorder(Graphics g) {
<span class="nc" id="L1243">        paintBorder(g);</span>
<span class="nc" id="L1244">    }</span>

    /**
     *  Returns true if the component is currently painting a tile.
     *  If this method returns true, paint will be called again for another
     *  tile. This method returns false if you are not painting a tile or
     *  if the last tile is painted.
     *  Use this method to keep some state you might need between tiles.
     *
     *  @return  true if the component is currently painting a tile,
     *          false otherwise
     */
    public boolean isPaintingTile() {
<span class="nc" id="L1257">        return getFlag(IS_PAINTING_TILE);</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the current painting operation on this
     * component is part of a &lt;code&gt;print&lt;/code&gt; operation. This method is
     * useful when you want to customize what you print versus what you show
     * on the screen.
     * &lt;p&gt;
     * You can detect changes in the value of this property by listening for
     * property change events on this component with name
     * &lt;code&gt;&quot;paintingForPrint&quot;&lt;/code&gt;.
     * &lt;p&gt;
     * Note: This method provides complimentary functionality to that provided
     * by other high level Swing printing APIs. However, it deals strictly with
     * painting and should not be confused as providing information on higher
     * level print processes. For example, a {@link javax.swing.JTable#print()}
     * operation doesn't necessarily result in a continuous rendering of the
     * full component, and the return value of this method can change multiple
     * times during that operation. It is even possible for the component to be
     * painted to the screen while the printing process is ongoing. In such a
     * case, the return value of this method is &lt;code&gt;true&lt;/code&gt; when, and only
     * when, the table is being painted as part of the printing process.
     *
     * @return true if the current painting operation on this component
     *         is part of a print operation
     * @see #print
     * @since 1.6
     */
    public final boolean isPaintingForPrint() {
<span class="nc" id="L1287">        return getFlag(IS_PRINTING);</span>
    }

    /**
     * In release 1.4, the focus subsystem was rearchitected.
     * For more information, see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
     * How to Use the Focus Subsystem&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
     * &lt;p&gt;
     * Changes this &lt;code&gt;JComponent&lt;/code&gt;'s focus traversal keys to
     * CTRL+TAB and CTRL+SHIFT+TAB. Also prevents
     * &lt;code&gt;SortingFocusTraversalPolicy&lt;/code&gt; from considering descendants
     * of this JComponent when computing a focus traversal cycle.
     *
     * @see java.awt.Component#setFocusTraversalKeys
     * @see SortingFocusTraversalPolicy
     * @deprecated As of 1.4, replaced by
     *   &lt;code&gt;Component.setFocusTraversalKeys(int, Set)&lt;/code&gt; and
     *   &lt;code&gt;Container.setFocusCycleRoot(boolean)&lt;/code&gt;.
     */
    @Deprecated
    public boolean isManagingFocus() {
<span class="nc" id="L1310">        return false;</span>
    }

    private void registerNextFocusableComponent() {
<span class="nc" id="L1314">        registerNextFocusableComponent(getNextFocusableComponent());</span>
<span class="nc" id="L1315">    }</span>

    private void registerNextFocusableComponent(Component
                                                nextFocusableComponent) {
<span class="nc bnc" id="L1319" title="All 2 branches missed.">        if (nextFocusableComponent == null) {</span>
<span class="nc" id="L1320">            return;</span>
        }

<span class="nc" id="L1323">        Container nearestRoot =</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">            (isFocusCycleRoot()) ? this : getFocusCycleRootAncestor();</span>
<span class="nc" id="L1325">        FocusTraversalPolicy policy = nearestRoot.getFocusTraversalPolicy();</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">        if (!(policy instanceof LegacyGlueFocusTraversalPolicy)) {</span>
<span class="nc" id="L1327">            policy = new LegacyGlueFocusTraversalPolicy(policy);</span>
<span class="nc" id="L1328">            nearestRoot.setFocusTraversalPolicy(policy);</span>
        }
<span class="nc" id="L1330">        ((LegacyGlueFocusTraversalPolicy)policy).</span>
<span class="nc" id="L1331">            setNextFocusableComponent(this, nextFocusableComponent);</span>
<span class="nc" id="L1332">    }</span>

    private void deregisterNextFocusableComponent() {
<span class="nc" id="L1335">        Component nextFocusableComponent = getNextFocusableComponent();</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">        if (nextFocusableComponent == null) {</span>
<span class="nc" id="L1337">            return;</span>
        }

<span class="nc" id="L1340">        Container nearestRoot =</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">            (isFocusCycleRoot()) ? this : getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">        if (nearestRoot == null) {</span>
<span class="nc" id="L1343">            return;</span>
        }
<span class="nc" id="L1345">        FocusTraversalPolicy policy = nearestRoot.getFocusTraversalPolicy();</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">        if (policy instanceof LegacyGlueFocusTraversalPolicy) {</span>
<span class="nc" id="L1347">            ((LegacyGlueFocusTraversalPolicy)policy).</span>
<span class="nc" id="L1348">                unsetNextFocusableComponent(this, nextFocusableComponent);</span>
        }
<span class="nc" id="L1350">    }</span>

    /**
     * In release 1.4, the focus subsystem was rearchitected.
     * For more information, see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
     * How to Use the Focus Subsystem&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
     * &lt;p&gt;
     * Overrides the default &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; for this
     * &lt;code&gt;JComponent&lt;/code&gt;'s focus traversal cycle by unconditionally
     * setting the specified &lt;code&gt;Component&lt;/code&gt; as the next
     * &lt;code&gt;Component&lt;/code&gt; in the cycle, and this &lt;code&gt;JComponent&lt;/code&gt;
     * as the specified &lt;code&gt;Component&lt;/code&gt;'s previous
     * &lt;code&gt;Component&lt;/code&gt; in the cycle.
     *
     * @param aComponent the &lt;code&gt;Component&lt;/code&gt; that should follow this
     *        &lt;code&gt;JComponent&lt;/code&gt; in the focus traversal cycle
     *
     * @see #getNextFocusableComponent
     * @see java.awt.FocusTraversalPolicy
     * @deprecated As of 1.4, replaced by &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;
     */
    @Deprecated
    public void setNextFocusableComponent(Component aComponent) {
<span class="nc" id="L1375">        boolean displayable = isDisplayable();</span>
<span class="nc bnc" id="L1376" title="All 2 branches missed.">        if (displayable) {</span>
<span class="nc" id="L1377">            deregisterNextFocusableComponent();</span>
        }
<span class="nc" id="L1379">        putClientProperty(NEXT_FOCUS, aComponent);</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">        if (displayable) {</span>
<span class="nc" id="L1381">            registerNextFocusableComponent(aComponent);</span>
        }
<span class="nc" id="L1383">    }</span>

    /**
     * In release 1.4, the focus subsystem was rearchitected.
     * For more information, see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
     * How to Use the Focus Subsystem&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
     * &lt;p&gt;
     * Returns the &lt;code&gt;Component&lt;/code&gt; set by a prior call to
     * &lt;code&gt;setNextFocusableComponent(Component)&lt;/code&gt; on this
     * &lt;code&gt;JComponent&lt;/code&gt;.
     *
     * @return the &lt;code&gt;Component&lt;/code&gt; that will follow this
     *        &lt;code&gt;JComponent&lt;/code&gt; in the focus traversal cycle, or
     *        &lt;code&gt;null&lt;/code&gt; if none has been explicitly specified
     *
     * @see #setNextFocusableComponent
     * @deprecated As of 1.4, replaced by &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;.
     */
    @Deprecated
    public Component getNextFocusableComponent() {
<span class="nc" id="L1405">        return (Component)getClientProperty(NEXT_FOCUS);</span>
    }

    /**
     * Provides a hint as to whether or not this &lt;code&gt;JComponent&lt;/code&gt;
     * should get focus. This is only a hint, and it is up to consumers that
     * are requesting focus to honor this property. This is typically honored
     * for mouse operations, but not keyboard operations. For example, look
     * and feels could verify this property is true before requesting focus
     * during a mouse operation. This would often times be used if you did
     * not want a mouse press on a &lt;code&gt;JComponent&lt;/code&gt; to steal focus,
     * but did want the &lt;code&gt;JComponent&lt;/code&gt; to be traversable via the
     * keyboard. If you do not want this &lt;code&gt;JComponent&lt;/code&gt; focusable at
     * all, use the &lt;code&gt;setFocusable&lt;/code&gt; method instead.
     * &lt;p&gt;
     * Please see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
     * How to Use the Focus Subsystem&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;,
     * for more information.
     *
     * @param requestFocusEnabled indicates whether you want this
     *        &lt;code&gt;JComponent&lt;/code&gt; to be focusable or not
     * @see &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus Specification&lt;/a&gt;
     * @see java.awt.Component#setFocusable
     */
    public void setRequestFocusEnabled(boolean requestFocusEnabled) {
<span class="nc bnc" id="L1432" title="All 2 branches missed.">        setFlag(REQUEST_FOCUS_DISABLED, !requestFocusEnabled);</span>
<span class="nc" id="L1433">    }</span>

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;code&gt;JComponent&lt;/code&gt; should
     * get focus; otherwise returns &lt;code&gt;false&lt;/code&gt;.
     * &lt;p&gt;
     * Please see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
     * How to Use the Focus Subsystem&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;,
     * for more information.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this component should get focus,
     *     otherwise returns &lt;code&gt;false&lt;/code&gt;
     * @see #setRequestFocusEnabled
     * @see &lt;a href=&quot;../../java/awt/doc-files/FocusSpec.html&quot;&gt;Focus
     *      Specification&lt;/a&gt;
     * @see java.awt.Component#isFocusable
     */
    public boolean isRequestFocusEnabled() {
<span class="nc bnc" id="L1453" title="All 2 branches missed.">        return !getFlag(REQUEST_FOCUS_DISABLED);</span>
    }

    /**
     * Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
     * Refer to {@link java.awt.Component#requestFocus()
     * Component.requestFocus()} for a complete description of
     * this method.
     * &lt;p&gt;
     * Note that the use of this method is discouraged because
     * its behavior is platform dependent. Instead we recommend the
     * use of {@link #requestFocusInWindow() requestFocusInWindow()}.
     * If you would like more information on focus, see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
     * How to Use the Focus Subsystem&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
     *
     * @see java.awt.Component#requestFocusInWindow()
     * @see java.awt.Component#requestFocusInWindow(boolean)
     * @since 1.4
     */
    public void requestFocus() {
<span class="nc" id="L1475">        super.requestFocus();</span>
<span class="nc" id="L1476">    }</span>

    /**
     * Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
     * Refer to {@link java.awt.Component#requestFocus(boolean)
     * Component.requestFocus(boolean)} for a complete description of
     * this method.
     * &lt;p&gt;
     * Note that the use of this method is discouraged because
     * its behavior is platform dependent. Instead we recommend the
     * use of {@link #requestFocusInWindow(boolean)
     * requestFocusInWindow(boolean)}.
     * If you would like more information on focus, see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
     * How to Use the Focus Subsystem&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
     *
     * @param temporary boolean indicating if the focus change is temporary
     * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
     *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
     * @see java.awt.Component#requestFocusInWindow()
     * @see java.awt.Component#requestFocusInWindow(boolean)
     * @since 1.4
     */
    public boolean requestFocus(boolean temporary) {
<span class="nc" id="L1501">        return super.requestFocus(temporary);</span>
    }

    /**
     * Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
     * Refer to {@link java.awt.Component#requestFocusInWindow()
     * Component.requestFocusInWindow()} for a complete description of
     * this method.
     * &lt;p&gt;
     * If you would like more information on focus, see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
     * How to Use the Focus Subsystem&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
     *
     * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
     *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
     * @see java.awt.Component#requestFocusInWindow()
     * @see java.awt.Component#requestFocusInWindow(boolean)
     * @since 1.4
     */
    public boolean requestFocusInWindow() {
<span class="nc" id="L1522">        return super.requestFocusInWindow();</span>
    }

    /**
     * Requests that this &lt;code&gt;Component&lt;/code&gt; gets the input focus.
     * Refer to {@link java.awt.Component#requestFocusInWindow(boolean)
     * Component.requestFocusInWindow(boolean)} for a complete description of
     * this method.
     * &lt;p&gt;
     * If you would like more information on focus, see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
     * How to Use the Focus Subsystem&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
     *
     * @param temporary boolean indicating if the focus change is temporary
     * @return &lt;code&gt;false&lt;/code&gt; if the focus change request is guaranteed to
     *         fail; &lt;code&gt;true&lt;/code&gt; if it is likely to succeed
     * @see java.awt.Component#requestFocusInWindow()
     * @see java.awt.Component#requestFocusInWindow(boolean)
     * @since 1.4
     */
    protected boolean requestFocusInWindow(boolean temporary) {
<span class="nc" id="L1544">        return super.requestFocusInWindow(temporary);</span>
    }

    /**
     * Requests that this Component get the input focus, and that this
     * Component's top-level ancestor become the focused Window. This component
     * must be displayable, visible, and focusable for the request to be
     * granted.
     * &lt;p&gt;
     * This method is intended for use by focus implementations. Client code
     * should not use this method; instead, it should use
     * &lt;code&gt;requestFocusInWindow()&lt;/code&gt;.
     *
     * @see #requestFocusInWindow()
     */
    public void grabFocus() {
<span class="nc" id="L1560">        requestFocus();</span>
<span class="nc" id="L1561">    }</span>

    /**
     * Sets the value to indicate whether input verifier for the
     * current focus owner will be called before this component requests
     * focus. The default is true. Set to false on components such as a
     * Cancel button or a scrollbar, which should activate even if the
     * input in the current focus owner is not &quot;passed&quot; by the input
     * verifier for that component.
     *
     * @param verifyInputWhenFocusTarget value for the
     *        &lt;code&gt;verifyInputWhenFocusTarget&lt;/code&gt; property
     * @see InputVerifier
     * @see #setInputVerifier
     * @see #getInputVerifier
     * @see #getVerifyInputWhenFocusTarget
     *
     * @since 1.3
     * @beaninfo
     *       bound: true
     * description: Whether the Component verifies input before accepting
     *              focus.
     */
    public void setVerifyInputWhenFocusTarget(boolean
                                              verifyInputWhenFocusTarget) {
<span class="nc" id="L1586">        boolean oldVerifyInputWhenFocusTarget =</span>
            this.verifyInputWhenFocusTarget;
<span class="nc" id="L1588">        this.verifyInputWhenFocusTarget = verifyInputWhenFocusTarget;</span>
<span class="nc" id="L1589">        firePropertyChange(&quot;verifyInputWhenFocusTarget&quot;,</span>
                           oldVerifyInputWhenFocusTarget,
                           verifyInputWhenFocusTarget);
<span class="nc" id="L1592">    }</span>

    /**
     * Returns the value that indicates whether the input verifier for the
     * current focus owner will be called before this component requests
     * focus.
     *
     * @return value of the &lt;code&gt;verifyInputWhenFocusTarget&lt;/code&gt; property
     *
     * @see InputVerifier
     * @see #setInputVerifier
     * @see #getInputVerifier
     * @see #setVerifyInputWhenFocusTarget
     *
     * @since 1.3
     */
    public boolean getVerifyInputWhenFocusTarget() {
<span class="nc" id="L1609">        return verifyInputWhenFocusTarget;</span>
    }


    /**
     * Gets the &lt;code&gt;FontMetrics&lt;/code&gt; for the specified &lt;code&gt;Font&lt;/code&gt;.
     *
     * @param font the font for which font metrics is to be
     *          obtained
     * @return the font metrics for &lt;code&gt;font&lt;/code&gt;
     * @throws NullPointerException if &lt;code&gt;font&lt;/code&gt; is null
     * @since 1.5
     */
    public FontMetrics getFontMetrics(Font font) {
<span class="nc" id="L1623">        return SwingUtilities2.getFontMetrics(this, font);</span>
    }


    /**
     * Sets the preferred size of this component.
     * If &lt;code&gt;preferredSize&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the UI will
     * be asked for the preferred size.
     * @beaninfo
     *   preferred: true
     *       bound: true
     * description: The preferred size of the component.
     */
    public void setPreferredSize(Dimension preferredSize) {
<span class="nc" id="L1637">        super.setPreferredSize(preferredSize);</span>
<span class="nc" id="L1638">    }</span>


    /**
     * If the &lt;code&gt;preferredSize&lt;/code&gt; has been set to a
     * non-&lt;code&gt;null&lt;/code&gt; value just returns it.
     * If the UI delegate's &lt;code&gt;getPreferredSize&lt;/code&gt;
     * method returns a non &lt;code&gt;null&lt;/code&gt; value then return that;
     * otherwise defer to the component's layout manager.
     *
     * @return the value of the &lt;code&gt;preferredSize&lt;/code&gt; property
     * @see #setPreferredSize
     * @see ComponentUI
     */
    @Transient
    public Dimension getPreferredSize() {
<span class="nc bnc" id="L1654" title="All 2 branches missed.">        if (isPreferredSizeSet()) {</span>
<span class="nc" id="L1655">            return super.getPreferredSize();</span>
        }
<span class="nc" id="L1657">        Dimension size = null;</span>
<span class="nc bnc" id="L1658" title="All 2 branches missed.">        if (ui != null) {</span>
<span class="nc" id="L1659">            size = ui.getPreferredSize(this);</span>
        }
<span class="nc bnc" id="L1661" title="All 2 branches missed.">        return (size != null) ? size : super.getPreferredSize();</span>
    }


    /**
     * Sets the maximum size of this component to a constant
     * value.  Subsequent calls to &lt;code&gt;getMaximumSize&lt;/code&gt; will always
     * return this value; the component's UI will not be asked
     * to compute it.  Setting the maximum size to &lt;code&gt;null&lt;/code&gt;
     * restores the default behavior.
     *
     * @param maximumSize a &lt;code&gt;Dimension&lt;/code&gt; containing the
     *          desired maximum allowable size
     * @see #getMaximumSize
     * @beaninfo
     *       bound: true
     * description: The maximum size of the component.
     */
    public void setMaximumSize(Dimension maximumSize) {
<span class="nc" id="L1680">        super.setMaximumSize(maximumSize);</span>
<span class="nc" id="L1681">    }</span>


    /**
     * If the maximum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value
     * just returns it.  If the UI delegate's &lt;code&gt;getMaximumSize&lt;/code&gt;
     * method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that;
     * otherwise defer to the component's layout manager.
     *
     * @return the value of the &lt;code&gt;maximumSize&lt;/code&gt; property
     * @see #setMaximumSize
     * @see ComponentUI
     */
    @Transient
    public Dimension getMaximumSize() {
<span class="nc bnc" id="L1696" title="All 2 branches missed.">        if (isMaximumSizeSet()) {</span>
<span class="nc" id="L1697">            return super.getMaximumSize();</span>
        }
<span class="nc" id="L1699">        Dimension size = null;</span>
<span class="nc bnc" id="L1700" title="All 2 branches missed.">        if (ui != null) {</span>
<span class="nc" id="L1701">            size = ui.getMaximumSize(this);</span>
        }
<span class="nc bnc" id="L1703" title="All 2 branches missed.">        return (size != null) ? size : super.getMaximumSize();</span>
    }


    /**
     * Sets the minimum size of this component to a constant
     * value.  Subsequent calls to &lt;code&gt;getMinimumSize&lt;/code&gt; will always
     * return this value; the component's UI will not be asked
     * to compute it.  Setting the minimum size to &lt;code&gt;null&lt;/code&gt;
     * restores the default behavior.
     *
     * @param minimumSize the new minimum size of this component
     * @see #getMinimumSize
     * @beaninfo
     *       bound: true
     * description: The minimum size of the component.
     */
    public void setMinimumSize(Dimension minimumSize) {
<span class="nc" id="L1721">        super.setMinimumSize(minimumSize);</span>
<span class="nc" id="L1722">    }</span>

    /**
     * If the minimum size has been set to a non-&lt;code&gt;null&lt;/code&gt; value
     * just returns it.  If the UI delegate's &lt;code&gt;getMinimumSize&lt;/code&gt;
     * method returns a non-&lt;code&gt;null&lt;/code&gt; value then return that; otherwise
     * defer to the component's layout manager.
     *
     * @return the value of the &lt;code&gt;minimumSize&lt;/code&gt; property
     * @see #setMinimumSize
     * @see ComponentUI
     */
    @Transient
    public Dimension getMinimumSize() {
<span class="nc bnc" id="L1736" title="All 2 branches missed.">        if (isMinimumSizeSet()) {</span>
<span class="nc" id="L1737">            return super.getMinimumSize();</span>
        }
<span class="nc" id="L1739">        Dimension size = null;</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">        if (ui != null) {</span>
<span class="nc" id="L1741">            size = ui.getMinimumSize(this);</span>
        }
<span class="nc bnc" id="L1743" title="All 2 branches missed.">        return (size != null) ? size : super.getMinimumSize();</span>
    }

    /**
     * Gives the UI delegate an opportunity to define the precise
     * shape of this component for the sake of mouse processing.
     *
     * @return true if this component logically contains x,y
     * @see java.awt.Component#contains(int, int)
     * @see ComponentUI
     */
    public boolean contains(int x, int y) {
<span class="nc bnc" id="L1755" title="All 2 branches missed.">        return (ui != null) ? ui.contains(this, x, y) : super.contains(x, y);</span>
    }

    /**
     * Sets the border of this component.  The &lt;code&gt;Border&lt;/code&gt; object is
     * responsible for defining the insets for the component
     * (overriding any insets set directly on the component) and
     * for optionally rendering any border decorations within the
     * bounds of those insets.  Borders should be used (rather
     * than insets) for creating both decorative and non-decorative
     * (such as margins and padding) regions for a swing component.
     * Compound borders can be used to nest multiple borders within a
     * single component.
     * &lt;p&gt;
     * Although technically you can set the border on any object
     * that inherits from &lt;code&gt;JComponent&lt;/code&gt;, the look and
     * feel implementation of many standard Swing components
     * doesn't work well with user-set borders.  In general,
     * when you want to set a border on a standard Swing
     * component other than &lt;code&gt;JPanel&lt;/code&gt; or &lt;code&gt;JLabel&lt;/code&gt;,
     * we recommend that you put the component in a &lt;code&gt;JPanel&lt;/code&gt;
     * and set the border on the &lt;code&gt;JPanel&lt;/code&gt;.
     * &lt;p&gt;
     * This is a bound property.
     *
     * @param border the border to be rendered for this component
     * @see Border
     * @see CompoundBorder
     * @beaninfo
     *        bound: true
     *    preferred: true
     *    attribute: visualUpdate true
     *  description: The component's border.
     */
    public void setBorder(Border border) {
<span class="nc" id="L1790">        Border         oldBorder = this.border;</span>

<span class="nc" id="L1792">        this.border = border;</span>
<span class="nc" id="L1793">        firePropertyChange(&quot;border&quot;, oldBorder, border);</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">        if (border != oldBorder) {</span>
<span class="nc bnc" id="L1795" title="All 4 branches missed.">            if (border == null || oldBorder == null ||</span>
<span class="nc bnc" id="L1796" title="All 2 branches missed.">                !(border.getBorderInsets(this).equals(oldBorder.getBorderInsets(this)))) {</span>
<span class="nc" id="L1797">                revalidate();</span>
            }
<span class="nc" id="L1799">            repaint();</span>
        }
<span class="nc" id="L1801">    }</span>

    /**
     * Returns the border of this component or &lt;code&gt;null&lt;/code&gt; if no
     * border is currently set.
     *
     * @return the border object for this component
     * @see #setBorder
     */
    public Border getBorder() {
<span class="nc" id="L1811">        return border;</span>
    }

    /**
     * If a border has been set on this component, returns the
     * border's insets; otherwise calls &lt;code&gt;super.getInsets&lt;/code&gt;.
     *
     * @return the value of the insets property
     * @see #setBorder
     */
    public Insets getInsets() {
<span class="nc bnc" id="L1822" title="All 2 branches missed.">        if (border != null) {</span>
<span class="nc" id="L1823">            return border.getBorderInsets(this);</span>
        }
<span class="nc" id="L1825">        return super.getInsets();</span>
    }

    /**
     * Returns an &lt;code&gt;Insets&lt;/code&gt; object containing this component's inset
     * values.  The passed-in &lt;code&gt;Insets&lt;/code&gt; object will be reused
     * if possible.
     * Calling methods cannot assume that the same object will be returned,
     * however.  All existing values within this object are overwritten.
     * If &lt;code&gt;insets&lt;/code&gt; is null, this will allocate a new one.
     *
     * @param insets the &lt;code&gt;Insets&lt;/code&gt; object, which can be reused
     * @return the &lt;code&gt;Insets&lt;/code&gt; object
     * @see #getInsets
     * @beaninfo
     *   expert: true
     */
    public Insets getInsets(Insets insets) {
<span class="nc bnc" id="L1843" title="All 2 branches missed.">        if (insets == null) {</span>
<span class="nc" id="L1844">            insets = new Insets(0, 0, 0, 0);</span>
        }
<span class="nc bnc" id="L1846" title="All 2 branches missed.">        if (border != null) {</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">            if (border instanceof AbstractBorder) {</span>
<span class="nc" id="L1848">                return ((AbstractBorder)border).getBorderInsets(this, insets);</span>
            } else {
                // Can't reuse border insets because the Border interface
                // can't be enhanced.
<span class="nc" id="L1852">                return border.getBorderInsets(this);</span>
            }
        } else {
            // super.getInsets() always returns an Insets object with
            // all of its value zeroed.  No need for a new object here.
<span class="nc" id="L1857">            insets.left = insets.top = insets.right = insets.bottom = 0;</span>
<span class="nc" id="L1858">            return insets;</span>
        }
    }

    /**
     * Overrides &lt;code&gt;Container.getAlignmentY&lt;/code&gt; to return
     * the horizontal alignment.
     *
     * @return the value of the &lt;code&gt;alignmentY&lt;/code&gt; property
     * @see #setAlignmentY
     * @see java.awt.Component#getAlignmentY
     */
    public float getAlignmentY() {
<span class="nc bnc" id="L1871" title="All 2 branches missed.">        if (isAlignmentYSet) {</span>
<span class="nc" id="L1872">            return alignmentY;</span>
        }
<span class="nc" id="L1874">        return super.getAlignmentY();</span>
    }

    /**
     * Sets the the horizontal alignment.
     *
     * @param alignmentY  the new horizontal alignment
     * @see #getAlignmentY
     * @beaninfo
     *   description: The preferred vertical alignment of the component.
     */
    public void setAlignmentY(float alignmentY) {
<span class="nc bnc" id="L1886" title="All 4 branches missed.">        this.alignmentY = alignmentY &gt; 1.0f ? 1.0f : alignmentY &lt; 0.0f ? 0.0f : alignmentY;</span>
<span class="nc" id="L1887">        isAlignmentYSet = true;</span>
<span class="nc" id="L1888">    }</span>


    /**
     * Overrides &lt;code&gt;Container.getAlignmentX&lt;/code&gt; to return
     * the vertical alignment.
     *
     * @return the value of the &lt;code&gt;alignmentX&lt;/code&gt; property
     * @see #setAlignmentX
     * @see java.awt.Component#getAlignmentX
     */
    public float getAlignmentX() {
<span class="nc bnc" id="L1900" title="All 2 branches missed.">        if (isAlignmentXSet) {</span>
<span class="nc" id="L1901">            return alignmentX;</span>
        }
<span class="nc" id="L1903">        return super.getAlignmentX();</span>
    }

    /**
     * Sets the the vertical alignment.
     *
     * @param alignmentX  the new vertical alignment
     * @see #getAlignmentX
     * @beaninfo
     *   description: The preferred horizontal alignment of the component.
     */
    public void setAlignmentX(float alignmentX) {
<span class="nc bnc" id="L1915" title="All 4 branches missed.">        this.alignmentX = alignmentX &gt; 1.0f ? 1.0f : alignmentX &lt; 0.0f ? 0.0f : alignmentX;</span>
<span class="nc" id="L1916">        isAlignmentXSet = true;</span>
<span class="nc" id="L1917">    }</span>

    /**
     * Sets the input verifier for this component.
     *
     * @param inputVerifier the new input verifier
     * @since 1.3
     * @see InputVerifier
     * @beaninfo
     *       bound: true
     * description: The component's input verifier.
     */
    public void setInputVerifier(InputVerifier inputVerifier) {
<span class="nc" id="L1930">        InputVerifier oldInputVerifier = (InputVerifier)getClientProperty(</span>
                                         JComponent_INPUT_VERIFIER);
<span class="nc" id="L1932">        putClientProperty(JComponent_INPUT_VERIFIER, inputVerifier);</span>
<span class="nc" id="L1933">        firePropertyChange(&quot;inputVerifier&quot;, oldInputVerifier, inputVerifier);</span>
<span class="nc" id="L1934">    }</span>

    /**
     * Returns the input verifier for this component.
     *
     * @return the &lt;code&gt;inputVerifier&lt;/code&gt; property
     * @since 1.3
     * @see InputVerifier
     */
    public InputVerifier getInputVerifier() {
<span class="nc" id="L1944">        return (InputVerifier)getClientProperty(JComponent_INPUT_VERIFIER);</span>
    }

    /**
     * Returns this component's graphics context, which lets you draw
     * on a component. Use this method to get a &lt;code&gt;Graphics&lt;/code&gt; object and
     * then invoke operations on that object to draw on the component.
     * @return this components graphics context
     */
    public Graphics getGraphics() {
<span class="nc bnc" id="L1954" title="All 4 branches missed.">        if (DEBUG_GRAPHICS_LOADED &amp;&amp; shouldDebugGraphics() != 0) {</span>
<span class="nc" id="L1955">            DebugGraphics graphics = new DebugGraphics(super.getGraphics(),</span>
                                                       this);
<span class="nc" id="L1957">            return graphics;</span>
        }
<span class="nc" id="L1959">        return super.getGraphics();</span>
    }


    /** Enables or disables diagnostic information about every graphics
      * operation performed within the component or one of its children.
      *
      * @param debugOptions  determines how the component should display
      *         the information;  one of the following options:
      * &lt;ul&gt;
      * &lt;li&gt;DebugGraphics.LOG_OPTION - causes a text message to be printed.
      * &lt;li&gt;DebugGraphics.FLASH_OPTION - causes the drawing to flash several
      * times.
      * &lt;li&gt;DebugGraphics.BUFFERED_OPTION - creates an
      *         &lt;code&gt;ExternalWindow&lt;/code&gt; that displays the operations
      *         performed on the View's offscreen buffer.
      * &lt;li&gt;DebugGraphics.NONE_OPTION disables debugging.
      * &lt;li&gt;A value of 0 causes no changes to the debugging options.
      * &lt;/ul&gt;
      * &lt;code&gt;debugOptions&lt;/code&gt; is bitwise OR'd into the current value
      *
      * @beaninfo
      *   preferred: true
      *        enum: NONE_OPTION DebugGraphics.NONE_OPTION
      *              LOG_OPTION DebugGraphics.LOG_OPTION
      *              FLASH_OPTION DebugGraphics.FLASH_OPTION
      *              BUFFERED_OPTION DebugGraphics.BUFFERED_OPTION
      * description: Diagnostic options for graphics operations.
      */
    public void setDebugGraphicsOptions(int debugOptions) {
<span class="nc" id="L1989">        DebugGraphics.setDebugOptions(this, debugOptions);</span>
<span class="nc" id="L1990">    }</span>

    /** Returns the state of graphics debugging.
      *
      * @return a bitwise OR'd flag of zero or more of the following options:
      * &lt;ul&gt;
      * &lt;li&gt;DebugGraphics.LOG_OPTION - causes a text message to be printed.
      * &lt;li&gt;DebugGraphics.FLASH_OPTION - causes the drawing to flash several
      * times.
      * &lt;li&gt;DebugGraphics.BUFFERED_OPTION - creates an
      *         &lt;code&gt;ExternalWindow&lt;/code&gt; that displays the operations
      *         performed on the View's offscreen buffer.
      * &lt;li&gt;DebugGraphics.NONE_OPTION disables debugging.
      * &lt;li&gt;A value of 0 causes no changes to the debugging options.
      * &lt;/ul&gt;
      * @see #setDebugGraphicsOptions
      */
    public int getDebugGraphicsOptions() {
<span class="nc" id="L2008">        return DebugGraphics.getDebugOptions(this);</span>
    }


    /**
     * Returns true if debug information is enabled for this
     * &lt;code&gt;JComponent&lt;/code&gt; or one of its parents.
     */
    int shouldDebugGraphics() {
<span class="nc" id="L2017">        return DebugGraphics.shouldComponentDebug(this);</span>
    }

    /**
     * This method is now obsolete, please use a combination of
     * &lt;code&gt;getActionMap()&lt;/code&gt; and &lt;code&gt;getInputMap()&lt;/code&gt; for
     * similar behavior. For example, to bind the &lt;code&gt;KeyStroke&lt;/code&gt;
     * &lt;code&gt;aKeyStroke&lt;/code&gt; to the &lt;code&gt;Action&lt;/code&gt; &lt;code&gt;anAction&lt;/code&gt;
     * now use:
     * &lt;pre&gt;
     *   component.getInputMap().put(aKeyStroke, aCommand);
     *   component.getActionMap().put(aCommmand, anAction);
     * &lt;/pre&gt;
     * The above assumes you want the binding to be applicable for
     * &lt;code&gt;WHEN_FOCUSED&lt;/code&gt;. To register bindings for other focus
     * states use the &lt;code&gt;getInputMap&lt;/code&gt; method that takes an integer.
     * &lt;p&gt;
     * Register a new keyboard action.
     * &lt;code&gt;anAction&lt;/code&gt; will be invoked if a key event matching
     * &lt;code&gt;aKeyStroke&lt;/code&gt; occurs and &lt;code&gt;aCondition&lt;/code&gt; is verified.
     * The &lt;code&gt;KeyStroke&lt;/code&gt; object defines a
     * particular combination of a keyboard key and one or more modifiers
     * (alt, shift, ctrl, meta).
     * &lt;p&gt;
     * The &lt;code&gt;aCommand&lt;/code&gt; will be set in the delivered event if
     * specified.
     * &lt;p&gt;
     * The &lt;code&gt;aCondition&lt;/code&gt; can be one of:
     * &lt;blockquote&gt;
     * &lt;DL&gt;
     * &lt;DT&gt;WHEN_FOCUSED
     * &lt;DD&gt;The action will be invoked only when the keystroke occurs
     *     while the component has the focus.
     * &lt;DT&gt;WHEN_IN_FOCUSED_WINDOW
     * &lt;DD&gt;The action will be invoked when the keystroke occurs while
     *     the component has the focus or if the component is in the
     *     window that has the focus. Note that the component need not
     *     be an immediate descendent of the window -- it can be
     *     anywhere in the window's containment hierarchy. In other
     *     words, whenever &lt;em&gt;any&lt;/em&gt; component in the window has the focus,
     *     the action registered with this component is invoked.
     * &lt;DT&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
     * &lt;DD&gt;The action will be invoked when the keystroke occurs while the
     *     component has the focus or if the component is an ancestor of
     *     the component that has the focus.
     * &lt;/DL&gt;
     * &lt;/blockquote&gt;
     * &lt;p&gt;
     * The combination of keystrokes and conditions lets you define high
     * level (semantic) action events for a specified keystroke+modifier
     * combination (using the KeyStroke class) and direct to a parent or
     * child of a component that has the focus, or to the component itself.
     * In other words, in any hierarchical structure of components, an
     * arbitrary key-combination can be immediately directed to the
     * appropriate component in the hierarchy, and cause a specific method
     * to be invoked (usually by way of adapter objects).
     * &lt;p&gt;
     * If an action has already been registered for the receiving
     * container, with the same charCode and the same modifiers,
     * &lt;code&gt;anAction&lt;/code&gt; will replace the action.
     *
     * @param anAction  the &lt;code&gt;Action&lt;/code&gt; to be registered
     * @param aCommand  the command to be set in the delivered event
     * @param aKeyStroke the &lt;code&gt;KeyStroke&lt;/code&gt; to bind to the action
     * @param aCondition the condition that needs to be met, see above
     * @see KeyStroke
     */
    public void registerKeyboardAction(ActionListener anAction,String aCommand,KeyStroke aKeyStroke,int aCondition) {

<span class="nc" id="L2086">        InputMap inputMap = getInputMap(aCondition, true);</span>

<span class="nc bnc" id="L2088" title="All 2 branches missed.">        if (inputMap != null) {</span>
<span class="nc" id="L2089">            ActionMap actionMap = getActionMap(true);</span>
<span class="nc" id="L2090">            ActionStandin action = new ActionStandin(anAction, aCommand);</span>
<span class="nc" id="L2091">            inputMap.put(aKeyStroke, action);</span>
<span class="nc bnc" id="L2092" title="All 2 branches missed.">            if (actionMap != null) {</span>
<span class="nc" id="L2093">                actionMap.put(action, action);</span>
            }
        }
<span class="nc" id="L2096">    }</span>

    /**
     * Registers any bound &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; actions with
     * the &lt;code&gt;KeyboardManager&lt;/code&gt;. If &lt;code&gt;onlyIfNew&lt;/code&gt;
     * is true only actions that haven't been registered are pushed
     * to the &lt;code&gt;KeyboardManager&lt;/code&gt;;
     * otherwise all actions are pushed to the &lt;code&gt;KeyboardManager&lt;/code&gt;.
     *
     * @param onlyIfNew  if true, only actions that haven't been registered
     *          are pushed to the &lt;code&gt;KeyboardManager&lt;/code&gt;
     */
    private void registerWithKeyboardManager(boolean onlyIfNew) {
<span class="nc" id="L2109">        InputMap inputMap = getInputMap(WHEN_IN_FOCUSED_WINDOW, false);</span>
        KeyStroke[] strokes;
<span class="nc" id="L2111">        Hashtable&lt;KeyStroke, KeyStroke&gt; registered =</span>
                (Hashtable&lt;KeyStroke, KeyStroke&gt;)getClientProperty
<span class="nc" id="L2113">                                (WHEN_IN_FOCUSED_WINDOW_BINDINGS);</span>

<span class="nc bnc" id="L2115" title="All 2 branches missed.">        if (inputMap != null) {</span>
            // Push any new KeyStrokes to the KeyboardManager.
<span class="nc" id="L2117">            strokes = inputMap.allKeys();</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">            if (strokes != null) {</span>
<span class="nc bnc" id="L2119" title="All 2 branches missed.">                for (int counter = strokes.length - 1; counter &gt;= 0;</span>
<span class="nc" id="L2120">                     counter--) {</span>
<span class="nc bnc" id="L2121" title="All 4 branches missed.">                    if (!onlyIfNew || registered == null ||</span>
<span class="nc bnc" id="L2122" title="All 2 branches missed.">                        registered.get(strokes[counter]) == null) {</span>
<span class="nc" id="L2123">                        registerWithKeyboardManager(strokes[counter]);</span>
                    }
<span class="nc bnc" id="L2125" title="All 2 branches missed.">                    if (registered != null) {</span>
<span class="nc" id="L2126">                        registered.remove(strokes[counter]);</span>
                    }
                }
            }
        }
        else {
<span class="nc" id="L2132">            strokes = null;</span>
        }
        // Remove any old ones.
<span class="nc bnc" id="L2135" title="All 4 branches missed.">        if (registered != null &amp;&amp; registered.size() &gt; 0) {</span>
<span class="nc" id="L2136">            Enumeration&lt;KeyStroke&gt; keys = registered.keys();</span>

<span class="nc bnc" id="L2138" title="All 2 branches missed.">            while (keys.hasMoreElements()) {</span>
<span class="nc" id="L2139">                KeyStroke ks = keys.nextElement();</span>
<span class="nc" id="L2140">                unregisterWithKeyboardManager(ks);</span>
<span class="nc" id="L2141">            }</span>
<span class="nc" id="L2142">            registered.clear();</span>
        }
        // Updated the registered Hashtable.
<span class="nc bnc" id="L2145" title="All 4 branches missed.">        if (strokes != null &amp;&amp; strokes.length &gt; 0) {</span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">            if (registered == null) {</span>
<span class="nc" id="L2147">                registered = new Hashtable&lt;KeyStroke, KeyStroke&gt;(strokes.length);</span>
<span class="nc" id="L2148">                putClientProperty(WHEN_IN_FOCUSED_WINDOW_BINDINGS, registered);</span>
            }
<span class="nc bnc" id="L2150" title="All 2 branches missed.">            for (int counter = strokes.length - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L2151">                registered.put(strokes[counter], strokes[counter]);</span>
            }
        }
        else {
<span class="nc" id="L2155">            putClientProperty(WHEN_IN_FOCUSED_WINDOW_BINDINGS, null);</span>
        }
<span class="nc" id="L2157">    }</span>

    /**
     * Unregisters all the previously registered
     * &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; &lt;code&gt;KeyStroke&lt;/code&gt; bindings.
     */
    private void unregisterWithKeyboardManager() {
<span class="nc" id="L2164">        Hashtable&lt;KeyStroke, KeyStroke&gt; registered =</span>
                (Hashtable&lt;KeyStroke, KeyStroke&gt;)getClientProperty
<span class="nc" id="L2166">                                (WHEN_IN_FOCUSED_WINDOW_BINDINGS);</span>

<span class="nc bnc" id="L2168" title="All 4 branches missed.">        if (registered != null &amp;&amp; registered.size() &gt; 0) {</span>
<span class="nc" id="L2169">            Enumeration&lt;KeyStroke&gt; keys = registered.keys();</span>

<span class="nc bnc" id="L2171" title="All 2 branches missed.">            while (keys.hasMoreElements()) {</span>
<span class="nc" id="L2172">                KeyStroke ks = keys.nextElement();</span>
<span class="nc" id="L2173">                unregisterWithKeyboardManager(ks);</span>
<span class="nc" id="L2174">            }</span>
        }
<span class="nc" id="L2176">        putClientProperty(WHEN_IN_FOCUSED_WINDOW_BINDINGS, null);</span>
<span class="nc" id="L2177">    }</span>

    /**
     * Invoked from &lt;code&gt;ComponentInputMap&lt;/code&gt; when its bindings change.
     * If &lt;code&gt;inputMap&lt;/code&gt; is the current &lt;code&gt;windowInputMap&lt;/code&gt;
     * (or a parent of the window &lt;code&gt;InputMap&lt;/code&gt;)
     * the &lt;code&gt;KeyboardManager&lt;/code&gt; is notified of the new bindings.
     *
     * @param inputMap the map containing the new bindings
     */
    void componentInputMapChanged(ComponentInputMap inputMap) {
<span class="nc" id="L2188">        InputMap km = getInputMap(WHEN_IN_FOCUSED_WINDOW, false);</span>

<span class="nc bnc" id="L2190" title="All 4 branches missed.">        while (km != inputMap &amp;&amp; km != null) {</span>
<span class="nc" id="L2191">            km = km.getParent();</span>
        }
<span class="nc bnc" id="L2193" title="All 2 branches missed.">        if (km != null) {</span>
<span class="nc" id="L2194">            registerWithKeyboardManager(false);</span>
        }
<span class="nc" id="L2196">    }</span>

    private void registerWithKeyboardManager(KeyStroke aKeyStroke) {
<span class="nc" id="L2199">        KeyboardManager.getCurrentManager().registerKeyStroke(aKeyStroke,this);</span>
<span class="nc" id="L2200">    }</span>

    private void unregisterWithKeyboardManager(KeyStroke aKeyStroke) {
<span class="nc" id="L2203">        KeyboardManager.getCurrentManager().unregisterKeyStroke(aKeyStroke,</span>
                                                                this);
<span class="nc" id="L2205">    }</span>

    /**
     * This method is now obsolete, please use a combination of
     * &lt;code&gt;getActionMap()&lt;/code&gt; and &lt;code&gt;getInputMap()&lt;/code&gt; for
     * similar behavior.
     */
    public void registerKeyboardAction(ActionListener anAction,KeyStroke aKeyStroke,int aCondition) {
<span class="nc" id="L2213">        registerKeyboardAction(anAction,null,aKeyStroke,aCondition);</span>
<span class="nc" id="L2214">    }</span>

    /**
     * This method is now obsolete. To unregister an existing binding
     * you can either remove the binding from the
     * &lt;code&gt;ActionMap/InputMap&lt;/code&gt;, or place a dummy binding the
     * &lt;code&gt;InputMap&lt;/code&gt;. Removing the binding from the
     * &lt;code&gt;InputMap&lt;/code&gt; allows bindings in parent &lt;code&gt;InputMap&lt;/code&gt;s
     * to be active, whereas putting a dummy binding in the
     * &lt;code&gt;InputMap&lt;/code&gt; effectively disables
     * the binding from ever happening.
     * &lt;p&gt;
     * Unregisters a keyboard action.
     * This will remove the binding from the &lt;code&gt;ActionMap&lt;/code&gt;
     * (if it exists) as well as the &lt;code&gt;InputMap&lt;/code&gt;s.
     */
    public void unregisterKeyboardAction(KeyStroke aKeyStroke) {
<span class="nc" id="L2231">        ActionMap am = getActionMap(false);</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">        for (int counter = 0; counter &lt; 3; counter++) {</span>
<span class="nc" id="L2233">            InputMap km = getInputMap(counter, false);</span>
<span class="nc bnc" id="L2234" title="All 2 branches missed.">            if (km != null) {</span>
<span class="nc" id="L2235">                Object actionID = km.get(aKeyStroke);</span>

<span class="nc bnc" id="L2237" title="All 4 branches missed.">                if (am != null &amp;&amp; actionID != null) {</span>
<span class="nc" id="L2238">                    am.remove(actionID);</span>
                }
<span class="nc" id="L2240">                km.remove(aKeyStroke);</span>
            }
        }
<span class="nc" id="L2243">    }</span>

    /**
     * Returns the &lt;code&gt;KeyStrokes&lt;/code&gt; that will initiate
     * registered actions.
     *
     * @return an array of &lt;code&gt;KeyStroke&lt;/code&gt; objects
     * @see #registerKeyboardAction
     */
    public KeyStroke[] getRegisteredKeyStrokes() {
<span class="nc" id="L2253">        int[] counts = new int[3];</span>
<span class="nc" id="L2254">        KeyStroke[][] strokes = new KeyStroke[3][];</span>

<span class="nc bnc" id="L2256" title="All 2 branches missed.">        for (int counter = 0; counter &lt; 3; counter++) {</span>
<span class="nc" id="L2257">            InputMap km = getInputMap(counter, false);</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">            strokes[counter] = (km != null) ? km.allKeys() : null;</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">            counts[counter] = (strokes[counter] != null) ?</span>
                               strokes[counter].length : 0;
        }
<span class="nc" id="L2262">        KeyStroke[] retValue = new KeyStroke[counts[0] + counts[1] +</span>
                                            counts[2]];
<span class="nc bnc" id="L2264" title="All 2 branches missed.">        for (int counter = 0, last = 0; counter &lt; 3; counter++) {</span>
<span class="nc bnc" id="L2265" title="All 2 branches missed.">            if (counts[counter] &gt; 0) {</span>
<span class="nc" id="L2266">                System.arraycopy(strokes[counter], 0, retValue, last,</span>
                                 counts[counter]);
<span class="nc" id="L2268">                last += counts[counter];</span>
            }
        }
<span class="nc" id="L2271">        return retValue;</span>
    }

    /**
     * Returns the condition that determines whether a registered action
     * occurs in response to the specified keystroke.
     * &lt;p&gt;
     * For Java 2 platform v1.3, a &lt;code&gt;KeyStroke&lt;/code&gt; can be associated
     * with more than one condition.
     * For example, 'a' could be bound for the two
     * conditions &lt;code&gt;WHEN_FOCUSED&lt;/code&gt; and
     * &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; condition.
     *
     * @return the action-keystroke condition
     */
    public int getConditionForKeyStroke(KeyStroke aKeyStroke) {
<span class="nc bnc" id="L2287" title="All 2 branches missed.">        for (int counter = 0; counter &lt; 3; counter++) {</span>
<span class="nc" id="L2288">            InputMap inputMap = getInputMap(counter, false);</span>
<span class="nc bnc" id="L2289" title="All 4 branches missed.">            if (inputMap != null &amp;&amp; inputMap.get(aKeyStroke) != null) {</span>
<span class="nc" id="L2290">                return counter;</span>
            }
        }
<span class="nc" id="L2293">        return UNDEFINED_CONDITION;</span>
    }

    /**
     * Returns the object that will perform the action registered for a
     * given keystroke.
     *
     * @return the &lt;code&gt;ActionListener&lt;/code&gt;
     *          object invoked when the keystroke occurs
     */
    public ActionListener getActionForKeyStroke(KeyStroke aKeyStroke) {
<span class="nc" id="L2304">        ActionMap am = getActionMap(false);</span>

<span class="nc bnc" id="L2306" title="All 2 branches missed.">        if (am == null) {</span>
<span class="nc" id="L2307">            return null;</span>
        }
<span class="nc bnc" id="L2309" title="All 2 branches missed.">        for (int counter = 0; counter &lt; 3; counter++) {</span>
<span class="nc" id="L2310">            InputMap inputMap = getInputMap(counter, false);</span>
<span class="nc bnc" id="L2311" title="All 2 branches missed.">            if (inputMap != null) {</span>
<span class="nc" id="L2312">                Object actionBinding = inputMap.get(aKeyStroke);</span>

<span class="nc bnc" id="L2314" title="All 2 branches missed.">                if (actionBinding != null) {</span>
<span class="nc" id="L2315">                    Action action = am.get(actionBinding);</span>
<span class="nc bnc" id="L2316" title="All 2 branches missed.">                    if (action instanceof ActionStandin) {</span>
<span class="nc" id="L2317">                        return ((ActionStandin)action).actionListener;</span>
                    }
<span class="nc" id="L2319">                    return action;</span>
                }
            }
        }
<span class="nc" id="L2323">        return null;</span>
    }

    /**
     * Unregisters all the bindings in the first tier &lt;code&gt;InputMaps&lt;/code&gt;
     * and &lt;code&gt;ActionMap&lt;/code&gt;. This has the effect of removing any
     * local bindings, and allowing the bindings defined in parent
     * &lt;code&gt;InputMap/ActionMaps&lt;/code&gt;
     * (the UI is usually defined in the second tier) to persist.
     */
    public void resetKeyboardActions() {
        // Keys
<span class="nc bnc" id="L2335" title="All 2 branches missed.">        for (int counter = 0; counter &lt; 3; counter++) {</span>
<span class="nc" id="L2336">            InputMap inputMap = getInputMap(counter, false);</span>

<span class="nc bnc" id="L2338" title="All 2 branches missed.">            if (inputMap != null) {</span>
<span class="nc" id="L2339">                inputMap.clear();</span>
            }
        }

        // Actions
<span class="nc" id="L2344">        ActionMap am = getActionMap(false);</span>

<span class="nc bnc" id="L2346" title="All 2 branches missed.">        if (am != null) {</span>
<span class="nc" id="L2347">            am.clear();</span>
        }
<span class="nc" id="L2349">    }</span>

    /**
     * Sets the &lt;code&gt;InputMap&lt;/code&gt; to use under the condition
     * &lt;code&gt;condition&lt;/code&gt; to
     * &lt;code&gt;map&lt;/code&gt;. A &lt;code&gt;null&lt;/code&gt; value implies you
     * do not want any bindings to be used, even from the UI. This will
     * not reinstall the UI &lt;code&gt;InputMap&lt;/code&gt; (if there was one).
     * &lt;code&gt;condition&lt;/code&gt; has one of the following values:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;WHEN_FOCUSED&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&lt;/code&gt;
     * &lt;/ul&gt;
     * If &lt;code&gt;condition&lt;/code&gt; is &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt;
     * and &lt;code&gt;map&lt;/code&gt; is not a &lt;code&gt;ComponentInputMap&lt;/code&gt;, an
     * &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
     * Similarly, if &lt;code&gt;condition&lt;/code&gt; is not one of the values
     * listed, an &lt;code&gt;IllegalArgumentException&lt;/code&gt; will be thrown.
     *
     * @param condition one of the values listed above
     * @param map  the &lt;code&gt;InputMap&lt;/code&gt; to use for the given condition
     * @exception IllegalArgumentException if &lt;code&gt;condition&lt;/code&gt; is
     *          &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;
     *          is not an instance of &lt;code&gt;ComponentInputMap&lt;/code&gt;; or
     *          if &lt;code&gt;condition&lt;/code&gt; is not one of the legal values
     *          specified above
     * @since 1.3
     */
    public final void setInputMap(int condition, InputMap map) {
<span class="nc bnc" id="L2379" title="All 4 branches missed.">        switch (condition) {</span>
        case WHEN_IN_FOCUSED_WINDOW:
<span class="nc bnc" id="L2381" title="All 4 branches missed.">            if (map != null &amp;&amp; !(map instanceof ComponentInputMap)) {</span>
<span class="nc" id="L2382">                throw new IllegalArgumentException(&quot;WHEN_IN_FOCUSED_WINDOW InputMaps must be of type ComponentInputMap&quot;);</span>
            }
<span class="nc" id="L2384">            windowInputMap = (ComponentInputMap)map;</span>
<span class="nc" id="L2385">            setFlag(WIF_INPUTMAP_CREATED, true);</span>
<span class="nc" id="L2386">            registerWithKeyboardManager(false);</span>
<span class="nc" id="L2387">            break;</span>
        case WHEN_ANCESTOR_OF_FOCUSED_COMPONENT:
<span class="nc" id="L2389">            ancestorInputMap = map;</span>
<span class="nc" id="L2390">            setFlag(ANCESTOR_INPUTMAP_CREATED, true);</span>
<span class="nc" id="L2391">            break;</span>
        case WHEN_FOCUSED:
<span class="nc" id="L2393">            focusInputMap = map;</span>
<span class="nc" id="L2394">            setFlag(FOCUS_INPUTMAP_CREATED, true);</span>
<span class="nc" id="L2395">            break;</span>
        default:
<span class="nc" id="L2397">            throw new IllegalArgumentException(&quot;condition must be one of JComponent.WHEN_IN_FOCUSED_WINDOW, JComponent.WHEN_FOCUSED or JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&quot;);</span>
        }
<span class="nc" id="L2399">    }</span>

    /**
     * Returns the &lt;code&gt;InputMap&lt;/code&gt; that is used during
     * &lt;code&gt;condition&lt;/code&gt;.
     *
     * @param condition one of WHEN_IN_FOCUSED_WINDOW, WHEN_FOCUSED,
     *        WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
     * @return the &lt;code&gt;InputMap&lt;/code&gt; for the specified
     *          &lt;code&gt;condition&lt;/code&gt;
     * @since 1.3
     */
    public final InputMap getInputMap(int condition) {
<span class="nc" id="L2412">        return getInputMap(condition, true);</span>
    }

    /**
     * Returns the &lt;code&gt;InputMap&lt;/code&gt; that is used when the
     * component has focus.
     * This is convenience method for &lt;code&gt;getInputMap(WHEN_FOCUSED)&lt;/code&gt;.
     *
     * @return the &lt;code&gt;InputMap&lt;/code&gt; used when the component has focus
     * @since 1.3
     */
    public final InputMap getInputMap() {
<span class="nc" id="L2424">        return getInputMap(WHEN_FOCUSED, true);</span>
    }

    /**
     * Sets the &lt;code&gt;ActionMap&lt;/code&gt; to &lt;code&gt;am&lt;/code&gt;. This does not set
     * the parent of the &lt;code&gt;am&lt;/code&gt; to be the &lt;code&gt;ActionMap&lt;/code&gt;
     * from the UI (if there was one), it is up to the caller to have done this.
     *
     * @param am  the new &lt;code&gt;ActionMap&lt;/code&gt;
     * @since 1.3
     */
    public final void setActionMap(ActionMap am) {
<span class="nc" id="L2436">        actionMap = am;</span>
<span class="nc" id="L2437">        setFlag(ACTIONMAP_CREATED, true);</span>
<span class="nc" id="L2438">    }</span>

    /**
     * Returns the &lt;code&gt;ActionMap&lt;/code&gt; used to determine what
     * &lt;code&gt;Action&lt;/code&gt; to fire for particular &lt;code&gt;KeyStroke&lt;/code&gt;
     * binding. The returned &lt;code&gt;ActionMap&lt;/code&gt;, unless otherwise
     * set, will have the &lt;code&gt;ActionMap&lt;/code&gt; from the UI set as the parent.
     *
     * @return the &lt;code&gt;ActionMap&lt;/code&gt; containing the key/action bindings
     * @since 1.3
     */
    public final ActionMap getActionMap() {
<span class="nc" id="L2450">        return getActionMap(true);</span>
    }

    /**
     * Returns the &lt;code&gt;InputMap&lt;/code&gt; to use for condition
     * &lt;code&gt;condition&lt;/code&gt;.  If the &lt;code&gt;InputMap&lt;/code&gt; hasn't
     * been created, and &lt;code&gt;create&lt;/code&gt; is
     * true, it will be created.
     *
     * @param condition one of the following values:
     * &lt;ul&gt;
     * &lt;li&gt;JComponent.FOCUS_INPUTMAP_CREATED
     * &lt;li&gt;JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
     * &lt;li&gt;JComponent.WHEN_IN_FOCUSED_WINDOW
     * &lt;/ul&gt;
     * @param create if true, create the &lt;code&gt;InputMap&lt;/code&gt; if it
     *          is not already created
     * @return the &lt;code&gt;InputMap&lt;/code&gt; for the given &lt;code&gt;condition&lt;/code&gt;;
     *          if &lt;code&gt;create&lt;/code&gt; is false and the &lt;code&gt;InputMap&lt;/code&gt;
     *          hasn't been created, returns &lt;code&gt;null&lt;/code&gt;
     * @exception IllegalArgumentException if &lt;code&gt;condition&lt;/code&gt;
     *          is not one of the legal values listed above
     */
    final InputMap getInputMap(int condition, boolean create) {
<span class="nc bnc" id="L2474" title="All 4 branches missed.">        switch (condition) {</span>
        case WHEN_FOCUSED:
<span class="nc bnc" id="L2476" title="All 2 branches missed.">            if (getFlag(FOCUS_INPUTMAP_CREATED)) {</span>
<span class="nc" id="L2477">                return focusInputMap;</span>
            }
            // Hasn't been created yet.
<span class="nc bnc" id="L2480" title="All 2 branches missed.">            if (create) {</span>
<span class="nc" id="L2481">                InputMap km = new InputMap();</span>
<span class="nc" id="L2482">                setInputMap(condition, km);</span>
<span class="nc" id="L2483">                return km;</span>
            }
            break;
        case WHEN_ANCESTOR_OF_FOCUSED_COMPONENT:
<span class="nc bnc" id="L2487" title="All 2 branches missed.">            if (getFlag(ANCESTOR_INPUTMAP_CREATED)) {</span>
<span class="nc" id="L2488">                return ancestorInputMap;</span>
            }
            // Hasn't been created yet.
<span class="nc bnc" id="L2491" title="All 2 branches missed.">            if (create) {</span>
<span class="nc" id="L2492">                InputMap km = new InputMap();</span>
<span class="nc" id="L2493">                setInputMap(condition, km);</span>
<span class="nc" id="L2494">                return km;</span>
            }
            break;
        case WHEN_IN_FOCUSED_WINDOW:
<span class="nc bnc" id="L2498" title="All 2 branches missed.">            if (getFlag(WIF_INPUTMAP_CREATED)) {</span>
<span class="nc" id="L2499">                return windowInputMap;</span>
            }
            // Hasn't been created yet.
<span class="nc bnc" id="L2502" title="All 2 branches missed.">            if (create) {</span>
<span class="nc" id="L2503">                ComponentInputMap km = new ComponentInputMap(this);</span>
<span class="nc" id="L2504">                setInputMap(condition, km);</span>
<span class="nc" id="L2505">                return km;</span>
            }
            break;
        default:
<span class="nc" id="L2509">            throw new IllegalArgumentException(&quot;condition must be one of JComponent.WHEN_IN_FOCUSED_WINDOW, JComponent.WHEN_FOCUSED or JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&quot;);</span>
        }
<span class="nc" id="L2511">        return null;</span>
    }

    /**
     * Finds and returns the appropriate &lt;code&gt;ActionMap&lt;/code&gt;.
     *
     * @param create if true, create the &lt;code&gt;ActionMap&lt;/code&gt; if it
     *          is not already created
     * @return the &lt;code&gt;ActionMap&lt;/code&gt; for this component; if the
     *          &lt;code&gt;create&lt;/code&gt; flag is false and there is no
     *          current &lt;code&gt;ActionMap&lt;/code&gt;, returns &lt;code&gt;null&lt;/code&gt;
     */
    final ActionMap getActionMap(boolean create) {
<span class="nc bnc" id="L2524" title="All 2 branches missed.">        if (getFlag(ACTIONMAP_CREATED)) {</span>
<span class="nc" id="L2525">            return actionMap;</span>
        }
        // Hasn't been created.
<span class="nc bnc" id="L2528" title="All 2 branches missed.">        if (create) {</span>
<span class="nc" id="L2529">            ActionMap am = new ActionMap();</span>
<span class="nc" id="L2530">            setActionMap(am);</span>
<span class="nc" id="L2531">            return am;</span>
        }
<span class="nc" id="L2533">        return null;</span>
    }

    /**
     * Returns the baseline.  The baseline is measured from the top of
     * the component.  This method is primarily meant for
     * &lt;code&gt;LayoutManager&lt;/code&gt;s to align components along their
     * baseline.  A return value less than 0 indicates this component
     * does not have a reasonable baseline and that
     * &lt;code&gt;LayoutManager&lt;/code&gt;s should not align this component on
     * its baseline.
     * &lt;p&gt;
     * This method calls into the &lt;code&gt;ComponentUI&lt;/code&gt; method of the
     * same name.  If this component does not have a &lt;code&gt;ComponentUI&lt;/code&gt;
     * -1 will be returned.  If a value &amp;gt;= 0 is
     * returned, then the component has a valid baseline for any
     * size &amp;gt;= the minimum size and &lt;code&gt;getBaselineResizeBehavior&lt;/code&gt;
     * can be used to determine how the baseline changes with size.
     *
     * @throws IllegalArgumentException {@inheritDoc}
     * @see #getBaselineResizeBehavior
     * @see java.awt.FontMetrics
     * @since 1.6
     */
    public int getBaseline(int width, int height) {
        // check size.
<span class="nc" id="L2559">        super.getBaseline(width, height);</span>
<span class="nc bnc" id="L2560" title="All 2 branches missed.">        if (ui != null) {</span>
<span class="nc" id="L2561">            return ui.getBaseline(this, width, height);</span>
        }
<span class="nc" id="L2563">        return -1;</span>
    }

    /**
     * Returns an enum indicating how the baseline of the component
     * changes as the size changes.  This method is primarily meant for
     * layout managers and GUI builders.
     * &lt;p&gt;
     * This method calls into the &lt;code&gt;ComponentUI&lt;/code&gt; method of
     * the same name.  If this component does not have a
     * &lt;code&gt;ComponentUI&lt;/code&gt;
     * &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt; will be
     * returned.  Subclasses should
     * never return &lt;code&gt;null&lt;/code&gt;; if the baseline can not be
     * calculated return &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt;.  Callers
     * should first ask for the baseline using
     * &lt;code&gt;getBaseline&lt;/code&gt; and if a value &amp;gt;= 0 is returned use
     * this method.  It is acceptable for this method to return a
     * value other than &lt;code&gt;BaselineResizeBehavior.OTHER&lt;/code&gt; even if
     * &lt;code&gt;getBaseline&lt;/code&gt; returns a value less than 0.
     *
     * @see #getBaseline(int, int)
     * @since 1.6
     */
    public BaselineResizeBehavior getBaselineResizeBehavior() {
<span class="nc bnc" id="L2588" title="All 2 branches missed.">        if (ui != null) {</span>
<span class="nc" id="L2589">            return ui.getBaselineResizeBehavior(this);</span>
        }
<span class="nc" id="L2591">        return BaselineResizeBehavior.OTHER;</span>
    }

    /**
     * In release 1.4, the focus subsystem was rearchitected.
     * For more information, see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/misc/focus.html&quot;&gt;
     * How to Use the Focus Subsystem&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;.
     * &lt;p&gt;
     * Requests focus on this &lt;code&gt;JComponent&lt;/code&gt;'s
     * &lt;code&gt;FocusTraversalPolicy&lt;/code&gt;'s default &lt;code&gt;Component&lt;/code&gt;.
     * If this &lt;code&gt;JComponent&lt;/code&gt; is a focus cycle root, then its
     * &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; is used. Otherwise, the
     * &lt;code&gt;FocusTraversalPolicy&lt;/code&gt; of this &lt;code&gt;JComponent&lt;/code&gt;'s
     * focus-cycle-root ancestor is used.
     *
     * @see java.awt.FocusTraversalPolicy#getDefaultComponent
     * @deprecated As of 1.4, replaced by
     * &lt;code&gt;FocusTraversalPolicy.getDefaultComponent(Container).requestFocus()&lt;/code&gt;
     */
    @Deprecated
    public boolean requestDefaultFocus() {
<span class="nc" id="L2614">        Container nearestRoot =</span>
<span class="nc bnc" id="L2615" title="All 2 branches missed.">            (isFocusCycleRoot()) ? this : getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L2616" title="All 2 branches missed.">        if (nearestRoot == null) {</span>
<span class="nc" id="L2617">            return false;</span>
        }
<span class="nc" id="L2619">        Component comp = nearestRoot.getFocusTraversalPolicy().</span>
<span class="nc" id="L2620">            getDefaultComponent(nearestRoot);</span>
<span class="nc bnc" id="L2621" title="All 2 branches missed.">        if (comp != null) {</span>
<span class="nc" id="L2622">            comp.requestFocus();</span>
<span class="nc" id="L2623">            return true;</span>
        } else {
<span class="nc" id="L2625">            return false;</span>
        }
    }

    /**
     * Makes the component visible or invisible.
     * Overrides &lt;code&gt;Component.setVisible&lt;/code&gt;.
     *
     * @param aFlag  true to make the component visible; false to
     *          make it invisible
     *
     * @beaninfo
     *    attribute: visualUpdate true
     */
    public void setVisible(boolean aFlag) {
<span class="nc bnc" id="L2640" title="All 2 branches missed.">        if (aFlag != isVisible()) {</span>
<span class="nc" id="L2641">            super.setVisible(aFlag);</span>
<span class="nc bnc" id="L2642" title="All 2 branches missed.">            if (aFlag) {</span>
<span class="nc" id="L2643">                Container parent = getParent();</span>
<span class="nc bnc" id="L2644" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L2645">                    Rectangle r = getBounds();</span>
<span class="nc" id="L2646">                    parent.repaint(r.x, r.y, r.width, r.height);</span>
                }
<span class="nc" id="L2648">                revalidate();</span>
            }
        }
<span class="nc" id="L2651">    }</span>

    /**
     * Sets whether or not this component is enabled.
     * A component that is enabled may respond to user input,
     * while a component that is not enabled cannot respond to
     * user input.  Some components may alter their visual
     * representation when they are disabled in order to
     * provide feedback to the user that they cannot take input.
     * &lt;p&gt;Note: Disabling a component does not disable its children.
     *
     * &lt;p&gt;Note: Disabling a lightweight component does not prevent it from
     * receiving MouseEvents.
     *
     * @param enabled true if this component should be enabled, false otherwise
     * @see java.awt.Component#isEnabled
     * @see java.awt.Component#isLightweight
     *
     * @beaninfo
     *    preferred: true
     *        bound: true
     *    attribute: visualUpdate true
     *  description: The enabled state of the component.
     */
    public void setEnabled(boolean enabled) {
<span class="nc" id="L2676">        boolean oldEnabled = isEnabled();</span>
<span class="nc" id="L2677">        super.setEnabled(enabled);</span>
<span class="nc" id="L2678">        firePropertyChange(&quot;enabled&quot;, oldEnabled, enabled);</span>
<span class="nc bnc" id="L2679" title="All 2 branches missed.">        if (enabled != oldEnabled) {</span>
<span class="nc" id="L2680">            repaint();</span>
        }
<span class="nc" id="L2682">    }</span>

    /**
     * Sets the foreground color of this component.  It is up to the
     * look and feel to honor this property, some may choose to ignore
     * it.
     *
     * @param fg  the desired foreground &lt;code&gt;Color&lt;/code&gt;
     * @see java.awt.Component#getForeground
     *
     * @beaninfo
     *    preferred: true
     *        bound: true
     *    attribute: visualUpdate true
     *  description: The foreground color of the component.
     */
    public void setForeground(Color fg) {
<span class="nc" id="L2699">        Color oldFg = getForeground();</span>
<span class="nc" id="L2700">        super.setForeground(fg);</span>
<span class="nc bnc" id="L2701" title="All 8 branches missed.">        if ((oldFg != null) ? !oldFg.equals(fg) : ((fg != null) &amp;&amp; !fg.equals(oldFg))) {</span>
            // foreground already bound in AWT1.2
<span class="nc" id="L2703">            repaint();</span>
        }
<span class="nc" id="L2705">    }</span>

    /**
     * Sets the background color of this component.  The background
     * color is used only if the component is opaque, and only
     * by subclasses of &lt;code&gt;JComponent&lt;/code&gt; or
     * &lt;code&gt;ComponentUI&lt;/code&gt; implementations.  Direct subclasses of
     * &lt;code&gt;JComponent&lt;/code&gt; must override
     * &lt;code&gt;paintComponent&lt;/code&gt; to honor this property.
     * &lt;p&gt;
     * It is up to the look and feel to honor this property, some may
     * choose to ignore it.
     *
     * @param bg the desired background &lt;code&gt;Color&lt;/code&gt;
     * @see java.awt.Component#getBackground
     * @see #setOpaque
     *
     * @beaninfo
     *    preferred: true
     *        bound: true
     *    attribute: visualUpdate true
     *  description: The background color of the component.
     */
    public void setBackground(Color bg) {
<span class="nc" id="L2729">        Color oldBg = getBackground();</span>
<span class="nc" id="L2730">        super.setBackground(bg);</span>
<span class="nc bnc" id="L2731" title="All 8 branches missed.">        if ((oldBg != null) ? !oldBg.equals(bg) : ((bg != null) &amp;&amp; !bg.equals(oldBg))) {</span>
            // background already bound in AWT1.2
<span class="nc" id="L2733">            repaint();</span>
        }
<span class="nc" id="L2735">    }</span>

    /**
     * Sets the font for this component.
     *
     * @param font the desired &lt;code&gt;Font&lt;/code&gt; for this component
     * @see java.awt.Component#getFont
     *
     * @beaninfo
     *    preferred: true
     *        bound: true
     *    attribute: visualUpdate true
     *  description: The font for the component.
     */
    public void setFont(Font font) {
<span class="nc" id="L2750">        Font oldFont = getFont();</span>
<span class="nc" id="L2751">        super.setFont(font);</span>
        // font already bound in AWT1.2
<span class="nc bnc" id="L2753" title="All 2 branches missed.">        if (font != oldFont) {</span>
<span class="nc" id="L2754">            revalidate();</span>
<span class="nc" id="L2755">            repaint();</span>
        }
<span class="nc" id="L2757">    }</span>

    /**
     * Returns the default locale used to initialize each JComponent's
     * locale property upon creation.
     *
     * The default locale has &quot;AppContext&quot; scope so that applets (and
     * potentially multiple lightweight applications running in a single VM)
     * can have their own setting. An applet can safely alter its default
     * locale because it will have no affect on other applets (or the browser).
     *
     * @return the default &lt;code&gt;Locale&lt;/code&gt;.
     * @see #setDefaultLocale
     * @see java.awt.Component#getLocale
     * @see #setLocale
     * @since 1.4
     */
    static public Locale getDefaultLocale() {
<span class="nc" id="L2775">        Locale l = (Locale) SwingUtilities.appContextGet(defaultLocale);</span>
<span class="nc bnc" id="L2776" title="All 2 branches missed.">        if( l == null ) {</span>
            //REMIND(bcb) choosing the default value is more complicated
            //than this.
<span class="nc" id="L2779">            l = Locale.getDefault();</span>
<span class="nc" id="L2780">            JComponent.setDefaultLocale( l );</span>
        }
<span class="nc" id="L2782">        return l;</span>
    }


    /**
     * Sets the default locale used to initialize each JComponent's locale
     * property upon creation.  The initial value is the VM's default locale.
     *
     * The default locale has &quot;AppContext&quot; scope so that applets (and
     * potentially multiple lightweight applications running in a single VM)
     * can have their own setting. An applet can safely alter its default
     * locale because it will have no affect on other applets (or the browser).
     *
     * @param l the desired default &lt;code&gt;Locale&lt;/code&gt; for new components.
     * @see #getDefaultLocale
     * @see java.awt.Component#getLocale
     * @see #setLocale
     * @since 1.4
     */
    static public void setDefaultLocale( Locale l ) {
<span class="nc" id="L2802">        SwingUtilities.appContextPut(defaultLocale, l);</span>
<span class="nc" id="L2803">    }</span>


    /**
     * Processes any key events that the component itself
     * recognizes.  This is called after the focus
     * manager and any interested listeners have been
     * given a chance to steal away the event.  This
     * method is called only if the event has not
     * yet been consumed.  This method is called prior
     * to the keyboard UI logic.
     * &lt;p&gt;
     * This method is implemented to do nothing.  Subclasses would
     * normally override this method if they process some
     * key events themselves.  If the event is processed,
     * it should be consumed.
     */
    protected void processComponentKeyEvent(KeyEvent e) {
<span class="nc" id="L2821">    }</span>

    /** Overrides &lt;code&gt;processKeyEvent&lt;/code&gt; to process events. **/
    protected void processKeyEvent(KeyEvent e) {
      boolean result;
      boolean shouldProcessKey;

      // This gives the key event listeners a crack at the event
<span class="nc" id="L2829">      super.processKeyEvent(e);</span>

      // give the component itself a crack at the event
<span class="nc bnc" id="L2832" title="All 2 branches missed.">      if (! e.isConsumed()) {</span>
<span class="nc" id="L2833">          processComponentKeyEvent(e);</span>
      }

<span class="nc" id="L2836">      shouldProcessKey = KeyboardState.shouldProcess(e);</span>

<span class="nc bnc" id="L2838" title="All 2 branches missed.">      if(e.isConsumed()) {</span>
<span class="nc" id="L2839">        return;</span>
      }

<span class="nc bnc" id="L2842" title="All 6 branches missed.">      if (shouldProcessKey &amp;&amp; processKeyBindings(e, e.getID() ==</span>
                                                 KeyEvent.KEY_PRESSED)) {
<span class="nc" id="L2844">          e.consume();</span>
      }
<span class="nc" id="L2846">    }</span>

    /**
     * Invoked to process the key bindings for &lt;code&gt;ks&lt;/code&gt; as the result
     * of the &lt;code&gt;KeyEvent&lt;/code&gt; &lt;code&gt;e&lt;/code&gt;. This obtains
     * the appropriate &lt;code&gt;InputMap&lt;/code&gt;,
     * gets the binding, gets the action from the &lt;code&gt;ActionMap&lt;/code&gt;,
     * and then (if the action is found and the component
     * is enabled) invokes &lt;code&gt;notifyAction&lt;/code&gt; to notify the action.
     *
     * @param ks  the &lt;code&gt;KeyStroke&lt;/code&gt; queried
     * @param e the &lt;code&gt;KeyEvent&lt;/code&gt;
     * @param condition one of the following values:
     * &lt;ul&gt;
     * &lt;li&gt;JComponent.WHEN_FOCUSED
     * &lt;li&gt;JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT
     * &lt;li&gt;JComponent.WHEN_IN_FOCUSED_WINDOW
     * &lt;/ul&gt;
     * @param pressed true if the key is pressed
     * @return true if there was a binding to an action, and the action
     *         was enabled
     *
     * @since 1.3
     */
    protected boolean processKeyBinding(KeyStroke ks, KeyEvent e,
                                        int condition, boolean pressed) {
<span class="nc" id="L2872">        InputMap map = getInputMap(condition, false);</span>
<span class="nc" id="L2873">        ActionMap am = getActionMap(false);</span>

<span class="nc bnc" id="L2875" title="All 6 branches missed.">        if(map != null &amp;&amp; am != null &amp;&amp; isEnabled()) {</span>
<span class="nc" id="L2876">            Object binding = map.get(ks);</span>
<span class="nc bnc" id="L2877" title="All 2 branches missed.">            Action action = (binding == null) ? null : am.get(binding);</span>
<span class="nc bnc" id="L2878" title="All 2 branches missed.">            if (action != null) {</span>
<span class="nc" id="L2879">                return SwingUtilities.notifyAction(action, ks, e, this,</span>
<span class="nc" id="L2880">                                                   e.getModifiers());</span>
            }
        }
<span class="nc" id="L2883">        return false;</span>
    }

    /**
     * This is invoked as the result of a &lt;code&gt;KeyEvent&lt;/code&gt;
     * that was not consumed by the &lt;code&gt;FocusManager&lt;/code&gt;,
     * &lt;code&gt;KeyListeners&lt;/code&gt;, or the component. It will first try
     * &lt;code&gt;WHEN_FOCUSED&lt;/code&gt; bindings,
     * then &lt;code&gt;WHEN_ANCESTOR_OF_FOCUSED_COMPONENT&lt;/code&gt; bindings,
     * and finally &lt;code&gt;WHEN_IN_FOCUSED_WINDOW&lt;/code&gt; bindings.
     *
     * @param e the unconsumed &lt;code&gt;KeyEvent&lt;/code&gt;
     * @param pressed true if the key is pressed
     * @return true if there is a key binding for &lt;code&gt;e&lt;/code&gt;
     */
    boolean processKeyBindings(KeyEvent e, boolean pressed) {
<span class="nc bnc" id="L2899" title="All 2 branches missed.">      if (!SwingUtilities.isValidKeyEventForKeyBindings(e)) {</span>
<span class="nc" id="L2900">          return false;</span>
      }
      // Get the KeyStroke
      // There may be two keystrokes associated with a low-level key event;
      // in this case a keystroke made of an extended key code has a priority.
      KeyStroke ks;
<span class="nc" id="L2906">      KeyStroke ksE = null;</span>

<span class="nc bnc" id="L2908" title="All 2 branches missed.">      if (e.getID() == KeyEvent.KEY_TYPED) {</span>
<span class="nc" id="L2909">          ks = KeyStroke.getKeyStroke(e.getKeyChar());</span>
      }
      else {
<span class="nc bnc" id="L2912" title="All 2 branches missed.">          ks = KeyStroke.getKeyStroke(e.getKeyCode(),e.getModifiers(),</span>
                                    (pressed ? false:true));
<span class="nc bnc" id="L2914" title="All 2 branches missed.">          if (e.getKeyCode() != e.getExtendedKeyCode()) {</span>
<span class="nc bnc" id="L2915" title="All 2 branches missed.">              ksE = KeyStroke.getKeyStroke(e.getExtendedKeyCode(),e.getModifiers(),</span>
                                    (pressed ? false:true));
          }
      }

      // Do we have a key binding for e?
      // If we have a binding by an extended code, use it.
      // If not, check for regular code binding.
<span class="nc bnc" id="L2923" title="All 4 branches missed.">      if(ksE != null &amp;&amp; processKeyBinding(ksE, e, WHEN_FOCUSED, pressed)) {</span>
<span class="nc" id="L2924">          return true;</span>
      }
<span class="nc bnc" id="L2926" title="All 2 branches missed.">      if(processKeyBinding(ks, e, WHEN_FOCUSED, pressed))</span>
<span class="nc" id="L2927">          return true;</span>

      /* We have no key binding. Let's try the path from our parent to the
       * window excluded. We store the path components so we can avoid
       * asking the same component twice.
       */
<span class="nc" id="L2933">      Container parent = this;</span>
<span class="nc bnc" id="L2934" title="All 6 branches missed.">      while (parent != null &amp;&amp; !(parent instanceof Window) &amp;&amp;</span>
             !(parent instanceof Applet)) {
<span class="nc bnc" id="L2936" title="All 2 branches missed.">          if(parent instanceof JComponent) {</span>
<span class="nc bnc" id="L2937" title="All 4 branches missed.">              if(ksE != null &amp;&amp; ((JComponent)parent).processKeyBinding(ksE, e,</span>
                               WHEN_ANCESTOR_OF_FOCUSED_COMPONENT, pressed))
<span class="nc" id="L2939">                  return true;</span>
<span class="nc bnc" id="L2940" title="All 2 branches missed.">              if(((JComponent)parent).processKeyBinding(ks, e,</span>
                               WHEN_ANCESTOR_OF_FOCUSED_COMPONENT, pressed))
<span class="nc" id="L2942">                  return true;</span>
          }
          // This is done so that the children of a JInternalFrame are
          // given precedence for WHEN_IN_FOCUSED_WINDOW bindings before
          // other components WHEN_IN_FOCUSED_WINDOW bindings. This also gives
          // more precedence to the WHEN_IN_FOCUSED_WINDOW bindings of the
          // JInternalFrame's children vs the
          // WHEN_ANCESTOR_OF_FOCUSED_COMPONENT bindings of the parents.
          // maybe generalize from JInternalFrame (like isFocusCycleRoot).
<span class="nc bnc" id="L2951" title="All 2 branches missed.">          if ((parent instanceof JInternalFrame) &amp;&amp;</span>
<span class="nc bnc" id="L2952" title="All 2 branches missed.">              JComponent.processKeyBindingsForAllComponents(e,parent,pressed)){</span>
<span class="nc" id="L2953">              return true;</span>
          }
<span class="nc" id="L2955">          parent = parent.getParent();</span>
      }

      /* No components between the focused component and the window is
       * actually interested by the key event. Let's try the other
       * JComponent in this window.
       */
<span class="nc bnc" id="L2962" title="All 2 branches missed.">      if(parent != null) {</span>
<span class="nc" id="L2963">        return JComponent.processKeyBindingsForAllComponents(e,parent,pressed);</span>
      }
<span class="nc" id="L2965">      return false;</span>
    }

    static boolean processKeyBindingsForAllComponents(KeyEvent e,
                                      Container container, boolean pressed) {
        while (true) {
<span class="nc bnc" id="L2971" title="All 2 branches missed.">            if (KeyboardManager.getCurrentManager().fireKeyboardAction(</span>
                                e, pressed, container)) {
<span class="nc" id="L2973">                return true;</span>
            }
<span class="nc bnc" id="L2975" title="All 2 branches missed.">            if (container instanceof Popup.HeavyWeightWindow) {</span>
<span class="nc" id="L2976">                container = ((Window)container).getOwner();</span>
            }
            else {
<span class="nc" id="L2979">                return false;</span>
            }
        }
    }

    /**
     * Registers the text to display in a tool tip.
     * The text displays when the cursor lingers over the component.
     * &lt;p&gt;
     * See &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/tooltip.html&quot;&gt;How to Use Tool Tips&lt;/a&gt;
     * in &lt;em&gt;The Java Tutorial&lt;/em&gt;
     * for further documentation.
     *
     * @param text  the string to display; if the text is &lt;code&gt;null&lt;/code&gt;,
     *              the tool tip is turned off for this component
     * @see #TOOL_TIP_TEXT_KEY
     * @beaninfo
     *   preferred: true
     * description: The text to display in a tool tip.
     */
    public void setToolTipText(String text) {
<span class="nc" id="L3000">        String oldText = getToolTipText();</span>
<span class="nc" id="L3001">        putClientProperty(TOOL_TIP_TEXT_KEY, text);</span>
<span class="nc" id="L3002">        ToolTipManager toolTipManager = ToolTipManager.sharedInstance();</span>
<span class="nc bnc" id="L3003" title="All 2 branches missed.">        if (text != null) {</span>
<span class="nc bnc" id="L3004" title="All 2 branches missed.">            if (oldText == null) {</span>
<span class="nc" id="L3005">                toolTipManager.registerComponent(this);</span>
            }
        } else {
<span class="nc" id="L3008">            toolTipManager.unregisterComponent(this);</span>
        }
<span class="nc" id="L3010">    }</span>

    /**
     * Returns the tooltip string that has been set with
     * &lt;code&gt;setToolTipText&lt;/code&gt;.
     *
     * @return the text of the tool tip
     * @see #TOOL_TIP_TEXT_KEY
     */
    public String getToolTipText() {
<span class="nc" id="L3020">        return (String)getClientProperty(TOOL_TIP_TEXT_KEY);</span>
    }


    /**
     * Returns the string to be used as the tooltip for &lt;i&gt;event&lt;/i&gt;.
     * By default this returns any string set using
     * &lt;code&gt;setToolTipText&lt;/code&gt;.  If a component provides
     * more extensive API to support differing tooltips at different locations,
     * this method should be overridden.
     */
    public String getToolTipText(MouseEvent event) {
<span class="nc" id="L3032">        return getToolTipText();</span>
    }

    /**
     * Returns the tooltip location in this component's coordinate system.
     * If &lt;code&gt;null&lt;/code&gt; is returned, Swing will choose a location.
     * The default implementation returns &lt;code&gt;null&lt;/code&gt;.
     *
     * @param event  the &lt;code&gt;MouseEvent&lt;/code&gt; that caused the
     *          &lt;code&gt;ToolTipManager&lt;/code&gt; to show the tooltip
     * @return always returns &lt;code&gt;null&lt;/code&gt;
     */
    public Point getToolTipLocation(MouseEvent event) {
<span class="nc" id="L3045">        return null;</span>
    }

    /**
     * Returns the preferred location to display the popup menu in this
     * component's coordinate system. It is up to the look and feel to
     * honor this property, some may choose to ignore it.
     * If {@code null}, the look and feel will choose a suitable location.
     *
     * @param event the {@code MouseEvent} that triggered the popup to be
     *        shown, or {@code null} if the popup is not being shown as the
     *        result of a mouse event
     * @return location to display the {@code JPopupMenu}, or {@code null}
     * @since 1.5
     */
    public Point getPopupLocation(MouseEvent event) {
<span class="nc" id="L3061">        return null;</span>
    }


    /**
     * Returns the instance of &lt;code&gt;JToolTip&lt;/code&gt; that should be used
     * to display the tooltip.
     * Components typically would not override this method,
     * but it can be used to
     * cause different tooltips to be displayed differently.
     *
     * @return the &lt;code&gt;JToolTip&lt;/code&gt; used to display this toolTip
     */
    public JToolTip createToolTip() {
<span class="nc" id="L3075">        JToolTip tip = new JToolTip();</span>
<span class="nc" id="L3076">        tip.setComponent(this);</span>
<span class="nc" id="L3077">        return tip;</span>
    }

    /**
     * Forwards the &lt;code&gt;scrollRectToVisible()&lt;/code&gt; message to the
     * &lt;code&gt;JComponent&lt;/code&gt;'s parent. Components that can service
     * the request, such as &lt;code&gt;JViewport&lt;/code&gt;,
     * override this method and perform the scrolling.
     *
     * @param aRect the visible &lt;code&gt;Rectangle&lt;/code&gt;
     * @see JViewport
     */
    public void scrollRectToVisible(Rectangle aRect) {
        Container parent;
<span class="nc" id="L3091">        int dx = getX(), dy = getY();</span>

<span class="nc" id="L3093">        for (parent = getParent();</span>
                 !(parent == null) &amp;&amp;
<span class="nc bnc" id="L3095" title="All 6 branches missed.">                 !(parent instanceof JComponent) &amp;&amp;</span>
                 !(parent instanceof CellRendererPane);
<span class="nc" id="L3097">             parent = parent.getParent()) {</span>
<span class="nc" id="L3098">             Rectangle bounds = parent.getBounds();</span>

<span class="nc" id="L3100">             dx += bounds.x;</span>
<span class="nc" id="L3101">             dy += bounds.y;</span>
        }

<span class="nc bnc" id="L3104" title="All 4 branches missed.">        if (!(parent == null) &amp;&amp; !(parent instanceof CellRendererPane)) {</span>
<span class="nc" id="L3105">            aRect.x += dx;</span>
<span class="nc" id="L3106">            aRect.y += dy;</span>

<span class="nc" id="L3108">            ((JComponent)parent).scrollRectToVisible(aRect);</span>
<span class="nc" id="L3109">            aRect.x -= dx;</span>
<span class="nc" id="L3110">            aRect.y -= dy;</span>
        }
<span class="nc" id="L3112">    }</span>

    /**
     * Sets the &lt;code&gt;autoscrolls&lt;/code&gt; property.
     * If &lt;code&gt;true&lt;/code&gt; mouse dragged events will be
     * synthetically generated when the mouse is dragged
     * outside of the component's bounds and mouse motion
     * has paused (while the button continues to be held
     * down). The synthetic events make it appear that the
     * drag gesture has resumed in the direction established when
     * the component's boundary was crossed.  Components that
     * support autoscrolling must handle &lt;code&gt;mouseDragged&lt;/code&gt;
     * events by calling &lt;code&gt;scrollRectToVisible&lt;/code&gt; with a
     * rectangle that contains the mouse event's location.  All of
     * the Swing components that support item selection and are
     * typically displayed in a &lt;code&gt;JScrollPane&lt;/code&gt;
     * (&lt;code&gt;JTable&lt;/code&gt;, &lt;code&gt;JList&lt;/code&gt;, &lt;code&gt;JTree&lt;/code&gt;,
     * &lt;code&gt;JTextArea&lt;/code&gt;, and &lt;code&gt;JEditorPane&lt;/code&gt;)
     * already handle mouse dragged events in this way.  To enable
     * autoscrolling in any other component, add a mouse motion
     * listener that calls &lt;code&gt;scrollRectToVisible&lt;/code&gt;.
     * For example, given a &lt;code&gt;JPanel&lt;/code&gt;, &lt;code&gt;myPanel&lt;/code&gt;:
     * &lt;pre&gt;
     * MouseMotionListener doScrollRectToVisible = new MouseMotionAdapter() {
     *     public void mouseDragged(MouseEvent e) {
     *        Rectangle r = new Rectangle(e.getX(), e.getY(), 1, 1);
     *        ((JPanel)e.getSource()).scrollRectToVisible(r);
     *    }
     * };
     * myPanel.addMouseMotionListener(doScrollRectToVisible);
     * &lt;/pre&gt;
     * The default value of the &lt;code&gt;autoScrolls&lt;/code&gt;
     * property is &lt;code&gt;false&lt;/code&gt;.
     *
     * @param autoscrolls if true, synthetic mouse dragged events
     *   are generated when the mouse is dragged outside of a component's
     *   bounds and the mouse button continues to be held down; otherwise
     *   false
     * @see #getAutoscrolls
     * @see JViewport
     * @see JScrollPane
     *
     * @beaninfo
     *      expert: true
     * description: Determines if this component automatically scrolls its contents when dragged.
     */
    public void setAutoscrolls(boolean autoscrolls) {
<span class="nc" id="L3159">        setFlag(AUTOSCROLLS_SET, true);</span>
<span class="nc bnc" id="L3160" title="All 2 branches missed.">        if (this.autoscrolls != autoscrolls) {</span>
<span class="nc" id="L3161">            this.autoscrolls = autoscrolls;</span>
<span class="nc bnc" id="L3162" title="All 2 branches missed.">            if (autoscrolls) {</span>
<span class="nc" id="L3163">                enableEvents(AWTEvent.MOUSE_EVENT_MASK);</span>
<span class="nc" id="L3164">                enableEvents(AWTEvent.MOUSE_MOTION_EVENT_MASK);</span>
            }
            else {
<span class="nc" id="L3167">                Autoscroller.stop(this);</span>
            }
        }
<span class="nc" id="L3170">    }</span>

    /**
     * Gets the &lt;code&gt;autoscrolls&lt;/code&gt; property.
     *
     * @return the value of the &lt;code&gt;autoscrolls&lt;/code&gt; property
     * @see JViewport
     * @see #setAutoscrolls
     */
    public boolean getAutoscrolls() {
<span class="nc" id="L3180">        return autoscrolls;</span>
    }

    /**
     * Sets the {@code TransferHandler}, which provides support for transfer
     * of data into and out of this component via cut/copy/paste and drag
     * and drop. This may be {@code null} if the component does not support
     * data transfer operations.
     * &lt;p&gt;
     * If the new {@code TransferHandler} is not {@code null}, this method
     * also installs a &lt;b&gt;new&lt;/b&gt; {@code DropTarget} on the component to
     * activate drop handling through the {@code TransferHandler} and activate
     * any built-in support (such as calculating and displaying potential drop
     * locations). If you do not wish for this component to respond in any way
     * to drops, you can disable drop support entirely either by removing the
     * drop target ({@code setDropTarget(null)}) or by de-activating it
     * ({@code getDropTaget().setActive(false)}).
     * &lt;p&gt;
     * If the new {@code TransferHandler} is {@code null}, this method removes
     * the drop target.
     * &lt;p&gt;
     * Under two circumstances, this method does not modify the drop target:
     * First, if the existing drop target on this component was explicitly
     * set by the developer to a {@code non-null} value. Second, if the
     * system property {@code suppressSwingDropSupport} is {@code true}. The
     * default value for the system property is {@code false}.
     * &lt;p&gt;
     * Please see
     * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/dnd/index.html&quot;&gt;
     * How to Use Drag and Drop and Data Transfer&lt;/a&gt;,
     * a section in &lt;em&gt;The Java Tutorial&lt;/em&gt;, for more information.
     *
     * @param newHandler the new {@code TransferHandler}
     *
     * @see TransferHandler
     * @see #getTransferHandler
     * @since 1.4
     * @beaninfo
     *        bound: true
     *       hidden: true
     *  description: Mechanism for transfer of data to and from the component
     */
    public void setTransferHandler(TransferHandler newHandler) {
<span class="nc" id="L3223">        TransferHandler oldHandler = (TransferHandler)getClientProperty(</span>
                                      JComponent_TRANSFER_HANDLER);
<span class="nc" id="L3225">        putClientProperty(JComponent_TRANSFER_HANDLER, newHandler);</span>

<span class="nc" id="L3227">        SwingUtilities.installSwingDropTargetAsNecessary(this, newHandler);</span>
<span class="nc" id="L3228">        firePropertyChange(&quot;transferHandler&quot;, oldHandler, newHandler);</span>
<span class="nc" id="L3229">    }</span>

    /**
     * Gets the &lt;code&gt;transferHandler&lt;/code&gt; property.
     *
     * @return  the value of the &lt;code&gt;transferHandler&lt;/code&gt; property
     *
     * @see TransferHandler
     * @see #setTransferHandler
     * @since 1.4
     */
    public TransferHandler getTransferHandler() {
<span class="nc" id="L3241">        return (TransferHandler)getClientProperty(JComponent_TRANSFER_HANDLER);</span>
    }

    /**
     * Calculates a custom drop location for this type of component,
     * representing where a drop at the given point should insert data.
     * &lt;code&gt;null&lt;/code&gt; is returned if this component doesn't calculate
     * custom drop locations. In this case, &lt;code&gt;TransferHandler&lt;/code&gt;
     * will provide a default &lt;code&gt;DropLocation&lt;/code&gt; containing just
     * the point.
     *
     * @param p the point to calculate a drop location for
     * @return the drop location, or &lt;code&gt;null&lt;/code&gt;
     */
    TransferHandler.DropLocation dropLocationForPoint(Point p) {
<span class="nc" id="L3256">        return null;</span>
    }

    /**
     * Called to set or clear the drop location during a DnD operation.
     * In some cases, the component may need to use its internal selection
     * temporarily to indicate the drop location. To help facilitate this,
     * this method returns and accepts as a parameter a state object.
     * This state object can be used to store, and later restore, the selection
     * state. Whatever this method returns will be passed back to it in
     * future calls, as the state parameter. If it wants the DnD system to
     * continue storing the same state, it must pass it back every time.
     * Here's how this is used:
     * &lt;p&gt;
     * Let's say that on the first call to this method the component decides
     * to save some state (because it is about to use the selection to show
     * a drop index). It can return a state object to the caller encapsulating
     * any saved selection state. On a second call, let's say the drop location
     * is being changed to something else. The component doesn't need to
     * restore anything yet, so it simply passes back the same state object
     * to have the DnD system continue storing it. Finally, let's say this
     * method is messaged with &lt;code&gt;null&lt;/code&gt;. This means DnD
     * is finished with this component for now, meaning it should restore
     * state. At this point, it can use the state parameter to restore
     * said state, and of course return &lt;code&gt;null&lt;/code&gt; since there's
     * no longer anything to store.
     *
     * @param location the drop location (as calculated by
     *        &lt;code&gt;dropLocationForPoint&lt;/code&gt;) or &lt;code&gt;null&lt;/code&gt;
     *        if there's no longer a valid drop location
     * @param state the state object saved earlier for this component,
     *        or &lt;code&gt;null&lt;/code&gt;
     * @param forDrop whether or not the method is being called because an
     *        actual drop occurred
     * @return any saved state for this component, or &lt;code&gt;null&lt;/code&gt; if none
     */
    Object setDropLocation(TransferHandler.DropLocation location,
                           Object state,
                           boolean forDrop) {

<span class="nc" id="L3296">        return null;</span>
    }

    /**
     * Called to indicate to this component that DnD is done.
     * Needed by &lt;code&gt;JTree&lt;/code&gt;.
     */
    void dndDone() {
<span class="nc" id="L3304">    }</span>

    /**
     * Processes mouse events occurring on this component by
     * dispatching them to any registered
     * &lt;code&gt;MouseListener&lt;/code&gt; objects, refer to
     * {@link java.awt.Component#processMouseEvent(MouseEvent)}
     * for a complete description of this method.
     *
     * @param       e the mouse event
     * @see         java.awt.Component#processMouseEvent
     * @since       1.5
     */
    protected void processMouseEvent(MouseEvent e) {
<span class="nc bnc" id="L3318" title="All 4 branches missed.">        if (autoscrolls &amp;&amp; e.getID() == MouseEvent.MOUSE_RELEASED) {</span>
<span class="nc" id="L3319">            Autoscroller.stop(this);</span>
        }
<span class="nc" id="L3321">        super.processMouseEvent(e);</span>
<span class="nc" id="L3322">    }</span>

    /**
     * Processes mouse motion events, such as MouseEvent.MOUSE_DRAGGED.
     *
     * @param e the &lt;code&gt;MouseEvent&lt;/code&gt;
     * @see MouseEvent
     */
    protected void processMouseMotionEvent(MouseEvent e) {
<span class="nc" id="L3331">        boolean dispatch = true;</span>
<span class="nc bnc" id="L3332" title="All 4 branches missed.">        if (autoscrolls &amp;&amp; e.getID() == MouseEvent.MOUSE_DRAGGED) {</span>
            // We don't want to do the drags when the mouse moves if we're
            // autoscrolling.  It makes it feel spastic.
<span class="nc bnc" id="L3335" title="All 2 branches missed.">            dispatch = !Autoscroller.isRunning(this);</span>
<span class="nc" id="L3336">            Autoscroller.processMouseDragged(e);</span>
        }
<span class="nc bnc" id="L3338" title="All 2 branches missed.">        if (dispatch) {</span>
<span class="nc" id="L3339">            super.processMouseMotionEvent(e);</span>
        }
<span class="nc" id="L3341">    }</span>

    // Inner classes can't get at this method from a super class
    void superProcessMouseMotionEvent(MouseEvent e) {
<span class="nc" id="L3345">        super.processMouseMotionEvent(e);</span>
<span class="nc" id="L3346">    }</span>

    /**
     * This is invoked by the &lt;code&gt;RepaintManager&lt;/code&gt; if
     * &lt;code&gt;createImage&lt;/code&gt; is called on the component.
     *
     * @param newValue true if the double buffer image was created from this component
     */
    void setCreatedDoubleBuffer(boolean newValue) {
<span class="nc" id="L3355">        setFlag(CREATED_DOUBLE_BUFFER, newValue);</span>
<span class="nc" id="L3356">    }</span>

    /**
     * Returns true if the &lt;code&gt;RepaintManager&lt;/code&gt;
     * created the double buffer image from the component.
     *
     * @return true if this component had a double buffer image, false otherwise
     */
    boolean getCreatedDoubleBuffer() {
<span class="nc" id="L3365">        return getFlag(CREATED_DOUBLE_BUFFER);</span>
    }

    /**
     * &lt;code&gt;ActionStandin&lt;/code&gt; is used as a standin for
     * &lt;code&gt;ActionListeners&lt;/code&gt; that are
     * added via &lt;code&gt;registerKeyboardAction&lt;/code&gt;.
     */
    final class ActionStandin implements Action {
        private final ActionListener actionListener;
        private final String command;
        // This will be non-null if actionListener is an Action.
        private final Action action;

<span class="nc" id="L3379">        ActionStandin(ActionListener actionListener, String command) {</span>
<span class="nc" id="L3380">            this.actionListener = actionListener;</span>
<span class="nc bnc" id="L3381" title="All 2 branches missed.">            if (actionListener instanceof Action) {</span>
<span class="nc" id="L3382">                this.action = (Action)actionListener;</span>
            }
            else {
<span class="nc" id="L3385">                this.action = null;</span>
            }
<span class="nc" id="L3387">            this.command = command;</span>
<span class="nc" id="L3388">        }</span>

        public Object getValue(String key) {
<span class="nc bnc" id="L3391" title="All 2 branches missed.">            if (key != null) {</span>
<span class="nc bnc" id="L3392" title="All 2 branches missed.">                if (key.equals(Action.ACTION_COMMAND_KEY)) {</span>
<span class="nc" id="L3393">                    return command;</span>
                }
<span class="nc bnc" id="L3395" title="All 2 branches missed.">                if (action != null) {</span>
<span class="nc" id="L3396">                    return action.getValue(key);</span>
                }
<span class="nc bnc" id="L3398" title="All 2 branches missed.">                if (key.equals(NAME)) {</span>
<span class="nc" id="L3399">                    return &quot;ActionStandin&quot;;</span>
                }
            }
<span class="nc" id="L3402">            return null;</span>
        }

        public boolean isEnabled() {
<span class="nc bnc" id="L3406" title="All 2 branches missed.">            if (actionListener == null) {</span>
                // This keeps the old semantics where
                // registerKeyboardAction(null) would essentialy remove
                // the binding. We don't remove the binding from the
                // InputMap as that would still allow parent InputMaps
                // bindings to be accessed.
<span class="nc" id="L3412">                return false;</span>
            }
<span class="nc bnc" id="L3414" title="All 2 branches missed.">            if (action == null) {</span>
<span class="nc" id="L3415">                return true;</span>
            }
<span class="nc" id="L3417">            return action.isEnabled();</span>
        }

        public void actionPerformed(ActionEvent ae) {
<span class="nc bnc" id="L3421" title="All 2 branches missed.">            if (actionListener != null) {</span>
<span class="nc" id="L3422">                actionListener.actionPerformed(ae);</span>
            }
<span class="nc" id="L3424">        }</span>

        // We don't allow any values to be added.
<span class="nc" id="L3427">        public void putValue(String key, Object value) {}</span>

        // Does nothing, our enabledness is determiend from our asociated
        // action.
<span class="nc" id="L3431">        public void setEnabled(boolean b) { }</span>

        public void addPropertyChangeListener
<span class="nc" id="L3434">                    (PropertyChangeListener listener) {}</span>
        public void removePropertyChangeListener
<span class="nc" id="L3436">                          (PropertyChangeListener listener) {}</span>
    }


    // This class is used by the KeyboardState class to provide a single
    // instance that can be stored in the AppContext.
<span class="nc" id="L3442">    static final class IntVector {</span>
<span class="nc" id="L3443">        int array[] = null;</span>
<span class="nc" id="L3444">        int count = 0;</span>
<span class="nc" id="L3445">        int capacity = 0;</span>

        int size() {
<span class="nc" id="L3448">            return count;</span>
        }

        int elementAt(int index) {
<span class="nc" id="L3452">            return array[index];</span>
        }

        void addElement(int value) {
<span class="nc bnc" id="L3456" title="All 2 branches missed.">            if (count == capacity) {</span>
<span class="nc" id="L3457">                capacity = (capacity + 2) * 2;</span>
<span class="nc" id="L3458">                int[] newarray = new int[capacity];</span>
<span class="nc bnc" id="L3459" title="All 2 branches missed.">                if (count &gt; 0) {</span>
<span class="nc" id="L3460">                    System.arraycopy(array, 0, newarray, 0, count);</span>
                }
<span class="nc" id="L3462">                array = newarray;</span>
            }
<span class="nc" id="L3464">            array[count++] = value;</span>
<span class="nc" id="L3465">        }</span>

        void setElementAt(int value, int index) {
<span class="nc" id="L3468">            array[index] = value;</span>
<span class="nc" id="L3469">        }</span>
    }

    @SuppressWarnings(&quot;serial&quot;)
<span class="nc" id="L3473">    static class KeyboardState implements Serializable {</span>
<span class="nc" id="L3474">        private static final Object keyCodesKey =</span>
            JComponent.KeyboardState.class;

        // Get the array of key codes from the AppContext.
        static IntVector getKeyCodeArray() {
<span class="nc" id="L3479">            IntVector iv =</span>
<span class="nc" id="L3480">                (IntVector)SwingUtilities.appContextGet(keyCodesKey);</span>
<span class="nc bnc" id="L3481" title="All 2 branches missed.">            if (iv == null) {</span>
<span class="nc" id="L3482">                iv = new IntVector();</span>
<span class="nc" id="L3483">                SwingUtilities.appContextPut(keyCodesKey, iv);</span>
            }
<span class="nc" id="L3485">            return iv;</span>
        }

        static void registerKeyPressed(int keyCode) {
<span class="nc" id="L3489">            IntVector kca = getKeyCodeArray();</span>
<span class="nc" id="L3490">            int count = kca.size();</span>
            int i;
<span class="nc bnc" id="L3492" title="All 2 branches missed.">            for(i=0;i&lt;count;i++) {</span>
<span class="nc bnc" id="L3493" title="All 2 branches missed.">                if(kca.elementAt(i) == -1){</span>
<span class="nc" id="L3494">                    kca.setElementAt(keyCode, i);</span>
<span class="nc" id="L3495">                    return;</span>
                }
            }
<span class="nc" id="L3498">            kca.addElement(keyCode);</span>
<span class="nc" id="L3499">        }</span>

        static void registerKeyReleased(int keyCode) {
<span class="nc" id="L3502">            IntVector kca = getKeyCodeArray();</span>
<span class="nc" id="L3503">            int count = kca.size();</span>
            int i;
<span class="nc bnc" id="L3505" title="All 2 branches missed.">            for(i=0;i&lt;count;i++) {</span>
<span class="nc bnc" id="L3506" title="All 2 branches missed.">                if(kca.elementAt(i) == keyCode) {</span>
<span class="nc" id="L3507">                    kca.setElementAt(-1, i);</span>
<span class="nc" id="L3508">                    return;</span>
                }
            }
<span class="nc" id="L3511">        }</span>

        static boolean keyIsPressed(int keyCode) {
<span class="nc" id="L3514">            IntVector kca = getKeyCodeArray();</span>
<span class="nc" id="L3515">            int count = kca.size();</span>
            int i;
<span class="nc bnc" id="L3517" title="All 2 branches missed.">            for(i=0;i&lt;count;i++) {</span>
<span class="nc bnc" id="L3518" title="All 2 branches missed.">                if(kca.elementAt(i) == keyCode) {</span>
<span class="nc" id="L3519">                    return true;</span>
                }
            }
<span class="nc" id="L3522">            return false;</span>
        }

        /**
         * Updates internal state of the KeyboardState and returns true
         * if the event should be processed further.
         */
        static boolean shouldProcess(KeyEvent e) {
<span class="nc bnc" id="L3530" title="All 4 branches missed.">            switch (e.getID()) {</span>
            case KeyEvent.KEY_PRESSED:
<span class="nc bnc" id="L3532" title="All 2 branches missed.">                if (!keyIsPressed(e.getKeyCode())) {</span>
<span class="nc" id="L3533">                    registerKeyPressed(e.getKeyCode());</span>
                }
<span class="nc" id="L3535">                return true;</span>
            case KeyEvent.KEY_RELEASED:
                // We are forced to process VK_PRINTSCREEN separately because
                // the Windows doesn't generate the key pressed event for
                // printscreen and it block the processing of key release
                // event for printscreen.
<span class="nc bnc" id="L3541" title="All 4 branches missed.">                if (keyIsPressed(e.getKeyCode()) || e.getKeyCode()==KeyEvent.VK_PRINTSCREEN) {</span>
<span class="nc" id="L3542">                    registerKeyReleased(e.getKeyCode());</span>
<span class="nc" id="L3543">                    return true;</span>
                }
<span class="nc" id="L3545">                return false;</span>
            case KeyEvent.KEY_TYPED:
<span class="nc" id="L3547">                return true;</span>
            default:
                // Not a known KeyEvent type, bail.
<span class="nc" id="L3550">                return false;</span>
            }
      }
    }

<span class="fc" id="L3555">    static final sun.awt.RequestFocusController focusController =</span>
<span class="fc" id="L3556">        new sun.awt.RequestFocusController() {</span>
            public boolean acceptRequestFocus(Component from, Component to,
                                              boolean temporary, boolean focusedWindowChangeAllowed,
                                              sun.awt.CausedFocusEvent.Cause cause)
            {
<span class="nc bnc" id="L3561" title="All 4 branches missed.">                if ((to == null) || !(to instanceof JComponent)) {</span>
<span class="nc" id="L3562">                    return true;</span>
                }

<span class="nc bnc" id="L3565" title="All 4 branches missed.">                if ((from == null) || !(from instanceof JComponent)) {</span>
<span class="nc" id="L3566">                    return true;</span>
                }

<span class="nc" id="L3569">                JComponent target = (JComponent) to;</span>
<span class="nc bnc" id="L3570" title="All 2 branches missed.">                if (!target.getVerifyInputWhenFocusTarget()) {</span>
<span class="nc" id="L3571">                    return true;</span>
                }

<span class="nc" id="L3574">                JComponent jFocusOwner = (JComponent)from;</span>
<span class="nc" id="L3575">                InputVerifier iv = jFocusOwner.getInputVerifier();</span>

<span class="nc bnc" id="L3577" title="All 2 branches missed.">                if (iv == null) {</span>
<span class="nc" id="L3578">                    return true;</span>
                } else {
<span class="nc" id="L3580">                    Object currentSource = SwingUtilities.appContextGet(</span>
<span class="nc" id="L3581">                            INPUT_VERIFIER_SOURCE_KEY);</span>
<span class="nc bnc" id="L3582" title="All 2 branches missed.">                    if (currentSource == jFocusOwner) {</span>
                        // We're currently calling into the InputVerifier
                        // for this component, so allow the focus change.
<span class="nc" id="L3585">                        return true;</span>
                    }
<span class="nc" id="L3587">                    SwingUtilities.appContextPut(INPUT_VERIFIER_SOURCE_KEY,</span>
                                                 jFocusOwner);
                    try {
<span class="nc" id="L3590">                        return iv.shouldYieldFocus(jFocusOwner);</span>
                    } finally {
<span class="nc bnc" id="L3592" title="All 4 branches missed.">                        if (currentSource != null) {</span>
                            // We're already in the InputVerifier for
                            // currentSource. By resetting the currentSource
                            // we ensure that if the InputVerifier for
                            // currentSource does a requestFocus, we don't
                            // try and run the InputVerifier again.
<span class="nc" id="L3598">                            SwingUtilities.appContextPut(</span>
<span class="nc" id="L3599">                                INPUT_VERIFIER_SOURCE_KEY, currentSource);</span>
                        } else {
<span class="nc" id="L3601">                            SwingUtilities.appContextRemove(</span>
<span class="nc" id="L3602">                                INPUT_VERIFIER_SOURCE_KEY);</span>
                        }
                    }
                }
            }
        };

    /*
     * --- Accessibility Support ---
     */

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;java.awt.Component.setEnabled(boolean)&lt;/code&gt;.
     */
    @Deprecated
    public void enable() {
<span class="nc bnc" id="L3619" title="All 2 branches missed.">        if (isEnabled() != true) {</span>
<span class="nc" id="L3620">            super.enable();</span>
<span class="nc bnc" id="L3621" title="All 2 branches missed.">            if (accessibleContext != null) {</span>
<span class="nc" id="L3622">                accessibleContext.firePropertyChange(</span>
                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                    null, AccessibleState.ENABLED);
            }
        }
<span class="nc" id="L3627">    }</span>

    /**
     * @deprecated As of JDK version 1.1,
     * replaced by &lt;code&gt;java.awt.Component.setEnabled(boolean)&lt;/code&gt;.
     */
    @Deprecated
    public void disable() {
<span class="nc bnc" id="L3635" title="All 2 branches missed.">        if (isEnabled() != false) {</span>
<span class="nc" id="L3636">            super.disable();</span>
<span class="nc bnc" id="L3637" title="All 2 branches missed.">            if (accessibleContext != null) {</span>
<span class="nc" id="L3638">                accessibleContext.firePropertyChange(</span>
                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                    AccessibleState.ENABLED, null);
            }
        }
<span class="nc" id="L3643">    }</span>

    /**
     * Inner class of JComponent used to provide default support for
     * accessibility.  This class is not meant to be used directly by
     * application developers, but is instead meant only to be
     * subclassed by component developers.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    public abstract class AccessibleJComponent extends AccessibleAWTContainer
       implements AccessibleExtendedComponent
    {
        /**
         * Though the class is abstract, this should be called by
         * all sub-classes.
         */
<span class="nc" id="L3667">        protected AccessibleJComponent() {</span>
<span class="nc" id="L3668">            super();</span>
<span class="nc" id="L3669">        }</span>

        /**
         * Number of PropertyChangeListener objects registered. It's used
         * to add/remove ContainerListener and FocusListener to track
         * target JComponent's state
         */
<span class="nc" id="L3676">        private volatile transient int propertyListenersCount = 0;</span>

        /**
         * This field duplicates the one in java.awt.Component.AccessibleAWTComponent,
         * so it has been deprecated.
         */
<span class="nc" id="L3682">        @Deprecated</span>
        protected FocusListener accessibleFocusHandler = null;

        /**
         * Fire PropertyChange listener, if one is registered,
         * when children added/removed.
         */
<span class="nc" id="L3689">        protected class AccessibleContainerHandler</span>
            implements ContainerListener {
            public void componentAdded(ContainerEvent e) {
<span class="nc" id="L3692">                Component c = e.getChild();</span>
<span class="nc bnc" id="L3693" title="All 4 branches missed.">                if (c != null &amp;&amp; c instanceof Accessible) {</span>
<span class="nc" id="L3694">                    AccessibleJComponent.this.firePropertyChange(</span>
                        AccessibleContext.ACCESSIBLE_CHILD_PROPERTY,
<span class="nc" id="L3696">                        null, c.getAccessibleContext());</span>
                }
<span class="nc" id="L3698">            }</span>
            public void componentRemoved(ContainerEvent e) {
<span class="nc" id="L3700">                Component c = e.getChild();</span>
<span class="nc bnc" id="L3701" title="All 4 branches missed.">                if (c != null &amp;&amp; c instanceof Accessible) {</span>
<span class="nc" id="L3702">                    AccessibleJComponent.this.firePropertyChange(</span>
                        AccessibleContext.ACCESSIBLE_CHILD_PROPERTY,
<span class="nc" id="L3704">                        c.getAccessibleContext(), null);</span>
                }
<span class="nc" id="L3706">            }</span>
        }

        /**
         * Fire PropertyChange listener, if one is registered,
         * when focus events happen
         * @since 1.3
         */
<span class="nc" id="L3714">        protected class AccessibleFocusHandler implements FocusListener {</span>
           public void focusGained(FocusEvent event) {
<span class="nc bnc" id="L3716" title="All 2 branches missed.">               if (accessibleContext != null) {</span>
<span class="nc" id="L3717">                    accessibleContext.firePropertyChange(</span>
                        AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                        null, AccessibleState.FOCUSED);
                }
<span class="nc" id="L3721">            }</span>
            public void focusLost(FocusEvent event) {
<span class="nc bnc" id="L3723" title="All 2 branches missed.">                if (accessibleContext != null) {</span>
<span class="nc" id="L3724">                    accessibleContext.firePropertyChange(</span>
                        AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
                        AccessibleState.FOCUSED, null);
                }
<span class="nc" id="L3728">            }</span>
        } // inner class AccessibleFocusHandler


        /**
         * Adds a PropertyChangeListener to the listener list.
         *
         * @param listener  the PropertyChangeListener to be added
         */
        public void addPropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L3738" title="All 2 branches missed.">            if (accessibleFocusHandler == null) {</span>
<span class="nc" id="L3739">                accessibleFocusHandler = new AccessibleFocusHandler();</span>
            }
<span class="nc bnc" id="L3741" title="All 2 branches missed.">            if (accessibleContainerHandler == null) {</span>
<span class="nc" id="L3742">                accessibleContainerHandler = new AccessibleContainerHandler();</span>
            }
<span class="nc bnc" id="L3744" title="All 2 branches missed.">            if (propertyListenersCount++ == 0) {</span>
<span class="nc" id="L3745">                JComponent.this.addFocusListener(accessibleFocusHandler);</span>
<span class="nc" id="L3746">                JComponent.this.addContainerListener(accessibleContainerHandler);</span>
            }
<span class="nc" id="L3748">            super.addPropertyChangeListener(listener);</span>
<span class="nc" id="L3749">        }</span>

        /**
         * Removes a PropertyChangeListener from the listener list.
         * This removes a PropertyChangeListener that was registered
         * for all properties.
         *
         * @param listener  the PropertyChangeListener to be removed
         */
        public void removePropertyChangeListener(PropertyChangeListener listener) {
<span class="nc bnc" id="L3759" title="All 2 branches missed.">            if (--propertyListenersCount == 0) {</span>
<span class="nc" id="L3760">                JComponent.this.removeFocusListener(accessibleFocusHandler);</span>
<span class="nc" id="L3761">                JComponent.this.removeContainerListener(accessibleContainerHandler);</span>
            }
<span class="nc" id="L3763">            super.removePropertyChangeListener(listener);</span>
<span class="nc" id="L3764">        }</span>



        /**
         * Recursively search through the border hierarchy (if it exists)
         * for a TitledBorder with a non-null title.  This does a depth
         * first search on first the inside borders then the outside borders.
         * The assumption is that titles make really pretty inside borders
         * but not very pretty outside borders in compound border situations.
         * It's rather arbitrary, but hopefully decent UI programmers will
         * not create multiple titled borders for the same component.
         */
        protected String getBorderTitle(Border b) {
            String s;
<span class="nc bnc" id="L3779" title="All 2 branches missed.">            if (b instanceof TitledBorder) {</span>
<span class="nc" id="L3780">                return ((TitledBorder) b).getTitle();</span>
<span class="nc bnc" id="L3781" title="All 2 branches missed.">            } else if (b instanceof CompoundBorder) {</span>
<span class="nc" id="L3782">                s = getBorderTitle(((CompoundBorder) b).getInsideBorder());</span>
<span class="nc bnc" id="L3783" title="All 2 branches missed.">                if (s == null) {</span>
<span class="nc" id="L3784">                    s = getBorderTitle(((CompoundBorder) b).getOutsideBorder());</span>
                }
<span class="nc" id="L3786">                return s;</span>
            } else {
<span class="nc" id="L3788">                return null;</span>
            }
        }

        // AccessibleContext methods
        //
        /**
         * Gets the accessible name of this object.  This should almost never
         * return java.awt.Component.getName(), as that generally isn't
         * a localized name, and doesn't have meaning for the user.  If the
         * object is fundamentally a text object (such as a menu item), the
         * accessible name should be the text of the object (for example,
         * &quot;save&quot;).
         * If the object has a tooltip, the tooltip text may also be an
         * appropriate String to return.
         *
         * @return the localized name of the object -- can be null if this
         *         object does not have a name
         * @see AccessibleContext#setAccessibleName
         */
        public String getAccessibleName() {
<span class="nc" id="L3809">            String name = accessibleName;</span>

            // fallback to the client name property
            //
<span class="nc bnc" id="L3813" title="All 2 branches missed.">            if (name == null) {</span>
<span class="nc" id="L3814">                name = (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);</span>
            }

            // fallback to the titled border if it exists
            //
<span class="nc bnc" id="L3819" title="All 2 branches missed.">            if (name == null) {</span>
<span class="nc" id="L3820">                name = getBorderTitle(getBorder());</span>
            }

            // fallback to the label labeling us if it exists
            //
<span class="nc bnc" id="L3825" title="All 2 branches missed.">            if (name == null) {</span>
<span class="nc" id="L3826">                Object o = getClientProperty(JLabel.LABELED_BY_PROPERTY);</span>
<span class="nc bnc" id="L3827" title="All 2 branches missed.">                if (o instanceof Accessible) {</span>
<span class="nc" id="L3828">                    AccessibleContext ac = ((Accessible) o).getAccessibleContext();</span>
<span class="nc bnc" id="L3829" title="All 2 branches missed.">                    if (ac != null) {</span>
<span class="nc" id="L3830">                        name = ac.getAccessibleName();</span>
                    }
                }
            }
<span class="nc" id="L3834">            return name;</span>
        }

        /**
         * Gets the accessible description of this object.  This should be
         * a concise, localized description of what this object is - what
         * is its meaning to the user.  If the object has a tooltip, the
         * tooltip text may be an appropriate string to return, assuming
         * it contains a concise description of the object (instead of just
         * the name of the object - for example a &quot;Save&quot; icon on a toolbar that
         * had &quot;save&quot; as the tooltip text shouldn't return the tooltip
         * text as the description, but something like &quot;Saves the current
         * text document&quot; instead).
         *
         * @return the localized description of the object -- can be null if
         * this object does not have a description
         * @see AccessibleContext#setAccessibleDescription
         */
        public String getAccessibleDescription() {
<span class="nc" id="L3853">            String description = accessibleDescription;</span>

            // fallback to the client description property
            //
<span class="nc bnc" id="L3857" title="All 2 branches missed.">            if (description == null) {</span>
<span class="nc" id="L3858">                description = (String)getClientProperty(AccessibleContext.ACCESSIBLE_DESCRIPTION_PROPERTY);</span>
            }

            // fallback to the tool tip text if it exists
            //
<span class="nc bnc" id="L3863" title="All 2 branches missed.">            if (description == null) {</span>
                try {
<span class="nc" id="L3865">                    description = getToolTipText();</span>
<span class="nc" id="L3866">                } catch (Exception e) {</span>
                    // Just in case the subclass overrode the
                    // getToolTipText method and actually
                    // requires a MouseEvent.
                    // [[[FIXME:  WDW - we probably should require this
                    // method to take a MouseEvent and just pass it on
                    // to getToolTipText.  The swing-feedback traffic
                    // leads me to believe getToolTipText might change,
                    // though, so I was hesitant to make this change at
                    // this time.]]]
<span class="nc" id="L3876">                }</span>
            }

            // fallback to the label labeling us if it exists
            //
<span class="nc bnc" id="L3881" title="All 2 branches missed.">            if (description == null) {</span>
<span class="nc" id="L3882">                Object o = getClientProperty(JLabel.LABELED_BY_PROPERTY);</span>
<span class="nc bnc" id="L3883" title="All 2 branches missed.">                if (o instanceof Accessible) {</span>
<span class="nc" id="L3884">                    AccessibleContext ac = ((Accessible) o).getAccessibleContext();</span>
<span class="nc bnc" id="L3885" title="All 2 branches missed.">                    if (ac != null) {</span>
<span class="nc" id="L3886">                        description = ac.getAccessibleDescription();</span>
                    }
                }
            }

<span class="nc" id="L3891">            return description;</span>
        }

        /**
         * Gets the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the
         * object
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L3902">            return AccessibleRole.SWING_COMPONENT;</span>
        }

        /**
         * Gets the state of this object.
         *
         * @return an instance of AccessibleStateSet containing the current
         * state set of the object
         * @see AccessibleState
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L3913">            AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc bnc" id="L3914" title="All 2 branches missed.">            if (JComponent.this.isOpaque()) {</span>
<span class="nc" id="L3915">                states.add(AccessibleState.OPAQUE);</span>
            }
<span class="nc" id="L3917">            return states;</span>
        }

        /**
         * Returns the number of accessible children in the object.  If all
         * of the children of this object implement Accessible, than this
         * method should return the number of children of this object.
         *
         * @return the number of accessible children in the object.
         */
        public int getAccessibleChildrenCount() {
<span class="nc" id="L3928">            return super.getAccessibleChildrenCount();</span>
        }

        /**
         * Returns the nth Accessible child of the object.
         *
         * @param i zero-based index of child
         * @return the nth Accessible child of the object
         */
        public Accessible getAccessibleChild(int i) {
<span class="nc" id="L3938">            return super.getAccessibleChild(i);</span>
        }

        // ----- AccessibleExtendedComponent

        /**
         * Returns the AccessibleExtendedComponent
         *
         * @return the AccessibleExtendedComponent
         */
        AccessibleExtendedComponent getAccessibleExtendedComponent() {
<span class="nc" id="L3949">            return this;</span>
        }

        /**
         * Returns the tool tip text
         *
         * @return the tool tip text, if supported, of the object;
         * otherwise, null
         * @since 1.4
         */
        public String getToolTipText() {
<span class="nc" id="L3960">            return JComponent.this.getToolTipText();</span>
        }

        /**
         * Returns the titled border text
         *
         * @return the titled border text, if supported, of the object;
         * otherwise, null
         * @since 1.4
         */
        public String getTitledBorderText() {
<span class="nc" id="L3971">            Border border = JComponent.this.getBorder();</span>
<span class="nc bnc" id="L3972" title="All 2 branches missed.">            if (border instanceof TitledBorder) {</span>
<span class="nc" id="L3973">                return ((TitledBorder)border).getTitle();</span>
            } else {
<span class="nc" id="L3975">                return null;</span>
            }
        }

        /**
         * Returns key bindings associated with this object
         *
         * @return the key bindings, if supported, of the object;
         * otherwise, null
         * @see AccessibleKeyBinding
         * @since 1.4
         */
        public AccessibleKeyBinding getAccessibleKeyBinding() {
<span class="nc" id="L3988">            return null;</span>
        }
    } // inner class AccessibleJComponent


    /**
     * Returns an &lt;code&gt;ArrayTable&lt;/code&gt; used for
     * key/value &quot;client properties&quot; for this component. If the
     * &lt;code&gt;clientProperties&lt;/code&gt; table doesn't exist, an empty one
     * will be created.
     *
     * @return an ArrayTable
     * @see #putClientProperty
     * @see #getClientProperty
     */
    private ArrayTable getClientProperties() {
<span class="nc bnc" id="L4004" title="All 2 branches missed.">        if (clientProperties == null) {</span>
<span class="nc" id="L4005">            clientProperties = new ArrayTable();</span>
        }
<span class="nc" id="L4007">        return clientProperties;</span>
    }


    /**
     * Returns the value of the property with the specified key.  Only
     * properties added with &lt;code&gt;putClientProperty&lt;/code&gt; will return
     * a non-&lt;code&gt;null&lt;/code&gt; value.
     *
     * @param key the being queried
     * @return the value of this property or &lt;code&gt;null&lt;/code&gt;
     * @see #putClientProperty
     */
    public final Object getClientProperty(Object key) {
<span class="nc bnc" id="L4021" title="All 2 branches missed.">        if (key == SwingUtilities2.AA_TEXT_PROPERTY_KEY) {</span>
<span class="nc" id="L4022">            return aaTextInfo;</span>
<span class="nc bnc" id="L4023" title="All 2 branches missed.">        } else if (key == SwingUtilities2.COMPONENT_UI_PROPERTY_KEY) {</span>
<span class="nc" id="L4024">            return ui;</span>
        }
<span class="nc bnc" id="L4026" title="All 2 branches missed.">         if(clientProperties == null) {</span>
<span class="nc" id="L4027">            return null;</span>
        } else {
<span class="nc" id="L4029">            synchronized(clientProperties) {</span>
<span class="nc" id="L4030">                return clientProperties.get(key);</span>
<span class="nc" id="L4031">            }</span>
        }
    }

    /**
     * Adds an arbitrary key/value &quot;client property&quot; to this component.
     * &lt;p&gt;
     * The &lt;code&gt;get/putClientProperty&lt;/code&gt; methods provide access to
     * a small per-instance hashtable. Callers can use get/putClientProperty
     * to annotate components that were created by another module.
     * For example, a
     * layout manager might store per child constraints this way. For example:
     * &lt;pre&gt;
     * componentA.putClientProperty(&quot;to the left of&quot;, componentB);
     * &lt;/pre&gt;
     * If value is &lt;code&gt;null&lt;/code&gt; this method will remove the property.
     * Changes to client properties are reported with
     * &lt;code&gt;PropertyChange&lt;/code&gt; events.
     * The name of the property (for the sake of PropertyChange
     * events) is &lt;code&gt;key.toString()&lt;/code&gt;.
     * &lt;p&gt;
     * The &lt;code&gt;clientProperty&lt;/code&gt; dictionary is not intended to
     * support large
     * scale extensions to JComponent nor should be it considered an
     * alternative to subclassing when designing a new component.
     *
     * @param key the new client property key
     * @param value the new client property value; if &lt;code&gt;null&lt;/code&gt;
     *          this method will remove the property
     * @see #getClientProperty
     * @see #addPropertyChangeListener
     */
    public final void putClientProperty(Object key, Object value) {
<span class="nc bnc" id="L4064" title="All 2 branches missed.">        if (key == SwingUtilities2.AA_TEXT_PROPERTY_KEY) {</span>
<span class="nc" id="L4065">            aaTextInfo = value;</span>
<span class="nc" id="L4066">            return;</span>
        }
<span class="nc bnc" id="L4068" title="All 4 branches missed.">        if (value == null &amp;&amp; clientProperties == null) {</span>
            // Both the value and ArrayTable are null, implying we don't
            // have to do anything.
<span class="nc" id="L4071">            return;</span>
        }
<span class="nc" id="L4073">        ArrayTable clientProperties = getClientProperties();</span>
        Object oldValue;
<span class="nc" id="L4075">        synchronized(clientProperties) {</span>
<span class="nc" id="L4076">            oldValue = clientProperties.get(key);</span>
<span class="nc bnc" id="L4077" title="All 2 branches missed.">            if (value != null) {</span>
<span class="nc" id="L4078">                clientProperties.put(key, value);</span>
<span class="nc bnc" id="L4079" title="All 2 branches missed.">            } else if (oldValue != null) {</span>
<span class="nc" id="L4080">                clientProperties.remove(key);</span>
            } else {
                // old == new == null
<span class="nc" id="L4083">                return;</span>
            }
<span class="nc" id="L4085">        }</span>
<span class="nc" id="L4086">        clientPropertyChanged(key, oldValue, value);</span>
<span class="nc" id="L4087">        firePropertyChange(key.toString(), oldValue, value);</span>
<span class="nc" id="L4088">    }</span>

    // Invoked from putClientProperty.  This is provided for subclasses
    // in Swing.
    void clientPropertyChanged(Object key, Object oldValue,
                               Object newValue) {
<span class="nc" id="L4094">    }</span>


    /*
     * Sets the property with the specified name to the specified value if
     * the property has not already been set by the client program.
     * This method is used primarily to set UI defaults for properties
     * with primitive types, where the values cannot be marked with
     * UIResource.
     * @see LookAndFeel#installProperty
     * @param propertyName String containing the name of the property
     * @param value Object containing the property value
     */
    void setUIProperty(String propertyName, Object value) {
<span class="nc bnc" id="L4108" title="All 2 branches missed.">        if (propertyName == &quot;opaque&quot;) {</span>
<span class="nc bnc" id="L4109" title="All 2 branches missed.">            if (!getFlag(OPAQUE_SET)) {</span>
<span class="nc" id="L4110">                setOpaque(((Boolean)value).booleanValue());</span>
<span class="nc" id="L4111">                setFlag(OPAQUE_SET, false);</span>
            }
<span class="nc bnc" id="L4113" title="All 2 branches missed.">        } else if (propertyName == &quot;autoscrolls&quot;) {</span>
<span class="nc bnc" id="L4114" title="All 2 branches missed.">            if (!getFlag(AUTOSCROLLS_SET)) {</span>
<span class="nc" id="L4115">                setAutoscrolls(((Boolean)value).booleanValue());</span>
<span class="nc" id="L4116">                setFlag(AUTOSCROLLS_SET, false);</span>
            }
<span class="nc bnc" id="L4118" title="All 2 branches missed.">        } else if (propertyName == &quot;focusTraversalKeysForward&quot;) {</span>
<span class="nc bnc" id="L4119" title="All 2 branches missed.">            if (!getFlag(FOCUS_TRAVERSAL_KEYS_FORWARD_SET)) {</span>
<span class="nc" id="L4120">                super.setFocusTraversalKeys(KeyboardFocusManager.</span>
                                            FORWARD_TRAVERSAL_KEYS,
                                            (Set&lt;AWTKeyStroke&gt;)value);
            }
<span class="nc bnc" id="L4124" title="All 2 branches missed.">        } else if (propertyName == &quot;focusTraversalKeysBackward&quot;) {</span>
<span class="nc bnc" id="L4125" title="All 2 branches missed.">            if (!getFlag(FOCUS_TRAVERSAL_KEYS_BACKWARD_SET)) {</span>
<span class="nc" id="L4126">                super.setFocusTraversalKeys(KeyboardFocusManager.</span>
                                            BACKWARD_TRAVERSAL_KEYS,
                                            (Set&lt;AWTKeyStroke&gt;)value);
            }
        } else {
<span class="nc" id="L4131">            throw new IllegalArgumentException(&quot;property \&quot;&quot;+</span>
                                               propertyName+ &quot;\&quot; cannot be set using this method&quot;);
        }
<span class="nc" id="L4134">    }</span>


    /**
     * Sets the focus traversal keys for a given traversal operation for this
     * Component.
     * Refer to
     * {@link java.awt.Component#setFocusTraversalKeys}
     * for a complete description of this method.
     * &lt;p&gt;
     * This method may throw a {@code ClassCastException} if any {@code Object}
     * in {@code keystrokes} is not an {@code AWTKeyStroke}.
     *
     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
     * @param keystrokes the Set of AWTKeyStroke for the specified operation
     * @see java.awt.KeyboardFocusManager#FORWARD_TRAVERSAL_KEYS
     * @see java.awt.KeyboardFocusManager#BACKWARD_TRAVERSAL_KEYS
     * @see java.awt.KeyboardFocusManager#UP_CYCLE_TRAVERSAL_KEYS
     * @throws IllegalArgumentException if id is not one of
     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, or
     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or if keystrokes
     *         contains null, or if any keystroke represents a KEY_TYPED event,
     *         or if any keystroke already maps to another focus traversal
     *         operation for this Component
     * @since 1.5
     * @beaninfo
     *       bound: true
     */
    public void
        setFocusTraversalKeys(int id, Set&lt;? extends AWTKeyStroke&gt; keystrokes)
    {
<span class="nc bnc" id="L4168" title="All 2 branches missed.">        if (id == KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS) {</span>
<span class="nc" id="L4169">            setFlag(FOCUS_TRAVERSAL_KEYS_FORWARD_SET,true);</span>
<span class="nc bnc" id="L4170" title="All 2 branches missed.">        } else if (id == KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS) {</span>
<span class="nc" id="L4171">            setFlag(FOCUS_TRAVERSAL_KEYS_BACKWARD_SET,true);</span>
        }
<span class="nc" id="L4173">        super.setFocusTraversalKeys(id,keystrokes);</span>
<span class="nc" id="L4174">    }</span>

    /* --- Transitional java.awt.Component Support ---
     * The methods and fields in this section will migrate to
     * java.awt.Component in the next JDK release.
     */

    /**
     * Returns true if this component is lightweight, that is, if it doesn't
     * have a native window system peer.
     *
     * @return true if this component is lightweight
     */
    @SuppressWarnings(&quot;deprecation&quot;)
    public static boolean isLightweightComponent(Component c) {
<span class="nc" id="L4189">        return c.getPeer() instanceof LightweightPeer;</span>
    }


    /**
     * @deprecated As of JDK 5,
     * replaced by &lt;code&gt;Component.setBounds(int, int, int, int)&lt;/code&gt;.
     * &lt;p&gt;
     * Moves and resizes this component.
     *
     * @param x  the new horizontal location
     * @param y  the new vertical location
     * @param w  the new width
     * @param h  the new height
     * @see java.awt.Component#setBounds
     */
    @Deprecated
    public void reshape(int x, int y, int w, int h) {
<span class="nc" id="L4207">        super.reshape(x, y, w, h);</span>
<span class="nc" id="L4208">    }</span>


    /**
     * Stores the bounds of this component into &quot;return value&quot;
     * &lt;code&gt;rv&lt;/code&gt; and returns &lt;code&gt;rv&lt;/code&gt;.
     * If &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; a new &lt;code&gt;Rectangle&lt;/code&gt;
     * is allocated.  This version of &lt;code&gt;getBounds&lt;/code&gt; is useful
     * if the caller wants to avoid allocating a new &lt;code&gt;Rectangle&lt;/code&gt;
     * object on the heap.
     *
     * @param rv the return value, modified to the component's bounds
     * @return &lt;code&gt;rv&lt;/code&gt;; if &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;
     *          return a newly created &lt;code&gt;Rectangle&lt;/code&gt; with this
     *          component's bounds
     */
    public Rectangle getBounds(Rectangle rv) {
<span class="nc bnc" id="L4225" title="All 2 branches missed.">        if (rv == null) {</span>
<span class="nc" id="L4226">            return new Rectangle(getX(), getY(), getWidth(), getHeight());</span>
        }
        else {
<span class="nc" id="L4229">            rv.setBounds(getX(), getY(), getWidth(), getHeight());</span>
<span class="nc" id="L4230">            return rv;</span>
        }
    }


    /**
     * Stores the width/height of this component into &quot;return value&quot;
     * &lt;code&gt;rv&lt;/code&gt; and returns &lt;code&gt;rv&lt;/code&gt;.
     * If &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; a new &lt;code&gt;Dimension&lt;/code&gt;
     * object is allocated.  This version of &lt;code&gt;getSize&lt;/code&gt;
     * is useful if the caller wants to avoid allocating a new
     * &lt;code&gt;Dimension&lt;/code&gt; object on the heap.
     *
     * @param rv the return value, modified to the component's size
     * @return &lt;code&gt;rv&lt;/code&gt;
     */
    public Dimension getSize(Dimension rv) {
<span class="nc bnc" id="L4247" title="All 2 branches missed.">        if (rv == null) {</span>
<span class="nc" id="L4248">            return new Dimension(getWidth(), getHeight());</span>
        }
        else {
<span class="nc" id="L4251">            rv.setSize(getWidth(), getHeight());</span>
<span class="nc" id="L4252">            return rv;</span>
        }
    }


    /**
     * Stores the x,y origin of this component into &quot;return value&quot;
     * &lt;code&gt;rv&lt;/code&gt; and returns &lt;code&gt;rv&lt;/code&gt;.
     * If &lt;code&gt;rv&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; a new &lt;code&gt;Point&lt;/code&gt;
     * is allocated.  This version of &lt;code&gt;getLocation&lt;/code&gt; is useful
     * if the caller wants to avoid allocating a new &lt;code&gt;Point&lt;/code&gt;
     * object on the heap.
     *
     * @param rv the return value, modified to the component's location
     * @return &lt;code&gt;rv&lt;/code&gt;
     */
    public Point getLocation(Point rv) {
<span class="nc bnc" id="L4269" title="All 2 branches missed.">        if (rv == null) {</span>
<span class="nc" id="L4270">            return new Point(getX(), getY());</span>
        }
        else {
<span class="nc" id="L4273">            rv.setLocation(getX(), getY());</span>
<span class="nc" id="L4274">            return rv;</span>
        }
    }


    /**
     * Returns the current x coordinate of the component's origin.
     * This method is preferable to writing
     * &lt;code&gt;component.getBounds().x&lt;/code&gt;, or
     * &lt;code&gt;component.getLocation().x&lt;/code&gt; because it doesn't cause any
     * heap allocations.
     *
     * @return the current x coordinate of the component's origin
     */
<span class="nc" id="L4288">    public int getX() { return super.getX(); }</span>


    /**
     * Returns the current y coordinate of the component's origin.
     * This method is preferable to writing
     * &lt;code&gt;component.getBounds().y&lt;/code&gt;, or
     * &lt;code&gt;component.getLocation().y&lt;/code&gt; because it doesn't cause any
     * heap allocations.
     *
     * @return the current y coordinate of the component's origin
     */
<span class="nc" id="L4300">    public int getY() { return super.getY(); }</span>


    /**
     * Returns the current width of this component.
     * This method is preferable to writing
     * &lt;code&gt;component.getBounds().width&lt;/code&gt;, or
     * &lt;code&gt;component.getSize().width&lt;/code&gt; because it doesn't cause any
     * heap allocations.
     *
     * @return the current width of this component
     */
<span class="nc" id="L4312">    public int getWidth() { return super.getWidth(); }</span>


    /**
     * Returns the current height of this component.
     * This method is preferable to writing
     * &lt;code&gt;component.getBounds().height&lt;/code&gt;, or
     * &lt;code&gt;component.getSize().height&lt;/code&gt; because it doesn't cause any
     * heap allocations.
     *
     * @return the current height of this component
     */
<span class="nc" id="L4324">    public int getHeight() { return super.getHeight(); }</span>

    /**
     * Returns true if this component is completely opaque.
     * &lt;p&gt;
     * An opaque component paints every pixel within its
     * rectangular bounds. A non-opaque component paints only a subset of
     * its pixels or none at all, allowing the pixels underneath it to
     * &quot;show through&quot;.  Therefore, a component that does not fully paint
     * its pixels provides a degree of transparency.
     * &lt;p&gt;
     * Subclasses that guarantee to always completely paint their contents
     * should override this method and return true.
     *
     * @return true if this component is completely opaque
     * @see #setOpaque
     */
    public boolean isOpaque() {
<span class="nc" id="L4342">        return getFlag(IS_OPAQUE);</span>
    }

    /**
     * If true the component paints every pixel within its bounds.
     * Otherwise, the component may not paint some or all of its
     * pixels, allowing the underlying pixels to show through.
     * &lt;p&gt;
     * The default value of this property is false for &lt;code&gt;JComponent&lt;/code&gt;.
     * However, the default value for this property on most standard
     * &lt;code&gt;JComponent&lt;/code&gt; subclasses (such as &lt;code&gt;JButton&lt;/code&gt; and
     * &lt;code&gt;JTree&lt;/code&gt;) is look-and-feel dependent.
     *
     * @param isOpaque  true if this component should be opaque
     * @see #isOpaque
     * @beaninfo
     *        bound: true
     *       expert: true
     *  description: The component's opacity
     */
    public void setOpaque(boolean isOpaque) {
<span class="nc" id="L4363">        boolean oldValue = getFlag(IS_OPAQUE);</span>
<span class="nc" id="L4364">        setFlag(IS_OPAQUE, isOpaque);</span>
<span class="nc" id="L4365">        setFlag(OPAQUE_SET, true);</span>
<span class="nc" id="L4366">        firePropertyChange(&quot;opaque&quot;, oldValue, isOpaque);</span>
<span class="nc" id="L4367">    }</span>


    /**
     * If the specified rectangle is completely obscured by any of this
     * component's opaque children then returns true.  Only direct children
     * are considered, more distant descendants are ignored.  A
     * &lt;code&gt;JComponent&lt;/code&gt; is opaque if
     * &lt;code&gt;JComponent.isOpaque()&lt;/code&gt; returns true, other lightweight
     * components are always considered transparent, and heavyweight components
     * are always considered opaque.
     *
     * @param x  x value of specified rectangle
     * @param y  y value of specified rectangle
     * @param width  width of specified rectangle
     * @param height height of specified rectangle
     * @return true if the specified rectangle is obscured by an opaque child
     */
    boolean rectangleIsObscured(int x,int y,int width,int height)
    {
<span class="nc" id="L4387">        int numChildren = getComponentCount();</span>

<span class="nc bnc" id="L4389" title="All 2 branches missed.">        for(int i = 0; i &lt; numChildren; i++) {</span>
<span class="nc" id="L4390">            Component child = getComponent(i);</span>
            int cx, cy, cw, ch;

<span class="nc" id="L4393">            cx = child.getX();</span>
<span class="nc" id="L4394">            cy = child.getY();</span>
<span class="nc" id="L4395">            cw = child.getWidth();</span>
<span class="nc" id="L4396">            ch = child.getHeight();</span>

<span class="nc bnc" id="L4398" title="All 8 branches missed.">            if (x &gt;= cx &amp;&amp; (x + width) &lt;= (cx + cw) &amp;&amp;</span>
<span class="nc bnc" id="L4399" title="All 2 branches missed.">                y &gt;= cy &amp;&amp; (y + height) &lt;= (cy + ch) &amp;&amp; child.isVisible()) {</span>

<span class="nc bnc" id="L4401" title="All 2 branches missed.">                if(child instanceof JComponent) {</span>
//                  System.out.println(&quot;A) checking opaque: &quot; + ((JComponent)child).isOpaque() + &quot;  &quot; + child);
//                  System.out.print(&quot;B) &quot;);
//                  Thread.dumpStack();
<span class="nc" id="L4405">                    return child.isOpaque();</span>
                } else {
                    /** Sometimes a heavy weight can have a bound larger than its peer size
                     *  so we should always draw under heavy weights
                     */
<span class="nc" id="L4410">                    return false;</span>
                }
            }
        }

<span class="nc" id="L4415">        return false;</span>
    }


    /**
     * Returns the &lt;code&gt;Component&lt;/code&gt;'s &quot;visible rect rectangle&quot; -  the
     * intersection of the visible rectangles for the component &lt;code&gt;c&lt;/code&gt;
     * and all of its ancestors.  The return value is stored in
     * &lt;code&gt;visibleRect&lt;/code&gt;.
     *
     * @param c  the component
     * @param visibleRect  a &lt;code&gt;Rectangle&lt;/code&gt; computed as the
     *          intersection of all visible rectangles for the component
     *          &lt;code&gt;c&lt;/code&gt; and all of its ancestors -- this is the
     *          return value for this method
     * @see #getVisibleRect
     */
    static final void computeVisibleRect(Component c, Rectangle visibleRect) {
<span class="nc" id="L4433">        Container p = c.getParent();</span>
<span class="nc" id="L4434">        Rectangle bounds = c.getBounds();</span>

<span class="nc bnc" id="L4436" title="All 6 branches missed.">        if (p == null || p instanceof Window || p instanceof Applet) {</span>
<span class="nc" id="L4437">            visibleRect.setBounds(0, 0, bounds.width, bounds.height);</span>
        } else {
<span class="nc" id="L4439">            computeVisibleRect(p, visibleRect);</span>
<span class="nc" id="L4440">            visibleRect.x -= bounds.x;</span>
<span class="nc" id="L4441">            visibleRect.y -= bounds.y;</span>
<span class="nc" id="L4442">            SwingUtilities.computeIntersection(0,0,bounds.width,bounds.height,visibleRect);</span>
        }
<span class="nc" id="L4444">    }</span>


    /**
     * Returns the &lt;code&gt;Component&lt;/code&gt;'s &quot;visible rect rectangle&quot; -  the
     * intersection of the visible rectangles for this component
     * and all of its ancestors.  The return value is stored in
     * &lt;code&gt;visibleRect&lt;/code&gt;.
     *
     * @param visibleRect a &lt;code&gt;Rectangle&lt;/code&gt; computed as the
     *          intersection of all visible rectangles for this
     *          component and all of its ancestors -- this is the return
     *          value for this method
     * @see #getVisibleRect
     */
    public void computeVisibleRect(Rectangle visibleRect) {
<span class="nc" id="L4460">        computeVisibleRect(this, visibleRect);</span>
<span class="nc" id="L4461">    }</span>


    /**
     * Returns the &lt;code&gt;Component&lt;/code&gt;'s &quot;visible rectangle&quot; -  the
     * intersection of this component's visible rectangle,
     * &lt;code&gt;new Rectangle(0, 0, getWidth(), getHeight())&lt;/code&gt;,
     * and all of its ancestors' visible rectangles.
     *
     * @return the visible rectangle
     */
    public Rectangle getVisibleRect() {
<span class="nc" id="L4473">        Rectangle visibleRect = new Rectangle();</span>

<span class="nc" id="L4475">        computeVisibleRect(visibleRect);</span>
<span class="nc" id="L4476">        return visibleRect;</span>
    }

    /**
     * Support for reporting bound property changes for boolean properties.
     * This method can be called when a bound property has changed and it will
     * send the appropriate PropertyChangeEvent to any registered
     * PropertyChangeListeners.
     *
     * @param propertyName the property whose value has changed
     * @param oldValue the property's previous value
     * @param newValue the property's new value
     */
    public void firePropertyChange(String propertyName,
                                   boolean oldValue, boolean newValue) {
<span class="nc" id="L4491">        super.firePropertyChange(propertyName, oldValue, newValue);</span>
<span class="nc" id="L4492">    }</span>


    /**
     * Support for reporting bound property changes for integer properties.
     * This method can be called when a bound property has changed and it will
     * send the appropriate PropertyChangeEvent to any registered
     * PropertyChangeListeners.
     *
     * @param propertyName the property whose value has changed
     * @param oldValue the property's previous value
     * @param newValue the property's new value
     */
    public void firePropertyChange(String propertyName,
                                      int oldValue, int newValue) {
<span class="nc" id="L4507">        super.firePropertyChange(propertyName, oldValue, newValue);</span>
<span class="nc" id="L4508">    }</span>

    // XXX This method is implemented as a workaround to a JLS issue with ambiguous
    // methods. This should be removed once 4758654 is resolved.
    public void firePropertyChange(String propertyName, char oldValue, char newValue) {
<span class="nc" id="L4513">        super.firePropertyChange(propertyName, oldValue, newValue);</span>
<span class="nc" id="L4514">    }</span>

    /**
     * Supports reporting constrained property changes.
     * This method can be called when a constrained property has changed
     * and it will send the appropriate &lt;code&gt;PropertyChangeEvent&lt;/code&gt;
     * to any registered &lt;code&gt;VetoableChangeListeners&lt;/code&gt;.
     *
     * @param propertyName  the name of the property that was listened on
     * @param oldValue  the old value of the property
     * @param newValue  the new value of the property
     * @exception java.beans.PropertyVetoException when the attempt to set the
     *          property is vetoed by the component
     */
    protected void fireVetoableChange(String propertyName, Object oldValue, Object newValue)
        throws java.beans.PropertyVetoException
    {
<span class="nc bnc" id="L4531" title="All 2 branches missed.">        if (vetoableChangeSupport == null) {</span>
<span class="nc" id="L4532">            return;</span>
        }
<span class="nc" id="L4534">        vetoableChangeSupport.fireVetoableChange(propertyName, oldValue, newValue);</span>
<span class="nc" id="L4535">    }</span>


    /**
     * Adds a &lt;code&gt;VetoableChangeListener&lt;/code&gt; to the listener list.
     * The listener is registered for all properties.
     *
     * @param listener  the &lt;code&gt;VetoableChangeListener&lt;/code&gt; to be added
     */
    public synchronized void addVetoableChangeListener(VetoableChangeListener listener) {
<span class="nc bnc" id="L4545" title="All 2 branches missed.">        if (vetoableChangeSupport == null) {</span>
<span class="nc" id="L4546">            vetoableChangeSupport = new java.beans.VetoableChangeSupport(this);</span>
        }
<span class="nc" id="L4548">        vetoableChangeSupport.addVetoableChangeListener(listener);</span>
<span class="nc" id="L4549">    }</span>


    /**
     * Removes a &lt;code&gt;VetoableChangeListener&lt;/code&gt; from the listener list.
     * This removes a &lt;code&gt;VetoableChangeListener&lt;/code&gt; that was registered
     * for all properties.
     *
     * @param listener  the &lt;code&gt;VetoableChangeListener&lt;/code&gt; to be removed
     */
    public synchronized void removeVetoableChangeListener(VetoableChangeListener listener) {
<span class="nc bnc" id="L4560" title="All 2 branches missed.">        if (vetoableChangeSupport == null) {</span>
<span class="nc" id="L4561">            return;</span>
        }
<span class="nc" id="L4563">        vetoableChangeSupport.removeVetoableChangeListener(listener);</span>
<span class="nc" id="L4564">    }</span>


    /**
     * Returns an array of all the vetoable change listeners
     * registered on this component.
     *
     * @return all of the component's &lt;code&gt;VetoableChangeListener&lt;/code&gt;s
     *         or an empty
     *         array if no vetoable change listeners are currently registered
     *
     * @see #addVetoableChangeListener
     * @see #removeVetoableChangeListener
     *
     * @since 1.4
     */
    public synchronized VetoableChangeListener[] getVetoableChangeListeners() {
<span class="nc bnc" id="L4581" title="All 2 branches missed.">        if (vetoableChangeSupport == null) {</span>
<span class="nc" id="L4582">            return new VetoableChangeListener[0];</span>
        }
<span class="nc" id="L4584">        return vetoableChangeSupport.getVetoableChangeListeners();</span>
    }


    /**
     * Returns the top-level ancestor of this component (either the
     * containing &lt;code&gt;Window&lt;/code&gt; or &lt;code&gt;Applet&lt;/code&gt;),
     * or &lt;code&gt;null&lt;/code&gt; if this component has not
     * been added to any container.
     *
     * @return the top-level &lt;code&gt;Container&lt;/code&gt; that this component is in,
     *          or &lt;code&gt;null&lt;/code&gt; if not in any container
     */
    public Container getTopLevelAncestor() {
<span class="nc bnc" id="L4598" title="All 2 branches missed.">        for(Container p = this; p != null; p = p.getParent()) {</span>
<span class="nc bnc" id="L4599" title="All 4 branches missed.">            if(p instanceof Window || p instanceof Applet) {</span>
<span class="nc" id="L4600">                return p;</span>
            }
        }
<span class="nc" id="L4603">        return null;</span>
    }

    private AncestorNotifier getAncestorNotifier() {
<span class="nc" id="L4607">        return (AncestorNotifier)</span>
<span class="nc" id="L4608">            getClientProperty(JComponent_ANCESTOR_NOTIFIER);</span>
    }

    /**
     * Registers &lt;code&gt;listener&lt;/code&gt; so that it will receive
     * &lt;code&gt;AncestorEvents&lt;/code&gt; when it or any of its ancestors
     * move or are made visible or invisible.
     * Events are also sent when the component or its ancestors are added
     * or removed from the containment hierarchy.
     *
     * @param listener  the &lt;code&gt;AncestorListener&lt;/code&gt; to register
     * @see AncestorEvent
     */
    public void addAncestorListener(AncestorListener listener) {
<span class="nc" id="L4622">        AncestorNotifier ancestorNotifier = getAncestorNotifier();</span>
<span class="nc bnc" id="L4623" title="All 2 branches missed.">        if (ancestorNotifier == null) {</span>
<span class="nc" id="L4624">            ancestorNotifier = new AncestorNotifier(this);</span>
<span class="nc" id="L4625">            putClientProperty(JComponent_ANCESTOR_NOTIFIER,</span>
                              ancestorNotifier);
        }
<span class="nc" id="L4628">        ancestorNotifier.addAncestorListener(listener);</span>
<span class="nc" id="L4629">    }</span>

    /**
     * Unregisters &lt;code&gt;listener&lt;/code&gt; so that it will no longer receive
     * &lt;code&gt;AncestorEvents&lt;/code&gt;.
     *
     * @param listener  the &lt;code&gt;AncestorListener&lt;/code&gt; to be removed
     * @see #addAncestorListener
     */
    public void removeAncestorListener(AncestorListener listener) {
<span class="nc" id="L4639">        AncestorNotifier ancestorNotifier = getAncestorNotifier();</span>
<span class="nc bnc" id="L4640" title="All 2 branches missed.">        if (ancestorNotifier == null) {</span>
<span class="nc" id="L4641">            return;</span>
        }
<span class="nc" id="L4643">        ancestorNotifier.removeAncestorListener(listener);</span>
<span class="nc bnc" id="L4644" title="All 2 branches missed.">        if (ancestorNotifier.listenerList.getListenerList().length == 0) {</span>
<span class="nc" id="L4645">            ancestorNotifier.removeAllListeners();</span>
<span class="nc" id="L4646">            putClientProperty(JComponent_ANCESTOR_NOTIFIER, null);</span>
        }
<span class="nc" id="L4648">    }</span>

    /**
     * Returns an array of all the ancestor listeners
     * registered on this component.
     *
     * @return all of the component's &lt;code&gt;AncestorListener&lt;/code&gt;s
     *         or an empty
     *         array if no ancestor listeners are currently registered
     *
     * @see #addAncestorListener
     * @see #removeAncestorListener
     *
     * @since 1.4
     */
    public AncestorListener[] getAncestorListeners() {
<span class="nc" id="L4664">        AncestorNotifier ancestorNotifier = getAncestorNotifier();</span>
<span class="nc bnc" id="L4665" title="All 2 branches missed.">        if (ancestorNotifier == null) {</span>
<span class="nc" id="L4666">            return new AncestorListener[0];</span>
        }
<span class="nc" id="L4668">        return ancestorNotifier.getAncestorListeners();</span>
    }

    /**
     * Returns an array of all the objects currently registered
     * as &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s
     * upon this &lt;code&gt;JComponent&lt;/code&gt;.
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s are registered using the
     * &lt;code&gt;add&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt; method.
     *
     * &lt;p&gt;
     *
     * You can specify the &lt;code&gt;listenerType&lt;/code&gt; argument
     * with a class literal,
     * such as
     * &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener.class&lt;/code&gt;.
     * For example, you can query a
     * &lt;code&gt;JComponent&lt;/code&gt; &lt;code&gt;c&lt;/code&gt;
     * for its mouse listeners with the following code:
     * &lt;pre&gt;MouseListener[] mls = (MouseListener[])(c.getListeners(MouseListener.class));&lt;/pre&gt;
     * If no such listeners exist, this method returns an empty array.
     *
     * @param listenerType the type of listeners requested; this parameter
     *          should specify an interface that descends from
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     * @return an array of all objects registered as
     *          &lt;code&gt;&lt;em&gt;Foo&lt;/em&gt;Listener&lt;/code&gt;s on this component,
     *          or an empty array if no such
     *          listeners have been added
     * @exception ClassCastException if &lt;code&gt;listenerType&lt;/code&gt;
     *          doesn't specify a class or interface that implements
     *          &lt;code&gt;java.util.EventListener&lt;/code&gt;
     *
     * @since 1.3
     *
     * @see #getVetoableChangeListeners
     * @see #getAncestorListeners
     */
    public &lt;T extends EventListener&gt; T[] getListeners(Class&lt;T&gt; listenerType) {
        T[] result;
<span class="nc bnc" id="L4708" title="All 2 branches missed.">        if (listenerType == AncestorListener.class) {</span>
            // AncestorListeners are handled by the AncestorNotifier
<span class="nc" id="L4710">            result = (T[])getAncestorListeners();</span>
        }
<span class="nc bnc" id="L4712" title="All 2 branches missed.">        else if (listenerType == VetoableChangeListener.class) {</span>
            // VetoableChangeListeners are handled by VetoableChangeSupport
<span class="nc" id="L4714">            result = (T[])getVetoableChangeListeners();</span>
        }
<span class="nc bnc" id="L4716" title="All 2 branches missed.">        else if (listenerType == PropertyChangeListener.class) {</span>
            // PropertyChangeListeners are handled by PropertyChangeSupport
<span class="nc" id="L4718">            result = (T[])getPropertyChangeListeners();</span>
        }
        else {
<span class="nc" id="L4721">            result = listenerList.getListeners(listenerType);</span>
        }

<span class="nc bnc" id="L4724" title="All 2 branches missed.">        if (result.length == 0) {</span>
<span class="nc" id="L4725">            return super.getListeners(listenerType);</span>
        }
<span class="nc" id="L4727">        return result;</span>
    }

    /**
     * Notifies this component that it now has a parent component.
     * When this method is invoked, the chain of parent components is
     * set up with &lt;code&gt;KeyboardAction&lt;/code&gt; event listeners.
     * This method is called by the toolkit internally and should
     * not be called directly by programs.
     *
     * @see #registerKeyboardAction
     */
    public void addNotify() {
<span class="nc" id="L4740">        super.addNotify();</span>
<span class="nc" id="L4741">        firePropertyChange(&quot;ancestor&quot;, null, getParent());</span>

<span class="nc" id="L4743">        registerWithKeyboardManager(false);</span>
<span class="nc" id="L4744">        registerNextFocusableComponent();</span>
<span class="nc" id="L4745">    }</span>


    /**
     * Notifies this component that it no longer has a parent component.
     * When this method is invoked, any &lt;code&gt;KeyboardAction&lt;/code&gt;s
     * set up in the the chain of parent components are removed.
     * This method is called by the toolkit internally and should
     * not be called directly by programs.
     *
     * @see #registerKeyboardAction
     */
    public void removeNotify() {
<span class="nc" id="L4758">        super.removeNotify();</span>
        // This isn't strictly correct.  The event shouldn't be
        // fired until *after* the parent is set to null.  But
        // we only get notified before that happens
<span class="nc" id="L4762">        firePropertyChange(&quot;ancestor&quot;, getParent(), null);</span>

<span class="nc" id="L4764">        unregisterWithKeyboardManager();</span>
<span class="nc" id="L4765">        deregisterNextFocusableComponent();</span>

<span class="nc bnc" id="L4767" title="All 2 branches missed.">        if (getCreatedDoubleBuffer()) {</span>
<span class="nc" id="L4768">            RepaintManager.currentManager(this).resetDoubleBuffer();</span>
<span class="nc" id="L4769">            setCreatedDoubleBuffer(false);</span>
        }
<span class="nc bnc" id="L4771" title="All 2 branches missed.">        if (autoscrolls) {</span>
<span class="nc" id="L4772">            Autoscroller.stop(this);</span>
        }
<span class="nc" id="L4774">    }</span>


    /**
     * Adds the specified region to the dirty region list if the component
     * is showing.  The component will be repainted after all of the
     * currently pending events have been dispatched.
     *
     * @param tm  this parameter is not used
     * @param x  the x value of the dirty region
     * @param y  the y value of the dirty region
     * @param width  the width of the dirty region
     * @param height  the height of the dirty region
     * @see #isPaintingOrigin()
     * @see java.awt.Component#isShowing
     * @see RepaintManager#addDirtyRegion
     */
    public void repaint(long tm, int x, int y, int width, int height) {
<span class="nc" id="L4792">        RepaintManager.currentManager(this).addDirtyRegion(this, x, y, width, height);</span>
<span class="nc" id="L4793">    }</span>


    /**
     * Adds the specified region to the dirty region list if the component
     * is showing.  The component will be repainted after all of the
     * currently pending events have been dispatched.
     *
     * @param  r a &lt;code&gt;Rectangle&lt;/code&gt; containing the dirty region
     * @see #isPaintingOrigin()
     * @see java.awt.Component#isShowing
     * @see RepaintManager#addDirtyRegion
     */
    public void repaint(Rectangle r) {
<span class="nc" id="L4807">        repaint(0,r.x,r.y,r.width,r.height);</span>
<span class="nc" id="L4808">    }</span>


    /**
     * Supports deferred automatic layout.
     * &lt;p&gt;
     * Calls &lt;code&gt;invalidate&lt;/code&gt; and then adds this component's
     * &lt;code&gt;validateRoot&lt;/code&gt; to a list of components that need to be
     * validated.  Validation will occur after all currently pending
     * events have been dispatched.  In other words after this method
     * is called,  the first validateRoot (if any) found when walking
     * up the containment hierarchy of this component will be validated.
     * By default, &lt;code&gt;JRootPane&lt;/code&gt;, &lt;code&gt;JScrollPane&lt;/code&gt;,
     * and &lt;code&gt;JTextField&lt;/code&gt; return true
     * from &lt;code&gt;isValidateRoot&lt;/code&gt;.
     * &lt;p&gt;
     * This method will automatically be called on this component
     * when a property value changes such that size, location, or
     * internal layout of this component has been affected.  This automatic
     * updating differs from the AWT because programs generally no
     * longer need to invoke &lt;code&gt;validate&lt;/code&gt; to get the contents of the
     * GUI to update.
     * &lt;p&gt;
     *
     * @see java.awt.Component#invalidate
     * @see java.awt.Container#validate
     * @see #isValidateRoot
     * @see RepaintManager#addInvalidComponent
     */
    public void revalidate() {
<span class="nc bnc" id="L4838" title="All 2 branches missed.">        if (getParent() == null) {</span>
            // Note: We don't bother invalidating here as once added
            // to a valid parent invalidate will be invoked (addImpl
            // invokes addNotify which will invoke invalidate on the
            // new Component). Also, if we do add a check to isValid
            // here it can potentially be called before the constructor
            // which was causing some people grief.
<span class="nc" id="L4845">            return;</span>
        }
<span class="nc bnc" id="L4847" title="All 2 branches missed.">        if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L4848">            invalidate();</span>
<span class="nc" id="L4849">            RepaintManager.currentManager(this).addInvalidComponent(this);</span>
        }
        else {
            // To avoid a flood of Runnables when constructing GUIs off
            // the EDT, a flag is maintained as to whether or not
            // a Runnable has been scheduled.
<span class="nc" id="L4855">            synchronized(this) {</span>
<span class="nc bnc" id="L4856" title="All 2 branches missed.">                if (getFlag(REVALIDATE_RUNNABLE_SCHEDULED)) {</span>
<span class="nc" id="L4857">                    return;</span>
                }
<span class="nc" id="L4859">                setFlag(REVALIDATE_RUNNABLE_SCHEDULED, true);</span>
<span class="nc" id="L4860">            }</span>
<span class="nc" id="L4861">            Runnable callRevalidate = new Runnable() {</span>
                public void run() {
<span class="nc" id="L4863">                    synchronized(JComponent.this) {</span>
<span class="nc" id="L4864">                        setFlag(REVALIDATE_RUNNABLE_SCHEDULED, false);</span>
<span class="nc" id="L4865">                    }</span>
<span class="nc" id="L4866">                    revalidate();</span>
<span class="nc" id="L4867">                }</span>
            };
<span class="nc" id="L4869">            SwingUtilities.invokeLater(callRevalidate);</span>
        }
<span class="nc" id="L4871">    }</span>

    /**
     * If this method returns true, &lt;code&gt;revalidate&lt;/code&gt; calls by
     * descendants of this component will cause the entire tree
     * beginning with this root to be validated.
     * Returns false by default.  &lt;code&gt;JScrollPane&lt;/code&gt; overrides
     * this method and returns true.
     *
     * @return always returns false
     * @see #revalidate
     * @see java.awt.Component#invalidate
     * @see java.awt.Container#validate
     * @see java.awt.Container#isValidateRoot
     */
    @Override
    public boolean isValidateRoot() {
<span class="nc" id="L4888">        return false;</span>
    }


    /**
     * Returns true if this component tiles its children -- that is, if
     * it can guarantee that the children will not overlap.  The
     * repainting system is substantially more efficient in this
     * common case.  &lt;code&gt;JComponent&lt;/code&gt; subclasses that can't make this
     * guarantee, such as &lt;code&gt;JLayeredPane&lt;/code&gt;,
     * should override this method to return false.
     *
     * @return always returns true
     */
    public boolean isOptimizedDrawingEnabled() {
<span class="nc" id="L4903">        return true;</span>
    }

    /**
     * Returns {@code true} if a paint triggered on a child component should cause
     * painting to originate from this Component, or one of its ancestors.
     * &lt;p&gt;
     * Calling {@link #repaint} or {@link #paintImmediately(int, int, int, int)}
     * on a Swing component will result in calling
     * the {@link JComponent#paintImmediately(int, int, int, int)} method of
     * the first ancestor which {@code isPaintingOrigin()} returns {@code true}, if there are any.
     * &lt;p&gt;
     * {@code JComponent} subclasses that need to be painted when any of their
     * children are repainted should override this method to return {@code true}.
     *
     * @return always returns {@code false}
     *
     * @see #paintImmediately(int, int, int, int)
     */
    protected boolean isPaintingOrigin() {
<span class="nc" id="L4923">        return false;</span>
    }

    /**
     * Paints the specified region in this component and all of its
     * descendants that overlap the region, immediately.
     * &lt;p&gt;
     * It's rarely necessary to call this method.  In most cases it's
     * more efficient to call repaint, which defers the actual painting
     * and can collapse redundant requests into a single paint call.
     * This method is useful if one needs to update the display while
     * the current event is being dispatched.
     * &lt;p&gt;
     * This method is to be overridden when the dirty region needs to be changed
     * for components that are painting origins.
     *
     * @param x  the x value of the region to be painted
     * @param y  the y value of the region to be painted
     * @param w  the width of the region to be painted
     * @param h  the height of the region to be painted
     * @see #repaint
     * @see #isPaintingOrigin()
     */
    public void paintImmediately(int x,int y,int w, int h) {
<span class="nc" id="L4947">        Component c = this;</span>
        Component parent;

<span class="nc bnc" id="L4950" title="All 2 branches missed.">        if(!isShowing()) {</span>
<span class="nc" id="L4951">            return;</span>
        }

<span class="nc" id="L4954">        JComponent paintingOigin = SwingUtilities.getPaintingOrigin(this);</span>
<span class="nc bnc" id="L4955" title="All 2 branches missed.">        if (paintingOigin != null) {</span>
<span class="nc" id="L4956">            Rectangle rectangle = SwingUtilities.convertRectangle(</span>
                    c, new Rectangle(x, y, w, h), paintingOigin);
<span class="nc" id="L4958">            paintingOigin.paintImmediately(rectangle.x, rectangle.y, rectangle.width, rectangle.height);</span>
<span class="nc" id="L4959">            return;</span>
        }

<span class="nc bnc" id="L4962" title="All 2 branches missed.">        while(!c.isOpaque()) {</span>
<span class="nc" id="L4963">            parent = c.getParent();</span>
<span class="nc bnc" id="L4964" title="All 2 branches missed.">            if(parent != null) {</span>
<span class="nc" id="L4965">                x += c.getX();</span>
<span class="nc" id="L4966">                y += c.getY();</span>
<span class="nc" id="L4967">                c = parent;</span>
            } else {
                break;
            }

<span class="nc bnc" id="L4972" title="All 2 branches missed.">            if(!(c instanceof JComponent)) {</span>
<span class="nc" id="L4973">                break;</span>
            }
        }
<span class="nc bnc" id="L4976" title="All 2 branches missed.">        if(c instanceof JComponent) {</span>
<span class="nc" id="L4977">            ((JComponent)c)._paintImmediately(x,y,w,h);</span>
        } else {
<span class="nc" id="L4979">            c.repaint(x,y,w,h);</span>
        }
<span class="nc" id="L4981">    }</span>

    /**
     * Paints the specified region now.
     *
     * @param r a &lt;code&gt;Rectangle&lt;/code&gt; containing the region to be painted
     */
    public void paintImmediately(Rectangle r) {
<span class="nc" id="L4989">        paintImmediately(r.x,r.y,r.width,r.height);</span>
<span class="nc" id="L4990">    }</span>

    /**
     * Returns whether this component should be guaranteed to be on top.
     * For example, it would make no sense for &lt;code&gt;Menu&lt;/code&gt;s to pop up
     * under another component, so they would always return true.
     * Most components will want to return false, hence that is the default.
     *
     * @return always returns false
     */
    // package private
    boolean alwaysOnTop() {
<span class="nc" id="L5002">        return false;</span>
    }

    void setPaintingChild(Component paintingChild) {
<span class="nc" id="L5006">        this.paintingChild = paintingChild;</span>
<span class="nc" id="L5007">    }</span>

    void _paintImmediately(int x, int y, int w, int h) {
        Graphics g;
        Container c;
        Rectangle b;

        int tmpX, tmpY, tmpWidth, tmpHeight;
<span class="nc" id="L5015">        int offsetX=0,offsetY=0;</span>

<span class="nc" id="L5017">        boolean hasBuffer = false;</span>

<span class="nc" id="L5019">        JComponent bufferedComponent = null;</span>
<span class="nc" id="L5020">        JComponent paintingComponent = this;</span>

<span class="nc" id="L5022">        RepaintManager repaintManager = RepaintManager.currentManager(this);</span>
        // parent Container's up to Window or Applet. First container is
        // the direct parent. Note that in testing it was faster to
        // alloc a new Vector vs keeping a stack of them around, and gc
        // seemed to have a minimal effect on this.
<span class="nc" id="L5027">        java.util.List&lt;Component&gt; path = new java.util.ArrayList&lt;Component&gt;(7);</span>
<span class="nc" id="L5028">        int pIndex = -1;</span>
<span class="nc" id="L5029">        int pCount = 0;</span>

<span class="nc" id="L5031">        tmpX = tmpY = tmpWidth = tmpHeight = 0;</span>

<span class="nc" id="L5033">        Rectangle paintImmediatelyClip = fetchRectangle();</span>
<span class="nc" id="L5034">        paintImmediatelyClip.x = x;</span>
<span class="nc" id="L5035">        paintImmediatelyClip.y = y;</span>
<span class="nc" id="L5036">        paintImmediatelyClip.width = w;</span>
<span class="nc" id="L5037">        paintImmediatelyClip.height = h;</span>


        // System.out.println(&quot;1) ************* in _paintImmediately for &quot; + this);

<span class="nc bnc" id="L5042" title="All 4 branches missed.">        boolean ontop = alwaysOnTop() &amp;&amp; isOpaque();</span>
<span class="nc bnc" id="L5043" title="All 2 branches missed.">        if (ontop) {</span>
<span class="nc" id="L5044">            SwingUtilities.computeIntersection(0, 0, getWidth(), getHeight(),</span>
                                               paintImmediatelyClip);
<span class="nc bnc" id="L5046" title="All 2 branches missed.">            if (paintImmediatelyClip.width == 0) {</span>
<span class="nc" id="L5047">                recycleRectangle(paintImmediatelyClip);</span>
<span class="nc" id="L5048">                return;</span>
            }
        }
        Component child;
<span class="nc" id="L5052">        for (c = this, child = null;</span>
<span class="nc bnc" id="L5053" title="All 6 branches missed.">             c != null &amp;&amp; !(c instanceof Window) &amp;&amp; !(c instanceof Applet);</span>
<span class="nc" id="L5054">             child = c, c = c.getParent()) {</span>
<span class="nc bnc" id="L5055" title="All 2 branches missed.">                JComponent jc = (c instanceof JComponent) ? (JComponent)c :</span>
                                null;
<span class="nc" id="L5057">                path.add(c);</span>
<span class="nc bnc" id="L5058" title="All 6 branches missed.">                if(!ontop &amp;&amp; jc != null &amp;&amp; !jc.isOptimizedDrawingEnabled()) {</span>
                    boolean resetPC;

                    // Children of c may overlap, three possible cases for the
                    // painting region:
                    // . Completely obscured by an opaque sibling, in which
                    //   case there is no need to paint.
                    // . Partially obscured by a sibling: need to start
                    //   painting from c.
                    // . Otherwise we aren't obscured and thus don't need to
                    //   start painting from parent.
<span class="nc bnc" id="L5069" title="All 2 branches missed.">                    if (c != this) {</span>
<span class="nc bnc" id="L5070" title="All 2 branches missed.">                        if (jc.isPaintingOrigin()) {</span>
<span class="nc" id="L5071">                            resetPC = true;</span>
                        }
                        else {
<span class="nc" id="L5074">                            Component[] children = c.getComponents();</span>
<span class="nc" id="L5075">                            int i = 0;</span>
<span class="nc bnc" id="L5076" title="All 2 branches missed.">                            for (; i&lt;children.length; i++) {</span>
<span class="nc bnc" id="L5077" title="All 2 branches missed.">                                if (children[i] == child) break;</span>
                            }
<span class="nc bnc" id="L5079" title="All 3 branches missed.">                            switch (jc.getObscuredState(i,</span>
                                            paintImmediatelyClip.x,
                                            paintImmediatelyClip.y,
                                            paintImmediatelyClip.width,
                                            paintImmediatelyClip.height)) {
                            case NOT_OBSCURED:
<span class="nc" id="L5085">                                resetPC = false;</span>
<span class="nc" id="L5086">                                break;</span>
                            case COMPLETELY_OBSCURED:
<span class="nc" id="L5088">                                recycleRectangle(paintImmediatelyClip);</span>
<span class="nc" id="L5089">                                return;</span>
                            default:
<span class="nc" id="L5091">                                resetPC = true;</span>
                                break;
                            }
<span class="nc" id="L5094">                        }</span>
                    }
                    else {
<span class="nc" id="L5097">                        resetPC = false;</span>
                    }

<span class="nc bnc" id="L5100" title="All 2 branches missed.">                    if (resetPC) {</span>
                        // Get rid of any buffer since we draw from here and
                        // we might draw something larger
<span class="nc" id="L5103">                        paintingComponent = jc;</span>
<span class="nc" id="L5104">                        pIndex = pCount;</span>
<span class="nc" id="L5105">                        offsetX = offsetY = 0;</span>
<span class="nc" id="L5106">                        hasBuffer = false;</span>
                    }
                }
<span class="nc" id="L5109">                pCount++;</span>

                // look to see if the parent (and therefor this component)
                // is double buffered
<span class="nc bnc" id="L5113" title="All 4 branches missed.">                if(repaintManager.isDoubleBufferingEnabled() &amp;&amp; jc != null &amp;&amp;</span>
<span class="nc bnc" id="L5114" title="All 2 branches missed.">                                  jc.isDoubleBuffered()) {</span>
<span class="nc" id="L5115">                    hasBuffer = true;</span>
<span class="nc" id="L5116">                    bufferedComponent = jc;</span>
                }

                // if we aren't on top, include the parent's clip
<span class="nc bnc" id="L5120" title="All 2 branches missed.">                if (!ontop) {</span>
<span class="nc" id="L5121">                    int bx = c.getX();</span>
<span class="nc" id="L5122">                    int by = c.getY();</span>
<span class="nc" id="L5123">                    tmpWidth = c.getWidth();</span>
<span class="nc" id="L5124">                    tmpHeight = c.getHeight();</span>
<span class="nc" id="L5125">                    SwingUtilities.computeIntersection(tmpX,tmpY,tmpWidth,tmpHeight,paintImmediatelyClip);</span>
<span class="nc" id="L5126">                    paintImmediatelyClip.x += bx;</span>
<span class="nc" id="L5127">                    paintImmediatelyClip.y += by;</span>
<span class="nc" id="L5128">                    offsetX += bx;</span>
<span class="nc" id="L5129">                    offsetY += by;</span>
                }
        }

        // If the clip width or height is negative, don't bother painting
<span class="nc bnc" id="L5134" title="All 8 branches missed.">        if(c == null || c.getPeer() == null ||</span>
                        paintImmediatelyClip.width &lt;= 0 ||
                        paintImmediatelyClip.height &lt;= 0) {
<span class="nc" id="L5137">            recycleRectangle(paintImmediatelyClip);</span>
<span class="nc" id="L5138">            return;</span>
        }

<span class="nc" id="L5141">        paintingComponent.setFlag(IS_REPAINTING, true);</span>

<span class="nc" id="L5143">        paintImmediatelyClip.x -= offsetX;</span>
<span class="nc" id="L5144">        paintImmediatelyClip.y -= offsetY;</span>

        // Notify the Components that are going to be painted of the
        // child component to paint to.
<span class="nc bnc" id="L5148" title="All 2 branches missed.">        if(paintingComponent != this) {</span>
            Component comp;
<span class="nc" id="L5150">            int i = pIndex;</span>
<span class="nc bnc" id="L5151" title="All 2 branches missed.">            for(; i &gt; 0 ; i--) {</span>
<span class="nc" id="L5152">                comp = path.get(i);</span>
<span class="nc bnc" id="L5153" title="All 2 branches missed.">                if(comp instanceof JComponent) {</span>
<span class="nc" id="L5154">                    ((JComponent)comp).setPaintingChild(path.get(i-1));</span>
                }
            }
        }
        try {
<span class="nc bnc" id="L5159" title="All 2 branches missed.">            if ((g = safelyGetGraphics(paintingComponent, c)) != null) {</span>
                try {
<span class="nc bnc" id="L5161" title="All 2 branches missed.">                    if (hasBuffer) {</span>
<span class="nc" id="L5162">                        RepaintManager rm = RepaintManager.currentManager(</span>
                                bufferedComponent);
<span class="nc" id="L5164">                        rm.beginPaint();</span>
                        try {
<span class="nc" id="L5166">                            rm.paint(paintingComponent, bufferedComponent, g,</span>
                                    paintImmediatelyClip.x,
                                    paintImmediatelyClip.y,
                                    paintImmediatelyClip.width,
                                    paintImmediatelyClip.height);
                        } finally {
<span class="nc" id="L5172">                            rm.endPaint();</span>
<span class="nc" id="L5173">                        }</span>
<span class="nc" id="L5174">                    } else {</span>
<span class="nc" id="L5175">                        g.setClip(paintImmediatelyClip.x, paintImmediatelyClip.y,</span>
                                paintImmediatelyClip.width, paintImmediatelyClip.height);
<span class="nc" id="L5177">                        paintingComponent.paint(g);</span>
                    }
                } finally {
<span class="nc" id="L5180">                    g.dispose();</span>
<span class="nc" id="L5181">                }</span>
            }
        }
        finally {
            // Reset the painting child for the parent components.
<span class="nc bnc" id="L5186" title="All 4 branches missed.">            if(paintingComponent != this) {</span>
                Component comp;
<span class="nc" id="L5188">                int i = pIndex;</span>
<span class="nc bnc" id="L5189" title="All 4 branches missed.">                for(; i &gt; 0 ; i--) {</span>
<span class="nc" id="L5190">                    comp = path.get(i);</span>
<span class="nc bnc" id="L5191" title="All 4 branches missed.">                    if(comp instanceof JComponent) {</span>
<span class="nc" id="L5192">                        ((JComponent)comp).setPaintingChild(null);</span>
                    }
                }
            }
<span class="nc" id="L5196">            paintingComponent.setFlag(IS_REPAINTING, false);</span>
<span class="nc" id="L5197">        }</span>
<span class="nc" id="L5198">        recycleRectangle(paintImmediatelyClip);</span>
<span class="nc" id="L5199">    }</span>

    /**
     * Paints to the specified graphics.  This does not set the clip and it
     * does not adjust the Graphics in anyway, callers must do that first.
     * This method is package-private for RepaintManager.PaintManager and
     * its subclasses to call, it is NOT intended for general use outside
     * of that.
     */
    void paintToOffscreen(Graphics g, int x, int y, int w, int h, int maxX,
                          int maxY) {
        try {
<span class="nc" id="L5211">            setFlag(ANCESTOR_USING_BUFFER, true);</span>
<span class="nc bnc" id="L5212" title="All 4 branches missed.">            if ((y + h) &lt; maxY || (x + w) &lt; maxX) {</span>
<span class="nc" id="L5213">                setFlag(IS_PAINTING_TILE, true);</span>
            }
<span class="nc bnc" id="L5215" title="All 2 branches missed.">            if (getFlag(IS_REPAINTING)) {</span>
                // Called from paintImmediately (RepaintManager) to fill
                // repaint request
<span class="nc" id="L5218">                paint(g);</span>
            } else {
                // Called from paint() (AWT) to repair damage
<span class="nc bnc" id="L5221" title="All 2 branches missed.">                if(!rectangleIsObscured(x, y, w, h)) {</span>
<span class="nc" id="L5222">                    paintComponent(g);</span>
<span class="nc" id="L5223">                    paintBorder(g);</span>
                }
<span class="nc" id="L5225">                paintChildren(g);</span>
            }
        } finally {
<span class="nc" id="L5228">            setFlag(ANCESTOR_USING_BUFFER, false);</span>
<span class="nc" id="L5229">            setFlag(IS_PAINTING_TILE, false);</span>
<span class="nc" id="L5230">        }</span>
<span class="nc" id="L5231">    }</span>

    /**
     * Returns whether or not the region of the specified component is
     * obscured by a sibling.
     *
     * @return NOT_OBSCURED if non of the siblings above the Component obscure
     *         it, COMPLETELY_OBSCURED if one of the siblings completely
     *         obscures the Component or PARTIALLY_OBSCURED if the Component is
     *         only partially obscured.
     */
    private int getObscuredState(int compIndex, int x, int y, int width,
                                 int height) {
<span class="nc" id="L5244">        int retValue = NOT_OBSCURED;</span>
<span class="nc" id="L5245">        Rectangle tmpRect = fetchRectangle();</span>

<span class="nc bnc" id="L5247" title="All 2 branches missed.">        for (int i = compIndex - 1 ; i &gt;= 0 ; i--) {</span>
<span class="nc" id="L5248">            Component sibling = getComponent(i);</span>
<span class="nc bnc" id="L5249" title="All 2 branches missed.">            if (!sibling.isVisible()) {</span>
<span class="nc" id="L5250">                continue;</span>
            }
            Rectangle siblingRect;
            boolean opaque;
<span class="nc bnc" id="L5254" title="All 2 branches missed.">            if (sibling instanceof JComponent) {</span>
<span class="nc" id="L5255">                opaque = sibling.isOpaque();</span>
<span class="nc bnc" id="L5256" title="All 2 branches missed.">                if (!opaque) {</span>
<span class="nc bnc" id="L5257" title="All 2 branches missed.">                    if (retValue == PARTIALLY_OBSCURED) {</span>
<span class="nc" id="L5258">                        continue;</span>
                    }
                }
            }
            else {
<span class="nc" id="L5263">                opaque = true;</span>
            }
<span class="nc" id="L5265">            siblingRect = sibling.getBounds(tmpRect);</span>
<span class="nc bnc" id="L5266" title="All 10 branches missed.">            if (opaque &amp;&amp; x &gt;= siblingRect.x &amp;&amp; (x + width) &lt;=</span>
                     (siblingRect.x + siblingRect.width) &amp;&amp;
                     y &gt;= siblingRect.y &amp;&amp; (y + height) &lt;=
                     (siblingRect.y + siblingRect.height)) {
<span class="nc" id="L5270">                recycleRectangle(tmpRect);</span>
<span class="nc" id="L5271">                return COMPLETELY_OBSCURED;</span>
            }
<span class="nc bnc" id="L5273" title="All 10 branches missed.">            else if (retValue == NOT_OBSCURED &amp;&amp;</span>
                     !((x + width &lt;= siblingRect.x) ||
                       (y + height &lt;= siblingRect.y) ||
                       (x &gt;= siblingRect.x + siblingRect.width) ||
                       (y &gt;= siblingRect.y + siblingRect.height))) {
<span class="nc" id="L5278">                retValue = PARTIALLY_OBSCURED;</span>
            }
        }
<span class="nc" id="L5281">        recycleRectangle(tmpRect);</span>
<span class="nc" id="L5282">        return retValue;</span>
    }

    /**
     * Returns true, which implies that before checking if a child should
     * be painted it is first check that the child is not obscured by another
     * sibling. This is only checked if &lt;code&gt;isOptimizedDrawingEnabled&lt;/code&gt;
     * returns false.
     *
     * @return always returns true
     */
    boolean checkIfChildObscuredBySibling() {
<span class="nc" id="L5294">        return true;</span>
    }


    private void setFlag(int aFlag, boolean aValue) {
<span class="nc bnc" id="L5299" title="All 2 branches missed.">        if(aValue) {</span>
<span class="nc" id="L5300">            flags |= (1 &lt;&lt; aFlag);</span>
        } else {
<span class="nc" id="L5302">            flags &amp;= ~(1 &lt;&lt; aFlag);</span>
        }
<span class="nc" id="L5304">    }</span>
    private boolean getFlag(int aFlag) {
<span class="nc" id="L5306">        int mask = (1 &lt;&lt; aFlag);</span>
<span class="nc bnc" id="L5307" title="All 2 branches missed.">        return ((flags &amp; mask) == mask);</span>
    }
    // These functions must be static so that they can be called from
    // subclasses inside the package, but whose inheritance hierarhcy includes
    // classes outside of the package below JComponent (e.g., JTextArea).
    static void setWriteObjCounter(JComponent comp, byte count) {
<span class="nc" id="L5313">        comp.flags = (comp.flags &amp; ~(0xFF &lt;&lt; WRITE_OBJ_COUNTER_FIRST)) |</span>
                     (count &lt;&lt; WRITE_OBJ_COUNTER_FIRST);
<span class="nc" id="L5315">    }</span>
    static byte getWriteObjCounter(JComponent comp) {
<span class="nc" id="L5317">        return (byte)((comp.flags &gt;&gt; WRITE_OBJ_COUNTER_FIRST) &amp; 0xFF);</span>
    }

    /** Buffering **/

    /**
     *  Sets whether this component should use a buffer to paint.
     *  If set to true, all the drawing from this component will be done
     *  in an offscreen painting buffer. The offscreen painting buffer will
     *  the be copied onto the screen.
     *  If a &lt;code&gt;Component&lt;/code&gt; is buffered and one of its ancestor
     *  is also buffered, the ancestor buffer will be used.
     *
     *  @param aFlag if true, set this component to be double buffered
     */
    public void setDoubleBuffered(boolean aFlag) {
<span class="nc" id="L5333">        setFlag(IS_DOUBLE_BUFFERED,aFlag);</span>
<span class="nc" id="L5334">    }</span>

    /**
     * Returns whether this component should use a buffer to paint.
     *
     * @return true if this component is double buffered, otherwise false
     */
    public boolean isDoubleBuffered() {
<span class="nc" id="L5342">        return getFlag(IS_DOUBLE_BUFFERED);</span>
    }

    /**
     * Returns the &lt;code&gt;JRootPane&lt;/code&gt; ancestor for this component.
     *
     * @return the &lt;code&gt;JRootPane&lt;/code&gt; that contains this component,
     *          or &lt;code&gt;null&lt;/code&gt; if no &lt;code&gt;JRootPane&lt;/code&gt; is found
     */
    public JRootPane getRootPane() {
<span class="nc" id="L5352">        return SwingUtilities.getRootPane(this);</span>
    }


    /** Serialization **/

    /**
     * This is called from Component by way of reflection. Do NOT change
     * the name unless you change the code in Component as well.
     */
    void compWriteObjectNotify() {
<span class="nc" id="L5363">        byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L5364">        JComponent.setWriteObjCounter(this, (byte)(count + 1));</span>
<span class="nc bnc" id="L5365" title="All 2 branches missed.">        if (count != 0) {</span>
<span class="nc" id="L5366">            return;</span>
        }

<span class="nc" id="L5369">        uninstallUIAndProperties();</span>

        /* JTableHeader is in a separate package, which prevents it from
         * being able to override this package-private method the way the
         * other components can.  We don't want to make this method protected
         * because it would introduce public-api for a less-than-desirable
         * serialization scheme, so we compromise with this 'instanceof' hack
         * for now.
         */
<span class="nc bnc" id="L5378" title="All 4 branches missed.">        if (getToolTipText() != null ||</span>
            this instanceof javax.swing.table.JTableHeader) {
<span class="nc" id="L5380">            ToolTipManager.sharedInstance().unregisterComponent(JComponent.this);</span>
        }
<span class="nc" id="L5382">    }</span>

    /**
     * This object is the &lt;code&gt;ObjectInputStream&lt;/code&gt; callback
     * that's called after a complete graph of objects (including at least
     * one &lt;code&gt;JComponent&lt;/code&gt;) has been read.
     *  It sets the UI property of each Swing component
     * that was read to the current default with &lt;code&gt;updateUI&lt;/code&gt;.
     * &lt;p&gt;
     * As each  component is read in we keep track of the current set of
     * root components here, in the roots vector.  Note that there's only one
     * &lt;code&gt;ReadObjectCallback&lt;/code&gt; per &lt;code&gt;ObjectInputStream&lt;/code&gt;,
     * they're stored in the static &lt;code&gt;readObjectCallbacks&lt;/code&gt;
     * hashtable.
     *
     * @see java.io.ObjectInputStream#registerValidation
     * @see SwingUtilities#updateComponentTreeUI
     */
    private class ReadObjectCallback implements ObjectInputValidation
    {
<span class="nc" id="L5402">        private final Vector&lt;JComponent&gt; roots = new Vector&lt;JComponent&gt;(1);</span>
        private final ObjectInputStream inputStream;

<span class="nc" id="L5405">        ReadObjectCallback(ObjectInputStream s) throws Exception {</span>
<span class="nc" id="L5406">            inputStream = s;</span>
<span class="nc" id="L5407">            s.registerValidation(this, 0);</span>
<span class="nc" id="L5408">        }</span>

        /**
         * This is the method that's called after the entire graph
         * of objects has been read in.  It initializes
         * the UI property of all of the copmonents with
         * &lt;code&gt;SwingUtilities.updateComponentTreeUI&lt;/code&gt;.
         */
        public void validateObject() throws InvalidObjectException {
            try {
<span class="nc bnc" id="L5418" title="All 2 branches missed.">                for (JComponent root : roots) {</span>
<span class="nc" id="L5419">                    SwingUtilities.updateComponentTreeUI(root);</span>
<span class="nc" id="L5420">                }</span>
            }
            finally {
<span class="nc" id="L5423">                readObjectCallbacks.remove(inputStream);</span>
<span class="nc" id="L5424">            }</span>
<span class="nc" id="L5425">        }</span>

        /**
         * If &lt;code&gt;c&lt;/code&gt; isn't a descendant of a component we've already
         * seen, then add it to the roots &lt;code&gt;Vector&lt;/code&gt;.
         *
         * @param c the &lt;code&gt;JComponent&lt;/code&gt; to add
         */
        private void registerComponent(JComponent c)
        {
            /* If the Component c is a descendant of one of the
             * existing roots (or it IS an existing root), we're done.
             */
<span class="nc bnc" id="L5438" title="All 2 branches missed.">            for (JComponent root : roots) {</span>
<span class="nc bnc" id="L5439" title="All 2 branches missed.">                for(Component p = c; p != null; p = p.getParent()) {</span>
<span class="nc bnc" id="L5440" title="All 2 branches missed.">                    if (p == root) {</span>
<span class="nc" id="L5441">                        return;</span>
                    }
                }
<span class="nc" id="L5444">            }</span>

            /* Otherwise: if Component c is an ancestor of any of the
             * existing roots then remove them and add c (the &quot;new root&quot;)
             * to the roots vector.
             */
<span class="nc bnc" id="L5450" title="All 2 branches missed.">            for(int i = 0; i &lt; roots.size(); i++) {</span>
<span class="nc" id="L5451">                JComponent root = roots.elementAt(i);</span>
<span class="nc bnc" id="L5452" title="All 2 branches missed.">                for(Component p = root.getParent(); p != null; p = p.getParent()) {</span>
<span class="nc bnc" id="L5453" title="All 2 branches missed.">                    if (p == c) {</span>
<span class="nc" id="L5454">                        roots.removeElementAt(i--); // !!</span>
<span class="nc" id="L5455">                        break;</span>
                    }
                }
            }

<span class="nc" id="L5460">            roots.addElement(c);</span>
<span class="nc" id="L5461">        }</span>
    }


    /**
     * We use the &lt;code&gt;ObjectInputStream&lt;/code&gt; &quot;registerValidation&quot;
     * callback to update the UI for the entire tree of components
     * after they've all been read in.
     *
     * @param s  the &lt;code&gt;ObjectInputStream&lt;/code&gt; from which to read
     */
    private void readObject(ObjectInputStream s)
        throws IOException, ClassNotFoundException
    {
<span class="nc" id="L5475">        s.defaultReadObject();</span>

        /* If there's no ReadObjectCallback for this stream yet, that is, if
         * this is the first call to JComponent.readObject() for this
         * graph of objects, then create a callback and stash it
         * in the readObjectCallbacks table.  Note that the ReadObjectCallback
         * constructor takes care of calling s.registerValidation().
         */
<span class="nc" id="L5483">        ReadObjectCallback cb = readObjectCallbacks.get(s);</span>
<span class="nc bnc" id="L5484" title="All 2 branches missed.">        if (cb == null) {</span>
            try {
<span class="nc" id="L5486">                readObjectCallbacks.put(s, cb = new ReadObjectCallback(s));</span>
            }
<span class="nc" id="L5488">            catch (Exception e) {</span>
<span class="nc" id="L5489">                throw new IOException(e.toString());</span>
<span class="nc" id="L5490">            }</span>
        }
<span class="nc" id="L5492">        cb.registerComponent(this);</span>

        // Read back the client properties.
<span class="nc" id="L5495">        int cpCount = s.readInt();</span>
<span class="nc bnc" id="L5496" title="All 2 branches missed.">        if (cpCount &gt; 0) {</span>
<span class="nc" id="L5497">            clientProperties = new ArrayTable();</span>
<span class="nc bnc" id="L5498" title="All 2 branches missed.">            for (int counter = 0; counter &lt; cpCount; counter++) {</span>
<span class="nc" id="L5499">                clientProperties.put(s.readObject(),</span>
<span class="nc" id="L5500">                                     s.readObject());</span>
            }
        }
<span class="nc bnc" id="L5503" title="All 2 branches missed.">        if (getToolTipText() != null) {</span>
<span class="nc" id="L5504">            ToolTipManager.sharedInstance().registerComponent(this);</span>
        }
<span class="nc" id="L5506">        setWriteObjCounter(this, (byte)0);</span>
<span class="nc" id="L5507">    }</span>


    /**
     * Before writing a &lt;code&gt;JComponent&lt;/code&gt; to an
     * &lt;code&gt;ObjectOutputStream&lt;/code&gt; we temporarily uninstall its UI.
     * This is tricky to do because we want to uninstall
     * the UI before any of the &lt;code&gt;JComponent&lt;/code&gt;'s children
     * (or its &lt;code&gt;LayoutManager&lt;/code&gt; etc.) are written,
     * and we don't want to restore the UI until the most derived
     * &lt;code&gt;JComponent&lt;/code&gt; subclass has been been stored.
     *
     * @param s the &lt;code&gt;ObjectOutputStream&lt;/code&gt; in which to write
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L5522">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L5523" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L5524">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L5525">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L5526" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L5527">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L5530">        ArrayTable.writeArrayTable(s, clientProperties);</span>
<span class="nc" id="L5531">    }</span>


    /**
     * Returns a string representation of this &lt;code&gt;JComponent&lt;/code&gt;.
     * This method
     * is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this &lt;code&gt;JComponent&lt;/code&gt;
     */
    protected String paramString() {
<span class="nc bnc" id="L5545" title="All 2 branches missed.">        String preferredSizeString = (isPreferredSizeSet() ?</span>
<span class="nc" id="L5546">                                      getPreferredSize().toString() : &quot;&quot;);</span>
<span class="nc bnc" id="L5547" title="All 2 branches missed.">        String minimumSizeString = (isMinimumSizeSet() ?</span>
<span class="nc" id="L5548">                                    getMinimumSize().toString() : &quot;&quot;);</span>
<span class="nc bnc" id="L5549" title="All 2 branches missed.">        String maximumSizeString = (isMaximumSizeSet() ?</span>
<span class="nc" id="L5550">                                    getMaximumSize().toString() : &quot;&quot;);</span>
<span class="nc bnc" id="L5551" title="All 4 branches missed.">        String borderString = (border == null ? &quot;&quot;</span>
<span class="nc" id="L5552">                               : (border == this ? &quot;this&quot; : border.toString()));</span>

<span class="nc" id="L5554">        return super.paramString() +</span>
        &quot;,alignmentX=&quot; + alignmentX +
        &quot;,alignmentY=&quot; + alignmentY +
        &quot;,border=&quot; + borderString +
        &quot;,flags=&quot; + flags +             // should beef this up a bit
        &quot;,maximumSize=&quot; + maximumSizeString +
        &quot;,minimumSize=&quot; + minimumSizeString +
        &quot;,preferredSize=&quot; + preferredSizeString;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    @Deprecated
    public void hide() {
<span class="nc" id="L5570">        boolean showing = isShowing();</span>
<span class="nc" id="L5571">        super.hide();</span>
<span class="nc bnc" id="L5572" title="All 2 branches missed.">        if (showing) {</span>
<span class="nc" id="L5573">            Container parent = getParent();</span>
<span class="nc bnc" id="L5574" title="All 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L5575">                Rectangle r = getBounds();</span>
<span class="nc" id="L5576">                parent.repaint(r.x, r.y, r.width, r.height);</span>
            }
<span class="nc" id="L5578">            revalidate();</span>
        }
<span class="nc" id="L5580">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>