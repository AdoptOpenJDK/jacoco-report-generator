<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KeyboardManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">KeyboardManager.java</span></div><h1>KeyboardManager.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1998, 2009, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;


import java.util.*;
import java.awt.*;
import java.awt.event.*;
import java.applet.*;
import java.beans.*;
import javax.swing.event.*;
import sun.awt.EmbeddedFrame;

/**
  * The KeyboardManager class is used to help dispatch keyboard actions for the
  * WHEN_IN_FOCUSED_WINDOW style actions.  Actions with other conditions are handled
  * directly in JComponent.
  *
  * Here's a description of the symantics of how keyboard dispatching should work
  * atleast as I understand it.
  *
  * KeyEvents are dispatched to the focused component.  The focus manager gets first
  * crack at processing this event.  If the focus manager doesn't want it, then
  * the JComponent calls super.processKeyEvent() this allows listeners a chance
  * to process the event.
  *
  * If none of the listeners &quot;consumes&quot; the event then the keybindings get a shot.
  * This is where things start to get interesting.  First, KeyStokes defined with the
  * WHEN_FOCUSED condition get a chance.  If none of these want the event, then the component
  * walks though it's parents looked for actions of type WHEN_ANCESTOR_OF_FOCUSED_COMPONENT.
  *
  * If no one has taken it yet, then it winds up here.  We then look for components registered
  * for WHEN_IN_FOCUSED_WINDOW events and fire to them.  Note that if none of those are found
  * then we pass the event to the menubars and let them have a crack at it.  They're handled differently.
  *
  * Lastly, we check if we're looking at an internal frame.  If we are and no one wanted the event
  * then we move up to the InternalFrame's creator and see if anyone wants the event (and so on and so on).
  *
  *
  * @see InputMap
  */
<span class="nc" id="L64">class KeyboardManager {</span>

<span class="nc" id="L66">    static KeyboardManager currentManager = new KeyboardManager();</span>

    /**
      * maps top-level containers to a sub-hashtable full of keystrokes
      */
<span class="nc" id="L71">    Hashtable&lt;Container, Hashtable&gt; containerMap = new Hashtable&lt;Container, Hashtable&gt;();</span>

    /**
      * Maps component/keystroke pairs to a topLevel container
      * This is mainly used for fast unregister operations
      */
<span class="nc" id="L77">    Hashtable&lt;ComponentKeyStrokePair, Container&gt; componentKeyStrokeMap = new Hashtable&lt;ComponentKeyStrokePair, Container&gt;();</span>

    public static KeyboardManager getCurrentManager() {
<span class="nc" id="L80">        return currentManager;</span>
    }

    public static void setCurrentManager(KeyboardManager km) {
<span class="nc" id="L84">        currentManager = km;</span>
<span class="nc" id="L85">    }</span>

    /**
      * register keystrokes here which are for the WHEN_IN_FOCUSED_WINDOW
      * case.
      * Other types of keystrokes will be handled by walking the hierarchy
      * That simplifies some potentially hairy stuff.
      */
     public void registerKeyStroke(KeyStroke k, JComponent c) {
<span class="nc" id="L94">         Container topContainer = getTopAncestor(c);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">         if (topContainer == null) {</span>
<span class="nc" id="L96">             return;</span>
         }
<span class="nc" id="L98">         Hashtable keyMap = containerMap.get(topContainer);</span>

<span class="nc bnc" id="L100" title="All 2 branches missed.">         if (keyMap ==  null) {  // lazy evaluate one</span>
<span class="nc" id="L101">             keyMap = registerNewTopContainer(topContainer);</span>
         }

<span class="nc" id="L104">         Object tmp = keyMap.get(k);</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">         if (tmp == null) {</span>
<span class="nc" id="L106">             keyMap.put(k,c);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">         } else if (tmp instanceof Vector) {  // if there's a Vector there then add to it.</span>
<span class="nc" id="L108">             Vector v = (Vector)tmp;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">             if (!v.contains(c)) {  // only add if this keystroke isn't registered for this component</span>
<span class="nc" id="L110">                 v.addElement(c);</span>
             }
<span class="nc bnc" id="L112" title="All 2 branches missed.">         } else if (tmp instanceof JComponent) {</span>
           // if a JComponent is there then remove it and replace it with a vector
           // Then add the old compoennt and the new compoent to the vector
           // then insert the vector in the table
<span class="nc bnc" id="L116" title="All 2 branches missed.">           if (tmp != c) {  // this means this is already registered for this component, no need to dup</span>
<span class="nc" id="L117">               Vector&lt;JComponent&gt; v = new Vector&lt;JComponent&gt;();</span>
<span class="nc" id="L118">               v.addElement((JComponent) tmp);</span>
<span class="nc" id="L119">               v.addElement(c);</span>
<span class="nc" id="L120">               keyMap.put(k, v);</span>
<span class="nc" id="L121">           }</span>
         } else {
<span class="nc" id="L123">             System.out.println(&quot;Unexpected condition in registerKeyStroke&quot;);</span>
<span class="nc" id="L124">             Thread.dumpStack();</span>
         }

<span class="nc" id="L127">         componentKeyStrokeMap.put(new ComponentKeyStrokePair(c,k), topContainer);</span>

         // Check for EmbeddedFrame case, they know how to process accelerators even
         // when focus is not in Java
<span class="nc bnc" id="L131" title="All 2 branches missed.">         if (topContainer instanceof EmbeddedFrame) {</span>
<span class="nc" id="L132">             ((EmbeddedFrame)topContainer).registerAccelerator(k);</span>
         }
<span class="nc" id="L134">     }</span>

     /**
       * Find the top focusable Window, Applet, or InternalFrame
       */
     private static Container getTopAncestor(JComponent c) {
<span class="nc bnc" id="L140" title="All 2 branches missed.">        for(Container p = c.getParent(); p != null; p = p.getParent()) {</span>
<span class="nc bnc" id="L141" title="All 8 branches missed.">            if (p instanceof Window &amp;&amp; ((Window)p).isFocusableWindow() ||</span>
                p instanceof Applet || p instanceof JInternalFrame) {

<span class="nc" id="L144">                return p;</span>
            }
        }
<span class="nc" id="L147">        return null;</span>
     }

     public void unregisterKeyStroke(KeyStroke ks, JComponent c) {

       // component may have already been removed from the hierarchy, we
       // need to look up the container using the componentKeyStrokeMap.

<span class="nc" id="L155">         ComponentKeyStrokePair ckp = new ComponentKeyStrokePair(c,ks);</span>

<span class="nc" id="L157">         Container topContainer = componentKeyStrokeMap.get(ckp);</span>

<span class="nc bnc" id="L159" title="All 2 branches missed.">         if (topContainer == null) {  // never heard of this pairing, so bail</span>
<span class="nc" id="L160">             return;</span>
         }

<span class="nc" id="L163">         Hashtable keyMap = containerMap.get(topContainer);</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">         if  (keyMap == null) { // this should never happen, but I'm being safe</span>
<span class="nc" id="L165">             Thread.dumpStack();</span>
<span class="nc" id="L166">             return;</span>
         }

<span class="nc" id="L169">         Object tmp = keyMap.get(ks);</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">         if (tmp == null) {  // this should never happen, but I'm being safe</span>
<span class="nc" id="L171">             Thread.dumpStack();</span>
<span class="nc" id="L172">             return;</span>
         }

<span class="nc bnc" id="L175" title="All 4 branches missed.">         if (tmp instanceof JComponent &amp;&amp; tmp == c) {</span>
<span class="nc" id="L176">             keyMap.remove(ks);  // remove the KeyStroke from the Map</span>
             //System.out.println(&quot;removed a stroke&quot; + ks);
<span class="nc bnc" id="L178" title="All 2 branches missed.">         } else if (tmp instanceof Vector ) {  // this means there is more than one component reg for this key</span>
<span class="nc" id="L179">             Vector v = (Vector)tmp;</span>
<span class="nc" id="L180">             v.removeElement(c);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">             if ( v.isEmpty() ) {</span>
<span class="nc" id="L182">                 keyMap.remove(ks);  // remove the KeyStroke from the Map</span>
                 //System.out.println(&quot;removed a ks vector&quot;);
             }
         }

<span class="nc bnc" id="L187" title="All 2 branches missed.">         if ( keyMap.isEmpty() ) {  // if no more bindings in this table</span>
<span class="nc" id="L188">             containerMap.remove(topContainer);  // remove table to enable GC</span>
             //System.out.println(&quot;removed a container&quot;);
         }

<span class="nc" id="L192">         componentKeyStrokeMap.remove(ckp);</span>

         // Check for EmbeddedFrame case, they know how to process accelerators even
         // when focus is not in Java
<span class="nc bnc" id="L196" title="All 2 branches missed.">         if (topContainer instanceof EmbeddedFrame) {</span>
<span class="nc" id="L197">             ((EmbeddedFrame)topContainer).unregisterAccelerator(ks);</span>
         }
<span class="nc" id="L199">     }</span>

    /**
      * This method is called when the focused component (and none of
      * its ancestors) want the key event.  This will look up the keystroke
      * to see if any chidren (or subchildren) of the specified container
      * want a crack at the event.
      * If one of them wants it, then it will &quot;DO-THE-RIGHT-THING&quot;
      */
    public boolean fireKeyboardAction(KeyEvent e, boolean pressed, Container topAncestor) {

<span class="nc bnc" id="L210" title="All 2 branches missed.">         if (e.isConsumed()) {</span>
<span class="nc" id="L211">              System.out.println(&quot;Acquired pre-used event!&quot;);</span>
<span class="nc" id="L212">              Thread.dumpStack();</span>
         }

         // There may be two keystrokes associated with a low-level key event;
         // in this case a keystroke made of an extended key code has a priority.
         KeyStroke ks;
<span class="nc" id="L218">         KeyStroke ksE = null;</span>


<span class="nc bnc" id="L221" title="All 2 branches missed.">         if(e.getID() == KeyEvent.KEY_TYPED) {</span>
<span class="nc" id="L222">               ks=KeyStroke.getKeyStroke(e.getKeyChar());</span>
         } else {
<span class="nc bnc" id="L224" title="All 2 branches missed.">               if(e.getKeyCode() != e.getExtendedKeyCode()) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                   ksE=KeyStroke.getKeyStroke(e.getExtendedKeyCode(), e.getModifiers(), !pressed);</span>
               }
<span class="nc bnc" id="L227" title="All 2 branches missed.">               ks=KeyStroke.getKeyStroke(e.getKeyCode(), e.getModifiers(), !pressed);</span>
         }

<span class="nc" id="L230">         Hashtable keyMap = containerMap.get(topAncestor);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">         if (keyMap != null) { // this container isn't registered, so bail</span>

<span class="nc" id="L233">             Object tmp = null;</span>
             // extended code has priority
<span class="nc bnc" id="L235" title="All 2 branches missed.">             if( ksE != null ) {</span>
<span class="nc" id="L236">                 tmp = keyMap.get(ksE);</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                 if( tmp != null ) {</span>
<span class="nc" id="L238">                     ks = ksE;</span>
                 }
             }
<span class="nc bnc" id="L241" title="All 2 branches missed.">             if( tmp == null ) {</span>
<span class="nc" id="L242">                 tmp = keyMap.get(ks);</span>
             }

<span class="nc bnc" id="L245" title="All 2 branches missed.">             if (tmp == null) {</span>
               // don't do anything
<span class="nc bnc" id="L247" title="All 2 branches missed.">             } else if ( tmp instanceof JComponent) {</span>
<span class="nc" id="L248">                 JComponent c = (JComponent)tmp;</span>
<span class="nc bnc" id="L249" title="All 4 branches missed.">                 if ( c.isShowing() &amp;&amp; c.isEnabled() ) { // only give it out if enabled and visible</span>
<span class="nc" id="L250">                     fireBinding(c, ks, e, pressed);</span>
                 }
<span class="nc bnc" id="L252" title="All 2 branches missed.">             } else if ( tmp instanceof Vector) { //more than one comp registered for this</span>
<span class="nc" id="L253">                 Vector v = (Vector)tmp;</span>
                 // There is no well defined order for WHEN_IN_FOCUSED_WINDOW
                 // bindings, but we give precedence to those bindings just
                 // added. This is done so that JMenus WHEN_IN_FOCUSED_WINDOW
                 // bindings are accessed before those of the JRootPane (they
                 // both have a WHEN_IN_FOCUSED_WINDOW binding for enter).
<span class="nc bnc" id="L259" title="All 2 branches missed.">                 for (int counter = v.size() - 1; counter &gt;= 0; counter--) {</span>
<span class="nc" id="L260">                     JComponent c = (JComponent)v.elementAt(counter);</span>
                     //System.out.println(&quot;Trying collision: &quot; + c + &quot; vector = &quot;+ v.size());
<span class="nc bnc" id="L262" title="All 4 branches missed.">                     if ( c.isShowing() &amp;&amp; c.isEnabled() ) { // don't want to give these out</span>
<span class="nc" id="L263">                         fireBinding(c, ks, e, pressed);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">                         if (e.isConsumed())</span>
<span class="nc" id="L265">                             return true;</span>
                     }
                 }
<span class="nc" id="L268">             } else  {</span>
<span class="nc" id="L269">                 System.out.println( &quot;Unexpected condition in fireKeyboardAction &quot; + tmp);</span>
                 // This means that tmp wasn't null, a JComponent, or a Vector.  What is it?
<span class="nc" id="L271">                 Thread.dumpStack();</span>
             }
         }

<span class="nc bnc" id="L275" title="All 2 branches missed.">         if (e.isConsumed()) {</span>
<span class="nc" id="L276">             return true;</span>
         }
         // if no one else handled it, then give the menus a crack
         // The're handled differently.  The key is to let any JMenuBars
         // process the event
<span class="nc bnc" id="L281" title="All 2 branches missed.">         if ( keyMap != null) {</span>
<span class="nc" id="L282">             Vector v = (Vector)keyMap.get(JMenuBar.class);</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">             if (v != null) {</span>
<span class="nc" id="L284">                 Enumeration iter = v.elements();</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">                 while (iter.hasMoreElements()) {</span>
<span class="nc" id="L286">                     JMenuBar mb = (JMenuBar)iter.nextElement();</span>
<span class="nc bnc" id="L287" title="All 4 branches missed.">                     if ( mb.isShowing() &amp;&amp; mb.isEnabled() ) { // don't want to give these out</span>
<span class="nc bnc" id="L288" title="All 4 branches missed.">                         boolean extended = (ksE != null) &amp;&amp; !ksE.equals(ks);</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">                         if (extended) {</span>
<span class="nc" id="L290">                             fireBinding(mb, ksE, e, pressed);</span>
                         }
<span class="nc bnc" id="L292" title="All 4 branches missed.">                         if (!extended || !e.isConsumed()) {</span>
<span class="nc" id="L293">                             fireBinding(mb, ks, e, pressed);</span>
                         }
<span class="nc bnc" id="L295" title="All 2 branches missed.">                         if (e.isConsumed()) {</span>
<span class="nc" id="L296">                             return true;</span>
                         }
                     }
<span class="nc" id="L299">                 }</span>
             }
         }

<span class="nc" id="L303">         return e.isConsumed();</span>
    }

    void fireBinding(JComponent c, KeyStroke ks, KeyEvent e, boolean pressed) {
<span class="nc bnc" id="L307" title="All 2 branches missed.">        if (c.processKeyBinding(ks, e, JComponent.WHEN_IN_FOCUSED_WINDOW,</span>
                                pressed)) {
<span class="nc" id="L309">            e.consume();</span>
        }
<span class="nc" id="L311">    }</span>

    public void registerMenuBar(JMenuBar mb) {
<span class="nc" id="L314">        Container top = getTopAncestor(mb);</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">        if (top == null) {</span>
<span class="nc" id="L316">            return;</span>
        }
<span class="nc" id="L318">        Hashtable keyMap = containerMap.get(top);</span>

<span class="nc bnc" id="L320" title="All 2 branches missed.">        if (keyMap ==  null) {  // lazy evaluate one</span>
<span class="nc" id="L321">             keyMap = registerNewTopContainer(top);</span>
        }
        // use the menubar class as the key
<span class="nc" id="L324">        Vector menuBars = (Vector)keyMap.get(JMenuBar.class);</span>

<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (menuBars == null) {  // if we don't have a list of menubars,</span>
                                 // then make one.
<span class="nc" id="L328">            menuBars = new Vector();</span>
<span class="nc" id="L329">            keyMap.put(JMenuBar.class, menuBars);</span>
        }

<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (!menuBars.contains(mb)) {</span>
<span class="nc" id="L333">            menuBars.addElement(mb);</span>
        }
<span class="nc" id="L335">    }</span>


    public void unregisterMenuBar(JMenuBar mb) {
<span class="nc" id="L339">        Container topContainer = getTopAncestor(mb);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (topContainer == null) {</span>
<span class="nc" id="L341">            return;</span>
        }
<span class="nc" id="L343">        Hashtable keyMap = containerMap.get(topContainer);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (keyMap!=null) {</span>
<span class="nc" id="L345">            Vector v = (Vector)keyMap.get(JMenuBar.class);</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (v != null) {</span>
<span class="nc" id="L347">                v.removeElement(mb);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">                if (v.isEmpty()) {</span>
<span class="nc" id="L349">                    keyMap.remove(JMenuBar.class);</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                    if (keyMap.isEmpty()) {</span>
                        // remove table to enable GC
<span class="nc" id="L352">                        containerMap.remove(topContainer);</span>
                    }
                }
            }
        }
<span class="nc" id="L357">    }</span>
    protected Hashtable registerNewTopContainer(Container topContainer) {
<span class="nc" id="L359">             Hashtable keyMap = new Hashtable();</span>
<span class="nc" id="L360">             containerMap.put(topContainer, keyMap);</span>
<span class="nc" id="L361">             return keyMap;</span>
    }

    /**
      * This class is used to create keys for a hashtable
      * which looks up topContainers based on component, keystroke pairs
      * This is used to make unregistering KeyStrokes fast
      */
<span class="nc" id="L369">    class ComponentKeyStrokePair {</span>
        Object component;
        Object keyStroke;

<span class="nc" id="L373">        public ComponentKeyStrokePair(Object comp, Object key) {</span>
<span class="nc" id="L374">            component = comp;</span>
<span class="nc" id="L375">            keyStroke = key;</span>
<span class="nc" id="L376">        }</span>

        public boolean equals(Object o) {
<span class="nc bnc" id="L379" title="All 2 branches missed.">            if ( !(o instanceof ComponentKeyStrokePair)) {</span>
<span class="nc" id="L380">                return false;</span>
            }
<span class="nc" id="L382">            ComponentKeyStrokePair ckp = (ComponentKeyStrokePair)o;</span>
<span class="nc bnc" id="L383" title="All 4 branches missed.">            return ((component.equals(ckp.component)) &amp;&amp; (keyStroke.equals(ckp.keyStroke)));</span>
        }

        public int hashCode() {
<span class="nc" id="L387">            return component.hashCode() * keyStroke.hashCode();</span>
        }

    }

} // end KeyboardManager
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>