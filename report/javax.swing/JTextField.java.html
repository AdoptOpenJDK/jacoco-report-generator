<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>JTextField.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JTextField.java</span></div><h1>JTextField.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import sun.swing.SwingUtilities2;

import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import javax.swing.text.*;
import javax.swing.plaf.*;
import javax.swing.event.*;
import javax.accessibility.*;

import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import java.io.Serializable;

/**
 * &lt;code&gt;JTextField&lt;/code&gt; is a lightweight component that allows the editing
 * of a single line of text.
 * For information on and examples of using text fields,
 * see
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/textfield.html&quot;&gt;How to Use Text Fields&lt;/a&gt;
 * in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 *
 * &lt;p&gt;
 * &lt;code&gt;JTextField&lt;/code&gt; is intended to be source-compatible
 * with &lt;code&gt;java.awt.TextField&lt;/code&gt; where it is reasonable to do so.  This
 * component has capabilities not found in the &lt;code&gt;java.awt.TextField&lt;/code&gt;
 * class.  The superclass should be consulted for additional capabilities.
 * &lt;p&gt;
 * &lt;code&gt;JTextField&lt;/code&gt; has a method to establish the string used as the
 * command string for the action event that gets fired.  The
 * &lt;code&gt;java.awt.TextField&lt;/code&gt; used the text of the field as the command
 * string for the &lt;code&gt;ActionEvent&lt;/code&gt;.
 * &lt;code&gt;JTextField&lt;/code&gt; will use the command
 * string set with the &lt;code&gt;setActionCommand&lt;/code&gt; method if not &lt;code&gt;null&lt;/code&gt;,
 * otherwise it will use the text of the field as a compatibility with
 * &lt;code&gt;java.awt.TextField&lt;/code&gt;.
 * &lt;p&gt;
 * The method &lt;code&gt;setEchoChar&lt;/code&gt; and &lt;code&gt;getEchoChar&lt;/code&gt;
 * are not provided directly to avoid a new implementation of a
 * pluggable look-and-feel inadvertently exposing password characters.
 * To provide password-like services a separate class &lt;code&gt;JPasswordField&lt;/code&gt;
 * extends &lt;code&gt;JTextField&lt;/code&gt; to provide this service with an independently
 * pluggable look-and-feel.
 * &lt;p&gt;
 * The &lt;code&gt;java.awt.TextField&lt;/code&gt; could be monitored for changes by adding
 * a &lt;code&gt;TextListener&lt;/code&gt; for &lt;code&gt;TextEvent&lt;/code&gt;'s.
 * In the &lt;code&gt;JTextComponent&lt;/code&gt; based
 * components, changes are broadcasted from the model via a
 * &lt;code&gt;DocumentEvent&lt;/code&gt; to &lt;code&gt;DocumentListeners&lt;/code&gt;.
 * The &lt;code&gt;DocumentEvent&lt;/code&gt; gives
 * the location of the change and the kind of change if desired.
 * The code fragment might look something like:
 * &lt;pre&gt;&lt;code&gt;
 * &amp;nbsp;   DocumentListener myListener = ??;
 * &amp;nbsp;   JTextField myArea = ??;
 * &amp;nbsp;   myArea.getDocument().addDocumentListener(myListener);
 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * The horizontal alignment of &lt;code&gt;JTextField&lt;/code&gt; can be set to be left
 * justified, leading justified, centered, right justified or trailing justified.
 * Right/trailing justification is useful if the required size
 * of the field text is smaller than the size allocated to it.
 * This is determined by the &lt;code&gt;setHorizontalAlignment&lt;/code&gt;
 * and &lt;code&gt;getHorizontalAlignment&lt;/code&gt; methods.  The default
 * is to be leading justified.
 * &lt;p&gt;
 * How the text field consumes VK_ENTER events depends
 * on whether the text field has any action listeners.
 * If so, then VK_ENTER results in the listeners
 * getting an ActionEvent,
 * and the VK_ENTER event is consumed.
 * This is compatible with how AWT text fields handle VK_ENTER events.
 * If the text field has no action listeners, then as of v 1.3 the VK_ENTER
 * event is not consumed.  Instead, the bindings of ancestor components
 * are processed, which enables the default button feature of
 * JFC/Swing to work.
 * &lt;p&gt;
 * Customized fields can easily be created by extending the model and
 * changing the default model provided.  For example, the following piece
 * of code will create a field that holds only upper case characters.  It
 * will work even if text is pasted into from the clipboard or it is altered via
 * programmatic changes.
 * &lt;pre&gt;&lt;code&gt;

&amp;nbsp;public class UpperCaseField extends JTextField {
&amp;nbsp;
&amp;nbsp;    public UpperCaseField(int cols) {
&amp;nbsp;        super(cols);
&amp;nbsp;    }
&amp;nbsp;
&amp;nbsp;    protected Document createDefaultModel() {
&amp;nbsp;        return new UpperCaseDocument();
&amp;nbsp;    }
&amp;nbsp;
&amp;nbsp;    static class UpperCaseDocument extends PlainDocument {
&amp;nbsp;
&amp;nbsp;        public void insertString(int offs, String str, AttributeSet a)
&amp;nbsp;            throws BadLocationException {
&amp;nbsp;
&amp;nbsp;            if (str == null) {
&amp;nbsp;                return;
&amp;nbsp;            }
&amp;nbsp;            char[] upper = str.toCharArray();
&amp;nbsp;            for (int i = 0; i &amp;lt; upper.length; i++) {
&amp;nbsp;                upper[i] = Character.toUpperCase(upper[i]);
&amp;nbsp;            }
&amp;nbsp;            super.insertString(offs, new String(upper), a);
&amp;nbsp;        }
&amp;nbsp;    }
&amp;nbsp;}

 * &lt;/code&gt;&lt;/pre&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @beaninfo
 *   attribute: isContainer false
 * description: A component which allows for the editing of a single line of text.
 *
 * @author  Timothy Prinzing
 * @see #setActionCommand
 * @see JPasswordField
 * @see #addActionListener
 */
public class JTextField extends JTextComponent implements SwingConstants {

    /**
     * Constructs a new &lt;code&gt;TextField&lt;/code&gt;.  A default model is created,
     * the initial string is &lt;code&gt;null&lt;/code&gt;,
     * and the number of columns is set to 0.
     */
    public JTextField() {
<span class="nc" id="L172">        this(null, null, 0);</span>
<span class="nc" id="L173">    }</span>

    /**
     * Constructs a new &lt;code&gt;TextField&lt;/code&gt; initialized with the
     * specified text. A default model is created and the number of
     * columns is 0.
     *
     * @param text the text to be displayed, or &lt;code&gt;null&lt;/code&gt;
     */
    public JTextField(String text) {
<span class="nc" id="L183">        this(null, text, 0);</span>
<span class="nc" id="L184">    }</span>

    /**
     * Constructs a new empty &lt;code&gt;TextField&lt;/code&gt; with the specified
     * number of columns.
     * A default model is created and the initial string is set to
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @param columns  the number of columns to use to calculate
     *   the preferred width; if columns is set to zero, the
     *   preferred width will be whatever naturally results from
     *   the component implementation
     */
    public JTextField(int columns) {
<span class="nc" id="L198">        this(null, null, columns);</span>
<span class="nc" id="L199">    }</span>

    /**
     * Constructs a new &lt;code&gt;TextField&lt;/code&gt; initialized with the
     * specified text and columns.  A default model is created.
     *
     * @param text the text to be displayed, or &lt;code&gt;null&lt;/code&gt;
     * @param columns  the number of columns to use to calculate
     *   the preferred width; if columns is set to zero, the
     *   preferred width will be whatever naturally results from
     *   the component implementation
     */
    public JTextField(String text, int columns) {
<span class="nc" id="L212">        this(null, text, columns);</span>
<span class="nc" id="L213">    }</span>

    /**
     * Constructs a new &lt;code&gt;JTextField&lt;/code&gt; that uses the given text
     * storage model and the given number of columns.
     * This is the constructor through which the other constructors feed.
     * If the document is &lt;code&gt;null&lt;/code&gt;, a default model is created.
     *
     * @param doc  the text storage to use; if this is &lt;code&gt;null&lt;/code&gt;,
     *          a default will be provided by calling the
     *          &lt;code&gt;createDefaultModel&lt;/code&gt; method
     * @param text  the initial string to display, or &lt;code&gt;null&lt;/code&gt;
     * @param columns  the number of columns to use to calculate
     *   the preferred width &amp;gt;= 0; if &lt;code&gt;columns&lt;/code&gt;
     *   is set to zero, the preferred width will be whatever
     *   naturally results from the component implementation
     * @exception IllegalArgumentException if &lt;code&gt;columns&lt;/code&gt; &amp;lt; 0
     */
<span class="nc" id="L231">    public JTextField(Document doc, String text, int columns) {</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (columns &lt; 0) {</span>
<span class="nc" id="L233">            throw new IllegalArgumentException(&quot;columns less than zero.&quot;);</span>
        }
<span class="nc" id="L235">        visibility = new DefaultBoundedRangeModel();</span>
<span class="nc" id="L236">        visibility.addChangeListener(new ScrollRepainter());</span>
<span class="nc" id="L237">        this.columns = columns;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        if (doc == null) {</span>
<span class="nc" id="L239">            doc = createDefaultModel();</span>
        }
<span class="nc" id="L241">        setDocument(doc);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (text != null) {</span>
<span class="nc" id="L243">            setText(text);</span>
        }
<span class="nc" id="L245">    }</span>

    /**
     * Gets the class ID for a UI.
     *
     * @return the string &quot;TextFieldUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L255">        return uiClassID;</span>
    }


    /**
     * Associates the editor with a text document.
     * The currently registered factory is used to build a view for
     * the document, which gets displayed by the editor after revalidation.
     * A PropertyChange event (&quot;document&quot;) is propagated to each listener.
     *
     * @param doc  the document to display/edit
     * @see #getDocument
     * @beaninfo
     *  description: the text document model
     *        bound: true
     *       expert: true
     */
    public void setDocument(Document doc) {
<span class="nc bnc" id="L273" title="All 2 branches missed.">        if (doc != null) {</span>
<span class="nc" id="L274">            doc.putProperty(&quot;filterNewlines&quot;, Boolean.TRUE);</span>
        }
<span class="nc" id="L276">        super.setDocument(doc);</span>
<span class="nc" id="L277">    }</span>

    /**
     * Calls to &lt;code&gt;revalidate&lt;/code&gt; that come from within the
     * textfield itself will
     * be handled by validating the textfield, unless the textfield
     * is contained within a &lt;code&gt;JViewport&lt;/code&gt;,
     * in which case this returns false.
     *
     * @return if the parent of this textfield is a &lt;code&gt;JViewPort&lt;/code&gt;
     *          return false, otherwise return true
     *
     * @see JComponent#revalidate
     * @see JComponent#isValidateRoot
     * @see java.awt.Container#isValidateRoot
     */
    @Override
    public boolean isValidateRoot() {
<span class="nc bnc" id="L295" title="All 2 branches missed.">        return !(SwingUtilities.getUnwrappedParent(this) instanceof JViewport);</span>
    }


    /**
     * Returns the horizontal alignment of the text.
     * Valid keys are:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;JTextField.LEFT&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;JTextField.CENTER&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;JTextField.RIGHT&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;JTextField.LEADING&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;JTextField.TRAILING&lt;/code&gt;
     * &lt;/ul&gt;
     *
     * @return the horizontal alignment
     */
    public int getHorizontalAlignment() {
<span class="nc" id="L313">        return horizontalAlignment;</span>
    }

    /**
     * Sets the horizontal alignment of the text.
     * Valid keys are:
     * &lt;ul&gt;
     * &lt;li&gt;&lt;code&gt;JTextField.LEFT&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;JTextField.CENTER&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;JTextField.RIGHT&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;JTextField.LEADING&lt;/code&gt;
     * &lt;li&gt;&lt;code&gt;JTextField.TRAILING&lt;/code&gt;
     * &lt;/ul&gt;
     * &lt;code&gt;invalidate&lt;/code&gt; and &lt;code&gt;repaint&lt;/code&gt; are called when the
     * alignment is set,
     * and a &lt;code&gt;PropertyChange&lt;/code&gt; event (&quot;horizontalAlignment&quot;) is fired.
     *
     * @param alignment the alignment
     * @exception IllegalArgumentException if &lt;code&gt;alignment&lt;/code&gt;
     *  is not a valid key
     * @beaninfo
     *   preferred: true
     *       bound: true
     * description: Set the field alignment to LEFT, CENTER, RIGHT,
     *              LEADING (the default) or TRAILING
     *        enum: LEFT JTextField.LEFT CENTER JTextField.CENTER RIGHT JTextField.RIGHT
     *              LEADING JTextField.LEADING TRAILING JTextField.TRAILING
     */
     public void setHorizontalAlignment(int alignment) {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (alignment == horizontalAlignment) return;</span>
<span class="nc" id="L343">        int oldValue = horizontalAlignment;</span>
<span class="nc bnc" id="L344" title="All 10 branches missed.">        if ((alignment == LEFT) || (alignment == CENTER) ||</span>
            (alignment == RIGHT)|| (alignment == LEADING) ||
            (alignment == TRAILING)) {
<span class="nc" id="L347">            horizontalAlignment = alignment;</span>
        } else {
<span class="nc" id="L349">            throw new IllegalArgumentException(&quot;horizontalAlignment&quot;);</span>
        }
<span class="nc" id="L351">        firePropertyChange(&quot;horizontalAlignment&quot;, oldValue, horizontalAlignment);</span>
<span class="nc" id="L352">        invalidate();</span>
<span class="nc" id="L353">        repaint();</span>
<span class="nc" id="L354">    }</span>

    /**
     * Creates the default implementation of the model
     * to be used at construction if one isn't explicitly
     * given.  An instance of &lt;code&gt;PlainDocument&lt;/code&gt; is returned.
     *
     * @return the default model implementation
     */
    protected Document createDefaultModel() {
<span class="nc" id="L364">        return new PlainDocument();</span>
    }

    /**
     * Returns the number of columns in this &lt;code&gt;TextField&lt;/code&gt;.
     *
     * @return the number of columns &amp;gt;= 0
     */
    public int getColumns() {
<span class="nc" id="L373">        return columns;</span>
    }

    /**
     * Sets the number of columns in this &lt;code&gt;TextField&lt;/code&gt;,
     * and then invalidate the layout.
     *
     * @param columns the number of columns &amp;gt;= 0
     * @exception IllegalArgumentException if &lt;code&gt;columns&lt;/code&gt;
     *          is less than 0
     * @beaninfo
     * description: the number of columns preferred for display
     */
    public void setColumns(int columns) {
<span class="nc" id="L387">        int oldVal = this.columns;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">        if (columns &lt; 0) {</span>
<span class="nc" id="L389">            throw new IllegalArgumentException(&quot;columns less than zero.&quot;);</span>
        }
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (columns != oldVal) {</span>
<span class="nc" id="L392">            this.columns = columns;</span>
<span class="nc" id="L393">            invalidate();</span>
        }
<span class="nc" id="L395">    }</span>

    /**
     * Returns the column width.
     * The meaning of what a column is can be considered a fairly weak
     * notion for some fonts.  This method is used to define the width
     * of a column.  By default this is defined to be the width of the
     * character &lt;em&gt;m&lt;/em&gt; for the font used.  This method can be
     * redefined to be some alternative amount
     *
     * @return the column width &amp;gt;= 1
     */
    protected int getColumnWidth() {
<span class="nc bnc" id="L408" title="All 2 branches missed.">        if (columnWidth == 0) {</span>
<span class="nc" id="L409">            FontMetrics metrics = getFontMetrics(getFont());</span>
<span class="nc" id="L410">            columnWidth = metrics.charWidth('m');</span>
        }
<span class="nc" id="L412">        return columnWidth;</span>
    }

    /**
     * Returns the preferred size &lt;code&gt;Dimensions&lt;/code&gt; needed for this
     * &lt;code&gt;TextField&lt;/code&gt;.  If a non-zero number of columns has been
     * set, the width is set to the columns multiplied by
     * the column width.
     *
     * @return the dimension of this textfield
     */
    public Dimension getPreferredSize() {
<span class="nc" id="L424">        Dimension size = super.getPreferredSize();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        if (columns != 0) {</span>
<span class="nc" id="L426">            Insets insets = getInsets();</span>
<span class="nc" id="L427">            size.width = columns * getColumnWidth() +</span>
                insets.left + insets.right;
        }
<span class="nc" id="L430">        return size;</span>
    }

    /**
     * Sets the current font.  This removes cached row height and column
     * width so the new font will be reflected.
     * &lt;code&gt;revalidate&lt;/code&gt; is called after setting the font.
     *
     * @param f the new font
     */
    public void setFont(Font f) {
<span class="nc" id="L441">        super.setFont(f);</span>
<span class="nc" id="L442">        columnWidth = 0;</span>
<span class="nc" id="L443">    }</span>

    /**
     * Adds the specified action listener to receive
     * action events from this textfield.
     *
     * @param l the action listener to be added
     */
    public synchronized void addActionListener(ActionListener l) {
<span class="nc" id="L452">        listenerList.add(ActionListener.class, l);</span>
<span class="nc" id="L453">    }</span>

    /**
     * Removes the specified action listener so that it no longer
     * receives action events from this textfield.
     *
     * @param l the action listener to be removed
     */
    public synchronized void removeActionListener(ActionListener l) {
<span class="nc bnc" id="L462" title="All 4 branches missed.">        if ((l != null) &amp;&amp; (getAction() == l)) {</span>
<span class="nc" id="L463">            setAction(null);</span>
        } else {
<span class="nc" id="L465">            listenerList.remove(ActionListener.class, l);</span>
        }
<span class="nc" id="L467">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;ActionListener&lt;/code&gt;s added
     * to this JTextField with addActionListener().
     *
     * @return all of the &lt;code&gt;ActionListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public synchronized ActionListener[] getActionListeners() {
<span class="nc" id="L478">        return listenerList.getListeners(ActionListener.class);</span>
    }

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  The event instance
     * is lazily created.
     * The listener list is processed in last to
     * first order.
     * @see EventListenerList
     */
    protected void fireActionPerformed() {
        // Guaranteed to return a non-null array
<span class="nc" id="L491">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L492">        int modifiers = 0;</span>
<span class="nc" id="L493">        AWTEvent currentEvent = EventQueue.getCurrentEvent();</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">        if (currentEvent instanceof InputEvent) {</span>
<span class="nc" id="L495">            modifiers = ((InputEvent)currentEvent).getModifiers();</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        } else if (currentEvent instanceof ActionEvent) {</span>
<span class="nc" id="L497">            modifiers = ((ActionEvent)currentEvent).getModifiers();</span>
        }
<span class="nc bnc" id="L499" title="All 2 branches missed.">        ActionEvent e =</span>
            new ActionEvent(this, ActionEvent.ACTION_PERFORMED,
<span class="nc" id="L501">                            (command != null) ? command : getText(),</span>
<span class="nc" id="L502">                            EventQueue.getMostRecentEventTime(), modifiers);</span>

        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L506" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">            if (listeners[i]==ActionListener.class) {</span>
<span class="nc" id="L508">                ((ActionListener)listeners[i+1]).actionPerformed(e);</span>
            }
        }
<span class="nc" id="L511">    }</span>

    /**
     * Sets the command string used for action events.
     *
     * @param command the command string
     */
    public void setActionCommand(String command) {
<span class="nc" id="L519">        this.command = command;</span>
<span class="nc" id="L520">    }</span>

    private Action action;
    private PropertyChangeListener actionPropertyChangeListener;

    /**
     * Sets the &lt;code&gt;Action&lt;/code&gt; for the &lt;code&gt;ActionEvent&lt;/code&gt; source.
     * The new &lt;code&gt;Action&lt;/code&gt; replaces
     * any previously set &lt;code&gt;Action&lt;/code&gt; but does not affect
     * &lt;code&gt;ActionListeners&lt;/code&gt; independently
     * added with &lt;code&gt;addActionListener&lt;/code&gt;.
     * If the &lt;code&gt;Action&lt;/code&gt; is already a registered
     * &lt;code&gt;ActionListener&lt;/code&gt;
     * for the &lt;code&gt;ActionEvent&lt;/code&gt; source, it is not re-registered.
     * &lt;p&gt;
     * Setting the &lt;code&gt;Action&lt;/code&gt; results in immediately changing
     * all the properties described in &lt;a href=&quot;Action.html#buttonActions&quot;&gt;
     * Swing Components Supporting &lt;code&gt;Action&lt;/code&gt;&lt;/a&gt;.
     * Subsequently, the textfield's properties are automatically updated
     * as the &lt;code&gt;Action&lt;/code&gt;'s properties change.
     * &lt;p&gt;
     * This method uses three other methods to set
     * and help track the &lt;code&gt;Action&lt;/code&gt;'s property values.
     * It uses the &lt;code&gt;configurePropertiesFromAction&lt;/code&gt; method
     * to immediately change the textfield's properties.
     * To track changes in the &lt;code&gt;Action&lt;/code&gt;'s property values,
     * this method registers the &lt;code&gt;PropertyChangeListener&lt;/code&gt;
     * returned by &lt;code&gt;createActionPropertyChangeListener&lt;/code&gt;. The
     * default {@code PropertyChangeListener} invokes the
     * {@code actionPropertyChanged} method when a property in the
     * {@code Action} changes.
     *
     * @param a the &lt;code&gt;Action&lt;/code&gt; for the &lt;code&gt;JTextField&lt;/code&gt;,
     *          or &lt;code&gt;null&lt;/code&gt;
     * @since 1.3
     * @see Action
     * @see #getAction
     * @see #configurePropertiesFromAction
     * @see #createActionPropertyChangeListener
     * @see #actionPropertyChanged
     * @beaninfo
     *        bound: true
     *    attribute: visualUpdate true
     *  description: the Action instance connected with this ActionEvent source
     */
    public void setAction(Action a) {
<span class="nc" id="L566">        Action oldValue = getAction();</span>
<span class="nc bnc" id="L567" title="All 4 branches missed.">        if (action==null || !action.equals(a)) {</span>
<span class="nc" id="L568">            action = a;</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">            if (oldValue!=null) {</span>
<span class="nc" id="L570">                removeActionListener(oldValue);</span>
<span class="nc" id="L571">                oldValue.removePropertyChangeListener(actionPropertyChangeListener);</span>
<span class="nc" id="L572">                actionPropertyChangeListener = null;</span>
            }
<span class="nc" id="L574">            configurePropertiesFromAction(action);</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">            if (action!=null) {</span>
                // Don't add if it is already a listener
<span class="nc bnc" id="L577" title="All 2 branches missed.">                if (!isListener(ActionListener.class, action)) {</span>
<span class="nc" id="L578">                    addActionListener(action);</span>
                }
                // Reverse linkage:
<span class="nc" id="L581">                actionPropertyChangeListener = createActionPropertyChangeListener(action);</span>
<span class="nc" id="L582">                action.addPropertyChangeListener(actionPropertyChangeListener);</span>
            }
<span class="nc" id="L584">            firePropertyChange(&quot;action&quot;, oldValue, action);</span>
        }
<span class="nc" id="L586">    }</span>

    private boolean isListener(Class c, ActionListener a) {
<span class="nc" id="L589">        boolean isListener = false;</span>
<span class="nc" id="L590">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L592" title="All 4 branches missed.">            if (listeners[i]==c &amp;&amp; listeners[i+1]==a) {</span>
<span class="nc" id="L593">                    isListener=true;</span>
            }
        }
<span class="nc" id="L596">        return isListener;</span>
    }

    /**
     * Returns the currently set &lt;code&gt;Action&lt;/code&gt; for this
     * &lt;code&gt;ActionEvent&lt;/code&gt; source, or &lt;code&gt;null&lt;/code&gt;
     * if no &lt;code&gt;Action&lt;/code&gt; is set.
     *
     * @return the &lt;code&gt;Action&lt;/code&gt; for this &lt;code&gt;ActionEvent&lt;/code&gt; source,
     *          or &lt;code&gt;null&lt;/code&gt;
     * @since 1.3
     * @see Action
     * @see #setAction
     */
    public Action getAction() {
<span class="nc" id="L611">        return action;</span>
    }

    /**
     * Sets the properties on this textfield to match those in the specified
     * &lt;code&gt;Action&lt;/code&gt;.  Refer to &lt;a href=&quot;Action.html#buttonActions&quot;&gt;
     * Swing Components Supporting &lt;code&gt;Action&lt;/code&gt;&lt;/a&gt; for more
     * details as to which properties this sets.
     *
     * @param a the &lt;code&gt;Action&lt;/code&gt; from which to get the properties,
     *          or &lt;code&gt;null&lt;/code&gt;
     * @since 1.3
     * @see Action
     * @see #setAction
     */
    protected void configurePropertiesFromAction(Action a) {
<span class="nc" id="L627">        AbstractAction.setEnabledFromAction(this, a);</span>
<span class="nc" id="L628">        AbstractAction.setToolTipTextFromAction(this, a);</span>
<span class="nc" id="L629">        setActionCommandFromAction(a);</span>
<span class="nc" id="L630">    }</span>

    /**
     * Updates the textfield's state in response to property changes in
     * associated action. This method is invoked from the
     * {@code PropertyChangeListener} returned from
     * {@code createActionPropertyChangeListener}. Subclasses do not normally
     * need to invoke this. Subclasses that support additional {@code Action}
     * properties should override this and
     * {@code configurePropertiesFromAction}.
     * &lt;p&gt;
     * Refer to the table at &lt;a href=&quot;Action.html#buttonActions&quot;&gt;
     * Swing Components Supporting &lt;code&gt;Action&lt;/code&gt;&lt;/a&gt; for a list of
     * the properties this method sets.
     *
     * @param action the &lt;code&gt;Action&lt;/code&gt; associated with this textfield
     * @param propertyName the name of the property that changed
     * @since 1.6
     * @see Action
     * @see #configurePropertiesFromAction
     */
    protected void actionPropertyChanged(Action action, String propertyName) {
<span class="nc bnc" id="L652" title="All 2 branches missed.">        if (propertyName == Action.ACTION_COMMAND_KEY) {</span>
<span class="nc" id="L653">            setActionCommandFromAction(action);</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">        } else if (propertyName == &quot;enabled&quot;) {</span>
<span class="nc" id="L655">            AbstractAction.setEnabledFromAction(this, action);</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">        } else if (propertyName == Action.SHORT_DESCRIPTION) {</span>
<span class="nc" id="L657">            AbstractAction.setToolTipTextFromAction(this, action);</span>
        }
<span class="nc" id="L659">    }</span>

    private void setActionCommandFromAction(Action action) {
<span class="nc bnc" id="L662" title="All 2 branches missed.">        setActionCommand((action == null) ? null :</span>
<span class="nc" id="L663">                         (String)action.getValue(Action.ACTION_COMMAND_KEY));</span>
<span class="nc" id="L664">    }</span>

    /**
     * Creates and returns a &lt;code&gt;PropertyChangeListener&lt;/code&gt; that is
     * responsible for listening for changes from the specified
     * &lt;code&gt;Action&lt;/code&gt; and updating the appropriate properties.
     * &lt;p&gt;
     * &lt;b&gt;Warning:&lt;/b&gt; If you subclass this do not create an anonymous
     * inner class.  If you do the lifetime of the textfield will be tied to
     * that of the &lt;code&gt;Action&lt;/code&gt;.
     *
     * @param a the textfield's action
     * @since 1.3
     * @see Action
     * @see #setAction
     */
    protected PropertyChangeListener createActionPropertyChangeListener(Action a) {
<span class="nc" id="L681">        return new TextFieldActionPropertyChangeListener(this, a);</span>
    }

    private static class TextFieldActionPropertyChangeListener extends
                         ActionPropertyChangeListener&lt;JTextField&gt; {
        TextFieldActionPropertyChangeListener(JTextField tf, Action a) {
<span class="nc" id="L687">            super(tf, a);</span>
<span class="nc" id="L688">        }</span>

        protected void actionPropertyChanged(JTextField textField,
                                             Action action,
                                             PropertyChangeEvent e) {
<span class="nc bnc" id="L693" title="All 2 branches missed.">            if (AbstractAction.shouldReconfigure(e)) {</span>
<span class="nc" id="L694">                textField.configurePropertiesFromAction(action);</span>
            } else {
<span class="nc" id="L696">                textField.actionPropertyChanged(action, e.getPropertyName());</span>
            }
<span class="nc" id="L698">        }</span>
    }

    /**
     * Fetches the command list for the editor.  This is
     * the list of commands supported by the plugged-in UI
     * augmented by the collection of commands that the
     * editor itself supports.  These are useful for binding
     * to events, such as in a keymap.
     *
     * @return the command list
     */
    public Action[] getActions() {
<span class="nc" id="L711">        return TextAction.augmentList(super.getActions(), defaultActions);</span>
    }

    /**
     * Processes action events occurring on this textfield by
     * dispatching them to any registered &lt;code&gt;ActionListener&lt;/code&gt; objects.
     * This is normally called by the controller registered with
     * textfield.
     */
    public void postActionEvent() {
<span class="nc" id="L721">        fireActionPerformed();</span>
<span class="nc" id="L722">    }</span>

    // --- Scrolling support -----------------------------------

    /**
     * Gets the visibility of the text field.  This can
     * be adjusted to change the location of the visible
     * area if the size of the field is greater than
     * the area that was allocated to the field.
     *
     * &lt;p&gt;
     * The fields look-and-feel implementation manages
     * the values of the minimum, maximum, and extent
     * properties on the &lt;code&gt;BoundedRangeModel&lt;/code&gt;.
     *
     * @return the visibility
     * @see BoundedRangeModel
     */
    public BoundedRangeModel getHorizontalVisibility() {
<span class="nc" id="L741">        return visibility;</span>
    }

    /**
     * Gets the scroll offset, in pixels.
     *
     * @return the offset &amp;gt;= 0
     */
    public int getScrollOffset() {
<span class="nc" id="L750">        return visibility.getValue();</span>
    }

    /**
     * Sets the scroll offset, in pixels.
     *
     * @param scrollOffset the offset &amp;gt;= 0
     */
    public void setScrollOffset(int scrollOffset) {
<span class="nc" id="L759">        visibility.setValue(scrollOffset);</span>
<span class="nc" id="L760">    }</span>

    /**
     * Scrolls the field left or right.
     *
     * @param r the region to scroll
     */
    public void scrollRectToVisible(Rectangle r) {
        // convert to coordinate system of the bounded range
<span class="nc" id="L769">        Insets i = getInsets();</span>
<span class="nc" id="L770">        int x0 = r.x + visibility.getValue() - i.left;</span>
<span class="nc" id="L771">        int x1 = x0 + r.width;</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">        if (x0 &lt; visibility.getValue()) {</span>
            // Scroll to the left
<span class="nc" id="L774">            visibility.setValue(x0);</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">        } else if(x1 &gt; visibility.getValue() + visibility.getExtent()) {</span>
            // Scroll to the right
<span class="nc" id="L777">            visibility.setValue(x1 - visibility.getExtent());</span>
        }
<span class="nc" id="L779">    }</span>

    /**
     * Returns true if the receiver has an &lt;code&gt;ActionListener&lt;/code&gt;
     * installed.
     */
    boolean hasActionListener() {
        // Guaranteed to return a non-null array
<span class="nc" id="L787">        Object[] listeners = listenerList.getListenerList();</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L790" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">            if (listeners[i]==ActionListener.class) {</span>
<span class="nc" id="L792">                return true;</span>
            }
        }
<span class="nc" id="L795">        return false;</span>
    }

    // --- variables -------------------------------------------

    /**
     * Name of the action to send notification that the
     * contents of the field have been accepted.  Typically
     * this is bound to a carriage-return.
     */
    public static final String notifyAction = &quot;notify-field-accept&quot;;

    private BoundedRangeModel visibility;
<span class="nc" id="L808">    private int horizontalAlignment = LEADING;</span>
    private int columns;
    private int columnWidth;
    private String command;

<span class="nc" id="L813">    private static final Action[] defaultActions = {</span>
        new NotifyAction()
    };

    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;TextFieldUI&quot;;

    // --- Action implementations -----------------------------------

    // Note that JFormattedTextField.CommitAction extends this
    static class NotifyAction extends TextAction {

        NotifyAction() {
<span class="nc" id="L829">            super(notifyAction);</span>
<span class="nc" id="L830">        }</span>

        public void actionPerformed(ActionEvent e) {
<span class="nc" id="L833">            JTextComponent target = getFocusedComponent();</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">            if (target instanceof JTextField) {</span>
<span class="nc" id="L835">                JTextField field = (JTextField) target;</span>
<span class="nc" id="L836">                field.postActionEvent();</span>
            }
<span class="nc" id="L838">        }</span>

        public boolean isEnabled() {
<span class="nc" id="L841">            JTextComponent target = getFocusedComponent();</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">            if (target instanceof JTextField) {</span>
<span class="nc" id="L843">                return ((JTextField)target).hasActionListener();</span>
            }
<span class="nc" id="L845">            return false;</span>
        }
    }

<span class="nc" id="L849">    class ScrollRepainter implements ChangeListener, Serializable {</span>

        public void stateChanged(ChangeEvent e) {
<span class="nc" id="L852">            repaint();</span>
<span class="nc" id="L853">        }</span>

    }


    /**
     * See &lt;code&gt;readObject&lt;/code&gt; and &lt;code&gt;writeObject&lt;/code&gt; in
     * &lt;code&gt;JComponent&lt;/code&gt; for more
     * information about serialization in Swing.
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L864">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L866">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L867">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L868" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L869">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L872">    }</span>


    /**
     * Returns a string representation of this &lt;code&gt;JTextField&lt;/code&gt;.
     * This method is intended to be used only for debugging purposes,
     * and the content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this &lt;code&gt;JTextField&lt;/code&gt;
     */
    protected String paramString() {
        String horizontalAlignmentString;
<span class="nc bnc" id="L886" title="All 2 branches missed.">        if (horizontalAlignment == LEFT) {</span>
<span class="nc" id="L887">            horizontalAlignmentString = &quot;LEFT&quot;;</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">        } else if (horizontalAlignment == CENTER) {</span>
<span class="nc" id="L889">            horizontalAlignmentString = &quot;CENTER&quot;;</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">        } else if (horizontalAlignment == RIGHT) {</span>
<span class="nc" id="L891">            horizontalAlignmentString = &quot;RIGHT&quot;;</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">        } else if (horizontalAlignment == LEADING) {</span>
<span class="nc" id="L893">            horizontalAlignmentString = &quot;LEADING&quot;;</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">        } else if (horizontalAlignment == TRAILING) {</span>
<span class="nc" id="L895">            horizontalAlignmentString = &quot;TRAILING&quot;;</span>
<span class="nc" id="L896">        } else horizontalAlignmentString = &quot;&quot;;</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">        String commandString = (command != null ?</span>
                                command : &quot;&quot;);

<span class="nc" id="L900">        return super.paramString() +</span>
        &quot;,columns=&quot; + columns +
        &quot;,columnWidth=&quot; + columnWidth +
        &quot;,command=&quot; + commandString +
        &quot;,horizontalAlignment=&quot; + horizontalAlignmentString;
    }


/////////////////
// Accessibility support
////////////////


    /**
     * Gets the &lt;code&gt;AccessibleContext&lt;/code&gt; associated with this
     * &lt;code&gt;JTextField&lt;/code&gt;. For &lt;code&gt;JTextFields&lt;/code&gt;,
     * the &lt;code&gt;AccessibleContext&lt;/code&gt; takes the form of an
     * &lt;code&gt;AccessibleJTextField&lt;/code&gt;.
     * A new &lt;code&gt;AccessibleJTextField&lt;/code&gt; instance is created
     * if necessary.
     *
     * @return an &lt;code&gt;AccessibleJTextField&lt;/code&gt; that serves as the
     *         &lt;code&gt;AccessibleContext&lt;/code&gt; of this &lt;code&gt;JTextField&lt;/code&gt;
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L925" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L926">            accessibleContext = new AccessibleJTextField();</span>
        }
<span class="nc" id="L928">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JTextField&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to text field user-interface
     * elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
<span class="nc" id="L946">    protected class AccessibleJTextField extends AccessibleJTextComponent {</span>

        /**
         * Gets the state set of this object.
         *
         * @return an instance of AccessibleStateSet describing the states
         * of the object
         * @see AccessibleState
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L956">            AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc" id="L957">            states.add(AccessibleState.SINGLE_LINE);</span>
<span class="nc" id="L958">            return states;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>