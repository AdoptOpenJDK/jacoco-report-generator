<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JEditorPane.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JEditorPane.java</span></div><h1>JEditorPane.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package javax.swing;

import sun.swing.SwingUtilities2;

import java.awt.*;
import java.awt.event.*;
import java.lang.reflect.*;
import java.net.*;
import java.util.*;
import java.io.*;
import java.util.*;

import javax.swing.plaf.*;
import javax.swing.text.*;
import javax.swing.event.*;
import javax.swing.text.html.*;
import javax.accessibility.*;

/**
 * A text component to edit various kinds of content.
 * You can find how-to information and examples of using editor panes in
 * &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/text.html&quot;&gt;Using Text Components&lt;/a&gt;,
 * a section in &lt;em&gt;The Java Tutorial.&lt;/em&gt;
 *
 * &lt;p&gt;
 * This component uses implementations of the
 * &lt;code&gt;EditorKit&lt;/code&gt; to accomplish its behavior. It effectively
 * morphs into the proper kind of text editor for the kind
 * of content it is given.  The content type that editor is bound
 * to at any given time is determined by the &lt;code&gt;EditorKit&lt;/code&gt; currently
 * installed.  If the content is set to a new URL, its type is used
 * to determine the &lt;code&gt;EditorKit&lt;/code&gt; that should be used to
 * load the content.
 * &lt;p&gt;
 * By default, the following types of content are known:
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;b&gt;text/plain&lt;/b&gt;
 * &lt;dd&gt;Plain text, which is the default the type given isn't
 * recognized.  The kit used in this case is an extension of
 * &lt;code&gt;DefaultEditorKit&lt;/code&gt; that produces a wrapped plain text view.
 * &lt;dt&gt;&lt;b&gt;text/html&lt;/b&gt;
 * &lt;dd&gt;HTML text.  The kit used in this case is the class
 * &lt;code&gt;javax.swing.text.html.HTMLEditorKit&lt;/code&gt;
 * which provides HTML 3.2 support.
 * &lt;dt&gt;&lt;b&gt;text/rtf&lt;/b&gt;
 * &lt;dd&gt;RTF text.  The kit used in this case is the class
 * &lt;code&gt;javax.swing.text.rtf.RTFEditorKit&lt;/code&gt;
 * which provides a limited support of the Rich Text Format.
 * &lt;/dl&gt;
 * &lt;p&gt;
 * There are several ways to load content into this component.
 * &lt;ol&gt;
 * &lt;li&gt;
 * The {@link #setText setText} method can be used to initialize
 * the component from a string.  In this case the current
 * &lt;code&gt;EditorKit&lt;/code&gt; will be used, and the content type will be
 * expected to be of this type.
 * &lt;li&gt;
 * The {@link #read read} method can be used to initialize the
 * component from a &lt;code&gt;Reader&lt;/code&gt;.  Note that if the content type is HTML,
 * relative references (e.g. for things like images) can't be resolved
 * unless the &amp;lt;base&amp;gt; tag is used or the &lt;em&gt;Base&lt;/em&gt; property
 * on &lt;code&gt;HTMLDocument&lt;/code&gt; is set.
 * In this case the current &lt;code&gt;EditorKit&lt;/code&gt; will be used,
 * and the content type will be expected to be of this type.
 * &lt;li&gt;
 * The {@link #setPage setPage} method can be used to initialize
 * the component from a URL.  In this case, the content type will be
 * determined from the URL, and the registered &lt;code&gt;EditorKit&lt;/code&gt;
 * for that content type will be set.
 * &lt;/ol&gt;
 * &lt;p&gt;
 * Some kinds of content may provide hyperlink support by generating
 * hyperlink events.  The HTML &lt;code&gt;EditorKit&lt;/code&gt; will generate
 * hyperlink events if the &lt;code&gt;JEditorPane&lt;/code&gt; is &lt;em&gt;not editable&lt;/em&gt;
 * (&lt;code&gt;JEditorPane.setEditable(false);&lt;/code&gt; has been called).
 * If HTML frames are embedded in the document, the typical response would be
 * to change a portion of the current document.  The following code
 * fragment is a possible hyperlink listener implementation, that treats
 * HTML frame events specially, and simply displays any other activated
 * hyperlinks.
 * &lt;pre&gt;

&amp;nbsp;    class Hyperactive implements HyperlinkListener {
&amp;nbsp;
&amp;nbsp;        public void hyperlinkUpdate(HyperlinkEvent e) {
&amp;nbsp;            if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED) {
&amp;nbsp;                JEditorPane pane = (JEditorPane) e.getSource();
&amp;nbsp;                if (e instanceof HTMLFrameHyperlinkEvent) {
&amp;nbsp;                    HTMLFrameHyperlinkEvent  evt = (HTMLFrameHyperlinkEvent)e;
&amp;nbsp;                    HTMLDocument doc = (HTMLDocument)pane.getDocument();
&amp;nbsp;                    doc.processHTMLFrameHyperlinkEvent(evt);
&amp;nbsp;                } else {
&amp;nbsp;                    try {
&amp;nbsp;                        pane.setPage(e.getURL());
&amp;nbsp;                    } catch (Throwable t) {
&amp;nbsp;                        t.printStackTrace();
&amp;nbsp;                    }
&amp;nbsp;                }
&amp;nbsp;            }
&amp;nbsp;        }
&amp;nbsp;    }

 * &lt;/pre&gt;
 * &lt;p&gt;
 * For information on customizing how &lt;b&gt;text/html&lt;/b&gt; is rendered please see
 * {@link #W3C_LENGTH_UNITS} and {@link #HONOR_DISPLAY_PROPERTIES}
 * &lt;p&gt;
 * Culturally dependent information in some documents is handled through
 * a mechanism called character encoding.  Character encoding is an
 * unambiguous mapping of the members of a character set (letters, ideographs,
 * digits, symbols, or control functions) to specific numeric code values. It
 * represents the way the file is stored. Example character encodings are
 * ISO-8859-1, ISO-8859-5, Shift-jis, Euc-jp, and UTF-8. When the file is
 * passed to an user agent (&lt;code&gt;JEditorPane&lt;/code&gt;) it is converted to
 * the document character set (ISO-10646 aka Unicode).
 * &lt;p&gt;
 * There are multiple ways to get a character set mapping to happen
 * with &lt;code&gt;JEditorPane&lt;/code&gt;.
 * &lt;ol&gt;
 * &lt;li&gt;
 * One way is to specify the character set as a parameter of the MIME
 * type.  This will be established by a call to the
 * {@link #setContentType setContentType} method.  If the content
 * is loaded by the {@link #setPage setPage} method the content
 * type will have been set according to the specification of the URL.
 * It the file is loaded directly, the content type would be expected to
 * have been set prior to loading.
 * &lt;li&gt;
 * Another way the character set can be specified is in the document itself.
 * This requires reading the document prior to determining the character set
 * that is desired.  To handle this, it is expected that the
 * &lt;code&gt;EditorKit&lt;/code&gt;.read operation throw a
 * &lt;code&gt;ChangedCharSetException&lt;/code&gt; which will
 * be caught.  The read is then restarted with a new Reader that uses
 * the character set specified in the &lt;code&gt;ChangedCharSetException&lt;/code&gt;
 * (which is an &lt;code&gt;IOException&lt;/code&gt;).
 * &lt;/ol&gt;
 * &lt;p&gt;
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;b&gt;&lt;font size=+1&gt;Newlines&lt;/font&gt;&lt;/b&gt;
 * &lt;dd&gt;
 * For a discussion on how newlines are handled, see
 * &lt;a href=&quot;text/DefaultEditorKit.html&quot;&gt;DefaultEditorKit&lt;/a&gt;.
 * &lt;/dl&gt;
 *
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @beaninfo
 *   attribute: isContainer false
 * description: A text component to edit various types of content.
 *
 * @author  Timothy Prinzing
 */
public class JEditorPane extends JTextComponent {

    /**
     * Creates a new &lt;code&gt;JEditorPane&lt;/code&gt;.
     * The document model is set to &lt;code&gt;null&lt;/code&gt;.
     */
    public JEditorPane() {
<span class="nc" id="L199">        super();</span>
<span class="nc" id="L200">        setFocusCycleRoot(true);</span>
<span class="nc" id="L201">        setFocusTraversalPolicy(new LayoutFocusTraversalPolicy() {</span>
                public Component getComponentAfter(Container focusCycleRoot,
                                                   Component aComponent) {
<span class="nc bnc" id="L204" title="All 2 branches missed.">                    if (focusCycleRoot != JEditorPane.this ||</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">                        (!isEditable() &amp;&amp; getComponentCount() &gt; 0)) {</span>
<span class="nc" id="L206">                        return super.getComponentAfter(focusCycleRoot,</span>
                                                       aComponent);
                    } else {
<span class="nc" id="L209">                        Container rootAncestor = getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">                        return (rootAncestor != null)</span>
<span class="nc" id="L211">                            ? rootAncestor.getFocusTraversalPolicy().</span>
<span class="nc" id="L212">                                  getComponentAfter(rootAncestor,</span>
                                                    JEditorPane.this)
                            : null;
                    }
                }
                public Component getComponentBefore(Container focusCycleRoot,
                                                    Component aComponent) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">                    if (focusCycleRoot != JEditorPane.this ||</span>
<span class="nc bnc" id="L220" title="All 4 branches missed.">                        (!isEditable() &amp;&amp; getComponentCount() &gt; 0)) {</span>
<span class="nc" id="L221">                        return super.getComponentBefore(focusCycleRoot,</span>
                                                        aComponent);
                    } else {
<span class="nc" id="L224">                        Container rootAncestor = getFocusCycleRootAncestor();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">                        return (rootAncestor != null)</span>
<span class="nc" id="L226">                            ? rootAncestor.getFocusTraversalPolicy().</span>
<span class="nc" id="L227">                                  getComponentBefore(rootAncestor,</span>
                                                     JEditorPane.this)
                            : null;
                    }
                }
                public Component getDefaultComponent(Container focusCycleRoot)
                {
<span class="nc bnc" id="L234" title="All 2 branches missed.">                    return (focusCycleRoot != JEditorPane.this ||</span>
<span class="nc bnc" id="L235" title="All 4 branches missed.">                            (!isEditable() &amp;&amp; getComponentCount() &gt; 0))</span>
<span class="nc" id="L236">                        ? super.getDefaultComponent(focusCycleRoot)</span>
                        : null;
                }
                protected boolean accept(Component aComponent) {
<span class="nc bnc" id="L240" title="All 2 branches missed.">                    return (aComponent != JEditorPane.this)</span>
<span class="nc" id="L241">                        ? super.accept(aComponent)</span>
                        : false;
                }
            });
<span class="nc" id="L245">        LookAndFeel.installProperty(this,</span>
                                    &quot;focusTraversalKeysForward&quot;,
                                    JComponent.
<span class="nc" id="L248">                                    getManagingFocusForwardTraversalKeys());</span>
<span class="nc" id="L249">        LookAndFeel.installProperty(this,</span>
                                    &quot;focusTraversalKeysBackward&quot;,
                                    JComponent.
<span class="nc" id="L252">                                    getManagingFocusBackwardTraversalKeys());</span>
<span class="nc" id="L253">    }</span>

    /**
     * Creates a &lt;code&gt;JEditorPane&lt;/code&gt; based on a specified URL for input.
     *
     * @param initialPage the URL
     * @exception IOException if the URL is &lt;code&gt;null&lt;/code&gt;
     *          or cannot be accessed
     */
    public JEditorPane(URL initialPage) throws IOException {
<span class="nc" id="L263">        this();</span>
<span class="nc" id="L264">        setPage(initialPage);</span>
<span class="nc" id="L265">    }</span>

    /**
     * Creates a &lt;code&gt;JEditorPane&lt;/code&gt; based on a string containing
     * a URL specification.
     *
     * @param url the URL
     * @exception IOException if the URL is &lt;code&gt;null&lt;/code&gt; or
     *          cannot be accessed
     */
    public JEditorPane(String url) throws IOException {
<span class="nc" id="L276">        this();</span>
<span class="nc" id="L277">        setPage(url);</span>
<span class="nc" id="L278">    }</span>

    /**
     * Creates a &lt;code&gt;JEditorPane&lt;/code&gt; that has been initialized
     * to the given text.  This is a convenience constructor that calls the
     * &lt;code&gt;setContentType&lt;/code&gt; and &lt;code&gt;setText&lt;/code&gt; methods.
     *
     * @param type mime type of the given text
     * @param text the text to initialize with; may be &lt;code&gt;null&lt;/code&gt;
     * @exception NullPointerException if the &lt;code&gt;type&lt;/code&gt; parameter
     *          is &lt;code&gt;null&lt;/code&gt;
     */
    public JEditorPane(String type, String text) {
<span class="nc" id="L291">        this();</span>
<span class="nc" id="L292">        setContentType(type);</span>
<span class="nc" id="L293">        setText(text);</span>
<span class="nc" id="L294">    }</span>

    /**
     * Adds a hyperlink listener for notification of any changes, for example
     * when a link is selected and entered.
     *
     * @param listener the listener
     */
    public synchronized void addHyperlinkListener(HyperlinkListener listener) {
<span class="nc" id="L303">        listenerList.add(HyperlinkListener.class, listener);</span>
<span class="nc" id="L304">    }</span>

    /**
     * Removes a hyperlink listener.
     *
     * @param listener the listener
     */
    public synchronized void removeHyperlinkListener(HyperlinkListener listener) {
<span class="nc" id="L312">        listenerList.remove(HyperlinkListener.class, listener);</span>
<span class="nc" id="L313">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;HyperLinkListener&lt;/code&gt;s added
     * to this JEditorPane with addHyperlinkListener().
     *
     * @return all of the &lt;code&gt;HyperLinkListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public synchronized HyperlinkListener[] getHyperlinkListeners() {
<span class="nc" id="L324">        return listenerList.getListeners(javax.swing.event.HyperlinkListener.class);</span>
    }

    /**
     * Notifies all listeners that have registered interest for
     * notification on this event type.  This is normally called
     * by the currently installed &lt;code&gt;EditorKit&lt;/code&gt; if a content type
     * that supports hyperlinks is currently active and there
     * was activity with a link.  The listener list is processed
     * last to first.
     *
     * @param e the event
     * @see EventListenerList
     */
    public void fireHyperlinkUpdate(HyperlinkEvent e) {
        // Guaranteed to return a non-null array
<span class="nc" id="L340">        Object[] listeners = listenerList.getListenerList();</span>
        // Process the listeners last to first, notifying
        // those that are interested in this event
<span class="nc bnc" id="L343" title="All 2 branches missed.">        for (int i = listeners.length-2; i&gt;=0; i-=2) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">            if (listeners[i]==HyperlinkListener.class) {</span>
<span class="nc" id="L345">                ((HyperlinkListener)listeners[i+1]).hyperlinkUpdate(e);</span>
            }
        }
<span class="nc" id="L348">    }</span>


    /**
     * Sets the current URL being displayed.  The content type of the
     * pane is set, and if the editor kit for the pane is
     * non-&lt;code&gt;null&lt;/code&gt;, then
     * a new default document is created and the URL is read into it.
     * If the URL contains and reference location, the location will
     * be scrolled to by calling the &lt;code&gt;scrollToReference&lt;/code&gt;
     * method. If the desired URL is the one currently being displayed,
     * the document will not be reloaded. To force a document
     * reload it is necessary to clear the stream description property
     * of the document. The following code shows how this can be done:
     *
     * &lt;pre&gt;
     *   Document doc = jEditorPane.getDocument();
     *   doc.putProperty(Document.StreamDescriptionProperty, null);
     * &lt;/pre&gt;
     *
     * If the desired URL is not the one currently being
     * displayed, the &lt;code&gt;getStream&lt;/code&gt; method is called to
     * give subclasses control over the stream provided.
     * &lt;p&gt;
     * This may load either synchronously or asynchronously
     * depending upon the document returned by the &lt;code&gt;EditorKit&lt;/code&gt;.
     * If the &lt;code&gt;Document&lt;/code&gt; is of type
     * &lt;code&gt;AbstractDocument&lt;/code&gt; and has a value returned by
     * &lt;code&gt;AbstractDocument.getAsynchronousLoadPriority&lt;/code&gt;
     * that is greater than or equal to zero, the page will be
     * loaded on a separate thread using that priority.
     * &lt;p&gt;
     * If the document is loaded synchronously, it will be
     * filled in with the stream prior to being installed into
     * the editor with a call to &lt;code&gt;setDocument&lt;/code&gt;, which
     * is bound and will fire a property change event.  If an
     * &lt;code&gt;IOException&lt;/code&gt; is thrown the partially loaded
     * document will
     * be discarded and neither the document or page property
     * change events will be fired.  If the document is
     * successfully loaded and installed, a view will be
     * built for it by the UI which will then be scrolled if
     * necessary, and then the page property change event
     * will be fired.
     * &lt;p&gt;
     * If the document is loaded asynchronously, the document
     * will be installed into the editor immediately using a
     * call to &lt;code&gt;setDocument&lt;/code&gt; which will fire a
     * document property change event, then a thread will be
     * created which will begin doing the actual loading.
     * In this case, the page property change event will not be
     * fired by the call to this method directly, but rather will be
     * fired when the thread doing the loading has finished.
     * It will also be fired on the event-dispatch thread.
     * Since the calling thread can not throw an &lt;code&gt;IOException&lt;/code&gt;
     * in the event of failure on the other thread, the page
     * property change event will be fired when the other
     * thread is done whether the load was successful or not.
     *
     * @param page the URL of the page
     * @exception IOException for a &lt;code&gt;null&lt;/code&gt; or invalid
     *          page specification, or exception from the stream being read
     * @see #getPage
     * @beaninfo
     *  description: the URL used to set content
     *        bound: true
     *       expert: true
     */
    public void setPage(URL page) throws IOException {
<span class="nc bnc" id="L417" title="All 2 branches missed.">        if (page == null) {</span>
<span class="nc" id="L418">            throw new IOException(&quot;invalid url&quot;);</span>
        }
<span class="nc" id="L420">        URL loaded = getPage();</span>


        // reset scrollbar
<span class="nc bnc" id="L424" title="All 4 branches missed.">        if (!page.equals(loaded) &amp;&amp; page.getRef() == null) {</span>
<span class="nc" id="L425">            scrollRectToVisible(new Rectangle(0,0,1,1));</span>
        }
<span class="nc" id="L427">        boolean reloaded = false;</span>
<span class="nc" id="L428">        Object postData = getPostData();</span>
<span class="nc bnc" id="L429" title="All 6 branches missed.">        if ((loaded == null) || !loaded.sameFile(page) || (postData != null)) {</span>
            // different url or POST method, load the new content

<span class="nc" id="L432">            int p = getAsynchronousLoadPriority(getDocument());</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">            if (p &lt; 0) {</span>
                // open stream synchronously
<span class="nc" id="L435">                InputStream in = getStream(page);</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                if (kit != null) {</span>
<span class="nc" id="L437">                    Document doc = initializeModel(kit, page);</span>

                    // At this point, one could either load up the model with no
                    // view notifications slowing it down (i.e. best synchronous
                    // behavior) or set the model and start to feed it on a separate
                    // thread (best asynchronous behavior).
<span class="nc" id="L443">                    p = getAsynchronousLoadPriority(doc);</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                    if (p &gt;= 0) {</span>
                        // load asynchronously
<span class="nc" id="L446">                        setDocument(doc);</span>
<span class="nc" id="L447">                        synchronized(this) {</span>
<span class="nc" id="L448">                            pageLoader = new PageLoader(doc, in, loaded, page);</span>
<span class="nc" id="L449">                            pageLoader.execute();</span>
<span class="nc" id="L450">                        }</span>
<span class="nc" id="L451">                        return;</span>
                    }
<span class="nc" id="L453">                    read(in, doc);</span>
<span class="nc" id="L454">                    setDocument(doc);</span>
<span class="nc" id="L455">                    reloaded = true;</span>
                }
<span class="nc" id="L457">            } else {</span>
                // we may need to cancel background loading
<span class="nc bnc" id="L459" title="All 2 branches missed.">                if (pageLoader != null) {</span>
<span class="nc" id="L460">                    pageLoader.cancel(true);</span>
                }

                // Do everything in a background thread.
                // Model initialization is deferred to that thread, too.
<span class="nc" id="L465">                pageLoader = new PageLoader(null, null, loaded, page);</span>
<span class="nc" id="L466">                pageLoader.execute();</span>
<span class="nc" id="L467">                return;</span>
            }
        }
<span class="nc" id="L470">        final String reference = page.getRef();</span>
<span class="nc bnc" id="L471" title="All 2 branches missed.">        if (reference != null) {</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if (!reloaded) {</span>
<span class="nc" id="L473">                scrollToReference(reference);</span>
            }
            else {
                // Have to scroll after painted.
<span class="nc" id="L477">                SwingUtilities.invokeLater(new Runnable() {</span>
                    public void run() {
<span class="nc" id="L479">                        scrollToReference(reference);</span>
<span class="nc" id="L480">                    }</span>
                });
            }
<span class="nc" id="L483">            getDocument().putProperty(Document.StreamDescriptionProperty, page);</span>
        }
<span class="nc" id="L485">        firePropertyChange(&quot;page&quot;, loaded, page);</span>
<span class="nc" id="L486">    }</span>

    /**
     * Create model and initialize document properties from page properties.
     */
    private Document initializeModel(EditorKit kit, URL page) {
<span class="nc" id="L492">        Document doc = kit.createDefaultDocument();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (pageProperties != null) {</span>
            // transfer properties discovered in stream to the
            // document property collection.
<span class="nc bnc" id="L496" title="All 2 branches missed.">            for (Enumeration&lt;String&gt; e = pageProperties.keys(); e.hasMoreElements() ;) {</span>
<span class="nc" id="L497">                String key = e.nextElement();</span>
<span class="nc" id="L498">                doc.putProperty(key, pageProperties.get(key));</span>
<span class="nc" id="L499">            }</span>
<span class="nc" id="L500">            pageProperties.clear();</span>
        }
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if (doc.getProperty(Document.StreamDescriptionProperty) == null) {</span>
<span class="nc" id="L503">            doc.putProperty(Document.StreamDescriptionProperty, page);</span>
        }
<span class="nc" id="L505">        return doc;</span>
    }

    /**
     * Return load priority for the document or -1 if priority not supported.
     */
    private int getAsynchronousLoadPriority(Document doc) {
<span class="nc bnc" id="L512" title="All 2 branches missed.">        return (doc instanceof AbstractDocument ?</span>
<span class="nc" id="L513">            ((AbstractDocument) doc).getAsynchronousLoadPriority() : -1);</span>
    }

    /**
     * This method initializes from a stream.  If the kit is
     * set to be of type &lt;code&gt;HTMLEditorKit&lt;/code&gt;, and the
     * &lt;code&gt;desc&lt;/code&gt; parameter is an &lt;code&gt;HTMLDocument&lt;/code&gt;,
     * then it invokes the &lt;code&gt;HTMLEditorKit&lt;/code&gt; to initiate
     * the read. Otherwise it calls the superclass
     * method which loads the model as plain text.
     *
     * @param in the stream from which to read
     * @param desc an object describing the stream
     * @exception IOException as thrown by the stream being
     *          used to initialize
     * @see JTextComponent#read
     * @see #setDocument
     */
    public void read(InputStream in, Object desc) throws IOException {

<span class="nc bnc" id="L533" title="All 4 branches missed.">        if (desc instanceof HTMLDocument &amp;&amp;</span>
            kit instanceof HTMLEditorKit) {
<span class="nc" id="L535">            HTMLDocument hdoc = (HTMLDocument) desc;</span>
<span class="nc" id="L536">            setDocument(hdoc);</span>
<span class="nc" id="L537">            read(in, hdoc);</span>
<span class="nc" id="L538">        } else {</span>
<span class="nc" id="L539">            String charset = (String) getClientProperty(&quot;charset&quot;);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">            Reader r = (charset != null) ? new InputStreamReader(in, charset) :</span>
                new InputStreamReader(in);
<span class="nc" id="L542">            super.read(r, desc);</span>
        }
<span class="nc" id="L544">    }</span>


    /**
     * This method invokes the &lt;code&gt;EditorKit&lt;/code&gt; to initiate a
     * read.  In the case where a &lt;code&gt;ChangedCharSetException&lt;/code&gt;
     * is thrown this exception will contain the new CharSet.
     * Therefore the &lt;code&gt;read&lt;/code&gt; operation
     * is then restarted after building a new Reader with the new charset.
     *
     * @param in the inputstream to use
     * @param doc the document to load
     *
     */
    void read(InputStream in, Document doc) throws IOException {
<span class="nc bnc" id="L559" title="All 2 branches missed.">        if (! Boolean.TRUE.equals(doc.getProperty(&quot;IgnoreCharsetDirective&quot;))) {</span>
            final int READ_LIMIT = 1024 * 10;
<span class="nc" id="L561">            in = new BufferedInputStream(in, READ_LIMIT);</span>
<span class="nc" id="L562">            in.mark(READ_LIMIT);</span>
        }
        try {
<span class="nc" id="L565">            String charset = (String) getClientProperty(&quot;charset&quot;);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">            Reader r = (charset != null) ? new InputStreamReader(in, charset) :</span>
                new InputStreamReader(in);
<span class="nc" id="L568">            kit.read(r, doc, 0);</span>
<span class="nc" id="L569">        } catch (BadLocationException e) {</span>
<span class="nc" id="L570">            throw new IOException(e.getMessage());</span>
<span class="nc" id="L571">        } catch (ChangedCharSetException changedCharSetException) {</span>
<span class="nc" id="L572">            String charSetSpec = changedCharSetException.getCharSetSpec();</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">            if (changedCharSetException.keyEqualsCharSet()) {</span>
<span class="nc" id="L574">                putClientProperty(&quot;charset&quot;, charSetSpec);</span>
            } else {
<span class="nc" id="L576">                setCharsetFromContentTypeParameters(charSetSpec);</span>
            }
            try {
<span class="nc" id="L579">                in.reset();</span>
<span class="nc" id="L580">            } catch (IOException exception) {</span>
                //mark was invalidated
<span class="nc" id="L582">                in.close();</span>
<span class="nc" id="L583">                URL url = (URL)doc.getProperty(Document.StreamDescriptionProperty);</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                if (url != null) {</span>
<span class="nc" id="L585">                    URLConnection conn = url.openConnection();</span>
<span class="nc" id="L586">                    in = conn.getInputStream();</span>
<span class="nc" id="L587">                } else {</span>
                    //there is nothing we can do to recover stream
<span class="nc" id="L589">                    throw changedCharSetException;</span>
                }
<span class="nc" id="L591">            }</span>
            try {
<span class="nc" id="L593">                doc.remove(0, doc.getLength());</span>
<span class="nc" id="L594">            } catch (BadLocationException e) {}</span>
<span class="nc" id="L595">            doc.putProperty(&quot;IgnoreCharsetDirective&quot;, Boolean.valueOf(true));</span>
<span class="nc" id="L596">            read(in, doc);</span>
<span class="nc" id="L597">        }</span>
<span class="nc" id="L598">    }</span>


    /**
     * Loads a stream into the text document model.
     */
    class PageLoader extends SwingWorker&lt;URL, Object&gt; {

        /**
         * Construct an asynchronous page loader.
         */
<span class="nc" id="L609">        PageLoader(Document doc, InputStream in, URL old, URL page) {</span>
<span class="nc" id="L610">            this.in = in;</span>
<span class="nc" id="L611">            this.old = old;</span>
<span class="nc" id="L612">            this.page = page;</span>
<span class="nc" id="L613">            this.doc = doc;</span>
<span class="nc" id="L614">        }</span>

        /**
         * Try to load the document, then scroll the view
         * to the reference (if specified).  When done, fire
         * a page property change event.
         */
        protected URL doInBackground() {
<span class="nc" id="L622">            boolean pageLoaded = false;</span>
            try {
<span class="nc bnc" id="L624" title="All 2 branches missed.">                if (in == null) {</span>
<span class="nc" id="L625">                    in = getStream(page);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">                    if (kit == null) {</span>
                        // We received document of unknown content type.
<span class="nc" id="L628">                        UIManager.getLookAndFeel().</span>
<span class="nc" id="L629">                                provideErrorFeedback(JEditorPane.this);</span>
<span class="nc" id="L630">                        return old;</span>
                    }
                }

<span class="nc bnc" id="L634" title="All 2 branches missed.">                if (doc == null) {</span>
                    try {
<span class="nc" id="L636">                        SwingUtilities.invokeAndWait(new Runnable() {</span>
                            public void run() {
<span class="nc" id="L638">                                doc = initializeModel(kit, page);</span>
<span class="nc" id="L639">                                setDocument(doc);</span>
<span class="nc" id="L640">                            }</span>
                        });
<span class="nc" id="L642">                    } catch (InvocationTargetException ex) {</span>
<span class="nc" id="L643">                        UIManager.getLookAndFeel().provideErrorFeedback(</span>
                                                            JEditorPane.this);
<span class="nc" id="L645">                        return old;</span>
<span class="nc" id="L646">                    } catch (InterruptedException ex) {</span>
<span class="nc" id="L647">                        UIManager.getLookAndFeel().provideErrorFeedback(</span>
                                                            JEditorPane.this);
<span class="nc" id="L649">                        return old;</span>
<span class="nc" id="L650">                    }</span>
                }

<span class="nc" id="L653">                read(in, doc);</span>
<span class="nc" id="L654">                URL page = (URL) doc.getProperty(Document.StreamDescriptionProperty);</span>
<span class="nc" id="L655">                String reference = page.getRef();</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if (reference != null) {</span>
                    // scroll the page if necessary, but do it on the
                    // event thread... that is the only guarantee that
                    // modelToView can be safely called.
<span class="nc" id="L660">                    Runnable callScrollToReference = new Runnable() {</span>
                        public void run() {
<span class="nc" id="L662">                            URL u = (URL) getDocument().getProperty</span>
<span class="nc" id="L663">                                (Document.StreamDescriptionProperty);</span>
<span class="nc" id="L664">                            String ref = u.getRef();</span>
<span class="nc" id="L665">                            scrollToReference(ref);</span>
<span class="nc" id="L666">                        }</span>
                    };
<span class="nc" id="L668">                    SwingUtilities.invokeLater(callScrollToReference);</span>
                }
<span class="nc" id="L670">                pageLoaded = true;</span>
<span class="nc" id="L671">            } catch (IOException ioe) {</span>
<span class="nc" id="L672">                UIManager.getLookAndFeel().provideErrorFeedback(JEditorPane.this);</span>
            } finally {
<span class="nc bnc" id="L674" title="All 12 branches missed.">                if (pageLoaded) {</span>
<span class="nc" id="L675">                    SwingUtilities.invokeLater(new Runnable() {</span>
                        public void run() {
<span class="nc" id="L677">                            JEditorPane.this.firePropertyChange(&quot;page&quot;, old, page);</span>
<span class="nc" id="L678">                        }</span>
                    });
                }
<span class="nc bnc" id="L681" title="All 12 branches missed.">                return (pageLoaded ? page : old);</span>
            }
        }

        /**
         * The stream to load the document with
         */
        InputStream in;

        /**
         * URL of the old page that was replaced (for the property change event)
         */
        URL old;

        /**
         * URL of the page being loaded (for the property change event)
         */
        URL page;

        /**
         * The Document instance to load into. This is cached in case a
         * new Document is created between the time the thread this is created
         * and run.
         */
        Document doc;
    }

    /**
     * Fetches a stream for the given URL, which is about to
     * be loaded by the &lt;code&gt;setPage&lt;/code&gt; method.  By
     * default, this simply opens the URL and returns the
     * stream.  This can be reimplemented to do useful things
     * like fetch the stream from a cache, monitor the progress
     * of the stream, etc.
     * &lt;p&gt;
     * This method is expected to have the the side effect of
     * establishing the content type, and therefore setting the
     * appropriate &lt;code&gt;EditorKit&lt;/code&gt; to use for loading the stream.
     * &lt;p&gt;
     * If this the stream was an http connection, redirects
     * will be followed and the resulting URL will be set as
     * the &lt;code&gt;Document.StreamDescriptionProperty&lt;/code&gt; so that relative
     * URL's can be properly resolved.
     *
     * @param page  the URL of the page
     */
    protected InputStream getStream(URL page) throws IOException {
<span class="nc" id="L728">        final URLConnection conn = page.openConnection();</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (conn instanceof HttpURLConnection) {</span>
<span class="nc" id="L730">            HttpURLConnection hconn = (HttpURLConnection) conn;</span>
<span class="nc" id="L731">            hconn.setInstanceFollowRedirects(false);</span>
<span class="nc" id="L732">            Object postData = getPostData();</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">            if (postData != null) {</span>
<span class="nc" id="L734">                handlePostData(hconn, postData);</span>
            }
<span class="nc" id="L736">            int response = hconn.getResponseCode();</span>
<span class="nc bnc" id="L737" title="All 4 branches missed.">            boolean redirect = (response &gt;= 300 &amp;&amp; response &lt;= 399);</span>

            /*
             * In the case of a redirect, we want to actually change the URL
             * that was input to the new, redirected URL
             */
<span class="nc bnc" id="L743" title="All 2 branches missed.">            if (redirect) {</span>
<span class="nc" id="L744">                String loc = conn.getHeaderField(&quot;Location&quot;);</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">                if (loc.startsWith(&quot;http&quot;, 0)) {</span>
<span class="nc" id="L746">                    page = new URL(loc);</span>
                } else {
<span class="nc" id="L748">                    page = new URL(page, loc);</span>
                }
<span class="nc" id="L750">                return getStream(page);</span>
            }
        }

        // Connection properties handler should be forced to run on EDT,
        // as it instantiates the EditorKit.
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if (SwingUtilities.isEventDispatchThread()) {</span>
<span class="nc" id="L757">            handleConnectionProperties(conn);</span>
        } else {
            try {
<span class="nc" id="L760">                SwingUtilities.invokeAndWait(new Runnable() {</span>
                    public void run() {
<span class="nc" id="L762">                        handleConnectionProperties(conn);</span>
<span class="nc" id="L763">                    }</span>
                });
<span class="nc" id="L765">            } catch (InterruptedException e) {</span>
<span class="nc" id="L766">                throw new RuntimeException(e);</span>
<span class="nc" id="L767">            } catch (InvocationTargetException e) {</span>
<span class="nc" id="L768">                throw new RuntimeException(e);</span>
<span class="nc" id="L769">            }</span>
        }
<span class="nc" id="L771">        return conn.getInputStream();</span>
    }

    /**
     * Handle URL connection properties (most notably, content type).
     */
    private void handleConnectionProperties(URLConnection conn) {
<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (pageProperties == null) {</span>
<span class="nc" id="L779">            pageProperties = new Hashtable&lt;String, Object&gt;();</span>
        }
<span class="nc" id="L781">        String type = conn.getContentType();</span>
<span class="nc bnc" id="L782" title="All 2 branches missed.">        if (type != null) {</span>
<span class="nc" id="L783">            setContentType(type);</span>
<span class="nc" id="L784">            pageProperties.put(&quot;content-type&quot;, type);</span>
        }
<span class="nc" id="L786">        pageProperties.put(Document.StreamDescriptionProperty, conn.getURL());</span>
<span class="nc" id="L787">        String enc = conn.getContentEncoding();</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">        if (enc != null) {</span>
<span class="nc" id="L789">            pageProperties.put(&quot;content-encoding&quot;, enc);</span>
        }
<span class="nc" id="L791">    }</span>

    private Object getPostData() {
<span class="nc" id="L794">        return getDocument().getProperty(PostDataProperty);</span>
    }

    private void handlePostData(HttpURLConnection conn, Object postData)
                                                            throws IOException {
<span class="nc" id="L799">        conn.setDoOutput(true);</span>
<span class="nc" id="L800">        DataOutputStream os = null;</span>
        try {
<span class="nc" id="L802">            conn.setRequestProperty(&quot;Content-Type&quot;,</span>
                    &quot;application/x-www-form-urlencoded&quot;);
<span class="nc" id="L804">            os = new DataOutputStream(conn.getOutputStream());</span>
<span class="nc" id="L805">            os.writeBytes((String) postData);</span>
        } finally {
<span class="nc bnc" id="L807" title="All 4 branches missed.">            if (os != null) {</span>
<span class="nc" id="L808">                os.close();</span>
            }
        }
<span class="nc" id="L811">    }</span>


    /**
     * Scrolls the view to the given reference location
     * (that is, the value returned by the &lt;code&gt;UL.getRef&lt;/code&gt;
     * method for the URL being displayed).  By default, this
     * method only knows how to locate a reference in an
     * HTMLDocument.  The implementation calls the
     * &lt;code&gt;scrollRectToVisible&lt;/code&gt; method to
     * accomplish the actual scrolling.  If scrolling to a
     * reference location is needed for document types other
     * than HTML, this method should be reimplemented.
     * This method will have no effect if the component
     * is not visible.
     *
     * @param reference the named location to scroll to
     */
    public void scrollToReference(String reference) {
<span class="nc" id="L830">        Document d = getDocument();</span>
<span class="nc bnc" id="L831" title="All 2 branches missed.">        if (d instanceof HTMLDocument) {</span>
<span class="nc" id="L832">            HTMLDocument doc = (HTMLDocument) d;</span>
<span class="nc" id="L833">            HTMLDocument.Iterator iter = doc.getIterator(HTML.Tag.A);</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">            for (; iter.isValid(); iter.next()) {</span>
<span class="nc" id="L835">                AttributeSet a = iter.getAttributes();</span>
<span class="nc" id="L836">                String nm = (String) a.getAttribute(HTML.Attribute.NAME);</span>
<span class="nc bnc" id="L837" title="All 4 branches missed.">                if ((nm != null) &amp;&amp; nm.equals(reference)) {</span>
                    // found a matching reference in the document.
                    try {
<span class="nc" id="L840">                        int pos = iter.getStartOffset();</span>
<span class="nc" id="L841">                        Rectangle r = modelToView(pos);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">                        if (r != null) {</span>
                            // the view is visible, scroll it to the
                            // center of the current visible area.
<span class="nc" id="L845">                            Rectangle vis = getVisibleRect();</span>
                            //r.y -= (vis.height / 2);
<span class="nc" id="L847">                            r.height = vis.height;</span>
<span class="nc" id="L848">                            scrollRectToVisible(r);</span>
<span class="nc" id="L849">                            setCaretPosition(pos);</span>
                        }
<span class="nc" id="L851">                    } catch (BadLocationException ble) {</span>
<span class="nc" id="L852">                        UIManager.getLookAndFeel().provideErrorFeedback(JEditorPane.this);</span>
<span class="nc" id="L853">                    }</span>
                }
            }
        }
<span class="nc" id="L857">    }</span>

    /**
     * Gets the current URL being displayed.  If a URL was
     * not specified in the creation of the document, this
     * will return &lt;code&gt;null&lt;/code&gt;, and relative URL's will not be
     * resolved.
     *
     * @return the URL, or &lt;code&gt;null&lt;/code&gt; if none
     */
    public URL getPage() {
<span class="nc" id="L868">        return (URL) getDocument().getProperty(Document.StreamDescriptionProperty);</span>
    }

    /**
     * Sets the current URL being displayed.
     *
     * @param url the URL for display
     * @exception IOException for a &lt;code&gt;null&lt;/code&gt; or invalid URL
     *          specification
     */
    public void setPage(String url) throws IOException {
<span class="nc bnc" id="L879" title="All 2 branches missed.">        if (url == null) {</span>
<span class="nc" id="L880">            throw new IOException(&quot;invalid url&quot;);</span>
        }
<span class="nc" id="L882">        URL page = new URL(url);</span>
<span class="nc" id="L883">        setPage(page);</span>
<span class="nc" id="L884">    }</span>

    /**
     * Gets the class ID for the UI.
     *
     * @return the string &quot;EditorPaneUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L894">        return uiClassID;</span>
    }

    /**
     * Creates the default editor kit (&lt;code&gt;PlainEditorKit&lt;/code&gt;) for when
     * the component is first created.
     *
     * @return the editor kit
     */
    protected EditorKit createDefaultEditorKit() {
<span class="nc" id="L904">        return new PlainEditorKit();</span>
    }

    /**
     * Fetches the currently installed kit for handling content.
     * &lt;code&gt;createDefaultEditorKit&lt;/code&gt; is called to set up a default
     * if necessary.
     *
     * @return the editor kit
     */
    public EditorKit getEditorKit() {
<span class="nc bnc" id="L915" title="All 2 branches missed.">        if (kit == null) {</span>
<span class="nc" id="L916">            kit = createDefaultEditorKit();</span>
<span class="nc" id="L917">            isUserSetEditorKit = false;</span>
        }
<span class="nc" id="L919">        return kit;</span>
    }

    /**
     * Gets the type of content that this editor
     * is currently set to deal with.  This is
     * defined to be the type associated with the
     * currently installed &lt;code&gt;EditorKit&lt;/code&gt;.
     *
     * @return the content type, &lt;code&gt;null&lt;/code&gt; if no editor kit set
     */
    public final String getContentType() {
<span class="nc bnc" id="L931" title="All 2 branches missed.">        return (kit != null) ? kit.getContentType() : null;</span>
    }

    /**
     * Sets the type of content that this editor
     * handles.  This calls &lt;code&gt;getEditorKitForContentType&lt;/code&gt;,
     * and then &lt;code&gt;setEditorKit&lt;/code&gt; if an editor kit can
     * be successfully located.  This is mostly convenience method
     * that can be used as an alternative to calling
     * &lt;code&gt;setEditorKit&lt;/code&gt; directly.
     * &lt;p&gt;
     * If there is a charset definition specified as a parameter
     * of the content type specification, it will be used when
     * loading input streams using the associated &lt;code&gt;EditorKit&lt;/code&gt;.
     * For example if the type is specified as
     * &lt;code&gt;text/html; charset=EUC-JP&lt;/code&gt; the content
     * will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered for
     * &lt;code&gt;text/html&lt;/code&gt; and the Reader provided to
     * the &lt;code&gt;EditorKit&lt;/code&gt; to load unicode into the document will
     * use the &lt;code&gt;EUC-JP&lt;/code&gt; charset for translating
     * to unicode.  If the type is not recognized, the content
     * will be loaded using the &lt;code&gt;EditorKit&lt;/code&gt; registered
     * for plain text, &lt;code&gt;text/plain&lt;/code&gt;.
     *
     * @param type the non-&lt;code&gt;null&lt;/code&gt; mime type for the content editing
     *   support
     * @see #getContentType
     * @beaninfo
     *  description: the type of content
     * @throws NullPointerException if the &lt;code&gt;type&lt;/code&gt; parameter
     *          is &lt;code&gt;null&lt;/code&gt;
     */
    public final void setContentType(String type) {
        // The type could have optional info is part of it,
        // for example some charset info.  We need to strip that
        // of and save it.
<span class="nc" id="L967">        int parm = type.indexOf(&quot;;&quot;);</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">        if (parm &gt; -1) {</span>
            // Save the paramList.
<span class="nc" id="L970">            String paramList = type.substring(parm);</span>
            // update the content type string.
<span class="nc" id="L972">            type = type.substring(0, parm).trim();</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">            if (type.toLowerCase().startsWith(&quot;text/&quot;)) {</span>
<span class="nc" id="L974">                setCharsetFromContentTypeParameters(paramList);</span>
            }
        }
<span class="nc bnc" id="L977" title="All 6 branches missed.">        if ((kit == null) || (! type.equals(kit.getContentType()))</span>
                || !isUserSetEditorKit) {
<span class="nc" id="L979">            EditorKit k = getEditorKitForContentType(type);</span>
<span class="nc bnc" id="L980" title="All 4 branches missed.">            if (k != null &amp;&amp; k != kit) {</span>
<span class="nc" id="L981">                setEditorKit(k);</span>
<span class="nc" id="L982">                isUserSetEditorKit = false;</span>
            }
        }

<span class="nc" id="L986">    }</span>

    /**
     * This method gets the charset information specified as part
     * of the content type in the http header information.
     */
    private void setCharsetFromContentTypeParameters(String paramlist) {
        String charset;
        try {
            // paramlist is handed to us with a leading ';', strip it.
<span class="nc" id="L996">            int semi = paramlist.indexOf(';');</span>
<span class="nc bnc" id="L997" title="All 4 branches missed.">            if (semi &gt; -1 &amp;&amp; semi &lt; paramlist.length()-1) {</span>
<span class="nc" id="L998">                paramlist = paramlist.substring(semi + 1);</span>
            }

<span class="nc bnc" id="L1001" title="All 2 branches missed.">            if (paramlist.length() &gt; 0) {</span>
                // parse the paramlist into attr-value pairs &amp; get the
                // charset pair's value
<span class="nc" id="L1004">                HeaderParser hdrParser = new HeaderParser(paramlist);</span>
<span class="nc" id="L1005">                charset = hdrParser.findValue(&quot;charset&quot;);</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">                if (charset != null) {</span>
<span class="nc" id="L1007">                    putClientProperty(&quot;charset&quot;, charset);</span>
                }
            }
        }
<span class="nc" id="L1011">        catch (IndexOutOfBoundsException e) {</span>
            // malformed parameter list, use charset we have
        }
<span class="nc" id="L1014">        catch (NullPointerException e) {</span>
            // malformed parameter list, use charset we have
        }
<span class="nc" id="L1017">        catch (Exception e) {</span>
            // malformed parameter list, use charset we have; but complain
<span class="nc" id="L1019">            System.err.println(&quot;JEditorPane.getCharsetFromContentTypeParameters failed on: &quot; + paramlist);</span>
<span class="nc" id="L1020">            e.printStackTrace();</span>
<span class="nc" id="L1021">        }</span>
<span class="nc" id="L1022">    }</span>


    /**
     * Sets the currently installed kit for handling
     * content.  This is the bound property that
     * establishes the content type of the editor.
     * Any old kit is first deinstalled, then if kit is
     * non-&lt;code&gt;null&lt;/code&gt;,
     * the new kit is installed, and a default document created for it.
     * A &lt;code&gt;PropertyChange&lt;/code&gt; event (&quot;editorKit&quot;) is always fired when
     * &lt;code&gt;setEditorKit&lt;/code&gt; is called.
     * &lt;p&gt;
     * &lt;em&gt;NOTE: This has the side effect of changing the model,
     * because the &lt;code&gt;EditorKit&lt;/code&gt; is the source of how a
     * particular type
     * of content is modeled.  This method will cause &lt;code&gt;setDocument&lt;/code&gt;
     * to be called on behalf of the caller to ensure integrity
     * of the internal state.&lt;/em&gt;
     *
     * @param kit the desired editor behavior
     * @see #getEditorKit
     * @beaninfo
     *  description: the currently installed kit for handling content
     *        bound: true
     *       expert: true
     */
    public void setEditorKit(EditorKit kit) {
<span class="nc" id="L1050">        EditorKit old = this.kit;</span>
<span class="nc" id="L1051">        isUserSetEditorKit = true;</span>
<span class="nc bnc" id="L1052" title="All 2 branches missed.">        if (old != null) {</span>
<span class="nc" id="L1053">            old.deinstall(this);</span>
        }
<span class="nc" id="L1055">        this.kit = kit;</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">        if (this.kit != null) {</span>
<span class="nc" id="L1057">            this.kit.install(this);</span>
<span class="nc" id="L1058">            setDocument(this.kit.createDefaultDocument());</span>
        }
<span class="nc" id="L1060">        firePropertyChange(&quot;editorKit&quot;, old, kit);</span>
<span class="nc" id="L1061">    }</span>

    /**
     * Fetches the editor kit to use for the given type
     * of content.  This is called when a type is requested
     * that doesn't match the currently installed type.
     * If the component doesn't have an &lt;code&gt;EditorKit&lt;/code&gt; registered
     * for the given type, it will try to create an
     * &lt;code&gt;EditorKit&lt;/code&gt; from the default &lt;code&gt;EditorKit&lt;/code&gt; registry.
     * If that fails, a &lt;code&gt;PlainEditorKit&lt;/code&gt; is used on the
     * assumption that all text documents can be represented
     * as plain text.
     * &lt;p&gt;
     * This method can be reimplemented to use some
     * other kind of type registry.  This can
     * be reimplemented to use the Java Activation
     * Framework, for example.
     *
     * @param type the non-&lt;code&gt;null&lt;/code&gt; content type
     * @return the editor kit
     */
    public EditorKit getEditorKitForContentType(String type) {
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        if (typeHandlers == null) {</span>
<span class="nc" id="L1084">            typeHandlers = new Hashtable&lt;String, EditorKit&gt;(3);</span>
        }
<span class="nc" id="L1086">        EditorKit k = typeHandlers.get(type);</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">        if (k == null) {</span>
<span class="nc" id="L1088">            k = createEditorKitForContentType(type);</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">            if (k != null) {</span>
<span class="nc" id="L1090">                setEditorKitForContentType(type, k);</span>
            }
        }
<span class="nc bnc" id="L1093" title="All 2 branches missed.">        if (k == null) {</span>
<span class="nc" id="L1094">            k = createDefaultEditorKit();</span>
        }
<span class="nc" id="L1096">        return k;</span>
    }

    /**
     * Directly sets the editor kit to use for the given type.  A
     * look-and-feel implementation might use this in conjunction
     * with &lt;code&gt;createEditorKitForContentType&lt;/code&gt; to install handlers for
     * content types with a look-and-feel bias.
     *
     * @param type the non-&lt;code&gt;null&lt;/code&gt; content type
     * @param k the editor kit to be set
     */
    public void setEditorKitForContentType(String type, EditorKit k) {
<span class="nc bnc" id="L1109" title="All 2 branches missed.">        if (typeHandlers == null) {</span>
<span class="nc" id="L1110">            typeHandlers = new Hashtable&lt;String, EditorKit&gt;(3);</span>
        }
<span class="nc" id="L1112">        typeHandlers.put(type, k);</span>
<span class="nc" id="L1113">    }</span>

    /**
     * Replaces the currently selected content with new content
     * represented by the given string.  If there is no selection
     * this amounts to an insert of the given text.  If there
     * is no replacement text (i.e. the content string is empty
     * or &lt;code&gt;null&lt;/code&gt;) this amounts to a removal of the
     * current selection.  The replacement text will have the
     * attributes currently defined for input.  If the component is not
     * editable, beep and return.
     *
     * @param content  the content to replace the selection with.  This
     *   value can be &lt;code&gt;null&lt;/code&gt;
     */
    @Override
    public void replaceSelection(String content) {
<span class="nc bnc" id="L1130" title="All 2 branches missed.">        if (! isEditable()) {</span>
<span class="nc" id="L1131">            UIManager.getLookAndFeel().provideErrorFeedback(JEditorPane.this);</span>
<span class="nc" id="L1132">            return;</span>
        }
<span class="nc" id="L1134">        EditorKit kit = getEditorKit();</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        if(kit instanceof StyledEditorKit) {</span>
            try {
<span class="nc" id="L1137">                Document doc = getDocument();</span>
<span class="nc" id="L1138">                Caret caret = getCaret();</span>
<span class="nc" id="L1139">                boolean composedTextSaved = saveComposedText(caret.getDot());</span>
<span class="nc" id="L1140">                int p0 = Math.min(caret.getDot(), caret.getMark());</span>
<span class="nc" id="L1141">                int p1 = Math.max(caret.getDot(), caret.getMark());</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">                if (doc instanceof AbstractDocument) {</span>
<span class="nc" id="L1143">                    ((AbstractDocument)doc).replace(p0, p1 - p0, content,</span>
<span class="nc" id="L1144">                              ((StyledEditorKit)kit).getInputAttributes());</span>
                }
                else {
<span class="nc bnc" id="L1147" title="All 2 branches missed.">                    if (p0 != p1) {</span>
<span class="nc" id="L1148">                        doc.remove(p0, p1 - p0);</span>
                    }
<span class="nc bnc" id="L1150" title="All 4 branches missed.">                    if (content != null &amp;&amp; content.length() &gt; 0) {</span>
<span class="nc" id="L1151">                        doc.insertString(p0, content, ((StyledEditorKit)kit).</span>
<span class="nc" id="L1152">                                         getInputAttributes());</span>
                    }
                }
<span class="nc bnc" id="L1155" title="All 2 branches missed.">                if (composedTextSaved) {</span>
<span class="nc" id="L1156">                    restoreComposedText();</span>
                }
<span class="nc" id="L1158">            } catch (BadLocationException e) {</span>
<span class="nc" id="L1159">                UIManager.getLookAndFeel().provideErrorFeedback(JEditorPane.this);</span>
<span class="nc" id="L1160">            }</span>
        }
        else {
<span class="nc" id="L1163">            super.replaceSelection(content);</span>
        }
<span class="nc" id="L1165">    }</span>

    /**
     * Creates a handler for the given type from the default registry
     * of editor kits.  The registry is created if necessary.  If the
     * registered class has not yet been loaded, an attempt
     * is made to dynamically load the prototype of the kit for the
     * given type.  If the type was registered with a &lt;code&gt;ClassLoader&lt;/code&gt;,
     * that &lt;code&gt;ClassLoader&lt;/code&gt; will be used to load the prototype.
     * If there was no registered &lt;code&gt;ClassLoader&lt;/code&gt;,
     * &lt;code&gt;Class.forName&lt;/code&gt; will be used to load the prototype.
     * &lt;p&gt;
     * Once a prototype &lt;code&gt;EditorKit&lt;/code&gt; instance is successfully
     * located, it is cloned and the clone is returned.
     *
     * @param type the content type
     * @return the editor kit, or &lt;code&gt;null&lt;/code&gt; if there is nothing
     *   registered for the given type
     */
    public static EditorKit createEditorKitForContentType(String type) {
<span class="nc" id="L1185">        Hashtable&lt;String, EditorKit&gt; kitRegistry = getKitRegisty();</span>
<span class="nc" id="L1186">        EditorKit k = kitRegistry.get(type);</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">        if (k == null) {</span>
            // try to dynamically load the support
<span class="nc" id="L1189">            String classname = getKitTypeRegistry().get(type);</span>
<span class="nc" id="L1190">            ClassLoader loader = getKitLoaderRegistry().get(type);</span>
            try {
                Class c;
<span class="nc bnc" id="L1193" title="All 2 branches missed.">                if (loader != null) {</span>
<span class="nc" id="L1194">                    c = loader.loadClass(classname);</span>
                } else {
                    // Will only happen if developer has invoked
                    // registerEditorKitForContentType(type, class, null).
<span class="nc" id="L1198">                    c = Class.forName(classname, true, Thread.currentThread().</span>
<span class="nc" id="L1199">                                      getContextClassLoader());</span>
                }
<span class="nc" id="L1201">                k = (EditorKit) c.newInstance();</span>
<span class="nc" id="L1202">                kitRegistry.put(type, k);</span>
<span class="nc" id="L1203">            } catch (Throwable e) {</span>
<span class="nc" id="L1204">                k = null;</span>
<span class="nc" id="L1205">            }</span>
        }

        // create a copy of the prototype or null if there
        // is no prototype.
<span class="nc bnc" id="L1210" title="All 2 branches missed.">        if (k != null) {</span>
<span class="nc" id="L1211">            return (EditorKit) k.clone();</span>
        }
<span class="nc" id="L1213">        return null;</span>
    }

    /**
     * Establishes the default bindings of &lt;code&gt;type&lt;/code&gt; to
     * &lt;code&gt;classname&lt;/code&gt;.
     * The class will be dynamically loaded later when actually
     * needed, and can be safely changed before attempted uses
     * to avoid loading unwanted classes.  The prototype
     * &lt;code&gt;EditorKit&lt;/code&gt; will be loaded with &lt;code&gt;Class.forName&lt;/code&gt;
     * when registered with this method.
     *
     * @param type the non-&lt;code&gt;null&lt;/code&gt; content type
     * @param classname the class to load later
     */
    public static void registerEditorKitForContentType(String type, String classname) {
<span class="nc" id="L1229">        registerEditorKitForContentType(type, classname,Thread.currentThread().</span>
<span class="nc" id="L1230">                                        getContextClassLoader());</span>
<span class="nc" id="L1231">    }</span>

    /**
     * Establishes the default bindings of &lt;code&gt;type&lt;/code&gt; to
     * &lt;code&gt;classname&lt;/code&gt;.
     * The class will be dynamically loaded later when actually
     * needed using the given &lt;code&gt;ClassLoader&lt;/code&gt;,
     * and can be safely changed
     * before attempted uses to avoid loading unwanted classes.
     *
     * @param type the non-&lt;code&gt;null&lt;/code&gt; content type
     * @param classname the class to load later
     * @param loader the &lt;code&gt;ClassLoader&lt;/code&gt; to use to load the name
     */
    public static void registerEditorKitForContentType(String type, String classname, ClassLoader loader) {
<span class="nc" id="L1246">        getKitTypeRegistry().put(type, classname);</span>
<span class="nc" id="L1247">        getKitLoaderRegistry().put(type, loader);</span>
<span class="nc" id="L1248">        getKitRegisty().remove(type);</span>
<span class="nc" id="L1249">    }</span>

    /**
     * Returns the currently registered &lt;code&gt;EditorKit&lt;/code&gt;
     * class name for the type &lt;code&gt;type&lt;/code&gt;.
     *
     * @param type  the non-&lt;code&gt;null&lt;/code&gt; content type
     *
     * @since 1.3
     */
    public static String getEditorKitClassNameForContentType(String type) {
<span class="nc" id="L1260">        return getKitTypeRegistry().get(type);</span>
    }

    private static Hashtable&lt;String, String&gt; getKitTypeRegistry() {
<span class="nc" id="L1264">        loadDefaultKitsIfNecessary();</span>
<span class="nc" id="L1265">        return (Hashtable)SwingUtilities.appContextGet(kitTypeRegistryKey);</span>
    }

    private static Hashtable&lt;String, ClassLoader&gt; getKitLoaderRegistry() {
<span class="nc" id="L1269">        loadDefaultKitsIfNecessary();</span>
<span class="nc" id="L1270">        return (Hashtable)SwingUtilities.appContextGet(kitLoaderRegistryKey);</span>
    }

    private static Hashtable&lt;String, EditorKit&gt; getKitRegisty() {
<span class="nc" id="L1274">        Hashtable ht = (Hashtable)SwingUtilities.appContextGet(kitRegistryKey);</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        if (ht == null) {</span>
<span class="nc" id="L1276">            ht = new Hashtable(3);</span>
<span class="nc" id="L1277">            SwingUtilities.appContextPut(kitRegistryKey, ht);</span>
        }
<span class="nc" id="L1279">        return ht;</span>
    }

    /**
     * This is invoked every time the registries are accessed. Loading
     * is done this way instead of via a static as the static is only
     * called once when running in plugin resulting in the entries only
     * appearing in the first applet.
     */
    private static void loadDefaultKitsIfNecessary() {
<span class="nc bnc" id="L1289" title="All 2 branches missed.">        if (SwingUtilities.appContextGet(kitTypeRegistryKey) == null) {</span>
<span class="nc" id="L1290">            synchronized(defaultEditorKitMap) {</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">                if (defaultEditorKitMap.size() == 0) {</span>
<span class="nc" id="L1292">                    defaultEditorKitMap.put(&quot;text/plain&quot;,</span>
                                            &quot;javax.swing.JEditorPane$PlainEditorKit&quot;);
<span class="nc" id="L1294">                    defaultEditorKitMap.put(&quot;text/html&quot;,</span>
                                            &quot;javax.swing.text.html.HTMLEditorKit&quot;);
<span class="nc" id="L1296">                    defaultEditorKitMap.put(&quot;text/rtf&quot;,</span>
                                            &quot;javax.swing.text.rtf.RTFEditorKit&quot;);
<span class="nc" id="L1298">                    defaultEditorKitMap.put(&quot;application/rtf&quot;,</span>
                                            &quot;javax.swing.text.rtf.RTFEditorKit&quot;);
                }
<span class="nc" id="L1301">            }</span>
<span class="nc" id="L1302">            Hashtable ht = new Hashtable();</span>
<span class="nc" id="L1303">            SwingUtilities.appContextPut(kitTypeRegistryKey, ht);</span>
<span class="nc" id="L1304">            ht = new Hashtable();</span>
<span class="nc" id="L1305">            SwingUtilities.appContextPut(kitLoaderRegistryKey, ht);</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">            for (String key : defaultEditorKitMap.keySet()) {</span>
<span class="nc" id="L1307">                registerEditorKitForContentType(key,defaultEditorKitMap.get(key));</span>
<span class="nc" id="L1308">            }</span>

        }
<span class="nc" id="L1311">    }</span>

    // --- java.awt.Component methods --------------------------

    /**
     * Returns the preferred size for the &lt;code&gt;JEditorPane&lt;/code&gt;.
     * The preferred size for &lt;code&gt;JEditorPane&lt;/code&gt; is slightly altered
     * from the preferred size of the superclass.  If the size
     * of the viewport has become smaller than the minimum size
     * of the component, the scrollable definition for tracking
     * width or height will turn to false.  The default viewport
     * layout will give the preferred size, and that is not desired
     * in the case where the scrollable is tracking.  In that case
     * the &lt;em&gt;normal&lt;/em&gt; preferred size is adjusted to the
     * minimum size.  This allows things like HTML tables to
     * shrink down to their minimum size and then be laid out at
     * their minimum size, refusing to shrink any further.
     *
     * @return a &lt;code&gt;Dimension&lt;/code&gt; containing the preferred size
     */
    public Dimension getPreferredSize() {
<span class="nc" id="L1332">        Dimension d = super.getPreferredSize();</span>
<span class="nc" id="L1333">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc" id="L1335">            JViewport port = (JViewport) parent;</span>
<span class="nc" id="L1336">            TextUI ui = getUI();</span>
<span class="nc" id="L1337">            int prefWidth = d.width;</span>
<span class="nc" id="L1338">            int prefHeight = d.height;</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">            if (! getScrollableTracksViewportWidth()) {</span>
<span class="nc" id="L1340">                int w = port.getWidth();</span>
<span class="nc" id="L1341">                Dimension min = ui.getMinimumSize(this);</span>
<span class="nc bnc" id="L1342" title="All 4 branches missed.">                if (w != 0 &amp;&amp; w &lt; min.width) {</span>
                    // Only adjust to min if we have a valid size
<span class="nc" id="L1344">                    prefWidth = min.width;</span>
                }
            }
<span class="nc bnc" id="L1347" title="All 2 branches missed.">            if (! getScrollableTracksViewportHeight()) {</span>
<span class="nc" id="L1348">                int h = port.getHeight();</span>
<span class="nc" id="L1349">                Dimension min = ui.getMinimumSize(this);</span>
<span class="nc bnc" id="L1350" title="All 4 branches missed.">                if (h != 0 &amp;&amp; h &lt; min.height) {</span>
                    // Only adjust to min if we have a valid size
<span class="nc" id="L1352">                    prefHeight = min.height;</span>
                }
            }
<span class="nc bnc" id="L1355" title="All 4 branches missed.">            if (prefWidth != d.width || prefHeight != d.height) {</span>
<span class="nc" id="L1356">                d = new Dimension(prefWidth, prefHeight);</span>
            }
        }
<span class="nc" id="L1359">        return d;</span>
    }

    // --- JTextComponent methods -----------------------------

    /**
     * Sets the text of this &lt;code&gt;TextComponent&lt;/code&gt; to the specified
     * content,
     * which is expected to be in the format of the content type of
     * this editor.  For example, if the type is set to &lt;code&gt;text/html&lt;/code&gt;
     * the string should be specified in terms of HTML.
     * &lt;p&gt;
     * This is implemented to remove the contents of the current document,
     * and replace them by parsing the given string using the current
     * &lt;code&gt;EditorKit&lt;/code&gt;.  This gives the semantics of the
     * superclass by not changing
     * out the model, while supporting the content type currently set on
     * this component.  The assumption is that the previous content is
     * relatively
     * small, and that the previous content doesn't have side effects.
     * Both of those assumptions can be violated and cause undesirable results.
     * To avoid this, create a new document,
     * &lt;code&gt;getEditorKit().createDefaultDocument()&lt;/code&gt;, and replace the
     * existing &lt;code&gt;Document&lt;/code&gt; with the new one. You are then assured the
     * previous &lt;code&gt;Document&lt;/code&gt; won't have any lingering state.
     * &lt;ol&gt;
     * &lt;li&gt;
     * Leaving the existing model in place means that the old view will be
     * torn down, and a new view created, where replacing the document would
     * avoid the tear down of the old view.
     * &lt;li&gt;
     * Some formats (such as HTML) can install things into the document that
     * can influence future contents.  HTML can have style information embedded
     * that would influence the next content installed unexpectedly.
     * &lt;/ol&gt;
     * &lt;p&gt;
     * An alternative way to load this component with a string would be to
     * create a StringReader and call the read method.  In this case the model
     * would be replaced after it was initialized with the contents of the
     * string.
     *
     * @param t the new text to be set; if &lt;code&gt;null&lt;/code&gt; the old
     *    text will be deleted
     * @see #getText
     * @beaninfo
     * description: the text of this component
     */
    public void setText(String t) {
        try {
<span class="nc" id="L1408">            Document doc = getDocument();</span>
<span class="nc" id="L1409">            doc.remove(0, doc.getLength());</span>
<span class="nc bnc" id="L1410" title="All 4 branches missed.">            if (t == null || t.equals(&quot;&quot;)) {</span>
<span class="nc" id="L1411">                return;</span>
            }
<span class="nc" id="L1413">            Reader r = new StringReader(t);</span>
<span class="nc" id="L1414">            EditorKit kit = getEditorKit();</span>
<span class="nc" id="L1415">            kit.read(r, doc, 0);</span>
<span class="nc" id="L1416">        } catch (IOException ioe) {</span>
<span class="nc" id="L1417">            UIManager.getLookAndFeel().provideErrorFeedback(JEditorPane.this);</span>
<span class="nc" id="L1418">        } catch (BadLocationException ble) {</span>
<span class="nc" id="L1419">            UIManager.getLookAndFeel().provideErrorFeedback(JEditorPane.this);</span>
<span class="nc" id="L1420">        }</span>
<span class="nc" id="L1421">    }</span>

    /**
     * Returns the text contained in this &lt;code&gt;TextComponent&lt;/code&gt;
     * in terms of the
     * content type of this editor.  If an exception is thrown while
     * attempting to retrieve the text, &lt;code&gt;null&lt;/code&gt; will be returned.
     * This is implemented to call &lt;code&gt;JTextComponent.write&lt;/code&gt; with
     * a &lt;code&gt;StringWriter&lt;/code&gt;.
     *
     * @return the text
     * @see #setText
     */
    public String getText() {
        String txt;
        try {
<span class="nc" id="L1437">            StringWriter buf = new StringWriter();</span>
<span class="nc" id="L1438">            write(buf);</span>
<span class="nc" id="L1439">            txt = buf.toString();</span>
<span class="nc" id="L1440">        } catch (IOException ioe) {</span>
<span class="nc" id="L1441">            txt = null;</span>
<span class="nc" id="L1442">        }</span>
<span class="nc" id="L1443">        return txt;</span>
    }

    // --- Scrollable  ----------------------------------------

    /**
     * Returns true if a viewport should always force the width of this
     * &lt;code&gt;Scrollable&lt;/code&gt; to match the width of the viewport.
     *
     * @return true if a viewport should force the Scrollables width to
     * match its own, false otherwise
     */
    public boolean getScrollableTracksViewportWidth() {
<span class="nc" id="L1456">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc" id="L1458">            JViewport port = (JViewport) parent;</span>
<span class="nc" id="L1459">            TextUI ui = getUI();</span>
<span class="nc" id="L1460">            int w = port.getWidth();</span>
<span class="nc" id="L1461">            Dimension min = ui.getMinimumSize(this);</span>
<span class="nc" id="L1462">            Dimension max = ui.getMaximumSize(this);</span>
<span class="nc bnc" id="L1463" title="All 4 branches missed.">            if ((w &gt;= min.width) &amp;&amp; (w &lt;= max.width)) {</span>
<span class="nc" id="L1464">                return true;</span>
            }
        }
<span class="nc" id="L1467">        return false;</span>
    }

    /**
     * Returns true if a viewport should always force the height of this
     * &lt;code&gt;Scrollable&lt;/code&gt; to match the height of the viewport.
     *
     * @return true if a viewport should force the
     *          &lt;code&gt;Scrollable&lt;/code&gt;'s height to match its own,
     *          false otherwise
     */
    public boolean getScrollableTracksViewportHeight() {
<span class="nc" id="L1479">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L1480" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc" id="L1481">            JViewport port = (JViewport) parent;</span>
<span class="nc" id="L1482">            TextUI ui = getUI();</span>
<span class="nc" id="L1483">            int h = port.getHeight();</span>
<span class="nc" id="L1484">            Dimension min = ui.getMinimumSize(this);</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">            if (h &gt;= min.height) {</span>
<span class="nc" id="L1486">                Dimension max = ui.getMaximumSize(this);</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">                if (h &lt;= max.height) {</span>
<span class="nc" id="L1488">                    return true;</span>
                }
            }
        }
<span class="nc" id="L1492">        return false;</span>
    }

    // --- Serialization ------------------------------------

    /**
     * See &lt;code&gt;readObject&lt;/code&gt; and &lt;code&gt;writeObject&lt;/code&gt; in
     * &lt;code&gt;JComponent&lt;/code&gt; for more
     * information about serialization in Swing.
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L1503">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L1504" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L1505">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L1506">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L1507" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L1508">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L1511">    }</span>

    // --- variables ---------------------------------------

    private SwingWorker&lt;URL, Object&gt; pageLoader;

    /**
     * Current content binding of the editor.
     */
    private EditorKit kit;
    private boolean isUserSetEditorKit;

    private Hashtable&lt;String, Object&gt; pageProperties;

    /** Should be kept in sync with javax.swing.text.html.FormView counterpart. */
    final static String PostDataProperty = &quot;javax.swing.JEditorPane.postdata&quot;;

    /**
     * Table of registered type handlers for this editor.
     */
    private Hashtable&lt;String, EditorKit&gt; typeHandlers;

    /*
     * Private AppContext keys for this class's static variables.
     */
<span class="nc" id="L1536">    private static final Object kitRegistryKey =</span>
        new StringBuffer(&quot;JEditorPane.kitRegistry&quot;);
<span class="nc" id="L1538">    private static final Object kitTypeRegistryKey =</span>
        new StringBuffer(&quot;JEditorPane.kitTypeRegistry&quot;);
<span class="nc" id="L1540">    private static final Object kitLoaderRegistryKey =</span>
        new StringBuffer(&quot;JEditorPane.kitLoaderRegistry&quot;);

    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;EditorPaneUI&quot;;


    /**
     * Key for a client property used to indicate whether
     * &lt;a href=&quot;http://www.w3.org/TR/CSS21/syndata.html#length-units&quot;&gt;
     * w3c compliant&lt;/a&gt; length units are used for html rendering.
     * &lt;p&gt;
     * By default this is not enabled; to enable
     * it set the client {@link #putClientProperty property} with this name
     * to &lt;code&gt;Boolean.TRUE&lt;/code&gt;.
     *
     * @since 1.5
     */
    public static final String W3C_LENGTH_UNITS = &quot;JEditorPane.w3cLengthUnits&quot;;

    /**
     * Key for a client property used to indicate whether
     * the default font and foreground color from the component are
     * used if a font or foreground color is not specified in the styled
     * text.
     * &lt;p&gt;
     * The default varies based on the look and feel;
     * to enable it set the client {@link #putClientProperty property} with
     * this name to &lt;code&gt;Boolean.TRUE&lt;/code&gt;.
     *
     * @since 1.5
     */
    public static final String HONOR_DISPLAY_PROPERTIES = &quot;JEditorPane.honorDisplayProperties&quot;;

<span class="nc" id="L1577">    static final Map&lt;String, String&gt; defaultEditorKitMap = new HashMap&lt;String, String&gt;(0);</span>

    /**
     * Returns a string representation of this &lt;code&gt;JEditorPane&lt;/code&gt;.
     * This method
     * is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this &lt;code&gt;JEditorPane&lt;/code&gt;
     */
    protected String paramString() {
<span class="nc bnc" id="L1590" title="All 2 branches missed.">        String kitString = (kit != null ?</span>
<span class="nc" id="L1591">                            kit.toString() : &quot;&quot;);</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">        String typeHandlersString = (typeHandlers != null ?</span>
<span class="nc" id="L1593">                                     typeHandlers.toString() : &quot;&quot;);</span>

<span class="nc" id="L1595">        return super.paramString() +</span>
        &quot;,kit=&quot; + kitString +
        &quot;,typeHandlers=&quot; + typeHandlersString;
    }


/////////////////
// Accessibility support
////////////////


    /**
     * Gets the AccessibleContext associated with this JEditorPane.
     * For editor panes, the AccessibleContext takes the form of an
     * AccessibleJEditorPane.
     * A new AccessibleJEditorPane instance is created if necessary.
     *
     * @return an AccessibleJEditorPane that serves as the
     *         AccessibleContext of this JEditorPane
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L1616" title="All 2 branches missed.">        if (getEditorKit() instanceof HTMLEditorKit) {</span>
<span class="nc bnc" id="L1617" title="All 4 branches missed.">            if (accessibleContext == null || accessibleContext.getClass() !=</span>
                    AccessibleJEditorPaneHTML.class) {
<span class="nc" id="L1619">                accessibleContext = new AccessibleJEditorPaneHTML();</span>
            }
<span class="nc bnc" id="L1621" title="All 4 branches missed.">        } else if (accessibleContext == null || accessibleContext.getClass() !=</span>
                       AccessibleJEditorPane.class) {
<span class="nc" id="L1623">            accessibleContext = new AccessibleJEditorPane();</span>
        }
<span class="nc" id="L1625">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JEditorPane&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to editor pane user-interface
     * elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
<span class="nc" id="L1643">    protected class AccessibleJEditorPane extends AccessibleJTextComponent {</span>

        /**
         * Gets the accessibleDescription property of this object.  If this
         * property isn't set, returns the content type of this
         * &lt;code&gt;JEditorPane&lt;/code&gt; instead (e.g. &quot;plain/text&quot;, &quot;html/text&quot;).
         *
         * @return the localized description of the object; &lt;code&gt;null&lt;/code&gt;
         *      if this object does not have a description
         *
         * @see #setAccessibleName
         */
        public String getAccessibleDescription() {
<span class="nc" id="L1656">            String description = accessibleDescription;</span>

            // fallback to client property
<span class="nc bnc" id="L1659" title="All 2 branches missed.">            if (description == null) {</span>
<span class="nc" id="L1660">                description = (String)getClientProperty(AccessibleContext.ACCESSIBLE_DESCRIPTION_PROPERTY);</span>
            }
<span class="nc bnc" id="L1662" title="All 2 branches missed.">            if (description == null) {</span>
<span class="nc" id="L1663">                description = JEditorPane.this.getContentType();</span>
            }
<span class="nc" id="L1665">            return description;</span>
        }

        /**
         * Gets the state set of this object.
         *
         * @return an instance of AccessibleStateSet describing the states
         * of the object
         * @see AccessibleStateSet
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L1676">            AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc" id="L1677">            states.add(AccessibleState.MULTI_LINE);</span>
<span class="nc" id="L1678">            return states;</span>
        }
    }

    /**
     * This class provides support for &lt;code&gt;AccessibleHypertext&lt;/code&gt;,
     * and is used in instances where the &lt;code&gt;EditorKit&lt;/code&gt;
     * installed in this &lt;code&gt;JEditorPane&lt;/code&gt; is an instance of
     * &lt;code&gt;HTMLEditorKit&lt;/code&gt;.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    protected class AccessibleJEditorPaneHTML extends AccessibleJEditorPane {

        private AccessibleContext accessibleContext;

        public AccessibleText getAccessibleText() {
<span class="nc" id="L1702">            return new JEditorPaneAccessibleHypertextSupport();</span>
        }

<span class="nc" id="L1705">        protected AccessibleJEditorPaneHTML () {</span>
<span class="nc" id="L1706">            HTMLEditorKit kit = (HTMLEditorKit)JEditorPane.this.getEditorKit();</span>
<span class="nc" id="L1707">            accessibleContext = kit.getAccessibleContext();</span>
<span class="nc" id="L1708">        }</span>

        /**
         * Returns the number of accessible children of the object.
         *
         * @return the number of accessible children of the object.
         */
        public int getAccessibleChildrenCount() {
<span class="nc bnc" id="L1716" title="All 2 branches missed.">            if (accessibleContext != null) {</span>
<span class="nc" id="L1717">                return accessibleContext.getAccessibleChildrenCount();</span>
            } else {
<span class="nc" id="L1719">                return 0;</span>
            }
        }

        /**
         * Returns the specified Accessible child of the object.  The Accessible
         * children of an Accessible object are zero-based, so the first child
         * of an Accessible child is at index 0, the second child is at index 1,
         * and so on.
         *
         * @param i zero-based index of child
         * @return the Accessible child of the object
         * @see #getAccessibleChildrenCount
         */
        public Accessible getAccessibleChild(int i) {
<span class="nc bnc" id="L1734" title="All 2 branches missed.">            if (accessibleContext != null) {</span>
<span class="nc" id="L1735">                return accessibleContext.getAccessibleChild(i);</span>
            } else {
<span class="nc" id="L1737">                return null;</span>
            }
        }

        /**
         * Returns the Accessible child, if one exists, contained at the local
         * coordinate Point.
         *
         * @param p The point relative to the coordinate system of this object.
         * @return the Accessible, if it exists, at the specified location;
         * otherwise null
         */
        public Accessible getAccessibleAt(Point p) {
<span class="nc bnc" id="L1750" title="All 4 branches missed.">            if (accessibleContext != null &amp;&amp; p != null) {</span>
                try {
<span class="nc" id="L1752">                    AccessibleComponent acomp =</span>
<span class="nc" id="L1753">                        accessibleContext.getAccessibleComponent();</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">                    if (acomp != null) {</span>
<span class="nc" id="L1755">                        return acomp.getAccessibleAt(p);</span>
                    } else {
<span class="nc" id="L1757">                        return null;</span>
                    }
<span class="nc" id="L1759">                } catch (IllegalComponentStateException e) {</span>
<span class="nc" id="L1760">                    return null;</span>
                }
            } else {
<span class="nc" id="L1763">                return null;</span>
            }
        }
    }

    /**
     * What's returned by
     * &lt;code&gt;AccessibleJEditorPaneHTML.getAccessibleText&lt;/code&gt;.
     *
     * Provides support for &lt;code&gt;AccessibleHypertext&lt;/code&gt; in case
     * there is an HTML document being displayed in this
     * &lt;code&gt;JEditorPane&lt;/code&gt;.
     *
     */
    protected class JEditorPaneAccessibleHypertextSupport
    extends AccessibleJEditorPane implements AccessibleHypertext {

        public class HTMLLink extends AccessibleHyperlink {
            Element element;

<span class="nc" id="L1783">            public HTMLLink(Element e) {</span>
<span class="nc" id="L1784">                element = e;</span>
<span class="nc" id="L1785">            }</span>

            /**
             * Since the document a link is associated with may have
             * changed, this method returns whether this Link is valid
             * anymore (with respect to the document it references).
             *
             * @return a flag indicating whether this link is still valid with
             *         respect to the AccessibleHypertext it belongs to
             */
            public boolean isValid() {
<span class="nc" id="L1796">                return JEditorPaneAccessibleHypertextSupport.this.linksValid;</span>
            }

            /**
             * Returns the number of accessible actions available in this Link
             * If there are more than one, the first one is NOT considered the
             * &quot;default&quot; action of this LINK object (e.g. in an HTML imagemap).
             * In general, links will have only one AccessibleAction in them.
             *
             * @return the zero-based number of Actions in this object
             */
            public int getAccessibleActionCount() {
<span class="nc" id="L1808">                return 1;</span>
            }

            /**
             * Perform the specified Action on the object
             *
             * @param i zero-based index of actions
             * @return true if the the action was performed; else false.
             * @see #getAccessibleActionCount
             */
            public boolean doAccessibleAction(int i) {
<span class="nc bnc" id="L1819" title="All 4 branches missed.">                if (i == 0 &amp;&amp; isValid() == true) {</span>
<span class="nc" id="L1820">                    URL u = (URL) getAccessibleActionObject(i);</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">                    if (u != null) {</span>
<span class="nc" id="L1822">                        HyperlinkEvent linkEvent =</span>
                            new HyperlinkEvent(JEditorPane.this, HyperlinkEvent.EventType.ACTIVATED, u);
<span class="nc" id="L1824">                        JEditorPane.this.fireHyperlinkUpdate(linkEvent);</span>
<span class="nc" id="L1825">                        return true;</span>
                    }
                }
<span class="nc" id="L1828">                return false;  // link invalid or i != 0</span>
            }

            /**
             * Return a String description of this particular
             * link action.  The string returned is the text
             * within the document associated with the element
             * which contains this link.
             *
             * @param i zero-based index of the actions
             * @return a String description of the action
             * @see #getAccessibleActionCount
             */
            public String getAccessibleActionDescription(int i) {
<span class="nc bnc" id="L1842" title="All 4 branches missed.">                if (i == 0 &amp;&amp; isValid() == true) {</span>
<span class="nc" id="L1843">                    Document d = JEditorPane.this.getDocument();</span>
<span class="nc bnc" id="L1844" title="All 2 branches missed.">                    if (d != null) {</span>
                        try {
<span class="nc" id="L1846">                            return d.getText(getStartIndex(),</span>
<span class="nc" id="L1847">                                             getEndIndex() - getStartIndex());</span>
<span class="nc" id="L1848">                        } catch (BadLocationException exception) {</span>
<span class="nc" id="L1849">                            return null;</span>
                        }
                    }
                }
<span class="nc" id="L1853">                return null;</span>
            }

            /**
             * Returns a URL object that represents the link.
             *
             * @param i zero-based index of the actions
             * @return an URL representing the HTML link itself
             * @see #getAccessibleActionCount
             */
            public Object getAccessibleActionObject(int i) {
<span class="nc bnc" id="L1864" title="All 4 branches missed.">                if (i == 0 &amp;&amp; isValid() == true) {</span>
<span class="nc" id="L1865">                    AttributeSet as = element.getAttributes();</span>
<span class="nc" id="L1866">                    AttributeSet anchor =</span>
<span class="nc" id="L1867">                        (AttributeSet) as.getAttribute(HTML.Tag.A);</span>
<span class="nc bnc" id="L1868" title="All 2 branches missed.">                    String href = (anchor != null) ?</span>
<span class="nc" id="L1869">                        (String) anchor.getAttribute(HTML.Attribute.HREF) : null;</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">                    if (href != null) {</span>
                        URL u;
                        try {
<span class="nc" id="L1873">                            u = new URL(JEditorPane.this.getPage(), href);</span>
<span class="nc" id="L1874">                        } catch (MalformedURLException m) {</span>
<span class="nc" id="L1875">                            u = null;</span>
<span class="nc" id="L1876">                        }</span>
<span class="nc" id="L1877">                        return u;</span>
                    }
                }
<span class="nc" id="L1880">                return null;  // link invalid or i != 0</span>
            }

            /**
             * Return an object that represents the link anchor,
             * as appropriate for that link.  E.g. from HTML:
             *   &lt;a href=&quot;http://www.sun.com/access&quot;&gt;Accessibility&lt;/a&gt;
             * this method would return a String containing the text:
             * 'Accessibility'.
             *
             * Similarly, from this HTML:
             *   &amp;lt;a HREF=&quot;#top&quot;&amp;gt;&amp;lt;img src=&quot;top-hat.gif&quot; alt=&quot;top hat&quot;&amp;gt;&amp;lt;/a&amp;gt;
             * this might return the object ImageIcon(&quot;top-hat.gif&quot;, &quot;top hat&quot;);
             *
             * @param i zero-based index of the actions
             * @return an Object representing the hypertext anchor
             * @see #getAccessibleActionCount
             */
            public Object getAccessibleActionAnchor(int i) {
<span class="nc" id="L1899">                return getAccessibleActionDescription(i);</span>
            }


            /**
             * Get the index with the hypertext document at which this
             * link begins
             *
             * @return index of start of link
             */
            public int getStartIndex() {
<span class="nc" id="L1910">                return element.getStartOffset();</span>
            }

            /**
             * Get the index with the hypertext document at which this
             * link ends
             *
             * @return index of end of link
             */
            public int getEndIndex() {
<span class="nc" id="L1920">                return element.getEndOffset();</span>
            }
        }

<span class="nc" id="L1924">        private class LinkVector extends Vector&lt;HTMLLink&gt; {</span>
            public int baseElementIndex(Element e) {
                HTMLLink l;
<span class="nc bnc" id="L1927" title="All 2 branches missed.">                for (int i = 0; i &lt; elementCount; i++) {</span>
<span class="nc" id="L1928">                    l = elementAt(i);</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">                    if (l.element == e) {</span>
<span class="nc" id="L1930">                        return i;</span>
                    }
                }
<span class="nc" id="L1933">                return -1;</span>
            }
        }

        LinkVector hyperlinks;
<span class="nc" id="L1938">        boolean linksValid = false;</span>

        /**
         * Build the private table mapping links to locations in the text
         */
        private void buildLinkTable() {
<span class="nc" id="L1944">            hyperlinks.removeAllElements();</span>
<span class="nc" id="L1945">            Document d = JEditorPane.this.getDocument();</span>
<span class="nc bnc" id="L1946" title="All 2 branches missed.">            if (d != null) {</span>
<span class="nc" id="L1947">                ElementIterator ei = new ElementIterator(d);</span>
                Element e;
                AttributeSet as;
                AttributeSet anchor;
                String href;
<span class="nc bnc" id="L1952" title="All 2 branches missed.">                while ((e = ei.next()) != null) {</span>
<span class="nc bnc" id="L1953" title="All 2 branches missed.">                    if (e.isLeaf()) {</span>
<span class="nc" id="L1954">                        as = e.getAttributes();</span>
<span class="nc" id="L1955">                    anchor = (AttributeSet) as.getAttribute(HTML.Tag.A);</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">                    href = (anchor != null) ?</span>
<span class="nc" id="L1957">                        (String) anchor.getAttribute(HTML.Attribute.HREF) : null;</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">                        if (href != null) {</span>
<span class="nc" id="L1959">                            hyperlinks.addElement(new HTMLLink(e));</span>
                        }
                    }
                }
            }
<span class="nc" id="L1964">            linksValid = true;</span>
<span class="nc" id="L1965">        }</span>

        /**
         * Make one of these puppies
         */
<span class="nc" id="L1970">        public JEditorPaneAccessibleHypertextSupport() {</span>
<span class="nc" id="L1971">            hyperlinks = new LinkVector();</span>
<span class="nc" id="L1972">            Document d = JEditorPane.this.getDocument();</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">            if (d != null) {</span>
<span class="nc" id="L1974">                d.addDocumentListener(new DocumentListener() {</span>
                    public void changedUpdate(DocumentEvent theEvent) {
<span class="nc" id="L1976">                        linksValid = false;</span>
<span class="nc" id="L1977">                    }</span>
                    public void insertUpdate(DocumentEvent theEvent) {
<span class="nc" id="L1979">                        linksValid = false;</span>
<span class="nc" id="L1980">                    }</span>
                    public void removeUpdate(DocumentEvent theEvent) {
<span class="nc" id="L1982">                        linksValid = false;</span>
<span class="nc" id="L1983">                    }</span>
                });
            }
<span class="nc" id="L1986">        }</span>

        /**
         * Returns the number of links within this hypertext doc.
         *
         * @return number of links in this hypertext doc.
         */
        public int getLinkCount() {
<span class="nc bnc" id="L1994" title="All 2 branches missed.">            if (linksValid == false) {</span>
<span class="nc" id="L1995">                buildLinkTable();</span>
            }
<span class="nc" id="L1997">            return hyperlinks.size();</span>
        }

        /**
         * Returns the index into an array of hyperlinks that
         * is associated with this character index, or -1 if there
         * is no hyperlink associated with this index.
         *
         * @param  charIndex index within the text
         * @return index into the set of hyperlinks for this hypertext doc.
         */
        public int getLinkIndex(int charIndex) {
<span class="nc bnc" id="L2009" title="All 2 branches missed.">            if (linksValid == false) {</span>
<span class="nc" id="L2010">                buildLinkTable();</span>
            }
<span class="nc" id="L2012">            Element e = null;</span>
<span class="nc" id="L2013">            Document doc = JEditorPane.this.getDocument();</span>
<span class="nc bnc" id="L2014" title="All 2 branches missed.">            if (doc != null) {</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">                for (e = doc.getDefaultRootElement(); ! e.isLeaf(); ) {</span>
<span class="nc" id="L2016">                    int index = e.getElementIndex(charIndex);</span>
<span class="nc" id="L2017">                    e = e.getElement(index);</span>
<span class="nc" id="L2018">                }</span>
            }

            // don't need to verify that it's an HREF element; if
            // not, then it won't be in the hyperlinks Vector, and
            // so indexOf will return -1 in any case
<span class="nc" id="L2024">            return hyperlinks.baseElementIndex(e);</span>
        }

        /**
         * Returns the index into an array of hyperlinks that
         * index.  If there is no hyperlink at this index, it returns
         * null.
         *
         * @param linkIndex into the set of hyperlinks for this hypertext doc.
         * @return string representation of the hyperlink
         */
        public AccessibleHyperlink getLink(int linkIndex) {
<span class="nc bnc" id="L2036" title="All 2 branches missed.">            if (linksValid == false) {</span>
<span class="nc" id="L2037">                buildLinkTable();</span>
            }
<span class="nc bnc" id="L2039" title="All 4 branches missed.">            if (linkIndex &gt;= 0 &amp;&amp; linkIndex &lt; hyperlinks.size()) {</span>
<span class="nc" id="L2040">                return hyperlinks.elementAt(linkIndex);</span>
            } else {
<span class="nc" id="L2042">                return null;</span>
            }
        }

        /**
         * Returns the contiguous text within the document that
         * is associated with this hyperlink.
         *
         * @param linkIndex into the set of hyperlinks for this hypertext doc.
         * @return the contiguous text sharing the link at this index
         */
        public String getLinkText(int linkIndex) {
<span class="nc bnc" id="L2054" title="All 2 branches missed.">            if (linksValid == false) {</span>
<span class="nc" id="L2055">                buildLinkTable();</span>
            }
<span class="nc" id="L2057">            Element e = (Element) hyperlinks.elementAt(linkIndex);</span>
<span class="nc bnc" id="L2058" title="All 2 branches missed.">            if (e != null) {</span>
<span class="nc" id="L2059">                Document d = JEditorPane.this.getDocument();</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">                if (d != null) {</span>
                    try {
<span class="nc" id="L2062">                        return d.getText(e.getStartOffset(),</span>
<span class="nc" id="L2063">                                         e.getEndOffset() - e.getStartOffset());</span>
<span class="nc" id="L2064">                    } catch (BadLocationException exception) {</span>
<span class="nc" id="L2065">                        return null;</span>
                    }
                }
            }
<span class="nc" id="L2069">            return null;</span>
        }
    }

<span class="nc" id="L2073">    static class PlainEditorKit extends DefaultEditorKit implements ViewFactory {</span>

        /**
         * Fetches a factory that is suitable for producing
         * views of any models that are produced by this
         * kit.  The default is to have the UI produce the
         * factory, so this method has no implementation.
         *
         * @return the view factory
         */
        public ViewFactory getViewFactory() {
<span class="nc" id="L2084">            return this;</span>
        }

        /**
         * Creates a view from the given structural element of a
         * document.
         *
         * @param elem  the piece of the document to build a view of
         * @return the view
         * @see View
         */
        public View create(Element elem) {
<span class="nc" id="L2096">            Document doc = elem.getDocument();</span>
<span class="nc" id="L2097">            Object i18nFlag</span>
<span class="nc" id="L2098">                = doc.getProperty(&quot;i18n&quot;/*AbstractDocument.I18NProperty*/);</span>
<span class="nc bnc" id="L2099" title="All 4 branches missed.">            if ((i18nFlag != null) &amp;&amp; i18nFlag.equals(Boolean.TRUE)) {</span>
                // build a view that support bidi
<span class="nc" id="L2101">                return createI18N(elem);</span>
            } else {
<span class="nc" id="L2103">                return new WrappedPlainView(elem);</span>
            }
        }

        View createI18N(Element elem) {
<span class="nc" id="L2108">            String kind = elem.getName();</span>
<span class="nc bnc" id="L2109" title="All 2 branches missed.">            if (kind != null) {</span>
<span class="nc bnc" id="L2110" title="All 2 branches missed.">                if (kind.equals(AbstractDocument.ContentElementName)) {</span>
<span class="nc" id="L2111">                    return new PlainParagraph(elem);</span>
<span class="nc bnc" id="L2112" title="All 2 branches missed.">                } else if (kind.equals(AbstractDocument.ParagraphElementName)){</span>
<span class="nc" id="L2113">                    return new BoxView(elem, View.Y_AXIS);</span>
                }
            }
<span class="nc" id="L2116">            return null;</span>
        }

        /**
         * Paragraph for representing plain-text lines that support
         * bidirectional text.
         */
<span class="nc" id="L2123">        static class PlainParagraph extends javax.swing.text.ParagraphView {</span>

            PlainParagraph(Element elem) {
<span class="nc" id="L2126">                super(elem);</span>
<span class="nc" id="L2127">                layoutPool = new LogicalView(elem);</span>
<span class="nc" id="L2128">                layoutPool.setParent(this);</span>
<span class="nc" id="L2129">            }</span>

            protected void setPropertiesFromAttributes() {
<span class="nc" id="L2132">                Component c = getContainer();</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">                if ((c != null)</span>
<span class="nc bnc" id="L2134" title="All 2 branches missed.">                    &amp;&amp; (! c.getComponentOrientation().isLeftToRight()))</span>
                {
<span class="nc" id="L2136">                    setJustification(StyleConstants.ALIGN_RIGHT);</span>
                } else {
<span class="nc" id="L2138">                    setJustification(StyleConstants.ALIGN_LEFT);</span>
                }
<span class="nc" id="L2140">            }</span>

            /**
             * Fetch the constraining span to flow against for
             * the given child index.
             */
            public int getFlowSpan(int index) {
<span class="nc" id="L2147">                Component c = getContainer();</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">                if (c instanceof JTextArea) {</span>
<span class="nc" id="L2149">                    JTextArea area = (JTextArea) c;</span>
<span class="nc bnc" id="L2150" title="All 2 branches missed.">                    if (! area.getLineWrap()) {</span>
                        // no limit if unwrapped
<span class="nc" id="L2152">                        return Integer.MAX_VALUE;</span>
                    }
                }
<span class="nc" id="L2155">                return super.getFlowSpan(index);</span>
            }

            protected SizeRequirements calculateMinorAxisRequirements(int axis,
                                                            SizeRequirements r)
            {
<span class="nc" id="L2161">                SizeRequirements req</span>
<span class="nc" id="L2162">                    = super.calculateMinorAxisRequirements(axis, r);</span>
<span class="nc" id="L2163">                Component c = getContainer();</span>
<span class="nc bnc" id="L2164" title="All 2 branches missed.">                if (c instanceof JTextArea) {</span>
<span class="nc" id="L2165">                    JTextArea area = (JTextArea) c;</span>
<span class="nc bnc" id="L2166" title="All 2 branches missed.">                    if (! area.getLineWrap()) {</span>
                        // min is pref if unwrapped
<span class="nc" id="L2168">                        req.minimum = req.preferred;</span>
                    }
                }
<span class="nc" id="L2171">                return req;</span>
            }

            /**
             * This class can be used to represent a logical view for
             * a flow.  It keeps the children updated to reflect the state
             * of the model, gives the logical child views access to the
             * view hierarchy, and calculates a preferred span.  It doesn't
             * do any rendering, layout, or model/view translation.
             */
            static class LogicalView extends CompositeView {

                LogicalView(Element elem) {
<span class="nc" id="L2184">                    super(elem);</span>
<span class="nc" id="L2185">                }</span>

                protected int getViewIndexAtPosition(int pos) {
<span class="nc" id="L2188">                    Element elem = getElement();</span>
<span class="nc bnc" id="L2189" title="All 2 branches missed.">                    if (elem.getElementCount() &gt; 0) {</span>
<span class="nc" id="L2190">                        return elem.getElementIndex(pos);</span>
                    }
<span class="nc" id="L2192">                    return 0;</span>
                }

                protected boolean
                updateChildren(DocumentEvent.ElementChange ec,
                               DocumentEvent e, ViewFactory f)
                {
<span class="nc" id="L2199">                    return false;</span>
                }

                protected void loadChildren(ViewFactory f) {
<span class="nc" id="L2203">                    Element elem = getElement();</span>
<span class="nc bnc" id="L2204" title="All 2 branches missed.">                    if (elem.getElementCount() &gt; 0) {</span>
<span class="nc" id="L2205">                        super.loadChildren(f);</span>
                    } else {
<span class="nc" id="L2207">                        View v = new GlyphView(elem);</span>
<span class="nc" id="L2208">                        append(v);</span>
                    }
<span class="nc" id="L2210">                }</span>

                public float getPreferredSpan(int axis) {
<span class="nc bnc" id="L2213" title="All 2 branches missed.">                    if( getViewCount() != 1 )</span>
<span class="nc" id="L2214">                        throw new Error(&quot;One child view is assumed.&quot;);</span>

<span class="nc" id="L2216">                    View v = getView(0);</span>
                    //((GlyphView)v).setGlyphPainter(null);
<span class="nc" id="L2218">                    return v.getPreferredSpan(axis);</span>
                }

                /**
                 * Forward the DocumentEvent to the given child view.  This
                 * is implemented to reparent the child to the logical view
                 * (the children may have been parented by a row in the flow
                 * if they fit without breaking) and then execute the
                 * superclass behavior.
                 *
                 * @param v the child view to forward the event to.
                 * @param e the change information from the associated document
                 * @param a the current allocation of the view
                 * @param f the factory to use to rebuild if the view has
                 *          children
                 * @see #forwardUpdate
                 * @since 1.3
                 */
                protected void forwardUpdateToView(View v, DocumentEvent e,
                                                   Shape a, ViewFactory f) {
<span class="nc" id="L2238">                    v.setParent(this);</span>
<span class="nc" id="L2239">                    super.forwardUpdateToView(v, e, a, f);</span>
<span class="nc" id="L2240">                }</span>

                // The following methods don't do anything useful, they
                // simply keep the class from being abstract.

                public void paint(Graphics g, Shape allocation) {
<span class="nc" id="L2246">                }</span>

                protected boolean isBefore(int x, int y, Rectangle alloc) {
<span class="nc" id="L2249">                    return false;</span>
                }

                protected boolean isAfter(int x, int y, Rectangle alloc) {
<span class="nc" id="L2253">                    return false;</span>
                }

                protected View getViewAtPoint(int x, int y, Rectangle alloc) {
<span class="nc" id="L2257">                    return null;</span>
                }

                protected void childAllocation(int index, Rectangle a) {
<span class="nc" id="L2261">                }</span>
            }
        }
    }

/* This is useful for the nightmare of parsing multi-part HTTP/RFC822 headers
 * sensibly:
 * From a String like: 'timeout=15, max=5'
 * create an array of Strings:
 * { {&quot;timeout&quot;, &quot;15&quot;},
 *   {&quot;max&quot;, &quot;5&quot;}
 * }
 * From one like: 'Basic Realm=&quot;FuzzFace&quot; JDK=&quot;Biz Bar Baz&quot;'
 * create one like (no quotes in literal):
 * { {&quot;basic&quot;, null},
 *   {&quot;realm&quot;, &quot;FuzzFace&quot;}
 *   {&quot;foo&quot;, &quot;Biz Bar Baz&quot;}
 * }
 * keys are converted to lower case, vals are left as is....
 *
 * author Dave Brown
 */


static class HeaderParser {

    /* table of key/val pairs - maxes out at 10!!!!*/
    String raw;
    String[][] tab;

<span class="nc" id="L2291">    public HeaderParser(String raw) {</span>
<span class="nc" id="L2292">        this.raw = raw;</span>
<span class="nc" id="L2293">        tab = new String[10][2];</span>
<span class="nc" id="L2294">        parse();</span>
<span class="nc" id="L2295">    }</span>

    private void parse() {

<span class="nc bnc" id="L2299" title="All 2 branches missed.">        if (raw != null) {</span>
<span class="nc" id="L2300">            raw = raw.trim();</span>
<span class="nc" id="L2301">            char[] ca = raw.toCharArray();</span>
<span class="nc" id="L2302">            int beg = 0, end = 0, i = 0;</span>
<span class="nc" id="L2303">            boolean inKey = true;</span>
<span class="nc" id="L2304">            boolean inQuote = false;</span>
<span class="nc" id="L2305">            int len = ca.length;</span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">            while (end &lt; len) {</span>
<span class="nc" id="L2307">                char c = ca[end];</span>
<span class="nc bnc" id="L2308" title="All 2 branches missed.">                if (c == '=') { // end of a key</span>
<span class="nc" id="L2309">                    tab[i][0] = new String(ca, beg, end-beg).toLowerCase();</span>
<span class="nc" id="L2310">                    inKey = false;</span>
<span class="nc" id="L2311">                    end++;</span>
<span class="nc" id="L2312">                    beg = end;</span>
<span class="nc bnc" id="L2313" title="All 2 branches missed.">                } else if (c == '\&quot;') {</span>
<span class="nc bnc" id="L2314" title="All 2 branches missed.">                    if (inQuote) {</span>
<span class="nc" id="L2315">                        tab[i++][1]= new String(ca, beg, end-beg);</span>
<span class="nc" id="L2316">                        inQuote=false;</span>
                        do {
<span class="nc" id="L2318">                            end++;</span>
<span class="nc bnc" id="L2319" title="All 6 branches missed.">                        } while (end &lt; len &amp;&amp; (ca[end] == ' ' || ca[end] == ','));</span>
<span class="nc" id="L2320">                        inKey=true;</span>
<span class="nc" id="L2321">                        beg=end;</span>
                    } else {
<span class="nc" id="L2323">                        inQuote=true;</span>
<span class="nc" id="L2324">                        end++;</span>
<span class="nc" id="L2325">                        beg=end;</span>
                    }
<span class="nc bnc" id="L2327" title="All 4 branches missed.">                } else if (c == ' ' || c == ',') { // end key/val, of whatever we're in</span>
<span class="nc bnc" id="L2328" title="All 2 branches missed.">                    if (inQuote) {</span>
<span class="nc" id="L2329">                        end++;</span>
<span class="nc" id="L2330">                        continue;</span>
<span class="nc bnc" id="L2331" title="All 2 branches missed.">                    } else if (inKey) {</span>
<span class="nc" id="L2332">                        tab[i++][0] = (new String(ca, beg, end-beg)).toLowerCase();</span>
                    } else {
<span class="nc" id="L2334">                        tab[i++][1] = (new String(ca, beg, end-beg));</span>
                    }
<span class="nc bnc" id="L2336" title="All 6 branches missed.">                    while (end &lt; len &amp;&amp; (ca[end] == ' ' || ca[end] == ',')) {</span>
<span class="nc" id="L2337">                        end++;</span>
                    }
<span class="nc" id="L2339">                    inKey = true;</span>
<span class="nc" id="L2340">                    beg = end;</span>
                } else {
<span class="nc" id="L2342">                    end++;</span>
                }
<span class="nc" id="L2344">            }</span>
            // get last key/val, if any
<span class="nc bnc" id="L2346" title="All 2 branches missed.">            if (--end &gt; beg) {</span>
<span class="nc bnc" id="L2347" title="All 2 branches missed.">                if (!inKey) {</span>
<span class="nc bnc" id="L2348" title="All 2 branches missed.">                    if (ca[end] == '\&quot;') {</span>
<span class="nc" id="L2349">                        tab[i++][1] = (new String(ca, beg, end-beg));</span>
                    } else {
<span class="nc" id="L2351">                        tab[i++][1] = (new String(ca, beg, end-beg+1));</span>
                    }
                } else {
<span class="nc" id="L2354">                    tab[i][0] = (new String(ca, beg, end-beg+1)).toLowerCase();</span>
                }
<span class="nc bnc" id="L2356" title="All 2 branches missed.">            } else if (end == beg) {</span>
<span class="nc bnc" id="L2357" title="All 2 branches missed.">                if (!inKey) {</span>
<span class="nc bnc" id="L2358" title="All 2 branches missed.">                    if (ca[end] == '\&quot;') {</span>
<span class="nc" id="L2359">                        tab[i++][1] = String.valueOf(ca[end-1]);</span>
                    } else {
<span class="nc" id="L2361">                        tab[i++][1] = String.valueOf(ca[end]);</span>
                    }
                } else {
<span class="nc" id="L2364">                    tab[i][0] = String.valueOf(ca[end]).toLowerCase();</span>
                }
            }
        }

<span class="nc" id="L2369">    }</span>

    public String findKey(int i) {
<span class="nc bnc" id="L2372" title="All 4 branches missed.">        if (i &lt; 0 || i &gt; 10)</span>
<span class="nc" id="L2373">            return null;</span>
<span class="nc" id="L2374">        return tab[i][0];</span>
    }

    public String findValue(int i) {
<span class="nc bnc" id="L2378" title="All 4 branches missed.">        if (i &lt; 0 || i &gt; 10)</span>
<span class="nc" id="L2379">            return null;</span>
<span class="nc" id="L2380">        return tab[i][1];</span>
    }

    public String findValue(String key) {
<span class="nc" id="L2384">        return findValue(key, null);</span>
    }

    public String findValue(String k, String Default) {
<span class="nc bnc" id="L2388" title="All 2 branches missed.">        if (k == null)</span>
<span class="nc" id="L2389">            return Default;</span>
<span class="nc" id="L2390">        k = k.toLowerCase();</span>
<span class="nc bnc" id="L2391" title="All 2 branches missed.">        for (int i = 0; i &lt; 10; ++i) {</span>
<span class="nc bnc" id="L2392" title="All 2 branches missed.">            if (tab[i][0] == null) {</span>
<span class="nc" id="L2393">                return Default;</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">            } else if (k.equals(tab[i][0])) {</span>
<span class="nc" id="L2395">                return tab[i][1];</span>
            }
        }
<span class="nc" id="L2398">        return Default;</span>
    }

    public int findInt(String k, int Default) {
        try {
<span class="nc" id="L2403">            return Integer.parseInt(findValue(k, String.valueOf(Default)));</span>
<span class="nc" id="L2404">        } catch (Throwable t) {</span>
<span class="nc" id="L2405">            return Default;</span>
        }
    }
 }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>