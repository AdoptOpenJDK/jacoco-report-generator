<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>JList.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JDK</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JList.java</span></div><h1>JList.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing;

import java.awt.*;
import java.awt.event.*;

import java.util.Vector;
import java.util.Locale;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.beans.Transient;

import javax.swing.event.*;
import javax.accessibility.*;
import javax.swing.plaf.*;
import javax.swing.text.Position;

import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import java.io.Serializable;

import sun.swing.SwingUtilities2;
import sun.swing.SwingUtilities2.Section;
import static sun.swing.SwingUtilities2.Section.*;


/**
 * A component that displays a list of objects and allows the user to select
 * one or more items. A separate model, {@code ListModel}, maintains the
 * contents of the list.
 * &lt;p&gt;
 * It's easy to display an array or Vector of objects, using the {@code JList}
 * constructor that automatically builds a read-only {@code ListModel} instance
 * for you:
 * &lt;pre&gt;
 * {@code
 * // Create a JList that displays strings from an array
 *
 * String[] data = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;};
 * JList&lt;String&gt; myList = new JList&lt;String&gt;(data);
 *
 * // Create a JList that displays the superclasses of JList.class, by
 * // creating it with a Vector populated with this data
 *
 * Vector&lt;Class&lt;?&gt;&gt; superClasses = new Vector&lt;Class&lt;?&gt;&gt;();
 * Class&lt;JList&gt; rootClass = javax.swing.JList.class;
 * for(Class&lt;?&gt; cls = rootClass; cls != null; cls = cls.getSuperclass()) {
 *     superClasses.addElement(cls);
 * }
 * JList&lt;Class&lt;?&gt;&gt; myList = new JList&lt;Class&lt;?&gt;&gt;(superClasses);
 *
 * // The automatically created model is stored in JList's &quot;model&quot;
 * // property, which you can retrieve
 *
 * ListModel&lt;Class&lt;?&gt;&gt; model = myList.getModel();
 * for(int i = 0; i &lt; model.getSize(); i++) {
 *     System.out.println(model.getElementAt(i));
 * }
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * A {@code ListModel} can be supplied directly to a {@code JList} by way of a
 * constructor or the {@code setModel} method. The contents need not be static -
 * the number of items, and the values of items can change over time. A correct
 * {@code ListModel} implementation notifies the set of
 * {@code javax.swing.event.ListDataListener}s that have been added to it, each
 * time a change occurs. These changes are characterized by a
 * {@code javax.swing.event.ListDataEvent}, which identifies the range of list
 * indices that have been modified, added, or removed. {@code JList}'s
 * {@code ListUI} is responsible for keeping the visual representation up to
 * date with changes, by listening to the model.
 * &lt;p&gt;
 * Simple, dynamic-content, {@code JList} applications can use the
 * {@code DefaultListModel} class to maintain list elements. This class
 * implements the {@code ListModel} interface and also provides a
 * &lt;code&gt;java.util.Vector&lt;/code&gt;-like API. Applications that need a more
 * custom &lt;code&gt;ListModel&lt;/code&gt; implementation may instead wish to subclass
 * {@code AbstractListModel}, which provides basic support for managing and
 * notifying listeners. For example, a read-only implementation of
 * {@code AbstractListModel}:
 * &lt;pre&gt;
 * {@code
 * // This list model has about 2^16 elements.  Enjoy scrolling.
 *
 * ListModel&lt;String&gt; bigData = new AbstractListModel&lt;String&gt;() {
 *     public int getSize() { return Short.MAX_VALUE; }
 *     public String getElementAt(int index) { return &quot;Index &quot; + index; }
 * };
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * The selection state of a {@code JList} is managed by another separate
 * model, an instance of {@code ListSelectionModel}. {@code JList} is
 * initialized with a selection model on construction, and also contains
 * methods to query or set this selection model. Additionally, {@code JList}
 * provides convenient methods for easily managing the selection. These methods,
 * such as {@code setSelectedIndex} and {@code getSelectedValue}, are cover
 * methods that take care of the details of interacting with the selection
 * model. By default, {@code JList}'s selection model is configured to allow any
 * combination of items to be selected at a time; selection mode
 * {@code MULTIPLE_INTERVAL_SELECTION}. The selection mode can be changed
 * on the selection model directly, or via {@code JList}'s cover method.
 * Responsibility for updating the selection model in response to user gestures
 * lies with the list's {@code ListUI}.
 * &lt;p&gt;
 * A correct {@code ListSelectionModel} implementation notifies the set of
 * {@code javax.swing.event.ListSelectionListener}s that have been added to it
 * each time a change to the selection occurs. These changes are characterized
 * by a {@code javax.swing.event.ListSelectionEvent}, which identifies the range
 * of the selection change.
 * &lt;p&gt;
 * The preferred way to listen for changes in list selection is to add
 * {@code ListSelectionListener}s directly to the {@code JList}. {@code JList}
 * then takes care of listening to the the selection model and notifying your
 * listeners of change.
 * &lt;p&gt;
 * Responsibility for listening to selection changes in order to keep the list's
 * visual representation up to date lies with the list's {@code ListUI}.
 * &lt;p&gt;
 * &lt;a name=&quot;renderer&quot;&gt;&lt;/a&gt;
 * Painting of cells in a {@code JList} is handled by a delegate called a
 * cell renderer, installed on the list as the {@code cellRenderer} property.
 * The renderer provides a {@code java.awt.Component} that is used
 * like a &quot;rubber stamp&quot; to paint the cells. Each time a cell needs to be
 * painted, the list's {@code ListUI} asks the cell renderer for the component,
 * moves it into place, and has it paint the contents of the cell by way of its
 * {@code paint} method. A default cell renderer, which uses a {@code JLabel}
 * component to render, is installed by the lists's {@code ListUI}. You can
 * substitute your own renderer using code like this:
 * &lt;pre&gt;
 * {@code
 *  // Display an icon and a string for each object in the list.
 *
 * class MyCellRenderer extends JLabel implements ListCellRenderer&lt;Object&gt; {
 *     final static ImageIcon longIcon = new ImageIcon(&quot;long.gif&quot;);
 *     final static ImageIcon shortIcon = new ImageIcon(&quot;short.gif&quot;);
 *
 *     // This is the only method defined by ListCellRenderer.
 *     // We just reconfigure the JLabel each time we're called.
 *
 *     public Component getListCellRendererComponent(
 *       JList&lt;?&gt; list,           // the list
 *       Object value,            // value to display
 *       int index,               // cell index
 *       boolean isSelected,      // is the cell selected
 *       boolean cellHasFocus)    // does the cell have focus
 *     {
 *         String s = value.toString();
 *         setText(s);
 *         setIcon((s.length() &gt; 10) ? longIcon : shortIcon);
 *         if (isSelected) {
 *             setBackground(list.getSelectionBackground());
 *             setForeground(list.getSelectionForeground());
 *         } else {
 *             setBackground(list.getBackground());
 *             setForeground(list.getForeground());
 *         }
 *         setEnabled(list.isEnabled());
 *         setFont(list.getFont());
 *         setOpaque(true);
 *         return this;
 *     }
 * }
 *
 * myList.setCellRenderer(new MyCellRenderer());
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Another job for the cell renderer is in helping to determine sizing
 * information for the list. By default, the list's {@code ListUI} determines
 * the size of cells by asking the cell renderer for its preferred
 * size for each list item. This can be expensive for large lists of items.
 * To avoid these calculations, you can set a {@code fixedCellWidth} and
 * {@code fixedCellHeight} on the list, or have these values calculated
 * automatically based on a single prototype value:
 * &lt;a name=&quot;prototype_example&quot;&gt;&lt;/a&gt;
 * &lt;pre&gt;
 * {@code
 * JList&lt;String&gt; bigDataList = new JList&lt;String&gt;(bigData);
 *
 * // We don't want the JList implementation to compute the width
 * // or height of all of the list cells, so we give it a string
 * // that's as big as we'll need for any cell.  It uses this to
 * // compute values for the fixedCellWidth and fixedCellHeight
 * // properties.
 *
 * bigDataList.setPrototypeCellValue(&quot;Index 1234567890&quot;);
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * {@code JList} doesn't implement scrolling directly. To create a list that
 * scrolls, make it the viewport view of a {@code JScrollPane}. For example:
 * &lt;pre&gt;
 * JScrollPane scrollPane = new JScrollPane(myList);
 *
 * // Or in two steps:
 * JScrollPane scrollPane = new JScrollPane();
 * scrollPane.getViewport().setView(myList);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * {@code JList} doesn't provide any special handling of double or triple
 * (or N) mouse clicks, but it's easy to add a {@code MouseListener} if you
 * wish to take action on these events. Use the {@code locationToIndex}
 * method to determine what cell was clicked. For example:
 * &lt;pre&gt;
 * MouseListener mouseListener = new MouseAdapter() {
 *     public void mouseClicked(MouseEvent e) {
 *         if (e.getClickCount() == 2) {
 *             int index = list.locationToIndex(e.getPoint());
 *             System.out.println(&quot;Double clicked on Item &quot; + index);
 *          }
 *     }
 * };
 * list.addMouseListener(mouseListener);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 * &lt;p&gt;
 * See &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/uiswing/components/list.html&quot;&gt;How to Use Lists&lt;/a&gt;
 * in &lt;a href=&quot;http://docs.oracle.com/javase/tutorial/&quot;&gt;&lt;em&gt;The Java Tutorial&lt;/em&gt;&lt;/a&gt;
 * for further documentation.
 * &lt;p&gt;
 * @see ListModel
 * @see AbstractListModel
 * @see DefaultListModel
 * @see ListSelectionModel
 * @see DefaultListSelectionModel
 * @see ListCellRenderer
 * @see DefaultListCellRenderer
 *
 * @param &lt;E&gt; the type of the elements of this list
 *
 * @beaninfo
 *   attribute: isContainer false
 * description: A component which allows for the selection of one or more objects from a list.
 *
 * @author Hans Muller
 */
<span class="nc bnc" id="L280" title="All 2 branches missed.">public class JList&lt;E&gt; extends JComponent implements Scrollable, Accessible</span>
{
    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;ListUI&quot;;

    /**
     * Indicates a vertical layout of cells, in a single column;
     * the default layout.
     * @see #setLayoutOrientation
     * @since 1.4
     */
    public static final int VERTICAL = 0;

    /**
     * Indicates a &quot;newspaper style&quot; layout with cells flowing vertically
     * then horizontally.
     * @see #setLayoutOrientation
     * @since 1.4
     */
    public static final int VERTICAL_WRAP = 1;

    /**
     * Indicates a &quot;newspaper style&quot; layout with cells flowing horizontally
     * then vertically.
     * @see #setLayoutOrientation
     * @since 1.4
     */
    public static final int HORIZONTAL_WRAP = 2;

<span class="nc" id="L312">    private int fixedCellWidth = -1;</span>
<span class="nc" id="L313">    private int fixedCellHeight = -1;</span>
<span class="nc" id="L314">    private int horizontalScrollIncrement = -1;</span>
    private E prototypeCellValue;
<span class="nc" id="L316">    private int visibleRowCount = 8;</span>
    private Color selectionForeground;
    private Color selectionBackground;
    private boolean dragEnabled;

    private ListSelectionModel selectionModel;
    private ListModel&lt;E&gt; dataModel;
    private ListCellRenderer&lt;? super E&gt; cellRenderer;
    private ListSelectionListener selectionListener;

    /**
     * How to lay out the cells; defaults to &lt;code&gt;VERTICAL&lt;/code&gt;.
     */
    private int layoutOrientation;

    /**
     * The drop mode for this component.
     */
<span class="nc" id="L334">    private DropMode dropMode = DropMode.USE_SELECTION;</span>

    /**
     * The drop location.
     */
    private transient DropLocation dropLocation;

    /**
     * A subclass of &lt;code&gt;TransferHandler.DropLocation&lt;/code&gt; representing
     * a drop location for a &lt;code&gt;JList&lt;/code&gt;.
     *
     * @see #getDropLocation
     * @since 1.6
     */
    public static final class DropLocation extends TransferHandler.DropLocation {
        private final int index;
        private final boolean isInsert;

        private DropLocation(Point p, int index, boolean isInsert) {
<span class="nc" id="L353">            super(p);</span>
<span class="nc" id="L354">            this.index = index;</span>
<span class="nc" id="L355">            this.isInsert = isInsert;</span>
<span class="nc" id="L356">        }</span>

        /**
         * Returns the index where dropped data should be placed in the
         * list. Interpretation of the value depends on the drop mode set on
         * the associated component. If the drop mode is either
         * &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt; or &lt;code&gt;DropMode.ON&lt;/code&gt;,
         * the return value is an index of a row in the list. If the drop mode is
         * &lt;code&gt;DropMode.INSERT&lt;/code&gt;, the return value refers to the index
         * where the data should be inserted. If the drop mode is
         * &lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;, the value of
         * &lt;code&gt;isInsert()&lt;/code&gt; indicates whether the index is an index
         * of a row, or an insert index.
         * &lt;p&gt;
         * &lt;code&gt;-1&lt;/code&gt; indicates that the drop occurred over empty space,
         * and no index could be calculated.
         *
         * @return the drop index
         */
        public int getIndex() {
<span class="nc" id="L376">            return index;</span>
        }

        /**
         * Returns whether or not this location represents an insert
         * location.
         *
         * @return whether or not this is an insert location
         */
        public boolean isInsert() {
<span class="nc" id="L386">            return isInsert;</span>
        }

        /**
         * Returns a string representation of this drop location.
         * This method is intended to be used for debugging purposes,
         * and the content and format of the returned string may vary
         * between implementations.
         *
         * @return a string representation of this drop location
         */
        public String toString() {
<span class="nc" id="L398">            return getClass().getName()</span>
<span class="nc" id="L399">                   + &quot;[dropPoint=&quot; + getDropPoint() + &quot;,&quot;</span>
                   + &quot;index=&quot; + index + &quot;,&quot;
                   + &quot;insert=&quot; + isInsert + &quot;]&quot;;
        }
    }

    /**
     * Constructs a {@code JList} that displays elements from the specified,
     * {@code non-null}, model. All {@code JList} constructors delegate to
     * this one.
     * &lt;p&gt;
     * This constructor registers the list with the {@code ToolTipManager},
     * allowing for tooltips to be provided by the cell renderers.
     *
     * @param dataModel the model for the list
     * @exception IllegalArgumentException if the model is {@code null}
     */
    public JList(ListModel&lt;E&gt; dataModel)
<span class="nc" id="L417">    {</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        if (dataModel == null) {</span>
<span class="nc" id="L419">            throw new IllegalArgumentException(&quot;dataModel must be non null&quot;);</span>
        }

        // Register with the ToolTipManager so that tooltips from the
        // renderer show through.
<span class="nc" id="L424">        ToolTipManager toolTipManager = ToolTipManager.sharedInstance();</span>
<span class="nc" id="L425">        toolTipManager.registerComponent(this);</span>

<span class="nc" id="L427">        layoutOrientation = VERTICAL;</span>

<span class="nc" id="L429">        this.dataModel = dataModel;</span>
<span class="nc" id="L430">        selectionModel = createSelectionModel();</span>
<span class="nc" id="L431">        setAutoscrolls(true);</span>
<span class="nc" id="L432">        setOpaque(true);</span>
<span class="nc" id="L433">        updateUI();</span>
<span class="nc" id="L434">    }</span>


    /**
     * Constructs a &lt;code&gt;JList&lt;/code&gt; that displays the elements in
     * the specified array. This constructor creates a read-only model
     * for the given array, and then delegates to the constructor that
     * takes a {@code ListModel}.
     * &lt;p&gt;
     * Attempts to pass a {@code null} value to this method results in
     * undefined behavior and, most likely, exceptions. The created model
     * references the given array directly. Attempts to modify the array
     * after constructing the list results in undefined behavior.
     *
     * @param  listData  the array of Objects to be loaded into the data model,
     *                   {@code non-null}
     */
    public JList(final E[] listData)
    {
<span class="nc" id="L453">        this (</span>
<span class="nc" id="L454">            new AbstractListModel&lt;E&gt;() {</span>
<span class="nc" id="L455">                public int getSize() { return listData.length; }</span>
<span class="nc" id="L456">                public E getElementAt(int i) { return listData[i]; }</span>
            }
        );
<span class="nc" id="L459">    }</span>


    /**
     * Constructs a &lt;code&gt;JList&lt;/code&gt; that displays the elements in
     * the specified &lt;code&gt;Vector&lt;/code&gt;. This constructor creates a read-only
     * model for the given {@code Vector}, and then delegates to the constructor
     * that takes a {@code ListModel}.
     * &lt;p&gt;
     * Attempts to pass a {@code null} value to this method results in
     * undefined behavior and, most likely, exceptions. The created model
     * references the given {@code Vector} directly. Attempts to modify the
     * {@code Vector} after constructing the list results in undefined behavior.
     *
     * @param  listData  the &lt;code&gt;Vector&lt;/code&gt; to be loaded into the
     *                   data model, {@code non-null}
     */
    public JList(final Vector&lt;? extends E&gt; listData) {
<span class="nc" id="L477">        this (</span>
<span class="nc" id="L478">            new AbstractListModel&lt;E&gt;() {</span>
<span class="nc" id="L479">                public int getSize() { return listData.size(); }</span>
<span class="nc" id="L480">                public E getElementAt(int i) { return listData.elementAt(i); }</span>
            }
        );
<span class="nc" id="L483">    }</span>


    /**
     * Constructs a &lt;code&gt;JList&lt;/code&gt; with an empty, read-only, model.
     */
    public JList() {
<span class="nc" id="L490">        this (</span>
<span class="nc" id="L491">            new AbstractListModel&lt;E&gt;() {</span>
<span class="nc" id="L492">              public int getSize() { return 0; }</span>
<span class="nc" id="L493">              public E getElementAt(int i) { throw new IndexOutOfBoundsException(&quot;No Data Model&quot;); }</span>
            }
        );
<span class="nc" id="L496">    }</span>


    /**
     * Returns the {@code ListUI}, the look and feel object that
     * renders this component.
     *
     * @return the &lt;code&gt;ListUI&lt;/code&gt; object that renders this component
     */
    public ListUI getUI() {
<span class="nc" id="L506">        return (ListUI)ui;</span>
    }


    /**
     * Sets the {@code ListUI}, the look and feel object that
     * renders this component.
     *
     * @param ui  the &lt;code&gt;ListUI&lt;/code&gt; object
     * @see UIDefaults#getUI
     * @beaninfo
     *        bound: true
     *       hidden: true
     *    attribute: visualUpdate true
     *  description: The UI object that implements the Component's LookAndFeel.
     */
    public void setUI(ListUI ui) {
<span class="nc" id="L523">        super.setUI(ui);</span>
<span class="nc" id="L524">    }</span>


    /**
     * Resets the {@code ListUI} property by setting it to the value provided
     * by the current look and feel. If the current cell renderer was installed
     * by the developer (rather than the look and feel itself), this also causes
     * the cell renderer and its children to be updated, by calling
     * {@code SwingUtilities.updateComponentTreeUI} on it.
     *
     * @see UIManager#getUI
     * @see SwingUtilities#updateComponentTreeUI
     */
    public void updateUI() {
<span class="nc" id="L538">        setUI((ListUI)UIManager.getUI(this));</span>

<span class="nc" id="L540">        ListCellRenderer&lt;? super E&gt; renderer = getCellRenderer();</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">        if (renderer instanceof Component) {</span>
<span class="nc" id="L542">            SwingUtilities.updateComponentTreeUI((Component)renderer);</span>
        }
<span class="nc" id="L544">    }</span>


    /**
     * Returns {@code &quot;ListUI&quot;}, the &lt;code&gt;UIDefaults&lt;/code&gt; key used to look
     * up the name of the {@code javax.swing.plaf.ListUI} class that defines
     * the look and feel for this component.
     *
     * @return the string &quot;ListUI&quot;
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L557">        return uiClassID;</span>
    }


    /* -----private-----
     * This method is called by setPrototypeCellValue and setCellRenderer
     * to update the fixedCellWidth and fixedCellHeight properties from the
     * current value of prototypeCellValue (if it's non null).
     * &lt;p&gt;
     * This method sets fixedCellWidth and fixedCellHeight but does &lt;b&gt;not&lt;/b&gt;
     * generate PropertyChangeEvents for them.
     *
     * @see #setPrototypeCellValue
     * @see #setCellRenderer
     */
    private void updateFixedCellSize()
    {
<span class="nc" id="L574">        ListCellRenderer&lt;? super E&gt; cr = getCellRenderer();</span>
<span class="nc" id="L575">        E value = getPrototypeCellValue();</span>

<span class="nc bnc" id="L577" title="All 4 branches missed.">        if ((cr != null) &amp;&amp; (value != null)) {</span>
<span class="nc" id="L578">            Component c = cr.getListCellRendererComponent(this, value, 0, false, false);</span>

            /* The ListUI implementation will add Component c to its private
             * CellRendererPane however we can't assume that's already
             * been done here.  So we temporarily set the one &quot;inherited&quot;
             * property that may affect the renderer components preferred size:
             * its font.
             */
<span class="nc" id="L586">            Font f = c.getFont();</span>
<span class="nc" id="L587">            c.setFont(getFont());</span>

<span class="nc" id="L589">            Dimension d = c.getPreferredSize();</span>
<span class="nc" id="L590">            fixedCellWidth = d.width;</span>
<span class="nc" id="L591">            fixedCellHeight = d.height;</span>

<span class="nc" id="L593">            c.setFont(f);</span>
        }
<span class="nc" id="L595">    }</span>


    /**
     * Returns the &quot;prototypical&quot; cell value -- a value used to calculate a
     * fixed width and height for cells. This can be {@code null} if there
     * is no such value.
     *
     * @return the value of the {@code prototypeCellValue} property
     * @see #setPrototypeCellValue
     */
    public E getPrototypeCellValue() {
<span class="nc" id="L607">        return prototypeCellValue;</span>
    }

    /**
     * Sets the {@code prototypeCellValue} property, and then (if the new value
     * is {@code non-null}), computes the {@code fixedCellWidth} and
     * {@code fixedCellHeight} properties by requesting the cell renderer
     * component for the given value (and index 0) from the cell renderer, and
     * using that component's preferred size.
     * &lt;p&gt;
     * This method is useful when the list is too long to allow the
     * {@code ListUI} to compute the width/height of each cell, and there is a
     * single cell value that is known to occupy as much space as any of the
     * others, a so-called prototype.
     * &lt;p&gt;
     * While all three of the {@code prototypeCellValue},
     * {@code fixedCellHeight}, and {@code fixedCellWidth} properties may be
     * modified by this method, {@code PropertyChangeEvent} notifications are
     * only sent when the {@code prototypeCellValue} property changes.
     * &lt;p&gt;
     * To see an example which sets this property, see the
     * &lt;a href=&quot;#prototype_example&quot;&gt;class description&lt;/a&gt; above.
     * &lt;p&gt;
     * The default value of this property is &lt;code&gt;null&lt;/code&gt;.
     * &lt;p&gt;
     * This is a JavaBeans bound property.
     *
     * @param prototypeCellValue  the value on which to base
     *                          &lt;code&gt;fixedCellWidth&lt;/code&gt; and
     *                          &lt;code&gt;fixedCellHeight&lt;/code&gt;
     * @see #getPrototypeCellValue
     * @see #setFixedCellWidth
     * @see #setFixedCellHeight
     * @see JComponent#addPropertyChangeListener
     * @beaninfo
     *       bound: true
     *   attribute: visualUpdate true
     * description: The cell prototype value, used to compute cell width and height.
     */
    public void setPrototypeCellValue(E prototypeCellValue) {
<span class="nc" id="L647">        E oldValue = this.prototypeCellValue;</span>
<span class="nc" id="L648">        this.prototypeCellValue = prototypeCellValue;</span>

        /* If the prototypeCellValue has changed and is non-null,
         * then recompute fixedCellWidth and fixedCellHeight.
         */

<span class="nc bnc" id="L654" title="All 4 branches missed.">        if ((prototypeCellValue != null) &amp;&amp; !prototypeCellValue.equals(oldValue)) {</span>
<span class="nc" id="L655">            updateFixedCellSize();</span>
        }

<span class="nc" id="L658">        firePropertyChange(&quot;prototypeCellValue&quot;, oldValue, prototypeCellValue);</span>
<span class="nc" id="L659">    }</span>


    /**
     * Returns the value of the {@code fixedCellWidth} property.
     *
     * @return the fixed cell width
     * @see #setFixedCellWidth
     */
    public int getFixedCellWidth() {
<span class="nc" id="L669">        return fixedCellWidth;</span>
    }

    /**
     * Sets a fixed value to be used for the width of every cell in the list.
     * If {@code width} is -1, cell widths are computed in the {@code ListUI}
     * by applying &lt;code&gt;getPreferredSize&lt;/code&gt; to the cell renderer component
     * for each list element.
     * &lt;p&gt;
     * The default value of this property is {@code -1}.
     * &lt;p&gt;
     * This is a JavaBeans bound property.
     *
     * @param width the width to be used for all cells in the list
     * @see #setPrototypeCellValue
     * @see #setFixedCellWidth
     * @see JComponent#addPropertyChangeListener
     * @beaninfo
     *       bound: true
     *   attribute: visualUpdate true
     * description: Defines a fixed cell width when greater than zero.
     */
    public void setFixedCellWidth(int width) {
<span class="nc" id="L692">        int oldValue = fixedCellWidth;</span>
<span class="nc" id="L693">        fixedCellWidth = width;</span>
<span class="nc" id="L694">        firePropertyChange(&quot;fixedCellWidth&quot;, oldValue, fixedCellWidth);</span>
<span class="nc" id="L695">    }</span>


    /**
     * Returns the value of the {@code fixedCellHeight} property.
     *
     * @return the fixed cell height
     * @see #setFixedCellHeight
     */
    public int getFixedCellHeight() {
<span class="nc" id="L705">        return fixedCellHeight;</span>
    }

    /**
     * Sets a fixed value to be used for the height of every cell in the list.
     * If {@code height} is -1, cell heights are computed in the {@code ListUI}
     * by applying &lt;code&gt;getPreferredSize&lt;/code&gt; to the cell renderer component
     * for each list element.
     * &lt;p&gt;
     * The default value of this property is {@code -1}.
     * &lt;p&gt;
     * This is a JavaBeans bound property.
     *
     * @param height the height to be used for for all cells in the list
     * @see #setPrototypeCellValue
     * @see #setFixedCellWidth
     * @see JComponent#addPropertyChangeListener
     * @beaninfo
     *       bound: true
     *   attribute: visualUpdate true
     * description: Defines a fixed cell height when greater than zero.
     */
    public void setFixedCellHeight(int height) {
<span class="nc" id="L728">        int oldValue = fixedCellHeight;</span>
<span class="nc" id="L729">        fixedCellHeight = height;</span>
<span class="nc" id="L730">        firePropertyChange(&quot;fixedCellHeight&quot;, oldValue, fixedCellHeight);</span>
<span class="nc" id="L731">    }</span>


    /**
     * Returns the object responsible for painting list items.
     *
     * @return the value of the {@code cellRenderer} property
     * @see #setCellRenderer
     */
    @Transient
    public ListCellRenderer&lt;? super E&gt; getCellRenderer() {
<span class="nc" id="L742">        return cellRenderer;</span>
    }

    /**
     * Sets the delegate that is used to paint each cell in the list.
     * The job of a cell renderer is discussed in detail in the
     * &lt;a href=&quot;#renderer&quot;&gt;class level documentation&lt;/a&gt;.
     * &lt;p&gt;
     * If the {@code prototypeCellValue} property is {@code non-null},
     * setting the cell renderer also causes the {@code fixedCellWidth} and
     * {@code fixedCellHeight} properties to be re-calculated. Only one
     * &lt;code&gt;PropertyChangeEvent&lt;/code&gt; is generated however -
     * for the &lt;code&gt;cellRenderer&lt;/code&gt; property.
     * &lt;p&gt;
     * The default value of this property is provided by the {@code ListUI}
     * delegate, i.e. by the look and feel implementation.
     * &lt;p&gt;
     * This is a JavaBeans bound property.
     *
     * @param cellRenderer the &lt;code&gt;ListCellRenderer&lt;/code&gt;
     *                          that paints list cells
     * @see #getCellRenderer
     * @beaninfo
     *       bound: true
     *   attribute: visualUpdate true
     * description: The component used to draw the cells.
     */
    public void setCellRenderer(ListCellRenderer&lt;? super E&gt; cellRenderer) {
<span class="nc" id="L770">        ListCellRenderer&lt;? super E&gt; oldValue = this.cellRenderer;</span>
<span class="nc" id="L771">        this.cellRenderer = cellRenderer;</span>

        /* If the cellRenderer has changed and prototypeCellValue
         * was set, then recompute fixedCellWidth and fixedCellHeight.
         */
<span class="nc bnc" id="L776" title="All 4 branches missed.">        if ((cellRenderer != null) &amp;&amp; !cellRenderer.equals(oldValue)) {</span>
<span class="nc" id="L777">            updateFixedCellSize();</span>
        }

<span class="nc" id="L780">        firePropertyChange(&quot;cellRenderer&quot;, oldValue, cellRenderer);</span>
<span class="nc" id="L781">    }</span>


    /**
     * Returns the color used to draw the foreground of selected items.
     * {@code DefaultListCellRenderer} uses this color to draw the foreground
     * of items in the selected state, as do the renderers installed by most
     * {@code ListUI} implementations.
     *
     * @return the color to draw the foreground of selected items
     * @see #setSelectionForeground
     * @see DefaultListCellRenderer
     */
    public Color getSelectionForeground() {
<span class="nc" id="L795">        return selectionForeground;</span>
    }


    /**
     * Sets the color used to draw the foreground of selected items, which
     * cell renderers can use to render text and graphics.
     * {@code DefaultListCellRenderer} uses this color to draw the foreground
     * of items in the selected state, as do the renderers installed by most
     * {@code ListUI} implementations.
     * &lt;p&gt;
     * The default value of this property is defined by the look and feel
     * implementation.
     * &lt;p&gt;
     * This is a JavaBeans bound property.
     *
     * @param selectionForeground  the {@code Color} to use in the foreground
     *                             for selected list items
     * @see #getSelectionForeground
     * @see #setSelectionBackground
     * @see #setForeground
     * @see #setBackground
     * @see #setFont
     * @see DefaultListCellRenderer
     * @beaninfo
     *       bound: true
     *   attribute: visualUpdate true
     * description: The foreground color of selected cells.
     */
    public void setSelectionForeground(Color selectionForeground) {
<span class="nc" id="L825">        Color oldValue = this.selectionForeground;</span>
<span class="nc" id="L826">        this.selectionForeground = selectionForeground;</span>
<span class="nc" id="L827">        firePropertyChange(&quot;selectionForeground&quot;, oldValue, selectionForeground);</span>
<span class="nc" id="L828">    }</span>


    /**
     * Returns the color used to draw the background of selected items.
     * {@code DefaultListCellRenderer} uses this color to draw the background
     * of items in the selected state, as do the renderers installed by most
     * {@code ListUI} implementations.
     *
     * @return the color to draw the background of selected items
     * @see #setSelectionBackground
     * @see DefaultListCellRenderer
     */
    public Color getSelectionBackground() {
<span class="nc" id="L842">        return selectionBackground;</span>
    }


    /**
     * Sets the color used to draw the background of selected items, which
     * cell renderers can use fill selected cells.
     * {@code DefaultListCellRenderer} uses this color to fill the background
     * of items in the selected state, as do the renderers installed by most
     * {@code ListUI} implementations.
     * &lt;p&gt;
     * The default value of this property is defined by the look
     * and feel implementation.
     * &lt;p&gt;
     * This is a JavaBeans bound property.
     *
     * @param selectionBackground  the {@code Color} to use for the
     *                             background of selected cells
     * @see #getSelectionBackground
     * @see #setSelectionForeground
     * @see #setForeground
     * @see #setBackground
     * @see #setFont
     * @see DefaultListCellRenderer
     * @beaninfo
     *       bound: true
     *   attribute: visualUpdate true
     * description: The background color of selected cells.
     */
    public void setSelectionBackground(Color selectionBackground) {
<span class="nc" id="L872">        Color oldValue = this.selectionBackground;</span>
<span class="nc" id="L873">        this.selectionBackground = selectionBackground;</span>
<span class="nc" id="L874">        firePropertyChange(&quot;selectionBackground&quot;, oldValue, selectionBackground);</span>
<span class="nc" id="L875">    }</span>


    /**
     * Returns the value of the {@code visibleRowCount} property. See the
     * documentation for {@link #setVisibleRowCount} for details on how to
     * interpret this value.
     *
     * @return the value of the {@code visibleRowCount} property.
     * @see #setVisibleRowCount
     */
    public int getVisibleRowCount() {
<span class="nc" id="L887">        return visibleRowCount;</span>
    }

    /**
     * Sets the {@code visibleRowCount} property, which has different meanings
     * depending on the layout orientation: For a {@code VERTICAL} layout
     * orientation, this sets the preferred number of rows to display without
     * requiring scrolling; for other orientations, it affects the wrapping of
     * cells.
     * &lt;p&gt;
     * In {@code VERTICAL} orientation:&lt;br&gt;
     * Setting this property affects the return value of the
     * {@link #getPreferredScrollableViewportSize} method, which is used to
     * calculate the preferred size of an enclosing viewport. See that method's
     * documentation for more details.
     * &lt;p&gt;
     * In {@code HORIZONTAL_WRAP} and {@code VERTICAL_WRAP} orientations:&lt;br&gt;
     * This affects how cells are wrapped. See the documentation of
     * {@link #setLayoutOrientation} for more details.
     * &lt;p&gt;
     * The default value of this property is {@code 8}.
     * &lt;p&gt;
     * Calling this method with a negative value results in the property
     * being set to {@code 0}.
     * &lt;p&gt;
     * This is a JavaBeans bound property.
     *
     * @param visibleRowCount  an integer specifying the preferred number of
     *                         rows to display without requiring scrolling
     * @see #getVisibleRowCount
     * @see #getPreferredScrollableViewportSize
     * @see #setLayoutOrientation
     * @see JComponent#getVisibleRect
     * @see JViewport
     * @beaninfo
     *       bound: true
     *   attribute: visualUpdate true
     * description: The preferred number of rows to display without
     *              requiring scrolling
     */
    public void setVisibleRowCount(int visibleRowCount) {
<span class="nc" id="L928">        int oldValue = this.visibleRowCount;</span>
<span class="nc" id="L929">        this.visibleRowCount = Math.max(0, visibleRowCount);</span>
<span class="nc" id="L930">        firePropertyChange(&quot;visibleRowCount&quot;, oldValue, visibleRowCount);</span>
<span class="nc" id="L931">    }</span>


    /**
     * Returns the layout orientation property for the list: {@code VERTICAL}
     * if the layout is a single column of cells, {@code VERTICAL_WRAP} if the
     * layout is &quot;newspaper style&quot; with the content flowing vertically then
     * horizontally, or {@code HORIZONTAL_WRAP} if the layout is &quot;newspaper
     * style&quot; with the content flowing horizontally then vertically.
     *
     * @return the value of the {@code layoutOrientation} property
     * @see #setLayoutOrientation
     * @since 1.4
     */
    public int getLayoutOrientation() {
<span class="nc" id="L946">        return layoutOrientation;</span>
    }


    /**
     * Defines the way list cells are layed out. Consider a {@code JList}
     * with five cells. Cells can be layed out in one of the following ways:
     * &lt;p&gt;
     * &lt;pre&gt;
     * VERTICAL:          0
     *                    1
     *                    2
     *                    3
     *                    4
     *
     * HORIZONTAL_WRAP:   0  1  2
     *                    3  4
     *
     * VERTICAL_WRAP:     0  3
     *                    1  4
     *                    2
     * &lt;/pre&gt;
     * &lt;p&gt;
     * A description of these layouts follows:
     *
     * &lt;table border=&quot;1&quot;
     *  summary=&quot;Describes layouts VERTICAL, HORIZONTAL_WRAP, and VERTICAL_WRAP&quot;&gt;
     *   &lt;tr&gt;&lt;th&gt;&lt;p style=&quot;text-align:left&quot;&gt;Value&lt;/p&gt;&lt;/th&gt;&lt;th&gt;&lt;p style=&quot;text-align:left&quot;&gt;Description&lt;/p&gt;&lt;/th&gt;&lt;/tr&gt;
     *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;VERTICAL&lt;/code&gt;
     *       &lt;td&gt;Cells are layed out vertically in a single column.
     *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;HORIZONTAL_WRAP&lt;/code&gt;
     *       &lt;td&gt;Cells are layed out horizontally, wrapping to a new row as
     *           necessary. If the {@code visibleRowCount} property is less than
     *           or equal to zero, wrapping is determined by the width of the
     *           list; otherwise wrapping is done in such a way as to ensure
     *           {@code visibleRowCount} rows in the list.
     *   &lt;tr&gt;&lt;td&gt;&lt;code&gt;VERTICAL_WRAP&lt;/code&gt;
     *       &lt;td&gt;Cells are layed out vertically, wrapping to a new column as
     *           necessary. If the {@code visibleRowCount} property is less than
     *           or equal to zero, wrapping is determined by the height of the
     *           list; otherwise wrapping is done at {@code visibleRowCount} rows.
     *  &lt;/table&gt;
     * &lt;p&gt;
     * The default value of this property is &lt;code&gt;VERTICAL&lt;/code&gt;.
     *
     * @param layoutOrientation the new layout orientation, one of:
     *        {@code VERTICAL}, {@code HORIZONTAL_WRAP} or {@code VERTICAL_WRAP}
     * @see #getLayoutOrientation
     * @see #setVisibleRowCount
     * @see #getScrollableTracksViewportHeight
     * @see #getScrollableTracksViewportWidth
     * @throws IllegalArgumentException if {@code layoutOrientation} isn't one of the
     *         allowable values
     * @since 1.4
     * @beaninfo
     *       bound: true
     *   attribute: visualUpdate true
     * description: Defines the way list cells are layed out.
     *        enum: VERTICAL JList.VERTICAL
     *              HORIZONTAL_WRAP JList.HORIZONTAL_WRAP
     *              VERTICAL_WRAP JList.VERTICAL_WRAP
     */
    public void setLayoutOrientation(int layoutOrientation) {
<span class="nc" id="L1009">        int oldValue = this.layoutOrientation;</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">        switch (layoutOrientation) {</span>
        case VERTICAL:
        case VERTICAL_WRAP:
        case HORIZONTAL_WRAP:
<span class="nc" id="L1014">            this.layoutOrientation = layoutOrientation;</span>
<span class="nc" id="L1015">            firePropertyChange(&quot;layoutOrientation&quot;, oldValue, layoutOrientation);</span>
<span class="nc" id="L1016">            break;</span>
        default:
<span class="nc" id="L1018">            throw new IllegalArgumentException(&quot;layoutOrientation must be one of: VERTICAL, HORIZONTAL_WRAP or VERTICAL_WRAP&quot;);</span>
        }
<span class="nc" id="L1020">    }</span>


    /**
     * Returns the smallest list index that is currently visible.
     * In a left-to-right {@code componentOrientation}, the first visible
     * cell is found closest to the list's upper-left corner. In right-to-left
     * orientation, it is found closest to the upper-right corner.
     * If nothing is visible or the list is empty, {@code -1} is returned.
     * Note that the returned cell may only be partially visible.
     *
     * @return the index of the first visible cell
     * @see #getLastVisibleIndex
     * @see JComponent#getVisibleRect
     */
    public int getFirstVisibleIndex() {
<span class="nc" id="L1036">        Rectangle r = getVisibleRect();</span>
        int first;
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        if (this.getComponentOrientation().isLeftToRight()) {</span>
<span class="nc" id="L1039">            first = locationToIndex(r.getLocation());</span>
        } else {
<span class="nc" id="L1041">            first = locationToIndex(new Point((r.x + r.width) - 1, r.y));</span>
        }
<span class="nc bnc" id="L1043" title="All 2 branches missed.">        if (first != -1) {</span>
<span class="nc" id="L1044">            Rectangle bounds = getCellBounds(first, first);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">            if (bounds != null) {</span>
<span class="nc" id="L1046">                SwingUtilities.computeIntersection(r.x, r.y, r.width, r.height, bounds);</span>
<span class="nc bnc" id="L1047" title="All 4 branches missed.">                if (bounds.width == 0 || bounds.height == 0) {</span>
<span class="nc" id="L1048">                    first = -1;</span>
                }
            }
        }
<span class="nc" id="L1052">        return first;</span>
    }


    /**
     * Returns the largest list index that is currently visible.
     * If nothing is visible or the list is empty, {@code -1} is returned.
     * Note that the returned cell may only be partially visible.
     *
     * @return the index of the last visible cell
     * @see #getFirstVisibleIndex
     * @see JComponent#getVisibleRect
     */
    public int getLastVisibleIndex() {
<span class="nc" id="L1066">        boolean leftToRight = this.getComponentOrientation().isLeftToRight();</span>
<span class="nc" id="L1067">        Rectangle r = getVisibleRect();</span>
        Point lastPoint;
<span class="nc bnc" id="L1069" title="All 2 branches missed.">        if (leftToRight) {</span>
<span class="nc" id="L1070">            lastPoint = new Point((r.x + r.width) - 1, (r.y + r.height) - 1);</span>
        } else {
<span class="nc" id="L1072">            lastPoint = new Point(r.x, (r.y + r.height) - 1);</span>
        }
<span class="nc" id="L1074">        int location = locationToIndex(lastPoint);</span>

<span class="nc bnc" id="L1076" title="All 2 branches missed.">        if (location != -1) {</span>
<span class="nc" id="L1077">            Rectangle bounds = getCellBounds(location, location);</span>

<span class="nc bnc" id="L1079" title="All 2 branches missed.">            if (bounds != null) {</span>
<span class="nc" id="L1080">                SwingUtilities.computeIntersection(r.x, r.y, r.width, r.height, bounds);</span>
<span class="nc bnc" id="L1081" title="All 4 branches missed.">                if (bounds.width == 0 || bounds.height == 0) {</span>
                    // Try the top left(LTR) or top right(RTL) corner, and
                    // then go across checking each cell for HORIZONTAL_WRAP.
                    // Try the lower left corner, and then go across checking
                    // each cell for other list layout orientation.
<span class="nc" id="L1086">                    boolean isHorizontalWrap =</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">                        (getLayoutOrientation() == HORIZONTAL_WRAP);</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">                    Point visibleLocation = isHorizontalWrap ?</span>
                        new Point(lastPoint.x, r.y) :
                        new Point(r.x, lastPoint.y);
                    int last;
<span class="nc" id="L1092">                    int visIndex = -1;</span>
<span class="nc" id="L1093">                    int lIndex = location;</span>
<span class="nc" id="L1094">                    location = -1;</span>

                    do {
<span class="nc" id="L1097">                        last = visIndex;</span>
<span class="nc" id="L1098">                        visIndex = locationToIndex(visibleLocation);</span>

<span class="nc bnc" id="L1100" title="All 2 branches missed.">                        if (visIndex != -1) {</span>
<span class="nc" id="L1101">                            bounds = getCellBounds(visIndex, visIndex);</span>
<span class="nc bnc" id="L1102" title="All 4 branches missed.">                            if (visIndex != lIndex &amp;&amp; bounds != null &amp;&amp;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">                                bounds.contains(visibleLocation)) {</span>
<span class="nc" id="L1104">                                location = visIndex;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                                if (isHorizontalWrap) {</span>
<span class="nc" id="L1106">                                    visibleLocation.y = bounds.y + bounds.height;</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">                                    if (visibleLocation.y &gt;= lastPoint.y) {</span>
                                        // Past visible region, bail.
<span class="nc" id="L1109">                                        last = visIndex;</span>
                                    }
                                }
                                else {
<span class="nc" id="L1113">                                    visibleLocation.x = bounds.x + bounds.width;</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">                                    if (visibleLocation.x &gt;= lastPoint.x) {</span>
                                        // Past visible region, bail.
<span class="nc" id="L1116">                                        last = visIndex;</span>
                                    }
                                }

                            }
                            else {
<span class="nc" id="L1122">                                last = visIndex;</span>
                            }
                        }
<span class="nc bnc" id="L1125" title="All 4 branches missed.">                    } while (visIndex != -1 &amp;&amp; last != visIndex);</span>
                }
            }
        }
<span class="nc" id="L1129">        return location;</span>
    }


    /**
     * Scrolls the list within an enclosing viewport to make the specified
     * cell completely visible. This calls {@code scrollRectToVisible} with
     * the bounds of the specified cell. For this method to work, the
     * {@code JList} must be within a &lt;code&gt;JViewport&lt;/code&gt;.
     * &lt;p&gt;
     * If the given index is outside the list's range of cells, this method
     * results in nothing.
     *
     * @param index  the index of the cell to make visible
     * @see JComponent#scrollRectToVisible
     * @see #getVisibleRect
     */
    public void ensureIndexIsVisible(int index) {
<span class="nc" id="L1147">        Rectangle cellBounds = getCellBounds(index, index);</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">        if (cellBounds != null) {</span>
<span class="nc" id="L1149">            scrollRectToVisible(cellBounds);</span>
        }
<span class="nc" id="L1151">    }</span>

    /**
     * Turns on or off automatic drag handling. In order to enable automatic
     * drag handling, this property should be set to {@code true}, and the
     * list's {@code TransferHandler} needs to be {@code non-null}.
     * The default value of the {@code dragEnabled} property is {@code false}.
     * &lt;p&gt;
     * The job of honoring this property, and recognizing a user drag gesture,
     * lies with the look and feel implementation, and in particular, the list's
     * {@code ListUI}. When automatic drag handling is enabled, most look and
     * feels (including those that subclass {@code BasicLookAndFeel}) begin a
     * drag and drop operation whenever the user presses the mouse button over
     * an item and then moves the mouse a few pixels. Setting this property to
     * {@code true} can therefore have a subtle effect on how selections behave.
     * &lt;p&gt;
     * If a look and feel is used that ignores this property, you can still
     * begin a drag and drop operation by calling {@code exportAsDrag} on the
     * list's {@code TransferHandler}.
     *
     * @param b whether or not to enable automatic drag handling
     * @exception HeadlessException if
     *            &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and
     *            &lt;code&gt;GraphicsEnvironment.isHeadless()&lt;/code&gt;
     *            returns &lt;code&gt;true&lt;/code&gt;
     * @see java.awt.GraphicsEnvironment#isHeadless
     * @see #getDragEnabled
     * @see #setTransferHandler
     * @see TransferHandler
     * @since 1.4
     *
     * @beaninfo
     *  description: determines whether automatic drag handling is enabled
     *        bound: false
     */
    public void setDragEnabled(boolean b) {
<span class="nc bnc" id="L1187" title="All 4 branches missed.">        if (b &amp;&amp; GraphicsEnvironment.isHeadless()) {</span>
<span class="nc" id="L1188">            throw new HeadlessException();</span>
        }
<span class="nc" id="L1190">        dragEnabled = b;</span>
<span class="nc" id="L1191">    }</span>

    /**
     * Returns whether or not automatic drag handling is enabled.
     *
     * @return the value of the {@code dragEnabled} property
     * @see #setDragEnabled
     * @since 1.4
     */
    public boolean getDragEnabled() {
<span class="nc" id="L1201">        return dragEnabled;</span>
    }

    /**
     * Sets the drop mode for this component. For backward compatibility,
     * the default for this property is &lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;.
     * Usage of one of the other modes is recommended, however, for an
     * improved user experience. &lt;code&gt;DropMode.ON&lt;/code&gt;, for instance,
     * offers similar behavior of showing items as selected, but does so without
     * affecting the actual selection in the list.
     * &lt;p&gt;
     * &lt;code&gt;JList&lt;/code&gt; supports the following drop modes:
     * &lt;ul&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.USE_SELECTION&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.ON&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.INSERT&lt;/code&gt;&lt;/li&gt;
     *    &lt;li&gt;&lt;code&gt;DropMode.ON_OR_INSERT&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * The drop mode is only meaningful if this component has a
     * &lt;code&gt;TransferHandler&lt;/code&gt; that accepts drops.
     *
     * @param dropMode the drop mode to use
     * @throws IllegalArgumentException if the drop mode is unsupported
     *         or &lt;code&gt;null&lt;/code&gt;
     * @see #getDropMode
     * @see #getDropLocation
     * @see #setTransferHandler
     * @see TransferHandler
     * @since 1.6
     */
    public final void setDropMode(DropMode dropMode) {
<span class="nc bnc" id="L1232" title="All 2 branches missed.">        if (dropMode != null) {</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">            switch (dropMode) {</span>
                case USE_SELECTION:
                case ON:
                case INSERT:
                case ON_OR_INSERT:
<span class="nc" id="L1238">                    this.dropMode = dropMode;</span>
<span class="nc" id="L1239">                    return;</span>
            }
        }

<span class="nc" id="L1243">        throw new IllegalArgumentException(dropMode + &quot;: Unsupported drop mode for list&quot;);</span>
    }

    /**
     * Returns the drop mode for this component.
     *
     * @return the drop mode for this component
     * @see #setDropMode
     * @since 1.6
     */
    public final DropMode getDropMode() {
<span class="nc" id="L1254">        return dropMode;</span>
    }

    /**
     * Calculates a drop location in this component, representing where a
     * drop at the given point should insert data.
     *
     * @param p the point to calculate a drop location for
     * @return the drop location, or &lt;code&gt;null&lt;/code&gt;
     */
    DropLocation dropLocationForPoint(Point p) {
<span class="nc" id="L1265">        DropLocation location = null;</span>
<span class="nc" id="L1266">        Rectangle rect = null;</span>

<span class="nc" id="L1268">        int index = locationToIndex(p);</span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">        if (index != -1) {</span>
<span class="nc" id="L1270">            rect = getCellBounds(index, index);</span>
        }

<span class="nc bnc" id="L1273" title="All 4 branches missed.">        switch(dropMode) {</span>
            case USE_SELECTION:
            case ON:
<span class="nc bnc" id="L1276" title="All 2 branches missed.">                location = new DropLocation(p,</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">                    (rect != null &amp;&amp; rect.contains(p)) ? index : -1,</span>
                    false);

<span class="nc" id="L1280">                break;</span>
            case INSERT:
<span class="nc bnc" id="L1282" title="All 2 branches missed.">                if (index == -1) {</span>
<span class="nc" id="L1283">                    location = new DropLocation(p, getModel().getSize(), true);</span>
<span class="nc" id="L1284">                    break;</span>
                }

<span class="nc bnc" id="L1287" title="All 2 branches missed.">                if (layoutOrientation == HORIZONTAL_WRAP) {</span>
<span class="nc" id="L1288">                    boolean ltr = getComponentOrientation().isLeftToRight();</span>

<span class="nc bnc" id="L1290" title="All 2 branches missed.">                    if (SwingUtilities2.liesInHorizontal(rect, p, ltr, false) == TRAILING) {</span>
<span class="nc" id="L1291">                        index++;</span>
                    // special case for below all cells
<span class="nc bnc" id="L1293" title="All 4 branches missed.">                    } else if (index == getModel().getSize() - 1 &amp;&amp; p.y &gt;= rect.y + rect.height) {</span>
<span class="nc" id="L1294">                        index++;</span>
                    }
<span class="nc" id="L1296">                } else {</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                    if (SwingUtilities2.liesInVertical(rect, p, false) == TRAILING) {</span>
<span class="nc" id="L1298">                        index++;</span>
                    }
                }

<span class="nc" id="L1302">                location = new DropLocation(p, index, true);</span>

<span class="nc" id="L1304">                break;</span>
            case ON_OR_INSERT:
<span class="nc bnc" id="L1306" title="All 2 branches missed.">                if (index == -1) {</span>
<span class="nc" id="L1307">                    location = new DropLocation(p, getModel().getSize(), true);</span>
<span class="nc" id="L1308">                    break;</span>
                }

<span class="nc" id="L1311">                boolean between = false;</span>

<span class="nc bnc" id="L1313" title="All 2 branches missed.">                if (layoutOrientation == HORIZONTAL_WRAP) {</span>
<span class="nc" id="L1314">                    boolean ltr = getComponentOrientation().isLeftToRight();</span>

<span class="nc" id="L1316">                    Section section = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">                    if (section == TRAILING) {</span>
<span class="nc" id="L1318">                        index++;</span>
<span class="nc" id="L1319">                        between = true;</span>
                    // special case for below all cells
<span class="nc bnc" id="L1321" title="All 4 branches missed.">                    } else if (index == getModel().getSize() - 1 &amp;&amp; p.y &gt;= rect.y + rect.height) {</span>
<span class="nc" id="L1322">                        index++;</span>
<span class="nc" id="L1323">                        between = true;</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">                    } else if (section == LEADING) {</span>
<span class="nc" id="L1325">                        between = true;</span>
                    }
<span class="nc" id="L1327">                } else {</span>
<span class="nc" id="L1328">                    Section section = SwingUtilities2.liesInVertical(rect, p, true);</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">                    if (section == LEADING) {</span>
<span class="nc" id="L1330">                        between = true;</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">                    } else if (section == TRAILING) {</span>
<span class="nc" id="L1332">                        index++;</span>
<span class="nc" id="L1333">                        between = true;</span>
                    }
                }

<span class="nc" id="L1337">                location = new DropLocation(p, index, between);</span>

<span class="nc" id="L1339">                break;</span>
            default:
<span class="nc bnc" id="L1341" title="All 2 branches missed.">                assert false : &quot;Unexpected drop mode&quot;;</span>
        }

<span class="nc" id="L1344">        return location;</span>
    }

    /**
     * Called to set or clear the drop location during a DnD operation.
     * In some cases, the component may need to use it's internal selection
     * temporarily to indicate the drop location. To help facilitate this,
     * this method returns and accepts as a parameter a state object.
     * This state object can be used to store, and later restore, the selection
     * state. Whatever this method returns will be passed back to it in
     * future calls, as the state parameter. If it wants the DnD system to
     * continue storing the same state, it must pass it back every time.
     * Here's how this is used:
     * &lt;p&gt;
     * Let's say that on the first call to this method the component decides
     * to save some state (because it is about to use the selection to show
     * a drop index). It can return a state object to the caller encapsulating
     * any saved selection state. On a second call, let's say the drop location
     * is being changed to something else. The component doesn't need to
     * restore anything yet, so it simply passes back the same state object
     * to have the DnD system continue storing it. Finally, let's say this
     * method is messaged with &lt;code&gt;null&lt;/code&gt;. This means DnD
     * is finished with this component for now, meaning it should restore
     * state. At this point, it can use the state parameter to restore
     * said state, and of course return &lt;code&gt;null&lt;/code&gt; since there's
     * no longer anything to store.
     *
     * @param location the drop location (as calculated by
     *        &lt;code&gt;dropLocationForPoint&lt;/code&gt;) or &lt;code&gt;null&lt;/code&gt;
     *        if there's no longer a valid drop location
     * @param state the state object saved earlier for this component,
     *        or &lt;code&gt;null&lt;/code&gt;
     * @param forDrop whether or not the method is being called because an
     *        actual drop occurred
     * @return any saved state for this component, or &lt;code&gt;null&lt;/code&gt; if none
     */
    Object setDropLocation(TransferHandler.DropLocation location,
                           Object state,
                           boolean forDrop) {

<span class="nc" id="L1384">        Object retVal = null;</span>
<span class="nc" id="L1385">        DropLocation listLocation = (DropLocation)location;</span>

<span class="nc bnc" id="L1387" title="All 2 branches missed.">        if (dropMode == DropMode.USE_SELECTION) {</span>
<span class="nc bnc" id="L1388" title="All 2 branches missed.">            if (listLocation == null) {</span>
<span class="nc bnc" id="L1389" title="All 4 branches missed.">                if (!forDrop &amp;&amp; state != null) {</span>
<span class="nc" id="L1390">                    setSelectedIndices(((int[][])state)[0]);</span>

<span class="nc" id="L1392">                    int anchor = ((int[][])state)[1][0];</span>
<span class="nc" id="L1393">                    int lead = ((int[][])state)[1][1];</span>

<span class="nc" id="L1395">                    SwingUtilities2.setLeadAnchorWithoutSelection(</span>
<span class="nc" id="L1396">                            getSelectionModel(), lead, anchor);</span>
<span class="nc" id="L1397">                }</span>
            } else {
<span class="nc bnc" id="L1399" title="All 2 branches missed.">                if (dropLocation == null) {</span>
<span class="nc" id="L1400">                    int[] inds = getSelectedIndices();</span>
<span class="nc" id="L1401">                    retVal = new int[][] {inds, {getAnchorSelectionIndex(),</span>
<span class="nc" id="L1402">                                                 getLeadSelectionIndex()}};</span>
<span class="nc" id="L1403">                } else {</span>
<span class="nc" id="L1404">                    retVal = state;</span>
                }

<span class="nc" id="L1407">                int index = listLocation.getIndex();</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">                if (index == -1) {</span>
<span class="nc" id="L1409">                    clearSelection();</span>
<span class="nc" id="L1410">                    getSelectionModel().setAnchorSelectionIndex(-1);</span>
<span class="nc" id="L1411">                    getSelectionModel().setLeadSelectionIndex(-1);</span>
                } else {
<span class="nc" id="L1413">                    setSelectionInterval(index, index);</span>
                }
            }
        }

<span class="nc" id="L1418">        DropLocation old = dropLocation;</span>
<span class="nc" id="L1419">        dropLocation = listLocation;</span>
<span class="nc" id="L1420">        firePropertyChange(&quot;dropLocation&quot;, old, dropLocation);</span>

<span class="nc" id="L1422">        return retVal;</span>
    }

    /**
     * Returns the location that this component should visually indicate
     * as the drop location during a DnD operation over the component,
     * or {@code null} if no location is to currently be shown.
     * &lt;p&gt;
     * This method is not meant for querying the drop location
     * from a {@code TransferHandler}, as the drop location is only
     * set after the {@code TransferHandler}'s &lt;code&gt;canImport&lt;/code&gt;
     * has returned and has allowed for the location to be shown.
     * &lt;p&gt;
     * When this property changes, a property change event with
     * name &quot;dropLocation&quot; is fired by the component.
     * &lt;p&gt;
     * By default, responsibility for listening for changes to this property
     * and indicating the drop location visually lies with the list's
     * {@code ListUI}, which may paint it directly and/or install a cell
     * renderer to do so. Developers wishing to implement custom drop location
     * painting and/or replace the default cell renderer, may need to honor
     * this property.
     *
     * @return the drop location
     * @see #setDropMode
     * @see TransferHandler#canImport(TransferHandler.TransferSupport)
     * @since 1.6
     */
    public final DropLocation getDropLocation() {
<span class="nc" id="L1451">        return dropLocation;</span>
    }

    /**
     * Returns the next list element whose {@code toString} value
     * starts with the given prefix.
     *
     * @param prefix the string to test for a match
     * @param startIndex the index for starting the search
     * @param bias the search direction, either
     * Position.Bias.Forward or Position.Bias.Backward.
     * @return the index of the next list element that
     * starts with the prefix; otherwise {@code -1}
     * @exception IllegalArgumentException if prefix is {@code null}
     * or startIndex is out of bounds
     * @since 1.4
     */
    public int getNextMatch(String prefix, int startIndex, Position.Bias bias) {
<span class="nc" id="L1469">        ListModel&lt;E&gt; model = getModel();</span>
<span class="nc" id="L1470">        int max = model.getSize();</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">        if (prefix == null) {</span>
<span class="nc" id="L1472">            throw new IllegalArgumentException();</span>
        }
<span class="nc bnc" id="L1474" title="All 4 branches missed.">        if (startIndex &lt; 0 || startIndex &gt;= max) {</span>
<span class="nc" id="L1475">            throw new IllegalArgumentException();</span>
        }
<span class="nc" id="L1477">        prefix = prefix.toUpperCase();</span>

        // start search from the next element after the selected element
<span class="nc bnc" id="L1480" title="All 2 branches missed.">        int increment = (bias == Position.Bias.Forward) ? 1 : -1;</span>
<span class="nc" id="L1481">        int index = startIndex;</span>
        do {
<span class="nc" id="L1483">            E element = model.getElementAt(index);</span>

<span class="nc bnc" id="L1485" title="All 2 branches missed.">            if (element != null) {</span>
                String string;

<span class="nc bnc" id="L1488" title="All 2 branches missed.">                if (element instanceof String) {</span>
<span class="nc" id="L1489">                    string = ((String)element).toUpperCase();</span>
                }
                else {
<span class="nc" id="L1492">                    string = element.toString();</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">                    if (string != null) {</span>
<span class="nc" id="L1494">                        string = string.toUpperCase();</span>
                    }
                }

<span class="nc bnc" id="L1498" title="All 4 branches missed.">                if (string != null &amp;&amp; string.startsWith(prefix)) {</span>
<span class="nc" id="L1499">                    return index;</span>
                }
            }
<span class="nc" id="L1502">            index = (index + increment + max) % max;</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">        } while (index != startIndex);</span>
<span class="nc" id="L1504">        return -1;</span>
    }

    /**
     * Returns the tooltip text to be used for the given event. This overrides
     * {@code JComponent}'s {@code getToolTipText} to first check the cell
     * renderer component for the cell over which the event occurred, returning
     * its tooltip text, if any. This implementation allows you to specify
     * tooltip text on the cell level, by using {@code setToolTipText} on your
     * cell renderer component.
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; For &lt;code&gt;JList&lt;/code&gt; to properly display the
     * tooltips of its renderers in this manner, &lt;code&gt;JList&lt;/code&gt; must be a
     * registered component with the &lt;code&gt;ToolTipManager&lt;/code&gt;. This registration
     * is done automatically in the constructor. However, if at a later point
     * &lt;code&gt;JList&lt;/code&gt; is unregistered, by way of a call to
     * {@code setToolTipText(null)}, tips from the renderers will no longer display.
     *
     * @param event the {@code MouseEvent} to fetch the tooltip text for
     * @see JComponent#setToolTipText
     * @see JComponent#getToolTipText
     */
    public String getToolTipText(MouseEvent event) {
<span class="nc bnc" id="L1527" title="All 2 branches missed.">        if(event != null) {</span>
<span class="nc" id="L1528">            Point p = event.getPoint();</span>
<span class="nc" id="L1529">            int index = locationToIndex(p);</span>
<span class="nc" id="L1530">            ListCellRenderer&lt;? super E&gt; r = getCellRenderer();</span>
            Rectangle cellBounds;

<span class="nc bnc" id="L1533" title="All 4 branches missed.">            if (index != -1 &amp;&amp; r != null &amp;&amp; (cellBounds =</span>
<span class="nc bnc" id="L1534" title="All 2 branches missed.">                               getCellBounds(index, index)) != null &amp;&amp;</span>
<span class="nc bnc" id="L1535" title="All 2 branches missed.">                               cellBounds.contains(p.x, p.y)) {</span>
<span class="nc" id="L1536">                ListSelectionModel lsm = getSelectionModel();</span>
<span class="nc" id="L1537">                Component rComponent = r.getListCellRendererComponent(</span>
<span class="nc" id="L1538">                           this, getModel().getElementAt(index), index,</span>
<span class="nc" id="L1539">                           lsm.isSelectedIndex(index),</span>
<span class="nc bnc" id="L1540" title="All 4 branches missed.">                           (hasFocus() &amp;&amp; (lsm.getLeadSelectionIndex() ==</span>
                                           index)));

<span class="nc bnc" id="L1543" title="All 2 branches missed.">                if(rComponent instanceof JComponent) {</span>
                    MouseEvent      newEvent;

<span class="nc" id="L1546">                    p.translate(-cellBounds.x, -cellBounds.y);</span>
<span class="nc" id="L1547">                    newEvent = new MouseEvent(rComponent, event.getID(),</span>
<span class="nc" id="L1548">                                              event.getWhen(),</span>
<span class="nc" id="L1549">                                              event.getModifiers(),</span>
                                              p.x, p.y,
<span class="nc" id="L1551">                                              event.getXOnScreen(),</span>
<span class="nc" id="L1552">                                              event.getYOnScreen(),</span>
<span class="nc" id="L1553">                                              event.getClickCount(),</span>
<span class="nc" id="L1554">                                              event.isPopupTrigger(),</span>
                                              MouseEvent.NOBUTTON);

<span class="nc" id="L1557">                    String tip = ((JComponent)rComponent).getToolTipText(</span>
                                              newEvent);

<span class="nc bnc" id="L1560" title="All 2 branches missed.">                    if (tip != null) {</span>
<span class="nc" id="L1561">                        return tip;</span>
                    }
                }
            }
        }
<span class="nc" id="L1566">        return super.getToolTipText();</span>
    }

    /**
     * --- ListUI Delegations ---
     */


    /**
     * Returns the cell index closest to the given location in the list's
     * coordinate system. To determine if the cell actually contains the
     * specified location, compare the point against the cell's bounds,
     * as provided by {@code getCellBounds}. This method returns {@code -1}
     * if the model is empty
     * &lt;p&gt;
     * This is a cover method that delegates to the method of the same name
     * in the list's {@code ListUI}. It returns {@code -1} if the list has
     * no {@code ListUI}.
     *
     * @param location the coordinates of the point
     * @return the cell index closest to the given location, or {@code -1}
     */
    public int locationToIndex(Point location) {
<span class="nc" id="L1589">        ListUI ui = getUI();</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">        return (ui != null) ? ui.locationToIndex(this, location) : -1;</span>
    }


    /**
     * Returns the origin of the specified item in the list's coordinate
     * system. This method returns {@code null} if the index isn't valid.
     * &lt;p&gt;
     * This is a cover method that delegates to the method of the same name
     * in the list's {@code ListUI}. It returns {@code null} if the list has
     * no {@code ListUI}.
     *
     * @param index the cell index
     * @return the origin of the cell, or {@code null}
     */
    public Point indexToLocation(int index) {
<span class="nc" id="L1606">        ListUI ui = getUI();</span>
<span class="nc bnc" id="L1607" title="All 2 branches missed.">        return (ui != null) ? ui.indexToLocation(this, index) : null;</span>
    }


    /**
     * Returns the bounding rectangle, in the list's coordinate system,
     * for the range of cells specified by the two indices.
     * These indices can be supplied in any order.
     * &lt;p&gt;
     * If the smaller index is outside the list's range of cells, this method
     * returns {@code null}. If the smaller index is valid, but the larger
     * index is outside the list's range, the bounds of just the first index
     * is returned. Otherwise, the bounds of the valid range is returned.
     * &lt;p&gt;
     * This is a cover method that delegates to the method of the same name
     * in the list's {@code ListUI}. It returns {@code null} if the list has
     * no {@code ListUI}.
     *
     * @param index0 the first index in the range
     * @param index1 the second index in the range
     * @return the bounding rectangle for the range of cells, or {@code null}
     */
    public Rectangle getCellBounds(int index0, int index1) {
<span class="nc" id="L1630">        ListUI ui = getUI();</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">        return (ui != null) ? ui.getCellBounds(this, index0, index1) : null;</span>
    }


    /**
     * --- ListModel Support ---
     */


    /**
     * Returns the data model that holds the list of items displayed
     * by the &lt;code&gt;JList&lt;/code&gt; component.
     *
     * @return the &lt;code&gt;ListModel&lt;/code&gt; that provides the displayed
     *                          list of items
     * @see #setModel
     */
    public ListModel&lt;E&gt; getModel() {
<span class="nc" id="L1649">        return dataModel;</span>
    }

    /**
     * Sets the model that represents the contents or &quot;value&quot; of the
     * list, notifies property change listeners, and then clears the
     * list's selection.
     * &lt;p&gt;
     * This is a JavaBeans bound property.
     *
     * @param model  the &lt;code&gt;ListModel&lt;/code&gt; that provides the
     *                                          list of items for display
     * @exception IllegalArgumentException  if &lt;code&gt;model&lt;/code&gt; is
     *                                          &lt;code&gt;null&lt;/code&gt;
     * @see #getModel
     * @see #clearSelection
     * @beaninfo
     *       bound: true
     *   attribute: visualUpdate true
     * description: The object that contains the data to be drawn by this JList.
     */
    public void setModel(ListModel&lt;E&gt; model) {
<span class="nc bnc" id="L1671" title="All 2 branches missed.">        if (model == null) {</span>
<span class="nc" id="L1672">            throw new IllegalArgumentException(&quot;model must be non null&quot;);</span>
        }
<span class="nc" id="L1674">        ListModel&lt;E&gt; oldValue = dataModel;</span>
<span class="nc" id="L1675">        dataModel = model;</span>
<span class="nc" id="L1676">        firePropertyChange(&quot;model&quot;, oldValue, dataModel);</span>
<span class="nc" id="L1677">        clearSelection();</span>
<span class="nc" id="L1678">    }</span>


    /**
     * Constructs a read-only &lt;code&gt;ListModel&lt;/code&gt; from an array of items,
     * and calls {@code setModel} with this model.
     * &lt;p&gt;
     * Attempts to pass a {@code null} value to this method results in
     * undefined behavior and, most likely, exceptions. The created model
     * references the given array directly. Attempts to modify the array
     * after invoking this method results in undefined behavior.
     *
     * @param listData an array of {@code E} containing the items to
     *        display in the list
     * @see #setModel
     */
    public void setListData(final E[] listData) {
<span class="nc" id="L1695">        setModel (</span>
<span class="nc" id="L1696">            new AbstractListModel&lt;E&gt;() {</span>
<span class="nc" id="L1697">                public int getSize() { return listData.length; }</span>
<span class="nc" id="L1698">                public E getElementAt(int i) { return listData[i]; }</span>
            }
        );
<span class="nc" id="L1701">    }</span>


    /**
     * Constructs a read-only &lt;code&gt;ListModel&lt;/code&gt; from a &lt;code&gt;Vector&lt;/code&gt;
     * and calls {@code setModel} with this model.
     * &lt;p&gt;
     * Attempts to pass a {@code null} value to this method results in
     * undefined behavior and, most likely, exceptions. The created model
     * references the given {@code Vector} directly. Attempts to modify the
     * {@code Vector} after invoking this method results in undefined behavior.
     *
     * @param listData a &lt;code&gt;Vector&lt;/code&gt; containing the items to
     *                                          display in the list
     * @see #setModel
     */
    public void setListData(final Vector&lt;? extends E&gt; listData) {
<span class="nc" id="L1718">        setModel (</span>
<span class="nc" id="L1719">            new AbstractListModel&lt;E&gt;() {</span>
<span class="nc" id="L1720">                public int getSize() { return listData.size(); }</span>
<span class="nc" id="L1721">                public E getElementAt(int i) { return listData.elementAt(i); }</span>
            }
        );
<span class="nc" id="L1724">    }</span>


    /**
     * --- ListSelectionModel delegations and extensions ---
     */


    /**
     * Returns an instance of {@code DefaultListSelectionModel}; called
     * during construction to initialize the list's selection model
     * property.
     *
     * @return a {@code DefaultListSelecitonModel}, used to initialize
     *         the list's selection model property during construction
     * @see #setSelectionModel
     * @see DefaultListSelectionModel
     */
    protected ListSelectionModel createSelectionModel() {
<span class="nc" id="L1743">        return new DefaultListSelectionModel();</span>
    }


    /**
     * Returns the current selection model. The selection model maintains the
     * selection state of the list. See the class level documentation for more
     * details.
     *
     * @return the &lt;code&gt;ListSelectionModel&lt;/code&gt; that maintains the
     *         list's selections
     *
     * @see #setSelectionModel
     * @see ListSelectionModel
     */
    public ListSelectionModel getSelectionModel() {
<span class="nc" id="L1759">        return selectionModel;</span>
    }


    /**
     * Notifies {@code ListSelectionListener}s added directly to the list
     * of selection changes made to the selection model. {@code JList}
     * listens for changes made to the selection in the selection model,
     * and forwards notification to listeners added to the list directly,
     * by calling this method.
     * &lt;p&gt;
     * This method constructs a {@code ListSelectionEvent} with this list
     * as the source, and the specified arguments, and sends it to the
     * registered {@code ListSelectionListeners}.
     *
     * @param firstIndex the first index in the range, {@code &lt;= lastIndex}
     * @param lastIndex the last index in the range, {@code &gt;= firstIndex}
     * @param isAdjusting whether or not this is one in a series of
     *        multiple events, where changes are still being made
     *
     * @see #addListSelectionListener
     * @see #removeListSelectionListener
     * @see javax.swing.event.ListSelectionEvent
     * @see EventListenerList
     */
    protected void fireSelectionValueChanged(int firstIndex, int lastIndex,
                                             boolean isAdjusting)
    {
<span class="nc" id="L1787">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc" id="L1788">        ListSelectionEvent e = null;</span>

<span class="nc bnc" id="L1790" title="All 2 branches missed.">        for (int i = listeners.length - 2; i &gt;= 0; i -= 2) {</span>
<span class="nc bnc" id="L1791" title="All 2 branches missed.">            if (listeners[i] == ListSelectionListener.class) {</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">                if (e == null) {</span>
<span class="nc" id="L1793">                    e = new ListSelectionEvent(this, firstIndex, lastIndex,</span>
                                               isAdjusting);
                }
<span class="nc" id="L1796">                ((ListSelectionListener)listeners[i+1]).valueChanged(e);</span>
            }
        }
<span class="nc" id="L1799">    }</span>


    /* A ListSelectionListener that forwards ListSelectionEvents from
     * the selectionModel to the JList ListSelectionListeners.  The
     * forwarded events only differ from the originals in that their
     * source is the JList instead of the selectionModel itself.
     */
<span class="nc" id="L1807">    private class ListSelectionHandler implements ListSelectionListener, Serializable</span>
    {
        public void valueChanged(ListSelectionEvent e) {
<span class="nc" id="L1810">            fireSelectionValueChanged(e.getFirstIndex(),</span>
<span class="nc" id="L1811">                                      e.getLastIndex(),</span>
<span class="nc" id="L1812">                                      e.getValueIsAdjusting());</span>
<span class="nc" id="L1813">        }</span>
    }


    /**
     * Adds a listener to the list, to be notified each time a change to the
     * selection occurs; the preferred way of listening for selection state
     * changes. {@code JList} takes care of listening for selection state
     * changes in the selection model, and notifies the given listener of
     * each change. {@code ListSelectionEvent}s sent to the listener have a
     * {@code source} property set to this list.
     *
     * @param listener the {@code ListSelectionListener} to add
     * @see #getSelectionModel
     * @see #getListSelectionListeners
     */
    public void addListSelectionListener(ListSelectionListener listener)
    {
<span class="nc bnc" id="L1831" title="All 2 branches missed.">        if (selectionListener == null) {</span>
<span class="nc" id="L1832">            selectionListener = new ListSelectionHandler();</span>
<span class="nc" id="L1833">            getSelectionModel().addListSelectionListener(selectionListener);</span>
        }

<span class="nc" id="L1836">        listenerList.add(ListSelectionListener.class, listener);</span>
<span class="nc" id="L1837">    }</span>


    /**
     * Removes a selection listener from the list.
     *
     * @param listener the {@code ListSelectionListener} to remove
     * @see #addListSelectionListener
     * @see #getSelectionModel
     */
    public void removeListSelectionListener(ListSelectionListener listener) {
<span class="nc" id="L1848">        listenerList.remove(ListSelectionListener.class, listener);</span>
<span class="nc" id="L1849">    }</span>


    /**
     * Returns an array of all the {@code ListSelectionListener}s added
     * to this {@code JList} by way of {@code addListSelectionListener}.
     *
     * @return all of the {@code ListSelectionListener}s on this list, or
     *         an empty array if no listeners have been added
     * @see #addListSelectionListener
     * @since 1.4
     */
    public ListSelectionListener[] getListSelectionListeners() {
<span class="nc" id="L1862">        return listenerList.getListeners(ListSelectionListener.class);</span>
    }


    /**
     * Sets the &lt;code&gt;selectionModel&lt;/code&gt; for the list to a
     * non-&lt;code&gt;null&lt;/code&gt; &lt;code&gt;ListSelectionModel&lt;/code&gt;
     * implementation. The selection model handles the task of making single
     * selections, selections of contiguous ranges, and non-contiguous
     * selections.
     * &lt;p&gt;
     * This is a JavaBeans bound property.
     *
     * @param selectionModel  the &lt;code&gt;ListSelectionModel&lt;/code&gt; that
     *                          implements the selections
     * @exception IllegalArgumentException   if &lt;code&gt;selectionModel&lt;/code&gt;
     *                                          is &lt;code&gt;null&lt;/code&gt;
     * @see #getSelectionModel
     * @beaninfo
     *       bound: true
     * description: The selection model, recording which cells are selected.
     */
    public void setSelectionModel(ListSelectionModel selectionModel) {
<span class="nc bnc" id="L1885" title="All 2 branches missed.">        if (selectionModel == null) {</span>
<span class="nc" id="L1886">            throw new IllegalArgumentException(&quot;selectionModel must be non null&quot;);</span>
        }

        /* Remove the forwarding ListSelectionListener from the old
         * selectionModel, and add it to the new one, if necessary.
         */
<span class="nc bnc" id="L1892" title="All 2 branches missed.">        if (selectionListener != null) {</span>
<span class="nc" id="L1893">            this.selectionModel.removeListSelectionListener(selectionListener);</span>
<span class="nc" id="L1894">            selectionModel.addListSelectionListener(selectionListener);</span>
        }

<span class="nc" id="L1897">        ListSelectionModel oldValue = this.selectionModel;</span>
<span class="nc" id="L1898">        this.selectionModel = selectionModel;</span>
<span class="nc" id="L1899">        firePropertyChange(&quot;selectionModel&quot;, oldValue, selectionModel);</span>
<span class="nc" id="L1900">    }</span>


    /**
     * Sets the selection mode for the list. This is a cover method that sets
     * the selection mode directly on the selection model.
     * &lt;p&gt;
     * The following list describes the accepted selection modes:
     * &lt;ul&gt;
     * &lt;li&gt;{@code ListSelectionModel.SINGLE_SELECTION} -
     *   Only one list index can be selected at a time. In this mode,
     *   {@code setSelectionInterval} and {@code addSelectionInterval} are
     *   equivalent, both replacing the current selection with the index
     *   represented by the second argument (the &quot;lead&quot;).
     * &lt;li&gt;{@code ListSelectionModel.SINGLE_INTERVAL_SELECTION} -
     *   Only one contiguous interval can be selected at a time.
     *   In this mode, {@code addSelectionInterval} behaves like
     *   {@code setSelectionInterval} (replacing the current selection},
     *   unless the given interval is immediately adjacent to or overlaps
     *   the existing selection, and can be used to grow the selection.
     * &lt;li&gt;{@code ListSelectionModel.MULTIPLE_INTERVAL_SELECTION} -
     *   In this mode, there's no restriction on what can be selected.
     *   This mode is the default.
     * &lt;/ul&gt;
     *
     * @param selectionMode the selection mode
     * @see #getSelectionMode
     * @throws IllegalArgumentException if the selection mode isn't
     *         one of those allowed
     * @beaninfo
     * description: The selection mode.
     *        enum: SINGLE_SELECTION            ListSelectionModel.SINGLE_SELECTION
     *              SINGLE_INTERVAL_SELECTION   ListSelectionModel.SINGLE_INTERVAL_SELECTION
     *              MULTIPLE_INTERVAL_SELECTION ListSelectionModel.MULTIPLE_INTERVAL_SELECTION
     */
    public void setSelectionMode(int selectionMode) {
<span class="nc" id="L1936">        getSelectionModel().setSelectionMode(selectionMode);</span>
<span class="nc" id="L1937">    }</span>

    /**
     * Returns the current selection mode for the list. This is a cover
     * method that delegates to the method of the same name on the
     * list's selection model.
     *
     * @return the current selection mode
     * @see #setSelectionMode
     */
    public int getSelectionMode() {
<span class="nc" id="L1948">        return getSelectionModel().getSelectionMode();</span>
    }


    /**
     * Returns the anchor selection index. This is a cover method that
     * delegates to the method of the same name on the list's selection model.
     *
     * @return the anchor selection index
     * @see ListSelectionModel#getAnchorSelectionIndex
     */
    public int getAnchorSelectionIndex() {
<span class="nc" id="L1960">        return getSelectionModel().getAnchorSelectionIndex();</span>
    }


    /**
     * Returns the lead selection index. This is a cover method that
     * delegates to the method of the same name on the list's selection model.
     *
     * @return the lead selection index
     * @see ListSelectionModel#getLeadSelectionIndex
     * @beaninfo
     * description: The lead selection index.
     */
    public int getLeadSelectionIndex() {
<span class="nc" id="L1974">        return getSelectionModel().getLeadSelectionIndex();</span>
    }


    /**
     * Returns the smallest selected cell index, or {@code -1} if the selection
     * is empty. This is a cover method that delegates to the method of the same
     * name on the list's selection model.
     *
     * @return the smallest selected cell index, or {@code -1}
     * @see ListSelectionModel#getMinSelectionIndex
     */
    public int getMinSelectionIndex() {
<span class="nc" id="L1987">        return getSelectionModel().getMinSelectionIndex();</span>
    }


    /**
     * Returns the largest selected cell index, or {@code -1} if the selection
     * is empty. This is a cover method that delegates to the method of the same
     * name on the list's selection model.
     *
     * @return the largest selected cell index
     * @see ListSelectionModel#getMaxSelectionIndex
     */
    public int getMaxSelectionIndex() {
<span class="nc" id="L2000">        return getSelectionModel().getMaxSelectionIndex();</span>
    }


    /**
     * Returns {@code true} if the specified index is selected,
     * else {@code false}. This is a cover method that delegates to the method
     * of the same name on the list's selection model.
     *
     * @param index index to be queried for selection state
     * @return {@code true} if the specified index is selected,
     *         else {@code false}
     * @see ListSelectionModel#isSelectedIndex
     * @see #setSelectedIndex
     */
    public boolean isSelectedIndex(int index) {
<span class="nc" id="L2016">        return getSelectionModel().isSelectedIndex(index);</span>
    }


    /**
     * Returns {@code true} if nothing is selected, else {@code false}.
     * This is a cover method that delegates to the method of the same
     * name on the list's selection model.
     *
     * @return {@code true} if nothing is selected, else {@code false}
     * @see ListSelectionModel#isSelectionEmpty
     * @see #clearSelection
     */
    public boolean isSelectionEmpty() {
<span class="nc" id="L2030">        return getSelectionModel().isSelectionEmpty();</span>
    }


    /**
     * Clears the selection; after calling this method, {@code isSelectionEmpty}
     * will return {@code true}. This is a cover method that delegates to the
     * method of the same name on the list's selection model.
     *
     * @see ListSelectionModel#clearSelection
     * @see #isSelectionEmpty
     */
    public void clearSelection() {
<span class="nc" id="L2043">        getSelectionModel().clearSelection();</span>
<span class="nc" id="L2044">    }</span>


    /**
     * Selects the specified interval. Both {@code anchor} and {@code lead}
     * indices are included. {@code anchor} doesn't have to be less than or
     * equal to {@code lead}. This is a cover method that delegates to the
     * method of the same name on the list's selection model.
     * &lt;p&gt;
     * Refer to the documentation of the selection model class being used
     * for details on how values less than {@code 0} are handled.
     *
     * @param anchor the first index to select
     * @param lead the last index to select
     * @see ListSelectionModel#setSelectionInterval
     * @see DefaultListSelectionModel#setSelectionInterval
     * @see #createSelectionModel
     * @see #addSelectionInterval
     * @see #removeSelectionInterval
     */
    public void setSelectionInterval(int anchor, int lead) {
<span class="nc" id="L2065">        getSelectionModel().setSelectionInterval(anchor, lead);</span>
<span class="nc" id="L2066">    }</span>


    /**
     * Sets the selection to be the union of the specified interval with current
     * selection. Both the {@code anchor} and {@code lead} indices are
     * included. {@code anchor} doesn't have to be less than or
     * equal to {@code lead}. This is a cover method that delegates to the
     * method of the same name on the list's selection model.
     * &lt;p&gt;
     * Refer to the documentation of the selection model class being used
     * for details on how values less than {@code 0} are handled.
     *
     * @param anchor the first index to add to the selection
     * @param lead the last index to add to the selection
     * @see ListSelectionModel#addSelectionInterval
     * @see DefaultListSelectionModel#addSelectionInterval
     * @see #createSelectionModel
     * @see #setSelectionInterval
     * @see #removeSelectionInterval
     */
    public void addSelectionInterval(int anchor, int lead) {
<span class="nc" id="L2088">        getSelectionModel().addSelectionInterval(anchor, lead);</span>
<span class="nc" id="L2089">    }</span>


    /**
     * Sets the selection to be the set difference of the specified interval
     * and the current selection. Both the {@code index0} and {@code index1}
     * indices are removed. {@code index0} doesn't have to be less than or
     * equal to {@code index1}. This is a cover method that delegates to the
     * method of the same name on the list's selection model.
     * &lt;p&gt;
     * Refer to the documentation of the selection model class being used
     * for details on how values less than {@code 0} are handled.
     *
     * @param index0 the first index to remove from the selection
     * @param index1 the last index to remove from the selection
     * @see ListSelectionModel#removeSelectionInterval
     * @see DefaultListSelectionModel#removeSelectionInterval
     * @see #createSelectionModel
     * @see #setSelectionInterval
     * @see #addSelectionInterval
     */
    public void removeSelectionInterval(int index0, int index1) {
<span class="nc" id="L2111">        getSelectionModel().removeSelectionInterval(index0, index1);</span>
<span class="nc" id="L2112">    }</span>


    /**
     * Sets the selection model's {@code valueIsAdjusting} property. When
     * {@code true}, upcoming changes to selection should be considered part
     * of a single change. This property is used internally and developers
     * typically need not call this method. For example, when the model is being
     * updated in response to a user drag, the value of the property is set
     * to {@code true} when the drag is initiated and set to {@code false}
     * when the drag is finished. This allows listeners to update only
     * when a change has been finalized, rather than handling all of the
     * intermediate values.
     * &lt;p&gt;
     * You may want to use this directly if making a series of changes
     * that should be considered part of a single change.
     * &lt;p&gt;
     * This is a cover method that delegates to the method of the same name on
     * the list's selection model. See the documentation for
     * {@link javax.swing.ListSelectionModel#setValueIsAdjusting} for
     * more details.
     *
     * @param b the new value for the property
     * @see ListSelectionModel#setValueIsAdjusting
     * @see javax.swing.event.ListSelectionEvent#getValueIsAdjusting
     * @see #getValueIsAdjusting
     */
    public void setValueIsAdjusting(boolean b) {
<span class="nc" id="L2140">        getSelectionModel().setValueIsAdjusting(b);</span>
<span class="nc" id="L2141">    }</span>


    /**
     * Returns the value of the selection model's {@code isAdjusting} property.
     * &lt;p&gt;
     * This is a cover method that delegates to the method of the same name on
     * the list's selection model.
     *
     * @return the value of the selection model's {@code isAdjusting} property.
     *
     * @see #setValueIsAdjusting
     * @see ListSelectionModel#getValueIsAdjusting
     */
    public boolean getValueIsAdjusting() {
<span class="nc" id="L2156">        return getSelectionModel().getValueIsAdjusting();</span>
    }


    /**
     * Returns an array of all of the selected indices, in increasing
     * order.
     *
     * @return all of the selected indices, in increasing order,
     *         or an empty array if nothing is selected
     * @see #removeSelectionInterval
     * @see #addListSelectionListener
     */
    @Transient
    public int[] getSelectedIndices() {
<span class="nc" id="L2171">        ListSelectionModel sm = getSelectionModel();</span>
<span class="nc" id="L2172">        int iMin = sm.getMinSelectionIndex();</span>
<span class="nc" id="L2173">        int iMax = sm.getMaxSelectionIndex();</span>

<span class="nc bnc" id="L2175" title="All 4 branches missed.">        if ((iMin &lt; 0) || (iMax &lt; 0)) {</span>
<span class="nc" id="L2176">            return new int[0];</span>
        }

<span class="nc" id="L2179">        int[] rvTmp = new int[1+ (iMax - iMin)];</span>
<span class="nc" id="L2180">        int n = 0;</span>
<span class="nc bnc" id="L2181" title="All 2 branches missed.">        for(int i = iMin; i &lt;= iMax; i++) {</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">            if (sm.isSelectedIndex(i)) {</span>
<span class="nc" id="L2183">                rvTmp[n++] = i;</span>
            }
        }
<span class="nc" id="L2186">        int[] rv = new int[n];</span>
<span class="nc" id="L2187">        System.arraycopy(rvTmp, 0, rv, 0, n);</span>
<span class="nc" id="L2188">        return rv;</span>
    }


    /**
     * Selects a single cell. Does nothing if the given index is greater
     * than or equal to the model size. This is a convenience method that uses
     * {@code setSelectionInterval} on the selection model. Refer to the
     * documentation for the selection model class being used for details on
     * how values less than {@code 0} are handled.
     *
     * @param index the index of the cell to select
     * @see ListSelectionModel#setSelectionInterval
     * @see #isSelectedIndex
     * @see #addListSelectionListener
     * @beaninfo
     * description: The index of the selected cell.
     */
    public void setSelectedIndex(int index) {
<span class="nc bnc" id="L2207" title="All 2 branches missed.">        if (index &gt;= getModel().getSize()) {</span>
<span class="nc" id="L2208">            return;</span>
        }
<span class="nc" id="L2210">        getSelectionModel().setSelectionInterval(index, index);</span>
<span class="nc" id="L2211">    }</span>


    /**
     * Changes the selection to be the set of indices specified by the given
     * array. Indices greater than or equal to the model size are ignored.
     * This is a convenience method that clears the selection and then uses
     * {@code addSelectionInterval} on the selection model to add the indices.
     * Refer to the documentation of the selection model class being used for
     * details on how values less than {@code 0} are handled.
     *
     * @param indices an array of the indices of the cells to select,
     *                {@code non-null}
     * @see ListSelectionModel#addSelectionInterval
     * @see #isSelectedIndex
     * @see #addListSelectionListener
     * @throws NullPointerException if the given array is {@code null}
     */
    public void setSelectedIndices(int[] indices) {
<span class="nc" id="L2230">        ListSelectionModel sm = getSelectionModel();</span>
<span class="nc" id="L2231">        sm.clearSelection();</span>
<span class="nc" id="L2232">        int size = getModel().getSize();</span>
<span class="nc bnc" id="L2233" title="All 2 branches missed.">        for (int i : indices) {</span>
<span class="nc bnc" id="L2234" title="All 2 branches missed.">            if (i &lt; size) {</span>
<span class="nc" id="L2235">                sm.addSelectionInterval(i, i);</span>
            }
        }
<span class="nc" id="L2238">    }</span>


    /**
     * Returns an array of all the selected values, in increasing order based
     * on their indices in the list.
     *
     * @return the selected values, or an empty array if nothing is selected
     * @see #isSelectedIndex
     * @see #getModel
     * @see #addListSelectionListener
     *
     * @deprecated As of JDK 1.7, replaced by {@link #getSelectedValuesList()}
     */
    @Deprecated
    public Object[] getSelectedValues() {
<span class="nc" id="L2254">        ListSelectionModel sm = getSelectionModel();</span>
<span class="nc" id="L2255">        ListModel&lt;E&gt; dm = getModel();</span>

<span class="nc" id="L2257">        int iMin = sm.getMinSelectionIndex();</span>
<span class="nc" id="L2258">        int iMax = sm.getMaxSelectionIndex();</span>

<span class="nc bnc" id="L2260" title="All 4 branches missed.">        if ((iMin &lt; 0) || (iMax &lt; 0)) {</span>
<span class="nc" id="L2261">            return new Object[0];</span>
        }

<span class="nc" id="L2264">        Object[] rvTmp = new Object[1+ (iMax - iMin)];</span>
<span class="nc" id="L2265">        int n = 0;</span>
<span class="nc bnc" id="L2266" title="All 2 branches missed.">        for(int i = iMin; i &lt;= iMax; i++) {</span>
<span class="nc bnc" id="L2267" title="All 2 branches missed.">            if (sm.isSelectedIndex(i)) {</span>
<span class="nc" id="L2268">                rvTmp[n++] = dm.getElementAt(i);</span>
            }
        }
<span class="nc" id="L2271">        Object[] rv = new Object[n];</span>
<span class="nc" id="L2272">        System.arraycopy(rvTmp, 0, rv, 0, n);</span>
<span class="nc" id="L2273">        return rv;</span>
    }

    /**
     * Returns a list of all the selected items, in increasing order based
     * on their indices in the list.
     *
     * @return the selected items, or an empty list if nothing is selected
     * @see #isSelectedIndex
     * @see #getModel
     * @see #addListSelectionListener
     *
     * @since 1.7
     */
    public List&lt;E&gt; getSelectedValuesList() {
<span class="nc" id="L2288">        ListSelectionModel sm = getSelectionModel();</span>
<span class="nc" id="L2289">        ListModel&lt;E&gt; dm = getModel();</span>

<span class="nc" id="L2291">        int iMin = sm.getMinSelectionIndex();</span>
<span class="nc" id="L2292">        int iMax = sm.getMaxSelectionIndex();</span>

<span class="nc bnc" id="L2294" title="All 4 branches missed.">        if ((iMin &lt; 0) || (iMax &lt; 0)) {</span>
<span class="nc" id="L2295">            return Collections.emptyList();</span>
        }

<span class="nc" id="L2298">        List&lt;E&gt; selectedItems = new ArrayList&lt;E&gt;();</span>
<span class="nc bnc" id="L2299" title="All 2 branches missed.">        for(int i = iMin; i &lt;= iMax; i++) {</span>
<span class="nc bnc" id="L2300" title="All 2 branches missed.">            if (sm.isSelectedIndex(i)) {</span>
<span class="nc" id="L2301">                selectedItems.add(dm.getElementAt(i));</span>
            }
        }
<span class="nc" id="L2304">        return selectedItems;</span>
    }


    /**
     * Returns the smallest selected cell index; &lt;i&gt;the selection&lt;/i&gt; when only
     * a single item is selected in the list. When multiple items are selected,
     * it is simply the smallest selected index. Returns {@code -1} if there is
     * no selection.
     * &lt;p&gt;
     * This method is a cover that delegates to {@code getMinSelectionIndex}.
     *
     * @return the smallest selected cell index
     * @see #getMinSelectionIndex
     * @see #addListSelectionListener
     */
    public int getSelectedIndex() {
<span class="nc" id="L2321">        return getMinSelectionIndex();</span>
    }


    /**
     * Returns the value for the smallest selected cell index;
     * &lt;i&gt;the selected value&lt;/i&gt; when only a single item is selected in the
     * list. When multiple items are selected, it is simply the value for the
     * smallest selected index. Returns {@code null} if there is no selection.
     * &lt;p&gt;
     * This is a convenience method that simply returns the model value for
     * {@code getMinSelectionIndex}.
     *
     * @return the first selected value
     * @see #getMinSelectionIndex
     * @see #getModel
     * @see #addListSelectionListener
     */
    public E getSelectedValue() {
<span class="nc" id="L2340">        int i = getMinSelectionIndex();</span>
<span class="nc bnc" id="L2341" title="All 2 branches missed.">        return (i == -1) ? null : getModel().getElementAt(i);</span>
    }


    /**
     * Selects the specified object from the list.
     *
     * @param anObject      the object to select
     * @param shouldScroll  {@code true} if the list should scroll to display
     *                      the selected object, if one exists; otherwise {@code false}
     */
    public void setSelectedValue(Object anObject,boolean shouldScroll) {
<span class="nc bnc" id="L2353" title="All 2 branches missed.">        if(anObject == null)</span>
<span class="nc" id="L2354">            setSelectedIndex(-1);</span>
<span class="nc bnc" id="L2355" title="All 2 branches missed.">        else if(!anObject.equals(getSelectedValue())) {</span>
            int i,c;
<span class="nc" id="L2357">            ListModel&lt;E&gt; dm = getModel();</span>
<span class="nc bnc" id="L2358" title="All 2 branches missed.">            for(i=0,c=dm.getSize();i&lt;c;i++)</span>
<span class="nc bnc" id="L2359" title="All 2 branches missed.">                if(anObject.equals(dm.getElementAt(i))){</span>
<span class="nc" id="L2360">                    setSelectedIndex(i);</span>
<span class="nc bnc" id="L2361" title="All 2 branches missed.">                    if(shouldScroll)</span>
<span class="nc" id="L2362">                        ensureIndexIsVisible(i);</span>
<span class="nc" id="L2363">                    repaint();  /** FIX-ME setSelectedIndex does not redraw all the time with the basic l&amp;f**/</span>
<span class="nc" id="L2364">                    return;</span>
                }
<span class="nc" id="L2366">            setSelectedIndex(-1);</span>
        }
<span class="nc" id="L2368">        repaint(); /** FIX-ME setSelectedIndex does not redraw all the time with the basic l&amp;f**/</span>
<span class="nc" id="L2369">    }</span>



    /**
     * --- The Scrollable Implementation ---
     */

    private void checkScrollableParameters(Rectangle visibleRect, int orientation) {
<span class="nc bnc" id="L2378" title="All 2 branches missed.">        if (visibleRect == null) {</span>
<span class="nc" id="L2379">            throw new IllegalArgumentException(&quot;visibleRect must be non-null&quot;);</span>
        }
<span class="nc bnc" id="L2381" title="All 2 branches missed.">        switch (orientation) {</span>
        case SwingConstants.VERTICAL:
        case SwingConstants.HORIZONTAL:
<span class="nc" id="L2384">            break;</span>
        default:
<span class="nc" id="L2386">            throw new IllegalArgumentException(&quot;orientation must be one of: VERTICAL, HORIZONTAL&quot;);</span>
        }
<span class="nc" id="L2388">    }</span>


    /**
     * Computes the size of viewport needed to display {@code visibleRowCount}
     * rows. The value returned by this method depends on the layout
     * orientation:
     * &lt;p&gt;
     * &lt;b&gt;{@code VERTICAL}:&lt;/b&gt;
     * &lt;br&gt;
     * This is trivial if both {@code fixedCellWidth} and {@code fixedCellHeight}
     * have been set (either explicitly or by specifying a prototype cell value).
     * The width is simply the {@code fixedCellWidth} plus the list's horizontal
     * insets. The height is the {@code fixedCellHeight} multiplied by the
     * {@code visibleRowCount}, plus the list's vertical insets.
     * &lt;p&gt;
     * If either {@code fixedCellWidth} or {@code fixedCellHeight} haven't been
     * specified, heuristics are used. If the model is empty, the width is
     * the {@code fixedCellWidth}, if greater than {@code 0}, or a hard-coded
     * value of {@code 256}. The height is the {@code fixedCellHeight} multiplied
     * by {@code visibleRowCount}, if {@code fixedCellHeight} is greater than
     * {@code 0}, otherwise it is a hard-coded value of {@code 16} multiplied by
     * {@code visibleRowCount}.
     * &lt;p&gt;
     * If the model isn't empty, the width is the preferred size's width,
     * typically the width of the widest list element. The height is the
     * {@code fixedCellHeight} multiplied by the {@code visibleRowCount},
     * plus the list's vertical insets.
     * &lt;p&gt;
     * &lt;b&gt;{@code VERTICAL_WRAP} or {@code HORIZONTAL_WRAP}:&lt;/b&gt;
     * &lt;br&gt;
     * This method simply returns the value from {@code getPreferredSize}.
     * The list's {@code ListUI} is expected to override {@code getPreferredSize}
     * to return an appropriate value.
     *
     * @return a dimension containing the size of the viewport needed
     *          to display {@code visibleRowCount} rows
     * @see #getPreferredScrollableViewportSize
     * @see #setPrototypeCellValue
     */
    public Dimension getPreferredScrollableViewportSize()
    {
<span class="nc bnc" id="L2430" title="All 2 branches missed.">        if (getLayoutOrientation() != VERTICAL) {</span>
<span class="nc" id="L2431">            return getPreferredSize();</span>
        }
<span class="nc" id="L2433">        Insets insets = getInsets();</span>
<span class="nc" id="L2434">        int dx = insets.left + insets.right;</span>
<span class="nc" id="L2435">        int dy = insets.top + insets.bottom;</span>

<span class="nc" id="L2437">        int visibleRowCount = getVisibleRowCount();</span>
<span class="nc" id="L2438">        int fixedCellWidth = getFixedCellWidth();</span>
<span class="nc" id="L2439">        int fixedCellHeight = getFixedCellHeight();</span>

<span class="nc bnc" id="L2441" title="All 4 branches missed.">        if ((fixedCellWidth &gt; 0) &amp;&amp; (fixedCellHeight &gt; 0)) {</span>
<span class="nc" id="L2442">            int width = fixedCellWidth + dx;</span>
<span class="nc" id="L2443">            int height = (visibleRowCount * fixedCellHeight) + dy;</span>
<span class="nc" id="L2444">            return new Dimension(width, height);</span>
        }
<span class="nc bnc" id="L2446" title="All 2 branches missed.">        else if (getModel().getSize() &gt; 0) {</span>
<span class="nc" id="L2447">            int width = getPreferredSize().width;</span>
            int height;
<span class="nc" id="L2449">            Rectangle r = getCellBounds(0, 0);</span>
<span class="nc bnc" id="L2450" title="All 2 branches missed.">            if (r != null) {</span>
<span class="nc" id="L2451">                height = (visibleRowCount * r.height) + dy;</span>
            }
            else {
                // Will only happen if UI null, shouldn't matter what we return
<span class="nc" id="L2455">                height = 1;</span>
            }
<span class="nc" id="L2457">            return new Dimension(width, height);</span>
        }
        else {
<span class="nc bnc" id="L2460" title="All 2 branches missed.">            fixedCellWidth = (fixedCellWidth &gt; 0) ? fixedCellWidth : 256;</span>
<span class="nc bnc" id="L2461" title="All 2 branches missed.">            fixedCellHeight = (fixedCellHeight &gt; 0) ? fixedCellHeight : 16;</span>
<span class="nc" id="L2462">            return new Dimension(fixedCellWidth, fixedCellHeight * visibleRowCount);</span>
        }
    }


    /**
     * Returns the distance to scroll to expose the next or previous
     * row (for vertical scrolling) or column (for horizontal scrolling).
     * &lt;p&gt;
     * For horizontal scrolling, if the layout orientation is {@code VERTICAL},
     * then the list's font size is returned (or {@code 1} if the font is
     * {@code null}).
     *
     * @param visibleRect the view area visible within the viewport
     * @param orientation {@code SwingConstants.HORIZONTAL} or
     *                    {@code SwingConstants.VERTICAL}
     * @param direction less or equal to zero to scroll up/back,
     *                  greater than zero for down/forward
     * @return the &quot;unit&quot; increment for scrolling in the specified direction;
     *         always positive
     * @see #getScrollableBlockIncrement
     * @see Scrollable#getScrollableUnitIncrement
     * @throws IllegalArgumentException if {@code visibleRect} is {@code null}, or
     *         {@code orientation} isn't one of {@code SwingConstants.VERTICAL} or
     *         {@code SwingConstants.HORIZONTAL}
     */
    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction)
    {
<span class="nc" id="L2490">        checkScrollableParameters(visibleRect, orientation);</span>

<span class="nc bnc" id="L2492" title="All 2 branches missed.">        if (orientation == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L2493">            int row = locationToIndex(visibleRect.getLocation());</span>

<span class="nc bnc" id="L2495" title="All 2 branches missed.">            if (row == -1) {</span>
<span class="nc" id="L2496">                return 0;</span>
            }
            else {
                /* Scroll Down */
<span class="nc bnc" id="L2500" title="All 2 branches missed.">                if (direction &gt; 0) {</span>
<span class="nc" id="L2501">                    Rectangle r = getCellBounds(row, row);</span>
<span class="nc bnc" id="L2502" title="All 2 branches missed.">                    return (r == null) ? 0 : r.height - (visibleRect.y - r.y);</span>
                }
                /* Scroll Up */
                else {
<span class="nc" id="L2506">                    Rectangle r = getCellBounds(row, row);</span>

                    /* The first row is completely visible and it's row 0.
                     * We're done.
                     */
<span class="nc bnc" id="L2511" title="All 4 branches missed.">                    if ((r.y == visibleRect.y) &amp;&amp; (row == 0))  {</span>
<span class="nc" id="L2512">                        return 0;</span>
                    }
                    /* The first row is completely visible, return the
                     * height of the previous row or 0 if the first row
                     * is the top row of the list.
                     */
<span class="nc bnc" id="L2518" title="All 2 branches missed.">                    else if (r.y == visibleRect.y) {</span>
<span class="nc" id="L2519">                        Point loc = r.getLocation();</span>
<span class="nc" id="L2520">                        loc.y--;</span>
<span class="nc" id="L2521">                        int prevIndex = locationToIndex(loc);</span>
<span class="nc" id="L2522">                        Rectangle prevR = getCellBounds(prevIndex, prevIndex);</span>

<span class="nc bnc" id="L2524" title="All 4 branches missed.">                        if (prevR == null || prevR.y &gt;= r.y) {</span>
<span class="nc" id="L2525">                            return 0;</span>
                        }
<span class="nc" id="L2527">                        return prevR.height;</span>
                    }
                    /* The first row is partially visible, return the
                     * height of hidden part.
                     */
                    else {
<span class="nc" id="L2533">                        return visibleRect.y - r.y;</span>
                    }
                }
            }
<span class="nc bnc" id="L2537" title="All 2 branches missed.">        } else if (orientation == SwingConstants.HORIZONTAL &amp;&amp;</span>
<span class="nc bnc" id="L2538" title="All 2 branches missed.">                           getLayoutOrientation() != JList.VERTICAL) {</span>
<span class="nc" id="L2539">            boolean leftToRight = getComponentOrientation().isLeftToRight();</span>
            int index;
            Point leadingPoint;

<span class="nc bnc" id="L2543" title="All 2 branches missed.">            if (leftToRight) {</span>
<span class="nc" id="L2544">                leadingPoint = visibleRect.getLocation();</span>
            }
            else {
<span class="nc" id="L2547">                leadingPoint = new Point(visibleRect.x + visibleRect.width -1,</span>
                                         visibleRect.y);
            }
<span class="nc" id="L2550">            index = locationToIndex(leadingPoint);</span>

<span class="nc bnc" id="L2552" title="All 2 branches missed.">            if (index != -1) {</span>
<span class="nc" id="L2553">                Rectangle cellBounds = getCellBounds(index, index);</span>
<span class="nc bnc" id="L2554" title="All 4 branches missed.">                if (cellBounds != null &amp;&amp; cellBounds.contains(leadingPoint)) {</span>
                    int leadingVisibleEdge;
                    int leadingCellEdge;

<span class="nc bnc" id="L2558" title="All 2 branches missed.">                    if (leftToRight) {</span>
<span class="nc" id="L2559">                        leadingVisibleEdge = visibleRect.x;</span>
<span class="nc" id="L2560">                        leadingCellEdge = cellBounds.x;</span>
                    }
                    else {
<span class="nc" id="L2563">                        leadingVisibleEdge = visibleRect.x + visibleRect.width;</span>
<span class="nc" id="L2564">                        leadingCellEdge = cellBounds.x + cellBounds.width;</span>
                    }

<span class="nc bnc" id="L2567" title="All 2 branches missed.">                    if (leadingCellEdge != leadingVisibleEdge) {</span>
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                        if (direction &lt; 0) {</span>
                            // Show remainder of leading cell
<span class="nc" id="L2570">                            return Math.abs(leadingVisibleEdge - leadingCellEdge);</span>

                        }
<span class="nc bnc" id="L2573" title="All 2 branches missed.">                        else if (leftToRight) {</span>
                            // Hide rest of leading cell
<span class="nc" id="L2575">                            return leadingCellEdge + cellBounds.width - leadingVisibleEdge;</span>
                        }
                        else {
                            // Hide rest of leading cell
<span class="nc" id="L2579">                            return leadingVisibleEdge - cellBounds.x;</span>
                        }
                    }
                    // ASSUME: All cells are the same width
<span class="nc" id="L2583">                    return cellBounds.width;</span>
                }
            }
        }
<span class="nc" id="L2587">        Font f = getFont();</span>
<span class="nc bnc" id="L2588" title="All 2 branches missed.">        return (f != null) ? f.getSize() : 1;</span>
    }


    /**
     * Returns the distance to scroll to expose the next or previous block.
     * &lt;p&gt;
     * For vertical scrolling, the following rules are used:
     * &lt;ul&gt;
     * &lt;li&gt;if scrolling down, returns the distance to scroll so that the last
     * visible element becomes the first completely visible element
     * &lt;li&gt;if scrolling up, returns the distance to scroll so that the first
     * visible element becomes the last completely visible element
     * &lt;li&gt;returns {@code visibleRect.height} if the list is empty
     * &lt;/ul&gt;
     * &lt;p&gt;
     * For horizontal scrolling, when the layout orientation is either
     * {@code VERTICAL_WRAP} or {@code HORIZONTAL_WRAP}:
     * &lt;ul&gt;
     * &lt;li&gt;if scrolling right, returns the distance to scroll so that the
     * last visible element becomes
     * the first completely visible element
     * &lt;li&gt;if scrolling left, returns the distance to scroll so that the first
     * visible element becomes the last completely visible element
     * &lt;li&gt;returns {@code visibleRect.width} if the list is empty
     * &lt;/ul&gt;
     * &lt;p&gt;
     * For horizontal scrolling and {@code VERTICAL} orientation,
     * returns {@code visibleRect.width}.
     * &lt;p&gt;
     * Note that the value of {@code visibleRect} must be the equal to
     * {@code this.getVisibleRect()}.
     *
     * @param visibleRect the view area visible within the viewport
     * @param orientation {@code SwingConstants.HORIZONTAL} or
     *                    {@code SwingConstants.VERTICAL}
     * @param direction less or equal to zero to scroll up/back,
     *                  greater than zero for down/forward
     * @return the &quot;block&quot; increment for scrolling in the specified direction;
     *         always positive
     * @see #getScrollableUnitIncrement
     * @see Scrollable#getScrollableBlockIncrement
     * @throws IllegalArgumentException if {@code visibleRect} is {@code null}, or
     *         {@code orientation} isn't one of {@code SwingConstants.VERTICAL} or
     *         {@code SwingConstants.HORIZONTAL}
     */
    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
<span class="nc" id="L2635">        checkScrollableParameters(visibleRect, orientation);</span>
<span class="nc bnc" id="L2636" title="All 2 branches missed.">        if (orientation == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L2637">            int inc = visibleRect.height;</span>
            /* Scroll Down */
<span class="nc bnc" id="L2639" title="All 2 branches missed.">            if (direction &gt; 0) {</span>
                // last cell is the lowest left cell
<span class="nc" id="L2641">                int last = locationToIndex(new Point(visibleRect.x, visibleRect.y+visibleRect.height-1));</span>
<span class="nc bnc" id="L2642" title="All 2 branches missed.">                if (last != -1) {</span>
<span class="nc" id="L2643">                    Rectangle lastRect = getCellBounds(last,last);</span>
<span class="nc bnc" id="L2644" title="All 2 branches missed.">                    if (lastRect != null) {</span>
<span class="nc" id="L2645">                        inc = lastRect.y - visibleRect.y;</span>
<span class="nc bnc" id="L2646" title="All 4 branches missed.">                        if ( (inc == 0) &amp;&amp; (last &lt; getModel().getSize()-1) ) {</span>
<span class="nc" id="L2647">                            inc = lastRect.height;</span>
                        }
                    }
                }
<span class="nc" id="L2651">            }</span>
            /* Scroll Up */
            else {
<span class="nc" id="L2654">                int newFirst = locationToIndex(new Point(visibleRect.x, visibleRect.y-visibleRect.height));</span>
<span class="nc" id="L2655">                int first = getFirstVisibleIndex();</span>
<span class="nc bnc" id="L2656" title="All 2 branches missed.">                if (newFirst != -1) {</span>
<span class="nc bnc" id="L2657" title="All 2 branches missed.">                    if (first == -1) {</span>
<span class="nc" id="L2658">                        first = locationToIndex(visibleRect.getLocation());</span>
                    }
<span class="nc" id="L2660">                    Rectangle newFirstRect = getCellBounds(newFirst,newFirst);</span>
<span class="nc" id="L2661">                    Rectangle firstRect = getCellBounds(first,first);</span>
<span class="nc bnc" id="L2662" title="All 4 branches missed.">                    if ((newFirstRect != null) &amp;&amp; (firstRect!=null)) {</span>
<span class="nc bnc" id="L2663" title="All 4 branches missed.">                        while ( (newFirstRect.y + visibleRect.height &lt;</span>
                                 firstRect.y + firstRect.height) &amp;&amp;
                                (newFirstRect.y &lt; firstRect.y) ) {
<span class="nc" id="L2666">                            newFirst++;</span>
<span class="nc" id="L2667">                            newFirstRect = getCellBounds(newFirst,newFirst);</span>
                        }
<span class="nc" id="L2669">                        inc = visibleRect.y - newFirstRect.y;</span>
<span class="nc bnc" id="L2670" title="All 4 branches missed.">                        if ( (inc &lt;= 0) &amp;&amp; (newFirstRect.y &gt; 0)) {</span>
<span class="nc" id="L2671">                            newFirst--;</span>
<span class="nc" id="L2672">                            newFirstRect = getCellBounds(newFirst,newFirst);</span>
<span class="nc bnc" id="L2673" title="All 2 branches missed.">                            if (newFirstRect != null) {</span>
<span class="nc" id="L2674">                                inc = visibleRect.y - newFirstRect.y;</span>
                            }
                        }
                    }
                }
            }
<span class="nc" id="L2680">            return inc;</span>
        }
<span class="nc bnc" id="L2682" title="All 2 branches missed.">        else if (orientation == SwingConstants.HORIZONTAL &amp;&amp;</span>
<span class="nc bnc" id="L2683" title="All 2 branches missed.">                 getLayoutOrientation() != JList.VERTICAL) {</span>
<span class="nc" id="L2684">            boolean leftToRight = getComponentOrientation().isLeftToRight();</span>
<span class="nc" id="L2685">            int inc = visibleRect.width;</span>
            /* Scroll Right (in ltr mode) or Scroll Left (in rtl mode) */
<span class="nc bnc" id="L2687" title="All 2 branches missed.">            if (direction &gt; 0) {</span>
                // position is upper right if ltr, or upper left otherwise
<span class="nc bnc" id="L2689" title="All 2 branches missed.">                int x = visibleRect.x + (leftToRight ? (visibleRect.width - 1) : 0);</span>
<span class="nc" id="L2690">                int last = locationToIndex(new Point(x, visibleRect.y));</span>

<span class="nc bnc" id="L2692" title="All 2 branches missed.">                if (last != -1) {</span>
<span class="nc" id="L2693">                    Rectangle lastRect = getCellBounds(last,last);</span>
<span class="nc bnc" id="L2694" title="All 2 branches missed.">                    if (lastRect != null) {</span>
<span class="nc bnc" id="L2695" title="All 2 branches missed.">                        if (leftToRight) {</span>
<span class="nc" id="L2696">                            inc = lastRect.x - visibleRect.x;</span>
                        } else {
<span class="nc" id="L2698">                            inc = visibleRect.x + visibleRect.width</span>
                                      - (lastRect.x + lastRect.width);
                        }
<span class="nc bnc" id="L2701" title="All 2 branches missed.">                        if (inc &lt; 0) {</span>
<span class="nc" id="L2702">                            inc += lastRect.width;</span>
<span class="nc bnc" id="L2703" title="All 4 branches missed.">                        } else if ( (inc == 0) &amp;&amp; (last &lt; getModel().getSize()-1) ) {</span>
<span class="nc" id="L2704">                            inc = lastRect.width;</span>
                        }
                    }
                }
<span class="nc" id="L2708">            }</span>
            /* Scroll Left (in ltr mode) or Scroll Right (in rtl mode) */
            else {
                // position is upper left corner of the visibleRect shifted
                // left by the visibleRect.width if ltr, or upper right shifted
                // right by the visibleRect.width otherwise
<span class="nc bnc" id="L2714" title="All 2 branches missed.">                int x = visibleRect.x + (leftToRight</span>
                                         ? -visibleRect.width
                                         : visibleRect.width - 1 + visibleRect.width);
<span class="nc" id="L2717">                int first = locationToIndex(new Point(x, visibleRect.y));</span>

<span class="nc bnc" id="L2719" title="All 2 branches missed.">                if (first != -1) {</span>
<span class="nc" id="L2720">                    Rectangle firstRect = getCellBounds(first,first);</span>
<span class="nc bnc" id="L2721" title="All 2 branches missed.">                    if (firstRect != null) {</span>
                        // the right of the first cell
<span class="nc" id="L2723">                        int firstRight = firstRect.x + firstRect.width;</span>

<span class="nc bnc" id="L2725" title="All 2 branches missed.">                        if (leftToRight) {</span>
<span class="nc bnc" id="L2726" title="All 4 branches missed.">                            if ((firstRect.x &lt; visibleRect.x - visibleRect.width)</span>
                                    &amp;&amp; (firstRight &lt; visibleRect.x)) {
<span class="nc" id="L2728">                                inc = visibleRect.x - firstRight;</span>
                            } else {
<span class="nc" id="L2730">                                inc = visibleRect.x - firstRect.x;</span>
                            }
                        } else {
<span class="nc" id="L2733">                            int visibleRight = visibleRect.x + visibleRect.width;</span>

<span class="nc bnc" id="L2735" title="All 4 branches missed.">                            if ((firstRight &gt; visibleRight + visibleRect.width)</span>
                                    &amp;&amp; (firstRect.x &gt; visibleRight)) {
<span class="nc" id="L2737">                                inc = firstRect.x - visibleRight;</span>
                            } else {
<span class="nc" id="L2739">                                inc = firstRight - visibleRight;</span>
                            }
                        }
                    }
                }
            }
<span class="nc" id="L2745">            return inc;</span>
        }
<span class="nc" id="L2747">        return visibleRect.width;</span>
    }


    /**
     * Returns {@code true} if this {@code JList} is displayed in a
     * {@code JViewport} and the viewport is wider than the list's
     * preferred width, or if the layout orientation is {@code HORIZONTAL_WRAP}
     * and {@code visibleRowCount &lt;= 0}; otherwise returns {@code false}.
     * &lt;p&gt;
     * If {@code false}, then don't track the viewport's width. This allows
     * horizontal scrolling if the {@code JViewport} is itself embedded in a
     * {@code JScrollPane}.
     *
     * @return whether or not an enclosing viewport should force the list's
     *         width to match its own
     * @see Scrollable#getScrollableTracksViewportWidth
     */
    public boolean getScrollableTracksViewportWidth() {
<span class="nc bnc" id="L2766" title="All 2 branches missed.">        if (getLayoutOrientation() == HORIZONTAL_WRAP &amp;&amp;</span>
<span class="nc bnc" id="L2767" title="All 2 branches missed.">                                      getVisibleRowCount() &lt;= 0) {</span>
<span class="nc" id="L2768">            return true;</span>
        }
<span class="nc" id="L2770">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L2771" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc bnc" id="L2772" title="All 2 branches missed.">            return parent.getWidth() &gt; getPreferredSize().width;</span>
        }
<span class="nc" id="L2774">        return false;</span>
    }

    /**
     * Returns {@code true} if this {@code JList} is displayed in a
     * {@code JViewport} and the viewport is taller than the list's
     * preferred height, or if the layout orientation is {@code VERTICAL_WRAP}
     * and {@code visibleRowCount &lt;= 0}; otherwise returns {@code false}.
     * &lt;p&gt;
     * If {@code false}, then don't track the viewport's height. This allows
     * vertical scrolling if the {@code JViewport} is itself embedded in a
     * {@code JScrollPane}.
     *
     * @return whether or not an enclosing viewport should force the list's
     *         height to match its own
     * @see Scrollable#getScrollableTracksViewportHeight
     */
    public boolean getScrollableTracksViewportHeight() {
<span class="nc bnc" id="L2792" title="All 2 branches missed.">        if (getLayoutOrientation() == VERTICAL_WRAP &amp;&amp;</span>
<span class="nc bnc" id="L2793" title="All 2 branches missed.">                     getVisibleRowCount() &lt;= 0) {</span>
<span class="nc" id="L2794">            return true;</span>
        }
<span class="nc" id="L2796">        Container parent = SwingUtilities.getUnwrappedParent(this);</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">        if (parent instanceof JViewport) {</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">            return parent.getHeight() &gt; getPreferredSize().height;</span>
        }
<span class="nc" id="L2800">        return false;</span>
    }


    /*
     * See {@code readObject} and {@code writeObject} in {@code JComponent}
     * for more information about serialization in Swing.
     */
    private void writeObject(ObjectOutputStream s) throws IOException {
<span class="nc" id="L2809">        s.defaultWriteObject();</span>
<span class="nc bnc" id="L2810" title="All 2 branches missed.">        if (getUIClassID().equals(uiClassID)) {</span>
<span class="nc" id="L2811">            byte count = JComponent.getWriteObjCounter(this);</span>
<span class="nc" id="L2812">            JComponent.setWriteObjCounter(this, --count);</span>
<span class="nc bnc" id="L2813" title="All 4 branches missed.">            if (count == 0 &amp;&amp; ui != null) {</span>
<span class="nc" id="L2814">                ui.installUI(this);</span>
            }
        }
<span class="nc" id="L2817">    }</span>


    /**
     * Returns a {@code String} representation of this {@code JList}.
     * This method is intended to be used only for debugging purposes,
     * and the content and format of the returned {@code String} may vary
     * between implementations. The returned {@code String} may be empty,
     * but may not be {@code null}.
     *
     * @return  a {@code String} representation of this {@code JList}.
     */
    protected String paramString() {
<span class="nc bnc" id="L2830" title="All 2 branches missed.">        String selectionForegroundString = (selectionForeground != null ?</span>
<span class="nc" id="L2831">                                            selectionForeground.toString() :</span>
                                            &quot;&quot;);
<span class="nc bnc" id="L2833" title="All 2 branches missed.">        String selectionBackgroundString = (selectionBackground != null ?</span>
<span class="nc" id="L2834">                                            selectionBackground.toString() :</span>
                                            &quot;&quot;);

<span class="nc" id="L2837">        return super.paramString() +</span>
        &quot;,fixedCellHeight=&quot; + fixedCellHeight +
        &quot;,fixedCellWidth=&quot; + fixedCellWidth +
        &quot;,horizontalScrollIncrement=&quot; + horizontalScrollIncrement +
        &quot;,selectionBackground=&quot; + selectionBackgroundString +
        &quot;,selectionForeground=&quot; + selectionForegroundString +
        &quot;,visibleRowCount=&quot; + visibleRowCount +
        &quot;,layoutOrientation=&quot; + layoutOrientation;
    }


    /**
     * --- Accessibility Support ---
     */

    /**
     * Gets the {@code AccessibleContext} associated with this {@code JList}.
     * For {@code JList}, the {@code AccessibleContext} takes the form of an
     * {@code AccessibleJList}.
     * &lt;p&gt;
     * A new {@code AccessibleJList} instance is created if necessary.
     *
     * @return an {@code AccessibleJList} that serves as the
     *         {@code AccessibleContext} of this {@code JList}
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L2863" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L2864">            accessibleContext = new AccessibleJList();</span>
        }
<span class="nc" id="L2866">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * {@code JList} class. It provides an implementation of the
     * Java Accessibility API appropriate to list user-interface
     * elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
    protected class AccessibleJList extends AccessibleJComponent
        implements AccessibleSelection, PropertyChangeListener,
        ListSelectionListener, ListDataListener {

        int leadSelectionIndex;

<span class="nc" id="L2890">        public AccessibleJList() {</span>
<span class="nc" id="L2891">            super();</span>
<span class="nc" id="L2892">            JList.this.addPropertyChangeListener(this);</span>
<span class="nc" id="L2893">            JList.this.getSelectionModel().addListSelectionListener(this);</span>
<span class="nc" id="L2894">            JList.this.getModel().addListDataListener(this);</span>
<span class="nc" id="L2895">            leadSelectionIndex = JList.this.getLeadSelectionIndex();</span>
<span class="nc" id="L2896">        }</span>

        /**
         * Property Change Listener change method. Used to track changes
         * to the DataModel and ListSelectionModel, in order to re-set
         * listeners to those for reporting changes there via the Accessibility
         * PropertyChange mechanism.
         *
         * @param e PropertyChangeEvent
         */
        public void propertyChange(PropertyChangeEvent e) {
<span class="nc" id="L2907">            String name = e.getPropertyName();</span>
<span class="nc" id="L2908">            Object oldValue = e.getOldValue();</span>
<span class="nc" id="L2909">            Object newValue = e.getNewValue();</span>

                // re-set listData listeners
<span class="nc bnc" id="L2912" title="All 2 branches missed.">            if (name.compareTo(&quot;model&quot;) == 0) {</span>

<span class="nc bnc" id="L2914" title="All 4 branches missed.">                if (oldValue != null &amp;&amp; oldValue instanceof ListModel) {</span>
<span class="nc" id="L2915">                    ((ListModel) oldValue).removeListDataListener(this);</span>
                }
<span class="nc bnc" id="L2917" title="All 4 branches missed.">                if (newValue != null &amp;&amp; newValue instanceof ListModel) {</span>
<span class="nc" id="L2918">                    ((ListModel) newValue).addListDataListener(this);</span>
                }

                // re-set listSelectionModel listeners
<span class="nc bnc" id="L2922" title="All 2 branches missed.">            } else if (name.compareTo(&quot;selectionModel&quot;) == 0) {</span>

<span class="nc bnc" id="L2924" title="All 4 branches missed.">                if (oldValue != null &amp;&amp; oldValue instanceof ListSelectionModel) {</span>
<span class="nc" id="L2925">                    ((ListSelectionModel) oldValue).removeListSelectionListener(this);</span>
                }
<span class="nc bnc" id="L2927" title="All 4 branches missed.">                if (newValue != null &amp;&amp; newValue instanceof ListSelectionModel) {</span>
<span class="nc" id="L2928">                    ((ListSelectionModel) newValue).addListSelectionListener(this);</span>
                }

<span class="nc" id="L2931">                firePropertyChange(</span>
                    AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,
<span class="nc" id="L2933">                    Boolean.valueOf(false), Boolean.valueOf(true));</span>
            }
<span class="nc" id="L2935">        }</span>

        /**
         * List Selection Listener value change method. Used to fire
         * the property change
         *
         * @param e ListSelectionEvent
         *
         */
        public void valueChanged(ListSelectionEvent e) {
<span class="nc" id="L2945">            int oldLeadSelectionIndex = leadSelectionIndex;</span>
<span class="nc" id="L2946">            leadSelectionIndex = JList.this.getLeadSelectionIndex();</span>
<span class="nc bnc" id="L2947" title="All 2 branches missed.">            if (oldLeadSelectionIndex != leadSelectionIndex) {</span>
                Accessible oldLS, newLS;
<span class="nc bnc" id="L2949" title="All 2 branches missed.">                oldLS = (oldLeadSelectionIndex &gt;= 0)</span>
<span class="nc" id="L2950">                        ? getAccessibleChild(oldLeadSelectionIndex)</span>
                        : null;
<span class="nc bnc" id="L2952" title="All 2 branches missed.">                newLS = (leadSelectionIndex &gt;= 0)</span>
<span class="nc" id="L2953">                        ? getAccessibleChild(leadSelectionIndex)</span>
                        : null;
<span class="nc" id="L2955">                firePropertyChange(AccessibleContext.ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY,</span>
                                   oldLS, newLS);
            }

<span class="nc" id="L2959">            firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
<span class="nc" id="L2960">                               Boolean.valueOf(false), Boolean.valueOf(true));</span>
<span class="nc" id="L2961">            firePropertyChange(AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,</span>
<span class="nc" id="L2962">                               Boolean.valueOf(false), Boolean.valueOf(true));</span>

            // Process the State changes for Multiselectable
<span class="nc" id="L2965">            AccessibleStateSet s = getAccessibleStateSet();</span>
<span class="nc" id="L2966">            ListSelectionModel lsm = JList.this.getSelectionModel();</span>
<span class="nc bnc" id="L2967" title="All 2 branches missed.">            if (lsm.getSelectionMode() != ListSelectionModel.SINGLE_SELECTION) {</span>
<span class="nc bnc" id="L2968" title="All 2 branches missed.">                if (!s.contains(AccessibleState.MULTISELECTABLE)) {</span>
<span class="nc" id="L2969">                    s.add(AccessibleState.MULTISELECTABLE);</span>
<span class="nc" id="L2970">                    firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,</span>
                                       null, AccessibleState.MULTISELECTABLE);
                }
            } else {
<span class="nc bnc" id="L2974" title="All 2 branches missed.">                if (s.contains(AccessibleState.MULTISELECTABLE)) {</span>
<span class="nc" id="L2975">                    s.remove(AccessibleState.MULTISELECTABLE);</span>
<span class="nc" id="L2976">                    firePropertyChange(AccessibleContext.ACCESSIBLE_STATE_PROPERTY,</span>
                                       AccessibleState.MULTISELECTABLE, null);
                }
            }
<span class="nc" id="L2980">        }</span>

        /**
         * List Data Listener interval added method. Used to fire the visible data property change
         *
         * @param e ListDataEvent
         *
         */
        public void intervalAdded(ListDataEvent e) {
<span class="nc" id="L2989">            firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
<span class="nc" id="L2990">                               Boolean.valueOf(false), Boolean.valueOf(true));</span>
<span class="nc" id="L2991">        }</span>

        /**
         * List Data Listener interval removed method. Used to fire the visible data property change
         *
         * @param e ListDataEvent
         *
         */
        public void intervalRemoved(ListDataEvent e) {
<span class="nc" id="L3000">            firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
<span class="nc" id="L3001">                               Boolean.valueOf(false), Boolean.valueOf(true));</span>
<span class="nc" id="L3002">        }</span>

        /**
         * List Data Listener contents changed method. Used to fire the visible data property change
         *
         * @param e ListDataEvent
         *
         */
         public void contentsChanged(ListDataEvent e) {
<span class="nc" id="L3011">             firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,</span>
<span class="nc" id="L3012">                                Boolean.valueOf(false), Boolean.valueOf(true));</span>
<span class="nc" id="L3013">         }</span>

    // AccessibleContext methods

        /**
         * Get the state set of this object.
         *
         * @return an instance of AccessibleState containing the current state
         * of the object
         * @see AccessibleState
         */
        public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L3025">            AccessibleStateSet states = super.getAccessibleStateSet();</span>
<span class="nc bnc" id="L3026" title="All 2 branches missed.">            if (selectionModel.getSelectionMode() !=</span>
                ListSelectionModel.SINGLE_SELECTION) {
<span class="nc" id="L3028">                states.add(AccessibleState.MULTISELECTABLE);</span>
            }
<span class="nc" id="L3030">            return states;</span>
        }

        /**
         * Get the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of the
         * object
         * @see AccessibleRole
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L3041">            return AccessibleRole.LIST;</span>
        }

        /**
         * Returns the &lt;code&gt;Accessible&lt;/code&gt; child contained at
         * the local coordinate &lt;code&gt;Point&lt;/code&gt;, if one exists.
         * Otherwise returns &lt;code&gt;null&lt;/code&gt;.
         *
         * @return the &lt;code&gt;Accessible&lt;/code&gt; at the specified
         *    location, if it exists
         */
        public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L3053">            int i = locationToIndex(p);</span>
<span class="nc bnc" id="L3054" title="All 2 branches missed.">            if (i &gt;= 0) {</span>
<span class="nc" id="L3055">                return new AccessibleJListChild(JList.this, i);</span>
            } else {
<span class="nc" id="L3057">                return null;</span>
            }
        }

        /**
         * Returns the number of accessible children in the object.  If all
         * of the children of this object implement Accessible, than this
         * method should return the number of children of this object.
         *
         * @return the number of accessible children in the object.
         */
        public int getAccessibleChildrenCount() {
<span class="nc" id="L3069">            return getModel().getSize();</span>
        }

        /**
         * Return the nth Accessible child of the object.
         *
         * @param i zero-based index of child
         * @return the nth Accessible child of the object
         */
        public Accessible getAccessibleChild(int i) {
<span class="nc bnc" id="L3079" title="All 2 branches missed.">            if (i &gt;= getModel().getSize()) {</span>
<span class="nc" id="L3080">                return null;</span>
            } else {
<span class="nc" id="L3082">                return new AccessibleJListChild(JList.this, i);</span>
            }
        }

        /**
         * Get the AccessibleSelection associated with this object.  In the
         * implementation of the Java Accessibility API for this class,
         * return this object, which is responsible for implementing the
         * AccessibleSelection interface on behalf of itself.
         *
         * @return this object
         */
        public AccessibleSelection getAccessibleSelection() {
<span class="nc" id="L3095">            return this;</span>
        }


    // AccessibleSelection methods

        /**
         * Returns the number of items currently selected.
         * If no items are selected, the return value will be 0.
         *
         * @return the number of items currently selected.
         */
         public int getAccessibleSelectionCount() {
<span class="nc" id="L3108">             return JList.this.getSelectedIndices().length;</span>
         }

        /**
         * Returns an Accessible representing the specified selected item
         * in the object.  If there isn't a selection, or there are
         * fewer items selected than the integer passed in, the return
         * value will be &lt;code&gt;null&lt;/code&gt;.
         *
         * @param i the zero-based index of selected items
         * @return an Accessible containing the selected item
         */
         public Accessible getAccessibleSelection(int i) {
<span class="nc" id="L3121">             int len = getAccessibleSelectionCount();</span>
<span class="nc bnc" id="L3122" title="All 4 branches missed.">             if (i &lt; 0 || i &gt;= len) {</span>
<span class="nc" id="L3123">                 return null;</span>
             } else {
<span class="nc" id="L3125">                 return getAccessibleChild(JList.this.getSelectedIndices()[i]);</span>
             }
         }

        /**
         * Returns true if the current child of this object is selected.
         *
         * @param i the zero-based index of the child in this Accessible
         * object.
         * @see AccessibleContext#getAccessibleChild
         */
        public boolean isAccessibleChildSelected(int i) {
<span class="nc" id="L3137">            return isSelectedIndex(i);</span>
        }

        /**
         * Adds the specified selected item in the object to the object's
         * selection.  If the object supports multiple selections,
         * the specified item is added to any existing selection, otherwise
         * it replaces any existing selection in the object.  If the
         * specified item is already selected, this method has no effect.
         *
         * @param i the zero-based index of selectable items
         */
         public void addAccessibleSelection(int i) {
<span class="nc" id="L3150">             JList.this.addSelectionInterval(i, i);</span>
<span class="nc" id="L3151">         }</span>

        /**
         * Removes the specified selected item in the object from the object's
         * selection.  If the specified item isn't currently selected, this
         * method has no effect.
         *
         * @param i the zero-based index of selectable items
         */
         public void removeAccessibleSelection(int i) {
<span class="nc" id="L3161">             JList.this.removeSelectionInterval(i, i);</span>
<span class="nc" id="L3162">         }</span>

        /**
         * Clears the selection in the object, so that nothing in the
         * object is selected.
         */
         public void clearAccessibleSelection() {
<span class="nc" id="L3169">             JList.this.clearSelection();</span>
<span class="nc" id="L3170">         }</span>

        /**
         * Causes every selected item in the object to be selected
         * if the object supports multiple selections.
         */
         public void selectAllAccessibleSelection() {
<span class="nc" id="L3177">             JList.this.addSelectionInterval(0, getAccessibleChildrenCount() -1);</span>
<span class="nc" id="L3178">         }</span>

          /**
           * This class implements accessibility support appropriate
           * for list children.
           */
        protected class AccessibleJListChild extends AccessibleContext
                implements Accessible, AccessibleComponent {
<span class="nc" id="L3186">            private JList&lt;E&gt;     parent = null;</span>
            private int       indexInParent;
<span class="nc" id="L3188">            private Component component = null;</span>
<span class="nc" id="L3189">            private AccessibleContext accessibleContext = null;</span>
            private ListModel&lt;E&gt; listModel;
<span class="nc" id="L3191">            private ListCellRenderer&lt;? super E&gt; cellRenderer = null;</span>

<span class="nc" id="L3193">            public AccessibleJListChild(JList&lt;E&gt; parent, int indexInParent) {</span>
<span class="nc" id="L3194">                this.parent = parent;</span>
<span class="nc" id="L3195">                this.setAccessibleParent(parent);</span>
<span class="nc" id="L3196">                this.indexInParent = indexInParent;</span>
<span class="nc bnc" id="L3197" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L3198">                    listModel = parent.getModel();</span>
<span class="nc" id="L3199">                    cellRenderer = parent.getCellRenderer();</span>
                }
<span class="nc" id="L3201">            }</span>

            private Component getCurrentComponent() {
<span class="nc" id="L3204">                return getComponentAtIndex(indexInParent);</span>
            }

            private AccessibleContext getCurrentAccessibleContext() {
<span class="nc" id="L3208">                Component c = getComponentAtIndex(indexInParent);</span>
<span class="nc bnc" id="L3209" title="All 2 branches missed.">                if (c instanceof Accessible) {</span>
<span class="nc" id="L3210">                    return c.getAccessibleContext();</span>
                } else {
<span class="nc" id="L3212">                    return null;</span>
                }
            }

            private Component getComponentAtIndex(int index) {
<span class="nc bnc" id="L3217" title="All 4 branches missed.">                if (index &lt; 0 || index &gt;= listModel.getSize()) {</span>
<span class="nc" id="L3218">                    return null;</span>
                }
<span class="nc bnc" id="L3220" title="All 6 branches missed.">                if ((parent != null)</span>
                        &amp;&amp; (listModel != null)
                        &amp;&amp; cellRenderer != null) {
<span class="nc" id="L3223">                    E value = listModel.getElementAt(index);</span>
<span class="nc" id="L3224">                    boolean isSelected = parent.isSelectedIndex(index);</span>
<span class="nc bnc" id="L3225" title="All 2 branches missed.">                    boolean isFocussed = parent.isFocusOwner()</span>
<span class="nc bnc" id="L3226" title="All 2 branches missed.">                            &amp;&amp; (index == parent.getLeadSelectionIndex());</span>
<span class="nc" id="L3227">                    return cellRenderer.getListCellRendererComponent(</span>
                            parent,
                            value,
                            index,
                            isSelected,
                            isFocussed);
                } else {
<span class="nc" id="L3234">                    return null;</span>
                }
            }


            // Accessible Methods
           /**
            * Get the AccessibleContext for this object. In the
            * implementation of the Java Accessibility API for this class,
            * returns this object, which is its own AccessibleContext.
            *
            * @return this object
            */
            public AccessibleContext getAccessibleContext() {
<span class="nc" id="L3248">                return this;</span>
            }


            // AccessibleContext methods

            public String getAccessibleName() {
<span class="nc" id="L3255">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3256" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3257">                    return ac.getAccessibleName();</span>
                } else {
<span class="nc" id="L3259">                    return null;</span>
                }
            }

            public void setAccessibleName(String s) {
<span class="nc" id="L3264">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3265" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3266">                    ac.setAccessibleName(s);</span>
                }
<span class="nc" id="L3268">            }</span>

            public String getAccessibleDescription() {
<span class="nc" id="L3271">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3272" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3273">                    return ac.getAccessibleDescription();</span>
                } else {
<span class="nc" id="L3275">                    return null;</span>
                }
            }

            public void setAccessibleDescription(String s) {
<span class="nc" id="L3280">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3281" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3282">                    ac.setAccessibleDescription(s);</span>
                }
<span class="nc" id="L3284">            }</span>

            public AccessibleRole getAccessibleRole() {
<span class="nc" id="L3287">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3288" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3289">                    return ac.getAccessibleRole();</span>
                } else {
<span class="nc" id="L3291">                    return null;</span>
                }
            }

            public AccessibleStateSet getAccessibleStateSet() {
<span class="nc" id="L3296">                AccessibleContext ac = getCurrentAccessibleContext();</span>
                AccessibleStateSet s;
<span class="nc bnc" id="L3298" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3299">                    s = ac.getAccessibleStateSet();</span>
                } else {
<span class="nc" id="L3301">                    s = new AccessibleStateSet();</span>
                }

<span class="nc" id="L3304">                s.add(AccessibleState.SELECTABLE);</span>
<span class="nc bnc" id="L3305" title="All 2 branches missed.">                if (parent.isFocusOwner()</span>
<span class="nc bnc" id="L3306" title="All 2 branches missed.">                    &amp;&amp; (indexInParent == parent.getLeadSelectionIndex())) {</span>
<span class="nc" id="L3307">                    s.add(AccessibleState.ACTIVE);</span>
                }
<span class="nc bnc" id="L3309" title="All 2 branches missed.">                if (parent.isSelectedIndex(indexInParent)) {</span>
<span class="nc" id="L3310">                    s.add(AccessibleState.SELECTED);</span>
                }
<span class="nc bnc" id="L3312" title="All 2 branches missed.">                if (this.isShowing()) {</span>
<span class="nc" id="L3313">                    s.add(AccessibleState.SHOWING);</span>
<span class="nc bnc" id="L3314" title="All 2 branches missed.">                } else if (s.contains(AccessibleState.SHOWING)) {</span>
<span class="nc" id="L3315">                    s.remove(AccessibleState.SHOWING);</span>
                }
<span class="nc bnc" id="L3317" title="All 2 branches missed.">                if (this.isVisible()) {</span>
<span class="nc" id="L3318">                    s.add(AccessibleState.VISIBLE);</span>
<span class="nc bnc" id="L3319" title="All 2 branches missed.">                } else if (s.contains(AccessibleState.VISIBLE)) {</span>
<span class="nc" id="L3320">                    s.remove(AccessibleState.VISIBLE);</span>
                }
<span class="nc" id="L3322">                s.add(AccessibleState.TRANSIENT); // cell-rendered</span>
<span class="nc" id="L3323">                return s;</span>
            }

            public int getAccessibleIndexInParent() {
<span class="nc" id="L3327">                return indexInParent;</span>
            }

            public int getAccessibleChildrenCount() {
<span class="nc" id="L3331">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3332" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3333">                    return ac.getAccessibleChildrenCount();</span>
                } else {
<span class="nc" id="L3335">                    return 0;</span>
                }
            }

            public Accessible getAccessibleChild(int i) {
<span class="nc" id="L3340">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3341" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3342">                    Accessible accessibleChild = ac.getAccessibleChild(i);</span>
<span class="nc" id="L3343">                    ac.setAccessibleParent(this);</span>
<span class="nc" id="L3344">                    return accessibleChild;</span>
                } else {
<span class="nc" id="L3346">                    return null;</span>
                }
            }

            public Locale getLocale() {
<span class="nc" id="L3351">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3352" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3353">                    return ac.getLocale();</span>
                } else {
<span class="nc" id="L3355">                    return null;</span>
                }
            }

            public void addPropertyChangeListener(PropertyChangeListener l) {
<span class="nc" id="L3360">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3361" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3362">                    ac.addPropertyChangeListener(l);</span>
                }
<span class="nc" id="L3364">            }</span>

            public void removePropertyChangeListener(PropertyChangeListener l) {
<span class="nc" id="L3367">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3368" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3369">                    ac.removePropertyChangeListener(l);</span>
                }
<span class="nc" id="L3371">            }</span>

            public AccessibleAction getAccessibleAction() {
<span class="nc" id="L3374">                return getCurrentAccessibleContext().getAccessibleAction();</span>
            }

           /**
            * Get the AccessibleComponent associated with this object.  In the
            * implementation of the Java Accessibility API for this class,
            * return this object, which is responsible for implementing the
            * AccessibleComponent interface on behalf of itself.
            *
            * @return this object
            */
            public AccessibleComponent getAccessibleComponent() {
<span class="nc" id="L3386">                return this; // to override getBounds()</span>
            }

            public AccessibleSelection getAccessibleSelection() {
<span class="nc" id="L3390">                return getCurrentAccessibleContext().getAccessibleSelection();</span>
            }

            public AccessibleText getAccessibleText() {
<span class="nc" id="L3394">                return getCurrentAccessibleContext().getAccessibleText();</span>
            }

            public AccessibleValue getAccessibleValue() {
<span class="nc" id="L3398">                return getCurrentAccessibleContext().getAccessibleValue();</span>
            }


            // AccessibleComponent methods

            public Color getBackground() {
<span class="nc" id="L3405">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3406" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3407">                    return ((AccessibleComponent) ac).getBackground();</span>
                } else {
<span class="nc" id="L3409">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3410" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3411">                        return c.getBackground();</span>
                    } else {
<span class="nc" id="L3413">                        return null;</span>
                    }
                }
            }

            public void setBackground(Color c) {
<span class="nc" id="L3419">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3420" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3421">                    ((AccessibleComponent) ac).setBackground(c);</span>
                } else {
<span class="nc" id="L3423">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L3424" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L3425">                        cp.setBackground(c);</span>
                    }
                }
<span class="nc" id="L3428">            }</span>

            public Color getForeground() {
<span class="nc" id="L3431">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3432" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3433">                    return ((AccessibleComponent) ac).getForeground();</span>
                } else {
<span class="nc" id="L3435">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3436" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3437">                        return c.getForeground();</span>
                    } else {
<span class="nc" id="L3439">                        return null;</span>
                    }
                }
            }

            public void setForeground(Color c) {
<span class="nc" id="L3445">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3446" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3447">                    ((AccessibleComponent) ac).setForeground(c);</span>
                } else {
<span class="nc" id="L3449">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L3450" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L3451">                        cp.setForeground(c);</span>
                    }
                }
<span class="nc" id="L3454">            }</span>

            public Cursor getCursor() {
<span class="nc" id="L3457">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3458" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3459">                    return ((AccessibleComponent) ac).getCursor();</span>
                } else {
<span class="nc" id="L3461">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3462" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3463">                        return c.getCursor();</span>
                    } else {
<span class="nc" id="L3465">                        Accessible ap = getAccessibleParent();</span>
<span class="nc bnc" id="L3466" title="All 2 branches missed.">                        if (ap instanceof AccessibleComponent) {</span>
<span class="nc" id="L3467">                            return ((AccessibleComponent) ap).getCursor();</span>
                        } else {
<span class="nc" id="L3469">                            return null;</span>
                        }
                    }
                }
            }

            public void setCursor(Cursor c) {
<span class="nc" id="L3476">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3477" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3478">                    ((AccessibleComponent) ac).setCursor(c);</span>
                } else {
<span class="nc" id="L3480">                    Component cp = getCurrentComponent();</span>
<span class="nc bnc" id="L3481" title="All 2 branches missed.">                    if (cp != null) {</span>
<span class="nc" id="L3482">                        cp.setCursor(c);</span>
                    }
                }
<span class="nc" id="L3485">            }</span>

            public Font getFont() {
<span class="nc" id="L3488">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3489" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3490">                    return ((AccessibleComponent) ac).getFont();</span>
                } else {
<span class="nc" id="L3492">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3493" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3494">                        return c.getFont();</span>
                    } else {
<span class="nc" id="L3496">                        return null;</span>
                    }
                }
            }

            public void setFont(Font f) {
<span class="nc" id="L3502">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3503" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3504">                    ((AccessibleComponent) ac).setFont(f);</span>
                } else {
<span class="nc" id="L3506">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3507" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3508">                        c.setFont(f);</span>
                    }
                }
<span class="nc" id="L3511">            }</span>

            public FontMetrics getFontMetrics(Font f) {
<span class="nc" id="L3514">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3516">                    return ((AccessibleComponent) ac).getFontMetrics(f);</span>
                } else {
<span class="nc" id="L3518">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3519" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3520">                        return c.getFontMetrics(f);</span>
                    } else {
<span class="nc" id="L3522">                        return null;</span>
                    }
                }
            }

            public boolean isEnabled() {
<span class="nc" id="L3528">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3529" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3530">                    return ((AccessibleComponent) ac).isEnabled();</span>
                } else {
<span class="nc" id="L3532">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3533" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3534">                        return c.isEnabled();</span>
                    } else {
<span class="nc" id="L3536">                        return false;</span>
                    }
                }
            }

            public void setEnabled(boolean b) {
<span class="nc" id="L3542">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3543" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3544">                    ((AccessibleComponent) ac).setEnabled(b);</span>
                } else {
<span class="nc" id="L3546">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3547" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3548">                        c.setEnabled(b);</span>
                    }
                }
<span class="nc" id="L3551">            }</span>

            public boolean isVisible() {
<span class="nc" id="L3554">                int fi = parent.getFirstVisibleIndex();</span>
<span class="nc" id="L3555">                int li = parent.getLastVisibleIndex();</span>
                // The UI incorrectly returns a -1 for the last
                // visible index if the list is smaller than the
                // viewport size.
<span class="nc bnc" id="L3559" title="All 2 branches missed.">                if (li == -1) {</span>
<span class="nc" id="L3560">                    li = parent.getModel().getSize() - 1;</span>
                }
<span class="nc bnc" id="L3562" title="All 4 branches missed.">                return ((indexInParent &gt;= fi)</span>
                        &amp;&amp; (indexInParent &lt;= li));
            }

            public void setVisible(boolean b) {
<span class="nc" id="L3567">            }</span>

            public boolean isShowing() {
<span class="nc bnc" id="L3570" title="All 4 branches missed.">                return (parent.isShowing() &amp;&amp; isVisible());</span>
            }

            public boolean contains(Point p) {
<span class="nc" id="L3574">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3575" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3576">                    Rectangle r = ((AccessibleComponent) ac).getBounds();</span>
<span class="nc" id="L3577">                    return r.contains(p);</span>
                } else {
<span class="nc" id="L3579">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3580" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3581">                        Rectangle r = c.getBounds();</span>
<span class="nc" id="L3582">                        return r.contains(p);</span>
                    } else {
<span class="nc" id="L3584">                        return getBounds().contains(p);</span>
                    }
                }
            }

            public Point getLocationOnScreen() {
<span class="nc bnc" id="L3590" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L3591">                    Point listLocation = parent.getLocationOnScreen();</span>
<span class="nc" id="L3592">                    Point componentLocation = parent.indexToLocation(indexInParent);</span>
<span class="nc bnc" id="L3593" title="All 2 branches missed.">                    if (componentLocation != null) {</span>
<span class="nc" id="L3594">                        componentLocation.translate(listLocation.x, listLocation.y);</span>
<span class="nc" id="L3595">                        return componentLocation;</span>
                    } else {
<span class="nc" id="L3597">                        return null;</span>
                    }
                } else {
<span class="nc" id="L3600">                    return null;</span>
                }
            }

            public Point getLocation() {
<span class="nc bnc" id="L3605" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L3606">                    return parent.indexToLocation(indexInParent);</span>
                } else {
<span class="nc" id="L3608">                    return null;</span>
                }
            }

            public void setLocation(Point p) {
<span class="nc bnc" id="L3613" title="All 4 branches missed.">                if ((parent != null)  &amp;&amp; (parent.contains(p))) {</span>
<span class="nc" id="L3614">                    ensureIndexIsVisible(indexInParent);</span>
                }
<span class="nc" id="L3616">            }</span>

            public Rectangle getBounds() {
<span class="nc bnc" id="L3619" title="All 2 branches missed.">                if (parent != null) {</span>
<span class="nc" id="L3620">                    return parent.getCellBounds(indexInParent,indexInParent);</span>
                } else {
<span class="nc" id="L3622">                    return null;</span>
                }
            }

            public void setBounds(Rectangle r) {
<span class="nc" id="L3627">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3628" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3629">                    ((AccessibleComponent) ac).setBounds(r);</span>
                }
<span class="nc" id="L3631">            }</span>

            public Dimension getSize() {
<span class="nc" id="L3634">                Rectangle cellBounds = this.getBounds();</span>
<span class="nc bnc" id="L3635" title="All 2 branches missed.">                if (cellBounds != null) {</span>
<span class="nc" id="L3636">                    return cellBounds.getSize();</span>
                } else {
<span class="nc" id="L3638">                    return null;</span>
                }
            }

            public void setSize (Dimension d) {
<span class="nc" id="L3643">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3644" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3645">                    ((AccessibleComponent) ac).setSize(d);</span>
                } else {
<span class="nc" id="L3647">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3648" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3649">                        c.setSize(d);</span>
                    }
                }
<span class="nc" id="L3652">            }</span>

            public Accessible getAccessibleAt(Point p) {
<span class="nc" id="L3655">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3656" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3657">                    return ((AccessibleComponent) ac).getAccessibleAt(p);</span>
                } else {
<span class="nc" id="L3659">                    return null;</span>
                }
            }

            public boolean isFocusTraversable() {
<span class="nc" id="L3664">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3665" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3666">                    return ((AccessibleComponent) ac).isFocusTraversable();</span>
                } else {
<span class="nc" id="L3668">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3669" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3670">                        return c.isFocusTraversable();</span>
                    } else {
<span class="nc" id="L3672">                        return false;</span>
                    }
                }
            }

            public void requestFocus() {
<span class="nc" id="L3678">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3679" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3680">                    ((AccessibleComponent) ac).requestFocus();</span>
                } else {
<span class="nc" id="L3682">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3683" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3684">                        c.requestFocus();</span>
                    }
                }
<span class="nc" id="L3687">            }</span>

            public void addFocusListener(FocusListener l) {
<span class="nc" id="L3690">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3691" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3692">                    ((AccessibleComponent) ac).addFocusListener(l);</span>
                } else {
<span class="nc" id="L3694">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3695" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3696">                        c.addFocusListener(l);</span>
                    }
                }
<span class="nc" id="L3699">            }</span>

            public void removeFocusListener(FocusListener l) {
<span class="nc" id="L3702">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3703" title="All 2 branches missed.">                if (ac instanceof AccessibleComponent) {</span>
<span class="nc" id="L3704">                    ((AccessibleComponent) ac).removeFocusListener(l);</span>
                } else {
<span class="nc" id="L3706">                    Component c = getCurrentComponent();</span>
<span class="nc bnc" id="L3707" title="All 2 branches missed.">                    if (c != null) {</span>
<span class="nc" id="L3708">                        c.removeFocusListener(l);</span>
                    }
                }
<span class="nc" id="L3711">            }</span>

            // TIGER - 4733624
            /**
             * Returns the icon for the element renderer, as the only item
             * of an array of &lt;code&gt;AccessibleIcon&lt;/code&gt;s or a &lt;code&gt;null&lt;/code&gt; array
             * if the renderer component contains no icons.
             *
             * @return an array containing the accessible icon
             *         or a &lt;code&gt;null&lt;/code&gt; array if none
             * @since 1.3
             */
            public AccessibleIcon [] getAccessibleIcon() {
<span class="nc" id="L3724">                AccessibleContext ac = getCurrentAccessibleContext();</span>
<span class="nc bnc" id="L3725" title="All 2 branches missed.">                if (ac != null) {</span>
<span class="nc" id="L3726">                    return ac.getAccessibleIcon();</span>
                } else {
<span class="nc" id="L3728">                    return null;</span>
                }
            }
        } // inner class AccessibleJListChild
    } // inner class AccessibleJList
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>