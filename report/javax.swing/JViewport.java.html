<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JViewport.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Foo</a> &gt; <a href="index.html" class="el_package">javax.swing</a> &gt; <span class="el_source">JViewport.java</span></div><h1>JViewport.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the &quot;Classpath&quot; exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

package javax.swing;

import sun.swing.JLightweightFrame;

import java.awt.*;
import java.awt.event.*;
import java.awt.peer.ComponentPeer;
import java.beans.Transient;
import javax.swing.plaf.ViewportUI;

import javax.swing.event.*;
import javax.swing.border.*;
import javax.accessibility.*;


import java.io.Serializable;


/**
 * The &quot;viewport&quot; or &quot;porthole&quot; through which you see the underlying
 * information. When you scroll, what moves is the viewport. It is like
 * peering through a camera's viewfinder. Moving the viewfinder upwards
 * brings new things into view at the top of the picture and loses
 * things that were at the bottom.
 * &lt;p&gt;
 * By default, &lt;code&gt;JViewport&lt;/code&gt; is opaque. To change this, use the
 * &lt;code&gt;setOpaque&lt;/code&gt; method.
 * &lt;p&gt;
 * &lt;b&gt;NOTE:&lt;/b&gt;We have implemented a faster scrolling algorithm that
 * does not require a buffer to draw in. The algorithm works as follows:
 * &lt;ol&gt;&lt;li&gt;The view and parent view and checked to see if they are
 * &lt;code&gt;JComponents&lt;/code&gt;,
 * if they aren't, stop and repaint the whole viewport.
 * &lt;li&gt;If the viewport is obscured by an ancestor, stop and repaint the whole
 * viewport.
 * &lt;li&gt;Compute the region that will become visible, if it is as big as
 * the viewport, stop and repaint the whole view region.
 * &lt;li&gt;Obtain the ancestor &lt;code&gt;Window&lt;/code&gt;'s graphics and
 * do a &lt;code&gt;copyArea&lt;/code&gt; on the scrolled region.
 * &lt;li&gt;Message the view to repaint the newly visible region.
 * &lt;li&gt;The next time paint is invoked on the viewport, if the clip region
 * is smaller than the viewport size a timer is kicked off to repaint the
 * whole region.
 * &lt;/ol&gt;
 * In general this approach is much faster. Compared to the backing store
 * approach this avoids the overhead of maintaining an offscreen buffer and
 * having to do two &lt;code&gt;copyArea&lt;/code&gt;s.
 * Compared to the non backing store case this
 * approach will greatly reduce the painted region.
 * &lt;p&gt;
 * This approach can cause slower times than the backing store approach
 * when the viewport is obscured by another window, or partially offscreen.
 * When another window
 * obscures the viewport the copyArea will copy garbage and a
 * paint event will be generated by the system to inform us we need to
 * paint the newly exposed region. The only way to handle this is to
 * repaint the whole viewport, which can cause slower performance than the
 * backing store case. In most applications very rarely will the user be
 * scrolling while the viewport is obscured by another window or offscreen,
 * so this optimization is usually worth the performance hit when obscured.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt; Swing is not thread safe. For more
 * information see &lt;a
 * href=&quot;package-summary.html#threading&quot;&gt;Swing's Threading
 * Policy&lt;/a&gt;.
 * &lt;p&gt;
 * &lt;strong&gt;Warning:&lt;/strong&gt;
 * Serialized objects of this class will not be compatible with
 * future Swing releases. The current serialization support is
 * appropriate for short term storage or RMI between applications running
 * the same version of Swing.  As of 1.4, support for long term storage
 * of all JavaBeans&amp;trade;
 * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
 * Please see {@link java.beans.XMLEncoder}.
 *
 * @author Hans Muller
 * @author Philip Milne
 * @see JScrollPane
 */
public class JViewport extends JComponent implements Accessible
{
    /**
     * @see #getUIClassID
     * @see #readObject
     */
    private static final String uiClassID = &quot;ViewportUI&quot;;

    /** Property used to indicate window blitting should not be done.
     */
<span class="nc" id="L115">    static final Object EnableWindowBlit = &quot;EnableWindowBlit&quot;;</span>

    /**
     * True when the viewport dimensions have been determined.
     * The default is false.
     */
<span class="nc" id="L121">    protected boolean isViewSizeSet = false;</span>

    /**
     * The last &lt;code&gt;viewPosition&lt;/code&gt; that we've painted, so we know how
     * much of the backing store image is valid.
     */
<span class="nc" id="L127">    protected Point lastPaintPosition = null;</span>

    /**
     * True when this viewport is maintaining an offscreen image of its
     * contents, so that some scrolling can take place using fast &quot;bit-blit&quot;
     * operations instead of by accessing the view object to construct the
     * display.  The default is &lt;code&gt;false&lt;/code&gt;.
     *
     * @deprecated As of Java 2 platform v1.3
     * @see #setScrollMode
     */
<span class="nc" id="L138">    @Deprecated</span>
    protected boolean backingStore = false;

    /** The view image used for a backing store. */
<span class="nc" id="L142">    transient protected Image backingStoreImage = null;</span>

    /**
     * The &lt;code&gt;scrollUnderway&lt;/code&gt; flag is used for components like
     * &lt;code&gt;JList&lt;/code&gt;.  When the downarrow key is pressed on a
     * &lt;code&gt;JList&lt;/code&gt; and the selected
     * cell is the last in the list, the &lt;code&gt;scrollpane&lt;/code&gt; autoscrolls.
     * Here, the old selected cell needs repainting and so we need
     * a flag to make the viewport do the optimized painting
     * only when there is an explicit call to
     * &lt;code&gt;setViewPosition(Point)&lt;/code&gt;.
     * When &lt;code&gt;setBounds&lt;/code&gt; is called through other routes,
     * the flag is off and the view repaints normally.  Another approach
     * would be to remove this from the &lt;code&gt;JViewport&lt;/code&gt;
     * class and have the &lt;code&gt;JList&lt;/code&gt; manage this case by using
     * &lt;code&gt;setBackingStoreEnabled&lt;/code&gt;.  The default is
     * &lt;code&gt;false&lt;/code&gt;.
     */
<span class="nc" id="L160">    protected boolean scrollUnderway = false;</span>

    /*
     * Listener that is notified each time the view changes size.
     */
<span class="nc" id="L165">    private ComponentListener viewListener = null;</span>

    /* Only one &lt;code&gt;ChangeEvent&lt;/code&gt; is needed per
     * &lt;code&gt;JViewport&lt;/code&gt; instance since the
     * event's only (read-only) state is the source property.  The source
     * of events generated here is always &quot;this&quot;.
     */
<span class="nc" id="L172">    private transient ChangeEvent changeEvent = null;</span>

    /**
      * Use &lt;code&gt;graphics.copyArea&lt;/code&gt; to implement scrolling.
      * This is the fastest for most applications.
      *
      * @see #setScrollMode
      * @since 1.3
      */
    public static final int BLIT_SCROLL_MODE = 1;

    /**
      * Draws viewport contents into an offscreen image.
      * This was previously the default mode for &lt;code&gt;JTable&lt;/code&gt;.
      * This mode may offer advantages over &quot;blit mode&quot;
      * in some cases, but it requires a large chunk of extra RAM.
      *
      * @see #setScrollMode
      * @since 1.3
      */
    public static final int BACKINGSTORE_SCROLL_MODE = 2;

    /**
      * This mode uses the very simple method of redrawing the entire
      * contents of the scrollpane each time it is scrolled.
      * This was the default behavior in Swing 1.0 and Swing 1.1.
      * Either of the other two options will provide better performance
      * in most cases.
      *
      * @see #setScrollMode
      * @since 1.3
      */
    public static final int SIMPLE_SCROLL_MODE = 0;

    /**
      * @see #setScrollMode
      * @since 1.3
      */
<span class="nc" id="L210">    private int scrollMode = BLIT_SCROLL_MODE;</span>

    //
    // Window blitting:
    //
    // As mentioned in the javadoc when using windowBlit a paint event
    // will be generated by the system if copyArea copies a non-visible
    // portion of the view (in other words, it copies garbage). We are
    // not guaranteed to receive the paint event before other mouse events,
    // so we can not be sure we haven't already copied garbage a bunch of
    // times to different parts of the view. For that reason when a blit
    // happens and the Component is obscured (the check for obscurity
    // is not supported on all platforms and is checked via ComponentPeer
    // methods) the ivar repaintAll is set to true. When paint is received
    // if repaintAll is true (we previously did a blit) it is set to
    // false, and if the clip region is smaller than the viewport
    // waitingForRepaint is set to true and a timer is started. When
    // the timer fires if waitingForRepaint is true, repaint is invoked.
    // In the mean time, if the view is asked to scroll and waitingForRepaint
    // is true, a blit will not happen, instead the non-backing store case
    // of scrolling will happen, which will reset waitingForRepaint.
    // waitingForRepaint is set to false in paint when the clip rect is
    // bigger (or equal) to the size of the viewport.
    // A Timer is used instead of just a repaint as it appeared to offer
    // better performance.


    /**
     * This is set to true in &lt;code&gt;setViewPosition&lt;/code&gt;
     * if doing a window blit and the viewport is obscured.
     */
    private transient boolean repaintAll;

    /**
     * This is set to true in paint, if &lt;code&gt;repaintAll&lt;/code&gt;
     * is true and the clip rectangle does not match the bounds.
     * If true, and scrolling happens the
     * repaint manager is not cleared which then allows for the repaint
     * previously invoked to succeed.
     */
    private transient boolean waitingForRepaint;

    /**
     * Instead of directly invoking repaint, a &lt;code&gt;Timer&lt;/code&gt;
     * is started and when it fires, repaint is invoked.
     */
    private transient Timer repaintTimer;

    /**
     * Set to true in paintView when paint is invoked.
     */
    private transient boolean inBlitPaint;

    /**
     * Whether or not a valid view has been installed.
     */
    private boolean hasHadValidView;

    /**
     * When view is changed we have to synchronize scrollbar values
     * with viewport (see the BasicScrollPaneUI#syncScrollPaneWithViewport method).
     * This flag allows to invoke that method while ScrollPaneLayout#layoutContainer
     * is running.
     */
    private boolean viewChanged;

    /** Creates a &lt;code&gt;JViewport&lt;/code&gt;. */
    public JViewport() {
<span class="nc" id="L278">        super();</span>
<span class="nc" id="L279">        setLayout(createLayoutManager());</span>
<span class="nc" id="L280">        setOpaque(true);</span>
<span class="nc" id="L281">        updateUI();</span>
<span class="nc" id="L282">        setInheritsPopupMenu(true);</span>
<span class="nc" id="L283">    }</span>



    /**
     * Returns the L&amp;amp;F object that renders this component.
     *
     * @return a &lt;code&gt;ViewportUI&lt;/code&gt; object
     * @since 1.3
     */
    public ViewportUI getUI() {
<span class="nc" id="L294">        return (ViewportUI)ui;</span>
    }


    /**
     * Sets the L&amp;amp;F object that renders this component.
     *
     * @param ui  the &lt;code&gt;ViewportUI&lt;/code&gt; L&amp;amp;F object
     * @see UIDefaults#getUI
     * @beaninfo
     *        bound: true
     *       hidden: true
     *    attribute: visualUpdate true
     *  description: The UI object that implements the Component's LookAndFeel.
     * @since 1.3
     */
    public void setUI(ViewportUI ui) {
<span class="nc" id="L311">        super.setUI(ui);</span>
<span class="nc" id="L312">    }</span>


    /**
     * Resets the UI property to a value from the current look and feel.
     *
     * @see JComponent#updateUI
     */
    public void updateUI() {
<span class="nc" id="L321">        setUI((ViewportUI)UIManager.getUI(this));</span>
<span class="nc" id="L322">    }</span>


    /**
     * Returns a string that specifies the name of the L&amp;amp;F class
     * that renders this component.
     *
     * @return the string &quot;ViewportUI&quot;
     *
     * @see JComponent#getUIClassID
     * @see UIDefaults#getUI
     */
    public String getUIClassID() {
<span class="nc" id="L335">        return uiClassID;</span>
    }


    /**
     * Sets the &lt;code&gt;JViewport&lt;/code&gt;'s one lightweight child,
     * which can be &lt;code&gt;null&lt;/code&gt;.
     * (Since there is only one child which occupies the entire viewport,
     * the &lt;code&gt;constraints&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt;
     * arguments are ignored.)
     *
     * @param child       the lightweight &lt;code&gt;child&lt;/code&gt; of the viewport
     * @param constraints the &lt;code&gt;constraints&lt;/code&gt; to be respected
     * @param index       the index
     * @see #setView
     */
    protected void addImpl(Component child, Object constraints, int index) {
<span class="nc" id="L352">      setView(child);</span>
<span class="nc" id="L353">    }</span>


    /**
     * Removes the &lt;code&gt;Viewport&lt;/code&gt;s one lightweight child.
     *
     * @see #setView
     */
    public void remove(Component child) {
<span class="nc" id="L362">        child.removeComponentListener(viewListener);</span>
<span class="nc" id="L363">        super.remove(child);</span>
<span class="nc" id="L364">    }</span>

    @Override
    public void addNotify() {
<span class="nc" id="L368">        super.addNotify();</span>
        // JLightweightFrame does not support BLIT_SCROLL_MODE, so it should be replaced
<span class="nc" id="L370">        Window rootWindow = SwingUtilities.getWindowAncestor(this);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (rootWindow instanceof JLightweightFrame</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                &amp;&amp; getScrollMode() == BLIT_SCROLL_MODE) {</span>
<span class="nc" id="L373">            setScrollMode(BACKINGSTORE_SCROLL_MODE);</span>
        }
<span class="nc" id="L375">    }</span>


    /**
     * Scrolls the view so that &lt;code&gt;Rectangle&lt;/code&gt;
     * within the view becomes visible.
     * &lt;p&gt;
     * This attempts to validate the view before scrolling if the
     * view is currently not valid - &lt;code&gt;isValid&lt;/code&gt; returns false.
     * To avoid excessive validation when the containment hierarchy is
     * being created this will not validate if one of the ancestors does not
     * have a peer, or there is no validate root ancestor, or one of the
     * ancestors is not a &lt;code&gt;Window&lt;/code&gt; or &lt;code&gt;Applet&lt;/code&gt;.
     * &lt;p&gt;
     * Note that this method will not scroll outside of the
     * valid viewport; for example, if &lt;code&gt;contentRect&lt;/code&gt; is larger
     * than the viewport, scrolling will be confined to the viewport's
     * bounds.
     *
     * @param contentRect the &lt;code&gt;Rectangle&lt;/code&gt; to display
     * @see JComponent#isValidateRoot
     * @see java.awt.Component#isValid
     * @see java.awt.Component#getPeer
     */
    public void scrollRectToVisible(Rectangle contentRect) {
<span class="nc" id="L400">        Component view = getView();</span>

<span class="nc bnc" id="L402" title="All 2 branches missed.">        if (view == null) {</span>
<span class="nc" id="L403">            return;</span>
        } else {
<span class="nc bnc" id="L405" title="All 2 branches missed.">            if (!view.isValid()) {</span>
                // If the view is not valid, validate. scrollRectToVisible
                // may fail if the view is not valid first, contentRect
                // could be bigger than invalid size.
<span class="nc" id="L409">                validateView();</span>
            }
            int dx, dy;

<span class="nc" id="L413">            dx = positionAdjustment(getWidth(), contentRect.width, contentRect.x);</span>
<span class="nc" id="L414">            dy = positionAdjustment(getHeight(), contentRect.height, contentRect.y);</span>

<span class="nc bnc" id="L416" title="All 4 branches missed.">            if (dx != 0 || dy != 0) {</span>
<span class="nc" id="L417">                Point viewPosition = getViewPosition();</span>
<span class="nc" id="L418">                Dimension viewSize = view.getSize();</span>
<span class="nc" id="L419">                int startX = viewPosition.x;</span>
<span class="nc" id="L420">                int startY = viewPosition.y;</span>
<span class="nc" id="L421">                Dimension extent = getExtentSize();</span>

<span class="nc" id="L423">                viewPosition.x -= dx;</span>
<span class="nc" id="L424">                viewPosition.y -= dy;</span>
                // Only constrain the location if the view is valid. If the
                // the view isn't valid, it typically indicates the view
                // isn't visible yet and most likely has a bogus size as will
                // we, and therefore we shouldn't constrain the scrolling
<span class="nc bnc" id="L429" title="All 2 branches missed.">                if (view.isValid()) {</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">                    if (getParent().getComponentOrientation().isLeftToRight()) {</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                        if (viewPosition.x + extent.width &gt; viewSize.width) {</span>
<span class="nc" id="L432">                            viewPosition.x = Math.max(0, viewSize.width - extent.width);</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">                        } else if (viewPosition.x &lt; 0) {</span>
<span class="nc" id="L434">                            viewPosition.x = 0;</span>
                        }
                    } else {
<span class="nc bnc" id="L437" title="All 2 branches missed.">                        if (extent.width &gt; viewSize.width) {</span>
<span class="nc" id="L438">                            viewPosition.x = viewSize.width - extent.width;</span>
                        } else {
<span class="nc" id="L440">                            viewPosition.x = Math.max(0, Math.min(viewSize.width - extent.width, viewPosition.x));</span>
                        }
                    }
<span class="nc bnc" id="L443" title="All 2 branches missed.">                    if (viewPosition.y + extent.height &gt; viewSize.height) {</span>
<span class="nc" id="L444">                        viewPosition.y = Math.max(0, viewSize.height -</span>
                                                  extent.height);
                    }
<span class="nc bnc" id="L447" title="All 2 branches missed.">                    else if (viewPosition.y &lt; 0) {</span>
<span class="nc" id="L448">                        viewPosition.y = 0;</span>
                    }
                }
<span class="nc bnc" id="L451" title="All 4 branches missed.">                if (viewPosition.x != startX || viewPosition.y != startY) {</span>
<span class="nc" id="L452">                    setViewPosition(viewPosition);</span>
                    // NOTE: How JViewport currently works with the
                    // backing store is not foolproof. The sequence of
                    // events when setViewPosition
                    // (scrollRectToVisible) is called is to reset the
                    // views bounds, which causes a repaint on the
                    // visible region and sets an ivar indicating
                    // scrolling (scrollUnderway). When
                    // JViewport.paint is invoked if scrollUnderway is
                    // true, the backing store is blitted.  This fails
                    // if between the time setViewPosition is invoked
                    // and paint is received another repaint is queued
                    // indicating part of the view is invalid. There
                    // is no way for JViewport to notice another
                    // repaint has occurred and it ends up blitting
                    // what is now a dirty region and the repaint is
                    // never delivered.
                    // It just so happens JTable encounters this
                    // behavior by way of scrollRectToVisible, for
                    // this reason scrollUnderway is set to false
                    // here, which effectively disables the backing
                    // store.
<span class="nc" id="L474">                    scrollUnderway = false;</span>
                }
            }
        }
<span class="nc" id="L478">    }</span>

    /**
     * Ascends the &lt;code&gt;Viewport&lt;/code&gt;'s parents stopping when
     * a component is found that returns
     * &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;isValidateRoot&lt;/code&gt;.
     * If all the &lt;code&gt;Component&lt;/code&gt;'s  parents are visible,
     * &lt;code&gt;validate&lt;/code&gt; will then be invoked on it. The
     * &lt;code&gt;RepaintManager&lt;/code&gt; is then invoked with
     * &lt;code&gt;removeInvalidComponent&lt;/code&gt;. This
     * is the synchronous version of a &lt;code&gt;revalidate&lt;/code&gt;.
     */
    private void validateView() {
<span class="nc" id="L491">        Component validateRoot = SwingUtilities.getValidateRoot(this, false);</span>

<span class="nc bnc" id="L493" title="All 2 branches missed.">        if (validateRoot == null) {</span>
<span class="nc" id="L494">            return;</span>
        }

        // Validate the root.
<span class="nc" id="L498">        validateRoot.validate();</span>

        // And let the RepaintManager it does not have to validate from
        // validateRoot anymore.
<span class="nc" id="L502">        RepaintManager rm = RepaintManager.currentManager(this);</span>

<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (rm != null) {</span>
<span class="nc" id="L505">            rm.removeInvalidComponent((JComponent)validateRoot);</span>
        }
<span class="nc" id="L507">    }</span>

     /*  Used by the scrollRectToVisible method to determine the
      *  proper direction and amount to move by. The integer variables are named
      *  width, but this method is applicable to height also. The code assumes that
      *  parentWidth/childWidth are positive and childAt can be negative.
      */
    private int positionAdjustment(int parentWidth, int childWidth, int childAt)    {

        //   +-----+
        //   | --- |     No Change
        //   +-----+
<span class="nc bnc" id="L519" title="All 4 branches missed.">        if (childAt &gt;= 0 &amp;&amp; childWidth + childAt &lt;= parentWidth)    {</span>
<span class="nc" id="L520">            return 0;</span>
        }

        //   +-----+
        //  ---------   No Change
        //   +-----+
<span class="nc bnc" id="L526" title="All 4 branches missed.">        if (childAt &lt;= 0 &amp;&amp; childWidth + childAt &gt;= parentWidth) {</span>
<span class="nc" id="L527">            return 0;</span>
        }

        //   +-----+          +-----+
        //   |   ----    -&gt;   | ----|
        //   +-----+          +-----+
<span class="nc bnc" id="L533" title="All 4 branches missed.">        if (childAt &gt; 0 &amp;&amp; childWidth &lt;= parentWidth)    {</span>
<span class="nc" id="L534">            return -childAt + parentWidth - childWidth;</span>
        }

        //   +-----+             +-----+
        //   |  --------  -&gt;     |--------
        //   +-----+             +-----+
<span class="nc bnc" id="L540" title="All 4 branches missed.">        if (childAt &gt;= 0 &amp;&amp; childWidth &gt;= parentWidth)   {</span>
<span class="nc" id="L541">            return -childAt;</span>
        }

        //   +-----+          +-----+
        // ----    |     -&gt;   |---- |
        //   +-----+          +-----+
<span class="nc bnc" id="L547" title="All 4 branches missed.">        if (childAt &lt;= 0 &amp;&amp; childWidth &lt;= parentWidth)   {</span>
<span class="nc" id="L548">            return -childAt;</span>
        }

        //   +-----+             +-----+
        //-------- |      -&gt;   --------|
        //   +-----+             +-----+
<span class="nc bnc" id="L554" title="All 4 branches missed.">        if (childAt &lt; 0 &amp;&amp; childWidth &gt;= parentWidth)    {</span>
<span class="nc" id="L555">            return -childAt + parentWidth - childWidth;</span>
        }

<span class="nc" id="L558">        return 0;</span>
    }


    /**
     * The viewport &quot;scrolls&quot; its child (called the &quot;view&quot;) by the
     * normal parent/child clipping (typically the view is moved in
     * the opposite direction of the scroll).  A non-&lt;code&gt;null&lt;/code&gt; border,
     * or non-zero insets, isn't supported, to prevent the geometry
     * of this component from becoming complex enough to inhibit
     * subclassing.  To create a &lt;code&gt;JViewport&lt;/code&gt; with a border,
     * add it to a &lt;code&gt;JPanel&lt;/code&gt; that has a border.
     * &lt;p&gt;Note:  If &lt;code&gt;border&lt;/code&gt; is non-&lt;code&gt;null&lt;/code&gt;, this
     * method will throw an exception as borders are not supported on
     * a &lt;code&gt;JViewPort&lt;/code&gt;.
     *
     * @param border the &lt;code&gt;Border&lt;/code&gt; to set
     * @exception IllegalArgumentException this method is not implemented
     */
    public final void setBorder(Border border) {
<span class="nc bnc" id="L578" title="All 2 branches missed.">        if (border != null) {</span>
<span class="nc" id="L579">            throw new IllegalArgumentException(&quot;JViewport.setBorder() not supported&quot;);</span>
        }
<span class="nc" id="L581">    }</span>


    /**
     * Returns the insets (border) dimensions as (0,0,0,0), since borders
     * are not supported on a &lt;code&gt;JViewport&lt;/code&gt;.
     *
     * @return a &lt;code&gt;Rectangle&lt;/code&gt; of zero dimension and zero origin
     * @see #setBorder
     */
    public final Insets getInsets() {
<span class="nc" id="L592">        return new Insets(0, 0, 0, 0);</span>
    }

    /**
     * Returns an &lt;code&gt;Insets&lt;/code&gt; object containing this
     * &lt;code&gt;JViewport&lt;/code&gt;s inset values.  The passed-in
     * &lt;code&gt;Insets&lt;/code&gt; object will be reinitialized, and
     * all existing values within this object are overwritten.
     *
     * @param insets the &lt;code&gt;Insets&lt;/code&gt; object which can be reused
     * @return this viewports inset values
     * @see #getInsets
     * @beaninfo
     *   expert: true
     */
    public final Insets getInsets(Insets insets) {
<span class="nc" id="L608">        insets.left = insets.top = insets.right = insets.bottom = 0;</span>
<span class="nc" id="L609">        return insets;</span>
    }


    private Graphics getBackingStoreGraphics(Graphics g) {
<span class="nc" id="L614">        Graphics bsg = backingStoreImage.getGraphics();</span>
<span class="nc" id="L615">        bsg.setColor(g.getColor());</span>
<span class="nc" id="L616">        bsg.setFont(g.getFont());</span>
<span class="nc" id="L617">        bsg.setClip(g.getClipBounds());</span>
<span class="nc" id="L618">        return bsg;</span>
    }


    private void paintViaBackingStore(Graphics g) {
<span class="nc" id="L623">        Graphics bsg = getBackingStoreGraphics(g);</span>
        try {
<span class="nc" id="L625">            super.paint(bsg);</span>
<span class="nc" id="L626">            g.drawImage(backingStoreImage, 0, 0, this);</span>
        } finally {
<span class="nc" id="L628">            bsg.dispose();</span>
<span class="nc" id="L629">        }</span>
<span class="nc" id="L630">    }</span>

    private void paintViaBackingStore(Graphics g, Rectangle oClip) {
<span class="nc" id="L633">        Graphics bsg = getBackingStoreGraphics(g);</span>
        try {
<span class="nc" id="L635">            super.paint(bsg);</span>
<span class="nc" id="L636">            g.setClip(oClip);</span>
<span class="nc" id="L637">            g.drawImage(backingStoreImage, 0, 0, this);</span>
        } finally {
<span class="nc" id="L639">            bsg.dispose();</span>
<span class="nc" id="L640">        }</span>
<span class="nc" id="L641">    }</span>

    /**
     * The &lt;code&gt;JViewport&lt;/code&gt; overrides the default implementation of
     * this method (in &lt;code&gt;JComponent&lt;/code&gt;) to return false.
     * This ensures
     * that the drawing machinery will call the &lt;code&gt;Viewport&lt;/code&gt;'s
     * &lt;code&gt;paint&lt;/code&gt;
     * implementation rather than messaging the &lt;code&gt;JViewport&lt;/code&gt;'s
     * children directly.
     *
     * @return false
     */
    public boolean isOptimizedDrawingEnabled() {
<span class="nc" id="L655">        return false;</span>
    }

    /**
     * Returns true if scroll mode is a {@code BACKINGSTORE_SCROLL_MODE} to cause
     * painting to originate from {@code JViewport}, or one of its
     * ancestors. Otherwise returns {@code false}.
     *
     * @return true if if scroll mode is a {@code BACKINGSTORE_SCROLL_MODE}.
     * @see JComponent#isPaintingOrigin()
     */
    protected boolean isPaintingOrigin() {
<span class="nc bnc" id="L667" title="All 2 branches missed.">        return scrollMode == BACKINGSTORE_SCROLL_MODE;</span>
    }


    /**
     * Only used by the paint method below.
     */
    private Point getViewLocation() {
<span class="nc" id="L675">        Component view = getView();</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">        if (view != null) {</span>
<span class="nc" id="L677">            return view.getLocation();</span>
        }
        else {
<span class="nc" id="L680">            return new Point(0,0);</span>
        }
    }

    /**
     * Depending on whether the &lt;code&gt;backingStore&lt;/code&gt; is enabled,
     * either paint the image through the backing store or paint
     * just the recently exposed part, using the backing store
     * to &quot;blit&quot; the remainder.
     * &lt;blockquote&gt;
     * The term &quot;blit&quot; is the pronounced version of the PDP-10
     * BLT (BLock Transfer) instruction, which copied a block of
     * bits. (In case you were curious.)
     * &lt;/blockquote&gt;
     *
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context within which to paint
     */
    public void paint(Graphics g)
    {
<span class="nc" id="L699">        int width = getWidth();</span>
<span class="nc" id="L700">        int height = getHeight();</span>

<span class="nc bnc" id="L702" title="All 4 branches missed.">        if ((width &lt;= 0) || (height &lt;= 0)) {</span>
<span class="nc" id="L703">            return;</span>
        }

<span class="nc bnc" id="L706" title="All 2 branches missed.">        if (inBlitPaint) {</span>
            // We invoked paint as part of copyArea cleanup, let it through.
<span class="nc" id="L708">            super.paint(g);</span>
<span class="nc" id="L709">            return;</span>
        }

<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (repaintAll) {</span>
<span class="nc" id="L713">            repaintAll = false;</span>
<span class="nc" id="L714">            Rectangle clipB = g.getClipBounds();</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">            if (clipB.width &lt; getWidth() ||</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">                clipB.height &lt; getHeight()) {</span>
<span class="nc" id="L717">                waitingForRepaint = true;</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">                if (repaintTimer == null) {</span>
<span class="nc" id="L719">                    repaintTimer = createRepaintTimer();</span>
                }
<span class="nc" id="L721">                repaintTimer.stop();</span>
<span class="nc" id="L722">                repaintTimer.start();</span>
                // We really don't need to paint, a future repaint will
                // take care of it, but if we don't we get an ugly flicker.
            }
            else {
<span class="nc bnc" id="L727" title="All 2 branches missed.">                if (repaintTimer != null) {</span>
<span class="nc" id="L728">                    repaintTimer.stop();</span>
                }
<span class="nc" id="L730">                waitingForRepaint = false;</span>
            }
<span class="nc" id="L732">        }</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">        else if (waitingForRepaint) {</span>
            // Need a complete repaint before resetting waitingForRepaint
<span class="nc" id="L735">            Rectangle clipB = g.getClipBounds();</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if (clipB.width &gt;= getWidth() &amp;&amp;</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">                clipB.height &gt;= getHeight()) {</span>
<span class="nc" id="L738">                waitingForRepaint = false;</span>
<span class="nc" id="L739">                repaintTimer.stop();</span>
            }
        }

<span class="nc bnc" id="L743" title="All 6 branches missed.">        if (!backingStore || isBlitting() || getView() == null) {</span>
<span class="nc" id="L744">            super.paint(g);</span>
<span class="nc" id="L745">            lastPaintPosition = getViewLocation();</span>
<span class="nc" id="L746">            return;</span>
        }

        // If the view is smaller than the viewport and we are not opaque
        // (that is, we won't paint our background), we should set the
        // clip. Otherwise, as the bounds of the view vary, we will
        // blit garbage into the exposed areas.
<span class="nc" id="L753">        Rectangle viewBounds = getView().getBounds();</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">        if (!isOpaque()) {</span>
<span class="nc" id="L755">            g.clipRect(0, 0, viewBounds.width, viewBounds.height);</span>
        }

<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (backingStoreImage == null) {</span>
            // Backing store is enabled but this is the first call to paint.
            // Create the backing store, paint it and then copy to g.
            // The backing store image will be created with the size of
            // the viewport. We must make sure the clip region is the
            // same size, otherwise when scrolling the backing image
            // the region outside of the clipped region will not be painted,
            // and result in empty areas.
<span class="nc" id="L766">            backingStoreImage = createImage(width, height);</span>
<span class="nc" id="L767">            Rectangle clip = g.getClipBounds();</span>
<span class="nc bnc" id="L768" title="All 4 branches missed.">            if (clip.width != width || clip.height != height) {</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">                if (!isOpaque()) {</span>
<span class="nc" id="L770">                    g.setClip(0, 0, Math.min(viewBounds.width, width),</span>
<span class="nc" id="L771">                              Math.min(viewBounds.height, height));</span>
                }
                else {
<span class="nc" id="L774">                    g.setClip(0, 0, width, height);</span>
                }
<span class="nc" id="L776">                paintViaBackingStore(g, clip);</span>
            }
            else {
<span class="nc" id="L779">                paintViaBackingStore(g);</span>
            }
<span class="nc" id="L781">        }</span>
        else {
<span class="nc bnc" id="L783" title="All 4 branches missed.">            if (!scrollUnderway || lastPaintPosition.equals(getViewLocation())) {</span>
                // No scrolling happened: repaint required area via backing store.
<span class="nc" id="L785">                paintViaBackingStore(g);</span>
            } else {
                // The image was scrolled. Manipulate the backing store and flush it to g.
<span class="nc" id="L788">                Point blitFrom = new Point();</span>
<span class="nc" id="L789">                Point blitTo = new Point();</span>
<span class="nc" id="L790">                Dimension blitSize = new Dimension();</span>
<span class="nc" id="L791">                Rectangle blitPaint = new Rectangle();</span>

<span class="nc" id="L793">                Point newLocation = getViewLocation();</span>
<span class="nc" id="L794">                int dx = newLocation.x - lastPaintPosition.x;</span>
<span class="nc" id="L795">                int dy = newLocation.y - lastPaintPosition.y;</span>
<span class="nc" id="L796">                boolean canBlit = computeBlit(dx, dy, blitFrom, blitTo, blitSize, blitPaint);</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">                if (!canBlit) {</span>
                    // The image was either moved diagonally or
                    // moved by more than the image size: paint normally.
<span class="nc" id="L800">                    paintViaBackingStore(g);</span>
                } else {
<span class="nc" id="L802">                    int bdx = blitTo.x - blitFrom.x;</span>
<span class="nc" id="L803">                    int bdy = blitTo.y - blitFrom.y;</span>

                    // Move the relevant part of the backing store.
<span class="nc" id="L806">                    Rectangle clip = g.getClipBounds();</span>
                    // We don't want to inherit the clip region when copying
                    // bits, if it is inherited it will result in not moving
                    // all of the image resulting in garbage appearing on
                    // the screen.
<span class="nc" id="L811">                    g.setClip(0, 0, width, height);</span>
<span class="nc" id="L812">                    Graphics bsg = getBackingStoreGraphics(g);</span>
                    try {
<span class="nc" id="L814">                        bsg.copyArea(blitFrom.x, blitFrom.y, blitSize.width, blitSize.height, bdx, bdy);</span>

<span class="nc" id="L816">                        g.setClip(clip.x, clip.y, clip.width, clip.height);</span>
                        // Paint the rest of the view; the part that has just been exposed.
<span class="nc" id="L818">                        Rectangle r = viewBounds.intersection(blitPaint);</span>
<span class="nc" id="L819">                        bsg.setClip(r);</span>
<span class="nc" id="L820">                        super.paint(bsg);</span>

                        // Copy whole of the backing store to g.
<span class="nc" id="L823">                        g.drawImage(backingStoreImage, 0, 0, this);</span>
                    } finally {
<span class="nc" id="L825">                        bsg.dispose();</span>
<span class="nc" id="L826">                    }</span>
                }
            }
        }
<span class="nc" id="L830">        lastPaintPosition = getViewLocation();</span>
<span class="nc" id="L831">        scrollUnderway = false;</span>
<span class="nc" id="L832">    }</span>


    /**
     * Sets the bounds of this viewport.  If the viewport's width
     * or height has changed, fire a &lt;code&gt;StateChanged&lt;/code&gt; event.
     *
     * @param x left edge of the origin
     * @param y top edge of the origin
     * @param w width in pixels
     * @param h height in pixels
     *
     * @see JComponent#reshape(int, int, int, int)
     */
    public void reshape(int x, int y, int w, int h) {
<span class="nc bnc" id="L847" title="All 4 branches missed.">        boolean sizeChanged = (getWidth() != w) || (getHeight() != h);</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">        if (sizeChanged) {</span>
<span class="nc" id="L849">            backingStoreImage = null;</span>
        }
<span class="nc" id="L851">        super.reshape(x, y, w, h);</span>
<span class="nc bnc" id="L852" title="All 4 branches missed.">        if (sizeChanged || viewChanged) {</span>
<span class="nc" id="L853">            viewChanged = false;</span>

<span class="nc" id="L855">            fireStateChanged();</span>
        }
<span class="nc" id="L857">    }</span>


    /**
      * Used to control the method of scrolling the viewport contents.
      * You may want to change this mode to get maximum performance for your
      * use case.
      *
      * @param mode one of the following values:
      * &lt;ul&gt;
      * &lt;li&gt; JViewport.BLIT_SCROLL_MODE
      * &lt;li&gt; JViewport.BACKINGSTORE_SCROLL_MODE
      * &lt;li&gt; JViewport.SIMPLE_SCROLL_MODE
      * &lt;/ul&gt;
      *
      * @see #BLIT_SCROLL_MODE
      * @see #BACKINGSTORE_SCROLL_MODE
      * @see #SIMPLE_SCROLL_MODE
      *
      * @beaninfo
      *        bound: false
      *  description: Method of moving contents for incremental scrolls.
      *         enum: BLIT_SCROLL_MODE JViewport.BLIT_SCROLL_MODE
      *               BACKINGSTORE_SCROLL_MODE JViewport.BACKINGSTORE_SCROLL_MODE
      *               SIMPLE_SCROLL_MODE JViewport.SIMPLE_SCROLL_MODE
      *
      * @since 1.3
      */
    public void setScrollMode(int mode) {
<span class="nc" id="L886">        scrollMode = mode;</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">        backingStore = mode == BACKINGSTORE_SCROLL_MODE;</span>
<span class="nc" id="L888">    }</span>

    /**
      * Returns the current scrolling mode.
      *
      * @return the &lt;code&gt;scrollMode&lt;/code&gt; property
      * @see #setScrollMode
      * @since 1.3
      */
    public int getScrollMode() {
<span class="nc" id="L898">        return scrollMode;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if this viewport is maintaining
     * an offscreen image of its contents.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;scrollMode&lt;/code&gt; is
     *    &lt;code&gt;BACKINGSTORE_SCROLL_MODE&lt;/code&gt;
     *
     * @deprecated As of Java 2 platform v1.3, replaced by
     *             &lt;code&gt;getScrollMode()&lt;/code&gt;.
     */
    @Deprecated
    public boolean isBackingStoreEnabled() {
<span class="nc bnc" id="L913" title="All 2 branches missed.">        return scrollMode == BACKINGSTORE_SCROLL_MODE;</span>
    }


    /**
     * If true if this viewport will maintain an offscreen
     * image of its contents.  The image is used to reduce the cost
     * of small one dimensional changes to the &lt;code&gt;viewPosition&lt;/code&gt;.
     * Rather than repainting the entire viewport we use
     * &lt;code&gt;Graphics.copyArea&lt;/code&gt; to effect some of the scroll.
     *
     * @param enabled if true, maintain an offscreen backing store
     *
     * @deprecated As of Java 2 platform v1.3, replaced by
     *             &lt;code&gt;setScrollMode()&lt;/code&gt;.
     */
    @Deprecated
    public void setBackingStoreEnabled(boolean enabled) {
<span class="nc bnc" id="L931" title="All 2 branches missed.">        if (enabled) {</span>
<span class="nc" id="L932">            setScrollMode(BACKINGSTORE_SCROLL_MODE);</span>
        } else {
<span class="nc" id="L934">            setScrollMode(BLIT_SCROLL_MODE);</span>
        }
<span class="nc" id="L936">    }</span>

    private boolean isBlitting() {
<span class="nc" id="L939">        Component view = getView();</span>
<span class="nc bnc" id="L940" title="All 4 branches missed.">        return (scrollMode == BLIT_SCROLL_MODE) &amp;&amp;</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">               (view instanceof JComponent) &amp;&amp; view.isOpaque();</span>
    }


    /**
     * Returns the &lt;code&gt;JViewport&lt;/code&gt;'s one child or &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the viewports child, or &lt;code&gt;null&lt;/code&gt; if none exists
     *
     * @see #setView
     */
    public Component getView() {
<span class="nc bnc" id="L953" title="All 2 branches missed.">        return (getComponentCount() &gt; 0) ? getComponent(0) : null;</span>
    }

    /**
     * Sets the &lt;code&gt;JViewport&lt;/code&gt;'s one lightweight child
     * (&lt;code&gt;view&lt;/code&gt;), which can be &lt;code&gt;null&lt;/code&gt;.
     *
     * @param view the viewport's new lightweight child
     *
     * @see #getView
     */
    public void setView(Component view) {

        /* Remove the viewport's existing children, if any.
         * Note that removeAll() isn't used here because it
         * doesn't call remove() (which JViewport overrides).
         */
<span class="nc" id="L970">        int n = getComponentCount();</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">        for(int i = n - 1; i &gt;= 0; i--) {</span>
<span class="nc" id="L972">            remove(getComponent(i));</span>
        }

<span class="nc" id="L975">        isViewSizeSet = false;</span>

<span class="nc bnc" id="L977" title="All 2 branches missed.">        if (view != null) {</span>
<span class="nc" id="L978">            super.addImpl(view, null, -1);</span>
<span class="nc" id="L979">            viewListener = createViewListener();</span>
<span class="nc" id="L980">            view.addComponentListener(viewListener);</span>
        }

<span class="nc bnc" id="L983" title="All 2 branches missed.">        if (hasHadValidView) {</span>
            // Only fire a change if a view has been installed.
<span class="nc" id="L985">            fireStateChanged();</span>
        }
<span class="nc bnc" id="L987" title="All 2 branches missed.">        else if (view != null) {</span>
<span class="nc" id="L988">            hasHadValidView = true;</span>
        }

<span class="nc" id="L991">        viewChanged = true;</span>

<span class="nc" id="L993">        revalidate();</span>
<span class="nc" id="L994">        repaint();</span>
<span class="nc" id="L995">    }</span>


    /**
     * If the view's size hasn't been explicitly set, return the
     * preferred size, otherwise return the view's current size.
     * If there is no view, return 0,0.
     *
     * @return a &lt;code&gt;Dimension&lt;/code&gt; object specifying the size of the view
     */
    public Dimension getViewSize() {
<span class="nc" id="L1006">        Component view = getView();</span>

<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (view == null) {</span>
<span class="nc" id="L1009">            return new Dimension(0,0);</span>
        }
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        else if (isViewSizeSet) {</span>
<span class="nc" id="L1012">            return view.getSize();</span>
        }
        else {
<span class="nc" id="L1015">            return view.getPreferredSize();</span>
        }
    }


    /**
     * Sets the size of the view.  A state changed event will be fired.
     *
     * @param newSize a &lt;code&gt;Dimension&lt;/code&gt; object specifying the new
     *          size of the view
     */
    public void setViewSize(Dimension newSize) {
<span class="nc" id="L1027">        Component view = getView();</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        if (view != null) {</span>
<span class="nc" id="L1029">            Dimension oldSize = view.getSize();</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">            if (!newSize.equals(oldSize)) {</span>
                // scrollUnderway will be true if this is invoked as the
                // result of a validate and setViewPosition was previously
                // invoked.
<span class="nc" id="L1034">                scrollUnderway = false;</span>
<span class="nc" id="L1035">                view.setSize(newSize);</span>
<span class="nc" id="L1036">                isViewSizeSet = true;</span>
<span class="nc" id="L1037">                fireStateChanged();</span>
            }
        }
<span class="nc" id="L1040">    }</span>

    /**
     * Returns the view coordinates that appear in the upper left
     * hand corner of the viewport, or 0,0 if there's no view.
     *
     * @return a &lt;code&gt;Point&lt;/code&gt; object giving the upper left coordinates
     */
    public Point getViewPosition() {
<span class="nc" id="L1049">        Component view = getView();</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">        if (view != null) {</span>
<span class="nc" id="L1051">            Point p = view.getLocation();</span>
<span class="nc" id="L1052">            p.x = -p.x;</span>
<span class="nc" id="L1053">            p.y = -p.y;</span>
<span class="nc" id="L1054">            return p;</span>
        }
        else {
<span class="nc" id="L1057">            return new Point(0,0);</span>
        }
    }


    /**
     * Sets the view coordinates that appear in the upper left
     * hand corner of the viewport, does nothing if there's no view.
     *
     * @param p  a &lt;code&gt;Point&lt;/code&gt; object giving the upper left coordinates
     */
    public void setViewPosition(Point p)
    {
<span class="nc" id="L1070">        Component view = getView();</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        if (view == null) {</span>
<span class="nc" id="L1072">            return;</span>
        }

<span class="nc" id="L1075">        int oldX, oldY, x = p.x, y = p.y;</span>

        /* Collect the old x,y values for the views location
         * and do the song and dance to avoid allocating
         * a Rectangle object if we don't have to.
         */
<span class="nc bnc" id="L1081" title="All 2 branches missed.">        if (view instanceof JComponent) {</span>
<span class="nc" id="L1082">            JComponent c = (JComponent)view;</span>
<span class="nc" id="L1083">            oldX = c.getX();</span>
<span class="nc" id="L1084">            oldY = c.getY();</span>
<span class="nc" id="L1085">        }</span>
        else {
<span class="nc" id="L1087">            Rectangle r = view.getBounds();</span>
<span class="nc" id="L1088">            oldX = r.x;</span>
<span class="nc" id="L1089">            oldY = r.y;</span>
        }

        /* The view scrolls in the opposite direction to mouse
         * movement.
         */
<span class="nc" id="L1095">        int newX = -x;</span>
<span class="nc" id="L1096">        int newY = -y;</span>

<span class="nc bnc" id="L1098" title="All 4 branches missed.">        if ((oldX != newX) || (oldY != newY)) {</span>
<span class="nc bnc" id="L1099" title="All 6 branches missed.">            if (!waitingForRepaint &amp;&amp; isBlitting() &amp;&amp; canUseWindowBlitter()) {</span>
<span class="nc" id="L1100">                RepaintManager rm = RepaintManager.currentManager(this);</span>
                // The cast to JComponent will work, if view is not
                // a JComponent, isBlitting will return false.
<span class="nc" id="L1103">                JComponent jview = (JComponent)view;</span>
<span class="nc" id="L1104">                Rectangle dirty = rm.getDirtyRegion(jview);</span>
<span class="nc bnc" id="L1105" title="All 4 branches missed.">                if (dirty == null || !dirty.contains(jview.getVisibleRect())) {</span>
<span class="nc" id="L1106">                    rm.beginPaint();</span>
                    try {
<span class="nc" id="L1108">                        Graphics g = JComponent.safelyGetGraphics(this);</span>
<span class="nc" id="L1109">                        flushViewDirtyRegion(g, dirty);</span>
<span class="nc" id="L1110">                        view.setLocation(newX, newY);</span>
<span class="nc" id="L1111">                        g.setClip(0,0,getWidth(), Math.min(getHeight(),</span>
<span class="nc" id="L1112">                                                           jview.getHeight()));</span>
                        // Repaint the complete component if the blit succeeded
                        // and needsRepaintAfterBlit returns true.
<span class="nc bnc" id="L1115" title="All 2 branches missed.">                        repaintAll = (windowBlitPaint(g) &amp;&amp;</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                                      needsRepaintAfterBlit());</span>
<span class="nc" id="L1117">                        g.dispose();</span>
<span class="nc" id="L1118">                        rm.markCompletelyClean((JComponent)getParent());</span>
<span class="nc" id="L1119">                        rm.markCompletelyClean(this);</span>
<span class="nc" id="L1120">                        rm.markCompletelyClean(jview);</span>
                    } finally {
<span class="nc" id="L1122">                        rm.endPaint();</span>
<span class="nc" id="L1123">                    }</span>
                }
                else {
                    // The visible region is dirty, no point in doing copyArea
<span class="nc" id="L1127">                    view.setLocation(newX, newY);</span>
<span class="nc" id="L1128">                    repaintAll = false;</span>
                }
<span class="nc" id="L1130">            }</span>
            else {
<span class="nc" id="L1132">                scrollUnderway = true;</span>
                // This calls setBounds(), and then repaint().
<span class="nc" id="L1134">                view.setLocation(newX, newY);</span>
<span class="nc" id="L1135">                repaintAll = false;</span>
            }
            // we must validate the hierarchy to not break the hw/lw mixing
<span class="nc" id="L1138">            revalidate();</span>
<span class="nc" id="L1139">            fireStateChanged();</span>
        }
<span class="nc" id="L1141">    }</span>


    /**
     * Returns a rectangle whose origin is &lt;code&gt;getViewPosition&lt;/code&gt;
     * and size is &lt;code&gt;getExtentSize&lt;/code&gt;.
     * This is the visible part of the view, in view coordinates.
     *
     * @return a &lt;code&gt;Rectangle&lt;/code&gt; giving the visible part of
     *          the view using view coordinates.
     */
    public Rectangle getViewRect() {
<span class="nc" id="L1153">        return new Rectangle(getViewPosition(), getExtentSize());</span>
    }


    /**
     * Computes the parameters for a blit where the backing store image
     * currently contains &lt;code&gt;oldLoc&lt;/code&gt; in the upper left hand corner
     * and we're scrolling to &lt;code&gt;newLoc&lt;/code&gt;.
     * The parameters are modified
     * to return the values required for the blit.
     *
     * @param dx  the horizontal delta
     * @param dy  the vertical delta
     * @param blitFrom the &lt;code&gt;Point&lt;/code&gt; we're blitting from
     * @param blitTo the &lt;code&gt;Point&lt;/code&gt; we're blitting to
     * @param blitSize the &lt;code&gt;Dimension&lt;/code&gt; of the area to blit
     * @param blitPaint the area to blit
     * @return  true if the parameters are modified and we're ready to blit;
     *          false otherwise
     */
    protected boolean computeBlit(
        int dx,
        int dy,
        Point blitFrom,
        Point blitTo,
        Dimension blitSize,
        Rectangle blitPaint)
    {
<span class="nc" id="L1181">        int dxAbs = Math.abs(dx);</span>
<span class="nc" id="L1182">        int dyAbs = Math.abs(dy);</span>
<span class="nc" id="L1183">        Dimension extentSize = getExtentSize();</span>

<span class="nc bnc" id="L1185" title="All 6 branches missed.">        if ((dx == 0) &amp;&amp; (dy != 0) &amp;&amp; (dyAbs &lt; extentSize.height)) {</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (dy &lt; 0) {</span>
<span class="nc" id="L1187">                blitFrom.y = -dy;</span>
<span class="nc" id="L1188">                blitTo.y = 0;</span>
<span class="nc" id="L1189">                blitPaint.y = extentSize.height + dy;</span>
            }
            else {
<span class="nc" id="L1192">                blitFrom.y = 0;</span>
<span class="nc" id="L1193">                blitTo.y = dy;</span>
<span class="nc" id="L1194">                blitPaint.y = 0;</span>
            }

<span class="nc" id="L1197">            blitPaint.x = blitFrom.x = blitTo.x = 0;</span>

<span class="nc" id="L1199">            blitSize.width = extentSize.width;</span>
<span class="nc" id="L1200">            blitSize.height = extentSize.height - dyAbs;</span>

<span class="nc" id="L1202">            blitPaint.width = extentSize.width;</span>
<span class="nc" id="L1203">            blitPaint.height = dyAbs;</span>

<span class="nc" id="L1205">            return true;</span>
        }

<span class="nc bnc" id="L1208" title="All 6 branches missed.">        else if ((dy == 0) &amp;&amp; (dx != 0) &amp;&amp; (dxAbs &lt; extentSize.width)) {</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">            if (dx &lt; 0) {</span>
<span class="nc" id="L1210">                blitFrom.x = -dx;</span>
<span class="nc" id="L1211">                blitTo.x = 0;</span>
<span class="nc" id="L1212">                blitPaint.x = extentSize.width + dx;</span>
            }
            else {
<span class="nc" id="L1215">                blitFrom.x = 0;</span>
<span class="nc" id="L1216">                blitTo.x = dx;</span>
<span class="nc" id="L1217">                blitPaint.x = 0;</span>
            }

<span class="nc" id="L1220">            blitPaint.y = blitFrom.y = blitTo.y = 0;</span>

<span class="nc" id="L1222">            blitSize.width = extentSize.width - dxAbs;</span>
<span class="nc" id="L1223">            blitSize.height = extentSize.height;</span>

<span class="nc" id="L1225">            blitPaint.width = dxAbs;</span>
<span class="nc" id="L1226">            blitPaint.height = extentSize.height;</span>

<span class="nc" id="L1228">            return true;</span>
        }

        else {
<span class="nc" id="L1232">            return false;</span>
        }
    }


    /**
     * Returns the size of the visible part of the view in view coordinates.
     *
     * @return a &lt;code&gt;Dimension&lt;/code&gt; object giving the size of the view
     */
    @Transient
    public Dimension getExtentSize() {
<span class="nc" id="L1244">        return getSize();</span>
    }


    /**
     * Converts a size in pixel coordinates to view coordinates.
     * Subclasses of viewport that support &quot;logical coordinates&quot;
     * will override this method.
     *
     * @param size  a &lt;code&gt;Dimension&lt;/code&gt; object using pixel coordinates
     * @return a &lt;code&gt;Dimension&lt;/code&gt; object converted to view coordinates
     */
    public Dimension toViewCoordinates(Dimension size) {
<span class="nc" id="L1257">        return new Dimension(size);</span>
    }

    /**
     * Converts a point in pixel coordinates to view coordinates.
     * Subclasses of viewport that support &quot;logical coordinates&quot;
     * will override this method.
     *
     * @param p  a &lt;code&gt;Point&lt;/code&gt; object using pixel coordinates
     * @return a &lt;code&gt;Point&lt;/code&gt; object converted to view coordinates
     */
    public Point toViewCoordinates(Point p) {
<span class="nc" id="L1269">        return new Point(p);</span>
    }


    /**
     * Sets the size of the visible part of the view using view coordinates.
     *
     * @param newExtent  a &lt;code&gt;Dimension&lt;/code&gt; object specifying
     *          the size of the view
     */
    public void setExtentSize(Dimension newExtent) {
<span class="nc" id="L1280">        Dimension oldExtent = getExtentSize();</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">        if (!newExtent.equals(oldExtent)) {</span>
<span class="nc" id="L1282">            setSize(newExtent);</span>
<span class="nc" id="L1283">            fireStateChanged();</span>
        }
<span class="nc" id="L1285">    }</span>

    /**
     * A listener for the view.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
<span class="nc" id="L1299">    protected class ViewListener extends ComponentAdapter implements Serializable</span>
    {
        public void componentResized(ComponentEvent e) {
<span class="nc" id="L1302">            fireStateChanged();</span>
<span class="nc" id="L1303">            revalidate();</span>
<span class="nc" id="L1304">        }</span>
    }

    /**
     * Creates a listener for the view.
     * @return a &lt;code&gt;ViewListener&lt;/code&gt;
     */
    protected ViewListener createViewListener() {
<span class="nc" id="L1312">        return new ViewListener();</span>
    }


    /**
     * Subclassers can override this to install a different
     * layout manager (or &lt;code&gt;null&lt;/code&gt;) in the constructor.  Returns
     * the &lt;code&gt;LayoutManager&lt;/code&gt; to install on the &lt;code&gt;JViewport&lt;/code&gt;.
     *
     * @return a &lt;code&gt;LayoutManager&lt;/code&gt;
     */
    protected LayoutManager createLayoutManager() {
<span class="nc" id="L1324">        return ViewportLayout.SHARED_INSTANCE;</span>
    }


    /**
     * Adds a &lt;code&gt;ChangeListener&lt;/code&gt; to the list that is
     * notified each time the view's
     * size, position, or the viewport's extent size has changed.
     *
     * @param l the &lt;code&gt;ChangeListener&lt;/code&gt; to add
     * @see #removeChangeListener
     * @see #setViewPosition
     * @see #setViewSize
     * @see #setExtentSize
     */
    public void addChangeListener(ChangeListener l) {
<span class="nc" id="L1340">        listenerList.add(ChangeListener.class, l);</span>
<span class="nc" id="L1341">    }</span>

    /**
     * Removes a &lt;code&gt;ChangeListener&lt;/code&gt; from the list that's notified each
     * time the views size, position, or the viewports extent size
     * has changed.
     *
     * @param l the &lt;code&gt;ChangeListener&lt;/code&gt; to remove
     * @see #addChangeListener
     */
    public void removeChangeListener(ChangeListener l) {
<span class="nc" id="L1352">        listenerList.remove(ChangeListener.class, l);</span>
<span class="nc" id="L1353">    }</span>

    /**
     * Returns an array of all the &lt;code&gt;ChangeListener&lt;/code&gt;s added
     * to this JViewport with addChangeListener().
     *
     * @return all of the &lt;code&gt;ChangeListener&lt;/code&gt;s added or an empty
     *         array if no listeners have been added
     * @since 1.4
     */
    public ChangeListener[] getChangeListeners() {
<span class="nc" id="L1364">        return listenerList.getListeners(ChangeListener.class);</span>
    }

    /**
     * Notifies all &lt;code&gt;ChangeListeners&lt;/code&gt; when the views
     * size, position, or the viewports extent size has changed.
     *
     * @see #addChangeListener
     * @see #removeChangeListener
     * @see EventListenerList
     */
    protected void fireStateChanged()
    {
<span class="nc" id="L1377">        Object[] listeners = listenerList.getListenerList();</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">        for (int i = listeners.length - 2; i &gt;= 0; i -= 2) {</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">            if (listeners[i] == ChangeListener.class) {</span>
<span class="nc bnc" id="L1380" title="All 2 branches missed.">                if (changeEvent == null) {</span>
<span class="nc" id="L1381">                    changeEvent = new ChangeEvent(this);</span>
                }
<span class="nc" id="L1383">                ((ChangeListener)listeners[i + 1]).stateChanged(changeEvent);</span>
            }
        }
<span class="nc" id="L1386">    }</span>

    /**
     * Always repaint in the parents coordinate system to make sure
     * only one paint is performed by the &lt;code&gt;RepaintManager&lt;/code&gt;.
     *
     * @param     tm   maximum time in milliseconds before update
     * @param     x    the &lt;code&gt;x&lt;/code&gt; coordinate (pixels over from left)
     * @param     y    the &lt;code&gt;y&lt;/code&gt; coordinate (pixels down from top)
     * @param     w    the width
     * @param     h   the height
     * @see       java.awt.Component#update(java.awt.Graphics)
     */
    public void repaint(long tm, int x, int y, int w, int h) {
<span class="nc" id="L1400">        Container parent = getParent();</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">        if(parent != null)</span>
<span class="nc" id="L1402">            parent.repaint(tm,x+getX(),y+getY(),w,h);</span>
        else
<span class="nc" id="L1404">            super.repaint(tm,x,y,w,h);</span>
<span class="nc" id="L1405">    }</span>


    /**
     * Returns a string representation of this &lt;code&gt;JViewport&lt;/code&gt;.
     * This method
     * is intended to be used only for debugging purposes, and the
     * content and format of the returned string may vary between
     * implementations. The returned string may be empty but may not
     * be &lt;code&gt;null&lt;/code&gt;.
     *
     * @return  a string representation of this &lt;code&gt;JViewport&lt;/code&gt;
     */
    protected String paramString() {
<span class="nc bnc" id="L1419" title="All 2 branches missed.">        String isViewSizeSetString = (isViewSizeSet ?</span>
                                      &quot;true&quot; : &quot;false&quot;);
<span class="nc bnc" id="L1421" title="All 2 branches missed.">        String lastPaintPositionString = (lastPaintPosition != null ?</span>
<span class="nc" id="L1422">                                          lastPaintPosition.toString() : &quot;&quot;);</span>
<span class="nc bnc" id="L1423" title="All 2 branches missed.">        String scrollUnderwayString = (scrollUnderway ?</span>
                                       &quot;true&quot; : &quot;false&quot;);

<span class="nc" id="L1426">        return super.paramString() +</span>
        &quot;,isViewSizeSet=&quot; + isViewSizeSetString +
        &quot;,lastPaintPosition=&quot; + lastPaintPositionString +
        &quot;,scrollUnderway=&quot; + scrollUnderwayString;
    }

    //
    // Following is used when doBlit is true.
    //

    /**
     * Notifies listeners of a property change. This is subclassed to update
     * the &lt;code&gt;windowBlit&lt;/code&gt; property.
     * (The &lt;code&gt;putClientProperty&lt;/code&gt; property is final).
     *
     * @param propertyName a string containing the property name
     * @param oldValue the old value of the property
     * @param newValue  the new value of the property
     */
    protected void firePropertyChange(String propertyName, Object oldValue,
                                      Object newValue) {
<span class="nc" id="L1447">        super.firePropertyChange(propertyName, oldValue, newValue);</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">        if (propertyName.equals(EnableWindowBlit)) {</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">            if (newValue != null) {</span>
<span class="nc" id="L1450">                setScrollMode(BLIT_SCROLL_MODE);</span>
            } else {
<span class="nc" id="L1452">                setScrollMode(SIMPLE_SCROLL_MODE);</span>
            }
        }
<span class="nc" id="L1455">    }</span>

    /**
     * Returns true if the component needs to be completely repainted after
     * a blit and a paint is received.
     */
    private boolean needsRepaintAfterBlit() {
        // Find the first heavy weight ancestor. isObscured and
        // canDetermineObscurity are only appropriate for heavy weights.
<span class="nc" id="L1464">        Component heavyParent = getParent();</span>

<span class="nc bnc" id="L1466" title="All 4 branches missed.">        while (heavyParent != null &amp;&amp; heavyParent.isLightweight()) {</span>
<span class="nc" id="L1467">            heavyParent = heavyParent.getParent();</span>
        }

<span class="nc bnc" id="L1470" title="All 2 branches missed.">        if (heavyParent != null) {</span>
<span class="nc" id="L1471">            ComponentPeer peer = heavyParent.getPeer();</span>

<span class="nc bnc" id="L1473" title="All 4 branches missed.">            if (peer != null &amp;&amp; peer.canDetermineObscurity() &amp;&amp;</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">                                !peer.isObscured()) {</span>
                // The peer says we aren't obscured, therefore we can assume
                // that we won't later be messaged to paint a portion that
                // we tried to blit that wasn't valid.
                // It is certainly possible that when we blited we were
                // obscured, and by the time this is invoked we aren't, but the
                // chances of that happening are pretty slim.
<span class="nc" id="L1481">                return false;</span>
            }
        }
<span class="nc" id="L1484">        return true;</span>
    }

    private Timer createRepaintTimer() {
<span class="nc" id="L1488">        Timer timer = new Timer(300, new ActionListener() {</span>
            public void actionPerformed(ActionEvent ae) {
                // waitingForRepaint will be false if a paint came down
                // with the complete clip rect, in which case we don't
                // have to cause a repaint.
<span class="nc bnc" id="L1493" title="All 2 branches missed.">                if (waitingForRepaint) {</span>
<span class="nc" id="L1494">                    repaint();</span>
                }
<span class="nc" id="L1496">            }</span>
        });
<span class="nc" id="L1498">        timer.setRepeats(false);</span>
<span class="nc" id="L1499">        return timer;</span>
    }

    /**
     * If the repaint manager has a dirty region for the view, the view is
     * asked to paint.
     *
     * @param g  the &lt;code&gt;Graphics&lt;/code&gt; context within which to paint
     */
    private void flushViewDirtyRegion(Graphics g, Rectangle dirty) {
<span class="nc" id="L1509">        JComponent view = (JComponent) getView();</span>
<span class="nc bnc" id="L1510" title="All 6 branches missed.">        if(dirty != null &amp;&amp; dirty.width &gt; 0 &amp;&amp; dirty.height &gt; 0) {</span>
<span class="nc" id="L1511">            dirty.x += view.getX();</span>
<span class="nc" id="L1512">            dirty.y += view.getY();</span>
<span class="nc" id="L1513">            Rectangle clip = g.getClipBounds();</span>
<span class="nc bnc" id="L1514" title="All 2 branches missed.">            if (clip == null) {</span>
                // Only happens in 1.2
<span class="nc" id="L1516">                g.setClip(0, 0, getWidth(), getHeight());</span>
            }
<span class="nc" id="L1518">            g.clipRect(dirty.x, dirty.y, dirty.width, dirty.height);</span>
<span class="nc" id="L1519">            clip = g.getClipBounds();</span>
            // Only paint the dirty region if it is visible.
<span class="nc bnc" id="L1521" title="All 4 branches missed.">            if (clip.width &gt; 0 &amp;&amp; clip.height &gt; 0) {</span>
<span class="nc" id="L1522">                paintView(g);</span>
            }
        }
<span class="nc" id="L1525">    }</span>

    /**
     * Used when blitting.
     *
     * @param g  the &lt;code&gt;Graphics&lt;/code&gt; context within which to paint
     * @return true if blitting succeeded; otherwise false
     */
    private boolean windowBlitPaint(Graphics g) {
<span class="nc" id="L1534">        int width = getWidth();</span>
<span class="nc" id="L1535">        int height = getHeight();</span>

<span class="nc bnc" id="L1537" title="All 4 branches missed.">        if ((width == 0) || (height == 0)) {</span>
<span class="nc" id="L1538">            return false;</span>
        }

        boolean retValue;
<span class="nc" id="L1542">        RepaintManager rm = RepaintManager.currentManager(this);</span>
<span class="nc" id="L1543">        JComponent view = (JComponent) getView();</span>

<span class="nc bnc" id="L1545" title="All 2 branches missed.">        if (lastPaintPosition == null ||</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">            lastPaintPosition.equals(getViewLocation())) {</span>
<span class="nc" id="L1547">            paintView(g);</span>
<span class="nc" id="L1548">            retValue = false;</span>
        } else {
            // The image was scrolled. Manipulate the backing store and flush
            // it to g.
<span class="nc" id="L1552">            Point blitFrom = new Point();</span>
<span class="nc" id="L1553">            Point blitTo = new Point();</span>
<span class="nc" id="L1554">            Dimension blitSize = new Dimension();</span>
<span class="nc" id="L1555">            Rectangle blitPaint = new Rectangle();</span>

<span class="nc" id="L1557">            Point newLocation = getViewLocation();</span>
<span class="nc" id="L1558">            int dx = newLocation.x - lastPaintPosition.x;</span>
<span class="nc" id="L1559">            int dy = newLocation.y - lastPaintPosition.y;</span>
<span class="nc" id="L1560">            boolean canBlit = computeBlit(dx, dy, blitFrom, blitTo, blitSize,</span>
                                          blitPaint);
<span class="nc bnc" id="L1562" title="All 2 branches missed.">            if (!canBlit) {</span>
<span class="nc" id="L1563">                paintView(g);</span>
<span class="nc" id="L1564">                retValue = false;</span>
            } else {
                // Prepare the rest of the view; the part that has just been
                // exposed.
<span class="nc" id="L1568">                Rectangle r = view.getBounds().intersection(blitPaint);</span>
<span class="nc" id="L1569">                r.x -= view.getX();</span>
<span class="nc" id="L1570">                r.y -= view.getY();</span>

<span class="nc" id="L1572">                blitDoubleBuffered(view, g, r.x, r.y, r.width, r.height,</span>
                                   blitFrom.x, blitFrom.y, blitTo.x, blitTo.y,
                                   blitSize.width, blitSize.height);
<span class="nc" id="L1575">                retValue = true;</span>
            }
        }
<span class="nc" id="L1578">        lastPaintPosition = getViewLocation();</span>
<span class="nc" id="L1579">        return retValue;</span>
    }

    //
    // NOTE: the code below uses paintForceDoubleBuffered for historical
    // reasons.  If we're going to allow a blit we've already accounted for
    // everything that paintImmediately and _paintImmediately does, for that
    // reason we call into paintForceDoubleBuffered to diregard whether or
    // not setDoubleBuffered(true) was invoked on the view.
    //

    private void blitDoubleBuffered(JComponent view, Graphics g,
                                    int clipX, int clipY, int clipW, int clipH,
                                    int blitFromX, int blitFromY, int blitToX, int blitToY,
                                    int blitW, int blitH) {
        // NOTE:
        //   blitFrom/blitTo are in JViewport coordinates system
        //     not the views coordinate space.
        //   clip* are in the views coordinate space.
<span class="nc" id="L1598">        RepaintManager rm = RepaintManager.currentManager(this);</span>
<span class="nc" id="L1599">        int bdx = blitToX - blitFromX;</span>
<span class="nc" id="L1600">        int bdy = blitToY - blitFromY;</span>

<span class="nc" id="L1602">        Composite oldComposite = null;</span>
        // Shift the scrolled region
<span class="nc bnc" id="L1604" title="All 2 branches missed.">        if (g instanceof Graphics2D) {</span>
<span class="nc" id="L1605">            Graphics2D g2d = (Graphics2D) g;</span>
<span class="nc" id="L1606">            oldComposite = g2d.getComposite();</span>
<span class="nc" id="L1607">            g2d.setComposite(AlphaComposite.Src);</span>
        }
<span class="nc" id="L1609">        rm.copyArea(this, g, blitFromX, blitFromY, blitW, blitH, bdx, bdy,</span>
                    false);
<span class="nc bnc" id="L1611" title="All 2 branches missed.">        if (oldComposite != null) {</span>
<span class="nc" id="L1612">            ((Graphics2D) g).setComposite(oldComposite);</span>
        }
        // Paint the newly exposed region.
<span class="nc" id="L1615">        int x = view.getX();</span>
<span class="nc" id="L1616">        int y = view.getY();</span>
<span class="nc" id="L1617">        g.translate(x, y);</span>
<span class="nc" id="L1618">        g.setClip(clipX, clipY, clipW, clipH);</span>
<span class="nc" id="L1619">        view.paintForceDoubleBuffered(g);</span>
<span class="nc" id="L1620">        g.translate(-x, -y);</span>
<span class="nc" id="L1621">    }</span>

    /**
     * Called to paint the view, usually when &lt;code&gt;blitPaint&lt;/code&gt;
     * can not blit.
     *
     * @param g the &lt;code&gt;Graphics&lt;/code&gt; context within which to paint
     */
    private void paintView(Graphics g) {
<span class="nc" id="L1630">        Rectangle clip = g.getClipBounds();</span>
<span class="nc" id="L1631">        JComponent view = (JComponent)getView();</span>

<span class="nc bnc" id="L1633" title="All 2 branches missed.">        if (view.getWidth() &gt;= getWidth()) {</span>
            // Graphics is relative to JViewport, need to map to view's
            // coordinates space.
<span class="nc" id="L1636">            int x = view.getX();</span>
<span class="nc" id="L1637">            int y = view.getY();</span>
<span class="nc" id="L1638">            g.translate(x, y);</span>
<span class="nc" id="L1639">            g.setClip(clip.x - x, clip.y - y, clip.width, clip.height);</span>
<span class="nc" id="L1640">            view.paintForceDoubleBuffered(g);</span>
<span class="nc" id="L1641">            g.translate(-x, -y);</span>
<span class="nc" id="L1642">            g.setClip(clip.x, clip.y, clip.width, clip.height);</span>
<span class="nc" id="L1643">        }</span>
        else {
            // To avoid any problems that may result from the viewport being
            // bigger than the view we start painting from the viewport.
            try {
<span class="nc" id="L1648">                inBlitPaint = true;</span>
<span class="nc" id="L1649">                paintForceDoubleBuffered(g);</span>
            } finally {
<span class="nc" id="L1651">                inBlitPaint = false;</span>
<span class="nc" id="L1652">            }</span>
        }
<span class="nc" id="L1654">    }</span>

    /**
     * Returns true if the viewport is not obscured by one of its ancestors,
     * or its ancestors children and if the viewport is showing. Blitting
     * when the view isn't showing will work,
     * or rather &lt;code&gt;copyArea&lt;/code&gt; will work,
     * but will not produce the expected behavior.
     */
    private boolean canUseWindowBlitter() {
<span class="nc bnc" id="L1664" title="All 4 branches missed.">        if (!isShowing() || (!(getParent() instanceof JComponent) &amp;&amp;</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">                             !(getView() instanceof JComponent))) {</span>
<span class="nc" id="L1666">            return false;</span>
        }
<span class="nc bnc" id="L1668" title="All 2 branches missed.">        if (isPainting()) {</span>
            // We're in the process of painting, don't blit. If we were
            // to blit we would draw on top of what we're already drawing,
            // so bail.
<span class="nc" id="L1672">            return false;</span>
        }

<span class="nc" id="L1675">        Rectangle dirtyRegion = RepaintManager.currentManager(this).</span>
<span class="nc" id="L1676">                                getDirtyRegion((JComponent)getParent());</span>

<span class="nc bnc" id="L1678" title="All 6 branches missed.">        if (dirtyRegion != null &amp;&amp; dirtyRegion.width &gt; 0 &amp;&amp;</span>
            dirtyRegion.height &gt; 0) {
            // Part of the scrollpane needs to be repainted too, don't blit.
<span class="nc" id="L1681">            return false;</span>
        }

<span class="nc" id="L1684">        Rectangle clip = new Rectangle(0,0,getWidth(),getHeight());</span>
<span class="nc" id="L1685">        Rectangle oldClip = new Rectangle();</span>
<span class="nc" id="L1686">        Rectangle tmp2 = null;</span>
        Container parent;
<span class="nc" id="L1688">        Component lastParent = null;</span>
        int x, y, w, h;

<span class="nc bnc" id="L1691" title="All 4 branches missed.">        for(parent = this; parent != null &amp;&amp; isLightweightComponent(parent); parent = parent.getParent()) {</span>
<span class="nc" id="L1692">            x = parent.getX();</span>
<span class="nc" id="L1693">            y = parent.getY();</span>
<span class="nc" id="L1694">            w = parent.getWidth();</span>
<span class="nc" id="L1695">            h = parent.getHeight();</span>

<span class="nc" id="L1697">            oldClip.setBounds(clip);</span>
<span class="nc" id="L1698">            SwingUtilities.computeIntersection(0, 0, w, h, clip);</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">            if(!clip.equals(oldClip))</span>
<span class="nc" id="L1700">                return false;</span>

<span class="nc bnc" id="L1702" title="All 4 branches missed.">            if(lastParent != null &amp;&amp; parent instanceof JComponent &amp;&amp;</span>
<span class="nc bnc" id="L1703" title="All 2 branches missed.">               !((JComponent)parent).isOptimizedDrawingEnabled()) {</span>
<span class="nc" id="L1704">                Component comps[] = parent.getComponents();</span>
<span class="nc" id="L1705">                int index = 0;</span>

<span class="nc bnc" id="L1707" title="All 2 branches missed.">                for(int i = comps.length - 1 ;i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L1708" title="All 2 branches missed.">                    if(comps[i] == lastParent) {</span>
<span class="nc" id="L1709">                        index = i - 1;</span>
<span class="nc" id="L1710">                        break;</span>
                    }
                }

<span class="nc bnc" id="L1714" title="All 2 branches missed.">                while(index &gt;= 0) {</span>
<span class="nc" id="L1715">                    tmp2 = comps[index].getBounds(tmp2);</span>

<span class="nc bnc" id="L1717" title="All 2 branches missed.">                    if(tmp2.intersects(clip))</span>
<span class="nc" id="L1718">                        return false;</span>
<span class="nc" id="L1719">                    index--;</span>
                }
            }
<span class="nc" id="L1722">            clip.x += x;</span>
<span class="nc" id="L1723">            clip.y += y;</span>
<span class="nc" id="L1724">            lastParent = parent;</span>
        }
<span class="nc bnc" id="L1726" title="All 2 branches missed.">        if (parent == null) {</span>
            // No Window parent.
<span class="nc" id="L1728">            return false;</span>
        }
<span class="nc" id="L1730">        return true;</span>
    }


/////////////////
// Accessibility support
////////////////

    /**
     * Gets the AccessibleContext associated with this JViewport.
     * For viewports, the AccessibleContext takes the form of an
     * AccessibleJViewport.
     * A new AccessibleJViewport instance is created if necessary.
     *
     * @return an AccessibleJViewport that serves as the
     *         AccessibleContext of this JViewport
     */
    public AccessibleContext getAccessibleContext() {
<span class="nc bnc" id="L1748" title="All 2 branches missed.">        if (accessibleContext == null) {</span>
<span class="nc" id="L1749">            accessibleContext = new AccessibleJViewport();</span>
        }
<span class="nc" id="L1751">        return accessibleContext;</span>
    }

    /**
     * This class implements accessibility support for the
     * &lt;code&gt;JViewport&lt;/code&gt; class.  It provides an implementation of the
     * Java Accessibility API appropriate to viewport user-interface elements.
     * &lt;p&gt;
     * &lt;strong&gt;Warning:&lt;/strong&gt;
     * Serialized objects of this class will not be compatible with
     * future Swing releases. The current serialization support is
     * appropriate for short term storage or RMI between applications running
     * the same version of Swing.  As of 1.4, support for long term storage
     * of all JavaBeans&amp;trade;
     * has been added to the &lt;code&gt;java.beans&lt;/code&gt; package.
     * Please see {@link java.beans.XMLEncoder}.
     */
<span class="nc" id="L1768">    protected class AccessibleJViewport extends AccessibleJComponent {</span>
        /**
         * Get the role of this object.
         *
         * @return an instance of AccessibleRole describing the role of
         * the object
         */
        public AccessibleRole getAccessibleRole() {
<span class="nc" id="L1776">            return AccessibleRole.VIEWPORT;</span>
        }
    } // inner class AccessibleJViewport
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.4.201312031056</span></div></body></html>